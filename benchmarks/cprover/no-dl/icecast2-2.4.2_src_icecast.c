// #anon_enum_AUTH_UNDEFINED=0_AUTH_OK=1_AUTH_FAILED=2_AUTH_FORBIDDEN=3_AUTH_USERADDED=4_AUTH_USEREXISTS=5_AUTH_USERDELETED=6
// file auth.h line 30
enum anonymous_19 { AUTH_UNDEFINED=0, AUTH_OK=1, AUTH_FAILED=2, AUTH_FORBIDDEN=3, AUTH_USERADDED=4, AUTH_USEREXISTS=5, AUTH_USERDELETED=6 };

// #anon_enum_CURLE_OK=0_CURLE_UNSUPPORTED_PROTOCOL=1_CURLE_FAILED_INIT=2_CURLE_URL_MALFORMAT=3_CURLE_NOT_BUILT_IN=4_CURLE_COULDNT_RESOLVE_PROXY=5_CURLE_COULDNT_RESOLVE_HOST=6_CURLE_COULDNT_CONNECT=7_CURLE_FTP_WEIRD_SERVER_REPLY=8_CURLE_REMOTE_ACCESS_DENIED=9_CURLE_FTP_ACCEPT_FAILED=10_CURLE_FTP_WEIRD_PASS_REPLY=11_CURLE_FTP_ACCEPT_TIMEOUT=12_CURLE_FTP_WEIRD_PASV_REPLY=13_CURLE_FTP_WEIRD_227_FORMAT=14_CURLE_FTP_CANT_GET_HOST=15_CURLE_HTTP2=16_CURLE_FTP_COULDNT_SET_TYPE=17_CURLE_PARTIAL_FILE=18_CURLE_FTP_COULDNT_RETR_FILE=19_CURLE_OBSOLETE20=20_CURLE_QUOTE_ERROR=21_CURLE_HTTP_RETURNED_ERROR=22_CURLE_WRITE_ERROR=23_CURLE_OBSOLETE24=24_CURLE_UPLOAD_FAILED=25_CURLE_READ_ERROR=26_CURLE_OUT_OF_MEMORY=27_CURLE_OPERATION_TIMEDOUT=28_CURLE_OBSOLETE29=29_CURLE_FTP_PORT_FAILED=30_CURLE_FTP_COULDNT_USE_REST=31_CURLE_OBSOLETE32=32_CURLE_RANGE_ERROR=33_CURLE_HTTP_POST_ERROR=34_CURLE_SSL_CONNECT_ERROR=35_CURLE_BAD_DOWNLOAD_RESUME=36_CURLE_FILE_COULDNT_READ_FILE=37_CURLE_LDAP_CANNOT_BIND=38_CURLE_LDAP_SEARCH_FAILED=39_CURLE_OBSOLETE40=40_CURLE_FUNCTION_NOT_FOUND=41_CURLE_ABORTED_BY_CALLBACK=42_CURLE_BAD_FUNCTION_ARGUMENT=43_CURLE_OBSOLETE44=44_CURLE_INTERFACE_FAILED=45_CURLE_OBSOLETE46=46_CURLE_TOO_MANY_REDIRECTS=47_CURLE_UNKNOWN_OPTION=48_CURLE_TELNET_OPTION_SYNTAX=49_CURLE_OBSOLETE50=50_CURLE_PEER_FAILED_VERIFICATION=51_CURLE_GOT_NOTHING=52_CURLE_SSL_ENGINE_NOTFOUND=53_CURLE_SSL_ENGINE_SETFAILED=54_CURLE_SEND_ERROR=55_CURLE_RECV_ERROR=56_CURLE_OBSOLETE57=57_CURLE_SSL_CERTPROBLEM=58_CURLE_SSL_CIPHER=59_CURLE_SSL_CACERT=60_CURLE_BAD_CONTENT_ENCODING=61_CURLE_LDAP_INVALID_URL=62_CURLE_FILESIZE_EXCEEDED=63_CURLE_USE_SSL_FAILED=64_CURLE_SEND_FAIL_REWIND=65_CURLE_SSL_ENGINE_INITFAILED=66_CURLE_LOGIN_DENIED=67_CURLE_TFTP_NOTFOUND=68_CURLE_TFTP_PERM=69_CURLE_REMOTE_DISK_FULL=70_CURLE_TFTP_ILLEGAL=71_CURLE_TFTP_UNKNOWNID=72_CURLE_REMOTE_FILE_EXISTS=73_CURLE_TFTP_NOSUCHUSER=74_CURLE_CONV_FAILED=75_CURLE_CONV_REQD=76_CURLE_SSL_CACERT_BADFILE=77_CURLE_REMOTE_FILE_NOT_FOUND=78_CURLE_SSH=79_CURLE_SSL_SHUTDOWN_FAILED=80_CURLE_AGAIN=81_CURLE_SSL_CRL_BADFILE=82_CURLE_SSL_ISSUER_ERROR=83_CURLE_FTP_PRET_FAILED=84_CURLE_RTSP_CSEQ_ERROR=85_CURLE_RTSP_SESSION_ERROR=86_CURLE_FTP_BAD_FILE_LIST=87_CURLE_CHUNK_FAILED=88_CURLE_NO_CONNECTION_AVAILABLE=89_CURLE_SSL_PINNEDPUBKEYNOTMATCH=90_CURLE_SSL_INVALIDCERTSTATUS=91_CURL_LAST=92
// file /usr/include/curl/curl.h line 413
enum anonymous_34 { CURLE_OK=0, CURLE_UNSUPPORTED_PROTOCOL=1, CURLE_FAILED_INIT=2, CURLE_URL_MALFORMAT=3, CURLE_NOT_BUILT_IN=4, CURLE_COULDNT_RESOLVE_PROXY=5, CURLE_COULDNT_RESOLVE_HOST=6, CURLE_COULDNT_CONNECT=7, CURLE_FTP_WEIRD_SERVER_REPLY=8, CURLE_REMOTE_ACCESS_DENIED=9, CURLE_FTP_ACCEPT_FAILED=10, CURLE_FTP_WEIRD_PASS_REPLY=11, CURLE_FTP_ACCEPT_TIMEOUT=12, CURLE_FTP_WEIRD_PASV_REPLY=13, CURLE_FTP_WEIRD_227_FORMAT=14, CURLE_FTP_CANT_GET_HOST=15, CURLE_HTTP2=16, CURLE_FTP_COULDNT_SET_TYPE=17, CURLE_PARTIAL_FILE=18, CURLE_FTP_COULDNT_RETR_FILE=19, CURLE_OBSOLETE20=20, CURLE_QUOTE_ERROR=21, CURLE_HTTP_RETURNED_ERROR=22, CURLE_WRITE_ERROR=23, CURLE_OBSOLETE24=24, CURLE_UPLOAD_FAILED=25, CURLE_READ_ERROR=26, CURLE_OUT_OF_MEMORY=27, CURLE_OPERATION_TIMEDOUT=28, CURLE_OBSOLETE29=29, CURLE_FTP_PORT_FAILED=30, CURLE_FTP_COULDNT_USE_REST=31, CURLE_OBSOLETE32=32, CURLE_RANGE_ERROR=33, CURLE_HTTP_POST_ERROR=34, CURLE_SSL_CONNECT_ERROR=35, CURLE_BAD_DOWNLOAD_RESUME=36, CURLE_FILE_COULDNT_READ_FILE=37, CURLE_LDAP_CANNOT_BIND=38, CURLE_LDAP_SEARCH_FAILED=39, CURLE_OBSOLETE40=40, CURLE_FUNCTION_NOT_FOUND=41, CURLE_ABORTED_BY_CALLBACK=42, CURLE_BAD_FUNCTION_ARGUMENT=43, CURLE_OBSOLETE44=44, CURLE_INTERFACE_FAILED=45, CURLE_OBSOLETE46=46, CURLE_TOO_MANY_REDIRECTS=47, CURLE_UNKNOWN_OPTION=48, CURLE_TELNET_OPTION_SYNTAX=49, CURLE_OBSOLETE50=50, CURLE_PEER_FAILED_VERIFICATION=51, CURLE_GOT_NOTHING=52, CURLE_SSL_ENGINE_NOTFOUND=53, CURLE_SSL_ENGINE_SETFAILED=54, CURLE_SEND_ERROR=55, CURLE_RECV_ERROR=56, CURLE_OBSOLETE57=57, CURLE_SSL_CERTPROBLEM=58, CURLE_SSL_CIPHER=59, CURLE_SSL_CACERT=60, CURLE_BAD_CONTENT_ENCODING=61, CURLE_LDAP_INVALID_URL=62, CURLE_FILESIZE_EXCEEDED=63, CURLE_USE_SSL_FAILED=64, CURLE_SEND_FAIL_REWIND=65, CURLE_SSL_ENGINE_INITFAILED=66, CURLE_LOGIN_DENIED=67, CURLE_TFTP_NOTFOUND=68, CURLE_TFTP_PERM=69, CURLE_REMOTE_DISK_FULL=70, CURLE_TFTP_ILLEGAL=71, CURLE_TFTP_UNKNOWNID=72, CURLE_REMOTE_FILE_EXISTS=73, CURLE_TFTP_NOSUCHUSER=74, CURLE_CONV_FAILED=75, CURLE_CONV_REQD=76, CURLE_SSL_CACERT_BADFILE=77, CURLE_REMOTE_FILE_NOT_FOUND=78, CURLE_SSH=79, CURLE_SSL_SHUTDOWN_FAILED=80, CURLE_AGAIN=81, CURLE_SSL_CRL_BADFILE=82, CURLE_SSL_ISSUER_ERROR=83, CURLE_FTP_PRET_FAILED=84, CURLE_RTSP_CSEQ_ERROR=85, CURLE_RTSP_SESSION_ERROR=86, CURLE_FTP_BAD_FILE_LIST=87, CURLE_CHUNK_FAILED=88, CURLE_NO_CONNECTION_AVAILABLE=89, CURLE_SSL_PINNEDPUBKEYNOTMATCH=90, CURLE_SSL_INVALIDCERTSTATUS=91, CURL_LAST=92 };

// #anon_enum_CURLOPT_WRITEDATA=10001_CURLOPT_URL=10002_CURLOPT_PORT=3_CURLOPT_PROXY=10004_CURLOPT_USERPWD=10005_CURLOPT_PROXYUSERPWD=10006_CURLOPT_RANGE=10007_CURLOPT_READDATA=10009_CURLOPT_ERRORBUFFER=10010_CURLOPT_WRITEFUNCTION=20011_CURLOPT_READFUNCTION=20012_CURLOPT_TIMEOUT=13_CURLOPT_INFILESIZE=14_CURLOPT_POSTFIELDS=10015_CURLOPT_REFERER=10016_CURLOPT_FTPPORT=10017_CURLOPT_USERAGENT=10018_CURLOPT_LOW_SPEED_LIMIT=19_CURLOPT_LOW_SPEED_TIME=20_CURLOPT_RESUME_FROM=21_CURLOPT_COOKIE=10022_CURLOPT_HTTPHEADER=10023_CURLOPT_HTTPPOST=10024_CURLOPT_SSLCERT=10025_CURLOPT_KEYPASSWD=10026_CURLOPT_CRLF=27_CURLOPT_QUOTE=10028_CURLOPT_HEADERDATA=10029_CURLOPT_COOKIEFILE=10031_CURLOPT_SSLVERSION=32_CURLOPT_TIMECONDITION=33_CURLOPT_TIMEVALUE=34_CURLOPT_CUSTOMREQUEST=10036_CURLOPT_STDERR=10037_CURLOPT_POSTQUOTE=10039_CURLOPT_OBSOLETE40=10040_CURLOPT_VERBOSE=41_CURLOPT_HEADER=42_CURLOPT_NOPROGRESS=43_CURLOPT_NOBODY=44_CURLOPT_FAILONERROR=45_CURLOPT_UPLOAD=46_CURLOPT_POST=47_CURLOPT_DIRLISTONLY=48_CURLOPT_APPEND=50_CURLOPT_NETRC=51_CURLOPT_FOLLOWLOCATION=52_CURLOPT_TRANSFERTEXT=53_CURLOPT_PUT=54_CURLOPT_PROGRESSFUNCTION=20056_CURLOPT_PROGRESSDATA=10057_CURLOPT_AUTOREFERER=58_CURLOPT_PROXYPORT=59_CURLOPT_POSTFIELDSIZE=60_CURLOPT_HTTPPROXYTUNNEL=61_CURLOPT_INTERFACE=10062_CURLOPT_KRBLEVEL=10063_CURLOPT_SSL_VERIFYPEER=64_CURLOPT_CAINFO=10065_CURLOPT_MAXREDIRS=68_CURLOPT_FILETIME=69_CURLOPT_TELNETOPTIONS=10070_CURLOPT_MAXCONNECTS=71_CURLOPT_OBSOLETE72=72_CURLOPT_FRESH_CONNECT=74_CURLOPT_FORBID_REUSE=75_CURLOPT_RANDOM_FILE=10076_CURLOPT_EGDSOCKET=10077_CURLOPT_CONNECTTIMEOUT=78_CURLOPT_HEADERFUNCTION=20079_CURLOPT_HTTPGET=80_CURLOPT_SSL_VERIFYHOST=81_CURLOPT_COOKIEJAR=10082_CURLOPT_SSL_CIPHER_LIST=10083_CURLOPT_HTTP_VERSION=84_CURLOPT_FTP_USE_EPSV=85_CURLOPT_SSLCERTTYPE=10086_CURLOPT_SSLKEY=10087_CURLOPT_SSLKEYTYPE=10088_CURLOPT_SSLENGINE=10089_CURLOPT_SSLENGINE_DEFAULT=90_CURLOPT_DNS_USE_GLOBAL_CACHE=91_CURLOPT_DNS_CACHE_TIMEOUT=92_CURLOPT_PREQUOTE=10093_CURLOPT_DEBUGFUNCTION=20094_CURLOPT_DEBUGDATA=10095_CURLOPT_COOKIESESSION=96_CURLOPT_CAPATH=10097_CURLOPT_BUFFERSIZE=98_CURLOPT_NOSIGNAL=99_CURLOPT_SHARE=10100_CURLOPT_PROXYTYPE=101_CURLOPT_ACCEPT_ENCODING=10102_CURLOPT_PRIVATE=10103_CURLOPT_HTTP200ALIASES=10104_CURLOPT_UNRESTRICTED_AUTH=105_CURLOPT_FTP_USE_EPRT=106_CURLOPT_HTTPAUTH=107_CURLOPT_SSL_CTX_FUNCTION=20108_CURLOPT_SSL_CTX_DATA=10109_CURLOPT_FTP_CREATE_MISSING_DIRS=110_CURLOPT_PROXYAUTH=111_CURLOPT_FTP_RESPONSE_TIMEOUT=112_CURLOPT_IPRESOLVE=113_CURLOPT_MAXFILESIZE=114_CURLOPT_INFILESIZE_LARGE=30115_CURLOPT_RESUME_FROM_LARGE=30116_CURLOPT_MAXFILESIZE_LARGE=30117_CURLOPT_NETRC_FILE=10118_CURLOPT_USE_SSL=119_CURLOPT_POSTFIELDSIZE_LARGE=30120_CURLOPT_TCP_NODELAY=121_CURLOPT_FTPSSLAUTH=129_CURLOPT_IOCTLFUNCTION=20130_CURLOPT_IOCTLDATA=10131_CURLOPT_FTP_ACCOUNT=10134_CURLOPT_COOKIELIST=10135_CURLOPT_IGNORE_CONTENT_LENGTH=136_CURLOPT_FTP_SKIP_PASV_IP=137_CURLOPT_FTP_FILEMETHOD=138_CURLOPT_LOCALPORT=139_CURLOPT_LOCALPORTRANGE=140_CURLOPT_CONNECT_ONLY=141_CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142_CURLOPT_CONV_TO_NETWORK_FUNCTION=20143_CURLOPT_CONV_FROM_UTF8_FUNCTION=20144_CURLOPT_MAX_SEND_SPEED_LARGE=30145_CURLOPT_MAX_RECV_SPEED_LARGE=30146_CURLOPT_FTP_ALTERNATIVE_TO_USER=10147_CURLOPT_SOCKOPTFUNCTION=20148_CURLOPT_SOCKOPTDATA=10149_CURLOPT_SSL_SESSIONID_CACHE=150_CURLOPT_SSH_AUTH_TYPES=151_CURLOPT_SSH_PUBLIC_KEYFILE=10152_CURLOPT_SSH_PRIVATE_KEYFILE=10153_CURLOPT_FTP_SSL_CCC=154_CURLOPT_TIMEOUT_MS=155_CURLOPT_CONNECTTIMEOUT_MS=156_CURLOPT_HTTP_TRANSFER_DECODING=157_CURLOPT_HTTP_CONTENT_DECODING=158_CURLOPT_NEW_FILE_PERMS=159_CURLOPT_NEW_DIRECTORY_PERMS=160_CURLOPT_POSTREDIR=161_CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162_CURLOPT_OPENSOCKETFUNCTION=20163_CURLOPT_OPENSOCKETDATA=10164_CURLOPT_COPYPOSTFIELDS=10165_CURLOPT_PROXY_TRANSFER_MODE=166_CURLOPT_SEEKFUNCTION=20167_CURLOPT_SEEKDATA=10168_CURLOPT_CRLFILE=10169_CURLOPT_ISSUERCERT=10170_CURLOPT_ADDRESS_SCOPE=171_CURLOPT_CERTINFO=172_CURLOPT_USERNAME=10173_CURLOPT_PASSWORD=10174_CURLOPT_PROXYUSERNAME=10175_CURLOPT_PROXYPASSWORD=10176_CURLOPT_NOPROXY=10177_CURLOPT_TFTP_BLKSIZE=178_CURLOPT_SOCKS5_GSSAPI_SERVICE=10179_CURLOPT_SOCKS5_GSSAPI_NEC=180_CURLOPT_PROTOCOLS=181_CURLOPT_REDIR_PROTOCOLS=182_CURLOPT_SSH_KNOWNHOSTS=10183_CURLOPT_SSH_KEYFUNCTION=20184_CURLOPT_SSH_KEYDATA=10185_CURLOPT_MAIL_FROM=10186_CURLOPT_MAIL_RCPT=10187_CURLOPT_FTP_USE_PRET=188_CURLOPT_RTSP_REQUEST=189_CURLOPT_RTSP_SESSION_ID=10190_CURLOPT_RTSP_STREAM_URI=10191_CURLOPT_RTSP_TRANSPORT=10192_CURLOPT_RTSP_CLIENT_CSEQ=193_CURLOPT_RTSP_SERVER_CSEQ=194_CURLOPT_INTERLEAVEDATA=10195_CURLOPT_INTERLEAVEFUNCTION=20196_CURLOPT_WILDCARDMATCH=197_CURLOPT_CHUNK_BGN_FUNCTION=20198_CURLOPT_CHUNK_END_FUNCTION=20199_CURLOPT_FNMATCH_FUNCTION=20200_CURLOPT_CHUNK_DATA=10201_CURLOPT_FNMATCH_DATA=10202_CURLOPT_RESOLVE=10203_CURLOPT_TLSAUTH_USERNAME=10204_CURLOPT_TLSAUTH_PASSWORD=10205_CURLOPT_TLSAUTH_TYPE=10206_CURLOPT_TRANSFER_ENCODING=207_CURLOPT_CLOSESOCKETFUNCTION=20208_CURLOPT_CLOSESOCKETDATA=10209_CURLOPT_GSSAPI_DELEGATION=210_CURLOPT_DNS_SERVERS=10211_CURLOPT_ACCEPTTIMEOUT_MS=212_CURLOPT_TCP_KEEPALIVE=213_CURLOPT_TCP_KEEPIDLE=214_CURLOPT_TCP_KEEPINTVL=215_CURLOPT_SSL_OPTIONS=216_CURLOPT_MAIL_AUTH=10217_CURLOPT_SASL_IR=218_CURLOPT_XFERINFOFUNCTION=20219_CURLOPT_XOAUTH2_BEARER=10220_CURLOPT_DNS_INTERFACE=10221_CURLOPT_DNS_LOCAL_IP4=10222_CURLOPT_DNS_LOCAL_IP6=10223_CURLOPT_LOGIN_OPTIONS=10224_CURLOPT_SSL_ENABLE_NPN=225_CURLOPT_SSL_ENABLE_ALPN=226_CURLOPT_EXPECT_100_TIMEOUT_MS=227_CURLOPT_PROXYHEADER=10228_CURLOPT_HEADEROPT=229_CURLOPT_PINNEDPUBLICKEY=10230_CURLOPT_UNIX_SOCKET_PATH=10231_CURLOPT_SSL_VERIFYSTATUS=232_CURLOPT_SSL_FALSESTART=233_CURLOPT_PATH_AS_IS=234_CURLOPT_PROXY_SERVICE_NAME=10235_CURLOPT_SERVICE_NAME=10236_CURLOPT_PIPEWAIT=237_CURLOPT_DEFAULT_PROTOCOL=10238_CURLOPT_STREAM_WEIGHT=239_CURLOPT_STREAM_DEPENDS=10240_CURLOPT_STREAM_DEPENDS_E=10241_CURLOPT_LASTENTRY=10242
// file /usr/include/curl/curl.h line 863
enum anonymous_32 { CURLOPT_WRITEDATA=10001, CURLOPT_URL=10002, CURLOPT_PORT=3, CURLOPT_PROXY=10004, CURLOPT_USERPWD=10005, CURLOPT_PROXYUSERPWD=10006, CURLOPT_RANGE=10007, CURLOPT_READDATA=10009, CURLOPT_ERRORBUFFER=10010, CURLOPT_WRITEFUNCTION=20011, CURLOPT_READFUNCTION=20012, CURLOPT_TIMEOUT=13, CURLOPT_INFILESIZE=14, CURLOPT_POSTFIELDS=10015, CURLOPT_REFERER=10016, CURLOPT_FTPPORT=10017, CURLOPT_USERAGENT=10018, CURLOPT_LOW_SPEED_LIMIT=19, CURLOPT_LOW_SPEED_TIME=20, CURLOPT_RESUME_FROM=21, CURLOPT_COOKIE=10022, CURLOPT_HTTPHEADER=10023, CURLOPT_HTTPPOST=10024, CURLOPT_SSLCERT=10025, CURLOPT_KEYPASSWD=10026, CURLOPT_CRLF=27, CURLOPT_QUOTE=10028, CURLOPT_HEADERDATA=10029, CURLOPT_COOKIEFILE=10031, CURLOPT_SSLVERSION=32, CURLOPT_TIMECONDITION=33, CURLOPT_TIMEVALUE=34, CURLOPT_CUSTOMREQUEST=10036, CURLOPT_STDERR=10037, CURLOPT_POSTQUOTE=10039, CURLOPT_OBSOLETE40=10040, CURLOPT_VERBOSE=41, CURLOPT_HEADER=42, CURLOPT_NOPROGRESS=43, CURLOPT_NOBODY=44, CURLOPT_FAILONERROR=45, CURLOPT_UPLOAD=46, CURLOPT_POST=47, CURLOPT_DIRLISTONLY=48, CURLOPT_APPEND=50, CURLOPT_NETRC=51, CURLOPT_FOLLOWLOCATION=52, CURLOPT_TRANSFERTEXT=53, CURLOPT_PUT=54, CURLOPT_PROGRESSFUNCTION=20056, CURLOPT_PROGRESSDATA=10057, CURLOPT_AUTOREFERER=58, CURLOPT_PROXYPORT=59, CURLOPT_POSTFIELDSIZE=60, CURLOPT_HTTPPROXYTUNNEL=61, CURLOPT_INTERFACE=10062, CURLOPT_KRBLEVEL=10063, CURLOPT_SSL_VERIFYPEER=64, CURLOPT_CAINFO=10065, CURLOPT_MAXREDIRS=68, CURLOPT_FILETIME=69, CURLOPT_TELNETOPTIONS=10070, CURLOPT_MAXCONNECTS=71, CURLOPT_OBSOLETE72=72, CURLOPT_FRESH_CONNECT=74, CURLOPT_FORBID_REUSE=75, CURLOPT_RANDOM_FILE=10076, CURLOPT_EGDSOCKET=10077, CURLOPT_CONNECTTIMEOUT=78, CURLOPT_HEADERFUNCTION=20079, CURLOPT_HTTPGET=80, CURLOPT_SSL_VERIFYHOST=81, CURLOPT_COOKIEJAR=10082, CURLOPT_SSL_CIPHER_LIST=10083, CURLOPT_HTTP_VERSION=84, CURLOPT_FTP_USE_EPSV=85, CURLOPT_SSLCERTTYPE=10086, CURLOPT_SSLKEY=10087, CURLOPT_SSLKEYTYPE=10088, CURLOPT_SSLENGINE=10089, CURLOPT_SSLENGINE_DEFAULT=90, CURLOPT_DNS_USE_GLOBAL_CACHE=91, CURLOPT_DNS_CACHE_TIMEOUT=92, CURLOPT_PREQUOTE=10093, CURLOPT_DEBUGFUNCTION=20094, CURLOPT_DEBUGDATA=10095, CURLOPT_COOKIESESSION=96, CURLOPT_CAPATH=10097, CURLOPT_BUFFERSIZE=98, CURLOPT_NOSIGNAL=99, CURLOPT_SHARE=10100, CURLOPT_PROXYTYPE=101, CURLOPT_ACCEPT_ENCODING=10102, CURLOPT_PRIVATE=10103, CURLOPT_HTTP200ALIASES=10104, CURLOPT_UNRESTRICTED_AUTH=105, CURLOPT_FTP_USE_EPRT=106, CURLOPT_HTTPAUTH=107, CURLOPT_SSL_CTX_FUNCTION=20108, CURLOPT_SSL_CTX_DATA=10109, CURLOPT_FTP_CREATE_MISSING_DIRS=110, CURLOPT_PROXYAUTH=111, CURLOPT_FTP_RESPONSE_TIMEOUT=112, CURLOPT_IPRESOLVE=113, CURLOPT_MAXFILESIZE=114, CURLOPT_INFILESIZE_LARGE=30115, CURLOPT_RESUME_FROM_LARGE=30116, CURLOPT_MAXFILESIZE_LARGE=30117, CURLOPT_NETRC_FILE=10118, CURLOPT_USE_SSL=119, CURLOPT_POSTFIELDSIZE_LARGE=30120, CURLOPT_TCP_NODELAY=121, CURLOPT_FTPSSLAUTH=129, CURLOPT_IOCTLFUNCTION=20130, CURLOPT_IOCTLDATA=10131, CURLOPT_FTP_ACCOUNT=10134, CURLOPT_COOKIELIST=10135, CURLOPT_IGNORE_CONTENT_LENGTH=136, CURLOPT_FTP_SKIP_PASV_IP=137, CURLOPT_FTP_FILEMETHOD=138, CURLOPT_LOCALPORT=139, CURLOPT_LOCALPORTRANGE=140, CURLOPT_CONNECT_ONLY=141, CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142, CURLOPT_CONV_TO_NETWORK_FUNCTION=20143, CURLOPT_CONV_FROM_UTF8_FUNCTION=20144, CURLOPT_MAX_SEND_SPEED_LARGE=30145, CURLOPT_MAX_RECV_SPEED_LARGE=30146, CURLOPT_FTP_ALTERNATIVE_TO_USER=10147, CURLOPT_SOCKOPTFUNCTION=20148, CURLOPT_SOCKOPTDATA=10149, CURLOPT_SSL_SESSIONID_CACHE=150, CURLOPT_SSH_AUTH_TYPES=151, CURLOPT_SSH_PUBLIC_KEYFILE=10152, CURLOPT_SSH_PRIVATE_KEYFILE=10153, CURLOPT_FTP_SSL_CCC=154, CURLOPT_TIMEOUT_MS=155, CURLOPT_CONNECTTIMEOUT_MS=156, CURLOPT_HTTP_TRANSFER_DECODING=157, CURLOPT_HTTP_CONTENT_DECODING=158, CURLOPT_NEW_FILE_PERMS=159, CURLOPT_NEW_DIRECTORY_PERMS=160, CURLOPT_POSTREDIR=161, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162, CURLOPT_OPENSOCKETFUNCTION=20163, CURLOPT_OPENSOCKETDATA=10164, CURLOPT_COPYPOSTFIELDS=10165, CURLOPT_PROXY_TRANSFER_MODE=166, CURLOPT_SEEKFUNCTION=20167, CURLOPT_SEEKDATA=10168, CURLOPT_CRLFILE=10169, CURLOPT_ISSUERCERT=10170, CURLOPT_ADDRESS_SCOPE=171, CURLOPT_CERTINFO=172, CURLOPT_USERNAME=10173, CURLOPT_PASSWORD=10174, CURLOPT_PROXYUSERNAME=10175, CURLOPT_PROXYPASSWORD=10176, CURLOPT_NOPROXY=10177, CURLOPT_TFTP_BLKSIZE=178, CURLOPT_SOCKS5_GSSAPI_SERVICE=10179, CURLOPT_SOCKS5_GSSAPI_NEC=180, CURLOPT_PROTOCOLS=181, CURLOPT_REDIR_PROTOCOLS=182, CURLOPT_SSH_KNOWNHOSTS=10183, CURLOPT_SSH_KEYFUNCTION=20184, CURLOPT_SSH_KEYDATA=10185, CURLOPT_MAIL_FROM=10186, CURLOPT_MAIL_RCPT=10187, CURLOPT_FTP_USE_PRET=188, CURLOPT_RTSP_REQUEST=189, CURLOPT_RTSP_SESSION_ID=10190, CURLOPT_RTSP_STREAM_URI=10191, CURLOPT_RTSP_TRANSPORT=10192, CURLOPT_RTSP_CLIENT_CSEQ=193, CURLOPT_RTSP_SERVER_CSEQ=194, CURLOPT_INTERLEAVEDATA=10195, CURLOPT_INTERLEAVEFUNCTION=20196, CURLOPT_WILDCARDMATCH=197, CURLOPT_CHUNK_BGN_FUNCTION=20198, CURLOPT_CHUNK_END_FUNCTION=20199, CURLOPT_FNMATCH_FUNCTION=20200, CURLOPT_CHUNK_DATA=10201, CURLOPT_FNMATCH_DATA=10202, CURLOPT_RESOLVE=10203, CURLOPT_TLSAUTH_USERNAME=10204, CURLOPT_TLSAUTH_PASSWORD=10205, CURLOPT_TLSAUTH_TYPE=10206, CURLOPT_TRANSFER_ENCODING=207, CURLOPT_CLOSESOCKETFUNCTION=20208, CURLOPT_CLOSESOCKETDATA=10209, CURLOPT_GSSAPI_DELEGATION=210, CURLOPT_DNS_SERVERS=10211, CURLOPT_ACCEPTTIMEOUT_MS=212, CURLOPT_TCP_KEEPALIVE=213, CURLOPT_TCP_KEEPIDLE=214, CURLOPT_TCP_KEEPINTVL=215, CURLOPT_SSL_OPTIONS=216, CURLOPT_MAIL_AUTH=10217, CURLOPT_SASL_IR=218, CURLOPT_XFERINFOFUNCTION=20219, CURLOPT_XOAUTH2_BEARER=10220, CURLOPT_DNS_INTERFACE=10221, CURLOPT_DNS_LOCAL_IP4=10222, CURLOPT_DNS_LOCAL_IP6=10223, CURLOPT_LOGIN_OPTIONS=10224, CURLOPT_SSL_ENABLE_NPN=225, CURLOPT_SSL_ENABLE_ALPN=226, CURLOPT_EXPECT_100_TIMEOUT_MS=227, CURLOPT_PROXYHEADER=10228, CURLOPT_HEADEROPT=229, CURLOPT_PINNEDPUBLICKEY=10230, CURLOPT_UNIX_SOCKET_PATH=10231, CURLOPT_SSL_VERIFYSTATUS=232, CURLOPT_SSL_FALSESTART=233, CURLOPT_PATH_AS_IS=234, CURLOPT_PROXY_SERVICE_NAME=10235, CURLOPT_SERVICE_NAME=10236, CURLOPT_PIPEWAIT=237, CURLOPT_DEFAULT_PROTOCOL=10238, CURLOPT_STREAM_WEIGHT=239, CURLOPT_STREAM_DEPENDS=10240, CURLOPT_STREAM_DEPENDS_E=10241, CURLOPT_LASTENTRY=10242 };

// #anon_enum_OC_CS_UNSPECIFIED=0_OC_CS_ITU_REC_470M=1_OC_CS_ITU_REC_470BG=2_OC_CS_NSPACES=3
// file /usr/include/theora/theora.h line 164
enum anonymous_29 { OC_CS_UNSPECIFIED=0, OC_CS_ITU_REC_470M=1, OC_CS_ITU_REC_470BG=2, OC_CS_NSPACES=3 };

// #anon_enum_OC_PF_420=0_OC_PF_RSVD=1_OC_PF_422=2_OC_PF_444=3
// file /usr/include/theora/theora.h line 178
enum anonymous_30 { OC_PF_420=0, OC_PF_RSVD=1, OC_PF_422=2, OC_PF_444=3 };

// #anon_enum_XML_ATTRIBUTE_CDATA=1_XML_ATTRIBUTE_ID=2_XML_ATTRIBUTE_IDREF=3_XML_ATTRIBUTE_IDREFS=4_XML_ATTRIBUTE_ENTITY=5_XML_ATTRIBUTE_ENTITIES=6_XML_ATTRIBUTE_NMTOKEN=7_XML_ATTRIBUTE_NMTOKENS=8_XML_ATTRIBUTE_ENUMERATION=9_XML_ATTRIBUTE_NOTATION=10
// file /usr/include/libxml2/libxml/tree.h line 206
enum anonymous_18 { XML_ATTRIBUTE_CDATA=1, XML_ATTRIBUTE_ID=2, XML_ATTRIBUTE_IDREF=3, XML_ATTRIBUTE_IDREFS=4, XML_ATTRIBUTE_ENTITY=5, XML_ATTRIBUTE_ENTITIES=6, XML_ATTRIBUTE_NMTOKEN=7, XML_ATTRIBUTE_NMTOKENS=8, XML_ATTRIBUTE_ENUMERATION=9, XML_ATTRIBUTE_NOTATION=10 };

// #anon_enum_XML_BUFFER_ALLOC_DOUBLEIT=0_XML_BUFFER_ALLOC_EXACT=1_XML_BUFFER_ALLOC_IMMUTABLE=2_XML_BUFFER_ALLOC_IO=3_XML_BUFFER_ALLOC_HYBRID=4_XML_BUFFER_ALLOC_BOUNDED=5
// file /usr/include/libxml2/libxml/tree.h line 74
enum anonymous_0 { XML_BUFFER_ALLOC_DOUBLEIT=0, XML_BUFFER_ALLOC_EXACT=1, XML_BUFFER_ALLOC_IMMUTABLE=2, XML_BUFFER_ALLOC_IO=3, XML_BUFFER_ALLOC_HYBRID=4, XML_BUFFER_ALLOC_BOUNDED=5 };

// #anon_enum_XML_ELEMENT_NODE=1_XML_ATTRIBUTE_NODE=2_XML_TEXT_NODE=3_XML_CDATA_SECTION_NODE=4_XML_ENTITY_REF_NODE=5_XML_ENTITY_NODE=6_XML_PI_NODE=7_XML_COMMENT_NODE=8_XML_DOCUMENT_NODE=9_XML_DOCUMENT_TYPE_NODE=10_XML_DOCUMENT_FRAG_NODE=11_XML_NOTATION_NODE=12_XML_HTML_DOCUMENT_NODE=13_XML_DTD_NODE=14_XML_ELEMENT_DECL=15_XML_ATTRIBUTE_DECL=16_XML_ENTITY_DECL=17_XML_NAMESPACE_DECL=18_XML_XINCLUDE_START=19_XML_XINCLUDE_END=20_XML_DOCB_DOCUMENT_NODE=21
// file /usr/include/libxml2/libxml/tree.h line 159
enum anonymous_13 { XML_ELEMENT_NODE=1, XML_ATTRIBUTE_NODE=2, XML_TEXT_NODE=3, XML_CDATA_SECTION_NODE=4, XML_ENTITY_REF_NODE=5, XML_ENTITY_NODE=6, XML_PI_NODE=7, XML_COMMENT_NODE=8, XML_DOCUMENT_NODE=9, XML_DOCUMENT_TYPE_NODE=10, XML_DOCUMENT_FRAG_NODE=11, XML_NOTATION_NODE=12, XML_HTML_DOCUMENT_NODE=13, XML_DTD_NODE=14, XML_ELEMENT_DECL=15, XML_ATTRIBUTE_DECL=16, XML_ENTITY_DECL=17, XML_NAMESPACE_DECL=18, XML_XINCLUDE_START=19, XML_XINCLUDE_END=20, XML_DOCB_DOCUMENT_NODE=21 };

// #anon_enum_XML_ERR_NONE=0_XML_ERR_WARNING=1_XML_ERR_ERROR=2_XML_ERR_FATAL=3
// file /usr/include/libxml2/libxml/xmlerror.h line 24
enum anonymous_7 { XML_ERR_NONE=0, XML_ERR_WARNING=1, XML_ERR_ERROR=2, XML_ERR_FATAL=3 };

// #anon_enum_XPATH_UNDEFINED=0_XPATH_NODESET=1_XPATH_BOOLEAN=2_XPATH_NUMBER=3_XPATH_STRING=4_XPATH_POINT=5_XPATH_RANGE=6_XPATH_LOCATIONSET=7_XPATH_USERS=8_XPATH_XSLT_TREE=9
// file /usr/include/libxml2/libxml/xpath.h line 99
enum anonymous_6 { XPATH_UNDEFINED=0, XPATH_NODESET=1, XPATH_BOOLEAN=2, XPATH_NUMBER=3, XPATH_STRING=4, XPATH_POINT=5, XPATH_RANGE=6, XPATH_LOCATIONSET=7, XPATH_USERS=8, XPATH_XSLT_TREE=9 };

// #anon_enum_XSLT_FUNC_COPY=1_XSLT_FUNC_SORT=2_XSLT_FUNC_TEXT=3_XSLT_FUNC_ELEMENT=4_XSLT_FUNC_ATTRIBUTE=5_XSLT_FUNC_COMMENT=6_XSLT_FUNC_PI=7_XSLT_FUNC_COPYOF=8_XSLT_FUNC_VALUEOF=9_XSLT_FUNC_NUMBER=10_XSLT_FUNC_APPLYIMPORTS=11_XSLT_FUNC_CALLTEMPLATE=12_XSLT_FUNC_APPLYTEMPLATES=13_XSLT_FUNC_CHOOSE=14_XSLT_FUNC_IF=15_XSLT_FUNC_FOREACH=16_XSLT_FUNC_DOCUMENT=17_XSLT_FUNC_WITHPARAM=18_XSLT_FUNC_PARAM=19_XSLT_FUNC_VARIABLE=20_XSLT_FUNC_WHEN=21_XSLT_FUNC_EXTENSION=22
// file /usr/include/libxslt/xsltInternals.h line 427
enum anonymous_10 { XSLT_FUNC_COPY=1, XSLT_FUNC_SORT=2, XSLT_FUNC_TEXT=3, XSLT_FUNC_ELEMENT=4, XSLT_FUNC_ATTRIBUTE=5, XSLT_FUNC_COMMENT=6, XSLT_FUNC_PI=7, XSLT_FUNC_COPYOF=8, XSLT_FUNC_VALUEOF=9, XSLT_FUNC_NUMBER=10, XSLT_FUNC_APPLYIMPORTS=11, XSLT_FUNC_CALLTEMPLATE=12, XSLT_FUNC_APPLYTEMPLATES=13, XSLT_FUNC_CHOOSE=14, XSLT_FUNC_IF=15, XSLT_FUNC_FOREACH=16, XSLT_FUNC_DOCUMENT=17, XSLT_FUNC_WITHPARAM=18, XSLT_FUNC_PARAM=19, XSLT_FUNC_VARIABLE=20, XSLT_FUNC_WHEN=21, XSLT_FUNC_EXTENSION=22 };

// #anon_enum_XSLT_OUTPUT_XML=0_XSLT_OUTPUT_HTML=1_XSLT_OUTPUT_TEXT=2
// file /usr/include/libxslt/xsltInternals.h line 1662
enum anonymous_11 { XSLT_OUTPUT_XML=0, XSLT_OUTPUT_HTML=1, XSLT_OUTPUT_TEXT=2 };

// #anon_enum_XSLT_STATE_OK=0_XSLT_STATE_ERROR=1_XSLT_STATE_STOPPED=2
// file /usr/include/libxslt/xsltInternals.h line 1668
enum anonymous_12 { XSLT_STATE_OK=0, XSLT_STATE_ERROR=1, XSLT_STATE_STOPPED=2 };

// tag-#anon#ST[*{S8}_S8_'ext'||*{S8}_S8_'type'|]
// file fserve.c line 89
struct anonymous_15;

// tag-#anon#ST[*{S8}_S8_'filename'||S64'file_recheck'||S64'file_mtime'||*{SYM#tag-_avl_tree#}_SYM#tag-_avl_tree#_'contents'|]
// file connection.c line 100
struct anonymous_42;

// tag-#anon#ST[*{S8}_S8_'filename'||S64'last_modified'||S64'cache_age'||*{SYM#tag-_xsltStylesheet#}_SYM#tag-_xsltStylesheet#_'stylesheet'|]
// file xslt.c line 59
struct anonymous_43;

// tag-#anon#ST[*{S8}_S8_'filename'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]#'sys_rwlock'|]#'file_rwlock'||*{SYM#tag-_avl_tree#}_SYM#tag-_avl_tree#_'users'||S64'mtime'|]
// file auth_htpasswd.c line 53
struct anonymous_20;

// tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'pass'|]
// file auth_htpasswd.c line 47
struct anonymous_22;

// tag-#anon#ST[*{S8}_S8_'pass_headers'||*{S8}_S8_'prefix_headers'||*{S8}_S8_'addurl'||*{S8}_S8_'removeurl'||*{S8}_S8_'stream_start'||*{S8}_S8_'stream_end'||*{S8}_S8_'stream_auth'||*{S8}_S8_'username'||*{S8}_S8_'password'||*{S8}_S8_'auth_header'||S32'auth_header_len'||U32'_pad0'||*{S8}_S8_'timelimit_header'||S32'timelimit_header_len'||U32'_pad1'||*{S8}_S8_'userpwd'||*{V}_V_'handle'||ARR256{S8}_S8_'errormsg'|]
// file auth_url.c line 88
struct anonymous_33;

// tag-#anon#ST[*{U8}_U8_'body_data'||S64'body_storage'||S64'body_fill'||S64'body_returned'||*{S32}_S32_'lacing_vals'||*{S64}_S64_'granule_vals'||S64'lacing_storage'||S64'lacing_fill'||S64'lacing_packet'||S64'lacing_returned'||ARR282{U8}_U8_'header'||U16'_pad0'||S32'header_fill'||S32'e_o_s'||S32'b_o_s'||S64'serialno'||S64'pageno'||S64'packetno'||S64'granulepos'|]
// file /usr/include/ogg/ogg.h line 53
struct anonymous_2;

// tag-#anon#ST[*{U8}_U8_'data'||S32'storage'||S32'fill'||S32'returned'||S32'unsynced'||S32'headerbytes'||S32'bodybytes'|]
// file /usr/include/ogg/ogg.h line 105
struct anonymous_1;

// tag-#anon#ST[*{U8}_U8_'header'||S64'header_len'||*{U8}_U8_'body'||S64'body_len'|]
// file /usr/include/ogg/ogg.h line 43
struct anonymous_3;

// tag-#anon#ST[*{U8}_U8_'packet'||S64'bytes'||S64'b_o_s'||S64'e_o_s'||S64'granulepos'||S64'packetno'|]
// file /usr/include/ogg/ogg.h line 90
struct anonymous_14;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_44;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_38;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_25;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_28;

// tag-#anon#ST[S32'inline_metadata_interval'||S32'offset'||S32'interval'||U32'_pad0'||*{S8}_S8_'url_artist'||*{S8}_S8_'url_title'||*{S8}_S8_'url'||*{S8}_S8_'inline_url'||S32'update_metadata'||U32'_pad1'||*{SYM#tag-_refbuf_tag#}_SYM#tag-_refbuf_tag#_'metadata'||*{SYM#tag-_refbuf_tag#}_SYM#tag-_refbuf_tag#_'read_data'||S32'read_count'||U32'_pad2'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'sys_mutex'|]#'url_lock'||U32'build_metadata_len'||U32'build_metadata_offset'||ARR4081{S8}_S8_'build_metadata'||U56'_pad3'|]
// file format_mp3.h line 21
struct anonymous_5;

// tag-#anon#ST[S64'thread_id'||*{S8}_S8_'name'||S64'create_time'||*{S8}_S8_'file'||S32'line'||S32'detached'||U64'sys_thread'|]
// file thread/thread.h line 28
struct anonymous_24;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]#'sys_rwlock'|]#'config_lock'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'sys_mutex'|]#'relay_lock'|]
// file cfgfile.h line 217
struct anonymous_17;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]#'sys_rwlock'|]
// file thread/thread.h line 76
struct anonymous_16;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'cond_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'sys_cond'|]
// file thread/thread.h line 66
struct anonymous_27;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'sys_mutex'|]
// file thread/thread.h line 47
struct anonymous_4;

// tag-#anon#ST[U32'interval'||S32'metadata_offset'||U32'since_meta_block'||S32'in_metadata'||*{SYM#tag-_refbuf_tag#}_SYM#tag-_refbuf_tag#_'associated'|]
// file format_mp3.c line 69
struct anonymous_8;

// tag-#anon#ST[U32'width'||U32'height'||U32'frame_width'||U32'frame_height'||U32'offset_x'||U32'offset_y'||U32'fps_numerator'||U32'fps_denominator'||U32'aspect_numerator'||U32'aspect_denominator'||EN#anon_enum_OC_CS_UNSPECIFIED=0_OC_CS_ITU_REC_470M=1_OC_CS_ITU_REC_470BG=2_OC_CS_NSPACES=3#{U32}_U32_'colorspace'||S32'target_bitrate'||S32'quality'||S32'quick_p'||U8'version_major'||U8'version_minor'||U8'version_subminor'||U40'_pad0'||*{V}_V_'codec_setup'||S32'dropframes_p'||S32'keyframe_auto_p'||U32'keyframe_frequency'||U32'keyframe_frequency_force'||U32'keyframe_data_target_bitrate'||S32'keyframe_auto_threshold'||U32'keyframe_mindistance'||S32'noise_sensitivity'||S32'sharpness'||EN#anon_enum_OC_PF_420=0_OC_PF_RSVD=1_OC_PF_422=2_OC_PF_444=3#{U32}_U32_'pixelformat'|]
// file /usr/include/theora/theora.h line 206
struct anonymous_31;

// tag-#anon#ST[vS32'lock'|]
// file thread/thread.h line 93
struct anonymous_41;

// tag-#anon#UN[*{V}_V_'ptr'||S32'ival'|]
// file /usr/include/libxslt/xsltInternals.h line 236
union anonymous_9;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_36;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_40;

// tag-#anon#UN[ARR8{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous_39;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_26;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_23;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_21;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_35;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous;

// tag-MD5Context
// file md5.h line 20
struct MD5Context;

// tag-SpeexHeader
// file /usr/include/speex/speex_header.h line 59
struct SpeexHeader;

// tag-UConverter
// file /usr/include/x86_64-linux-gnu/unicode/ucnv_err.h line 91
struct UConverter;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_aliases
// file cfgfile.h line 123
struct _aliases;

// tag-_avl_tree
// file avl/avl.h line 54
struct _avl_tree;

// tag-_client_tag
// file connection.h line 28
struct _client_tag;

// tag-_config_options
// file cfgfile.h line 61
struct _config_options;

// tag-_event_listener_tag
// file stats.c line 66
struct _event_listener_tag;

// tag-_event_queue_tag
// file stats.c line 58
struct _event_queue_tag;

// tag-_format_plugin_tag
// file format.h line 36
struct _format_plugin_tag;

// tag-_format_type_tag
// file format.h line 28
enum _format_type_tag { FORMAT_ERROR=0, FORMAT_TYPE_OGG=1, FORMAT_TYPE_EBML=2, FORMAT_TYPE_GENERIC=3 };

// tag-_fserve_t
// file fserve.h line 21
struct _fserve_t;

// tag-_http_header_type
// file cfgfile.h line 35
enum _http_header_type { HTTP_HEADER_TYPE_STATIC=0 };

// tag-_kate_codec_tag
// file format_kate.c line 39
struct _kate_codec_tag;

// tag-_link_node
// file avl.c line 1066
struct _link_node;

// tag-_listener_t
// file cfgfile.h line 131
struct _listener_t;

// tag-_log_entry_t
// file log.c line 49
struct _log_entry_t;

// tag-_mount_proxy
// file cfgfile.h line 25
struct _mount_proxy;

// tag-_mount_type
// file cfgfile.h line 67
enum _mount_type { MOUNT_TYPE_NORMAL=0, MOUNT_TYPE_DEFAULT=1 };

// tag-_refbuf_tag
// file refbuf.h line 21
struct _refbuf_tag;

// tag-_relay_server
// file slave.h line 18
struct _relay_server;

// tag-_stats_event_tag
// file stats.h line 32
struct _stats_event_tag;

// tag-_stats_node_tag
// file stats.h line 25
struct _stats_node_tag;

// tag-_stats_source_tag
// file stats.h line 43
struct _stats_source_tag;

// tag-_stats_tag
// file stats.h line 50
struct _stats_tag;

// tag-_theora_codec_tag
// file format_theora.c line 36
struct _theora_codec_tag;

// tag-_uconv_t
// file /usr/include/libxml2/libxml/encoding.h line 132
struct _uconv_t;

// tag-_util_dict
// file util.h line 71
struct _util_dict;

// tag-_xmlAttr
// file /usr/include/libxml2/libxml/tree.h line 432
struct _xmlAttr;

// tag-_xmlBuffer
// file /usr/include/libxml2/libxml/tree.h line 89
struct _xmlBuffer;

// tag-_xmlCharEncodingHandler
// file /usr/include/libxml2/libxml/encoding.h line 139
struct _xmlCharEncodingHandler;

// tag-_xmlDict
// file /usr/include/libxml2/libxml/dict.h line 25
struct _xmlDict;

// tag-_xmlDoc
// file /usr/include/libxml2/libxml/tree.h line 262
struct _xmlDoc;

// tag-_xmlDtd
// file /usr/include/libxml2/libxml/tree.h line 259
struct _xmlDtd;

// tag-_xmlError
// file /usr/include/libxml2/libxml/xmlerror.h line 76
struct _xmlError;

// tag-_xmlHashTable
// file /usr/include/libxml2/libxml/hash.h line 21
struct _xmlHashTable;

// tag-_xmlNode
// file /usr/include/libxml2/libxml/tree.h line 257
struct _xmlNode;

// tag-_xmlNodeSet
// file /usr/include/libxml2/libxml/xpath.h line 79
struct _xmlNodeSet;

// tag-_xmlNs
// file /usr/include/libxml2/libxml/tree.h line 387
struct _xmlNs;

// tag-_xmlURI
// file /usr/include/libxml2/libxml/uri.h line 31
struct _xmlURI;

// tag-_xmlXPathAxis
// file /usr/include/libxml2/libxml/xpath.h line 201
struct _xmlXPathAxis;

// tag-_xmlXPathCompExpr
// file /usr/include/libxml2/libxml/xpath.h line 361
struct _xmlXPathCompExpr;

// tag-_xmlXPathContext
// file /usr/include/libxml2/libxml/xpath.h line 39
struct _xmlXPathContext;

// tag-_xmlXPathObject
// file /usr/include/libxml2/libxml/xpath.h line 112
struct _xmlXPathObject;

// tag-_xmlXPathParserContext
// file /usr/include/libxml2/libxml/xpath.h line 41
struct _xmlXPathParserContext;

// tag-_xmlXPathType
// file /usr/include/libxml2/libxml/xpath.h line 142
struct _xmlXPathType;

// tag-_xsltCompMatch
// file /usr/include/libxslt/numbersInternals.h line 20
struct _xsltCompMatch;

// tag-_xsltDecimalFormat
// file /usr/include/libxslt/xsltInternals.h line 309
struct _xsltDecimalFormat;

// tag-_xsltDocument
// file /usr/include/libxslt/xsltInternals.h line 334
struct _xsltDocument;

// tag-_xsltElemPreComp
// file /usr/include/libxslt/xsltInternals.h line 398
struct _xsltElemPreComp;

// tag-_xsltNumberData
// file /usr/include/libxslt/numbersInternals.h line 27
struct _xsltNumberData;

// tag-_xsltRuntimeExtra
// file /usr/include/libxslt/xsltInternals.h line 231
struct _xsltRuntimeExtra;

// tag-_xsltStackElem
// file /usr/include/libxslt/xsltInternals.h line 1428
struct _xsltStackElem;

// tag-_xsltStylePreComp
// file /usr/include/libxslt/xsltInternals.h line 499
struct _xsltStylePreComp;

// tag-_xsltStylesheet
// file /usr/include/libxslt/xsltInternals.h line 276
struct _xsltStylesheet;

// tag-_xsltTemplate
// file /usr/include/libxslt/xsltInternals.h line 272
struct _xsltTemplate;

// tag-_xsltTransformCache
// file /usr/include/libxslt/xsltInternals.h line 1644
struct _xsltTransformCache;

// tag-_xsltTransformContext
// file /usr/include/libxslt/xsltInternals.h line 389
struct _xsltTransformContext;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-auth_client_tag
// file auth.h line 41
struct auth_client_tag;

// tag-auth_tag
// file auth.h line 21
struct auth_tag;

// tag-avl_node_tag
// file avl/avl.h line 26
struct avl_node_tag;

// tag-client_queue_tag
// file connection.c line 86
struct client_queue_tag;

// tag-connection_tag
// file connection.h line 32
struct connection_tag;

// tag-ebml_client_data_st
// file format_ebml.c line 43
struct ebml_client_data_st;

// tag-ebml_source_state_st
// file format_ebml.h line 23
struct ebml_source_state_st;

// tag-ebml_st
// file format_ebml.h line 22
struct ebml_st;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-http_parser_tag
// file httpp/httpp.h line 39
struct http_parser_tag;

// tag-http_var_tag
// file httpp/httpp.h line 29
struct http_var_tag;

// tag-http_varlist_tag
// file httpp/httpp.h line 34
struct http_varlist_tag;

// tag-httpp_request_type_tag
// file httpp/httpp.h line 24
enum httpp_request_type_tag { httpp_req_none=0, httpp_req_get=1, httpp_req_post=2, httpp_req_put=3, httpp_req_head=4, httpp_req_source=5, httpp_req_play=6, httpp_req_stats=7, httpp_req_unknown=8 };

// tag-ice_config_dir_tag
// file cfgfile.h line 55
struct ice_config_dir_tag;

// tag-ice_config_http_header_tag
// file cfgfile.h line 40
struct ice_config_http_header_tag;

// tag-ice_config_tag
// file connection.h line 30
struct ice_config_tag;

// tag-ice_global_tag
// file global.h line 27
struct ice_global_tag;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 379
struct linger;

// tag-log_tag
// file log.c line 57
struct log_tag;

// tag-ogg_client
// file format_ogg.c line 67
struct ogg_client;

// tag-ogg_codec_tag
// file format_ogg.h line 32
struct ogg_codec_tag;

// tag-ogg_state_tag
// file format_ogg.h line 25
struct ogg_state_tag;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-source_tag
// file auth.h line 20
struct source_tag;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-theora_comment
// file /usr/include/theora/theora.h line 275
struct theora_comment;

// tag-thread_start_tag
// file thread.c line 74
struct thread_start_tag;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-vorbis_codec_tag
// file format_vorbis.c line 38
struct vorbis_codec_tag;

// tag-vorbis_comment
// file /usr/include/vorbis/codec.h line 140
struct vorbis_comment;

// tag-vorbis_info
// file /usr/include/vorbis/codec.h line 28
struct vorbis_info;

// tag-yp_server
// file yp.c line 40
struct yp_server;

// tag-ypdata_tag
// file yp.c line 49
struct ypdata_tag;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// MD5Final
// file md5.c line 136
void MD5Final(unsigned char *digest, struct MD5Context *ctx);
// MD5Init
// file md5.c line 68
void MD5Init(struct MD5Context *ctx);
// MD5Transform
// file md5.c line 197
static void MD5Transform(unsigned int *buf, const unsigned int *in);
// MD5Update
// file md5.c line 83
void MD5Update(struct MD5Context *ctx, const unsigned char *buf, unsigned int len);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __format_time
// file stats.c line 589
static inline void __format_time(char *buffer, unsigned long int len, const char *format);
// __setup_empty_script_environment
// file source.c line 1326
static inline void __setup_empty_script_environment(void);
// __vsnprintf
// file log.c line 422
static void __vsnprintf(char *str, unsigned long int size, const char *format, __builtin_va_list ap);
// __xmlLoadExtDtdDefaultValue
// file /usr/include/libxml2/libxml/globals.h line 419
signed int * __xmlLoadExtDtdDefaultValue(void);
// _accept_connection
// file connection.c line 530
static struct connection_tag * _accept_connection(signed int duration);
// _add_connection
// file connection.c line 573
static void _add_connection(struct client_queue_tag *node);
// _add_event_to_queue
// file stats.c line 773
static void _add_event_to_queue(struct _stats_event_tag *event, struct _event_queue_tag *queue);
// _add_request_queue
// file connection.c line 703
static void _add_request_queue(struct client_queue_tag *node);
// _add_server
// file cfgfile.c line 1291
static void _add_server(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _block_signals
// file thread.c line 215
static void _block_signals(void);
// _build_headers
// file util.c line 534
static inline char * _build_headers(signed int status, struct ice_config_tag *config, struct source_tag *source);
// _build_headers_loop
// file util.c line 495
static inline void _build_headers_loop(char **ret, unsigned long int *len, struct ice_config_http_header_tag *header, signed int status);
// _catch_signals
// file thread.c line 241
static void _catch_signals(void);
// _ch_root_uid_setup
// file main.c line 352
static void _ch_root_uid_setup(void);
// _check_pass_http
// file connection.c line 907
static signed int _check_pass_http(struct http_parser_tag *parser, const char *correctuser, const char *correctpass);
// _check_pass_ice
// file connection.c line 960
static signed int _check_pass_ice(struct http_parser_tag *parser, const char *correctpass);
// _check_pass_icy
// file connection.c line 946
static signed int _check_pass_icy(struct http_parser_tag *parser, const char *correctpass);
// _compare_clients
// file source.c line 925
static signed int _compare_clients(void *compare_arg, void *a, void *b);
// _compare_mappings
// file fserve.c line 708
static signed int _compare_mappings(void *arg, void *a, void *b);
// _compare_source_stats
// file stats.c line 1010
static signed int _compare_source_stats(void *arg, void *a, void *b);
// _compare_stats
// file stats.c line 1002
static signed int _compare_stats(void *arg, void *a, void *b);
// _compare_threads
// file thread.c line 767
static signed int _compare_threads(void *compare_arg, void *a, void *b);
// _compare_vars
// file httpp.c line 547
static signed int _compare_vars(void *compare_arg, void *a, void *b);
// _copy_event
// file stats.c line 415
static struct _stats_event_tag * _copy_event(struct _stats_event_tag *event);
// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void);
// _curl_easy_setopt_err_CURLSH_link1
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH_link1(void);
// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void);
// _curl_easy_setopt_err_FILE_link1
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE_link1(void);
// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void);
// _curl_easy_setopt_err_cb_data_link1
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data_link1(void);
// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void);
// _curl_easy_setopt_err_conv_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb_link1(void);
// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void);
// _curl_easy_setopt_err_curl_httpost_link1
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost_link1(void);
// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void);
// _curl_easy_setopt_err_curl_off_t_link1
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t_link1(void);
// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void);
// _curl_easy_setopt_err_curl_slist_link1
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist_link1(void);
// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void);
// _curl_easy_setopt_err_debug_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb_link1(void);
// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void);
// _curl_easy_setopt_err_error_buffer_link1
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer_link1(void);
// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void);
// _curl_easy_setopt_err_ioctl_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb_link1(void);
// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void);
// _curl_easy_setopt_err_long_link1
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long_link1(void);
// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void);
// _curl_easy_setopt_err_opensocket_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb_link1(void);
// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void);
// _curl_easy_setopt_err_postfields_link1
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields_link1(void);
// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void);
// _curl_easy_setopt_err_progress_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb_link1(void);
// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void);
// _curl_easy_setopt_err_read_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb_link1(void);
// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void);
// _curl_easy_setopt_err_seek_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb_link1(void);
// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void);
// _curl_easy_setopt_err_sockopt_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb_link1(void);
// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void);
// _curl_easy_setopt_err_ssl_ctx_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb_link1(void);
// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void);
// _curl_easy_setopt_err_string_link1
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string_link1(void);
// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void);
// _curl_easy_setopt_err_write_callback_link1
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback_link1(void);
// _delete_mapping
// file fserve.c line 699
static signed int _delete_mapping(void *mapping);
// _dump_stats_to_doc
// file stats.c line 815
static struct _xmlNode * _dump_stats_to_doc(struct _xmlNode *root, const char *show_mount, signed int hidden);
// _fatal_error
// file main.c line 80
static void _fatal_error(const char *perr);
// _find_node
// file stats.c line 365
static struct _stats_node_tag * _find_node(struct _avl_tree *stats_tree, const char *name);
// _find_source
// file stats.c line 392
static struct _stats_source_tag * _find_source(struct _avl_tree *source_tree, const char *source);
// _free_client
// file source.c line 944
static signed int _free_client(void *key);
// _free_event
// file stats.c line 1038
static void _free_event(struct _stats_event_tag *event);
// _free_source_stats
// file stats.c line 1028
static signed int _free_source_stats(void *key);
// _free_stats
// file stats.c line 1018
static signed int _free_stats(void *key);
// _free_thread
// file thread.c line 799
static signed int _free_thread(void *key);
// _free_user
// file auth_htpasswd.c line 95
static signed int _free_user(void *key);
// _free_vars
// file httpp.c line 557
static signed int _free_vars(void *key);
// _get_connection
// file connection.c line 585
static struct client_queue_tag * _get_connection(void);
// _get_event_from_queue
// file stats.c line 780
static struct _stats_event_tag * _get_event_from_queue(struct _event_queue_tag *queue);
// _get_log_id
// file log.c line 610
static signed int _get_log_id(void);
// _get_stats
// file stats.c line 284
static char * _get_stats(const char *source, const char *name);
// _handle_connection
// file connection.c line 1311
static void _handle_connection(void);
// _handle_get_request
// file connection.c line 1137
static void _handle_get_request(struct _client_tag *client, char *passed_uri);
// _handle_shoutcast_compatible
// file connection.c line 1190
static void _handle_shoutcast_compatible(struct client_queue_tag *node);
// _handle_source_request
// file connection.c line 1048
static void _handle_source_request(struct _client_tag *client, const char *uri);
// _handle_stats_request
// file connection.c line 1119
static void _handle_stats_request(struct _client_tag *client, char *uri);
// _isip
// file resolver.c line 62
static signed int _isip(const char *what);
// _lock_logger
// file log.c line 642
static void _lock_logger(void);
// _log_open
// file log.c line 86
static signed int _log_open(signed int id);
// _lowercase
// file httpp.c line 538
static char * _lowercase(char *str);
// _make_event_from_node
// file stats.c line 755
static struct _stats_event_tag * _make_event_from_node(struct _stats_node_tag *node, char *source);
// _merge_mounts_all
// file cfgfile.c line 1413
static inline void _merge_mounts_all(struct ice_config_tag *c);
// _mutex_create
// file thread.c line 326
static void _mutex_create(struct anonymous_4 *mutex);
// _mutex_lock
// file thread.c line 717
static void _mutex_lock(struct anonymous_4 *mutex);
// _mutex_unlock
// file thread.c line 722
static void _mutex_unlock(struct anonymous_4 *mutex);
// _next_connection_id
// file connection.c line 182
static unsigned long int _next_connection_id(void);
// _parse_audio_info
// file source.c line 957
static void _parse_audio_info(struct source_tag *source, const char *s);
// _parse_authentication
// file cfgfile.c line 1045
static void _parse_authentication(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _parse_config_opts
// file main.c line 153
static signed int _parse_config_opts(signed int argc, char **argv, char *filename, signed int size);
// _parse_directory
// file cfgfile.c line 1086
static void _parse_directory(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _parse_http_headers
// file cfgfile.c line 834
static void _parse_http_headers(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_http_header_tag **http_headers);
// _parse_limits
// file cfgfile.c line 588
static void _parse_limits(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _parse_listen_socket
// file cfgfile.c line 973
static void _parse_listen_socket(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _parse_logging
// file cfgfile.c line 1216
static void _parse_logging(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _parse_mount
// file cfgfile.c line 638
static void _parse_mount(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _parse_paths
// file cfgfile.c line 1123
static void _parse_paths(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _parse_relay
// file cfgfile.c line 892
static void _parse_relay(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _parse_root
// file cfgfile.c line 453
static void _parse_root(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _parse_security
// file cfgfile.c line 1257
static void _parse_security(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration);
// _print_usage
// file main.c line 91
static void _print_usage(void);
// _register_listener
// file stats.c line 863
static void _register_listener(struct _event_listener_tag *listener);
// _send_event_to_client
// file stats.c line 795
static signed int _send_event_to_client(struct _stats_event_tag *event, struct _client_tag *client);
// _server_proc
// file main.c line 336
static void _server_proc(void);
// _server_proc_init
// file main.c line 308
static signed int _server_proc_init(void);
// _set_defaults
// file cfgfile.c line 407
static void _set_defaults(struct ice_config_tag *configuration);
// _sig_die
// file sighandler.c line 68
void _sig_die(signed int signo);
// _sig_hup
// file sighandler.c line 56
void _sig_hup(signed int signo);
// _sig_ignore
// file sighandler.c line 51
void _sig_ignore(signed int signo);
// _slave_thread
// file slave.c line 725
static void * _slave_thread(void *arg);
// _start_listening
// file main.c line 294
static signed int _start_listening(void);
// _start_logging
// file main.c line 213
static signed int _start_logging(void);
// _start_logging_stdout
// file main.c line 203
static signed int _start_logging_stdout(void);
// _start_routine
// file thread.c line 635
static void * _start_routine(void *arg);
// _start_routine::1::start_routine_object
//
void * start_routine_object(void *);
// _stats_thread
// file stats.c line 664
static void * _stats_thread(void *arg);
// _stop_logging
// file main.c line 103
static void _stop_logging(void);
// _unlock_logger
// file log.c line 651
static void _unlock_logger(void);
// _unregister_listener
// file stats.c line 738
static void _unregister_listener(struct _event_listener_tag *listener);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous, unsigned int *);
// accept_ip_address
// file connection.c line 384
static signed int accept_ip_address(char *ip);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_audio_packet
// file format_vorbis.c line 127
static void add_audio_packet(struct vorbis_codec_tag *source_vorbis, struct anonymous_14 *packet);
// add_authenticated_listener
// file auth.c line 433
static signed int add_authenticated_listener(const char *mount, struct _mount_proxy *mountinfo, struct _client_tag *client);
// add_listener_to_source
// file auth.c line 378
static signed int add_listener_to_source(struct source_tag *source, struct _client_tag *client);
// add_pending_yp
// file yp.c line 669
static void add_pending_yp(struct yp_server *server);
// add_yp_info
// file yp.c line 812
static void add_yp_info(struct ypdata_tag *yp, void *info, signed int type);
// admin_build_sourcelist
// file admin.c line 198
struct _xmlDoc * admin_build_sourcelist(const char *mount);
// admin_get_command
// file admin.c line 113
signed int admin_get_command(const char *command);
// admin_handle_general_request
// file admin.c line 492
static void admin_handle_general_request(struct _client_tag *client, signed int command);
// admin_handle_mount_request
// file admin.c line 526
static void admin_handle_mount_request(struct _client_tag *client, struct source_tag *source, signed int command);
// admin_handle_request
// file admin.h line 26
void admin_handle_request(struct _client_tag *client, const char *uri);
// admin_send_response
// file admin.h line 27
void admin_send_response(struct _xmlDoc *doc, struct _client_tag *client, signed int response, const char *xslt_template);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atoll
// file /usr/include/stdlib.h line 157
extern signed long long int atoll(const char *);
// auth_add_listener
// file auth.h line 89
void auth_add_listener(const char *mount, struct _client_tag *client);
// auth_client_free
// file auth.c line 159
static void auth_client_free(struct auth_client_tag *auth_user);
// auth_client_setup
// file auth.c line 44
static struct auth_client_tag * auth_client_setup(const char *mount, struct _client_tag *client);
// auth_get_authenticator
// file auth.h line 95
struct auth_tag * auth_get_authenticator(struct _xmlNode *node);
// auth_get_htpasswd_auth
// file auth_htpasswd.h line 20
signed int auth_get_htpasswd_auth(struct auth_tag *authenticator, struct _config_options *options);
// auth_get_url_auth
// file auth_url.h line 20
signed int auth_get_url_auth(struct auth_tag *authenticator, struct _config_options *options);
// auth_initialise
// file auth.h line 92
void auth_initialise(void);
// auth_new_listener
// file auth.c line 194
static void auth_new_listener(struct auth_tag *auth, struct auth_client_tag *auth_user);
// auth_postprocess_listener
// file auth.c line 483
signed int auth_postprocess_listener(struct auth_client_tag *auth_user);
// auth_postprocess_source
// file auth.c line 505
static void auth_postprocess_source(struct auth_client_tag *auth_user);
// auth_release
// file auth.h line 96
void auth_release(struct auth_tag *authenticator);
// auth_release_listener
// file auth.h line 90
signed int auth_release_listener(struct _client_tag *client);
// auth_remove_listener
// file auth.c line 228
static void auth_remove_listener(struct auth_tag *auth, struct auth_client_tag *auth_user);
// auth_run_thread
// file auth.c line 283
static void * auth_run_thread(void *arg);
// auth_shutdown
// file auth.h line 93
void auth_shutdown(void);
// auth_stream_authenticate
// file auth.h line 105
signed int auth_stream_authenticate(struct _client_tag *client, const char *mount, struct _mount_proxy *mountinfo);
// auth_stream_end
// file auth.h line 102
void auth_stream_end(struct _mount_proxy *mountinfo, const char *mount);
// auth_stream_start
// file auth.h line 99
void auth_stream_start(struct _mount_proxy *mountinfo, const char *mount);
// auth_url_adduser
// file auth_url.c line 571
static enum anonymous_19 auth_url_adduser(struct auth_tag *auth, const char *username, const char *password);
// auth_url_clear
// file auth_url.c line 108
static void auth_url_clear(struct auth_tag *self);
// auth_url_deleteuser
// file auth_url.c line 576
static enum anonymous_19 auth_url_deleteuser(struct auth_tag *auth, const char *username);
// auth_url_listuser
// file auth_url.c line 581
static enum anonymous_19 auth_url_listuser(struct auth_tag *auth, struct _xmlNode *srcnode);
// avl_delete
// file avl/avl.h line 119
signed int avl_delete(struct _avl_tree *tree, void *key, signed int (*free_key_fun)(void *));
// avl_delete::free_key_fun_object
//
signed int free_key_fun_object(void *);
// avl_get_by_index
// file avl.c line 299
signed int avl_get_by_index(struct _avl_tree *tree, unsigned long int index, void **value_address);
// avl_get_by_key
// file avl/avl.h line 131
signed int avl_get_by_key(struct _avl_tree *tree, void *key, void **value_address);
// avl_get_first
// file avl/avl.h line 173
struct avl_node_tag * avl_get_first(struct _avl_tree *tree);
// avl_get_index_by_key
// file avl.c line 772
static struct avl_node_tag * avl_get_index_by_key(struct _avl_tree *tree, void *key, unsigned long int *index);
// avl_get_item_by_key_least
// file avl.c line 951
signed int avl_get_item_by_key_least(struct _avl_tree *tree, void *key, void **value_address);
// avl_get_item_by_key_most
// file avl.c line 907
signed int avl_get_item_by_key_most(struct _avl_tree *tree, void *key, void **value_address);
// avl_get_next
// file avl/avl.h line 177
struct avl_node_tag * avl_get_next(struct avl_node_tag *node);
// avl_get_prev
// file avl.c line 679
struct avl_node_tag * avl_get_prev(struct avl_node_tag *node);
// avl_get_span_by_key
// file avl.c line 813
signed int avl_get_span_by_key(struct _avl_tree *tree, void *key, unsigned long int *low, unsigned long int *high);
// avl_get_span_by_two_keys
// file avl.c line 856
signed int avl_get_span_by_two_keys(struct _avl_tree *tree, void *low_key, void *high_key, unsigned long int *low, unsigned long int *high);
// avl_insert
// file avl/avl.h line 114
signed int avl_insert(struct _avl_tree *ob, void *key);
// avl_iterate_index_range
// file avl.c line 728
signed int avl_iterate_index_range(struct _avl_tree *tree, signed int (*iter_fun)(unsigned long int, void *, void *), unsigned long int low, unsigned long int high, void *iter_arg);
// avl_iterate_index_range::iter_fun_object
//
signed int iter_fun_object(unsigned long int, void *, void *);
// avl_iterate_inorder
// file avl.c line 652
signed int avl_iterate_inorder(struct _avl_tree *tree, signed int (*iter_fun)(void *, void *), void *iter_arg);
// avl_iterate_inorder::iter_fun_object
//
signed int iter_fun_object(void *, void *);
// avl_iterate_inorder_helper
// file avl.c line 627
static signed int avl_iterate_inorder_helper(struct avl_node_tag *node, signed int (*iter_fun)(void *, void *), void *iter_arg);
// avl_iterate_inorder_helper::iter_fun_object
//
signed int iter_fun_object(void *, void *);
// avl_node_new
// file avl.c line 42
struct avl_node_tag * avl_node_new(void *key, struct avl_node_tag *parent);
// avl_print_tree
// file avl.c line 1150
void avl_print_tree(struct _avl_tree *tree, signed int (*key_printer)(char *, void *));
// avl_print_tree::key_printer_object
//
signed int key_printer_object(char *, void *);
// avl_tree_free
// file avl/avl.h line 109
void avl_tree_free(struct _avl_tree *tree, signed int (*free_key_fun)(void *));
// avl_tree_free::free_key_fun_object
//
signed int free_key_fun_object(void *);
// avl_tree_free_helper
// file avl.c line 90
static void avl_tree_free_helper(struct avl_node_tag *node, signed int (*free_key_fun)(void *));
// avl_tree_free_helper::free_key_fun_object
//
signed int free_key_fun_object(void *);
// avl_tree_new
// file avl/avl.h line 106
struct _avl_tree * avl_tree_new(signed int (*compare_fun)(void *, void *, void *), void *compare_arg);
// avl_tree_new::compare_fun_object
//
signed int compare_fun_object(void *, void *, void *);
// avl_tree_rlock
// file avl/avl.h line 194
void avl_tree_rlock(struct _avl_tree *tree);
// avl_tree_unlock
// file avl/avl.h line 196
void avl_tree_unlock(struct _avl_tree *tree);
// avl_tree_wlock
// file avl/avl.h line 195
void avl_tree_wlock(struct _avl_tree *tree);
// avl_verify
// file avl.c line 1050
signed int avl_verify(struct _avl_tree *tree);
// avl_verify_balance
// file avl.c line 995
static signed long int avl_verify_balance(struct avl_node_tag *node);
// avl_verify_parent
// file avl.c line 1013
static void avl_verify_parent(struct avl_node_tag *node, struct avl_node_tag *parent);
// avl_verify_rank
// file avl.c line 1027
static signed long int avl_verify_rank(struct avl_node_tag *node);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous, unsigned int);
// build_event
// file stats.c line 100
static struct _stats_event_tag * build_event(const char *source, const char *name, const char *value);
// byteReverse
// file md5.c line 51
static void byteReverse(unsigned char *buf, unsigned int longs);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_duplicate_logins
// file auth.c line 331
static signed int check_duplicate_logins(struct source_tag *source, struct _client_tag *client, struct auth_tag *auth);
// check_relay_stream
// file slave.c line 392
static void check_relay_stream(struct _relay_server *relay);
// check_servers
// file yp.c line 615
static void check_servers(void);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// client_check_source_auth
// file client.h line 82
signed int client_check_source_auth(struct _client_tag *client, const char *mount);
// client_create
// file client.h line 71
signed int client_create(struct _client_tag **c_ptr, struct connection_tag *con, struct http_parser_tag *parser);
// client_destroy
// file client.h line 72
void client_destroy(struct _client_tag *client);
// client_read_bytes
// file client.h line 80
signed int client_read_bytes(struct _client_tag *client, void *buf, unsigned int len);
// client_send_100
// file client.h line 73
void client_send_100(struct _client_tag *client);
// client_send_400
// file client.h line 77
void client_send_400(struct _client_tag *client, const char *message);
// client_send_401
// file client.h line 75
void client_send_401(struct _client_tag *client);
// client_send_403
// file client.h line 76
void client_send_403(struct _client_tag *client, const char *message);
// client_send_404
// file client.h line 74
void client_send_404(struct _client_tag *client, const char *message);
// client_send_500
// file client.c line 238
void client_send_500(struct _client_tag *client, const char *message);
// client_send_bytes
// file client.h line 79
signed int client_send_bytes(struct _client_tag *client, const void *buf, unsigned int len);
// client_send_error
// file client.c line 186
static void client_send_error(struct _client_tag *client, signed int status, signed int plain, const char *message);
// client_set_queue
// file client.h line 81
void client_set_queue(struct _client_tag *client, struct _refbuf_tag *refbuf);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// command_buildm3u
// file admin.c line 745
static void command_buildm3u(struct _client_tag *client, const char *mount);
// command_fallback
// file admin.c line 938
static void command_fallback(struct _client_tag *client, struct source_tag *source, signed int response);
// command_kill_client
// file admin.c line 894
static void command_kill_client(struct _client_tag *client, struct source_tag *source, signed int response);
// command_kill_source
// file admin.c line 875
static void command_kill_source(struct _client_tag *client, struct source_tag *source, signed int response);
// command_list_mounts
// file admin.c line 1076
static void command_list_mounts(struct _client_tag *client, signed int response);
// command_manageauth
// file admin.c line 785
static void command_manageauth(struct _client_tag *client, struct source_tag *source, signed int response);
// command_metadata
// file admin.c line 955
static void command_metadata(struct _client_tag *client, struct source_tag *source, signed int response);
// command_move_clients
// file admin.c line 630
static void command_move_clients(struct _client_tag *client, struct source_tag *source, signed int response);
// command_shoutcast_metadata
// file admin.c line 1030
static void command_shoutcast_metadata(struct _client_tag *client, struct source_tag *source);
// command_show_listeners
// file admin.c line 692
static void command_show_listeners(struct _client_tag *client, struct source_tag *source, signed int response);
// command_stats
// file admin.c line 1065
static void command_stats(struct _client_tag *client, const char *mount, signed int response);
// command_updatemetadata
// file admin.c line 1112
static void command_updatemetadata(struct _client_tag *client, struct source_tag *source, signed int response);
// compare_ip
// file connection.c line 126
static signed int compare_ip(void *arg, void *a, void *b);
// compare_users
// file auth_htpasswd.c line 86
static signed int compare_users(void *arg, void *a, void *b);
// complete_buffer
// file format_ogg.c line 342
static struct _refbuf_tag * complete_buffer(struct source_tag *source, struct _refbuf_tag *refbuf);
// complete_read
// file format_mp3.c line 468
static signed int complete_read(struct source_tag *source);
// config_clear
// file cfgfile.c line 229
void config_clear(struct ice_config_tag *c);
// config_clear_http_header
// file cfgfile.c line 128
static void config_clear_http_header(struct ice_config_http_header_tag *header);
// config_clear_listener
// file cfgfile.c line 216
struct _listener_t * config_clear_listener(struct _listener_t *listener);
// config_clear_mount
// file cfgfile.c line 180
static void config_clear_mount(struct _mount_proxy *mount);
// config_copy_http_header
// file cfgfile.c line 140
static inline struct ice_config_http_header_tag * config_copy_http_header(struct ice_config_http_header_tag *header);
// config_find_mount
// file cfgfile.c line 1429
struct _mount_proxy * config_find_mount(struct ice_config_tag *config, const char *mount, enum _mount_type type);
// config_get_config
// file cfgfile.c line 385
struct ice_config_tag * config_get_config(void);
// config_get_config_unlocked
// file cfgfile.c line 402
struct ice_config_tag * config_get_config_unlocked(void);
// config_get_listen_sock
// file cfgfile.c line 1463
struct _listener_t * config_get_listen_sock(struct ice_config_tag *config, struct connection_tag *con);
// config_grab_config
// file cfgfile.c line 391
struct ice_config_tag * config_grab_config(void);
// config_init_configuration
// file cfgfile.c line 122
void config_init_configuration(struct ice_config_tag *configuration);
// config_initial_parse_file
// file cfgfile.c line 328
signed int config_initial_parse_file(const char *filename);
// config_initialize
// file cfgfile.c line 111
void config_initialize(void);
// config_locks
// file cfgfile.c line 375
struct anonymous_17 * config_locks(void);
// config_parse_cmdline
// file cfgfile.c line 370
signed int config_parse_cmdline(signed int arg, char **argv);
// config_parse_file
// file cfgfile.c line 334
signed int config_parse_file(const char *filename, struct ice_config_tag *configuration);
// config_release_config
// file cfgfile.c line 380
void config_release_config(void);
// config_set_config
// file cfgfile.c line 398
void config_set_config(struct ice_config_tag *config);
// config_shutdown
// file cfgfile.c line 115
void config_shutdown(void);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous, unsigned int);
// connection_accept_loop
// file connection.h line 57
void connection_accept_loop(void);
// connection_check_admin_pass
// file connection.c line 974
signed int connection_check_admin_pass(struct http_parser_tag *parser);
// connection_check_pass
// file connection.c line 1016
signed int connection_check_pass(struct http_parser_tag *parser, const char *user, const char *pass);
// connection_check_relay_pass
// file connection.c line 996
signed int connection_check_relay_pass(struct http_parser_tag *parser);
// connection_close
// file connection.c line 1490
void connection_close(struct connection_tag *con);
// connection_complete_source
// file connection.c line 800
signed int connection_complete_source(struct source_tag *source, signed int response);
// connection_create
// file connection.c line 416
struct connection_tag * connection_create(signed int sock, signed int serversock, char *ip);
// connection_initialize
// file connection.h line 55
void connection_initialize(void);
// connection_read
// file connection.c line 297
static signed int connection_read(struct connection_tag *con, void *buf, unsigned long int len);
// connection_send
// file connection.c line 307
static signed int connection_send(struct connection_tag *con, const void *buf, unsigned long int len);
// connection_setup_sockets
// file connection.h line 58
signed int connection_setup_sockets(struct ice_config_tag *config);
// connection_shutdown
// file connection.h line 56
void connection_shutdown(void);
// connection_uses_ssl
// file connection.c line 436
void connection_uses_ssl(struct connection_tag *con);
// copy_ogg_packet
// file format_vorbis.c line 105
static struct anonymous_14 * copy_ogg_packet(struct anonymous_14 *packet);
// create_locks
// file cfgfile.c line 101
static void create_locks(void);
// create_log_entry
// file log.c line 361
static signed int create_log_entry(signed int log_id, const char *pre, const char *line);
// create_ogg_client_data
// file format_ogg.c line 459
static signed int create_ogg_client_data(struct source_tag *source, struct _client_tag *client);
// create_yp_entry
// file yp.c line 555
static struct ypdata_tag * create_yp_entry(const char *mount);
// curl_easy_cleanup
// file /usr/include/curl/easy.h line 31
void curl_easy_cleanup(void *);
// curl_easy_init
// file /usr/include/curl/easy.h line 28
void * curl_easy_init(void);
// curl_easy_perform
// file /usr/include/curl/easy.h line 30
enum anonymous_34 curl_easy_perform(void *);
// curl_easy_setopt
// file /usr/include/curl/easy.h line 29
enum anonymous_34 curl_easy_setopt(void *, enum anonymous_32, ...);
// curl_global_cleanup
// file /usr/include/curl/curl.h line 2044
void curl_global_cleanup(void);
// curl_global_init
// file /usr/include/curl/curl.h line 2014
enum anonymous_34 curl_global_init(signed long int);
// default_key_printer
// file avl.c line 1075
static signed int default_key_printer(char *buffer, void *key);
// delete_marked_yp
// file yp.c line 692
static void delete_marked_yp(struct yp_server *server);
// destroy_yp_server
// file yp.c line 179
static void destroy_yp_server(struct yp_server *server);
// do_yp_add
// file yp.c line 370
static signed int do_yp_add(struct ypdata_tag *yp, char *s, unsigned int len);
// do_yp_remove
// file yp.c line 347
static signed int do_yp_remove(struct ypdata_tag *yp, char *s, unsigned int len);
// do_yp_touch
// file yp.c line 427
static signed int do_yp_touch(struct ypdata_tag *yp, char *s, unsigned int len);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// ebml_create
// file format_ebml.c line 288
static struct ebml_st * ebml_create();
// ebml_create_client_data
// file format_ebml.c line 212
static signed int ebml_create_client_data(struct source_tag *source, struct _client_tag *client);
// ebml_destroy
// file format_ebml.c line 278
static void ebml_destroy(struct ebml_st *ebml);
// ebml_free_client_data
// file format_ebml.c line 234
static void ebml_free_client_data(struct _client_tag *client);
// ebml_free_plugin
// file format_ebml.c line 107
static void ebml_free_plugin(struct _format_plugin_tag *plugin);
// ebml_get_buffer
// file format_ebml.c line 160
static struct _refbuf_tag * ebml_get_buffer(struct source_tag *source);
// ebml_last_was_sync
// file format_ebml.c line 387
static signed int ebml_last_was_sync(struct ebml_st *ebml);
// ebml_read
// file format_ebml.c line 329
static signed int ebml_read(struct ebml_st *ebml, char *buffer, signed int len);
// ebml_read_space
// file format_ebml.c line 305
static signed int ebml_read_space(struct ebml_st *ebml);
// ebml_write_buf_to_client
// file format_ebml.c line 143
static signed int ebml_write_buf_to_client(struct _client_tag *client);
// ebml_write_buf_to_file
// file format_ebml.c line 253
static void ebml_write_buf_to_file(struct source_tag *source, struct _refbuf_tag *refbuf);
// ebml_write_buf_to_file_fail
// file format_ebml.c line 245
static void ebml_write_buf_to_file_fail(struct source_tag *source);
// ebml_write_buffer
// file format_ebml.c line 406
static char * ebml_write_buffer(struct ebml_st *ebml, signed int len);
// ebml_wrote
// file format_ebml.c line 414
static signed int ebml_wrote(struct ebml_st *ebml, signed int len);
// endhostent
// file /usr/include/netdb.h line 123
extern void endhostent(void);
// event_config_read
// file event.h line 19
void event_config_read(void *arg);
// evict_cache_entry
// file xslt.c line 123
static signed int evict_cache_entry(void);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// filter_shoutcast_metadata
// file format_mp3.c line 171
static void filter_shoutcast_metadata(struct source_tag *source, char *metadata, unsigned int meta_len);
// find_client_start
// file format.c line 114
static void find_client_start(struct source_tag *source, struct _client_tag *client);
// find_yp_mount
// file yp.c line 196
static struct ypdata_tag * find_yp_mount(struct ypdata_tag *mounts, const char *mount);
// find_yp_server
// file yp.c line 157
static struct yp_server * find_yp_server(const char *url);
// flac_codec_free
// file format_flac.c line 35
static void flac_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// fnmatch
// file /usr/include/fnmatch.h line 56
extern signed int fnmatch(const char *, const char *, signed int);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// format_advance_queue
// file format.c line 270
signed int format_advance_queue(struct source_tag *source, struct _client_tag *client);
// format_check_file_buffer
// file format.h line 67
signed int format_check_file_buffer(struct source_tag *source, struct _client_tag *client);
// format_check_http_buffer
// file format.h line 66
signed int format_check_http_buffer(struct source_tag *source, struct _client_tag *client);
// format_ebml_get_plugin
// file format_ebml.h line 33
signed int format_ebml_get_plugin(struct source_tag *source);
// format_generic_write_to_client
// file format.h line 64
signed int format_generic_write_to_client(struct _client_tag *client);
// format_get_plugin
// file format.h line 62
signed int format_get_plugin(enum _format_type_tag type, struct source_tag *source);
// format_get_type
// file format.h line 60
enum _format_type_tag format_get_type(const char *contenttype);
// format_mp3_apply_settings
// file format_mp3.c line 200
static void format_mp3_apply_settings(struct _client_tag *client, struct _format_plugin_tag *format, struct _mount_proxy *mount);
// format_mp3_create_client_data
// file format_mp3.c line 659
static signed int format_mp3_create_client_data(struct source_tag *source, struct _client_tag *client);
// format_mp3_free_plugin
// file format_mp3.c line 447
static void format_mp3_free_plugin(struct _format_plugin_tag *self);
// format_mp3_get_plugin
// file format_mp3.h line 42
signed int format_mp3_get_plugin(struct source_tag *source);
// format_mp3_write_buf_to_client
// file format_mp3.c line 371
static signed int format_mp3_write_buf_to_client(struct _client_tag *client);
// format_ogg_attach_header
// file format_ogg.c line 89
void format_ogg_attach_header(struct ogg_state_tag *ogg_info, struct anonymous_3 *page);
// format_ogg_free_headers
// file format_ogg.c line 113
void format_ogg_free_headers(struct ogg_state_tag *ogg_info);
// format_ogg_free_plugin
// file format_ogg.c line 189
static void format_ogg_free_plugin(struct _format_plugin_tag *plugin);
// format_ogg_get_plugin
// file format_ogg.h line 68
signed int format_ogg_get_plugin(struct source_tag *source);
// format_prepare_headers
// file format.c line 290
static signed int format_prepare_headers(struct source_tag *source, struct _client_tag *client);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_filtered_ip
// file connection.c line 135
static signed int free_filtered_ip(void *x);
// free_mp3_client_data
// file format_mp3.c line 714
static void free_mp3_client_data(struct _client_tag *client);
// free_ogg_client_data
// file format_ogg.c line 475
static void free_ogg_client_data(struct _client_tag *client);
// free_ogg_codecs
// file format_ogg.c line 133
static void free_ogg_codecs(struct ogg_state_tag *ogg_info);
// free_ogg_packet
// file format_vorbis.c line 73
static void free_ogg_packet(struct anonymous_14 *packet);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fseeko
// file /usr/include/stdio.h line 773
extern signed int fseeko(struct _IO_FILE *, signed long int, signed int);
// fserv_thread_function
// file fserve.c line 267
static void * fserv_thread_function(void *arg);
// fserve_add_client
// file fserve.h line 35
signed int fserve_add_client(struct _client_tag *client, struct _IO_FILE *file);
// fserve_add_client_callback
// file fserve.h line 36
void fserve_add_client_callback(struct _client_tag *client, void (*callback)(struct _client_tag *, void *), void *arg);
// fserve_add_client_callback::callback_object
//
void callback_object(struct _client_tag *, void *);
// fserve_add_pending
// file fserve.c line 639
static void fserve_add_pending(struct _fserve_t *fclient);
// fserve_client_create
// file fserve.c line 400
signed int fserve_client_create(struct _client_tag *httpclient, const char *path);
// fserve_client_destroy
// file fserve.c line 380
static void fserve_client_destroy(struct _fserve_t *fclient);
// fserve_client_waiting
// file fserve.c line 141
signed int fserve_client_waiting(void);
// fserve_content_type
// file fserve.h line 37
char * fserve_content_type(const char *path);
// fserve_initialize
// file fserve.h line 32
void fserve_initialize(void);
// fserve_recheck_mime_types
// file fserve.c line 715
void fserve_recheck_mime_types(struct ice_config_tag *config);
// fserve_shutdown
// file fserve.h line 33
void fserve_shutdown(void);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_authenticator
// file auth.c line 594
static signed int get_authenticator(struct auth_tag *auth, struct _config_options *options);
// get_buffer_audio
// file format_vorbis.c line 145
static struct _refbuf_tag * get_buffer_audio(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// get_buffer_audio::1::get_ogg_page_object
//
signed int get_ogg_page_object(struct anonymous_2 *, struct anonymous_3 *);
// get_buffer_finished
// file format_vorbis.c line 186
static struct _refbuf_tag * get_buffer_finished(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// get_buffer_header
// file format_vorbis.c line 167
static struct _refbuf_tag * get_buffer_header(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// get_file_data
// file format.c line 150
static signed int get_file_data(struct _IO_FILE *intro, struct _client_tag *client);
// get_hash
// file auth_htpasswd.c line 71
static char * get_hash(const char *data, signed int len);
// get_line
// file util.h line 89
signed int get_line(struct _IO_FILE *file, char *buf, unsigned long int siz);
// get_next_buffer
// file source.c line 467
static struct _refbuf_tag * get_next_buffer(struct source_tag *source);
// get_ssl_certificate
// file connection.c line 286
static void get_ssl_certificate(struct ice_config_tag *config);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// global_initialize
// file global.h line 49
void global_initialize(void);
// global_lock
// file global.h line 51
void global_lock(void);
// global_shutdown
// file global.h line 50
void global_shutdown(void);
// global_unlock
// file global.h line 52
void global_unlock(void);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// handle_returned_data
// file auth_url.c line 175
static unsigned long int handle_returned_data(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream);
// handle_returned_data_link1
// file yp.c line 150
static signed int handle_returned_data_link1(void *ptr_link1, unsigned long int size_link1, unsigned long int nmemb_link1, void *stream_link1);
// handle_returned_header
// file auth_url.c line 141
static unsigned long int handle_returned_header(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream);
// handle_returned_header_link1
// file yp.c line 106
static signed int handle_returned_header_link1(void *ptr_link1, unsigned long int size_link1, unsigned long int nmemb_link1, void *stream_link1);
// hex
// file util.c line 177
static signed int hex(char c);
// hex_link1
// file httpp.c line 191
static signed int hex_link1(char c_link1);
// html_success
// file admin.c line 605
static void html_success(struct _client_tag *client, char *message);
// htpasswd_adduser
// file auth_htpasswd.c line 257
static enum anonymous_19 htpasswd_adduser(struct auth_tag *auth, const char *username, const char *password);
// htpasswd_auth
// file auth_htpasswd.c line 179
static enum anonymous_19 htpasswd_auth(struct auth_client_tag *auth_user);
// htpasswd_clear
// file auth_htpasswd.c line 60
static void htpasswd_clear(struct auth_tag *self);
// htpasswd_deleteuser
// file auth_htpasswd.c line 299
static enum anonymous_19 htpasswd_deleteuser(struct auth_tag *auth, const char *username);
// htpasswd_recheckfile
// file auth_htpasswd.c line 105
static void htpasswd_recheckfile(struct anonymous_20 *htpasswd);
// htpasswd_userlist
// file auth_htpasswd.c line 387
static enum anonymous_19 htpasswd_userlist(struct auth_tag *auth, struct _xmlNode *srcnode);
// httpp_clear
// file httpp.c line 521
void httpp_clear(struct http_parser_tag *parser);
// httpp_create_parser
// file httpp/httpp.h line 60
struct http_parser_tag * httpp_create_parser(void);
// httpp_deletevar
// file httpp.c line 433
void httpp_deletevar(struct http_parser_tag *parser, const char *name);
// httpp_destroy
// file httpp/httpp.h line 70
void httpp_destroy(struct http_parser_tag *parser);
// httpp_get_query_param
// file httpp/httpp.h line 69
const char * httpp_get_query_param(struct http_parser_tag *parser, const char *name);
// httpp_getvar
// file httpp/httpp.h line 67
const char * httpp_getvar(struct http_parser_tag *parser, const char *name);
// httpp_initialize
// file httpp/httpp.h line 61
void httpp_initialize(struct http_parser_tag *parser, struct http_varlist_tag *defaults);
// httpp_parse
// file httpp/httpp.h line 62
signed int httpp_parse(struct http_parser_tag *parser, const char *http_data, unsigned long int len);
// httpp_parse_response
// file httpp/httpp.h line 64
signed int httpp_parse_response(struct http_parser_tag *parser, const char *http_data, unsigned long int len, const char *uri);
// httpp_set_query_param
// file httpp/httpp.h line 68
void httpp_set_query_param(struct http_parser_tag *parser, const char *name, const char *value);
// httpp_setvar
// file httpp/httpp.h line 65
void httpp_setvar(struct http_parser_tag *parser, const char *name, const char *value);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// initial_flac_page
// file format_flac.h line 19
struct ogg_codec_tag * initial_flac_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page);
// initial_kate_page
// file format_kate.h line 19
struct ogg_codec_tag * initial_kate_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page);
// initial_midi_page
// file format_midi.h line 19
struct ogg_codec_tag * initial_midi_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page);
// initial_opus_page
// file format_opus.h line 18
struct ogg_codec_tag * initial_opus_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page);
// initial_skeleton_page
// file format_skeleton.h line 19
struct ogg_codec_tag * initial_skeleton_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page);
// initial_speex_page
// file format_speex.h line 19
struct ogg_codec_tag * initial_speex_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page);
// initial_theora_page
// file format_theora.h line 19
struct ogg_codec_tag * initial_theora_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page);
// initial_vorbis_page
// file format_vorbis.h line 19
struct ogg_codec_tag * initial_vorbis_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page);
// initialize_subsystems
// file main.c line 110
void initialize_subsystems(void);
// initiate_flush
// file format_vorbis.c line 219
static void initiate_flush(struct vorbis_codec_tag *source_vorbis);
// is_listener_connected
// file auth.c line 179
static signed int is_listener_connected(struct _client_tag *client);
// kate_codec_free
// file format_kate.c line 53
static void kate_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_close
// file log/log.h line 37
void log_close(signed int log_id);
// log_contents
// file log.c line 392
void log_contents(signed int log_id, char **_contents, unsigned int *_len);
// log_flush
// file log.c line 288
void log_flush(signed int log_id);
// log_initialize
// file log/log.h line 25
void log_initialize(void);
// log_open
// file log/log.h line 27
signed int log_open(const char *filename);
// log_open_file
// file log/log.h line 26
signed int log_open_file(struct _IO_FILE *file);
// log_open_with_buffer
// file log.c line 253
signed int log_open_with_buffer(const char *filename, signed int size);
// log_parse_failure
// file logging.c line 202
void log_parse_failure(void *ctx, const char *fmt, ...);
// log_reopen
// file log/log.h line 36
void log_reopen(signed int log_id);
// log_set_archive_timestamp
// file log/log.h line 34
signed int log_set_archive_timestamp(signed int id, signed int value);
// log_set_filename
// file log/log.h line 31
signed int log_set_filename(signed int id, const char *filename);
// log_set_level
// file log/log.h line 29
void log_set_level(signed int log_id, unsigned int level);
// log_set_lines_kept
// file log.c line 260
void log_set_lines_kept(signed int log_id, unsigned int count);
// log_set_trigger
// file log/log.h line 30
void log_set_trigger(signed int id, unsigned int trigger);
// log_shutdown
// file log/log.h line 38
void log_shutdown(void);
// log_write
// file log/log.h line 40
void log_write(signed int log_id, unsigned int priority, const char *cat, const char *func, const char *fmt, ...);
// log_write_direct
// file log/log.h line 42
void log_write_direct(signed int log_id, const char *fmt, ...);
// logging_access
// file logging.c line 120
void logging_access(struct _client_tag *client);
// logging_playlist
// file logging.c line 172
void logging_playlist(const char *mount, const char *metadata, signed long int listeners);
// make_refbuf_with_page
// file format_ogg.c line 76
struct _refbuf_tag * make_refbuf_with_page(struct anonymous_3 *page);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// merge_mounts
// file cfgfile.c line 1337
static void merge_mounts(struct _mount_proxy *dst, struct _mount_proxy *src);
// midi_codec_free
// file format_midi.c line 35
static void midi_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// modify_node_event
// file stats.c line 436
static void modify_node_event(struct _stats_node_tag *node, struct _stats_event_tag *event);
// mp3_get_filter_meta
// file format_mp3.c line 541
static struct _refbuf_tag * mp3_get_filter_meta(struct source_tag *source);
// mp3_get_no_meta
// file format_mp3.c line 514
static struct _refbuf_tag * mp3_get_no_meta(struct source_tag *source);
// mp3_set_tag
// file format_mp3.c line 128
static void mp3_set_tag(struct _format_plugin_tag *plugin, const char *tag, const char *in_value, const char *charset);
// mp3_set_title
// file format_mp3.c line 238
static void mp3_set_title(struct source_tag *source);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// ogg_get_buffer
// file format_ogg.c line 395
static struct _refbuf_tag * ogg_get_buffer(struct source_tag *source);
// ogg_packet_clear
// file /usr/include/ogg/ogg.h line 203
extern void ogg_packet_clear(struct anonymous_14 *);
// ogg_page_bos
// file /usr/include/ogg/ogg.h line 196
extern signed int ogg_page_bos(const struct anonymous_3 *);
// ogg_page_granulepos
// file /usr/include/ogg/ogg.h line 198
extern signed long int ogg_page_granulepos(const struct anonymous_3 *);
// ogg_page_serialno
// file /usr/include/ogg/ogg.h line 199
extern signed int ogg_page_serialno(const struct anonymous_3 *);
// ogg_stream_clear
// file /usr/include/ogg/ogg.h line 185
extern signed int ogg_stream_clear(struct anonymous_2 *);
// ogg_stream_flush
// file /usr/include/ogg/ogg.h line 163
extern signed int ogg_stream_flush(struct anonymous_2 *, struct anonymous_3 *);
// ogg_stream_init
// file /usr/include/ogg/ogg.h line 184
extern signed int ogg_stream_init(struct anonymous_2 *, signed int);
// ogg_stream_packetin
// file /usr/include/ogg/ogg.h line 158
extern signed int ogg_stream_packetin(struct anonymous_2 *, struct anonymous_14 *);
// ogg_stream_packetout
// file /usr/include/ogg/ogg.h line 179
extern signed int ogg_stream_packetout(struct anonymous_2 *, struct anonymous_14 *);
// ogg_stream_pagein
// file /usr/include/ogg/ogg.h line 178
extern signed int ogg_stream_pagein(struct anonymous_2 *, struct anonymous_3 *);
// ogg_stream_pageout
// file /usr/include/ogg/ogg.h line 161
extern signed int ogg_stream_pageout(struct anonymous_2 *, struct anonymous_3 *);
// ogg_sync_buffer
// file /usr/include/ogg/ogg.h line 174
extern char * ogg_sync_buffer(struct anonymous_1 *, signed long int);
// ogg_sync_clear
// file /usr/include/ogg/ogg.h line 169
extern signed int ogg_sync_clear(struct anonymous_1 *);
// ogg_sync_init
// file /usr/include/ogg/ogg.h line 168
extern signed int ogg_sync_init(struct anonymous_1 *);
// ogg_sync_pageout
// file /usr/include/ogg/ogg.h line 177
extern signed int ogg_sync_pageout(struct anonymous_1 *, struct anonymous_3 *);
// ogg_sync_wrote
// file /usr/include/ogg/ogg.h line 175
extern signed int ogg_sync_wrote(struct anonymous_1 *, signed long int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_relay_connection
// file slave.c line 158
static struct _client_tag * open_relay_connection(struct _relay_server *relay);
// opus_codec_free
// file format_opus.c line 32
static void opus_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// parse_headers
// file httpp.c line 92
static void parse_headers(struct http_parser_tag *parser, char **line, signed int lines);
// parse_query
// file httpp.c line 254
static void parse_query(struct http_parser_tag *parser, char *query);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// print_connectors
// file avl.c line 1088
static void print_connectors(struct _link_node *link);
// print_node
// file avl.c line 1115
static void print_node(signed int (*key_printer)(char *, void *), struct avl_node_tag *node, struct _link_node *link);
// print_node::key_printer_object
//
signed int key_printer_object(char *, void *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_flac_page
// file format_flac.c line 45
static struct _refbuf_tag * process_flac_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page);
// process_global_event
// file stats.c line 486
static void process_global_event(struct _stats_event_tag *event);
// process_initial_page
// file format_ogg.c line 206
static signed int process_initial_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page);
// process_kate_page
// file format_kate.c line 77
static struct _refbuf_tag * process_kate_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page);
// process_midi_page
// file format_midi.c line 44
static struct _refbuf_tag * process_midi_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page);
// process_ogg_page
// file format_ogg.c line 370
static struct _refbuf_tag * process_ogg_page(struct ogg_state_tag *ogg_info, struct anonymous_3 *page);
// process_opus_page
// file format_opus.c line 39
static struct _refbuf_tag * process_opus_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page);
// process_request_queue
// file connection.c line 606
static void process_request_queue(void);
// process_skeleton_page
// file format_skeleton.c line 47
static struct _refbuf_tag * process_skeleton_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page);
// process_source_event
// file stats.c line 516
static void process_source_event(struct _stats_event_tag *event);
// process_speex_page
// file format_speex.c line 40
static struct _refbuf_tag * process_speex_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page);
// process_theora_page
// file format_theora.c line 66
static struct _refbuf_tag * process_theora_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page);
// process_vorbis
// file format_vorbis.c line 466
static struct _refbuf_tag * process_vorbis(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// process_vorbis_audio
// file format_vorbis.c line 238
static signed int process_vorbis_audio(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// process_vorbis_headers
// file format_vorbis.c line 314
static signed int process_vorbis_headers(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// process_vorbis_page
// file format_vorbis.c line 501
static struct _refbuf_tag * process_vorbis_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page);
// process_vorbis_passthru_page
// file format_vorbis.c line 491
static struct _refbuf_tag * process_vorbis_passthru_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page);
// process_ypdata
// file yp.c line 494
static signed int process_ypdata(struct yp_server *server, struct ypdata_tag *yp);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_attr_setinheritsched
// file /usr/include/pthread.h line 342
extern signed int pthread_attr_setinheritsched(union pthread_attr_t *, signed int);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_26 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_26 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_26 *, const union anonymous_40 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_26 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_26 *, union anonymous_21 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_26 *, union anonymous_21 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 280
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_21 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_21 *, const union anonymous_40 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_21 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_21 *);
// pthread_rwlock_destroy
// file /usr/include/pthread.h line 895
extern signed int pthread_rwlock_destroy(union anonymous_23 *);
// pthread_rwlock_init
// file /usr/include/pthread.h line 890
extern signed int pthread_rwlock_init(union anonymous_23 *, const union anonymous_39 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous_23 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous_23 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous_23 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_38 *, struct anonymous_38 *);
// pthread_spin_destroy
// file /usr/include/pthread.h line 1050
extern signed int pthread_spin_destroy(volatile signed int *);
// pthread_spin_init
// file /usr/include/pthread.h line 1046
extern signed int pthread_spin_init(volatile signed int *, signed int);
// pthread_spin_lock
// file /usr/include/pthread.h line 1054
extern signed int pthread_spin_lock(volatile signed int *);
// pthread_spin_unlock
// file /usr/include/pthread.h line 1062
extern signed int pthread_spin_unlock(volatile signed int *);
// queue_auth_client
// file auth.c line 93
static void queue_auth_client(struct auth_client_tag *auth_user, struct _mount_proxy *mountinfo);
// queue_global_event
// file stats.c line 119
static void queue_global_event(struct _stats_event_tag *event);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recheck_ip_file
// file connection.c line 324
static void recheck_ip_file(struct anonymous_42 *cache);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// refbuf_addref
// file refbuf.h line 36
void refbuf_addref(struct _refbuf_tag *self);
// refbuf_initialize
// file refbuf.h line 32
void refbuf_initialize(void);
// refbuf_new
// file refbuf.h line 35
struct _refbuf_tag * refbuf_new(unsigned int size);
// refbuf_release
// file refbuf.h line 37
void refbuf_release(struct _refbuf_tag *self);
// refbuf_release_associated
// file refbuf.c line 69
static void refbuf_release_associated(struct _refbuf_tag *ref);
// refbuf_shutdown
// file refbuf.h line 33
void refbuf_shutdown(void);
// relay_check_streams
// file slave.c line 570
static void relay_check_streams(struct _relay_server *to_start, struct _relay_server *to_free, signed int skip_timer);
// relay_copy
// file slave.c line 88
struct _relay_server * relay_copy(struct _relay_server *r);
// relay_free
// file slave.c line 70
struct _relay_server * relay_free(struct _relay_server *relay);
// relay_has_changed
// file slave.c line 489
static signed int relay_has_changed(struct _relay_server *new, struct _relay_server *old);
// release_locks
// file cfgfile.c line 106
static void release_locks(void);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// resolver_getip
// file resolver.h line 34
char * resolver_getip(const char *name, char *buff, signed int len);
// resolver_getname
// file resolver.c line 86
char * resolver_getname(const char *ip, char *buff, signed int len);
// resolver_initialize
// file net/resolver.h line 30
void resolver_initialize(void);
// resolver_shutdown
// file net/resolver.h line 31
void resolver_shutdown(void);
// restart_logging
// file logging.c line 217
void restart_logging(struct ice_config_tag *config);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_44 *, struct anonymous_44 *, struct anonymous_44 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// send_ebml_header
// file format_ebml.c line 119
static signed int send_ebml_header(struct _client_tag *client);
// send_ogg_headers
// file format_ogg.c line 485
static signed int send_ogg_headers(struct _client_tag *client, struct _refbuf_tag *headers);
// send_stream_metadata
// file format_mp3.c line 319
static signed int send_stream_metadata(struct _client_tag *client, struct _refbuf_tag *associated);
// send_to_listener
// file source.c line 538
static void send_to_listener(struct source_tag *source, struct _client_tag *client, signed int deletion_expected);
// send_to_yp
// file yp.c line 296
static signed int send_to_yp(const char *cmd, struct ypdata_tag *yp, char *post);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// sethostent
// file /usr/include/netdb.h line 117
extern void sethostent(signed int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// shutdown_subsystems
// file main.c line 127
void shutdown_subsystems(void);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_38 *, signed int);
// sigdelset
// file /usr/include/signal.h line 224
extern signed int sigdelset(struct anonymous_38 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_38 *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_38 *);
// sighandler_initialize
// file sighandler.h line 16
void sighandler_initialize(void);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// skeleton_codec_free
// file format_skeleton.c line 36
static void skeleton_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// slave_initialize
// file slave.h line 37
void slave_initialize(void);
// slave_rebuild_mounts
// file slave.h line 40
void slave_rebuild_mounts(void);
// slave_shutdown
// file slave.h line 38
void slave_shutdown(void);
// slave_update_all_mounts
// file slave.c line 112
void slave_update_all_mounts(void);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_accept
// file net/sock.h line 140
signed int sock_accept(signed int serversock, char *ip, unsigned long int len);
// sock_active
// file net/sock.h line 110
signed int sock_active(signed int sock);
// sock_close
// file net/sock.h line 117
signed int sock_close(signed int sock);
// sock_connect_non_blocking
// file sock.c line 591
signed int sock_connect_non_blocking(const char *hostname, unsigned int port);
// sock_connect_pending
// file sock.c line 188
static signed int sock_connect_pending(signed int error);
// sock_connect_wto
// file net/sock.h line 120
signed int sock_connect_wto(const char *hostname, signed int port, signed int timeout);
// sock_connect_wto_bind
// file net/sock.h line 121
signed int sock_connect_wto_bind(const char *hostname, signed int port, const char *bnd, signed int timeout);
// sock_connected
// file sock.c line 516
signed int sock_connected(signed int sock, signed int timeout);
// sock_error
// file net/sock.h line 106
signed int sock_error(void);
// sock_get_localip
// file sock.c line 108
char * sock_get_localip(char *buff, signed int len);
// sock_get_server_socket
// file net/sock.h line 138
signed int sock_get_server_socket(signed int port, const char *sinterface);
// sock_initialize
// file net/sock.h line 103
void sock_initialize(void);
// sock_listen
// file net/sock.h line 139
signed int sock_listen(signed int serversock, signed int backlog);
// sock_read_bytes
// file net/sock.h line 134
signed int sock_read_bytes(signed int sock, char *buff, unsigned long int len);
// sock_read_line
// file net/sock.h line 135
signed int sock_read_line(signed int sock, char *buff, const signed int len);
// sock_recoverable
// file net/sock.h line 107
signed int sock_recoverable(signed int error);
// sock_set_blocking
// file net/sock.h line 111
signed int sock_set_blocking(signed int sock, signed int block);
// sock_set_error
// file sock.c line 134
void sock_set_error(signed int val);
// sock_set_keepalive
// file sock.c line 286
signed int sock_set_keepalive(signed int sock);
// sock_set_nodelay
// file net/sock.h line 114
signed int sock_set_nodelay(signed int sock);
// sock_set_nolinger
// file sock.c line 271
signed int sock_set_nolinger(signed int sock);
// sock_set_send_buffer
// file net/sock.h line 115
void sock_set_send_buffer(signed int sock, signed int win_size);
// sock_shutdown
// file net/sock.h line 104
void sock_shutdown(void);
// sock_stalled
// file sock.c line 168
signed int sock_stalled(signed int error);
// sock_valid_socket
// file sock.c line 197
signed int sock_valid_socket(signed int sock);
// sock_write
// file net/sock.h line 127
signed int sock_write(signed int sock, const char *fmt, ...);
// sock_write_bytes
// file net/sock.h line 126
signed int sock_write_bytes(signed int sock, const void *buff, unsigned long int len);
// sock_write_fmt
// file sock.c line 421
signed int sock_write_fmt(signed int sock, const char *fmt, void **ap);
// sock_write_string
// file sock.c line 369
signed int sock_write_string(signed int sock, const char *buff);
// sock_writev
// file sock.c line 312
signed long int sock_writev(signed int sock, struct iovec *iov, unsigned long int count);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// source_apply_mount
// file source.c line 991
static void source_apply_mount(struct source_tag *source, struct _mount_proxy *mountinfo);
// source_clear_source
// file source.h line 88
void source_clear_source(struct source_tag *source);
// source_client_callback
// file source.h line 86
void source_client_callback(struct _client_tag *client, void *arg);
// source_client_thread
// file source.c line 1278
void * source_client_thread(void *arg);
// source_compare_sources
// file source.h line 92
signed int source_compare_sources(void *arg, void *a, void *b);
// source_fallback_file
// file source.c line 1389
static void * source_fallback_file(void *arg);
// source_find_client
// file source.c line 326
struct _client_tag * source_find_client(struct source_tag *source, signed int id);
// source_find_mount
// file source.h line 89
struct source_tag * source_find_mount(const char *mount);
// source_find_mount_raw
// file source.c line 129
struct source_tag * source_find_mount_raw(const char *mount);
// source_free_source
// file source.h line 93
void source_free_source(struct source_tag *source);
// source_init
// file source.c line 618
static void source_init(struct source_tag *source);
// source_main
// file source.h line 96
void source_main(struct source_tag *source);
// source_move_clients
// file source.h line 94
void source_move_clients(struct source_tag *source, struct source_tag *dest);
// source_open_dumpfile
// file source.c line 595
static struct _IO_FILE * source_open_dumpfile(const char *filename);
// source_recheck_mounts
// file source.h line 97
void source_recheck_mounts(signed int update_all);
// source_remove_client
// file source.c line 939
signed int source_remove_client(void *key);
// source_reserve
// file source.h line 83
struct source_tag * source_reserve(const char *mount);
// source_run_script
// file source.c line 1350
static void source_run_script(char *command, char *mountpoint);
// source_shutdown
// file source.c line 876
static void source_shutdown(struct source_tag *source);
// source_startup
// file connection.c line 1076
void source_startup(struct _client_tag *client, const char *uri, signed int auth_style);
// source_update_settings
// file source.h line 87
void source_update_settings(struct ice_config_tag *config, struct source_tag *source, struct _mount_proxy *mountinfo);
// speex_codec_free
// file format_speex.c line 33
static void speex_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// speex_packet_to_header
// file /usr/include/speex/speex_header.h line 84
struct SpeexHeader * speex_packet_to_header(char *, signed int);
// split_headers
// file httpp.c line 62
static signed int split_headers(char *data, unsigned long int len, char **line);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_relay_stream
// file slave.c line 316
static void * start_relay_stream(void *arg);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stats_callback
// file stats.h line 95
void stats_callback(struct _client_tag *client, void *notused);
// stats_clear_virtual_mounts
// file stats.h line 80
void stats_clear_virtual_mounts(void);
// stats_connection
// file stats.c line 905
void * stats_connection(void *arg);
// stats_event
// file stats.h line 82
void stats_event(const char *source, const char *name, const char *value);
// stats_event_add
// file stats.c line 325
void stats_event_add(const char *source, const char *name, unsigned long int value);
// stats_event_args
// file stats.h line 85
void stats_event_args(const char *source, char *name, char *format, ...);
// stats_event_conv
// file stats.h line 83
void stats_event_conv(const char *mount, const char *name, const char *value, const char *charset);
// stats_event_dec
// file stats.h line 89
void stats_event_dec(const char *source, const char *name);
// stats_event_hidden
// file stats.h line 90
void stats_event_hidden(const char *source, const char *name, signed int hidden);
// stats_event_inc
// file stats.h line 86
void stats_event_inc(const char *source, const char *name);
// stats_event_sub
// file stats.h line 88
void stats_event_sub(const char *source, const char *name, unsigned long int value);
// stats_event_time
// file stats.h line 91
void stats_event_time(const char *mount, const char *name);
// stats_event_time_iso8601
// file stats.h line 92
void stats_event_time_iso8601(const char *mount, const char *name);
// stats_get_stats
// file stats.c line 189
struct _stats_tag * stats_get_stats(void);
// stats_get_streams
// file stats.c line 1047
struct _refbuf_tag * stats_get_streams(void);
// stats_get_value
// file stats.c line 308
char * stats_get_value(const char *source, const char *name);
// stats_get_xml
// file stats.c line 987
struct _xmlDoc * stats_get_xml(signed int show_hidden, const char *show_mount);
// stats_global
// file stats.h line 77
void stats_global(struct ice_config_tag *config);
// stats_initialize
// file stats.h line 74
void stats_initialize(void);
// stats_shutdown
// file stats.h line 75
void stats_shutdown(void);
// stats_transform_xslt
// file stats.c line 973
void stats_transform_xslt(struct _client_tag *client, const char *uri);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 372
extern char * strcasestr(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// stream_auth_callback
// file auth.c line 244
static void stream_auth_callback(struct auth_tag *auth, struct auth_client_tag *auth_user);
// stream_end_callback
// file auth.c line 274
static void stream_end_callback(struct auth_tag *auth, struct auth_client_tag *auth_user);
// stream_start_callback
// file auth.c line 263
static void stream_start_callback(struct auth_tag *auth, struct auth_client_tag *auth_user);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// theora_codec_free
// file format_theora.c line 46
static void theora_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// theora_comment_clear
// file /usr/include/theora/theora.h line 766
extern void theora_comment_clear(struct theora_comment *);
// theora_comment_init
// file /usr/include/theora/theora.h line 704
extern void theora_comment_init(struct theora_comment *);
// theora_decode_header
// file /usr/include/theora/theora.h line 557
extern signed int theora_decode_header(struct anonymous_31 *, struct theora_comment *, struct anonymous_14 *);
// theora_info_clear
// file /usr/include/theora/theora.h line 692
extern void theora_info_clear(struct anonymous_31 *);
// theora_info_init
// file /usr/include/theora/theora.h line 685
extern void theora_info_init(struct anonymous_31 *);
// theora_packet_isheader
// file /usr/include/theora/theora.h line 603
extern signed int theora_packet_isheader(struct anonymous_14 *);
// theora_packet_iskeyframe
// file /usr/include/theora/theora.h line 615
extern signed int theora_packet_iskeyframe(struct anonymous_14 *);
// thread_cond_broadcast_c
// file thread/thread.h line 174
void thread_cond_broadcast_c(struct anonymous_27 *cond, signed int line, char *file);
// thread_cond_create_c
// file thread/thread.h line 172
void thread_cond_create_c(struct anonymous_27 *cond, signed int line, char *file);
// thread_cond_destroy
// file thread/thread.h line 177
void thread_cond_destroy(struct anonymous_27 *cond);
// thread_cond_signal_c
// file thread.c line 508
void thread_cond_signal_c(struct anonymous_27 *cond, signed int line, char *file);
// thread_cond_timedwait_c
// file thread.c line 518
void thread_cond_timedwait_c(struct anonymous_27 *cond, signed int millis, signed int line, char *file);
// thread_cond_wait_c
// file thread.c line 530
void thread_cond_wait_c(struct anonymous_27 *cond, signed int line, char *file);
// thread_create_c
// file thread/thread.h line 166
struct anonymous_24 * thread_create_c(char *name, void * (*start_routine)(void *), void *arg, signed int detached, signed int line, char *file);
// thread_create_c::start_routine_object
//
void * start_routine_object(void *);
// thread_exit_c
// file thread.c line 562
void thread_exit_c(signed long int val, signed int line, char *file);
// thread_initialize
// file thread/thread.h line 161
void thread_initialize(void);
// thread_join
// file thread/thread.h line 200
void thread_join(struct anonymous_24 *thread);
// thread_library_lock
// file thread.c line 728
void thread_library_lock(void);
// thread_library_unlock
// file thread.c line 733
void thread_library_unlock(void);
// thread_mutex_create_c
// file thread/thread.h line 168
void thread_mutex_create_c(struct anonymous_4 *mutex, signed int line, char *file);
// thread_mutex_destroy
// file thread/thread.h line 171
void thread_mutex_destroy(struct anonymous_4 *mutex);
// thread_mutex_lock_c
// file thread/thread.h line 169
void thread_mutex_lock_c(struct anonymous_4 *mutex, signed int line, char *file);
// thread_mutex_unlock_c
// file thread/thread.h line 170
void thread_mutex_unlock_c(struct anonymous_4 *mutex, signed int line, char *file);
// thread_rename
// file thread.c line 707
void thread_rename(const char *name);
// thread_rwlock_create_c
// file thread/thread.h line 178
void thread_rwlock_create_c(struct anonymous_16 *rwlock, signed int line, char *file);
// thread_rwlock_destroy
// file thread/thread.h line 182
void thread_rwlock_destroy(struct anonymous_16 *rwlock);
// thread_rwlock_rlock_c
// file thread/thread.h line 179
void thread_rwlock_rlock_c(struct anonymous_16 *rwlock, signed int line, char *file);
// thread_rwlock_unlock_c
// file thread/thread.h line 181
void thread_rwlock_unlock_c(struct anonymous_16 *rwlock, signed int line, char *file);
// thread_rwlock_wlock_c
// file thread/thread.h line 180
void thread_rwlock_wlock_c(struct anonymous_16 *rwlock, signed int line, char *file);
// thread_self
// file thread.c line 669
struct anonymous_24 * thread_self(void);
// thread_shutdown
// file thread/thread.h line 163
void thread_shutdown(void);
// thread_sleep
// file thread/thread.h line 186
void thread_sleep(unsigned long int len);
// thread_spin_create
// file thread/thread.h line 98
void thread_spin_create(struct anonymous_41 *spin);
// thread_spin_destroy
// file thread/thread.h line 99
void thread_spin_destroy(struct anonymous_41 *spin);
// thread_spin_lock
// file thread/thread.h line 100
void thread_spin_lock(struct anonymous_41 *spin);
// thread_spin_unlock
// file thread/thread.h line 101
void thread_spin_unlock(struct anonymous_41 *spin);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timing_get_time
// file timing.c line 48
unsigned long int timing_get_time(void);
// timing_sleep
// file timing.c line 67
void timing_sleep(unsigned long int sleeptime);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// update_comments
// file format_ogg.c line 277
static void update_comments(struct source_tag *source);
// update_from_master
// file slave.c line 604
static signed int update_from_master(struct ice_config_tag *config);
// update_relay_set
// file slave.c line 514
static struct _relay_server * update_relay_set(struct _relay_server **current, struct _relay_server *updated);
// update_relays
// file slave.c line 556
static struct _relay_server * update_relays(struct _relay_server **relay_list, struct _relay_server *new_relay_list);
// url_add_listener
// file auth_url.c line 274
static enum anonymous_19 url_add_listener(struct auth_client_tag *auth_user);
// url_escape
// file httpp.c line 203
static char * url_escape(const char *src);
// url_remove_listener
// file auth_url.c line 181
static enum anonymous_19 url_remove_listener(struct auth_client_tag *auth_user);
// url_stream_auth
// file auth_url.c line 514
static void url_stream_auth(struct auth_client_tag *auth_user);
// url_stream_end
// file auth_url.c line 463
static void url_stream_end(struct auth_client_tag *auth_user);
// url_stream_start
// file auth_url.c line 411
static void url_stream_start(struct auth_client_tag *auth_user);
// util_base64_decode
// file util.h line 33
char * util_base64_decode(const char *data);
// util_base64_encode
// file util.c line 414
char * util_base64_encode(const char *data);
// util_bin_to_hex
// file util.c line 398
char * util_bin_to_hex(unsigned char *data, signed int len);
// util_check_valid_extension
// file util.c line 145
signed int util_check_valid_extension(const char *uri);
// util_conv_string
// file util.c line 804
char * util_conv_string(const char *string, const char *in_charset, const char *out_charset);
// util_dict_free
// file util.c line 656
void util_dict_free(struct _util_dict *dict);
// util_dict_get
// file util.c line 673
const char * util_dict_get(struct _util_dict *dict, const char *key);
// util_dict_new
// file util.c line 651
struct _util_dict * util_dict_new(void);
// util_dict_set
// file util.c line 683
signed int util_dict_set(struct _util_dict *dict, const char *key, const char *val);
// util_dict_urlencode
// file util.c line 734
char * util_dict_urlencode(struct _util_dict *dict, char delim);
// util_get_extension
// file util.c line 136
char * util_get_extension(const char *path);
// util_get_path_from_normalised_uri
// file util.c line 230
char * util_get_path_from_normalised_uri(const char *uri);
// util_get_path_from_uri
// file util.c line 217
char * util_get_path_from_uri(char *uri);
// util_http_build_header
// file util.c line 552
signed long int util_http_build_header(char *out, unsigned long int len, signed long int offset, signed int cache, signed int status, const char *statusmsg, const char *contenttype, const char *charset, const char *datablock, struct source_tag *source);
// util_normalise_uri
// file util.h line 31
char * util_normalise_uri(const char *uri);
// util_read_header
// file util.c line 89
signed int util_read_header(signed int sock, char *buff, unsigned long int len, signed int entire);
// util_timed_wait_for_fd
// file util.c line 63
signed int util_timed_wait_for_fd(signed int fd, signed int timeout);
// util_url_escape
// file util.c line 268
char * util_url_escape(const char *src);
// util_url_unescape
// file util.c line 296
char * util_url_unescape(const char *src);
// verify_path
// file util.c line 189
static signed int verify_path(char *path);
// vorbis_codec_free
// file format_vorbis.c line 83
static void vorbis_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec);
// vorbis_comment_add_tag
// file /usr/include/vorbis/codec.h line 170
extern void vorbis_comment_add_tag(struct vorbis_comment *, const char *, const char *);
// vorbis_comment_clear
// file /usr/include/vorbis/codec.h line 174
extern void vorbis_comment_clear(struct vorbis_comment *);
// vorbis_comment_init
// file /usr/include/vorbis/codec.h line 168
extern void vorbis_comment_init(struct vorbis_comment *);
// vorbis_comment_query
// file /usr/include/vorbis/codec.h line 172
extern char * vorbis_comment_query(struct vorbis_comment *, const char *, signed int);
// vorbis_commentheader_out
// file /usr/include/vorbis/codec.h line 187
extern signed int vorbis_commentheader_out(struct vorbis_comment *, struct anonymous_14 *);
// vorbis_info_clear
// file /usr/include/vorbis/codec.h line 166
extern void vorbis_info_clear(struct vorbis_info *);
// vorbis_info_init
// file /usr/include/vorbis/codec.h line 165
extern void vorbis_info_init(struct vorbis_info *);
// vorbis_packet_blocksize
// file /usr/include/vorbis/codec.h line 215
extern signed long int vorbis_packet_blocksize(struct vorbis_info *, struct anonymous_14 *);
// vorbis_set_tag
// file format_vorbis.c line 419
static void vorbis_set_tag(struct _format_plugin_tag *plugin, const char *tag, const char *in_value, const char *charset);
// vorbis_synthesis_headerin
// file /usr/include/vorbis/codec.h line 204
extern signed int vorbis_synthesis_headerin(struct vorbis_info *, struct vorbis_comment *, struct anonymous_14 *);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait_for_fds
// file fserve.c line 234
static signed int wait_for_fds(void);
// wait_for_serversock
// file connection.c line 447
static signed int wait_for_serversock(signed int timeout);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write_buf_to_client
// file format_ogg.c line 526
static signed int write_buf_to_client(struct _client_tag *client);
// write_mp3_to_file
// file format_mp3.c line 721
static void write_mp3_to_file(struct source_tag *source, struct _refbuf_tag *refbuf);
// write_ogg_data
// file format_ogg.c line 561
static signed int write_ogg_data(struct source_tag *source, struct _refbuf_tag *refbuf);
// write_ogg_to_file
// file format_ogg.c line 576
static void write_ogg_to_file(struct source_tag *source, struct _refbuf_tag *refbuf);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);
// xmlBufferAdd
// file /usr/include/libxml2/libxml/tree.h line 717
signed int xmlBufferAdd(struct _xmlBuffer *, const unsigned char *, signed int);
// xmlBufferCCat
// file /usr/include/libxml2/libxml/tree.h line 728
signed int xmlBufferCCat(struct _xmlBuffer *, const char *);
// xmlBufferContent
// file /usr/include/libxml2/libxml/tree.h line 739
const unsigned char * xmlBufferContent(const struct _xmlBuffer *);
// xmlBufferCreate
// file /usr/include/libxml2/libxml/tree.h line 702
struct _xmlBuffer * xmlBufferCreate(void);
// xmlBufferFree
// file /usr/include/libxml2/libxml/tree.h line 712
void xmlBufferFree(struct _xmlBuffer *);
// xmlCharEncCloseFunc
// file /usr/include/libxml2/libxml/encoding.h line 219
signed int xmlCharEncCloseFunc(struct _xmlCharEncodingHandler *);
// xmlCharEncInFunc
// file /usr/include/libxml2/libxml/encoding.h line 211
signed int xmlCharEncInFunc(struct _xmlCharEncodingHandler *, struct _xmlBuffer *, struct _xmlBuffer *);
// xmlCharEncOutFunc
// file /usr/include/libxml2/libxml/encoding.h line 206
signed int xmlCharEncOutFunc(struct _xmlCharEncodingHandler *, struct _xmlBuffer *, struct _xmlBuffer *);
// xmlCharStrdup
// file /usr/include/libxml2/libxml/xmlstring.h line 49
unsigned char * xmlCharStrdup(const char *);
// xmlCheckUTF8
// file /usr/include/libxml2/libxml/xmlstring.h line 112
signed int xmlCheckUTF8(const unsigned char *);
// xmlCheckVersion
// file /usr/include/libxml2/libxml/xmlversion.h line 24
void xmlCheckVersion(signed int);
// xmlCleanupParser
// file /usr/include/libxml2/libxml/parser.h line 825
void xmlCleanupParser(void);
// xmlDocDumpMemory
// file /usr/include/libxml2/libxml/tree.h line 1160
void xmlDocDumpMemory(struct _xmlDoc *, unsigned char **, signed int *);
// xmlDocGetRootElement
// file /usr/include/libxml2/libxml/tree.h line 920
struct _xmlNode * xmlDocGetRootElement(const struct _xmlDoc *);
// xmlDocSetRootElement
// file /usr/include/libxml2/libxml/tree.h line 933
struct _xmlNode * xmlDocSetRootElement(struct _xmlDoc *, struct _xmlNode *);
// xmlFindCharEncodingHandler
// file /usr/include/libxml2/libxml/encoding.h line 175
struct _xmlCharEncodingHandler * xmlFindCharEncodingHandler(const char *);
// xmlFree_object
//
void xmlFree_object(void *);
// xmlFreeDoc
// file /usr/include/libxml2/libxml/tree.h line 782
void xmlFreeDoc(struct _xmlDoc *);
// xmlFreeURI
// file /usr/include/libxml2/libxml/uri.h line 85
void xmlFreeURI(struct _xmlURI *);
// xmlGetProp
// file /usr/include/libxml2/libxml/tree.h line 1029
unsigned char * xmlGetProp(const struct _xmlNode *, const unsigned char *);
// xmlInitParser
// file /usr/include/libxml2/libxml/parser.h line 823
void xmlInitParser(void);
// xmlIsBlankNode
// file /usr/include/libxml2/libxml/tree.h line 926
signed int xmlIsBlankNode(const struct _xmlNode *);
// xmlNewChild
// file /usr/include/libxml2/libxml/tree.h line 844
struct _xmlNode * xmlNewChild(struct _xmlNode *, struct _xmlNs *, const unsigned char *, const unsigned char *);
// xmlNewDoc
// file /usr/include/libxml2/libxml/tree.h line 780
struct _xmlDoc * xmlNewDoc(const unsigned char *);
// xmlNewDocNode
// file /usr/include/libxml2/libxml/tree.h line 827
struct _xmlNode * xmlNewDocNode(struct _xmlDoc *, struct _xmlNs *, const unsigned char *, const unsigned char *);
// xmlNewTextChild
// file /usr/include/libxml2/libxml/tree.h line 897
struct _xmlNode * xmlNewTextChild(struct _xmlNode *, struct _xmlNs *, const unsigned char *, const unsigned char *);
// xmlNodeListGetString
// file /usr/include/libxml2/libxml/tree.h line 1050
unsigned char * xmlNodeListGetString(struct _xmlDoc *, const struct _xmlNode *, signed int);
// xmlParseFile
// file /usr/include/libxml2/libxml/parser.h line 844
struct _xmlDoc * xmlParseFile(const char *);
// xmlParseURI
// file /usr/include/libxml2/libxml/uri.h line 61
struct _xmlURI * xmlParseURI(const char *);
// xmlSetGenericErrorFunc
// file /usr/include/libxml2/libxml/xmlerror.h line 863
void xmlSetGenericErrorFunc(void *, void (*)(void *, const char *, ...));
// xmlSetProp
// file /usr/include/libxml2/libxml/tree.h line 1015
struct _xmlAttr * xmlSetProp(struct _xmlNode *, const unsigned char *, const unsigned char *);
// xmlStrcmp
// file /usr/include/libxml2/libxml/xmlstring.h line 64
signed int xmlStrcmp(const unsigned char *, const unsigned char *);
// xmlStrdup
// file /usr/include/libxml2/libxml/xmlstring.h line 41
unsigned char * xmlStrdup(const unsigned char *);
// xmlStrlen
// file /usr/include/libxml2/libxml/xmlstring.h line 85
signed int xmlStrlen(const unsigned char *);
// xmlSubstituteEntitiesDefault
// file /usr/include/libxml2/libxml/parser.h line 850
signed int xmlSubstituteEntitiesDefault(signed int);
// xsltApplyStylesheet
// file /usr/include/libxslt/transform.h line 60
struct _xmlDoc * xsltApplyStylesheet(struct _xsltStylesheet *, struct _xmlDoc *, const char **);
// xsltCleanupGlobals
// file /usr/include/libxslt/xslt.h line 103
void xsltCleanupGlobals(void);
// xsltFreeStylesheet
// file /usr/include/libxslt/xsltInternals.h line 1847
void xsltFreeStylesheet(struct _xsltStylesheet *);
// xsltParseStylesheetFile
// file /usr/include/libxslt/xsltInternals.h line 1845
struct _xsltStylesheet * xsltParseStylesheetFile(const unsigned char *);
// xsltSaveResultToString
// file /usr/include/libxslt/xsltutils.h line 234
signed int xsltSaveResultToString(unsigned char **, signed int *, struct _xmlDoc *, struct _xsltStylesheet *);
// xsltSetGenericErrorFunc
// file /usr/include/libxslt/xsltutils.h line 154
void xsltSetGenericErrorFunc(void *, void (*)(void *, const char *, ...));
// xslt_get_stylesheet
// file xslt.c line 139
static struct _xsltStylesheet * xslt_get_stylesheet(const char *fn);
// xslt_initialize
// file xslt.h line 38
void xslt_initialize(void);
// xslt_shutdown
// file xslt.h line 39
void xslt_shutdown(void);
// xslt_transform
// file xslt.h line 37
void xslt_transform(struct _xmlDoc *doc, const char *xslfilename, struct _client_tag *client);
// yp_add
// file yp.h line 31
void yp_add(const char *mount);
// yp_destroy_ypdata
// file yp.c line 767
static void yp_destroy_ypdata(struct ypdata_tag *ypdata);
// yp_initialize
// file yp.h line 35
void yp_initialize(void);
// yp_process_server
// file yp.c line 528
static void yp_process_server(struct yp_server *server);
// yp_recheck_config
// file yp.h line 34
void yp_recheck_config(struct ice_config_tag *config);
// yp_remove
// file yp.h line 32
void yp_remove(const char *mount);
// yp_shutdown
// file yp.h line 36
void yp_shutdown(void);
// yp_touch
// file yp.h line 33
void yp_touch(const char *mount);
// yp_update_thread
// file yp.c line 713
static void * yp_update_thread(void *arg);

struct anonymous_15
{
  // ext
  char *ext;
  // type
  char *type;
};

struct anonymous_42
{
  // filename
  char *filename;
  // file_recheck
  signed long int file_recheck;
  // file_mtime
  signed long int file_mtime;
  // contents
  struct _avl_tree *contents;
};

struct anonymous_43
{
  // filename
  char *filename;
  // last_modified
  signed long int last_modified;
  // cache_age
  signed long int cache_age;
  // stylesheet
  struct _xsltStylesheet *stylesheet;
};

struct anonymous_28
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

union anonymous_23
{
  // __data
  struct anonymous_28 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct anonymous_16
{
  // sys_rwlock
  union anonymous_23 sys_rwlock;
};

struct anonymous_20
{
  // filename
  char *filename;
  // file_rwlock
  struct anonymous_16 file_rwlock;
  // users
  struct _avl_tree *users;
  // mtime
  signed long int mtime;
};

struct anonymous_22
{
  // name
  char *name;
  // pass
  char *pass;
};

struct anonymous_33
{
  // pass_headers
  char *pass_headers;
  // prefix_headers
  char *prefix_headers;
  // addurl
  char *addurl;
  // removeurl
  char *removeurl;
  // stream_start
  char *stream_start;
  // stream_end
  char *stream_end;
  // stream_auth
  char *stream_auth;
  // username
  char *username;
  // password
  char *password;
  // auth_header
  char *auth_header;
  // auth_header_len
  signed int auth_header_len;
  // timelimit_header
  char *timelimit_header;
  // timelimit_header_len
  signed int timelimit_header_len;
  // userpwd
  char *userpwd;
  // handle
  void *handle;
  // errormsg
  char errormsg[256l];
};

struct anonymous_2
{
  // body_data
  unsigned char *body_data;
  // body_storage
  signed long int body_storage;
  // body_fill
  signed long int body_fill;
  // body_returned
  signed long int body_returned;
  // lacing_vals
  signed int *lacing_vals;
  // granule_vals
  signed long int *granule_vals;
  // lacing_storage
  signed long int lacing_storage;
  // lacing_fill
  signed long int lacing_fill;
  // lacing_packet
  signed long int lacing_packet;
  // lacing_returned
  signed long int lacing_returned;
  // header
  unsigned char header[282l];
  // header_fill
  signed int header_fill;
  // e_o_s
  signed int e_o_s;
  // b_o_s
  signed int b_o_s;
  // serialno
  signed long int serialno;
  // pageno
  signed long int pageno;
  // packetno
  signed long int packetno;
  // granulepos
  signed long int granulepos;
};

struct anonymous_1
{
  // data
  unsigned char *data;
  // storage
  signed int storage;
  // fill
  signed int fill;
  // returned
  signed int returned;
  // unsynced
  signed int unsynced;
  // headerbytes
  signed int headerbytes;
  // bodybytes
  signed int bodybytes;
};

struct anonymous_3
{
  // header
  unsigned char *header;
  // header_len
  signed long int header_len;
  // body
  unsigned char *body;
  // body_len
  signed long int body_len;
};

struct anonymous_14
{
  // packet
  unsigned char *packet;
  // bytes
  signed long int bytes;
  // b_o_s
  signed long int b_o_s;
  // e_o_s
  signed long int e_o_s;
  // granulepos
  signed long int granulepos;
  // packetno
  signed long int packetno;
};

struct anonymous_44
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_38
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_25
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_21
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_4
{
  // sys_mutex
  union anonymous_21 sys_mutex;
};

struct anonymous_5
{
  // inline_metadata_interval
  signed int inline_metadata_interval;
  // offset
  signed int offset;
  // interval
  signed int interval;
  // url_artist
  char *url_artist;
  // url_title
  char *url_title;
  // url
  char *url;
  // inline_url
  char *inline_url;
  // update_metadata
  signed int update_metadata;
  // metadata
  struct _refbuf_tag *metadata;
  // read_data
  struct _refbuf_tag *read_data;
  // read_count
  signed int read_count;
  // url_lock
  struct anonymous_4 url_lock;
  // build_metadata_len
  unsigned int build_metadata_len;
  // build_metadata_offset
  unsigned int build_metadata_offset;
  // build_metadata
  char build_metadata[4081l];
};

struct anonymous_24
{
  // thread_id
  signed long int thread_id;
  // name
  char *name;
  // create_time
  signed long int create_time;
  // file
  char *file;
  // line
  signed int line;
  // detached
  signed int detached;
  // sys_thread
  unsigned long int sys_thread;
};

struct anonymous_17
{
  // config_lock
  struct anonymous_16 config_lock;
  // relay_lock
  struct anonymous_4 relay_lock;
};

union anonymous_26
{
  // __data
  struct anonymous_25 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous_27
{
  // cond_mutex
  union anonymous_21 cond_mutex;
  // sys_cond
  union anonymous_26 sys_cond;
};

struct anonymous_8
{
  // interval
  unsigned int interval;
  // metadata_offset
  signed int metadata_offset;
  // since_meta_block
  unsigned int since_meta_block;
  // in_metadata
  signed int in_metadata;
  // associated
  struct _refbuf_tag *associated;
};

struct anonymous_31
{
  // width
  unsigned int width;
  // height
  unsigned int height;
  // frame_width
  unsigned int frame_width;
  // frame_height
  unsigned int frame_height;
  // offset_x
  unsigned int offset_x;
  // offset_y
  unsigned int offset_y;
  // fps_numerator
  unsigned int fps_numerator;
  // fps_denominator
  unsigned int fps_denominator;
  // aspect_numerator
  unsigned int aspect_numerator;
  // aspect_denominator
  unsigned int aspect_denominator;
  // colorspace
  enum anonymous_29 colorspace;
  // target_bitrate
  signed int target_bitrate;
  // quality
  signed int quality;
  // quick_p
  signed int quick_p;
  // version_major
  unsigned char version_major;
  // version_minor
  unsigned char version_minor;
  // version_subminor
  unsigned char version_subminor;
  // codec_setup
  void *codec_setup;
  // dropframes_p
  signed int dropframes_p;
  // keyframe_auto_p
  signed int keyframe_auto_p;
  // keyframe_frequency
  unsigned int keyframe_frequency;
  // keyframe_frequency_force
  unsigned int keyframe_frequency_force;
  // keyframe_data_target_bitrate
  unsigned int keyframe_data_target_bitrate;
  // keyframe_auto_threshold
  signed int keyframe_auto_threshold;
  // keyframe_mindistance
  unsigned int keyframe_mindistance;
  // noise_sensitivity
  signed int noise_sensitivity;
  // sharpness
  signed int sharpness;
  // pixelformat
  enum anonymous_30 pixelformat;
};

struct anonymous_41
{
  // lock
  volatile signed int lock;
};

union anonymous_9
{
  // ptr
  void *ptr;
  // ival
  signed int ival;
};

union anonymous_36
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_40
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_39
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous_35
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct MD5Context
{
  // buf
  unsigned int buf[4l];
  // bits
  unsigned int bits[2l];
  // in
  unsigned char in[64l];
};

struct SpeexHeader
{
  // speex_string
  char speex_string[8l];
  // speex_version
  char speex_version[20l];
  // speex_version_id
  signed int speex_version_id;
  // header_size
  signed int header_size;
  // rate
  signed int rate;
  // mode
  signed int mode;
  // mode_bitstream_version
  signed int mode_bitstream_version;
  // nb_channels
  signed int nb_channels;
  // bitrate
  signed int bitrate;
  // frame_size
  signed int frame_size;
  // vbr
  signed int vbr;
  // frames_per_packet
  signed int frames_per_packet;
  // extra_headers
  signed int extra_headers;
  // reserved1
  signed int reserved1;
  // reserved2
  signed int reserved2;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _aliases
{
  // source
  char *source;
  // destination
  char *destination;
  // port
  signed int port;
  // bind_address
  char *bind_address;
  // next
  struct _aliases *next;
};

struct _avl_tree
{
  // root
  struct avl_node_tag *root;
  // height
  unsigned int height;
  // length
  unsigned int length;
  // compare_fun
  signed int (*compare_fun)(void *, void *, void *);
  // compare_arg
  void *compare_arg;
  // rwlock
  struct anonymous_16 rwlock;
};

struct _client_tag
{
  // con
  struct connection_tag *con;
  // parser
  struct http_parser_tag *parser;
  // respcode
  signed int respcode;
  // authenticated
  signed int authenticated;
  // intro_offset
  signed long int intro_offset;
  // refbuf
  struct _refbuf_tag *refbuf;
  // pos
  unsigned int pos;
  // auth
  struct auth_tag *auth;
  // username
  char *username;
  // password
  char *password;
  // format_data
  void *format_data;
  // free_client_data
  void (*free_client_data)(struct _client_tag *);
  // write_to_client
  signed int (*write_to_client)(struct _client_tag *);
  // check_buffer
  signed int (*check_buffer)(struct source_tag *, struct _client_tag *);
};

struct _config_options
{
  // name
  char *name;
  // value
  char *value;
  // next
  struct _config_options *next;
};

struct _event_queue_tag
{
  // head
  volatile struct _stats_event_tag *head;
  // tail
  volatile struct _stats_event_tag **tail;
};

struct _event_listener_tag
{
  // queue
  struct _event_queue_tag queue;
  // mutex
  struct anonymous_4 mutex;
  // next
  struct _event_listener_tag *next;
};

struct _format_plugin_tag
{
  // type
  enum _format_type_tag type;
  // mount
  char *mount;
  // contenttype
  const char *contenttype;
  // charset
  char *charset;
  // read_bytes
  unsigned long int read_bytes;
  // sent_bytes
  unsigned long int sent_bytes;
  // get_buffer
  struct _refbuf_tag * (*get_buffer)(struct source_tag *);
  // write_buf_to_client
  signed int (*write_buf_to_client)(struct _client_tag *);
  // write_buf_to_file
  void (*write_buf_to_file)(struct source_tag *, struct _refbuf_tag *);
  // create_client_data
  signed int (*create_client_data)(struct source_tag *, struct _client_tag *);
  // set_tag
  void (*set_tag)(struct _format_plugin_tag *, const char *, const char *, const char *);
  // free_plugin
  void (*free_plugin)(struct _format_plugin_tag *);
  // apply_settings
  void (*apply_settings)(struct _client_tag *, struct _format_plugin_tag *, struct _mount_proxy *);
  // _state
  void *_state;
};

struct _fserve_t
{
  // client
  struct _client_tag *client;
  // file
  struct _IO_FILE *file;
  // ready
  signed int ready;
  // callback
  void (*callback)(struct _client_tag *, void *);
  // arg
  void *arg;
  // next
  struct _fserve_t *next;
};

struct _kate_codec_tag
{
  // headers_done
  signed int headers_done;
  // num_headers
  signed int num_headers;
  // granule_shift
  signed int granule_shift;
  // last_iframe
  signed long int last_iframe;
  // prev_granulepos
  signed long int prev_granulepos;
};

struct _link_node
{
  // parent
  struct _link_node *parent;
  // direction
  char direction;
  // width
  signed int width;
};

struct _listener_t
{
  // next
  struct _listener_t *next;
  // port
  signed int port;
  // so_sndbuf
  signed int so_sndbuf;
  // bind_address
  char *bind_address;
  // shoutcast_compat
  signed int shoutcast_compat;
  // shoutcast_mount
  char *shoutcast_mount;
  // ssl
  signed int ssl;
};

struct _log_entry_t
{
  // line
  char *line;
  // len
  unsigned int len;
  // next
  struct _log_entry_t *next;
};

struct _mount_proxy
{
  // mountname
  char *mountname;
  // mounttype
  enum _mount_type mounttype;
  // username
  char *username;
  // password
  char *password;
  // dumpfile
  char *dumpfile;
  // intro_filename
  char *intro_filename;
  // fallback_when_full
  signed int fallback_when_full;
  // max_listeners
  signed int max_listeners;
  // fallback_mount
  char *fallback_mount;
  // fallback_override
  signed int fallback_override;
  // no_mount
  signed int no_mount;
  // burst_size
  signed int burst_size;
  // queue_size_limit
  unsigned int queue_size_limit;
  // hidden
  signed int hidden;
  // source_timeout
  unsigned int source_timeout;
  // charset
  char *charset;
  // mp3_meta_interval
  signed int mp3_meta_interval;
  // http_headers
  struct ice_config_http_header_tag *http_headers;
  // auth_type
  char *auth_type;
  // auth
  struct auth_tag *auth;
  // cluster_password
  char *cluster_password;
  // auth_options
  struct _config_options *auth_options;
  // on_connect
  char *on_connect;
  // on_disconnect
  char *on_disconnect;
  // max_listener_duration
  unsigned int max_listener_duration;
  // stream_name
  char *stream_name;
  // stream_description
  char *stream_description;
  // stream_url
  char *stream_url;
  // stream_genre
  char *stream_genre;
  // bitrate
  char *bitrate;
  // type
  char *type;
  // subtype
  char *subtype;
  // yp_public
  signed int yp_public;
  // next
  struct _mount_proxy *next;
};

struct _refbuf_tag
{
  // len
  unsigned int len;
  // _count
  unsigned int _count;
  // data
  char *data;
  // associated
  struct _refbuf_tag *associated;
  // next
  struct _refbuf_tag *next;
  // sync_point
  signed int sync_point;
};

struct _relay_server
{
  // server
  char *server;
  // port
  signed int port;
  // mount
  char *mount;
  // username
  char *username;
  // password
  char *password;
  // localmount
  char *localmount;
  // bind
  char *bind;
  // source
  struct source_tag *source;
  // mp3metadata
  signed int mp3metadata;
  // on_demand
  signed int on_demand;
  // running
  signed int running;
  // cleanup
  signed int cleanup;
  // start
  signed long int start;
  // thread
  struct anonymous_24 *thread;
  // next
  struct _relay_server *next;
};

struct _stats_event_tag
{
  // source
  char *source;
  // name
  char *name;
  // value
  char *value;
  // hidden
  signed int hidden;
  // action
  signed int action;
  // next
  struct _stats_event_tag *next;
};

struct _stats_node_tag
{
  // name
  char *name;
  // value
  char *value;
  // hidden
  signed int hidden;
};

struct _stats_source_tag
{
  // source
  char *source;
  // hidden
  signed int hidden;
  // stats_tree
  struct _avl_tree *stats_tree;
};

struct _stats_tag
{
  // global_tree
  struct _avl_tree *global_tree;
  // source_tree
  struct _avl_tree *source_tree;
};

struct theora_comment
{
  // user_comments
  char **user_comments;
  // comment_lengths
  signed int *comment_lengths;
  // comments
  signed int comments;
  // vendor
  char *vendor;
};

struct _theora_codec_tag
{
  // ti
  struct anonymous_31 ti;
  // tc
  struct theora_comment tc;
  // granule_shift
  signed int granule_shift;
  // last_iframe
  signed long int last_iframe;
  // prev_granulepos
  signed long int prev_granulepos;
};

struct _uconv_t
{
  // uconv
  struct UConverter *uconv;
  // utf8
  struct UConverter *utf8;
};

struct _util_dict
{
  // key
  char *key;
  // val
  char *val;
  // next
  struct _util_dict *next;
};

struct _xmlAttr
{
  // _private
  void *_private;
  // type
  enum anonymous_13 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlAttr *next;
  // prev
  struct _xmlAttr *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // atype
  enum anonymous_18 atype;
  // psvi
  void *psvi;
};

struct _xmlBuffer
{
  // content
  unsigned char *content;
  // use
  unsigned int use;
  // size
  unsigned int size;
  // alloc
  enum anonymous_0 alloc;
  // contentIO
  unsigned char *contentIO;
};

struct _xmlCharEncodingHandler
{
  // name
  char *name;
  // input
  signed int (*input)(unsigned char *, signed int *, const unsigned char *, signed int *);
  // output
  signed int (*output)(unsigned char *, signed int *, const unsigned char *, signed int *);
  // iconv_in
  void *iconv_in;
  // iconv_out
  void *iconv_out;
  // uconv_in
  struct _uconv_t *uconv_in;
  // uconv_out
  struct _uconv_t *uconv_out;
};

struct _xmlDoc
{
  // _private
  void *_private;
  // type
  enum anonymous_13 type;
  // name
  char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // compression
  signed int compression;
  // standalone
  signed int standalone;
  // intSubset
  struct _xmlDtd *intSubset;
  // extSubset
  struct _xmlDtd *extSubset;
  // oldNs
  struct _xmlNs *oldNs;
  // version
  const unsigned char *version;
  // encoding
  const unsigned char *encoding;
  // ids
  void *ids;
  // refs
  void *refs;
  // URL
  const unsigned char *URL;
  // charset
  signed int charset;
  // dict
  struct _xmlDict *dict;
  // psvi
  void *psvi;
  // parseFlags
  signed int parseFlags;
  // properties
  signed int properties;
};

struct _xmlDtd
{
  // _private
  void *_private;
  // type
  enum anonymous_13 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlDoc *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // notations
  void *notations;
  // elements
  void *elements;
  // attributes
  void *attributes;
  // entities
  void *entities;
  // ExternalID
  const unsigned char *ExternalID;
  // SystemID
  const unsigned char *SystemID;
  // pentities
  void *pentities;
};

struct _xmlError
{
  // domain
  signed int domain;
  // code
  signed int code;
  // message
  char *message;
  // level
  enum anonymous_7 level;
  // file
  char *file;
  // line
  signed int line;
  // str1
  char *str1;
  // str2
  char *str2;
  // str3
  char *str3;
  // int1
  signed int int1;
  // int2
  signed int int2;
  // ctxt
  void *ctxt;
  // node
  void *node;
};

struct _xmlNode
{
  // _private
  void *_private;
  // type
  enum anonymous_13 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // content
  unsigned char *content;
  // properties
  struct _xmlAttr *properties;
  // nsDef
  struct _xmlNs *nsDef;
  // psvi
  void *psvi;
  // line
  unsigned short int line;
  // extra
  unsigned short int extra;
};

struct _xmlNodeSet
{
  // nodeNr
  signed int nodeNr;
  // nodeMax
  signed int nodeMax;
  // nodeTab
  struct _xmlNode **nodeTab;
};

struct _xmlNs
{
  // next
  struct _xmlNs *next;
  // type
  enum anonymous_13 type;
  // href
  const unsigned char *href;
  // prefix
  const unsigned char *prefix;
  // _private
  void *_private;
  // context
  struct _xmlDoc *context;
};

struct _xmlURI
{
  // scheme
  char *scheme;
  // opaque
  char *opaque;
  // authority
  char *authority;
  // server
  char *server;
  // user
  char *user;
  // port
  signed int port;
  // path
  char *path;
  // query
  char *query;
  // fragment
  char *fragment;
  // cleanup
  signed int cleanup;
  // query_raw
  char *query_raw;
};

struct _xmlXPathAxis
{
  // name
  const unsigned char *name;
  // func
  struct _xmlXPathObject * (*func)(struct _xmlXPathParserContext *, struct _xmlXPathObject *);
};

struct _xmlXPathContext
{
  // doc
  struct _xmlDoc *doc;
  // node
  struct _xmlNode *node;
  // nb_variables_unused
  signed int nb_variables_unused;
  // max_variables_unused
  signed int max_variables_unused;
  // varHash
  struct _xmlHashTable *varHash;
  // nb_types
  signed int nb_types;
  // max_types
  signed int max_types;
  // types
  struct _xmlXPathType *types;
  // nb_funcs_unused
  signed int nb_funcs_unused;
  // max_funcs_unused
  signed int max_funcs_unused;
  // funcHash
  struct _xmlHashTable *funcHash;
  // nb_axis
  signed int nb_axis;
  // max_axis
  signed int max_axis;
  // axis
  struct _xmlXPathAxis *axis;
  // namespaces
  struct _xmlNs **namespaces;
  // nsNr
  signed int nsNr;
  // user
  void *user;
  // contextSize
  signed int contextSize;
  // proximityPosition
  signed int proximityPosition;
  // xptr
  signed int xptr;
  // here
  struct _xmlNode *here;
  // origin
  struct _xmlNode *origin;
  // nsHash
  struct _xmlHashTable *nsHash;
  // varLookupFunc
  struct _xmlXPathObject * (*varLookupFunc)(void *, const unsigned char *, const unsigned char *);
  // varLookupData
  void *varLookupData;
  // extra
  void *extra;
  // function
  const unsigned char *function;
  // functionURI
  const unsigned char *functionURI;
  // funcLookupFunc
  void (*(*funcLookupFunc)(void *, const unsigned char *, const unsigned char *))(struct _xmlXPathParserContext *, signed int);
  // funcLookupData
  void *funcLookupData;
  // tmpNsList
  struct _xmlNs **tmpNsList;
  // tmpNsNr
  signed int tmpNsNr;
  // userData
  void *userData;
  // error
  void (*error)(void *, struct _xmlError *);
  // lastError
  struct _xmlError lastError;
  // debugNode
  struct _xmlNode *debugNode;
  // dict
  struct _xmlDict *dict;
  // flags
  signed int flags;
  // cache
  void *cache;
};

struct _xmlXPathObject
{
  // type
  enum anonymous_6 type;
  // nodesetval
  struct _xmlNodeSet *nodesetval;
  // boolval
  signed int boolval;
  // floatval
  double floatval;
  // stringval
  unsigned char *stringval;
  // user
  void *user;
  // index
  signed int index;
  // user2
  void *user2;
  // index2
  signed int index2;
};

struct _xmlXPathParserContext
{
  // cur
  const unsigned char *cur;
  // base
  const unsigned char *base;
  // error
  signed int error;
  // context
  struct _xmlXPathContext *context;
  // value
  struct _xmlXPathObject *value;
  // valueNr
  signed int valueNr;
  // valueMax
  signed int valueMax;
  // valueTab
  struct _xmlXPathObject **valueTab;
  // comp
  struct _xmlXPathCompExpr *comp;
  // xptr
  signed int xptr;
  // ancestor
  struct _xmlNode *ancestor;
  // valueFrame
  signed int valueFrame;
};

struct _xmlXPathType
{
  // name
  const unsigned char *name;
  // func
  signed int (*func)(struct _xmlXPathObject *, signed int);
};

struct _xsltDecimalFormat
{
  // next
  struct _xsltDecimalFormat *next;
  // name
  unsigned char *name;
  // digit
  unsigned char *digit;
  // patternSeparator
  unsigned char *patternSeparator;
  // minusSign
  unsigned char *minusSign;
  // infinity
  unsigned char *infinity;
  // noNumber
  unsigned char *noNumber;
  // decimalPoint
  unsigned char *decimalPoint;
  // grouping
  unsigned char *grouping;
  // percent
  unsigned char *percent;
  // permille
  unsigned char *permille;
  // zeroDigit
  unsigned char *zeroDigit;
};

struct _xsltDocument
{
  // next
  struct _xsltDocument *next;
  // main
  signed int main;
  // doc
  struct _xmlDoc *doc;
  // keys
  void *keys;
  // includes
  struct _xsltDocument *includes;
  // preproc
  signed int preproc;
  // nbKeysComputed
  signed int nbKeysComputed;
};

struct _xsltElemPreComp
{
  // next
  struct _xsltElemPreComp *next;
  // type
  enum anonymous_10 type;
  // func
  void (*func)(struct _xsltTransformContext *, struct _xmlNode *, struct _xmlNode *, struct _xsltElemPreComp *);
  // inst
  struct _xmlNode *inst;
  // free
  void (*free)(struct _xsltElemPreComp *);
};

struct _xsltNumberData
{
  // level
  const unsigned char *level;
  // count
  const unsigned char *count;
  // from
  const unsigned char *from;
  // value
  const unsigned char *value;
  // format
  const unsigned char *format;
  // has_format
  signed int has_format;
  // digitsPerGroup
  signed int digitsPerGroup;
  // groupingCharacter
  signed int groupingCharacter;
  // groupingCharacterLen
  signed int groupingCharacterLen;
  // doc
  struct _xmlDoc *doc;
  // node
  struct _xmlNode *node;
  // countPat
  struct _xsltCompMatch *countPat;
  // fromPat
  struct _xsltCompMatch *fromPat;
};

struct _xsltRuntimeExtra
{
  // info
  void *info;
  // deallocate
  void (*deallocate)(void *);
  // val
  union anonymous_9 val;
};

struct _xsltStackElem
{
  // next
  struct _xsltStackElem *next;
  // comp
  struct _xsltStylePreComp *comp;
  // computed
  signed int computed;
  // name
  const unsigned char *name;
  // nameURI
  const unsigned char *nameURI;
  // select
  const unsigned char *select;
  // tree
  struct _xmlNode *tree;
  // value
  struct _xmlXPathObject *value;
  // fragment
  struct _xmlDoc *fragment;
  // level
  signed int level;
  // context
  struct _xsltTransformContext *context;
  // flags
  signed int flags;
};

struct _xsltStylePreComp
{
  // next
  struct _xsltElemPreComp *next;
  // type
  enum anonymous_10 type;
  // func
  void (*func)(struct _xsltTransformContext *, struct _xmlNode *, struct _xmlNode *, struct _xsltElemPreComp *);
  // inst
  struct _xmlNode *inst;
  // stype
  const unsigned char *stype;
  // has_stype
  signed int has_stype;
  // number
  signed int number;
  // order
  const unsigned char *order;
  // has_order
  signed int has_order;
  // descending
  signed int descending;
  // lang
  const unsigned char *lang;
  // has_lang
  signed int has_lang;
  // locale
  void *locale;
  // case_order
  const unsigned char *case_order;
  // lower_first
  signed int lower_first;
  // use
  const unsigned char *use;
  // has_use
  signed int has_use;
  // noescape
  signed int noescape;
  // name
  const unsigned char *name;
  // has_name
  signed int has_name;
  // ns
  const unsigned char *ns;
  // has_ns
  signed int has_ns;
  // mode
  const unsigned char *mode;
  // modeURI
  const unsigned char *modeURI;
  // test
  const unsigned char *test;
  // templ
  struct _xsltTemplate *templ;
  // select
  const unsigned char *select;
  // ver11
  signed int ver11;
  // filename
  const unsigned char *filename;
  // has_filename
  signed int has_filename;
  // numdata
  struct _xsltNumberData numdata;
  // comp
  struct _xmlXPathCompExpr *comp;
  // nsList
  struct _xmlNs **nsList;
  // nsNr
  signed int nsNr;
};

struct _xsltStylesheet
{
  // parent
  struct _xsltStylesheet *parent;
  // next
  struct _xsltStylesheet *next;
  // imports
  struct _xsltStylesheet *imports;
  // docList
  struct _xsltDocument *docList;
  // doc
  struct _xmlDoc *doc;
  // stripSpaces
  struct _xmlHashTable *stripSpaces;
  // stripAll
  signed int stripAll;
  // cdataSection
  struct _xmlHashTable *cdataSection;
  // variables
  struct _xsltStackElem *variables;
  // templates
  struct _xsltTemplate *templates;
  // templatesHash
  void *templatesHash;
  // rootMatch
  void *rootMatch;
  // keyMatch
  void *keyMatch;
  // elemMatch
  void *elemMatch;
  // attrMatch
  void *attrMatch;
  // parentMatch
  void *parentMatch;
  // textMatch
  void *textMatch;
  // piMatch
  void *piMatch;
  // commentMatch
  void *commentMatch;
  // nsAliases
  struct _xmlHashTable *nsAliases;
  // attributeSets
  struct _xmlHashTable *attributeSets;
  // nsHash
  struct _xmlHashTable *nsHash;
  // nsDefs
  void *nsDefs;
  // keys
  void *keys;
  // method
  unsigned char *method;
  // methodURI
  unsigned char *methodURI;
  // version
  unsigned char *version;
  // encoding
  unsigned char *encoding;
  // omitXmlDeclaration
  signed int omitXmlDeclaration;
  // decimalFormat
  struct _xsltDecimalFormat *decimalFormat;
  // standalone
  signed int standalone;
  // doctypePublic
  unsigned char *doctypePublic;
  // doctypeSystem
  unsigned char *doctypeSystem;
  // indent
  signed int indent;
  // mediaType
  unsigned char *mediaType;
  // preComps
  struct _xsltElemPreComp *preComps;
  // warnings
  signed int warnings;
  // errors
  signed int errors;
  // exclPrefix
  unsigned char *exclPrefix;
  // exclPrefixTab
  unsigned char **exclPrefixTab;
  // exclPrefixNr
  signed int exclPrefixNr;
  // exclPrefixMax
  signed int exclPrefixMax;
  // _private
  void *_private;
  // extInfos
  struct _xmlHashTable *extInfos;
  // extrasNr
  signed int extrasNr;
  // includes
  struct _xsltDocument *includes;
  // dict
  struct _xmlDict *dict;
  // attVTs
  void *attVTs;
  // defaultAlias
  const unsigned char *defaultAlias;
  // nopreproc
  signed int nopreproc;
  // internalized
  signed int internalized;
  // literal_result
  signed int literal_result;
  // principal
  struct _xsltStylesheet *principal;
  // forwards_compatible
  signed int forwards_compatible;
};

struct _xsltTemplate
{
  // next
  struct _xsltTemplate *next;
  // style
  struct _xsltStylesheet *style;
  // match
  unsigned char *match;
  // priority
  float priority;
  // name
  const unsigned char *name;
  // nameURI
  const unsigned char *nameURI;
  // mode
  const unsigned char *mode;
  // modeURI
  const unsigned char *modeURI;
  // content
  struct _xmlNode *content;
  // elem
  struct _xmlNode *elem;
  // inheritedNsNr
  signed int inheritedNsNr;
  // inheritedNs
  struct _xmlNs **inheritedNs;
  // nbCalls
  signed int nbCalls;
  // time
  unsigned long int time;
  // params
  void *params;
  // templNr
  signed int templNr;
  // templMax
  signed int templMax;
  // templCalledTab
  struct _xsltTemplate **templCalledTab;
  // templCountTab
  signed int *templCountTab;
};

struct _xsltTransformCache
{
  // RVT
  struct _xmlDoc *RVT;
  // nbRVT
  signed int nbRVT;
  // stackItems
  struct _xsltStackElem *stackItems;
  // nbStackItems
  signed int nbStackItems;
};

struct _xsltTransformContext
{
  // style
  struct _xsltStylesheet *style;
  // type
  enum anonymous_11 type;
  // templ
  struct _xsltTemplate *templ;
  // templNr
  signed int templNr;
  // templMax
  signed int templMax;
  // templTab
  struct _xsltTemplate **templTab;
  // vars
  struct _xsltStackElem *vars;
  // varsNr
  signed int varsNr;
  // varsMax
  signed int varsMax;
  // varsTab
  struct _xsltStackElem **varsTab;
  // varsBase
  signed int varsBase;
  // extFunctions
  struct _xmlHashTable *extFunctions;
  // extElements
  struct _xmlHashTable *extElements;
  // extInfos
  struct _xmlHashTable *extInfos;
  // mode
  const unsigned char *mode;
  // modeURI
  const unsigned char *modeURI;
  // docList
  struct _xsltDocument *docList;
  // document
  struct _xsltDocument *document;
  // node
  struct _xmlNode *node;
  // nodeList
  struct _xmlNodeSet *nodeList;
  // output
  struct _xmlDoc *output;
  // insert
  struct _xmlNode *insert;
  // xpathCtxt
  struct _xmlXPathContext *xpathCtxt;
  // state
  enum anonymous_12 state;
  // globalVars
  struct _xmlHashTable *globalVars;
  // inst
  struct _xmlNode *inst;
  // xinclude
  signed int xinclude;
  // outputFile
  const char *outputFile;
  // profile
  signed int profile;
  // prof
  signed long int prof;
  // profNr
  signed int profNr;
  // profMax
  signed int profMax;
  // profTab
  signed long int *profTab;
  // _private
  void *_private;
  // extrasNr
  signed int extrasNr;
  // extrasMax
  signed int extrasMax;
  // extras
  struct _xsltRuntimeExtra *extras;
  // styleList
  struct _xsltDocument *styleList;
  // sec
  void *sec;
  // error
  void (*error)(void *, const char *, ...);
  // errctx
  void *errctx;
  // sortfunc
  void (*sortfunc)(struct _xsltTransformContext *, struct _xmlNode **, signed int);
  // tmpRVT
  struct _xmlDoc *tmpRVT;
  // persistRVT
  struct _xmlDoc *persistRVT;
  // ctxtflags
  signed int ctxtflags;
  // lasttext
  const unsigned char *lasttext;
  // lasttsize
  unsigned int lasttsize;
  // lasttuse
  unsigned int lasttuse;
  // debugStatus
  signed int debugStatus;
  // traceCode
  unsigned long int *traceCode;
  // parserOptions
  signed int parserOptions;
  // dict
  struct _xmlDict *dict;
  // tmpDoc
  struct _xmlDoc *tmpDoc;
  // internalized
  signed int internalized;
  // nbKeys
  signed int nbKeys;
  // hasTemplKeyPatterns
  signed int hasTemplKeyPatterns;
  // currentTemplateRule
  struct _xsltTemplate *currentTemplateRule;
  // initialContextNode
  struct _xmlNode *initialContextNode;
  // initialContextDoc
  struct _xmlDoc *initialContextDoc;
  // cache
  struct _xsltTransformCache *cache;
  // contextVariable
  void *contextVariable;
  // localRVT
  struct _xmlDoc *localRVT;
  // localRVTBase
  struct _xmlDoc *localRVTBase;
  // keyInitLevel
  signed int keyInitLevel;
  // funcLevel
  signed int funcLevel;
  // maxTemplateDepth
  signed int maxTemplateDepth;
  // maxTemplateVars
  signed int maxTemplateVars;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct auth_client_tag
{
  // mount
  char *mount;
  // client
  struct _client_tag *client;
  // process
  void (*process)(struct auth_tag *, struct auth_client_tag *);
  // next
  struct auth_client_tag *next;
};

struct auth_tag
{
  // mount
  char *mount;
  // authenticate
  enum anonymous_19 (*authenticate)(struct auth_client_tag *);
  // release_listener
  enum anonymous_19 (*release_listener)(struct auth_client_tag *);
  // stream_auth
  void (*stream_auth)(struct auth_client_tag *);
  // stream_start
  void (*stream_start)(struct auth_client_tag *);
  // stream_end
  void (*stream_end)(struct auth_client_tag *);
  // free
  void (*free)(struct auth_tag *);
  // adduser
  enum anonymous_19 (*adduser)(struct auth_tag *, const char *, const char *);
  // deleteuser
  enum anonymous_19 (*deleteuser)(struct auth_tag *, const char *);
  // listuser
  enum anonymous_19 (*listuser)(struct auth_tag *, struct _xmlNode *);
  // lock
  struct anonymous_4 lock;
  // running
  signed int running;
  // refcount
  signed int refcount;
  // allow_duplicate_users
  signed int allow_duplicate_users;
  // thread
  struct anonymous_24 *thread;
  // head
  struct auth_client_tag *head;
  // tailp
  struct auth_client_tag **tailp;
  // pending_count
  signed int pending_count;
  // state
  void *state;
  // type
  char *type;
};

struct avl_node_tag
{
  // key
  void *key;
  // left
  struct avl_node_tag *left;
  // right
  struct avl_node_tag *right;
  // parent
  struct avl_node_tag *parent;
  // rank_and_balance
  unsigned int rank_and_balance;
};

struct client_queue_tag
{
  // client
  struct _client_tag *client;
  // offset
  signed int offset;
  // stream_offset
  signed int stream_offset;
  // shoutcast
  signed int shoutcast;
  // shoutcast_mount
  char *shoutcast_mount;
  // next
  struct client_queue_tag *next;
};

struct connection_tag
{
  // id
  unsigned long int id;
  // con_time
  signed long int con_time;
  // discon_time
  signed long int discon_time;
  // sent_bytes
  unsigned long int sent_bytes;
  // sock
  signed int sock;
  // serversock
  signed int serversock;
  // error
  signed int error;
  // send
  signed int (*send)(struct connection_tag *, const void *, unsigned long int);
  // read
  signed int (*read)(struct connection_tag *, void *, unsigned long int);
  // ip
  char *ip;
  // host
  char *host;
};

struct ebml_client_data_st
{
  // header
  struct _refbuf_tag *header;
  // header_pos
  signed int header_pos;
};

struct ebml_source_state_st
{
  // ebml
  struct ebml_st *ebml;
  // header
  struct _refbuf_tag *header;
  // file_headers_written
  signed int file_headers_written;
};

struct ebml_st
{
  // cluster_id
  char *cluster_id;
  // cluster_start
  signed int cluster_start;
  // position
  signed int position;
  // input_buffer
  unsigned char *input_buffer;
  // buffer
  unsigned char *buffer;
  // header_read
  signed int header_read;
  // header_size
  signed int header_size;
  // header_position
  signed int header_position;
  // header_read_position
  signed int header_read_position;
  // header
  unsigned char *header;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct http_parser_tag
{
  // req_type
  enum httpp_request_type_tag req_type;
  // uri
  char *uri;
  // vars
  struct _avl_tree *vars;
  // queryvars
  struct _avl_tree *queryvars;
};

struct http_var_tag
{
  // name
  char *name;
  // value
  char *value;
};

struct http_varlist_tag
{
  // var
  struct http_var_tag var;
  // next
  struct http_varlist_tag *next;
};

struct ice_config_dir_tag
{
  // host
  char *host;
  // touch_interval
  signed int touch_interval;
  // next
  struct ice_config_dir_tag *next;
};

struct ice_config_http_header_tag
{
  // type
  enum _http_header_type type;
  // name
  char *name;
  // value
  char *value;
  // status
  signed int status;
  // next
  struct ice_config_http_header_tag *next;
};

struct ice_config_tag
{
  // config_filename
  char *config_filename;
  // location
  char *location;
  // admin
  char *admin;
  // client_limit
  signed int client_limit;
  // source_limit
  signed int source_limit;
  // queue_size_limit
  unsigned int queue_size_limit;
  // threadpool_size
  signed int threadpool_size;
  // burst_size
  unsigned int burst_size;
  // client_timeout
  signed int client_timeout;
  // header_timeout
  signed int header_timeout;
  // source_timeout
  signed int source_timeout;
  // ice_login
  signed int ice_login;
  // fileserve
  signed int fileserve;
  // on_demand
  signed int on_demand;
  // shoutcast_mount
  char *shoutcast_mount;
  // source_password
  char *source_password;
  // admin_username
  char *admin_username;
  // admin_password
  char *admin_password;
  // relay_username
  char *relay_username;
  // relay_password
  char *relay_password;
  // touch_interval
  signed int touch_interval;
  // dir_list
  struct ice_config_dir_tag *dir_list;
  // hostname
  char *hostname;
  // port
  signed int port;
  // mimetypes_fn
  char *mimetypes_fn;
  // listen_sock
  struct _listener_t *listen_sock;
  // listen_sock_count
  unsigned int listen_sock_count;
  // master_server
  char *master_server;
  // master_server_port
  signed int master_server_port;
  // master_update_interval
  signed int master_update_interval;
  // master_username
  char *master_username;
  // master_password
  char *master_password;
  // http_headers
  struct ice_config_http_header_tag *http_headers;
  // relay
  struct _relay_server *relay;
  // mounts
  struct _mount_proxy *mounts;
  // server_id
  char *server_id;
  // base_dir
  char *base_dir;
  // log_dir
  char *log_dir;
  // pidfile
  char *pidfile;
  // banfile
  char *banfile;
  // allowfile
  char *allowfile;
  // cert_file
  char *cert_file;
  // cipher_list
  char *cipher_list;
  // webroot_dir
  char *webroot_dir;
  // adminroot_dir
  char *adminroot_dir;
  // aliases
  struct _aliases *aliases;
  // access_log
  char *access_log;
  // error_log
  char *error_log;
  // playlist_log
  char *playlist_log;
  // loglevel
  signed int loglevel;
  // logsize
  signed int logsize;
  // logarchive
  signed int logarchive;
  // chroot
  signed int chroot;
  // chuid
  signed int chuid;
  // user
  char *user;
  // group
  char *group;
  // yp_url
  char *yp_url[25l];
  // yp_url_timeout
  signed int yp_url_timeout[25l];
  // yp_touch_interval
  signed int yp_touch_interval[25l];
  // num_yp_directories
  signed int num_yp_directories;
};

struct ice_global_tag
{
  // serversock
  signed int *serversock;
  // server_sockets
  signed int server_sockets;
  // running
  signed int running;
  // sources
  signed int sources;
  // clients
  signed int clients;
  // schedule_config_reread
  signed int schedule_config_reread;
  // source_tree
  struct _avl_tree *source_tree;
  // relays
  struct _relay_server *relays;
  // master_relays
  struct _relay_server *master_relays;
  // shutdown_cond
  struct anonymous_27 shutdown_cond;
};

struct in6_addr
{
  // __in6_u
  union anonymous_36 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct log_tag
{
  // in_use
  signed int in_use;
  // level
  unsigned int level;
  // filename
  char *filename;
  // logfile
  struct _IO_FILE *logfile;
  // size
  signed long int size;
  // trigger_level
  signed long int trigger_level;
  // archive_timestamp
  signed int archive_timestamp;
  // total
  unsigned long int total;
  // entries
  unsigned int entries;
  // keep_entries
  unsigned int keep_entries;
  // log_head
  struct _log_entry_t *log_head;
  // log_tail
  struct _log_entry_t **log_tail;
  // buffer
  char *buffer;
};

struct ogg_client
{
  // headers
  struct _refbuf_tag *headers;
  // header_page
  struct _refbuf_tag *header_page;
  // pos
  unsigned int pos;
  // headers_sent
  signed int headers_sent;
};

struct ogg_codec_tag
{
  // next
  struct ogg_codec_tag *next;
  // os
  struct anonymous_2 os;
  // headers
  unsigned int headers;
  // name
  const char *name;
  // specific
  void *specific;
  // possible_start
  struct _refbuf_tag *possible_start;
  // page
  struct _refbuf_tag *page;
  // process
  struct _refbuf_tag * (*process)(struct ogg_state_tag *, struct ogg_codec_tag *);
  // process_page
  struct _refbuf_tag * (*process_page)(struct ogg_state_tag *, struct ogg_codec_tag *, struct anonymous_3 *);
  // codec_free
  void (*codec_free)(struct ogg_state_tag *, struct ogg_codec_tag *);
};

struct ogg_state_tag
{
  // mount
  char *mount;
  // oy
  struct anonymous_1 oy;
  // error
  signed int error;
  // codec_count
  signed int codec_count;
  // codecs
  struct ogg_codec_tag *codecs;
  // artist
  char *artist;
  // title
  char *title;
  // log_metadata
  signed int log_metadata;
  // file_headers
  struct _refbuf_tag *file_headers;
  // header_pages
  struct _refbuf_tag *header_pages;
  // header_pages_tail
  struct _refbuf_tag *header_pages_tail;
  // bos_end
  struct _refbuf_tag **bos_end;
  // bos_completed
  signed int bos_completed;
  // bitrate
  signed long int bitrate;
  // current
  struct ogg_codec_tag *current;
  // codec_sync
  struct ogg_codec_tag *codec_sync;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct source_tag
{
  // lock
  struct anonymous_4 lock;
  // client
  struct _client_tag *client;
  // con
  struct connection_tag *con;
  // parser
  struct http_parser_tag *parser;
  // client_stats_update
  signed long int client_stats_update;
  // mount
  char *mount;
  // fallback_mount
  char *fallback_mount;
  // running
  signed int running;
  // format
  struct _format_plugin_tag *format;
  // client_tree
  struct _avl_tree *client_tree;
  // pending_tree
  struct _avl_tree *pending_tree;
  // shutdown_rwlock
  struct anonymous_16 *shutdown_rwlock;
  // audio_info
  struct _util_dict *audio_info;
  // intro_file
  struct _IO_FILE *intro_file;
  // dumpfilename
  char *dumpfilename;
  // dumpfile
  struct _IO_FILE *dumpfile;
  // peak_listeners
  unsigned long int peak_listeners;
  // listeners
  unsigned long int listeners;
  // prev_listeners
  unsigned long int prev_listeners;
  // max_listeners
  signed long int max_listeners;
  // yp_public
  signed int yp_public;
  // fallback_override
  signed int fallback_override;
  // fallback_when_full
  signed int fallback_when_full;
  // shoutcast_compat
  signed int shoutcast_compat;
  // burst_size
  unsigned int burst_size;
  // burst_offset
  unsigned int burst_offset;
  // burst_point
  struct _refbuf_tag *burst_point;
  // queue_size
  unsigned int queue_size;
  // queue_size_limit
  unsigned int queue_size_limit;
  // timeout
  unsigned int timeout;
  // on_demand
  signed int on_demand;
  // on_demand_req
  signed int on_demand_req;
  // hidden
  signed int hidden;
  // last_read
  signed long int last_read;
  // short_delay
  signed int short_delay;
  // stream_data
  struct _refbuf_tag *stream_data;
  // stream_data_tail
  struct _refbuf_tag *stream_data_tail;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct thread_start_tag
{
  // start_routine
  void * (*start_routine)(void *);
  // arg
  void *arg;
  // thread
  struct anonymous_24 *thread;
  // sys_thread
  unsigned long int sys_thread;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct vorbis_info
{
  // version
  signed int version;
  // channels
  signed int channels;
  // rate
  signed long int rate;
  // bitrate_upper
  signed long int bitrate_upper;
  // bitrate_nominal
  signed long int bitrate_nominal;
  // bitrate_lower
  signed long int bitrate_lower;
  // bitrate_window
  signed long int bitrate_window;
  // codec_setup
  void *codec_setup;
};

struct vorbis_comment
{
  // user_comments
  char **user_comments;
  // comment_lengths
  signed int *comment_lengths;
  // comments
  signed int comments;
  // vendor
  char *vendor;
};

struct vorbis_codec_tag
{
  // vi
  struct vorbis_info vi;
  // vc
  struct vorbis_comment vc;
  // rebuild_comment
  signed int rebuild_comment;
  // stream_notify
  signed int stream_notify;
  // initial_audio_page
  signed int initial_audio_page;
  // new_os
  struct anonymous_2 new_os;
  // page_samples_trigger
  signed int page_samples_trigger;
  // prev_granulepos
  signed long int prev_granulepos;
  // prev_packet
  struct anonymous_14 *prev_packet;
  // granulepos
  signed long int granulepos;
  // initial_page_granulepos
  signed long int initial_page_granulepos;
  // samples_in_page
  signed long int samples_in_page;
  // prev_window
  signed int prev_window;
  // initial_audio_packet
  signed int initial_audio_packet;
  // bos_page
  struct anonymous_3 bos_page;
  // header
  struct anonymous_14 *header[3l];
  // prev_page_samples
  signed long int prev_page_samples;
  // process_packet
  signed int (*process_packet)(struct ogg_state_tag *, struct ogg_codec_tag *);
  // get_buffer_page
  struct _refbuf_tag * (*get_buffer_page)(struct ogg_state_tag *, struct ogg_codec_tag *);
};

struct yp_server
{
  // url
  char *url;
  // server_id
  char *server_id;
  // url_timeout
  unsigned int url_timeout;
  // touch_interval
  unsigned int touch_interval;
  // remove
  signed int remove;
  // curl
  void *curl;
  // mounts
  struct ypdata_tag *mounts;
  // pending_mounts
  struct ypdata_tag *pending_mounts;
  // next
  struct yp_server *next;
  // curl_error
  char curl_error[256l];
};

struct ypdata_tag
{
  // remove
  signed int remove;
  // release
  signed int release;
  // cmd_ok
  signed int cmd_ok;
  // sid
  char *sid;
  // mount
  char *mount;
  // url
  char *url;
  // listen_url
  char *listen_url;
  // server_name
  char *server_name;
  // server_desc
  char *server_desc;
  // server_genre
  char *server_genre;
  // cluster_password
  char *cluster_password;
  // bitrate
  char *bitrate;
  // audio_info
  char *audio_info;
  // server_type
  char *server_type;
  // current_song
  char *current_song;
  // subtype
  char *subtype;
  // server
  struct yp_server *server;
  // next_update
  signed long int next_update;
  // touch_interval
  unsigned int touch_interval;
  // error_msg
  char *error_msg;
  // process
  signed int (*process)(struct ypdata_tag *, char *, unsigned int);
  // next
  struct ypdata_tag *next;
};


// _con_queue
// file connection.c line 113
static volatile struct client_queue_tag *_con_queue = (volatile struct client_queue_tag *)(void *)0;
// _con_queue_tail
// file connection.c line 113
static volatile struct client_queue_tag **_con_queue_tail;
// _con_queue_tail
// file connection.c line 113
static volatile struct client_queue_tag **_con_queue_tail = &_con_queue;
// _connection_lock
// file connection.c line 108
static struct anonymous_41 _connection_lock;
// _current_configuration
// file cfgfile.c line 78
static struct ice_config_tag _current_configuration;
// _current_id
// file connection.c line 109
static volatile unsigned long int _current_id = (volatile unsigned long int)0;
// _event_listeners
// file stats.c line 84
static volatile struct _event_listener_tag *_event_listeners;
// _global_event_mutex
// file stats.c line 82
struct anonymous_4 _global_event_mutex;
// _global_event_queue
// file stats.c line 81
static struct _event_queue_tag _global_event_queue;
// _global_mutex
// file global.c line 34
static struct anonymous_4 _global_mutex;
// _initialized
// file connection.c line 110
static signed int _initialized = 0;
// _initialized_link1
// file resolver.c line 59
static signed int _initialized_link1 = 0;
// _initialized_link2
// file thread.c line 87
static signed int _initialized_link2 = 0;
// _initialized_link3
// file log.c line 47
static signed int _initialized_link3 = 0;
// _library_mutex
// file thread.c line 112
static struct anonymous_4 _library_mutex = { .sys_mutex={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// _locks
// file cfgfile.c line 79
static struct anonymous_17 _locks;
// _logger_mutex
// file log.c line 46
static union anonymous_21 _logger_mutex;
// _next_thread_id
// file thread.c line 86
static signed long int _next_thread_id = (signed long int)0;
// _req_queue
// file connection.c line 112
static volatile struct client_queue_tag *_req_queue = (volatile struct client_queue_tag *)(void *)0;
// _req_queue_tail
// file connection.c line 112
static volatile struct client_queue_tag **_req_queue_tail;
// _req_queue_tail
// file connection.c line 112
static volatile struct client_queue_tag **_req_queue_tail = &_req_queue;
// _resolver_mutex
// file resolver.c line 57
static struct anonymous_4 _resolver_mutex;
// _slave_mutex
// file slave.c line 68
static struct anonymous_4 _slave_mutex;
// _slave_thread_id
// file slave.c line 63
static struct anonymous_24 *_slave_thread_id;
// _source_shutdown_rwlock
// file connection.c line 122
struct anonymous_16 _source_shutdown_rwlock;
// _stats
// file stats.c line 78
static struct _stats_tag _stats;
// _stats_mutex
// file stats.c line 79
static struct anonymous_4 _stats_mutex;
// _stats_running
// file stats.c line 74
static volatile signed int _stats_running = 0;
// _stats_thread_id
// file stats.c line 75
static struct anonymous_24 *_stats_thread_id;
// _stats_threads
// file stats.c line 76
static volatile signed int _stats_threads = 0;
// _threadtree
// file thread.c line 88
static struct _avl_tree *_threadtree = (struct _avl_tree *)(void *)0;
// _threadtree_mutex
// file thread.c line 94
static struct anonymous_4 _threadtree_mutex = { .sys_mutex={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// accesslog
// file logging.c line 41
signed int accesslog = 0;
// active_list
// file fserve.c line 72
static struct _fserve_t *active_list = (struct _fserve_t *)(void *)0;
// active_yps
// file yp.c line 89
static struct yp_server *active_yps = (struct yp_server *)(void *)0;
// allowed_ip
// file connection.c line 120
static struct anonymous_42 allowed_ip;
// background
// file main.c line 77
static signed int background;
// balance_chars
// file avl.c line 1072
static char balance_chars[3l] = { (char)92, (char)45, (char)47 };
// banned_ip
// file connection.c line 120
static struct anonymous_42 banned_ip;
// base64decode
// file util.c line 379
static signed char base64decode[256l] = { (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)62, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)63, (signed char)52, (signed char)53, (signed char)54, (signed char)55, (signed char)56, (signed char)57, (signed char)58, (signed char)59, (signed char)60, (signed char)61, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-1, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)0, (signed char)1, (signed char)2, (signed char)3, (signed char)4, (signed char)5, (signed char)6, (signed char)7, (signed char)8, (signed char)9, (signed char)10, (signed char)11, (signed char)12, (signed char)13, (signed char)14, (signed char)15, (signed char)16, (signed char)17, (signed char)18, (signed char)19, (signed char)20, (signed char)21, (signed char)22, (signed char)23, (signed char)24, (signed char)25, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)26, (signed char)27, (signed char)28, (signed char)29, (signed char)30, (signed char)31, (signed char)32, (signed char)33, (signed char)34, (signed char)35, (signed char)36, (signed char)37, (signed char)38, (signed char)39, (signed char)40, (signed char)41, (signed char)42, (signed char)43, (signed char)44, (signed char)45, (signed char)46, (signed char)47, (signed char)48, (signed char)49, (signed char)50, (signed char)51, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2, (signed char)-2 };
// base64table
// file util.c line 372
static char base64table[64l] = { (char)65, (char)66, (char)67, (char)68, (char)69, (char)70, (char)71, (char)72, (char)73, (char)74, (char)75, (char)76, (char)77, (char)78, (char)79, (char)80, (char)81, (char)82, (char)83, (char)84, (char)85, (char)86, (char)87, (char)88, (char)89, (char)90, (char)97, (char)98, (char)99, (char)100, (char)101, (char)102, (char)103, (char)104, (char)105, (char)106, (char)107, (char)108, (char)109, (char)110, (char)111, (char)112, (char)113, (char)114, (char)115, (char)116, (char)117, (char)118, (char)119, (char)120, (char)121, (char)122, (char)48, (char)49, (char)50, (char)51, (char)52, (char)53, (char)54, (char)55, (char)56, (char)57, (char)43, (char)47 };
// cache
// file xslt.c line 95
static struct anonymous_43 cache[3l];
// client_limit
// file yp.c line 94
static volatile unsigned int client_limit = (volatile unsigned int)0;
// client_tree_changed
// file fserve.c line 80
static signed int client_tree_changed = 0;
// errorlog
// file logging.c line 40
signed int errorlog = 0;
// fserve_clients
// file fserve.c line 79
static unsigned int fserve_clients;
// global
// file global.c line 32
struct ice_global_tag global;
// hexchars
// file util.c line 245
static char hexchars[16l] = { (char)48, (char)49, (char)50, (char)51, (char)52, (char)53, (char)54, (char)55, (char)56, (char)57, (char)97, (char)98, (char)99, (char)100, (char)101, (char)102 };
// loglist
// file log.c line 78
static struct log_tag loglist[25l];
// max_interval
// file slave.c line 67
static volatile unsigned int max_interval = (volatile unsigned int)0;
// mimetypes
// file fserve.c line 76
static struct _avl_tree *mimetypes = (struct _avl_tree *)(void *)0;
// move_clients_mutex
// file source.c line 70
struct anonymous_4 move_clients_mutex;
// now
// file yp.c line 92
static signed long int now;
// pending_list
// file fserve.c line 73
static struct _fserve_t *pending_list = (struct _fserve_t *)(void *)0;
// pending_lock
// file fserve.c line 75
static struct anonymous_41 pending_lock;
// pending_yps
// file yp.c line 89
static struct yp_server *pending_yps = (struct yp_server *)(void *)0;
// pidfile
// file main.c line 78
static char *pidfile = (char *)(void *)0;
// playlistlog
// file logging.c line 42
signed int playlistlog = 0;
// run_fserv
// file fserve.c line 78
static volatile signed int run_fserv = 0;
// safechars
// file util.c line 249
static char safechars[256l] = { (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0 };
// server_version
// file yp.c line 95
static volatile char *server_version = (volatile char *)(void *)0;
// slave_running
// file slave.c line 64
static signed int slave_running = 0;
// ssl_ok
// file connection.c line 114
static signed int ssl_ok;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// ufds
// file fserve.c line 83
static struct pollfd *ufds = (struct pollfd *)(void *)0;
// update_all_mounts
// file slave.c line 66
static volatile signed int update_all_mounts = 0;
// update_settings
// file slave.c line 65
static volatile signed int update_settings = 0;
// xmlFree
// file /usr/include/libxml2/libxml/globals.h line 251
extern void (*xmlFree)(void *);
// xsltlock
// file xslt.c line 96
static struct anonymous_4 xsltlock;
// yp_lock
// file yp.c line 86
static struct anonymous_16 yp_lock;
// yp_pending_lock
// file yp.c line 87
static struct anonymous_4 yp_pending_lock;
// yp_running
// file yp.c line 91
static signed int yp_running;
// yp_thread
// file yp.c line 93
static struct anonymous_24 *yp_thread;
// yp_update
// file yp.c line 90
static volatile signed int yp_update = 0;

// MD5Final
// file md5.c line 136
void MD5Final(unsigned char *digest, struct MD5Context *ctx)
{
  unsigned int count;
  unsigned char *p;
  count = ctx->bits[(signed long int)0] >> 3 & (unsigned int)0x3F;
  p = ctx->in + (signed long int)count;
  unsigned char *tmp_post_1 = p;
  p = p + 1l;
  *tmp_post_1 = (unsigned char)0x80;
  count = (unsigned int)(64 - 1) - count;
  if(!(count >= 8u))
  {
    memset((void *)p, 0, (unsigned long int)count);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    memset((void *)ctx->in, 0, (unsigned long int)56);
  }

  else
    memset((void *)p, 0, (unsigned long int)(count - (unsigned int)8));
  byteReverse(ctx->in, (unsigned int)14);
  ((unsigned int *)ctx->in)[(signed long int)14] = ctx->bits[(signed long int)0];
  ((unsigned int *)ctx->in)[(signed long int)15] = ctx->bits[(signed long int)1];
  MD5Transform(ctx->buf, (unsigned int *)ctx->in);
  byteReverse((unsigned char *)ctx->buf, (unsigned int)4);
  memcpy((void *)digest, (const void *)ctx->buf, (unsigned long int)16);
  memset((void *)ctx, 0, sizeof(struct MD5Context *) /*8ul*/ );
}

// MD5Init
// file md5.c line 68
void MD5Init(struct MD5Context *ctx)
{
  ctx->buf[(signed long int)0] = (unsigned int)0x67452301;
  ctx->buf[(signed long int)1] = 0xefcdab89;
  ctx->buf[(signed long int)2] = 0x98badcfe;
  ctx->buf[(signed long int)3] = (unsigned int)0x10325476;
  ctx->bits[(signed long int)0] = (unsigned int)0;
  ctx->bits[(signed long int)1] = (unsigned int)0;
}

// MD5Transform
// file md5.c line 197
static void MD5Transform(unsigned int *buf, const unsigned int *in)
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  a = buf[(signed long int)0];
  b = buf[(signed long int)1];
  c = buf[(signed long int)2];
  d = buf[(signed long int)3];
  do
  {
    a = a + (d ^ b & (c ^ d)) + in[(signed long int)0] + 0xd76aa478;
    a = a << 7 | a >> 32 - 7;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (c ^ a & (b ^ c)) + in[(signed long int)1] + 0xe8c7b756;
    d = d << 12 | d >> 32 - 12;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (b ^ d & (a ^ b)) + in[(signed long int)2] + (unsigned int)0x242070db;
    c = c << 17 | c >> 32 - 17;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (a ^ c & (d ^ a)) + in[(signed long int)3] + 0xc1bdceee;
    b = b << 22 | b >> 32 - 22;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (d ^ b & (c ^ d)) + in[(signed long int)4] + 0xf57c0faf;
    a = a << 7 | a >> 32 - 7;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (c ^ a & (b ^ c)) + in[(signed long int)5] + (unsigned int)0x4787c62a;
    d = d << 12 | d >> 32 - 12;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (b ^ d & (a ^ b)) + in[(signed long int)6] + 0xa8304613;
    c = c << 17 | c >> 32 - 17;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (a ^ c & (d ^ a)) + in[(signed long int)7] + 0xfd469501;
    b = b << 22 | b >> 32 - 22;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (d ^ b & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x698098d8;
    a = a << 7 | a >> 32 - 7;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (c ^ a & (b ^ c)) + in[(signed long int)9] + 0x8b44f7af;
    d = d << 12 | d >> 32 - 12;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (b ^ d & (a ^ b)) + in[(signed long int)10] + 0xffff5bb1;
    c = c << 17 | c >> 32 - 17;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (a ^ c & (d ^ a)) + in[(signed long int)11] + 0x895cd7be;
    b = b << 22 | b >> 32 - 22;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (d ^ b & (c ^ d)) + in[(signed long int)12] + (unsigned int)0x6b901122;
    a = a << 7 | a >> 32 - 7;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (c ^ a & (b ^ c)) + in[(signed long int)13] + 0xfd987193;
    d = d << 12 | d >> 32 - 12;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (b ^ d & (a ^ b)) + in[(signed long int)14] + 0xa679438e;
    c = c << 17 | c >> 32 - 17;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (a ^ c & (d ^ a)) + in[(signed long int)15] + (unsigned int)0x49b40821;
    b = b << 22 | b >> 32 - 22;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (c ^ d & (b ^ c)) + in[(signed long int)1] + 0xf61e2562;
    a = a << 5 | a >> 32 - 5;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (b ^ c & (a ^ b)) + in[(signed long int)6] + 0xc040b340;
    d = d << 9 | d >> 32 - 9;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (a ^ b & (d ^ a)) + in[(signed long int)11] + (unsigned int)0x265e5a51;
    c = c << 14 | c >> 32 - 14;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (d ^ a & (c ^ d)) + in[(signed long int)0] + 0xe9b6c7aa;
    b = b << 20 | b >> 32 - 20;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (c ^ d & (b ^ c)) + in[(signed long int)5] + 0xd62f105d;
    a = a << 5 | a >> 32 - 5;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (b ^ c & (a ^ b)) + in[(signed long int)10] + (unsigned int)0x02441453;
    d = d << 9 | d >> 32 - 9;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (a ^ b & (d ^ a)) + in[(signed long int)15] + 0xd8a1e681;
    c = c << 14 | c >> 32 - 14;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (d ^ a & (c ^ d)) + in[(signed long int)4] + 0xe7d3fbc8;
    b = b << 20 | b >> 32 - 20;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (c ^ d & (b ^ c)) + in[(signed long int)9] + (unsigned int)0x21e1cde6;
    a = a << 5 | a >> 32 - 5;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (b ^ c & (a ^ b)) + in[(signed long int)14] + 0xc33707d6;
    d = d << 9 | d >> 32 - 9;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (a ^ b & (d ^ a)) + in[(signed long int)3] + 0xf4d50d87;
    c = c << 14 | c >> 32 - 14;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (d ^ a & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x455a14ed;
    b = b << 20 | b >> 32 - 20;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (c ^ d & (b ^ c)) + in[(signed long int)13] + 0xa9e3e905;
    a = a << 5 | a >> 32 - 5;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (b ^ c & (a ^ b)) + in[(signed long int)2] + 0xfcefa3f8;
    d = d << 9 | d >> 32 - 9;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (a ^ b & (d ^ a)) + in[(signed long int)7] + (unsigned int)0x676f02d9;
    c = c << 14 | c >> 32 - 14;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (d ^ a & (c ^ d)) + in[(signed long int)12] + 0x8d2a4c8a;
    b = b << 20 | b >> 32 - 20;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (b ^ c ^ d) + in[(signed long int)5] + 0xfffa3942;
    a = a << 4 | a >> 32 - 4;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (a ^ b ^ c) + in[(signed long int)8] + 0x8771f681;
    d = d << 11 | d >> 32 - 11;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (d ^ a ^ b) + in[(signed long int)11] + (unsigned int)0x6d9d6122;
    c = c << 16 | c >> 32 - 16;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (c ^ d ^ a) + in[(signed long int)14] + 0xfde5380c;
    b = b << 23 | b >> 32 - 23;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (b ^ c ^ d) + in[(signed long int)1] + 0xa4beea44;
    a = a << 4 | a >> 32 - 4;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (a ^ b ^ c) + in[(signed long int)4] + (unsigned int)0x4bdecfa9;
    d = d << 11 | d >> 32 - 11;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (d ^ a ^ b) + in[(signed long int)7] + 0xf6bb4b60;
    c = c << 16 | c >> 32 - 16;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (c ^ d ^ a) + in[(signed long int)10] + 0xbebfbc70;
    b = b << 23 | b >> 32 - 23;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (b ^ c ^ d) + in[(signed long int)13] + (unsigned int)0x289b7ec6;
    a = a << 4 | a >> 32 - 4;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (a ^ b ^ c) + in[(signed long int)0] + 0xeaa127fa;
    d = d << 11 | d >> 32 - 11;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (d ^ a ^ b) + in[(signed long int)3] + 0xd4ef3085;
    c = c << 16 | c >> 32 - 16;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (c ^ d ^ a) + in[(signed long int)6] + (unsigned int)0x04881d05;
    b = b << 23 | b >> 32 - 23;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (b ^ c ^ d) + in[(signed long int)9] + 0xd9d4d039;
    a = a << 4 | a >> 32 - 4;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (a ^ b ^ c) + in[(signed long int)12] + 0xe6db99e5;
    d = d << 11 | d >> 32 - 11;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (d ^ a ^ b) + in[(signed long int)15] + (unsigned int)0x1fa27cf8;
    c = c << 16 | c >> 32 - 16;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (c ^ d ^ a) + in[(signed long int)2] + 0xc4ac5665;
    b = b << 23 | b >> 32 - 23;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (c ^ (b | ~d)) + in[(signed long int)0] + 0xf4292244;
    a = a << 6 | a >> 32 - 6;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (b ^ (a | ~c)) + in[(signed long int)7] + (unsigned int)0x432aff97;
    d = d << 10 | d >> 32 - 10;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (a ^ (d | ~b)) + in[(signed long int)14] + 0xab9423a7;
    c = c << 15 | c >> 32 - 15;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (d ^ (c | ~a)) + in[(signed long int)5] + 0xfc93a039;
    b = b << 21 | b >> 32 - 21;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (c ^ (b | ~d)) + in[(signed long int)12] + (unsigned int)0x655b59c3;
    a = a << 6 | a >> 32 - 6;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (b ^ (a | ~c)) + in[(signed long int)3] + 0x8f0ccc92;
    d = d << 10 | d >> 32 - 10;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (a ^ (d | ~b)) + in[(signed long int)10] + 0xffeff47d;
    c = c << 15 | c >> 32 - 15;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (d ^ (c | ~a)) + in[(signed long int)1] + 0x85845dd1;
    b = b << 21 | b >> 32 - 21;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (c ^ (b | ~d)) + in[(signed long int)8] + (unsigned int)0x6fa87e4f;
    a = a << 6 | a >> 32 - 6;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (b ^ (a | ~c)) + in[(signed long int)15] + 0xfe2ce6e0;
    d = d << 10 | d >> 32 - 10;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (a ^ (d | ~b)) + in[(signed long int)6] + 0xa3014314;
    c = c << 15 | c >> 32 - 15;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (d ^ (c | ~a)) + in[(signed long int)13] + (unsigned int)0x4e0811a1;
    b = b << 21 | b >> 32 - 21;
    b = b + c;
  }
  while((_Bool)0);
  do
  {
    a = a + (c ^ (b | ~d)) + in[(signed long int)4] + 0xf7537e82;
    a = a << 6 | a >> 32 - 6;
    a = a + b;
  }
  while((_Bool)0);
  do
  {
    d = d + (b ^ (a | ~c)) + in[(signed long int)11] + 0xbd3af235;
    d = d << 10 | d >> 32 - 10;
    d = d + a;
  }
  while((_Bool)0);
  do
  {
    c = c + (a ^ (d | ~b)) + in[(signed long int)2] + (unsigned int)0x2ad7d2bb;
    c = c << 15 | c >> 32 - 15;
    c = c + d;
  }
  while((_Bool)0);
  do
  {
    b = b + (d ^ (c | ~a)) + in[(signed long int)9] + 0xeb86d391;
    b = b << 21 | b >> 32 - 21;
    b = b + c;
  }
  while((_Bool)0);
  buf[(signed long int)0] = buf[(signed long int)0] + a;
  buf[(signed long int)1] = buf[(signed long int)1] + b;
  buf[(signed long int)2] = buf[(signed long int)2] + c;
  buf[(signed long int)3] = buf[(signed long int)3] + d;
}

// MD5Update
// file md5.c line 83
void MD5Update(struct MD5Context *ctx, const unsigned char *buf, unsigned int len)
{
  unsigned int t = ctx->bits[(signed long int)0];
  ctx->bits[(signed long int)0] = t + ((unsigned int)len << 3);
  if(!(ctx->bits[0l] >= t))
    ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + 1u;

  ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + (len >> 29);
  t = t >> 3 & (unsigned int)0x3f;
  if(!(t == 0u))
  {
    unsigned char *p = (unsigned char *)ctx->in + (signed long int)t;
    t = (unsigned int)64 - t;
    if(!(len >= t))
    {
      memcpy((void *)p, (const void *)buf, (unsigned long int)len);
      goto __CPROVER_DUMP_L5;
    }

    memcpy((void *)p, (const void *)buf, (unsigned long int)t);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    buf = buf + (signed long int)t;
    len = len - t;
  }

  for( ; len >= 64u; len = len - (unsigned int)64)
  {
    memcpy((void *)ctx->in, (const void *)buf, (unsigned long int)64);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    buf = buf + (signed long int)64;
  }
  memcpy((void *)ctx->in, (const void *)buf, (unsigned long int)len);

__CPROVER_DUMP_L5:
  ;
}

// __format_time
// file stats.c line 589
static inline void __format_time(char *buffer, unsigned long int len, const char *format)
{
  signed long int __format_time__1__now;
  __format_time__1__now=time((signed long int *)(void *)0);
  struct tm local;
  char tzbuffer[32l];
  char timebuffer[128l];
  localtime_r(&__format_time__1__now, &local);
  strftime(tzbuffer, sizeof(char [32l]) /*32ul*/ , "%z", &local);
  strftime(timebuffer, sizeof(char [128l]) /*128ul*/ , format, &local);
  snprintf(buffer, len, "%s%s", (const void *)timebuffer, (const void *)tzbuffer);
}

// __setup_empty_script_environment
// file source.c line 1326
static inline void __setup_empty_script_environment(void)
{
  signed int i = 0;
  for( ; !(i >= 1024); i = i + 1)
    close(i);
  i=open("/dev/null", 02);
  if(!(i == -1))
  {
    if(!(i == 0))
      dup2(i, 0);

    if(!(i == 1))
      dup2(i, 1);

    if(!(i == 2))
      dup2(i, 2);

    if(i >= 3)
      close(i);

  }

}

// __vsnprintf
// file log.c line 422
static void __vsnprintf(char *str, unsigned long int size, const char *format, __builtin_va_list ap)
{
  signed int in_block = 0;
  signed int block_size = 0;
  signed int block_len;
  signed int block_space = 0;
  const char *arg;
  char buf[80l];
  char *tmp_post_1;
  _Bool tmp_if_expr_2;
  void *return_value_gcc_builtin_va_arg_3;
  unsigned int return_value_gcc_builtin_va_arg_4;
  signed int return_value_gcc_builtin_va_arg_5;
  unsigned long int return_value_gcc_builtin_va_arg_6;
  signed long int return_value_gcc_builtin_va_arg_7;
  unsigned long long int return_value_gcc_builtin_va_arg_8;
  signed long long int return_value_gcc_builtin_va_arg_9;
  unsigned long int return_value_strlen_10;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_15;
  char *tmp_post_11;
  char *tmp_post_12;
  char *tmp_post_17;
  for( ; !(*format == 0) && !(size == 0ul); format = format + 1l)
    if(in_block == 0)
    {
      if((signed int)*format == 37)
      {
        in_block = 1;
        block_size = 0;
        block_len = 0;
        block_space = 0;
      }

      else
      {
        tmp_post_1 = str;
        str = str + 1l;
        *tmp_post_1 = *format;
        size = size - 1ul;
      }
    }

    else
    {
      arg = (const char *)(void *)0;
      switch((signed int)*format)
      {
        case 108:
        {
          block_size = block_size + 1;
          break;
        }
        case 46:
          break;
        case 42:
        {
          block_len=va_arg(ap, __typeof__(block_len));
          break;
        }
        case 32:
        {
          block_space = 1;
          break;
        }
        case 49:

        case 50:

        case 51:

        case 52:

        case 53:

        case 54:

        case 55:

        case 56:

        case 57:
        {
          block_len=atoi(format);
          do
          {
            if((signed int)*format >= 48)
              tmp_if_expr_2 = (signed int)*format <= 57 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_2 = (_Bool)0;
            if(!tmp_if_expr_2)
              break;

            format = format + 1l;
          }
          while((_Bool)1);
          format = format - 1l;
          break;
        }
        case 112:
        {
          return_value_gcc_builtin_va_arg_3=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_3));
          snprintf(buf, sizeof(char [80l]) /*80ul*/ , "%p", (void *)return_value_gcc_builtin_va_arg_3);
          arg = buf;
        }
        case 100:

        case 105:

        case 117:
          if(arg == ((const char *)NULL))
          {
            switch(block_size)
            {
              case 0:
              {
                if((signed int)*format == 117)
                {
                  return_value_gcc_builtin_va_arg_4=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_4));
                  snprintf(buf, sizeof(char [80l]) /*80ul*/ , "%u", (unsigned int)return_value_gcc_builtin_va_arg_4);
                }

                else
                {
                  return_value_gcc_builtin_va_arg_5=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_5));
                  snprintf(buf, sizeof(char [80l]) /*80ul*/ , "%i", (signed int)return_value_gcc_builtin_va_arg_5);
                }
                break;
              }
              case 1:
              {
                if((signed int)*format == 117)
                {
                  return_value_gcc_builtin_va_arg_6=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_6));
                  snprintf(buf, sizeof(char [80l]) /*80ul*/ , "%lu", (unsigned long int)return_value_gcc_builtin_va_arg_6);
                }

                else
                {
                  return_value_gcc_builtin_va_arg_7=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_7));
                  snprintf(buf, sizeof(char [80l]) /*80ul*/ , "%li", (signed long int)return_value_gcc_builtin_va_arg_7);
                }
                break;
              }
              case 2:
              {
                if((signed int)*format == 117)
                {
                  return_value_gcc_builtin_va_arg_8=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_8));
                  snprintf(buf, sizeof(char [80l]) /*80ul*/ , "%llu", (unsigned long long int)return_value_gcc_builtin_va_arg_8);
                }

                else
                {
                  return_value_gcc_builtin_va_arg_9=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_9));
                  snprintf(buf, sizeof(char [80l]) /*80ul*/ , "%lli", (signed long long int)return_value_gcc_builtin_va_arg_9);
                }
                break;
              }
              default:
                snprintf(buf, sizeof(char [80l]) /*80ul*/ , "<<<invalid>>>");
            }
            arg = buf;
          }

        case 115:

        case 72:
        {
          if(arg == ((const char *)NULL))
            arg=va_arg(ap, __typeof__(arg));

          if(arg == ((const char *)NULL))
            arg = "(null)";

          if(block_len == 0)
          {
            return_value_strlen_10=strlen(arg);
            block_len = (signed int)return_value_strlen_10;
          }

          if((signed int)*format == 72)
            for( ; !(*arg == 0) && !(block_len == 0) && !(size == 0ul); block_len = block_len - 1)
            {
              if(!((signed int)*arg >= 35))
                tmp_if_expr_13 = (_Bool)1;

              else
                tmp_if_expr_13 = (signed int)*arg == 96 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_13)
                tmp_if_expr_14 = (_Bool)1;

              else
                tmp_if_expr_14 = (signed int)*arg == 92 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_14)
              {
                if(!(block_space == 0))
                  tmp_if_expr_15 = (signed int)*arg == 32 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_15 = (_Bool)0;
                tmp_if_expr_16 = !tmp_if_expr_15 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_16 = (_Bool)0;
              if(tmp_if_expr_16)
              {
                tmp_post_11 = str;
                str = str + 1l;
                *tmp_post_11 = (char)46;
              }

              else
              {
                tmp_post_12 = str;
                str = str + 1l;
                *tmp_post_12 = *arg;
              }
              arg = arg + 1l;
              size = size - 1ul;
            }

          else
            for( ; !(*arg == 0) && !(block_len == 0) && !(size == 0ul); block_len = block_len - 1)
            {
              tmp_post_17 = str;
              str = str + 1l;
              *tmp_post_17 = *arg;
              arg = arg + 1l;
              size = size - 1ul;
            }
          in_block = 0;
        }
        default:
          ;
      }
    }
  if(size == 0ul)
    str = str - 1l;

  *str = (char)0;
}

// _accept_connection
// file connection.c line 530
static struct connection_tag * _accept_connection(signed int duration)
{
  signed int sock;
  signed int serversock;
  char *ip;
  serversock=wait_for_serversock(duration);
  unsigned long int return_value_strlen_2;
  if(serversock == -1)
    return (struct connection_tag *)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)46);
    ip = (char *)return_value_malloc_1;
    sock=sock_accept(serversock, ip, (unsigned long int)46);
    if(!(sock == -1))
    {
      struct connection_tag *con = (struct connection_tag *)(void *)0;
      signed int return_value_strncmp_3;
      return_value_strncmp_3=strncmp(ip, "::ffff:", (unsigned long int)7);
      if(return_value_strncmp_3 == 0)
      {
        return_value_strlen_2=strlen(ip + (signed long int)7);
        memmove((void *)ip, (const void *)(ip + (signed long int)7), return_value_strlen_2 + (unsigned long int)1);
      }

      signed int return_value_accept_ip_address_4;
      return_value_accept_ip_address_4=accept_ip_address(ip);
      if(!(return_value_accept_ip_address_4 == 0))
        con=connection_create(sock, serversock, ip);

      if(!(con == ((struct connection_tag *)NULL)))
        return con;

      sock_close(sock);
    }

    else
    {
      signed int return_value_sock_error_8;
      return_value_sock_error_8=sock_error();
      signed int return_value_sock_recoverable_9;
      return_value_sock_recoverable_9=sock_recoverable(return_value_sock_error_8);
      if(return_value_sock_recoverable_9 == 0)
      {
        signed int return_value_sock_error_5;
        return_value_sock_error_5=sock_error();
        signed int return_value_sock_error_6;
        return_value_sock_error_6=sock_error();
        char *return_value_strerror_7;
        return_value_strerror_7=strerror(return_value_sock_error_6);
        log_write(errorlog, (unsigned int)2, "connection/", "_accept_connection", "accept() failed with error %d: %s", return_value_sock_error_5, return_value_strerror_7);
        thread_sleep((unsigned long int)500000);
      }

    }
    free((void *)ip);
    return (struct connection_tag *)(void *)0;
  }
}

// _add_connection
// file connection.c line 573
static void _add_connection(struct client_queue_tag *node)
{
  thread_spin_lock(&_connection_lock);
  *_con_queue_tail = node;
  _con_queue_tail = (volatile struct client_queue_tag **)&node->next;
  thread_spin_unlock(&_connection_lock);
}

// _add_event_to_queue
// file stats.c line 773
static void _add_event_to_queue(struct _stats_event_tag *event, struct _event_queue_tag *queue)
{
  *queue->tail = event;
  queue->tail = (volatile struct _stats_event_tag **)&event->next;
}

// _add_request_queue
// file connection.c line 703
static void _add_request_queue(struct client_queue_tag *node)
{
  *_req_queue_tail = node;
  _req_queue_tail = (volatile struct client_queue_tag **)&node->next;
}

// _add_server
// file cfgfile.c line 1291
static void _add_server(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  struct ice_config_dir_tag *dirnode;
  struct ice_config_dir_tag *server;
  signed int addnode;
  char *tmp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ice_config_dir_tag) /*24ul*/ );
  server = (struct ice_config_dir_tag *)return_value_malloc_1;
  server->touch_interval = configuration->touch_interval;
  server->host = (char *)(void *)0;
  addnode = 0;
  signed int return_value_xmlStrcmp_5;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_2;
    return_value_xmlIsBlankNode_2=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_2 == 0)
    {
      signed int return_value_xmlStrcmp_6;
      return_value_xmlStrcmp_6=xmlStrcmp(node->name, (unsigned char *)"host");
      if(return_value_xmlStrcmp_6 == 0)
      {
        unsigned char *return_value_xmlNodeListGetString_3;
        return_value_xmlNodeListGetString_3=xmlNodeListGetString(doc, node->children, 1);
        server->host = (char *)return_value_xmlNodeListGetString_3;
        addnode = 1;
      }

      else
      {
        return_value_xmlStrcmp_5=xmlStrcmp(node->name, (unsigned char *)"touch-interval");
        if(return_value_xmlStrcmp_5 == 0)
        {
          unsigned char *return_value_xmlNodeListGetString_4;
          return_value_xmlNodeListGetString_4=xmlNodeListGetString(doc, node->children, 1);
          tmp = (char *)return_value_xmlNodeListGetString_4;
          server->touch_interval=atoi(tmp);
          if(!(tmp == ((char *)NULL)))
            xmlFree((void *)tmp);

        }

      }
      server->next = (struct ice_config_dir_tag *)(void *)0;
    }

    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
  if(!(addnode == 0))
  {
    dirnode = configuration->dir_list;
    if(dirnode == ((struct ice_config_dir_tag *)NULL))
      configuration->dir_list = server;

    else
    {
      for( ; !(dirnode->next == ((struct ice_config_dir_tag *)NULL)); dirnode = dirnode->next)
        ;
      dirnode->next = server;
    }
    server = (struct ice_config_dir_tag *)(void *)0;
    addnode = 0;
  }

  else
    free((void *)server);
}

// _block_signals
// file thread.c line 215
static void _block_signals(void)
{
  struct anonymous_38 ss;
  sigfillset(&ss);
  sigdelset(&ss, 9);
  sigdelset(&ss, 19);
  sigdelset(&ss, 11);
  sigdelset(&ss, 17);
  sigdelset(&ss, 7);
  signed int return_value_pthread_sigmask_1;
  return_value_pthread_sigmask_1=pthread_sigmask(0, &ss, (struct anonymous_38 *)(void *)0);
}

// _build_headers
// file util.c line 534
static inline char * _build_headers(signed int status, struct ice_config_tag *config, struct source_tag *source)
{
  struct _mount_proxy *mountproxy = (struct _mount_proxy *)(void *)0;
  char *ret = (char *)(void *)0;
  unsigned long int len = (unsigned long int)1;
  if(!(source == ((struct source_tag *)NULL)))
    mountproxy=config_find_mount(config, source->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);

  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, (unsigned long int)1);
  ret = (char *)return_value_calloc_1;
  *ret = (char)0;
  _build_headers_loop(&ret, &len, config->http_headers, status);
  if(!(mountproxy == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountproxy->http_headers == ((struct ice_config_http_header_tag *)NULL)))
      _build_headers_loop(&ret, &len, mountproxy->http_headers, status);

  }

  return ret;
}

// _build_headers_loop
// file util.c line 495
static inline void _build_headers_loop(char **ret, unsigned long int *len, struct ice_config_http_header_tag *header, signed int status)
{
  unsigned long int headerlen;
  const char *name;
  const char *value;
  char *r = *ret;
  if(!(header == ((struct ice_config_http_header_tag *)NULL)))
  {
    while((_Bool)1)
    {
      if(!(header->status == 0))
      {
        if(!(header->status == status))
          goto __CPROVER_DUMP_L5;

      }

      name = header->name;
      value = (const char *)(void *)0;
      if((signed int)header->type == HTTP_HEADER_TYPE_STATIC)
        value = header->value;

      if(!(name == ((const char *)NULL)) && !(value == ((const char *)NULL)))
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(name);
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(value);
        headerlen = return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)4;
        *len = *len + headerlen;
        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)r, *len);
        r = (char *)return_value_realloc_3;
        strcat(r, name);
        strcat(r, ": ");
        strcat(r, value);
        strcat(r, "\r\n");
      }


    __CPROVER_DUMP_L5:
      ;
      header = header->next;
      if(header == ((struct ice_config_http_header_tag *)NULL))
        break;

    }
    *ret = r;
  }

}

// _catch_signals
// file thread.c line 241
static void _catch_signals(void)
{
  struct anonymous_38 ss;
  sigemptyset(&ss);
  sigaddset(&ss, 1);
  sigaddset(&ss, 17);
  sigaddset(&ss, 2);
  sigaddset(&ss, 13);
  sigaddset(&ss, 15);
  signed int return_value_pthread_sigmask_1;
  return_value_pthread_sigmask_1=pthread_sigmask(1, &ss, (struct anonymous_38 *)(void *)0);
}

// _ch_root_uid_setup
// file main.c line 352
static void _ch_root_uid_setup(void)
{
  struct ice_config_tag *conf;
  conf=config_get_config_unlocked();
  struct passwd *user;
  struct group *group;
  unsigned int uid = (unsigned int)-1;
  unsigned int gid = (unsigned int)-1;
  if(!(conf->chuid == 0))
  {
    if(!(conf->user == ((char *)NULL)))
    {
      user=getpwnam(conf->user);
      if(!(user == ((struct passwd *)NULL)))
        uid = user->pw_uid;

      else
        fprintf(stderr, "Couldn't find user \"%s\" in password file\n", conf->user);
    }

    if(!(conf->group == ((char *)NULL)))
    {
      group=getgrnam(conf->group);
      if(!(group == ((struct group *)NULL)))
        gid = group->gr_gid;

      else
        fprintf(stderr, "Couldn't find group \"%s\" in groups file\n", conf->group);
    }

  }

  if(!(conf->chroot == 0))
  {
    unsigned int return_value_getuid_1;
    return_value_getuid_1=getuid();
    if(!(return_value_getuid_1 == 0u))
    {
      fprintf(stderr, "WARNING: Cannot change server root unless running as root.\n");
      goto __CPROVER_DUMP_L18;
    }

    signed int return_value_chroot_4;
    return_value_chroot_4=chroot(conf->base_dir);
    if(!(return_value_chroot_4 == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      fprintf(stderr, "WARNING: Couldn't change server root: %s\n", return_value_strerror_3);
      goto __CPROVER_DUMP_L18;
    }

    else
      fprintf(stdout, "Changed root successfully to \"%s\".\n", conf->base_dir);
  }

  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  signed int *return_value___errno_location_9;
  char *return_value_strerror_10;
  signed int *return_value___errno_location_12;
  char *return_value_strerror_13;
  if(!(conf->chuid == 0))
  {
    unsigned int return_value_getuid_5;
    return_value_getuid_5=getuid();
    if(!(return_value_getuid_5 == 0u))
    {
      fprintf(stderr, "WARNING: Can't change user id unless you are root.\n");
      goto __CPROVER_DUMP_L18;
    }

    if(!(gid == 4294967295u) && !(uid == 4294967295u))
    {
      signed int return_value_setgid_8;
      return_value_setgid_8=setgid(gid);
      if(return_value_setgid_8 == 0)
        fprintf(stdout, "Changed groupid to %i.\n", (signed int)gid);

      else
      {
        return_value___errno_location_6=__errno_location();
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        fprintf(stdout, "Error changing groupid: %s.\n", return_value_strerror_7);
      }
      signed int return_value_initgroups_11;
      return_value_initgroups_11=initgroups(conf->user, gid);
      if(return_value_initgroups_11 == 0)
        fprintf(stdout, "Changed supplementary groups based on user: %s.\n", conf->user);

      else
      {
        return_value___errno_location_9=__errno_location();
        return_value_strerror_10=strerror(*return_value___errno_location_9);
        fprintf(stdout, "Error changing supplementary groups: %s.\n", return_value_strerror_10);
      }
      signed int return_value_setuid_14;
      return_value_setuid_14=setuid(uid);
      if(return_value_setuid_14 == 0)
        fprintf(stdout, "Changed userid to %i.\n", (signed int)uid);

      else
      {
        return_value___errno_location_12=__errno_location();
        return_value_strerror_13=strerror(*return_value___errno_location_12);
        fprintf(stdout, "Error changing userid: %s.\n", return_value_strerror_13);
      }
    }

  }


__CPROVER_DUMP_L18:
  ;
}

// _check_pass_http
// file connection.c line 907
static signed int _check_pass_http(struct http_parser_tag *parser, const char *correctuser, const char *correctpass)
{
  const char *header;
  header=httpp_getvar(parser, "authorization");
  char *userpass;
  char *tmp;
  char *username;
  char *password;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  if(header == ((const char *)NULL))
    return 0;

  else
  {
    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(header, "Basic ", (unsigned long int)6);
    if(!(return_value_strncmp_1 == 0))
      return 0;

    else
    {
      userpass=util_base64_decode(header + (signed long int)6);
      if(userpass == ((char *)NULL))
      {
        log_write(errorlog, (unsigned int)2, "connection/", "_check_pass_http", "Base64 decode of Authorization header \"%s\" failed", header + (signed long int)6);
        return 0;
      }

      else
      {
        tmp=strchr(userpass, 58);
        if(tmp == ((char *)NULL))
        {
          free((void *)userpass);
          return 0;
        }

        else
        {
          *tmp = (char)0;
          username = userpass;
          password = tmp + (signed long int)1;
          signed int return_value_strcmp_2;
          return_value_strcmp_2=strcmp(username, correctuser);
          if(!(return_value_strcmp_2 == 0))
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            return_value_strcmp_3=strcmp(password, correctpass);
            tmp_if_expr_4 = return_value_strcmp_3 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
          {
            free((void *)userpass);
            return 0;
          }

          else
          {
            free((void *)userpass);
            return 1;
          }
        }
      }
    }
  }
}

// _check_pass_ice
// file connection.c line 960
static signed int _check_pass_ice(struct http_parser_tag *parser, const char *correctpass)
{
  const char *password;
  password=httpp_getvar(parser, "ice-password");
  if(password == ((const char *)NULL))
    password = "";

  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(password, correctpass);
  if(!(return_value_strcmp_1 == 0))
    return 0;

  else
    return 1;
}

// _check_pass_icy
// file connection.c line 946
static signed int _check_pass_icy(struct http_parser_tag *parser, const char *correctpass)
{
  const char *password;
  password=httpp_getvar(parser, "__icy_password");
  if(password == ((const char *)NULL))
    return 0;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(password, correctpass);
    if(!(return_value_strcmp_1 == 0))
      return 0;

    else
      return 1;
  }
}

// _compare_clients
// file source.c line 925
static signed int _compare_clients(void *compare_arg, void *a, void *b)
{
  struct _client_tag *clienta = (struct _client_tag *)a;
  struct _client_tag *clientb = (struct _client_tag *)b;
  struct connection_tag *cona = clienta->con;
  struct connection_tag *conb = clientb->con;
  if(!(cona->id >= conb->id))
    return -1;

  else
    if(!(conb->id >= cona->id))
      return 1;

    else
      return 0;
}

// _compare_mappings
// file fserve.c line 708
static signed int _compare_mappings(void *arg, void *a, void *b)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(((struct anonymous_15 *)a)->ext, ((struct anonymous_15 *)b)->ext);
  return return_value_strcmp_1;
}

// _compare_source_stats
// file stats.c line 1010
static signed int _compare_source_stats(void *arg, void *a, void *b)
{
  struct _stats_source_tag *nodea = (struct _stats_source_tag *)a;
  struct _stats_source_tag *nodeb = (struct _stats_source_tag *)b;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(nodea->source, nodeb->source);
  return return_value_strcmp_1;
}

// _compare_stats
// file stats.c line 1002
static signed int _compare_stats(void *arg, void *a, void *b)
{
  struct _stats_node_tag *nodea = (struct _stats_node_tag *)a;
  struct _stats_node_tag *nodeb = (struct _stats_node_tag *)b;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(nodea->name, nodeb->name);
  return return_value_strcmp_1;
}

// _compare_threads
// file thread.c line 767
static signed int _compare_threads(void *compare_arg, void *a, void *b)
{
  struct anonymous_24 *t1;
  struct anonymous_24 *t2;
  t1 = (struct anonymous_24 *)a;
  t2 = (struct anonymous_24 *)b;
  if(!(t2->thread_id >= t1->thread_id))
    return 1;

  else
    if(!(t1->thread_id >= t2->thread_id))
      return -1;

    else
      return 0;
}

// _compare_vars
// file httpp.c line 547
static signed int _compare_vars(void *compare_arg, void *a, void *b)
{
  struct http_var_tag *vara;
  struct http_var_tag *varb;
  vara = (struct http_var_tag *)a;
  varb = (struct http_var_tag *)b;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(vara->name, varb->name);
  return return_value_strcmp_1;
}

// _copy_event
// file stats.c line 415
static struct _stats_event_tag * _copy_event(struct _stats_event_tag *event)
{
  struct _stats_event_tag *copy;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _stats_event_tag) /*40ul*/ );
  copy = (struct _stats_event_tag *)return_value_calloc_1;
  char *return_value_strdup_2;
  if(!(event->source == ((char *)NULL)))
  {
    return_value_strdup_2=strdup(event->source);
    copy->source = (char *)return_value_strdup_2;
  }

  else
    copy->source = (char *)(void *)0;
  char *return_value_strdup_3;
  if(!(event->name == ((char *)NULL)))
  {
    return_value_strdup_3=strdup(event->name);
    copy->name = (char *)return_value_strdup_3;
  }

  char *return_value_strdup_4;
  if(!(event->value == ((char *)NULL)))
  {
    return_value_strdup_4=strdup(event->value);
    copy->value = (char *)return_value_strdup_4;
  }

  else
    copy->value = (char *)(void *)0;
  copy->hidden = event->hidden;
  copy->next = (struct _stats_event_tag *)(void *)0;
  return copy;
}

// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void)
{
  asm("");
}

// _curl_easy_setopt_err_CURLSH_link1
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void)
{
  asm("");
}

// _curl_easy_setopt_err_FILE_link1
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void)
{
  asm("");
}

// _curl_easy_setopt_err_cb_data_link1
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_conv_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_httpost_link1
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_off_t_link1
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_slist_link1
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_debug_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void)
{
  asm("");
}

// _curl_easy_setopt_err_error_buffer_link1
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_ioctl_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void)
{
  asm("");
}

// _curl_easy_setopt_err_long_link1
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_opensocket_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void)
{
  asm("");
}

// _curl_easy_setopt_err_postfields_link1
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_progress_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_read_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_seek_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_sockopt_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_ssl_ctx_cb_link1
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_string_link1
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string_link1(void)
{
  asm("");
}

// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void)
{
  asm("");
}

// _curl_easy_setopt_err_write_callback_link1
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback_link1(void)
{
  asm("");
}

// _delete_mapping
// file fserve.c line 699
static signed int _delete_mapping(void *mapping)
{
  struct anonymous_15 *map = (struct anonymous_15 *)mapping;
  free((void *)map->ext);
  free((void *)map->type);
  free((void *)map);
  return 1;
}

// _dump_stats_to_doc
// file stats.c line 815
static struct _xmlNode * _dump_stats_to_doc(struct _xmlNode *root, const char *show_mount, signed int hidden)
{
  struct avl_node_tag *avlnode;
  struct _xmlNode *ret = (struct _xmlNode *)(void *)0;
  thread_mutex_lock_c(&_stats_mutex, 820, "stats.c");
  avlnode=avl_get_first(_stats.global_tree);
  while(!(avlnode == ((struct avl_node_tag *)NULL)))
  {
    struct _stats_node_tag *_dump_stats_to_doc__1__1__stat = (struct _stats_node_tag *)avlnode->key;
    if(hidden >= _dump_stats_to_doc__1__1__stat->hidden)
      xmlNewTextChild(root, (struct _xmlNs *)(void *)0, (unsigned char *)_dump_stats_to_doc__1__1__stat->name, (unsigned char *)_dump_stats_to_doc__1__1__stat->value);

    avlnode=avl_get_next(avlnode);
  }
  avlnode=avl_get_first(_stats.source_tree);
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  while(!(avlnode == ((struct avl_node_tag *)NULL)))
  {
    struct _stats_source_tag *source = (struct _stats_source_tag *)avlnode->key;
    if(hidden >= source->hidden)
    {
      if(show_mount == ((const char *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        return_value_strcmp_1=strcmp(show_mount, source->source);
        tmp_if_expr_2 = return_value_strcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
      {
        struct avl_node_tag *avlnode2;
        avlnode2=avl_get_first(source->stats_tree);
        struct _xmlNode *xmlnode;
        xmlnode=xmlNewTextChild(root, (struct _xmlNs *)(void *)0, (unsigned char *)"source", (const unsigned char *)(void *)0);
        xmlSetProp(xmlnode, (unsigned char *)"mount", (unsigned char *)source->source);
        if(ret == ((struct _xmlNode *)NULL))
          ret = xmlnode;

        while(!(avlnode2 == ((struct avl_node_tag *)NULL)))
        {
          struct _stats_node_tag *_dump_stats_to_doc__1__2__1__1__stat = (struct _stats_node_tag *)avlnode2->key;
          xmlNewTextChild(xmlnode, (struct _xmlNs *)(void *)0, (unsigned char *)_dump_stats_to_doc__1__2__1__1__stat->name, (unsigned char *)_dump_stats_to_doc__1__2__1__1__stat->value);
          avlnode2=avl_get_next(avlnode2);
        }
      }

    }

    avlnode=avl_get_next(avlnode);
  }
  thread_mutex_unlock_c(&_stats_mutex, 853, "stats.c");
  return ret;
}

// _fatal_error
// file main.c line 80
static void _fatal_error(const char *perr)
{
  fprintf(stdout, "%s\n", perr);
}

// _find_node
// file stats.c line 365
static struct _stats_node_tag * _find_node(struct _avl_tree *stats_tree, const char *name)
{
  struct _stats_node_tag *stats;
  struct avl_node_tag *node;
  signed int cmp;
  node = stats_tree->root->right;
  while(!(node == ((struct avl_node_tag *)NULL)))
  {
    stats = (struct _stats_node_tag *)node->key;
    cmp=strcmp(name, stats->name);
    if(!(cmp >= 0))
      node = node->left;

    else
      if(cmp >= 1)
        node = node->right;

      else
        return stats;
  }
  return (struct _stats_node_tag *)(void *)0;
}

// _find_source
// file stats.c line 392
static struct _stats_source_tag * _find_source(struct _avl_tree *source_tree, const char *source)
{
  struct _stats_source_tag *stats;
  struct avl_node_tag *node;
  signed int cmp;
  node = source_tree->root->right;
  while(!(node == ((struct avl_node_tag *)NULL)))
  {
    stats = (struct _stats_source_tag *)node->key;
    cmp=strcmp(source, stats->source);
    if(!(cmp >= 0))
      node = node->left;

    else
      if(cmp >= 1)
        node = node->right;

      else
        return stats;
  }
  return (struct _stats_source_tag *)(void *)0;
}

// _free_client
// file source.c line 944
static signed int _free_client(void *key)
{
  struct _client_tag *client = (struct _client_tag *)key;
  if(client->respcode == 0)
    client_send_404(client, "Mount unavailable");

  else
    client_destroy(client);
  return 1;
}

// _free_event
// file stats.c line 1038
static void _free_event(struct _stats_event_tag *event)
{
  if(!(event->source == ((char *)NULL)))
    free((void *)event->source);

  if(!(event->name == ((char *)NULL)))
    free((void *)event->name);

  if(!(event->value == ((char *)NULL)))
    free((void *)event->value);

  free((void *)event);
}

// _free_source_stats
// file stats.c line 1028
static signed int _free_source_stats(void *key)
{
  struct _stats_source_tag *node = (struct _stats_source_tag *)key;
  avl_tree_free(node->stats_tree, _free_stats);
  free((void *)node->source);
  free((void *)node);
  return 1;
}

// _free_stats
// file stats.c line 1018
static signed int _free_stats(void *key)
{
  struct _stats_node_tag *node = (struct _stats_node_tag *)key;
  free((void *)node->value);
  free((void *)node->name);
  free((void *)node);
  return 1;
}

// _free_thread
// file thread.c line 799
static signed int _free_thread(void *key)
{
  struct anonymous_24 *t = (struct anonymous_24 *)key;
  if(!(t->file == ((char *)NULL)))
    free((void *)t->file);

  if(!(t->name == ((char *)NULL)))
    free((void *)t->name);

  free((void *)t);
  return 1;
}

// _free_user
// file auth_htpasswd.c line 95
static signed int _free_user(void *key)
{
  struct anonymous_22 *user = (struct anonymous_22 *)key;
  free((void *)user->name);
  free((void *)user);
  return 1;
}

// _free_vars
// file httpp.c line 557
static signed int _free_vars(void *key)
{
  struct http_var_tag *var = (struct http_var_tag *)key;
  if(!(var->name == ((char *)NULL)))
    free((void *)var->name);

  if(!(var->value == ((char *)NULL)))
    free((void *)var->value);

  free((void *)var);
  return 1;
}

// _get_connection
// file connection.c line 585
static struct client_queue_tag * _get_connection(void)
{
  struct client_queue_tag *node = (struct client_queue_tag *)(void *)0;
  thread_spin_lock(&_connection_lock);
  if(!(_con_queue == ((volatile struct client_queue_tag *)NULL)))
  {
    node = (struct client_queue_tag *)_con_queue;
    _con_queue = node->next;
    if(_con_queue == ((volatile struct client_queue_tag *)NULL))
      _con_queue_tail = &_con_queue;

    node->next = (struct client_queue_tag *)(void *)0;
  }

  thread_spin_unlock(&_connection_lock);
  return node;
}

// _get_event_from_queue
// file stats.c line 780
static struct _stats_event_tag * _get_event_from_queue(struct _event_queue_tag *queue)
{
  struct _stats_event_tag *event = (struct _stats_event_tag *)(void *)0;
  if(!(queue == ((struct _event_queue_tag *)NULL)))
  {
    if(!(queue->head == ((volatile struct _stats_event_tag *)NULL)))
    {
      event = (struct _stats_event_tag *)queue->head;
      queue->head = event->next;
      if(queue->head == ((volatile struct _stats_event_tag *)NULL))
        queue->tail = &queue->head;

    }

  }

  return event;
}

// _get_log_id
// file log.c line 610
static signed int _get_log_id(void)
{
  signed int i;
  signed int id = -1;
  _lock_logger();
  i = 0;
  for( ; !(i >= 25); i = i + 1)
    if(loglist[(signed long int)i].in_use == 0)
    {
      loglist[(signed long int)i].in_use = 1;
      id = i;
      break;
    }

  _unlock_logger();
  return id;
}

// _get_stats
// file stats.c line 284
static char * _get_stats(const char *source, const char *name)
{
  struct _stats_node_tag *stats = (struct _stats_node_tag *)(void *)0;
  struct _stats_source_tag *src = (struct _stats_source_tag *)(void *)0;
  char *value = (char *)(void *)0;
  thread_mutex_lock_c(&_stats_mutex, 290, "stats.c");
  if(source == ((const char *)NULL))
    stats=_find_node(_stats.global_tree, name);

  else
  {
    src=_find_source(_stats.source_tree, source);
    if(!(src == ((struct _stats_source_tag *)NULL)))
      stats=_find_node(src->stats_tree, name);

  }
  char *return_value_strdup_1;
  if(!(stats == ((struct _stats_node_tag *)NULL)))
  {
    return_value_strdup_1=strdup(stats->value);
    value = (char *)return_value_strdup_1;
  }

  thread_mutex_unlock_c(&_stats_mutex, 303, "stats.c");
  return value;
}

// _handle_connection
// file connection.c line 1311
static void _handle_connection(void)
{
  struct http_parser_tag *parser;
  const char *rawuri;
  struct client_queue_tag *node;
  signed int return_value_strcmp_1;
  const char *return_value_httpp_getvar_2;
  signed int return_value_strcmp_3;
  _Bool tmp_if_expr_6;
  while((_Bool)1)
  {
    node=_get_connection();
    if(!(node == ((struct client_queue_tag *)NULL)))
    {
      struct _client_tag *client = node->client;
      if(!(node->shoutcast == 0))
      {
        _handle_shoutcast_compatible(node);
        continue;
      }

      parser=httpp_create_parser();
      httpp_initialize(parser, (struct http_varlist_tag *)(void *)0);
      client->parser = parser;
      signed int return_value_httpp_parse_7;
      return_value_httpp_parse_7=httpp_parse(parser, client->refbuf->data, (unsigned long int)node->offset);
      if(!(return_value_httpp_parse_7 == 0))
      {
        char *uri;
        if(node->stream_offset == node->offset)
          client->refbuf->len = (unsigned int)0;

        else
        {
          char *ptr = client->refbuf->data;
          client->refbuf->len = (unsigned int)(node->offset - node->stream_offset);
          memmove((void *)ptr, (const void *)(ptr + (signed long int)node->stream_offset), (unsigned long int)client->refbuf->len);
        }
        rawuri=httpp_getvar(parser, "__uri");
        if(!(node->shoutcast_mount == ((char *)NULL)))
        {
          return_value_strcmp_1=strcmp(rawuri, "/admin.cgi");
          if(return_value_strcmp_1 == 0)
            httpp_set_query_param(client->parser, "mount", node->shoutcast_mount);

        }

        free((void *)node->shoutcast_mount);
        free((void *)node);
        const char *return_value_httpp_getvar_4;
        return_value_httpp_getvar_4=httpp_getvar(parser, "__protocol");
        signed int return_value_strcmp_5;
        return_value_strcmp_5=strcmp("ICE", return_value_httpp_getvar_4);
        if(!(return_value_strcmp_5 == 0))
        {
          return_value_httpp_getvar_2=httpp_getvar(parser, "__protocol");
          return_value_strcmp_3=strcmp("HTTP", return_value_httpp_getvar_2);
          if(!(return_value_strcmp_3 == 0))
          {
            log_write(errorlog, (unsigned int)1, "connection/", "_handle_connection", "Bad HTTP protocol detected");
            client_destroy(client);
            continue;
          }

        }

        uri=util_normalise_uri(rawuri);
        if(uri == ((char *)NULL))
        {
          client_destroy(client);
          continue;
        }

        if((signed int)parser->req_type == httpp_req_source)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = (signed int)parser->req_type == httpp_req_put ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
          _handle_source_request(client, uri);

        else
          if((signed int)parser->req_type == httpp_req_stats)
            _handle_stats_request(client, uri);

          else
            if((signed int)parser->req_type == httpp_req_get)
              _handle_get_request(client, uri);

            else
            {
              log_write(errorlog, (unsigned int)1, "connection/", "_handle_connection", "Wrong request type from client");
              client_send_400(client, "unknown request");
            }
        free((void *)uri);
      }

      else
      {
        free((void *)node);
        log_write(errorlog, (unsigned int)1, "connection/", "_handle_connection", "HTTP request parsing failed");
        client_destroy(client);
      }
      continue;
    }

    break;
  }
}

// _handle_get_request
// file connection.c line 1137
static void _handle_get_request(struct _client_tag *client, char *passed_uri)
{
  char *serverhost = (char *)(void *)0;
  signed int serverport = 0;
  struct _aliases *alias;
  struct ice_config_tag *config;
  char *uri = passed_uri;
  struct _listener_t *listen_sock;
  config=config_get_config();
  listen_sock=config_get_listen_sock(config, client->con);
  if(!(listen_sock == ((struct _listener_t *)NULL)))
  {
    serverhost = listen_sock->bind_address;
    serverport = listen_sock->port;
  }

  alias = config->aliases;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  while(!(alias == ((struct _aliases *)NULL)))
  {
    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp(uri, alias->source);
    if(return_value_strcmp_5 == 0)
    {
      if(alias->port == -1)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = alias->port == serverport ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        if(alias->bind_address == ((char *)NULL))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          if(!(serverhost == ((char *)NULL)))
          {
            return_value_strcmp_1=strcmp(alias->bind_address, serverhost);
            tmp_if_expr_2 = return_value_strcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_2 = (_Bool)0;
          tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          uri=strdup(alias->destination);
          log_write(errorlog, (unsigned int)4, "connection/", "_handle_get_request", "alias has made %s into %s", passed_uri, uri);
          break;
        }

      }

    }

    alias = alias->next;
  }
  config_release_config();
  stats_event_inc((const char *)(void *)0, "client_connections");
  signed int return_value_strcmp_6;
  return_value_strcmp_6=strcmp(uri, "/admin.cgi");
  _Bool tmp_if_expr_8;
  signed int return_value_strncmp_7;
  if(return_value_strcmp_6 == 0)
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    return_value_strncmp_7=strncmp(uri, "/admin/", (unsigned long int)7);
    tmp_if_expr_8 = return_value_strncmp_7 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_8)
  {
    admin_handle_request(client, uri);
    if(!(uri == passed_uri))
      free((void *)uri);

  }

  else
  {
    auth_add_listener(uri, client);
    if(!(uri == passed_uri))
      free((void *)uri);

  }
}

// _handle_shoutcast_compatible
// file connection.c line 1190
static void _handle_shoutcast_compatible(struct client_queue_tag *node)
{
  char *http_compliant;
  signed int http_compliant_len = 0;
  struct http_parser_tag *parser;
  struct ice_config_tag *config;
  config=config_get_config();
  char *shoutcast_mount;
  struct _client_tag *client = node->client;
  if(!(node->shoutcast_mount == ((char *)NULL)))
    shoutcast_mount = node->shoutcast_mount;

  else
    shoutcast_mount = config->shoutcast_mount;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(node->shoutcast == 1)
  {
    char *source_password;
    char *ptr;
    char *headers;
    struct _mount_proxy *mountinfo;
    mountinfo=config_find_mount(config, shoutcast_mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
    if(!(mountinfo == ((struct _mount_proxy *)NULL)))
      tmp_if_expr_1 = mountinfo->password != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      source_password=strdup(mountinfo->password);

    else
      if(!(config->source_password == ((char *)NULL)))
        source_password=strdup(config->source_password);

      else
        source_password = (char *)(void *)0;
    config_release_config();
    ptr=strstr(client->refbuf->data, "\r\r\n");
    if(!(ptr == ((char *)NULL)))
      headers = ptr + (signed long int)3;

    else
    {
      ptr=strstr(client->refbuf->data, "\r\n");
      if(!(ptr == ((char *)NULL)))
        headers = ptr + (signed long int)2;

      else
      {
        ptr=strstr(client->refbuf->data, "\n");
        if(!(ptr == ((char *)NULL)))
          headers = ptr + (signed long int)1;

      }
    }
    if(ptr == ((char *)NULL))
    {
      client_destroy(client);
      free((void *)source_password);
      free((void *)node->shoutcast_mount);
      free((void *)node);
      goto __CPROVER_DUMP_L21;
    }

    *ptr = (char)0;
    if(!(source_password == ((char *)NULL)))
    {
      return_value_strcmp_2=strcmp(client->refbuf->data, source_password);
      tmp_if_expr_3 = return_value_strcmp_2 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      client->respcode = 200;
      sock_write(client->con->sock, "OK2\r\nicy-caps:11\r\n\r\n");
      node->offset = node->offset - (signed int)(headers - client->refbuf->data);
      memmove((void *)client->refbuf->data, (const void *)headers, (unsigned long int)(node->offset + 1));
      node->shoutcast = 2;
      _add_request_queue(node);
      free((void *)source_password);
      goto __CPROVER_DUMP_L21;
    }

    else
      log_write(errorlog, (unsigned int)3, "connection/", "_handle_shoutcast_compatible", "password does not match \"%s\"", client->refbuf->data);
    client_destroy(client);
    free((void *)source_password);
    free((void *)node->shoutcast_mount);
    free((void *)node);
    goto __CPROVER_DUMP_L21;
  }

  shoutcast_mount=strdup(shoutcast_mount);
  config_release_config();
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(shoutcast_mount);
  http_compliant_len = (signed int)((unsigned long int)20 + return_value_strlen_4 + (unsigned long int)node->offset);
  void *return_value_calloc_5;
  return_value_calloc_5=calloc((unsigned long int)1, (unsigned long int)http_compliant_len);
  http_compliant = (char *)return_value_calloc_5;
  snprintf(http_compliant, (unsigned long int)http_compliant_len, "SOURCE %s HTTP/1.0\r\n%s", shoutcast_mount, client->refbuf->data);
  parser=httpp_create_parser();
  httpp_initialize(parser, (struct http_varlist_tag *)(void *)0);
  unsigned long int return_value_strlen_6;
  return_value_strlen_6=strlen(http_compliant);
  signed int return_value_httpp_parse_7;
  return_value_httpp_parse_7=httpp_parse(parser, http_compliant, return_value_strlen_6);
  if(!(return_value_httpp_parse_7 == 0))
  {
    if(node->stream_offset == node->offset)
      client->refbuf->len = (unsigned int)0;

    else
    {
      char *_handle_shoutcast_compatible__1__2__1__ptr = client->refbuf->data;
      client->refbuf->len = (unsigned int)(node->offset - node->stream_offset);
      memmove((void *)_handle_shoutcast_compatible__1__2__1__ptr, (const void *)(_handle_shoutcast_compatible__1__2__1__ptr + (signed long int)node->stream_offset), (unsigned long int)client->refbuf->len);
    }
    client->parser = parser;
    source_startup(client, shoutcast_mount, 1);
  }

  else
  {
    httpp_destroy(parser);
    client_destroy(client);
  }
  free((void *)http_compliant);
  free((void *)shoutcast_mount);
  free((void *)node->shoutcast_mount);
  free((void *)node);
  goto __CPROVER_DUMP_L21;

__CPROVER_DUMP_L21:
  ;
}

// _handle_source_request
// file connection.c line 1048
static void _handle_source_request(struct _client_tag *client, const char *uri)
{
  log_write(errorlog, (unsigned int)3, "connection/", "_handle_source_request", "Source logging in at mountpoint \"%s\" from %s", uri, client->con->ip);
  if(!((signed int)*uri == 47))
  {
    log_write(errorlog, (unsigned int)2, "connection/", "_handle_source_request", "source mountpoint not starting with /");
    client_send_401(client);
  }

  else
  {
    signed int return_value_client_check_source_auth_1;
    return_value_client_check_source_auth_1=client_check_source_auth(client, uri);
    switch(return_value_client_check_source_auth_1)
    {
      case 0:
      {
        source_startup(client, uri, 0);
        break;
      }
      case 1:
        break;
      default:
      {
        log_write(errorlog, (unsigned int)3, "connection/", "_handle_source_request", "Source (%s) attempted to login with invalid or missing password", uri);
        client_send_401(client);
      }
    }
  }
}

// _handle_stats_request
// file connection.c line 1119
static void _handle_stats_request(struct _client_tag *client, char *uri)
{
  stats_event_inc((const char *)(void *)0, "stats_connections");
  signed int return_value_connection_check_admin_pass_1;
  return_value_connection_check_admin_pass_1=connection_check_admin_pass(client->parser);
  if(return_value_connection_check_admin_pass_1 == 0)
  {
    client_send_401(client);
    log_write(errorlog, (unsigned int)1, "connection/", "_handle_stats_request", "Bad password for stats connection");
  }

  else
  {
    client->respcode = 200;
    snprintf(client->refbuf->data, (unsigned long int)4096, "HTTP/1.0 200 OK\r\n\r\n");
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(client->refbuf->data);
    client->refbuf->len = (unsigned int)return_value_strlen_2;
    fserve_add_client_callback(client, stats_callback, (void *)0);
  }
}

// _isip
// file resolver.c line 62
static signed int _isip(const char *what)
{
  /* tag-#anon#lUN[lSYM#tag-in_addr#'v4addr'||lSYM#tag-in6_addr#'v6addr'|] */
union anonymous_37
{
  // v4addr
  struct in_addr v4addr;
  // v6addr
  struct in6_addr v6addr;
};

/* */
  ;
  union anonymous_37 addr_u;
  signed int return_value_inet_pton_2;
  return_value_inet_pton_2=inet_pton(2, what, (void *)&addr_u.v4addr);
  signed int return_value_inet_pton_1;
  if(!(return_value_inet_pton_2 >= 1))
  {
    return_value_inet_pton_1=inet_pton(10, what, (void *)&addr_u.v6addr);
    return return_value_inet_pton_1 > 0 ? 1 : 0;
  }

  else
    return 1;
}

// _lock_logger
// file log.c line 642
static void _lock_logger(void)
{
  pthread_mutex_lock(&_logger_mutex);
}

// _log_open
// file log.c line 86
static signed int _log_open(signed int id)
{
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(loglist[(signed long int)id].in_use == 0)
    return 0;

  else
  {
    if(loglist[(signed long int)id].logfile == ((struct _IO_FILE *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if(!(loglist[(signed long int)id].trigger_level == 0l))
        tmp_if_expr_3 = loglist[(signed long int)id].size > loglist[(signed long int)id].trigger_level ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      if(!(loglist[(signed long int)id].filename == ((char *)NULL)))
      {
        struct stat st;
        if(!(loglist[(signed long int)id].logfile == ((struct _IO_FILE *)NULL)))
        {
          char new_name[4096l];
          fclose(loglist[(signed long int)id].logfile);
          loglist[(signed long int)id].logfile = (struct _IO_FILE *)(void *)0;
          if(!(loglist[(signed long int)id].archive_timestamp == 0))
          {
            char timestamp[128l];
            signed long int _log_open__1__1__1__1__1__now;
            _log_open__1__1__1__1__1__now=time((signed long int *)(void *)0);
            struct tm *return_value_localtime_1;
            return_value_localtime_1=localtime(&_log_open__1__1__1__1__1__now);
            strftime(timestamp, sizeof(char [128l]) /*128ul*/ , "%Y%m%d_%H%M%S", return_value_localtime_1);
            snprintf(new_name, sizeof(char [4096l]) /*4096ul*/ , "%s.%s", loglist[(signed long int)id].filename, (const void *)timestamp);
          }

          else
            snprintf(new_name, sizeof(char [4096l]) /*4096ul*/ , "%s.old", loglist[(signed long int)id].filename);
          rename(loglist[(signed long int)id].filename, new_name);
        }

        loglist[(signed long int)id].logfile=fopen(loglist[(signed long int)id].filename, "a");
        if(loglist[(signed long int)id].logfile == ((struct _IO_FILE *)NULL))
          return 0;

        setvbuf(loglist[(signed long int)id].logfile, (char *)(void *)0, 1, (unsigned long int)0);
        signed int return_value_stat_2;
        return_value_stat_2=stat(loglist[(signed long int)id].filename, &st);
        if(!(return_value_stat_2 >= 0))
          loglist[(signed long int)id].size = (signed long int)0;

        else
          loglist[(signed long int)id].size = st.st_size;
      }

      else
        loglist[(signed long int)id].size = (signed long int)0;
    }

    return 1;
  }
}

// _lowercase
// file httpp.c line 538
static char * _lowercase(char *str)
{
  char *p = str;
  signed int return_value_tolower_1;
  for( ; !((signed int)*p == 0); p = p + 1l)
  {
    return_value_tolower_1=tolower((signed int)*p);
    *p = (char)return_value_tolower_1;
  }
  return str;
}

// _make_event_from_node
// file stats.c line 755
static struct _stats_event_tag * _make_event_from_node(struct _stats_node_tag *node, char *source)
{
  struct _stats_event_tag *event;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _stats_event_tag) /*40ul*/ );
  event = (struct _stats_event_tag *)return_value_malloc_1;
  char *return_value_strdup_2;
  if(!(source == ((char *)NULL)))
  {
    return_value_strdup_2=strdup(source);
    event->source = (char *)return_value_strdup_2;
  }

  else
    event->source = (char *)(void *)0;
  char *return_value_strdup_3;
  return_value_strdup_3=strdup(node->name);
  event->name = (char *)return_value_strdup_3;
  char *return_value_strdup_4;
  return_value_strdup_4=strdup(node->value);
  event->value = (char *)return_value_strdup_4;
  event->hidden = node->hidden;
  event->action = 0;
  event->next = (struct _stats_event_tag *)(void *)0;
  return event;
}

// _merge_mounts_all
// file cfgfile.c line 1413
static inline void _merge_mounts_all(struct ice_config_tag *c)
{
  struct _mount_proxy *mountinfo = c->mounts;
  struct _mount_proxy *default_mount;
  for( ; !(mountinfo == ((struct _mount_proxy *)NULL)); mountinfo = mountinfo->next)
    if((signed int)mountinfo->mounttype == MOUNT_TYPE_NORMAL)
    {
      default_mount=config_find_mount(c, mountinfo->mountname, (enum _mount_type)MOUNT_TYPE_DEFAULT);
      merge_mounts(mountinfo, default_mount);
    }

}

// _mutex_create
// file thread.c line 326
static void _mutex_create(struct anonymous_4 *mutex)
{
  pthread_mutex_init(&mutex->sys_mutex, (const union anonymous_40 *)(void *)0);
}

// _mutex_lock
// file thread.c line 717
static void _mutex_lock(struct anonymous_4 *mutex)
{
  pthread_mutex_lock(&mutex->sys_mutex);
}

// _mutex_unlock
// file thread.c line 722
static void _mutex_unlock(struct anonymous_4 *mutex)
{
  pthread_mutex_unlock(&mutex->sys_mutex);
}

// _next_connection_id
// file connection.c line 182
static unsigned long int _next_connection_id(void)
{
  unsigned long int id;
  thread_spin_lock(&_connection_lock);
  volatile unsigned long int tmp_post_1 = _current_id;
  _current_id = _current_id + 1ul;
  id = tmp_post_1;
  thread_spin_unlock(&_connection_lock);
  return id;
}

// _parse_audio_info
// file source.c line 957
static void _parse_audio_info(struct source_tag *source, const char *s)
{
  const char *start = s;
  unsigned int len;
  unsigned long int return_value_strlen_1;
  while(!(start == ((const char *)NULL)))
  {
    if((signed int)*start == 0)
      break;

    s=strchr(start, 59);
    if(s == ((const char *)NULL))
    {
      return_value_strlen_1=strlen(start);
      len = (unsigned int)return_value_strlen_1;
    }

    else
    {
      len = (unsigned int)(signed int)(s - start);
      s = s + 1l;
    }
    if(!(len == 0u))
    {
      char name[100l];
      char value[200l];
      char *esc;
      sscanf(start, "%99[^=]=%199[^;\r\n]", (const void *)name, (const void *)value);
      esc=util_url_unescape(value);
      if(!(esc == ((char *)NULL)))
      {
        util_dict_set(source->audio_info, name, esc);
        stats_event(source->mount, name, esc);
        free((void *)esc);
      }

    }

    start = s;
  }
}

// _parse_authentication
// file cfgfile.c line 1045
static void _parse_authentication(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  signed int return_value_xmlStrcmp_11;
  signed int return_value_xmlStrcmp_10;
  signed int return_value_xmlStrcmp_9;
  signed int return_value_xmlStrcmp_8;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_1;
    return_value_xmlIsBlankNode_1=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_1 == 0)
    {
      signed int return_value_xmlStrcmp_12;
      return_value_xmlStrcmp_12=xmlStrcmp(node->name, (unsigned char *)"source-password");
      if(return_value_xmlStrcmp_12 == 0)
      {
        unsigned char *return_value_xmlGetProp_3;
        return_value_xmlGetProp_3=xmlGetProp(node, (unsigned char *)"mount");
        if(!(return_value_xmlGetProp_3 == ((unsigned char *)NULL)))
          log_write(errorlog, (unsigned int)1, "CONFIG/", "_parse_authentication", "Mount level source password defined within global <authentication> section.");

        else
        {
          if(!(configuration->source_password == ((char *)NULL)))
            xmlFree((void *)configuration->source_password);

          unsigned char *return_value_xmlNodeListGetString_2;
          return_value_xmlNodeListGetString_2=xmlNodeListGetString(doc, node->children, 1);
          configuration->source_password = (char *)return_value_xmlNodeListGetString_2;
        }
      }

      else
      {
        return_value_xmlStrcmp_11=xmlStrcmp(node->name, (unsigned char *)"admin-password");
        if(return_value_xmlStrcmp_11 == 0)
        {
          if(!(configuration->admin_password == ((char *)NULL)))
            xmlFree((void *)configuration->admin_password);

          unsigned char *return_value_xmlNodeListGetString_4;
          return_value_xmlNodeListGetString_4=xmlNodeListGetString(doc, node->children, 1);
          configuration->admin_password = (char *)return_value_xmlNodeListGetString_4;
        }

        else
        {
          return_value_xmlStrcmp_10=xmlStrcmp(node->name, (unsigned char *)"admin-user");
          if(return_value_xmlStrcmp_10 == 0)
          {
            if(!(configuration->admin_username == ((char *)NULL)))
              xmlFree((void *)configuration->admin_username);

            unsigned char *return_value_xmlNodeListGetString_5;
            return_value_xmlNodeListGetString_5=xmlNodeListGetString(doc, node->children, 1);
            configuration->admin_username = (char *)return_value_xmlNodeListGetString_5;
          }

          else
          {
            return_value_xmlStrcmp_9=xmlStrcmp(node->name, (unsigned char *)"relay-password");
            if(return_value_xmlStrcmp_9 == 0)
            {
              if(!(configuration->relay_password == ((char *)NULL)))
                xmlFree((void *)configuration->relay_password);

              unsigned char *return_value_xmlNodeListGetString_6;
              return_value_xmlNodeListGetString_6=xmlNodeListGetString(doc, node->children, 1);
              configuration->relay_password = (char *)return_value_xmlNodeListGetString_6;
            }

            else
            {
              return_value_xmlStrcmp_8=xmlStrcmp(node->name, (unsigned char *)"relay-user");
              if(return_value_xmlStrcmp_8 == 0)
              {
                if(!(configuration->relay_username == ((char *)NULL)))
                  xmlFree((void *)configuration->relay_username);

                unsigned char *return_value_xmlNodeListGetString_7;
                return_value_xmlNodeListGetString_7=xmlNodeListGetString(doc, node->children, 1);
                configuration->relay_username = (char *)return_value_xmlNodeListGetString_7;
              }

            }
          }
        }
      }
    }

    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
}

// _parse_config_opts
// file main.c line 153
static signed int _parse_config_opts(signed int argc, char **argv, char *filename, signed int size)
{
  signed int i = 1;
  signed int config_ok = 0;
  background = 0;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  if(!(argc >= 2))
    return -1;

  else
  {
    while(!(i >= argc))
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(argv[(signed long int)i], "-b");
      if(return_value_strcmp_1 == 0)
      {
        signed int pid;
        fprintf(stdout, "Starting icecast2\nDetaching from the console\n");
        pid=fork();
        if(pid >= 1)
          exit(0);

        else
          if(!(pid >= 0))
          {
            fprintf(stderr, "FATAL: Unable to fork child!");
            exit(1);
          }

        background = 1;
      }

      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(argv[(signed long int)i], "-v");
      if(return_value_strcmp_2 == 0)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_strcmp_3=strcmp(argv[(signed long int)i], "--version");
        tmp_if_expr_4 = return_value_strcmp_3 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
      {
        fprintf(stdout, "%s\n", (const void *)"Icecast 2.4.2");
        exit(0);
      }

      signed int return_value_strcmp_5;
      return_value_strcmp_5=strcmp(argv[(signed long int)i], "-c");
      if(return_value_strcmp_5 == 0)
      {
        if(!(1 + i >= argc))
        {
          strncpy(filename, argv[(signed long int)(i + 1)], (unsigned long int)(size - 1));
          filename[(signed long int)(size - 1)] = (char)0;
          config_ok = 1;
        }

        else
          return -1;
      }

      i = i + 1;
    }
    if(!(config_ok == 0))
      return 1;

    else
      return -1;
  }
}

// _parse_directory
// file cfgfile.c line 1086
static void _parse_directory(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  char *tmp;
  signed int return_value_xmlStrcmp_7;
  signed int return_value_xmlStrcmp_6;
  signed int return_value_xmlStrcmp_5;
  if(configuration->num_yp_directories >= 25)
    log_write(errorlog, (unsigned int)1, "CONFIG/", "_parse_directory", "Maximum number of yp directories exceeded!");

  else
  {
    while(!(node == ((struct _xmlNode *)NULL)))
    {
      signed int return_value_xmlIsBlankNode_1;
      return_value_xmlIsBlankNode_1=xmlIsBlankNode(node);
      if(return_value_xmlIsBlankNode_1 == 0)
      {
        signed int return_value_xmlStrcmp_8;
        return_value_xmlStrcmp_8=xmlStrcmp(node->name, (unsigned char *)"yp-url");
        if(return_value_xmlStrcmp_8 == 0)
        {
          if(!(configuration->yp_url[(signed long int)configuration->num_yp_directories] == ((char *)NULL)))
            xmlFree((void *)configuration->yp_url[(signed long int)configuration->num_yp_directories]);

          unsigned char *return_value_xmlNodeListGetString_2;
          return_value_xmlNodeListGetString_2=xmlNodeListGetString(doc, node->children, 1);
          configuration->yp_url[(signed long int)configuration->num_yp_directories] = (char *)return_value_xmlNodeListGetString_2;
        }

        else
        {
          return_value_xmlStrcmp_7=xmlStrcmp(node->name, (unsigned char *)"yp-url-timeout");
          if(return_value_xmlStrcmp_7 == 0)
          {
            unsigned char *return_value_xmlNodeListGetString_3;
            return_value_xmlNodeListGetString_3=xmlNodeListGetString(doc, node->children, 1);
            tmp = (char *)return_value_xmlNodeListGetString_3;
            configuration->yp_url_timeout[(signed long int)configuration->num_yp_directories]=atoi(tmp);
            if(!(tmp == ((char *)NULL)))
              xmlFree((void *)tmp);

          }

          else
          {
            return_value_xmlStrcmp_6=xmlStrcmp(node->name, (unsigned char *)"server");
            if(return_value_xmlStrcmp_6 == 0)
              _add_server(doc, node->children, configuration);

            else
            {
              return_value_xmlStrcmp_5=xmlStrcmp(node->name, (unsigned char *)"touch-interval");
              if(return_value_xmlStrcmp_5 == 0)
              {
                unsigned char *return_value_xmlNodeListGetString_4;
                return_value_xmlNodeListGetString_4=xmlNodeListGetString(doc, node->children, 1);
                tmp = (char *)return_value_xmlNodeListGetString_4;
                configuration->yp_touch_interval[(signed long int)configuration->num_yp_directories]=atoi(tmp);
                if(!(tmp == ((char *)NULL)))
                  xmlFree((void *)tmp);

              }

            }
          }
        }
      }

      node = node->next;
      if(node == ((struct _xmlNode *)NULL))
        break;

    }
    if(!(configuration->yp_url[(signed long int)configuration->num_yp_directories] == ((char *)NULL)))
      configuration->num_yp_directories = configuration->num_yp_directories + 1;

  }
}

// _parse_http_headers
// file cfgfile.c line 834
static void _parse_http_headers(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_http_header_tag **http_headers)
{
  struct ice_config_http_header_tag *header;
  struct ice_config_http_header_tag *next;
  char *name = (char *)(void *)0;
  char *value = (char *)(void *)0;
  char *tmp;
  signed int status;
  enum _http_header_type type;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_1;
    return_value_xmlIsBlankNode_1=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_1 == 0)
    {
      signed int return_value_xmlStrcmp_2;
      return_value_xmlStrcmp_2=xmlStrcmp(node->name, (unsigned char *)"header");
      if(!(return_value_xmlStrcmp_2 == 0))
        break;

      unsigned char *return_value_xmlGetProp_3;
      return_value_xmlGetProp_3=xmlGetProp(node, (unsigned char *)"name");
      name = (char *)return_value_xmlGetProp_3;
      if(name == ((char *)NULL))
        break;

      unsigned char *return_value_xmlGetProp_4;
      return_value_xmlGetProp_4=xmlGetProp(node, (unsigned char *)"value");
      value = (char *)return_value_xmlGetProp_4;
      if(value == ((char *)NULL))
        break;

      type = (enum _http_header_type)HTTP_HEADER_TYPE_STATIC;
      unsigned char *return_value_xmlGetProp_6;
      return_value_xmlGetProp_6=xmlGetProp(node, (unsigned char *)"type");
      tmp = (char *)return_value_xmlGetProp_6;
      if(!(tmp == ((char *)NULL)))
      {
        signed int return_value_strcmp_5;
        return_value_strcmp_5=strcmp(tmp, "static");
        if(return_value_strcmp_5 == 0)
          type = (enum _http_header_type)HTTP_HEADER_TYPE_STATIC;

        else
        {
          log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_http_headers", "Unknown type %s for HTTP Header %s", tmp, name);
          xmlFree((void *)tmp);
          break;
        }
        xmlFree((void *)tmp);
      }

      status = 0;
      unsigned char *return_value_xmlGetProp_7;
      return_value_xmlGetProp_7=xmlGetProp(node, (unsigned char *)"status");
      tmp = (char *)return_value_xmlGetProp_7;
      if(!(tmp == ((char *)NULL)))
      {
        status=atoi(tmp);
        xmlFree((void *)tmp);
      }

      void *return_value_calloc_8;
      return_value_calloc_8=calloc((unsigned long int)1, sizeof(struct ice_config_http_header_tag) /*40ul*/ );
      header = (struct ice_config_http_header_tag *)return_value_calloc_8;
      if(header == ((struct ice_config_http_header_tag *)NULL))
        break;

      header->type = type;
      header->name = name;
      header->value = value;
      header->status = status;
      name = (char *)(void *)0;
      value = (char *)(void *)0;
      if(*http_headers == ((struct ice_config_http_header_tag *)NULL))
        *http_headers = header;

      else
      {
        next = *http_headers;
        for( ; !(next->next == ((struct ice_config_http_header_tag *)NULL)); next = next->next)
          ;
        next->next = header;
      }
    }

    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
  if(!(name == ((char *)NULL)))
    xmlFree((void *)name);

  if(!(value == ((char *)NULL)))
    xmlFree((void *)value);

}

// _parse_limits
// file cfgfile.c line 588
static void _parse_limits(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  char *tmp;
  signed int return_value_xmlStrcmp_21;
  signed int return_value_xmlStrcmp_20;
  signed int return_value_xmlStrcmp_19;
  signed int return_value_xmlStrcmp_18;
  signed int return_value_xmlStrcmp_17;
  signed int return_value_xmlStrcmp_16;
  signed int return_value_xmlStrcmp_15;
  signed int return_value_xmlStrcmp_14;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_1;
    return_value_xmlIsBlankNode_1=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_1 == 0)
    {
      signed int return_value_xmlStrcmp_22;
      return_value_xmlStrcmp_22=xmlStrcmp(node->name, (unsigned char *)"clients");
      if(return_value_xmlStrcmp_22 == 0)
      {
        unsigned char *return_value_xmlNodeListGetString_2;
        return_value_xmlNodeListGetString_2=xmlNodeListGetString(doc, node->children, 1);
        tmp = (char *)return_value_xmlNodeListGetString_2;
        configuration->client_limit=atoi(tmp);
        if(!(tmp == ((char *)NULL)))
          xmlFree((void *)tmp);

      }

      else
      {
        return_value_xmlStrcmp_21=xmlStrcmp(node->name, (unsigned char *)"sources");
        if(return_value_xmlStrcmp_21 == 0)
        {
          unsigned char *return_value_xmlNodeListGetString_3;
          return_value_xmlNodeListGetString_3=xmlNodeListGetString(doc, node->children, 1);
          tmp = (char *)return_value_xmlNodeListGetString_3;
          configuration->source_limit=atoi(tmp);
          if(!(tmp == ((char *)NULL)))
            xmlFree((void *)tmp);

        }

        else
        {
          return_value_xmlStrcmp_20=xmlStrcmp(node->name, (unsigned char *)"queue-size");
          if(return_value_xmlStrcmp_20 == 0)
          {
            unsigned char *return_value_xmlNodeListGetString_4;
            return_value_xmlNodeListGetString_4=xmlNodeListGetString(doc, node->children, 1);
            tmp = (char *)return_value_xmlNodeListGetString_4;
            signed int return_value_atoi_5;
            return_value_atoi_5=atoi(tmp);
            configuration->queue_size_limit = (unsigned int)return_value_atoi_5;
            if(!(tmp == ((char *)NULL)))
              xmlFree((void *)tmp);

          }

          else
          {
            return_value_xmlStrcmp_19=xmlStrcmp(node->name, (unsigned char *)"threadpool");
            if(return_value_xmlStrcmp_19 == 0)
            {
              unsigned char *return_value_xmlNodeListGetString_6;
              return_value_xmlNodeListGetString_6=xmlNodeListGetString(doc, node->children, 1);
              tmp = (char *)return_value_xmlNodeListGetString_6;
              configuration->threadpool_size=atoi(tmp);
              if(!(tmp == ((char *)NULL)))
                xmlFree((void *)tmp);

            }

            else
            {
              return_value_xmlStrcmp_18=xmlStrcmp(node->name, (unsigned char *)"client-timeout");
              if(return_value_xmlStrcmp_18 == 0)
              {
                unsigned char *return_value_xmlNodeListGetString_7;
                return_value_xmlNodeListGetString_7=xmlNodeListGetString(doc, node->children, 1);
                tmp = (char *)return_value_xmlNodeListGetString_7;
                configuration->client_timeout=atoi(tmp);
                if(!(tmp == ((char *)NULL)))
                  xmlFree((void *)tmp);

              }

              else
              {
                return_value_xmlStrcmp_17=xmlStrcmp(node->name, (unsigned char *)"header-timeout");
                if(return_value_xmlStrcmp_17 == 0)
                {
                  unsigned char *return_value_xmlNodeListGetString_8;
                  return_value_xmlNodeListGetString_8=xmlNodeListGetString(doc, node->children, 1);
                  tmp = (char *)return_value_xmlNodeListGetString_8;
                  configuration->header_timeout=atoi(tmp);
                  if(!(tmp == ((char *)NULL)))
                    xmlFree((void *)tmp);

                }

                else
                {
                  return_value_xmlStrcmp_16=xmlStrcmp(node->name, (unsigned char *)"source-timeout");
                  if(return_value_xmlStrcmp_16 == 0)
                  {
                    unsigned char *return_value_xmlNodeListGetString_9;
                    return_value_xmlNodeListGetString_9=xmlNodeListGetString(doc, node->children, 1);
                    tmp = (char *)return_value_xmlNodeListGetString_9;
                    configuration->source_timeout=atoi(tmp);
                    if(!(tmp == ((char *)NULL)))
                      xmlFree((void *)tmp);

                  }

                  else
                  {
                    return_value_xmlStrcmp_15=xmlStrcmp(node->name, (unsigned char *)"burst-on-connect");
                    if(return_value_xmlStrcmp_15 == 0)
                    {
                      unsigned char *return_value_xmlNodeListGetString_10;
                      return_value_xmlNodeListGetString_10=xmlNodeListGetString(doc, node->children, 1);
                      tmp = (char *)return_value_xmlNodeListGetString_10;
                      signed int return_value_atoi_11;
                      return_value_atoi_11=atoi(tmp);
                      if(return_value_atoi_11 == 0)
                        configuration->burst_size = (unsigned int)0;

                      if(!(tmp == ((char *)NULL)))
                        xmlFree((void *)tmp);

                    }

                    else
                    {
                      return_value_xmlStrcmp_14=xmlStrcmp(node->name, (unsigned char *)"burst-size");
                      if(return_value_xmlStrcmp_14 == 0)
                      {
                        unsigned char *return_value_xmlNodeListGetString_12;
                        return_value_xmlNodeListGetString_12=xmlNodeListGetString(doc, node->children, 1);
                        tmp = (char *)return_value_xmlNodeListGetString_12;
                        signed int return_value_atoi_13;
                        return_value_atoi_13=atoi(tmp);
                        configuration->burst_size = (unsigned int)return_value_atoi_13;
                        if(!(tmp == ((char *)NULL)))
                          xmlFree((void *)tmp);

                      }

                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
}

// _parse_listen_socket
// file cfgfile.c line 973
static void _parse_listen_socket(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  char *tmp;
  struct _listener_t *listener;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _listener_t) /*48ul*/ );
  listener = (struct _listener_t *)return_value_calloc_1;
  signed int return_value_xmlStrcmp_13;
  signed int return_value_xmlStrcmp_12;
  signed int return_value_xmlStrcmp_11;
  signed int return_value_xmlStrcmp_10;
  signed int return_value_xmlStrcmp_9;
  unsigned char *return_value_xmlStrdup_17;
  if(!(listener == ((struct _listener_t *)NULL)))
  {
    listener->port = 8000;
    while(!(node == ((struct _xmlNode *)NULL)))
    {
      signed int return_value_xmlIsBlankNode_2;
      return_value_xmlIsBlankNode_2=xmlIsBlankNode(node);
      if(return_value_xmlIsBlankNode_2 == 0)
      {
        signed int return_value_xmlStrcmp_14;
        return_value_xmlStrcmp_14=xmlStrcmp(node->name, (unsigned char *)"port");
        if(return_value_xmlStrcmp_14 == 0)
        {
          unsigned char *return_value_xmlNodeListGetString_3;
          return_value_xmlNodeListGetString_3=xmlNodeListGetString(doc, node->children, 1);
          tmp = (char *)return_value_xmlNodeListGetString_3;
          if(!(tmp == ((char *)NULL)))
          {
            if(configuration->port == 0)
              configuration->port=atoi(tmp);

            listener->port=atoi(tmp);
            xmlFree((void *)tmp);
          }

          else
            log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_listen_socket", "<port> must not be empty.");
        }

        else
        {
          return_value_xmlStrcmp_13=xmlStrcmp(node->name, (unsigned char *)"ssl");
          if(return_value_xmlStrcmp_13 == 0)
          {
            unsigned char *return_value_xmlNodeListGetString_4;
            return_value_xmlNodeListGetString_4=xmlNodeListGetString(doc, node->children, 1);
            tmp = (char *)return_value_xmlNodeListGetString_4;
            listener->ssl=atoi(tmp);
            if(!(tmp == ((char *)NULL)))
              xmlFree((void *)tmp);

          }

          else
          {
            return_value_xmlStrcmp_12=xmlStrcmp(node->name, (unsigned char *)"shoutcast-compat");
            if(return_value_xmlStrcmp_12 == 0)
            {
              unsigned char *return_value_xmlNodeListGetString_5;
              return_value_xmlNodeListGetString_5=xmlNodeListGetString(doc, node->children, 1);
              tmp = (char *)return_value_xmlNodeListGetString_5;
              listener->shoutcast_compat=atoi(tmp);
              if(!(tmp == ((char *)NULL)))
                xmlFree((void *)tmp);

            }

            else
            {
              return_value_xmlStrcmp_11=xmlStrcmp(node->name, (unsigned char *)"shoutcast-mount");
              if(return_value_xmlStrcmp_11 == 0)
              {
                if(!(listener->shoutcast_mount == ((char *)NULL)))
                  xmlFree((void *)listener->shoutcast_mount);

                unsigned char *return_value_xmlNodeListGetString_6;
                return_value_xmlNodeListGetString_6=xmlNodeListGetString(doc, node->children, 1);
                listener->shoutcast_mount = (char *)return_value_xmlNodeListGetString_6;
              }

              else
              {
                return_value_xmlStrcmp_10=xmlStrcmp(node->name, (unsigned char *)"bind-address");
                if(return_value_xmlStrcmp_10 == 0)
                {
                  if(!(listener->bind_address == ((char *)NULL)))
                    xmlFree((void *)listener->bind_address);

                  unsigned char *return_value_xmlNodeListGetString_7;
                  return_value_xmlNodeListGetString_7=xmlNodeListGetString(doc, node->children, 1);
                  listener->bind_address = (char *)return_value_xmlNodeListGetString_7;
                }

                else
                {
                  return_value_xmlStrcmp_9=xmlStrcmp(node->name, (unsigned char *)"so-sndbuf");
                  if(return_value_xmlStrcmp_9 == 0)
                  {
                    unsigned char *return_value_xmlNodeListGetString_8;
                    return_value_xmlNodeListGetString_8=xmlNodeListGetString(doc, node->children, 1);
                    tmp = (char *)return_value_xmlNodeListGetString_8;
                    listener->so_sndbuf=atoi(tmp);
                    if(!(tmp == ((char *)NULL)))
                      xmlFree((void *)tmp);

                  }

                }
              }
            }
          }
        }
      }

      node = node->next;
      if(node == ((struct _xmlNode *)NULL))
        break;

    }
    listener->next = configuration->listen_sock->next;
    configuration->listen_sock->next = listener;
    configuration->listen_sock_count = configuration->listen_sock_count + 1u;
    if(!(listener->shoutcast_mount == ((char *)NULL)))
    {
      struct _listener_t *sc_port;
      void *return_value_calloc_15;
      return_value_calloc_15=calloc((unsigned long int)1, sizeof(struct _listener_t) /*48ul*/ );
      sc_port = (struct _listener_t *)return_value_calloc_15;
      sc_port->port = listener->port + 1;
      sc_port->shoutcast_compat = 1;
      unsigned char *return_value_xmlStrdup_16;
      return_value_xmlStrdup_16=xmlStrdup((unsigned char *)listener->shoutcast_mount);
      sc_port->shoutcast_mount = (char *)return_value_xmlStrdup_16;
      if(!(listener->bind_address == ((char *)NULL)))
      {
        return_value_xmlStrdup_17=xmlStrdup((unsigned char *)listener->bind_address);
        sc_port->bind_address = (char *)return_value_xmlStrdup_17;
      }

      sc_port->next = listener->next;
      listener->next = sc_port;
      configuration->listen_sock_count = configuration->listen_sock_count + 1u;
    }

  }

}

// _parse_logging
// file cfgfile.c line 1216
static void _parse_logging(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  char *tmp;
  signed int return_value_xmlStrcmp_12;
  signed int return_value_xmlStrcmp_11;
  signed int return_value_xmlStrcmp_10;
  signed int return_value_xmlStrcmp_9;
  signed int return_value_xmlStrcmp_8;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_1;
    return_value_xmlIsBlankNode_1=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_1 == 0)
    {
      signed int return_value_xmlStrcmp_13;
      return_value_xmlStrcmp_13=xmlStrcmp(node->name, (unsigned char *)"accesslog");
      if(return_value_xmlStrcmp_13 == 0)
      {
        unsigned char *return_value_xmlNodeListGetString_2;
        return_value_xmlNodeListGetString_2=xmlNodeListGetString(doc, node->children, 1);
        tmp = (char *)return_value_xmlNodeListGetString_2;
        if(tmp == ((char *)NULL))
        {
          log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_logging", "<accesslog> must not be empty.");
          goto __CPROVER_DUMP_L16;
        }

        if(!(configuration->access_log == ((char *)NULL)))
          xmlFree((void *)configuration->access_log);

        configuration->access_log = tmp;
      }

      else
      {
        return_value_xmlStrcmp_12=xmlStrcmp(node->name, (unsigned char *)"errorlog");
        if(return_value_xmlStrcmp_12 == 0)
        {
          unsigned char *return_value_xmlNodeListGetString_3;
          return_value_xmlNodeListGetString_3=xmlNodeListGetString(doc, node->children, 1);
          tmp = (char *)return_value_xmlNodeListGetString_3;
          if(tmp == ((char *)NULL))
          {
            log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_logging", "<errorlog> must not be empty.");
            goto __CPROVER_DUMP_L16;
          }

          if(!(configuration->error_log == ((char *)NULL)))
            xmlFree((void *)configuration->error_log);

          configuration->error_log = tmp;
        }

        else
        {
          return_value_xmlStrcmp_11=xmlStrcmp(node->name, (unsigned char *)"playlistlog");
          if(return_value_xmlStrcmp_11 == 0)
          {
            if(!(configuration->playlist_log == ((char *)NULL)))
              xmlFree((void *)configuration->playlist_log);

            unsigned char *return_value_xmlNodeListGetString_4;
            return_value_xmlNodeListGetString_4=xmlNodeListGetString(doc, node->children, 1);
            configuration->playlist_log = (char *)return_value_xmlNodeListGetString_4;
          }

          else
          {
            return_value_xmlStrcmp_10=xmlStrcmp(node->name, (unsigned char *)"logsize");
            if(return_value_xmlStrcmp_10 == 0)
            {
              char *_parse_logging__1__1__4__tmp;
              unsigned char *return_value_xmlNodeListGetString_5;
              return_value_xmlNodeListGetString_5=xmlNodeListGetString(doc, node->children, 1);
              _parse_logging__1__1__4__tmp = (char *)return_value_xmlNodeListGetString_5;
              configuration->logsize=atoi(_parse_logging__1__1__4__tmp);
              if(!(_parse_logging__1__1__4__tmp == ((char *)NULL)))
                xmlFree((void *)_parse_logging__1__1__4__tmp);

            }

            else
            {
              return_value_xmlStrcmp_9=xmlStrcmp(node->name, (unsigned char *)"loglevel");
              if(return_value_xmlStrcmp_9 == 0)
              {
                char *_parse_logging__1__1__5__tmp;
                unsigned char *return_value_xmlNodeListGetString_6;
                return_value_xmlNodeListGetString_6=xmlNodeListGetString(doc, node->children, 1);
                _parse_logging__1__1__5__tmp = (char *)return_value_xmlNodeListGetString_6;
                configuration->loglevel=atoi(_parse_logging__1__1__5__tmp);
                if(!(_parse_logging__1__1__5__tmp == ((char *)NULL)))
                  xmlFree((void *)_parse_logging__1__1__5__tmp);

              }

              else
              {
                return_value_xmlStrcmp_8=xmlStrcmp(node->name, (unsigned char *)"logarchive");
                if(return_value_xmlStrcmp_8 == 0)
                {
                  char *_parse_logging__1__1__6__tmp;
                  unsigned char *return_value_xmlNodeListGetString_7;
                  return_value_xmlNodeListGetString_7=xmlNodeListGetString(doc, node->children, 1);
                  _parse_logging__1__1__6__tmp = (char *)return_value_xmlNodeListGetString_7;
                  configuration->logarchive=atoi(_parse_logging__1__1__6__tmp);
                  if(!(_parse_logging__1__1__6__tmp == ((char *)NULL)))
                    xmlFree((void *)_parse_logging__1__1__6__tmp);

                }

              }
            }
          }
        }
      }
    }


  __CPROVER_DUMP_L16:
    ;
    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
}

// _parse_mount
// file cfgfile.c line 638
static void _parse_mount(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  char *tmp;
  struct _mount_proxy *mount;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _mount_proxy) /*240ul*/ );
  mount = (struct _mount_proxy *)return_value_calloc_1;
  struct _mount_proxy *current = configuration->mounts;
  struct _mount_proxy *last = (struct _mount_proxy *)(void *)0;
  mount->mounttype = (enum _mount_type)MOUNT_TYPE_NORMAL;
  mount->max_listeners = -1;
  mount->burst_size = -1;
  mount->mp3_meta_interval = -1;
  mount->yp_public = -1;
  mount->next = (struct _mount_proxy *)(void *)0;
  unsigned char *return_value_xmlGetProp_2;
  return_value_xmlGetProp_2=xmlGetProp(node, (unsigned char *)"type");
  tmp = (char *)return_value_xmlGetProp_2;
  signed int return_value_strcmp_3;
  if(!(tmp == ((char *)NULL)))
  {
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(tmp, "normal");
    if(return_value_strcmp_4 == 0)
      mount->mounttype = (enum _mount_type)MOUNT_TYPE_NORMAL;

    else
    {
      return_value_strcmp_3=strcmp(tmp, "default");
      if(return_value_strcmp_3 == 0)
        mount->mounttype = (enum _mount_type)MOUNT_TYPE_DEFAULT;

      else
      {
        log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_mount", "Unknown mountpoint type: %s", tmp);
        config_clear_mount(mount);
        goto __CPROVER_DUMP_L65;
      }
    }
    xmlFree((void *)tmp);
  }

  node = node->children;
  signed int return_value_xmlStrcmp_68;
  signed int return_value_xmlStrcmp_67;
  signed int return_value_xmlStrcmp_66;
  signed int return_value_xmlStrcmp_65;
  signed int return_value_xmlStrcmp_64;
  signed int return_value_xmlStrcmp_63;
  signed int return_value_xmlStrcmp_62;
  signed int return_value_xmlStrcmp_61;
  signed int return_value_xmlStrcmp_60;
  signed int return_value_xmlStrcmp_59;
  signed int return_value_xmlStrcmp_58;
  signed int return_value_xmlStrcmp_57;
  signed int return_value_xmlStrcmp_56;
  signed int return_value_xmlStrcmp_55;
  signed int return_value_xmlStrcmp_54;
  signed int return_value_xmlStrcmp_53;
  signed int return_value_xmlStrcmp_52;
  signed int return_value_xmlStrcmp_51;
  signed int return_value_xmlStrcmp_50;
  signed int return_value_xmlStrcmp_49;
  signed int return_value_xmlStrcmp_48;
  signed int return_value_xmlStrcmp_47;
  signed int return_value_xmlStrcmp_46;
  signed int return_value_xmlStrcmp_45;
  signed int return_value_xmlStrcmp_44;
  signed int return_value_xmlStrcmp_43;
  signed int return_value_xmlStrcmp_42;
  signed int return_value_xmlStrcmp_41;
  signed int return_value_xmlStrcmp_40;
  signed int return_value_xmlStrcmp_39;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_5;
    return_value_xmlIsBlankNode_5=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_5 == 0)
    {
      signed int return_value_xmlStrcmp_69;
      return_value_xmlStrcmp_69=xmlStrcmp(node->name, (unsigned char *)"mount-name");
      if(return_value_xmlStrcmp_69 == 0)
      {
        unsigned char *return_value_xmlNodeListGetString_6;
        return_value_xmlNodeListGetString_6=xmlNodeListGetString(doc, node->children, 1);
        mount->mountname = (char *)return_value_xmlNodeListGetString_6;
      }

      else
      {
        return_value_xmlStrcmp_68=xmlStrcmp(node->name, (unsigned char *)"username");
        if(return_value_xmlStrcmp_68 == 0)
        {
          unsigned char *return_value_xmlNodeListGetString_7;
          return_value_xmlNodeListGetString_7=xmlNodeListGetString(doc, node->children, 1);
          mount->username = (char *)return_value_xmlNodeListGetString_7;
        }

        else
        {
          return_value_xmlStrcmp_67=xmlStrcmp(node->name, (unsigned char *)"password");
          if(return_value_xmlStrcmp_67 == 0)
          {
            unsigned char *return_value_xmlNodeListGetString_8;
            return_value_xmlNodeListGetString_8=xmlNodeListGetString(doc, node->children, 1);
            mount->password = (char *)return_value_xmlNodeListGetString_8;
          }

          else
          {
            return_value_xmlStrcmp_66=xmlStrcmp(node->name, (unsigned char *)"dump-file");
            if(return_value_xmlStrcmp_66 == 0)
            {
              unsigned char *return_value_xmlNodeListGetString_9;
              return_value_xmlNodeListGetString_9=xmlNodeListGetString(doc, node->children, 1);
              mount->dumpfile = (char *)return_value_xmlNodeListGetString_9;
            }

            else
            {
              return_value_xmlStrcmp_65=xmlStrcmp(node->name, (unsigned char *)"intro");
              if(return_value_xmlStrcmp_65 == 0)
              {
                unsigned char *return_value_xmlNodeListGetString_10;
                return_value_xmlNodeListGetString_10=xmlNodeListGetString(doc, node->children, 1);
                mount->intro_filename = (char *)return_value_xmlNodeListGetString_10;
              }

              else
              {
                return_value_xmlStrcmp_64=xmlStrcmp(node->name, (unsigned char *)"fallback-mount");
                if(return_value_xmlStrcmp_64 == 0)
                {
                  unsigned char *return_value_xmlNodeListGetString_11;
                  return_value_xmlNodeListGetString_11=xmlNodeListGetString(doc, node->children, 1);
                  mount->fallback_mount = (char *)return_value_xmlNodeListGetString_11;
                }

                else
                {
                  return_value_xmlStrcmp_63=xmlStrcmp(node->name, (unsigned char *)"fallback-when-full");
                  if(return_value_xmlStrcmp_63 == 0)
                  {
                    unsigned char *return_value_xmlNodeListGetString_12;
                    return_value_xmlNodeListGetString_12=xmlNodeListGetString(doc, node->children, 1);
                    tmp = (char *)return_value_xmlNodeListGetString_12;
                    mount->fallback_when_full=atoi(tmp);
                    if(!(tmp == ((char *)NULL)))
                      xmlFree((void *)tmp);

                  }

                  else
                  {
                    return_value_xmlStrcmp_62=xmlStrcmp(node->name, (unsigned char *)"max-listeners");
                    if(return_value_xmlStrcmp_62 == 0)
                    {
                      unsigned char *return_value_xmlNodeListGetString_13;
                      return_value_xmlNodeListGetString_13=xmlNodeListGetString(doc, node->children, 1);
                      tmp = (char *)return_value_xmlNodeListGetString_13;
                      mount->max_listeners=atoi(tmp);
                      if(!(tmp == ((char *)NULL)))
                        xmlFree((void *)tmp);

                    }

                    else
                    {
                      return_value_xmlStrcmp_61=xmlStrcmp(node->name, (unsigned char *)"charset");
                      if(return_value_xmlStrcmp_61 == 0)
                      {
                        unsigned char *return_value_xmlNodeListGetString_14;
                        return_value_xmlNodeListGetString_14=xmlNodeListGetString(doc, node->children, 1);
                        mount->charset = (char *)return_value_xmlNodeListGetString_14;
                      }

                      else
                      {
                        return_value_xmlStrcmp_60=xmlStrcmp(node->name, (unsigned char *)"mp3-metadata-interval");
                        if(return_value_xmlStrcmp_60 == 0)
                        {
                          unsigned char *return_value_xmlNodeListGetString_15;
                          return_value_xmlNodeListGetString_15=xmlNodeListGetString(doc, node->children, 1);
                          tmp = (char *)return_value_xmlNodeListGetString_15;
                          mount->mp3_meta_interval=atoi(tmp);
                          if(!(tmp == ((char *)NULL)))
                            xmlFree((void *)tmp);

                        }

                        else
                        {
                          return_value_xmlStrcmp_59=xmlStrcmp(node->name, (unsigned char *)"fallback-override");
                          if(return_value_xmlStrcmp_59 == 0)
                          {
                            unsigned char *return_value_xmlNodeListGetString_16;
                            return_value_xmlNodeListGetString_16=xmlNodeListGetString(doc, node->children, 1);
                            tmp = (char *)return_value_xmlNodeListGetString_16;
                            mount->fallback_override=atoi(tmp);
                            if(!(tmp == ((char *)NULL)))
                              xmlFree((void *)tmp);

                          }

                          else
                          {
                            return_value_xmlStrcmp_58=xmlStrcmp(node->name, (unsigned char *)"no-mount");
                            if(return_value_xmlStrcmp_58 == 0)
                            {
                              unsigned char *return_value_xmlNodeListGetString_17;
                              return_value_xmlNodeListGetString_17=xmlNodeListGetString(doc, node->children, 1);
                              tmp = (char *)return_value_xmlNodeListGetString_17;
                              mount->no_mount=atoi(tmp);
                              if(!(tmp == ((char *)NULL)))
                                xmlFree((void *)tmp);

                            }

                            else
                            {
                              return_value_xmlStrcmp_57=xmlStrcmp(node->name, (unsigned char *)"no-yp");
                              if(return_value_xmlStrcmp_57 == 0)
                              {
                                unsigned char *return_value_xmlNodeListGetString_18;
                                return_value_xmlNodeListGetString_18=xmlNodeListGetString(doc, node->children, 1);
                                tmp = (char *)return_value_xmlNodeListGetString_18;
                                signed int return_value_atoi_19;
                                return_value_atoi_19=atoi(tmp);
                                mount->yp_public = return_value_atoi_19 == 0 ? -1 : 0;
                                if(!(tmp == ((char *)NULL)))
                                  xmlFree((void *)tmp);

                              }

                              else
                              {
                                return_value_xmlStrcmp_56=xmlStrcmp(node->name, (unsigned char *)"hidden");
                                if(return_value_xmlStrcmp_56 == 0)
                                {
                                  unsigned char *return_value_xmlNodeListGetString_20;
                                  return_value_xmlNodeListGetString_20=xmlNodeListGetString(doc, node->children, 1);
                                  tmp = (char *)return_value_xmlNodeListGetString_20;
                                  mount->hidden=atoi(tmp);
                                  if(!(tmp == ((char *)NULL)))
                                    xmlFree((void *)tmp);

                                }

                                else
                                {
                                  return_value_xmlStrcmp_55=xmlStrcmp(node->name, (unsigned char *)"authentication");
                                  if(return_value_xmlStrcmp_55 == 0)
                                    mount->auth=auth_get_authenticator(node);

                                  else
                                  {
                                    return_value_xmlStrcmp_54=xmlStrcmp(node->name, (unsigned char *)"on-connect");
                                    if(return_value_xmlStrcmp_54 == 0)
                                    {
                                      unsigned char *return_value_xmlNodeListGetString_21;
                                      return_value_xmlNodeListGetString_21=xmlNodeListGetString(doc, node->children, 1);
                                      mount->on_connect = (char *)return_value_xmlNodeListGetString_21;
                                    }

                                    else
                                    {
                                      return_value_xmlStrcmp_53=xmlStrcmp(node->name, (unsigned char *)"on-disconnect");
                                      if(return_value_xmlStrcmp_53 == 0)
                                      {
                                        unsigned char *return_value_xmlNodeListGetString_22;
                                        return_value_xmlNodeListGetString_22=xmlNodeListGetString(doc, node->children, 1);
                                        mount->on_disconnect = (char *)return_value_xmlNodeListGetString_22;
                                      }

                                      else
                                      {
                                        return_value_xmlStrcmp_52=xmlStrcmp(node->name, (unsigned char *)"max-listener-duration");
                                        if(return_value_xmlStrcmp_52 == 0)
                                        {
                                          unsigned char *return_value_xmlNodeListGetString_23;
                                          return_value_xmlNodeListGetString_23=xmlNodeListGetString(doc, node->children, 1);
                                          tmp = (char *)return_value_xmlNodeListGetString_23;
                                          signed int return_value_atoi_24;
                                          return_value_atoi_24=atoi(tmp);
                                          mount->max_listener_duration = (unsigned int)return_value_atoi_24;
                                          if(!(tmp == ((char *)NULL)))
                                            xmlFree((void *)tmp);

                                        }

                                        else
                                        {
                                          return_value_xmlStrcmp_51=xmlStrcmp(node->name, (unsigned char *)"queue-size");
                                          if(return_value_xmlStrcmp_51 == 0)
                                          {
                                            unsigned char *return_value_xmlNodeListGetString_25;
                                            return_value_xmlNodeListGetString_25=xmlNodeListGetString(doc, node->children, 1);
                                            tmp = (char *)return_value_xmlNodeListGetString_25;
                                            signed int return_value_atoi_26;
                                            return_value_atoi_26=atoi(tmp);
                                            mount->queue_size_limit = (unsigned int)return_value_atoi_26;
                                            if(!(tmp == ((char *)NULL)))
                                              xmlFree((void *)tmp);

                                          }

                                          else
                                          {
                                            return_value_xmlStrcmp_50=xmlStrcmp(node->name, (unsigned char *)"source-timeout");
                                            if(return_value_xmlStrcmp_50 == 0)
                                            {
                                              unsigned char *return_value_xmlNodeListGetString_27;
                                              return_value_xmlNodeListGetString_27=xmlNodeListGetString(doc, node->children, 1);
                                              tmp = (char *)return_value_xmlNodeListGetString_27;
                                              if(!(tmp == ((char *)NULL)))
                                              {
                                                signed int return_value_atoi_28;
                                                return_value_atoi_28=atoi(tmp);
                                                mount->source_timeout = (unsigned int)return_value_atoi_28;
                                                xmlFree((void *)tmp);
                                              }

                                            }

                                            else
                                            {
                                              return_value_xmlStrcmp_49=xmlStrcmp(node->name, (unsigned char *)"burst-size");
                                              if(return_value_xmlStrcmp_49 == 0)
                                              {
                                                unsigned char *return_value_xmlNodeListGetString_29;
                                                return_value_xmlNodeListGetString_29=xmlNodeListGetString(doc, node->children, 1);
                                                tmp = (char *)return_value_xmlNodeListGetString_29;
                                                mount->burst_size=atoi(tmp);
                                                if(!(tmp == ((char *)NULL)))
                                                  xmlFree((void *)tmp);

                                              }

                                              else
                                              {
                                                return_value_xmlStrcmp_48=xmlStrcmp(node->name, (unsigned char *)"cluster-password");
                                                if(return_value_xmlStrcmp_48 == 0)
                                                {
                                                  unsigned char *return_value_xmlNodeListGetString_30;
                                                  return_value_xmlNodeListGetString_30=xmlNodeListGetString(doc, node->children, 1);
                                                  mount->cluster_password = (char *)return_value_xmlNodeListGetString_30;
                                                }

                                                else
                                                {
                                                  return_value_xmlStrcmp_47=xmlStrcmp(node->name, (unsigned char *)"stream-name");
                                                  if(return_value_xmlStrcmp_47 == 0)
                                                  {
                                                    unsigned char *return_value_xmlNodeListGetString_31;
                                                    return_value_xmlNodeListGetString_31=xmlNodeListGetString(doc, node->children, 1);
                                                    mount->stream_name = (char *)return_value_xmlNodeListGetString_31;
                                                  }

                                                  else
                                                  {
                                                    return_value_xmlStrcmp_46=xmlStrcmp(node->name, (unsigned char *)"stream-description");
                                                    if(return_value_xmlStrcmp_46 == 0)
                                                    {
                                                      unsigned char *return_value_xmlNodeListGetString_32;
                                                      return_value_xmlNodeListGetString_32=xmlNodeListGetString(doc, node->children, 1);
                                                      mount->stream_description = (char *)return_value_xmlNodeListGetString_32;
                                                    }

                                                    else
                                                    {
                                                      return_value_xmlStrcmp_45=xmlStrcmp(node->name, (unsigned char *)"stream-url");
                                                      if(return_value_xmlStrcmp_45 == 0)
                                                      {
                                                        unsigned char *return_value_xmlNodeListGetString_33;
                                                        return_value_xmlNodeListGetString_33=xmlNodeListGetString(doc, node->children, 1);
                                                        mount->stream_url = (char *)return_value_xmlNodeListGetString_33;
                                                      }

                                                      else
                                                      {
                                                        return_value_xmlStrcmp_44=xmlStrcmp(node->name, (unsigned char *)"genre");
                                                        if(return_value_xmlStrcmp_44 == 0)
                                                        {
                                                          unsigned char *return_value_xmlNodeListGetString_34;
                                                          return_value_xmlNodeListGetString_34=xmlNodeListGetString(doc, node->children, 1);
                                                          mount->stream_genre = (char *)return_value_xmlNodeListGetString_34;
                                                        }

                                                        else
                                                        {
                                                          return_value_xmlStrcmp_43=xmlStrcmp(node->name, (unsigned char *)"bitrate");
                                                          if(return_value_xmlStrcmp_43 == 0)
                                                          {
                                                            unsigned char *return_value_xmlNodeListGetString_35;
                                                            return_value_xmlNodeListGetString_35=xmlNodeListGetString(doc, node->children, 1);
                                                            mount->bitrate = (char *)return_value_xmlNodeListGetString_35;
                                                          }

                                                          else
                                                          {
                                                            return_value_xmlStrcmp_42=xmlStrcmp(node->name, (unsigned char *)"public");
                                                            if(return_value_xmlStrcmp_42 == 0)
                                                            {
                                                              unsigned char *return_value_xmlNodeListGetString_36;
                                                              return_value_xmlNodeListGetString_36=xmlNodeListGetString(doc, node->children, 1);
                                                              tmp = (char *)return_value_xmlNodeListGetString_36;
                                                              mount->yp_public=atoi(tmp);
                                                              if(!(tmp == ((char *)NULL)))
                                                                xmlFree((void *)tmp);

                                                            }

                                                            else
                                                            {
                                                              return_value_xmlStrcmp_41=xmlStrcmp(node->name, (unsigned char *)"type");
                                                              if(return_value_xmlStrcmp_41 == 0)
                                                              {
                                                                unsigned char *return_value_xmlNodeListGetString_37;
                                                                return_value_xmlNodeListGetString_37=xmlNodeListGetString(doc, node->children, 1);
                                                                mount->type = (char *)return_value_xmlNodeListGetString_37;
                                                              }

                                                              else
                                                              {
                                                                return_value_xmlStrcmp_40=xmlStrcmp(node->name, (unsigned char *)"subtype");
                                                                if(return_value_xmlStrcmp_40 == 0)
                                                                {
                                                                  unsigned char *return_value_xmlNodeListGetString_38;
                                                                  return_value_xmlNodeListGetString_38=xmlNodeListGetString(doc, node->children, 1);
                                                                  mount->subtype = (char *)return_value_xmlNodeListGetString_38;
                                                                }

                                                                else
                                                                {
                                                                  return_value_xmlStrcmp_39=xmlStrcmp(node->name, (unsigned char *)"http-headers");
                                                                  if(return_value_xmlStrcmp_39 == 0)
                                                                    _parse_http_headers(doc, node->children, &mount->http_headers);

                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
  _Bool tmp_if_expr_70;
  if(mount->mountname == ((char *)NULL))
    tmp_if_expr_70 = (signed int)mount->mounttype != MOUNT_TYPE_DEFAULT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_70 = (_Bool)0;
  if(tmp_if_expr_70)
  {
    config_clear_mount(mount);
    goto __CPROVER_DUMP_L65;
  }

  else
    if(!(mount->mountname == ((char *)NULL)))
    {
      if((signed int)mount->mounttype == MOUNT_TYPE_DEFAULT)
        log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_mount", "Default mount %s has mount-name set. This is not supported. Behavior may not be consistent.", mount->mountname);

    }

  _Bool tmp_if_expr_71;
  if(!(mount->auth == ((struct auth_tag *)NULL)))
    tmp_if_expr_71 = mount->mountname != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_71 = (_Bool)0;
  if(tmp_if_expr_71)
    mount->auth->mount=strdup((char *)mount->mountname);

  else
    if(!(mount->auth == ((struct auth_tag *)NULL)))
    {
      if((signed int)mount->mounttype == MOUNT_TYPE_DEFAULT)
        mount->auth->mount=strdup("(default mount)");

    }

  for( ; !(current == ((struct _mount_proxy *)NULL)); current = current->next)
    last = current;
  _Bool tmp_if_expr_72;
  if(mount->fallback_mount == ((char *)NULL))
  {
    if(!(mount->fallback_when_full == 0))
      tmp_if_expr_72 = (_Bool)1;

    else
      tmp_if_expr_72 = mount->fallback_override != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_72)
      log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_mount", "Config for mount %s contains fallback options but no fallback mount.", mount->mountname);

  }

  if(!(last == ((struct _mount_proxy *)NULL)))
    last->next = mount;

  else
    configuration->mounts = mount;

__CPROVER_DUMP_L65:
  ;
}

// _parse_paths
// file cfgfile.c line 1123
static void _parse_paths(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  char *temp;
  struct _aliases *alias;
  struct _aliases *current;
  struct _aliases *last;
  signed int return_value_xmlStrcmp_29;
  signed int return_value_xmlStrcmp_28;
  signed int return_value_xmlStrcmp_27;
  signed int return_value_xmlStrcmp_26;
  signed int return_value_xmlStrcmp_25;
  signed int return_value_xmlStrcmp_24;
  signed int return_value_xmlStrcmp_23;
  unsigned long int return_value_strlen_10;
  signed int return_value_xmlStrcmp_22;
  unsigned long int return_value_strlen_13;
  signed int return_value_xmlStrcmp_21;
  unsigned char *return_value_xmlGetProp_18;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_1;
    return_value_xmlIsBlankNode_1=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_1 == 0)
    {
      signed int return_value_xmlStrcmp_30;
      return_value_xmlStrcmp_30=xmlStrcmp(node->name, (unsigned char *)"basedir");
      if(return_value_xmlStrcmp_30 == 0)
      {
        if(!(configuration->base_dir == ((char *)NULL)))
          xmlFree((void *)configuration->base_dir);

        unsigned char *return_value_xmlNodeListGetString_2;
        return_value_xmlNodeListGetString_2=xmlNodeListGetString(doc, node->children, 1);
        configuration->base_dir = (char *)return_value_xmlNodeListGetString_2;
      }

      else
      {
        return_value_xmlStrcmp_29=xmlStrcmp(node->name, (unsigned char *)"logdir");
        if(return_value_xmlStrcmp_29 == 0)
        {
          unsigned char *return_value_xmlNodeListGetString_3;
          return_value_xmlNodeListGetString_3=xmlNodeListGetString(doc, node->children, 1);
          temp = (char *)return_value_xmlNodeListGetString_3;
          if(temp == ((char *)NULL))
          {
            log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_paths", "<logdir> must not be empty.");
            goto __CPROVER_DUMP_L35;
          }

          if(!(configuration->log_dir == ((char *)NULL)))
            xmlFree((void *)configuration->log_dir);

          configuration->log_dir = temp;
        }

        else
        {
          return_value_xmlStrcmp_28=xmlStrcmp(node->name, (unsigned char *)"pidfile");
          if(return_value_xmlStrcmp_28 == 0)
          {
            if(!(configuration->pidfile == ((char *)NULL)))
              xmlFree((void *)configuration->pidfile);

            unsigned char *return_value_xmlNodeListGetString_4;
            return_value_xmlNodeListGetString_4=xmlNodeListGetString(doc, node->children, 1);
            configuration->pidfile = (char *)return_value_xmlNodeListGetString_4;
          }

          else
          {
            return_value_xmlStrcmp_27=xmlStrcmp(node->name, (unsigned char *)"deny-ip");
            if(return_value_xmlStrcmp_27 == 0)
            {
              if(!(configuration->banfile == ((char *)NULL)))
                xmlFree((void *)configuration->banfile);

              unsigned char *return_value_xmlNodeListGetString_5;
              return_value_xmlNodeListGetString_5=xmlNodeListGetString(doc, node->children, 1);
              configuration->banfile = (char *)return_value_xmlNodeListGetString_5;
            }

            else
            {
              return_value_xmlStrcmp_26=xmlStrcmp(node->name, (unsigned char *)"allow-ip");
              if(return_value_xmlStrcmp_26 == 0)
              {
                if(!(configuration->allowfile == ((char *)NULL)))
                  xmlFree((void *)configuration->allowfile);

                unsigned char *return_value_xmlNodeListGetString_6;
                return_value_xmlNodeListGetString_6=xmlNodeListGetString(doc, node->children, 1);
                configuration->allowfile = (char *)return_value_xmlNodeListGetString_6;
              }

              else
              {
                return_value_xmlStrcmp_25=xmlStrcmp(node->name, (unsigned char *)"ssl-certificate");
                if(return_value_xmlStrcmp_25 == 0)
                {
                  if(!(configuration->cert_file == ((char *)NULL)))
                    xmlFree((void *)configuration->cert_file);

                  unsigned char *return_value_xmlNodeListGetString_7;
                  return_value_xmlNodeListGetString_7=xmlNodeListGetString(doc, node->children, 1);
                  configuration->cert_file = (char *)return_value_xmlNodeListGetString_7;
                }

                else
                {
                  return_value_xmlStrcmp_24=xmlStrcmp(node->name, (unsigned char *)"ssl-allowed-ciphers");
                  if(return_value_xmlStrcmp_24 == 0)
                  {
                    if(!(configuration->cipher_list == ((char *)NULL)))
                      xmlFree((void *)configuration->cipher_list);

                    unsigned char *return_value_xmlNodeListGetString_8;
                    return_value_xmlNodeListGetString_8=xmlNodeListGetString(doc, node->children, 1);
                    configuration->cipher_list = (char *)return_value_xmlNodeListGetString_8;
                  }

                  else
                  {
                    return_value_xmlStrcmp_23=xmlStrcmp(node->name, (unsigned char *)"webroot");
                    if(return_value_xmlStrcmp_23 == 0)
                    {
                      unsigned char *return_value_xmlNodeListGetString_9;
                      return_value_xmlNodeListGetString_9=xmlNodeListGetString(doc, node->children, 1);
                      temp = (char *)return_value_xmlNodeListGetString_9;
                      if(temp == ((char *)NULL))
                      {
                        log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_paths", "<webroot> must not be empty.");
                        goto __CPROVER_DUMP_L35;
                      }

                      if(!(configuration->webroot_dir == ((char *)NULL)))
                        xmlFree((void *)configuration->webroot_dir);

                      configuration->webroot_dir = temp;
                      unsigned long int return_value_strlen_11;
                      return_value_strlen_11=strlen(configuration->webroot_dir);
                      if((signed int)configuration->webroot_dir[-1l + (signed long int)return_value_strlen_11] == 47)
                      {
                        return_value_strlen_10=strlen(configuration->webroot_dir);
                        configuration->webroot_dir[(signed long int)(return_value_strlen_10 - (unsigned long int)1)] = (char)0;
                      }

                    }

                    else
                    {
                      return_value_xmlStrcmp_22=xmlStrcmp(node->name, (unsigned char *)"adminroot");
                      if(return_value_xmlStrcmp_22 == 0)
                      {
                        unsigned char *return_value_xmlNodeListGetString_12;
                        return_value_xmlNodeListGetString_12=xmlNodeListGetString(doc, node->children, 1);
                        temp = (char *)return_value_xmlNodeListGetString_12;
                        if(temp == ((char *)NULL))
                        {
                          log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_paths", "<adminroot> must not be empty.");
                          goto __CPROVER_DUMP_L35;
                        }

                        if(!(configuration->adminroot_dir == ((char *)NULL)))
                          xmlFree((void *)configuration->adminroot_dir);

                        configuration->adminroot_dir = (char *)temp;
                        unsigned long int return_value_strlen_14;
                        return_value_strlen_14=strlen(configuration->adminroot_dir);
                        if((signed int)configuration->adminroot_dir[-1l + (signed long int)return_value_strlen_14] == 47)
                        {
                          return_value_strlen_13=strlen(configuration->adminroot_dir);
                          configuration->adminroot_dir[(signed long int)(return_value_strlen_13 - (unsigned long int)1)] = (char)0;
                        }

                      }

                      else
                      {
                        return_value_xmlStrcmp_21=xmlStrcmp(node->name, (unsigned char *)"alias");
                        if(return_value_xmlStrcmp_21 == 0)
                        {
                          void *return_value_malloc_15;
                          return_value_malloc_15=malloc(sizeof(struct _aliases) /*40ul*/ );
                          alias = (struct _aliases *)return_value_malloc_15;
                          alias->next = (struct _aliases *)(void *)0;
                          unsigned char *return_value_xmlGetProp_16;
                          return_value_xmlGetProp_16=xmlGetProp(node, (unsigned char *)"source");
                          alias->source = (char *)return_value_xmlGetProp_16;
                          if(alias->source == ((char *)NULL))
                          {
                            free((void *)alias);
                            goto __CPROVER_DUMP_L35;
                          }

                          unsigned char *return_value_xmlGetProp_17;
                          return_value_xmlGetProp_17=xmlGetProp(node, (unsigned char *)"destination");
                          alias->destination = (char *)return_value_xmlGetProp_17;
                          if(alias->destination == ((char *)NULL))
                          {
                            return_value_xmlGetProp_18=xmlGetProp(node, (unsigned char *)"dest");
                            alias->destination = (char *)return_value_xmlGetProp_18;
                          }

                          if(alias->destination == ((char *)NULL))
                          {
                            xmlFree((void *)alias->source);
                            free((void *)alias);
                          }

                          temp = (char *)(void *)0;
                          unsigned char *return_value_xmlGetProp_19;
                          return_value_xmlGetProp_19=xmlGetProp(node, (unsigned char *)"port");
                          temp = (char *)return_value_xmlGetProp_19;
                          if(!(temp == ((char *)NULL)))
                          {
                            alias->port=atoi(temp);
                            xmlFree((void *)temp);
                          }

                          else
                            alias->port = -1;
                          unsigned char *return_value_xmlGetProp_20;
                          return_value_xmlGetProp_20=xmlGetProp(node, (unsigned char *)"bind-address");
                          alias->bind_address = (char *)return_value_xmlGetProp_20;
                          current = configuration->aliases;
                          last = (struct _aliases *)(void *)0;
                          for( ; !(current == ((struct _aliases *)NULL)); current = current->next)
                            last = current;
                          if(!(last == ((struct _aliases *)NULL)))
                            last->next = alias;

                          else
                            configuration->aliases = alias;
                        }

                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }


  __CPROVER_DUMP_L35:
    ;
    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
}

// _parse_relay
// file cfgfile.c line 892
static void _parse_relay(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  char *tmp;
  struct _relay_server *relay;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _relay_server) /*104ul*/ );
  relay = (struct _relay_server *)return_value_calloc_1;
  struct _relay_server *current = configuration->relay;
  struct _relay_server *last = (struct _relay_server *)(void *)0;
  for( ; !(current == ((struct _relay_server *)NULL)); current = current->next)
    last = current;
  if(!(last == ((struct _relay_server *)NULL)))
    last->next = relay;

  else
    configuration->relay = relay;
  relay->next = (struct _relay_server *)(void *)0;
  relay->mp3metadata = 1;
  relay->on_demand = configuration->on_demand;
  unsigned char *return_value_xmlCharStrdup_2;
  return_value_xmlCharStrdup_2=xmlCharStrdup("127.0.0.1");
  relay->server = (char *)return_value_xmlCharStrdup_2;
  unsigned char *return_value_xmlCharStrdup_3;
  return_value_xmlCharStrdup_3=xmlCharStrdup("/");
  relay->mount = (char *)return_value_xmlCharStrdup_3;
  signed int return_value_xmlStrcmp_21;
  signed int return_value_xmlStrcmp_20;
  signed int return_value_xmlStrcmp_19;
  signed int return_value_xmlStrcmp_18;
  signed int return_value_xmlStrcmp_17;
  signed int return_value_xmlStrcmp_16;
  signed int return_value_xmlStrcmp_15;
  signed int return_value_xmlStrcmp_14;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_4;
    return_value_xmlIsBlankNode_4=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_4 == 0)
    {
      signed int return_value_xmlStrcmp_22;
      return_value_xmlStrcmp_22=xmlStrcmp(node->name, (unsigned char *)"server");
      if(return_value_xmlStrcmp_22 == 0)
      {
        if(!(relay->server == ((char *)NULL)))
          xmlFree((void *)relay->server);

        unsigned char *return_value_xmlNodeListGetString_5;
        return_value_xmlNodeListGetString_5=xmlNodeListGetString(doc, node->children, 1);
        relay->server = (char *)return_value_xmlNodeListGetString_5;
      }

      else
      {
        return_value_xmlStrcmp_21=xmlStrcmp(node->name, (unsigned char *)"port");
        if(return_value_xmlStrcmp_21 == 0)
        {
          unsigned char *return_value_xmlNodeListGetString_6;
          return_value_xmlNodeListGetString_6=xmlNodeListGetString(doc, node->children, 1);
          tmp = (char *)return_value_xmlNodeListGetString_6;
          if(!(tmp == ((char *)NULL)))
          {
            relay->port=atoi(tmp);
            xmlFree((void *)tmp);
          }

          else
            log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_relay", "<port> must not be empty.");
        }

        else
        {
          return_value_xmlStrcmp_20=xmlStrcmp(node->name, (unsigned char *)"mount");
          if(return_value_xmlStrcmp_20 == 0)
          {
            if(!(relay->mount == ((char *)NULL)))
              xmlFree((void *)relay->mount);

            unsigned char *return_value_xmlNodeListGetString_7;
            return_value_xmlNodeListGetString_7=xmlNodeListGetString(doc, node->children, 1);
            relay->mount = (char *)return_value_xmlNodeListGetString_7;
          }

          else
          {
            return_value_xmlStrcmp_19=xmlStrcmp(node->name, (unsigned char *)"local-mount");
            if(return_value_xmlStrcmp_19 == 0)
            {
              if(!(relay->localmount == ((char *)NULL)))
                xmlFree((void *)relay->localmount);

              unsigned char *return_value_xmlNodeListGetString_8;
              return_value_xmlNodeListGetString_8=xmlNodeListGetString(doc, node->children, 1);
              relay->localmount = (char *)return_value_xmlNodeListGetString_8;
            }

            else
            {
              return_value_xmlStrcmp_18=xmlStrcmp(node->name, (unsigned char *)"relay-shoutcast-metadata");
              if(return_value_xmlStrcmp_18 == 0)
              {
                unsigned char *return_value_xmlNodeListGetString_9;
                return_value_xmlNodeListGetString_9=xmlNodeListGetString(doc, node->children, 1);
                tmp = (char *)return_value_xmlNodeListGetString_9;
                relay->mp3metadata=atoi(tmp);
                if(!(tmp == ((char *)NULL)))
                  xmlFree((void *)tmp);

              }

              else
              {
                return_value_xmlStrcmp_17=xmlStrcmp(node->name, (unsigned char *)"username");
                if(return_value_xmlStrcmp_17 == 0)
                {
                  if(!(relay->username == ((char *)NULL)))
                    xmlFree((void *)relay->username);

                  unsigned char *return_value_xmlNodeListGetString_10;
                  return_value_xmlNodeListGetString_10=xmlNodeListGetString(doc, node->children, 1);
                  relay->username = (char *)return_value_xmlNodeListGetString_10;
                }

                else
                {
                  return_value_xmlStrcmp_16=xmlStrcmp(node->name, (unsigned char *)"password");
                  if(return_value_xmlStrcmp_16 == 0)
                  {
                    if(!(relay->password == ((char *)NULL)))
                      xmlFree((void *)relay->password);

                    unsigned char *return_value_xmlNodeListGetString_11;
                    return_value_xmlNodeListGetString_11=xmlNodeListGetString(doc, node->children, 1);
                    relay->password = (char *)return_value_xmlNodeListGetString_11;
                  }

                  else
                  {
                    return_value_xmlStrcmp_15=xmlStrcmp(node->name, (unsigned char *)"on-demand");
                    if(return_value_xmlStrcmp_15 == 0)
                    {
                      unsigned char *return_value_xmlNodeListGetString_12;
                      return_value_xmlNodeListGetString_12=xmlNodeListGetString(doc, node->children, 1);
                      tmp = (char *)return_value_xmlNodeListGetString_12;
                      relay->on_demand=atoi(tmp);
                      if(!(tmp == ((char *)NULL)))
                        xmlFree((void *)tmp);

                    }

                    else
                    {
                      return_value_xmlStrcmp_14=xmlStrcmp(node->name, (unsigned char *)"bind");
                      if(return_value_xmlStrcmp_14 == 0)
                      {
                        if(!(relay->bind == ((char *)NULL)))
                          xmlFree((void *)relay->bind);

                        unsigned char *return_value_xmlNodeListGetString_13;
                        return_value_xmlNodeListGetString_13=xmlNodeListGetString(doc, node->children, 1);
                        relay->bind = (char *)return_value_xmlNodeListGetString_13;
                      }

                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
  unsigned char *return_value_xmlStrdup_23;
  if(relay->localmount == ((char *)NULL))
  {
    return_value_xmlStrdup_23=xmlStrdup((unsigned char *)relay->mount);
    relay->localmount = (char *)return_value_xmlStrdup_23;
  }

}

// _parse_root
// file cfgfile.c line 453
static void _parse_root(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  char *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _listener_t) /*48ul*/ );
  configuration->listen_sock = (struct _listener_t *)return_value_calloc_1;
  configuration->listen_sock->port = 8000;
  configuration->listen_sock_count = (unsigned int)1;
  signed int return_value_xmlStrcmp_45;
  signed int return_value_xmlStrcmp_44;
  signed int return_value_xmlStrcmp_43;
  signed int return_value_xmlStrcmp_42;
  signed int return_value_xmlStrcmp_41;
  signed int return_value_xmlStrcmp_40;
  signed int return_value_xmlStrcmp_39;
  signed int return_value_xmlStrcmp_38;
  signed int return_value_xmlStrcmp_37;
  signed int return_value_xmlStrcmp_36;
  signed int return_value_xmlStrcmp_35;
  signed int return_value_xmlStrcmp_34;
  signed int return_value_xmlStrcmp_33;
  signed int return_value_xmlStrcmp_32;
  signed int return_value_xmlStrcmp_31;
  signed int return_value_xmlStrcmp_30;
  signed int return_value_xmlStrcmp_29;
  signed int return_value_xmlStrcmp_28;
  signed int return_value_xmlStrcmp_27;
  signed int return_value_xmlStrcmp_26;
  signed int return_value_xmlStrcmp_25;
  signed int return_value_xmlStrcmp_24;
  signed int return_value_xmlStrcmp_23;
  signed int return_value_xmlStrcmp_22;
  signed int return_value_xmlStrcmp_21;
  signed int return_value_xmlStrcmp_20;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_2;
    return_value_xmlIsBlankNode_2=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_2 == 0)
    {
      signed int return_value_xmlStrcmp_46;
      return_value_xmlStrcmp_46=xmlStrcmp(node->name, (unsigned char *)"location");
      if(return_value_xmlStrcmp_46 == 0)
      {
        if(!(configuration->location == ((char *)NULL)))
          xmlFree((void *)configuration->location);

        unsigned char *return_value_xmlNodeListGetString_3;
        return_value_xmlNodeListGetString_3=xmlNodeListGetString(doc, node->children, 1);
        configuration->location = (char *)return_value_xmlNodeListGetString_3;
      }

      else
      {
        return_value_xmlStrcmp_45=xmlStrcmp(node->name, (unsigned char *)"admin");
        if(return_value_xmlStrcmp_45 == 0)
        {
          if(!(configuration->admin == ((char *)NULL)))
            xmlFree((void *)configuration->admin);

          unsigned char *return_value_xmlNodeListGetString_4;
          return_value_xmlNodeListGetString_4=xmlNodeListGetString(doc, node->children, 1);
          configuration->admin = (char *)return_value_xmlNodeListGetString_4;
        }

        else
        {
          return_value_xmlStrcmp_44=xmlStrcmp(node->name, (unsigned char *)"server-id");
          if(return_value_xmlStrcmp_44 == 0)
          {
            xmlFree((void *)configuration->server_id);
            unsigned char *return_value_xmlNodeListGetString_5;
            return_value_xmlNodeListGetString_5=xmlNodeListGetString(doc, node->children, 1);
            configuration->server_id = (char *)return_value_xmlNodeListGetString_5;
            log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_root", "Warning, server version string override detected. This may lead to unexpected client software behavior.");
          }

          else
          {
            return_value_xmlStrcmp_43=xmlStrcmp(node->name, (unsigned char *)"authentication");
            if(return_value_xmlStrcmp_43 == 0)
              _parse_authentication(doc, node->children, configuration);

            else
            {
              return_value_xmlStrcmp_42=xmlStrcmp(node->name, (unsigned char *)"source-password");
              if(return_value_xmlStrcmp_42 == 0)
              {
                log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_root", "<source-password> defined outside <authentication>. This is deprecated.");
                if(!(configuration->source_password == ((char *)NULL)))
                  xmlFree((void *)configuration->source_password);

                unsigned char *return_value_xmlNodeListGetString_6;
                return_value_xmlNodeListGetString_6=xmlNodeListGetString(doc, node->children, 1);
                configuration->source_password = (char *)return_value_xmlNodeListGetString_6;
              }

              else
              {
                return_value_xmlStrcmp_41=xmlStrcmp(node->name, (unsigned char *)"icelogin");
                if(return_value_xmlStrcmp_41 == 0)
                {
                  unsigned char *return_value_xmlNodeListGetString_7;
                  return_value_xmlNodeListGetString_7=xmlNodeListGetString(doc, node->children, 1);
                  tmp = (char *)return_value_xmlNodeListGetString_7;
                  configuration->ice_login=atoi(tmp);
                  if(!(tmp == ((char *)NULL)))
                    xmlFree((void *)tmp);

                }

                else
                {
                  return_value_xmlStrcmp_40=xmlStrcmp(node->name, (unsigned char *)"fileserve");
                  if(return_value_xmlStrcmp_40 == 0)
                  {
                    unsigned char *return_value_xmlNodeListGetString_8;
                    return_value_xmlNodeListGetString_8=xmlNodeListGetString(doc, node->children, 1);
                    tmp = (char *)return_value_xmlNodeListGetString_8;
                    configuration->fileserve=atoi(tmp);
                    if(!(tmp == ((char *)NULL)))
                      xmlFree((void *)tmp);

                  }

                  else
                  {
                    return_value_xmlStrcmp_39=xmlStrcmp(node->name, (unsigned char *)"relays-on-demand");
                    if(return_value_xmlStrcmp_39 == 0)
                    {
                      unsigned char *return_value_xmlNodeListGetString_9;
                      return_value_xmlNodeListGetString_9=xmlNodeListGetString(doc, node->children, 1);
                      tmp = (char *)return_value_xmlNodeListGetString_9;
                      configuration->on_demand=atoi(tmp);
                      if(!(tmp == ((char *)NULL)))
                        xmlFree((void *)tmp);

                    }

                    else
                    {
                      return_value_xmlStrcmp_38=xmlStrcmp(node->name, (unsigned char *)"hostname");
                      if(return_value_xmlStrcmp_38 == 0)
                      {
                        if(!(configuration->hostname == ((char *)NULL)))
                          xmlFree((void *)configuration->hostname);

                        unsigned char *return_value_xmlNodeListGetString_10;
                        return_value_xmlNodeListGetString_10=xmlNodeListGetString(doc, node->children, 1);
                        configuration->hostname = (char *)return_value_xmlNodeListGetString_10;
                      }

                      else
                      {
                        return_value_xmlStrcmp_37=xmlStrcmp(node->name, (unsigned char *)"mime-types");
                        if(return_value_xmlStrcmp_37 == 0)
                        {
                          if(!(configuration->mimetypes_fn == ((char *)NULL)))
                            xmlFree((void *)configuration->mimetypes_fn);

                          unsigned char *return_value_xmlNodeListGetString_11;
                          return_value_xmlNodeListGetString_11=xmlNodeListGetString(doc, node->children, 1);
                          configuration->mimetypes_fn = (char *)return_value_xmlNodeListGetString_11;
                        }

                        else
                        {
                          return_value_xmlStrcmp_36=xmlStrcmp(node->name, (unsigned char *)"listen-socket");
                          if(return_value_xmlStrcmp_36 == 0)
                            _parse_listen_socket(doc, node->children, configuration);

                          else
                          {
                            return_value_xmlStrcmp_35=xmlStrcmp(node->name, (unsigned char *)"port");
                            if(return_value_xmlStrcmp_35 == 0)
                            {
                              unsigned char *return_value_xmlNodeListGetString_12;
                              return_value_xmlNodeListGetString_12=xmlNodeListGetString(doc, node->children, 1);
                              tmp = (char *)return_value_xmlNodeListGetString_12;
                              if(!(tmp == ((char *)NULL)))
                              {
                                configuration->port=atoi(tmp);
                                configuration->listen_sock->port=atoi(tmp);
                                xmlFree((void *)tmp);
                              }

                              else
                                log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_root", "<port> must not be empty.");
                            }

                            else
                            {
                              return_value_xmlStrcmp_34=xmlStrcmp(node->name, (unsigned char *)"bind-address");
                              if(return_value_xmlStrcmp_34 == 0)
                              {
                                if(!(configuration->listen_sock->bind_address == ((char *)NULL)))
                                  xmlFree((void *)configuration->listen_sock->bind_address);

                                unsigned char *return_value_xmlNodeListGetString_13;
                                return_value_xmlNodeListGetString_13=xmlNodeListGetString(doc, node->children, 1);
                                configuration->listen_sock->bind_address = (char *)return_value_xmlNodeListGetString_13;
                              }

                              else
                              {
                                return_value_xmlStrcmp_33=xmlStrcmp(node->name, (unsigned char *)"master-server");
                                if(return_value_xmlStrcmp_33 == 0)
                                {
                                  if(!(configuration->master_server == ((char *)NULL)))
                                    xmlFree((void *)configuration->master_server);

                                  unsigned char *return_value_xmlNodeListGetString_14;
                                  return_value_xmlNodeListGetString_14=xmlNodeListGetString(doc, node->children, 1);
                                  configuration->master_server = (char *)return_value_xmlNodeListGetString_14;
                                }

                                else
                                {
                                  return_value_xmlStrcmp_32=xmlStrcmp(node->name, (unsigned char *)"master-username");
                                  if(return_value_xmlStrcmp_32 == 0)
                                  {
                                    if(!(configuration->master_username == ((char *)NULL)))
                                      xmlFree((void *)configuration->master_username);

                                    unsigned char *return_value_xmlNodeListGetString_15;
                                    return_value_xmlNodeListGetString_15=xmlNodeListGetString(doc, node->children, 1);
                                    configuration->master_username = (char *)return_value_xmlNodeListGetString_15;
                                  }

                                  else
                                  {
                                    return_value_xmlStrcmp_31=xmlStrcmp(node->name, (unsigned char *)"master-password");
                                    if(return_value_xmlStrcmp_31 == 0)
                                    {
                                      if(!(configuration->master_password == ((char *)NULL)))
                                        xmlFree((void *)configuration->master_password);

                                      unsigned char *return_value_xmlNodeListGetString_16;
                                      return_value_xmlNodeListGetString_16=xmlNodeListGetString(doc, node->children, 1);
                                      configuration->master_password = (char *)return_value_xmlNodeListGetString_16;
                                    }

                                    else
                                    {
                                      return_value_xmlStrcmp_30=xmlStrcmp(node->name, (unsigned char *)"master-server-port");
                                      if(return_value_xmlStrcmp_30 == 0)
                                      {
                                        unsigned char *return_value_xmlNodeListGetString_17;
                                        return_value_xmlNodeListGetString_17=xmlNodeListGetString(doc, node->children, 1);
                                        tmp = (char *)return_value_xmlNodeListGetString_17;
                                        configuration->master_server_port=atoi(tmp);
                                        xmlFree((void *)tmp);
                                      }

                                      else
                                      {
                                        return_value_xmlStrcmp_29=xmlStrcmp(node->name, (unsigned char *)"master-update-interval");
                                        if(return_value_xmlStrcmp_29 == 0)
                                        {
                                          unsigned char *return_value_xmlNodeListGetString_18;
                                          return_value_xmlNodeListGetString_18=xmlNodeListGetString(doc, node->children, 1);
                                          tmp = (char *)return_value_xmlNodeListGetString_18;
                                          configuration->master_update_interval=atoi(tmp);
                                          xmlFree((void *)tmp);
                                        }

                                        else
                                        {
                                          return_value_xmlStrcmp_28=xmlStrcmp(node->name, (unsigned char *)"shoutcast-mount");
                                          if(return_value_xmlStrcmp_28 == 0)
                                          {
                                            if(!(configuration->shoutcast_mount == ((char *)NULL)))
                                              xmlFree((void *)configuration->shoutcast_mount);

                                            unsigned char *return_value_xmlNodeListGetString_19;
                                            return_value_xmlNodeListGetString_19=xmlNodeListGetString(doc, node->children, 1);
                                            configuration->shoutcast_mount = (char *)return_value_xmlNodeListGetString_19;
                                          }

                                          else
                                          {
                                            return_value_xmlStrcmp_27=xmlStrcmp(node->name, (unsigned char *)"limits");
                                            if(return_value_xmlStrcmp_27 == 0)
                                              _parse_limits(doc, node->children, configuration);

                                            else
                                            {
                                              return_value_xmlStrcmp_26=xmlStrcmp(node->name, (unsigned char *)"http-headers");
                                              if(return_value_xmlStrcmp_26 == 0)
                                                _parse_http_headers(doc, node->children, &configuration->http_headers);

                                              else
                                              {
                                                return_value_xmlStrcmp_25=xmlStrcmp(node->name, (unsigned char *)"relay");
                                                if(return_value_xmlStrcmp_25 == 0)
                                                  _parse_relay(doc, node->children, configuration);

                                                else
                                                {
                                                  return_value_xmlStrcmp_24=xmlStrcmp(node->name, (unsigned char *)"mount");
                                                  if(return_value_xmlStrcmp_24 == 0)
                                                    _parse_mount(doc, node, configuration);

                                                  else
                                                  {
                                                    return_value_xmlStrcmp_23=xmlStrcmp(node->name, (unsigned char *)"directory");
                                                    if(return_value_xmlStrcmp_23 == 0)
                                                      _parse_directory(doc, node->children, configuration);

                                                    else
                                                    {
                                                      return_value_xmlStrcmp_22=xmlStrcmp(node->name, (unsigned char *)"paths");
                                                      if(return_value_xmlStrcmp_22 == 0)
                                                        _parse_paths(doc, node->children, configuration);

                                                      else
                                                      {
                                                        return_value_xmlStrcmp_21=xmlStrcmp(node->name, (unsigned char *)"logging");
                                                        if(return_value_xmlStrcmp_21 == 0)
                                                          _parse_logging(doc, node->children, configuration);

                                                        else
                                                        {
                                                          return_value_xmlStrcmp_20=xmlStrcmp(node->name, (unsigned char *)"security");
                                                          if(return_value_xmlStrcmp_20 == 0)
                                                            _parse_security(doc, node->children, configuration);

                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
  if(configuration->listen_sock_count >= 2u)
  {
    configuration->listen_sock=config_clear_listener(configuration->listen_sock);
    configuration->listen_sock_count = configuration->listen_sock_count - 1u;
  }

  if(configuration->port == 0)
    configuration->port = 8000;

  if(configuration->fileserve == 0)
    log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_root", "Warning, serving of static files has been disabled in the config, this will also affect files used by the web interface (stylesheets, images).");

  _Bool tmp_if_expr_49;
  signed int return_value_strcmp_48;
  if(configuration->hostname == ((char *)NULL))
    tmp_if_expr_49 = (_Bool)1;

  else
  {
    return_value_strcmp_48=strcmp(configuration->hostname, "localhost");
    tmp_if_expr_49 = return_value_strcmp_48 == 0 ? (_Bool)1 : (_Bool)0;
  }
  unsigned char *return_value_xmlCharStrdup_47;
  if(tmp_if_expr_49)
  {
    log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_root", "Warning, <hostname> not configured, using default value \"%s\". This will cause problems, e.g. with YP directory listings.", (const void *)"localhost");
    if(configuration->hostname == ((char *)NULL))
    {
      return_value_xmlCharStrdup_47=xmlCharStrdup("localhost");
      configuration->hostname = (char *)return_value_xmlCharStrdup_47;
    }

  }

  _Bool tmp_if_expr_52;
  signed int return_value_strcmp_51;
  if(configuration->location == ((char *)NULL))
    tmp_if_expr_52 = (_Bool)1;

  else
  {
    return_value_strcmp_51=strcmp(configuration->location, "Earth");
    tmp_if_expr_52 = return_value_strcmp_51 == 0 ? (_Bool)1 : (_Bool)0;
  }
  unsigned char *return_value_xmlCharStrdup_50;
  if(tmp_if_expr_52)
  {
    log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_root", "Warning, <location> not configured, using default value \"%s\".", (const void *)"Earth");
    if(configuration->location == ((char *)NULL))
    {
      return_value_xmlCharStrdup_50=xmlCharStrdup("Earth");
      configuration->location = (char *)return_value_xmlCharStrdup_50;
    }

  }

  _Bool tmp_if_expr_55;
  signed int return_value_strcmp_54;
  if(configuration->admin == ((char *)NULL))
    tmp_if_expr_55 = (_Bool)1;

  else
  {
    return_value_strcmp_54=strcmp(configuration->admin, "icemaster@localhost");
    tmp_if_expr_55 = return_value_strcmp_54 == 0 ? (_Bool)1 : (_Bool)0;
  }
  unsigned char *return_value_xmlCharStrdup_53;
  if(tmp_if_expr_55)
  {
    log_write(errorlog, (unsigned int)2, "CONFIG/", "_parse_root", "Warning, <admin> contact not configured, using default value \"%s\".", (const void *)"icemaster@localhost");
    if(configuration->admin == ((char *)NULL))
    {
      return_value_xmlCharStrdup_53=xmlCharStrdup("icemaster@localhost");
      configuration->admin = (char *)return_value_xmlCharStrdup_53;
    }

  }

}

// _parse_security
// file cfgfile.c line 1257
static void _parse_security(struct _xmlDoc *doc, struct _xmlNode *node, struct ice_config_tag *configuration)
{
  char *tmp;
  struct _xmlNode *oldnode;
  signed int return_value_xmlStrcmp_8;
  signed int return_value_xmlStrcmp_6;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    signed int return_value_xmlIsBlankNode_1;
    return_value_xmlIsBlankNode_1=xmlIsBlankNode(node);
    if(return_value_xmlIsBlankNode_1 == 0)
    {
      signed int return_value_xmlStrcmp_9;
      return_value_xmlStrcmp_9=xmlStrcmp(node->name, (unsigned char *)"chroot");
      if(return_value_xmlStrcmp_9 == 0)
      {
        unsigned char *return_value_xmlNodeListGetString_2;
        return_value_xmlNodeListGetString_2=xmlNodeListGetString(doc, node->children, 1);
        tmp = (char *)return_value_xmlNodeListGetString_2;
        configuration->chroot=atoi(tmp);
        if(!(tmp == ((char *)NULL)))
          xmlFree((void *)tmp);

      }

      else
      {
        return_value_xmlStrcmp_8=xmlStrcmp(node->name, (unsigned char *)"changeowner");
        if(return_value_xmlStrcmp_8 == 0)
        {
          configuration->chuid = 1;
          oldnode = node;
          node = node->children;
          while(!(node == ((struct _xmlNode *)NULL)))
          {
            signed int return_value_xmlIsBlankNode_3;
            return_value_xmlIsBlankNode_3=xmlIsBlankNode(node);
            if(return_value_xmlIsBlankNode_3 == 0)
            {
              signed int return_value_xmlStrcmp_7;
              return_value_xmlStrcmp_7=xmlStrcmp(node->name, (unsigned char *)"user");
              if(return_value_xmlStrcmp_7 == 0)
              {
                if(!(configuration->user == ((char *)NULL)))
                  xmlFree((void *)configuration->user);

                unsigned char *return_value_xmlNodeListGetString_4;
                return_value_xmlNodeListGetString_4=xmlNodeListGetString(doc, node->children, 1);
                configuration->user = (char *)return_value_xmlNodeListGetString_4;
              }

              else
              {
                return_value_xmlStrcmp_6=xmlStrcmp(node->name, (unsigned char *)"group");
                if(return_value_xmlStrcmp_6 == 0)
                {
                  if(!(configuration->group == ((char *)NULL)))
                    xmlFree((void *)configuration->group);

                  unsigned char *return_value_xmlNodeListGetString_5;
                  return_value_xmlNodeListGetString_5=xmlNodeListGetString(doc, node->children, 1);
                  configuration->group = (char *)return_value_xmlNodeListGetString_5;
                }

              }
            }

            node = node->next;
            if(node == ((struct _xmlNode *)NULL))
              break;

          }
          node = oldnode;
        }

      }
    }

    node = node->next;
    if(node == ((struct _xmlNode *)NULL))
      break;

  }
}

// _print_usage
// file main.c line 91
static void _print_usage(void)
{
  printf("%s\n\n", (const void *)"Icecast 2.4.2");
  printf("usage: icecast [-b] -c <file>\n");
  printf("or   : icecast {-v|--version}\n");
  printf("options:\n");
  printf("\t-c <file>       Specify configuration file\n");
  printf("\t-v or --version Display version info\n");
  printf("\t-b              Run icecast in the background\n");
  printf("\n");
}

// _register_listener
// file stats.c line 863
static void _register_listener(struct _event_listener_tag *listener)
{
  struct avl_node_tag *node;
  struct avl_node_tag *node2;
  struct _stats_event_tag *event;
  struct _stats_source_tag *source;
  thread_mutex_lock_c(&_stats_mutex, 870, "stats.c");
  node=avl_get_first(_stats.global_tree);
  while(!(node == ((struct avl_node_tag *)NULL)))
  {
    event=_make_event_from_node((struct _stats_node_tag *)node->key, (char *)(void *)0);
    _add_event_to_queue(event, &listener->queue);
    node=avl_get_next(node);
  }
  node=avl_get_first(_stats.source_tree);
  while(!(node == ((struct avl_node_tag *)NULL)))
  {
    source = (struct _stats_source_tag *)node->key;
    node2=avl_get_first(source->stats_tree);
    while(!(node2 == ((struct avl_node_tag *)NULL)))
    {
      event=_make_event_from_node((struct _stats_node_tag *)node2->key, source->source);
      _add_event_to_queue(event, &listener->queue);
      node2=avl_get_next(node2);
    }
    node=avl_get_next(node);
  }
  listener->next = (struct _event_listener_tag *)_event_listeners;
  _event_listeners = listener;
  thread_mutex_unlock_c(&_stats_mutex, 902, "stats.c");
}

// _send_event_to_client
// file stats.c line 795
static signed int _send_event_to_client(struct _stats_event_tag *event, struct _client_tag *client)
{
  signed int len;
  char buf[200l];
  char *tmp_if_expr_1;
  if(!(event->source == ((char *)NULL)))
    tmp_if_expr_1 = event->source;

  else
    tmp_if_expr_1 = "global";
  char *tmp_if_expr_2;
  if(!(event->name == ((char *)NULL)))
    tmp_if_expr_2 = event->name;

  else
    tmp_if_expr_2 = "null";
  char *tmp_if_expr_3;
  if(!(event->value == ((char *)NULL)))
    tmp_if_expr_3 = event->value;

  else
    tmp_if_expr_3 = "null";
  len=snprintf(buf, sizeof(char [200l]) /*200ul*/ , "EVENT %s %s %s\n", tmp_if_expr_1, tmp_if_expr_2, tmp_if_expr_3);
  if(len >= 1 && !(len >= (signed int)sizeof(char [200l]) /*200*/ ))
  {
    client_send_bytes(client, (const void *)buf, (unsigned int)len);
    if(client->con->error == 0)
      goto __CPROVER_DUMP_L7;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    return 0;
  }
}

// _server_proc
// file main.c line 336
static void _server_proc(void)
{
  if(!(background == 0))
  {
    fclose(stdin);
    fclose(stdout);
    fclose(stderr);
  }

  connection_accept_loop();
  connection_setup_sockets((struct ice_config_tag *)(void *)0);
}

// _server_proc_init
// file main.c line 308
static signed int _server_proc_init(void)
{
  struct ice_config_tag *config;
  config=config_get_config_unlocked();
  signed int return_value_connection_setup_sockets_1;
  return_value_connection_setup_sockets_1=connection_setup_sockets(config);
  if(!(return_value_connection_setup_sockets_1 >= 1))
    return 0;

  else
  {
    signed int return_value__start_listening_2;
    return_value__start_listening_2=_start_listening();
    if(return_value__start_listening_2 == 0)
    {
      _fatal_error("Failed trying to listen on server socket");
      return 0;
    }

    else
    {
      if(!(config->pidfile == ((char *)NULL)))
      {
        struct _IO_FILE *f;
        pidfile=strdup(config->pidfile);
        if(!(pidfile == ((char *)NULL)))
        {
          f=fopen(config->pidfile, "w");
          if(!(f == ((struct _IO_FILE *)NULL)))
          {
            signed int return_value_getpid_3;
            return_value_getpid_3=getpid();
            fprintf(f, "%d\n", (signed int)return_value_getpid_3);
            fclose(f);
          }

        }

      }

      return 1;
    }
  }
}

// _set_defaults
// file cfgfile.c line 407
static void _set_defaults(struct ice_config_tag *configuration)
{
  unsigned char *return_value_xmlCharStrdup_1;
  return_value_xmlCharStrdup_1=xmlCharStrdup("Earth");
  configuration->location = (char *)return_value_xmlCharStrdup_1;
  unsigned char *return_value_xmlCharStrdup_2;
  return_value_xmlCharStrdup_2=xmlCharStrdup("Icecast 2.4.2");
  configuration->server_id = (char *)return_value_xmlCharStrdup_2;
  unsigned char *return_value_xmlCharStrdup_3;
  return_value_xmlCharStrdup_3=xmlCharStrdup("icemaster@localhost");
  configuration->admin = (char *)return_value_xmlCharStrdup_3;
  configuration->client_limit = 256;
  configuration->source_limit = 16;
  configuration->queue_size_limit = (unsigned int)(500 * 1024);
  configuration->threadpool_size = 4;
  configuration->client_timeout = 30;
  configuration->header_timeout = 15;
  configuration->source_timeout = 10;
  configuration->source_password = (char *)(void *)0;
  unsigned char *return_value_xmlCharStrdup_4;
  return_value_xmlCharStrdup_4=xmlCharStrdup("/stream");
  configuration->shoutcast_mount = (char *)return_value_xmlCharStrdup_4;
  configuration->ice_login = 0;
  configuration->fileserve = 1;
  configuration->touch_interval = 5;
  configuration->on_demand = 0;
  configuration->dir_list = (struct ice_config_dir_tag *)(void *)0;
  unsigned char *return_value_xmlCharStrdup_5;
  return_value_xmlCharStrdup_5=xmlCharStrdup("localhost");
  configuration->hostname = (char *)return_value_xmlCharStrdup_5;
  unsigned char *return_value_xmlCharStrdup_6;
  return_value_xmlCharStrdup_6=xmlCharStrdup("/etc/mime.types");
  configuration->mimetypes_fn = (char *)return_value_xmlCharStrdup_6;
  configuration->master_server = (char *)(void *)0;
  configuration->master_server_port = 0;
  configuration->master_update_interval = 120;
  unsigned char *return_value_xmlCharStrdup_7;
  return_value_xmlCharStrdup_7=xmlCharStrdup("relay");
  configuration->master_username = (char *)return_value_xmlCharStrdup_7;
  configuration->master_password = (char *)(void *)0;
  unsigned char *return_value_xmlCharStrdup_8;
  return_value_xmlCharStrdup_8=xmlCharStrdup("/usr/local/icecast");
  configuration->base_dir = (char *)return_value_xmlCharStrdup_8;
  unsigned char *return_value_xmlCharStrdup_9;
  return_value_xmlCharStrdup_9=xmlCharStrdup("/usr/local/icecast/logs");
  configuration->log_dir = (char *)return_value_xmlCharStrdup_9;
  unsigned char *return_value_xmlCharStrdup_10;
  return_value_xmlCharStrdup_10=xmlCharStrdup("ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA");
  configuration->cipher_list = (char *)return_value_xmlCharStrdup_10;
  unsigned char *return_value_xmlCharStrdup_11;
  return_value_xmlCharStrdup_11=xmlCharStrdup("/usr/local/icecast/webroot");
  configuration->webroot_dir = (char *)return_value_xmlCharStrdup_11;
  unsigned char *return_value_xmlCharStrdup_12;
  return_value_xmlCharStrdup_12=xmlCharStrdup("/usr/local/icecast/admin");
  configuration->adminroot_dir = (char *)return_value_xmlCharStrdup_12;
  unsigned char *return_value_xmlCharStrdup_13;
  return_value_xmlCharStrdup_13=xmlCharStrdup((const char *)(void *)0);
  configuration->playlist_log = (char *)return_value_xmlCharStrdup_13;
  unsigned char *return_value_xmlCharStrdup_14;
  return_value_xmlCharStrdup_14=xmlCharStrdup("access.log");
  configuration->access_log = (char *)return_value_xmlCharStrdup_14;
  unsigned char *return_value_xmlCharStrdup_15;
  return_value_xmlCharStrdup_15=xmlCharStrdup("error.log");
  configuration->error_log = (char *)return_value_xmlCharStrdup_15;
  configuration->loglevel = 3;
  configuration->chroot = 0;
  configuration->chuid = 0;
  configuration->user = (char *)(void *)0;
  configuration->group = (char *)(void *)0;
  configuration->num_yp_directories = 0;
  unsigned char *return_value_xmlCharStrdup_16;
  return_value_xmlCharStrdup_16=xmlCharStrdup("relay");
  configuration->relay_username = (char *)return_value_xmlCharStrdup_16;
  configuration->relay_password = (char *)(void *)0;
  configuration->burst_size = (unsigned int)(64 * 1024);
}

// _sig_die
// file sighandler.c line 68
void _sig_die(signed int signo)
{
  log_write(errorlog, (unsigned int)3, "sighandler/", "_sig_die", "Caught signal %d, shutting down...", signo);
  global.running = 2;
}

// _sig_hup
// file sighandler.c line 56
void _sig_hup(signed int signo)
{
  log_write(errorlog, (unsigned int)3, "sighandler/", "_sig_hup", "Caught signal %d, scheduling config re-read...", signo);
  global_lock();
  global.schedule_config_reread = 1;
  global_unlock();
  signal(1, _sig_hup);
}

// _sig_ignore
// file sighandler.c line 51
void _sig_ignore(signed int signo)
{
  signal(signo, _sig_ignore);
}

// _slave_thread
// file slave.c line 725
static void * _slave_thread(void *arg)
{
  struct ice_config_tag *config;
  unsigned int interval = (unsigned int)0;
  thread_mutex_lock_c(&_slave_mutex, 730, "slave.c");
  update_settings = 0;
  update_all_mounts = 0;
  thread_mutex_unlock_c(&_slave_mutex, 733, "slave.c");
  config=config_get_config();
  stats_global(config);
  config_release_config();
  source_recheck_mounts(1);
  while((_Bool)1)
  {
    struct _relay_server *cleanup_relays = (struct _relay_server *)(void *)0;
    signed int skip_timer = 0;
    global_lock();
    if(!(global.schedule_config_reread == 0))
    {
      event_config_read((void *)0);
      global.schedule_config_reread = 0;
    }

    global_unlock();
    thread_sleep((unsigned long int)1000000);
    if(slave_running == 0)
      break;

    interval = interval + 1u;
    thread_mutex_lock_c(&_slave_mutex, 761, "slave.c");
    if(interval >= max_interval)
    {
      log_write(errorlog, (unsigned int)4, "slave/", "_slave_thread", "checking master stream list");
      config=config_get_config();
      if(max_interval == 0u)
        skip_timer = 1;

      interval = (unsigned int)0;
      max_interval = (volatile unsigned int)config->master_update_interval;
      thread_mutex_unlock_c(&_slave_mutex, 771, "slave.c");
      signed int return_value_update_from_master_1;
      return_value_update_from_master_1=update_from_master(config);
      if(!(return_value_update_from_master_1 == 0))
        config=config_get_config();

      struct anonymous_17 *return_value_config_locks_2;
      return_value_config_locks_2=config_locks();
      thread_mutex_lock_c(&return_value_config_locks_2->relay_lock, 777, "slave.c");
      cleanup_relays=update_relays(&global.relays, config->relay);
      config_release_config();
    }

    else
    {
      thread_mutex_unlock_c(&_slave_mutex, 785, "slave.c");
      struct anonymous_17 *return_value_config_locks_3;
      return_value_config_locks_3=config_locks();
      thread_mutex_lock_c(&return_value_config_locks_3->relay_lock, 786, "slave.c");
    }
    relay_check_streams(global.relays, cleanup_relays, skip_timer);
    relay_check_streams(global.master_relays, (struct _relay_server *)(void *)0, skip_timer);
    struct anonymous_17 *return_value_config_locks_4;
    return_value_config_locks_4=config_locks();
    thread_mutex_unlock_c(&return_value_config_locks_4->relay_lock, 791, "slave.c");
    thread_mutex_lock_c(&_slave_mutex, 793, "slave.c");
    if(!(update_settings == 0))
    {
      source_recheck_mounts(update_all_mounts);
      update_settings = 0;
      update_all_mounts = 0;
    }

    thread_mutex_unlock_c(&_slave_mutex, 800, "slave.c");
  }
  log_write(errorlog, (unsigned int)3, "slave/", "_slave_thread", "shutting down current relays");
  relay_check_streams((struct _relay_server *)(void *)0, global.relays, 0);
  relay_check_streams((struct _relay_server *)(void *)0, global.master_relays, 0);
  log_write(errorlog, (unsigned int)3, "slave/", "_slave_thread", "Slave thread shutdown complete");
  return (void *)0;
}

// _start_listening
// file main.c line 294
static signed int _start_listening(void)
{
  signed int i = 0;
  for( ; !(i >= global.server_sockets); i = i + 1)
  {
    signed int return_value_sock_listen_1;
    return_value_sock_listen_1=sock_listen(global.serversock[(signed long int)i], 5);
    if(return_value_sock_listen_1 == -1)
      return 0;

    sock_set_blocking(global.serversock[(signed long int)i], 0);
  }
  return 1;
}

// _start_logging
// file main.c line 213
static signed int _start_logging(void)
{
  char fn_error[4096l];
  char fn_access[4096l];
  char fn_playlist[4096l];
  char buf[1024l];
  signed int log_to_stderr;
  struct ice_config_tag *config;
  config=config_get_config_unlocked();
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(config->error_log, "-");
  if(!(return_value_strcmp_1 == 0))
  {
    snprintf(fn_error, (unsigned long int)4096, "%s%s%s", config->log_dir, (const void *)"/", config->error_log);
    errorlog=log_open(fn_error);
    log_to_stderr = 0;
    if(!(config->logsize == 0))
      log_set_trigger(errorlog, (unsigned int)config->logsize);

    log_set_archive_timestamp(errorlog, config->logarchive);
  }

  char *tmp_if_expr_2;
  if(!(errorlog >= 0))
  {
    buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    if(!(log_to_stderr == 0))
      tmp_if_expr_2 = "standard error";

    else
      tmp_if_expr_2 = fn_error;
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    snprintf(buf, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "FATAL: could not open error logging (%s): %s", tmp_if_expr_2, return_value_strerror_4);
    _fatal_error(buf);
  }

  log_set_level(errorlog, (unsigned int)config->loglevel);
  signed int return_value_strcmp_5;
  return_value_strcmp_5=strcmp(config->access_log, "-");
  if(!(return_value_strcmp_5 == 0))
  {
    snprintf(fn_access, (unsigned long int)4096, "%s%s%s", config->log_dir, (const void *)"/", config->access_log);
    accesslog=log_open(fn_access);
    log_to_stderr = 0;
    if(!(config->logsize == 0))
      log_set_trigger(accesslog, (unsigned int)config->logsize);

    log_set_archive_timestamp(accesslog, config->logarchive);
  }

  else
  {
    accesslog=log_open_file(stderr);
    log_to_stderr = 1;
  }
  char *tmp_if_expr_6;
  if(!(accesslog >= 0))
  {
    buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    if(!(log_to_stderr == 0))
      tmp_if_expr_6 = "standard error";

    else
      tmp_if_expr_6 = fn_access;
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    char *return_value_strerror_8;
    return_value_strerror_8=strerror(*return_value___errno_location_7);
    snprintf(buf, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "FATAL: could not open access logging (%s): %s", tmp_if_expr_6, return_value_strerror_8);
    _fatal_error(buf);
  }

  char *tmp_if_expr_9;
  if(!(config->playlist_log == ((char *)NULL)))
  {
    snprintf(fn_playlist, (unsigned long int)4096, "%s%s%s", config->log_dir, (const void *)"/", config->playlist_log);
    playlistlog=log_open(fn_playlist);
    if(!(playlistlog >= 0))
    {
      buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
      if(!(log_to_stderr == 0))
        tmp_if_expr_9 = "standard error";

      else
        tmp_if_expr_9 = fn_playlist;
      signed int *return_value___errno_location_10;
      return_value___errno_location_10=__errno_location();
      char *return_value_strerror_11;
      return_value_strerror_11=strerror(*return_value___errno_location_10);
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "FATAL: could not open playlist logging (%s): %s", tmp_if_expr_9, return_value_strerror_11);
      _fatal_error(buf);
    }

    log_to_stderr = 0;
    if(!(config->logsize == 0))
      log_set_trigger(playlistlog, (unsigned int)config->logsize);

    log_set_archive_timestamp(playlistlog, config->logarchive);
  }

  else
    playlistlog = -1;
  log_set_level(errorlog, (unsigned int)config->loglevel);
  log_set_level(accesslog, (unsigned int)4);
  log_set_level(playlistlog, (unsigned int)4);
  if(accesslog >= 0 && errorlog >= 0)
    return 1;

  else
    return 0;
}

// _start_logging_stdout
// file main.c line 203
static signed int _start_logging_stdout(void)
{
  errorlog=log_open_file(stderr);
  if(!(errorlog >= 0))
    return 0;

  else
  {
    log_set_level(errorlog, (unsigned int)2);
    return 1;
  }
}

// _start_routine
// file thread.c line 635
static void * _start_routine(void *arg)
{
  struct thread_start_tag *start = (struct thread_start_tag *)arg;
  void * (*start_routine)(void *) = start->start_routine;
  void *real_arg = start->arg;
  struct anonymous_24 *thread = start->thread;
  _block_signals();
  _mutex_lock(&_threadtree_mutex);
  thread->sys_thread=pthread_self();
  avl_insert(_threadtree, (void *)thread);
  _mutex_unlock(&_threadtree_mutex);
  pthread_setcancelstate(0, (signed int *)(void *)0);
  free((void *)start);
  start_routine(real_arg);
  if(!(thread->detached == 0))
  {
    _mutex_lock(&_threadtree_mutex);
    avl_delete(_threadtree, (void *)thread, _free_thread);
    _mutex_unlock(&_threadtree_mutex);
  }

  return (void *)0;
}

// _stats_thread
// file stats.c line 664
static void * _stats_thread(void *arg)
{
  struct _stats_event_tag *event;
  struct _stats_event_tag *copy;
  struct _event_listener_tag *listener;
  stats_event_time((const char *)(void *)0, "server_start");
  stats_event_time_iso8601((const char *)(void *)0, "server_start_iso8601");
  stats_event((const char *)(void *)0, "clients", "0");
  stats_event((const char *)(void *)0, "connections", "0");
  stats_event((const char *)(void *)0, "sources", "0");
  stats_event((const char *)(void *)0, "stats", "0");
  stats_event((const char *)(void *)0, "listeners", "0");
  stats_event((const char *)(void *)0, "client_connections", "0");
  stats_event((const char *)(void *)0, "source_client_connections", "0");
  stats_event((const char *)(void *)0, "source_relay_connections", "0");
  stats_event((const char *)(void *)0, "source_total_connections", "0");
  stats_event((const char *)(void *)0, "stats_connections", "0");
  stats_event((const char *)(void *)0, "listener_connections", "0");
  log_write(errorlog, (unsigned int)3, "stats/", "_stats_thread", "stats thread started");
  while(!(_stats_running == 0))
  {
    thread_mutex_lock_c(&_global_event_mutex, 690, "stats.c");
    if(!(_global_event_queue.head == ((volatile struct _stats_event_tag *)NULL)))
    {
      event=_get_event_from_queue(&_global_event_queue);
      thread_mutex_unlock_c(&_global_event_mutex, 694, "stats.c");
      if(event == ((struct _stats_event_tag *)NULL))
        continue;

      event->next = (struct _stats_event_tag *)(void *)0;
      thread_mutex_lock_c(&_stats_mutex, 700, "stats.c");
      if(event->source == ((char *)NULL))
        process_global_event(event);

      else
        process_source_event(event);
      listener = (struct _event_listener_tag *)_event_listeners;
      for( ; !(listener == ((struct _event_listener_tag *)NULL)); listener = listener->next)
      {
        copy=_copy_event(event);
        thread_mutex_lock_c(&listener->mutex, 713, "stats.c");
        _add_event_to_queue(copy, &listener->queue);
        thread_mutex_unlock_c(&listener->mutex, 715, "stats.c");
      }
      _free_event(event);
      thread_mutex_unlock_c(&_stats_mutex, 723, "stats.c");
      continue;
    }

    else
      thread_mutex_unlock_c(&_global_event_mutex, 728, "stats.c");
    thread_sleep((unsigned long int)300000);
  }
  return (void *)0;
}

// _stop_logging
// file main.c line 103
static void _stop_logging(void)
{
  log_close(errorlog);
  log_close(accesslog);
  log_close(playlistlog);
}

// _unlock_logger
// file log.c line 651
static void _unlock_logger(void)
{
  pthread_mutex_unlock(&_logger_mutex);
}

// _unregister_listener
// file stats.c line 738
static void _unregister_listener(struct _event_listener_tag *listener)
{
  struct _event_listener_tag **prev = (struct _event_listener_tag **)&_event_listeners;
  struct _event_listener_tag *current = *prev;
  for( ; !(current == ((struct _event_listener_tag *)NULL)); current = *prev)
  {
    if(current == listener)
    {
      *prev = current->next;
      break;
    }

    prev = &current->next;
  }
}

// accept_ip_address
// file connection.c line 384
static signed int accept_ip_address(char *ip)
{
  void *result;
  recheck_ip_file(&banned_ip);
  recheck_ip_file(&allowed_ip);
  if(!(banned_ip.contents == ((struct _avl_tree *)NULL)))
  {
    signed int return_value_avl_get_by_key_1;
    return_value_avl_get_by_key_1=avl_get_by_key(banned_ip.contents, (void *)ip, &result);
    if(return_value_avl_get_by_key_1 == 0)
    {
      log_write(errorlog, (unsigned int)4, "connection/", "accept_ip_address", "%s is banned", ip);
      return 0;
    }

  }

  if(!(allowed_ip.contents == ((struct _avl_tree *)NULL)))
  {
    signed int return_value_avl_get_by_key_2;
    return_value_avl_get_by_key_2=avl_get_by_key(allowed_ip.contents, (void *)ip, &result);
    if(return_value_avl_get_by_key_2 == 0)
    {
      log_write(errorlog, (unsigned int)4, "connection/", "accept_ip_address", "%s is allowed", ip);
      return 1;
    }

    else
    {
      log_write(errorlog, (unsigned int)4, "connection/", "accept_ip_address", "%s is not allowed", ip);
      return 0;
    }
  }

  return 1;
}

// add_audio_packet
// file format_vorbis.c line 127
static void add_audio_packet(struct vorbis_codec_tag *source_vorbis, struct anonymous_14 *packet)
{
  if(!(source_vorbis->initial_audio_packet == 0))
  {
    packet->granulepos = (signed long int)0;
    source_vorbis->initial_audio_packet = 0;
  }

  else
  {
    source_vorbis->samples_in_page = source_vorbis->samples_in_page + (packet->granulepos - source_vorbis->prev_granulepos);
    source_vorbis->prev_granulepos = packet->granulepos;
    source_vorbis->granulepos = source_vorbis->granulepos + (signed long int)source_vorbis->prev_window;
  }
  ogg_stream_packetin(&source_vorbis->new_os, packet);
}

// add_authenticated_listener
// file auth.c line 433
static signed int add_authenticated_listener(const char *mount, struct _mount_proxy *mountinfo, struct _client_tag *client)
{
  signed int ret = 0;
  struct source_tag *source = (struct source_tag *)(void *)0;
  client->authenticated = 1;
  signed int return_value_util_check_valid_extension_1;
  return_value_util_check_valid_extension_1=util_check_valid_extension(mount);
  signed long int return_value_time_3;
  if(return_value_util_check_valid_extension_1 == 1)
  {
    log_write(errorlog, (unsigned int)4, "auth/", "add_authenticated_listener", "Stats request, sending XSL transformed stats");
    stats_transform_xslt(client, mount);
    return 0;
  }

  else
  {
    avl_tree_rlock(global.source_tree);
    source=source_find_mount(mount);
    if(!(source == ((struct source_tag *)NULL)))
    {
      if(!(mountinfo == ((struct _mount_proxy *)NULL)))
      {
        signed int return_value_check_duplicate_logins_2;
        return_value_check_duplicate_logins_2=check_duplicate_logins(source, client, mountinfo->auth);
        if(return_value_check_duplicate_logins_2 == 0)
        {
          avl_tree_unlock(global.source_tree);
          return -1;
        }

        if(!(mountinfo->max_listener_duration == 0u))
        {
          if(client->con->discon_time == 0l)
          {
            return_value_time_3=time((signed long int *)(void *)0);
            client->con->discon_time = return_value_time_3 + (signed long int)mountinfo->max_listener_duration;
          }

        }

      }

      ret=add_listener_to_source(source, client);
      avl_tree_unlock(global.source_tree);
      if(ret == 0)
        log_write(errorlog, (unsigned int)4, "auth/", "add_authenticated_listener", "client authenticated, passed to source");

    }

    else
    {
      avl_tree_unlock(global.source_tree);
      fserve_client_create(client, mount);
    }
    return ret;
  }
}

// add_listener_to_source
// file auth.c line 378
static signed int add_listener_to_source(struct source_tag *source, struct _client_tag *client)
{
  signed int loop = 10;
  do
  {
    log_write(errorlog, (unsigned int)4, "auth/", "add_listener_to_source", "max on %s is %ld (cur %lu)", source->mount, source->max_listeners, source->listeners);
    if(source->max_listeners == -1l)
      break;

    if(!(source->listeners >= (unsigned long int)source->max_listeners))
      break;

    if(!(loop == 0))
    {
      if(!(source->fallback_when_full == 0))
      {
        if(!(source->fallback_mount == ((char *)NULL)))
        {
          struct source_tag *next;
          next=source_find_mount(source->fallback_mount);
          if(next == ((struct source_tag *)NULL))
          {
            log_write(errorlog, (unsigned int)1, "auth/", "add_listener_to_source", "Fallback '%s' for full source '%s' not found", source->mount, source->fallback_mount);
            return -1;
          }

          log_write(errorlog, (unsigned int)3, "auth/", "add_listener_to_source", "stream full trying %s", next->mount);
          source = next;
          loop = loop - 1;
          continue;
        }

      }

    }

    return -1;
  }
  while((_Bool)1);
  client->write_to_client = format_generic_write_to_client;
  client->check_buffer = format_check_http_buffer;
  client->refbuf->len = (unsigned int)4096;
  memset((void *)client->refbuf->data, 0, (unsigned long int)4096);
  avl_tree_wlock(source->pending_tree);
  avl_insert(source->pending_tree, (void *)client);
  avl_tree_unlock(source->pending_tree);
  if(source->running == 0)
  {
    if(!(source->on_demand == 0))
    {
      log_write(errorlog, (unsigned int)4, "auth/", "add_listener_to_source", "kicking off on-demand relay");
      source->on_demand_req = 1;
    }

  }

  log_write(errorlog, (unsigned int)4, "auth/", "add_listener_to_source", "Added client to %s", source->mount);
  return 0;
}

// add_pending_yp
// file yp.c line 669
static void add_pending_yp(struct yp_server *server)
{
  struct ypdata_tag *current;
  struct ypdata_tag *yp;
  unsigned int count = (unsigned int)0;
  if(!(server->pending_mounts == ((struct ypdata_tag *)NULL)))
  {
    current = server->mounts;
    server->mounts = server->pending_mounts;
    server->pending_mounts = (struct ypdata_tag *)(void *)0;
    yp = server->mounts;
    for( ; (_Bool)1; yp = yp->next)
    {
      count = count + 1u;
      if(yp->next == ((struct ypdata_tag *)NULL))
        break;

    }
    yp->next = current;
    log_write(errorlog, (unsigned int)4, "yp/", "add_pending_yp", "%u YP entries added to %s", count, server->url);
  }

}

// add_yp_info
// file yp.c line 812
static void add_yp_info(struct ypdata_tag *yp, void *info, signed int type)
{
  char *escaped;
  if(!(info == NULL))
  {
    escaped=util_url_escape((const char *)info);
    if(!(escaped == ((char *)NULL)))
      switch(type)
      {
        case 1:
        {
          free((void *)yp->server_name);
          yp->server_name = escaped;
          break;
        }
        case 2:
        {
          free((void *)yp->server_desc);
          yp->server_desc = escaped;
          break;
        }
        case 3:
        {
          free((void *)yp->server_genre);
          yp->server_genre = escaped;
          break;
        }
        case 4:
        {
          free((void *)yp->url);
          yp->url = escaped;
          break;
        }
        case 5:
        {
          free((void *)yp->bitrate);
          yp->bitrate = escaped;
          break;
        }
        case 6:
        {
          free((void *)yp->audio_info);
          yp->audio_info = escaped;
          break;
        }
        case 7:
        {
          free((void *)yp->server_type);
          yp->server_type = escaped;
          break;
        }
        case 8:
        {
          free((void *)yp->current_song);
          yp->current_song = escaped;
          break;
        }
        case 9:
        {
          free((void *)yp->cluster_password);
          yp->cluster_password = escaped;
          break;
        }
        case 10:
        {
          free((void *)yp->subtype);
          yp->subtype = escaped;
          break;
        }
        default:
          free((void *)escaped);
      }

  }

}

// admin_build_sourcelist
// file admin.c line 198
struct _xmlDoc * admin_build_sourcelist(const char *mount)
{
  struct avl_node_tag *node;
  struct source_tag *source;
  struct _xmlNode *xmlnode;
  struct _xmlNode *srcnode;
  struct _xmlDoc *doc;
  char buf[22l];
  signed long int admin_build_sourcelist__1__now;
  admin_build_sourcelist__1__now=time((signed long int *)(void *)0);
  doc=xmlNewDoc((unsigned char *)"1.0");
  xmlnode=xmlNewDocNode(doc, (struct _xmlNs *)(void *)0, (unsigned char *)"icestats", (const unsigned char *)(void *)0);
  xmlDocSetRootElement(doc, xmlnode);
  if(!(mount == ((const char *)NULL)))
    xmlNewChild(xmlnode, (struct _xmlNs *)(void *)0, (unsigned char *)"current_source", (unsigned char *)mount);

  node=avl_get_first(global.source_tree);
  signed int return_value_strcmp_1;
  _Bool tmp_if_expr_3;
  unsigned char *tmp_if_expr_2;
  while(!(node == ((struct avl_node_tag *)NULL)))
  {
    source = (struct source_tag *)node->key;
    if(!(mount == ((const char *)NULL)))
    {
      return_value_strcmp_1=strcmp(mount, source->mount);
      if(!(return_value_strcmp_1 == 0))
        goto __CPROVER_DUMP_L3;

      node=avl_get_next(node);
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(!(source->running == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = source->on_demand != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        struct ice_config_tag *config;
        struct _mount_proxy *mountinfo;
        srcnode=xmlNewChild(xmlnode, (struct _xmlNs *)(void *)0, (unsigned char *)"source", (const unsigned char *)(void *)0);
        xmlSetProp(srcnode, (unsigned char *)"mount", (unsigned char *)source->mount);
        if(!(source->fallback_mount == ((char *)NULL)))
          tmp_if_expr_2 = (unsigned char *)source->fallback_mount;

        else
          tmp_if_expr_2 = (unsigned char *)"";
        xmlNewChild(srcnode, (struct _xmlNs *)(void *)0, (unsigned char *)"fallback", tmp_if_expr_2);
        snprintf(buf, sizeof(char [22l]) /*22ul*/ , "%lu", source->listeners);
        xmlNewChild(srcnode, (struct _xmlNs *)(void *)0, (unsigned char *)"listeners", (unsigned char *)buf);
        config=config_get_config();
        mountinfo=config_find_mount(config, source->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
        if(!(mountinfo == ((struct _mount_proxy *)NULL)))
        {
          if(!(mountinfo->auth == ((struct auth_tag *)NULL)))
            xmlNewChild(srcnode, (struct _xmlNs *)(void *)0, (unsigned char *)"authenticator", (unsigned char *)mountinfo->auth->type);

        }

        config_release_config();
        if(!(source->running == 0))
        {
          if(!(source->client == ((struct _client_tag *)NULL)))
          {
            snprintf(buf, sizeof(char [22l]) /*22ul*/ , "%lu", (unsigned long int)(admin_build_sourcelist__1__now - source->con->con_time));
            xmlNewChild(srcnode, (struct _xmlNs *)(void *)0, (unsigned char *)"Connected", (unsigned char *)buf);
          }

          xmlNewChild(srcnode, (struct _xmlNs *)(void *)0, (unsigned char *)"content-type", (unsigned char *)source->format->contenttype);
        }

      }

      node=avl_get_next(node);
    }
  }
  return doc;
}

// admin_get_command
// file admin.c line 113
signed int admin_get_command(const char *command)
{
  signed int return_value_strcmp_27;
  return_value_strcmp_27=strcmp(command, "fallbacks");
  signed int return_value_strcmp_26;
  signed int return_value_strcmp_25;
  signed int return_value_strcmp_24;
  signed int return_value_strcmp_23;
  signed int return_value_strcmp_22;
  signed int return_value_strcmp_21;
  signed int return_value_strcmp_20;
  signed int return_value_strcmp_19;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_14;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(return_value_strcmp_27 == 0)
    return 1;

  else
  {
    return_value_strcmp_26=strcmp(command, "fallbacks.xsl");
    if(return_value_strcmp_26 == 0)
      return 50;

    else
    {
      return_value_strcmp_25=strcmp(command, "metadata");
      if(return_value_strcmp_25 == 0)
        return 2;

      else
      {
        return_value_strcmp_24=strcmp(command, "metadata.xsl");
        if(return_value_strcmp_24 == 0)
          return 57;

        else
        {
          return_value_strcmp_23=strcmp(command, "admin.cgi");
          if(return_value_strcmp_23 == 0)
            return 6;

          else
          {
            return_value_strcmp_22=strcmp(command, "listclients");
            if(return_value_strcmp_22 == 0)
              return 3;

            else
            {
              return_value_strcmp_21=strcmp(command, "listclients.xsl");
              if(return_value_strcmp_21 == 0)
                return 53;

              else
              {
                return_value_strcmp_20=strcmp(command, "stats");
                if(return_value_strcmp_20 == 0)
                  return 102;

                else
                {
                  return_value_strcmp_19=strcmp(command, "stats.xsl");
                  if(return_value_strcmp_19 == 0)
                    return 202;

                  else
                  {
                    return_value_strcmp_18=strcmp(command, "stats.xml");
                    if(return_value_strcmp_18 == 0)
                      return 102;

                    else
                    {
                      return_value_strcmp_17=strcmp(command, "listmounts");
                      if(return_value_strcmp_17 == 0)
                        return 101;

                      else
                      {
                        return_value_strcmp_16=strcmp(command, "listmounts.xsl");
                        if(return_value_strcmp_16 == 0)
                          return 201;

                        else
                        {
                          return_value_strcmp_15=strcmp(command, "streamlist");
                          if(return_value_strcmp_15 == 0)
                            return 103;

                          else
                          {
                            return_value_strcmp_14=strcmp(command, "streamlist.txt");
                            if(return_value_strcmp_14 == 0)
                              return 104;

                            else
                            {
                              return_value_strcmp_13=strcmp(command, "moveclients");
                              if(return_value_strcmp_13 == 0)
                                return 4;

                              else
                              {
                                return_value_strcmp_12=strcmp(command, "moveclients.xsl");
                                if(return_value_strcmp_12 == 0)
                                  return 54;

                                else
                                {
                                  return_value_strcmp_11=strcmp(command, "killclient");
                                  if(return_value_strcmp_11 == 0)
                                    return 301;

                                  else
                                  {
                                    return_value_strcmp_10=strcmp(command, "killclient.xsl");
                                    if(return_value_strcmp_10 == 0)
                                      return 401;

                                    else
                                    {
                                      return_value_strcmp_9=strcmp(command, "killsource");
                                      if(return_value_strcmp_9 == 0)
                                        return 302;

                                      else
                                      {
                                        return_value_strcmp_8=strcmp(command, "killsource.xsl");
                                        if(return_value_strcmp_8 == 0)
                                          return 402;

                                        else
                                        {
                                          return_value_strcmp_7=strcmp(command, "manageauth");
                                          if(return_value_strcmp_7 == 0)
                                            return 5;

                                          else
                                          {
                                            return_value_strcmp_6=strcmp(command, "manageauth.xsl");
                                            if(return_value_strcmp_6 == 0)
                                              return 55;

                                            else
                                            {
                                              return_value_strcmp_5=strcmp(command, "updatemetadata");
                                              if(return_value_strcmp_5 == 0)
                                                return 7;

                                              else
                                              {
                                                return_value_strcmp_4=strcmp(command, "updatemetadata.xsl");
                                                if(return_value_strcmp_4 == 0)
                                                  return 56;

                                                else
                                                {
                                                  return_value_strcmp_3=strcmp(command, "buildm3u");
                                                  if(return_value_strcmp_3 == 0)
                                                    return 501;

                                                  else
                                                  {
                                                    return_value_strcmp_2=strcmp(command, "");
                                                    if(return_value_strcmp_2 == 0)
                                                      return 202;

                                                    else
                                                    {
                                                      return_value_strcmp_1=strcmp(command, "");
                                                      if(return_value_strcmp_1 == 0)
                                                        return 202;

                                                      else
                                                        return -1;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// admin_handle_general_request
// file admin.c line 492
static void admin_handle_general_request(struct _client_tag *client, signed int command)
{
  switch(command)
  {
    case 102:
    {
      command_stats(client, (const char *)(void *)0, 1);
      break;
    }
    case 101:
    {
      command_list_mounts(client, 1);
      break;
    }
    case 103:
    {
      command_list_mounts(client, 1);
      break;
    }
    case 104:
    {
      command_list_mounts(client, 3);
      break;
    }
    case 202:
    {
      command_stats(client, (const char *)(void *)0, 2);
      break;
    }
    case 201:
    {
      command_list_mounts(client, 2);
      break;
    }
    case 203:
    {
      command_list_mounts(client, 2);
      break;
    }
    case 54:
    {
      command_list_mounts(client, 2);
      break;
    }
    default:
    {
      log_write(errorlog, (unsigned int)2, "admin/", "admin_handle_general_request", "General admin request not recognised");
      client_send_400(client, "Unknown admin request");
    }
  }
}

// admin_handle_mount_request
// file admin.c line 526
static void admin_handle_mount_request(struct _client_tag *client, struct source_tag *source, signed int command)
{
  switch(command)
  {
    case 102:
    {
      command_stats(client, source->mount, 1);
      break;
    }
    case 1:
    {
      command_fallback(client, source, 1);
      break;
    }
    case 2:
    {
      command_metadata(client, source, 1);
      break;
    }
    case 57:
    {
      command_metadata(client, source, 2);
      break;
    }
    case 6:
    {
      command_shoutcast_metadata(client, source);
      break;
    }
    case 3:
    {
      command_show_listeners(client, source, 1);
      break;
    }
    case 4:
    {
      command_move_clients(client, source, 1);
      break;
    }
    case 301:
    {
      command_kill_client(client, source, 1);
      break;
    }
    case 302:
    {
      command_kill_source(client, source, 1);
      break;
    }
    case 202:
    {
      command_stats(client, source->mount, 2);
      break;
    }
    case 50:
    {
      command_fallback(client, source, 1);
      break;
    }
    case 53:
    {
      command_show_listeners(client, source, 2);
      break;
    }
    case 54:
    {
      command_move_clients(client, source, 2);
      break;
    }
    case 401:
    {
      command_kill_client(client, source, 2);
      break;
    }
    case 402:
    {
      command_kill_source(client, source, 2);
      break;
    }
    case 55:
    {
      command_manageauth(client, source, 2);
      break;
    }
    case 5:
    {
      command_manageauth(client, source, 1);
      break;
    }
    case 56:
    {
      command_updatemetadata(client, source, 2);
      break;
    }
    case 7:
    {
      command_updatemetadata(client, source, 1);
      break;
    }
    default:
    {
      log_write(errorlog, (unsigned int)2, "admin/", "admin_handle_mount_request", "Mount request not recognised");
      client_send_400(client, "Mount request unknown");
    }
  }
}

// admin_handle_request
// file admin.h line 26
void admin_handle_request(struct _client_tag *client, const char *uri)
{
  const char *mount;
  const char *command_string;
  signed int command;
  log_write(errorlog, (unsigned int)4, "admin/", "admin_handle_request", "Admin request (%s)", uri);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(uri, "/admin.cgi");
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_2;
  if(return_value_strcmp_1 == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strncmp_2=strncmp("/admin/", uri, (unsigned long int)7);
    tmp_if_expr_3 = return_value_strncmp_2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_connection_check_admin_pass_6;
  if(!tmp_if_expr_3)
  {
    log_write(errorlog, (unsigned int)1, "admin/", "admin_handle_request", "Internal error: admin request isn't");
    client_send_401(client);
  }

  else
  {
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(uri, "/admin.cgi");
    if(return_value_strcmp_4 == 0)
      command_string = uri + (signed long int)1;

    else
      command_string = uri + (signed long int)7;
    log_write(errorlog, (unsigned int)4, "admin/", "admin_handle_request", "Got command (%s)", command_string);
    command=admin_get_command(command_string);
    if(!(command >= 0))
    {
      log_write(errorlog, (unsigned int)1, "admin/", "admin_handle_request", "Error parsing command string or unrecognised command: %s", command_string);
      client_send_400(client, "Unrecognised command");
    }

    else
    {
      if(command == 6)
      {
        struct ice_config_tag *config;
        const char *sc_mount;
        const char *pass;
        pass=httpp_get_query_param(client->parser, "pass");
        struct _listener_t *listener;
        if(pass == ((const char *)NULL))
        {
          client_send_400(client, "missing pass parameter");
          goto __CPROVER_DUMP_L26;
        }

        global_lock();
        config=config_get_config();
        sc_mount = config->shoutcast_mount;
        listener=config_get_listen_sock(config, client->con);
        if(!(listener == ((struct _listener_t *)NULL)))
        {
          if(!(listener->shoutcast_mount == ((char *)NULL)))
            sc_mount = listener->shoutcast_mount;

        }

        httpp_set_query_param(client->parser, "mount", sc_mount);
        httpp_setvar(client->parser, "__protocol", "ICY");
        httpp_setvar(client->parser, "__icy_password", pass);
        config_release_config();
        global_unlock();
      }

      mount=httpp_get_query_param(client->parser, "mount");
      if(!(mount == ((const char *)NULL)))
      {
        struct source_tag *source;
        if(command == 501)
        {
          command_buildm3u(client, mount);
          goto __CPROVER_DUMP_L26;
        }

        if(client->authenticated == 0)
        {
          return_value_connection_check_admin_pass_6=connection_check_admin_pass(client->parser);
          if(return_value_connection_check_admin_pass_6 == 0)
          {
            signed int return_value_client_check_source_auth_5;
            return_value_client_check_source_auth_5=client_check_source_auth(client, mount);
            if(!(return_value_client_check_source_auth_5 == 0))
            {
              if(return_value_client_check_source_auth_5 == 1)
                goto __CPROVER_DUMP_L13;

            }

            else
              goto __CPROVER_DUMP_L14;
            log_write(errorlog, (unsigned int)3, "admin/", "admin_handle_request", "Bad or missing password on mount modification admin request (command: %s)", command_string);
            client_send_401(client);

          __CPROVER_DUMP_L13:
            ;
            goto __CPROVER_DUMP_L26;
          }

        }


      __CPROVER_DUMP_L14:
        ;
        avl_tree_rlock(global.source_tree);
        source=source_find_mount_raw(mount);
        if(source == ((struct source_tag *)NULL))
        {
          log_write(errorlog, (unsigned int)2, "admin/", "admin_handle_request", "Admin command %s on non-existent source %s", command_string, mount);
          avl_tree_unlock(global.source_tree);
          client_send_400(client, "Source does not exist");
        }

        else
        {
          if(source->running == 0)
          {
            if(source->on_demand == 0)
            {
              avl_tree_unlock(global.source_tree);
              log_write(errorlog, (unsigned int)3, "admin/", "admin_handle_request", "Received admin command %s on unavailable mount \"%s\"", command_string, mount);
              client_send_400(client, "Source is not available");
              goto __CPROVER_DUMP_L26;
            }

          }

          if(command == 6)
          {
            if(source->shoutcast_compat == 0)
            {
              avl_tree_unlock(global.source_tree);
              log_write(errorlog, (unsigned int)1, "admin/", "admin_handle_request", "illegal change of metadata on non-shoutcast compatible stream");
              client_send_400(client, "illegal metadata call");
              goto __CPROVER_DUMP_L26;
            }

          }

          log_write(errorlog, (unsigned int)3, "admin/", "admin_handle_request", "Received admin command %s on mount \"%s\"", command_string, mount);
          admin_handle_mount_request(client, source, command);
          avl_tree_unlock(global.source_tree);
        }
      }

      else
      {
        if(command == 104)
        {
          signed int return_value_connection_check_relay_pass_7;
          return_value_connection_check_relay_pass_7=connection_check_relay_pass(client->parser);
          if(return_value_connection_check_relay_pass_7 == 0)
          {
            log_write(errorlog, (unsigned int)3, "admin/", "admin_handle_request", "Bad or missing password on admin command request (command: %s)", command_string);
            client_send_401(client);
            goto __CPROVER_DUMP_L26;
          }

        }

        else
        {
          signed int return_value_connection_check_admin_pass_8;
          return_value_connection_check_admin_pass_8=connection_check_admin_pass(client->parser);
          if(return_value_connection_check_admin_pass_8 == 0)
          {
            log_write(errorlog, (unsigned int)3, "admin/", "admin_handle_request", "Bad or missing password on admin command request (command: %s)", command_string);
            client_send_401(client);
            goto __CPROVER_DUMP_L26;
          }

        }
        admin_handle_general_request(client, command);
      }
    }
  }

__CPROVER_DUMP_L26:
  ;
}

// admin_send_response
// file admin.h line 27
void admin_send_response(struct _xmlDoc *doc, struct _client_tag *client, signed int response, const char *xslt_template)
{
  if(response == 1)
  {
    unsigned char *buff = (unsigned char *)(void *)0;
    signed int len = 0;
    unsigned long int buf_len;
    signed long int ret;
    xmlDocDumpMemory(doc, &buff, &len);
    buf_len = (unsigned long int)(len + 1024);
    if(!(buf_len >= 4096ul))
      buf_len = (unsigned long int)4096;

    client_set_queue(client, (struct _refbuf_tag *)(void *)0);
    client->refbuf=refbuf_new((unsigned int)buf_len);
    ret=util_http_build_header(client->refbuf->data, buf_len, (signed long int)0, 0, 200, (const char *)(void *)0, "text/xml", "utf-8", (const char *)(void *)0, (struct source_tag *)(void *)0);
    if(ret == -1l)
    {
      log_write(errorlog, (unsigned int)1, "admin/", "admin_send_response", "Dropping client as we can not build response headers.");
      client_send_500(client, "Header generation failed.");
      xmlFree((void *)buff);
    }

    else
      if(!(buf_len >= 64ul + (unsigned long int)ret + (unsigned long int)(signed long int)len))
      {
        void *new_data;
        buf_len = (unsigned long int)(ret + (signed long int)len + (signed long int)64);
        new_data=realloc((void *)client->refbuf->data, buf_len);
        if(!(new_data == NULL))
        {
          log_write(errorlog, (unsigned int)4, "admin/", "admin_send_response", "Client buffer reallocation succeeded.");
          client->refbuf->data = (char *)new_data;
          client->refbuf->len = (unsigned int)buf_len;
          ret=util_http_build_header(client->refbuf->data, buf_len, (signed long int)0, 0, 200, (const char *)(void *)0, "text/xml", "utf-8", (const char *)(void *)0, (struct source_tag *)(void *)0);
          if(ret == -1l)
          {
            log_write(errorlog, (unsigned int)1, "admin/", "admin_send_response", "Dropping client as we can not build response headers.");
            client_send_500(client, "Header generation failed.");
            xmlFree((void *)buff);
          }

        }

        else
        {
          log_write(errorlog, (unsigned int)1, "admin/", "admin_send_response", "Client buffer reallocation failed. Dropping client.");
          client_send_500(client, "Buffer reallocation failed.");
          xmlFree((void *)buff);
        }
      }

    signed int return_value_xmlStrlen_1;
    return_value_xmlStrlen_1=xmlStrlen(buff);
    signed int return_value_snprintf_2;
    return_value_snprintf_2=snprintf(client->refbuf->data + ret, buf_len - (unsigned long int)ret, "Content-Length: %d\r\n\r\n%s", return_value_xmlStrlen_1, buff);
    ret = ret + (signed long int)return_value_snprintf_2;
    client->refbuf->len = (unsigned int)ret;
    xmlFree((void *)buff);
    client->respcode = 200;
    fserve_add_client(client, (struct _IO_FILE *)(void *)0);
  }

  if(response == 2)
  {
    char *fullpath_xslt_template;
    signed int fullpath_xslt_template_len;
    struct ice_config_tag *config;
    config=config_get_config();
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(config->adminroot_dir);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(xslt_template);
    fullpath_xslt_template_len = (signed int)(return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)2);
    void *return_value_malloc_5;
    return_value_malloc_5=malloc((unsigned long int)fullpath_xslt_template_len);
    fullpath_xslt_template = (char *)return_value_malloc_5;
    snprintf(fullpath_xslt_template, (unsigned long int)fullpath_xslt_template_len, "%s%s%s", config->adminroot_dir, (const void *)"/", xslt_template);
    config_release_config();
    log_write(errorlog, (unsigned int)4, "admin/", "admin_send_response", "Sending XSLT (%s)", fullpath_xslt_template);
    xslt_transform(doc, fullpath_xslt_template, client);
    free((void *)fullpath_xslt_template);
  }

}

// auth_add_listener
// file auth.h line 89
void auth_add_listener(const char *mount, struct _client_tag *client)
{
  struct _mount_proxy *mountinfo;
  struct ice_config_tag *config;
  config=config_get_config();
  mountinfo=config_find_mount(config, mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
  _Bool tmp_if_expr_1;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(mountinfo->no_mount == 0)
      goto __CPROVER_DUMP_L1;

    config_release_config();
    client_send_403(client, "mountpoint unavailable");
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(mountinfo == ((struct _mount_proxy *)NULL)))
      tmp_if_expr_1 = mountinfo->auth != ((struct auth_tag *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      struct auth_client_tag *auth_user;
      if(mountinfo->auth->pending_count >= 101)
      {
        config_release_config();
        log_write(errorlog, (unsigned int)2, "auth/", "auth_add_listener", "too many clients awaiting authentication");
        client_send_403(client, "busy, please try again later");
        goto __CPROVER_DUMP_L8;
      }

      auth_user=auth_client_setup(mount, client);
      auth_user->process = auth_new_listener;
      log_write(errorlog, (unsigned int)3, "auth/", "auth_add_listener", "adding client for authentication");
      queue_auth_client(auth_user, mountinfo);
      config_release_config();
    }

    else
    {
      signed int ret;
      ret=add_authenticated_listener(mount, mountinfo, client);
      config_release_config();
      if(!(ret >= 0))
        client_send_403(client, "max listeners reached");

    }
  }

__CPROVER_DUMP_L8:
  ;
}

// auth_client_free
// file auth.c line 159
static void auth_client_free(struct auth_client_tag *auth_user)
{
  if(!(auth_user == ((struct auth_client_tag *)NULL)))
  {
    if(!(auth_user->client == ((struct _client_tag *)NULL)))
    {
      struct _client_tag *client = auth_user->client;
      if(!(client->respcode == 0))
        client_destroy(client);

      else
        client_send_401(client);
      auth_user->client = (struct _client_tag *)(void *)0;
    }

    free((void *)auth_user->mount);
    free((void *)auth_user);
  }

}

// auth_client_setup
// file auth.c line 44
static struct auth_client_tag * auth_client_setup(const char *mount, struct _client_tag *client)
{
  const char *header;
  header=httpp_getvar(client->parser, "authorization");
  char *userpass;
  char *tmp;
  char *username;
  char *password;
  struct auth_client_tag *auth_user;
  while(!(header == ((const char *)NULL)))
  {
    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(header, "Basic ", (unsigned long int)6);
    if(return_value_strncmp_1 == 0)
    {
      userpass=util_base64_decode(header + (signed long int)6);
      if(userpass == ((char *)NULL))
      {
        log_write(errorlog, (unsigned int)2, "auth/", "auth_client_setup", "Base64 decode of Authorization header \"%s\" failed", header + (signed long int)6);
        break;
      }

      tmp=strchr(userpass, 58);
      if(tmp == ((char *)NULL))
      {
        free((void *)userpass);
        break;
      }

      *tmp = (char)0;
      username = userpass;
      password = tmp + (signed long int)1;
      client->username=strdup(username);
      client->password=strdup(password);
      free((void *)userpass);
      break;
    }

    log_write(errorlog, (unsigned int)3, "auth/", "auth_client_setup", "unhandled authorization header: %s", header);
    break;
  }
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct auth_client_tag) /*32ul*/ );
  auth_user = (struct auth_client_tag *)return_value_calloc_2;
  auth_user->mount=strdup(mount);
  auth_user->client = client;
  return auth_user;
}

// auth_get_authenticator
// file auth.h line 95
struct auth_tag * auth_get_authenticator(struct _xmlNode *node)
{
  struct auth_tag *auth;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct auth_tag) /*184ul*/ );
  auth = (struct auth_tag *)return_value_calloc_1;
  struct _config_options *options = (struct _config_options *)(void *)0;
  struct _config_options **next_option = &options;
  struct _xmlNode *option;
  signed int return_value_xmlStrcmp_5;
  if(auth == ((struct auth_tag *)NULL))
    return (struct auth_tag *)(void *)0;

  else
  {
    option = node->children;
    while(!(option == ((struct _xmlNode *)NULL)))
    {
      struct _xmlNode *current = option;
      option = option->next;
      signed int return_value_xmlStrcmp_6;
      return_value_xmlStrcmp_6=xmlStrcmp(current->name, (unsigned char *)"option");
      if(return_value_xmlStrcmp_6 == 0)
      {
        struct _config_options *opt;
        void *return_value_calloc_2;
        return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct _config_options) /*24ul*/ );
        opt = (struct _config_options *)return_value_calloc_2;
        unsigned char *return_value_xmlGetProp_3;
        return_value_xmlGetProp_3=xmlGetProp(current, (unsigned char *)"name");
        opt->name = (char *)return_value_xmlGetProp_3;
        if(opt->name == ((char *)NULL))
        {
          free((void *)opt);
          continue;
        }

        unsigned char *return_value_xmlGetProp_4;
        return_value_xmlGetProp_4=xmlGetProp(current, (unsigned char *)"value");
        opt->value = (char *)return_value_xmlGetProp_4;
        if(opt->value == ((char *)NULL))
        {
          xmlFree((void *)opt->name);
          free((void *)opt);
          continue;
        }

        *next_option = opt;
        next_option = &opt->next;
      }

      else
      {
        return_value_xmlStrcmp_5=xmlStrcmp(current->name, (unsigned char *)"text");
        if(!(return_value_xmlStrcmp_5 == 0))
          log_write(errorlog, (unsigned int)2, "auth/", "auth_get_authenticator", "unknown auth setting (%s)", current->name);

      }
    }
    unsigned char *return_value_xmlGetProp_7;
    return_value_xmlGetProp_7=xmlGetProp(node, (unsigned char *)"type");
    auth->type = (char *)return_value_xmlGetProp_7;
    signed int return_value_get_authenticator_8;
    return_value_get_authenticator_8=get_authenticator(auth, options);
    if(!(return_value_get_authenticator_8 >= 0))
    {
      xmlFree((void *)auth->type);
      free((void *)auth);
      auth = (struct auth_tag *)(void *)0;
    }

    else
    {
      auth->tailp = &auth->head;
      thread_mutex_create_c(&auth->lock, 684, "auth.c");
      auth->refcount = 1;
      auth->running = 1;
      auth->thread=thread_create_c("auth thread", auth_run_thread, (void *)auth, 0, 687, "auth.c");
    }
    if(!(options == ((struct _config_options *)NULL)))
    {
      struct _config_options *auth_get_authenticator__1__4__opt = options;
      options = auth_get_authenticator__1__4__opt->next;
      xmlFree((void *)auth_get_authenticator__1__4__opt->name);
      xmlFree((void *)auth_get_authenticator__1__4__opt->value);
      free((void *)auth_get_authenticator__1__4__opt);
    }

    return auth;
  }
}

// auth_get_htpasswd_auth
// file auth_htpasswd.h line 20
signed int auth_get_htpasswd_auth(struct auth_tag *authenticator, struct _config_options *options)
{
  struct anonymous_20 *state;
  authenticator->authenticate = htpasswd_auth;
  authenticator->free = htpasswd_clear;
  authenticator->adduser = htpasswd_adduser;
  authenticator->deleteuser = htpasswd_deleteuser;
  authenticator->listuser = htpasswd_userlist;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_20) /*80ul*/ );
  state = (struct anonymous_20 *)return_value_calloc_1;
  while(!(options == ((struct _config_options *)NULL)))
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(options->name, "filename");
    if(return_value_strcmp_2 == 0)
    {
      free((void *)state->filename);
      state->filename=strdup(options->value);
    }

    options = options->next;
  }
  if(!(state->filename == ((char *)NULL)))
    log_write(errorlog, (unsigned int)3, "auth_htpasswd/", "auth_get_htpasswd_auth", "Configured htpasswd authentication using password file \"%s\"", state->filename);

  else
    log_write(errorlog, (unsigned int)1, "auth_htpasswd/", "auth_get_htpasswd_auth", "No filename given in options for authenticator.");
  authenticator->state = (void *)state;
  thread_rwlock_create_c(&state->file_rwlock, 250, "auth_htpasswd.c");
  htpasswd_recheckfile(state);
  return 0;
}

// auth_get_url_auth
// file auth_url.h line 20
signed int auth_get_url_auth(struct auth_tag *authenticator, struct _config_options *options)
{
  struct anonymous_33 *url_info;
  authenticator->free = auth_url_clear;
  authenticator->adduser = auth_url_adduser;
  authenticator->deleteuser = auth_url_deleteuser;
  authenticator->listuser = auth_url_listuser;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_33) /*376ul*/ );
  url_info = (struct anonymous_33 *)return_value_calloc_1;
  authenticator->state = (void *)url_info;
  url_info->auth_header=strdup("icecast-auth-user: 1\r\n");
  url_info->timelimit_header=strdup("icecast-auth-timelimit:");
  authenticator->authenticate = url_add_listener;
  while(!(options == ((struct _config_options *)NULL)))
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(options->name, "username");
    if(return_value_strcmp_2 == 0)
    {
      free((void *)url_info->username);
      url_info->username=strdup(options->value);
    }

    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(options->name, "password");
    if(return_value_strcmp_3 == 0)
    {
      free((void *)url_info->password);
      url_info->password=strdup(options->value);
    }

    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(options->name, "headers");
    if(return_value_strcmp_4 == 0)
    {
      free((void *)url_info->pass_headers);
      url_info->pass_headers=strdup(options->value);
    }

    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp(options->name, "header_prefix");
    if(return_value_strcmp_5 == 0)
    {
      free((void *)url_info->prefix_headers);
      url_info->prefix_headers=strdup(options->value);
    }

    signed int return_value_strcmp_6;
    return_value_strcmp_6=strcmp(options->name, "listener_add");
    if(return_value_strcmp_6 == 0)
    {
      free((void *)url_info->addurl);
      url_info->addurl=strdup(options->value);
    }

    signed int return_value_strcmp_7;
    return_value_strcmp_7=strcmp(options->name, "listener_remove");
    if(return_value_strcmp_7 == 0)
    {
      authenticator->release_listener = url_remove_listener;
      free((void *)url_info->removeurl);
      url_info->removeurl=strdup(options->value);
    }

    signed int return_value_strcmp_8;
    return_value_strcmp_8=strcmp(options->name, "mount_add");
    if(return_value_strcmp_8 == 0)
    {
      authenticator->stream_start = url_stream_start;
      free((void *)url_info->stream_start);
      url_info->stream_start=strdup(options->value);
    }

    signed int return_value_strcmp_9;
    return_value_strcmp_9=strcmp(options->name, "mount_remove");
    if(return_value_strcmp_9 == 0)
    {
      authenticator->stream_end = url_stream_end;
      free((void *)url_info->stream_end);
      url_info->stream_end=strdup(options->value);
    }

    signed int return_value_strcmp_10;
    return_value_strcmp_10=strcmp(options->name, "stream_auth");
    if(return_value_strcmp_10 == 0)
    {
      authenticator->stream_auth = url_stream_auth;
      free((void *)url_info->stream_auth);
      url_info->stream_auth=strdup(options->value);
    }

    signed int return_value_strcmp_11;
    return_value_strcmp_11=strcmp(options->name, "auth_header");
    if(return_value_strcmp_11 == 0)
    {
      free((void *)url_info->auth_header);
      url_info->auth_header=strdup(options->value);
    }

    signed int return_value_strcmp_12;
    return_value_strcmp_12=strcmp(options->name, "timelimit_header");
    if(return_value_strcmp_12 == 0)
    {
      free((void *)url_info->timelimit_header);
      url_info->timelimit_header=strdup(options->value);
    }

    options = options->next;
  }
  url_info->handle=curl_easy_init();
  unsigned long int return_value_strlen_13;
  unsigned long int return_value_strlen_14;
  if(url_info->handle == NULL)
  {
    auth_url_clear(authenticator);
    return -1;
  }

  else
  {
    if(!(url_info->auth_header == ((char *)NULL)))
    {
      return_value_strlen_13=strlen(url_info->auth_header);
      url_info->auth_header_len = (signed int)return_value_strlen_13;
    }

    if(!(url_info->timelimit_header == ((char *)NULL)))
    {
      return_value_strlen_14=strlen(url_info->timelimit_header);
      url_info->timelimit_header_len = (signed int)return_value_strlen_14;
    }

    signed int _curl_opt = CURLOPT_USERAGENT;
    curl_easy_setopt(url_info->handle, (enum anonymous_32)_curl_opt, (const void *)"Icecast 2.4.2");
    signed int auth_get_url_auth__1__4___curl_opt = CURLOPT_HEADERFUNCTION;
    curl_easy_setopt(url_info->handle, (enum anonymous_32)auth_get_url_auth__1__4___curl_opt, handle_returned_header);
    signed int auth_get_url_auth__1__5___curl_opt = CURLOPT_WRITEFUNCTION;
    curl_easy_setopt(url_info->handle, (enum anonymous_32)auth_get_url_auth__1__5___curl_opt, handle_returned_data);
    signed int auth_get_url_auth__1__6___curl_opt = CURLOPT_WRITEDATA;
    curl_easy_setopt(url_info->handle, (enum anonymous_32)auth_get_url_auth__1__6___curl_opt, url_info->handle);
    signed int auth_get_url_auth__1__7___curl_opt = CURLOPT_NOSIGNAL;
    if((_Bool)0)
    {
      if(auth_get_url_auth__1__7___curl_opt >= 30001)
      {
        goto __CPROVER_DUMP_L98;
        _curl_easy_setopt_err_curl_off_t();
      }


    __CPROVER_DUMP_L98:
      ;
      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_URL || auth_get_url_auth__1__7___curl_opt == CURLOPT_PROXY || auth_get_url_auth__1__7___curl_opt == CURLOPT_USERPWD || auth_get_url_auth__1__7___curl_opt == CURLOPT_PROXYUSERPWD || auth_get_url_auth__1__7___curl_opt == CURLOPT_RANGE || auth_get_url_auth__1__7___curl_opt == CURLOPT_REFERER || auth_get_url_auth__1__7___curl_opt == CURLOPT_FTPPORT || auth_get_url_auth__1__7___curl_opt == CURLOPT_USERAGENT || auth_get_url_auth__1__7___curl_opt == CURLOPT_COOKIE || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSLCERT || auth_get_url_auth__1__7___curl_opt == CURLOPT_KEYPASSWD || auth_get_url_auth__1__7___curl_opt == CURLOPT_COOKIEFILE || auth_get_url_auth__1__7___curl_opt == CURLOPT_CUSTOMREQUEST || auth_get_url_auth__1__7___curl_opt == CURLOPT_INTERFACE || auth_get_url_auth__1__7___curl_opt == CURLOPT_KRBLEVEL || auth_get_url_auth__1__7___curl_opt == CURLOPT_CAINFO || auth_get_url_auth__1__7___curl_opt == CURLOPT_RANDOM_FILE || auth_get_url_auth__1__7___curl_opt == CURLOPT_EGDSOCKET || auth_get_url_auth__1__7___curl_opt == CURLOPT_COOKIEJAR || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSL_CIPHER_LIST || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSLCERTTYPE || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSLKEY || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSLKEYTYPE || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSLENGINE || auth_get_url_auth__1__7___curl_opt == CURLOPT_CAPATH || auth_get_url_auth__1__7___curl_opt == CURLOPT_ACCEPT_ENCODING || auth_get_url_auth__1__7___curl_opt == CURLOPT_NETRC_FILE || auth_get_url_auth__1__7___curl_opt == CURLOPT_FTP_ACCOUNT || auth_get_url_auth__1__7___curl_opt == CURLOPT_COOKIELIST || auth_get_url_auth__1__7___curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || auth_get_url_auth__1__7___curl_opt == CURLOPT_CRLFILE || auth_get_url_auth__1__7___curl_opt == CURLOPT_ISSUERCERT || auth_get_url_auth__1__7___curl_opt == CURLOPT_USERNAME || auth_get_url_auth__1__7___curl_opt == CURLOPT_PASSWORD || auth_get_url_auth__1__7___curl_opt == CURLOPT_PROXYUSERNAME || auth_get_url_auth__1__7___curl_opt == CURLOPT_PROXYPASSWORD || auth_get_url_auth__1__7___curl_opt == CURLOPT_NOPROXY || auth_get_url_auth__1__7___curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || auth_get_url_auth__1__7___curl_opt == CURLOPT_SSH_KNOWNHOSTS || auth_get_url_auth__1__7___curl_opt == CURLOPT_MAIL_FROM || auth_get_url_auth__1__7___curl_opt == CURLOPT_RTSP_SESSION_ID || auth_get_url_auth__1__7___curl_opt == CURLOPT_RTSP_STREAM_URI || auth_get_url_auth__1__7___curl_opt == CURLOPT_RTSP_TRANSPORT || auth_get_url_auth__1__7___curl_opt == CURLOPT_TLSAUTH_USERNAME || auth_get_url_auth__1__7___curl_opt == CURLOPT_TLSAUTH_PASSWORD || auth_get_url_auth__1__7___curl_opt == CURLOPT_TLSAUTH_TYPE || auth_get_url_auth__1__7___curl_opt == CURLOPT_DNS_SERVERS || auth_get_url_auth__1__7___curl_opt == CURLOPT_MAIL_AUTH || auth_get_url_auth__1__7___curl_opt == CURLOPT_XOAUTH2_BEARER || auth_get_url_auth__1__7___curl_opt == CURLOPT_DNS_INTERFACE || auth_get_url_auth__1__7___curl_opt == CURLOPT_DNS_LOCAL_IP4 || auth_get_url_auth__1__7___curl_opt == CURLOPT_DNS_LOCAL_IP6 || auth_get_url_auth__1__7___curl_opt == CURLOPT_LOGIN_OPTIONS || auth_get_url_auth__1__7___curl_opt == CURLOPT_PINNEDPUBLICKEY || auth_get_url_auth__1__7___curl_opt == CURLOPT_UNIX_SOCKET_PATH || auth_get_url_auth__1__7___curl_opt == CURLOPT_PROXY_SERVICE_NAME || auth_get_url_auth__1__7___curl_opt == CURLOPT_SERVICE_NAME || auth_get_url_auth__1__7___curl_opt == CURLOPT_DEFAULT_PROTOCOL)
        _curl_easy_setopt_err_string();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_WRITEFUNCTION || auth_get_url_auth__1__7___curl_opt == CURLOPT_HEADERFUNCTION)
        _curl_easy_setopt_err_write_callback();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_READFUNCTION)
        _curl_easy_setopt_err_read_cb();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_IOCTLFUNCTION)
        _curl_easy_setopt_err_ioctl_cb();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_SOCKOPTFUNCTION)
        _curl_easy_setopt_err_sockopt_cb();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_OPENSOCKETFUNCTION)
        _curl_easy_setopt_err_opensocket_cb();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_PROGRESSFUNCTION)
        _curl_easy_setopt_err_progress_cb();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_DEBUGFUNCTION)
        _curl_easy_setopt_err_debug_cb();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_SSL_CTX_FUNCTION)
        _curl_easy_setopt_err_ssl_ctx_cb();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || auth_get_url_auth__1__7___curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || auth_get_url_auth__1__7___curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
        _curl_easy_setopt_err_conv_cb();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_SEEKFUNCTION)
        _curl_easy_setopt_err_seek_cb();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_ERRORBUFFER)
        _curl_easy_setopt_err_error_buffer();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_STDERR)
        _curl_easy_setopt_err_FILE();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_POSTFIELDS || auth_get_url_auth__1__7___curl_opt == CURLOPT_COPYPOSTFIELDS)
        _curl_easy_setopt_err_postfields();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_HTTPPOST)
        _curl_easy_setopt_err_curl_httpost();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_HTTPHEADER || auth_get_url_auth__1__7___curl_opt == CURLOPT_QUOTE || auth_get_url_auth__1__7___curl_opt == CURLOPT_POSTQUOTE || auth_get_url_auth__1__7___curl_opt == CURLOPT_TELNETOPTIONS || auth_get_url_auth__1__7___curl_opt == CURLOPT_PREQUOTE || auth_get_url_auth__1__7___curl_opt == CURLOPT_HTTP200ALIASES || auth_get_url_auth__1__7___curl_opt == CURLOPT_MAIL_RCPT || auth_get_url_auth__1__7___curl_opt == CURLOPT_RESOLVE || auth_get_url_auth__1__7___curl_opt == CURLOPT_PROXYHEADER)
        _curl_easy_setopt_err_curl_slist();

      if(auth_get_url_auth__1__7___curl_opt == CURLOPT_SHARE)
        _curl_easy_setopt_err_CURLSH();

    }

    curl_easy_setopt(url_info->handle, (enum anonymous_32)auth_get_url_auth__1__7___curl_opt, 1L);
    signed int auth_get_url_auth__1__8___curl_opt = CURLOPT_TIMEOUT;
    if((_Bool)0)
    {
      if(auth_get_url_auth__1__8___curl_opt >= 30001)
      {
        goto __CPROVER_DUMP_L118;
        _curl_easy_setopt_err_curl_off_t();
      }


    __CPROVER_DUMP_L118:
      ;
      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_URL || auth_get_url_auth__1__8___curl_opt == CURLOPT_PROXY || auth_get_url_auth__1__8___curl_opt == CURLOPT_USERPWD || auth_get_url_auth__1__8___curl_opt == CURLOPT_PROXYUSERPWD || auth_get_url_auth__1__8___curl_opt == CURLOPT_RANGE || auth_get_url_auth__1__8___curl_opt == CURLOPT_REFERER || auth_get_url_auth__1__8___curl_opt == CURLOPT_FTPPORT || auth_get_url_auth__1__8___curl_opt == CURLOPT_USERAGENT || auth_get_url_auth__1__8___curl_opt == CURLOPT_COOKIE || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSLCERT || auth_get_url_auth__1__8___curl_opt == CURLOPT_KEYPASSWD || auth_get_url_auth__1__8___curl_opt == CURLOPT_COOKIEFILE || auth_get_url_auth__1__8___curl_opt == CURLOPT_CUSTOMREQUEST || auth_get_url_auth__1__8___curl_opt == CURLOPT_INTERFACE || auth_get_url_auth__1__8___curl_opt == CURLOPT_KRBLEVEL || auth_get_url_auth__1__8___curl_opt == CURLOPT_CAINFO || auth_get_url_auth__1__8___curl_opt == CURLOPT_RANDOM_FILE || auth_get_url_auth__1__8___curl_opt == CURLOPT_EGDSOCKET || auth_get_url_auth__1__8___curl_opt == CURLOPT_COOKIEJAR || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSL_CIPHER_LIST || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSLCERTTYPE || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSLKEY || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSLKEYTYPE || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSLENGINE || auth_get_url_auth__1__8___curl_opt == CURLOPT_CAPATH || auth_get_url_auth__1__8___curl_opt == CURLOPT_ACCEPT_ENCODING || auth_get_url_auth__1__8___curl_opt == CURLOPT_NETRC_FILE || auth_get_url_auth__1__8___curl_opt == CURLOPT_FTP_ACCOUNT || auth_get_url_auth__1__8___curl_opt == CURLOPT_COOKIELIST || auth_get_url_auth__1__8___curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || auth_get_url_auth__1__8___curl_opt == CURLOPT_CRLFILE || auth_get_url_auth__1__8___curl_opt == CURLOPT_ISSUERCERT || auth_get_url_auth__1__8___curl_opt == CURLOPT_USERNAME || auth_get_url_auth__1__8___curl_opt == CURLOPT_PASSWORD || auth_get_url_auth__1__8___curl_opt == CURLOPT_PROXYUSERNAME || auth_get_url_auth__1__8___curl_opt == CURLOPT_PROXYPASSWORD || auth_get_url_auth__1__8___curl_opt == CURLOPT_NOPROXY || auth_get_url_auth__1__8___curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || auth_get_url_auth__1__8___curl_opt == CURLOPT_SSH_KNOWNHOSTS || auth_get_url_auth__1__8___curl_opt == CURLOPT_MAIL_FROM || auth_get_url_auth__1__8___curl_opt == CURLOPT_RTSP_SESSION_ID || auth_get_url_auth__1__8___curl_opt == CURLOPT_RTSP_STREAM_URI || auth_get_url_auth__1__8___curl_opt == CURLOPT_RTSP_TRANSPORT || auth_get_url_auth__1__8___curl_opt == CURLOPT_TLSAUTH_USERNAME || auth_get_url_auth__1__8___curl_opt == CURLOPT_TLSAUTH_PASSWORD || auth_get_url_auth__1__8___curl_opt == CURLOPT_TLSAUTH_TYPE || auth_get_url_auth__1__8___curl_opt == CURLOPT_DNS_SERVERS || auth_get_url_auth__1__8___curl_opt == CURLOPT_MAIL_AUTH || auth_get_url_auth__1__8___curl_opt == CURLOPT_XOAUTH2_BEARER || auth_get_url_auth__1__8___curl_opt == CURLOPT_DNS_INTERFACE || auth_get_url_auth__1__8___curl_opt == CURLOPT_DNS_LOCAL_IP4 || auth_get_url_auth__1__8___curl_opt == CURLOPT_DNS_LOCAL_IP6 || auth_get_url_auth__1__8___curl_opt == CURLOPT_LOGIN_OPTIONS || auth_get_url_auth__1__8___curl_opt == CURLOPT_PINNEDPUBLICKEY || auth_get_url_auth__1__8___curl_opt == CURLOPT_UNIX_SOCKET_PATH || auth_get_url_auth__1__8___curl_opt == CURLOPT_PROXY_SERVICE_NAME || auth_get_url_auth__1__8___curl_opt == CURLOPT_SERVICE_NAME || auth_get_url_auth__1__8___curl_opt == CURLOPT_DEFAULT_PROTOCOL)
        _curl_easy_setopt_err_string();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_WRITEFUNCTION || auth_get_url_auth__1__8___curl_opt == CURLOPT_HEADERFUNCTION)
        _curl_easy_setopt_err_write_callback();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_READFUNCTION)
        _curl_easy_setopt_err_read_cb();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_IOCTLFUNCTION)
        _curl_easy_setopt_err_ioctl_cb();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_SOCKOPTFUNCTION)
        _curl_easy_setopt_err_sockopt_cb();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_OPENSOCKETFUNCTION)
        _curl_easy_setopt_err_opensocket_cb();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_PROGRESSFUNCTION)
        _curl_easy_setopt_err_progress_cb();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_DEBUGFUNCTION)
        _curl_easy_setopt_err_debug_cb();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_SSL_CTX_FUNCTION)
        _curl_easy_setopt_err_ssl_ctx_cb();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || auth_get_url_auth__1__8___curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || auth_get_url_auth__1__8___curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
        _curl_easy_setopt_err_conv_cb();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_SEEKFUNCTION)
        _curl_easy_setopt_err_seek_cb();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_ERRORBUFFER)
        _curl_easy_setopt_err_error_buffer();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_STDERR)
        _curl_easy_setopt_err_FILE();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_POSTFIELDS || auth_get_url_auth__1__8___curl_opt == CURLOPT_COPYPOSTFIELDS)
        _curl_easy_setopt_err_postfields();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_HTTPPOST)
        _curl_easy_setopt_err_curl_httpost();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_HTTPHEADER || auth_get_url_auth__1__8___curl_opt == CURLOPT_QUOTE || auth_get_url_auth__1__8___curl_opt == CURLOPT_POSTQUOTE || auth_get_url_auth__1__8___curl_opt == CURLOPT_TELNETOPTIONS || auth_get_url_auth__1__8___curl_opt == CURLOPT_PREQUOTE || auth_get_url_auth__1__8___curl_opt == CURLOPT_HTTP200ALIASES || auth_get_url_auth__1__8___curl_opt == CURLOPT_MAIL_RCPT || auth_get_url_auth__1__8___curl_opt == CURLOPT_RESOLVE || auth_get_url_auth__1__8___curl_opt == CURLOPT_PROXYHEADER)
        _curl_easy_setopt_err_curl_slist();

      if(auth_get_url_auth__1__8___curl_opt == CURLOPT_SHARE)
        _curl_easy_setopt_err_CURLSH();

    }

    curl_easy_setopt(url_info->handle, (enum anonymous_32)auth_get_url_auth__1__8___curl_opt, 15L);
    signed int auth_get_url_auth__1__9___curl_opt = CURLOPT_ERRORBUFFER;
    curl_easy_setopt(url_info->handle, (enum anonymous_32)auth_get_url_auth__1__9___curl_opt, &url_info->errormsg[(signed long int)0]);
    if(!(url_info->username == ((char *)NULL)))
    {
      if(!(url_info->password == ((char *)NULL)))
      {
        signed int len;
        unsigned long int return_value_strlen_15;
        return_value_strlen_15=strlen(url_info->username);
        unsigned long int return_value_strlen_16;
        return_value_strlen_16=strlen(url_info->password);
        len = (signed int)(return_value_strlen_15 + return_value_strlen_16 + (unsigned long int)2);
        void *return_value_malloc_17;
        return_value_malloc_17=malloc((unsigned long int)len);
        url_info->userpwd = (char *)return_value_malloc_17;
        snprintf(url_info->userpwd, (unsigned long int)len, "%s:%s", url_info->username, url_info->password);
      }

    }

    log_write(errorlog, (unsigned int)3, "auth_url/", "auth_get_url_auth", "URL based authentication setup");
    return 0;
  }
}

// auth_initialise
// file auth.h line 92
void auth_initialise(void)
{
  ;
}

// auth_new_listener
// file auth.c line 194
static void auth_new_listener(struct auth_tag *auth, struct auth_client_tag *auth_user)
{
  struct _client_tag *client = auth_user->client;
  signed int return_value_is_listener_connected_1;
  return_value_is_listener_connected_1=is_listener_connected(client);
  if(return_value_is_listener_connected_1 == 0)
  {
    log_write(errorlog, (unsigned int)4, "auth/", "auth_new_listener", "listener is no longer connected");
    client->respcode = 400;
    auth_release(client->auth);
    client->auth = (struct auth_tag *)(void *)0;
  }

  else
  {
    if(!(auth->authenticate == ((enum anonymous_19 (*)(struct auth_client_tag *))NULL)))
    {
      enum anonymous_19 return_value;
      return_value=auth->authenticate(auth_user);
      if(!((signed int)return_value == AUTH_OK))
      {
        auth_release(client->auth);
        client->auth = (struct auth_tag *)(void *)0;
      }

    }

    signed int return_value_auth_postprocess_listener_2;
    return_value_auth_postprocess_listener_2=auth_postprocess_listener(auth_user);
    if(!(return_value_auth_postprocess_listener_2 >= 0))
    {
      auth_release(client->auth);
      client->auth = (struct auth_tag *)(void *)0;
      log_write(errorlog, (unsigned int)3, "auth/", "auth_new_listener", "client %lu failed", client->con->id);
    }

  }
}

// auth_postprocess_listener
// file auth.c line 483
signed int auth_postprocess_listener(struct auth_client_tag *auth_user)
{
  signed int ret;
  struct _client_tag *client = auth_user->client;
  struct ice_config_tag *config;
  config=config_get_config();
  struct _mount_proxy *mountinfo;
  mountinfo=config_find_mount(config, auth_user->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
  ret=add_authenticated_listener(auth_user->mount, mountinfo, client);
  config_release_config();
  if(!(ret >= 0))
    client_send_401(auth_user->client);

  auth_user->client = (struct _client_tag *)(void *)0;
  return ret;
}

// auth_postprocess_source
// file auth.c line 505
static void auth_postprocess_source(struct auth_client_tag *auth_user)
{
  struct _client_tag *client = auth_user->client;
  const char *mount = auth_user->mount;
  const char *req;
  req=httpp_getvar(client->parser, "__uri");
  auth_user->client = (struct _client_tag *)(void *)0;
  client->authenticated = 1;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(req, "/admin.cgi");
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_2;
  if(return_value_strcmp_1 == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strncmp_2=strncmp("/admin/metadata", req, (unsigned long int)15);
    tmp_if_expr_3 = return_value_strncmp_2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    log_write(errorlog, (unsigned int)4, "auth/", "auth_postprocess_source", "metadata request (%s, %s)", req, mount);
    admin_handle_request(client, "/admin/metadata");
  }

  else
  {
    log_write(errorlog, (unsigned int)4, "auth/", "auth_postprocess_source", "on mountpoint %s", mount);
    source_startup(client, mount, 0);
  }
}

// auth_release
// file auth.h line 96
void auth_release(struct auth_tag *authenticator)
{
  if(!(authenticator == ((struct auth_tag *)NULL)))
  {
    thread_mutex_lock_c(&authenticator->lock, 135, "auth.c");
    authenticator->refcount = authenticator->refcount - 1;
    log_write(errorlog, (unsigned int)4, "auth/", "auth_release", "...refcount on auth_t %s is now %d", authenticator->mount, authenticator->refcount);
    if(!(authenticator->refcount == 0))
      thread_mutex_unlock_c(&authenticator->lock, 140, "auth.c");

    else
    {
      authenticator->running = 0;
      thread_join(authenticator->thread);
      if(!(authenticator->free == ((void (*)(struct auth_tag *))NULL)))
        authenticator->free(authenticator);

      xmlFree((void *)authenticator->type);
      thread_mutex_unlock_c(&authenticator->lock, 151, "auth.c");
      thread_mutex_destroy(&authenticator->lock);
      if(!(authenticator->mount == ((char *)NULL)))
        free((void *)authenticator->mount);

      free((void *)authenticator);
    }
  }

}

// auth_release_listener
// file auth.h line 90
signed int auth_release_listener(struct _client_tag *client)
{
  if(!(client->authenticated == 0))
  {
    const char *mount;
    mount=httpp_getvar(client->parser, "__uri");
    client_set_queue(client, (struct _refbuf_tag *)(void *)0);
    if(!(mount == ((const char *)NULL)))
    {
      if(!(client->auth == ((struct auth_tag *)NULL)))
      {
        if(!(client->auth->release_listener == ((enum anonymous_19 (*)(struct auth_client_tag *))NULL)))
        {
          struct auth_client_tag *auth_user;
          auth_user=auth_client_setup(mount, client);
          auth_user->process = auth_remove_listener;
          queue_auth_client(auth_user, (struct _mount_proxy *)(void *)0);
          return 1;
        }

      }

    }

    client->authenticated = 0;
  }

  return 0;
}

// auth_remove_listener
// file auth.c line 228
static void auth_remove_listener(struct auth_tag *auth, struct auth_client_tag *auth_user)
{
  struct _client_tag *client = auth_user->client;
  if(!(client->auth->release_listener == ((enum anonymous_19 (*)(struct auth_client_tag *))NULL)))
    client->auth->release_listener(auth_user);

  auth_release(client->auth);
  client->auth = (struct auth_tag *)(void *)0;
  client->authenticated = 0;
}

// auth_run_thread
// file auth.c line 283
static void * auth_run_thread(void *arg)
{
  struct auth_tag *auth = (struct auth_tag *)arg;
  log_write(errorlog, (unsigned int)3, "auth/", "auth_run_thread", "Authentication thread started");
  while(!(auth->running == 0))
  {
    if(!(auth->head == ((struct auth_client_tag *)NULL)))
    {
      struct auth_client_tag *auth_user;
      thread_mutex_lock_c(&auth->lock, 296, "auth.c");
      auth_user = (struct auth_client_tag *)auth->head;
      if(auth_user == ((struct auth_client_tag *)NULL))
      {
        thread_mutex_unlock_c(&auth->lock, 300, "auth.c");
        continue;
      }

      log_write(errorlog, (unsigned int)4, "auth/", "auth_run_thread", "%d client(s) pending on %s", auth->pending_count, auth->mount);
      auth->head = auth_user->next;
      if(auth->head == ((struct auth_client_tag *)NULL))
        auth->tailp = &auth->head;

      auth->pending_count = auth->pending_count - 1;
      thread_mutex_unlock_c(&auth->lock, 308, "auth.c");
      auth_user->next = (struct auth_client_tag *)(void *)0;
      if(!(auth_user->process == ((void (*)(struct auth_tag *, struct auth_client_tag *))NULL)))
        auth_user->process(auth, auth_user);

      else
        log_write(errorlog, (unsigned int)1, "auth/", "auth_run_thread", "client auth process not set");
      auth_client_free(auth_user);
      continue;
    }

    thread_sleep((unsigned long int)150000);
  }
  log_write(errorlog, (unsigned int)3, "auth/", "auth_run_thread", "Authenication thread shutting down");
  return (void *)0;
}

// auth_shutdown
// file auth.h line 93
void auth_shutdown(void)
{
  log_write(errorlog, (unsigned int)3, "auth/", "auth_shutdown", "Auth shutdown");
}

// auth_stream_authenticate
// file auth.h line 105
signed int auth_stream_authenticate(struct _client_tag *client, const char *mount, struct _mount_proxy *mountinfo)
{
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->auth == ((struct auth_tag *)NULL)))
    {
      if(!(mountinfo->auth->stream_auth == ((void (*)(struct auth_client_tag *))NULL)))
      {
        struct auth_client_tag *auth_user;
        auth_user=auth_client_setup(mount, client);
        auth_user->process = stream_auth_callback;
        log_write(errorlog, (unsigned int)3, "auth/", "auth_stream_authenticate", "request source auth for \"%s\"", mount);
        queue_auth_client(auth_user, mountinfo);
        return 1;
      }

    }

  }

  return 0;
}

// auth_stream_end
// file auth.h line 102
void auth_stream_end(struct _mount_proxy *mountinfo, const char *mount)
{
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->auth == ((struct auth_tag *)NULL)))
    {
      if(!(mountinfo->auth->stream_end == ((void (*)(struct auth_client_tag *))NULL)))
      {
        struct auth_client_tag *auth_user;
        void *return_value_calloc_1;
        return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct auth_client_tag) /*32ul*/ );
        auth_user = (struct auth_client_tag *)return_value_calloc_1;
        if(!(auth_user == ((struct auth_client_tag *)NULL)))
        {
          auth_user->mount=strdup(mount);
          auth_user->process = stream_end_callback;
          queue_auth_client(auth_user, mountinfo);
        }

      }

    }

  }

}

// auth_stream_start
// file auth.h line 99
void auth_stream_start(struct _mount_proxy *mountinfo, const char *mount)
{
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->auth == ((struct auth_tag *)NULL)))
    {
      if(!(mountinfo->auth->stream_start == ((void (*)(struct auth_client_tag *))NULL)))
      {
        struct auth_client_tag *auth_user;
        void *return_value_calloc_1;
        return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct auth_client_tag) /*32ul*/ );
        auth_user = (struct auth_client_tag *)return_value_calloc_1;
        if(!(auth_user == ((struct auth_client_tag *)NULL)))
        {
          auth_user->mount=strdup(mount);
          auth_user->process = stream_start_callback;
          queue_auth_client(auth_user, mountinfo);
        }

      }

    }

  }

}

// auth_url_adduser
// file auth_url.c line 571
static enum anonymous_19 auth_url_adduser(struct auth_tag *auth, const char *username, const char *password)
{
  return (enum anonymous_19)AUTH_FAILED;
}

// auth_url_clear
// file auth_url.c line 108
static void auth_url_clear(struct auth_tag *self)
{
  struct anonymous_33 *url;
  log_write(errorlog, (unsigned int)3, "auth_url/", "auth_url_clear", "Doing auth URL cleanup");
  url = (struct anonymous_33 *)self->state;
  self->state = (void *)0;
  curl_easy_cleanup(url->handle);
  free((void *)url->username);
  free((void *)url->password);
  free((void *)url->pass_headers);
  free((void *)url->prefix_headers);
  free((void *)url->removeurl);
  free((void *)url->addurl);
  free((void *)url->stream_start);
  free((void *)url->stream_end);
  free((void *)url->auth_header);
  free((void *)url->timelimit_header);
  free((void *)url->userpwd);
  free((void *)url);
}

// auth_url_deleteuser
// file auth_url.c line 576
static enum anonymous_19 auth_url_deleteuser(struct auth_tag *auth, const char *username)
{
  return (enum anonymous_19)AUTH_FAILED;
}

// auth_url_listuser
// file auth_url.c line 581
static enum anonymous_19 auth_url_listuser(struct auth_tag *auth, struct _xmlNode *srcnode)
{
  return (enum anonymous_19)AUTH_FAILED;
}

// avl_delete
// file avl/avl.h line 119
signed int avl_delete(struct _avl_tree *tree, void *key, signed int (*free_key_fun)(void *))
{
  struct avl_node_tag *x;
  struct avl_node_tag *y;
  struct avl_node_tag *p;
  struct avl_node_tag *q;
  struct avl_node_tag *r;
  struct avl_node_tag *top;
  struct avl_node_tag *x_child;
  signed int shortened_side;
  signed int shorter;
  x = tree->root->right;
  if(x == ((struct avl_node_tag *)NULL))
    return -1;

  else
  {
    {
      signed int compare_result;
      compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
      if(!(compare_result >= 0))
      {
        x->rank_and_balance = x->rank_and_balance & (unsigned int)3 | (x->rank_and_balance >> 2) - (unsigned int)1 << 2;
        if(!(x->left == ((struct avl_node_tag *)NULL)))
          x = x->left;

        else
        {
          x->rank_and_balance = x->rank_and_balance & (unsigned int)3 | (x->rank_and_balance >> 2) + (unsigned int)1 << 2;
          if(!(x == tree->root->right))
          {
            if(x->parent->left == x)
              x->parent->rank_and_balance = x->parent->rank_and_balance & (unsigned int)3 | (x->parent->rank_and_balance >> 2) + (unsigned int)1 << 2;

            x = x->parent;
          }

          return -1;
        }
      }

      else
        if(compare_result >= 1)
        {
          if(!(x->right == ((struct avl_node_tag *)NULL)))
            x = x->right;

          else
          {
            x->rank_and_balance = x->rank_and_balance & (unsigned int)3 | (x->rank_and_balance >> 2) + (unsigned int)1 << 2;
            if(!(x == tree->root->right))
            {
              if(x->parent->left == x)
                x->parent->rank_and_balance = x->parent->rank_and_balance & (unsigned int)3 | (x->parent->rank_and_balance >> 2) + (unsigned int)1 << 2;

              x = x->parent;
            }

            return -1;
          }
        }

    }
    if(!(x->left == ((struct avl_node_tag *)NULL)))
    {
      if(!(x->right == ((struct avl_node_tag *)NULL)))
      {
        void *temp_key;
        y = x->left;
        for( ; !(y->right == ((struct avl_node_tag *)NULL)); y = y->right)
          ;
        temp_key = x->key;
        x->key = y->key;
        y->key = temp_key;
        x->rank_and_balance = x->rank_and_balance & (unsigned int)3 | (x->rank_and_balance >> 2) - (unsigned int)1 << 2;
        x = y;
      }

    }

    if(!(x->left == ((struct avl_node_tag *)NULL)))
    {
      x_child = x->left;
      x_child->parent = x->parent;
    }

    else
      if(!(x->right == ((struct avl_node_tag *)NULL)))
      {
        x_child = x->right;
        x_child->parent = x->parent;
      }

      else
        x_child = (struct avl_node_tag *)(void *)0;
    if(x == x->parent->left)
    {
      x->parent->left = x_child;
      shortened_side = -1;
    }

    else
    {
      x->parent->right = x_child;
      shortened_side = +1;
    }
    shorter = 1;
    p = x->parent;
    if(!(free_key_fun == ((signed int (*)(void *))NULL)))
      free_key_fun(x->key);

    free((void *)x);
    while(!(shorter == 0))
    {
      if(p->parent == ((struct avl_node_tag *)NULL))
        break;

      if((3 & (signed int)p->rank_and_balance) == 1)
      {
        if(shortened_side == -1)
          p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(+1 + 1);

        else
          p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-1 + 1);
        shorter = 0;
      }

      else
        if((3 & (signed int)p->rank_and_balance) + -1 == shortened_side)
          p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);

        else
        {
          top = p->parent;
          if(shortened_side == 1)
            q = p->left;

          else
            q = p->right;
          if((3 & (signed int)q->rank_and_balance) == 1)
          {
            if(shortened_side == -1)
            {
              q->parent = p->parent;
              p->right = q->left;
              if(!(q->left == ((struct avl_node_tag *)NULL)))
                q->left->parent = p;

              q->left = p;
              p->parent = q;
              q->rank_and_balance = q->rank_and_balance & (unsigned int)3 | (q->rank_and_balance >> 2) + (p->rank_and_balance >> 2) << 2;
            }

            else
            {
              q->parent = p->parent;
              p->left = q->right;
              if(!(q->right == ((struct avl_node_tag *)NULL)))
                q->right->parent = p;

              q->right = p;
              p->parent = q;
              p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) - (q->rank_and_balance >> 2) << 2;
            }
            shorter = 0;
            q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(shortened_side + 1);
            p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-shortened_side + 1);
          }

          else
            if((3 & (signed int)q->rank_and_balance) == (3 & (signed int)p->rank_and_balance))
            {
              if(shortened_side == -1)
              {
                q->parent = p->parent;
                p->right = q->left;
                if(!(q->left == ((struct avl_node_tag *)NULL)))
                  q->left->parent = p;

                q->left = p;
                p->parent = q;
                q->rank_and_balance = q->rank_and_balance & (unsigned int)3 | (q->rank_and_balance >> 2) + (p->rank_and_balance >> 2) << 2;
              }

              else
              {
                q->parent = p->parent;
                p->left = q->right;
                if(!(q->right == ((struct avl_node_tag *)NULL)))
                  q->right->parent = p;

                q->right = p;
                p->parent = q;
                p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) - (q->rank_and_balance >> 2) << 2;
              }
              shorter = 1;
              q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
              p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
            }

            else
            {
              if(shortened_side == 1)
              {
                r = q->right;
                r->parent = p->parent;
                q->right = r->left;
                if(!(r->left == ((struct avl_node_tag *)NULL)))
                  r->left->parent = q;

                r->left = q;
                q->parent = r;
                p->left = r->right;
                if(!(r->right == ((struct avl_node_tag *)NULL)))
                  r->right->parent = p;

                r->right = p;
                p->parent = r;
                r->rank_and_balance = r->rank_and_balance & (unsigned int)3 | (r->rank_and_balance >> 2) + (q->rank_and_balance >> 2) << 2;
                p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) - (r->rank_and_balance >> 2) << 2;
              }

              else
              {
                r = q->left;
                r->parent = p->parent;
                q->left = r->right;
                if(!(r->right == ((struct avl_node_tag *)NULL)))
                  r->right->parent = q;

                r->right = q;
                q->parent = r;
                p->right = r->left;
                if(!(r->left == ((struct avl_node_tag *)NULL)))
                  r->left->parent = p;

                r->left = p;
                p->parent = r;
                q->rank_and_balance = q->rank_and_balance & (unsigned int)3 | (q->rank_and_balance >> 2) - (r->rank_and_balance >> 2) << 2;
                r->rank_and_balance = r->rank_and_balance & (unsigned int)3 | (r->rank_and_balance >> 2) + (p->rank_and_balance >> 2) << 2;
              }
              if((3 & (signed int)r->rank_and_balance) + -1 == shortened_side)
              {
                q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-shortened_side + 1);
                p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
              }

              else
                if((3 & (signed int)r->rank_and_balance) + -1 == -shortened_side)
                {
                  q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                  p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(shortened_side + 1);
                }

                else
                {
                  q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                  p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                }
              r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
              q = r;
            }
          if(top->left == p)
            top->left = q;

          else
            top->right = q;
          p = q;
        }
      x = p;
      p = x->parent;
      if(x == p->left)
        shortened_side = -1;

      else
        shortened_side = +1;
    }
    tree->length = tree->length - (unsigned int)1;
    return 0;
  }
}

// avl_get_by_index
// file avl.c line 299
signed int avl_get_by_index(struct _avl_tree *tree, unsigned long int index, void **value_address)
{
  struct avl_node_tag *p = tree->root->right;
  unsigned long int m = index + (unsigned long int)1;
  while((_Bool)1)
  {
    if(p == ((struct avl_node_tag *)NULL))
      return -1;

    if(!(m >= (unsigned long int)(p->rank_and_balance >> 2)))
      p = p->left;

    else
      if(!((unsigned long int)(p->rank_and_balance >> 2) >= m))
      {
        m = m - (unsigned long int)(p->rank_and_balance >> 2);
        p = p->right;
      }

      else
      {
        *value_address = p->key;
        return 0;
      }
  }
}

// avl_get_by_key
// file avl/avl.h line 131
signed int avl_get_by_key(struct _avl_tree *tree, void *key, void **value_address)
{
  struct avl_node_tag *x = tree->root->right;
  if(x == ((struct avl_node_tag *)NULL))
    return -1;

  else
  {
    signed int compare_result;
    compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
    if(!(compare_result >= 0))
    {
      if(!(x->left == ((struct avl_node_tag *)NULL)))
        x = x->left;

      else
        return -1;
    }

    else
      if(compare_result >= 1)
      {
        if(!(x->right == ((struct avl_node_tag *)NULL)))
          x = x->right;

        else
          return -1;
      }

      else
      {
        *value_address = x->key;
        return 0;
      }
  }
}

// avl_get_first
// file avl/avl.h line 173
struct avl_node_tag * avl_get_first(struct _avl_tree *tree)
{
  struct avl_node_tag *node = tree->root->right;
  _Bool tmp_if_expr_1;
  if(node == ((struct avl_node_tag *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = node->key == (void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (struct avl_node_tag *)(void *)0;

  else
  {
    for( ; !(node->left == ((struct avl_node_tag *)NULL)); node = node->left)
      ;
    return node;
  }
}

// avl_get_index_by_key
// file avl.c line 772
static struct avl_node_tag * avl_get_index_by_key(struct _avl_tree *tree, void *key, unsigned long int *index)
{
  struct avl_node_tag *x = tree->root->right;
  unsigned long int m;
  if(x == ((struct avl_node_tag *)NULL))
    return (struct avl_node_tag *)(void *)0;

  else
  {
    m = (unsigned long int)(x->rank_and_balance >> 2);
    {
      signed int compare_result;
      compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
      if(!(compare_result >= 0))
      {
        if(!(x->left == ((struct avl_node_tag *)NULL)))
        {
          m = m - (unsigned long int)(x->rank_and_balance >> 2);
          x = x->left;
          m = m + (unsigned long int)(x->rank_and_balance >> 2);
        }

        else
        {
          *index = m - (unsigned long int)2;
          return (struct avl_node_tag *)(void *)0;
        }
      }

      else
        if(compare_result >= 1)
        {
          if(!(x->right == ((struct avl_node_tag *)NULL)))
          {
            x = x->right;
            m = m + (unsigned long int)(x->rank_and_balance >> 2);
          }

          else
          {
            *index = m - (unsigned long int)1;
            return (struct avl_node_tag *)(void *)0;
          }
        }

        else
        {
          *index = m - (unsigned long int)1;
          return x;
        }
    }
  }
}

// avl_get_item_by_key_least
// file avl.c line 951
signed int avl_get_item_by_key_least(struct _avl_tree *tree, void *key, void **value_address)
{
  struct avl_node_tag *x = tree->root->right;
  *value_address = (void *)0;
  if(x == ((struct avl_node_tag *)NULL))
    return -1;

  else
  {
    signed int compare_result;
    compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
    if(compare_result == 0)
    {
      *value_address = x->key;
      return 0;
    }

    else
      if(!(compare_result >= 0))
      {
        *value_address = x->key;
        if(!(x->left == ((struct avl_node_tag *)NULL)))
          x = x->left;

        else
          if(!(*value_address == NULL))
            return 0;

          else
            return -1;
      }

      else
        if(!(x->right == ((struct avl_node_tag *)NULL)))
          x = x->right;

        else
          if(!(*value_address == NULL))
            return 0;

          else
            return -1;
  }
}

// avl_get_item_by_key_most
// file avl.c line 907
signed int avl_get_item_by_key_most(struct _avl_tree *tree, void *key, void **value_address)
{
  struct avl_node_tag *x = tree->root->right;
  *value_address = (void *)0;
  if(x == ((struct avl_node_tag *)NULL))
    return -1;

  else
  {
    signed int compare_result;
    compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
    if(compare_result == 0)
    {
      *value_address = x->key;
      return 0;
    }

    else
      if(!(compare_result >= 0))
      {
        if(!(x->left == ((struct avl_node_tag *)NULL)))
          x = x->left;

        else
          if(!(*value_address == NULL))
            return 0;

          else
            return -1;
      }

      else
      {
        *value_address = x->key;
        if(!(x->right == ((struct avl_node_tag *)NULL)))
          x = x->right;

        else
          if(!(*value_address == NULL))
            return 0;

          else
            return -1;
      }
  }
}

// avl_get_next
// file avl/avl.h line 177
struct avl_node_tag * avl_get_next(struct avl_node_tag *node)
{
  if(!(node->right == ((struct avl_node_tag *)NULL)))
  {
    node = node->right;
    for( ; !(node->left == ((struct avl_node_tag *)NULL)); node = node->left)
      ;
    return node;
  }

  else
  {
    struct avl_node_tag *child = node;
    for( ; !(node->parent == ((struct avl_node_tag *)NULL)); child = node)
    {
      if(node->parent->key == NULL)
        break;

      node = node->parent;
      if(child == node->left)
        return node;

    }
    return (struct avl_node_tag *)(void *)0;
  }
}

// avl_get_prev
// file avl.c line 679
struct avl_node_tag * avl_get_prev(struct avl_node_tag *node)
{
  if(!(node->left == ((struct avl_node_tag *)NULL)))
  {
    node = node->left;
    for( ; !(node->right == ((struct avl_node_tag *)NULL)); node = node->right)
      ;
    return node;
  }

  else
  {
    struct avl_node_tag *child = node;
    for( ; !(node->parent == ((struct avl_node_tag *)NULL)); child = node)
    {
      if(node->parent->key == NULL)
        break;

      node = node->parent;
      if(child == node->right)
        return node;

    }
    return (struct avl_node_tag *)(void *)0;
  }
}

// avl_get_span_by_key
// file avl.c line 813
signed int avl_get_span_by_key(struct _avl_tree *tree, void *key, unsigned long int *low, unsigned long int *high)
{
  unsigned long int m;
  unsigned long int i;
  unsigned long int j;
  struct avl_node_tag *node;
  node=avl_get_index_by_key(tree, key, &m);
  signed int return_value;
  signed int return_value_1;
  if(!(node == ((struct avl_node_tag *)NULL)))
  {
    struct avl_node_tag *left;
    struct avl_node_tag *right;
    left=avl_get_prev(node);
    i = m;
    if(!(left == ((struct avl_node_tag *)NULL)))
    {
      if(i >= 1ul)
      {
        return_value=tree->compare_fun(tree->compare_arg, key, left->key);
        if(return_value == 0)
        {
          left=avl_get_prev(left);
          i = i - (unsigned long int)1;
        }

      }

    }

    right=avl_get_next(node);
    j = m;
    if(!(right == ((struct avl_node_tag *)NULL)))
    {
      if((unsigned long int)tree->length >= j)
      {
        return_value_1=tree->compare_fun(tree->compare_arg, key, right->key);
        if(return_value_1 == 0)
        {
          right=avl_get_next(right);
          j = j + (unsigned long int)1;
        }

      }

    }

    *low = i;
    *high = j + (unsigned long int)1;
    return 0;
  }

  else
  {
    *high = m;
    *low = *high;
  }
  return 0;
}

// avl_get_span_by_two_keys
// file avl.c line 856
signed int avl_get_span_by_two_keys(struct _avl_tree *tree, void *low_key, void *high_key, unsigned long int *low, unsigned long int *high)
{
  unsigned long int i;
  unsigned long int j;
  struct avl_node_tag *low_node;
  struct avl_node_tag *high_node;
  signed int order;
  order=tree->compare_fun(tree->compare_arg, low_key, high_key);
  if(order >= 1)
  {
    void *temp = low_key;
    low_key = high_key;
    high_key = temp;
  }

  low_node=avl_get_index_by_key(tree, low_key, &i);
  high_node=avl_get_index_by_key(tree, high_key, &j);
  signed int return_value;
  if(!(low_node == ((struct avl_node_tag *)NULL)))
  {
    struct avl_node_tag *left;
    left=avl_get_prev(low_node);
    if(!(left == ((struct avl_node_tag *)NULL)))
    {
      if(i >= 1ul)
      {
        return_value=tree->compare_fun(tree->compare_arg, low_key, left->key);
        if(return_value == 0)
        {
          left=avl_get_prev(left);
          i = i - (unsigned long int)1;
        }

      }

    }

  }

  else
    i = i + (unsigned long int)1;
  signed int return_value_1;
  if(!(high_node == ((struct avl_node_tag *)NULL)))
  {
    struct avl_node_tag *right;
    right=avl_get_next(high_node);
    if(!(right == ((struct avl_node_tag *)NULL)))
    {
      if((unsigned long int)tree->length >= j)
      {
        return_value_1=tree->compare_fun(tree->compare_arg, high_key, right->key);
        if(return_value_1 == 0)
        {
          right=avl_get_next(right);
          j = j + (unsigned long int)1;
        }

      }

    }

  }

  else
    j = j + (unsigned long int)1;
  *low = i;
  *high = j;
  return 0;
}

// avl_insert
// file avl/avl.h line 114
signed int avl_insert(struct _avl_tree *ob, void *key)
{
  if(ob->root->right == ((struct avl_node_tag *)NULL))
  {
    struct avl_node_tag *node;
    node=avl_node_new(key, ob->root);
    if(node == ((struct avl_node_tag *)NULL))
      return -1;

    else
    {
      ob->root->right = node;
      ob->length = ob->length + (unsigned int)1;
      return 0;
    }
  }

  else
  {
    struct avl_node_tag *t;
    struct avl_node_tag *p;
    struct avl_node_tag *s;
    struct avl_node_tag *q;
    struct avl_node_tag *r;
    signed int a;
    t = ob->root;
    p = t->right;
    s = p;
    {
      signed int return_value;
      return_value=ob->compare_fun(ob->compare_arg, key, p->key);
      if(!(return_value >= 1))
      {
        p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) + (unsigned int)1 << 2;
        q = p->left;
        if(q == ((struct avl_node_tag *)NULL))
        {
          struct avl_node_tag *q_node;
          q_node=avl_node_new(key, p);
          if(q_node == ((struct avl_node_tag *)NULL))
            return -1;

          else
          {
            q = q_node;
            p->left = q;
          }
        }

        else
          if(!((3 & (signed int)q->rank_and_balance) == 1))
          {
            t = p;
            s = q;
          }

        p = q;
      }

      else
      {
        q = p->right;
        if(q == ((struct avl_node_tag *)NULL))
        {
          struct avl_node_tag *avl_insert__1__2__1__2__1__q_node;
          avl_insert__1__2__1__2__1__q_node=avl_node_new(key, p);
          if(avl_insert__1__2__1__2__1__q_node == ((struct avl_node_tag *)NULL))
            return -1;

          else
          {
            q = avl_insert__1__2__1__2__1__q_node;
            p->right = q;
          }
        }

        else
          if(!((3 & (signed int)q->rank_and_balance) == 1))
          {
            t = p;
            s = q;
          }

        p = q;
      }
    }
    ob->length = ob->length + (unsigned int)1;
    signed int return_value_1;
    return_value_1=ob->compare_fun(ob->compare_arg, key, s->key);
    if(!(return_value_1 >= 1))
    {
      p = s->left;
      r = p;
    }

    else
    {
      p = s->right;
      r = p;
    }
    if(!(p == q))
    {
      signed int return_value_2;
      return_value_2=ob->compare_fun(ob->compare_arg, key, p->key);
      if(!(return_value_2 >= 1))
      {
        p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-1 + 1);
        p = p->left;
      }

      else
      {
        p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(+1 + 1);
        p = p->right;
      }
    }

    signed int return_value_3;
    return_value_3=ob->compare_fun(ob->compare_arg, key, s->key);
    if(!(return_value_3 >= 1))
      a = -1;

    else
      a = +1;
    if((3 & (signed int)s->rank_and_balance) == 1)
    {
      s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(a + 1);
      ob->height = ob->height + (unsigned int)1;
      return 0;
    }

    else
      if((3 & (signed int)s->rank_and_balance) + -1 == -a)
      {
        s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
        return 0;
      }

      else
        if((3 & (signed int)s->rank_and_balance) + -1 == a)
        {
          if((3 & (signed int)r->rank_and_balance) + -1 == a)
          {
            p = r;
            if(a == -1)
            {
              s->left = r->right;
              if(!(r->right == ((struct avl_node_tag *)NULL)))
                r->right->parent = s;

              r->right = s;
              s->parent = r;
              s->rank_and_balance = s->rank_and_balance & (unsigned int)3 | (s->rank_and_balance >> 2) - (r->rank_and_balance >> 2) << 2;
            }

            else
            {
              s->right = r->left;
              if(!(r->left == ((struct avl_node_tag *)NULL)))
                r->left->parent = s;

              r->left = s;
              s->parent = r;
              r->rank_and_balance = r->rank_and_balance & (unsigned int)3 | (r->rank_and_balance >> 2) + (s->rank_and_balance >> 2) << 2;
            }
            s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
            r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
          }

          else
            if((3 & (signed int)r->rank_and_balance) + -1 == -a)
            {
              if(a == -1)
              {
                p = r->right;
                r->right = p->left;
                if(!(p->left == ((struct avl_node_tag *)NULL)))
                  p->left->parent = r;

                p->left = r;
                r->parent = p;
                s->left = p->right;
                if(!(p->right == ((struct avl_node_tag *)NULL)))
                  p->right->parent = s;

                p->right = s;
                s->parent = p;
                p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) + (r->rank_and_balance >> 2) << 2;
                s->rank_and_balance = s->rank_and_balance & (unsigned int)3 | (s->rank_and_balance >> 2) - (p->rank_and_balance >> 2) << 2;
              }

              else
              {
                p = r->left;
                r->left = p->right;
                if(!(p->right == ((struct avl_node_tag *)NULL)))
                  p->right->parent = r;

                p->right = r;
                r->parent = p;
                s->right = p->left;
                if(!(p->left == ((struct avl_node_tag *)NULL)))
                  p->left->parent = s;

                p->left = s;
                s->parent = p;
                r->rank_and_balance = r->rank_and_balance & (unsigned int)3 | (r->rank_and_balance >> 2) - (p->rank_and_balance >> 2) << 2;
                p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) + (s->rank_and_balance >> 2) << 2;
              }
              if((3 & (signed int)p->rank_and_balance) + -1 == a)
              {
                s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-a + 1);
                r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
              }

              else
                if((3 & (signed int)p->rank_and_balance) + -1 == -a)
                {
                  s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                  r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(a + 1);
                }

                else
                {
                  s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                  r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                }
              p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
            }

          if(s == t->right)
            t->right = p;

          else
            t->left = p;
          p->parent = t;
        }

  }
  return 0;
}

// avl_iterate_index_range
// file avl.c line 728
signed int avl_iterate_index_range(struct _avl_tree *tree, signed int (*iter_fun)(unsigned long int, void *, void *), unsigned long int low, unsigned long int high, void *iter_arg)
{
  unsigned long int m;
  unsigned long int num_left;
  struct avl_node_tag *node;
  if(!((unsigned long int)tree->length >= high))
    return -1;

  else
  {
    num_left = high - low;
    m = high;
    node = tree->root->right;
    while((_Bool)1)
      if(!(m >= (unsigned long int)(node->rank_and_balance >> 2)))
        node = node->left;

      else
        if(!((unsigned long int)(node->rank_and_balance >> 2) >= m))
        {
          m = m - (unsigned long int)(node->rank_and_balance >> 2);
          node = node->right;
        }

        else
          break;
    if(!(num_left == 0ul))
    {
      num_left = num_left - (unsigned long int)1;
      signed int return_value;
      return_value=iter_fun(num_left, node->key, iter_arg);
      if(!(return_value == 0))
        return -1;

      node=avl_get_prev(node);
    }

    return 0;
  }
}

// avl_iterate_inorder
// file avl.c line 652
signed int avl_iterate_inorder(struct _avl_tree *tree, signed int (*iter_fun)(void *, void *), void *iter_arg)
{
  signed int result;
  if(!(tree->length == 0u))
  {
    result=avl_iterate_inorder_helper(tree->root->right, iter_fun, iter_arg);
    return result;
  }

  else
    return 0;
}

// avl_iterate_inorder_helper
// file avl.c line 627
static signed int avl_iterate_inorder_helper(struct avl_node_tag *node, signed int (*iter_fun)(void *, void *), void *iter_arg)
{
  signed int result;
  if(!(node->left == ((struct avl_node_tag *)NULL)))
  {
    result=avl_iterate_inorder_helper(node->left, iter_fun, iter_arg);
    if(result == 0)
      goto __CPROVER_DUMP_L1;

    return result;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    result=iter_fun(node->key, iter_arg);
    if(!(result == 0))
      return result;

    else
      if(!(node->right == ((struct avl_node_tag *)NULL)))
      {
        result=avl_iterate_inorder_helper(node->right, iter_fun, iter_arg);
        return result;
      }

      else
        return 0;
  }
}

// avl_node_new
// file avl.c line 42
struct avl_node_tag * avl_node_new(void *key, struct avl_node_tag *parent)
{
  struct avl_node_tag *node;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct avl_node_tag) /*40ul*/ );
  node = (struct avl_node_tag *)return_value_malloc_1;
  if(node == ((struct avl_node_tag *)NULL))
    return (struct avl_node_tag *)(void *)0;

  else
  {
    node->parent = parent;
    node->key = key;
    node->left = (struct avl_node_tag *)(void *)0;
    node->right = (struct avl_node_tag *)(void *)0;
    node->rank_and_balance = (unsigned int)0;
    node->rank_and_balance = node->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
    node->rank_and_balance = node->rank_and_balance & (unsigned int)3 | (unsigned int)(1 << 2);
    return node;
  }
}

// avl_print_tree
// file avl.c line 1150
void avl_print_tree(struct _avl_tree *tree, signed int (*key_printer)(char *, void *))
{
  struct _link_node top = { .parent=(struct _link_node *)(void *)0, .direction=(char)0,
    .width=0 };
  if(key_printer == ((signed int (*)(char *, void *))NULL))
    key_printer = default_key_printer;

  if(!(tree->length == 0u))
    print_node(key_printer, tree->root->right, &top);

  else
    fprintf(stdout, "<empty tree>\n");
}

// avl_tree_free
// file avl/avl.h line 109
void avl_tree_free(struct _avl_tree *tree, signed int (*free_key_fun)(void *))
{
  if(!(tree->length == 0u))
    avl_tree_free_helper(tree->root->right, free_key_fun);

  if(!(tree->root == ((struct avl_node_tag *)NULL)))
    free((void *)tree->root);

  thread_rwlock_destroy(&tree->rwlock);
  free((void *)tree);
}

// avl_tree_free_helper
// file avl.c line 90
static void avl_tree_free_helper(struct avl_node_tag *node, signed int (*free_key_fun)(void *))
{
  if(!(node->left == ((struct avl_node_tag *)NULL)))
    avl_tree_free_helper(node->left, free_key_fun);

  if(!(free_key_fun == ((signed int (*)(void *))NULL)))
    free_key_fun(node->key);

  if(!(node->right == ((struct avl_node_tag *)NULL)))
    avl_tree_free_helper(node->right, free_key_fun);

  free((void *)node);
}

// avl_tree_new
// file avl/avl.h line 106
struct _avl_tree * avl_tree_new(signed int (*compare_fun)(void *, void *, void *), void *compare_arg)
{
  struct _avl_tree *t;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _avl_tree) /*88ul*/ );
  t = (struct _avl_tree *)return_value_malloc_1;
  if(t == ((struct _avl_tree *)NULL))
    return (struct _avl_tree *)(void *)0;

  else
  {
    struct avl_node_tag *root;
    root=avl_node_new((void *)0, (struct avl_node_tag *)(void *)0);
    if(root == ((struct avl_node_tag *)NULL))
    {
      free((void *)t);
      return (struct _avl_tree *)(void *)0;
    }

    else
    {
      t->root = root;
      t->height = (unsigned int)0;
      t->length = (unsigned int)0;
      t->compare_fun = compare_fun;
      t->compare_arg = compare_arg;
      thread_rwlock_create_c(&t->rwlock, 83, "avl.c");
      return t;
    }
  }
}

// avl_tree_rlock
// file avl/avl.h line 194
void avl_tree_rlock(struct _avl_tree *tree)
{
  thread_rwlock_rlock_c(&tree->rwlock, 1166, "avl.c");
}

// avl_tree_unlock
// file avl/avl.h line 196
void avl_tree_unlock(struct _avl_tree *tree)
{
  thread_rwlock_unlock_c(&tree->rwlock, 1176, "avl.c");
}

// avl_tree_wlock
// file avl/avl.h line 195
void avl_tree_wlock(struct _avl_tree *tree)
{
  thread_rwlock_wlock_c(&tree->rwlock, 1171, "avl.c");
}

// avl_verify
// file avl.c line 1050
signed int avl_verify(struct _avl_tree *tree)
{
  if(!(tree->length == 0u))
  {
    avl_verify_balance(tree->root->right);
    avl_verify_parent(tree->root->right, tree->root);
    avl_verify_rank(tree->root->right);
  }

  return 0;
}

// avl_verify_balance
// file avl.c line 995
static signed long int avl_verify_balance(struct avl_node_tag *node)
{
  if(node == ((struct avl_node_tag *)NULL))
    return (signed long int)0;

  else
  {
    signed long int lh;
    lh=avl_verify_balance(node->left);
    signed long int rh;
    rh=avl_verify_balance(node->right);
    if(!(rh + -lh == (signed long int)((3 & (signed int)node->rank_and_balance) + -1)))
      return (signed long int)0;

    if(lh + -rh >= 2l || !(lh + -rh >= -1l))
      return (signed long int)0;

    return (signed long int)1 + (lh > rh ? lh : rh);
  }
}

// avl_verify_parent
// file avl.c line 1013
static void avl_verify_parent(struct avl_node_tag *node, struct avl_node_tag *parent)
{
  if(node->parent == parent)
  {
    if(!(node->left == ((struct avl_node_tag *)NULL)))
      avl_verify_parent(node->left, node);

    if(!(node->right == ((struct avl_node_tag *)NULL)))
      avl_verify_parent(node->right, node);

  }

}

// avl_verify_rank
// file avl.c line 1027
static signed long int avl_verify_rank(struct avl_node_tag *node)
{
  if(node == ((struct avl_node_tag *)NULL))
    return (signed long int)0;

  else
  {
    unsigned long int num_left = (unsigned long int)0;
    unsigned long int num_right = (unsigned long int)0;
    if(!(node->left == ((struct avl_node_tag *)NULL)))
    {
      signed long int return_value_avl_verify_rank_1;
      return_value_avl_verify_rank_1=avl_verify_rank(node->left);
      num_left = (unsigned long int)return_value_avl_verify_rank_1;
    }

    if(!(node->right == ((struct avl_node_tag *)NULL)))
    {
      signed long int return_value_avl_verify_rank_2;
      return_value_avl_verify_rank_2=avl_verify_rank(node->right);
      num_right = (unsigned long int)return_value_avl_verify_rank_2;
    }

    if(!((unsigned long int)(node->rank_and_balance >> 2) == 1ul + num_left))
    {
      fprintf(stderr, "invalid rank at node %ld\n", (signed long int)node->key);
      exit(1);
    }

    return (signed long int)(num_left + num_right + (unsigned long int)1);
  }
}

// build_event
// file stats.c line 100
static struct _stats_event_tag * build_event(const char *source, const char *name, const char *value)
{
  struct _stats_event_tag *event;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _stats_event_tag) /*40ul*/ );
  event = (struct _stats_event_tag *)return_value_calloc_1;
  char *return_value_strdup_2;
  char *return_value_strdup_3;
  char *return_value_strdup_4;
  if(!(event == ((struct _stats_event_tag *)NULL)))
  {
    if(!(source == ((const char *)NULL)))
    {
      return_value_strdup_2=strdup(source);
      event->source = (char *)return_value_strdup_2;
    }

    if(!(name == ((const char *)NULL)))
    {
      return_value_strdup_3=strdup(name);
      event->name = (char *)return_value_strdup_3;
    }

    if(!(value == ((const char *)NULL)))
    {
      return_value_strdup_4=strdup(value);
      event->value = (char *)return_value_strdup_4;
    }

    else
      event->action = 5;
  }

  return event;
}

// byteReverse
// file md5.c line 51
static void byteReverse(unsigned char *buf, unsigned int longs)
{
  unsigned int t;
  do
  {
    t = (unsigned int)((unsigned int)buf[(signed long int)3] << 8 | (unsigned int)buf[(signed long int)2]) << 16 | (unsigned int)buf[(signed long int)1] << 8 | (unsigned int)buf[(signed long int)0];
    *((unsigned int *)buf) = t;
    buf = buf + (signed long int)4;
    longs = longs - 1u;
  }
  while(!(longs == 0u));
}

// check_duplicate_logins
// file auth.c line 331
static signed int check_duplicate_logins(struct source_tag *source, struct _client_tag *client, struct auth_tag *auth)
{
  signed int return_value_strcmp_1;
  signed int return_value_strcmp_2;
  if(client->username == ((char *)NULL))
    return 1;

  else
  {
    if(!(auth == ((struct auth_tag *)NULL)))
    {
      if(auth->allow_duplicate_users == 0)
      {
        struct avl_node_tag *node;
        avl_tree_rlock(source->client_tree);
        node=avl_get_first(source->client_tree);
        while(!(node == ((struct avl_node_tag *)NULL)))
        {
          struct _client_tag *existing_client = (struct _client_tag *)node->key;
          if(!(existing_client->username == ((char *)NULL)))
          {
            return_value_strcmp_1=strcmp(existing_client->username, client->username);
            if(return_value_strcmp_1 == 0)
            {
              avl_tree_unlock(source->client_tree);
              return 0;
            }

          }

          node=avl_get_next(node);
        }
        avl_tree_unlock(source->client_tree);
        avl_tree_rlock(source->pending_tree);
        node=avl_get_first(source->pending_tree);
        while(!(node == ((struct avl_node_tag *)NULL)))
        {
          struct _client_tag *check_duplicate_logins__1__1__2__existing_client = (struct _client_tag *)node->key;
          if(!(check_duplicate_logins__1__1__2__existing_client->username == ((char *)NULL)))
          {
            return_value_strcmp_2=strcmp(check_duplicate_logins__1__1__2__existing_client->username, client->username);
            if(return_value_strcmp_2 == 0)
            {
              avl_tree_unlock(source->pending_tree);
              return 0;
            }

          }

          node=avl_get_next(node);
        }
        avl_tree_unlock(source->pending_tree);
      }

    }

    return 1;
  }
}

// check_relay_stream
// file slave.c line 392
static void check_relay_stream(struct _relay_server *relay)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed long int return_value_time_2;
  if(relay->source == ((struct source_tag *)NULL))
  {
    if(!((signed int)*relay->localmount == 47))
    {
      log_write(errorlog, (unsigned int)2, "slave/", "check_relay_stream", "relay mountpoint \"%s\" does not start with /, skipping", relay->localmount);
      goto __CPROVER_DUMP_L17;
    }

    relay->source=source_reserve(relay->localmount);
    if(!(relay->source == ((struct source_tag *)NULL)))
    {
      log_write(errorlog, (unsigned int)4, "slave/", "check_relay_stream", "Adding relay source at mountpoint \"%s\"", relay->localmount);
      if(!(relay->on_demand == 0))
      {
        struct ice_config_tag *config;
        config=config_get_config();
        struct _mount_proxy *mountinfo;
        mountinfo=config_find_mount(config, relay->localmount, (enum _mount_type)MOUNT_TYPE_NORMAL);
        if(mountinfo == ((struct _mount_proxy *)NULL))
          source_update_settings(config, relay->source, mountinfo);

        config_release_config();
        stats_event(relay->localmount, "listeners", "0");
        slave_update_all_mounts();
      }

      goto __CPROVER_DUMP_L6;
    }

    if(relay->start == 0l)
    {
      log_write(errorlog, (unsigned int)2, "slave/", "check_relay_stream", "new relay but source \"%s\" already exists", relay->localmount);
      relay->start = (signed long int)1;
    }

  }

  else
  {

  __CPROVER_DUMP_L6:
    ;
    struct source_tag *source = relay->source;
    if(relay->source == ((struct source_tag *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = relay->running != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_time_2=time((signed long int *)(void *)0);
      tmp_if_expr_3 = relay->start > return_value_time_2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_3)
    {
      if(!(relay->on_demand == 0))
      {
        if(!(source->on_demand_req == 0))
          goto __CPROVER_DUMP_L14;

        relay->source->on_demand = relay->on_demand;
        if(!(source->fallback_mount == ((char *)NULL)))
        {
          if(!(source->fallback_override == 0))
          {
            struct source_tag *fallback;
            avl_tree_rlock(global.source_tree);
            fallback=source_find_mount(source->fallback_mount);
            if(!(fallback == ((struct source_tag *)NULL)))
            {
              if(!(fallback->running == 0))
              {
                if(!(fallback->listeners == 0ul))
                {
                  log_write(errorlog, (unsigned int)4, "slave/", "check_relay_stream", "fallback running %d with %lu listeners", fallback->running, fallback->listeners);
                  source->on_demand_req = 1;
                }

              }

            }

            avl_tree_unlock(global.source_tree);
          }

        }

        if(!(source->on_demand_req == 0))
          goto __CPROVER_DUMP_L14;

      }

      else
      {

      __CPROVER_DUMP_L14:
        ;
        signed long int return_value_time_4;
        return_value_time_4=time((signed long int *)(void *)0);
        relay->start = return_value_time_4 + (signed long int)5;
        relay->running = 1;
        relay->thread=thread_create_c("Relay Thread", start_relay_stream, (void *)relay, 0, 458, "slave.c");
        goto __CPROVER_DUMP_L17;
      }
    }

    if(!(relay->cleanup == 0))
    {
      if(!(relay->thread == ((struct anonymous_24 *)NULL)))
      {
        log_write(errorlog, (unsigned int)4, "slave/", "check_relay_stream", "waiting for relay thread for \"%s\"", relay->localmount);
        thread_join(relay->thread);
        relay->thread = (struct anonymous_24 *)(void *)0;
      }

      relay->cleanup = 0;
      relay->running = 0;
      if(!(relay->on_demand == 0))
      {
        if(!(relay->source == ((struct source_tag *)NULL)))
        {
          struct ice_config_tag *check_relay_stream__1__3__2__config;
          check_relay_stream__1__3__2__config=config_get_config();
          struct _mount_proxy *check_relay_stream__1__3__2__mountinfo;
          check_relay_stream__1__3__2__mountinfo=config_find_mount(check_relay_stream__1__3__2__config, relay->localmount, (enum _mount_type)MOUNT_TYPE_NORMAL);
          source_update_settings(check_relay_stream__1__3__2__config, relay->source, check_relay_stream__1__3__2__mountinfo);
          config_release_config();
          stats_event(relay->localmount, "listeners", "0");
        }

      }

    }

  }

__CPROVER_DUMP_L17:
  ;
}

// check_servers
// file yp.c line 615
static void check_servers(void)
{
  struct yp_server *server = (struct yp_server *)active_yps;
  struct yp_server **server_p = (struct yp_server **)&active_yps;
  while(!(server == ((struct yp_server *)NULL)))
  {
    if(!(server->remove == 0))
    {
      struct yp_server *to_go = server;
      log_write(errorlog, (unsigned int)4, "yp/", "check_servers", "YP server \"%s\"removed", server->url);
      *server_p = server->next;
      server = server->next;
      destroy_yp_server(to_go);
      continue;
    }

    server_p = &server->next;
    server = server->next;
  }
  while(!(pending_yps == ((struct yp_server *)NULL)))
  {
    struct avl_node_tag *node;
    server = (struct yp_server *)pending_yps;
    pending_yps = server->next;
    log_write(errorlog, (unsigned int)4, "yp/", "check_servers", "Add pending yps %s", server->url);
    server->next = (struct yp_server *)active_yps;
    active_yps = server;
    avl_tree_rlock(global.source_tree);
    node=avl_get_first(global.source_tree);
    while(!(node == ((struct avl_node_tag *)NULL)))
    {
      struct ypdata_tag *yp;
      struct source_tag *source = (struct source_tag *)node->key;
      if(!(source->yp_public == 0))
      {
        yp=create_yp_entry(source->mount);
        if(!(yp == ((struct ypdata_tag *)NULL)))
        {
          log_write(errorlog, (unsigned int)4, "yp/", "check_servers", "Adding existing mount %s", source->mount);
          yp->server = server;
          yp->touch_interval = server->touch_interval;
          yp->next = server->mounts;
          server->mounts = yp;
        }

      }

      node=avl_get_next(node);
    }
    avl_tree_unlock(global.source_tree);
  }
}

// client_check_source_auth
// file client.h line 82
signed int client_check_source_auth(struct _client_tag *client, const char *mount)
{
  struct ice_config_tag *config;
  config=config_get_config();
  char *pass = config->source_password;
  char *user = "source";
  signed int ret = -1;
  struct _mount_proxy *mountinfo;
  mountinfo=config_find_mount(config, mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
  do
  {
    if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    {
      ret = 1;
      signed int return_value_auth_stream_authenticate_1;
      return_value_auth_stream_authenticate_1=auth_stream_authenticate(client, mount, mountinfo);
      if(return_value_auth_stream_authenticate_1 >= 1)
        goto __CPROVER_DUMP_L6;

      ret = -1;
      if(!(mountinfo->password == ((char *)NULL)))
        pass = mountinfo->password;

      if(!(mountinfo->username == ((char *)NULL)))
        user = mountinfo->username;

    }

    signed int return_value_connection_check_pass_2;
    return_value_connection_check_pass_2=connection_check_pass(client->parser, user, pass);
    if(return_value_connection_check_pass_2 >= 1)
      ret = 0;

  }
  while((_Bool)0);

__CPROVER_DUMP_L6:
  ;
  config_release_config();
  return ret;
}

// client_create
// file client.h line 71
signed int client_create(struct _client_tag **c_ptr, struct connection_tag *con, struct http_parser_tag *parser)
{
  struct ice_config_tag *config;
  struct _client_tag *client;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _client_tag) /*104ul*/ );
  client = (struct _client_tag *)return_value_calloc_1;
  signed int ret = -1;
  if(client == ((struct _client_tag *)NULL))
    abort();

  config=config_get_config();
  global.clients = global.clients + 1;
  if(!(config->client_limit >= global.clients))
    log_write(errorlog, (unsigned int)2, "client/", "client_create", "server client limit reached (%d/%d)", config->client_limit, global.clients);

  else
    ret = 0;
  config_release_config();
  stats_event_args((const char *)(void *)0, "clients", "%d", global.clients);
  client->con = con;
  client->parser = parser;
  client->refbuf=refbuf_new((unsigned int)4096);
  client->refbuf->len = (unsigned int)0;
  client->pos = (unsigned int)0;
  client->write_to_client = format_generic_write_to_client;
  *c_ptr = client;
  return ret;
}

// client_destroy
// file client.h line 72
void client_destroy(struct _client_tag *client)
{
  if(!(client == ((struct _client_tag *)NULL)))
  {
    if(!(client->refbuf == ((struct _refbuf_tag *)NULL)))
    {
      refbuf_release(client->refbuf);
      client->refbuf = (struct _refbuf_tag *)(void *)0;
    }

    signed int return_value_auth_release_listener_1;
    return_value_auth_release_listener_1=auth_release_listener(client);
    if(return_value_auth_release_listener_1 == 0)
    {
      if(!(client->respcode == 0))
      {
        if(!(client->parser == ((struct http_parser_tag *)NULL)))
          logging_access(client);

      }

      if(!(client->con == ((struct connection_tag *)NULL)))
        connection_close(client->con);

      if(!(client->parser == ((struct http_parser_tag *)NULL)))
        httpp_destroy(client->parser);

      global_lock();
      global.clients = global.clients - 1;
      stats_event_args((const char *)(void *)0, "clients", "%d", global.clients);
      global_unlock();
      if(!(client->free_client_data == ((void (*)(struct _client_tag *))NULL)))
        client->free_client_data(client);

      free((void *)client->username);
      free((void *)client->password);
      free((void *)client);
    }

  }

}

// client_read_bytes
// file client.h line 80
signed int client_read_bytes(struct _client_tag *client, void *buf, unsigned int len)
{
  signed int bytes;
  if(!(client->refbuf == ((struct _refbuf_tag *)NULL)))
  {
    if(client->refbuf->len == 0u)
      goto __CPROVER_DUMP_L3;

    if(!(client->refbuf->len >= len))
      len = client->refbuf->len;

    memcpy(buf, (const void *)client->refbuf->data, (unsigned long int)len);
    if(!(len >= client->refbuf->len))
    {
      char *ptr = client->refbuf->data;
      memmove((void *)ptr, (const void *)(ptr + (signed long int)len), (unsigned long int)(client->refbuf->len - len));
    }

    client->refbuf->len = client->refbuf->len - len;
    return (signed int)len;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    bytes=client->con->read(client->con, buf, (unsigned long int)len);
    if(bytes == -1)
    {
      if(!(client->con->error == 0))
        log_write(errorlog, (unsigned int)4, "client/", "client_read_bytes", "reading from connection has failed");

    }

    return bytes;
  }
}

// client_send_100
// file client.h line 73
void client_send_100(struct _client_tag *client)
{
  sock_write(client->con->sock, "HTTP/1.1 100 Continue\r\n\r\n");
}

// client_send_400
// file client.h line 77
void client_send_400(struct _client_tag *client, const char *message)
{
  client_send_error(client, 400, 0, message);
}

// client_send_401
// file client.h line 75
void client_send_401(struct _client_tag *client)
{
  client_send_error(client, 401, 1, "You need to authenticate\r\n");
}

// client_send_403
// file client.h line 76
void client_send_403(struct _client_tag *client, const char *message)
{
  client_send_error(client, 403, 1, message);
}

// client_send_404
// file client.h line 74
void client_send_404(struct _client_tag *client, const char *message)
{
  client_send_error(client, 404, 0, message);
}

// client_send_500
// file client.c line 238
void client_send_500(struct _client_tag *client, const char *message)
{
  const char header[136l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '0', ' ', '5', '0', '0', ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'S', 'e', 'r', 'v', 'e', 'r', ' ', 'E', 'r', 'r', 'o', 'r', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', ';', ' ', 'c', 'h', 'a', 'r', 's', 'e', 't', '=', 'u', 't', 'f', '-', '8', '\r', '\n', '\r', '\n', '5', '0', '0', ' ', '-', ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'S', 'e', 'r', 'v', 'e', 'r', ' ', 'E', 'r', 'r', 'o', 'r', '\n', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '\n', 0 };
  const unsigned long int header_len = sizeof(const char [136l]) /*136ul*/  - (unsigned long int)1;
  signed int ret;
  ret=client_send_bytes(client, (const void *)header, (unsigned int)header_len);
  unsigned long int return_value_strlen_1;
  if((unsigned long int)ret == header_len && !(message == ((const char *)NULL)))
  {
    return_value_strlen_1=strlen(message);
    client_send_bytes(client, (const void *)message, (unsigned int)return_value_strlen_1);
  }

  client_destroy(client);
}

// client_send_bytes
// file client.h line 79
signed int client_send_bytes(struct _client_tag *client, const void *buf, unsigned int len)
{
  signed int ret;
  ret=client->con->send(client->con, buf, (unsigned long int)len);
  if(!(client->con->error == 0))
    log_write(errorlog, (unsigned int)4, "client/", "client_send_bytes", "Client connection died");

  return ret;
}

// client_send_error
// file client.c line 186
static void client_send_error(struct _client_tag *client, signed int status, signed int plain, const char *message)
{
  signed long int ret;
  ret=util_http_build_header(client->refbuf->data, (unsigned long int)4096, (signed long int)0, 0, status, (const char *)(void *)0, plain != 0 ? "text/plain" : "text/html", "utf-8", plain != 0 ? message : "", (struct source_tag *)(void *)0);
  if(ret == -1l || ret >= 4096l)
  {
    log_write(errorlog, (unsigned int)1, "client/", "client_send_error", "Dropping client as we can not build response headers.");
    client_send_500(client, "Header generation failed.");
  }

  else
  {
    if(plain == 0)
      snprintf(client->refbuf->data + ret, (unsigned long int)((signed long int)4096 - ret), "<html><head><title>Error %i</title></head><body><b>%i - %s</b></body></html>\r\n", status, status, message);

    client->respcode = status;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(client->refbuf->data);
    client->refbuf->len = (unsigned int)return_value_strlen_1;
    fserve_add_client(client, (struct _IO_FILE *)(void *)0);
  }
}

// client_set_queue
// file client.h line 81
void client_set_queue(struct _client_tag *client, struct _refbuf_tag *refbuf)
{
  struct _refbuf_tag *to_release = client->refbuf;
  client->refbuf = refbuf;
  if(!(refbuf == ((struct _refbuf_tag *)NULL)))
    refbuf_addref(client->refbuf);

  client->pos = (unsigned int)0;
  if(!(to_release == ((struct _refbuf_tag *)NULL)))
    refbuf_release(to_release);

}

// command_buildm3u
// file admin.c line 745
static void command_buildm3u(struct _client_tag *client, const char *mount)
{
  const char *username = (const char *)(void *)0;
  const char *password = (const char *)(void *)0;
  struct ice_config_tag *config;
  signed long int ret;
  do
  {
    username=httpp_get_query_param(client->parser, "username");
    if(username == ((const char *)NULL))
    {
      client_send_400(client, "Missing parameter");
      goto __CPROVER_DUMP_L6;
    }

  }
  while((_Bool)0);
  do
  {
    password=httpp_get_query_param(client->parser, "password");
    if(password == ((const char *)NULL))
    {
      client_send_400(client, "Missing parameter");
      goto __CPROVER_DUMP_L6;
    }

  }
  while((_Bool)0);
  ret=util_http_build_header(client->refbuf->data, (unsigned long int)4096, (signed long int)0, 0, 200, (const char *)(void *)0, "audio/x-mpegurl", (const char *)(void *)0, (const char *)(void *)0, (struct source_tag *)(void *)0);
  if(ret == -1l || ret >= 3584l)
  {
    log_write(errorlog, (unsigned int)1, "admin/", "command_buildm3u", "Dropping client as we can not build response headers.");
    client_send_500(client, "Header generation failed.");
  }

  else
  {
    config=config_get_config();
    snprintf(client->refbuf->data + ret, (unsigned long int)((signed long int)4096 - ret), "Content-Disposition = attachment; filename=listen.m3u\r\n\r\nhttp://%s:%s@%s:%d%s\r\n", username, password, config->hostname, config->port, mount);
    config_release_config();
    client->respcode = 200;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(client->refbuf->data);
    client->refbuf->len = (unsigned int)return_value_strlen_1;
    fserve_add_client(client, (struct _IO_FILE *)(void *)0);
  }

__CPROVER_DUMP_L6:
  ;
}

// command_fallback
// file admin.c line 938
static void command_fallback(struct _client_tag *client, struct source_tag *source, signed int response)
{
  const char *fallback;
  char *old;
  log_write(errorlog, (unsigned int)4, "admin/", "command_fallback", "Got fallback request");
  do
  {
    fallback=httpp_get_query_param(client->parser, "fallback");
    if(fallback == ((const char *)NULL))
    {
      client_send_400(client, "Missing parameter");
      goto __CPROVER_DUMP_L3;
    }

  }
  while((_Bool)0);
  old = source->fallback_mount;
  source->fallback_mount=strdup(fallback);
  free((void *)old);
  html_success(client, "Fallback configured");

__CPROVER_DUMP_L3:
  ;
}

// command_kill_client
// file admin.c line 894
static void command_kill_client(struct _client_tag *client, struct source_tag *source, signed int response)
{
  const char *idtext;
  signed int id;
  struct _client_tag *listener;
  struct _xmlDoc *doc;
  struct _xmlNode *node;
  char buf[50l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  do
  {
    idtext=httpp_get_query_param(client->parser, "id");
    if(idtext == ((const char *)NULL))
    {
      client_send_400(client, "Missing parameter");
      goto __CPROVER_DUMP_L5;
    }

  }
  while((_Bool)0);
  id=atoi(idtext);
  listener=source_find_client(source, id);
  doc=xmlNewDoc((unsigned char *)"1.0");
  node=xmlNewDocNode(doc, (struct _xmlNs *)(void *)0, (unsigned char *)"iceresponse", (const unsigned char *)(void *)0);
  xmlDocSetRootElement(doc, node);
  log_write(errorlog, (unsigned int)4, "admin/", "command_kill_client", "Response is %d", response);
  if(!(listener == ((struct _client_tag *)NULL)))
  {
    log_write(errorlog, (unsigned int)3, "admin/", "command_kill_client", "Admin request: client %d removed", id);
    listener->con->error = 1;
    memset((void *)buf, 0, sizeof(char [50l]) /*50ul*/ );
    snprintf(buf, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "Client %d removed", id);
    xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"message", (unsigned char *)buf);
    xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"return", (unsigned char *)"1");
  }

  else
  {
    memset((void *)buf, 0, sizeof(char [50l]) /*50ul*/ );
    snprintf(buf, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "Client %d not found", id);
    xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"message", (unsigned char *)buf);
    xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"return", (unsigned char *)"0");
  }
  admin_send_response(doc, client, response, "response.xsl");
  xmlFreeDoc(doc);

__CPROVER_DUMP_L5:
  ;
}

// command_kill_source
// file admin.c line 875
static void command_kill_source(struct _client_tag *client, struct source_tag *source, signed int response)
{
  struct _xmlDoc *doc;
  struct _xmlNode *node;
  doc=xmlNewDoc((unsigned char *)"1.0");
  node=xmlNewDocNode(doc, (struct _xmlNs *)(void *)0, (unsigned char *)"iceresponse", (const unsigned char *)(void *)0);
  xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"message", (unsigned char *)"Source Removed");
  xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"return", (unsigned char *)"1");
  xmlDocSetRootElement(doc, node);
  source->running = 0;
  admin_send_response(doc, client, response, "response.xsl");
  xmlFreeDoc(doc);
}

// command_list_mounts
// file admin.c line 1076
static void command_list_mounts(struct _client_tag *client, signed int response)
{
  log_write(errorlog, (unsigned int)4, "admin/", "command_list_mounts", "List mounts request");
  if(response == 3)
  {
    signed long int ret;
    ret=util_http_build_header(client->refbuf->data, (unsigned long int)4096, (signed long int)0, 0, 200, (const char *)(void *)0, "text/plain", "utf-8", "", (struct source_tag *)(void *)0);
    if(ret == -1l || ret >= 4096l)
    {
      log_write(errorlog, (unsigned int)1, "admin/", "command_list_mounts", "Dropping client as we can not build response headers.");
      client_send_500(client, "Header generation failed.");
      goto __CPROVER_DUMP_L3;
    }

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(client->refbuf->data);
    client->refbuf->len = (unsigned int)return_value_strlen_1;
    client->respcode = 200;
    client->refbuf->next=stats_get_streams();
    fserve_add_client(client, (struct _IO_FILE *)(void *)0);
  }

  else
  {
    struct _xmlDoc *doc;
    avl_tree_rlock(global.source_tree);
    doc=admin_build_sourcelist((const char *)(void *)0);
    avl_tree_unlock(global.source_tree);
    admin_send_response(doc, client, response, "listmounts.xsl");
    xmlFreeDoc(doc);
  }

__CPROVER_DUMP_L3:
  ;
}

// command_manageauth
// file admin.c line 785
static void command_manageauth(struct _client_tag *client, struct source_tag *source, signed int response)
{
  struct _xmlDoc *doc;
  struct _xmlNode *node;
  struct _xmlNode *srcnode;
  struct _xmlNode *msgnode;
  const char *action = (const char *)(void *)0;
  const char *username = (const char *)(void *)0;
  char *message = (char *)(void *)0;
  signed int ret = AUTH_OK;
  struct ice_config_tag *config;
  config=config_get_config();
  struct _mount_proxy *mountinfo;
  mountinfo=config_find_mount(config, source->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
  _Bool tmp_if_expr_1;
  if(mountinfo == ((struct _mount_proxy *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = mountinfo->auth == (struct auth_tag *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    log_write(errorlog, (unsigned int)2, "admin/", "command_manageauth", "manage auth request for %s but no facility available", source->mount);

  else
  {
    action=httpp_get_query_param(client->parser, "action");
    username=httpp_get_query_param(client->parser, "username");
    if(action == ((const char *)NULL))
      action = "list";

    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(action, "add");
    if(return_value_strcmp_2 == 0)
    {
      const char *password = (const char *)(void *)0;
      password=httpp_get_query_param(client->parser, "password");
      if(password == ((const char *)NULL) || username == ((const char *)NULL))
      {
        log_write(errorlog, (unsigned int)2, "admin/", "command_manageauth", "manage auth request add for %s but no user/pass", source->mount);
        goto __CPROVER_DUMP_L17;
      }

      enum anonymous_19 return_value;
      return_value=mountinfo->auth->adduser(mountinfo->auth, username, password);
      ret = (signed int)return_value;
      if(ret == AUTH_FAILED)
        message=strdup("User add failed - check the icecast error log");

      if(ret == AUTH_USERADDED)
        message=strdup("User added");

      if(ret == AUTH_USEREXISTS)
        message=strdup("User already exists - not added");

    }

    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(action, "delete");
    if(return_value_strcmp_3 == 0)
    {
      if(username == ((const char *)NULL))
      {
        log_write(errorlog, (unsigned int)2, "admin/", "command_manageauth", "manage auth request delete for %s but no username", source->mount);
        goto __CPROVER_DUMP_L17;
      }

      enum anonymous_19 return_value_1;
      return_value_1=mountinfo->auth->deleteuser(mountinfo->auth, username);
      ret = (signed int)return_value_1;
      if(ret == AUTH_FAILED)
        message=strdup("User delete failed - check the icecast error log");

      if(ret == AUTH_USERDELETED)
        message=strdup("User deleted");

    }

    doc=xmlNewDoc((unsigned char *)"1.0");
    node=xmlNewDocNode(doc, (struct _xmlNs *)(void *)0, (unsigned char *)"icestats", (const unsigned char *)(void *)0);
    srcnode=xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"source", (const unsigned char *)(void *)0);
    xmlSetProp(srcnode, (unsigned char *)"mount", (unsigned char *)source->mount);
    if(!(message == ((char *)NULL)))
    {
      msgnode=xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"iceresponse", (const unsigned char *)(void *)0);
      xmlNewChild(msgnode, (struct _xmlNs *)(void *)0, (unsigned char *)"message", (unsigned char *)message);
    }

    xmlDocSetRootElement(doc, node);
    if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    {
      if(!(mountinfo->auth == ((struct auth_tag *)NULL)))
      {
        if(!(mountinfo->auth->listuser == ((enum anonymous_19 (*)(struct auth_tag *, struct _xmlNode *))NULL)))
          mountinfo->auth->listuser(mountinfo->auth, srcnode);

      }

    }

    config_release_config();
    admin_send_response(doc, client, response, "manageauth.xsl");
    free((void *)message);
    xmlFreeDoc(doc);
    goto __CPROVER_DUMP_L18;
  }

__CPROVER_DUMP_L17:
  ;
  config_release_config();
  client_send_400(client, "missing parameter");

__CPROVER_DUMP_L18:
  ;
}

// command_metadata
// file admin.c line 955
static void command_metadata(struct _client_tag *client, struct source_tag *source, signed int response)
{
  const char *action;
  const char *song;
  const char *title;
  const char *artist;
  const char *charset;
  struct _format_plugin_tag *plugin;
  struct _xmlDoc *doc;
  struct _xmlNode *node;
  signed int same_ip = 1;
  doc=xmlNewDoc((unsigned char *)"1.0");
  node=xmlNewDocNode(doc, (struct _xmlNs *)(void *)0, (unsigned char *)"iceresponse", (const unsigned char *)(void *)0);
  xmlDocSetRootElement(doc, node);
  log_write(errorlog, (unsigned int)4, "admin/", "command_metadata", "Got metadata update request");
  do
  {
    action=httpp_get_query_param(client->parser, "mode");
    if(action == ((const char *)NULL))
    {
      client_send_400(client, "Missing parameter");
      goto __CPROVER_DUMP_L11;
    }

  }
  while((_Bool)0);
  song=httpp_get_query_param(client->parser, "song");
  title=httpp_get_query_param(client->parser, "title");
  artist=httpp_get_query_param(client->parser, "artist");
  charset=httpp_get_query_param(client->parser, "charset");
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(action, "updinfo");
  signed int return_value_strcmp_3;
  signed int return_value_connection_check_admin_pass_2;
  _Bool tmp_if_expr_4;
  if(!(return_value_strcmp_1 == 0))
  {
    xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"message", (unsigned char *)"No such action");
    xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"return", (unsigned char *)"0");
    admin_send_response(doc, client, response, "response.xsl");
    xmlFreeDoc(doc);
  }

  else
  {
    plugin = source->format;
    if(!(source->client == ((struct _client_tag *)NULL)))
    {
      return_value_strcmp_3=strcmp(client->con->ip, source->client->con->ip);
      if(!(return_value_strcmp_3 == 0))
      {
        if(response == 1)
        {
          return_value_connection_check_admin_pass_2=connection_check_admin_pass(client->parser);
          if(return_value_connection_check_admin_pass_2 == 0)
            same_ip = 0;

        }

      }

    }

    if(!(plugin == ((struct _format_plugin_tag *)NULL)) && !(same_ip == 0))
      tmp_if_expr_4 = plugin->set_tag != ((void (*)(struct _format_plugin_tag *, const char *, const char *, const char *))NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      if(!(song == ((const char *)NULL)))
      {
        plugin->set_tag(plugin, "song", song, charset);
        log_write(errorlog, (unsigned int)3, "admin/", "command_metadata", "Metadata on mountpoint %s changed to \"%s\"", source->mount, song);
      }

      else
        if(!(artist == ((const char *)NULL)) && !(title == ((const char *)NULL)))
        {
          plugin->set_tag(plugin, "title", title, charset);
          plugin->set_tag(plugin, "artist", artist, charset);
          log_write(errorlog, (unsigned int)3, "admin/", "command_metadata", "Metadata on mountpoint %s changed to \"%s - %s\"", source->mount, artist, title);
        }

      plugin->set_tag(plugin, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0);
    }

    else
    {
      xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"message", (unsigned char *)"Mountpoint will not accept URL updates");
      xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"return", (unsigned char *)"1");
      admin_send_response(doc, client, response, "response.xsl");
      xmlFreeDoc(doc);
      goto __CPROVER_DUMP_L11;
    }
    xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"message", (unsigned char *)"Metadata update successful");
    xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"return", (unsigned char *)"1");
    admin_send_response(doc, client, response, "response.xsl");
    xmlFreeDoc(doc);
  }

__CPROVER_DUMP_L11:
  ;
}

// command_move_clients
// file admin.c line 630
static void command_move_clients(struct _client_tag *client, struct source_tag *source, signed int response)
{
  const char *dest_source;
  struct source_tag *dest;
  struct _xmlDoc *doc;
  struct _xmlNode *node;
  char buf[255l];
  signed int parameters_passed = 0;
  log_write(errorlog, (unsigned int)4, "admin/", "command_move_clients", "Doing optional check");
  dest_source=httpp_get_query_param(client->parser, "destination");
  if(!(dest_source == ((const char *)NULL)))
    parameters_passed = 1;

  log_write(errorlog, (unsigned int)4, "admin/", "command_move_clients", "Done optional check (%d)", parameters_passed);
  if(parameters_passed == 0)
  {
    doc=admin_build_sourcelist(source->mount);
    admin_send_response(doc, client, response, "moveclients.xsl");
    xmlFreeDoc(doc);
  }

  else
  {
    dest=source_find_mount(dest_source);
    if(dest == ((struct source_tag *)NULL))
      client_send_400(client, "No such destination");

    else
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(dest->mount, source->mount);
      if(return_value_strcmp_1 == 0)
        client_send_400(client, "supplied mountpoints are identical");

      else
        if(dest->running == 0)
        {
          if(!(dest->on_demand == 0))
            goto __CPROVER_DUMP_L5;

          client_send_400(client, "Destination not running");
        }

        else
        {

        __CPROVER_DUMP_L5:
          ;
          log_write(errorlog, (unsigned int)3, "admin/", "command_move_clients", "source is \"%s\", destination is \"%s\"", source->mount, dest->mount);
          doc=xmlNewDoc((unsigned char *)"1.0");
          node=xmlNewDocNode(doc, (struct _xmlNs *)(void *)0, (unsigned char *)"iceresponse", (const unsigned char *)(void *)0);
          xmlDocSetRootElement(doc, node);
          source_move_clients(source, dest);
          memset((void *)buf, 0, sizeof(char [255l]) /*255ul*/ );
          snprintf(buf, sizeof(char [255l]) /*255ul*/ , "Clients moved from %s to %s", source->mount, dest_source);
          xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"message", (unsigned char *)buf);
          xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"return", (unsigned char *)"1");
          admin_send_response(doc, client, response, "response.xsl");
          xmlFreeDoc(doc);
        }
    }
  }
}

// command_shoutcast_metadata
// file admin.c line 1030
static void command_shoutcast_metadata(struct _client_tag *client, struct source_tag *source)
{
  const char *action;
  const char *value;
  signed int same_ip = 1;
  log_write(errorlog, (unsigned int)4, "admin/", "command_shoutcast_metadata", "Got shoutcast metadata update request");
  do
  {
    action=httpp_get_query_param(client->parser, "mode");
    if(action == ((const char *)NULL))
    {
      client_send_400(client, "Missing parameter");
      goto __CPROVER_DUMP_L13;
    }

  }
  while((_Bool)0);
  do
  {
    value=httpp_get_query_param(client->parser, "song");
    if(value == ((const char *)NULL))
    {
      client_send_400(client, "Missing parameter");
      goto __CPROVER_DUMP_L13;
    }

  }
  while((_Bool)0);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(action, "updinfo");
  signed int return_value_strcmp_3;
  signed int return_value_connection_check_admin_pass_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(!(return_value_strcmp_1 == 0))
    client_send_400(client, "No such action");

  else
  {
    if(!(source->client == ((struct _client_tag *)NULL)))
    {
      return_value_strcmp_3=strcmp(client->con->ip, source->client->con->ip);
      if(!(return_value_strcmp_3 == 0))
      {
        return_value_connection_check_admin_pass_2=connection_check_admin_pass(client->parser);
        if(return_value_connection_check_admin_pass_2 == 0)
          same_ip = 0;

      }

    }

    if(!(same_ip == 0))
      tmp_if_expr_4 = source->format != ((struct _format_plugin_tag *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = source->format->set_tag != ((void (*)(struct _format_plugin_tag *, const char *, const char *, const char *))NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      source->format->set_tag(source->format, "title", value, (const char *)(void *)0);
      source->format->set_tag(source->format, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0);
      log_write(errorlog, (unsigned int)4, "admin/", "command_shoutcast_metadata", "Metadata on mountpoint %s changed to \"%s\"", source->mount, value);
      html_success(client, "Metadata update successful");
    }

    else
      client_send_400(client, "mountpoint will not accept URL updates");
  }

__CPROVER_DUMP_L13:
  ;
}

// command_show_listeners
// file admin.c line 692
static void command_show_listeners(struct _client_tag *client, struct source_tag *source, signed int response)
{
  struct _xmlDoc *doc;
  struct _xmlNode *node;
  struct _xmlNode *srcnode;
  struct _xmlNode *listenernode;
  struct avl_node_tag *client_node;
  struct _client_tag *current;
  char buf[22l];
  const char *userAgent = (const char *)(void *)0;
  signed long int command_show_listeners__1__now;
  command_show_listeners__1__now=time((signed long int *)(void *)0);
  doc=xmlNewDoc((unsigned char *)"1.0");
  node=xmlNewDocNode(doc, (struct _xmlNs *)(void *)0, (unsigned char *)"icestats", (const unsigned char *)(void *)0);
  srcnode=xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"source", (const unsigned char *)(void *)0);
  xmlSetProp(srcnode, (unsigned char *)"mount", (unsigned char *)source->mount);
  xmlDocSetRootElement(doc, node);
  memset((void *)buf, 0, sizeof(char [22l]) /*22ul*/ );
  snprintf(buf, sizeof(char [22l]) /*22ul*/ , "%lu", source->listeners);
  xmlNewChild(srcnode, (struct _xmlNs *)(void *)0, (unsigned char *)"Listeners", (unsigned char *)buf);
  avl_tree_rlock(source->client_tree);
  client_node=avl_get_first(source->client_tree);
  while(!(client_node == ((struct avl_node_tag *)NULL)))
  {
    current = (struct _client_tag *)client_node->key;
    listenernode=xmlNewChild(srcnode, (struct _xmlNs *)(void *)0, (unsigned char *)"listener", (const unsigned char *)(void *)0);
    xmlNewChild(listenernode, (struct _xmlNs *)(void *)0, (unsigned char *)"IP", (unsigned char *)current->con->ip);
    userAgent=httpp_getvar(current->parser, "user-agent");
    if(!(userAgent == ((const char *)NULL)))
      xmlNewChild(listenernode, (struct _xmlNs *)(void *)0, (unsigned char *)"UserAgent", (unsigned char *)userAgent);

    else
      xmlNewChild(listenernode, (struct _xmlNs *)(void *)0, (unsigned char *)"UserAgent", (unsigned char *)"Unknown");
    memset((void *)buf, 0, sizeof(char [22l]) /*22ul*/ );
    snprintf(buf, sizeof(char [22l]) /*22ul*/ , "%lu", (unsigned long int)(command_show_listeners__1__now - current->con->con_time));
    xmlNewChild(listenernode, (struct _xmlNs *)(void *)0, (unsigned char *)"Connected", (unsigned char *)buf);
    memset((void *)buf, 0, sizeof(char [22l]) /*22ul*/ );
    snprintf(buf, sizeof(char [22l]) /*22ul*/  - (unsigned long int)1, "%lu", current->con->id);
    xmlNewChild(listenernode, (struct _xmlNs *)(void *)0, (unsigned char *)"ID", (unsigned char *)buf);
    if(!(current->username == ((char *)NULL)))
      xmlNewChild(listenernode, (struct _xmlNs *)(void *)0, (unsigned char *)"username", (unsigned char *)current->username);

    client_node=avl_get_next(client_node);
  }
  avl_tree_unlock(source->client_tree);
  admin_send_response(doc, client, response, "listclients.xsl");
  xmlFreeDoc(doc);
}

// command_stats
// file admin.c line 1065
static void command_stats(struct _client_tag *client, const char *mount, signed int response)
{
  struct _xmlDoc *doc;
  log_write(errorlog, (unsigned int)4, "admin/", "command_stats", "Stats request, sending xml stats");
  doc=stats_get_xml(1, mount);
  admin_send_response(doc, client, response, "stats.xsl");
  xmlFreeDoc(doc);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// command_updatemetadata
// file admin.c line 1112
static void command_updatemetadata(struct _client_tag *client, struct source_tag *source, signed int response)
{
  struct _xmlDoc *doc;
  struct _xmlNode *node;
  struct _xmlNode *srcnode;
  doc=xmlNewDoc((unsigned char *)"1.0");
  node=xmlNewDocNode(doc, (struct _xmlNs *)(void *)0, (unsigned char *)"icestats", (const unsigned char *)(void *)0);
  srcnode=xmlNewChild(node, (struct _xmlNs *)(void *)0, (unsigned char *)"source", (const unsigned char *)(void *)0);
  xmlSetProp(srcnode, (unsigned char *)"mount", (unsigned char *)source->mount);
  xmlDocSetRootElement(doc, node);
  admin_send_response(doc, client, response, "updatemetadata.xsl");
  xmlFreeDoc(doc);
}

// compare_ip
// file connection.c line 126
static signed int compare_ip(void *arg, void *a, void *b)
{
  const char *ip = (const char *)a;
  const char *pattern = (const char *)b;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(pattern, ip);
  return return_value_strcmp_1;
}

// compare_users
// file auth_htpasswd.c line 86
static signed int compare_users(void *arg, void *a, void *b)
{
  struct anonymous_22 *user1 = (struct anonymous_22 *)a;
  struct anonymous_22 *user2 = (struct anonymous_22 *)b;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(user1->name, user2->name);
  return return_value_strcmp_1;
}

// complete_buffer
// file format_ogg.c line 342
static struct _refbuf_tag * complete_buffer(struct source_tag *source, struct _refbuf_tag *refbuf)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)source->format->_state;
  struct _refbuf_tag *header = ogg_info->header_pages;
  for( ; !(header == ((struct _refbuf_tag *)NULL)); header = header->next)
    refbuf_addref(header);
  refbuf->associated = ogg_info->header_pages;
  if(!(ogg_info->log_metadata == 0))
  {
    update_comments(source);
    ogg_info->log_metadata = 0;
  }

  if(ogg_info->codec_sync == ((struct ogg_codec_tag *)NULL))
    refbuf->sync_point = 1;

  return refbuf;
}

// complete_read
// file format_mp3.c line 468
static signed int complete_read(struct source_tag *source)
{
  signed int bytes;
  struct _format_plugin_tag *format = source->format;
  struct anonymous_5 *source_mp3 = (struct anonymous_5 *)format->_state;
  char *buf;
  struct _refbuf_tag *refbuf;
  if(source_mp3->read_data == ((struct _refbuf_tag *)NULL))
  {
    source_mp3->read_data=refbuf_new((unsigned int)1400);
    source_mp3->read_count = 0;
  }

  buf = source_mp3->read_data->data + (signed long int)source_mp3->read_count;
  bytes=client_read_bytes(source->client, (void *)buf, (unsigned int)(1400 - source_mp3->read_count));
  if(!(bytes >= 0))
  {
    if(!(source->client->con->error == 0))
    {
      refbuf_release(source_mp3->read_data);
      source_mp3->read_data = (struct _refbuf_tag *)(void *)0;
    }

    return 0;
  }

  else
  {
    source_mp3->read_count = source_mp3->read_count + bytes;
    refbuf = source_mp3->read_data;
    refbuf->len = (unsigned int)source_mp3->read_count;
    format->read_bytes = format->read_bytes + (unsigned long int)bytes;
    if(!(source_mp3->read_count >= 1400))
    {
      if(source_mp3->read_count == 0)
      {
        refbuf_release(source_mp3->read_data);
        source_mp3->read_data = (struct _refbuf_tag *)(void *)0;
      }

      return 0;
    }

    else
      return 1;
  }
}

// config_clear
// file cfgfile.c line 229
void config_clear(struct ice_config_tag *c)
{
  struct ice_config_dir_tag *dirnode;
  struct ice_config_dir_tag *nextdirnode;
  struct _relay_server *relay;
  struct _relay_server *nextrelay;
  struct _mount_proxy *mount;
  struct _mount_proxy *nextmount;
  struct _aliases *alias;
  struct _aliases *nextalias;
  signed int i;
  free((void *)c->config_filename);
  xmlFree((void *)c->server_id);
  if(!(c->location == ((char *)NULL)))
    xmlFree((void *)c->location);

  if(!(c->admin == ((char *)NULL)))
    xmlFree((void *)c->admin);

  if(!(c->source_password == ((char *)NULL)))
    xmlFree((void *)c->source_password);

  if(!(c->admin_username == ((char *)NULL)))
    xmlFree((void *)c->admin_username);

  if(!(c->admin_password == ((char *)NULL)))
    xmlFree((void *)c->admin_password);

  if(!(c->relay_username == ((char *)NULL)))
    xmlFree((void *)c->relay_username);

  if(!(c->relay_password == ((char *)NULL)))
    xmlFree((void *)c->relay_password);

  if(!(c->hostname == ((char *)NULL)))
    xmlFree((void *)c->hostname);

  if(!(c->base_dir == ((char *)NULL)))
    xmlFree((void *)c->base_dir);

  if(!(c->log_dir == ((char *)NULL)))
    xmlFree((void *)c->log_dir);

  if(!(c->webroot_dir == ((char *)NULL)))
    xmlFree((void *)c->webroot_dir);

  if(!(c->adminroot_dir == ((char *)NULL)))
    xmlFree((void *)c->adminroot_dir);

  if(!(c->cert_file == ((char *)NULL)))
    xmlFree((void *)c->cert_file);

  if(!(c->cipher_list == ((char *)NULL)))
    xmlFree((void *)c->cipher_list);

  if(!(c->pidfile == ((char *)NULL)))
    xmlFree((void *)c->pidfile);

  if(!(c->banfile == ((char *)NULL)))
    xmlFree((void *)c->banfile);

  if(!(c->allowfile == ((char *)NULL)))
    xmlFree((void *)c->allowfile);

  if(!(c->playlist_log == ((char *)NULL)))
    xmlFree((void *)c->playlist_log);

  if(!(c->access_log == ((char *)NULL)))
    xmlFree((void *)c->access_log);

  if(!(c->error_log == ((char *)NULL)))
    xmlFree((void *)c->error_log);

  if(!(c->shoutcast_mount == ((char *)NULL)))
    xmlFree((void *)c->shoutcast_mount);

  if(!(c->master_server == ((char *)NULL)))
    xmlFree((void *)c->master_server);

  if(!(c->master_username == ((char *)NULL)))
    xmlFree((void *)c->master_username);

  if(!(c->master_password == ((char *)NULL)))
    xmlFree((void *)c->master_password);

  if(!(c->user == ((char *)NULL)))
    xmlFree((void *)c->user);

  if(!(c->group == ((char *)NULL)))
    xmlFree((void *)c->group);

  if(!(c->mimetypes_fn == ((char *)NULL)))
    xmlFree((void *)c->mimetypes_fn);

  c->listen_sock=config_clear_listener(c->listen_sock);
  thread_mutex_lock_c(&_locks.relay_lock, 278, "cfgfile.c");
  relay = c->relay;
  if(!(relay == ((struct _relay_server *)NULL)))
  {
    nextrelay = relay->next;
    xmlFree((void *)relay->server);
    xmlFree((void *)relay->mount);
    xmlFree((void *)relay->localmount);
    free((void *)relay);
    relay = nextrelay;
  }

  thread_mutex_unlock_c(&_locks.relay_lock, 288, "cfgfile.c");
  mount = c->mounts;
  if(!(mount == ((struct _mount_proxy *)NULL)))
  {
    nextmount = mount->next;
    config_clear_mount(mount);
    mount = nextmount;
  }

  alias = c->aliases;
  if(!(alias == ((struct _aliases *)NULL)))
  {
    nextalias = alias->next;
    xmlFree((void *)alias->source);
    xmlFree((void *)alias->destination);
    xmlFree((void *)alias->bind_address);
    free((void *)alias);
    alias = nextalias;
  }

  dirnode = c->dir_list;
  if(!(dirnode == ((struct ice_config_dir_tag *)NULL)))
  {
    nextdirnode = dirnode->next;
    xmlFree((void *)dirnode->host);
    free((void *)dirnode);
    dirnode = nextdirnode;
  }

  i = 0;
  if(!(i >= c->num_yp_directories))
  {
    xmlFree((void *)c->yp_url[(signed long int)i]);
    i = i + 1;
  }

  config_clear_http_header(c->http_headers);
  memset((void *)c, 0, sizeof(struct ice_config_tag) /*792ul*/ );
}

// config_clear_http_header
// file cfgfile.c line 128
static void config_clear_http_header(struct ice_config_http_header_tag *header)
{
  struct ice_config_http_header_tag *old;
  if(!(header == ((struct ice_config_http_header_tag *)NULL)))
  {
    xmlFree((void *)header->name);
    xmlFree((void *)header->value);
    old = header;
    header = header->next;
    free((void *)old);
  }

}

// config_clear_listener
// file cfgfile.c line 216
struct _listener_t * config_clear_listener(struct _listener_t *listener)
{
  struct _listener_t *next = (struct _listener_t *)(void *)0;
  if(!(listener == ((struct _listener_t *)NULL)))
  {
    next = listener->next;
    if(!(listener->bind_address == ((char *)NULL)))
      xmlFree((void *)listener->bind_address);

    if(!(listener->shoutcast_mount == ((char *)NULL)))
      xmlFree((void *)listener->shoutcast_mount);

    free((void *)listener);
  }

  return next;
}

// config_clear_mount
// file cfgfile.c line 180
static void config_clear_mount(struct _mount_proxy *mount)
{
  struct _config_options *option;
  if(!(mount->mountname == ((char *)NULL)))
    xmlFree((void *)mount->mountname);

  if(!(mount->username == ((char *)NULL)))
    xmlFree((void *)mount->username);

  if(!(mount->password == ((char *)NULL)))
    xmlFree((void *)mount->password);

  if(!(mount->dumpfile == ((char *)NULL)))
    xmlFree((void *)mount->dumpfile);

  if(!(mount->intro_filename == ((char *)NULL)))
    xmlFree((void *)mount->intro_filename);

  if(!(mount->on_connect == ((char *)NULL)))
    xmlFree((void *)mount->on_connect);

  if(!(mount->on_disconnect == ((char *)NULL)))
    xmlFree((void *)mount->on_disconnect);

  if(!(mount->fallback_mount == ((char *)NULL)))
    xmlFree((void *)mount->fallback_mount);

  if(!(mount->stream_name == ((char *)NULL)))
    xmlFree((void *)mount->stream_name);

  if(!(mount->stream_description == ((char *)NULL)))
    xmlFree((void *)mount->stream_description);

  if(!(mount->stream_url == ((char *)NULL)))
    xmlFree((void *)mount->stream_url);

  if(!(mount->stream_genre == ((char *)NULL)))
    xmlFree((void *)mount->stream_genre);

  if(!(mount->bitrate == ((char *)NULL)))
    xmlFree((void *)mount->bitrate);

  if(!(mount->type == ((char *)NULL)))
    xmlFree((void *)mount->type);

  if(!(mount->charset == ((char *)NULL)))
    xmlFree((void *)mount->charset);

  if(!(mount->cluster_password == ((char *)NULL)))
    xmlFree((void *)mount->cluster_password);

  if(!(mount->auth_type == ((char *)NULL)))
    xmlFree((void *)mount->auth_type);

  option = mount->auth_options;
  while(!(option == ((struct _config_options *)NULL)))
  {
    struct _config_options *nextopt = option->next;
    if(!(option->name == ((char *)NULL)))
      xmlFree((void *)option->name);

    if(!(option->value == ((char *)NULL)))
      xmlFree((void *)option->value);

    free((void *)option);
    option = nextopt;
  }
  auth_release(mount->auth);
  config_clear_http_header(mount->http_headers);
  free((void *)mount);
}

// config_copy_http_header
// file cfgfile.c line 140
static inline struct ice_config_http_header_tag * config_copy_http_header(struct ice_config_http_header_tag *header)
{
  struct ice_config_http_header_tag *ret = (struct ice_config_http_header_tag *)(void *)0;
  struct ice_config_http_header_tag *cur = (struct ice_config_http_header_tag *)(void *)0;
  struct ice_config_http_header_tag *old = (struct ice_config_http_header_tag *)(void *)0;
  _Bool tmp_if_expr_5;
  while(!(header == ((struct ice_config_http_header_tag *)NULL)))
  {
    if(!(cur == ((struct ice_config_http_header_tag *)NULL)))
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ice_config_http_header_tag) /*40ul*/ );
      cur->next = (struct ice_config_http_header_tag *)return_value_calloc_1;
      old = cur;
      cur = cur->next;
    }

    else
    {
      void *return_value_calloc_2;
      return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct ice_config_http_header_tag) /*40ul*/ );
      ret = (struct ice_config_http_header_tag *)return_value_calloc_2;
      cur = ret;
    }
    if(cur == ((struct ice_config_http_header_tag *)NULL))
      return ret;

    cur->type = header->type;
    unsigned char *return_value_xmlCharStrdup_3;
    return_value_xmlCharStrdup_3=xmlCharStrdup(header->name);
    cur->name = (char *)return_value_xmlCharStrdup_3;
    unsigned char *return_value_xmlCharStrdup_4;
    return_value_xmlCharStrdup_4=xmlCharStrdup(header->value);
    cur->value = (char *)return_value_xmlCharStrdup_4;
    cur->status = header->status;
    if(cur->name == ((char *)NULL))
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(cur->value != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
    {
      if(!(cur->name == ((char *)NULL)))
        xmlFree((void *)cur->name);

      if(!(cur->value == ((char *)NULL)))
        xmlFree((void *)cur->value);

      if(!(old == ((struct ice_config_http_header_tag *)NULL)))
        old->next = (struct ice_config_http_header_tag *)(void *)0;

      else
        ret = (struct ice_config_http_header_tag *)(void *)0;
      free((void *)cur);
      return ret;
    }

    header = header->next;
  }
  return ret;
}

// config_find_mount
// file cfgfile.c line 1429
struct _mount_proxy * config_find_mount(struct ice_config_tag *config, const char *mount, enum _mount_type type)
{
  struct _mount_proxy *mountinfo = config->mounts;
  _Bool tmp_if_expr_1;
  signed int return_value_strcmp_2;
  for( ; !(mountinfo == ((struct _mount_proxy *)NULL)); mountinfo = mountinfo->next)
    if(mountinfo->mounttype == type)
    {
      if(mount == ((const char *)NULL))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = mountinfo->mountname == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        break;

      if((signed int)mountinfo->mounttype == MOUNT_TYPE_NORMAL)
      {
        return_value_strcmp_2=strcmp(mountinfo->mountname, mount);
        if(return_value_strcmp_2 == 0)
          break;

      }

      signed int return_value_fnmatch_3;
      return_value_fnmatch_3=fnmatch(mountinfo->mountname, mount, 1 << 0);
      if(return_value_fnmatch_3 == 0)
        break;

    }

  if(mountinfo == ((struct _mount_proxy *)NULL) && (signed int)type == MOUNT_TYPE_NORMAL)
    mountinfo=config_find_mount(config, mount, (enum _mount_type)MOUNT_TYPE_DEFAULT);

  return mountinfo;
}

// config_get_config
// file cfgfile.c line 385
struct ice_config_tag * config_get_config(void)
{
  thread_rwlock_rlock_c(&_locks.config_lock, 387, "cfgfile.c");
  return &_current_configuration;
}

// config_get_config_unlocked
// file cfgfile.c line 402
struct ice_config_tag * config_get_config_unlocked(void)
{
  return &_current_configuration;
}

// config_get_listen_sock
// file cfgfile.c line 1463
struct _listener_t * config_get_listen_sock(struct ice_config_tag *config, struct connection_tag *con)
{
  struct _listener_t *listener;
  signed int i = 0;
  listener = config->listen_sock;
  while(!(listener == ((struct _listener_t *)NULL)))
    if(i >= global.server_sockets)
      listener = (struct _listener_t *)(void *)0;

    else
    {
      if(global.serversock[(signed long int)i] == con->serversock)
        break;

      listener = listener->next;
      i = i + 1;
    }
  return listener;
}

// config_grab_config
// file cfgfile.c line 391
struct ice_config_tag * config_grab_config(void)
{
  thread_rwlock_wlock_c(&_locks.config_lock, 393, "cfgfile.c");
  return &_current_configuration;
}

// config_init_configuration
// file cfgfile.c line 122
void config_init_configuration(struct ice_config_tag *configuration)
{
  memset((void *)configuration, 0, sizeof(struct ice_config_tag) /*792ul*/ );
  _set_defaults(configuration);
}

// config_initial_parse_file
// file cfgfile.c line 328
signed int config_initial_parse_file(const char *filename)
{
  signed int return_value_config_parse_file_1;
  return_value_config_parse_file_1=config_parse_file(filename, &_current_configuration);
  return return_value_config_parse_file_1;
}

// config_initialize
// file cfgfile.c line 111
void config_initialize(void)
{
  create_locks();
}

// config_locks
// file cfgfile.c line 375
struct anonymous_17 * config_locks(void)
{
  return &_locks;
}

// config_parse_cmdline
// file cfgfile.c line 370
signed int config_parse_cmdline(signed int arg, char **argv)
{
  return 0;
}

// config_parse_file
// file cfgfile.c line 334
signed int config_parse_file(const char *filename, struct ice_config_tag *configuration)
{
  struct _xmlDoc *doc;
  struct _xmlNode *node;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(filename == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strcmp_1=strcmp(filename, "");
    tmp_if_expr_2 = return_value_strcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return -1;

  else
  {
    doc=xmlParseFile(filename);
    if(doc == ((struct _xmlDoc *)NULL))
      return -4;

    else
    {
      node=xmlDocGetRootElement(doc);
      if(node == ((struct _xmlNode *)NULL))
      {
        xmlFreeDoc(doc);
        return -2;
      }

      else
      {
        signed int return_value_xmlStrcmp_3;
        return_value_xmlStrcmp_3=xmlStrcmp(node->name, (unsigned char *)"icecast");
        if(!(return_value_xmlStrcmp_3 == 0))
        {
          xmlFreeDoc(doc);
          return -3;
        }

        else
        {
          config_init_configuration(configuration);
          configuration->config_filename=strdup(filename);
          _parse_root(doc, node->children, configuration);
          xmlFreeDoc(doc);
          _merge_mounts_all(configuration);
          return 0;
        }
      }
    }
  }
}

// config_release_config
// file cfgfile.c line 380
void config_release_config(void)
{
  thread_rwlock_unlock_c(&_locks.config_lock, 382, "cfgfile.c");
}

// config_set_config
// file cfgfile.c line 398
void config_set_config(struct ice_config_tag *config)
{
  memcpy((void *)&_current_configuration, (const void *)config, sizeof(struct ice_config_tag) /*792ul*/ );
}

// config_shutdown
// file cfgfile.c line 115
void config_shutdown(void)
{
  config_get_config();
  config_clear(&_current_configuration);
  config_release_config();
  release_locks();
}

// connection_accept_loop
// file connection.h line 57
void connection_accept_loop(void)
{
  struct connection_tag *con;
  struct ice_config_tag *config;
  signed int duration = 300;
  config=config_get_config();
  get_ssl_certificate(config);
  config_release_config();
  _Bool tmp_if_expr_4;
  signed int return_value_sock_set_nodelay_3;
  while(global.running == 1)
  {
    con=_accept_connection(duration);
    if(!(con == ((struct connection_tag *)NULL)))
    {
      struct client_queue_tag *node;
      struct ice_config_tag *connection_accept_loop__1__1__1__config;
      struct _client_tag *client = (struct _client_tag *)(void *)0;
      struct _listener_t *listener;
      global_lock();
      signed int return_value_client_create_1;
      return_value_client_create_1=client_create(&client, con, (struct http_parser_tag *)(void *)0);
      if(!(return_value_client_create_1 >= 0))
      {
        global_unlock();
        client_send_403(client, "Icecast connection limit reached");
        thread_sleep((unsigned long int)400000);
        continue;
      }

      client->refbuf->data[(signed long int)(4096 - 1)] = (char)0;
      signed int return_value_sock_set_blocking_2;
      return_value_sock_set_blocking_2=sock_set_blocking(client->con->sock, 0);
      if(!(return_value_sock_set_blocking_2 == 0))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_sock_set_nodelay_3=sock_set_nodelay(client->con->sock);
        tmp_if_expr_4 = return_value_sock_set_nodelay_3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
      {
        global_unlock();
        log_write(errorlog, (unsigned int)2, "connection/", "connection_accept_loop", "failed to set tcp options on client connection, dropping");
        client_destroy(client);
        continue;
      }

      void *return_value_calloc_5;
      return_value_calloc_5=calloc((unsigned long int)1, sizeof(struct client_queue_tag) /*40ul*/ );
      node = (struct client_queue_tag *)return_value_calloc_5;
      if(node == ((struct client_queue_tag *)NULL))
      {
        global_unlock();
        client_destroy(client);
        continue;
      }

      node->client = client;
      connection_accept_loop__1__1__1__config=config_get_config();
      listener=config_get_listen_sock(connection_accept_loop__1__1__1__config, client->con);
      if(!(listener == ((struct _listener_t *)NULL)))
      {
        if(!(listener->shoutcast_compat == 0))
          node->shoutcast = 1;

        if(!(listener->ssl == 0))
        {
          if(!(ssl_ok == 0))
            connection_uses_ssl(client->con);

        }

        if(!(listener->shoutcast_mount == ((char *)NULL)))
          node->shoutcast_mount=strdup(listener->shoutcast_mount);

      }

      global_unlock();
      config_release_config();
      _add_request_queue(node);
      stats_event_inc((const char *)(void *)0, "connections");
      duration = 5;
    }

    else
      if(_req_queue == ((volatile struct client_queue_tag *)NULL))
        duration = 300;

    process_request_queue();
  }
  thread_cond_broadcast_c(&global.shutdown_cond, 789, "connection.c");
  thread_rwlock_wlock_c(&_source_shutdown_rwlock, 792, "connection.c");
  thread_rwlock_unlock_c(&_source_shutdown_rwlock, 793, "connection.c");
}

// connection_check_admin_pass
// file connection.c line 974
signed int connection_check_admin_pass(struct http_parser_tag *parser)
{
  signed int ret;
  struct ice_config_tag *config;
  config=config_get_config();
  char *pass = config->admin_password;
  char *user = config->admin_username;
  const char *protocol;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(pass == ((char *)NULL) || user == ((char *)NULL))
  {
    config_release_config();
    return 0;
  }

  else
  {
    protocol=httpp_getvar(parser, "__protocol");
    if(!(protocol == ((const char *)NULL)))
    {
      return_value_strcmp_1=strcmp(protocol, "ICY");
      tmp_if_expr_2 = return_value_strcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      ret=_check_pass_icy(parser, pass);

    else
      ret=_check_pass_http(parser, user, pass);
    config_release_config();
    return ret;
  }
}

// connection_check_pass
// file connection.c line 1016
signed int connection_check_pass(struct http_parser_tag *parser, const char *user, const char *pass)
{
  signed int ret;
  const char *protocol;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(pass == ((const char *)NULL))
  {
    log_write(errorlog, (unsigned int)2, "connection/", "connection_check_pass", "No source password set, rejecting source");
    return -1;
  }

  else
  {
    protocol=httpp_getvar(parser, "__protocol");
    if(!(protocol == ((const char *)NULL)))
    {
      return_value_strcmp_1=strcmp(protocol, "ICY");
      tmp_if_expr_2 = !(return_value_strcmp_1 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      ret=_check_pass_icy(parser, pass);

    else
    {
      ret=_check_pass_http(parser, user, pass);
      if(ret == 0)
      {
        struct ice_config_tag *config;
        config=config_get_config_unlocked();
        if(!(config->ice_login == 0))
        {
          ret=_check_pass_ice(parser, pass);
          if(!(ret == 0))
            log_write(errorlog, (unsigned int)2, "connection/", "connection_check_pass", "Source is using deprecated icecast login");

        }

      }

    }
    return ret;
  }
}

// connection_check_relay_pass
// file connection.c line 996
signed int connection_check_relay_pass(struct http_parser_tag *parser)
{
  signed int ret;
  struct ice_config_tag *config;
  config=config_get_config();
  char *pass = config->relay_password;
  char *user = config->relay_username;
  if(pass == ((char *)NULL) || user == ((char *)NULL))
  {
    config_release_config();
    return 0;
  }

  else
  {
    ret=_check_pass_http(parser, user, pass);
    config_release_config();
    return ret;
  }
}

// connection_close
// file connection.c line 1490
void connection_close(struct connection_tag *con)
{
  sock_close(con->sock);
  if(!(con->ip == ((char *)NULL)))
    free((void *)con->ip);

  if(!(con->host == ((char *)NULL)))
    free((void *)con->host);

  free((void *)con);
}

// connection_complete_source
// file connection.c line 800
signed int connection_complete_source(struct source_tag *source, signed int response)
{
  struct ice_config_tag *config;
  global_lock();
  log_write(errorlog, (unsigned int)4, "connection/", "connection_complete_source", "sources count is %d", global.sources);
  config=config_get_config();
  if(!(global.sources >= config->source_limit))
  {
    const char *contenttype;
    const char *expectcontinue;
    struct _mount_proxy *mountinfo;
    enum _format_type_tag format_type;
    contenttype=httpp_getvar(source->parser, "content-type");
    if(!(contenttype == ((const char *)NULL)))
    {
      format_type=format_get_type(contenttype);
      if((signed int)format_type == FORMAT_ERROR)
      {
        config_release_config();
        global_unlock();
        if(!(response == 0))
        {
          client_send_403(source->client, "Content-type not supported");
          source->client = (struct _client_tag *)(void *)0;
        }

        log_write(errorlog, (unsigned int)2, "connection/", "connection_complete_source", "Content-type \"%s\" not supported, dropping source", contenttype);
        return -1;
      }

    }

    else
      if((signed int)source->parser->req_type == httpp_req_put)
      {
        config_release_config();
        global_unlock();
        if(!(response == 0))
        {
          client_send_403(source->client, "No Content-type given");
          source->client = (struct _client_tag *)(void *)0;
        }

        log_write(errorlog, (unsigned int)1, "connection/", "connection_complete_source", "Content-type not given in PUT request, dropping source");
        return -1;
      }

      else
      {
        log_write(errorlog, (unsigned int)1, "connection/", "connection_complete_source", "No content-type header, falling back to backwards compatibility mode for icecast 1.x relays. Assuming content is mp3. This behaviour is deprecated and the source client will NOT work with future Icecast versions!");
        format_type = (enum _format_type_tag)FORMAT_TYPE_GENERIC;
      }
    signed int return_value_format_get_plugin_1;
    return_value_format_get_plugin_1=format_get_plugin(format_type, source);
    if(!(return_value_format_get_plugin_1 >= 0))
    {
      global_unlock();
      config_release_config();
      if(!(response == 0))
      {
        client_send_403(source->client, "internal format allocation problem");
        source->client = (struct _client_tag *)(void *)0;
      }

      log_write(errorlog, (unsigned int)2, "connection/", "connection_complete_source", "plugin format failed for \"%s\"", source->mount);
      return -1;
    }

    expectcontinue=httpp_getvar(source->parser, "expect");
    if(!(expectcontinue == ((const char *)NULL)))
    {
      char *return_value_strcasestr_2;
      return_value_strcasestr_2=strcasestr(expectcontinue, "100-continue");
      if(!(return_value_strcasestr_2 == ((char *)NULL)))
        client_send_100(source->client);

    }

    global.sources = global.sources + 1;
    stats_event_args((const char *)(void *)0, "sources", "%d", global.sources);
    global_unlock();
    source->running = 1;
    mountinfo=config_find_mount(config, source->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
    source_update_settings(config, source, mountinfo);
    config_release_config();
    slave_rebuild_mounts();
    source->shutdown_rwlock = &_source_shutdown_rwlock;
    log_write(errorlog, (unsigned int)4, "connection/", "connection_complete_source", "source is ready to start");
    return 0;
  }

  log_write(errorlog, (unsigned int)2, "connection/", "connection_complete_source", "Request to add source when maximum source limit reached %d", global.sources);
  global_unlock();
  config_release_config();
  if(!(response == 0))
  {
    client_send_403(source->client, "too many sources connected");
    source->client = (struct _client_tag *)(void *)0;
  }

  return -1;
}

// connection_create
// file connection.c line 416
struct connection_tag * connection_create(signed int sock, signed int serversock, char *ip)
{
  struct connection_tag *con;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct connection_tag) /*80ul*/ );
  con = (struct connection_tag *)return_value_calloc_1;
  if(!(con == ((struct connection_tag *)NULL)))
  {
    con->sock = sock;
    con->serversock = serversock;
    con->con_time=time((signed long int *)(void *)0);
    con->id=_next_connection_id();
    con->ip = ip;
    con->read = connection_read;
    con->send = connection_send;
  }

  return con;
}

// connection_initialize
// file connection.h line 55
void connection_initialize(void)
{
  if(_initialized == 0)
  {
    thread_spin_create(&_connection_lock);
    thread_mutex_create_c(&move_clients_mutex, 147, "connection.c");
    thread_rwlock_create_c(&_source_shutdown_rwlock, 148, "connection.c");
    thread_cond_create_c(&global.shutdown_cond, 149, "connection.c");
    _req_queue = (volatile struct client_queue_tag *)(void *)0;
    _req_queue_tail = &_req_queue;
    _con_queue = (volatile struct client_queue_tag *)(void *)0;
    _con_queue_tail = &_con_queue;
    banned_ip.contents = (struct _avl_tree *)(void *)0;
    banned_ip.file_mtime = (signed long int)0;
    allowed_ip.contents = (struct _avl_tree *)(void *)0;
    allowed_ip.file_mtime = (signed long int)0;
    _initialized = 1;
  }

}

// connection_read
// file connection.c line 297
static signed int connection_read(struct connection_tag *con, void *buf, unsigned long int len)
{
  signed int bytes;
  bytes=sock_read_bytes(con->sock, (char *)buf, len);
  if(bytes == 0)
    con->error = 1;

  signed int return_value_sock_error_1;
  signed int return_value_sock_recoverable_2;
  if(bytes == -1)
  {
    return_value_sock_error_1=sock_error();
    return_value_sock_recoverable_2=sock_recoverable(return_value_sock_error_1);
    if(return_value_sock_recoverable_2 == 0)
      con->error = 1;

  }

  return bytes;
}

// connection_send
// file connection.c line 307
static signed int connection_send(struct connection_tag *con, const void *buf, unsigned long int len)
{
  signed int bytes;
  bytes=sock_write_bytes(con->sock, buf, len);
  if(!(bytes >= 0))
  {
    signed int return_value_sock_error_1;
    return_value_sock_error_1=sock_error();
    signed int return_value_sock_recoverable_2;
    return_value_sock_recoverable_2=sock_recoverable(return_value_sock_error_1);
    if(return_value_sock_recoverable_2 == 0)
      con->error = 1;

  }

  else
    con->sent_bytes = con->sent_bytes + (unsigned long int)bytes;
  return bytes;
}

// connection_setup_sockets
// file connection.h line 58
signed int connection_setup_sockets(struct ice_config_tag *config)
{
  signed int count = 0;
  struct _listener_t *listener;
  struct _listener_t **prev;
  free((void *)banned_ip.filename);
  banned_ip.filename = (char *)(void *)0;
  free((void *)allowed_ip.filename);
  allowed_ip.filename = (char *)(void *)0;
  global_lock();
  if(!(global.serversock == ((signed int *)NULL)))
  {
    for( ; !(count >= global.server_sockets); count = count + 1)
      sock_close(global.serversock[(signed long int)count]);
    free((void *)global.serversock);
    global.serversock = (signed int *)(void *)0;
  }

  if(config == ((struct ice_config_tag *)NULL))
  {
    global_unlock();
    return 0;
  }

  else
  {
    if(!(config->banfile == ((char *)NULL)))
      banned_ip.filename=strdup(config->banfile);

    if(!(config->allowfile == ((char *)NULL)))
      allowed_ip.filename=strdup(config->allowfile);

    count = 0;
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)config->listen_sock_count, sizeof(signed int) /*4ul*/ );
    global.serversock = (signed int *)return_value_calloc_1;
    listener = config->listen_sock;
    prev = &config->listen_sock;
    while(!(listener == ((struct _listener_t *)NULL)))
    {
      signed int successful = 0;
      do
      {
        signed int sock;
        sock=sock_get_server_socket(listener->port, listener->bind_address);
        if(sock == -1)
          break;

        signed int return_value_sock_listen_2;
        return_value_sock_listen_2=sock_listen(sock, 5);
        if(return_value_sock_listen_2 == -1)
        {
          sock_close(sock);
          break;
        }

        if(!(listener->so_sndbuf == 0))
          sock_set_send_buffer(sock, listener->so_sndbuf);

        sock_set_blocking(sock, 0);
        successful = 1;
        global.serversock[(signed long int)count] = sock;
        count = count + 1;
      }
      while((_Bool)0);
      if(successful == 0)
      {
        if(!(listener->bind_address == ((char *)NULL)))
          log_write(errorlog, (unsigned int)1, "connection/", "connection_setup_sockets", "Could not create listener socket on port %d bind %s", listener->port, listener->bind_address);

        else
          log_write(errorlog, (unsigned int)1, "connection/", "connection_setup_sockets", "Could not create listener socket on port %d", listener->port);
        *prev=config_clear_listener(listener);
        listener = *prev;
      }

      else
      {
        if(!(listener->bind_address == ((char *)NULL)))
          log_write(errorlog, (unsigned int)3, "connection/", "connection_setup_sockets", "listener socket on port %d address %s", listener->port, listener->bind_address);

        else
          log_write(errorlog, (unsigned int)3, "connection/", "connection_setup_sockets", "listener socket on port %d", listener->port);
        prev = &listener->next;
        listener = listener->next;
      }
    }
    global.server_sockets = count;
    global_unlock();
    if(count == 0)
      log_write(errorlog, (unsigned int)1, "connection/", "connection_setup_sockets", "No listening sockets established");

    return count;
  }
}

// connection_shutdown
// file connection.h line 56
void connection_shutdown(void)
{
  if(!(_initialized == 0))
  {
    if(!(banned_ip.contents == ((struct _avl_tree *)NULL)))
      avl_tree_free(banned_ip.contents, free_filtered_ip);

    if(!(allowed_ip.contents == ((struct _avl_tree *)NULL)))
      avl_tree_free(allowed_ip.contents, free_filtered_ip);

    thread_cond_destroy(&global.shutdown_cond);
    thread_rwlock_destroy(&_source_shutdown_rwlock);
    thread_spin_destroy(&_connection_lock);
    thread_mutex_destroy(&move_clients_mutex);
    _initialized = 0;
  }

}

// connection_uses_ssl
// file connection.c line 436
void connection_uses_ssl(struct connection_tag *con)
{
  ;
}

// copy_ogg_packet
// file format_vorbis.c line 105
static struct anonymous_14 * copy_ogg_packet(struct anonymous_14 *packet)
{
  struct anonymous_14 *next;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_14) /*48ul*/ );
  next = (struct anonymous_14 *)return_value_malloc_1;
  if(!(next == ((struct anonymous_14 *)NULL)))
  {
    memcpy((void *)next, (const void *)packet, sizeof(struct anonymous_14) /*48ul*/ );
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)next->bytes);
    next->packet = (unsigned char *)return_value_malloc_2;
    if(!(next->packet == ((unsigned char *)NULL)))
    {
      memcpy((void *)next->packet, (const void *)packet->packet, (unsigned long int)next->bytes);
      return next;
    }

  }

  if(!(next == ((struct anonymous_14 *)NULL)))
    free((void *)next);

  return (struct anonymous_14 *)(void *)0;
}

// create_locks
// file cfgfile.c line 101
static void create_locks(void)
{
  thread_mutex_create_c(&_locks.relay_lock, 102, "cfgfile.c");
  thread_rwlock_create_c(&_locks.config_lock, 103, "cfgfile.c");
}

// create_log_entry
// file log.c line 361
static signed int create_log_entry(signed int log_id, const char *pre, const char *line)
{
  struct _log_entry_t *entry;
  signed int return_value_fprintf_1;
  if(loglist[(signed long int)log_id].keep_entries == 0u)
  {
    return_value_fprintf_1=fprintf(loglist[(signed long int)log_id].logfile, "%s%s\n", pre, line);
    return return_value_fprintf_1;
  }

  else
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct _log_entry_t) /*24ul*/ );
    entry = (struct _log_entry_t *)return_value_calloc_2;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(pre);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(line);
    entry->len = (unsigned int)(return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)2);
    void *return_value_malloc_5;
    return_value_malloc_5=malloc((unsigned long int)entry->len);
    entry->line = (char *)return_value_malloc_5;
    snprintf(entry->line, (unsigned long int)entry->len, "%s%s\n", pre, line);
    loglist[(signed long int)log_id].total = loglist[(signed long int)log_id].total + (unsigned long int)entry->len;
    fprintf(loglist[(signed long int)log_id].logfile, "%s", entry->line);
    *loglist[(signed long int)log_id].log_tail = entry;
    loglist[(signed long int)log_id].log_tail = &entry->next;
    if(loglist[(signed long int)log_id].entries >= loglist[(signed long int)log_id].keep_entries)
    {
      struct _log_entry_t *to_go = loglist[(signed long int)log_id].log_head;
      loglist[(signed long int)log_id].log_head = to_go->next;
      loglist[(signed long int)log_id].total = loglist[(signed long int)log_id].total - (unsigned long int)to_go->len;
      free((void *)to_go->line);
      free((void *)to_go);
    }

    else
      loglist[(signed long int)log_id].entries = loglist[(signed long int)log_id].entries + 1u;
    return (signed int)entry->len;
  }
}

// create_ogg_client_data
// file format_ogg.c line 459
static signed int create_ogg_client_data(struct source_tag *source, struct _client_tag *client)
{
  struct ogg_client *client_data;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_client) /*24ul*/ );
  client_data = (struct ogg_client *)return_value_calloc_1;
  signed int ret = -1;
  if(!(client_data == ((struct ogg_client *)NULL)))
  {
    client_data->headers_sent = 1;
    client->format_data = (void *)client_data;
    client->free_client_data = free_ogg_client_data;
    ret = 0;
  }

  return ret;
}

// create_yp_entry
// file yp.c line 555
static struct ypdata_tag * create_yp_entry(const char *mount)
{
  struct ypdata_tag *yp;
  char *s;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ypdata_tag) /*168ul*/ );
  yp = (struct ypdata_tag *)return_value_calloc_1;
  unsigned int len = (unsigned int)512;
  signed int ret;
  char *url;
  struct _mount_proxy *mountproxy = (struct _mount_proxy *)(void *)0;
  struct ice_config_tag *config;
  if(!(yp == ((struct ypdata_tag *)NULL)))
  {
    yp->mount=strdup(mount);
    yp->server_name=strdup("");
    yp->server_desc=strdup("");
    yp->server_genre=strdup("");
    yp->bitrate=strdup("");
    yp->server_type=strdup("");
    yp->cluster_password=strdup("");
    yp->url=strdup("");
    yp->current_song=strdup("");
    yp->audio_info=strdup("");
    yp->subtype=strdup("");
    yp->process = do_yp_add;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)len);
    url = (char *)return_value_malloc_2;
    if(!(url == ((char *)NULL)))
    {
      config=config_get_config();
      ret=snprintf(url, (unsigned long int)len, "http://%s:%d%s", config->hostname, config->port, mount);
      if(ret >= (signed int)len)
      {
        ret = ret + 1;
        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)url, (unsigned long int)ret);
        s = (char *)return_value_realloc_3;
        if(!(s == ((char *)NULL)))
          url = s;

        snprintf(url, (unsigned long int)ret, "http://%s:%d%s", config->hostname, config->port, mount);
      }

      mountproxy=config_find_mount(config, mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
      if(!(mountproxy == ((struct _mount_proxy *)NULL)))
      {
        if(!(mountproxy->cluster_password == ((char *)NULL)))
          add_yp_info(yp, (void *)mountproxy->cluster_password, 9);

      }

      config_release_config();
      yp->listen_url=util_url_escape(url);
      free((void *)url);
      if(!(yp->listen_url == ((char *)NULL)))
        return yp;

    }

  }

  yp_destroy_ypdata(yp);
  return (struct ypdata_tag *)(void *)0;
}

// default_key_printer
// file avl.c line 1075
static signed int default_key_printer(char *buffer, void *key)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buffer, (unsigned long int)256, "%p", key);
  return return_value_snprintf_1;
}

// delete_marked_yp
// file yp.c line 692
static void delete_marked_yp(struct yp_server *server)
{
  struct ypdata_tag *yp = server->mounts;
  struct ypdata_tag **prev = &server->mounts;
  while(!(yp == ((struct ypdata_tag *)NULL)))
  {
    if(!(yp->remove == 0))
    {
      struct ypdata_tag *to_go = yp;
      log_write(errorlog, (unsigned int)4, "yp/", "delete_marked_yp", "removed %s from YP server %s", yp->mount, server->url);
      *prev = yp->next;
      yp = yp->next;
      yp_destroy_ypdata(to_go);
      continue;
    }

    prev = &yp->next;
    yp = yp->next;
  }
}

// destroy_yp_server
// file yp.c line 179
static void destroy_yp_server(struct yp_server *server)
{
  if(!(server == ((struct yp_server *)NULL)))
  {
    log_write(errorlog, (unsigned int)4, "yp/", "destroy_yp_server", "Removing YP server entry for %s", server->url);
    if(!(server->curl == NULL))
      curl_easy_cleanup(server->curl);

    if(!(server->mounts == ((struct ypdata_tag *)NULL)))
      log_write(errorlog, (unsigned int)2, "yp/", "destroy_yp_server", "active ypdata not freed up");

    if(!(server->pending_mounts == ((struct ypdata_tag *)NULL)))
      log_write(errorlog, (unsigned int)2, "yp/", "destroy_yp_server", "pending ypdata not freed up");

    free((void *)server->url);
    free((void *)server->server_id);
    free((void *)server);
  }

}

// do_yp_add
// file yp.c line 370
static signed int do_yp_add(struct ypdata_tag *yp, char *s, unsigned int len)
{
  signed int ret;
  char *value;
  value=stats_get_value(yp->mount, "server_type");
  add_yp_info(yp, (void *)value, 7);
  free((void *)value);
  value=stats_get_value(yp->mount, "server_name");
  add_yp_info(yp, (void *)value, 1);
  free((void *)value);
  value=stats_get_value(yp->mount, "server_url");
  add_yp_info(yp, (void *)value, 4);
  free((void *)value);
  value=stats_get_value(yp->mount, "genre");
  add_yp_info(yp, (void *)value, 3);
  free((void *)value);
  value=stats_get_value(yp->mount, "bitrate");
  if(value == ((char *)NULL))
    value=stats_get_value(yp->mount, "ice-bitrate");

  add_yp_info(yp, (void *)value, 5);
  free((void *)value);
  value=stats_get_value(yp->mount, "server_description");
  add_yp_info(yp, (void *)value, 2);
  free((void *)value);
  value=stats_get_value(yp->mount, "subtype");
  add_yp_info(yp, (void *)value, 10);
  free((void *)value);
  value=stats_get_value(yp->mount, "audio_info");
  add_yp_info(yp, (void *)value, 6);
  free((void *)value);
  ret=snprintf(s, (unsigned long int)len, "action=add&sn=%s&genre=%s&cpswd=%s&desc=%s&url=%s&listenurl=%s&type=%s&stype=%s&b=%s&%s\r\n", yp->server_name, yp->server_genre, yp->cluster_password, yp->server_desc, yp->url, yp->listen_url, yp->server_type, yp->subtype, yp->bitrate, yp->audio_info);
  if(ret >= (signed int)len)
    return ret + 1;

  else
  {
    ret=send_to_yp("add", yp, s);
    if(ret == 0)
    {
      yp->process = do_yp_touch;
      signed long int return_value_time_1;
      return_value_time_1=time((signed long int *)(void *)0);
      yp->next_update = return_value_time_1 + (signed long int)5;
    }

    return ret;
  }
}

// do_yp_remove
// file yp.c line 347
static signed int do_yp_remove(struct ypdata_tag *yp, char *s, unsigned int len)
{
  signed int ret = 0;
  if(!(yp->sid == ((char *)NULL)))
  {
    ret=snprintf(s, (unsigned long int)len, "action=remove&sid=%s", yp->sid);
    if(ret >= (signed int)len)
      return ret + 1;

    log_write(errorlog, (unsigned int)3, "yp/", "do_yp_remove", "clearing up YP entry for %s", yp->mount);
    ret=send_to_yp("remove", yp, s);
    free((void *)yp->sid);
    yp->sid = (char *)(void *)0;
  }

  yp->remove = 1;
  yp->process = do_yp_add;
  yp_update = 1;
  return ret;
}

// do_yp_touch
// file yp.c line 427
static signed int do_yp_touch(struct ypdata_tag *yp, char *s, unsigned int len)
{
  unsigned int listeners = (unsigned int)0;
  unsigned int max_listeners = (unsigned int)1;
  char *val;
  char *artist;
  char *title;
  signed int ret;
  char *return_value_stats_get_value_1;
  return_value_stats_get_value_1=stats_get_value(yp->mount, "artist");
  artist = (char *)return_value_stats_get_value_1;
  char *return_value_stats_get_value_2;
  return_value_stats_get_value_2=stats_get_value(yp->mount, "title");
  title = (char *)return_value_stats_get_value_2;
  if(!(artist == ((char *)NULL)) || !(title == ((char *)NULL)))
  {
    char *song;
    char *separator = " - ";
    if(artist == ((char *)NULL))
    {
      artist=strdup("");
      separator = "";
    }

    if(title == ((char *)NULL))
      title=strdup("");

    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(artist);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(title);
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(separator);
    void *return_value_malloc_6;
    return_value_malloc_6=malloc(return_value_strlen_3 + return_value_strlen_4 + return_value_strlen_5 + (unsigned long int)1);
    song = (char *)return_value_malloc_6;
    if(!(song == ((char *)NULL)))
    {
      sprintf(song, "%s%s%s", artist, separator, title);
      add_yp_info(yp, (void *)song, 8);
      stats_event(yp->mount, "yp_currently_playing", song);
      free((void *)song);
    }

  }

  free((void *)artist);
  free((void *)title);
  char *return_value_stats_get_value_7;
  return_value_stats_get_value_7=stats_get_value(yp->mount, "listeners");
  val = (char *)return_value_stats_get_value_7;
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_atoi_8;
    return_value_atoi_8=atoi(val);
    listeners = (unsigned int)return_value_atoi_8;
    free((void *)val);
  }

  val=stats_get_value(yp->mount, "max_listeners");
  _Bool tmp_if_expr_11;
  signed int return_value_strcmp_10;
  if(val == ((char *)NULL))
    tmp_if_expr_11 = (_Bool)1;

  else
  {
    return_value_strcmp_10=strcmp(val, "unlimited");
    tmp_if_expr_11 = return_value_strcmp_10 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_13;
  signed int return_value_atoi_12;
  if(tmp_if_expr_11)
    tmp_if_expr_13 = (_Bool)1;

  else
  {
    return_value_atoi_12=atoi(val);
    tmp_if_expr_13 = return_value_atoi_12 < 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_atoi_9;
  if(tmp_if_expr_13)
    max_listeners = client_limit;

  else
  {
    return_value_atoi_9=atoi(val);
    max_listeners = (unsigned int)return_value_atoi_9;
  }
  free((void *)val);
  val=stats_get_value(yp->mount, "subtype");
  if(!(val == ((char *)NULL)))
  {
    add_yp_info(yp, (void *)val, 10);
    free((void *)val);
  }

  ret=snprintf(s, (unsigned long int)len, "action=touch&sid=%s&st=%s&listeners=%u&max_listeners=%u&stype=%s\r\n", yp->sid, yp->current_song, listeners, max_listeners, yp->subtype);
  if(ret >= (signed int)len)
    return ret + 1;

  else
  {
    signed int return_value_send_to_yp_14;
    return_value_send_to_yp_14=send_to_yp("touch", yp, s);
    if(return_value_send_to_yp_14 == 0)
    {
      yp->next_update = now + (signed long int)yp->touch_interval;
      return 0;
    }

    else
      return -1;
  }
}

// ebml_create
// file format_ebml.c line 288
static struct ebml_st * ebml_create()
{
  struct ebml_st *ebml;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ebml_st) /*56ul*/ );
  ebml = (struct ebml_st *)return_value_calloc_1;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, (unsigned long int)131072);
  ebml->header = (unsigned char *)return_value_calloc_2;
  void *return_value_calloc_3;
  return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)(4096 * 4));
  ebml->buffer = (unsigned char *)return_value_calloc_3;
  void *return_value_calloc_4;
  return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)4096);
  ebml->input_buffer = (unsigned char *)return_value_calloc_4;
  ebml->cluster_id = "\037Cu";
  ebml->cluster_start = -2;
  return ebml;
}

// ebml_create_client_data
// file format_ebml.c line 212
static signed int ebml_create_client_data(struct source_tag *source, struct _client_tag *client)
{
  struct ebml_client_data_st *ebml_client_data;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ebml_client_data_st) /*16ul*/ );
  ebml_client_data = (struct ebml_client_data_st *)return_value_calloc_1;
  struct ebml_source_state_st *ebml_source_state = (struct ebml_source_state_st *)source->format->_state;
  signed int ret = -1;
  if(!(ebml_client_data == ((struct ebml_client_data_st *)NULL)))
  {
    if(!(ebml_source_state->header == ((struct _refbuf_tag *)NULL)))
    {
      ebml_client_data->header = ebml_source_state->header;
      refbuf_addref(ebml_client_data->header);
      client->format_data = (void *)ebml_client_data;
      client->free_client_data = ebml_free_client_data;
      ret = 0;
    }

  }

  return ret;
}

// ebml_destroy
// file format_ebml.c line 278
static void ebml_destroy(struct ebml_st *ebml)
{
  free((void *)ebml->header);
  free((void *)ebml->input_buffer);
  free((void *)ebml->buffer);
  free((void *)ebml);
}

// ebml_free_client_data
// file format_ebml.c line 234
static void ebml_free_client_data(struct _client_tag *client)
{
  struct ebml_client_data_st *ebml_client_data = (struct ebml_client_data_st *)client->format_data;
  refbuf_release(ebml_client_data->header);
  free(client->format_data);
  client->format_data = (void *)0;
}

// ebml_free_plugin
// file format_ebml.c line 107
static void ebml_free_plugin(struct _format_plugin_tag *plugin)
{
  struct ebml_source_state_st *ebml_source_state = (struct ebml_source_state_st *)plugin->_state;
  refbuf_release(ebml_source_state->header);
  ebml_destroy(ebml_source_state->ebml);
  free((void *)ebml_source_state);
  free((void *)plugin);
}

// ebml_get_buffer
// file format_ebml.c line 160
static struct _refbuf_tag * ebml_get_buffer(struct source_tag *source)
{
  struct ebml_source_state_st *ebml_source_state = (struct ebml_source_state_st *)source->format->_state;
  struct _format_plugin_tag *format = source->format;
  char *data = (char *)(void *)0;
  signed int bytes = 0;
  struct _refbuf_tag *refbuf;
  signed int ret;
  while((_Bool)1)
  {
    bytes=ebml_read_space(ebml_source_state->ebml);
    if(bytes >= 1)
    {
      refbuf=refbuf_new((unsigned int)bytes);
      ebml_read(ebml_source_state->ebml, refbuf->data, bytes);
      if(ebml_source_state->header == ((struct _refbuf_tag *)NULL))
      {
        ebml_source_state->header = refbuf;
        continue;
      }

      signed int return_value_ebml_last_was_sync_1;
      return_value_ebml_last_was_sync_1=ebml_last_was_sync(ebml_source_state->ebml);
      if(!(return_value_ebml_last_was_sync_1 == 0))
        refbuf->sync_point = 1;

      return refbuf;
    }

    else
    {
      data=ebml_write_buffer(ebml_source_state->ebml, 4096);
      bytes=client_read_bytes(source->client, (void *)data, (unsigned int)4096);
      if(!(bytes >= 1))
      {
        ebml_wrote(ebml_source_state->ebml, 0);
        return (struct _refbuf_tag *)(void *)0;
      }

      format->read_bytes = format->read_bytes + (unsigned long int)bytes;
      ret=ebml_wrote(ebml_source_state->ebml, bytes);
      if(!(ret == bytes))
      {
        log_write(errorlog, (unsigned int)1, "format-ebml/", "ebml_get_buffer", "Problem processing stream");
        source->running = 0;
        return (struct _refbuf_tag *)(void *)0;
      }

    }
  }
}

// ebml_last_was_sync
// file format_ebml.c line 387
static signed int ebml_last_was_sync(struct ebml_st *ebml)
{
  if(ebml->cluster_start == 0)
  {
    ebml->cluster_start = ebml->cluster_start - 1;
    return 0;
  }

  else
    if(ebml->cluster_start == -1)
    {
      ebml->cluster_start = ebml->cluster_start - 1;
      return 1;
    }

    else
      return 0;
}

// ebml_read
// file format_ebml.c line 329
static signed int ebml_read(struct ebml_st *ebml, char *buffer, signed int len)
{
  signed int read_space;
  signed int to_read;
  if(!(len >= 1))
    return 0;

  else
  {
    if(ebml->header_read == 1)
    {
      if(ebml->cluster_start >= 1)
        read_space = ebml->cluster_start;

      else
        read_space = ebml->position - 4;
      if(!(read_space >= 1))
        return 0;

      if(read_space >= len)
        to_read = len;

      else
        to_read = read_space;
      memcpy((void *)buffer, (const void *)ebml->buffer, (unsigned long int)to_read);
      memmove((void *)ebml->buffer, (const void *)(ebml->buffer + (signed long int)to_read), (unsigned long int)(ebml->position - to_read));
      ebml->position = ebml->position - to_read;
      if(ebml->cluster_start >= 1)
        ebml->cluster_start = ebml->cluster_start - to_read;

    }

    else
      if(!(ebml->header_size == 0))
      {
        read_space = ebml->header_size - ebml->header_read_position;
        if(read_space >= len)
          to_read = len;

        else
          to_read = read_space;
        memcpy((void *)buffer, (const void *)ebml->header, (unsigned long int)to_read);
        ebml->header_read_position = ebml->header_read_position + to_read;
        if(ebml->header_read_position == ebml->header_size)
          ebml->header_read = 1;

      }

      else
        return 0;
    return to_read;
  }
}

// ebml_read_space
// file format_ebml.c line 305
static signed int ebml_read_space(struct ebml_st *ebml)
{
  signed int read_space;
  if(ebml->header_read == 1)
  {
    if(ebml->cluster_start >= 1)
      read_space = ebml->cluster_start;

    else
      read_space = ebml->position - 4;
    return read_space;
  }

  else
    if(!(ebml->header_size == 0))
      return ebml->header_size;

    else
      return 0;
}

// ebml_write_buf_to_client
// file format_ebml.c line 143
static signed int ebml_write_buf_to_client(struct _client_tag *client)
{
  struct ebml_client_data_st *ebml_client_data = (struct ebml_client_data_st *)client->format_data;
  if(!((unsigned int)ebml_client_data->header_pos == ebml_client_data->header->len))
  {
    signed int return_value_send_ebml_header_1;
    return_value_send_ebml_header_1=send_ebml_header(client);
    return return_value_send_ebml_header_1;
  }

  else
  {
    client->write_to_client = format_generic_write_to_client;
    signed int return_value;
    return_value=client->write_to_client(client);
    return return_value;
  }
}

// ebml_write_buf_to_file
// file format_ebml.c line 253
static void ebml_write_buf_to_file(struct source_tag *source, struct _refbuf_tag *refbuf)
{
  struct ebml_source_state_st *ebml_source_state = (struct ebml_source_state_st *)source->format->_state;
  if(ebml_source_state->file_headers_written == 0)
  {
    unsigned long int return_value_fwrite_1;
    return_value_fwrite_1=fwrite((const void *)ebml_source_state->header->data, (unsigned long int)1, (unsigned long int)ebml_source_state->header->len, source->dumpfile);
    if(!(return_value_fwrite_1 == (unsigned long int)ebml_source_state->header->len))
      ebml_write_buf_to_file_fail(source);

    else
      ebml_source_state->file_headers_written = 1;
  }

  unsigned long int return_value_fwrite_2;
  return_value_fwrite_2=fwrite((const void *)refbuf->data, (unsigned long int)1, (unsigned long int)refbuf->len, source->dumpfile);
  if(!(return_value_fwrite_2 == (unsigned long int)refbuf->len))
    ebml_write_buf_to_file_fail(source);

}

// ebml_write_buf_to_file_fail
// file format_ebml.c line 245
static void ebml_write_buf_to_file_fail(struct source_tag *source)
{
  log_write(errorlog, (unsigned int)2, "format-ebml/", "ebml_write_buf_to_file_fail", "Write to dump file failed, disabling");
  fclose(source->dumpfile);
  source->dumpfile = (struct _IO_FILE *)(void *)0;
}

// ebml_write_buffer
// file format_ebml.c line 406
static char * ebml_write_buffer(struct ebml_st *ebml, signed int len)
{
  return (char *)ebml->input_buffer;
}

// ebml_wrote
// file format_ebml.c line 414
static signed int ebml_wrote(struct ebml_st *ebml, signed int len)
{
  signed int b;
  if(ebml->header_size == 0)
  {
    if(ebml->header_position + len >= 131073)
    {
      log_write(errorlog, (unsigned int)1, "format-ebml/", "ebml_wrote", "EBML Header too large, failing");
      return -1;
    }

    memcpy((void *)(ebml->header + (signed long int)ebml->header_position), (const void *)ebml->input_buffer, (unsigned long int)len);
    ebml->header_position = ebml->header_position + len;
  }

  else
    memcpy((void *)(ebml->buffer + (signed long int)ebml->position), (const void *)ebml->input_buffer, (unsigned long int)len);
  b = 0;
  for( ; !(b >= len + -4); b = b + 1)
  {
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp((const void *)(ebml->input_buffer + (signed long int)b), (const void *)ebml->cluster_id, (unsigned long int)4);
    if(return_value_memcmp_1 == 0)
    {
      if(ebml->header_size == 0)
      {
        ebml->header_size = (ebml->header_position - len) + b;
        memcpy((void *)ebml->buffer, (const void *)(ebml->input_buffer + (signed long int)b), (unsigned long int)(len - b));
        ebml->position = len - b;
        ebml->cluster_start = -1;
        return len;
      }

      else
        ebml->cluster_start = ebml->position + b;
    }

  }
  ebml->position = ebml->position + len;
  return len;
}

// event_config_read
// file event.h line 19
void event_config_read(void *arg)
{
  signed int ret;
  struct ice_config_tag *config;
  struct ice_config_tag new_config;
  config=config_grab_config();
  xmlSetGenericErrorFunc((void *)"config", log_parse_failure);
  ret=config_parse_file(config->config_filename, &new_config);
  if(!(ret >= 0))
  {
    log_write(errorlog, (unsigned int)1, "event/", "event_config_read", "Error parsing config, not replacing existing config");
    if(!(ret == -1))
    {
      if(ret == -2)
        goto __CPROVER_DUMP_L2;

      if(ret == -3)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      log_write(errorlog, (unsigned int)1, "event/", "event_config_read", "Config filename null or blank");
      goto __CPROVER_DUMP_L5;

    __CPROVER_DUMP_L2:
      ;
      log_write(errorlog, (unsigned int)1, "event/", "event_config_read", "Root element not found in %s", config->config_filename);
      goto __CPROVER_DUMP_L5;

    __CPROVER_DUMP_L3:
      ;
      log_write(errorlog, (unsigned int)1, "event/", "event_config_read", "Not an icecast2 config file: %s", config->config_filename);
      goto __CPROVER_DUMP_L5;
    }
    log_write(errorlog, (unsigned int)1, "event/", "event_config_read", "Parse error in reading %s", config->config_filename);

  __CPROVER_DUMP_L5:
    ;
    config_release_config();
  }

  else
  {
    config_clear(config);
    config_set_config(&new_config);
    config=config_get_config_unlocked();
    restart_logging(config);
    yp_recheck_config(config);
    fserve_recheck_mime_types(config);
    stats_global(config);
    config_release_config();
    slave_update_all_mounts();
  }
}

// evict_cache_entry
// file xslt.c line 123
static signed int evict_cache_entry(void)
{
  signed int i;
  signed int age = 0;
  signed int oldest = 0;
  i = 0;
  for( ; !(i >= 3); i = i + 1)
    if(!((signed long int)age >= cache[(signed long int)i].cache_age))
    {
      age = (signed int)cache[(signed long int)i].cache_age;
      oldest = i;
    }

  xsltFreeStylesheet(cache[(signed long int)oldest].stylesheet);
  free((void *)cache[(signed long int)oldest].filename);
  return oldest;
}

// filter_shoutcast_metadata
// file format_mp3.c line 171
static void filter_shoutcast_metadata(struct source_tag *source, char *metadata, unsigned int meta_len)
{
  if(!(metadata == ((char *)NULL)))
  {
    char *end;
    char *p;
    signed int len;
    do
    {
      metadata = metadata + 1l;
      signed int return_value_strncmp_1;
      return_value_strncmp_1=strncmp(metadata, "StreamTitle='", (unsigned long int)13);
      if(!(return_value_strncmp_1 == 0))
        break;

      end=strstr(metadata + (signed long int)13, "';");
      if(end == ((char *)NULL))
        break;

      len = (signed int)((end - metadata) - (signed long int)13);
      void *return_value_calloc_2;
      return_value_calloc_2=calloc((unsigned long int)1, (unsigned long int)(len + 1));
      p = (char *)return_value_calloc_2;
      if(!(p == ((char *)NULL)))
      {
        memcpy((void *)p, (const void *)(metadata + (signed long int)13), (unsigned long int)len);
        logging_playlist(source->mount, p, (signed long int)source->listeners);
        stats_event_conv(source->mount, "title", p, source->format->charset);
        yp_touch(source->mount);
        free((void *)p);
      }

    }
    while((_Bool)0);
  }

}

// find_client_start
// file format.c line 114
static void find_client_start(struct source_tag *source, struct _client_tag *client)
{
  struct _refbuf_tag *refbuf = source->burst_point;
  _Bool tmp_if_expr_1;
  if(client->intro_offset == -1l)
    tmp_if_expr_1 = source->stream_data_tail != ((struct _refbuf_tag *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = source->stream_data_tail->sync_point != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    refbuf = source->stream_data_tail;

  else
  {
    unsigned long int size = (unsigned long int)client->intro_offset;
    refbuf = source->burst_point;
    for( ; size >= 1ul; refbuf = refbuf->next)
    {
      if(refbuf == ((struct _refbuf_tag *)NULL))
        break;

      if(refbuf->next == ((struct _refbuf_tag *)NULL))
        break;

      size = size - (unsigned long int)refbuf->len;
    }
  }
  for( ; !(refbuf == ((struct _refbuf_tag *)NULL)); refbuf = refbuf->next)
    if(!(refbuf->sync_point == 0))
    {
      client_set_queue(client, refbuf);
      client->check_buffer = format_advance_queue;
      client->write_to_client = source->format->write_buf_to_client;
      client->intro_offset = (signed long int)-1;
      break;
    }

}

// find_yp_mount
// file yp.c line 196
static struct ypdata_tag * find_yp_mount(struct ypdata_tag *mounts, const char *mount)
{
  struct ypdata_tag *yp = mounts;
  while(!(yp == ((struct ypdata_tag *)NULL)))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(yp->mount, mount);
    if(return_value_strcmp_1 == 0)
      break;

    yp = yp->next;
  }
  return yp;
}

// find_yp_server
// file yp.c line 157
static struct yp_server * find_yp_server(const char *url)
{
  struct yp_server *server = (struct yp_server *)active_yps;
  while(!(server == ((struct yp_server *)NULL)))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(server->url, url);
    if(return_value_strcmp_1 == 0)
      return server;

    server = server->next;
  }
  server = (struct yp_server *)pending_yps;
  while(!(server == ((struct yp_server *)NULL)))
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(server->url, url);
    if(return_value_strcmp_2 == 0)
      break;

    server = server->next;
  }
  return server;
}

// flac_codec_free
// file format_flac.c line 35
static void flac_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  log_write(errorlog, (unsigned int)4, "format-flac/", "flac_codec_free", "freeing FLAC codec");
  stats_event(ogg_info->mount, "FLAC_version", (const char *)(void *)0);
  ogg_stream_clear(&codec->os);
  free((void *)codec);
}

// format_advance_queue
// file format.c line 270
signed int format_advance_queue(struct source_tag *source, struct _client_tag *client)
{
  struct _refbuf_tag *refbuf = client->refbuf;
  if(refbuf == ((struct _refbuf_tag *)NULL))
    return -1;

  else
    if(refbuf->next == ((struct _refbuf_tag *)NULL))
    {
      if(!(client->pos == refbuf->len))
        goto __CPROVER_DUMP_L2;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(refbuf->next == ((struct _refbuf_tag *)NULL)))
      {
        if(client->pos == refbuf->len)
        {
          client_set_queue(client, refbuf->next);
          refbuf = client->refbuf;
        }

      }

      return 0;
    }
}

// format_check_file_buffer
// file format.h line 67
signed int format_check_file_buffer(struct source_tag *source, struct _client_tag *client)
{
  struct _refbuf_tag *refbuf = client->refbuf;
  if(refbuf == ((struct _refbuf_tag *)NULL))
  {
    if(!(source->client == ((struct _client_tag *)NULL)))
    {
      find_client_start(source, client);
      return -1;
    }

    refbuf=refbuf_new((unsigned int)4096);
    client->refbuf = refbuf;
    client->pos = refbuf->len;
    client->intro_offset = (signed long int)0;
  }

  if(client->pos == refbuf->len)
  {
    signed int return_value_get_file_data_1;
    return_value_get_file_data_1=get_file_data(source->intro_file, client);
    if(!(return_value_get_file_data_1 == 0))
    {
      client->pos = (unsigned int)0;
      client->intro_offset = client->intro_offset + (signed long int)refbuf->len;
    }

    else
    {
      if(!(source->stream_data_tail == ((struct _refbuf_tag *)NULL)))
      {
        client_set_queue(client, (struct _refbuf_tag *)(void *)0);
        find_client_start(source, client);
      }

      else
        client->intro_offset = (signed long int)0;
      return -1;
    }
  }

  return 0;
}

// format_check_http_buffer
// file format.h line 66
signed int format_check_http_buffer(struct source_tag *source, struct _client_tag *client)
{
  struct _refbuf_tag *refbuf = client->refbuf;
  if(refbuf == ((struct _refbuf_tag *)NULL))
    return -1;

  else
  {
    if(client->respcode == 0)
    {
      log_write(errorlog, (unsigned int)4, "format/", "format_check_http_buffer", "processing pending client headers");
      signed int return_value_format_prepare_headers_1;
      return_value_format_prepare_headers_1=format_prepare_headers(source, client);
      if(!(return_value_format_prepare_headers_1 >= 0))
      {
        log_write(errorlog, (unsigned int)1, "format/", "format_check_http_buffer", "internal problem, dropping client");
        client->con->error = 1;
        return -1;
      }

      client->respcode = 200;
      stats_event_inc((const char *)(void *)0, "listeners");
      stats_event_inc((const char *)(void *)0, "listener_connections");
      stats_event_inc(source->mount, "listener_connections");
    }

    if(client->pos == refbuf->len)
    {
      client->write_to_client = source->format->write_buf_to_client;
      client->check_buffer = format_check_file_buffer;
      client->intro_offset = (signed long int)0;
      refbuf->len = (unsigned int)4096;
      client->pos = refbuf->len;
      return -1;
    }

    else
      return 0;
  }
}

// format_ebml_get_plugin
// file format_ebml.h line 33
signed int format_ebml_get_plugin(struct source_tag *source)
{
  struct ebml_source_state_st *ebml_source_state;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ebml_source_state_st) /*24ul*/ );
  ebml_source_state = (struct ebml_source_state_st *)return_value_calloc_1;
  struct _format_plugin_tag *plugin;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct _format_plugin_tag) /*112ul*/ );
  plugin = (struct _format_plugin_tag *)return_value_calloc_2;
  plugin->get_buffer = ebml_get_buffer;
  plugin->write_buf_to_client = ebml_write_buf_to_client;
  plugin->create_client_data = ebml_create_client_data;
  plugin->free_plugin = ebml_free_plugin;
  plugin->write_buf_to_file = ebml_write_buf_to_file;
  plugin->set_tag = (void (*)(struct _format_plugin_tag *, const char *, const char *, const char *))(void *)0;
  plugin->apply_settings = (void (*)(struct _client_tag *, struct _format_plugin_tag *, struct _mount_proxy *))(void *)0;
  plugin->contenttype=httpp_getvar(source->parser, "content-type");
  plugin->_state = (void *)ebml_source_state;
  source->format = plugin;
  ebml_source_state->ebml=ebml_create();
  return 0;
}

// format_generic_write_to_client
// file format.h line 64
signed int format_generic_write_to_client(struct _client_tag *client)
{
  struct _refbuf_tag *refbuf = client->refbuf;
  signed int ret;
  const char *buf = refbuf->data + (signed long int)client->pos;
  unsigned int len = refbuf->len - client->pos;
  ret=client_send_bytes(client, (const void *)buf, len);
  if(ret >= 1)
    client->pos = client->pos + (unsigned int)ret;

  return ret;
}

// format_get_plugin
// file format.h line 62
signed int format_get_plugin(enum _format_type_tag type, struct source_tag *source)
{
  signed int ret = -1;
  switch((signed int)type)
  {
    case FORMAT_TYPE_OGG:
    {
      ret=format_ogg_get_plugin(source);
      break;
    }
    case FORMAT_TYPE_EBML:
    {
      ret=format_ebml_get_plugin(source);
      break;
    }
    case FORMAT_TYPE_GENERIC:
      ret=format_mp3_get_plugin(source);
  }
  if(!(ret >= 0))
    stats_event(source->mount, "content-type", source->format->contenttype);

  return ret;
}

// format_get_type
// file format.h line 60
enum _format_type_tag format_get_type(const char *contenttype)
{
  signed int return_value_strcmp_9;
  return_value_strcmp_9=strcmp(contenttype, "application/x-ogg");
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(return_value_strcmp_9 == 0)
    return (enum _format_type_tag)FORMAT_TYPE_OGG;

  else
  {
    return_value_strcmp_8=strcmp(contenttype, "application/ogg");
    if(return_value_strcmp_8 == 0)
      return (enum _format_type_tag)FORMAT_TYPE_OGG;

    else
    {
      return_value_strcmp_7=strcmp(contenttype, "audio/ogg");
      if(return_value_strcmp_7 == 0)
        return (enum _format_type_tag)FORMAT_TYPE_OGG;

      else
      {
        return_value_strcmp_6=strcmp(contenttype, "video/ogg");
        if(return_value_strcmp_6 == 0)
          return (enum _format_type_tag)FORMAT_TYPE_OGG;

        else
        {
          return_value_strcmp_5=strcmp(contenttype, "audio/webm");
          if(return_value_strcmp_5 == 0)
            return (enum _format_type_tag)FORMAT_TYPE_EBML;

          else
          {
            return_value_strcmp_4=strcmp(contenttype, "video/webm");
            if(return_value_strcmp_4 == 0)
              return (enum _format_type_tag)FORMAT_TYPE_EBML;

            else
            {
              return_value_strcmp_3=strcmp(contenttype, "audio/x-matroska");
              if(return_value_strcmp_3 == 0)
                return (enum _format_type_tag)FORMAT_TYPE_EBML;

              else
              {
                return_value_strcmp_2=strcmp(contenttype, "video/x-matroska");
                if(return_value_strcmp_2 == 0)
                  return (enum _format_type_tag)FORMAT_TYPE_EBML;

                else
                {
                  return_value_strcmp_1=strcmp(contenttype, "video/x-matroska-3d");
                  if(return_value_strcmp_1 == 0)
                    return (enum _format_type_tag)FORMAT_TYPE_EBML;

                  else
                    log_write(errorlog, (unsigned int)2, "format/", "format_get_type", "Unsupported or legacy stream type: \"%s\". Falling back to generic minimal handler for best effort.", contenttype);
                }
              }
            }
          }
        }
      }
    }
  }
  return (enum _format_type_tag)FORMAT_TYPE_GENERIC;
}

// format_mp3_apply_settings
// file format_mp3.c line 200
static void format_mp3_apply_settings(struct _client_tag *client, struct _format_plugin_tag *format, struct _mount_proxy *mount)
{
  struct anonymous_5 *source_mp3 = (struct anonymous_5 *)format->_state;
  source_mp3->interval = -1;
  free((void *)format->charset);
  format->charset = (char *)(void *)0;
  if(!(mount == ((struct _mount_proxy *)NULL)))
  {
    if(mount->mp3_meta_interval >= 0)
      source_mp3->interval = mount->mp3_meta_interval;

    if(!(mount->charset == ((char *)NULL)))
      format->charset=strdup(mount->charset);

  }

  if(!(source_mp3->interval >= 0))
  {
    const char *metadata;
    metadata=httpp_getvar(client->parser, "icy-metaint");
    source_mp3->interval = 16000;
    if(!(metadata == ((const char *)NULL)))
    {
      signed int interval;
      interval=atoi(metadata);
      if(interval >= 1)
        source_mp3->interval = interval;

    }

  }

  if(format->charset == ((char *)NULL))
    format->charset=strdup("ISO8859-1");

  log_write(errorlog, (unsigned int)4, "format-mp3/", "format_mp3_apply_settings", "sending metadata interval %d", source_mp3->interval);
  log_write(errorlog, (unsigned int)4, "format-mp3/", "format_mp3_apply_settings", "charset %s", format->charset);
}

// format_mp3_create_client_data
// file format_mp3.c line 659
static signed int format_mp3_create_client_data(struct source_tag *source, struct _client_tag *client)
{
  struct anonymous_8 *client_mp3;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_8) /*24ul*/ );
  client_mp3 = (struct anonymous_8 *)return_value_calloc_1;
  struct anonymous_5 *source_mp3 = (struct anonymous_5 *)source->format->_state;
  const char *metadata;
  unsigned int remaining = ((unsigned int)4096 - client->refbuf->len) + (unsigned int)2;
  char *ptr = (client->refbuf->data + (signed long int)client->refbuf->len) - (signed long int)2;
  signed int bytes;
  const char *useragent;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  char *return_value_strstr_3;
  signed int return_value_atoi_6;
  if(client_mp3 == ((struct anonymous_8 *)NULL))
    return -1;

  else
  {
    useragent=httpp_getvar(client->parser, "user-agent");
    const char *return_value_httpp_getvar_2;
    return_value_httpp_getvar_2=httpp_getvar(client->parser, "x-flash-version");
    if(!(return_value_httpp_getvar_2 == ((const char *)NULL)))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      if(!(useragent == ((const char *)NULL)))
      {
        return_value_strstr_3=strstr(useragent, "MSIE");
        tmp_if_expr_4 = return_value_strstr_3 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      bytes=snprintf(ptr, (unsigned long int)remaining, "Content-Length: 221183499\r\n");
      remaining = remaining - (unsigned int)bytes;
      ptr = ptr + (signed long int)bytes;
    }

    client->format_data = (void *)client_mp3;
    client->free_client_data = free_mp3_client_data;
    metadata=httpp_getvar(client->parser, "icy-metadata");
    if(!(metadata == ((const char *)NULL)))
    {
      return_value_atoi_6=atoi(metadata);
      if(!(return_value_atoi_6 == 0))
      {
        if(source_mp3->interval >= 0)
          client_mp3->interval = (unsigned int)source_mp3->interval;

        else
          client_mp3->interval = (unsigned int)16000;
        if(!(client_mp3->interval == 0u))
        {
          bytes=snprintf(ptr, (unsigned long int)remaining, "icy-metaint:%u\r\n", client_mp3->interval);
          if(bytes >= 1)
          {
            remaining = remaining - (unsigned int)bytes;
            ptr = ptr + (signed long int)bytes;
          }

        }

      }

    }

    bytes=snprintf(ptr, (unsigned long int)remaining, "\r\n");
    remaining = remaining - (unsigned int)bytes;
    ptr = ptr + (signed long int)bytes;
    client->refbuf->len = (unsigned int)4096 - remaining;
    return 0;
  }
}

// format_mp3_free_plugin
// file format_mp3.c line 447
static void format_mp3_free_plugin(struct _format_plugin_tag *self)
{
  struct anonymous_5 *state = (struct anonymous_5 *)self->_state;
  thread_mutex_destroy(&state->url_lock);
  free((void *)state->url_artist);
  free((void *)state->url_title);
  free((void *)self->charset);
  refbuf_release(state->metadata);
  refbuf_release(state->read_data);
  free((void *)state);
  free((void *)self);
}

// format_mp3_get_plugin
// file format_mp3.h line 42
signed int format_mp3_get_plugin(struct source_tag *source)
{
  const char *metadata;
  struct _format_plugin_tag *plugin;
  struct anonymous_5 *state;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_5) /*4216ul*/ );
  state = (struct anonymous_5 *)return_value_calloc_1;
  struct _refbuf_tag *meta;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct _format_plugin_tag) /*112ul*/ );
  plugin = (struct _format_plugin_tag *)return_value_calloc_2;
  plugin->type = (enum _format_type_tag)FORMAT_TYPE_GENERIC;
  plugin->get_buffer = mp3_get_no_meta;
  plugin->write_buf_to_client = format_mp3_write_buf_to_client;
  plugin->write_buf_to_file = write_mp3_to_file;
  plugin->create_client_data = format_mp3_create_client_data;
  plugin->free_plugin = format_mp3_free_plugin;
  plugin->set_tag = mp3_set_tag;
  plugin->apply_settings = format_mp3_apply_settings;
  plugin->contenttype=httpp_getvar(source->parser, "content-type");
  if(plugin->contenttype == ((const char *)NULL))
    plugin->contenttype = "audio/mpeg";

  plugin->_state = (void *)state;
  meta=refbuf_new((unsigned int)17);
  memcpy((void *)meta->data, (const void *)"\001StreamTitle='';", (unsigned long int)17);
  state->metadata = meta;
  state->interval = -1;
  metadata=httpp_getvar(source->parser, "icy-metaint");
  if(!(metadata == ((const char *)NULL)))
  {
    state->inline_metadata_interval=atoi(metadata);
    if(state->inline_metadata_interval >= 1)
    {
      state->offset = 0;
      plugin->get_buffer = mp3_get_filter_meta;
      state->interval = state->inline_metadata_interval;
    }

  }

  source->format = plugin;
  thread_mutex_create_c(&state->url_lock, 122, "format_mp3.c");
  return 0;
}

// format_mp3_write_buf_to_client
// file format_mp3.c line 371
static signed int format_mp3_write_buf_to_client(struct _client_tag *client)
{
  signed int ret;
  signed int written = 0;
  struct anonymous_8 *client_mp3 = (struct anonymous_8 *)client->format_data;
  struct _refbuf_tag *refbuf = client->refbuf;
  char *buf = refbuf->data + (signed long int)client->pos;
  unsigned int len = refbuf->len - client->pos;
  do
  {
    if(!(client_mp3->in_metadata == 0))
    {
      struct _refbuf_tag *associated = refbuf->associated;
      ret=send_stream_metadata(client, associated);
      if(!(client_mp3->in_metadata == 0))
        goto __CPROVER_DUMP_L12;

      written = written + ret;
    }

    if(!(client_mp3->interval == 0u))
    {
      unsigned int remaining = client_mp3->interval - client_mp3->since_meta_block;
      if(len >= remaining)
      {
        if(!(remaining == 0u))
        {
          ret=client_send_bytes(client, (const void *)buf, remaining);
          if(ret >= 1)
          {
            client_mp3->since_meta_block = client_mp3->since_meta_block + (unsigned int)ret;
            client->pos = client->pos + (unsigned int)ret;
          }

          if(!(ret >= (signed int)remaining))
            break;

          written = written + ret;
        }

        ret=send_stream_metadata(client, refbuf->associated);
        if(!(client_mp3->in_metadata == 0))
          break;

        written = written + ret;
        buf = buf + (signed long int)remaining;
        len = len - remaining;
        if(!(client_mp3->interval >= len))
          len = client_mp3->interval;

      }

    }

    if(!(len == 0u))
    {
      ret=client_send_bytes(client, (const void *)buf, len);
      if(ret >= 1)
      {
        client_mp3->since_meta_block = client_mp3->since_meta_block + (unsigned int)ret;
        client->pos = client->pos + (unsigned int)ret;
      }

      if(!(ret >= (signed int)len))
        break;

      written = written + ret;
    }

    ret = 0;
  }
  while((_Bool)0);

__CPROVER_DUMP_L12:
  ;
  if(ret >= 1)
    written = written + ret;

  return written;
}

// format_ogg_attach_header
// file format_ogg.c line 89
void format_ogg_attach_header(struct ogg_state_tag *ogg_info, struct anonymous_3 *page)
{
  struct _refbuf_tag *refbuf;
  refbuf=make_refbuf_with_page(page);
  signed int return_value_ogg_page_bos_1;
  return_value_ogg_page_bos_1=ogg_page_bos(page);
  if(!(return_value_ogg_page_bos_1 == 0))
  {
    log_write(errorlog, (unsigned int)4, "format-ogg/", "format_ogg_attach_header", "attaching BOS page");
    if(*ogg_info->bos_end == ((struct _refbuf_tag *)NULL))
      ogg_info->header_pages_tail = refbuf;

    refbuf->next = *ogg_info->bos_end;
    *ogg_info->bos_end = refbuf;
    ogg_info->bos_end = &refbuf->next;
  }

  else
  {
    log_write(errorlog, (unsigned int)4, "format-ogg/", "format_ogg_attach_header", "attaching header page");
    if(!(ogg_info->header_pages_tail == ((struct _refbuf_tag *)NULL)))
      ogg_info->header_pages_tail->next = refbuf;

    ogg_info->header_pages_tail = refbuf;
    if(ogg_info->header_pages == ((struct _refbuf_tag *)NULL))
      ogg_info->header_pages = refbuf;

  }
}

// format_ogg_free_headers
// file format_ogg.c line 113
void format_ogg_free_headers(struct ogg_state_tag *ogg_info)
{
  struct _refbuf_tag *header;
  log_write(errorlog, (unsigned int)4, "format-ogg/", "format_ogg_free_headers", "releasing header pages");
  header = ogg_info->header_pages;
  while(!(header == ((struct _refbuf_tag *)NULL)))
  {
    struct _refbuf_tag *to_release = header;
    header = header->next;
    refbuf_release(to_release);
  }
  ogg_info->header_pages = (struct _refbuf_tag *)(void *)0;
  ogg_info->header_pages_tail = (struct _refbuf_tag *)(void *)0;
  ogg_info->bos_end = &ogg_info->header_pages;
}

// format_ogg_free_plugin
// file format_ogg.c line 189
static void format_ogg_free_plugin(struct _format_plugin_tag *plugin)
{
  struct ogg_state_tag *state = (struct ogg_state_tag *)plugin->_state;
  free_ogg_codecs(state);
  free((void *)state->artist);
  free((void *)state->title);
  ogg_sync_clear(&state->oy);
  free((void *)state);
  free((void *)plugin);
}

// format_ogg_get_plugin
// file format_ogg.h line 68
signed int format_ogg_get_plugin(struct source_tag *source)
{
  struct _format_plugin_tag *plugin;
  struct ogg_state_tag *state;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_state_tag) /*144ul*/ );
  state = (struct ogg_state_tag *)return_value_calloc_1;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct _format_plugin_tag) /*112ul*/ );
  plugin = (struct _format_plugin_tag *)return_value_calloc_2;
  plugin->type = (enum _format_type_tag)FORMAT_TYPE_OGG;
  plugin->get_buffer = ogg_get_buffer;
  plugin->write_buf_to_client = write_buf_to_client;
  plugin->write_buf_to_file = write_ogg_to_file;
  plugin->create_client_data = create_ogg_client_data;
  plugin->free_plugin = format_ogg_free_plugin;
  plugin->set_tag = (void (*)(struct _format_plugin_tag *, const char *, const char *, const char *))(void *)0;
  const char *return_value_httpp_getvar_3;
  return_value_httpp_getvar_3=httpp_getvar(source->parser, "content-type");
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(return_value_httpp_getvar_3, "application/x-ogg");
  if(return_value_strcmp_4 == 0)
    httpp_setvar(source->parser, "content-type", "application/ogg");

  plugin->contenttype=httpp_getvar(source->parser, "content-type");
  ogg_sync_init(&state->oy);
  plugin->_state = (void *)state;
  source->format = plugin;
  state->mount = source->mount;
  state->bos_end = &state->header_pages;
  return 0;
}

// format_prepare_headers
// file format.c line 290
static signed int format_prepare_headers(struct source_tag *source, struct _client_tag *client)
{
  unsigned int remaining;
  char *ptr;
  signed int bytes;
  signed int bitrate_filtered = 0;
  struct avl_node_tag *node;
  remaining = client->refbuf->len;
  ptr = client->refbuf->data;
  client->respcode = 200;
  signed long int return_value_util_http_build_header_1;
  return_value_util_http_build_header_1=util_http_build_header(ptr, (unsigned long int)remaining, (signed long int)0, 0, 200, (const char *)(void *)0, source->format->contenttype, (const char *)(void *)0, (const char *)(void *)0, source);
  bytes = (signed int)return_value_util_http_build_header_1;
  if(bytes == -1)
  {
    log_write(errorlog, (unsigned int)1, "format/", "format_prepare_headers", "Dropping client as we can not build response headers.");
    client_send_500(client, "Header generation failed.");
    return -1;
  }

  else
    if(1024u + (unsigned int)bytes >= remaining)
    {
      void *new_ptr;
      new_ptr=realloc((void *)ptr, (unsigned long int)(bytes + 1024));
      if(!(new_ptr == NULL))
      {
        log_write(errorlog, (unsigned int)4, "format/", "format_prepare_headers", "Client buffer reallocation succeeded.");
        ptr = (char *)new_ptr;
        client->refbuf->data = ptr;
        remaining = (unsigned int)(bytes + 1024);
        client->refbuf->len = remaining;
        signed long int return_value_util_http_build_header_2;
        return_value_util_http_build_header_2=util_http_build_header(ptr, (unsigned long int)remaining, (signed long int)0, 0, 200, (const char *)(void *)0, source->format->contenttype, (const char *)(void *)0, (const char *)(void *)0, source);
        bytes = (signed int)return_value_util_http_build_header_2;
        if(bytes == -1)
        {
          log_write(errorlog, (unsigned int)1, "format/", "format_prepare_headers", "Dropping client as we can not build response headers.");
          client_send_500(client, "Header generation failed.");
          return -1;
        }

      }

      else
      {
        log_write(errorlog, (unsigned int)1, "format/", "format_prepare_headers", "Client buffer reallocation failed. Dropping client.");
        client_send_500(client, "Buffer reallocation failed.");
        return -1;
      }
    }

  remaining = remaining - (unsigned int)bytes;
  ptr = ptr + (signed long int)bytes;
  avl_tree_rlock(source->parser->vars);
  node=avl_get_first(source->parser->vars);
  _Bool tmp_if_expr_4;
  signed int return_value_sscanf_3;
  signed int return_value_strcasecmp_11;
  _Bool tmp_if_expr_5;
  signed int return_value_strncasecmp_9;
  signed int return_value_strcasecmp_6;
  signed int return_value_strncasecmp_8;
  while(!(node == ((struct avl_node_tag *)NULL)))
  {
    signed int next = 1;
    struct http_var_tag *var = (struct http_var_tag *)node->key;
    bytes = 0;
    signed int return_value_strcasecmp_13;
    return_value_strcasecmp_13=strcasecmp(var->name, "ice-audio-info");
    if(return_value_strcasecmp_13 == 0)
    {
      char *brfield = (char *)(void *)0;
      unsigned int bitrate;
      if(bitrate_filtered == 0)
        brfield=strstr(var->value, "bitrate=");

      if(!(brfield == ((char *)NULL)))
      {
        return_value_sscanf_3=sscanf(brfield, "bitrate=%u", &bitrate);
        tmp_if_expr_4 = return_value_sscanf_3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        bytes=snprintf(ptr, (unsigned long int)remaining, "icy-br:%u\r\n", bitrate);
        next = 0;
        bitrate_filtered = 1;
      }

      else
        bytes=snprintf(ptr, (unsigned long int)remaining, "%s: %s\r\n", var->name, var->value);
    }

    else
    {
      signed int return_value_strcasecmp_12;
      return_value_strcasecmp_12=strcasecmp(var->name, "ice-password");
      if(!(return_value_strcasecmp_12 == 0))
      {
        return_value_strcasecmp_11=strcasecmp(var->name, "icy-metaint");
        if(!(return_value_strcasecmp_11 == 0))
        {
          signed int return_value_strcasecmp_10;
          return_value_strcasecmp_10=strcasecmp(var->name, "ice-name");
          if(return_value_strcasecmp_10 == 0)
          {
            struct ice_config_tag *config;
            struct _mount_proxy *mountinfo;
            config=config_get_config();
            mountinfo=config_find_mount(config, source->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
            if(!(mountinfo == ((struct _mount_proxy *)NULL)))
              tmp_if_expr_5 = mountinfo->stream_name != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_5 = (_Bool)0;
            if(tmp_if_expr_5)
              bytes=snprintf(ptr, (unsigned long int)remaining, "icy-name:%s\r\n", mountinfo->stream_name);

            else
              bytes=snprintf(ptr, (unsigned long int)remaining, "icy-name:%s\r\n", var->value);
            config_release_config();
          }

          else
          {
            return_value_strncasecmp_9=strncasecmp("ice-", var->name, (unsigned long int)4);
            if(return_value_strncasecmp_9 == 0)
            {
              signed int return_value_strcasecmp_7;
              return_value_strcasecmp_7=strcasecmp("ice-public", var->name);
              if(return_value_strcasecmp_7 == 0)
                bytes=snprintf(ptr, (unsigned long int)remaining, "icy-pub:%s\r\n", var->value);

              else
              {
                return_value_strcasecmp_6=strcasecmp("ice-bitrate", var->name);
                if(return_value_strcasecmp_6 == 0)
                  bytes=snprintf(ptr, (unsigned long int)remaining, "icy-br:%s\r\n", var->value);

                else
                  bytes=snprintf(ptr, (unsigned long int)remaining, "icy%s:%s\r\n", var->name + (signed long int)3, var->value);
              }
            }

            else
            {
              return_value_strncasecmp_8=strncasecmp("icy-", var->name, (unsigned long int)4);
              if(return_value_strncasecmp_8 == 0)
                bytes=snprintf(ptr, (unsigned long int)remaining, "icy%s:%s\r\n", var->name + (signed long int)3, var->value);

            }
          }
        }

      }

    }
    remaining = remaining - (unsigned int)bytes;
    ptr = ptr + (signed long int)bytes;
    if(!(next == 0))
      node=avl_get_next(node);

  }
  avl_tree_unlock(source->parser->vars);
  bytes=snprintf(ptr, (unsigned long int)remaining, "\r\n");
  remaining = remaining - (unsigned int)bytes;
  ptr = ptr + (signed long int)bytes;
  client->refbuf->len = client->refbuf->len - remaining;
  signed int return_value;
  if(!(source->format->create_client_data == ((signed int (*)(struct source_tag *, struct _client_tag *))NULL)))
  {
    return_value=source->format->create_client_data(source, client);
    return -1;
  }

  else
    return 0;
}

// free_filtered_ip
// file connection.c line 135
static signed int free_filtered_ip(void *x)
{
  free(x);
  return 1;
}

// free_mp3_client_data
// file format_mp3.c line 714
static void free_mp3_client_data(struct _client_tag *client)
{
  free(client->format_data);
  client->format_data = (void *)0;
}

// free_ogg_client_data
// file format_ogg.c line 475
static void free_ogg_client_data(struct _client_tag *client)
{
  free(client->format_data);
  client->format_data = (void *)0;
}

// free_ogg_codecs
// file format_ogg.c line 133
static void free_ogg_codecs(struct ogg_state_tag *ogg_info)
{
  struct ogg_codec_tag *codec;
  if(!(ogg_info == ((struct ogg_state_tag *)NULL)))
  {
    format_ogg_free_headers(ogg_info);
    codec = ogg_info->codecs;
    log_write(errorlog, (unsigned int)4, "format-ogg/", "free_ogg_codecs", "freeing codecs");
    if(!(codec == ((struct ogg_codec_tag *)NULL)))
    {
      struct ogg_codec_tag *next = codec->next;
      if(!(codec->possible_start == ((struct _refbuf_tag *)NULL)))
        refbuf_release(codec->possible_start);

      codec->codec_free(ogg_info, codec);
      codec = next;
    }

    ogg_info->codecs = (struct ogg_codec_tag *)(void *)0;
    ogg_info->current = (struct ogg_codec_tag *)(void *)0;
    ogg_info->bos_completed = 0;
    ogg_info->codec_count = 0;
  }

}

// free_ogg_packet
// file format_vorbis.c line 73
static void free_ogg_packet(struct anonymous_14 *packet)
{
  if(!(packet == ((struct anonymous_14 *)NULL)))
  {
    free((void *)packet->packet);
    free((void *)packet);
  }

}

// fserv_thread_function
// file fserve.c line 267
static void * fserv_thread_function(void *arg)
{
  struct _fserve_t *fclient;
  struct _fserve_t **trail;
  unsigned long int bytes;
  while((_Bool)1)
  {
    signed int return_value_wait_for_fds_1;
    return_value_wait_for_fds_1=wait_for_fds();
    if(!(return_value_wait_for_fds_1 >= 0))
      break;

    fclient = active_list;
    trail = &active_list;
    while(!(fclient == ((struct _fserve_t *)NULL)))
    {
      if(!(fclient->ready == 0))
      {
        struct _client_tag *client = fclient->client;
        struct _refbuf_tag *refbuf = client->refbuf;
        fclient->ready = 0;
        if(client->pos == refbuf->len)
        {
          if(!(fclient->file == ((struct _IO_FILE *)NULL)))
            bytes=fread((void *)refbuf->data, (unsigned long int)1, (unsigned long int)4096, fclient->file);

          else
            bytes = (unsigned long int)0;
          if(bytes == 0ul)
          {
            if(refbuf->next == ((struct _refbuf_tag *)NULL))
            {
              struct _fserve_t *to_go = fclient;
              fclient = fclient->next;
              *trail = fclient;
              fserve_client_destroy(to_go);
              fserve_clients = fserve_clients - 1u;
              client_tree_changed = 1;
              continue;
            }

            refbuf = refbuf->next;
            client->refbuf->next = (struct _refbuf_tag *)(void *)0;
            refbuf_release(client->refbuf);
            client->refbuf = refbuf;
            bytes = (unsigned long int)refbuf->len;
          }

          refbuf->len = (unsigned int)bytes;
          client->pos = (unsigned int)0;
        }

        format_generic_write_to_client(client);
        if(!(client->con->error == 0))
        {
          struct _fserve_t *fserv_thread_function__1__1__1__1__2__to_go = fclient;
          fclient = fclient->next;
          *trail = fclient;
          fserve_clients = fserve_clients - 1u;
          fserve_client_destroy(fserv_thread_function__1__1__1__1__2__to_go);
          client_tree_changed = 1;
          continue;
        }

      }

      trail = &fclient->next;
      fclient = fclient->next;
    }
  }
  log_write(errorlog, (unsigned int)4, "fserve/", "fserv_thread_function", "fserve handler exit");
  return (void *)0;
}

// fserve_add_client
// file fserve.h line 35
signed int fserve_add_client(struct _client_tag *client, struct _IO_FILE *file)
{
  struct _fserve_t *fclient;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _fserve_t) /*48ul*/ );
  fclient = (struct _fserve_t *)return_value_calloc_1;
  log_write(errorlog, (unsigned int)4, "fserve/", "fserve_add_client", "Adding client to file serving engine");
  if(fclient == ((struct _fserve_t *)NULL))
  {
    client_send_404(client, "memory exhausted");
    return -1;
  }

  else
  {
    fclient->file = file;
    fclient->client = client;
    fclient->ready = 0;
    fserve_add_pending(fclient);
    return 0;
  }
}

// fserve_add_client_callback
// file fserve.h line 36
void fserve_add_client_callback(struct _client_tag *client, void (*callback)(struct _client_tag *, void *), void *arg)
{
  struct _fserve_t *fclient;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _fserve_t) /*48ul*/ );
  fclient = (struct _fserve_t *)return_value_calloc_1;
  log_write(errorlog, (unsigned int)4, "fserve/", "fserve_add_client_callback", "Adding client to file serving engine");
  if(fclient == ((struct _fserve_t *)NULL))
    client_send_404(client, "memory exhausted");

  else
  {
    fclient->file = (struct _IO_FILE *)(void *)0;
    fclient->client = client;
    fclient->ready = 0;
    fclient->callback = callback;
    fclient->arg = arg;
    fserve_add_pending(fclient);
  }
}

// fserve_add_pending
// file fserve.c line 639
static void fserve_add_pending(struct _fserve_t *fclient)
{
  thread_spin_lock(&pending_lock);
  fclient->next = (struct _fserve_t *)pending_list;
  pending_list = fclient;
  if(run_fserv == 0)
  {
    run_fserv = 1;
    log_write(errorlog, (unsigned int)4, "fserve/", "fserve_add_pending", "fserve handler waking up");
    thread_create_c("File Serving Thread", fserv_thread_function, (void *)0, 1, 648, "fserve.c");
  }

  thread_spin_unlock(&pending_lock);
}

// fserve_client_create
// file fserve.c line 400
signed int fserve_client_create(struct _client_tag *httpclient, const char *path)
{
  signed int bytes;
  struct stat file_buf;
  const char *range = (const char *)(void *)0;
  signed long int new_content_len = (signed long int)0;
  signed long int rangenumber = (signed long int)0;
  signed long int content_length;
  signed int rangeproblem = 0;
  signed int ret = 0;
  char *fullpath;
  signed int m3u_requested = 0;
  signed int m3u_file_available = 1;
  const char *xslt_playlist_requested = (const char *)(void *)0;
  signed int xslt_playlist_file_available = 1;
  struct ice_config_tag *config;
  struct _IO_FILE *file;
  fullpath=util_get_path_from_normalised_uri(path);
  log_write(errorlog, (unsigned int)3, "fserve/", "fserve_client_create", "checking for file %H (%H)", path, fullpath);
  char *return_value_util_get_extension_1;
  return_value_util_get_extension_1=util_get_extension(fullpath);
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(return_value_util_get_extension_1, "m3u");
  if(return_value_strcmp_2 == 0)
    m3u_requested = 1;

  char *return_value_util_get_extension_3;
  return_value_util_get_extension_3=util_get_extension(fullpath);
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(return_value_util_get_extension_3, "xspf");
  if(return_value_strcmp_4 == 0)
    xslt_playlist_requested = "xspf.xsl";

  char *return_value_util_get_extension_5;
  return_value_util_get_extension_5=util_get_extension(fullpath);
  signed int return_value_strcmp_6;
  return_value_strcmp_6=strcmp(return_value_util_get_extension_5, "vclt");
  if(return_value_strcmp_6 == 0)
    xslt_playlist_requested = "vclt.xsl";

  signed int return_value_stat_9;
  return_value_stat_9=stat(fullpath, &file_buf);
  if(!(return_value_stat_9 == 0))
  {
    if(xslt_playlist_requested == ((const char *)NULL) && m3u_requested == 0)
    {
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      char *return_value_strerror_8;
      return_value_strerror_8=strerror(*return_value___errno_location_7);
      log_write(errorlog, (unsigned int)2, "fserve/", "fserve_client_create", "req for file \"%H\" %s", fullpath, return_value_strerror_8);
      client_send_404(httpclient, "The file you requested could not be found");
      free((void *)fullpath);
      return -1;
    }

    m3u_file_available = 0;
    xslt_playlist_file_available = 0;
  }

  httpclient->refbuf->len = (unsigned int)4096;
  char *return_value_strchr_10;
  if(m3u_file_available == 0 && !(m3u_requested == 0))
  {
    const char *host;
    host=httpp_getvar(httpclient->parser, "host");
    char *sourceuri;
    sourceuri=strdup(path);
    char *dot;
    dot=strrchr(sourceuri, 46);
    if(!(host == ((const char *)NULL)))
    {
      return_value_strchr_10=strchr(host, 58);
      if(return_value_strchr_10 == ((char *)NULL))
        host = (const char *)(void *)0;

    }

    *dot = (char)0;
    httpclient->respcode = 200;
    signed long int return_value_util_http_build_header_11;
    return_value_util_http_build_header_11=util_http_build_header(httpclient->refbuf->data, (unsigned long int)4096, (signed long int)0, 0, 200, (const char *)(void *)0, "audio/x-mpegurl", (const char *)(void *)0, "", (struct source_tag *)(void *)0);
    ret = (signed int)return_value_util_http_build_header_11;
    if(ret == -1 || ret >= 4096)
    {
      log_write(errorlog, (unsigned int)1, "fserve/", "fserve_client_create", "Dropping client as we can not build response headers.");
      client_send_500(httpclient, "Header generation failed.");
      return -1;
    }

    if(host == ((const char *)NULL))
    {
      config=config_get_config();
      snprintf(httpclient->refbuf->data + (signed long int)ret, (unsigned long int)(4096 - ret), "http://%s:%d%s\r\n", config->hostname, config->port, sourceuri);
      config_release_config();
    }

    else
      snprintf(httpclient->refbuf->data + (signed long int)ret, (unsigned long int)(4096 - ret), "http://%s%s\r\n", host, sourceuri);
    unsigned long int return_value_strlen_12;
    return_value_strlen_12=strlen(httpclient->refbuf->data);
    httpclient->refbuf->len = (unsigned int)return_value_strlen_12;
    fserve_add_client(httpclient, (struct _IO_FILE *)(void *)0);
    free((void *)sourceuri);
    free((void *)fullpath);
    return 0;
  }

  if(xslt_playlist_file_available == 0 && !(xslt_playlist_requested == ((const char *)NULL)))
  {
    struct _xmlDoc *doc;
    char *reference;
    reference=strdup(path);
    char *eol;
    eol=strrchr(reference, 46);
    if(!(eol == ((char *)NULL)))
      *eol = (char)0;

    doc=stats_get_xml(0, reference);
    free((void *)reference);
    admin_send_response(doc, httpclient, 2, xslt_playlist_requested);
    xmlFreeDoc(doc);
    return 0;
  }

  config=config_get_config();
  if(config->fileserve == 0)
  {
    log_write(errorlog, (unsigned int)4, "fserve/", "fserve_client_create", "on demand file \"%H\" refused. Serving static files has been disabled in the config", fullpath);
    client_send_404(httpclient, "The file you requested could not be found");
    config_release_config();
    free((void *)fullpath);
    return -1;
  }

  else
  {
    config_release_config();
    if(!((61440u & file_buf.st_mode) == 32768u))
    {
      client_send_404(httpclient, "The file you requested could not be found");
      log_write(errorlog, (unsigned int)2, "fserve/", "fserve_client_create", "found requested file but there is no handler for it: %H", fullpath);
      free((void *)fullpath);
      return -1;
    }

    else
    {
      file=fopen(fullpath, "rb");
      if(file == ((struct _IO_FILE *)NULL))
      {
        log_write(errorlog, (unsigned int)2, "fserve/", "fserve_client_create", "Problem accessing file \"%H\"", fullpath);
        client_send_404(httpclient, "File not readable");
        free((void *)fullpath);
        return -1;
      }

      else
      {
        free((void *)fullpath);
        content_length = file_buf.st_size;
        range=httpp_getvar(httpclient->parser, "range");
        if(!(range == ((const char *)NULL)))
        {
          ret = 0;
          signed int return_value_strncasecmp_13;
          return_value_strncasecmp_13=strncasecmp(range, "bytes=", (unsigned long int)6);
          if(return_value_strncasecmp_13 == 0)
            ret=sscanf(range + (signed long int)6, "%ld-", &rangenumber);

          if(!(ret == 1))
            rangeproblem = 1;

          if(!(rangenumber >= 0l))
            rangeproblem = 1;

          if(rangeproblem == 0)
          {
            ret=fseeko(file, rangenumber, 0);
            if(!(ret == -1))
            {
              new_content_len = content_length - rangenumber;
              if(!(new_content_len >= 0l))
                rangeproblem = 1;

            }

            else
              rangeproblem = 1;
            if(rangeproblem == 0)
            {
              signed long int endpos = (rangenumber + new_content_len) - (signed long int)1;
              char *type;
              if(!(endpos >= 0l))
                endpos = (signed long int)0;

              httpclient->respcode = 206;
              type=fserve_content_type(path);
              signed long int return_value_util_http_build_header_14;
              return_value_util_http_build_header_14=util_http_build_header(httpclient->refbuf->data, (unsigned long int)4096, (signed long int)0, 0, 206, (const char *)(void *)0, type, (const char *)(void *)0, (const char *)(void *)0, (struct source_tag *)(void *)0);
              bytes = (signed int)return_value_util_http_build_header_14;
              if(bytes == -1 || bytes >= 4096)
              {
                log_write(errorlog, (unsigned int)1, "fserve/", "fserve_client_create", "Dropping client as we can not build response headers.");
                client_send_500(httpclient, "Header generation failed.");
                return -1;
              }

              signed int return_value_snprintf_15;
              return_value_snprintf_15=snprintf(httpclient->refbuf->data + (signed long int)bytes, (unsigned long int)(4096 - bytes), "Accept-Ranges: bytes\r\nContent-Length: %ld\r\nContent-Range: bytes %ld-%ld/%ld\r\n\r\n", new_content_len, rangenumber, endpos, content_length);
              bytes = bytes + return_value_snprintf_15;
              free((void *)type);
            }

            else
              goto fail;
          }

          else
            goto fail;
        }

        else
        {
          char *fserve_client_create__1__8__type;
          fserve_client_create__1__8__type=fserve_content_type(path);
          httpclient->respcode = 200;
          signed long int return_value_util_http_build_header_16;
          return_value_util_http_build_header_16=util_http_build_header(httpclient->refbuf->data, (unsigned long int)4096, (signed long int)0, 0, 200, (const char *)(void *)0, fserve_client_create__1__8__type, (const char *)(void *)0, (const char *)(void *)0, (struct source_tag *)(void *)0);
          bytes = (signed int)return_value_util_http_build_header_16;
          if(bytes == -1 || bytes >= 4096)
          {
            log_write(errorlog, (unsigned int)1, "fserve/", "fserve_client_create", "Dropping client as we can not build response headers.");
            client_send_500(httpclient, "Header generation failed.");
            return -1;
          }

          signed int return_value_snprintf_17;
          return_value_snprintf_17=snprintf(httpclient->refbuf->data + (signed long int)bytes, (unsigned long int)(4096 - bytes), "Accept-Ranges: bytes\r\nContent-Length: %ld\r\n\r\n", content_length);
          bytes = bytes + return_value_snprintf_17;
          free((void *)fserve_client_create__1__8__type);
        }
        httpclient->refbuf->len = (unsigned int)bytes;
        httpclient->pos = (unsigned int)0;
        stats_event_inc((const char *)(void *)0, "file_connections");
        fserve_add_client(httpclient, file);
        return 0;

      fail:
        ;
        fclose(file);
        httpclient->respcode = 416;
        sock_write(httpclient->con->sock, "HTTP/1.0 416 Request Range Not Satisfiable\r\n\r\n");
        client_destroy(httpclient);
        return -1;
      }
    }
  }
}

// fserve_client_destroy
// file fserve.c line 380
static void fserve_client_destroy(struct _fserve_t *fclient)
{
  if(!(fclient == ((struct _fserve_t *)NULL)))
  {
    if(!(fclient->file == ((struct _IO_FILE *)NULL)))
      fclose(fclient->file);

    if(!(fclient->callback == ((void (*)(struct _client_tag *, void *))NULL)))
      fclient->callback(fclient->client, fclient->arg);

    else
      if(!(fclient->client == ((struct _client_tag *)NULL)))
        client_destroy(fclient->client);

    free((void *)fclient);
  }

}

// fserve_client_waiting
// file fserve.c line 141
signed int fserve_client_waiting(void)
{
  struct _fserve_t *fclient;
  unsigned int i = (unsigned int)0;
  if(!(client_tree_changed == 0))
  {
    client_tree_changed = 0;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)ufds, (unsigned long int)fserve_clients * sizeof(struct pollfd) /*8ul*/ );
    ufds = (struct pollfd *)return_value_realloc_1;
    fclient = active_list;
    for( ; !(fclient == ((struct _fserve_t *)NULL)); i = i + 1u)
    {
      (ufds + (signed long int)i)->fd = fclient->client->con->sock;
      (ufds + (signed long int)i)->events = (signed short int)0x004;
      (ufds + (signed long int)i)->revents = (signed short int)0;
      fclient = fclient->next;
    }
  }

  signed int return_value_poll_2;
  if(ufds == ((struct pollfd *)NULL))
  {
    thread_spin_lock(&pending_lock);
    run_fserv = 0;
    thread_spin_unlock(&pending_lock);
    return -1;
  }

  else
  {
    return_value_poll_2=poll(ufds, (unsigned long int)fserve_clients, 200);
    if(return_value_poll_2 >= 1)
    {
      fclient = active_list;
      i = (unsigned int)0;
      for( ; !(i >= fserve_clients); i = i + 1u)
      {
        if(!((28 & (signed int)(ufds + (signed long int)i)->revents) == 0))
          fclient->ready = 1;

        fclient = fclient->next;
      }
      return 1;
    }

  }
  return 0;
}

// fserve_content_type
// file fserve.h line 37
char * fserve_content_type(const char *path)
{
  char *ext;
  ext=util_get_extension(path);
  struct anonymous_15 exttype = { .ext=ext, .type=(char *)(void *)0 };
  void *result;
  char *type;
  thread_spin_lock(&pending_lock);
  _Bool tmp_if_expr_11;
  signed int return_value_avl_get_by_key_10;
  if(!(mimetypes == ((struct _avl_tree *)NULL)))
  {
    return_value_avl_get_by_key_10=avl_get_by_key(mimetypes, (void *)&exttype, &result);
    tmp_if_expr_11 = !(return_value_avl_get_by_key_10 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_11 = (_Bool)0;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(tmp_if_expr_11)
  {
    struct anonymous_15 *mime = (struct anonymous_15 *)result;
    type=strdup(mime->type);
  }

  else
  {
    signed int return_value_strcmp_9;
    return_value_strcmp_9=strcmp(ext, "ogg");
    if(return_value_strcmp_9 == 0)
      type=strdup("application/ogg");

    else
    {
      return_value_strcmp_8=strcmp(ext, "mp3");
      if(return_value_strcmp_8 == 0)
        type=strdup("audio/mpeg");

      else
      {
        return_value_strcmp_7=strcmp(ext, "html");
        if(return_value_strcmp_7 == 0)
          type=strdup("text/html");

        else
        {
          return_value_strcmp_6=strcmp(ext, "css");
          if(return_value_strcmp_6 == 0)
            type=strdup("text/css");

          else
          {
            return_value_strcmp_5=strcmp(ext, "txt");
            if(return_value_strcmp_5 == 0)
              type=strdup("text/plain");

            else
            {
              return_value_strcmp_4=strcmp(ext, "jpg");
              if(return_value_strcmp_4 == 0)
                type=strdup("image/jpeg");

              else
              {
                return_value_strcmp_3=strcmp(ext, "png");
                if(return_value_strcmp_3 == 0)
                  type=strdup("image/png");

                else
                {
                  return_value_strcmp_2=strcmp(ext, "m3u");
                  if(return_value_strcmp_2 == 0)
                    type=strdup("audio/x-mpegurl");

                  else
                  {
                    return_value_strcmp_1=strcmp(ext, "aac");
                    if(return_value_strcmp_1 == 0)
                      type=strdup("audio/aac");

                    else
                      type=strdup("application/octet-stream");
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  thread_spin_unlock(&pending_lock);
  return type;
}

// fserve_initialize
// file fserve.h line 32
void fserve_initialize(void)
{
  struct ice_config_tag *config;
  config=config_get_config();
  mimetypes = (struct _avl_tree *)(void *)0;
  active_list = (struct _fserve_t *)(void *)0;
  pending_list = (struct _fserve_t *)(void *)0;
  thread_spin_create(&pending_lock);
  fserve_recheck_mime_types(config);
  config_release_config();
  stats_event((const char *)(void *)0, "file_connections", "0");
  log_write(errorlog, (unsigned int)3, "fserve/", "fserve_initialize", "file serving started");
}

// fserve_recheck_mime_types
// file fserve.c line 715
void fserve_recheck_mime_types(struct ice_config_tag *config)
{
  struct _IO_FILE *mimefile;
  char line[4096l];
  char *type;
  char *ext;
  char *cur;
  struct anonymous_15 *mapping;
  struct _avl_tree *new_mimetypes;
  char *return_value_fgets_1;
  _Bool tmp_if_expr_2;
  char *tmp_post_3;
  char *tmp_post_4;
  if(!(config->mimetypes_fn == ((char *)NULL)))
  {
    mimefile=fopen(config->mimetypes_fn, "r");
    if(mimefile == ((struct _IO_FILE *)NULL))
      log_write(errorlog, (unsigned int)2, "fserve/", "fserve_recheck_mime_types", "Cannot open mime types file %s", config->mimetypes_fn);

    else
    {
      new_mimetypes=avl_tree_new(_compare_mappings, (void *)0);
      do
      {
        return_value_fgets_1=fgets(line, 4096, mimefile);
        if(return_value_fgets_1 == ((char *)NULL))
          break;

        line[(signed long int)4095] = (char)0;
        if((signed int)line[0l] == 0)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)line[0l] == 35 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_2)
        {
          type = line;
          cur = line;
          for( ; !((signed int)*cur == 32); cur = cur + 1l)
          {
            if((signed int)*cur == 9)
              break;

            if(*cur == 0)
              break;

          }
          if(!((signed int)*cur == 0))
          {
            tmp_post_3 = cur;
            cur = cur + 1l;
            *tmp_post_3 = (char)0;
            while((_Bool)1)
            {
              for( ; (_Bool)1; cur = cur + 1l)
                if(!((signed int)*cur == 32))
                {
                  if(!((signed int)*cur == 9))
                    goto __CPROVER_DUMP_L11;

                }


            __CPROVER_DUMP_L11:
              ;
              if((signed int)*cur == 0)
                break;

              ext = cur;
              for( ; !((signed int)*cur == 32); cur = cur + 1l)
              {
                if((signed int)*cur == 9)
                  break;

                if((signed int)*cur == 10)
                  break;

                if(*cur == 0)
                  break;

              }
              tmp_post_4 = cur;
              cur = cur + 1l;
              *tmp_post_4 = (char)0;
              if(!(*ext == 0))
              {
                void *tmp;
                void *return_value_malloc_5;
                return_value_malloc_5=malloc(sizeof(struct anonymous_15) /*16ul*/ );
                mapping = (struct anonymous_15 *)return_value_malloc_5;
                mapping->ext=strdup(ext);
                mapping->type=strdup(type);
                signed int return_value_avl_get_by_key_6;
                return_value_avl_get_by_key_6=avl_get_by_key(new_mimetypes, (void *)mapping, &tmp);
                if(return_value_avl_get_by_key_6 == 0)
                  avl_delete(new_mimetypes, (void *)mapping, _delete_mapping);

                avl_insert(new_mimetypes, (void *)mapping);
              }

            }
          }

        }

      }
      while((_Bool)1);
      fclose(mimefile);
      thread_spin_lock(&pending_lock);
      if(!(mimetypes == ((struct _avl_tree *)NULL)))
        avl_tree_free(mimetypes, _delete_mapping);

      mimetypes = new_mimetypes;
      thread_spin_unlock(&pending_lock);
    }
  }

}

// fserve_shutdown
// file fserve.h line 33
void fserve_shutdown(void)
{
  thread_spin_lock(&pending_lock);
  run_fserv = 0;
  while(!(pending_list == ((struct _fserve_t *)NULL)))
  {
    struct _fserve_t *fserve_shutdown__1__1__to_go = (struct _fserve_t *)pending_list;
    pending_list = fserve_shutdown__1__1__to_go->next;
    fserve_client_destroy(fserve_shutdown__1__1__to_go);
  }
  while(!(active_list == ((struct _fserve_t *)NULL)))
  {
    struct _fserve_t *to_go = active_list;
    active_list = to_go->next;
    fserve_client_destroy(to_go);
  }
  if(!(mimetypes == ((struct _avl_tree *)NULL)))
    avl_tree_free(mimetypes, _delete_mapping);

  thread_spin_unlock(&pending_lock);
  thread_spin_destroy(&pending_lock);
  log_write(errorlog, (unsigned int)3, "fserve/", "fserve_shutdown", "file serving stopped");
}

// get_authenticator
// file auth.c line 594
static signed int get_authenticator(struct auth_tag *auth, struct _config_options *options)
{
  if(auth->type == ((char *)NULL))
  {
    log_write(errorlog, (unsigned int)2, "auth/", "get_authenticator", "no authentication type defined");
    return -1;
  }

  else
  {
    log_write(errorlog, (unsigned int)4, "auth/", "get_authenticator", "type is %s", auth->type);
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(auth->type, "url");
    if(return_value_strcmp_2 == 0)
    {
      signed int return_value_auth_get_url_auth_1;
      return_value_auth_get_url_auth_1=auth_get_url_auth(auth, options);
      if(!(return_value_auth_get_url_auth_1 >= 0))
        return -1;

      goto __CPROVER_DUMP_L6;
    }

    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(auth->type, "htpasswd");
    if(return_value_strcmp_4 == 0)
    {
      signed int return_value_auth_get_htpasswd_auth_3;
      return_value_auth_get_htpasswd_auth_3=auth_get_htpasswd_auth(auth, options);
      if(!(return_value_auth_get_htpasswd_auth_3 >= 0))
        return -1;

      goto __CPROVER_DUMP_L6;
    }

    log_write(errorlog, (unsigned int)1, "auth/", "get_authenticator", "Unrecognised authenticator type: \"%s\"", auth->type);
    return -1;

  __CPROVER_DUMP_L6:
    ;
    while(!(options == ((struct _config_options *)NULL)))
    {
      signed int return_value_strcmp_5;
      return_value_strcmp_5=strcmp(options->name, "allow_duplicate_users");
      if(return_value_strcmp_5 == 0)
        auth->allow_duplicate_users=atoi((char *)options->value);

      options = options->next;
    }
    return 0;
  }
}

// get_buffer_audio
// file format_vorbis.c line 145
static struct _refbuf_tag * get_buffer_audio(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  struct _refbuf_tag *refbuf = (struct _refbuf_tag *)(void *)0;
  struct anonymous_3 page;
  struct vorbis_codec_tag *source_vorbis = (struct vorbis_codec_tag *)codec->specific;
  signed int (*get_ogg_page)(struct anonymous_2 *, struct anonymous_3 *) = ogg_stream_pageout;
  if(!((signed long int)source_vorbis->page_samples_trigger >= source_vorbis->samples_in_page))
    get_ogg_page = ogg_stream_flush;

  signed int return_value;
  return_value=get_ogg_page(&source_vorbis->new_os, &page);
  if(return_value >= 1)
  {
    signed long int return_value_ogg_page_granulepos_1;
    return_value_ogg_page_granulepos_1=ogg_page_granulepos(&page);
    source_vorbis->samples_in_page = source_vorbis->samples_in_page - (return_value_ogg_page_granulepos_1 - source_vorbis->prev_page_samples);
    source_vorbis->prev_page_samples=ogg_page_granulepos(&page);
    refbuf=make_refbuf_with_page(&page);
  }

  return refbuf;
}

// get_buffer_finished
// file format_vorbis.c line 186
static struct _refbuf_tag * get_buffer_finished(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  struct vorbis_codec_tag *source_vorbis = (struct vorbis_codec_tag *)codec->specific;
  struct anonymous_3 page;
  struct _refbuf_tag *refbuf;
  signed int return_value_ogg_stream_flush_2;
  return_value_ogg_stream_flush_2=ogg_stream_flush(&source_vorbis->new_os, &page);
  if(return_value_ogg_stream_flush_2 >= 1)
  {
    signed long int return_value_ogg_page_granulepos_1;
    return_value_ogg_page_granulepos_1=ogg_page_granulepos(&page);
    source_vorbis->samples_in_page = source_vorbis->samples_in_page - (return_value_ogg_page_granulepos_1 - source_vorbis->prev_page_samples);
    source_vorbis->prev_page_samples=ogg_page_granulepos(&page);
    refbuf=make_refbuf_with_page(&page);
    log_write(errorlog, (unsigned int)4, "format-vorbis/", "get_buffer_finished", "flushing page");
    return refbuf;
  }

  ogg_stream_clear(&source_vorbis->new_os);
  signed int return_value_rand_3;
  return_value_rand_3=rand();
  ogg_stream_init(&source_vorbis->new_os, return_value_rand_3);
  format_ogg_free_headers(ogg_info);
  source_vorbis->get_buffer_page = (struct _refbuf_tag * (*)(struct ogg_state_tag *, struct ogg_codec_tag *))(void *)0;
  if(!(source_vorbis->prev_packet == ((struct anonymous_14 *)NULL)))
    source_vorbis->process_packet = process_vorbis_headers;

  else
    source_vorbis->process_packet = (signed int (*)(struct ogg_state_tag *, struct ogg_codec_tag *))(void *)0;
  if(source_vorbis->initial_audio_packet == 0)
    source_vorbis->prev_window = 0;

  return (struct _refbuf_tag *)(void *)0;
}

// get_buffer_header
// file format_vorbis.c line 167
static struct _refbuf_tag * get_buffer_header(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  signed int headers_flushed = 0;
  struct anonymous_3 page;
  struct vorbis_codec_tag *source_vorbis = (struct vorbis_codec_tag *)codec->specific;
  signed int return_value_ogg_stream_flush_1;
  do
  {
    return_value_ogg_stream_flush_1=ogg_stream_flush(&source_vorbis->new_os, &page);
    if(!(return_value_ogg_stream_flush_1 >= 1))
      break;

    format_ogg_attach_header(ogg_info, &page);
    headers_flushed = 1;
  }
  while((_Bool)1);
  if(!(headers_flushed == 0))
    source_vorbis->get_buffer_page = get_buffer_audio;

  return (struct _refbuf_tag *)(void *)0;
}

// get_file_data
// file format.c line 150
static signed int get_file_data(struct _IO_FILE *intro, struct _client_tag *client)
{
  struct _refbuf_tag *refbuf = client->refbuf;
  unsigned long int bytes;
  _Bool tmp_if_expr_2;
  signed int return_value_fseek_1;
  if(intro == ((struct _IO_FILE *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_fseek_1=fseek(intro, client->intro_offset, 0);
    tmp_if_expr_2 = return_value_fseek_1 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return 0;

  else
  {
    bytes=fread((void *)refbuf->data, (unsigned long int)1, (unsigned long int)4096, intro);
    if(bytes == 0ul)
      return 0;

    else
    {
      refbuf->len = (unsigned int)bytes;
      return 1;
    }
  }
}

// get_hash
// file auth_htpasswd.c line 71
static char * get_hash(const char *data, signed int len)
{
  struct MD5Context context;
  unsigned char digest[16l];
  MD5Init(&context);
  MD5Update(&context, (const unsigned char *)data, (unsigned int)len);
  MD5Final(digest, &context);
  char *return_value_util_bin_to_hex_1;
  return_value_util_bin_to_hex_1=util_bin_to_hex(digest, 16);
  return return_value_util_bin_to_hex_1;
}

// get_line
// file util.h line 89
signed int get_line(struct _IO_FILE *file, char *buf, unsigned long int siz)
{
  char *return_value_fgets_1;
  return_value_fgets_1=fgets(buf, (signed int)siz, file);
  if(!(return_value_fgets_1 == ((char *)NULL)))
  {
    unsigned long int len;
    len=strlen(buf);
    if(len >= 1ul)
    {
      if((signed int)buf[-1l + (signed long int)len] == 10)
      {
        len = len - 1ul;
        buf[(signed long int)len] = (char)0;
        if(len >= 1ul)
        {
          if((signed int)buf[-1l + (signed long int)len] == 13)
          {
            len = len - 1ul;
            buf[(signed long int)len] = (char)0;
          }

        }

      }

    }

    return 1;
  }

  return 0;
}

// get_next_buffer
// file source.c line 467
static struct _refbuf_tag * get_next_buffer(struct source_tag *source)
{
  struct _refbuf_tag *refbuf = (struct _refbuf_tag *)(void *)0;
  signed int delay = 250;
  if(!(source->short_delay == 0))
    delay = 0;

  if(global.running == 1)
  {
    if(!(source->running == 0))
    {
      signed int fds = 0;
      signed long int current;
      current=time((signed long int *)(void *)0);
      if(!(source->client == ((struct _client_tag *)NULL)))
        fds=util_timed_wait_for_fd(source->con->sock, delay);

      else
      {
        thread_sleep((unsigned long int)(delay * 1000));
        source->last_read = current;
      }
      if(current >= source->client_stats_update)
      {
        stats_event_args(source->mount, "total_bytes_read", "%lu", source->format->read_bytes);
        stats_event_args(source->mount, "total_bytes_sent", "%lu", source->format->sent_bytes);
        source->client_stats_update = current + (signed long int)5;
      }

      if(!(fds >= 0))
      {
        signed int return_value_sock_error_1;
        return_value_sock_error_1=sock_error();
        signed int return_value_sock_recoverable_2;
        return_value_sock_recoverable_2=sock_recoverable(return_value_sock_error_1);
        if(return_value_sock_recoverable_2 == 0)
        {
          log_write(errorlog, (unsigned int)2, "source/", "get_next_buffer", "Error while waiting on socket, Disconnecting source");
          source->running = 0;
        }

        goto __CPROVER_DUMP_L12;
      }

      if(fds == 0)
      {
        thread_mutex_lock_c(&source->lock, 506, "source.c");
        if(!(source->last_read + (signed long int)source->timeout >= current))
        {
          log_write(errorlog, (unsigned int)4, "source/", "get_next_buffer", "last %ld, timeout %d, now %ld", (signed long int)source->last_read, source->timeout, (signed long int)current);
          log_write(errorlog, (unsigned int)2, "source/", "get_next_buffer", "Disconnecting source due to socket timeout");
          source->running = 0;
        }

        thread_mutex_unlock_c(&source->lock, 514, "source.c");
      }

      else
      {
        source->last_read = current;
        refbuf=source->format->get_buffer(source);
        if(!(source->client->con == ((struct connection_tag *)NULL)))
        {
          log_write(errorlog, (unsigned int)3, "source/", "get_next_buffer", "End of Stream %s", source->mount);
          source->running = 0;
        }

      }
    }

  }


__CPROVER_DUMP_L12:
  ;
  return refbuf;
}

// get_ssl_certificate
// file connection.c line 286
static void get_ssl_certificate(struct ice_config_tag *config)
{
  ssl_ok = 0;
  log_write(errorlog, (unsigned int)3, "connection/", "get_ssl_certificate", "No SSL capability");
}

// global_initialize
// file global.h line 49
void global_initialize(void)
{
  global.server_sockets = 0;
  global.relays = (struct _relay_server *)(void *)0;
  global.master_relays = (struct _relay_server *)(void *)0;
  global.running = 0;
  global.clients = 0;
  global.sources = 0;
  global.source_tree=avl_tree_new(source_compare_sources, (void *)0);
  thread_mutex_create_c(&_global_mutex, 45, "global.c");
}

// global_lock
// file global.h line 51
void global_lock(void)
{
  thread_mutex_lock_c(&_global_mutex, 56, "global.c");
}

// global_shutdown
// file global.h line 50
void global_shutdown(void)
{
  thread_mutex_destroy(&_global_mutex);
  avl_tree_free(global.source_tree, (signed int (*)(void *))(void *)0);
}

// global_unlock
// file global.h line 52
void global_unlock(void)
{
  thread_mutex_unlock_c(&_global_mutex, 61, "global.c");
}

// handle_returned_data
// file auth_url.c line 175
static unsigned long int handle_returned_data(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream)
{
  return (unsigned long int)(signed int)(size * nmemb);
}

// handle_returned_data_link1
// file yp.c line 150
static signed int handle_returned_data_link1(void *ptr_link1, unsigned long int size_link1, unsigned long int nmemb_link1, void *stream_link1)
{
  return (signed int)(size_link1 * nmemb_link1);
}

// handle_returned_header
// file auth_url.c line 141
static unsigned long int handle_returned_header(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream)
{
  struct auth_client_tag *auth_user = (struct auth_client_tag *)stream;
  unsigned int bytes = (unsigned int)(size * nmemb);
  struct _client_tag *client = auth_user->client;
  if(!(client == ((struct _client_tag *)NULL)))
  {
    struct auth_tag *auth = client->auth;
    struct anonymous_33 *url = (struct anonymous_33 *)auth->state;
    signed int return_value_strncasecmp_1;
    return_value_strncasecmp_1=strncasecmp((const char *)ptr, url->auth_header, (unsigned long int)url->auth_header_len);
    if(return_value_strncasecmp_1 == 0)
      client->authenticated = 1;

    signed int return_value_strncasecmp_3;
    return_value_strncasecmp_3=strncasecmp((const char *)ptr, url->timelimit_header, (unsigned long int)url->timelimit_header_len);
    if(return_value_strncasecmp_3 == 0)
    {
      unsigned int limit = (unsigned int)0;
      sscanf((char *)ptr + (signed long int)url->timelimit_header_len, "%u\r\n", &limit);
      signed long int return_value_time_2;
      return_value_time_2=time((signed long int *)(void *)0);
      client->con->discon_time = return_value_time_2 + (signed long int)limit;
    }

    signed int return_value_strncasecmp_4;
    return_value_strncasecmp_4=strncasecmp((const char *)ptr, "icecast-auth-message: ", (unsigned long int)22);
    if(return_value_strncasecmp_4 == 0)
    {
      char *eol;
      snprintf(url->errormsg, sizeof(char [256l]) /*256ul*/ , "%s", (char *)ptr + (signed long int)22);
      eol=strchr(url->errormsg, 13);
      if(eol == ((char *)NULL))
        eol=strchr(url->errormsg, 10);

      if(!(eol == ((char *)NULL)))
        *eol = (char)0;

    }

  }

  return (unsigned long int)(signed int)bytes;
}

// handle_returned_header_link1
// file yp.c line 106
static signed int handle_returned_header_link1(void *ptr_link1, unsigned long int size_link1, unsigned long int nmemb_link1, void *stream_link1)
{
  struct ypdata_tag *yp = (struct ypdata_tag *)stream_link1;
  unsigned int bytes_link1 = (unsigned int)(size_link1 * nmemb_link1);
  signed int return_value_strncasecmp_1_link1;
  return_value_strncasecmp_1_link1=strncasecmp((const char *)ptr_link1, "YPResponse: 1", (unsigned long int)13);
  if(return_value_strncasecmp_1_link1 == 0)
    yp->cmd_ok = 1;

  signed int return_value_strncasecmp_3_link1;
  return_value_strncasecmp_3_link1=strncasecmp((const char *)ptr_link1, "YPMessage: ", (unsigned long int)11);
  if(return_value_strncasecmp_3_link1 == 0)
  {
    unsigned int handle_returned_header__1__1__len = bytes_link1 - (unsigned int)11;
    free((void *)yp->error_msg);
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, (unsigned long int)handle_returned_header__1__1__len);
    yp->error_msg = (char *)return_value_calloc_2;
    if(!(yp->error_msg == ((char *)NULL)))
      sscanf((const char *)(ptr_link1 + (signed long int)11), "%[^\r\n]", yp->error_msg);

  }

  if(yp->process == do_yp_add)
  {
    signed int return_value_strncasecmp_5;
    return_value_strncasecmp_5=strncasecmp((const char *)ptr_link1, "SID: ", (unsigned long int)5);
    if(return_value_strncasecmp_5 == 0)
    {
      unsigned int len = bytes_link1 - (unsigned int)5;
      free((void *)yp->sid);
      void *return_value_calloc_4;
      return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)len);
      yp->sid = (char *)return_value_calloc_4;
      if(!(yp->sid == ((char *)NULL)))
        sscanf((const char *)(ptr_link1 + (signed long int)5), "%[^\r\n]", yp->sid);

    }

  }

  signed int return_value_strncasecmp_7;
  return_value_strncasecmp_7=strncasecmp((const char *)ptr_link1, "TouchFreq: ", (unsigned long int)11);
  if(return_value_strncasecmp_7 == 0)
  {
    unsigned int secs;
    signed int return_value_sscanf_6;
    return_value_sscanf_6=sscanf((const char *)(ptr_link1 + (signed long int)11), "%u", &secs);
    if(!(return_value_sscanf_6 == 1))
      secs = (unsigned int)0;

    if(!(secs >= 30u))
      secs = (unsigned int)30;

    log_write(errorlog, (unsigned int)4, "yp/", "handle_returned_header", "server touch interval is %u", secs);
    yp->touch_interval = secs;
  }

  return (signed int)bytes_link1;
}

// hex
// file util.c line 177
static signed int hex(char c)
{
  if((signed int)c >= 48 && !((signed int)c >= 58))
    return (signed int)c - 48;

  else
    if((signed int)c >= 65 && !((signed int)c >= 71))
      return ((signed int)c - 65) + 10;

    else
      if((signed int)c >= 97 && !((signed int)c >= 103))
        return ((signed int)c - 97) + 10;

      else
        return -1;
}

// hex_link1
// file httpp.c line 191
static signed int hex_link1(char c_link1)
{
  if((signed int)c_link1 >= 48 && !((signed int)c_link1 >= 58))
    return (signed int)c_link1 - 48;

  else
    if((signed int)c_link1 >= 65 && !((signed int)c_link1 >= 71))
      return ((signed int)c_link1 - 65) + 10;

    else
      if((signed int)c_link1 >= 97 && !((signed int)c_link1 >= 103))
        return ((signed int)c_link1 - 97) + 10;

      else
        return -1;
}

// html_success
// file admin.c line 605
static void html_success(struct _client_tag *client, char *message)
{
  signed long int ret;
  ret=util_http_build_header(client->refbuf->data, (unsigned long int)4096, (signed long int)0, 0, 200, (const char *)(void *)0, "text/html", "utf-8", "", (struct source_tag *)(void *)0);
  if(ret == -1l || ret >= 4096l)
  {
    log_write(errorlog, (unsigned int)1, "admin/", "html_success", "Dropping client as we can not build response headers.");
    client_send_500(client, "Header generation failed.");
  }

  else
  {
    snprintf(client->refbuf->data + ret, (unsigned long int)((signed long int)4096 - ret), "<html><head><title>Admin request successful</title></head><body><p>%s</p></body></html>", message);
    client->respcode = 200;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(client->refbuf->data);
    client->refbuf->len = (unsigned int)return_value_strlen_1;
    fserve_add_client(client, (struct _IO_FILE *)(void *)0);
  }
}

// htpasswd_adduser
// file auth_htpasswd.c line 257
static enum anonymous_19 htpasswd_adduser(struct auth_tag *auth, const char *username, const char *password)
{
  struct _IO_FILE *passwdfile;
  char *hashed_password = (char *)(void *)0;
  struct anonymous_20 *state = (struct anonymous_20 *)auth->state;
  struct anonymous_22 entry;
  void *result;
  htpasswd_recheckfile(state);
  thread_rwlock_wlock_c(&state->file_rwlock, 267, "auth_htpasswd.c");
  entry.name = (char *)username;
  signed int return_value_avl_get_by_key_1;
  return_value_avl_get_by_key_1=avl_get_by_key(state->users, (void *)&entry, &result);
  if(return_value_avl_get_by_key_1 == 0)
  {
    thread_rwlock_unlock_c(&state->file_rwlock, 272, "auth_htpasswd.c");
    return (enum anonymous_19)AUTH_USEREXISTS;
  }

  else
  {
    passwdfile=fopen(state->filename, "ab");
    if(passwdfile == ((struct _IO_FILE *)NULL))
    {
      thread_rwlock_unlock_c(&state->file_rwlock, 280, "auth_htpasswd.c");
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      log_write(errorlog, (unsigned int)2, "auth_htpasswd/", "htpasswd_adduser", "Failed to open authentication database \"%s\": %s", state->filename, return_value_strerror_3);
      return (enum anonymous_19)AUTH_FAILED;
    }

    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(password);
    hashed_password=get_hash(password, (signed int)return_value_strlen_4);
    if(!(hashed_password == ((char *)NULL)))
    {
      fprintf(passwdfile, "%s:%s\n", username, hashed_password);
      free((void *)hashed_password);
    }

    fclose(passwdfile);
    thread_rwlock_unlock_c(&state->file_rwlock, 293, "auth_htpasswd.c");
    return (enum anonymous_19)AUTH_USERADDED;
  }
}

// htpasswd_auth
// file auth_htpasswd.c line 179
static enum anonymous_19 htpasswd_auth(struct auth_client_tag *auth_user)
{
  struct auth_tag *auth = auth_user->client->auth;
  struct anonymous_20 *htpasswd = (struct anonymous_20 *)auth->state;
  struct _client_tag *client = auth_user->client;
  struct anonymous_22 entry;
  void *result;
  _Bool tmp_if_expr_1;
  if(client->username == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = client->password == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (enum anonymous_19)AUTH_FAILED;

  else
    if(htpasswd->filename == ((char *)NULL))
    {
      log_write(errorlog, (unsigned int)1, "auth_htpasswd/", "htpasswd_auth", "No filename given in options for authenticator.");
      return (enum anonymous_19)AUTH_FAILED;
    }

    else
    {
      htpasswd_recheckfile(htpasswd);
      thread_rwlock_rlock_c(&htpasswd->file_rwlock, 197, "auth_htpasswd.c");
      entry.name = client->username;
      signed int return_value_avl_get_by_key_4;
      return_value_avl_get_by_key_4=avl_get_by_key(htpasswd->users, (void *)&entry, &result);
      if(return_value_avl_get_by_key_4 == 0)
      {
        struct anonymous_22 *found = (struct anonymous_22 *)result;
        char *hashed_pw;
        thread_rwlock_unlock_c(&htpasswd->file_rwlock, 204, "auth_htpasswd.c");
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(client->password);
        hashed_pw=get_hash(client->password, (signed int)return_value_strlen_2);
        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp(found->pass, hashed_pw);
        if(return_value_strcmp_3 == 0)
        {
          free((void *)hashed_pw);
          return (enum anonymous_19)AUTH_OK;
        }

        free((void *)hashed_pw);
        log_write(errorlog, (unsigned int)4, "auth_htpasswd/", "htpasswd_auth", "incorrect password for client");
        return (enum anonymous_19)AUTH_FAILED;
      }

      log_write(errorlog, (unsigned int)4, "auth_htpasswd/", "htpasswd_auth", "no such username: %s", client->username);
      thread_rwlock_unlock_c(&htpasswd->file_rwlock, 216, "auth_htpasswd.c");
      return (enum anonymous_19)AUTH_FAILED;
    }
}

// htpasswd_clear
// file auth_htpasswd.c line 60
static void htpasswd_clear(struct auth_tag *self)
{
  struct anonymous_20 *state = (struct anonymous_20 *)self->state;
  free((void *)state->filename);
  if(!(state->users == ((struct _avl_tree *)NULL)))
    avl_tree_free(state->users, _free_user);

  thread_rwlock_destroy(&state->file_rwlock);
  free((void *)state);
}

// htpasswd_deleteuser
// file auth_htpasswd.c line 299
static enum anonymous_19 htpasswd_deleteuser(struct auth_tag *auth, const char *username)
{
  struct _IO_FILE *passwdfile;
  struct _IO_FILE *tmp_passwdfile;
  struct anonymous_20 *state;
  char line[512l];
  char *sep;
  char *tmpfile = (char *)(void *)0;
  signed int tmpfile_len = 0;
  struct stat file_info;
  state = (struct anonymous_20 *)auth->state;
  thread_rwlock_wlock_c(&state->file_rwlock, 311, "auth_htpasswd.c");
  passwdfile=fopen(state->filename, "rb");
  if(passwdfile == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_write(errorlog, (unsigned int)2, "auth_htpasswd/", "htpasswd_deleteuser", "Failed to open authentication database \"%s\": %s", state->filename, return_value_strerror_2);
    thread_rwlock_unlock_c(&state->file_rwlock, 317, "auth_htpasswd.c");
    return (enum anonymous_19)AUTH_FAILED;
  }

  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(state->filename);
  tmpfile_len = (signed int)(return_value_strlen_3 + (unsigned long int)6);
  void *return_value_calloc_4;
  return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)tmpfile_len);
  tmpfile = (char *)return_value_calloc_4;
  snprintf(tmpfile, (unsigned long int)tmpfile_len, "%s.tmp", state->filename);
  signed int return_value_stat_5;
  return_value_stat_5=stat(tmpfile, &file_info);
  signed int return_value_get_line_8;
  _Bool tmp_if_expr_9;
  if(return_value_stat_5 == 0)
  {
    log_write(errorlog, (unsigned int)2, "auth_htpasswd/", "htpasswd_deleteuser", "temp file \"%s\" exists, rejecting operation", tmpfile);
    free((void *)tmpfile);
    fclose(passwdfile);
    thread_rwlock_unlock_c(&state->file_rwlock, 328, "auth_htpasswd.c");
    return (enum anonymous_19)AUTH_FAILED;
  }

  else
  {
    tmp_passwdfile=fopen(tmpfile, "wb");
    if(tmp_passwdfile == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      log_write(errorlog, (unsigned int)2, "auth_htpasswd/", "htpasswd_deleteuser", "Failed to open temporary authentication database \"%s\": %s", tmpfile, return_value_strerror_7);
      fclose(passwdfile);
      free((void *)tmpfile);
      thread_rwlock_unlock_c(&state->file_rwlock, 339, "auth_htpasswd.c");
      return (enum anonymous_19)AUTH_FAILED;
    }

    do
    {
      return_value_get_line_8=get_line(passwdfile, line, (unsigned long int)512);
      if(return_value_get_line_8 == 0)
        break;

      if(line[0l] == 0)
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_9)
      {
        sep=strchr(line, 58);
        if(sep == ((char *)NULL))
          log_write(errorlog, (unsigned int)4, "auth_htpasswd/", "htpasswd_deleteuser", "No separator in line");

        else
        {
          *sep = (char)0;
          signed int return_value_strcmp_10;
          return_value_strcmp_10=strcmp(username, line);
          if(!(return_value_strcmp_10 == 0))
          {
            *sep = (char)58;
            fprintf(tmp_passwdfile, "%s\n", (const void *)line);
          }

        }
      }

    }
    while((_Bool)1);
    fclose(tmp_passwdfile);
    fclose(passwdfile);
    signed int return_value_remove_16;
    return_value_remove_16=remove(state->filename);
    if(!(return_value_remove_16 == 0))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      log_write(errorlog, (unsigned int)1, "auth_htpasswd/", "htpasswd_deleteuser", "Problem moving temp authentication file to original \"%s\" - \"%s\": %s", tmpfile, state->filename, return_value_strerror_12);
    }

    else
    {
      signed int return_value_rename_15;
      return_value_rename_15=rename(tmpfile, state->filename);
      if(!(return_value_rename_15 == 0))
      {
        signed int *return_value___errno_location_13;
        return_value___errno_location_13=__errno_location();
        char *return_value_strerror_14;
        return_value_strerror_14=strerror(*return_value___errno_location_13);
        log_write(errorlog, (unsigned int)1, "auth_htpasswd/", "htpasswd_deleteuser", "Problem moving temp authentication file to original \"%s\" - \"%s\": %s", tmpfile, state->filename, return_value_strerror_14);
      }

    }
    free((void *)tmpfile);
    thread_rwlock_unlock_c(&state->file_rwlock, 380, "auth_htpasswd.c");
    htpasswd_recheckfile(state);
    return (enum anonymous_19)AUTH_USERDELETED;
  }
}

// htpasswd_recheckfile
// file auth_htpasswd.c line 105
static void htpasswd_recheckfile(struct anonymous_20 *htpasswd)
{
  struct _IO_FILE *passwdfile;
  struct _avl_tree *new_users;
  signed int num = 0;
  struct stat file_stat;
  char *sep;
  char line[512l];
  signed int return_value_get_line_4;
  _Bool tmp_if_expr_5;
  if(!(htpasswd->filename == ((char *)NULL)))
  {
    signed int return_value_stat_1;
    return_value_stat_1=stat(htpasswd->filename, &file_stat);
    if(!(return_value_stat_1 >= 0))
    {
      log_write(errorlog, (unsigned int)2, "auth_htpasswd/", "htpasswd_recheckfile", "failed to check status of %s", htpasswd->filename);
      thread_rwlock_wlock_c(&htpasswd->file_rwlock, 121, "auth_htpasswd.c");
      if(htpasswd->users == ((struct _avl_tree *)NULL))
        htpasswd->users=avl_tree_new(compare_users, (void *)0);

      thread_rwlock_unlock_c(&htpasswd->file_rwlock, 124, "auth_htpasswd.c");
    }

    else
      if(!(file_stat.st_mtim.tv_sec == htpasswd->mtime))
      {
        log_write(errorlog, (unsigned int)3, "auth_htpasswd/", "htpasswd_recheckfile", "re-reading htpasswd file \"%s\"", htpasswd->filename);
        passwdfile=fopen(htpasswd->filename, "rb");
        if(passwdfile == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          log_write(errorlog, (unsigned int)2, "auth_htpasswd/", "htpasswd_recheckfile", "Failed to open authentication database \"%s\": %s", htpasswd->filename, return_value_strerror_3);
          goto __CPROVER_DUMP_L14;
        }

        htpasswd->mtime = file_stat.st_mtim.tv_sec;
        new_users=avl_tree_new(compare_users, (void *)0);
        do
        {
          return_value_get_line_4=get_line(passwdfile, line, (unsigned long int)512);
          if(return_value_get_line_4 == 0)
            break;

          signed int len;
          struct anonymous_22 *entry;
          num = num + 1;
          if(line[0l] == 0)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr_5)
          {
            sep=strrchr(line, 58);
            if(sep == ((char *)NULL))
              log_write(errorlog, (unsigned int)2, "auth_htpasswd/", "htpasswd_recheckfile", "No separator on line %d (%s)", num, htpasswd->filename);

            else
            {
              void *return_value_calloc_6;
              return_value_calloc_6=calloc((unsigned long int)1, sizeof(struct anonymous_22) /*16ul*/ );
              entry = (struct anonymous_22 *)return_value_calloc_6;
              unsigned long int return_value_strlen_7;
              return_value_strlen_7=strlen(line);
              len = (signed int)(return_value_strlen_7 + (unsigned long int)1);
              void *return_value_malloc_8;
              return_value_malloc_8=malloc((unsigned long int)len);
              entry->name = (char *)return_value_malloc_8;
              *sep = (char)0;
              memcpy((void *)entry->name, (const void *)line, (unsigned long int)len);
              entry->pass = entry->name + (sep - line) + (signed long int)1;
              avl_insert(new_users, (void *)entry);
            }
          }

        }
        while((_Bool)1);
        fclose(passwdfile);
        thread_rwlock_wlock_c(&htpasswd->file_rwlock, 171, "auth_htpasswd.c");
        if(!(htpasswd->users == ((struct _avl_tree *)NULL)))
          avl_tree_free(htpasswd->users, _free_user);

        htpasswd->users = new_users;
        thread_rwlock_unlock_c(&htpasswd->file_rwlock, 175, "auth_htpasswd.c");
      }

  }


__CPROVER_DUMP_L14:
  ;
}

// htpasswd_userlist
// file auth_htpasswd.c line 387
static enum anonymous_19 htpasswd_userlist(struct auth_tag *auth, struct _xmlNode *srcnode)
{
  struct anonymous_20 *state;
  struct _xmlNode *newnode;
  struct avl_node_tag *node;
  state = (struct anonymous_20 *)auth->state;
  htpasswd_recheckfile(state);
  thread_rwlock_rlock_c(&state->file_rwlock, 397, "auth_htpasswd.c");
  node=avl_get_first(state->users);
  while(!(node == ((struct avl_node_tag *)NULL)))
  {
    struct anonymous_22 *user = (struct anonymous_22 *)node->key;
    newnode=xmlNewChild(srcnode, (struct _xmlNs *)(void *)0, (unsigned char *)"User", (const unsigned char *)(void *)0);
    xmlNewChild(newnode, (struct _xmlNs *)(void *)0, (unsigned char *)"username", (unsigned char *)user->name);
    xmlNewChild(newnode, (struct _xmlNs *)(void *)0, (unsigned char *)"password", (unsigned char *)user->pass);
    node=avl_get_next(node);
  }
  thread_rwlock_unlock_c(&state->file_rwlock, 407, "auth_htpasswd.c");
  return (enum anonymous_19)AUTH_OK;
}

// httpp_clear
// file httpp.c line 521
void httpp_clear(struct http_parser_tag *parser)
{
  parser->req_type = (enum httpp_request_type_tag)httpp_req_none;
  if(!(parser->uri == ((char *)NULL)))
    free((void *)parser->uri);

  parser->uri = (char *)(void *)0;
  avl_tree_free(parser->vars, _free_vars);
  avl_tree_free(parser->queryvars, _free_vars);
  parser->vars = (struct _avl_tree *)(void *)0;
}

// httpp_create_parser
// file httpp/httpp.h line 60
struct http_parser_tag * httpp_create_parser(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct http_parser_tag) /*32ul*/ );
  return (struct http_parser_tag *)return_value_malloc_1;
}

// httpp_deletevar
// file httpp.c line 433
void httpp_deletevar(struct http_parser_tag *parser, const char *name)
{
  struct http_var_tag var;
  if(!(name == ((const char *)NULL)) && !(parser == ((struct http_parser_tag *)NULL)))
  {
    var.name = (char *)name;
    var.value = (char *)(void *)0;
    avl_delete(parser->vars, (void *)&var, _free_vars);
  }

}

// httpp_destroy
// file httpp/httpp.h line 70
void httpp_destroy(struct http_parser_tag *parser)
{
  httpp_clear(parser);
  free((void *)parser);
}

// httpp_get_query_param
// file httpp/httpp.h line 69
const char * httpp_get_query_param(struct http_parser_tag *parser, const char *name)
{
  struct http_var_tag var;
  struct http_var_tag *found;
  void *fp = (void *)&found;
  var.name = (char *)name;
  var.value = (char *)(void *)0;
  signed int return_value_avl_get_by_key_1;
  return_value_avl_get_by_key_1=avl_get_by_key(parser->queryvars, (void *)&var, (void **)fp);
  if(return_value_avl_get_by_key_1 == 0)
    return found->value;

  else
    return (const char *)(void *)0;
}

// httpp_getvar
// file httpp/httpp.h line 67
const char * httpp_getvar(struct http_parser_tag *parser, const char *name)
{
  struct http_var_tag var;
  struct http_var_tag *found;
  void *fp;
  if(name == ((const char *)NULL) || parser == ((struct http_parser_tag *)NULL))
    return (const char *)(void *)0;

  else
  {
    fp = (void *)&found;
    var.name = (char *)name;
    var.value = (char *)(void *)0;
    signed int return_value_avl_get_by_key_1;
    return_value_avl_get_by_key_1=avl_get_by_key(parser->vars, (void *)&var, (void **)fp);
    if(return_value_avl_get_by_key_1 == 0)
      return found->value;

    else
      return (const char *)(void *)0;
  }
}

// httpp_initialize
// file httpp/httpp.h line 61
void httpp_initialize(struct http_parser_tag *parser, struct http_varlist_tag *defaults)
{
  struct http_varlist_tag *list;
  parser->req_type = (enum httpp_request_type_tag)httpp_req_none;
  parser->uri = (char *)(void *)0;
  parser->vars=avl_tree_new(_compare_vars, (void *)0);
  parser->queryvars=avl_tree_new(_compare_vars, (void *)0);
  list = defaults;
  for( ; !(list == ((struct http_varlist_tag *)NULL)); list = list->next)
    httpp_setvar(parser, list->var.name, list->var.value);
}

// httpp_parse
// file httpp/httpp.h line 62
signed int httpp_parse(struct http_parser_tag *parser, const char *http_data, unsigned long int len)
{
  char *data;
  char *tmp;
  char *line[32l];
  signed int i;
  signed int lines;
  char *req_type = (char *)(void *)0;
  char *uri = (char *)(void *)0;
  char *version = (char *)(void *)0;
  signed int whitespace;
  signed int where;
  signed int slen;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  _Bool tmp_if_expr_11;
  unsigned long int return_value_strlen_10;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_14;
  unsigned long int return_value_strlen_13;
  _Bool tmp_if_expr_16;
  if(http_data == ((const char *)NULL))
    return 0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(len + (unsigned long int)1);
    data = (char *)return_value_malloc_1;
    if(data == ((char *)NULL))
      return 0;

    else
    {
      memcpy((void *)data, (const void *)http_data, len);
      data[(signed long int)len] = (char)0;
      lines=split_headers(data, len, line);
      where = 0;
      whitespace = 0;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(line[(signed long int)0]);
      slen = (signed int)return_value_strlen_2;
      req_type = line[(signed long int)0];
      i = 0;
      for( ; !(i >= slen); i = i + 1)
        if((signed int)line[0l][(signed long int)i] == 32)
        {
          whitespace = 1;
          line[(signed long int)0][(signed long int)i] = (char)0;
        }

        else
          if(!(whitespace == 0))
          {
            whitespace = 0;
            where = where + 1;
            switch(where)
            {
              case 1:
              {
                uri = &line[(signed long int)0][(signed long int)i];
                break;
              }
              case 2:
                version = &line[(signed long int)0][(signed long int)i];
            }
          }

      signed int return_value_strcasecmp_9;
      return_value_strcasecmp_9=strcasecmp("GET", req_type);
      if(return_value_strcasecmp_9 == 0)
        parser->req_type = (enum httpp_request_type_tag)httpp_req_get;

      else
      {
        return_value_strcasecmp_8=strcasecmp("POST", req_type);
        if(return_value_strcasecmp_8 == 0)
          parser->req_type = (enum httpp_request_type_tag)httpp_req_post;

        else
        {
          return_value_strcasecmp_7=strcasecmp("PUT", req_type);
          if(return_value_strcasecmp_7 == 0)
            parser->req_type = (enum httpp_request_type_tag)httpp_req_put;

          else
          {
            return_value_strcasecmp_6=strcasecmp("HEAD", req_type);
            if(return_value_strcasecmp_6 == 0)
              parser->req_type = (enum httpp_request_type_tag)httpp_req_head;

            else
            {
              return_value_strcasecmp_5=strcasecmp("SOURCE", req_type);
              if(return_value_strcasecmp_5 == 0)
                parser->req_type = (enum httpp_request_type_tag)httpp_req_source;

              else
              {
                return_value_strcasecmp_4=strcasecmp("PLAY", req_type);
                if(return_value_strcasecmp_4 == 0)
                  parser->req_type = (enum httpp_request_type_tag)httpp_req_play;

                else
                {
                  return_value_strcasecmp_3=strcasecmp("STATS", req_type);
                  if(return_value_strcasecmp_3 == 0)
                    parser->req_type = (enum httpp_request_type_tag)httpp_req_stats;

                  else
                    parser->req_type = (enum httpp_request_type_tag)httpp_req_unknown;
                }
              }
            }
          }
        }
      }
      if(!(uri == ((char *)NULL)))
      {
        return_value_strlen_10=strlen(uri);
        tmp_if_expr_11 = return_value_strlen_10 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_11 = (_Bool)0;
      if(tmp_if_expr_11)
      {
        char *query;
        query=strchr(uri, 63);
        if(!(query == ((char *)NULL)))
        {
          httpp_setvar(parser, "__rawuri", uri);
          httpp_setvar(parser, " __queryargs", query);
          *query = (char)0;
          query = query + 1l;
          parse_query(parser, query);
        }

        parser->uri=strdup(uri);
      }

      else
      {
        free((void *)data);
        return 0;
      }
      if(!(version == ((char *)NULL)))
      {
        tmp=strchr(version, 47);
        tmp_if_expr_15 = tmp != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_15 = (_Bool)0;
      if(tmp_if_expr_15)
      {
        tmp[(signed long int)0] = (char)0;
        unsigned long int return_value_strlen_12;
        return_value_strlen_12=strlen(version);
        if(return_value_strlen_12 >= 1ul)
        {
          return_value_strlen_13=strlen(&tmp[(signed long int)1]);
          tmp_if_expr_14 = return_value_strlen_13 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_14 = (_Bool)0;
        if(tmp_if_expr_14)
        {
          httpp_setvar(parser, "__protocol", version);
          httpp_setvar(parser, "__version", &tmp[(signed long int)1]);
        }

        else
        {
          free((void *)data);
          return 0;
        }
      }

      else
      {
        free((void *)data);
        return 0;
      }
      if(!((signed int)parser->req_type == httpp_req_none))
        tmp_if_expr_16 = (signed int)parser->req_type != httpp_req_unknown ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_16 = (_Bool)0;
      if(tmp_if_expr_16)
        switch((signed int)parser->req_type)
        {
          case httpp_req_get:
          {
            httpp_setvar(parser, "__req_type", "GET");
            break;
          }
          case httpp_req_post:
          {
            httpp_setvar(parser, "__req_type", "POST");
            break;
          }
          case httpp_req_put:
          {
            httpp_setvar(parser, "__req_type", "PUT");
            break;
          }
          case httpp_req_head:
          {
            httpp_setvar(parser, "__req_type", "HEAD");
            break;
          }
          case httpp_req_source:
          {
            httpp_setvar(parser, "__req_type", "SOURCE");
            break;
          }
          case httpp_req_play:
          {
            httpp_setvar(parser, "__req_type", "PLAY");
            break;
          }
          case httpp_req_stats:
            httpp_setvar(parser, "__req_type", "STATS");
        }

      else
      {
        free((void *)data);
        return 0;
      }
      if(!(parser->uri == ((char *)NULL)))
        httpp_setvar(parser, "__uri", parser->uri);

      else
      {
        free((void *)data);
        return 0;
      }
      parse_headers(parser, line, lines);
      free((void *)data);
      return 1;
    }
  }
}

// httpp_parse_response
// file httpp/httpp.h line 64
signed int httpp_parse_response(struct http_parser_tag *parser, const char *http_data, unsigned long int len, const char *uri)
{
  char *data;
  char *line[32l];
  signed int lines;
  signed int slen;
  signed int i;
  signed int whitespace = 0;
  signed int where = 0;
  signed int code;
  char *version = (char *)(void *)0;
  char *resp_code = (char *)(void *)0;
  char *message = (char *)(void *)0;
  if(http_data == ((const char *)NULL))
    return 0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(len + (unsigned long int)1);
    data = (char *)return_value_malloc_1;
    if(data == ((char *)NULL))
      return 0;

    else
    {
      memcpy((void *)data, (const void *)http_data, len);
      data[(signed long int)len] = (char)0;
      lines=split_headers(data, len, line);
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(line[(signed long int)0]);
      slen = (signed int)return_value_strlen_2;
      version = line[(signed long int)0];
      i = 0;
      for( ; !(i >= slen); i = i + 1)
        if((signed int)line[0l][(signed long int)i] == 32)
        {
          line[(signed long int)0][(signed long int)i] = (char)0;
          whitespace = 1;
        }

        else
          if(!(whitespace == 0))
          {
            whitespace = 0;
            where = where + 1;
            if(where == 1)
              resp_code = &line[(signed long int)0][(signed long int)i];

            else
            {
              message = &line[(signed long int)0][(signed long int)i];
              break;
            }
          }

      if(message == ((char *)NULL) || resp_code == ((char *)NULL) || version == ((char *)NULL))
      {
        free((void *)data);
        return 0;
      }

      else
      {
        httpp_setvar(parser, "__errorcode", resp_code);
        code=atoi(resp_code);
        if(code >= 300 || !(code >= 200))
          httpp_setvar(parser, "__errormessage", message);

        httpp_setvar(parser, "__uri", uri);
        httpp_setvar(parser, "__req_type", "NONE");
        parse_headers(parser, line, lines);
        free((void *)data);
        return 1;
      }
    }
  }
}

// httpp_set_query_param
// file httpp/httpp.h line 68
void httpp_set_query_param(struct http_parser_tag *parser, const char *name, const char *value)
{
  struct http_var_tag *var;
  if(!(name == ((const char *)NULL)) && !(value == ((const char *)NULL)))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct http_var_tag) /*16ul*/ );
    var = (struct http_var_tag *)return_value_malloc_1;
    if(!(var == ((struct http_var_tag *)NULL)))
    {
      var->name=strdup(name);
      var->value=url_escape(value);
      const char *return_value_httpp_get_query_param_2;
      return_value_httpp_get_query_param_2=httpp_get_query_param(parser, name);
      if(return_value_httpp_get_query_param_2 == ((const char *)NULL))
        avl_insert(parser->queryvars, (void *)var);

      else
      {
        avl_delete(parser->queryvars, (void *)var, _free_vars);
        avl_insert(parser->queryvars, (void *)var);
      }
    }

  }

}

// httpp_setvar
// file httpp/httpp.h line 65
void httpp_setvar(struct http_parser_tag *parser, const char *name, const char *value)
{
  struct http_var_tag *var;
  if(!(name == ((const char *)NULL)) && !(value == ((const char *)NULL)))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct http_var_tag) /*16ul*/ );
    var = (struct http_var_tag *)return_value_malloc_1;
    if(!(var == ((struct http_var_tag *)NULL)))
    {
      var->name=strdup(name);
      var->value=strdup(value);
      const char *return_value_httpp_getvar_2;
      return_value_httpp_getvar_2=httpp_getvar(parser, name);
      if(return_value_httpp_getvar_2 == ((const char *)NULL))
        avl_insert(parser->vars, (void *)var);

      else
      {
        avl_delete(parser->vars, (void *)var, _free_vars);
        avl_insert(parser->vars, (void *)var);
      }
    }

  }

}

// initial_flac_page
// file format_flac.h line 19
struct ogg_codec_tag * initial_flac_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)plugin->_state;
  struct ogg_codec_tag *codec;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_codec_tag) /*480ul*/ );
  codec = (struct ogg_codec_tag *)return_value_calloc_1;
  struct anonymous_14 packet;
  signed int return_value_ogg_page_serialno_2;
  return_value_ogg_page_serialno_2=ogg_page_serialno(page);
  ogg_stream_init(&codec->os, return_value_ogg_page_serialno_2);
  ogg_stream_pagein(&codec->os, page);
  ogg_stream_packetout(&codec->os, &packet);
  log_write(errorlog, (unsigned int)4, "format-flac/", "initial_flac_page", "checking for FLAC codec");
  unsigned char *parse = packet.packet;
  if(page->body_len + page->header_len == 79l)
  {
    if((signed int)*parse == 0x7F)
    {
      parse = parse + 1l;
      signed int return_value_memcmp_3;
      return_value_memcmp_3=memcmp((const void *)parse, (const void *)"FLAC", (unsigned long int)4);
      if(return_value_memcmp_3 == 0)
      {
        log_write(errorlog, (unsigned int)3, "format-flac/", "initial_flac_page", "seen initial FLAC header");
        parse = parse + (signed long int)4;
        stats_event_args(ogg_info->mount, "FLAC_version", "%d.%d", parse[(signed long int)0], parse[(signed long int)1]);
        codec->process_page = process_flac_page;
        codec->codec_free = flac_codec_free;
        codec->headers = (unsigned int)1;
        codec->name = "FLAC";
        format_ogg_attach_header(ogg_info, page);
        return codec;
      }

    }

  }

  ogg_stream_clear(&codec->os);
  free((void *)codec);
  return (struct ogg_codec_tag *)(void *)0;
}

// initial_kate_page
// file format_kate.h line 19
struct ogg_codec_tag * initial_kate_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)plugin->_state;
  struct ogg_codec_tag *codec;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_codec_tag) /*480ul*/ );
  codec = (struct ogg_codec_tag *)return_value_calloc_1;
  struct anonymous_14 packet;
  struct _kate_codec_tag *kate_codec;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct _kate_codec_tag) /*32ul*/ );
  kate_codec = (struct _kate_codec_tag *)return_value_calloc_2;
  signed int return_value_ogg_page_serialno_3;
  return_value_ogg_page_serialno_3=ogg_page_serialno(page);
  ogg_stream_init(&codec->os, return_value_ogg_page_serialno_3);
  ogg_stream_pagein(&codec->os, page);
  ogg_stream_packetout(&codec->os, &packet);
  log_write(errorlog, (unsigned int)4, "format-kate/", "initial_kate_page", "checking for kate codec");
  _Bool tmp_if_expr_5;
  signed int return_value_memcmp_4;
  if(!(packet.bytes >= 9l))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_memcmp_4=memcmp((const void *)packet.packet, (const void *)"kate\0\0\0\0", (unsigned long int)9);
    tmp_if_expr_5 = return_value_memcmp_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    ogg_stream_clear(&codec->os);
    free((void *)kate_codec);
    free((void *)codec);
    return (struct ogg_codec_tag *)(void *)0;
  }

  else
  {
    log_write(errorlog, (unsigned int)3, "format-kate/", "initial_kate_page", "seen initial kate header");
    codec->specific = (void *)kate_codec;
    codec->process_page = process_kate_page;
    codec->codec_free = kate_codec_free;
    codec->headers = (unsigned int)1;
    codec->name = "Kate";
    format_ogg_attach_header(ogg_info, page);
    ogg_info->codec_sync = codec;
    return codec;
  }
}

// initial_midi_page
// file format_midi.h line 19
struct ogg_codec_tag * initial_midi_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)plugin->_state;
  struct ogg_codec_tag *codec;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_codec_tag) /*480ul*/ );
  codec = (struct ogg_codec_tag *)return_value_calloc_1;
  struct anonymous_14 packet;
  signed int return_value_ogg_page_serialno_2;
  return_value_ogg_page_serialno_2=ogg_page_serialno(page);
  ogg_stream_init(&codec->os, return_value_ogg_page_serialno_2);
  ogg_stream_pagein(&codec->os, page);
  ogg_stream_packetout(&codec->os, &packet);
  log_write(errorlog, (unsigned int)4, "format-midi/", "initial_midi_page", "checking for MIDI codec");
  if(packet.bytes >= 9l)
  {
    signed int return_value_memcmp_3;
    return_value_memcmp_3=memcmp((const void *)packet.packet, (const void *)"OggMIDI\0", (unsigned long int)8);
    if(return_value_memcmp_3 == 0)
    {
      if(packet.bytes == 12l)
      {
        log_write(errorlog, (unsigned int)3, "format-midi/", "initial_midi_page", "seen initial MIDI header");
        codec->process_page = process_midi_page;
        codec->codec_free = midi_codec_free;
        codec->headers = (unsigned int)1;
        codec->name = "MIDI";
        format_ogg_attach_header(ogg_info, page);
        return codec;
      }

    }

  }

  ogg_stream_clear(&codec->os);
  free((void *)codec);
  return (struct ogg_codec_tag *)(void *)0;
}

// initial_opus_page
// file format_opus.h line 18
struct ogg_codec_tag * initial_opus_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)plugin->_state;
  struct ogg_codec_tag *codec;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_codec_tag) /*480ul*/ );
  codec = (struct ogg_codec_tag *)return_value_calloc_1;
  struct anonymous_14 packet;
  signed int return_value_ogg_page_serialno_2;
  return_value_ogg_page_serialno_2=ogg_page_serialno(page);
  ogg_stream_init(&codec->os, return_value_ogg_page_serialno_2);
  ogg_stream_pagein(&codec->os, page);
  ogg_stream_packetout(&codec->os, &packet);
  log_write(errorlog, (unsigned int)4, "format-opus/", "initial_opus_page", "checking for opus codec");
  signed int return_value_strncmp_3;
  return_value_strncmp_3=strncmp((char *)packet.packet, "OpusHead", (unsigned long int)8);
  if(!(return_value_strncmp_3 == 0))
  {
    ogg_stream_clear(&codec->os);
    free((void *)codec);
    return (struct ogg_codec_tag *)(void *)0;
  }

  else
  {
    log_write(errorlog, (unsigned int)3, "format-opus/", "initial_opus_page", "seen initial opus header");
    codec->process_page = process_opus_page;
    codec->codec_free = opus_codec_free;
    codec->headers = (unsigned int)1;
    format_ogg_attach_header(ogg_info, page);
    return codec;
  }
}

// initial_skeleton_page
// file format_skeleton.h line 19
struct ogg_codec_tag * initial_skeleton_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)plugin->_state;
  struct ogg_codec_tag *codec;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_codec_tag) /*480ul*/ );
  codec = (struct ogg_codec_tag *)return_value_calloc_1;
  struct anonymous_14 packet;
  signed int return_value_ogg_page_serialno_2;
  return_value_ogg_page_serialno_2=ogg_page_serialno(page);
  ogg_stream_init(&codec->os, return_value_ogg_page_serialno_2);
  ogg_stream_pagein(&codec->os, page);
  ogg_stream_packetout(&codec->os, &packet);
  log_write(errorlog, (unsigned int)4, "format-skeleton/", "initial_skeleton_page", "checking for skeleton codec");
  _Bool tmp_if_expr_4;
  signed int return_value_memcmp_3;
  if(!(packet.bytes >= 8l))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_memcmp_3=memcmp((const void *)packet.packet, (const void *)"fishead\0", (unsigned long int)8);
    tmp_if_expr_4 = return_value_memcmp_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
  {
    ogg_stream_clear(&codec->os);
    free((void *)codec);
    return (struct ogg_codec_tag *)(void *)0;
  }

  else
  {
    log_write(errorlog, (unsigned int)3, "format-skeleton/", "initial_skeleton_page", "seen initial skeleton header");
    codec->process_page = process_skeleton_page;
    codec->codec_free = skeleton_codec_free;
    codec->headers = (unsigned int)1;
    codec->name = "Skeleton";
    format_ogg_attach_header(ogg_info, page);
    return codec;
  }
}

// initial_speex_page
// file format_speex.h line 19
struct ogg_codec_tag * initial_speex_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)plugin->_state;
  struct ogg_codec_tag *codec;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_codec_tag) /*480ul*/ );
  codec = (struct ogg_codec_tag *)return_value_calloc_1;
  struct anonymous_14 packet;
  struct SpeexHeader *header;
  signed int return_value_ogg_page_serialno_2;
  return_value_ogg_page_serialno_2=ogg_page_serialno(page);
  ogg_stream_init(&codec->os, return_value_ogg_page_serialno_2);
  ogg_stream_pagein(&codec->os, page);
  ogg_stream_packetout(&codec->os, &packet);
  log_write(errorlog, (unsigned int)4, "format-speex/", "initial_speex_page", "checking for speex codec");
  header=speex_packet_to_header((char *)packet.packet, (signed int)packet.bytes);
  if(header == ((struct SpeexHeader *)NULL))
  {
    ogg_stream_clear(&codec->os);
    free((void *)header);
    free((void *)codec);
    return (struct ogg_codec_tag *)(void *)0;
  }

  else
  {
    log_write(errorlog, (unsigned int)3, "format-speex/", "initial_speex_page", "seen initial speex header");
    codec->process_page = process_speex_page;
    codec->codec_free = speex_codec_free;
    codec->headers = (unsigned int)1;
    format_ogg_attach_header(ogg_info, page);
    free((void *)header);
    return codec;
  }
}

// initial_theora_page
// file format_theora.h line 19
struct ogg_codec_tag * initial_theora_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)plugin->_state;
  struct ogg_codec_tag *codec;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_codec_tag) /*480ul*/ );
  codec = (struct ogg_codec_tag *)return_value_calloc_1;
  struct anonymous_14 packet;
  struct _theora_codec_tag *theora_codec;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct _theora_codec_tag) /*168ul*/ );
  theora_codec = (struct _theora_codec_tag *)return_value_calloc_2;
  signed int return_value_ogg_page_serialno_3;
  return_value_ogg_page_serialno_3=ogg_page_serialno(page);
  ogg_stream_init(&codec->os, return_value_ogg_page_serialno_3);
  ogg_stream_pagein(&codec->os, page);
  theora_info_init(&theora_codec->ti);
  theora_comment_init(&theora_codec->tc);
  ogg_stream_packetout(&codec->os, &packet);
  log_write(errorlog, (unsigned int)4, "format-theora/", "initial_theora_page", "checking for theora codec");
  signed int return_value_theora_decode_header_4;
  return_value_theora_decode_header_4=theora_decode_header(&theora_codec->ti, &theora_codec->tc, &packet);
  if(!(return_value_theora_decode_header_4 >= 0))
  {
    theora_info_clear(&theora_codec->ti);
    theora_comment_clear(&theora_codec->tc);
    ogg_stream_clear(&codec->os);
    free((void *)theora_codec);
    free((void *)codec);
    return (struct ogg_codec_tag *)(void *)0;
  }

  else
  {
    log_write(errorlog, (unsigned int)3, "format-theora/", "initial_theora_page", "seen initial theora header");
    codec->specific = (void *)theora_codec;
    codec->process_page = process_theora_page;
    codec->codec_free = theora_codec_free;
    codec->headers = (unsigned int)1;
    codec->name = "Theora";
    format_ogg_attach_header(ogg_info, page);
    ogg_info->codec_sync = codec;
    return codec;
  }
}

// initial_vorbis_page
// file format_vorbis.h line 19
struct ogg_codec_tag * initial_vorbis_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page)
{
  struct ogg_codec_tag *codec;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ogg_codec_tag) /*480ul*/ );
  codec = (struct ogg_codec_tag *)return_value_calloc_1;
  struct anonymous_14 packet;
  struct vorbis_codec_tag *vorbis;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct vorbis_codec_tag) /*648ul*/ );
  vorbis = (struct vorbis_codec_tag *)return_value_calloc_2;
  signed int return_value_ogg_page_serialno_3;
  return_value_ogg_page_serialno_3=ogg_page_serialno(page);
  ogg_stream_init(&codec->os, return_value_ogg_page_serialno_3);
  ogg_stream_pagein(&codec->os, page);
  vorbis_info_init(&vorbis->vi);
  vorbis_comment_init(&vorbis->vc);
  ogg_stream_packetout(&codec->os, &packet);
  log_write(errorlog, (unsigned int)4, "format-vorbis/", "initial_vorbis_page", "checking for vorbis codec");
  signed int return_value_vorbis_synthesis_headerin_4;
  return_value_vorbis_synthesis_headerin_4=vorbis_synthesis_headerin(&vorbis->vi, &vorbis->vc, &packet);
  if(!(return_value_vorbis_synthesis_headerin_4 >= 0))
  {
    ogg_stream_clear(&codec->os);
    vorbis_info_clear(&vorbis->vi);
    vorbis_comment_clear(&vorbis->vc);
    free((void *)vorbis);
    free((void *)codec);
    return (struct ogg_codec_tag *)(void *)0;
  }

  else
  {
    log_write(errorlog, (unsigned int)3, "format-vorbis/", "initial_vorbis_page", "seen initial vorbis header");
    codec->specific = (void *)vorbis;
    codec->codec_free = vorbis_codec_free;
    codec->headers = (unsigned int)1;
    codec->name = "Vorbis";
    free_ogg_packet(vorbis->header[(signed long int)0]);
    free_ogg_packet(vorbis->header[(signed long int)1]);
    free_ogg_packet(vorbis->header[(signed long int)2]);
    memset((void *)vorbis->header, 0, sizeof(struct anonymous_14 *[3l]) /*24ul*/ );
    vorbis->header[(signed long int)0]=copy_ogg_packet(&packet);
    signed int return_value_rand_5;
    return_value_rand_5=rand();
    ogg_stream_init(&vorbis->new_os, return_value_rand_5);
    codec->process_page = process_vorbis_page;
    codec->process = process_vorbis;
    plugin->set_tag = vorbis_set_tag;
    void *return_value_malloc_6;
    return_value_malloc_6=malloc((unsigned long int)(page->header_len + page->body_len));
    vorbis->bos_page.header = (unsigned char *)return_value_malloc_6;
    memcpy((void *)vorbis->bos_page.header, (const void *)page->header, (unsigned long int)page->header_len);
    vorbis->bos_page.header_len = page->header_len;
    vorbis->bos_page.body = vorbis->bos_page.header + page->header_len;
    memcpy((void *)vorbis->bos_page.body, (const void *)page->body, (unsigned long int)page->body_len);
    vorbis->bos_page.body_len = page->body_len;
    return codec;
  }
}

// initialize_subsystems
// file main.c line 110
void initialize_subsystems(void)
{
  log_initialize();
  thread_initialize();
  sock_initialize();
  resolver_initialize();
  config_initialize();
  connection_initialize();
  global_initialize();
  refbuf_initialize();
  xslt_initialize();
  curl_global_init((signed long int)(1 << 0 | 1 << 1));
}

// initiate_flush
// file format_vorbis.c line 219
static void initiate_flush(struct vorbis_codec_tag *source_vorbis)
{
  if(!(source_vorbis->prev_packet == ((struct anonymous_14 *)NULL)))
  {
    log_write(errorlog, (unsigned int)4, "format-vorbis/", "initiate_flush", "adding EOS packet");
    source_vorbis->prev_packet->e_o_s = (signed long int)1;
    add_audio_packet(source_vorbis, source_vorbis->prev_packet);
    source_vorbis->prev_packet->e_o_s = (signed long int)0;
  }

  source_vorbis->get_buffer_page = get_buffer_finished;
  source_vorbis->initial_audio_packet = 1;
}

// is_listener_connected
// file auth.c line 179
static signed int is_listener_connected(struct _client_tag *client)
{
  signed int ret = 1;
  if(!(client == ((struct _client_tag *)NULL)))
  {
    signed int return_value_sock_active_1;
    return_value_sock_active_1=sock_active(client->con->sock);
    if(return_value_sock_active_1 == 0)
      ret = 0;

  }

  return ret;
}

// kate_codec_free
// file format_kate.c line 53
static void kate_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  struct _kate_codec_tag *kate = (struct _kate_codec_tag *)codec->specific;
  log_write(errorlog, (unsigned int)4, "format-kate/", "kate_codec_free", "freeing kate codec");
  ogg_stream_clear(&codec->os);
  free((void *)kate);
  free((void *)codec);
}

// log_close
// file log/log.h line 37
void log_close(signed int log_id)
{
  if(!(log_id >= 25) && log_id >= 0)
  {
    _lock_logger();
    if(loglist[(signed long int)log_id].in_use == 0)
      _unlock_logger();

    else
    {
      loglist[(signed long int)log_id].in_use = 0;
      loglist[(signed long int)log_id].level = (unsigned int)2;
      if(!(loglist[(signed long int)log_id].filename == ((char *)NULL)))
        free((void *)loglist[(signed long int)log_id].filename);

      if(!(loglist[(signed long int)log_id].buffer == ((char *)NULL)))
        free((void *)loglist[(signed long int)log_id].buffer);

      if(!(loglist[(signed long int)log_id].logfile == ((struct _IO_FILE *)NULL)))
      {
        fclose(loglist[(signed long int)log_id].logfile);
        loglist[(signed long int)log_id].logfile = (struct _IO_FILE *)(void *)0;
      }

      while(!(loglist[(signed long int)log_id].entries == 0u))
      {
        struct _log_entry_t *to_go = loglist[(signed long int)log_id].log_head;
        loglist[(signed long int)log_id].log_head = to_go->next;
        loglist[(signed long int)log_id].total = loglist[(signed long int)log_id].total - (unsigned long int)to_go->len;
        free((void *)to_go->line);
        free((void *)to_go);
        loglist[(signed long int)log_id].entries = loglist[(signed long int)log_id].entries - 1u;
      }
      _unlock_logger();
    }
  }

}

// log_contents
// file log.c line 392
void log_contents(signed int log_id, char **_contents, unsigned int *_len)
{
  signed int remain;
  struct _log_entry_t *entry;
  char *ptr;
  if(log_id >= 0)
  {
    if(!(log_id >= 25))
    {
      _lock_logger();
      remain = (signed int)(loglist[(signed long int)log_id].total + (unsigned long int)1);
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)remain);
      *_contents = (char *)return_value_malloc_1;
      *(*_contents) = (char)0;
      *_len = (unsigned int)loglist[(signed long int)log_id].total;
      entry = loglist[(signed long int)log_id].log_head;
      ptr = *_contents;
      while(!(entry == ((struct _log_entry_t *)NULL)))
      {
        signed int len;
        len=snprintf(ptr, (unsigned long int)remain, "%s", entry->line);
        if(len >= 1)
        {
          ptr = ptr + (signed long int)len;
          remain = remain - len;
        }

        entry = entry->next;
      }
      _unlock_logger();
    }

  }

}

// log_flush
// file log.c line 288
void log_flush(signed int log_id)
{
  if(!(log_id >= 25) && log_id >= 0)
  {
    if(!(loglist[(signed long int)log_id].in_use == 0))
    {
      _lock_logger();
      if(!(loglist[(signed long int)log_id].logfile == ((struct _IO_FILE *)NULL)))
        fflush(loglist[(signed long int)log_id].logfile);

      _unlock_logger();
    }

  }

}

// log_initialize
// file log/log.h line 25
void log_initialize(void)
{
  signed int i;
  if(_initialized_link3 == 0)
  {
    i = 0;
    for( ; !(i >= 25); i = i + 1)
    {
      loglist[(signed long int)i].in_use = 0;
      loglist[(signed long int)i].level = (unsigned int)2;
      loglist[(signed long int)i].size = (signed long int)0;
      loglist[(signed long int)i].trigger_level = (signed long int)1000000000;
      loglist[(signed long int)i].filename = (char *)(void *)0;
      loglist[(signed long int)i].logfile = (struct _IO_FILE *)(void *)0;
      loglist[(signed long int)i].buffer = (char *)(void *)0;
      loglist[(signed long int)i].total = (unsigned long int)0;
      loglist[(signed long int)i].entries = (unsigned int)0;
      loglist[(signed long int)i].keep_entries = (unsigned int)0;
      loglist[(signed long int)i].log_head = (struct _log_entry_t *)(void *)0;
      loglist[(signed long int)i].log_tail = &loglist[(signed long int)i].log_head;
    }
    pthread_mutex_init(&_logger_mutex, (const union anonymous_40 *)(void *)0);
    _initialized_link3 = 1;
  }

}

// log_open
// file log/log.h line 27
signed int log_open(const char *filename)
{
  signed int id;
  struct _IO_FILE *file;
  if(filename == ((const char *)NULL))
    return -1;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(filename, "");
    if(return_value_strcmp_1 == 0)
      return -1;

    else
    {
      file=fopen(filename, "a");
      id=log_open_file(file);
      if(id >= 0)
      {
        struct stat st;
        setvbuf(loglist[(signed long int)id].logfile, (char *)(void *)0, 1, (unsigned long int)0);
        loglist[(signed long int)id].filename=strdup(filename);
        signed int return_value_stat_2;
        return_value_stat_2=stat(loglist[(signed long int)id].filename, &st);
        if(return_value_stat_2 == 0)
          loglist[(signed long int)id].size = st.st_size;

        loglist[(signed long int)id].entries = (unsigned int)0;
        loglist[(signed long int)id].log_head = (struct _log_entry_t *)(void *)0;
        loglist[(signed long int)id].log_tail = &loglist[(signed long int)id].log_head;
      }

      return id;
    }
  }
}

// log_open_file
// file log/log.h line 26
signed int log_open_file(struct _IO_FILE *file)
{
  signed int log_id;
  if(file == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    log_id=_get_log_id();
    if(!(log_id >= 0))
      return -2;

    else
    {
      loglist[(signed long int)log_id].logfile = file;
      loglist[(signed long int)log_id].filename = (char *)(void *)0;
      loglist[(signed long int)log_id].size = (signed long int)0;
      return log_id;
    }
  }
}

// log_open_with_buffer
// file log.c line 253
signed int log_open_with_buffer(const char *filename, signed int size)
{
  return -5;
}

// log_parse_failure
// file logging.c line 202
void log_parse_failure(void *ctx, const char *fmt, ...)
{
  char line[200l];
  void **ap;
  char *eol;
  ap = (void **)&fmt;
  vsnprintf(line, sizeof(char [200l]) /*200ul*/ , fmt, ap);
  eol=strrchr(line, 10);
  if(!(eol == ((char *)NULL)))
    *eol = (char)0;

  ap = ((void **)NULL);
  log_write(errorlog, (unsigned int)2, (char *)ctx, "", "%s", (const void *)line);
}

// log_reopen
// file log/log.h line 36
void log_reopen(signed int log_id)
{
  if(!(log_id >= 25) && log_id >= 0)
  {
    if(!(loglist[(signed long int)log_id].filename == ((char *)NULL)))
    {
      if(!(loglist[(signed long int)log_id].logfile == ((struct _IO_FILE *)NULL)))
      {
        _lock_logger();
        fclose(loglist[(signed long int)log_id].logfile);
        loglist[(signed long int)log_id].logfile = (struct _IO_FILE *)(void *)0;
        _unlock_logger();
      }

    }

  }

}

// log_set_archive_timestamp
// file log/log.h line 34
signed int log_set_archive_timestamp(signed int id, signed int value)
{
  if(id >= 25 || !(id >= 0))
    return -1;

  else
  {
    _lock_logger();
    loglist[(signed long int)id].archive_timestamp = value;
    _unlock_logger();
    return id;
  }
}

// log_set_filename
// file log/log.h line 31
signed int log_set_filename(signed int id, const char *filename)
{
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  _Bool tmp_if_expr_3;
  if(id >= 25 || !(id >= 0))
    return -1;

  else
  {
    if(!(filename == ((const char *)NULL)))
    {
      return_value_strcmp_1=strcmp(filename, "");
      tmp_if_expr_2 = !(return_value_strcmp_1 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = loglist[(signed long int)id].in_use == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      return -1;

    else
    {
      _lock_logger();
      if(!(loglist[(signed long int)id].filename == ((char *)NULL)))
        free((void *)loglist[(signed long int)id].filename);

      if(!(filename == ((const char *)NULL)))
        loglist[(signed long int)id].filename=strdup(filename);

      else
        loglist[(signed long int)id].filename = (char *)(void *)0;
      _unlock_logger();
      return id;
    }
  }
}

// log_set_level
// file log/log.h line 29
void log_set_level(signed int log_id, unsigned int level)
{
  if(!(log_id >= 25) && log_id >= 0)
  {
    if(!(loglist[(signed long int)log_id].in_use == 0))
      loglist[(signed long int)log_id].level = level;

  }

}

// log_set_lines_kept
// file log.c line 260
void log_set_lines_kept(signed int log_id, unsigned int count)
{
  if(!(log_id >= 25) && log_id >= 0)
  {
    if(!(loglist[(signed long int)log_id].in_use == 0))
    {
      _lock_logger();
      loglist[(signed long int)log_id].keep_entries = count;
      while(!(count >= loglist[(signed long int)log_id].entries))
      {
        struct _log_entry_t *to_go = loglist[(signed long int)log_id].log_head;
        loglist[(signed long int)log_id].log_head = to_go->next;
        loglist[(signed long int)log_id].total = loglist[(signed long int)log_id].total - (unsigned long int)to_go->len;
        free((void *)to_go->line);
        free((void *)to_go);
        loglist[(signed long int)log_id].entries = loglist[(signed long int)log_id].entries - 1u;
      }
      _unlock_logger();
    }

  }

}

// log_set_trigger
// file log/log.h line 30
void log_set_trigger(signed int id, unsigned int trigger)
{
  if(id >= 0 && !(id >= 25))
  {
    if(!(loglist[(signed long int)id].in_use == 0))
      loglist[(signed long int)id].trigger_level = (signed long int)(trigger * (unsigned int)1024);

  }

}

// log_shutdown
// file log/log.h line 38
void log_shutdown(void)
{
  pthread_mutex_destroy(&_logger_mutex);
  _initialized_link3 = 0;
}

// log_write
// file log/log.h line 40
void log_write(signed int log_id, unsigned int priority, const char *cat, const char *func, const char *fmt, ...)
{
  signed int datelen;
  signed long int log_write__1__now;
  char pre[256l];
  char line[1024l];
  void **ap;
  if(!(log_id >= 25) && log_id >= 0)
  {
    if(loglist[(signed long int)log_id].level >= priority)
    {
      if(!(priority == 0u) && !((unsigned long int)priority >= 5ul))
      {
        ap = (void **)&fmt;
        __vsnprintf(line, sizeof(char [1024l]) /*1024ul*/ , fmt, ap);
        ap = ((void **)NULL);
        log_write__1__now=time((signed long int *)(void *)0);
        struct tm *return_value_localtime_1;
        return_value_localtime_1=localtime(&log_write__1__now);
        unsigned long int return_value_strftime_2;
        return_value_strftime_2=strftime(pre, sizeof(char [256l]) /*256ul*/ , "[%Y-%m-%d  %H:%M:%S]", return_value_localtime_1);
        datelen = (signed int)return_value_strftime_2;
        static const char *prior[4l] = { "EROR", "WARN", "INFO", "DBUG" };
        snprintf(pre + (signed long int)datelen, sizeof(char [256l]) /*256ul*/  - (unsigned long int)datelen, " %s %s%s ", prior[(signed long int)(priority - (unsigned int)1)], cat, func);
        _lock_logger();
        signed int return_value__log_open_3;
        return_value__log_open_3=_log_open(log_id);
        if(!(return_value__log_open_3 == 0))
        {
          signed int len;
          len=create_log_entry(log_id, pre, line);
          if(len >= 1)
            loglist[(signed long int)log_id].size = loglist[(signed long int)log_id].size + (signed long int)len;

        }

        _unlock_logger();
      }

    }

  }

}

// log_write_direct
// file log/log.h line 42
void log_write_direct(signed int log_id, const char *fmt, ...)
{
  void **ap;
  signed long int log_write_direct__1__now;
  char line[1024l];
  if(!(log_id >= 25) && log_id >= 0)
  {
    ap = (void **)&fmt;
    log_write_direct__1__now=time((signed long int *)(void *)0);
    _lock_logger();
    __vsnprintf(line, (unsigned long int)1024, fmt, ap);
    signed int return_value__log_open_1;
    return_value__log_open_1=_log_open(log_id);
    if(!(return_value__log_open_1 == 0))
    {
      signed int len;
      len=create_log_entry(log_id, "", line);
      if(len >= 1)
        loglist[(signed long int)log_id].size = loglist[(signed long int)log_id].size + (signed long int)len;

    }

    _unlock_logger();
    ap = ((void **)NULL);
    fflush(loglist[(signed long int)log_id].logfile);
  }

}

// logging_access
// file logging.c line 120
void logging_access(struct _client_tag *client)
{
  char datebuf[128l];
  struct tm thetime;
  signed long int logging_access__1__now;
  signed long int stayed;
  const char *referrer;
  const char *user_agent;
  const char *username;
  logging_access__1__now=time((signed long int *)(void *)0);
  localtime_r(&logging_access__1__now, &thetime);
  strftime(datebuf, sizeof(char [128l]) /*128ul*/ , "%d/%b/%Y:%H:%M:%S %z", &thetime);
  stayed = logging_access__1__now - client->con->con_time;
  if(client->username == ((char *)NULL))
    username = "-";

  else
    username = client->username;
  referrer=httpp_getvar(client->parser, "referer");
  if(referrer == ((const char *)NULL))
    referrer = "-";

  user_agent=httpp_getvar(client->parser, "user-agent");
  if(user_agent == ((const char *)NULL))
    user_agent = "-";

  const char *return_value_httpp_getvar_1;
  return_value_httpp_getvar_1=httpp_getvar(client->parser, "__req_type");
  const char *return_value_httpp_getvar_2;
  return_value_httpp_getvar_2=httpp_getvar(client->parser, "__uri");
  const char *return_value_httpp_getvar_3;
  return_value_httpp_getvar_3=httpp_getvar(client->parser, "__protocol");
  const char *return_value_httpp_getvar_4;
  return_value_httpp_getvar_4=httpp_getvar(client->parser, "__version");
  log_write_direct(accesslog, "%s - %H [%s] \"%H %H %H/%H\" %d %llu \"% H\" \"% H\" %llu", client->con->ip, username, (const void *)datebuf, return_value_httpp_getvar_1, return_value_httpp_getvar_2, return_value_httpp_getvar_3, return_value_httpp_getvar_4, client->respcode, (unsigned long long int)client->con->sent_bytes, referrer, user_agent, (unsigned long long int)stayed);
}

// logging_playlist
// file logging.c line 172
void logging_playlist(const char *mount, const char *metadata, signed long int listeners)
{
  char datebuf[128l];
  struct tm thetime;
  signed long int logging_playlist__1__now;
  if(!(playlistlog == -1))
  {
    logging_playlist__1__now=time((signed long int *)(void *)0);
    localtime_r(&logging_playlist__1__now, &thetime);
    strftime(datebuf, sizeof(char [128l]) /*128ul*/ , "%d/%b/%Y:%H:%M:%S %z", &thetime);
    log_write_direct(playlistlog, "%s|%s|%ld|%s", (const void *)datebuf, mount, listeners, metadata);
  }

}

// main
// file main.c line 431
signed int main(signed int argc, char **argv)
{
  signed int res;
  signed int ret;
  char filename[512l];
  char pbuf[1024l];
  res=_parse_config_opts(argc, argv, filename, 512);
  if(res == 1)
  {
    initialize_subsystems();
    signed int return_value__start_logging_stdout_1;
    return_value__start_logging_stdout_1=_start_logging_stdout();
    if(return_value__start_logging_stdout_1 == 0)
    {
      _fatal_error("FATAL: Could not start logging on stderr.");
      shutdown_subsystems();
      return 1;
    }

    config_get_config();
    ret=config_initial_parse_file(filename);
    config_release_config();
    if(!(ret >= 0))
    {
      memset((void *)pbuf, 0, sizeof(char [1024l]) /*1024ul*/ );
      snprintf(pbuf, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "FATAL: error parsing config file (%s)", (const void *)filename);
      _fatal_error(pbuf);
      if(!(ret == -1))
      {
        if(ret == -2)
          goto __CPROVER_DUMP_L3;

        if(ret == -3)
          goto __CPROVER_DUMP_L4;

      }

      else
      {
        _fatal_error("filename was null or blank");
        goto __CPROVER_DUMP_L6;

      __CPROVER_DUMP_L3:
        ;
        _fatal_error("no root element found");
        goto __CPROVER_DUMP_L6;

      __CPROVER_DUMP_L4:
        ;
        _fatal_error("root element is not <icecast>");
        goto __CPROVER_DUMP_L6;
      }
      _fatal_error("XML config parsing error");

    __CPROVER_DUMP_L6:
      ;
      shutdown_subsystems();
      return 1;
    }

  }

  else
    if(res == -1)
    {
      _print_usage();
      return 1;
    }

  config_parse_cmdline(argc, argv);
  signed int return_value__server_proc_init_2;
  return_value__server_proc_init_2=_server_proc_init();
  if(return_value__server_proc_init_2 == 0)
  {
    _fatal_error("Server startup failed. Exiting");
    shutdown_subsystems();
    return 1;
  }

  else
  {
    _ch_root_uid_setup();
    stats_initialize();
    fserve_initialize();
    unsigned int return_value_getuid_3;
    return_value_getuid_3=getuid();
    if(return_value_getuid_3 == 0u)
    {
      fprintf(stderr, "ERROR: You should not run icecast2 as root\n");
      fprintf(stderr, "Use the changeowner directive in the config file\n");
      shutdown_subsystems();
      return 1;
    }

    else
    {
      sighandler_initialize();
      signed int return_value__start_logging_4;
      return_value__start_logging_4=_start_logging();
      if(return_value__start_logging_4 == 0)
      {
        _fatal_error("FATAL: Could not start logging");
        shutdown_subsystems();
        return 1;
      }

      else
      {
        log_write(errorlog, (unsigned int)3, "main/", "main", "%s server started", (const void *)"Icecast 2.4.2");
        global.running = 1;
        yp_initialize();
        slave_initialize();
        auth_initialise();
        _server_proc();
        log_write(errorlog, (unsigned int)3, "main/", "main", "Shutting down");
        shutdown_subsystems();
        if(!(pidfile == ((char *)NULL)))
        {
          remove(pidfile);
          free((void *)pidfile);
        }

        return 0;
      }
    }
  }
}

// make_refbuf_with_page
// file format_ogg.c line 76
struct _refbuf_tag * make_refbuf_with_page(struct anonymous_3 *page)
{
  struct _refbuf_tag *refbuf;
  refbuf=refbuf_new((unsigned int)(page->header_len + page->body_len));
  memcpy((void *)refbuf->data, (const void *)page->header, (unsigned long int)page->header_len);
  memcpy((void *)(refbuf->data + page->header_len), (const void *)page->body, (unsigned long int)page->body_len);
  return refbuf;
}

// merge_mounts
// file cfgfile.c line 1337
static void merge_mounts(struct _mount_proxy *dst, struct _mount_proxy *src)
{
  struct ice_config_http_header_tag *http_header_next;
  struct ice_config_http_header_tag **http_header_tail;
  unsigned char *return_value_xmlStrdup_1;
  unsigned char *return_value_xmlStrdup_2;
  unsigned char *return_value_xmlStrdup_3;
  unsigned char *return_value_xmlStrdup_4;
  unsigned char *return_value_xmlStrdup_5;
  unsigned char *return_value_xmlStrdup_6;
  unsigned char *return_value_xmlStrdup_7;
  unsigned char *return_value_xmlStrdup_8;
  unsigned char *return_value_xmlStrdup_9;
  unsigned char *return_value_xmlStrdup_10;
  unsigned char *return_value_xmlStrdup_11;
  unsigned char *return_value_xmlStrdup_12;
  unsigned char *return_value_xmlStrdup_13;
  unsigned char *return_value_xmlStrdup_14;
  unsigned char *return_value_xmlStrdup_15;
  unsigned char *return_value_xmlStrdup_16;
  unsigned char *return_value_xmlStrdup_17;
  if(!(dst == ((struct _mount_proxy *)NULL)) && !(src == ((struct _mount_proxy *)NULL)))
  {
    if(dst->username == ((char *)NULL))
    {
      return_value_xmlStrdup_1=xmlStrdup((unsigned char *)src->username);
      dst->username = (char *)return_value_xmlStrdup_1;
    }

    if(dst->password == ((char *)NULL))
    {
      return_value_xmlStrdup_2=xmlStrdup((unsigned char *)src->password);
      dst->password = (char *)return_value_xmlStrdup_2;
    }

    if(dst->dumpfile == ((char *)NULL))
    {
      return_value_xmlStrdup_3=xmlStrdup((unsigned char *)src->dumpfile);
      dst->dumpfile = (char *)return_value_xmlStrdup_3;
    }

    if(dst->intro_filename == ((char *)NULL))
    {
      return_value_xmlStrdup_4=xmlStrdup((unsigned char *)src->intro_filename);
      dst->intro_filename = (char *)return_value_xmlStrdup_4;
    }

    if(dst->fallback_when_full == 0)
      dst->fallback_when_full = src->fallback_when_full;

    if(dst->max_listeners == -1)
      dst->max_listeners = src->max_listeners;

    if(dst->fallback_mount == ((char *)NULL))
    {
      return_value_xmlStrdup_5=xmlStrdup((unsigned char *)src->fallback_mount);
      dst->fallback_mount = (char *)return_value_xmlStrdup_5;
    }

    if(dst->fallback_override == 0)
      dst->fallback_override = src->fallback_override;

    if(dst->no_mount == 0)
      dst->no_mount = src->no_mount;

    if(dst->burst_size == -1)
      dst->burst_size = src->burst_size;

    if(dst->queue_size_limit == 0u)
      dst->queue_size_limit = src->queue_size_limit;

    if(dst->hidden == 0)
      dst->hidden = src->hidden;

    if(dst->source_timeout == 0u)
      dst->source_timeout = src->source_timeout;

    if(dst->charset == ((char *)NULL))
    {
      return_value_xmlStrdup_6=xmlStrdup((unsigned char *)src->charset);
      dst->charset = (char *)return_value_xmlStrdup_6;
    }

    if(dst->mp3_meta_interval == -1)
      dst->mp3_meta_interval = src->mp3_meta_interval;

    if(dst->auth_type == ((char *)NULL))
    {
      return_value_xmlStrdup_7=xmlStrdup((unsigned char *)src->auth_type);
      dst->auth_type = (char *)return_value_xmlStrdup_7;
    }

    if(dst->cluster_password == ((char *)NULL))
    {
      return_value_xmlStrdup_8=xmlStrdup((unsigned char *)src->cluster_password);
      dst->cluster_password = (char *)return_value_xmlStrdup_8;
    }

    if(dst->on_connect == ((char *)NULL))
    {
      return_value_xmlStrdup_9=xmlStrdup((unsigned char *)src->on_connect);
      dst->on_connect = (char *)return_value_xmlStrdup_9;
    }

    if(dst->on_disconnect == ((char *)NULL))
    {
      return_value_xmlStrdup_10=xmlStrdup((unsigned char *)src->on_disconnect);
      dst->on_disconnect = (char *)return_value_xmlStrdup_10;
    }

    if(dst->max_listener_duration == 0u)
      dst->max_listener_duration = src->max_listener_duration;

    if(dst->stream_name == ((char *)NULL))
    {
      return_value_xmlStrdup_11=xmlStrdup((unsigned char *)src->stream_name);
      dst->stream_name = (char *)return_value_xmlStrdup_11;
    }

    if(dst->stream_description == ((char *)NULL))
    {
      return_value_xmlStrdup_12=xmlStrdup((unsigned char *)src->stream_description);
      dst->stream_description = (char *)return_value_xmlStrdup_12;
    }

    if(dst->stream_url == ((char *)NULL))
    {
      return_value_xmlStrdup_13=xmlStrdup((unsigned char *)src->stream_url);
      dst->stream_url = (char *)return_value_xmlStrdup_13;
    }

    if(dst->stream_genre == ((char *)NULL))
    {
      return_value_xmlStrdup_14=xmlStrdup((unsigned char *)src->stream_genre);
      dst->stream_genre = (char *)return_value_xmlStrdup_14;
    }

    if(dst->bitrate == ((char *)NULL))
    {
      return_value_xmlStrdup_15=xmlStrdup((unsigned char *)src->bitrate);
      dst->bitrate = (char *)return_value_xmlStrdup_15;
    }

    if(dst->type == ((char *)NULL))
    {
      return_value_xmlStrdup_16=xmlStrdup((unsigned char *)src->type);
      dst->type = (char *)return_value_xmlStrdup_16;
    }

    if(dst->subtype == ((char *)NULL))
    {
      return_value_xmlStrdup_17=xmlStrdup((unsigned char *)src->subtype);
      dst->subtype = (char *)return_value_xmlStrdup_17;
    }

    if(dst->yp_public == -1)
      dst->yp_public = src->yp_public;

    if(!(dst->http_headers == ((struct ice_config_http_header_tag *)NULL)))
    {
      http_header_next = dst->http_headers;
      for( ; !(http_header_next->next == ((struct ice_config_http_header_tag *)NULL)); http_header_next = http_header_next->next)
        ;
      http_header_tail = &http_header_next->next;
    }

    else
      http_header_tail = &dst->http_headers;
    *http_header_tail=config_copy_http_header(src->http_headers);
  }

}

// midi_codec_free
// file format_midi.c line 35
static void midi_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  log_write(errorlog, (unsigned int)4, "format-midi/", "midi_codec_free", "freeing MIDI codec");
  ogg_stream_clear(&codec->os);
  free((void *)codec);
}

// modify_node_event
// file stats.c line 436
static void modify_node_event(struct _stats_node_tag *node, struct _stats_event_tag *event)
{
  char *str;
  signed int return_value_atoi_1;
  signed int return_value_atoi_2;
  signed int return_value_atoi_3;
  signed int return_value_atoi_4;
  signed long long int return_value_atoll_5;
  signed long long int return_value_atoll_6;
  char *return_value_strdup_8;
  if(event->action == 6)
  {
    if(!(event->value == ((char *)NULL)))
      node->hidden = 1;

    else
      node->hidden = 0;
  }

  else
  {
    if(!(event->action == 0))
    {
      signed long int value = (signed long int)0;
      switch(event->action)
      {
        case 1:
        {
          return_value_atoi_1=atoi(node->value);
          value = (signed long int)(return_value_atoi_1 + 1);
          break;
        }
        case 2:
        {
          return_value_atoi_2=atoi(node->value);
          value = (signed long int)(return_value_atoi_2 - 1);
          break;
        }
        case 3:
        {
          return_value_atoi_3=atoi(node->value);
          return_value_atoi_4=atoi(event->value);
          value = (signed long int)(return_value_atoi_3 + return_value_atoi_4);
          break;
        }
        case 4:
        {
          return_value_atoll_5=atoll(node->value);
          return_value_atoll_6=atoll(event->value);
          value = return_value_atoll_5 - return_value_atoll_6;
          break;
        }
        default:
          log_write(errorlog, (unsigned int)2, "stats/", "modify_node_event", "unhandled event (%d) for %s", event->action, event->source);
      }
      void *return_value_malloc_7;
      return_value_malloc_7=malloc((unsigned long int)16);
      str = (char *)return_value_malloc_7;
      snprintf(str, (unsigned long int)16, "%ld", value);
      if(event->value == ((char *)NULL))
        event->value=strdup(str);

    }

    else
    {
      return_value_strdup_8=strdup(event->value);
      str = (char *)return_value_strdup_8;
    }
    free((void *)node->value);
    node->value = str;
    if(!(event->source == ((char *)NULL)))
      log_write(errorlog, (unsigned int)4, "stats/", "modify_node_event", "update \"%s\" %s (%s)", event->source, node->name, node->value);

    else
      log_write(errorlog, (unsigned int)4, "stats/", "modify_node_event", "update global %s (%s)", node->name, node->value);
  }
}

// mp3_get_filter_meta
// file format_mp3.c line 541
static struct _refbuf_tag * mp3_get_filter_meta(struct source_tag *source)
{
  struct _refbuf_tag *refbuf;
  struct _format_plugin_tag *plugin = source->format;
  struct anonymous_5 *source_mp3 = (struct anonymous_5 *)plugin->_state;
  unsigned char *src;
  unsigned int bytes;
  unsigned int mp3_block;
  signed int return_value_complete_read_1;
  return_value_complete_read_1=complete_read(source);
  signed int return_value_strcmp_3;
  if(return_value_complete_read_1 == 0)
    return (struct _refbuf_tag *)(void *)0;

  else
  {
    refbuf = source_mp3->read_data;
    source_mp3->read_data = (struct _refbuf_tag *)(void *)0;
    src = (unsigned char *)refbuf->data;
    if(!(source_mp3->update_metadata == 0))
    {
      mp3_set_title(source);
      source_mp3->update_metadata = 0;
    }

    bytes = (unsigned int)source_mp3->read_count;
    refbuf->len = (unsigned int)0;
    while(bytes >= 1u)
    {
      unsigned int metadata_remaining;
      mp3_block = (unsigned int)(source_mp3->inline_metadata_interval - source_mp3->offset);
      if(mp3_block >= bytes)
      {
        refbuf->len = refbuf->len + bytes;
        source_mp3->offset = source_mp3->offset + (signed int)bytes;
        break;
      }

      if(!(mp3_block == 0u))
      {
        src = src + (signed long int)mp3_block;
        bytes = bytes - mp3_block;
        refbuf->len = refbuf->len + mp3_block;
        source_mp3->offset = source_mp3->offset + (signed int)mp3_block;
      }

      else
      {
        if(source_mp3->build_metadata_len == 0u)
        {
          memset((void *)source_mp3->build_metadata, 0, sizeof(char [4081l]) /*4081ul*/ );
          source_mp3->build_metadata_offset = (unsigned int)0;
          source_mp3->build_metadata_len = (unsigned int)(1 + (signed int)*src * 16);
        }

        metadata_remaining = source_mp3->build_metadata_len - source_mp3->build_metadata_offset;
        if(!(bytes >= metadata_remaining))
        {
          memcpy((void *)(source_mp3->build_metadata + (signed long int)source_mp3->build_metadata_offset), (const void *)src, (unsigned long int)bytes);
          source_mp3->build_metadata_offset = source_mp3->build_metadata_offset + bytes;
          break;
        }

        memcpy((void *)(source_mp3->build_metadata + (signed long int)source_mp3->build_metadata_offset), (const void *)src, (unsigned long int)(metadata_remaining - (unsigned int)1));
        bytes = bytes - metadata_remaining;
        memmove((void *)src, (const void *)(src + (signed long int)metadata_remaining), (unsigned long int)bytes);
        if(source_mp3->build_metadata_len >= 2u)
        {
          return_value_strcmp_3=strcmp(source_mp3->build_metadata + (signed long int)1, source_mp3->metadata->data + (signed long int)1);
          if(!(return_value_strcmp_3 == 0))
          {
            struct _refbuf_tag *meta;
            meta=refbuf_new(source_mp3->build_metadata_len);
            memcpy((void *)meta->data, (const void *)source_mp3->build_metadata, (unsigned long int)source_mp3->build_metadata_len);
            log_write(errorlog, (unsigned int)4, "format-mp3/", "mp3_get_filter_meta", "shoutcast metadata %.*s", 4080, meta->data + (signed long int)1);
            signed int return_value_strncmp_2;
            return_value_strncmp_2=strncmp(meta->data + (signed long int)1, "StreamTitle=", (unsigned long int)12);
            if(return_value_strncmp_2 == 0)
            {
              filter_shoutcast_metadata(source, source_mp3->build_metadata, source_mp3->build_metadata_len);
              refbuf_release(source_mp3->metadata);
              source_mp3->metadata = meta;
              source_mp3->inline_url=strstr(meta->data + (signed long int)1, "StreamUrl='");
            }

            else
            {
              log_write(errorlog, (unsigned int)1, "format-mp3/", "mp3_get_filter_meta", "Incorrect metadata format, ending stream");
              source->running = 0;
              refbuf_release(refbuf);
              refbuf_release(meta);
              return (struct _refbuf_tag *)(void *)0;
            }
          }

        }

        source_mp3->offset = 0;
        source_mp3->build_metadata_len = (unsigned int)0;
      }
    }
    if(refbuf->len == 0u)
    {
      refbuf_release(refbuf);
      return (struct _refbuf_tag *)(void *)0;
    }

    else
    {
      refbuf->associated = source_mp3->metadata;
      refbuf_addref(source_mp3->metadata);
      refbuf->sync_point = 1;
      return refbuf;
    }
  }
}

// mp3_get_no_meta
// file format_mp3.c line 514
static struct _refbuf_tag * mp3_get_no_meta(struct source_tag *source)
{
  struct _refbuf_tag *refbuf;
  struct anonymous_5 *source_mp3 = (struct anonymous_5 *)source->format->_state;
  signed int return_value_complete_read_1;
  return_value_complete_read_1=complete_read(source);
  if(return_value_complete_read_1 == 0)
    return (struct _refbuf_tag *)(void *)0;

  else
  {
    refbuf = source_mp3->read_data;
    source_mp3->read_data = (struct _refbuf_tag *)(void *)0;
    if(!(source_mp3->update_metadata == 0))
    {
      mp3_set_title(source);
      source_mp3->update_metadata = 0;
    }

    refbuf->associated = source_mp3->metadata;
    refbuf_addref(source_mp3->metadata);
    refbuf->sync_point = 1;
    return refbuf;
  }
}

// mp3_set_tag
// file format_mp3.c line 128
static void mp3_set_tag(struct _format_plugin_tag *plugin, const char *tag, const char *in_value, const char *charset)
{
  struct anonymous_5 *source_mp3 = (struct anonymous_5 *)plugin->_state;
  char *value = (char *)(void *)0;
  thread_mutex_lock_c(&source_mp3->url_lock, 134, "format_mp3.c");
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(tag == ((const char *)NULL))
  {
    source_mp3->update_metadata = 1;
    thread_mutex_unlock_c(&source_mp3->url_lock, 139, "format_mp3.c");
  }

  else
  {
    if(!(in_value == ((const char *)NULL)))
    {
      value=util_conv_string(in_value, charset, plugin->charset);
      if(value == ((char *)NULL))
        value=strdup(in_value);

    }

    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(tag, "title");
    if(return_value_strcmp_3 == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strcmp_4=strcmp(tag, "song");
      tmp_if_expr_5 = return_value_strcmp_4 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      free((void *)source_mp3->url_title);
      source_mp3->url_title = value;
    }

    else
    {
      return_value_strcmp_2=strcmp(tag, "artist");
      if(return_value_strcmp_2 == 0)
      {
        free((void *)source_mp3->url_artist);
        source_mp3->url_artist = value;
      }

      else
      {
        return_value_strcmp_1=strcmp(tag, "url");
        if(return_value_strcmp_1 == 0)
        {
          free((void *)source_mp3->url);
          source_mp3->url = value;
        }

        else
          free((void *)value);
      }
    }
    thread_mutex_unlock_c(&source_mp3->url_lock, 167, "format_mp3.c");
  }
}

// mp3_set_title
// file format_mp3.c line 238
static void mp3_set_title(struct source_tag *source)
{
  const char streamtitle[14l] = { 'S', 't', 'r', 'e', 'a', 'm', 'T', 'i', 't', 'l', 'e', '=', '\'', 0 };
  const char streamurl[12l] = { 'S', 't', 'r', 'e', 'a', 'm', 'U', 'r', 'l', '=', '\'', 0 };
  unsigned long int size;
  unsigned char len_byte;
  struct _refbuf_tag *p;
  unsigned int len = (unsigned int)(sizeof(const char [14l]) /*14ul*/  + (unsigned long int)2);
  struct anonymous_5 *mp3_set_title__1__source_mp3 = (struct anonymous_5 *)source->format->_state;
  thread_mutex_lock_c(&mp3_set_title__1__source_mp3->url_lock, 249, "format_mp3.c");
  unsigned long int return_value_strlen_1;
  if(!(mp3_set_title__1__source_mp3->url_artist == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(mp3_set_title__1__source_mp3->url_artist);
    len = len + (unsigned int)return_value_strlen_1;
  }

  unsigned long int return_value_strlen_2;
  if(!(mp3_set_title__1__source_mp3->url_title == ((char *)NULL)))
  {
    return_value_strlen_2=strlen(mp3_set_title__1__source_mp3->url_title);
    len = len + (unsigned int)return_value_strlen_2;
  }

  if(!(mp3_set_title__1__source_mp3->url_artist == ((char *)NULL)))
  {
    if(!(mp3_set_title__1__source_mp3->url_title == ((char *)NULL)))
      len = len + (unsigned int)3;

  }

  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  if(!(mp3_set_title__1__source_mp3->inline_url == ((char *)NULL)))
  {
    char *mp3_set_title__1__1__end;
    mp3_set_title__1__1__end=strstr(mp3_set_title__1__source_mp3->inline_url, "';");
    if(!(mp3_set_title__1__1__end == ((char *)NULL)))
      len = len + (unsigned int)((mp3_set_title__1__1__end - mp3_set_title__1__source_mp3->inline_url) + (signed long int)2);

  }

  else
    if(!(mp3_set_title__1__source_mp3->url == ((char *)NULL)))
    {
      return_value_strlen_3=strlen(mp3_set_title__1__source_mp3->url);
      return_value_strlen_4=strlen(streamurl);
      len = len + (unsigned int)(return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)2);
    }

  _Bool tmp_if_expr_5;
  if(len >= 4081u)
  {
    thread_mutex_unlock_c(&mp3_set_title__1__source_mp3->url_lock, 269, "format_mp3.c");
    log_write(errorlog, (unsigned int)2, "format-mp3/", "mp3_set_title", "Metadata too long at %d chars", len);
  }

  else
  {
    len_byte = (unsigned char)((len - (unsigned int)1) / (unsigned int)16 + (unsigned int)1);
    size = (unsigned long int)((signed int)len_byte * 16 + 1);
    p=refbuf_new((unsigned int)size);
    if(!(p == ((struct _refbuf_tag *)NULL)))
    {
      struct anonymous_5 *source_mp3 = (struct anonymous_5 *)source->format->_state;
      signed int r;
      memset((void *)p->data, 0, size);
      if(!(source_mp3->url_artist == ((char *)NULL)))
        tmp_if_expr_5 = source_mp3->url_title != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        r=snprintf(p->data, size, "%c%s%s - %s';", len_byte, (const void *)streamtitle, source_mp3->url_artist, source_mp3->url_title);

      else
        r=snprintf(p->data, size, "%c%s%s';", len_byte, (const void *)streamtitle, source_mp3->url_title);
      if(r >= 1)
      {
        if(!(source_mp3->inline_url == ((char *)NULL)))
        {
          char *end;
          end=strstr(source_mp3->inline_url, "';");
          signed long int urllen = (signed long int)size;
          if(!(end == ((char *)NULL)))
            urllen = (end - source_mp3->inline_url) + (signed long int)2;

          if(!(urllen >= (signed long int)size + -((signed long int)(unsigned long int)r)))
            snprintf(p->data + (signed long int)r, size - (unsigned long int)r, "StreamUrl='%s';", source_mp3->inline_url + (signed long int)11);

        }

        else
          if(!(source_mp3->url == ((char *)NULL)))
            snprintf(p->data + (signed long int)r, size - (unsigned long int)r, "StreamUrl='%s';", source_mp3->url);

      }

      log_write(errorlog, (unsigned int)4, "format-mp3/", "mp3_set_title", "shoutcast metadata block setup with %s", p->data + (signed long int)1);
      filter_shoutcast_metadata(source, p->data, (unsigned int)size);
      refbuf_release(source_mp3->metadata);
      source_mp3->metadata = p;
    }

    thread_mutex_unlock_c(&mp3_set_title__1__source_mp3->url_lock, 311, "format_mp3.c");
  }
}

// ogg_get_buffer
// file format_ogg.c line 395
static struct _refbuf_tag * ogg_get_buffer(struct source_tag *source)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)source->format->_state;
  struct _format_plugin_tag *format = source->format;
  char *data = (char *)(void *)0;
  signed int bytes = 0;
  struct _refbuf_tag *return_value_complete_buffer_1;
  struct _refbuf_tag *return_value_complete_buffer_3;
  while((_Bool)1)
  {
    while((_Bool)1)
    {
      struct anonymous_3 page;
      struct _refbuf_tag *refbuf = (struct _refbuf_tag *)(void *)0;
      struct ogg_codec_tag *codec = ogg_info->current;
      if(!(codec == ((struct ogg_codec_tag *)NULL)))
      {
        if(!(codec->process == ((struct _refbuf_tag * (*)(struct ogg_state_tag *, struct ogg_codec_tag *))NULL)))
        {
          refbuf=codec->process(ogg_info, codec);
          if(!(refbuf == ((struct _refbuf_tag *)NULL)))
          {
            return_value_complete_buffer_1=complete_buffer(source, refbuf);
            return return_value_complete_buffer_1;
          }

          ogg_info->current = (struct ogg_codec_tag *)(void *)0;
        }

      }

      signed int return_value_ogg_sync_pageout_4;
      return_value_ogg_sync_pageout_4=ogg_sync_pageout(&ogg_info->oy, &page);
      if(return_value_ogg_sync_pageout_4 >= 1)
      {
        signed int return_value_ogg_page_bos_2;
        return_value_ogg_page_bos_2=ogg_page_bos(&page);
        if(!(return_value_ogg_page_bos_2 == 0))
          process_initial_page(source->format, &page);

        else
        {
          ogg_info->bos_completed = 1;
          refbuf=process_ogg_page(ogg_info, &page);
        }
        if(!(ogg_info->error == 0))
        {
          log_write(errorlog, (unsigned int)1, "format-ogg/", "ogg_get_buffer", "Problem processing stream");
          source->running = 0;
          return (struct _refbuf_tag *)(void *)0;
        }

        if(!(refbuf == ((struct _refbuf_tag *)NULL)))
        {
          return_value_complete_buffer_3=complete_buffer(source, refbuf);
          return return_value_complete_buffer_3;
        }

        continue;
      }

      break;
    }
    data=ogg_sync_buffer(&ogg_info->oy, (signed long int)4096);
    bytes=client_read_bytes(source->client, (void *)data, (unsigned int)4096);
    if(!(bytes >= 1))
    {
      ogg_sync_wrote(&ogg_info->oy, (signed long int)0);
      return (struct _refbuf_tag *)(void *)0;
    }

    format->read_bytes = format->read_bytes + (unsigned long int)bytes;
    ogg_sync_wrote(&ogg_info->oy, (signed long int)bytes);
  }
}

// open_relay_connection
// file slave.c line 158
static struct _client_tag * open_relay_connection(struct _relay_server *relay)
{
  signed int redirects = 0;
  char *server_id = (char *)(void *)0;
  struct ice_config_tag *config;
  struct http_parser_tag *parser = (struct http_parser_tag *)(void *)0;
  struct connection_tag *con = (struct connection_tag *)(void *)0;
  char *server;
  server=strdup(relay->server);
  char *mount;
  mount=strdup(relay->mount);
  signed int port = relay->port;
  char *auth_header;
  char header[4096l];
  config=config_get_config();
  server_id=strdup(config->server_id);
  config_release_config();
  _Bool tmp_if_expr_6;
  if(!(relay->username == ((char *)NULL)))
    tmp_if_expr_6 = relay->password != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_6 = (_Bool)0;
  if(tmp_if_expr_6)
  {
    char *esc_authorisation;
    unsigned int len;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(relay->username);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(relay->password);
    len = (unsigned int)(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)2);
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)len);
    auth_header = (char *)return_value_malloc_3;
    snprintf(auth_header, (unsigned long int)len, "%s:%s", relay->username, relay->password);
    esc_authorisation=util_base64_encode(auth_header);
    free((void *)auth_header);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(esc_authorisation);
    len = (unsigned int)(return_value_strlen_4 + (unsigned long int)24);
    void *return_value_malloc_5;
    return_value_malloc_5=malloc((unsigned long int)len);
    auth_header = (char *)return_value_malloc_5;
    snprintf(auth_header, (unsigned long int)len, "Authorization: Basic %s\r\n", esc_authorisation);
    free((void *)esc_authorisation);
  }

  else
    auth_header=strdup("");
  while(!(redirects >= 10))
  {
    signed int streamsock;
    log_write(errorlog, (unsigned int)3, "slave/", "open_relay_connection", "connecting to %s:%d", server, port);
    streamsock=sock_connect_wto_bind(server, port, relay->bind, 10);
    if(streamsock == -1)
    {
      log_write(errorlog, (unsigned int)2, "slave/", "open_relay_connection", "Failed to connect to %s:%d", server, port);
      break;
    }

    char *return_value_strdup_7;
    return_value_strdup_7=strdup(server);
    con=connection_create(streamsock, -1, return_value_strdup_7);
    sock_write(streamsock, "GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s\r\n%s%s\r\n", mount, server_id, server, relay->mp3metadata != 0 ? "Icy-MetaData: 1\r\n" : "", auth_header);
    memset((void *)header, 0, sizeof(char [4096l]) /*4096ul*/ );
    signed int return_value_util_read_header_8;
    return_value_util_read_header_8=util_read_header(con->sock, header, (unsigned long int)4096, 1);
    if(return_value_util_read_header_8 == 0)
    {
      log_write(errorlog, (unsigned int)1, "slave/", "open_relay_connection", "Header read failed for %s (%s:%d%s)", relay->localmount, server, port, mount);
      break;
    }

    parser=httpp_create_parser();
    httpp_initialize(parser, (struct http_varlist_tag *)(void *)0);
    unsigned long int return_value_strlen_9;
    return_value_strlen_9=strlen(header);
    signed int return_value_httpp_parse_response_10;
    return_value_httpp_parse_response_10=httpp_parse_response(parser, header, return_value_strlen_9, relay->localmount);
    if(return_value_httpp_parse_response_10 == 0)
    {
      log_write(errorlog, (unsigned int)1, "slave/", "open_relay_connection", "Error parsing relay request for %s (%s:%d%s)", relay->localmount, server, port, mount);
      break;
    }

    const char *return_value_httpp_getvar_17;
    return_value_httpp_getvar_17=httpp_getvar(parser, "__errorcode");
    signed int return_value_strcmp_18;
    return_value_strcmp_18=strcmp(return_value_httpp_getvar_17, "302");
    if(return_value_strcmp_18 == 0)
    {
      const char *uri;
      const char *mountpoint;
      signed int open_relay_connection__1__2__4__len;
      uri=httpp_getvar(parser, "location");
      log_write(errorlog, (unsigned int)3, "slave/", "open_relay_connection", "redirect received %s", uri);
      signed int return_value_strncmp_11;
      return_value_strncmp_11=strncmp(uri, "http://", (unsigned long int)7);
      if(!(return_value_strncmp_11 == 0))
        break;

      uri = uri + (signed long int)7;
      mountpoint=strchr(uri, 47);
      free((void *)mount);
      if(!(mountpoint == ((const char *)NULL)))
        mount=strdup(mountpoint);

      else
        mount=strdup("/");
      unsigned long int return_value_strcspn_12;
      return_value_strcspn_12=strcspn(uri, ":/");
      open_relay_connection__1__2__4__len = (signed int)return_value_strcspn_12;
      port = 80;
      if((signed int)uri[(signed long int)open_relay_connection__1__2__4__len] == 58)
        port=atoi(uri + (signed long int)open_relay_connection__1__2__4__len + (signed long int)1);

      free((void *)server);
      void *return_value_calloc_13;
      return_value_calloc_13=calloc((unsigned long int)1, (unsigned long int)(open_relay_connection__1__2__4__len + 1));
      server = (char *)return_value_calloc_13;
      strncpy(server, uri, (unsigned long int)open_relay_connection__1__2__4__len);
      connection_close(con);
      httpp_destroy(parser);
      con = (struct connection_tag *)(void *)0;
      parser = (struct http_parser_tag *)(void *)0;
    }

    else
    {
      struct _client_tag *client = (struct _client_tag *)(void *)0;
      const char *return_value_httpp_getvar_15;
      return_value_httpp_getvar_15=httpp_getvar(parser, "__errormessage");
      if(!(return_value_httpp_getvar_15 == ((const char *)NULL)))
      {
        const char *return_value_httpp_getvar_14;
        return_value_httpp_getvar_14=httpp_getvar(parser, "__errormessage");
        log_write(errorlog, (unsigned int)1, "slave/", "open_relay_connection", "Error from relay request: %s (%s)", relay->localmount, return_value_httpp_getvar_14);
        break;
      }

      global_lock();
      signed int return_value_client_create_16;
      return_value_client_create_16=client_create(&client, con, parser);
      if(!(return_value_client_create_16 >= 0))
      {
        global_unlock();
        con = (struct connection_tag *)(void *)0;
        parser = (struct http_parser_tag *)(void *)0;
        client_destroy(client);
        break;
      }

      global_unlock();
      sock_set_blocking(streamsock, 0);
      client_set_queue(client, (struct _refbuf_tag *)(void *)0);
      free((void *)server);
      free((void *)mount);
      free((void *)server_id);
      free((void *)auth_header);
      return client;
    }
    redirects = redirects + 1;
  }
  free((void *)server);
  free((void *)mount);
  free((void *)server_id);
  free((void *)auth_header);
  if(!(con == ((struct connection_tag *)NULL)))
    connection_close(con);

  if(!(parser == ((struct http_parser_tag *)NULL)))
    httpp_destroy(parser);

  return (struct _client_tag *)(void *)0;
}

// opus_codec_free
// file format_opus.c line 32
static void opus_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  ogg_stream_clear(&codec->os);
  free((void *)codec);
}

// parse_headers
// file httpp.c line 92
static void parse_headers(struct http_parser_tag *parser, char **line, signed int lines)
{
  signed int i;
  signed int l;
  signed int whitespace;
  signed int slen;
  char *name = (char *)(void *)0;
  char *value = (char *)(void *)0;
  l = 1;
  for( ; !(l >= lines); l = l + 1)
  {
    whitespace = 0;
    name = line[(signed long int)l];
    value = (char *)(void *)0;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(line[(signed long int)l]);
    slen = (signed int)return_value_strlen_1;
    i = 0;
    for( ; !(i >= slen); i = i + 1)
      if((signed int)line[(signed long int)l][(signed long int)i] == 58)
      {
        whitespace = 1;
        line[(signed long int)l][(signed long int)i] = (char)0;
      }

      else
        if(!(whitespace == 0))
        {
          whitespace = 0;
          for( ; !(i >= slen); i = i + 1)
            if(!((signed int)line[(signed long int)l][(signed long int)i] == 32))
              break;

          if(!(i >= slen))
            value = &line[(signed long int)l][(signed long int)i];

          break;
        }

    if(!(name == ((char *)NULL)) && !(value == ((char *)NULL)))
    {
      char *return_value__lowercase_2;
      return_value__lowercase_2=_lowercase(name);
      httpp_setvar(parser, return_value__lowercase_2, value);
      name = (char *)(void *)0;
      value = (char *)(void *)0;
    }

  }
}

// parse_query
// file httpp.c line 254
static void parse_query(struct http_parser_tag *parser, char *query)
{
  signed int len;
  signed int i = 0;
  char *key = query;
  char *val = (char *)(void *)0;
  _Bool tmp_if_expr_1;
  if(query == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*query != 0) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(query);
    len = (signed int)return_value_strlen_2;
    for( ; !(i >= len); i = i + 1)
      switch((signed int)query[(signed long int)i])
      {
        case 38:
        {
          query[(signed long int)i] = (char)0;
          if(!(key == ((char *)NULL)) && !(val == ((char *)NULL)))
            httpp_set_query_param(parser, key, val);

          key = query + (signed long int)i + (signed long int)1;
          break;
        }
        case 61:
        {
          query[(signed long int)i] = (char)0;
          val = query + (signed long int)i + (signed long int)1;
        }
      }
    if(!(key == ((char *)NULL)) && !(val == ((char *)NULL)))
      httpp_set_query_param(parser, key, val);

  }

}

// print_connectors
// file avl.c line 1088
static void print_connectors(struct _link_node *link)
{
  if(!(link->parent == ((struct _link_node *)NULL)))
    print_connectors(link->parent);

  _Bool tmp_if_expr_1;
  if(!(link->parent == ((struct _link_node *)NULL)))
    tmp_if_expr_1 = link->parent->direction != link->direction ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = link->parent->parent != ((struct _link_node *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int i;
    fprintf(stdout, "|");
    i = 0;
    for( ; !(i >= link->width + -1); i = i + 1)
      fprintf(stdout, " ");
  }

  else
  {
    signed int print_connectors__1__3__i = 0;
    for( ; !(print_connectors__1__3__i >= link->width); print_connectors__1__3__i = print_connectors__1__3__i + 1)
      fprintf(stdout, " ");
  }
}

// print_node
// file avl.c line 1115
static void print_node(signed int (*key_printer)(char *, void *), struct avl_node_tag *node, struct _link_node *link)
{
  char buffer[256l];
  unsigned int width;
  signed int return_value;
  return_value=key_printer(buffer, node->key);
  width = (unsigned int)return_value;
  if(!(node->right == ((struct avl_node_tag *)NULL)))
  {
    struct _link_node here;
    here.parent = link;
    here.direction = (char)1;
    here.width = (signed int)(width + (unsigned int)11);
    print_node(key_printer, node->right, &here);
  }

  print_connectors(link);
  fprintf(stdout, "+-[%c %s %03d]", balance_chars[(signed long int)((signed int)((node->rank_and_balance & (unsigned int)3) - (unsigned int)1) + 1)], (const void *)buffer, (signed int)(node->rank_and_balance >> 2));
  _Bool tmp_if_expr_1;
  if(!(node->left == ((struct avl_node_tag *)NULL)))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = node->right != ((struct avl_node_tag *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    fprintf(stdout, "-|\n");

  else
    fprintf(stdout, "\n");
  if(!(node->left == ((struct avl_node_tag *)NULL)))
  {
    struct _link_node print_node__1__4__here;
    print_node__1__4__here.parent = link;
    print_node__1__4__here.direction = (char)-1;
    print_node__1__4__here.width = (signed int)(width + (unsigned int)11);
    print_node(key_printer, node->left, &print_node__1__4__here);
  }

}

// process_flac_page
// file format_flac.c line 45
static struct _refbuf_tag * process_flac_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page)
{
  struct _refbuf_tag *refbuf;
  signed int return_value_ogg_stream_packetout_2;
  if(!(codec->headers == 0u))
  {
    struct anonymous_14 packet;
    signed int return_value_ogg_stream_pagein_1;
    return_value_ogg_stream_pagein_1=ogg_stream_pagein(&codec->os, page);
    if(!(return_value_ogg_stream_pagein_1 >= 0))
    {
      ogg_info->error = 1;
      return (struct _refbuf_tag *)(void *)0;
    }

    do
    {
      return_value_ogg_stream_packetout_2=ogg_stream_packetout(&codec->os, &packet);
      if(return_value_ogg_stream_packetout_2 == 0)
        break;

      signed int type = (signed int)packet.packet[(signed long int)0];
      if(type == 0xFF)
      {
        codec->headers = (unsigned int)0;
        break;
      }

      if(!(type >= 1) || type >= 127)
      {
        if(!(type >= 0x81) || type >= 255)
        {
          ogg_info->error = 1;
          return (struct _refbuf_tag *)(void *)0;
        }

      }

    }
    while((_Bool)1);
    if(!(codec->headers == 0u))
    {
      format_ogg_attach_header(ogg_info, page);
      return (struct _refbuf_tag *)(void *)0;
    }

  }

  refbuf=make_refbuf_with_page(page);
  return refbuf;
}

// process_global_event
// file stats.c line 486
static void process_global_event(struct _stats_event_tag *event)
{
  struct _stats_node_tag *node;
  if(event->action == 5)
  {
    node=_find_node(_stats.global_tree, event->name);
    if(!(node == ((struct _stats_node_tag *)NULL)))
      avl_delete(_stats.global_tree, (void *)node, _free_stats);

  }

  else
  {
    node=_find_node(_stats.global_tree, event->name);
    if(!(node == ((struct _stats_node_tag *)NULL)))
      modify_node_event(node, event);

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _stats_node_tag) /*24ul*/ );
      node = (struct _stats_node_tag *)return_value_calloc_1;
      char *return_value_strdup_2;
      return_value_strdup_2=strdup(event->name);
      node->name = (char *)return_value_strdup_2;
      char *return_value_strdup_3;
      return_value_strdup_3=strdup(event->value);
      node->value = (char *)return_value_strdup_3;
      avl_insert(_stats.global_tree, (void *)node);
    }
  }
}

// process_initial_page
// file format_ogg.c line 206
static signed int process_initial_page(struct _format_plugin_tag *plugin, struct anonymous_3 *page)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)plugin->_state;
  struct ogg_codec_tag *codec;
  if(!(ogg_info->bos_completed == 0))
  {
    ogg_info->bitrate = (signed long int)0;
    ogg_info->codec_sync = (struct ogg_codec_tag *)(void *)0;
    free_ogg_codecs(ogg_info);
  }

  if(ogg_info->codec_count >= 11)
  {
    log_write(errorlog, (unsigned int)1, "format-ogg/", "process_initial_page", "many codecs in stream, playing safe, dropping source");
    ogg_info->error = 1;
    return -1;
  }

  else
  {
    codec=initial_vorbis_page(plugin, page);
    if(codec == ((struct ogg_codec_tag *)NULL))
    {
      codec=initial_theora_page(plugin, page);
      if(codec == ((struct ogg_codec_tag *)NULL))
      {
        codec=initial_midi_page(plugin, page);
        if(codec == ((struct ogg_codec_tag *)NULL))
        {
          codec=initial_flac_page(plugin, page);
          if(codec == ((struct ogg_codec_tag *)NULL))
          {
            codec=initial_speex_page(plugin, page);
            if(codec == ((struct ogg_codec_tag *)NULL))
            {
              codec=initial_kate_page(plugin, page);
              if(codec == ((struct ogg_codec_tag *)NULL))
              {
                codec=initial_skeleton_page(plugin, page);
                if(codec == ((struct ogg_codec_tag *)NULL))
                {
                  codec=initial_opus_page(plugin, page);
                  if(codec == ((struct ogg_codec_tag *)NULL))
                  {
                    log_write(errorlog, (unsigned int)1, "format-ogg/", "process_initial_page", "Seen BOS page with unknown type");
                    ogg_info->error = 1;
                    return -1;
                  }

                }

              }

            }

          }

        }

      }

    }

    if(!(codec == ((struct ogg_codec_tag *)NULL)))
    {
      codec->next = ogg_info->codecs;
      ogg_info->codecs = codec;
      ogg_info->codec_count = ogg_info->codec_count + 1;
    }

    return 0;
  }
}

// process_kate_page
// file format_kate.c line 77
static struct _refbuf_tag * process_kate_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page)
{
  struct _kate_codec_tag *kate = (struct _kate_codec_tag *)codec->specific;
  struct anonymous_14 packet;
  signed int header_page = 0;
  struct _refbuf_tag *refbuf = (struct _refbuf_tag *)(void *)0;
  signed long int granulepos;
  signed int return_value_ogg_stream_pagein_1;
  return_value_ogg_stream_pagein_1=ogg_stream_pagein(&codec->os, page);
  signed int return_value_ogg_stream_packetout_2;
  _Bool tmp_if_expr_3;
  if(!(return_value_ogg_stream_pagein_1 >= 0))
  {
    ogg_info->error = 1;
    return (struct _refbuf_tag *)(void *)0;
  }

  else
  {
    granulepos=ogg_page_granulepos(page);
    do
    {
      return_value_ogg_stream_packetout_2=ogg_stream_packetout(&codec->os, &packet);
      if(!(return_value_ogg_stream_packetout_2 >= 1))
        break;

      if(kate->headers_done == 0)
      {
        if(packet.bytes >= 1l)
          tmp_if_expr_3 = ((signed int)packet.packet[(signed long int)0] & 0x80) != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        header_page = (signed int)tmp_if_expr_3;
        if(header_page == 0)
          break;

        codec->headers = codec->headers + 1u;
        if((signed int)*packet.packet == 0x80)
        {
          if(!(packet.bytes >= 64l))
            return (struct _refbuf_tag *)(void *)0;

          kate->num_headers = (signed int)packet.packet[(signed long int)11];
        }

      }

      else
        if(!(codec->headers >= (unsigned int)kate->num_headers))
        {
          ogg_info->error = 1;
          log_write(errorlog, (unsigned int)1, "format-kate/", "process_kate_page", "Not enough header packets");
          return (struct _refbuf_tag *)(void *)0;
        }

    }
    while((_Bool)1);
    if(!(header_page == 0))
    {
      format_ogg_attach_header(ogg_info, page);
      return (struct _refbuf_tag *)(void *)0;
    }

    else
    {
      refbuf=make_refbuf_with_page(page);
      if(!(codec->possible_start == ((struct _refbuf_tag *)NULL)))
      {
        codec->possible_start->sync_point = 1;
        refbuf_release(codec->possible_start);
        codec->possible_start = (struct _refbuf_tag *)(void *)0;
      }

      if(granulepos == 0l || !(granulepos == kate->prev_granulepos))
      {
        if(!(codec->possible_start == ((struct _refbuf_tag *)NULL)))
          refbuf_release(codec->possible_start);

        refbuf_addref(refbuf);
        codec->possible_start = refbuf;
      }

      kate->prev_granulepos = granulepos;
      return refbuf;
    }
  }
}

// process_midi_page
// file format_midi.c line 44
static struct _refbuf_tag * process_midi_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page)
{
  struct _refbuf_tag *refbuf;
  signed int return_value_ogg_stream_pagein_1;
  return_value_ogg_stream_pagein_1=ogg_stream_pagein(&codec->os, page);
  if(!(return_value_ogg_stream_pagein_1 >= 0))
  {
    ogg_info->error = 1;
    return (struct _refbuf_tag *)(void *)0;
  }

  else
  {
    refbuf=make_refbuf_with_page(page);
    return refbuf;
  }
}

// process_ogg_page
// file format_ogg.c line 370
static struct _refbuf_tag * process_ogg_page(struct ogg_state_tag *ogg_info, struct anonymous_3 *page)
{
  struct ogg_codec_tag *codec = ogg_info->codecs;
  struct _refbuf_tag *refbuf = (struct _refbuf_tag *)(void *)0;
  while(!(codec == ((struct ogg_codec_tag *)NULL)))
  {
    signed int return_value_ogg_page_serialno_1;
    return_value_ogg_page_serialno_1=ogg_page_serialno(page);
    if((signed long int)return_value_ogg_page_serialno_1 == codec->os.serialno)
    {
      if(!(codec->process_page == ((struct _refbuf_tag * (*)(struct ogg_state_tag *, struct ogg_codec_tag *, struct anonymous_3 *))NULL)))
        refbuf=codec->process_page(ogg_info, codec, page);

      break;
    }

    codec = codec->next;
  }
  ogg_info->current = codec;
  return refbuf;
}

// process_opus_page
// file format_opus.c line 39
static struct _refbuf_tag * process_opus_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page)
{
  struct _refbuf_tag *refbuf;
  signed int return_value_ogg_stream_packetout_1;
  if(!(codec->headers >= 2u))
  {
    struct anonymous_14 packet;
    ogg_stream_pagein(&codec->os, page);
    do
    {
      return_value_ogg_stream_packetout_1=ogg_stream_packetout(&codec->os, &packet);
      if(!(return_value_ogg_stream_packetout_1 >= 1))
        break;

      codec->headers = codec->headers + 1u;
    }
    while((_Bool)1);
    format_ogg_attach_header(ogg_info, page);
    return (struct _refbuf_tag *)(void *)0;
  }

  refbuf=make_refbuf_with_page(page);
  return refbuf;
}

// process_request_queue
// file connection.c line 606
static void process_request_queue(void)
{
  struct client_queue_tag **node_ref = (struct client_queue_tag **)&_req_queue;
  struct ice_config_tag *config;
  config=config_get_config();
  signed int timeout = config->header_timeout;
  config_release_config();
  _Bool tmp_if_expr_5;
  while(!(*node_ref == ((struct client_queue_tag *)NULL)))
  {
    struct client_queue_tag *node = *node_ref;
    struct _client_tag *client = node->client;
    signed int len = (4096 - 1) - node->offset;
    char *buf = client->refbuf->data + (signed long int)node->offset;
    if(len >= 1)
    {
      signed long int return_value_time_1;
      return_value_time_1=time((signed long int *)(void *)0);
      if(return_value_time_1 >= client->con->con_time + (signed long int)timeout)
        len = 0;

      else
        len=client_read_bytes(client, (void *)buf, (unsigned int)len);
    }

    if(len >= 1)
    {
      signed int pass_it = 1;
      char *ptr;
      node->offset = node->offset + len;
      client->refbuf->data[(signed long int)node->offset] = (char)0;
      do
      {
        if(node->shoutcast == 1)
        {
          char *return_value_strstr_2;
          return_value_strstr_2=strstr(client->refbuf->data, "\r\r\n");
          if(!(return_value_strstr_2 == ((char *)NULL)))
            goto __CPROVER_DUMP_L12;

          char *return_value_strstr_3;
          return_value_strstr_3=strstr(client->refbuf->data, "\r\n");
          if(!(return_value_strstr_3 == ((char *)NULL)))
            goto __CPROVER_DUMP_L12;

          char *return_value_strstr_4;
          return_value_strstr_4=strstr(client->refbuf->data, "\n");
          if(!(return_value_strstr_4 == ((char *)NULL)))
            goto __CPROVER_DUMP_L12;

        }

        ptr=strstr(client->refbuf->data, "\r\r\n\r\r\n");
        if(!(ptr == ((char *)NULL)))
        {
          node->stream_offset = (signed int)((ptr + (signed long int)6) - client->refbuf->data);
          break;
        }

        ptr=strstr(client->refbuf->data, "\r\n\r\n");
        if(!(ptr == ((char *)NULL)))
        {
          node->stream_offset = (signed int)((ptr + (signed long int)4) - client->refbuf->data);
          break;
        }

        ptr=strstr(client->refbuf->data, "\n\n");
        if(!(ptr == ((char *)NULL)))
        {
          node->stream_offset = (signed int)((ptr + (signed long int)2) - client->refbuf->data);
          break;
        }

        pass_it = 0;
      }
      while((_Bool)0);

    __CPROVER_DUMP_L12:
      ;
      if(!(pass_it == 0))
      {
        if(_req_queue_tail == &node->next)
          _req_queue_tail = (volatile struct client_queue_tag **)node_ref;

        *node_ref = node->next;
        node->next = (struct client_queue_tag *)(void *)0;
        _add_connection(node);
        continue;
      }

    }

    else
    {
      if(len == 0)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = client->con->error != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        if(_req_queue_tail == &node->next)
          _req_queue_tail = (volatile struct client_queue_tag **)node_ref;

        *node_ref = node->next;
        client_destroy(client);
        free((void *)node);
        continue;
      }

    }
    node_ref = &node->next;
  }
  _handle_connection();
}

// process_skeleton_page
// file format_skeleton.c line 47
static struct _refbuf_tag * process_skeleton_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page)
{
  struct anonymous_14 packet;
  signed int return_value_ogg_stream_pagein_1;
  return_value_ogg_stream_pagein_1=ogg_stream_pagein(&codec->os, page);
  signed int return_value_ogg_stream_packetout_2;
  if(!(return_value_ogg_stream_pagein_1 >= 0))
  {
    ogg_info->error = 1;
    return (struct _refbuf_tag *)(void *)0;
  }

  else
  {
    do
    {
      return_value_ogg_stream_packetout_2=ogg_stream_packetout(&codec->os, &packet);
      if(!(return_value_ogg_stream_packetout_2 >= 1))
        break;

      codec->headers = codec->headers + 1u;
    }
    while((_Bool)1);
    format_ogg_attach_header(ogg_info, page);
    return (struct _refbuf_tag *)(void *)0;
  }
}

// process_source_event
// file stats.c line 516
static void process_source_event(struct _stats_event_tag *event)
{
  struct _stats_source_tag *snode;
  snode=_find_source(_stats.source_tree, event->source);
  if(snode == ((struct _stats_source_tag *)NULL))
  {
    if(event->action == 5)
      goto __CPROVER_DUMP_L16;

    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _stats_source_tag) /*24ul*/ );
    snode = (struct _stats_source_tag *)return_value_calloc_1;
    if(snode == ((struct _stats_source_tag *)NULL))
      goto __CPROVER_DUMP_L16;

    log_write(errorlog, (unsigned int)4, "stats/", "process_source_event", "new source stat %s", event->source);
    char *return_value_strdup_2;
    return_value_strdup_2=strdup(event->source);
    snode->source = (char *)return_value_strdup_2;
    snode->stats_tree=avl_tree_new(_compare_stats, (void *)0);
    if(event->action == 6)
      snode->hidden = 1;

    else
      snode->hidden = 0;
    avl_insert(_stats.source_tree, (void *)snode);
  }

  if(!(event->name == ((char *)NULL)))
  {
    struct _stats_node_tag *node;
    node=_find_node(snode->stats_tree, event->name);
    if(node == ((struct _stats_node_tag *)NULL))
    {
      if(event->action == 5)
        goto __CPROVER_DUMP_L16;

      if(!(event->value == ((char *)NULL)))
      {
        log_write(errorlog, (unsigned int)4, "stats/", "process_source_event", "new node %s (%s)", event->name, event->value);
        void *return_value_calloc_3;
        return_value_calloc_3=calloc((unsigned long int)1, sizeof(struct _stats_node_tag) /*24ul*/ );
        node = (struct _stats_node_tag *)return_value_calloc_3;
        char *return_value_strdup_4;
        return_value_strdup_4=strdup(event->name);
        node->name = (char *)return_value_strdup_4;
        char *return_value_strdup_5;
        return_value_strdup_5=strdup(event->value);
        node->value = (char *)return_value_strdup_5;
        node->hidden = snode->hidden;
        avl_insert(snode->stats_tree, (void *)node);
      }

      goto __CPROVER_DUMP_L16;
    }

    if(event->action == 5)
    {
      log_write(errorlog, (unsigned int)4, "stats/", "process_source_event", "delete node %s", event->name);
      avl_delete(snode->stats_tree, (void *)node, _free_stats);
      goto __CPROVER_DUMP_L16;
    }

    modify_node_event(node, event);
    goto __CPROVER_DUMP_L16;
  }

  if(event->action == 6)
  {
    struct avl_node_tag *process_source_event__1__3__node;
    process_source_event__1__3__node=avl_get_first(snode->stats_tree);
    if(!(event->value == ((char *)NULL)))
      snode->hidden = 1;

    else
      snode->hidden = 0;
    while(!(process_source_event__1__3__node == ((struct avl_node_tag *)NULL)))
    {
      struct _stats_node_tag *stats = (struct _stats_node_tag *)process_source_event__1__3__node->key;
      stats->hidden = snode->hidden;
      process_source_event__1__3__node=avl_get_next(process_source_event__1__3__node);
    }
    goto __CPROVER_DUMP_L16;
  }

  if(event->action == 5)
  {
    log_write(errorlog, (unsigned int)4, "stats/", "process_source_event", "delete source node %s", event->source);
    avl_delete(_stats.source_tree, (void *)snode, _free_source_stats);
  }


__CPROVER_DUMP_L16:
  ;
}

// process_speex_page
// file format_speex.c line 40
static struct _refbuf_tag * process_speex_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page)
{
  struct _refbuf_tag *refbuf;
  signed int return_value_ogg_stream_packetout_1;
  if(!(codec->headers >= 2u))
  {
    struct anonymous_14 packet;
    ogg_stream_pagein(&codec->os, page);
    do
    {
      return_value_ogg_stream_packetout_1=ogg_stream_packetout(&codec->os, &packet);
      if(!(return_value_ogg_stream_packetout_1 >= 1))
        break;

      codec->headers = codec->headers + 1u;
    }
    while((_Bool)1);
    format_ogg_attach_header(ogg_info, page);
    return (struct _refbuf_tag *)(void *)0;
  }

  refbuf=make_refbuf_with_page(page);
  return refbuf;
}

// process_theora_page
// file format_theora.c line 66
static struct _refbuf_tag * process_theora_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page)
{
  struct _theora_codec_tag *theora = (struct _theora_codec_tag *)codec->specific;
  struct anonymous_14 packet;
  signed int header_page = 0;
  signed int has_keyframe = 0;
  struct _refbuf_tag *refbuf = (struct _refbuf_tag *)(void *)0;
  signed long int granulepos;
  signed int return_value_ogg_stream_pagein_1;
  return_value_ogg_stream_pagein_1=ogg_stream_pagein(&codec->os, page);
  signed int return_value_ogg_stream_packetout_2;
  if(!(return_value_ogg_stream_pagein_1 >= 0))
  {
    ogg_info->error = 1;
    return (struct _refbuf_tag *)(void *)0;
  }

  else
  {
    granulepos=ogg_page_granulepos(page);
    do
    {
      return_value_ogg_stream_packetout_2=ogg_stream_packetout(&codec->os, &packet);
      if(!(return_value_ogg_stream_packetout_2 >= 1))
        break;

      signed int return_value_theora_packet_isheader_4;
      return_value_theora_packet_isheader_4=theora_packet_isheader(&packet);
      if(!(return_value_theora_packet_isheader_4 == 0))
      {
        signed int return_value_theora_decode_header_3;
        return_value_theora_decode_header_3=theora_decode_header(&theora->ti, &theora->tc, &packet);
        if(!(return_value_theora_decode_header_3 >= 0))
        {
          ogg_info->error = 1;
          log_write(errorlog, (unsigned int)2, "format-theora/", "process_theora_page", "problem with theora header");
          return (struct _refbuf_tag *)(void *)0;
        }

        header_page = 1;
        codec->headers = codec->headers + 1u;
        if(codec->headers == 3u)
        {
          ogg_info->bitrate = ogg_info->bitrate + (signed long int)theora->ti.target_bitrate;
          stats_event_args(ogg_info->mount, "video_bitrate", "%ld", (signed long int)theora->ti.target_bitrate);
          stats_event_args(ogg_info->mount, "video_quality", "%ld", (signed long int)theora->ti.quality);
          stats_event_args(ogg_info->mount, "frame_size", "%ld x %ld", (signed long int)theora->ti.frame_width, (signed long int)theora->ti.frame_height);
          stats_event_args(ogg_info->mount, "frame_rate", "%.2f", (float)theora->ti.fps_numerator / (float)theora->ti.fps_denominator);
        }

        continue;
      }

      if(!(codec->headers >= 3u))
      {
        ogg_info->error = 1;
        log_write(errorlog, (unsigned int)1, "format-theora/", "process_theora_page", "Not enough header packets");
        return (struct _refbuf_tag *)(void *)0;
      }

      signed int return_value_theora_packet_iskeyframe_5;
      return_value_theora_packet_iskeyframe_5=theora_packet_iskeyframe(&packet);
      if(!(return_value_theora_packet_iskeyframe_5 == 0))
        has_keyframe = 1;

    }
    while((_Bool)1);
    if(!(header_page == 0))
    {
      format_ogg_attach_header(ogg_info, page);
      return (struct _refbuf_tag *)(void *)0;
    }

    else
    {
      refbuf=make_refbuf_with_page(page);
      if(granulepos == 0l || !(granulepos == theora->prev_granulepos))
      {
        if(!(codec->possible_start == ((struct _refbuf_tag *)NULL)))
          refbuf_release(codec->possible_start);

        refbuf_addref(refbuf);
        codec->possible_start = refbuf;
      }

      theora->prev_granulepos = granulepos;
      if(!(has_keyframe == 0))
      {
        if(!(codec->possible_start == ((struct _refbuf_tag *)NULL)))
        {
          codec->possible_start->sync_point = 1;
          refbuf_release(codec->possible_start);
          codec->possible_start = (struct _refbuf_tag *)(void *)0;
        }

      }

      return refbuf;
    }
  }
}

// process_vorbis
// file format_vorbis.c line 466
static struct _refbuf_tag * process_vorbis(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  struct vorbis_codec_tag *source_vorbis = (struct vorbis_codec_tag *)codec->specific;
  struct _refbuf_tag *refbuf;
  signed int return_value;
  if(!(source_vorbis->get_buffer_page == ((struct _refbuf_tag * (*)(struct ogg_state_tag *, struct ogg_codec_tag *))NULL)))
  {
    refbuf=source_vorbis->get_buffer_page(ogg_info, codec);
    if(!(refbuf == ((struct _refbuf_tag *)NULL)))
      return refbuf;

  }

  if(!(source_vorbis->process_packet == ((signed int (*)(struct ogg_state_tag *, struct ogg_codec_tag *))NULL)))
    return_value=source_vorbis->process_packet(ogg_info, codec);

  return (struct _refbuf_tag *)(void *)0;
}

// process_vorbis_audio
// file format_vorbis.c line 238
static signed int process_vorbis_audio(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  struct vorbis_codec_tag *source_vorbis = (struct vorbis_codec_tag *)codec->specific;
  while((_Bool)1)
  {
    signed int window;
    struct anonymous_14 packet;
    signed int return_value_ogg_stream_packetout_1;
    return_value_ogg_stream_packetout_1=ogg_stream_packetout(&codec->os, &packet);
    if(!(return_value_ogg_stream_packetout_1 >= 1))
      break;

    signed long int return_value_vorbis_packet_blocksize_2;
    return_value_vorbis_packet_blocksize_2=vorbis_packet_blocksize(&source_vorbis->vi, &packet);
    window = (signed int)(return_value_vorbis_packet_blocksize_2 / (signed long int)4);
    source_vorbis->granulepos = source_vorbis->granulepos + (signed long int)window;
    if(!(source_vorbis->prev_packet == ((struct anonymous_14 *)NULL)))
    {
      struct anonymous_14 *prev_packet = source_vorbis->prev_packet;
      add_audio_packet(source_vorbis, prev_packet);
      free_ogg_packet(prev_packet);
      if(packet.packetno == 4l)
      {
        if(!(source_vorbis->initial_page_granulepos >= source_vorbis->granulepos))
        {
          source_vorbis->granulepos = source_vorbis->granulepos - source_vorbis->initial_page_granulepos;
          source_vorbis->samples_in_page = (signed long int)source_vorbis->page_samples_trigger;
        }

      }

      if(packet.granulepos == source_vorbis->initial_page_granulepos)
      {
        if(!(source_vorbis->granulepos >= source_vorbis->initial_page_granulepos))
          source_vorbis->granulepos = source_vorbis->initial_page_granulepos;

      }

      if(packet.e_o_s == 0l)
        packet.granulepos = source_vorbis->granulepos;

    }

    else
      packet.granulepos = (signed long int)0;
    source_vorbis->prev_window = window;
    source_vorbis->prev_packet=copy_ogg_packet(&packet);
    if(!(packet.e_o_s == 0l))
    {
      initiate_flush(source_vorbis);
      free_ogg_packet(source_vorbis->prev_packet);
      source_vorbis->prev_packet = (struct anonymous_14 *)(void *)0;
      return 1;
    }

    if(!((signed long int)source_vorbis->page_samples_trigger >= source_vorbis->samples_in_page))
      return 1;

  }
  if(!(source_vorbis->stream_notify == 0))
  {
    initiate_flush(source_vorbis);
    source_vorbis->stream_notify = 0;
    return 1;
  }

  else
    return -1;
}

// process_vorbis_headers
// file format_vorbis.c line 314
static signed int process_vorbis_headers(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  struct vorbis_codec_tag *source_vorbis = (struct vorbis_codec_tag *)codec->specific;
  if(source_vorbis->header[0l] == ((struct anonymous_14 *)NULL))
    return 0;

  else
  {
    log_write(errorlog, (unsigned int)4, "format-vorbis/", "process_vorbis_headers", "Adding the 3 header packets");
    ogg_stream_packetin(&source_vorbis->new_os, source_vorbis->header[(signed long int)0]);
    if(!(source_vorbis->rebuild_comment == 0))
    {
      struct vorbis_comment vc;
      struct anonymous_14 header;
      struct ice_config_tag *config;
      vorbis_comment_init(&vc);
      if(!(ogg_info->artist == ((char *)NULL)))
        vorbis_comment_add_tag(&vc, "artist", ogg_info->artist);

      if(!(ogg_info->title == ((char *)NULL)))
        vorbis_comment_add_tag(&vc, "title", ogg_info->title);

      config=config_get_config();
      vorbis_comment_add_tag(&vc, "server", config->server_id);
      config_release_config();
      vorbis_commentheader_out(&vc, &header);
      ogg_stream_packetin(&source_vorbis->new_os, &header);
      vorbis_comment_clear(&vc);
      ogg_packet_clear(&header);
    }

    else
      ogg_stream_packetin(&source_vorbis->new_os, source_vorbis->header[(signed long int)1]);
    ogg_stream_packetin(&source_vorbis->new_os, source_vorbis->header[(signed long int)2]);
    source_vorbis->rebuild_comment = 0;
    ogg_info->log_metadata = 1;
    source_vorbis->get_buffer_page = get_buffer_header;
    source_vorbis->process_packet = process_vorbis_audio;
    source_vorbis->granulepos = (signed long int)source_vorbis->prev_window;
    source_vorbis->initial_audio_packet = 1;
    return 1;
  }
}

// process_vorbis_page
// file format_vorbis.c line 501
static struct _refbuf_tag * process_vorbis_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page)
{
  struct anonymous_14 header;
  struct vorbis_codec_tag *source_vorbis = (struct vorbis_codec_tag *)codec->specific;
  char *comment;
  signed int return_value_ogg_stream_pagein_1;
  return_value_ogg_stream_pagein_1=ogg_stream_pagein(&codec->os, page);
  if(!(return_value_ogg_stream_pagein_1 >= 0))
  {
    ogg_info->error = 1;
    return (struct _refbuf_tag *)(void *)0;
  }

  else
    if(codec->headers == 3u)
    {
      if(!(source_vorbis->initial_audio_page == 0))
      {
        source_vorbis->initial_page_granulepos=ogg_page_granulepos(page);
        source_vorbis->initial_audio_page = 0;
      }

      return (struct _refbuf_tag *)(void *)0;
    }

    else
    {
      while(!(codec->headers >= 3u))
      {
        log_write(errorlog, (unsigned int)4, "format-vorbis/", "process_vorbis_page", "processing incoming header packet (%d)", codec->headers);
        signed int return_value_ogg_stream_packetout_2;
        return_value_ogg_stream_packetout_2=ogg_stream_packetout(&codec->os, &header);
        if(!(return_value_ogg_stream_packetout_2 >= 1))
        {
          if(!(ogg_info->codecs->next == ((struct ogg_codec_tag *)NULL)))
            format_ogg_attach_header(ogg_info, page);

          return (struct _refbuf_tag *)(void *)0;
        }

        signed int return_value_vorbis_synthesis_headerin_3;
        return_value_vorbis_synthesis_headerin_3=vorbis_synthesis_headerin(&source_vorbis->vi, &source_vorbis->vc, &header);
        if(!(return_value_vorbis_synthesis_headerin_3 >= 0))
        {
          ogg_info->error = 1;
          log_write(errorlog, (unsigned int)2, "format-vorbis/", "process_vorbis_page", "Problem parsing ogg vorbis header");
          return (struct _refbuf_tag *)(void *)0;
        }

        header.granulepos = (signed long int)0;
        source_vorbis->header[(signed long int)codec->headers]=copy_ogg_packet(&header);
        codec->headers = codec->headers + 1u;
      }
      log_write(errorlog, (unsigned int)4, "format-vorbis/", "process_vorbis_page", "we have the header packets now");
      if(ogg_info->codecs->next == ((struct ogg_codec_tag *)NULL))
      {
        source_vorbis->page_samples_trigger = (signed int)(source_vorbis->vi.rate / (signed long int)2);
        source_vorbis->process_packet = process_vorbis_headers;
        source_vorbis->initial_audio_page = 1;
      }

      else
      {
        format_ogg_attach_header(ogg_info, &source_vorbis->bos_page);
        format_ogg_attach_header(ogg_info, page);
        codec->process_page = process_vorbis_passthru_page;
      }
      free((void *)ogg_info->title);
      comment=vorbis_comment_query(&source_vorbis->vc, "TITLE", 0);
      if(!(comment == ((char *)NULL)))
        ogg_info->title=strdup(comment);

      else
        ogg_info->title = (char *)(void *)0;
      free((void *)ogg_info->artist);
      comment=vorbis_comment_query(&source_vorbis->vc, "ARTIST", 0);
      if(!(comment == ((char *)NULL)))
        ogg_info->artist=strdup(comment);

      else
        ogg_info->artist = (char *)(void *)0;
      ogg_info->log_metadata = 1;
      stats_event_args(ogg_info->mount, "audio_samplerate", "%ld", (signed long int)source_vorbis->vi.rate);
      stats_event_args(ogg_info->mount, "audio_channels", "%ld", (signed long int)source_vorbis->vi.channels);
      stats_event_args(ogg_info->mount, "audio_bitrate", "%ld", (signed long int)source_vorbis->vi.bitrate_nominal);
      stats_event_args(ogg_info->mount, "ice-bitrate", "%ld", (signed long int)source_vorbis->vi.bitrate_nominal / (signed long int)1000);
      return (struct _refbuf_tag *)(void *)0;
    }
}

// process_vorbis_passthru_page
// file format_vorbis.c line 491
static struct _refbuf_tag * process_vorbis_passthru_page(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec, struct anonymous_3 *page)
{
  struct _refbuf_tag *return_value_make_refbuf_with_page_1;
  return_value_make_refbuf_with_page_1=make_refbuf_with_page(page);
  return return_value_make_refbuf_with_page_1;
}

// process_ypdata
// file yp.c line 494
static signed int process_ypdata(struct yp_server *server, struct ypdata_tag *yp)
{
  unsigned int len = (unsigned int)1024;
  char *s = (char *)(void *)0;
  char *tmp;
  if(!(now >= yp->next_update))
    return 0;

  else
  {
    {
      signed int ret;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)s, (unsigned long int)len);
      tmp = (char *)return_value_realloc_1;
      if(tmp == ((char *)NULL))
        return 0;

      s = tmp;
      if(!(yp->release == 0))
      {
        yp->process = do_yp_remove;
        yp->next_update = (signed long int)0;
      }

      ret=yp->process(yp, s, len);
      if(!(ret >= 1))
      {
        free((void *)s);
        return ret;
      }

      len = (unsigned int)ret;
    }
    return 0;
  }
}

// queue_auth_client
// file auth.c line 93
static void queue_auth_client(struct auth_client_tag *auth_user, struct _mount_proxy *mountinfo)
{
  struct auth_tag *auth;
  _Bool tmp_if_expr_1;
  if(!(auth_user == ((struct auth_client_tag *)NULL)))
  {
    auth_user->next = (struct auth_client_tag *)(void *)0;
    if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    {
      auth = mountinfo->auth;
      thread_mutex_lock_c(&auth->lock, 103, "auth.c");
      if(!(auth_user->client == ((struct _client_tag *)NULL)))
        auth_user->client->auth = auth;

      auth->refcount = auth->refcount + 1;
    }

    else
    {
      if(auth_user->client == ((struct _client_tag *)NULL))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = auth_user->client->auth == (struct auth_tag *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        log_write(errorlog, (unsigned int)2, "auth/", "queue_auth_client", "internal state is incorrect for %p", auth_user->client);
        goto __CPROVER_DUMP_L8;
      }

      auth = auth_user->client->auth;
      thread_mutex_lock_c(&auth->lock, 116, "auth.c");
    }
    log_write(errorlog, (unsigned int)4, "auth/", "queue_auth_client", "...refcount on auth_t %s is now %d", auth->mount, auth->refcount);
    *auth->tailp = auth_user;
    auth->tailp = &auth_user->next;
    auth->pending_count = auth->pending_count + 1;
    log_write(errorlog, (unsigned int)3, "auth/", "queue_auth_client", "auth on %s has %d pending", auth->mount, auth->pending_count);
    thread_mutex_unlock_c(&auth->lock, 123, "auth.c");
  }


__CPROVER_DUMP_L8:
  ;
}

// queue_global_event
// file stats.c line 119
static void queue_global_event(struct _stats_event_tag *event)
{
  thread_mutex_lock_c(&_global_event_mutex, 121, "stats.c");
  _add_event_to_queue(event, &_global_event_queue);
  thread_mutex_unlock_c(&_global_event_mutex, 123, "stats.c");
}

// recheck_ip_file
// file connection.c line 324
static void recheck_ip_file(struct anonymous_42 *cache)
{
  signed long int recheck_ip_file__1__now;
  recheck_ip_file__1__now=time((signed long int *)(void *)0);
  signed int return_value_get_line_6;
  _Bool tmp_if_expr_7;
  if(recheck_ip_file__1__now >= cache->file_recheck)
  {
    struct stat file_stat;
    struct _IO_FILE *file = (struct _IO_FILE *)(void *)0;
    signed int count = 0;
    struct _avl_tree *new_ips;
    char line[512l];
    cache->file_recheck = recheck_ip_file__1__now + (signed long int)10;
    if(cache->filename == ((char *)NULL))
    {
      if(!(cache->contents == ((struct _avl_tree *)NULL)))
      {
        avl_tree_free(cache->contents, free_filtered_ip);
        cache->contents = (struct _avl_tree *)(void *)0;
      }

      goto __CPROVER_DUMP_L15;
    }

    signed int return_value_stat_3;
    return_value_stat_3=stat(cache->filename, &file_stat);
    if(!(return_value_stat_3 >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_write(errorlog, (unsigned int)2, "connection/", "recheck_ip_file", "failed to check status of \"%s\": %s", cache->filename, return_value_strerror_2);
      goto __CPROVER_DUMP_L15;
    }

    if(file_stat.st_mtim.tv_sec == cache->file_mtime)
      goto __CPROVER_DUMP_L15;

    cache->file_mtime = file_stat.st_mtim.tv_sec;
    file=fopen(cache->filename, "r");
    if(file == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_write(errorlog, (unsigned int)2, "connection/", "recheck_ip_file", "Failed to open file \"%s\": %s", cache->filename, return_value_strerror_5);
      goto __CPROVER_DUMP_L15;
    }

    new_ips=avl_tree_new(compare_ip, (void *)0);
    do
    {
      return_value_get_line_6=get_line(file, line, (unsigned long int)512);
      if(return_value_get_line_6 == 0)
        break;

      char *str;
      if(line[0l] == 0)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_7)
      {
        count = count + 1;
        str=strdup(line);
        if(!(str == ((char *)NULL)))
          avl_insert(new_ips, (void *)str);

      }

    }
    while((_Bool)1);
    fclose(file);
    log_write(errorlog, (unsigned int)3, "connection/", "recheck_ip_file", "%d entries read from file \"%s\"", count, cache->filename);
    if(!(cache->contents == ((struct _avl_tree *)NULL)))
      avl_tree_free(cache->contents, free_filtered_ip);

    cache->contents = new_ips;
  }


__CPROVER_DUMP_L15:
  ;
}

// refbuf_addref
// file refbuf.h line 36
void refbuf_addref(struct _refbuf_tag *self)
{
  self->_count = self->_count + 1u;
}

// refbuf_initialize
// file refbuf.h line 32
void refbuf_initialize(void)
{
  ;
}

// refbuf_new
// file refbuf.h line 35
struct _refbuf_tag * refbuf_new(unsigned int size)
{
  struct _refbuf_tag *refbuf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _refbuf_tag) /*40ul*/ );
  refbuf = (struct _refbuf_tag *)return_value_malloc_1;
  if(refbuf == ((struct _refbuf_tag *)NULL))
    abort();

  refbuf->data = (char *)(void *)0;
  if(!(size == 0u))
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)size);
    refbuf->data = (char *)return_value_malloc_2;
    if(refbuf->data == ((char *)NULL))
      abort();

  }

  refbuf->len = size;
  refbuf->sync_point = 0;
  refbuf->_count = (unsigned int)1;
  refbuf->next = (struct _refbuf_tag *)(void *)0;
  refbuf->associated = (struct _refbuf_tag *)(void *)0;
  return refbuf;
}

// refbuf_release
// file refbuf.h line 37
void refbuf_release(struct _refbuf_tag *self)
{
  if(!(self == ((struct _refbuf_tag *)NULL)))
  {
    self->_count = self->_count - 1u;
    if(self->_count == 0u)
    {
      refbuf_release_associated(self->associated);
      if(!(self->next == ((struct _refbuf_tag *)NULL)))
        log_write(errorlog, (unsigned int)1, "refbuf/", "refbuf_release", "next not null");

      free((void *)self->data);
      free((void *)self);
    }

  }

}

// refbuf_release_associated
// file refbuf.c line 69
static void refbuf_release_associated(struct _refbuf_tag *ref)
{
  if(!(ref == ((struct _refbuf_tag *)NULL)))
    while(!(ref == ((struct _refbuf_tag *)NULL)))
    {
      struct _refbuf_tag *to_go = ref;
      ref = to_go->next;
      if(to_go->_count == 1u)
        to_go->next = (struct _refbuf_tag *)(void *)0;

      refbuf_release(to_go);
    }

}

// refbuf_shutdown
// file refbuf.h line 33
void refbuf_shutdown(void)
{
  ;
}

// relay_check_streams
// file slave.c line 570
static void relay_check_streams(struct _relay_server *to_start, struct _relay_server *to_free, signed int skip_timer)
{
  struct _relay_server *relay;
  while(!(to_free == ((struct _relay_server *)NULL)))
  {
    if(!(to_free->source == ((struct source_tag *)NULL)))
    {
      if(!(to_free->running == 0))
      {
        log_write(errorlog, (unsigned int)4, "slave/", "relay_check_streams", "source shutdown request on \"%s\"", to_free->localmount);
        to_free->running = 0;
        to_free->source->running = 0;
        thread_join(to_free->thread);
      }

      else
        stats_event(to_free->localmount, (const char *)(void *)0, (const char *)(void *)0);
    }

    to_free=relay_free(to_free);
  }
  relay = to_start;
  for( ; !(relay == ((struct _relay_server *)NULL)); relay = relay->next)
  {
    if(!(skip_timer == 0))
      relay->start = (signed long int)0;

    check_relay_stream(relay);
  }
}

// relay_copy
// file slave.c line 88
struct _relay_server * relay_copy(struct _relay_server *r)
{
  struct _relay_server *copy;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _relay_server) /*104ul*/ );
  copy = (struct _relay_server *)return_value_calloc_1;
  unsigned char *return_value_xmlCharStrdup_5;
  unsigned char *return_value_xmlCharStrdup_6;
  if(!(copy == ((struct _relay_server *)NULL)))
  {
    unsigned char *return_value_xmlCharStrdup_2;
    return_value_xmlCharStrdup_2=xmlCharStrdup(r->server);
    copy->server = (char *)return_value_xmlCharStrdup_2;
    unsigned char *return_value_xmlCharStrdup_3;
    return_value_xmlCharStrdup_3=xmlCharStrdup(r->mount);
    copy->mount = (char *)return_value_xmlCharStrdup_3;
    unsigned char *return_value_xmlCharStrdup_4;
    return_value_xmlCharStrdup_4=xmlCharStrdup(r->localmount);
    copy->localmount = (char *)return_value_xmlCharStrdup_4;
    if(!(r->username == ((char *)NULL)))
    {
      return_value_xmlCharStrdup_5=xmlCharStrdup(r->username);
      copy->username = (char *)return_value_xmlCharStrdup_5;
    }

    if(!(r->password == ((char *)NULL)))
    {
      return_value_xmlCharStrdup_6=xmlCharStrdup(r->password);
      copy->password = (char *)return_value_xmlCharStrdup_6;
    }

    copy->port = r->port;
    copy->mp3metadata = r->mp3metadata;
    copy->on_demand = r->on_demand;
  }

  return copy;
}

// relay_free
// file slave.c line 70
struct _relay_server * relay_free(struct _relay_server *relay)
{
  struct _relay_server *next = relay->next;
  log_write(errorlog, (unsigned int)4, "slave/", "relay_free", "freeing relay %s", relay->localmount);
  if(!(relay->source == ((struct source_tag *)NULL)))
    source_free_source(relay->source);

  xmlFree((void *)relay->server);
  xmlFree((void *)relay->mount);
  xmlFree((void *)relay->localmount);
  if(!(relay->username == ((char *)NULL)))
    xmlFree((void *)relay->username);

  if(!(relay->password == ((char *)NULL)))
    xmlFree((void *)relay->password);

  free((void *)relay);
  return next;
}

// relay_has_changed
// file slave.c line 489
static signed int relay_has_changed(struct _relay_server *new, struct _relay_server *old)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(new->mount, old->mount);
  if(return_value_strcmp_1 == 0)
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(new->server, old->server);
    if(return_value_strcmp_2 == 0)
    {
      if(new->port == old->port)
      {
        if(new->mp3metadata == old->mp3metadata)
        {
          if(!(new->on_demand == old->on_demand))
            old->on_demand = new->on_demand;

          return 0;
        }

      }

    }

  }

  return 1;
}

// release_locks
// file cfgfile.c line 106
static void release_locks(void)
{
  thread_mutex_destroy(&_locks.relay_lock);
  thread_rwlock_destroy(&_locks.config_lock);
}

// resolver_getip
// file resolver.h line 34
char * resolver_getip(const char *name, char *buff, signed int len)
{
  struct addrinfo *head;
  struct addrinfo hints;
  char *ret = (char *)(void *)0;
  signed int return_value__isip_1;
  return_value__isip_1=_isip(name);
  if(!(return_value__isip_1 == 0))
  {
    strncpy(buff, name, (unsigned long int)len);
    buff[(signed long int)(len - 1)] = (char)0;
    return buff;
  }

  else
  {
    memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_socktype = 1;
    signed int return_value_getaddrinfo_2;
    return_value_getaddrinfo_2=getaddrinfo(name, (const char *)(void *)0, &hints, &head);
    if(!(return_value_getaddrinfo_2 == 0))
      return (char *)(void *)0;

    else
    {
      if(!(head == ((struct addrinfo *)NULL)))
      {
        signed int return_value_getnameinfo_3;
        return_value_getnameinfo_3=getnameinfo(head->ai_addr, head->ai_addrlen, buff, (unsigned int)len, (char *)(void *)0, (unsigned int)0, 1);
        if(return_value_getnameinfo_3 == 0)
          ret = buff;

        freeaddrinfo(head);
      }

      return ret;
    }
  }
}

// resolver_getname
// file resolver.c line 86
char * resolver_getname(const char *ip, char *buff, signed int len)
{
  struct addrinfo *head = (struct addrinfo *)(void *)0;
  struct addrinfo hints;
  char *ret = (char *)(void *)0;
  signed int return_value__isip_1;
  return_value__isip_1=_isip(ip);
  if(return_value__isip_1 == 0)
  {
    strncpy(buff, ip, (unsigned long int)len);
    buff[(signed long int)(len - 1)] = (char)0;
    return buff;
  }

  else
  {
    memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_socktype = 1;
    hints.ai_flags = 0x0002;
    signed int return_value_getaddrinfo_2;
    return_value_getaddrinfo_2=getaddrinfo(ip, (const char *)(void *)0, &hints, &head);
    if(!(return_value_getaddrinfo_2 == 0))
      return (char *)(void *)0;

    else
    {
      if(!(head == ((struct addrinfo *)NULL)))
      {
        signed int return_value_getnameinfo_3;
        return_value_getnameinfo_3=getnameinfo(head->ai_addr, head->ai_addrlen, buff, (unsigned int)len, (char *)(void *)0, (unsigned int)0, 8);
        if(return_value_getnameinfo_3 == 0)
          ret = buff;

        freeaddrinfo(head);
      }

      return ret;
    }
  }
}

// resolver_initialize
// file net/resolver.h line 30
void resolver_initialize(void)
{
  if(_initialized_link1 == 0)
  {
    _initialized_link1 = 1;
    thread_mutex_create_c(&_resolver_mutex, 207, "resolver.c");
    sethostent(1);
  }

}

// resolver_shutdown
// file net/resolver.h line 31
void resolver_shutdown(void)
{
  if(!(_initialized_link1 == 0))
  {
    thread_mutex_destroy(&_resolver_mutex);
    _initialized_link1 = 0;
    endhostent();
  }

}

// restart_logging
// file logging.c line 217
void restart_logging(struct ice_config_tag *config)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(config->error_log, "-");
  if(!(return_value_strcmp_1 == 0))
  {
    char fn_error[4096l];
    snprintf(fn_error, (unsigned long int)4096, "%s%s%s", config->log_dir, (const void *)"/", config->error_log);
    log_set_filename(errorlog, fn_error);
    log_set_level(errorlog, (unsigned int)config->loglevel);
    log_set_trigger(errorlog, (unsigned int)config->logsize);
    log_set_archive_timestamp(errorlog, config->logarchive);
    log_reopen(errorlog);
  }

  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(config->access_log, "-");
  if(!(return_value_strcmp_2 == 0))
  {
    char restart_logging__1__2__fn_error[4096l];
    snprintf(restart_logging__1__2__fn_error, (unsigned long int)4096, "%s%s%s", config->log_dir, (const void *)"/", config->access_log);
    log_set_filename(accesslog, restart_logging__1__2__fn_error);
    log_set_trigger(accesslog, (unsigned int)config->logsize);
    log_set_archive_timestamp(accesslog, config->logarchive);
    log_reopen(accesslog);
  }

  if(!(config->playlist_log == ((char *)NULL)))
  {
    char restart_logging__1__3__fn_error[4096l];
    snprintf(restart_logging__1__3__fn_error, (unsigned long int)4096, "%s%s%s", config->log_dir, (const void *)"/", config->playlist_log);
    log_set_filename(playlistlog, restart_logging__1__3__fn_error);
    log_set_trigger(playlistlog, (unsigned int)config->logsize);
    log_set_archive_timestamp(playlistlog, config->logarchive);
    log_reopen(playlistlog);
  }

}

// send_ebml_header
// file format_ebml.c line 119
static signed int send_ebml_header(struct _client_tag *client)
{
  struct ebml_client_data_st *ebml_client_data = (struct ebml_client_data_st *)client->format_data;
  signed int len = 4096;
  signed int ret;
  if(!(ebml_client_data->header->len + -((unsigned int)ebml_client_data->header_pos) >= (unsigned int)len))
    len = (signed int)(ebml_client_data->header->len - (unsigned int)ebml_client_data->header_pos);

  ret=client_send_bytes(client, (const void *)(ebml_client_data->header->data + (signed long int)ebml_client_data->header_pos), (unsigned int)len);
  if(ret >= 1)
    ebml_client_data->header_pos = ebml_client_data->header_pos + ret;

  return ret;
}

// send_ogg_headers
// file format_ogg.c line 485
static signed int send_ogg_headers(struct _client_tag *client, struct _refbuf_tag *headers)
{
  struct ogg_client *client_data = (struct ogg_client *)client->format_data;
  struct _refbuf_tag *refbuf;
  signed int written = 0;
  if(!(client_data->headers_sent == 0))
  {
    client_data->header_page = headers;
    client_data->pos = (unsigned int)0;
    client_data->headers_sent = 0;
  }

  refbuf = client_data->header_page;
  while(!(refbuf == ((struct _refbuf_tag *)NULL)))
  {
    char *data = refbuf->data + (signed long int)client_data->pos;
    unsigned int len = refbuf->len - client_data->pos;
    signed int ret;
    ret=client_send_bytes(client, (const void *)data, len);
    if(ret >= 1)
      written = written + ret;

    if(!(ret >= (signed int)len))
      return written != 0 ? written : -1;

    client_data->pos = client_data->pos + (unsigned int)ret;
    if(client_data->pos == refbuf->len)
    {
      refbuf = refbuf->next;
      client_data->header_page = refbuf;
      client_data->pos = (unsigned int)0;
    }

  }
  client_data->headers_sent = 1;
  client_data->headers = headers;
  return written;
}

// send_stream_metadata
// file format_mp3.c line 319
static signed int send_stream_metadata(struct _client_tag *client, struct _refbuf_tag *associated)
{
  signed int ret = 0;
  char *metadata;
  signed int meta_len;
  struct anonymous_8 *client_mp3 = (struct anonymous_8 *)client->format_data;
  _Bool tmp_if_expr_1;
  if(!(associated == ((struct _refbuf_tag *)NULL)))
    tmp_if_expr_1 = associated != client_mp3->associated ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    metadata = associated->data + (signed long int)client_mp3->metadata_offset;
    meta_len = (signed int)(associated->len - (unsigned int)client_mp3->metadata_offset);
  }

  else
    if(!(associated == ((struct _refbuf_tag *)NULL)))
    {
      metadata = "\0";
      meta_len = 1;
    }

    else
    {
      char *meta = "\001StreamTitle='';";
      metadata = meta + (signed long int)client_mp3->metadata_offset;
      meta_len = 17 - client_mp3->metadata_offset;
    }
  ret=client_send_bytes(client, (const void *)metadata, (unsigned int)meta_len);
  if(ret == meta_len)
  {
    client_mp3->associated = associated;
    client_mp3->metadata_offset = 0;
    client_mp3->in_metadata = 0;
    client_mp3->since_meta_block = (unsigned int)0;
    return ret;
  }

  else
  {
    if(ret >= 1)
      client_mp3->metadata_offset = client_mp3->metadata_offset + ret;

    else
      ret = 0;
    client_mp3->in_metadata = 1;
    return ret;
  }
}

// send_to_listener
// file source.c line 538
static void send_to_listener(struct source_tag *source, struct _client_tag *client, signed int deletion_expected)
{
  signed int bytes;
  signed int loop = 10;
  signed int total_written = 0;
  signed long int return_value_time_1;
  if(!(client->con->discon_time == 0l))
  {
    return_value_time_1=time((signed long int *)(void *)0);
    if(return_value_time_1 >= client->con->discon_time)
    {
      log_write(errorlog, (unsigned int)3, "source/", "send_to_listener", "time limit reached for client #%lu", client->con->id);
      client->con->error = 1;
    }

  }

  if(client->con->error == 0)
  {
    if(loop == 0 || total_written >= 20001)
    {
      if(!(client->check_buffer == format_check_file_buffer))
        source->short_delay = 1;

    }

    else
    {
      loop = loop - 1;
      signed int return_value;
      return_value=client->check_buffer(source, client);
      if(return_value >= 0)
      {
        bytes=client->write_to_client(client);
        if(bytes >= 1)
          total_written = total_written + bytes;

      }

    }
  }

  source->format->sent_bytes = source->format->sent_bytes + (unsigned long int)total_written;
  if(!(deletion_expected == 0))
  {
    if(!(client->refbuf == ((struct _refbuf_tag *)NULL)))
    {
      if(client->refbuf == source->stream_data)
      {
        log_write(errorlog, (unsigned int)3, "source/", "send_to_listener", "Client %lu (%s) has fallen too far behind, removing", client->con->id, client->con->ip);
        stats_event_inc(source->mount, "slow_listeners");
        client->con->error = 1;
      }

    }

  }

}

// send_to_yp
// file yp.c line 296
static signed int send_to_yp(const char *cmd, struct ypdata_tag *yp, char *post)
{
  signed int curlcode;
  struct yp_server *server = yp->server;
  yp->cmd_ok = 0;
  signed int _curl_opt = CURLOPT_POSTFIELDS;
  curl_easy_setopt(server->curl, (enum anonymous_32)_curl_opt, post);
  signed int send_to_yp__1__2___curl_opt = CURLOPT_HEADERDATA;
  curl_easy_setopt(server->curl, (enum anonymous_32)send_to_yp__1__2___curl_opt, yp);
  enum anonymous_34 return_value_curl_easy_perform_1;
  return_value_curl_easy_perform_1=curl_easy_perform(server->curl);
  curlcode = (signed int)return_value_curl_easy_perform_1;
  if(!(curlcode == 0))
  {
    yp->process = do_yp_add;
    yp->next_update = now + (signed long int)1200;
    log_write(errorlog, (unsigned int)1, "yp/", "send_to_yp", "connection to %s failed with \"%s\"", server->url, (const void *)server->curl_error);
    return -2;
  }

  else
    if(yp->cmd_ok == 0)
    {
      if(yp->error_msg == ((char *)NULL))
        yp->error_msg=strdup("no response from server");

      if(yp->process == do_yp_add)
      {
        log_write(errorlog, (unsigned int)1, "yp/", "send_to_yp", "YP %s on %s failed: %s", cmd, server->url, yp->error_msg);
        yp->next_update = now + (signed long int)7200;
      }

      if(yp->process == do_yp_touch)
      {
        if(!(yp->touch_interval >= 1200u))
          yp->next_update = now + (signed long int)1200;

        else
          yp->next_update = now + (signed long int)yp->touch_interval;
        log_write(errorlog, (unsigned int)3, "yp/", "send_to_yp", "YP %s on %s failed: %s", cmd, server->url, yp->error_msg);
      }

      yp->process = do_yp_add;
      free((void *)yp->sid);
      yp->sid = (char *)(void *)0;
      return -1;
    }

    else
    {
      log_write(errorlog, (unsigned int)4, "yp/", "send_to_yp", "YP %s at %s succeeded", cmd, server->url);
      return 0;
    }
}

// shutdown_subsystems
// file main.c line 127
void shutdown_subsystems(void)
{
  fserve_shutdown();
  refbuf_shutdown();
  slave_shutdown();
  auth_shutdown();
  yp_shutdown();
  stats_shutdown();
  global_shutdown();
  connection_shutdown();
  config_shutdown();
  resolver_shutdown();
  sock_shutdown();
  thread_shutdown();
  curl_global_cleanup();
  _stop_logging();
  log_shutdown();
  xslt_shutdown();
}

// sighandler_initialize
// file sighandler.h line 16
void sighandler_initialize(void)
{
  signal(1, _sig_hup);
  signal(2, _sig_die);
  signal(15, _sig_die);
  signal(13, (void (*)(signed int))1);
  signal(17, _sig_ignore);
}

// skeleton_codec_free
// file format_skeleton.c line 36
static void skeleton_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  log_write(errorlog, (unsigned int)4, "format-skeleton/", "skeleton_codec_free", "freeing skeleton codec");
  ogg_stream_clear(&codec->os);
  free((void *)codec);
}

// slave_initialize
// file slave.h line 37
void slave_initialize(void)
{
  if(slave_running == 0)
  {
    slave_running = 1;
    max_interval = (volatile unsigned int)0;
    thread_mutex_create_c(&_slave_mutex, 140, "slave.c");
    _slave_thread_id=thread_create_c("Slave Thread", _slave_thread, (void *)0, 0, 141, "slave.c");
  }

}

// slave_rebuild_mounts
// file slave.h line 40
void slave_rebuild_mounts(void)
{
  thread_mutex_lock_c(&_slave_mutex, 127, "slave.c");
  update_settings = 1;
  thread_mutex_unlock_c(&_slave_mutex, 129, "slave.c");
}

// slave_shutdown
// file slave.h line 38
void slave_shutdown(void)
{
  if(!(slave_running == 0))
  {
    slave_running = 0;
    log_write(errorlog, (unsigned int)4, "slave/", "slave_shutdown", "waiting for slave thread");
    thread_join(_slave_thread_id);
  }

}

// slave_update_all_mounts
// file slave.c line 112
void slave_update_all_mounts(void)
{
  thread_mutex_lock_c(&_slave_mutex, 114, "slave.c");
  max_interval = (volatile unsigned int)0;
  update_all_mounts = 1;
  update_settings = 1;
  thread_mutex_unlock_c(&_slave_mutex, 118, "slave.c");
}

// sock_accept
// file net/sock.h line 140
signed int sock_accept(signed int serversock, char *ip, unsigned long int len)
{
  struct sockaddr_storage sa;
  signed int ret;
  unsigned int slen;
  _Bool tmp_if_expr_2;
  signed int return_value_sock_valid_socket_1;
  if(ip == ((char *)NULL) || len == 0ul)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_sock_valid_socket_1=sock_valid_socket(serversock);
    tmp_if_expr_2 = !(return_value_sock_valid_socket_1 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return (signed int)-1;

  else
  {
    slen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
    ret=accept(serversock, (struct sockaddr *)&sa, &slen);
    if(!(ret == -1))
    {
      signed int return_value_getnameinfo_3;
      return_value_getnameinfo_3=getnameinfo((struct sockaddr *)&sa, slen, ip, (unsigned int)len, (char *)(void *)0, (unsigned int)0, 1);
      if(!(return_value_getnameinfo_3 == 0))
        snprintf(ip, len, "unknown");

      sock_set_nolinger(ret);
      sock_set_keepalive(ret);
    }

    return ret;
  }
}

// sock_active
// file net/sock.h line 110
signed int sock_active(signed int sock)
{
  char c;
  signed int l;
  signed long int return_value_recv_1;
  return_value_recv_1=recv(sock, (void *)&c, (unsigned long int)1, 2);
  l = (signed int)return_value_recv_1;
  signed int return_value_sock_error_2;
  signed int return_value_sock_recoverable_3;
  if(l == 0)
    return 0;

  else
    if(l == -1)
    {
      return_value_sock_error_2=sock_error();
      return_value_sock_recoverable_3=sock_recoverable(return_value_sock_error_2);
      if(return_value_sock_recoverable_3 == 0)
        goto __CPROVER_DUMP_L2;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return 0;
    }
}

// sock_close
// file net/sock.h line 117
signed int sock_close(signed int sock)
{
  signed int return_value_close_1;
  return_value_close_1=close(sock);
  return return_value_close_1;
}

// sock_connect_non_blocking
// file sock.c line 591
signed int sock_connect_non_blocking(const char *hostname, unsigned int port)
{
  signed int sock = (signed int)-1;
  struct addrinfo *ai;
  struct addrinfo *head;
  struct addrinfo hints;
  char service[8l];
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  snprintf(service, sizeof(char [8l]) /*8ul*/ , "%u", port);
  signed int return_value_getaddrinfo_1;
  return_value_getaddrinfo_1=getaddrinfo(hostname, service, &hints, &head);
  _Bool tmp_if_expr_5;
  signed int return_value_sock_error_3;
  signed int return_value_sock_connect_pending_4;
  if(!(return_value_getaddrinfo_1 == 0))
    return (signed int)-1;

  else
  {
    ai = head;
    for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
    {
      sock=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
      if(sock >= 0)
      {
        sock_set_blocking(sock, 0);
        signed int return_value_connect_2;
        return_value_connect_2=connect(sock, ai->ai_addr, ai->ai_addrlen);
        if(!(return_value_connect_2 >= 0))
        {
          return_value_sock_error_3=sock_error();
          return_value_sock_connect_pending_4=sock_connect_pending(return_value_sock_error_3);
          tmp_if_expr_5 = !(return_value_sock_connect_pending_4 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
        {
          sock_close(sock);
          sock = (signed int)-1;
        }

        else
          break;
      }

    }
    if(!(head == ((struct addrinfo *)NULL)))
      freeaddrinfo(head);

    return sock;
  }
}

// sock_connect_pending
// file sock.c line 188
static signed int sock_connect_pending(signed int error)
{
  return (signed int)(error == 115 || error == 114);
}

// sock_connect_wto
// file net/sock.h line 120
signed int sock_connect_wto(const char *hostname, signed int port, signed int timeout)
{
  signed int return_value_sock_connect_wto_bind_1;
  return_value_sock_connect_wto_bind_1=sock_connect_wto_bind(hostname, port, (const char *)(void *)0, timeout);
  return return_value_sock_connect_wto_bind_1;
}

// sock_connect_wto_bind
// file net/sock.h line 121
signed int sock_connect_wto_bind(const char *hostname, signed int port, const char *bnd, signed int timeout)
{
  signed int sock = (signed int)-1;
  struct addrinfo *ai;
  struct addrinfo *head;
  struct addrinfo *b_head = (struct addrinfo *)(void *)0;
  struct addrinfo hints;
  char service[8l];
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  snprintf(service, sizeof(char [8l]) /*8ul*/ , "%u", port);
  signed int return_value_getaddrinfo_1;
  return_value_getaddrinfo_1=getaddrinfo(hostname, service, &hints, &head);
  _Bool tmp_if_expr_4;
  signed int return_value_bind_3;
  if(!(return_value_getaddrinfo_1 == 0))
    return (signed int)-1;

  else
  {
    ai = head;
    for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
    {
      sock=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
      if(sock >= 0)
      {
        if(timeout >= 1)
          sock_set_blocking(sock, 0);

        if(!(bnd == ((const char *)NULL)))
        {
          struct addrinfo b_hints;
          memset((void *)&b_hints, 0, sizeof(struct addrinfo) /*48ul*/ );
          b_hints.ai_family = ai->ai_family;
          b_hints.ai_socktype = ai->ai_socktype;
          b_hints.ai_protocol = ai->ai_protocol;
          signed int return_value_getaddrinfo_2;
          return_value_getaddrinfo_2=getaddrinfo(bnd, (const char *)(void *)0, &b_hints, &b_head);
          if(!(return_value_getaddrinfo_2 == 0))
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            return_value_bind_3=bind(sock, b_head->ai_addr, b_head->ai_addrlen);
            tmp_if_expr_4 = return_value_bind_3 < 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
          {
            sock_close(sock);
            sock = (signed int)-1;
            break;
          }

        }

        signed int return_value_connect_5;
        return_value_connect_5=connect(sock, ai->ai_addr, ai->ai_addrlen);
        if(return_value_connect_5 == 0)
          break;

        while(!(sock == -1))
        {
          signed int return_value_sock_error_6;
          return_value_sock_error_6=sock_error();
          signed int return_value_sock_recoverable_7;
          return_value_sock_recoverable_7=sock_recoverable(return_value_sock_error_6);
          if(!(return_value_sock_recoverable_7 == 0))
          {
            signed int connected;
            connected=sock_connected(sock, timeout);
            if(connected == 0)
              continue;

            if(connected == 1)
            {
              if(timeout >= 0)
                sock_set_blocking(sock, 1);

              break;
            }

          }

          sock_close(sock);
          sock = (signed int)-1;
        }
        if(!(sock == -1))
          break;

      }

    }
    if(!(b_head == ((struct addrinfo *)NULL)))
      freeaddrinfo(b_head);

    freeaddrinfo(head);
    return sock;
  }
}

// sock_connected
// file sock.c line 516
signed int sock_connected(signed int sock, signed int timeout)
{
  struct pollfd check;
  signed int val = (signed int)-1;
  unsigned int size = (unsigned int)sizeof(signed int) /*4ul*/ ;
  check.fd = sock;
  check.events = (signed short int)0x004;
  signed int return_value_poll_1;
  return_value_poll_1=poll(&check, (unsigned long int)1, timeout * 1000);
  if(!(return_value_poll_1 == 0))
  {
    if(return_value_poll_1 == -1)
      goto __CPROVER_DUMP_L4;

  }

  else
    return -2;
  signed int return_value_getsockopt_2;
  return_value_getsockopt_2=getsockopt(sock, 1, 4, (void *)&val, &size);
  if(return_value_getsockopt_2 == 0)
  {
    if(val == 0)
      return 1;

    sock_set_error(val);
  }


__CPROVER_DUMP_L4:
  ;
  signed int return_value_sock_error_3;
  return_value_sock_error_3=sock_error();
  signed int return_value_sock_recoverable_4;
  return_value_sock_recoverable_4=sock_recoverable(return_value_sock_error_3);
  if(!(return_value_sock_recoverable_4 == 0))
    return 0;

  else
    return (signed int)-1;
}

// sock_error
// file net/sock.h line 106
signed int sock_error(void)
{
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  return *return_value___errno_location_1;
}

// sock_get_localip
// file sock.c line 108
char * sock_get_localip(char *buff, signed int len)
{
  char temp[1024l];
  signed int return_value_gethostname_1;
  return_value_gethostname_1=gethostname(temp, sizeof(char [1024l]) /*1024ul*/ );
  if(!(return_value_gethostname_1 == 0))
    return (char *)(void *)0;

  else
  {
    char *return_value_resolver_getip_2;
    return_value_resolver_getip_2=resolver_getip(temp, buff, len);
    if(!(return_value_resolver_getip_2 == ((char *)NULL)))
      return buff;

    else
      return (char *)(void *)0;
  }
}

// sock_get_server_socket
// file net/sock.h line 138
signed int sock_get_server_socket(signed int port, const char *sinterface)
{
  struct sockaddr_storage sa;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ai;
  char service[10l];
  signed int sock;
  if(!(port >= 0))
    return (signed int)-1;

  else
  {
    memset((void *)&sa, 0, sizeof(struct sockaddr_storage) /*128ul*/ );
    memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_flags = 0x0001 | 0x0020 | 0x0400 | 0x0004;
    hints.ai_socktype = 1;
    snprintf(service, sizeof(char [10l]) /*10ul*/ , "%d", port);
    signed int return_value_getaddrinfo_1;
    return_value_getaddrinfo_1=getaddrinfo(sinterface, service, &hints, &res);
    if(!(return_value_getaddrinfo_1 == 0))
      return (signed int)-1;

    else
    {
      ai = res;
      do
      {
        signed int on = 1;
        sock=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if(sock >= 0)
        {
          setsockopt(sock, 1, 2, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
          on = 0;
          setsockopt(sock, 41, 26, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
          signed int return_value_bind_2;
          return_value_bind_2=bind(sock, ai->ai_addr, ai->ai_addrlen);
          if(!(return_value_bind_2 >= 0))
            sock_close(sock);

          else
          {
            freeaddrinfo(res);
            return sock;
          }
        }

        ai = ai->ai_next;
      }
      while(!(ai == ((struct addrinfo *)NULL)));
      freeaddrinfo(res);
      return (signed int)-1;
    }
  }
}

// sock_initialize
// file net/sock.h line 103
void sock_initialize(void)
{
  resolver_initialize();
}

// sock_listen
// file net/sock.h line 139
signed int sock_listen(signed int serversock, signed int backlog)
{
  signed int return_value_sock_valid_socket_1;
  return_value_sock_valid_socket_1=sock_valid_socket(serversock);
  if(return_value_sock_valid_socket_1 == 0)
    return 0;

  else
  {
    if(!(backlog >= 1))
      backlog = 10;

    signed int return_value_listen_2;
    return_value_listen_2=listen(serversock, backlog);
    return (signed int)(return_value_listen_2 == 0);
  }
}

// sock_read_bytes
// file net/sock.h line 134
signed int sock_read_bytes(signed int sock, char *buff, unsigned long int len)
{
  if(buff == ((char *)NULL))
    return 0;

  else
    if(!(len >= 1ul))
      return 0;

    else
    {
      signed long int return_value_recv_1;
      return_value_recv_1=recv(sock, (void *)buff, len, 0);
      return (signed int)return_value_recv_1;
    }
}

// sock_read_line
// file net/sock.h line 135
signed int sock_read_line(signed int sock, char *buff, const signed int len)
{
  char c = (char)0;
  signed int read_bytes;
  signed int pos;
  if(buff == ((char *)NULL))
    return 0;

  else
    if(!(len >= 1))
      return 0;

  pos = 0;
  signed long int return_value_recv_1;
  return_value_recv_1=recv(sock, (void *)&c, (unsigned long int)1, 0);
  read_bytes = (signed int)return_value_recv_1;
  signed int tmp_post_2;
  if(!(read_bytes >= 0))
    return 0;

  else
  {
    while(read_bytes == 1 && !((signed int)c == 10) && !(pos >= len))
    {
      if(!((signed int)c == 13))
      {
        tmp_post_2 = pos;
        pos = pos + 1;
        buff[(signed long int)tmp_post_2] = c;
      }

      signed long int return_value_recv_3;
      return_value_recv_3=recv(sock, (void *)&c, (unsigned long int)1, 0);
      read_bytes = (signed int)return_value_recv_3;
    }
    if(read_bytes == 1)
    {
      buff[(signed long int)pos] = (char)0;
      return 1;
    }

    else
      return 0;
  }
}

// sock_recoverable
// file net/sock.h line 107
signed int sock_recoverable(signed int error)
{
  if(error == 0 || error == 4 || error == 11 || error == 85 || error == 115)
    return 1;

  return 0;
}

// sock_set_blocking
// file net/sock.h line 111
signed int sock_set_blocking(signed int sock, signed int block)
{
  signed int return_value_sock_valid_socket_1;
  return_value_sock_valid_socket_1=sock_valid_socket(sock);
  if(return_value_sock_valid_socket_1 == 0 || block >= 2 || !(block >= 0))
    return (signed int)-1;

  else
  {
    signed int return_value_fcntl_2;
    return_value_fcntl_2=fcntl(sock, 4, block != 0 ? 0 : 04000);
    return return_value_fcntl_2;
  }
}

// sock_set_error
// file sock.c line 134
void sock_set_error(signed int val)
{
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = val;
}

// sock_set_keepalive
// file sock.c line 286
signed int sock_set_keepalive(signed int sock)
{
  signed int keepalive = 1;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sock, 1, 9, (void *)&keepalive, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// sock_set_nodelay
// file net/sock.h line 114
signed int sock_set_nodelay(signed int sock)
{
  signed int nodelay = 1;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sock, 6, 1, (void *)&nodelay, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// sock_set_nolinger
// file sock.c line 271
signed int sock_set_nolinger(signed int sock)
{
  struct linger lin = { .l_onoff=0, .l_linger=0 };
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sock, 1, 13, (void *)&lin, (unsigned int)sizeof(struct linger) /*8ul*/ );
  return return_value_setsockopt_1;
}

// sock_set_send_buffer
// file net/sock.h line 115
void sock_set_send_buffer(signed int sock, signed int win_size)
{
  setsockopt(sock, 1, 7, (const void *)(char *)&win_size, (unsigned int)sizeof(signed int) /*4ul*/ );
}

// sock_shutdown
// file net/sock.h line 104
void sock_shutdown(void)
{
  resolver_shutdown();
}

// sock_stalled
// file sock.c line 168
signed int sock_stalled(signed int error)
{
  if(error == 11 || error == 85 || error == 114 || error == 115)
    return 1;

  return 0;
}

// sock_valid_socket
// file sock.c line 197
signed int sock_valid_socket(signed int sock)
{
  signed int ret;
  signed int optval;
  unsigned int optlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
  ret=getsockopt(sock, 1, 3, (void *)&optval, &optlen);
  return (signed int)(ret == 0);
}

// sock_write
// file net/sock.h line 127
signed int sock_write(signed int sock, const char *fmt, ...)
{
  signed int rc;
  void **ap = (void **)&fmt;
  rc=sock_write_fmt(sock, fmt, ap);
  ap = ((void **)NULL);
  return rc;
}

// sock_write_bytes
// file net/sock.h line 126
signed int sock_write_bytes(signed int sock, const void *buff, unsigned long int len)
{
  if(buff == NULL)
    return (signed int)-1;

  else
    if(!(len >= 1ul))
      return (signed int)-1;

  signed long int return_value_send_1;
  return_value_send_1=send(sock, buff, len, 0);
  return (signed int)return_value_send_1;
}

// sock_write_fmt
// file sock.c line 421
signed int sock_write_fmt(signed int sock, const char *fmt, void **ap)
{
  char buffer[1024l];
  char *buff = buffer;
  signed int len;
  signed int rc = (signed int)-1;
  void **ap_retry = (void **)ap;
  len=vsnprintf(buff, sizeof(char [1024l]) /*1024ul*/ , fmt, ap);
  if(len >= 1)
  {
    if(!((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ ))
      rc=sock_write_bytes(sock, (const void *)buff, (unsigned long int)len);

    else
    {
      len = len + 1;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)len);
      buff = (char *)return_value_malloc_1;
      if(!(buff == ((char *)NULL)))
      {
        len=vsnprintf(buff, (unsigned long int)len, fmt, ap_retry);
        if(len >= 1)
          rc=sock_write_bytes(sock, (const void *)buff, (unsigned long int)len);

        free((void *)buff);
      }

    }
  }

  ap_retry = ((void **)NULL);
  return rc;
}

// sock_write_string
// file sock.c line 369
signed int sock_write_string(signed int sock, const char *buff)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buff);
  signed int return_value_sock_write_bytes_2;
  return_value_sock_write_bytes_2=sock_write_bytes(sock, (const void *)buff, return_value_strlen_1);
  return (signed int)(return_value_sock_write_bytes_2 > 0);
}

// sock_writev
// file sock.c line 312
signed long int sock_writev(signed int sock, struct iovec *iov, unsigned long int count)
{
  signed long int return_value_writev_1;
  return_value_writev_1=writev(sock, iov, (signed int)count);
  return return_value_writev_1;
}

// source_apply_mount
// file source.c line 991
static void source_apply_mount(struct source_tag *source, struct _mount_proxy *mountinfo)
{
  const char *str;
  signed int val;
  struct http_parser_tag *parser = (struct http_parser_tag *)(void *)0;
  log_write(errorlog, (unsigned int)4, "source/", "source_apply_mount", "Applying mount information for \"%s\"", source->mount);
  avl_tree_rlock(source->client_tree);
  stats_event_args(source->mount, "listener_peak", "%lu", source->peak_listeners);
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    source->max_listeners = (signed long int)mountinfo->max_listeners;
    source->fallback_override = mountinfo->fallback_override;
    source->hidden = mountinfo->hidden;
  }

  if(!(source->client == ((struct _client_tag *)NULL)))
    parser = source->client->parser;

  if(!(source->format == ((struct _format_plugin_tag *)NULL)))
  {
    if(!(source->format->apply_settings == ((void (*)(struct _client_tag *, struct _format_plugin_tag *, struct _mount_proxy *))NULL)))
      source->format->apply_settings(source->client, source->format, mountinfo);

  }

  _Bool tmp_if_expr_1;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_1 = mountinfo->yp_public >= 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    val = mountinfo->yp_public;

  else
  {
    do
    {
      str=httpp_getvar(parser, "ice-public");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "icy-pub");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "x-audiocast-public");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "icy-public");
      if(!(str == ((const char *)NULL)))
        break;

      str = "0";
    }
    while((_Bool)0);
    val=atoi(str);
  }
  stats_event_args(source->mount, "public", "%d", val);
  if(!(source->yp_public == val))
  {
    log_write(errorlog, (unsigned int)4, "source/", "source_apply_mount", "YP changed to %d", val);
    if(!(val == 0))
      yp_add(source->mount);

    else
      yp_remove(source->mount);
    source->yp_public = val;
  }

  _Bool tmp_if_expr_2;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_2 = mountinfo->stream_name != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    stats_event(source->mount, "server_name", mountinfo->stream_name);

  else
  {
    do
    {
      str=httpp_getvar(parser, "ice-name");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "icy-name");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "x-audiocast-name");
      if(!(str == ((const char *)NULL)))
        break;

      str = "Unspecified name";
    }
    while((_Bool)0);
    if(!(source->format == ((struct _format_plugin_tag *)NULL)))
      stats_event_conv(source->mount, "server_name", str, source->format->charset);

  }
  _Bool tmp_if_expr_3;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_3 = mountinfo->stream_description != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
    stats_event(source->mount, "server_description", mountinfo->stream_description);

  else
  {
    do
    {
      str=httpp_getvar(parser, "ice-description");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "icy-description");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "x-audiocast-description");
      if(!(str == ((const char *)NULL)))
        break;

      str = "Unspecified description";
    }
    while((_Bool)0);
    if(!(source->format == ((struct _format_plugin_tag *)NULL)))
      stats_event_conv(source->mount, "server_description", str, source->format->charset);

  }
  _Bool tmp_if_expr_4;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_4 = mountinfo->stream_url != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  if(tmp_if_expr_4)
    stats_event(source->mount, "server_url", mountinfo->stream_url);

  else
  {
    do
    {
      str=httpp_getvar(parser, "ice-url");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "icy-url");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "x-audiocast-url");
      if(!(str == ((const char *)NULL)))
        break;

    }
    while((_Bool)0);
    if(!(str == ((const char *)NULL)))
    {
      if(!(source->format == ((struct _format_plugin_tag *)NULL)))
        stats_event_conv(source->mount, "server_url", str, source->format->charset);

    }

  }
  _Bool tmp_if_expr_5;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_5 = mountinfo->stream_genre != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  if(tmp_if_expr_5)
    stats_event(source->mount, "genre", mountinfo->stream_genre);

  else
  {
    do
    {
      str=httpp_getvar(parser, "ice-genre");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "icy-genre");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "x-audiocast-genre");
      if(!(str == ((const char *)NULL)))
        break;

      str = "various";
    }
    while((_Bool)0);
    if(!(source->format == ((struct _format_plugin_tag *)NULL)))
      stats_event_conv(source->mount, "genre", str, source->format->charset);

  }
  _Bool tmp_if_expr_6;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_6 = mountinfo->bitrate != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_6 = (_Bool)0;
  if(tmp_if_expr_6)
    str = mountinfo->bitrate;

  else
    do
    {
      str=httpp_getvar(parser, "ice-bitrate");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "icy-br");
      if(!(str == ((const char *)NULL)))
        break;

      str=httpp_getvar(parser, "x-audiocast-bitrate");
    }
    while((_Bool)0);
  stats_event(source->mount, "bitrate", str);
  _Bool tmp_if_expr_7;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_7 = mountinfo->type != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  if(tmp_if_expr_7)
    stats_event(source->mount, "server_type", mountinfo->type);

  else
    if(!(source->format == ((struct _format_plugin_tag *)NULL)))
      stats_event(source->mount, "server_type", source->format->contenttype);

  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->subtype == ((char *)NULL)))
      stats_event(source->mount, "subtype", mountinfo->subtype);

  }

  _Bool tmp_if_expr_8;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_8 = mountinfo->auth != ((struct auth_tag *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_8 = (_Bool)0;
  if(tmp_if_expr_8)
    stats_event(source->mount, "authenticator", mountinfo->auth->type);

  else
    stats_event(source->mount, "authenticator", (const char *)(void *)0);
  _Bool tmp_if_expr_9;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_9 = mountinfo->fallback_mount != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_9 = (_Bool)0;
  if(tmp_if_expr_9)
  {
    char *mount = source->fallback_mount;
    source->fallback_mount=strdup(mountinfo->fallback_mount);
    free((void *)mount);
  }

  else
    source->fallback_mount = (char *)(void *)0;
  _Bool tmp_if_expr_10;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    tmp_if_expr_10 = mountinfo->dumpfile != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_10 = (_Bool)0;
  if(tmp_if_expr_10)
  {
    char *filename = source->dumpfilename;
    source->dumpfilename=strdup(mountinfo->dumpfile);
    free((void *)filename);
  }

  else
    source->dumpfilename = (char *)(void *)0;
  if(!(source->intro_file == ((struct _IO_FILE *)NULL)))
  {
    fclose(source->intro_file);
    source->intro_file = (struct _IO_FILE *)(void *)0;
  }

  signed int *return_value___errno_location_14;
  char *return_value_strerror_15;
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->intro_filename == ((char *)NULL)))
    {
      struct ice_config_tag *config;
      config=config_get_config_unlocked();
      unsigned int len;
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(config->webroot_dir);
      unsigned long int return_value_strlen_12;
      return_value_strlen_12=strlen(mountinfo->intro_filename);
      len = (unsigned int)(return_value_strlen_11 + return_value_strlen_12 + (unsigned long int)2);
      char *path;
      void *return_value_malloc_13;
      return_value_malloc_13=malloc((unsigned long int)len);
      path = (char *)return_value_malloc_13;
      if(!(path == ((char *)NULL)))
      {
        struct _IO_FILE *f;
        snprintf(path, (unsigned long int)len, "%s/%s", config->webroot_dir, mountinfo->intro_filename);
        f=fopen(path, "rb");
        if(!(f == ((struct _IO_FILE *)NULL)))
          source->intro_file = f;

        else
        {
          return_value___errno_location_14=__errno_location();
          return_value_strerror_15=strerror(*return_value___errno_location_14);
          log_write(errorlog, (unsigned int)2, "source/", "source_apply_mount", "Cannot open intro file \"%s\": %s", path, return_value_strerror_15);
        }
        free((void *)path);
      }

    }

  }

  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->queue_size_limit == 0u))
      source->queue_size_limit = mountinfo->queue_size_limit;

  }

  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->source_timeout == 0u))
      source->timeout = mountinfo->source_timeout;

  }

  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(mountinfo->burst_size >= 0)
      source->burst_size = (unsigned int)mountinfo->burst_size;

  }

  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->fallback_when_full == 0))
      source->fallback_when_full = mountinfo->fallback_when_full;

  }

  avl_tree_unlock(source->client_tree);
}

// source_clear_source
// file source.h line 88
void source_clear_source(struct source_tag *source)
{
  signed int c;
  log_write(errorlog, (unsigned int)4, "source/", "source_clear_source", "clearing source \"%s\"", source->mount);
  avl_tree_wlock(source->pending_tree);
  client_destroy(source->client);
  source->client = (struct _client_tag *)(void *)0;
  source->parser = (struct http_parser_tag *)(void *)0;
  source->con = (struct connection_tag *)(void *)0;
  if(!(source->client == ((struct _client_tag *)NULL)))
  {
    if(!(source->format == ((struct _format_plugin_tag *)NULL)))
      source->client->con->sent_bytes = source->format->read_bytes;

  }

  if(!(source->dumpfile == ((struct _IO_FILE *)NULL)))
  {
    log_write(errorlog, (unsigned int)3, "source/", "source_clear_source", "Closing dumpfile for %s", source->mount);
    fclose(source->dumpfile);
    source->dumpfile = (struct _IO_FILE *)(void *)0;
  }

  avl_tree_wlock(source->client_tree);
  c = 0;
  while((_Bool)1)
  {
    struct avl_node_tag *node;
    node=avl_get_first(source->client_tree);
    if(!(node == ((struct avl_node_tag *)NULL)))
    {
      struct _client_tag *client = (struct _client_tag *)node->key;
      if(client->respcode == 200)
        c = c + 1;

      avl_delete(source->client_tree, (void *)client, _free_client);
      continue;
    }

    break;
  }
  if(!(c == 0))
  {
    stats_event_sub((const char *)(void *)0, "listeners", source->listeners);
    log_write(errorlog, (unsigned int)3, "source/", "source_clear_source", "%d active listeners on %s released", c, source->mount);
  }

  avl_tree_unlock(source->client_tree);
  struct avl_node_tag *return_value_avl_get_first_1;
  do
  {
    return_value_avl_get_first_1=avl_get_first(source->pending_tree);
    if(return_value_avl_get_first_1 == ((struct avl_node_tag *)NULL))
      break;

    struct avl_node_tag *return_value_avl_get_first_2;
    return_value_avl_get_first_2=avl_get_first(source->pending_tree);
    avl_delete(source->pending_tree, return_value_avl_get_first_2->key, _free_client);
  }
  while((_Bool)1);
  if(!(source->format == ((struct _format_plugin_tag *)NULL)))
  {
    if(!(source->format->free_plugin == ((void (*)(struct _format_plugin_tag *))NULL)))
      source->format->free_plugin(source->format);

  }

  source->format = (struct _format_plugin_tag *)(void *)0;
  while(!(source->stream_data == ((struct _refbuf_tag *)NULL)))
  {
    struct _refbuf_tag *p = source->stream_data;
    source->stream_data = p->next;
    p->next = (struct _refbuf_tag *)(void *)0;
    while(p->_count >= 2u)
      refbuf_release(p);
    refbuf_release(p);
  }
  source->stream_data_tail = (struct _refbuf_tag *)(void *)0;
  source->burst_point = (struct _refbuf_tag *)(void *)0;
  source->burst_size = (unsigned int)0;
  source->burst_offset = (unsigned int)0;
  source->queue_size = (unsigned int)0;
  source->queue_size_limit = (unsigned int)0;
  source->listeners = (unsigned long int)0;
  source->max_listeners = (signed long int)-1;
  source->prev_listeners = (unsigned long int)0;
  source->hidden = 0;
  source->shoutcast_compat = 0;
  source->client_stats_update = (signed long int)0;
  util_dict_free(source->audio_info);
  source->audio_info = (struct _util_dict *)(void *)0;
  free((void *)source->fallback_mount);
  source->fallback_mount = (char *)(void *)0;
  free((void *)source->dumpfilename);
  source->dumpfilename = (char *)(void *)0;
  if(!(source->intro_file == ((struct _IO_FILE *)NULL)))
  {
    fclose(source->intro_file);
    source->intro_file = (struct _IO_FILE *)(void *)0;
  }

  source->on_demand_req = 0;
  avl_tree_unlock(source->pending_tree);
}

// source_client_callback
// file source.h line 86
void source_client_callback(struct _client_tag *client, void *arg)
{
  const char *agent;
  struct source_tag *source = (struct source_tag *)arg;
  struct _refbuf_tag *old_data = client->refbuf;
  if(!(client->con->error == 0))
  {
    global_lock();
    global.sources = global.sources - 1;
    global_unlock();
    source_clear_source(source);
    source_free_source(source);
  }

  else
  {
    client->refbuf = old_data->associated;
    old_data->associated = (struct _refbuf_tag *)(void *)0;
    refbuf_release(old_data);
    stats_event(source->mount, "source_ip", source->client->con->ip);
    agent=httpp_getvar(source->client->parser, "user-agent");
    if(!(agent == ((const char *)NULL)))
      stats_event(source->mount, "user_agent", agent);

    thread_create_c("Source Thread", source_client_thread, (void *)source, 1, 1318, "source.c");
  }
}

// source_client_thread
// file source.c line 1278
void * source_client_thread(void *arg)
{
  struct source_tag *source = (struct source_tag *)arg;
  stats_event_inc((const char *)(void *)0, "source_client_connections");
  stats_event(source->mount, "listeners", "0");
  source_main(source);
  source_free_source(source);
  slave_update_all_mounts();
  return (void *)0;
}

// source_compare_sources
// file source.h line 92
signed int source_compare_sources(void *arg, void *a, void *b)
{
  struct source_tag *srca = (struct source_tag *)a;
  struct source_tag *srcb = (struct source_tag *)b;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(srca->mount, srcb->mount);
  return return_value_strcmp_1;
}

// source_fallback_file
// file source.c line 1389
static void * source_fallback_file(void *arg)
{
  char *mount = (char *)arg;
  char *type;
  char *path;
  unsigned int len;
  struct _IO_FILE *file = (struct _IO_FILE *)(void *)0;
  struct source_tag *source = (struct source_tag *)(void *)0;
  struct ice_config_tag *config;
  struct http_parser_tag *parser;
  _Bool tmp_if_expr_1;
  do
  {
    if(mount == ((char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)mount[(signed long int)0] != 47 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      break;

    config=config_get_config();
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(config->webroot_dir);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(mount);
    len = (unsigned int)(return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)1);
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)len);
    path = (char *)return_value_malloc_4;
    if(!(path == ((char *)NULL)))
      snprintf(path, (unsigned long int)len, "%s%s", config->webroot_dir, mount);

    config_release_config();
    if(path == ((char *)NULL))
      break;

    file=fopen(path, "rb");
    if(file == ((struct _IO_FILE *)NULL))
    {
      log_write(errorlog, (unsigned int)2, "source/", "source_fallback_file", "unable to open file \"%s\"", path);
      free((void *)path);
      break;
    }

    free((void *)path);
    source=source_reserve(mount);
    if(source == ((struct source_tag *)NULL))
    {
      log_write(errorlog, (unsigned int)2, "source/", "source_fallback_file", "mountpoint \"%s\" already reserved", mount);
      break;
    }

    log_write(errorlog, (unsigned int)3, "source/", "source_fallback_file", "mountpoint %s is reserved", mount);
    type=fserve_content_type(mount);
    parser=httpp_create_parser();
    httpp_initialize(parser, (struct http_varlist_tag *)(void *)0);
    httpp_setvar(parser, "content-type", type);
    free((void *)type);
    source->hidden = 1;
    source->yp_public = 0;
    source->intro_file = file;
    source->parser = parser;
    file = (struct _IO_FILE *)(void *)0;
    signed int return_value_connection_complete_source_5;
    return_value_connection_complete_source_5=connection_complete_source(source, 0);
    if(!(return_value_connection_complete_source_5 >= 0))
      break;

    source_client_thread((void *)source);
    httpp_destroy(parser);
  }
  while((_Bool)0);
  if(!(file == ((struct _IO_FILE *)NULL)))
    fclose(file);

  free((void *)mount);
  return (void *)0;
}

// source_find_client
// file source.c line 326
struct _client_tag * source_find_client(struct source_tag *source, signed int id)
{
  struct _client_tag fakeclient;
  void *result;
  struct connection_tag fakecon;
  fakeclient.con = &fakecon;
  fakeclient.con->id = (unsigned long int)id;
  avl_tree_rlock(source->client_tree);
  signed int return_value_avl_get_by_key_1;
  return_value_avl_get_by_key_1=avl_get_by_key(source->client_tree, (void *)&fakeclient, &result);
  if(return_value_avl_get_by_key_1 == 0)
  {
    avl_tree_unlock(source->client_tree);
    return (struct _client_tag *)result;
  }

  else
  {
    avl_tree_unlock(source->client_tree);
    return (struct _client_tag *)(void *)0;
  }
}

// source_find_mount
// file source.h line 89
struct source_tag * source_find_mount(const char *mount)
{
  struct source_tag *source = (struct source_tag *)(void *)0;
  struct ice_config_tag *config;
  struct _mount_proxy *mountinfo;
  signed int depth = 0;
  config=config_get_config();
  _Bool tmp_if_expr_1;
  for( ; !(mount == ((const char *)NULL)) && !(depth >= 10); depth = depth + 1)
  {
    source=source_find_mount_raw(mount);
    if(!(source == ((struct source_tag *)NULL)))
    {
      if(!(source->running == 0))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = source->on_demand != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        break;

    }

    mountinfo=config_find_mount(config, mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
    source = (struct source_tag *)(void *)0;
    if(mountinfo == ((struct _mount_proxy *)NULL))
      break;

    mount = mountinfo->fallback_mount;
  }
  config_release_config();
  return source;
}

// source_find_mount_raw
// file source.c line 129
struct source_tag * source_find_mount_raw(const char *mount)
{
  struct source_tag *source;
  struct avl_node_tag *node;
  signed int cmp;
  if(mount == ((const char *)NULL))
    return (struct source_tag *)(void *)0;

  else
  {
    node = global.source_tree->root->right;
    while(!(node == ((struct avl_node_tag *)NULL)))
    {
      source = (struct source_tag *)node->key;
      cmp=strcmp(mount, source->mount);
      if(!(cmp >= 0))
        node = node->left;

      else
        if(cmp >= 1)
          node = node->right;

        else
          return source;
    }
    return (struct source_tag *)(void *)0;
  }
}

// source_free_source
// file source.h line 93
void source_free_source(struct source_tag *source)
{
  log_write(errorlog, (unsigned int)4, "source/", "source_free_source", "freeing source \"%s\"", source->mount);
  avl_tree_wlock(global.source_tree);
  avl_delete(global.source_tree, (void *)source, (signed int (*)(void *))(void *)0);
  avl_tree_unlock(global.source_tree);
  avl_tree_free(source->pending_tree, _free_client);
  avl_tree_free(source->client_tree, _free_client);
  yp_remove(source->mount);
  free((void *)source->mount);
  free((void *)source);
}

// source_init
// file source.c line 618
static void source_init(struct source_tag *source)
{
  struct ice_config_tag *config;
  config=config_get_config();
  char *listenurl;
  const char *str;
  signed int listen_url_size;
  struct _mount_proxy *mountinfo;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen("http://");
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(config->hostname);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(":");
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(source->mount);
  listen_url_size = (signed int)(return_value_strlen_1 + return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)6 + return_value_strlen_4 + (unsigned long int)1);
  void *return_value_malloc_5;
  return_value_malloc_5=malloc((unsigned long int)listen_url_size);
  listenurl = (char *)return_value_malloc_5;
  memset((void *)listenurl, 0, (unsigned long int)listen_url_size);
  snprintf(listenurl, (unsigned long int)listen_url_size, "http://%s:%d%s", config->hostname, config->port, source->mount);
  config_release_config();
  str=httpp_getvar(source->parser, "ice-audio-info");
  source->audio_info=util_dict_new();
  if(!(str == ((const char *)NULL)))
  {
    _parse_audio_info(source, str);
    stats_event(source->mount, "audio_info", str);
  }

  stats_event(source->mount, "listenurl", listenurl);
  free((void *)listenurl);
  if(!(source->dumpfilename == ((char *)NULL)))
  {
    source->dumpfile=source_open_dumpfile(source->dumpfilename);
    if(source->dumpfile == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      log_write(errorlog, (unsigned int)2, "source/", "source_init", "Cannot open dump file \"%s\" for appending: %s, disabling.", source->dumpfilename, return_value_strerror_7);
    }

  }

  thread_rwlock_rlock_c(source->shutdown_rwlock, 659, "source.c");
  source->listeners = (unsigned long int)0;
  stats_event_inc((const char *)(void *)0, "source_total_connections");
  stats_event(source->mount, "slow_listeners", "0");
  stats_event_args(source->mount, "listeners", "%lu", source->listeners);
  stats_event_args(source->mount, "listener_peak", "%lu", source->peak_listeners);
  stats_event_time(source->mount, "stream_start");
  stats_event_time_iso8601(source->mount, "stream_start_iso8601");
  log_write(errorlog, (unsigned int)4, "source/", "source_init", "Source creation complete");
  source->last_read=time((signed long int *)(void *)0);
  source->prev_listeners = (unsigned long int)-1;
  source->running = 1;
  struct ice_config_tag *return_value_config_get_config_8;
  return_value_config_get_config_8=config_get_config();
  mountinfo=config_find_mount(return_value_config_get_config_8, source->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->on_connect == ((char *)NULL)))
      source_run_script(mountinfo->on_connect, source->mount);

    auth_stream_start(mountinfo, source->mount);
  }

  config_release_config();
  if(!(source->fallback_override == 0))
  {
    if(!(source->fallback_mount == ((char *)NULL)))
    {
      struct source_tag *fallback_source;
      avl_tree_rlock(global.source_tree);
      fallback_source=source_find_mount(source->fallback_mount);
      if(!(fallback_source == ((struct source_tag *)NULL)))
        source_move_clients(fallback_source, source);

      avl_tree_unlock(global.source_tree);
    }

  }

}

// source_main
// file source.h line 96
void source_main(struct source_tag *source)
{
  struct _refbuf_tag *refbuf;
  struct _client_tag *client;
  struct avl_node_tag *client_node;
  source_init(source);
  struct avl_node_tag *return_value_avl_get_first_1;
  _Bool tmp_if_expr_3;
  while(global.running == 1)
  {
    if(source->running == 0)
      break;

    signed int remove_from_q;
    refbuf=get_next_buffer(source);
    remove_from_q = 0;
    source->short_delay = 0;
    if(!(refbuf == ((struct _refbuf_tag *)NULL)))
    {
      if(source->stream_data == ((struct _refbuf_tag *)NULL))
      {
        source->stream_data = refbuf;
        source->burst_point = refbuf;
      }

      if(!(source->stream_data_tail == ((struct _refbuf_tag *)NULL)))
        source->stream_data_tail->next = refbuf;

      source->stream_data_tail = refbuf;
      source->queue_size = source->queue_size + refbuf->len;
      refbuf_addref(refbuf);
      source->burst_offset = source->burst_offset + refbuf->len;
      while(!(source->burst_size >= source->burst_offset))
      {
        struct _refbuf_tag *to_release = source->burst_point;
        if(!(to_release->next == ((struct _refbuf_tag *)NULL)))
        {
          source->burst_point = to_release->next;
          source->burst_offset = source->burst_offset - to_release->len;
          refbuf_release(to_release);
        }

        else
          break;
      }
      if(!(source->dumpfile == ((struct _IO_FILE *)NULL)))
      {
        if(!(source->format->write_buf_to_file == ((void (*)(struct source_tag *, struct _refbuf_tag *))NULL)))
          source->format->write_buf_to_file(source, refbuf);

      }

    }

    thread_mutex_lock_c(&source->lock, 758, "source.c");
    if(!(source->queue_size_limit >= source->queue_size))
      remove_from_q = 1;

    thread_mutex_unlock_c(&source->lock, 761, "source.c");
    avl_tree_wlock(source->pending_tree);
    avl_tree_wlock(source->client_tree);
    client_node=avl_get_first(source->client_tree);
    while(!(client_node == ((struct avl_node_tag *)NULL)))
    {
      client = (struct _client_tag *)client_node->key;
      send_to_listener(source, client, remove_from_q);
      if(!(client->con->error == 0))
      {
        client_node=avl_get_next(client_node);
        if(client->respcode == 200)
          stats_event_dec((const char *)(void *)0, "listeners");

        avl_delete(source->client_tree, (void *)client, _free_client);
        source->listeners = source->listeners - 1ul;
        log_write(errorlog, (unsigned int)4, "source/", "source_main", "Client removed");
      }

      else
        client_node=avl_get_next(client_node);
    }
    client_node=avl_get_first(source->pending_tree);
    while(!(client_node == ((struct avl_node_tag *)NULL)))
      if(!(source->max_listeners == -1l))
      {
        if(!(source->listeners >= (unsigned long int)source->max_listeners))
          goto __CPROVER_DUMP_L16;

        client = (struct _client_tag *)client_node->key;
        client_node=avl_get_next(client_node);
        avl_delete(source->pending_tree, (void *)client, _free_client);
        log_write(errorlog, (unsigned int)3, "source/", "source_main", "Client deleted, exceeding maximum listeners for this mountpoint (%s).", source->mount);
      }

      else
      {

      __CPROVER_DUMP_L16:
        ;
        avl_insert(source->client_tree, client_node->key);
        source->listeners = source->listeners + 1ul;
        log_write(errorlog, (unsigned int)4, "source/", "source_main", "Client added for mountpoint (%s)", source->mount);
        stats_event_inc(source->mount, "connections");
        client_node=avl_get_next(client_node);
      }
    do
    {
      return_value_avl_get_first_1=avl_get_first(source->pending_tree);
      if(return_value_avl_get_first_1 == ((struct avl_node_tag *)NULL))
        break;

      struct avl_node_tag *return_value_avl_get_first_2;
      return_value_avl_get_first_2=avl_get_first(source->pending_tree);
      avl_delete(source->pending_tree, return_value_avl_get_first_2->key, source_remove_client);
    }
    while((_Bool)1);
    avl_tree_unlock(source->pending_tree);
    if(!(source->listeners == source->prev_listeners))
    {
      source->prev_listeners = source->listeners;
      log_write(errorlog, (unsigned int)3, "source/", "source_main", "listener count on %s now %lu", source->mount, source->listeners);
      if(!(source->peak_listeners >= source->listeners))
      {
        source->peak_listeners = source->listeners;
        stats_event_args(source->mount, "listener_peak", "%lu", source->peak_listeners);
      }

      stats_event_args(source->mount, "listeners", "%lu", source->listeners);
      if(source->listeners == 0ul)
      {
        if(!(source->on_demand == 0))
          source->running = 0;

      }

    }

    if(!(source->stream_data == ((struct _refbuf_tag *)NULL)))
      while(source->stream_data->_count == 1u)
      {
        struct _refbuf_tag *to_go = source->stream_data;
        if(to_go->next == ((struct _refbuf_tag *)NULL))
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = source->burst_point == to_go ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
        {
          log_write(errorlog, (unsigned int)1, "source/", "source_main", "queue state is unexpected");
          source->running = 0;
          break;
        }

        source->stream_data = to_go->next;
        source->queue_size = source->queue_size - to_go->len;
        to_go->next = (struct _refbuf_tag *)(void *)0;
        refbuf_release(to_go);
      }

    avl_tree_unlock(source->client_tree);
  }
  source_shutdown(source);
}

// source_move_clients
// file source.h line 94
void source_move_clients(struct source_tag *source, struct source_tag *dest)
{
  unsigned long int count = (unsigned long int)0;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(source->mount, dest->mount);
  if(return_value_strcmp_1 == 0)
    log_write(errorlog, (unsigned int)2, "source/", "source_move_clients", "src and dst are the same \"%s\", skipping", source->mount);

  else
  {
    thread_mutex_lock_c(&move_clients_mutex, 361, "source.c");
    avl_tree_wlock(dest->pending_tree);
    if(dest->running == 0)
    {
      if(!(dest->on_demand == 0))
        goto __CPROVER_DUMP_L2;

      log_write(errorlog, (unsigned int)2, "source/", "source_move_clients", "destination mount %s not running, unable to move clients ", dest->mount);
      avl_tree_unlock(dest->pending_tree);
      thread_mutex_unlock_c(&move_clients_mutex, 370, "source.c");
    }

    else
    {
      do
      {

      __CPROVER_DUMP_L2:
        ;
        struct _client_tag *client;
        avl_tree_wlock(source->pending_tree);
        avl_tree_wlock(source->client_tree);
        if(source->on_demand == 0)
        {
          if(source->format == ((struct _format_plugin_tag *)NULL))
          {
            log_write(errorlog, (unsigned int)3, "source/", "source_move_clients", "source mount %s is not available", source->mount);
            break;
          }

        }

        if(!(source->format == ((struct _format_plugin_tag *)NULL)))
        {
          if(!(dest->format == ((struct _format_plugin_tag *)NULL)))
          {
            if(!(source->format->type == dest->format->type))
            {
              log_write(errorlog, (unsigned int)2, "source/", "source_move_clients", "stream %s and %s are of different types, ignored", source->mount, dest->mount);
              break;
            }

          }

        }

        while((_Bool)1)
        {
          struct avl_node_tag *node;
          node=avl_get_first(source->pending_tree);
          if(node == ((struct avl_node_tag *)NULL))
            break;

          client = (struct _client_tag *)node->key;
          avl_delete(source->pending_tree, (void *)client, (signed int (*)(void *))(void *)0);
          if(!(client->check_buffer == format_check_http_buffer))
          {
            client_set_queue(client, (struct _refbuf_tag *)(void *)0);
            client->check_buffer = format_check_file_buffer;
            if(source->con == ((struct connection_tag *)NULL))
              client->intro_offset = (signed long int)-1;

          }

          avl_insert(dest->pending_tree, (void *)client);
          count = count + 1ul;
        }
        while((_Bool)1)
        {
          struct avl_node_tag *source_move_clients__1__3__4__node;
          source_move_clients__1__3__4__node=avl_get_first(source->client_tree);
          if(source_move_clients__1__3__4__node == ((struct avl_node_tag *)NULL))
            break;

          client = (struct _client_tag *)source_move_clients__1__3__4__node->key;
          avl_delete(source->client_tree, (void *)client, (signed int (*)(void *))(void *)0);
          if(!(client->check_buffer == format_check_http_buffer))
          {
            client_set_queue(client, (struct _refbuf_tag *)(void *)0);
            client->check_buffer = format_check_file_buffer;
            if(source->con == ((struct connection_tag *)NULL))
              client->intro_offset = (signed long int)-1;

          }

          avl_insert(dest->pending_tree, (void *)client);
          count = count + 1ul;
        }
        log_write(errorlog, (unsigned int)3, "source/", "source_move_clients", "passing %lu listeners to \"%s\"", count, dest->mount);
        source->listeners = (unsigned long int)0;
        stats_event(source->mount, "listeners", "0");
      }
      while((_Bool)0);
      avl_tree_unlock(source->pending_tree);
      avl_tree_unlock(source->client_tree);
      if(dest->running == 0)
      {
        if(!(dest->on_demand == 0))
        {
          if(!(count == 0ul))
            dest->on_demand_req = 1;

        }

      }

      avl_tree_unlock(dest->pending_tree);
      thread_mutex_unlock_c(&move_clients_mutex, 459, "source.c");
    }
  }
}

// source_open_dumpfile
// file source.c line 595
static struct _IO_FILE * source_open_dumpfile(const char *filename)
{
  char buffer[4096l];
  signed long int curtime;
  struct tm *loctime;
  curtime=time((signed long int *)(void *)0);
  loctime=localtime(&curtime);
  strftime(buffer, sizeof(char [4096l]) /*4096ul*/ , filename, loctime);
  filename = buffer;
  struct _IO_FILE *return_value_fopen_1;
  return_value_fopen_1=fopen(filename, "ab");
  return return_value_fopen_1;
}

// source_recheck_mounts
// file source.h line 97
void source_recheck_mounts(signed int update_all)
{
  struct ice_config_tag *config;
  struct _mount_proxy *mount;
  avl_tree_rlock(global.source_tree);
  config=config_get_config();
  mount = config->mounts;
  if(!(update_all == 0))
    stats_clear_virtual_mounts();

  for( ; !(mount == ((struct _mount_proxy *)NULL)); mount = mount->next)
    if((signed int)mount->mounttype == MOUNT_TYPE_NORMAL)
    {
      struct source_tag *source;
      source=source_find_mount(mount->mountname);
      if(!(source == ((struct source_tag *)NULL)))
      {
        source=source_find_mount_raw(mount->mountname);
        if(!(source == ((struct source_tag *)NULL)))
        {
          struct _mount_proxy *mountinfo;
          mountinfo=config_find_mount(config, source->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
          source_update_settings(config, source, mountinfo);
        }

        else
          if(!(update_all == 0))
          {
            stats_event_hidden(mount->mountname, (const char *)(void *)0, mount->hidden);
            stats_event_args(mount->mountname, "listenurl", "http://%s:%d%s", config->hostname, config->port, mount->mountname);
            stats_event(mount->mountname, "listeners", "0");
            if(!(mount->max_listeners >= 0))
              stats_event(mount->mountname, "max_listeners", "unlimited");

            else
              stats_event_args(mount->mountname, "max_listeners", "%d", mount->max_listeners);
          }

      }

      else
        stats_event(mount->mountname, (const char *)(void *)0, (const char *)(void *)0);
      if(global.running == 1)
      {
        if(!(mount->fallback_mount == ((char *)NULL)))
        {
          struct source_tag *fallback;
          fallback=source_find_mount(mount->fallback_mount);
          if(fallback == ((struct source_tag *)NULL))
          {
            char *return_value_strdup_1;
            return_value_strdup_1=strdup(mount->fallback_mount);
            thread_create_c("Fallback file thread", source_fallback_file, (void *)return_value_strdup_1, 1, 1505, "source.c");
          }

        }

      }

    }

  avl_tree_unlock(global.source_tree);
  config_release_config();
}

// source_remove_client
// file source.c line 939
signed int source_remove_client(void *key)
{
  return 1;
}

// source_reserve
// file source.h line 83
struct source_tag * source_reserve(const char *mount)
{
  struct source_tag *src = (struct source_tag *)(void *)0;
  if(!((signed int)*mount == 47))
    log_write(errorlog, (unsigned int)2, "source/", "source_reserve", "Source at \"%s\" does not start with '/', clients will be unable to connect", mount);

  do
  {
    avl_tree_wlock(global.source_tree);
    src=source_find_mount_raw(mount);
    if(!(src == ((struct source_tag *)NULL)))
    {
      src = (struct source_tag *)(void *)0;
      break;
    }

    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct source_tag) /*280ul*/ );
    src = (struct source_tag *)return_value_calloc_1;
    if(src == ((struct source_tag *)NULL))
      break;

    src->client_tree=avl_tree_new(_compare_clients, (void *)0);
    src->pending_tree=avl_tree_new(_compare_clients, (void *)0);
    src->mount=strdup(mount);
    src->max_listeners = (signed long int)-1;
    thread_mutex_create_c(&src->lock, 115, "source.c");
    avl_insert(global.source_tree, (void *)src);
  }
  while((_Bool)0);
  avl_tree_unlock(global.source_tree);
  return src;
}

// source_run_script
// file source.c line 1350
static void source_run_script(char *command, char *mountpoint)
{
  signed int pid;
  signed int external_pid;
  external_pid=fork();
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int return_value_access_5;
  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  if(!(external_pid == 0))
  {
    if(external_pid == -1)
      goto __CPROVER_DUMP_L7;

  }

  else
  {
    pid=fork();
    if(!(pid == -1))
    {
      if(pid == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_write(errorlog, (unsigned int)1, "source/", "source_run_script", "Unable to fork %s (%s)", command, return_value_strerror_2);
      goto __CPROVER_DUMP_L6;

    __CPROVER_DUMP_L3:
      ;
      return_value_access_5=access(command, 4 | 1);
      if(!(return_value_access_5 == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        log_write(errorlog, (unsigned int)1, "source/", "source_run_script", "Unable to run command %s (%s)", command, return_value_strerror_4);
        exit(1);
      }

      log_write(errorlog, (unsigned int)4, "source/", "source_run_script", "Starting command %s", command);
      __setup_empty_script_environment();
      execl(command, command, mountpoint, (char *)(void *)0);
      exit(1);
    }
    goto __CPROVER_DUMP_L6;

  __CPROVER_DUMP_L6:
    ;
    exit(0);

  __CPROVER_DUMP_L7:
    ;
    return_value___errno_location_6=__errno_location();
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    log_write(errorlog, (unsigned int)1, "source/", "source_run_script", "Unable to fork %s", return_value_strerror_7);
    goto __CPROVER_DUMP_L9;
  }
  waitpid(external_pid, (signed int *)(void *)0, 0);
  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L9:
  ;
}

// source_shutdown
// file source.c line 876
static void source_shutdown(struct source_tag *source)
{
  struct _mount_proxy *mountinfo;
  source->running = 0;
  log_write(errorlog, (unsigned int)3, "source/", "source_shutdown", "Source from %s at \"%s\" exiting", source->con->ip, source->mount);
  struct ice_config_tag *return_value_config_get_config_1;
  return_value_config_get_config_1=config_get_config();
  mountinfo=config_find_mount(return_value_config_get_config_1, source->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
  if(!(mountinfo == ((struct _mount_proxy *)NULL)))
  {
    if(!(mountinfo->on_disconnect == ((char *)NULL)))
      source_run_script(mountinfo->on_disconnect, source->mount);

    auth_stream_end(mountinfo, source->mount);
  }

  config_release_config();
  if(!(source->fallback_mount == ((char *)NULL)))
  {
    struct source_tag *fallback_source;
    avl_tree_rlock(global.source_tree);
    fallback_source=source_find_mount(source->fallback_mount);
    if(!(fallback_source == ((struct source_tag *)NULL)))
      source_move_clients(source, fallback_source);

    avl_tree_unlock(global.source_tree);
  }

  stats_event(source->mount, (const char *)(void *)0, (const char *)(void *)0);
  source_clear_source(source);
  global_lock();
  global.sources = global.sources - 1;
  stats_event_args((const char *)(void *)0, "sources", "%d", global.sources);
  global_unlock();
  thread_rwlock_unlock_c(source->shutdown_rwlock, 921, "source.c");
}

// source_startup
// file connection.c line 1076
void source_startup(struct _client_tag *client, const char *uri, signed int auth_style)
{
  struct source_tag *source;
  source=source_reserve(uri);
  if(!(source == ((struct source_tag *)NULL)))
  {
    source->client = client;
    source->parser = client->parser;
    source->con = client->con;
    signed int return_value_connection_complete_source_1;
    return_value_connection_complete_source_1=connection_complete_source(source, 1);
    if(!(return_value_connection_complete_source_1 >= 0))
    {
      source_clear_source(source);
      source_free_source(source);
      goto __CPROVER_DUMP_L6;
    }

    client->respcode = 200;
    if(auth_style == 1)
    {
      source->shoutcast_compat = 1;
      source_client_callback(client, (void *)source);
    }

    else
    {
      struct _refbuf_tag *ok;
      ok=refbuf_new((unsigned int)4096);
      client->respcode = 200;
      snprintf(ok->data, (unsigned long int)4096, "HTTP/1.0 200 OK\r\n\r\n");
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(ok->data);
      ok->len = (unsigned int)return_value_strlen_2;
      ok->associated = client->refbuf;
      client->refbuf = ok;
      fserve_add_client_callback(client, source_client_callback, (void *)source);
    }
  }

  else
  {
    client_send_403(client, "Mountpoint in use");
    log_write(errorlog, (unsigned int)2, "connection/", "source_startup", "Mountpoint %s in use", uri);
  }

__CPROVER_DUMP_L6:
  ;
}

// source_update_settings
// file source.h line 87
void source_update_settings(struct ice_config_tag *config, struct source_tag *source, struct _mount_proxy *mountinfo)
{
  thread_mutex_lock_c(&source->lock, 1215, "source.c");
  if(!(source->running == 0))
  {
    if(!(source->client == ((struct _client_tag *)NULL)))
      goto __CPROVER_DUMP_L1;

    stats_event_hidden(source->mount, (const char *)(void *)0, 1);
    thread_mutex_unlock_c(&source->lock, 1220, "source.c");
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    source->queue_size_limit = config->queue_size_limit;
    source->timeout = (unsigned int)config->source_timeout;
    source->burst_size = config->burst_size;
    stats_event_args(source->mount, "listenurl", "http://%s:%d%s", config->hostname, config->port, source->mount);
    source_apply_mount(source, mountinfo);
    if(!(source->fallback_mount == ((char *)NULL)))
      log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "fallback %s", source->fallback_mount);

    if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    {
      if(!(mountinfo->intro_filename == ((char *)NULL)))
        log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "intro file is %s", mountinfo->intro_filename);

    }

    if(!(source->dumpfilename == ((char *)NULL)))
      log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "Dumping stream to %s", source->dumpfilename);

    if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    {
      if(!(mountinfo->on_connect == ((char *)NULL)))
        log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "connect script \"%s\"", mountinfo->on_connect);

    }

    if(!(mountinfo == ((struct _mount_proxy *)NULL)))
    {
      if(!(mountinfo->on_disconnect == ((char *)NULL)))
        log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "disconnect script \"%s\"", mountinfo->on_disconnect);

    }

    if(!(source->on_demand == 0))
    {
      log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "on_demand set");
      stats_event(source->mount, "on_demand", "1");
      stats_event_args(source->mount, "listeners", "%ld", source->listeners);
    }

    else
      stats_event(source->mount, "on_demand", (const char *)(void *)0);
    if(!(source->hidden == 0))
    {
      stats_event_hidden(source->mount, (const char *)(void *)0, 1);
      log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "hidden from public");
    }

    else
      stats_event_hidden(source->mount, (const char *)(void *)0, 0);
    if(source->max_listeners == -1l)
      stats_event(source->mount, "max_listeners", "unlimited");

    else
    {
      char buf[10l];
      snprintf(buf, sizeof(char [10l]) /*10ul*/ , "%ld", source->max_listeners);
      stats_event(source->mount, "max_listeners", buf);
    }
    log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "public set to %d", source->yp_public);
    log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "max listeners to %ld", source->max_listeners);
    log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "queue size to %u", source->queue_size_limit);
    log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "burst size to %u", source->burst_size);
    log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "source timeout to %u", source->timeout);
    log_write(errorlog, (unsigned int)4, "source/", "source_update_settings", "fallback_when_full to %u", source->fallback_when_full);
    thread_mutex_unlock_c(&source->lock, 1274, "source.c");
  }
}

// speex_codec_free
// file format_speex.c line 33
static void speex_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  ogg_stream_clear(&codec->os);
  free((void *)codec);
}

// split_headers
// file httpp.c line 62
static signed int split_headers(char *data, unsigned long int len, char **line)
{
  signed int lines = 0;
  unsigned long int i;
  line[(signed long int)lines] = data;
  i = (unsigned long int)0;
  _Bool tmp_if_expr_1;
  for( ; !(lines >= 32) && !(i >= len); i = i + 1ul)
  {
    if((signed int)data[(signed long int)i] == 13)
      data[(signed long int)i] = (char)0;

    if((signed int)data[(signed long int)i] == 10)
    {
      lines = lines + 1;
      data[(signed long int)i] = (char)0;
      if(lines >= 32)
        return 32;

      if(!(1ul + i >= len))
      {
        if((signed int)data[1l + (signed long int)i] == 10)
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (signed int)data[(signed long int)(i + (unsigned long int)1)] == 13 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
          break;

        line[(signed long int)lines] = &data[(signed long int)(i + (unsigned long int)1)];
      }

    }

  }
  i = i + 1ul;
  for( ; !(i >= len); i = i + 1ul)
    if(!((signed int)data[(signed long int)i] == 10))
      break;

  return lines;
}

// start_relay_stream
// file slave.c line 316
static void * start_relay_stream(void *arg)
{
  struct _relay_server *relay = (struct _relay_server *)arg;
  struct source_tag *src = relay->source;
  struct _client_tag *client;
  log_write(errorlog, (unsigned int)3, "slave/", "start_relay_stream", "Starting relayed source at mountpoint \"%s\"", relay->localmount);
  do
  {
    client=open_relay_connection(relay);
    if(!(client == ((struct _client_tag *)NULL)))
    {
      src->client = client;
      src->parser = client->parser;
      src->con = client->con;
      signed int return_value_connection_complete_source_1;
      return_value_connection_complete_source_1=connection_complete_source(src, 0);
      if(!(return_value_connection_complete_source_1 >= 0))
      {
        log_write(errorlog, (unsigned int)3, "slave/", "start_relay_stream", "Failed to complete source initialisation");
        client_destroy(client);
        src->client = (struct _client_tag *)(void *)0;
      }

      else
      {
        stats_event_inc((const char *)(void *)0, "source_relay_connections");
        stats_event(relay->localmount, "source_ip", client->con->ip);
        source_main(relay->source);
        if(relay->on_demand == 0)
        {
          yp_remove(relay->localmount);
          relay->source->yp_public = -1;
          signed long int return_value_time_2;
          return_value_time_2=time((signed long int *)(void *)0);
          relay->start = return_value_time_2 + (signed long int)10;
          slave_update_all_mounts();
        }

        relay->cleanup = 1;
        slave_rebuild_mounts();
        return (void *)0;
      }
    }

  }
  while((_Bool)0);
  if(!(relay->source->fallback_mount == ((char *)NULL)))
  {
    struct source_tag *fallback_source;
    log_write(errorlog, (unsigned int)4, "slave/", "start_relay_stream", "failed relay, fallback to %s", relay->source->fallback_mount);
    avl_tree_rlock(global.source_tree);
    fallback_source=source_find_mount(relay->source->fallback_mount);
    if(!(fallback_source == ((struct source_tag *)NULL)))
      source_move_clients(relay->source, fallback_source);

    avl_tree_unlock(global.source_tree);
  }

  source_clear_source(relay->source);
  thread_mutex_lock_c(&_slave_mutex, 379, "slave.c");
  struct anonymous_17 *return_value_config_locks_3;
  return_value_config_locks_3=config_locks();
  thread_mutex_lock_c(&return_value_config_locks_3->relay_lock, 380, "slave.c");
  relay->source->on_demand = 0;
  signed long int return_value_time_4;
  return_value_time_4=time((signed long int *)(void *)0);
  relay->start = return_value_time_4 + (signed long int)max_interval;
  relay->cleanup = 1;
  struct anonymous_17 *return_value_config_locks_5;
  return_value_config_locks_5=config_locks();
  thread_mutex_unlock_c(&return_value_config_locks_5->relay_lock, 384, "slave.c");
  thread_mutex_unlock_c(&_slave_mutex, 385, "slave.c");
  return (void *)0;
}

// stats_callback
// file stats.h line 95
void stats_callback(struct _client_tag *client, void *notused)
{
  if(!(client->con->error == 0))
    client_destroy(client);

  else
  {
    client_set_queue(client, (struct _refbuf_tag *)(void *)0);
    thread_create_c("Stats Connection", stats_connection, (void *)client, 1, 961, "stats.c");
  }
}

// stats_clear_virtual_mounts
// file stats.h line 80
void stats_clear_virtual_mounts(void)
{
  struct avl_node_tag *snode;
  thread_mutex_lock_c(&_stats_mutex, 1097, "stats.c");
  snode=avl_get_first(_stats.source_tree);
  while(!(snode == ((struct avl_node_tag *)NULL)))
  {
    struct _stats_source_tag *src = (struct _stats_source_tag *)snode->key;
    struct source_tag *source;
    source=source_find_mount_raw(src->source);
    if(source == ((struct source_tag *)NULL))
    {
      snode=avl_get_next(snode);
      log_write(errorlog, (unsigned int)4, "stats/", "stats_clear_virtual_mounts", "releasing %s stats", src->source);
      avl_delete(_stats.source_tree, (void *)src, _free_source_stats);
    }

    else
      snode=avl_get_next(snode);
  }
  thread_mutex_unlock_c(&_stats_mutex, 1115, "stats.c");
}

// stats_connection
// file stats.c line 905
void * stats_connection(void *arg)
{
  struct _client_tag *client = (struct _client_tag *)arg;
  struct _stats_event_tag *event;
  struct _event_listener_tag listener;
  log_write(errorlog, (unsigned int)3, "stats/", "stats_connection", "stats client starting");
  (&listener.queue)->head = (volatile struct _stats_event_tag *)(void *)0;
  (&listener.queue)->tail = &(&listener.queue)->head;
  thread_mutex_lock_c(&_stats_mutex, 915, "stats.c");
  _stats_threads = _stats_threads + 1;
  stats_event_args((const char *)(void *)0, "stats", "%d", _stats_threads);
  thread_mutex_unlock_c(&_stats_mutex, 918, "stats.c");
  thread_mutex_create_c(&listener.mutex, 920, "stats.c");
  _register_listener(&listener);
  while(!(_stats_running == 0))
  {
    thread_mutex_lock_c(&listener.mutex, 925, "stats.c");
    event=_get_event_from_queue(&listener.queue);
    thread_mutex_unlock_c(&listener.mutex, 927, "stats.c");
    if(!(event == ((struct _stats_event_tag *)NULL)))
    {
      signed int return_value__send_event_to_client_1;
      return_value__send_event_to_client_1=_send_event_to_client(event, client);
      if(!(return_value__send_event_to_client_1 >= 0))
      {
        _free_event(event);
        break;
      }

      _free_event(event);
      continue;
    }

    thread_sleep((unsigned long int)500000);
  }
  thread_mutex_lock_c(&_stats_mutex, 939, "stats.c");
  _unregister_listener(&listener);
  _stats_threads = _stats_threads - 1;
  stats_event_args((const char *)(void *)0, "stats", "%d", _stats_threads);
  thread_mutex_unlock_c(&_stats_mutex, 943, "stats.c");
  thread_mutex_destroy(&listener.mutex);
  client_destroy(client);
  log_write(errorlog, (unsigned int)3, "stats/", "stats_connection", "stats client finished");
  return (void *)0;
}

// stats_event
// file stats.h line 82
void stats_event(const char *source, const char *name, const char *value)
{
  struct _stats_event_tag *event;
  signed int return_value_xmlCheckUTF8_1;
  if(!(value == ((const char *)NULL)))
  {
    return_value_xmlCheckUTF8_1=xmlCheckUTF8((unsigned char *)value);
    if(!(return_value_xmlCheckUTF8_1 == 0))
      goto __CPROVER_DUMP_L1;

    log_write(errorlog, (unsigned int)2, "stats/", "stats_event", "seen non-UTF8 data, probably incorrect metadata (%s, %s)", name, value);
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    event=build_event(source, name, value);
    if(!(event == ((struct _stats_event_tag *)NULL)))
      queue_global_event(event);

  }
}

// stats_event_add
// file stats.c line 325
void stats_event_add(const char *source, const char *name, unsigned long int value)
{
  struct _stats_event_tag *event;
  event=build_event(source, name, (const char *)(void *)0);
  if(!(event == ((struct _stats_event_tag *)NULL)))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)16);
    event->value = (char *)return_value_malloc_1;
    snprintf(event->value, (unsigned long int)16, "%ld", value);
    event->action = 3;
    queue_global_event(event);
  }

}

// stats_event_args
// file stats.h line 85
void stats_event_args(const char *source, char *name, char *format, ...)
{
  char buf[1024l];
  void **val;
  signed int ret;
  if(!(name == ((char *)NULL)))
  {
    val = (void **)&format;
    ret=vsnprintf(buf, sizeof(char [1024l]) /*1024ul*/ , format, val);
    val = ((void **)NULL);
    if((unsigned long int)(unsigned int)ret >= sizeof(char [1024l]) /*1024ul*/  || !(ret >= 0))
      log_write(errorlog, (unsigned int)2, "stats/", "stats_event_args", "problem with formatting %s stat %s", source == (const char *)(void *)0 ? "global" : source, name);

    else
      stats_event(source, name, buf);
  }

}

// stats_event_conv
// file stats.h line 83
void stats_event_conv(const char *mount, const char *name, const char *value, const char *charset)
{
  const char *metadata = value;
  struct _xmlBuffer *conv;
  conv=xmlBufferCreate();
  const unsigned char *return_value_xmlBufferContent_2;
  if(!(charset == ((const char *)NULL)))
  {
    struct _xmlCharEncodingHandler *handle;
    handle=xmlFindCharEncodingHandler(charset);
    if(!(handle == ((struct _xmlCharEncodingHandler *)NULL)))
    {
      struct _xmlBuffer *raw;
      raw=xmlBufferCreate();
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(value);
      xmlBufferAdd(raw, (const unsigned char *)value, (signed int)return_value_strlen_1);
      signed int return_value_xmlCharEncInFunc_3;
      return_value_xmlCharEncInFunc_3=xmlCharEncInFunc(handle, conv, raw);
      if(return_value_xmlCharEncInFunc_3 >= 1)
      {
        return_value_xmlBufferContent_2=xmlBufferContent(conv);
        metadata = (char *)return_value_xmlBufferContent_2;
      }

      xmlBufferFree(raw);
      xmlCharEncCloseFunc(handle);
    }

    else
      log_write(errorlog, (unsigned int)2, "stats/", "stats_event_conv", "No charset found for \"%s\"", charset);
  }

  stats_event(mount, name, metadata);
  xmlBufferFree(conv);
}

// stats_event_dec
// file stats.h line 89
void stats_event_dec(const char *source, const char *name)
{
  struct _stats_event_tag *event;
  event=build_event(source, name, (const char *)(void *)0);
  if(!(event == ((struct _stats_event_tag *)NULL)))
  {
    event->action = 2;
    queue_global_event(event);
  }

}

// stats_event_hidden
// file stats.h line 90
void stats_event_hidden(const char *source, const char *name, signed int hidden)
{
  struct _stats_event_tag *event;
  const char *str = (const char *)(void *)0;
  if(!(hidden == 0))
    str = "";

  event=build_event(source, name, str);
  if(!(event == ((struct _stats_event_tag *)NULL)))
  {
    event->action = 6;
    queue_global_event(event);
  }

}

// stats_event_inc
// file stats.h line 86
void stats_event_inc(const char *source, const char *name)
{
  struct _stats_event_tag *event;
  event=build_event(source, name, (const char *)(void *)0);
  if(!(event == ((struct _stats_event_tag *)NULL)))
  {
    event->action = 1;
    queue_global_event(event);
  }

}

// stats_event_sub
// file stats.h line 88
void stats_event_sub(const char *source, const char *name, unsigned long int value)
{
  struct _stats_event_tag *event;
  event=build_event(source, name, (const char *)(void *)0);
  if(!(event == ((struct _stats_event_tag *)NULL)))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)16);
    event->value = (char *)return_value_malloc_1;
    snprintf(event->value, (unsigned long int)16, "%ld", value);
    event->action = 4;
    queue_global_event(event);
  }

}

// stats_event_time
// file stats.h line 91
void stats_event_time(const char *mount, const char *name)
{
  char buffer[100l];
  __format_time(buffer, sizeof(char [100l]) /*100ul*/ , "%a, %d %b %Y %H:%M:%S ");
  stats_event(mount, name, buffer);
}

// stats_event_time_iso8601
// file stats.h line 92
void stats_event_time_iso8601(const char *mount, const char *name)
{
  char buffer[100l];
  __format_time(buffer, sizeof(char [100l]) /*100ul*/ , "%Y-%m-%dT%H:%M:%S");
  stats_event(mount, name, buffer);
}

// stats_get_stats
// file stats.c line 189
struct _stats_tag * stats_get_stats(void)
{
  return (struct _stats_tag *)(void *)0;
}

// stats_get_streams
// file stats.c line 1047
struct _refbuf_tag * stats_get_streams(void)
{
  struct avl_node_tag *node;
  unsigned int remaining = (unsigned int)4096;
  struct _refbuf_tag *start;
  start=refbuf_new(remaining);
  struct _refbuf_tag *cur = start;
  char *buffer = cur->data;
  thread_mutex_lock_c(&_stats_mutex, 1056, "stats.c");
  node=avl_get_first(_stats.source_tree);
  while(!(node == ((struct avl_node_tag *)NULL)))
  {
    signed int ret;
    struct _stats_source_tag *source = (struct _stats_source_tag *)node->key;
    if(source->hidden == 0)
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(source->source);
      if(3ul + return_value_strlen_1 >= (unsigned long int)remaining)
      {
        cur->len = (unsigned int)4096 - remaining;
        cur->next=refbuf_new((unsigned int)4096);
        remaining = (unsigned int)4096;
        cur = cur->next;
        buffer = cur->data;
      }

      ret=snprintf(buffer, (unsigned long int)remaining, "%s\r\n", source->source);
      if(ret >= 1)
      {
        buffer = buffer + (signed long int)ret;
        remaining = remaining - (unsigned int)ret;
      }

    }

    node=avl_get_next(node);
  }
  thread_mutex_unlock_c(&_stats_mutex, 1082, "stats.c");
  cur->len = (unsigned int)4096 - remaining;
  return start;
}

// stats_get_value
// file stats.c line 308
char * stats_get_value(const char *source, const char *name)
{
  char *return_value__get_stats_1;
  return_value__get_stats_1=_get_stats(source, name);
  return return_value__get_stats_1;
}

// stats_get_xml
// file stats.c line 987
struct _xmlDoc * stats_get_xml(signed int show_hidden, const char *show_mount)
{
  struct _xmlDoc *doc;
  struct _xmlNode *node;
  doc=xmlNewDoc((unsigned char *)"1.0");
  node=xmlNewDocNode(doc, (struct _xmlNs *)(void *)0, (unsigned char *)"icestats", (const unsigned char *)(void *)0);
  xmlDocSetRootElement(doc, node);
  node=_dump_stats_to_doc(node, show_mount, show_hidden);
  return doc;
}

// stats_global
// file stats.h line 77
void stats_global(struct ice_config_tag *config)
{
  stats_event((const char *)(void *)0, "server_id", config->server_id);
  stats_event((const char *)(void *)0, "host", config->hostname);
  stats_event((const char *)(void *)0, "location", config->location);
  stats_event((const char *)(void *)0, "admin", config->admin);
}

// stats_initialize
// file stats.h line 74
void stats_initialize(void)
{
  _event_listeners = (volatile struct _event_listener_tag *)(void *)0;
  _stats.global_tree=avl_tree_new(_compare_stats, (void *)0);
  _stats.source_tree=avl_tree_new(_compare_source_stats, (void *)0);
  thread_mutex_create_c(&_stats_mutex, 135, "stats.c");
  (&_global_event_queue)->head = (volatile struct _stats_event_tag *)(void *)0;
  (&_global_event_queue)->tail = &(&_global_event_queue)->head;
  thread_mutex_create_c(&_global_event_mutex, 139, "stats.c");
  _stats_running = 1;
  _stats_thread_id=thread_create_c("Stats Thread", _stats_thread, (void *)0, 0, 143, "stats.c");
}

// stats_shutdown
// file stats.h line 75
void stats_shutdown(void)
{
  signed int n;
  if(!(_stats_running == 0))
  {
    _stats_running = 0;
    thread_join(_stats_thread_id);
    do
    {
      thread_sleep((unsigned long int)300000);
      thread_mutex_lock_c(&_stats_mutex, 160, "stats.c");
      n = _stats_threads;
      thread_mutex_unlock_c(&_stats_mutex, 162, "stats.c");
    }
    while(n >= 1);
    log_write(errorlog, (unsigned int)3, "stats/", "stats_shutdown", "stats thread finished");
    thread_mutex_destroy(&_global_event_mutex);
    thread_mutex_destroy(&_stats_mutex);
    avl_tree_free(_stats.source_tree, _free_source_stats);
    avl_tree_free(_stats.global_tree, _free_stats);
    while((_Bool)1)
    {
      struct _stats_event_tag *event;
      event=_get_event_from_queue(&_global_event_queue);
      if(event == ((struct _stats_event_tag *)NULL))
        break;

      if(!(event->source == ((char *)NULL)))
        free((void *)event->source);

      if(!(event->value == ((char *)NULL)))
        free((void *)event->value);

      if(!(event->name == ((char *)NULL)))
        free((void *)event->name);

      free((void *)event);
    }
  }

}

// stats_transform_xslt
// file stats.c line 973
void stats_transform_xslt(struct _client_tag *client, const char *uri)
{
  struct _xmlDoc *doc;
  char *xslpath;
  xslpath=util_get_path_from_normalised_uri(uri);
  const char *mount;
  mount=httpp_get_query_param(client->parser, "mount");
  doc=stats_get_xml(0, mount);
  xslt_transform(doc, xslpath, client);
  xmlFreeDoc(doc);
  free((void *)xslpath);
}

// stream_auth_callback
// file auth.c line 244
static void stream_auth_callback(struct auth_tag *auth, struct auth_client_tag *auth_user)
{
  struct _client_tag *client = auth_user->client;
  if(!(auth->stream_auth == ((void (*)(struct auth_client_tag *))NULL)))
    auth->stream_auth(auth_user);

  auth_release(auth);
  client->auth = (struct auth_tag *)(void *)0;
  if(!(client->authenticated == 0))
    auth_postprocess_source(auth_user);

  else
    log_write(errorlog, (unsigned int)2, "auth/", "stream_auth_callback", "Failed auth for source \"%s\"", auth_user->mount);
}

// stream_end_callback
// file auth.c line 274
static void stream_end_callback(struct auth_tag *auth, struct auth_client_tag *auth_user)
{
  if(!(auth->stream_end == ((void (*)(struct auth_client_tag *))NULL)))
    auth->stream_end(auth_user);

  auth_release(auth);
}

// stream_start_callback
// file auth.c line 263
static void stream_start_callback(struct auth_tag *auth, struct auth_client_tag *auth_user)
{
  if(!(auth->stream_start == ((void (*)(struct auth_client_tag *))NULL)))
    auth->stream_start(auth_user);

  auth_release(auth);
}

// theora_codec_free
// file format_theora.c line 46
static void theora_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  struct _theora_codec_tag *theora = (struct _theora_codec_tag *)codec->specific;
  log_write(errorlog, (unsigned int)4, "format-theora/", "theora_codec_free", "freeing theora codec");
  stats_event(ogg_info->mount, "video_bitrate", (const char *)(void *)0);
  stats_event(ogg_info->mount, "video_quality", (const char *)(void *)0);
  stats_event(ogg_info->mount, "frame_rate", (const char *)(void *)0);
  stats_event(ogg_info->mount, "frame_size", (const char *)(void *)0);
  theora_info_clear(&theora->ti);
  theora_comment_clear(&theora->tc);
  ogg_stream_clear(&codec->os);
  free((void *)theora);
  free((void *)codec);
}

// thread_cond_broadcast_c
// file thread/thread.h line 174
void thread_cond_broadcast_c(struct anonymous_27 *cond, signed int line, char *file)
{
  pthread_cond_broadcast(&cond->sys_cond);
}

// thread_cond_create_c
// file thread/thread.h line 172
void thread_cond_create_c(struct anonymous_27 *cond, signed int line, char *file)
{
  pthread_cond_init(&cond->sys_cond, (const union anonymous_40 *)(void *)0);
  pthread_mutex_init(&cond->cond_mutex, (const union anonymous_40 *)(void *)0);
}

// thread_cond_destroy
// file thread/thread.h line 177
void thread_cond_destroy(struct anonymous_27 *cond)
{
  pthread_mutex_destroy(&cond->cond_mutex);
  pthread_cond_destroy(&cond->sys_cond);
}

// thread_cond_signal_c
// file thread.c line 508
void thread_cond_signal_c(struct anonymous_27 *cond, signed int line, char *file)
{
  pthread_cond_signal(&cond->sys_cond);
}

// thread_cond_timedwait_c
// file thread.c line 518
void thread_cond_timedwait_c(struct anonymous_27 *cond, signed int millis, signed int line, char *file)
{
  struct timespec thread_cond_timedwait_c__1__time;
  thread_cond_timedwait_c__1__time.tv_sec = (signed long int)(millis / 1000);
  thread_cond_timedwait_c__1__time.tv_nsec = ((signed long int)millis - thread_cond_timedwait_c__1__time.tv_sec * (signed long int)1000) * (signed long int)1000000;
  pthread_mutex_lock(&cond->cond_mutex);
  pthread_cond_timedwait(&cond->sys_cond, &cond->cond_mutex, &thread_cond_timedwait_c__1__time);
  pthread_mutex_unlock(&cond->cond_mutex);
}

// thread_cond_wait_c
// file thread.c line 530
void thread_cond_wait_c(struct anonymous_27 *cond, signed int line, char *file)
{
  pthread_mutex_lock(&cond->cond_mutex);
  pthread_cond_wait(&cond->sys_cond, &cond->cond_mutex);
  pthread_mutex_unlock(&cond->cond_mutex);
}

// thread_create_c
// file thread/thread.h line 166
struct anonymous_24 * thread_create_c(char *name, void * (*start_routine)(void *), void *arg, signed int detached, signed int line, char *file)
{
  signed int ok = 1;
  struct anonymous_24 *thread = (struct anonymous_24 *)(void *)0;
  struct thread_start_tag *start = (struct thread_start_tag *)(void *)0;
  union pthread_attr_t attr;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_24) /*48ul*/ );
  thread = (struct anonymous_24 *)return_value_calloc_1;
  signed long int tmp_post_4;
  while(!(thread == ((struct anonymous_24 *)NULL)))
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct thread_start_tag) /*32ul*/ );
    start = (struct thread_start_tag *)return_value_calloc_2;
    if(start == ((struct thread_start_tag *)NULL))
      break;

    signed int return_value_pthread_attr_init_3;
    return_value_pthread_attr_init_3=pthread_attr_init(&attr);
    if(!(return_value_pthread_attr_init_3 >= 0))
      break;

    thread->line = line;
    thread->file=strdup(file);
    _mutex_lock(&_threadtree_mutex);
    tmp_post_4 = _next_thread_id;
    _next_thread_id = _next_thread_id + 1l;
    thread->thread_id = tmp_post_4;
    _mutex_unlock(&_threadtree_mutex);
    thread->name=strdup(name);
    thread->create_time=time((signed long int *)(void *)0);
    start->start_routine = start_routine;
    start->arg = arg;
    start->thread = thread;
    pthread_attr_setstacksize(&attr, (unsigned long int)(512 * 1024));
    pthread_attr_setinheritsched(&attr, 0);
    if(!(detached == 0))
    {
      pthread_attr_setdetachstate(&attr, 1);
      thread->detached = 1;
    }

    signed int return_value_pthread_create_5;
    return_value_pthread_create_5=pthread_create(&thread->sys_thread, &attr, _start_routine, (void *)start);
    if(return_value_pthread_create_5 == 0)
    {
      pthread_attr_destroy(&attr);
      return thread;
    }

    else
      pthread_attr_destroy(&attr);
    break;
  }
  if(!(start == ((struct thread_start_tag *)NULL)))
    free((void *)start);

  if(!(thread == ((struct anonymous_24 *)NULL)))
    free((void *)thread);

  return (struct anonymous_24 *)(void *)0;
}

// thread_exit_c
// file thread.c line 562
void thread_exit_c(signed long int val, signed int line, char *file)
{
  struct anonymous_24 *th;
  th=thread_self();
  if(!(th == ((struct anonymous_24 *)NULL)))
  {
    if(!(th->detached == 0))
    {
      _mutex_lock(&_threadtree_mutex);
      avl_delete(_threadtree, (void *)th, _free_thread);
      _mutex_unlock(&_threadtree_mutex);
    }

  }

  pthread_exit((void *)val);
}

// thread_initialize
// file thread/thread.h line 161
void thread_initialize(void)
{
  struct anonymous_24 *thread;
  thread_mutex_create_c(&_threadtree_mutex, 164, "thread.c");
  thread_mutex_create_c(&_library_mutex, 165, "thread.c");
  _threadtree=avl_tree_new(_compare_threads, (void *)0);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_24) /*48ul*/ );
  thread = (struct anonymous_24 *)return_value_malloc_1;
  signed long int tmp_post_2 = _next_thread_id;
  _next_thread_id = _next_thread_id + 1l;
  thread->thread_id = tmp_post_2;
  thread->line = 0;
  thread->file=strdup("main.c");
  thread->sys_thread=pthread_self();
  thread->create_time=time((signed long int *)(void *)0);
  thread->name=strdup("Main Thread");
  avl_insert(_threadtree, (void *)thread);
  _catch_signals();
  _initialized_link2 = 1;
}

// thread_join
// file thread/thread.h line 200
void thread_join(struct anonymous_24 *thread)
{
  void *ret;
  signed int i;
  i=pthread_join(thread->sys_thread, &ret);
  _mutex_lock(&_threadtree_mutex);
  avl_delete(_threadtree, (void *)thread, _free_thread);
  _mutex_unlock(&_threadtree_mutex);
}

// thread_library_lock
// file thread.c line 728
void thread_library_lock(void)
{
  _mutex_lock(&_library_mutex);
}

// thread_library_unlock
// file thread.c line 733
void thread_library_unlock(void)
{
  _mutex_unlock(&_library_mutex);
}

// thread_mutex_create_c
// file thread/thread.h line 168
void thread_mutex_create_c(struct anonymous_4 *mutex, signed int line, char *file)
{
  _mutex_create(mutex);
}

// thread_mutex_destroy
// file thread/thread.h line 171
void thread_mutex_destroy(struct anonymous_4 *mutex)
{
  pthread_mutex_destroy(&mutex->sys_mutex);
}

// thread_mutex_lock_c
// file thread/thread.h line 169
void thread_mutex_lock_c(struct anonymous_4 *mutex, signed int line, char *file)
{
  _mutex_lock(mutex);
}

// thread_mutex_unlock_c
// file thread/thread.h line 170
void thread_mutex_unlock_c(struct anonymous_4 *mutex, signed int line, char *file)
{
  _mutex_unlock(mutex);
}

// thread_rename
// file thread.c line 707
void thread_rename(const char *name)
{
  struct anonymous_24 *th;
  th=thread_self();
  if(!(th->name == ((char *)NULL)))
    free((void *)th->name);

  th->name=strdup(name);
}

// thread_rwlock_create_c
// file thread/thread.h line 178
void thread_rwlock_create_c(struct anonymous_16 *rwlock, signed int line, char *file)
{
  pthread_rwlock_init(&rwlock->sys_rwlock, (const union anonymous_39 *)(void *)0);
}

// thread_rwlock_destroy
// file thread/thread.h line 182
void thread_rwlock_destroy(struct anonymous_16 *rwlock)
{
  pthread_rwlock_destroy(&rwlock->sys_rwlock);
}

// thread_rwlock_rlock_c
// file thread/thread.h line 179
void thread_rwlock_rlock_c(struct anonymous_16 *rwlock, signed int line, char *file)
{
  pthread_rwlock_rdlock(&rwlock->sys_rwlock);
}

// thread_rwlock_unlock_c
// file thread/thread.h line 181
void thread_rwlock_unlock_c(struct anonymous_16 *rwlock, signed int line, char *file)
{
  pthread_rwlock_unlock(&rwlock->sys_rwlock);
}

// thread_rwlock_wlock_c
// file thread/thread.h line 180
void thread_rwlock_wlock_c(struct anonymous_16 *rwlock, signed int line, char *file)
{
  pthread_rwlock_wrlock(&rwlock->sys_rwlock);
}

// thread_self
// file thread.c line 669
struct anonymous_24 * thread_self(void)
{
  struct avl_node_tag *node;
  struct anonymous_24 *th;
  unsigned long int sys_thread;
  sys_thread=pthread_self();
  _mutex_lock(&_threadtree_mutex);
  signed int return_value_pthread_equal_1;
  if(_threadtree == ((struct _avl_tree *)NULL))
  {
    _mutex_unlock(&_threadtree_mutex);
    return (struct anonymous_24 *)(void *)0;
  }

  else
  {
    node=avl_get_first(_threadtree);
    while(!(node == ((struct avl_node_tag *)NULL)))
    {
      th = (struct anonymous_24 *)node->key;
      if(!(th == ((struct anonymous_24 *)NULL)))
      {
        return_value_pthread_equal_1=pthread_equal(sys_thread, th->sys_thread);
        if(!(return_value_pthread_equal_1 == 0))
        {
          _mutex_unlock(&_threadtree_mutex);
          return th;
        }

      }

      node=avl_get_next(node);
    }
    _mutex_unlock(&_threadtree_mutex);
    return (struct anonymous_24 *)(void *)0;
  }
}

// thread_shutdown
// file thread/thread.h line 163
void thread_shutdown(void)
{
  if(_initialized_link2 == 1)
  {
    thread_mutex_destroy(&_library_mutex);
    thread_mutex_destroy(&_threadtree_mutex);
    avl_tree_free(_threadtree, _free_thread);
    _threadtree = (struct _avl_tree *)(void *)0;
  }

}

// thread_sleep
// file thread/thread.h line 186
void thread_sleep(unsigned long int len)
{
  struct timespec time_sleep;
  struct timespec time_remaining;
  signed int ret;
  time_sleep.tv_sec = (signed long int)(len / (unsigned long int)1000000);
  time_sleep.tv_nsec = (signed long int)((len % (unsigned long int)1000000) * (unsigned long int)1000);
  ret=nanosleep(&time_sleep, &time_remaining);
  signed int *return_value___errno_location_1;
  while(!(ret == 0))
  {
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 4))
      break;

    time_sleep.tv_sec = time_remaining.tv_sec;
    time_sleep.tv_nsec = time_remaining.tv_nsec;
    ret=nanosleep(&time_sleep, &time_remaining);
  }
}

// thread_spin_create
// file thread/thread.h line 98
void thread_spin_create(struct anonymous_41 *spin)
{
  signed int x;
  x=pthread_spin_init(&spin->lock, 0);
  if(!(x == 0))
    abort();

}

// thread_spin_destroy
// file thread/thread.h line 99
void thread_spin_destroy(struct anonymous_41 *spin)
{
  pthread_spin_destroy(&spin->lock);
}

// thread_spin_lock
// file thread/thread.h line 100
void thread_spin_lock(struct anonymous_41 *spin)
{
  signed int x;
  x=pthread_spin_lock(&spin->lock);
  if(!(x == 0))
    abort();

}

// thread_spin_unlock
// file thread/thread.h line 101
void thread_spin_unlock(struct anonymous_41 *spin)
{
  pthread_spin_unlock(&spin->lock);
}

// timing_get_time
// file timing.c line 48
unsigned long int timing_get_time(void)
{
  struct timeval mtv;
  gettimeofday(&mtv, (struct timezone *)(void *)0);
  return (unsigned long int)mtv.tv_sec * (unsigned long int)1000 + (unsigned long int)mtv.tv_usec / (unsigned long int)1000;
}

// timing_sleep
// file timing.c line 67
void timing_sleep(unsigned long int sleeptime)
{
  struct timeval sleeper;
  sleeper.tv_sec = (signed long int)(sleeptime / (unsigned long int)1000);
  sleeper.tv_usec = (signed long int)((sleeptime % (unsigned long int)1000) * (unsigned long int)1000);
  select(1, (struct anonymous_44 *)(void *)0, (struct anonymous_44 *)(void *)0, (struct anonymous_44 *)(void *)0, &sleeper);
}

// update_comments
// file format_ogg.c line 277
static void update_comments(struct source_tag *source)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)source->format->_state;
  char *title = ogg_info->title;
  char *artist = ogg_info->artist;
  char *metadata = (char *)(void *)0;
  unsigned int update_comments__1__len = (unsigned int)1;
  struct ogg_codec_tag *codec;
  char codec_names[100l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  if(!(ogg_info->artist == ((char *)NULL)))
  {
    if(!(title == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(artist);
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(title);
      update_comments__1__len = update_comments__1__len + (unsigned int)(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)3);
      void *return_value_calloc_3;
      return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)update_comments__1__len);
      metadata = (char *)return_value_calloc_3;
      snprintf(metadata, (unsigned long int)update_comments__1__len, "%s - %s", artist, title);
    }

    else
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(artist);
      update_comments__1__len = update_comments__1__len + (unsigned int)return_value_strlen_4;
      void *return_value_calloc_5;
      return_value_calloc_5=calloc((unsigned long int)1, (unsigned long int)update_comments__1__len);
      metadata = (char *)return_value_calloc_5;
      snprintf(metadata, (unsigned long int)update_comments__1__len, "%s", artist);
    }
  }

  else
    if(!(title == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(title);
      update_comments__1__len = update_comments__1__len + (unsigned int)return_value_strlen_6;
      void *return_value_calloc_7;
      return_value_calloc_7=calloc((unsigned long int)1, (unsigned long int)update_comments__1__len);
      metadata = (char *)return_value_calloc_7;
      snprintf(metadata, (unsigned long int)update_comments__1__len, "%s", title);
    }

  if(!(metadata == ((char *)NULL)))
  {
    logging_playlist(source->mount, metadata, (signed long int)source->listeners);
    free((void *)metadata);
  }

  stats_event(source->mount, "artist", artist);
  stats_event(source->mount, "title", title);
  codec = ogg_info->codecs;
  for( ; !(codec == ((struct ogg_codec_tag *)NULL)); codec = codec->next)
    if(!(codec->name == ((const char *)NULL)))
    {
      signed int len;
      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen(codec_names);
      len = (signed int)return_value_strlen_8;
      signed int remaining = (signed int)(sizeof(char [100l]) /*100ul*/  - (unsigned long int)len);
      char *where = codec_names + (signed long int)len;
      char *separator = "/";
      if(len == 0)
        separator = "";

      snprintf(where, (unsigned long int)remaining, "%s%s", separator, codec->name);
    }

  stats_event(source->mount, "subtype", codec_names);
  yp_touch(source->mount);
}

// update_from_master
// file slave.c line 604
static signed int update_from_master(struct ice_config_tag *config)
{
  char *master = (char *)(void *)0;
  char *password = (char *)(void *)0;
  char *username = (char *)(void *)0;
  signed int port;
  signed int mastersock;
  signed int ret = 0;
  char buf[256l];
  _Bool tmp_if_expr_6;
  signed int return_value_strncmp_5;
  signed int return_value_sock_read_line_7;
  signed int return_value_sock_read_line_9;
  signed int tmp_post_11;
  do
  {
    char *authheader;
    char *data;
    struct _relay_server *new_relays = (struct _relay_server *)(void *)0;
    struct _relay_server *cleanup_relays;
    signed int len;
    signed int count = 1;
    signed int on_demand;
    username=strdup(config->master_username);
    if(!(config->master_password == ((char *)NULL)))
      password=strdup(config->master_password);

    if(!(config->master_server == ((char *)NULL)))
      master=strdup(config->master_server);

    port = config->master_server_port;
    if(master == ((char *)NULL) || password == ((char *)NULL) || port == 0)
      break;

    on_demand = config->on_demand;
    ret = 1;
    config_release_config();
    mastersock=sock_connect_wto(master, port, 10);
    if(mastersock == -1)
    {
      log_write(errorlog, (unsigned int)2, "slave/", "update_from_master", "Relay slave failed to contact master server to fetch stream list");
      break;
    }

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(username);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(password);
    len = (signed int)(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)2);
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)len);
    authheader = (char *)return_value_malloc_3;
    snprintf(authheader, (unsigned long int)len, "%s:%s", username, password);
    data=util_base64_encode(authheader);
    sock_write(mastersock, "GET /admin/streamlist.txt HTTP/1.0\r\nAuthorization: Basic %s\r\n\r\n", data);
    free((void *)authheader);
    free((void *)data);
    signed int return_value_sock_read_line_4;
    return_value_sock_read_line_4=sock_read_line(mastersock, buf, (const signed int)sizeof(char [256l]) /*256ul*/ );
    if(return_value_sock_read_line_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strncmp_5=strncmp(buf, "HTTP/1.0 200", (unsigned long int)12);
      tmp_if_expr_6 = return_value_strncmp_5 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      sock_close(mastersock);
      log_write(errorlog, (unsigned int)2, "slave/", "update_from_master", "Master rejected streamlist request");
      break;
    }

    do
    {
      return_value_sock_read_line_7=sock_read_line(mastersock, buf, (const signed int)sizeof(char [256l]) /*256ul*/ );
      if(return_value_sock_read_line_7 == 0)
        break;

      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen(buf);
      if(return_value_strlen_8 == 0ul)
        break;

    }
    while((_Bool)1);
    do
    {
      return_value_sock_read_line_9=sock_read_line(mastersock, buf, (const signed int)sizeof(char [256l]) /*256ul*/ );
      if(return_value_sock_read_line_9 == 0)
        break;

      struct _relay_server *r;
      unsigned long int return_value_strlen_10;
      return_value_strlen_10=strlen(buf);
      if(!(return_value_strlen_10 == 0ul))
      {
        tmp_post_11 = count;
        count = count + 1;
        log_write(errorlog, (unsigned int)4, "slave/", "update_from_master", "read %d from master \"%s\"", tmp_post_11, (const void *)buf);
        struct _xmlURI *parsed_uri;
        parsed_uri=xmlParseURI(buf);
        if(parsed_uri == ((struct _xmlURI *)NULL))
          log_write(errorlog, (unsigned int)4, "slave/", "update_from_master", "Error while parsing line from master. Ignoring line.");

        else
        {
          void *return_value_calloc_12;
          return_value_calloc_12=calloc((unsigned long int)1, sizeof(struct _relay_server) /*104ul*/ );
          r = (struct _relay_server *)return_value_calloc_12;
          if(!(r == ((struct _relay_server *)NULL)))
          {
            if(!(parsed_uri->server == ((char *)NULL)))
            {
              r->server=strdup(parsed_uri->server);
              if(parsed_uri->port == 0)
                r->port = 80;

              else
                r->port = parsed_uri->port;
            }

            else
            {
              unsigned char *return_value_xmlCharStrdup_13;
              return_value_xmlCharStrdup_13=xmlCharStrdup(master);
              r->server = (char *)return_value_xmlCharStrdup_13;
              r->port = port;
            }
            r->mount=strdup(parsed_uri->path);
            r->localmount=strdup(parsed_uri->path);
            r->mp3metadata = 1;
            r->on_demand = on_demand;
            r->next = new_relays;
            log_write(errorlog, (unsigned int)4, "slave/", "update_from_master", "Added relay host=\"%s\", port=%d, mount=\"%s\"", r->server, r->port, r->mount);
            new_relays = r;
          }

          xmlFreeURI(parsed_uri);
        }
      }

    }
    while((_Bool)1);
    sock_close(mastersock);
    struct anonymous_17 *return_value_config_locks_14;
    return_value_config_locks_14=config_locks();
    thread_mutex_lock_c(&return_value_config_locks_14->relay_lock, 704, "slave.c");
    cleanup_relays=update_relays(&global.master_relays, new_relays);
    relay_check_streams(global.master_relays, cleanup_relays, 0);
    relay_check_streams((struct _relay_server *)(void *)0, new_relays, 0);
    struct anonymous_17 *return_value_config_locks_15;
    return_value_config_locks_15=config_locks();
    thread_mutex_unlock_c(&return_value_config_locks_15->relay_lock, 710, "slave.c");
  }
  while((_Bool)0);
  if(!(master == ((char *)NULL)))
    free((void *)master);

  if(!(username == ((char *)NULL)))
    free((void *)username);

  if(!(password == ((char *)NULL)))
    free((void *)password);

  return ret;
}

// update_relay_set
// file slave.c line 514
static struct _relay_server * update_relay_set(struct _relay_server **current, struct _relay_server *updated)
{
  struct _relay_server *relay = updated;
  struct _relay_server *existing_relay;
  struct _relay_server **existing_p;
  struct _relay_server *new_list = (struct _relay_server *)(void *)0;
  signed int return_value_relay_has_changed_1;
  for( ; !(relay == ((struct _relay_server *)NULL)); relay = relay->next)
  {
    existing_relay = *current;
    existing_p = current;
    while(!(existing_relay == ((struct _relay_server *)NULL)))
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(relay->localmount, existing_relay->localmount);
      if(return_value_strcmp_2 == 0)
      {
        return_value_relay_has_changed_1=relay_has_changed(relay, existing_relay);
        if(return_value_relay_has_changed_1 == 0)
          break;

      }

      existing_p = &existing_relay->next;
      existing_relay = existing_relay->next;
    }
    if(existing_relay == ((struct _relay_server *)NULL))
      existing_relay=relay_copy(relay);

    else
      *existing_p = existing_relay->next;
    existing_relay->next = new_list;
    new_list = existing_relay;
  }
  return new_list;
}

// update_relays
// file slave.c line 556
static struct _relay_server * update_relays(struct _relay_server **relay_list, struct _relay_server *new_relay_list)
{
  struct _relay_server *active_relays;
  struct _relay_server *cleanup_relays;
  active_relays=update_relay_set(relay_list, new_relay_list);
  cleanup_relays = *relay_list;
  *relay_list = active_relays;
  return cleanup_relays;
}

// url_add_listener
// file auth_url.c line 274
static enum anonymous_19 url_add_listener(struct auth_client_tag *auth_user)
{
  struct _client_tag *client = auth_user->client;
  struct auth_tag *auth = client->auth;
  struct anonymous_33 *url = (struct anonymous_33 *)auth->state;
  signed int res = 0;
  signed int port;
  const char *agent;
  char *user_agent;
  char *username;
  char *password;
  const char *mountreq;
  char *mount;
  char *ipaddr;
  char *server;
  struct ice_config_tag *config;
  char *userpwd = (char *)(void *)0;
  char post[4096l];
  signed long int post_offset;
  char *pass_headers;
  char *cur_header;
  char *next_header;
  const char *header_val;
  char *header_valesc;
  char *tmp_if_expr_2;
  _Bool tmp_if_expr_7;
  if(url->addurl == ((char *)NULL))
    return (enum anonymous_19)AUTH_OK;

  else
  {
    config=config_get_config();
    server=util_url_escape(config->hostname);
    port = config->port;
    config_release_config();
    agent=httpp_getvar(client->parser, "user-agent");
    if(!(agent == ((const char *)NULL)))
      user_agent=util_url_escape(agent);

    else
      user_agent=strdup("-");
    if(!(client->username == ((char *)NULL)))
      username=util_url_escape(client->username);

    else
      username=strdup("");
    if(!(client->password == ((char *)NULL)))
      password=util_url_escape(client->password);

    else
      password=strdup("");
    mountreq=httpp_getvar(client->parser, "__rawuri");
    if(mountreq == ((const char *)NULL))
      mountreq=httpp_getvar(client->parser, "__uri");

    mount=util_url_escape(mountreq);
    ipaddr=util_url_escape(client->con->ip);
    signed int return_value_snprintf_1;
    return_value_snprintf_1=snprintf(post, sizeof(char [4096l]) /*4096ul*/ , "action=listener_add&server=%s&port=%d&client=%lu&mount=%s&user=%s&pass=%s&ip=%s&agent=%s", server, port, client->con->id, mount, username, password, ipaddr, user_agent);
    post_offset = (signed long int)return_value_snprintf_1;
    free((void *)server);
    free((void *)mount);
    free((void *)user_agent);
    free((void *)username);
    free((void *)password);
    free((void *)ipaddr);
    pass_headers = (char *)(void *)0;
    if(!(url->pass_headers == ((char *)NULL)))
      pass_headers=strdup(url->pass_headers);

    if(!(pass_headers == ((char *)NULL)))
    {
      cur_header = pass_headers;
      for( ; !(cur_header == ((char *)NULL)); cur_header = next_header)
      {
        next_header=strstr(cur_header, ",");
        if(!(next_header == ((char *)NULL)))
        {
          *next_header = (char)0;
          next_header = next_header + 1l;
        }

        header_val=httpp_getvar(client->parser, cur_header);
        if(!(header_val == ((const char *)NULL)))
        {
          header_valesc=util_url_escape(header_val);
          if(!(url->prefix_headers == ((char *)NULL)))
            tmp_if_expr_2 = url->prefix_headers;

          else
            tmp_if_expr_2 = "";
          signed int return_value_snprintf_3;
          return_value_snprintf_3=snprintf(post + post_offset, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)post_offset, "&%s%s=%s", tmp_if_expr_2, cur_header, header_valesc);
          post_offset = post_offset + (signed long int)return_value_snprintf_3;
          free((void *)header_valesc);
        }

      }
    }

    char *return_value_strchr_8;
    return_value_strchr_8=strchr(url->addurl, 64);
    if(return_value_strchr_8 == ((char *)NULL))
    {
      if(!(url->userpwd == ((char *)NULL)))
      {
        signed int _curl_opt = CURLOPT_USERPWD;
        curl_easy_setopt(url->handle, (enum anonymous_32)_curl_opt, url->userpwd);
      }

      else
      {
        if(!(client->username == ((char *)NULL)))
          tmp_if_expr_7 = client->password != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
        {
          unsigned long int len;
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(client->username);
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(client->password);
          len = return_value_strlen_4 + return_value_strlen_5 + (unsigned long int)2;
          void *return_value_malloc_6;
          return_value_malloc_6=malloc(len);
          userpwd = (char *)return_value_malloc_6;
          snprintf(userpwd, len, "%s:%s", client->username, client->password);
          signed int url_add_listener__1__2__2__1__1___curl_opt = CURLOPT_USERPWD;
          curl_easy_setopt(url->handle, (enum anonymous_32)url_add_listener__1__2__2__1__1___curl_opt, userpwd);
        }

        else
        {
          signed int url_add_listener__1__2__2__2___curl_opt = CURLOPT_USERPWD;
          curl_easy_setopt(url->handle, (enum anonymous_32)url_add_listener__1__2__2__2___curl_opt, (const void *)"");
        }
      }
    }

    else
    {
      signed int url_add_listener__1__3__1___curl_opt = CURLOPT_USERPWD;
      curl_easy_setopt(url->handle, (enum anonymous_32)url_add_listener__1__3__1___curl_opt, (const void *)"");
    }
    signed int url_add_listener__1__4___curl_opt = CURLOPT_URL;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_add_listener__1__4___curl_opt, url->addurl);
    signed int url_add_listener__1__5___curl_opt = CURLOPT_POSTFIELDS;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_add_listener__1__5___curl_opt, (const void *)post);
    signed int url_add_listener__1__6___curl_opt = CURLOPT_HEADERDATA;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_add_listener__1__6___curl_opt, auth_user);
    url->errormsg[(signed long int)0] = (char)0;
    enum anonymous_34 return_value_curl_easy_perform_9;
    return_value_curl_easy_perform_9=curl_easy_perform(url->handle);
    res = (signed int)return_value_curl_easy_perform_9;
    free((void *)userpwd);
    if(!(res == 0))
    {
      log_write(errorlog, (unsigned int)2, "auth_url/", "url_add_listener", "auth to server %s failed with %s", url->addurl, (const void *)url->errormsg);
      return (enum anonymous_19)AUTH_FAILED;
    }

    else
      if(!(client->authenticated == 0))
        return (enum anonymous_19)AUTH_OK;

      else
      {
        log_write(errorlog, (unsigned int)3, "auth_url/", "url_add_listener", "client auth (%s) failed with \"%s\"", url->addurl, (const void *)url->errormsg);
        return (enum anonymous_19)AUTH_FAILED;
      }
  }
}

// url_escape
// file httpp.c line 203
static char * url_escape(const char *src)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(src);
  len = (signed int)return_value_strlen_1;
  unsigned char *decoded;
  signed int i;
  char *dst;
  signed int done = 0;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, (unsigned long int)(len + 1));
  decoded = (unsigned char *)return_value_calloc_2;
  dst = (char *)decoded;
  i = 0;
  signed int return_value_hex_3;
  _Bool tmp_if_expr_5;
  signed int return_value_hex_4;
  char *tmp_post_6;
  signed int return_value_hex_7;
  signed int return_value_hex_8;
  char *tmp_post_9;
  char *tmp_post_10;
  for( ; !(i >= len); i = i + 1)
  {
    switch((signed int)src[(signed long int)i])
    {
      case 37:
      {
        if(2 + i >= len)
        {
          free((void *)decoded);
          return (char *)(void *)0;
        }

        return_value_hex_3=hex_link1(src[(signed long int)(i + 1)]);
        if(return_value_hex_3 == -1)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_hex_4=hex_link1(src[(signed long int)(i + 2)]);
          tmp_if_expr_5 = return_value_hex_4 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
        {
          free((void *)decoded);
          return (char *)(void *)0;
        }

        tmp_post_6 = dst;
        dst = dst + 1l;
        return_value_hex_7=hex_link1(src[(signed long int)(i + 1)]);
        return_value_hex_8=hex_link1(src[(signed long int)(i + 2)]);
        *tmp_post_6 = (char)(return_value_hex_7 * 16 + return_value_hex_8);
        i = i + 2;
        break;
      }
      case 43:
      {
        tmp_post_9 = dst;
        dst = dst + 1l;
        *tmp_post_9 = (char)32;
        break;
      }
      case 35:
      {
        done = 1;
        break;
      }
      case 0:
      {
        free((void *)decoded);
        return (char *)(void *)0;
      }
      default:
      {
        tmp_post_10 = dst;
        dst = dst + 1l;
        *tmp_post_10 = src[(signed long int)i];
      }
    }
    if(!(done == 0))
      break;

  }
  *dst = (char)0;
  return (char *)decoded;
}

// url_remove_listener
// file auth_url.c line 181
static enum anonymous_19 url_remove_listener(struct auth_client_tag *auth_user)
{
  struct _client_tag *client = auth_user->client;
  struct auth_tag *auth = client->auth;
  struct anonymous_33 *url = (struct anonymous_33 *)auth->state;
  signed long int duration;
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  duration = return_value_time_1 - client->con->con_time;
  char *username;
  char *password;
  char *mount;
  char *server;
  const char *mountreq;
  struct ice_config_tag *config;
  signed int port;
  char *userpwd = (char *)(void *)0;
  char post[4096l];
  const char *agent;
  char *user_agent;
  char *ipaddr;
  _Bool tmp_if_expr_5;
  if(url->removeurl == ((char *)NULL))
    return (enum anonymous_19)AUTH_OK;

  else
  {
    config=config_get_config();
    server=util_url_escape(config->hostname);
    port = config->port;
    config_release_config();
    agent=httpp_getvar(client->parser, "user-agent");
    if(!(agent == ((const char *)NULL)))
      user_agent=util_url_escape(agent);

    else
      user_agent=strdup("-");
    if(!(client->username == ((char *)NULL)))
      username=util_url_escape(client->username);

    else
      username=strdup("");
    if(!(client->password == ((char *)NULL)))
      password=util_url_escape(client->password);

    else
      password=strdup("");
    mountreq=httpp_getvar(client->parser, "__rawuri");
    if(mountreq == ((const char *)NULL))
      mountreq=httpp_getvar(client->parser, "__uri");

    mount=util_url_escape(mountreq);
    ipaddr=util_url_escape(client->con->ip);
    snprintf(post, sizeof(char [4096l]) /*4096ul*/ , "action=listener_remove&server=%s&port=%d&client=%lu&mount=%s&user=%s&pass=%s&duration=%lu&ip=%s&agent=%s", server, port, client->con->id, mount, username, password, (unsigned long int)duration, ipaddr, user_agent);
    free((void *)server);
    free((void *)mount);
    free((void *)username);
    free((void *)password);
    free((void *)ipaddr);
    free((void *)user_agent);
    char *return_value_strchr_6;
    return_value_strchr_6=strchr(url->removeurl, 64);
    if(return_value_strchr_6 == ((char *)NULL))
    {
      if(!(url->userpwd == ((char *)NULL)))
      {
        signed int url_remove_listener__1__1__1___curl_opt = CURLOPT_USERPWD;
        curl_easy_setopt(url->handle, (enum anonymous_32)url_remove_listener__1__1__1___curl_opt, url->userpwd);
      }

      else
      {
        if(!(client->username == ((char *)NULL)))
          tmp_if_expr_5 = client->password != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
        {
          unsigned long int len;
          unsigned long int return_value_strlen_2;
          return_value_strlen_2=strlen(client->username);
          unsigned long int return_value_strlen_3;
          return_value_strlen_3=strlen(client->password);
          len = return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)2;
          void *return_value_malloc_4;
          return_value_malloc_4=malloc(len);
          userpwd = (char *)return_value_malloc_4;
          snprintf(userpwd, len, "%s:%s", client->username, client->password);
          signed int url_remove_listener__1__1__2__1__1___curl_opt = CURLOPT_USERPWD;
          curl_easy_setopt(url->handle, (enum anonymous_32)url_remove_listener__1__1__2__1__1___curl_opt, userpwd);
        }

        else
        {
          signed int url_remove_listener__1__1__2__2___curl_opt = CURLOPT_USERPWD;
          curl_easy_setopt(url->handle, (enum anonymous_32)url_remove_listener__1__1__2__2___curl_opt, (const void *)"");
        }
      }
    }

    else
    {
      signed int _curl_opt = CURLOPT_USERPWD;
      curl_easy_setopt(url->handle, (enum anonymous_32)_curl_opt, (const void *)"");
    }
    signed int url_remove_listener__1__3___curl_opt = CURLOPT_URL;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_remove_listener__1__3___curl_opt, url->removeurl);
    signed int url_remove_listener__1__4___curl_opt = CURLOPT_POSTFIELDS;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_remove_listener__1__4___curl_opt, (const void *)post);
    signed int url_remove_listener__1__5___curl_opt = CURLOPT_HEADERDATA;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_remove_listener__1__5___curl_opt, auth_user);
    enum anonymous_34 return_value_curl_easy_perform_7;
    return_value_curl_easy_perform_7=curl_easy_perform(url->handle);
    if(!(return_value_curl_easy_perform_7 == /*enum*/CURLE_OK))
      log_write(errorlog, (unsigned int)2, "auth_url/", "url_remove_listener", "auth to server %s failed with %s", url->removeurl, (const void *)url->errormsg);

    free((void *)userpwd);
    return (enum anonymous_19)AUTH_OK;
  }
}

// url_stream_auth
// file auth_url.c line 514
static void url_stream_auth(struct auth_client_tag *auth_user)
{
  struct ice_config_tag *config;
  signed int port;
  struct _client_tag *client = auth_user->client;
  struct anonymous_33 *url = (struct anonymous_33 *)client->auth->state;
  char *mount;
  char *host;
  char *user;
  char *pass;
  char *ipaddr;
  char *admin = "";
  char post[4096l];
  char *return_value_strchr_1;
  return_value_strchr_1=strchr(url->stream_auth, 64);
  if(return_value_strchr_1 == ((char *)NULL))
  {
    if(!(url->userpwd == ((char *)NULL)))
    {
      signed int _curl_opt = CURLOPT_USERPWD;
      curl_easy_setopt(url->handle, (enum anonymous_32)_curl_opt, url->userpwd);
    }

    else
    {
      signed int url_stream_auth__1__1__2___curl_opt = CURLOPT_USERPWD;
      curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_auth__1__1__2___curl_opt, (const void *)"");
    }
  }

  else
  {
    signed int url_stream_auth__1__2___curl_opt = CURLOPT_USERPWD;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_auth__1__2___curl_opt, (const void *)"");
  }
  signed int url_stream_auth__1__3___curl_opt = CURLOPT_URL;
  curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_auth__1__3___curl_opt, url->stream_auth);
  signed int url_stream_auth__1__4___curl_opt = CURLOPT_POSTFIELDS;
  curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_auth__1__4___curl_opt, (const void *)post);
  signed int url_stream_auth__1__5___curl_opt = CURLOPT_HEADERDATA;
  curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_auth__1__5___curl_opt, auth_user);
  const char *return_value_httpp_getvar_2;
  return_value_httpp_getvar_2=httpp_getvar(client->parser, "__uri");
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(auth_user->mount, return_value_httpp_getvar_2);
  if(!(return_value_strcmp_3 == 0))
    admin = "&admin=1";

  mount=util_url_escape(auth_user->mount);
  config=config_get_config();
  host=util_url_escape(config->hostname);
  port = config->port;
  config_release_config();
  ipaddr=util_url_escape(client->con->ip);
  if(!(client->username == ((char *)NULL)))
    user=util_url_escape(client->username);

  else
    user=strdup("");
  if(!(client->password == ((char *)NULL)))
    pass=util_url_escape(client->password);

  else
    pass=strdup("");
  snprintf(post, sizeof(char [4096l]) /*4096ul*/ , "action=stream_auth&mount=%s&ip=%s&server=%s&port=%d&user=%s&pass=%s%s", mount, ipaddr, host, port, user, pass, admin);
  free((void *)ipaddr);
  free((void *)user);
  free((void *)pass);
  free((void *)mount);
  free((void *)host);
  client->authenticated = 0;
  enum anonymous_34 return_value_curl_easy_perform_4;
  return_value_curl_easy_perform_4=curl_easy_perform(url->handle);
  if(!(return_value_curl_easy_perform_4 == /*enum*/CURLE_OK))
    log_write(errorlog, (unsigned int)2, "auth_url/", "url_stream_auth", "auth to server %s failed with %s", url->stream_auth, (const void *)url->errormsg);

}

// url_stream_end
// file auth_url.c line 463
static void url_stream_end(struct auth_client_tag *auth_user)
{
  char *mount;
  char *server;
  struct ice_config_tag *config;
  config=config_get_config();
  struct _mount_proxy *mountinfo;
  mountinfo=config_find_mount(config, auth_user->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
  struct auth_tag *auth = mountinfo->auth;
  struct anonymous_33 *url = (struct anonymous_33 *)auth->state;
  char *stream_end_url;
  signed int port;
  char post[4096l];
  if(url->stream_end == ((char *)NULL))
    config_release_config();

  else
  {
    server=util_url_escape(config->hostname);
    port = config->port;
    stream_end_url=strdup(url->stream_end);
    mountinfo->auth->refcount = mountinfo->auth->refcount + 1;
    config_release_config();
    mount=util_url_escape(auth_user->mount);
    snprintf(post, sizeof(char [4096l]) /*4096ul*/ , "action=mount_remove&mount=%s&server=%s&port=%d", mount, server, port);
    free((void *)server);
    free((void *)mount);
    char *return_value_strchr_1;
    return_value_strchr_1=strchr(url->stream_end, 64);
    if(return_value_strchr_1 == ((char *)NULL))
    {
      if(!(url->userpwd == ((char *)NULL)))
      {
        signed int url_stream_end__1__2__1___curl_opt = CURLOPT_USERPWD;
        curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_end__1__2__1___curl_opt, url->userpwd);
      }

      else
      {
        signed int _curl_opt = CURLOPT_USERPWD;
        curl_easy_setopt(url->handle, (enum anonymous_32)_curl_opt, (const void *)"");
      }
    }

    else
    {
      signed int url_stream_end__1__3___curl_opt = CURLOPT_USERPWD;
      curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_end__1__3___curl_opt, (const void *)"");
    }
    signed int url_stream_end__1__4___curl_opt = CURLOPT_URL;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_end__1__4___curl_opt, url->stream_end);
    signed int url_stream_end__1__5___curl_opt = CURLOPT_POSTFIELDS;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_end__1__5___curl_opt, (const void *)post);
    signed int url_stream_end__1__6___curl_opt = CURLOPT_HEADERDATA;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_end__1__6___curl_opt, auth_user);
    enum anonymous_34 return_value_curl_easy_perform_2;
    return_value_curl_easy_perform_2=curl_easy_perform(url->handle);
    if(!(return_value_curl_easy_perform_2 == /*enum*/CURLE_OK))
      log_write(errorlog, (unsigned int)2, "auth_url/", "url_stream_end", "auth to server %s failed with %s", stream_end_url, (const void *)url->errormsg);

    auth_release(auth);
    free((void *)stream_end_url);
    goto __CPROVER_DUMP_L127;
  }

__CPROVER_DUMP_L127:
  ;
}

// url_stream_start
// file auth_url.c line 411
static void url_stream_start(struct auth_client_tag *auth_user)
{
  char *mount;
  char *server;
  struct ice_config_tag *config;
  config=config_get_config();
  struct _mount_proxy *mountinfo;
  mountinfo=config_find_mount(config, auth_user->mount, (enum _mount_type)MOUNT_TYPE_NORMAL);
  struct auth_tag *auth = mountinfo->auth;
  struct anonymous_33 *url = (struct anonymous_33 *)auth->state;
  char *stream_start_url;
  signed int port;
  char post[4096l];
  if(url->stream_start == ((char *)NULL))
    config_release_config();

  else
  {
    server=util_url_escape(config->hostname);
    port = config->port;
    stream_start_url=strdup(url->stream_start);
    mountinfo->auth->refcount = mountinfo->auth->refcount + 1;
    config_release_config();
    mount=util_url_escape(auth_user->mount);
    snprintf(post, sizeof(char [4096l]) /*4096ul*/ , "action=mount_add&mount=%s&server=%s&port=%d", mount, server, port);
    free((void *)server);
    free((void *)mount);
    char *return_value_strchr_1;
    return_value_strchr_1=strchr(url->stream_start, 64);
    if(return_value_strchr_1 == ((char *)NULL))
    {
      if(!(url->userpwd == ((char *)NULL)))
      {
        signed int url_stream_start__1__2__1___curl_opt = CURLOPT_USERPWD;
        curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_start__1__2__1___curl_opt, url->userpwd);
      }

      else
      {
        signed int url_stream_start__1__2__2___curl_opt = CURLOPT_USERPWD;
        curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_start__1__2__2___curl_opt, (const void *)"");
      }
    }

    else
    {
      signed int url_stream_start__1__3___curl_opt = CURLOPT_USERPWD;
      curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_start__1__3___curl_opt, (const void *)"");
    }
    signed int url_stream_start__1__4___curl_opt = CURLOPT_URL;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_start__1__4___curl_opt, stream_start_url);
    signed int url_stream_start__1__5___curl_opt = CURLOPT_POSTFIELDS;
    curl_easy_setopt(url->handle, (enum anonymous_32)url_stream_start__1__5___curl_opt, (const void *)post);
    signed int _curl_opt = CURLOPT_HEADERDATA;
    curl_easy_setopt(url->handle, (enum anonymous_32)_curl_opt, auth_user);
    enum anonymous_34 return_value_curl_easy_perform_2;
    return_value_curl_easy_perform_2=curl_easy_perform(url->handle);
    if(!(return_value_curl_easy_perform_2 == /*enum*/CURLE_OK))
      log_write(errorlog, (unsigned int)2, "auth_url/", "url_stream_start", "auth to server %s failed with %s", stream_start_url, (const void *)url->errormsg);

    auth_release(auth);
    free((void *)stream_start_url);
    goto __CPROVER_DUMP_L127;
  }

__CPROVER_DUMP_L127:
  ;
}

// util_base64_decode
// file util.h line 33
char * util_base64_decode(const char *data)
{
  const unsigned char *input = (const unsigned char *)data;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(data);
  len = (signed int)return_value_strlen_1;
  char *out;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)((len * 3) / 4 + 5));
  out = (char *)return_value_malloc_2;
  char *result = out;
  signed char vals[4l];
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  char *tmp_post_10;
  char *tmp_post_11;
  char *tmp_post_12;
  char *tmp_post_13;
  char *tmp_post_14;
  while(len >= 1)
  {
    if(!(len >= 4))
    {
      free((void *)result);
      return (char *)(void *)0;
    }

    tmp_post_3 = input;
    input = input + 1l;
    vals[(signed long int)0] = base64decode[(signed long int)*tmp_post_3];
    tmp_post_4 = input;
    input = input + 1l;
    vals[(signed long int)1] = base64decode[(signed long int)*tmp_post_4];
    tmp_post_5 = input;
    input = input + 1l;
    vals[(signed long int)2] = base64decode[(signed long int)*tmp_post_5];
    tmp_post_6 = input;
    input = input + 1l;
    vals[(signed long int)3] = base64decode[(signed long int)*tmp_post_6];
    if(!((signed int)vals[0l] >= 0))
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (signed int)vals[(signed long int)1] < 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = (signed int)vals[(signed long int)2] < -1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
      tmp_if_expr_9 = (_Bool)1;

    else
      tmp_if_expr_9 = (signed int)vals[(signed long int)3] < -1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_9)
      len = len - 4;

    else
    {
      tmp_post_10 = out;
      out = out + 1l;
      *tmp_post_10 = (char)((signed int)vals[(signed long int)0] << 2 | (signed int)vals[(signed long int)1] >> 4);
      if((signed int)vals[2l] >= 0)
      {
        tmp_post_11 = out;
        out = out + 1l;
        *tmp_post_11 = (char)(((signed int)vals[(signed long int)1] & 0x0F) << 4 | (signed int)vals[(signed long int)2] >> 2);
      }

      else
      {
        tmp_post_12 = out;
        out = out + 1l;
        *tmp_post_12 = (char)0;
      }
      if((signed int)vals[3l] >= 0)
      {
        tmp_post_13 = out;
        out = out + 1l;
        *tmp_post_13 = (char)(((signed int)vals[(signed long int)2] & 0x03) << 6 | (signed int)vals[(signed long int)3]);
      }

      else
      {
        tmp_post_14 = out;
        out = out + 1l;
        *tmp_post_14 = (char)0;
      }
      len = len - 4;
    }
  }
  *out = (char)0;
  return result;
}

// util_base64_encode
// file util.c line 414
char * util_base64_encode(const char *data)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(data);
  len = (signed int)return_value_strlen_1;
  char *out;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)((len * 4) / 3 + 4));
  out = (char *)return_value_malloc_2;
  char *result = out;
  signed int chunk;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_8;
  char *tmp_post_9;
  char *tmp_post_10;
  for( ; len >= 1; len = len - chunk)
  {
    chunk = len > 3 ? 3 : len;
    tmp_post_3 = out;
    out = out + 1l;
    *tmp_post_3 = base64table[(signed long int)(((signed int)*data & 0xFC) >> 2)];
    tmp_post_4 = out;
    out = out + 1l;
    *tmp_post_4 = base64table[(signed long int)(((signed int)*data & 0x03) << 4 | ((signed int)data[(signed long int)1] & 0xF0) >> 4)];
    switch(chunk)
    {
      case 3:
      {
        tmp_post_5 = out;
        out = out + 1l;
        *tmp_post_5 = base64table[(signed long int)(((signed int)data[(signed long int)1] & 0x0F) << 2 | ((signed int)data[(signed long int)2] & 0xC0) >> 6)];
        tmp_post_6 = out;
        out = out + 1l;
        *tmp_post_6 = base64table[(signed long int)((signed int)data[(signed long int)2] & 0x3F)];
        break;
      }
      case 2:
      {
        tmp_post_7 = out;
        out = out + 1l;
        *tmp_post_7 = base64table[(signed long int)(((signed int)data[(signed long int)1] & 0x0F) << 2)];
        tmp_post_8 = out;
        out = out + 1l;
        *tmp_post_8 = (char)61;
        break;
      }
      case 1:
      {
        tmp_post_9 = out;
        out = out + 1l;
        *tmp_post_9 = (char)61;
        tmp_post_10 = out;
        out = out + 1l;
        *tmp_post_10 = (char)61;
      }
    }
    data = data + (signed long int)chunk;
  }
  *out = (char)0;
  return result;
}

// util_bin_to_hex
// file util.c line 398
char * util_bin_to_hex(unsigned char *data, signed int len)
{
  char *util_bin_to_hex__1__hex;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(len * 2 + 1));
  util_bin_to_hex__1__hex = (char *)return_value_malloc_1;
  signed int i = 0;
  for( ; !(i >= len); i = i + 1)
  {
    util_bin_to_hex__1__hex[(signed long int)(i * 2)] = hexchars[(signed long int)(((signed int)data[(signed long int)i] & 0xf0) >> 4)];
    util_bin_to_hex__1__hex[(signed long int)(i * 2 + 1)] = hexchars[(signed long int)((signed int)data[(signed long int)i] & 0x0f)];
  }
  util_bin_to_hex__1__hex[(signed long int)(len * 2)] = (char)0;
  return util_bin_to_hex__1__hex;
}

// util_check_valid_extension
// file util.c line 145
signed int util_check_valid_extension(const char *uri)
{
  signed int ret = 0;
  char *p2;
  if(!(uri == ((const char *)NULL)))
  {
    p2=strrchr(uri, 46);
    if(!(p2 == ((char *)NULL)))
    {
      p2 = p2 + 1l;
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen("xsl");
      signed int return_value_strncmp_2;
      return_value_strncmp_2=strncmp(p2, "xsl", return_value_strlen_1);
      if(return_value_strncmp_2 == 0)
        ret = 1;

      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen("htm");
      signed int return_value_strncmp_4;
      return_value_strncmp_4=strncmp(p2, "htm", return_value_strlen_3);
      if(return_value_strncmp_4 == 0)
        ret = 2;

      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen("html");
      signed int return_value_strncmp_6;
      return_value_strncmp_6=strncmp(p2, "html", return_value_strlen_5);
      if(return_value_strncmp_6 == 0)
        ret = 2;

    }

  }

  return ret;
}

// util_conv_string
// file util.c line 804
char * util_conv_string(const char *string, const char *in_charset, const char *out_charset)
{
  struct _xmlCharEncodingHandler *in;
  struct _xmlCharEncodingHandler *out;
  char *ret = (char *)(void *)0;
  const unsigned char *return_value_xmlBufferContent_1;
  if(in_charset == ((const char *)NULL) || out_charset == ((const char *)NULL) || string == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    in=xmlFindCharEncodingHandler(in_charset);
    out=xmlFindCharEncodingHandler(out_charset);
    if(!(in == ((struct _xmlCharEncodingHandler *)NULL)) && !(out == ((struct _xmlCharEncodingHandler *)NULL)))
    {
      struct _xmlBuffer *orig;
      orig=xmlBufferCreate();
      struct _xmlBuffer *utf8;
      utf8=xmlBufferCreate();
      struct _xmlBuffer *conv;
      conv=xmlBufferCreate();
      log_write(errorlog, (unsigned int)3, "util/", "util_conv_string", "converting metadata from %s to %s", in_charset, out_charset);
      xmlBufferCCat(orig, string);
      signed int return_value_xmlCharEncInFunc_3;
      return_value_xmlCharEncInFunc_3=xmlCharEncInFunc(in, utf8, orig);
      if(return_value_xmlCharEncInFunc_3 >= 1)
      {
        xmlCharEncOutFunc(out, conv, (struct _xmlBuffer *)(void *)0);
        signed int return_value_xmlCharEncOutFunc_2;
        return_value_xmlCharEncOutFunc_2=xmlCharEncOutFunc(out, conv, utf8);
        if(return_value_xmlCharEncOutFunc_2 >= 0)
        {
          return_value_xmlBufferContent_1=xmlBufferContent(conv);
          ret=strdup((const char *)return_value_xmlBufferContent_1);
        }

      }

      xmlBufferFree(orig);
      xmlBufferFree(utf8);
      xmlBufferFree(conv);
    }

    xmlCharEncCloseFunc(in);
    xmlCharEncCloseFunc(out);
    return ret;
  }
}

// util_dict_free
// file util.c line 656
void util_dict_free(struct _util_dict *dict)
{
  struct _util_dict *next;
  for( ; !(dict == ((struct _util_dict *)NULL)); dict = next)
  {
    next = dict->next;
    if(!(dict->key == ((char *)NULL)))
      free((void *)dict->key);

    if(!(dict->val == ((char *)NULL)))
      free((void *)dict->val);

    free((void *)dict);
  }
}

// util_dict_get
// file util.c line 673
const char * util_dict_get(struct _util_dict *dict, const char *key)
{
  while(!(dict == ((struct _util_dict *)NULL)))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(key, dict->key);
    if(return_value_strcmp_1 == 0)
      return dict->val;

    dict = dict->next;
  }
  return (const char *)(void *)0;
}

// util_dict_new
// file util.c line 651
struct _util_dict * util_dict_new(void)
{
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _util_dict) /*24ul*/ );
  return (struct _util_dict *)return_value_calloc_1;
}

// util_dict_set
// file util.c line 683
signed int util_dict_set(struct _util_dict *dict, const char *key, const char *val)
{
  struct _util_dict *prev;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(key == ((const char *)NULL) || dict == ((struct _util_dict *)NULL))
  {
    log_write(errorlog, (unsigned int)1, "util/", "util_dict_set", "NULL values passed to util_dict_set()");
    return 0;
  }

  else
  {
    prev = (struct _util_dict *)(void *)0;
    while(!(dict == ((struct _util_dict *)NULL)))
    {
      if(dict->key == ((char *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        return_value_strcmp_1=strcmp(dict->key, key);
        tmp_if_expr_2 = !(return_value_strcmp_1 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        break;

      prev = dict;
      dict = dict->next;
    }
    if(dict == ((struct _util_dict *)NULL))
    {
      dict=util_dict_new();
      if(dict == ((struct _util_dict *)NULL))
      {
        log_write(errorlog, (unsigned int)1, "util/", "util_dict_set", "unable to allocate new dictionary");
        return 0;
      }

      if(!(prev == ((struct _util_dict *)NULL)))
        prev->next = dict;

    }

    if(!(dict->key == ((char *)NULL)))
      free((void *)dict->val);

    else
    {
      dict->key=strdup(key);
      if(dict->key == ((char *)NULL))
      {
        if(!(prev == ((struct _util_dict *)NULL)))
          prev->next = (struct _util_dict *)(void *)0;

        util_dict_free(dict);
        log_write(errorlog, (unsigned int)1, "util/", "util_dict_set", "unable to allocate new dictionary key");
        return 0;
      }

    }
    dict->val=strdup(val);
    if(dict->val == ((char *)NULL))
    {
      log_write(errorlog, (unsigned int)1, "util/", "util_dict_set", "unable to allocate new dictionary value");
      return 0;
    }

    else
      return 1;
  }
}

// util_dict_urlencode
// file util.c line 734
char * util_dict_urlencode(struct _util_dict *dict, char delim)
{
  char *res;
  char *tmp;
  char *enc;
  signed int start = 1;
  res = (char *)(void *)0;
  for( ; !(dict == ((struct _util_dict *)NULL)); dict = dict->next)
    if(!(dict->key == ((char *)NULL)))
    {
      if(!(start == 0))
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(dict->key);
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)1);
        res = (char *)return_value_malloc_2;
        if(res == ((char *)NULL))
          return (char *)(void *)0;

        sprintf(res, "%s", dict->key);
        start = 0;
      }

      else
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(res);
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(dict->key);
        void *return_value_realloc_5;
        return_value_realloc_5=realloc((void *)res, return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)2);
        tmp = (char *)return_value_realloc_5;
        if(tmp == ((char *)NULL))
        {
          free((void *)res);
          return (char *)(void *)0;
        }

        else
          res = tmp;
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(res);
        sprintf(res + (signed long int)return_value_strlen_6, "%c%s", delim, dict->key);
      }
      if(!(dict->val == ((char *)NULL)))
      {
        enc=util_url_escape(dict->val);
        if(enc == ((char *)NULL))
        {
          free((void *)res);
          return (char *)(void *)0;
        }

        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen(res);
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen(enc);
        void *return_value_realloc_9;
        return_value_realloc_9=realloc((void *)res, return_value_strlen_7 + return_value_strlen_8 + (unsigned long int)2);
        tmp = (char *)return_value_realloc_9;
        if(tmp == ((char *)NULL))
        {
          free((void *)enc);
          free((void *)res);
          return (char *)(void *)0;
        }

        else
          res = tmp;
        unsigned long int return_value_strlen_10;
        return_value_strlen_10=strlen(res);
        sprintf(res + (signed long int)return_value_strlen_10, "=%s", enc);
        free((void *)enc);
      }

    }

  return res;
}

// util_get_extension
// file util.c line 136
char * util_get_extension(const char *path)
{
  char *ext;
  ext=strrchr(path, 46);
  if(ext == ((char *)NULL))
    return "";

  else
    return ext + (signed long int)1;
}

// util_get_path_from_normalised_uri
// file util.c line 230
char * util_get_path_from_normalised_uri(const char *uri)
{
  char *fullpath;
  char *webroot;
  struct ice_config_tag *config;
  config=config_get_config();
  webroot = config->webroot_dir;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(uri);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(webroot);
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)1);
  fullpath = (char *)return_value_malloc_3;
  if(!(fullpath == ((char *)NULL)))
    sprintf(fullpath, "%s%s", webroot, uri);

  config_release_config();
  return fullpath;
}

// util_get_path_from_uri
// file util.c line 217
char * util_get_path_from_uri(char *uri)
{
  char *path;
  path=util_normalise_uri(uri);
  char *fullpath;
  if(path == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    fullpath=util_get_path_from_normalised_uri(path);
    free((void *)path);
    return fullpath;
  }
}

// util_http_build_header
// file util.c line 552
signed long int util_http_build_header(char *out, unsigned long int len, signed long int offset, signed int cache, signed int status, const char *statusmsg, const char *contenttype, const char *charset, const char *datablock, struct source_tag *source)
{
  const char *http_version = "1.0";
  struct ice_config_tag *config;
  signed long int util_http_build_header__1__now;
  struct tm result;
  struct tm *gmtime_result;
  char currenttime_buffer[80l];
  char status_buffer[80l];
  char contenttype_buffer[80l];
  signed long int ret;
  char *extra_headers;
  unsigned long int return_value_strlen_1;
  if(out == ((char *)NULL))
    return (signed long int)-1;

  else
  {
    if(offset == -1l)
    {
      return_value_strlen_1=strlen(out);
      offset = (signed long int)return_value_strlen_1;
    }

    out = out + offset;
    len = len - (unsigned long int)offset;
    if(status == -1)
      status_buffer[(signed long int)0] = (char)0;

    else
    {
      if(statusmsg == ((const char *)NULL))
        switch(status)
        {
          case 200:
          {
            statusmsg = "OK";
            break;
          }
          case 206:
          {
            statusmsg = "Partial Content";
            http_version = "1.1";
            break;
          }
          case 400:
          {
            statusmsg = "Bad Request";
            break;
          }
          case 401:
          {
            statusmsg = "Authentication Required";
            break;
          }
          case 403:
          {
            statusmsg = "Forbidden";
            break;
          }
          case 404:
          {
            statusmsg = "File Not Found";
            break;
          }
          case 416:
          {
            statusmsg = "Request Range Not Satisfiable";
            break;
          }
          default:
            statusmsg = "(unknown status code)";
        }

      snprintf(status_buffer, sizeof(char [80l]) /*80ul*/ , "HTTP/%s %d %s\r\n", http_version, status, statusmsg);
    }
    if(!(contenttype == ((const char *)NULL)))
    {
      if(!(charset == ((const char *)NULL)))
        snprintf(contenttype_buffer, sizeof(char [80l]) /*80ul*/ , "Content-Type: %s; charset=%s\r\n", contenttype, charset);

      else
        snprintf(contenttype_buffer, sizeof(char [80l]) /*80ul*/ , "Content-Type: %s\r\n", contenttype);
    }

    else
      contenttype_buffer[(signed long int)0] = (char)0;
    time(&util_http_build_header__1__now);
    gmtime_result=gmtime_r(&util_http_build_header__1__now, &result);
    if(!(gmtime_result == ((struct tm *)NULL)))
      strftime(currenttime_buffer, sizeof(char [80l]) /*80ul*/ , "Date: %a, %d %b %Y %X GMT\r\n", gmtime_result);

    else
      currenttime_buffer[(signed long int)0] = (char)0;
    config=config_get_config();
    extra_headers=_build_headers(status, config, source);
    signed int return_value_snprintf_2;
    return_value_snprintf_2=snprintf(out, len, "%sServer: %s\r\n%s%s%s%s%s%s%s", (const void *)status_buffer, config->server_id, (const void *)currenttime_buffer, (const void *)contenttype_buffer, status == 401 ? "WWW-Authenticate: Basic realm=\"Icecast2 Server\"\r\n" : "", cache != 0 ? "" : "Cache-Control: no-cache\r\nExpires: Mon, 26 Jul 1997 05:00:00 GMT\r\nPragma: no-cache\r\n", extra_headers, datablock != ((const char *)NULL) ? "\r\n" : "", datablock != ((const char *)NULL) ? datablock : "");
    ret = (signed long int)return_value_snprintf_2;
    free((void *)extra_headers);
    config_release_config();
    return ret;
  }
}

// util_normalise_uri
// file util.h line 31
char * util_normalise_uri(const char *uri)
{
  char *path;
  if(!((signed int)*uri == 47))
    return (char *)(void *)0;

  else
  {
    path=util_url_unescape(uri);
    if(path == ((char *)NULL))
    {
      log_write(errorlog, (unsigned int)2, "util/", "util_normalise_uri", "Error decoding URI: %s\n", uri);
      return (char *)(void *)0;
    }

    else
    {
      signed int return_value_verify_path_1;
      return_value_verify_path_1=verify_path(path);
      if(!(return_value_verify_path_1 == 0))
        return path;

      else
      {
        log_write(errorlog, (unsigned int)2, "util/", "util_normalise_uri", "Rejecting invalid path \"%s\"", path);
        free((void *)path);
        return (char *)(void *)0;
      }
    }
  }
}

// util_read_header
// file util.c line 89
signed int util_read_header(signed int sock, char *buff, unsigned long int len, signed int entire)
{
  signed int read_bytes;
  signed int ret;
  unsigned long int pos;
  char c;
  struct ice_config_tag *config;
  signed int header_timeout;
  config=config_get_config();
  header_timeout = config->header_timeout;
  config_release_config();
  read_bytes = 1;
  pos = (unsigned long int)0;
  ret = 0;
  unsigned long int tmp_post_1;
  while(read_bytes == 1 && !(pos >= len + 18446744073709551615ul))
  {
    read_bytes = 0;
    signed int return_value_util_timed_wait_for_fd_3;
    return_value_util_timed_wait_for_fd_3=util_timed_wait_for_fd(sock, header_timeout * 1000);
    if(return_value_util_timed_wait_for_fd_3 >= 1)
    {
      signed long int return_value_recv_2;
      return_value_recv_2=recv(sock, (void *)&c, (unsigned long int)1, 0);
      read_bytes = (signed int)return_value_recv_2;
      if(!(read_bytes == 0))
      {
        if(!((signed int)c == 13))
        {
          tmp_post_1 = pos;
          pos = pos + 1ul;
          buff[(signed long int)tmp_post_1] = c;
        }

        if(!(entire == 0))
        {
          if(pos >= 2ul)
          {
            if((signed int)buff[-1l + (signed long int)pos] == 10)
            {
              if((signed int)buff[-2l + (signed long int)pos] == 10)
              {
                ret = 1;
                break;
              }

            }

          }

        }

        else
          if(pos >= 2ul)
          {
            if((signed int)buff[-1l + (signed long int)pos] == 10)
            {
              ret = 1;
              break;
            }

          }

      }

    }

    else
      break;
  }
  if(!(ret == 0))
    buff[(signed long int)pos] = (char)0;

  return ret;
}

// util_timed_wait_for_fd
// file util.c line 63
signed int util_timed_wait_for_fd(signed int fd, signed int timeout)
{
  struct pollfd util_timed_wait_for_fd__1__ufds;
  util_timed_wait_for_fd__1__ufds.fd = fd;
  util_timed_wait_for_fd__1__ufds.events = (signed short int)0x001;
  util_timed_wait_for_fd__1__ufds.revents = (signed short int)0;
  signed int return_value_poll_1;
  return_value_poll_1=poll(&util_timed_wait_for_fd__1__ufds, (unsigned long int)1, timeout);
  return return_value_poll_1;
}

// util_url_escape
// file util.c line 268
char * util_url_escape(const char *src)
{
  unsigned long int len;
  char *dst;
  unsigned char *source = (unsigned char *)src;
  unsigned long int i;
  unsigned long int j;
  unsigned long int tmp_post_2;
  unsigned long int tmp_post_3;
  unsigned long int tmp_post_4;
  unsigned long int tmp_post_5;
  if(src == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    len=strlen(src);
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)1, len * (unsigned long int)3 + (unsigned long int)1);
    dst = (char *)return_value_calloc_1;
    i = (unsigned long int)0;
    j = (unsigned long int)0;
    for( ; !(i >= len); i = i + 1ul)
      if(!(safechars[(signed long int)source[(signed long int)i]] == 0))
      {
        tmp_post_2 = j;
        j = j + 1ul;
        dst[(signed long int)tmp_post_2] = (char)source[(signed long int)i];
      }

      else
      {
        tmp_post_3 = j;
        j = j + 1ul;
        dst[(signed long int)tmp_post_3] = (char)37;
        tmp_post_4 = j;
        j = j + 1ul;
        dst[(signed long int)tmp_post_4] = hexchars[(signed long int)((signed int)source[(signed long int)i] >> 4 & 0x0F)];
        tmp_post_5 = j;
        j = j + 1ul;
        dst[(signed long int)tmp_post_5] = hexchars[(signed long int)((signed int)source[(signed long int)i] & 0x0F)];
      }
    dst[(signed long int)j] = (char)0;
    return dst;
  }
}

// util_url_unescape
// file util.c line 296
char * util_url_unescape(const char *src)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(src);
  len = (signed int)return_value_strlen_1;
  char *decoded;
  signed int i;
  char *dst;
  signed int done = 0;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, (unsigned long int)(len + 1));
  decoded = (char *)return_value_calloc_2;
  dst = decoded;
  i = 0;
  signed int return_value_hex_3;
  _Bool tmp_if_expr_5;
  signed int return_value_hex_4;
  char *tmp_post_6;
  signed int return_value_hex_7;
  signed int return_value_hex_8;
  char *tmp_post_9;
  for( ; !(i >= len); i = i + 1)
  {
    switch((signed int)src[(signed long int)i])
    {
      case 37:
      {
        if(2 + i >= len)
        {
          free((void *)decoded);
          return (char *)(void *)0;
        }

        return_value_hex_3=hex(src[(signed long int)(i + 1)]);
        if(return_value_hex_3 == -1)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_hex_4=hex(src[(signed long int)(i + 2)]);
          tmp_if_expr_5 = return_value_hex_4 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
        {
          free((void *)decoded);
          return (char *)(void *)0;
        }

        tmp_post_6 = dst;
        dst = dst + 1l;
        return_value_hex_7=hex(src[(signed long int)(i + 1)]);
        return_value_hex_8=hex(src[(signed long int)(i + 2)]);
        *tmp_post_6 = (char)(return_value_hex_7 * 16 + return_value_hex_8);
        i = i + 2;
        break;
      }
      case 35:
      {
        done = 1;
        break;
      }
      case 0:
      {
        log_write(errorlog, (unsigned int)1, "util/", "util_url_unescape", "Fatal internal logic error in util_url_unescape()");
        free((void *)decoded);
        return (char *)(void *)0;
      }
      default:
      {
        tmp_post_9 = dst;
        dst = dst + 1l;
        *tmp_post_9 = src[(signed long int)i];
      }
    }
    if(!(done == 0))
      break;

  }
  *dst = (char)0;
  return decoded;
}

// verify_path
// file util.c line 189
static signed int verify_path(char *path)
{
  signed int dir = 0;
  signed int indotseq = 0;
  _Bool tmp_if_expr_1;
  while(!(*path == 0))
  {
    if((signed int)*path == 47)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*path == 92 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(!(indotseq == 0))
        return 0;

      if(!(dir == 0))
        return 0;

      dir = 1;
      path = path + 1l;
    }

    else
    {
      if(!(dir == 0) || !(indotseq == 0))
      {
        if((signed int)*path == 46)
          indotseq = 1;

        else
          indotseq = 0;
      }

      dir = 0;
      path = path + 1l;
    }
  }
  return 1;
}

// vorbis_codec_free
// file format_vorbis.c line 83
static void vorbis_codec_free(struct ogg_state_tag *ogg_info, struct ogg_codec_tag *codec)
{
  struct vorbis_codec_tag *vorbis = (struct vorbis_codec_tag *)codec->specific;
  log_write(errorlog, (unsigned int)4, "format-vorbis/", "vorbis_codec_free", "freeing vorbis codec");
  stats_event(ogg_info->mount, "audio_bitrate", (const char *)(void *)0);
  stats_event(ogg_info->mount, "audio_channels", (const char *)(void *)0);
  stats_event(ogg_info->mount, "audio_samplerate", (const char *)(void *)0);
  vorbis_info_clear(&vorbis->vi);
  vorbis_comment_clear(&vorbis->vc);
  ogg_stream_clear(&codec->os);
  ogg_stream_clear(&vorbis->new_os);
  free_ogg_packet(vorbis->header[(signed long int)0]);
  free_ogg_packet(vorbis->header[(signed long int)1]);
  free_ogg_packet(vorbis->header[(signed long int)2]);
  free_ogg_packet(vorbis->prev_packet);
  free((void *)vorbis->bos_page.header);
  free((void *)vorbis);
  free((void *)codec);
}

// vorbis_set_tag
// file format_vorbis.c line 419
static void vorbis_set_tag(struct _format_plugin_tag *plugin, const char *tag, const char *in_value, const char *charset)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)plugin->_state;
  struct ogg_codec_tag *codec = ogg_info->codecs;
  struct vorbis_codec_tag *source_vorbis;
  char *value;
  _Bool tmp_if_expr_1;
  if(!(codec == ((struct ogg_codec_tag *)NULL)))
    tmp_if_expr_1 = codec->next == (struct ogg_codec_tag *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    source_vorbis = (struct vorbis_codec_tag *)codec->specific;

  else
    goto __CPROVER_DUMP_L11;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  if(tag == ((const char *)NULL))
  {
    source_vorbis->stream_notify = 1;
    source_vorbis->rebuild_comment = 1;
  }

  else
  {
    value=util_conv_string(in_value, charset, "UTF-8");
    if(value == ((char *)NULL))
      value=strdup(in_value);

    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(tag, "artist");
    if(return_value_strcmp_4 == 0)
    {
      free((void *)ogg_info->artist);
      ogg_info->artist = value;
    }

    else
    {
      return_value_strcmp_3=strcmp(tag, "title");
      if(return_value_strcmp_3 == 0)
      {
        free((void *)ogg_info->title);
        ogg_info->title = value;
      }

      else
      {
        return_value_strcmp_2=strcmp(tag, "song");
        if(return_value_strcmp_2 == 0)
        {
          free((void *)ogg_info->title);
          ogg_info->title = value;
        }

        else
          free((void *)value);
      }
    }
  }

__CPROVER_DUMP_L11:
  ;
}

// wait_for_fds
// file fserve.c line 234
static signed int wait_for_fds(void)
{
  struct _fserve_t *fclient;
  signed int ret;
  while(!(run_fserv == 0))
  {
    if(!(pending_list == ((struct _fserve_t *)NULL)))
    {
      thread_spin_lock(&pending_lock);
      fclient = (struct _fserve_t *)pending_list;
      while(!(fclient == ((struct _fserve_t *)NULL)))
      {
        struct _fserve_t *to_move = fclient;
        fclient = fclient->next;
        to_move->next = active_list;
        active_list = to_move;
        client_tree_changed = 1;
        fserve_clients = fserve_clients + 1u;
      }
      pending_list = (struct _fserve_t *)(void *)0;
      thread_spin_unlock(&pending_lock);
    }

    ret=fserve_client_waiting();
    if(!(ret == 0))
      return ret;

  }
  return -1;
}

// wait_for_serversock
// file connection.c line 447
static signed int wait_for_serversock(signed int timeout)
{
  const signed long int wait_for_serversock_array_size0 = (signed long int)global.server_sockets;
  struct pollfd wait_for_serversock__1__ufds[wait_for_serversock_array_size0];
  signed int i;
  signed int ret;
  i = 0;
  for( ; !(i >= global.server_sockets); i = i + 1)
  {
    wait_for_serversock__1__ufds[(signed long int)i].fd = global.serversock[(signed long int)i];
    wait_for_serversock__1__ufds[(signed long int)i].events = (signed short int)0x001;
    wait_for_serversock__1__ufds[(signed long int)i].revents = (signed short int)0;
  }
  ret=poll(wait_for_serversock__1__ufds, (unsigned long int)global.server_sockets, timeout);
  if(!(ret >= 0))
    return (signed int)-1;

  else
    if(ret == 0)
      return (signed int)-1;

    else
    {
      signed int dst;
      i = 0;
      for( ; !(i >= global.server_sockets); i = i + 1)
      {
        if(!((0x001 & (signed int)wait_for_serversock__1__ufds[(signed long int)i].revents) == 0))
          return wait_for_serversock__1__ufds[(signed long int)i].fd;

        if(!((56 & (signed int)wait_for_serversock__1__ufds[(signed long int)i].revents) == 0))
        {
          if(!((24 & (signed int)wait_for_serversock__1__ufds[(signed long int)i].revents) == 0))
          {
            sock_close(global.serversock[(signed long int)i]);
            log_write(errorlog, (unsigned int)2, "connection/", "wait_for_serversock", "Had to close a listening socket");
          }

          global.serversock[(signed long int)i] = (signed int)-1;
        }

      }
      i = 0;
      dst = 0;
      for( ; !(i >= global.server_sockets); i = i + 1)
        if(!(global.serversock[(signed long int)i] == -1))
        {
          if(!(i == dst))
            global.serversock[(signed long int)dst] = global.serversock[(signed long int)i];

          dst = dst + 1;
        }

      global.server_sockets = dst;
      return (signed int)-1;
    }
}

// write_buf_to_client
// file format_ogg.c line 526
static signed int write_buf_to_client(struct _client_tag *client)
{
  struct _refbuf_tag *refbuf = client->refbuf;
  char *buf = refbuf->data + (signed long int)client->pos;
  unsigned int len = refbuf->len - client->pos;
  struct ogg_client *client_data = (struct ogg_client *)client->format_data;
  signed int ret;
  signed int written = 0;
  do
  {
    if(!(client_data->headers == refbuf->associated))
    {
      ret=send_ogg_headers(client, refbuf->associated);
      if(client_data->headers_sent == 0)
        goto __CPROVER_DUMP_L4;

      written = written + ret;
    }

    ret=client_send_bytes(client, (const void *)buf, len);
    if(ret >= 1)
      client->pos = client->pos + (unsigned int)ret;

    if(!(ret >= (signed int)len))
      break;

    written = written + ret;
    ret = 0;
  }
  while((_Bool)0);

__CPROVER_DUMP_L4:
  ;
  if(ret >= 1)
    written = written + ret;

  return written;
}

// write_mp3_to_file
// file format_mp3.c line 721
static void write_mp3_to_file(struct source_tag *source, struct _refbuf_tag *refbuf)
{
  if(!(refbuf->len == 0u))
  {
    unsigned long int return_value_fwrite_1;
    return_value_fwrite_1=fwrite((const void *)refbuf->data, (unsigned long int)1, (unsigned long int)refbuf->len, source->dumpfile);
    if(!(return_value_fwrite_1 >= (unsigned long int)refbuf->len))
    {
      log_write(errorlog, (unsigned int)2, "format-mp3/", "write_mp3_to_file", "Write to dump file failed, disabling");
      fclose(source->dumpfile);
      source->dumpfile = (struct _IO_FILE *)(void *)0;
    }

  }

}

// write_ogg_data
// file format_ogg.c line 561
static signed int write_ogg_data(struct source_tag *source, struct _refbuf_tag *refbuf)
{
  signed int ret = 1;
  unsigned long int return_value_fwrite_1;
  return_value_fwrite_1=fwrite((const void *)refbuf->data, (unsigned long int)1, (unsigned long int)refbuf->len, source->dumpfile);
  if(!(return_value_fwrite_1 == (unsigned long int)refbuf->len))
  {
    log_write(errorlog, (unsigned int)2, "format-ogg/", "write_ogg_data", "Write to dump file failed, disabling");
    fclose(source->dumpfile);
    source->dumpfile = (struct _IO_FILE *)(void *)0;
    ret = 0;
  }

  return ret;
}

// write_ogg_to_file
// file format_ogg.c line 576
static void write_ogg_to_file(struct source_tag *source, struct _refbuf_tag *refbuf)
{
  struct ogg_state_tag *ogg_info = (struct ogg_state_tag *)source->format->_state;
  if(!(ogg_info->file_headers == refbuf->associated))
  {
    struct _refbuf_tag *header = refbuf->associated;
    while(!(header == ((struct _refbuf_tag *)NULL)))
    {
      signed int return_value_write_ogg_data_1;
      return_value_write_ogg_data_1=write_ogg_data(source, header);
      if(return_value_write_ogg_data_1 == 0)
        goto __CPROVER_DUMP_L5;

      header = header->next;
    }
    ogg_info->file_headers = refbuf->associated;
  }

  write_ogg_data(source, refbuf);

__CPROVER_DUMP_L5:
  ;
}

// xslt_get_stylesheet
// file xslt.c line 139
static struct _xsltStylesheet * xslt_get_stylesheet(const char *fn)
{
  signed int i;
  signed int empty = -1;
  struct stat file;
  signed int return_value_stat_3;
  return_value_stat_3=stat(fn, &file);
  if(!(return_value_stat_3 == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_write(errorlog, (unsigned int)2, "xslt/", "xslt_get_stylesheet", "Error checking for stylesheet file \"%s\": %s", fn, return_value_strerror_2);
    return (struct _xsltStylesheet *)(void *)0;
  }

  i = 0;
  for( ; !(i >= 3); i = i + 1)
    if(!(cache[(signed long int)i].filename == ((char *)NULL)))
    {
      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(fn, cache[(signed long int)i].filename);
      if(return_value_strcmp_4 == 0)
      {
        if(!(cache[(signed long int)i].last_modified >= file.st_mtim.tv_sec))
        {
          xsltFreeStylesheet(cache[(signed long int)i].stylesheet);
          cache[(signed long int)i].last_modified = file.st_mtim.tv_sec;
          cache[(signed long int)i].stylesheet=xsltParseStylesheetFile((unsigned char *)fn);
          cache[(signed long int)i].cache_age=time((signed long int *)(void *)0);
        }

        log_write(errorlog, (unsigned int)4, "xslt/", "xslt_get_stylesheet", "Using cached sheet %i", i);
        return cache[(signed long int)i].stylesheet;
      }

    }

    else
      empty = i;
  if(empty >= 0)
    i = empty;

  else
    i=evict_cache_entry();
  cache[(signed long int)i].last_modified = file.st_mtim.tv_sec;
  cache[(signed long int)i].filename=strdup(fn);
  cache[(signed long int)i].stylesheet=xsltParseStylesheetFile((unsigned char *)fn);
  cache[(signed long int)i].cache_age=time((signed long int *)(void *)0);
  return cache[(signed long int)i].stylesheet;
}

// xslt_initialize
// file xslt.h line 38
void xslt_initialize(void)
{
  memset((void *)cache, 0, sizeof(struct anonymous_43) /*32ul*/  * (unsigned long int)3);
  thread_mutex_create_c(&xsltlock, 101, "xslt.c");
  xmlInitParser();
  xmlCheckVersion(20903);
  xmlSubstituteEntitiesDefault(1);
  signed int *return_value___xmlLoadExtDtdDefaultValue_1;
  return_value___xmlLoadExtDtdDefaultValue_1=__xmlLoadExtDtdDefaultValue();
  *return_value___xmlLoadExtDtdDefaultValue_1 = 1;
}

// xslt_shutdown
// file xslt.h line 39
void xslt_shutdown(void)
{
  signed int i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    if(!(cache[(signed long int)i].filename == ((char *)NULL)))
      free((void *)cache[(signed long int)i].filename);

    if(!(cache[(signed long int)i].stylesheet == ((struct _xsltStylesheet *)NULL)))
      xsltFreeStylesheet(cache[(signed long int)i].stylesheet);

  }
  thread_mutex_destroy(&xsltlock);
  xmlCleanupParser();
  xsltCleanupGlobals();
}

// xslt_transform
// file xslt.h line 37
void xslt_transform(struct _xmlDoc *doc, const char *xslfilename, struct _client_tag *client)
{
  struct _xmlDoc *res;
  struct _xsltStylesheet *cur;
  unsigned char *string;
  signed int len;
  signed int problem = 0;
  const char *mediatype = (const char *)(void *)0;
  const char *charset = (const char *)(void *)0;
  xmlSetGenericErrorFunc((void *)"", log_parse_failure);
  xsltSetGenericErrorFunc((void *)"", log_parse_failure);
  thread_mutex_lock_c(&xsltlock, 199, "xslt.c");
  cur=xslt_get_stylesheet(xslfilename);
  _Bool tmp_if_expr_5;
  signed int return_value_xmlStrcmp_4;
  _Bool tmp_if_expr_3;
  signed int return_value_xmlStrcmp_2;
  if(cur == ((struct _xsltStylesheet *)NULL))
  {
    thread_mutex_unlock_c(&xsltlock, 204, "xslt.c");
    log_write(errorlog, (unsigned int)1, "xslt/", "xslt_transform", "problem reading stylesheet \"%s\"", xslfilename);
    client_send_404(client, "Could not parse XSLT file");
  }

  else
  {
    res=xsltApplyStylesheet(cur, doc, (const char **)(void *)0);
    signed int return_value_xsltSaveResultToString_1;
    return_value_xsltSaveResultToString_1=xsltSaveResultToString(&string, &len, res, cur);
    if(!(return_value_xsltSaveResultToString_1 >= 0))
      problem = 1;

    if(!(cur->encoding == ((unsigned char *)NULL)))
      charset = (char *)cur->encoding;

    if(!(cur->mediaType == ((unsigned char *)NULL)))
      mediatype = (char *)cur->mediaType;

    else
    {
      if(!(cur->method == ((unsigned char *)NULL)))
      {
        return_value_xmlStrcmp_4=xmlStrcmp(cur->method, (unsigned char *)"html");
        tmp_if_expr_5 = return_value_xmlStrcmp_4 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        mediatype = "text/html";

      else
      {
        if(!(cur->method == ((unsigned char *)NULL)))
        {
          return_value_xmlStrcmp_2=xmlStrcmp(cur->method, (unsigned char *)"text");
          tmp_if_expr_3 = return_value_xmlStrcmp_2 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          mediatype = "text/plain";

        else
          mediatype = "text/xml";
      }
    }
    if(problem == 0)
    {
      signed long int ret;
      signed int failed = 0;
      struct _refbuf_tag *refbuf;
      unsigned long int full_len;
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(mediatype);
      full_len = return_value_strlen_6 + (unsigned long int)len + (unsigned long int)1024;
      if(!(full_len >= 4096ul))
        full_len = (unsigned long int)4096;

      refbuf=refbuf_new((unsigned int)full_len);
      if(string == ((unsigned char *)NULL))
        string=xmlCharStrdup("");

      ret=util_http_build_header(refbuf->data, full_len, (signed long int)0, 0, 200, (const char *)(void *)0, mediatype, charset, (const char *)(void *)0, (struct source_tag *)(void *)0);
      if(ret == -1l)
      {
        log_write(errorlog, (unsigned int)1, "xslt/", "xslt_transform", "Dropping client as we can not build response headers.");
        client_send_500(client, "Header generation failed.");
      }

      else
      {
        if(!(full_len >= 64ul + (unsigned long int)ret + (unsigned long int)(signed long int)len))
        {
          void *new_data;
          full_len = (unsigned long int)(ret + (signed long int)len + (signed long int)64);
          new_data=realloc((void *)refbuf->data, full_len);
          if(!(new_data == NULL))
          {
            log_write(errorlog, (unsigned int)4, "xslt/", "xslt_transform", "Client buffer reallocation succeeded.");
            refbuf->data = (char *)new_data;
            refbuf->len = (unsigned int)full_len;
            ret=util_http_build_header(refbuf->data, full_len, (signed long int)0, 0, 200, (const char *)(void *)0, mediatype, charset, (const char *)(void *)0, (struct source_tag *)(void *)0);
            if(ret == -1l)
            {
              log_write(errorlog, (unsigned int)1, "xslt/", "xslt_transform", "Dropping client as we can not build response headers.");
              client_send_500(client, "Header generation failed.");
              failed = 1;
            }

          }

          else
          {
            log_write(errorlog, (unsigned int)1, "xslt/", "xslt_transform", "Client buffer reallocation failed. Dropping client.");
            client_send_500(client, "Buffer reallocation failed.");
            failed = 1;
          }
        }

        if(failed == 0)
        {
          snprintf(refbuf->data + ret, full_len - (unsigned long int)ret, "Content-Length: %d\r\n\r\n%s", len, string);
          client->respcode = 200;
          client_set_queue(client, (struct _refbuf_tag *)(void *)0);
          client->refbuf = refbuf;
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(refbuf->data);
          refbuf->len = (unsigned int)return_value_strlen_7;
          fserve_add_client(client, (struct _IO_FILE *)(void *)0);
        }

      }
      xmlFree((void *)string);
    }

    else
    {
      log_write(errorlog, (unsigned int)2, "xslt/", "xslt_transform", "problem applying stylesheet \"%s\"", xslfilename);
      client_send_404(client, "XSLT problem");
    }
    thread_mutex_unlock_c(&xsltlock, 287, "xslt.c");
    xmlFreeDoc(res);
  }
}

// yp_add
// file yp.h line 31
void yp_add(const char *mount)
{
  struct yp_server *server;
  thread_rwlock_rlock_c(&yp_lock, 877, "yp.c");
  thread_mutex_lock_c(&yp_pending_lock, 880, "yp.c");
  server = (struct yp_server *)active_yps;
  while(!(server == ((struct yp_server *)NULL)))
  {
    struct ypdata_tag *yp;
    yp=find_yp_mount(server->mounts, mount);
    if(yp == ((struct ypdata_tag *)NULL))
    {
      yp=create_yp_entry(mount);
      if(!(yp == ((struct ypdata_tag *)NULL)))
      {
        log_write(errorlog, (unsigned int)4, "yp/", "yp_add", "Adding %s to %s", mount, server->url);
        yp->server = server;
        yp->touch_interval = server->touch_interval;
        yp->next = server->pending_mounts;
        signed long int return_value_time_1;
        return_value_time_1=time((signed long int *)(void *)0);
        yp->next_update = return_value_time_1 + (signed long int)60;
        server->pending_mounts = yp;
        yp_update = 1;
      }

    }

    else
      log_write(errorlog, (unsigned int)4, "yp/", "yp_add", "YP entry %s already exists", mount);
    server = server->next;
  }
  thread_mutex_unlock_c(&yp_pending_lock, 907, "yp.c");
  thread_rwlock_unlock_c(&yp_lock, 908, "yp.c");
}

// yp_destroy_ypdata
// file yp.c line 767
static void yp_destroy_ypdata(struct ypdata_tag *ypdata)
{
  if(!(ypdata == ((struct ypdata_tag *)NULL)))
  {
    if(!(ypdata->mount == ((char *)NULL)))
      free((void *)ypdata->mount);

    if(!(ypdata->url == ((char *)NULL)))
      free((void *)ypdata->url);

    if(!(ypdata->sid == ((char *)NULL)))
      free((void *)ypdata->sid);

    if(!(ypdata->server_name == ((char *)NULL)))
      free((void *)ypdata->server_name);

    if(!(ypdata->server_desc == ((char *)NULL)))
      free((void *)ypdata->server_desc);

    if(!(ypdata->server_genre == ((char *)NULL)))
      free((void *)ypdata->server_genre);

    if(!(ypdata->cluster_password == ((char *)NULL)))
      free((void *)ypdata->cluster_password);

    if(!(ypdata->listen_url == ((char *)NULL)))
      free((void *)ypdata->listen_url);

    if(!(ypdata->current_song == ((char *)NULL)))
      free((void *)ypdata->current_song);

    if(!(ypdata->bitrate == ((char *)NULL)))
      free((void *)ypdata->bitrate);

    if(!(ypdata->server_type == ((char *)NULL)))
      free((void *)ypdata->server_type);

    if(!(ypdata->audio_info == ((char *)NULL)))
      free((void *)ypdata->audio_info);

    free((void *)ypdata->subtype);
    free((void *)ypdata->error_msg);
    free((void *)ypdata);
  }

}

// yp_initialize
// file yp.h line 35
void yp_initialize(void)
{
  struct ice_config_tag *config;
  config=config_get_config();
  thread_rwlock_create_c(&yp_lock, 282, "yp.c");
  thread_mutex_create_c(&yp_pending_lock, 283, "yp.c");
  yp_recheck_config(config);
  config_release_config();
  yp_thread=thread_create_c("YP Touch Thread", yp_update_thread, (void *)0, 0, 287, "yp.c");
}

// yp_process_server
// file yp.c line 528
static void yp_process_server(struct yp_server *server)
{
  struct ypdata_tag *yp;
  signed int state = 0;
  yp = server->mounts;
  for( ; !(yp == ((struct ypdata_tag *)NULL)); yp = yp->next)
  {
    now=time((signed long int *)(void *)0);
    if(state == -2)
    {
      log_write(errorlog, (unsigned int)4, "yp/", "yp_process_server", "skiping %s on %s", yp->mount, server->url);
      yp->process = do_yp_add;
      yp->next_update = yp->next_update + (signed long int)900;
    }

    else
      state=process_ypdata(server, yp);
  }
}

// yp_recheck_config
// file yp.h line 34
void yp_recheck_config(struct ice_config_tag *config)
{
  signed int i;
  struct yp_server *server;
  log_write(errorlog, (unsigned int)4, "yp/", "yp_recheck_config", "Updating YP configuration");
  thread_rwlock_rlock_c(&yp_lock, 215, "yp.c");
  server = (struct yp_server *)active_yps;
  for( ; !(server == ((struct yp_server *)NULL)); server = server->next)
    server->remove = 1;
  client_limit = (volatile unsigned int)config->client_limit;
  free((void *)(char *)server_version);
  server_version=strdup(config->server_id);
  i = 0;
  _Bool tmp_if_expr_2;
  for( ; !(i >= config->num_yp_directories); i = i + 1)
  {
    server=find_yp_server(config->yp_url[(signed long int)i]);
    if(server == ((struct yp_server *)NULL))
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct yp_server) /*320ul*/ );
      server = (struct yp_server *)return_value_calloc_1;
      if(server == ((struct yp_server *)NULL))
      {
        destroy_yp_server(server);
        break;
      }

      server->server_id=strdup((char *)server_version);
      server->url=strdup(config->yp_url[(signed long int)i]);
      server->url_timeout = (unsigned int)config->yp_url_timeout[(signed long int)i];
      server->touch_interval = (unsigned int)config->yp_touch_interval[(signed long int)i];
      server->curl=curl_easy_init();
      if(server->curl == NULL)
      {
        destroy_yp_server(server);
        break;
      }

      if(server->url_timeout >= 11u)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = server->url_timeout < (unsigned int)1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        server->url_timeout = (unsigned int)6;

      if(!(server->touch_interval >= 30u))
        server->touch_interval = (unsigned int)30;

      signed int yp_recheck_config__1__2__1__1__3___curl_opt = CURLOPT_USERAGENT;
      curl_easy_setopt(server->curl, (enum anonymous_32)yp_recheck_config__1__2__1__1__3___curl_opt, server->server_id);
      signed int yp_recheck_config__1__2__1__1__4___curl_opt = CURLOPT_URL;
      curl_easy_setopt(server->curl, (enum anonymous_32)yp_recheck_config__1__2__1__1__4___curl_opt, server->url);
      signed int yp_recheck_config__1__2__1__1__5___curl_opt = CURLOPT_HEADERFUNCTION;
      curl_easy_setopt(server->curl, (enum anonymous_32)yp_recheck_config__1__2__1__1__5___curl_opt, handle_returned_header_link1);
      signed int yp_recheck_config__1__2__1__1__6___curl_opt = CURLOPT_WRITEFUNCTION;
      curl_easy_setopt(server->curl, (enum anonymous_32)yp_recheck_config__1__2__1__1__6___curl_opt, handle_returned_data_link1);
      signed int _curl_opt = CURLOPT_WRITEDATA;
      curl_easy_setopt(server->curl, (enum anonymous_32)_curl_opt, server->curl);
      signed int yp_recheck_config__1__2__1__1__8___curl_opt = CURLOPT_TIMEOUT;
      curl_easy_setopt(server->curl, (enum anonymous_32)yp_recheck_config__1__2__1__1__8___curl_opt, server->url_timeout);
      signed int yp_recheck_config__1__2__1__1__9___curl_opt = CURLOPT_NOSIGNAL;
      curl_easy_setopt(server->curl, (enum anonymous_32)yp_recheck_config__1__2__1__1__9___curl_opt, 1L);
      signed int yp_recheck_config__1__2__1__1__10___curl_opt = CURLOPT_FOLLOWLOCATION;
      curl_easy_setopt(server->curl, (enum anonymous_32)yp_recheck_config__1__2__1__1__10___curl_opt, 1L);
      signed int yp_recheck_config__1__2__1__1__11___curl_opt = CURLOPT_MAXREDIRS;
      curl_easy_setopt(server->curl, (enum anonymous_32)yp_recheck_config__1__2__1__1__11___curl_opt, 3L);
      signed int yp_recheck_config__1__2__1__1__12___curl_opt = CURLOPT_ERRORBUFFER;
      curl_easy_setopt(server->curl, (enum anonymous_32)yp_recheck_config__1__2__1__1__12___curl_opt, &server->curl_error[(signed long int)0]);
      server->next = (struct yp_server *)pending_yps;
      pending_yps = server;
      log_write(errorlog, (unsigned int)3, "yp/", "yp_recheck_config", "Adding new YP server \"%s\" (timeout %ds, default interval %ds)", server->url, server->url_timeout, server->touch_interval);
    }

    else
      server->remove = 0;
  }
  thread_rwlock_unlock_c(&yp_lock, 274, "yp.c");
  yp_update = 1;
}

// yp_remove
// file yp.h line 32
void yp_remove(const char *mount)
{
  struct yp_server *server = (struct yp_server *)active_yps;
  thread_rwlock_rlock_c(&yp_lock, 918, "yp.c");
  _Bool tmp_if_expr_1;
  while(!(server == ((struct yp_server *)NULL)))
  {
    struct ypdata_tag *list = server->mounts;
    while((_Bool)1)
    {
      struct ypdata_tag *yp;
      yp=find_yp_mount(list, mount);
      if(yp == ((struct ypdata_tag *)NULL))
        break;

      if(!(yp->release == 0))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = yp->remove != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        list = yp->next;

      else
      {
        log_write(errorlog, (unsigned int)4, "yp/", "yp_remove", "release %s on YP %s", mount, server->url);
        yp->release = 1;
        yp->next_update = (signed long int)0;
      }
    }
    server = server->next;
  }
  thread_rwlock_unlock_c(&yp_lock, 939, "yp.c");
}

// yp_shutdown
// file yp.h line 36
void yp_shutdown(void)
{
  yp_running = 0;
  yp_update = 1;
  if(!(yp_thread == ((struct anonymous_24 *)NULL)))
    thread_join(yp_thread);

  curl_global_cleanup();
  free((void *)(char *)server_version);
  server_version = (volatile char *)(void *)0;
  log_write(errorlog, (unsigned int)3, "yp/", "yp_shutdown", "YP thread down");
}

// yp_touch
// file yp.h line 33
void yp_touch(const char *mount)
{
  struct yp_server *server = (struct yp_server *)active_yps;
  struct ypdata_tag *search_list = (struct ypdata_tag *)(void *)0;
  thread_rwlock_rlock_c(&yp_lock, 950, "yp.c");
  if(!(server == ((struct yp_server *)NULL)))
    search_list = server->mounts;

  _Bool tmp_if_expr_1;
  while(!(server == ((struct yp_server *)NULL)))
  {
    struct ypdata_tag *yp;
    yp=find_yp_mount(search_list, mount);
    if(!(yp == ((struct ypdata_tag *)NULL)))
    {
      if(!(yp->release == 0))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = yp->remove != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        search_list = yp->next;
        continue;
      }

      if(yp->process == do_yp_touch)
      {
        if(now + (signed long int)yp->touch_interval + -yp->next_update >= 61l)
          yp->next_update = now + (signed long int)3;

      }

    }

    server = server->next;
    if(!(server == ((struct yp_server *)NULL)))
      search_list = server->mounts;

  }
  thread_rwlock_unlock_c(&yp_lock, 973, "yp.c");
}

// yp_update_thread
// file yp.c line 713
static void * yp_update_thread(void *arg)
{
  log_write(errorlog, (unsigned int)3, "yp/", "yp_update_thread", "YP update thread started");
  yp_running = 1;
  while(!(yp_running == 0))
  {
    struct yp_server *server;
    thread_sleep((unsigned long int)200000);
    thread_rwlock_rlock_c(&yp_lock, 725, "yp.c");
    server = (struct yp_server *)active_yps;
    for( ; !(server == ((struct yp_server *)NULL)); server = server->next)
      yp_process_server(server);
    thread_rwlock_unlock_c(&yp_lock, 733, "yp.c");
    if(!(yp_update == 0))
    {
      thread_rwlock_wlock_c(&yp_lock, 738, "yp.c");
      check_servers();
      server = (struct yp_server *)active_yps;
      for( ; !(server == ((struct yp_server *)NULL)); server = server->next)
      {
        add_pending_yp(server);
        delete_marked_yp(server);
      }
      yp_update = 0;
      thread_rwlock_unlock_c(&yp_lock, 749, "yp.c");
    }

  }
  thread_rwlock_destroy(&yp_lock);
  thread_mutex_destroy(&yp_pending_lock);
  while(!(active_yps == ((struct yp_server *)NULL)))
  {
    struct yp_server *yp_update_thread__1__2__server = (struct yp_server *)active_yps;
    active_yps = yp_update_thread__1__2__server->next;
    destroy_yp_server(yp_update_thread__1__2__server);
  }
  return (void *)0;
}

