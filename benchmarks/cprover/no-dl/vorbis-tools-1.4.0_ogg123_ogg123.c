// #anon_enum_CURLE_OK=0_CURLE_UNSUPPORTED_PROTOCOL=1_CURLE_FAILED_INIT=2_CURLE_URL_MALFORMAT=3_CURLE_NOT_BUILT_IN=4_CURLE_COULDNT_RESOLVE_PROXY=5_CURLE_COULDNT_RESOLVE_HOST=6_CURLE_COULDNT_CONNECT=7_CURLE_FTP_WEIRD_SERVER_REPLY=8_CURLE_REMOTE_ACCESS_DENIED=9_CURLE_FTP_ACCEPT_FAILED=10_CURLE_FTP_WEIRD_PASS_REPLY=11_CURLE_FTP_ACCEPT_TIMEOUT=12_CURLE_FTP_WEIRD_PASV_REPLY=13_CURLE_FTP_WEIRD_227_FORMAT=14_CURLE_FTP_CANT_GET_HOST=15_CURLE_HTTP2=16_CURLE_FTP_COULDNT_SET_TYPE=17_CURLE_PARTIAL_FILE=18_CURLE_FTP_COULDNT_RETR_FILE=19_CURLE_OBSOLETE20=20_CURLE_QUOTE_ERROR=21_CURLE_HTTP_RETURNED_ERROR=22_CURLE_WRITE_ERROR=23_CURLE_OBSOLETE24=24_CURLE_UPLOAD_FAILED=25_CURLE_READ_ERROR=26_CURLE_OUT_OF_MEMORY=27_CURLE_OPERATION_TIMEDOUT=28_CURLE_OBSOLETE29=29_CURLE_FTP_PORT_FAILED=30_CURLE_FTP_COULDNT_USE_REST=31_CURLE_OBSOLETE32=32_CURLE_RANGE_ERROR=33_CURLE_HTTP_POST_ERROR=34_CURLE_SSL_CONNECT_ERROR=35_CURLE_BAD_DOWNLOAD_RESUME=36_CURLE_FILE_COULDNT_READ_FILE=37_CURLE_LDAP_CANNOT_BIND=38_CURLE_LDAP_SEARCH_FAILED=39_CURLE_OBSOLETE40=40_CURLE_FUNCTION_NOT_FOUND=41_CURLE_ABORTED_BY_CALLBACK=42_CURLE_BAD_FUNCTION_ARGUMENT=43_CURLE_OBSOLETE44=44_CURLE_INTERFACE_FAILED=45_CURLE_OBSOLETE46=46_CURLE_TOO_MANY_REDIRECTS=47_CURLE_UNKNOWN_OPTION=48_CURLE_TELNET_OPTION_SYNTAX=49_CURLE_OBSOLETE50=50_CURLE_PEER_FAILED_VERIFICATION=51_CURLE_GOT_NOTHING=52_CURLE_SSL_ENGINE_NOTFOUND=53_CURLE_SSL_ENGINE_SETFAILED=54_CURLE_SEND_ERROR=55_CURLE_RECV_ERROR=56_CURLE_OBSOLETE57=57_CURLE_SSL_CERTPROBLEM=58_CURLE_SSL_CIPHER=59_CURLE_SSL_CACERT=60_CURLE_BAD_CONTENT_ENCODING=61_CURLE_LDAP_INVALID_URL=62_CURLE_FILESIZE_EXCEEDED=63_CURLE_USE_SSL_FAILED=64_CURLE_SEND_FAIL_REWIND=65_CURLE_SSL_ENGINE_INITFAILED=66_CURLE_LOGIN_DENIED=67_CURLE_TFTP_NOTFOUND=68_CURLE_TFTP_PERM=69_CURLE_REMOTE_DISK_FULL=70_CURLE_TFTP_ILLEGAL=71_CURLE_TFTP_UNKNOWNID=72_CURLE_REMOTE_FILE_EXISTS=73_CURLE_TFTP_NOSUCHUSER=74_CURLE_CONV_FAILED=75_CURLE_CONV_REQD=76_CURLE_SSL_CACERT_BADFILE=77_CURLE_REMOTE_FILE_NOT_FOUND=78_CURLE_SSH=79_CURLE_SSL_SHUTDOWN_FAILED=80_CURLE_AGAIN=81_CURLE_SSL_CRL_BADFILE=82_CURLE_SSL_ISSUER_ERROR=83_CURLE_FTP_PRET_FAILED=84_CURLE_RTSP_CSEQ_ERROR=85_CURLE_RTSP_SESSION_ERROR=86_CURLE_FTP_BAD_FILE_LIST=87_CURLE_CHUNK_FAILED=88_CURLE_NO_CONNECTION_AVAILABLE=89_CURLE_SSL_PINNEDPUBKEYNOTMATCH=90_CURLE_SSL_INVALIDCERTSTATUS=91_CURL_LAST=92
// file /usr/include/curl/curl.h line 414
enum anonymous_2 { CURLE_OK=0, CURLE_UNSUPPORTED_PROTOCOL=1, CURLE_FAILED_INIT=2, CURLE_URL_MALFORMAT=3, CURLE_NOT_BUILT_IN=4, CURLE_COULDNT_RESOLVE_PROXY=5, CURLE_COULDNT_RESOLVE_HOST=6, CURLE_COULDNT_CONNECT=7, CURLE_FTP_WEIRD_SERVER_REPLY=8, CURLE_REMOTE_ACCESS_DENIED=9, CURLE_FTP_ACCEPT_FAILED=10, CURLE_FTP_WEIRD_PASS_REPLY=11, CURLE_FTP_ACCEPT_TIMEOUT=12, CURLE_FTP_WEIRD_PASV_REPLY=13, CURLE_FTP_WEIRD_227_FORMAT=14, CURLE_FTP_CANT_GET_HOST=15, CURLE_HTTP2=16, CURLE_FTP_COULDNT_SET_TYPE=17, CURLE_PARTIAL_FILE=18, CURLE_FTP_COULDNT_RETR_FILE=19, CURLE_OBSOLETE20=20, CURLE_QUOTE_ERROR=21, CURLE_HTTP_RETURNED_ERROR=22, CURLE_WRITE_ERROR=23, CURLE_OBSOLETE24=24, CURLE_UPLOAD_FAILED=25, CURLE_READ_ERROR=26, CURLE_OUT_OF_MEMORY=27, CURLE_OPERATION_TIMEDOUT=28, CURLE_OBSOLETE29=29, CURLE_FTP_PORT_FAILED=30, CURLE_FTP_COULDNT_USE_REST=31, CURLE_OBSOLETE32=32, CURLE_RANGE_ERROR=33, CURLE_HTTP_POST_ERROR=34, CURLE_SSL_CONNECT_ERROR=35, CURLE_BAD_DOWNLOAD_RESUME=36, CURLE_FILE_COULDNT_READ_FILE=37, CURLE_LDAP_CANNOT_BIND=38, CURLE_LDAP_SEARCH_FAILED=39, CURLE_OBSOLETE40=40, CURLE_FUNCTION_NOT_FOUND=41, CURLE_ABORTED_BY_CALLBACK=42, CURLE_BAD_FUNCTION_ARGUMENT=43, CURLE_OBSOLETE44=44, CURLE_INTERFACE_FAILED=45, CURLE_OBSOLETE46=46, CURLE_TOO_MANY_REDIRECTS=47, CURLE_UNKNOWN_OPTION=48, CURLE_TELNET_OPTION_SYNTAX=49, CURLE_OBSOLETE50=50, CURLE_PEER_FAILED_VERIFICATION=51, CURLE_GOT_NOTHING=52, CURLE_SSL_ENGINE_NOTFOUND=53, CURLE_SSL_ENGINE_SETFAILED=54, CURLE_SEND_ERROR=55, CURLE_RECV_ERROR=56, CURLE_OBSOLETE57=57, CURLE_SSL_CERTPROBLEM=58, CURLE_SSL_CIPHER=59, CURLE_SSL_CACERT=60, CURLE_BAD_CONTENT_ENCODING=61, CURLE_LDAP_INVALID_URL=62, CURLE_FILESIZE_EXCEEDED=63, CURLE_USE_SSL_FAILED=64, CURLE_SEND_FAIL_REWIND=65, CURLE_SSL_ENGINE_INITFAILED=66, CURLE_LOGIN_DENIED=67, CURLE_TFTP_NOTFOUND=68, CURLE_TFTP_PERM=69, CURLE_REMOTE_DISK_FULL=70, CURLE_TFTP_ILLEGAL=71, CURLE_TFTP_UNKNOWNID=72, CURLE_REMOTE_FILE_EXISTS=73, CURLE_TFTP_NOSUCHUSER=74, CURLE_CONV_FAILED=75, CURLE_CONV_REQD=76, CURLE_SSL_CACERT_BADFILE=77, CURLE_REMOTE_FILE_NOT_FOUND=78, CURLE_SSH=79, CURLE_SSL_SHUTDOWN_FAILED=80, CURLE_AGAIN=81, CURLE_SSL_CRL_BADFILE=82, CURLE_SSL_ISSUER_ERROR=83, CURLE_FTP_PRET_FAILED=84, CURLE_RTSP_CSEQ_ERROR=85, CURLE_RTSP_SESSION_ERROR=86, CURLE_FTP_BAD_FILE_LIST=87, CURLE_CHUNK_FAILED=88, CURLE_NO_CONNECTION_AVAILABLE=89, CURLE_SSL_PINNEDPUBKEYNOTMATCH=90, CURLE_SSL_INVALIDCERTSTATUS=91, CURL_LAST=92 };

// #anon_enum_CURLOPT_WRITEDATA=10001_CURLOPT_URL=10002_CURLOPT_PORT=3_CURLOPT_PROXY=10004_CURLOPT_USERPWD=10005_CURLOPT_PROXYUSERPWD=10006_CURLOPT_RANGE=10007_CURLOPT_READDATA=10009_CURLOPT_ERRORBUFFER=10010_CURLOPT_WRITEFUNCTION=20011_CURLOPT_READFUNCTION=20012_CURLOPT_TIMEOUT=13_CURLOPT_INFILESIZE=14_CURLOPT_POSTFIELDS=10015_CURLOPT_REFERER=10016_CURLOPT_FTPPORT=10017_CURLOPT_USERAGENT=10018_CURLOPT_LOW_SPEED_LIMIT=19_CURLOPT_LOW_SPEED_TIME=20_CURLOPT_RESUME_FROM=21_CURLOPT_COOKIE=10022_CURLOPT_HTTPHEADER=10023_CURLOPT_HTTPPOST=10024_CURLOPT_SSLCERT=10025_CURLOPT_KEYPASSWD=10026_CURLOPT_CRLF=27_CURLOPT_QUOTE=10028_CURLOPT_HEADERDATA=10029_CURLOPT_COOKIEFILE=10031_CURLOPT_SSLVERSION=32_CURLOPT_TIMECONDITION=33_CURLOPT_TIMEVALUE=34_CURLOPT_CUSTOMREQUEST=10036_CURLOPT_STDERR=10037_CURLOPT_POSTQUOTE=10039_CURLOPT_OBSOLETE40=10040_CURLOPT_VERBOSE=41_CURLOPT_HEADER=42_CURLOPT_NOPROGRESS=43_CURLOPT_NOBODY=44_CURLOPT_FAILONERROR=45_CURLOPT_UPLOAD=46_CURLOPT_POST=47_CURLOPT_DIRLISTONLY=48_CURLOPT_APPEND=50_CURLOPT_NETRC=51_CURLOPT_FOLLOWLOCATION=52_CURLOPT_TRANSFERTEXT=53_CURLOPT_PUT=54_CURLOPT_PROGRESSFUNCTION=20056_CURLOPT_PROGRESSDATA=10057_CURLOPT_AUTOREFERER=58_CURLOPT_PROXYPORT=59_CURLOPT_POSTFIELDSIZE=60_CURLOPT_HTTPPROXYTUNNEL=61_CURLOPT_INTERFACE=10062_CURLOPT_KRBLEVEL=10063_CURLOPT_SSL_VERIFYPEER=64_CURLOPT_CAINFO=10065_CURLOPT_MAXREDIRS=68_CURLOPT_FILETIME=69_CURLOPT_TELNETOPTIONS=10070_CURLOPT_MAXCONNECTS=71_CURLOPT_OBSOLETE72=72_CURLOPT_FRESH_CONNECT=74_CURLOPT_FORBID_REUSE=75_CURLOPT_RANDOM_FILE=10076_CURLOPT_EGDSOCKET=10077_CURLOPT_CONNECTTIMEOUT=78_CURLOPT_HEADERFUNCTION=20079_CURLOPT_HTTPGET=80_CURLOPT_SSL_VERIFYHOST=81_CURLOPT_COOKIEJAR=10082_CURLOPT_SSL_CIPHER_LIST=10083_CURLOPT_HTTP_VERSION=84_CURLOPT_FTP_USE_EPSV=85_CURLOPT_SSLCERTTYPE=10086_CURLOPT_SSLKEY=10087_CURLOPT_SSLKEYTYPE=10088_CURLOPT_SSLENGINE=10089_CURLOPT_SSLENGINE_DEFAULT=90_CURLOPT_DNS_USE_GLOBAL_CACHE=91_CURLOPT_DNS_CACHE_TIMEOUT=92_CURLOPT_PREQUOTE=10093_CURLOPT_DEBUGFUNCTION=20094_CURLOPT_DEBUGDATA=10095_CURLOPT_COOKIESESSION=96_CURLOPT_CAPATH=10097_CURLOPT_BUFFERSIZE=98_CURLOPT_NOSIGNAL=99_CURLOPT_SHARE=10100_CURLOPT_PROXYTYPE=101_CURLOPT_ACCEPT_ENCODING=10102_CURLOPT_PRIVATE=10103_CURLOPT_HTTP200ALIASES=10104_CURLOPT_UNRESTRICTED_AUTH=105_CURLOPT_FTP_USE_EPRT=106_CURLOPT_HTTPAUTH=107_CURLOPT_SSL_CTX_FUNCTION=20108_CURLOPT_SSL_CTX_DATA=10109_CURLOPT_FTP_CREATE_MISSING_DIRS=110_CURLOPT_PROXYAUTH=111_CURLOPT_FTP_RESPONSE_TIMEOUT=112_CURLOPT_IPRESOLVE=113_CURLOPT_MAXFILESIZE=114_CURLOPT_INFILESIZE_LARGE=30115_CURLOPT_RESUME_FROM_LARGE=30116_CURLOPT_MAXFILESIZE_LARGE=30117_CURLOPT_NETRC_FILE=10118_CURLOPT_USE_SSL=119_CURLOPT_POSTFIELDSIZE_LARGE=30120_CURLOPT_TCP_NODELAY=121_CURLOPT_FTPSSLAUTH=129_CURLOPT_IOCTLFUNCTION=20130_CURLOPT_IOCTLDATA=10131_CURLOPT_FTP_ACCOUNT=10134_CURLOPT_COOKIELIST=10135_CURLOPT_IGNORE_CONTENT_LENGTH=136_CURLOPT_FTP_SKIP_PASV_IP=137_CURLOPT_FTP_FILEMETHOD=138_CURLOPT_LOCALPORT=139_CURLOPT_LOCALPORTRANGE=140_CURLOPT_CONNECT_ONLY=141_CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142_CURLOPT_CONV_TO_NETWORK_FUNCTION=20143_CURLOPT_CONV_FROM_UTF8_FUNCTION=20144_CURLOPT_MAX_SEND_SPEED_LARGE=30145_CURLOPT_MAX_RECV_SPEED_LARGE=30146_CURLOPT_FTP_ALTERNATIVE_TO_USER=10147_CURLOPT_SOCKOPTFUNCTION=20148_CURLOPT_SOCKOPTDATA=10149_CURLOPT_SSL_SESSIONID_CACHE=150_CURLOPT_SSH_AUTH_TYPES=151_CURLOPT_SSH_PUBLIC_KEYFILE=10152_CURLOPT_SSH_PRIVATE_KEYFILE=10153_CURLOPT_FTP_SSL_CCC=154_CURLOPT_TIMEOUT_MS=155_CURLOPT_CONNECTTIMEOUT_MS=156_CURLOPT_HTTP_TRANSFER_DECODING=157_CURLOPT_HTTP_CONTENT_DECODING=158_CURLOPT_NEW_FILE_PERMS=159_CURLOPT_NEW_DIRECTORY_PERMS=160_CURLOPT_POSTREDIR=161_CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162_CURLOPT_OPENSOCKETFUNCTION=20163_CURLOPT_OPENSOCKETDATA=10164_CURLOPT_COPYPOSTFIELDS=10165_CURLOPT_PROXY_TRANSFER_MODE=166_CURLOPT_SEEKFUNCTION=20167_CURLOPT_SEEKDATA=10168_CURLOPT_CRLFILE=10169_CURLOPT_ISSUERCERT=10170_CURLOPT_ADDRESS_SCOPE=171_CURLOPT_CERTINFO=172_CURLOPT_USERNAME=10173_CURLOPT_PASSWORD=10174_CURLOPT_PROXYUSERNAME=10175_CURLOPT_PROXYPASSWORD=10176_CURLOPT_NOPROXY=10177_CURLOPT_TFTP_BLKSIZE=178_CURLOPT_SOCKS5_GSSAPI_SERVICE=10179_CURLOPT_SOCKS5_GSSAPI_NEC=180_CURLOPT_PROTOCOLS=181_CURLOPT_REDIR_PROTOCOLS=182_CURLOPT_SSH_KNOWNHOSTS=10183_CURLOPT_SSH_KEYFUNCTION=20184_CURLOPT_SSH_KEYDATA=10185_CURLOPT_MAIL_FROM=10186_CURLOPT_MAIL_RCPT=10187_CURLOPT_FTP_USE_PRET=188_CURLOPT_RTSP_REQUEST=189_CURLOPT_RTSP_SESSION_ID=10190_CURLOPT_RTSP_STREAM_URI=10191_CURLOPT_RTSP_TRANSPORT=10192_CURLOPT_RTSP_CLIENT_CSEQ=193_CURLOPT_RTSP_SERVER_CSEQ=194_CURLOPT_INTERLEAVEDATA=10195_CURLOPT_INTERLEAVEFUNCTION=20196_CURLOPT_WILDCARDMATCH=197_CURLOPT_CHUNK_BGN_FUNCTION=20198_CURLOPT_CHUNK_END_FUNCTION=20199_CURLOPT_FNMATCH_FUNCTION=20200_CURLOPT_CHUNK_DATA=10201_CURLOPT_FNMATCH_DATA=10202_CURLOPT_RESOLVE=10203_CURLOPT_TLSAUTH_USERNAME=10204_CURLOPT_TLSAUTH_PASSWORD=10205_CURLOPT_TLSAUTH_TYPE=10206_CURLOPT_TRANSFER_ENCODING=207_CURLOPT_CLOSESOCKETFUNCTION=20208_CURLOPT_CLOSESOCKETDATA=10209_CURLOPT_GSSAPI_DELEGATION=210_CURLOPT_DNS_SERVERS=10211_CURLOPT_ACCEPTTIMEOUT_MS=212_CURLOPT_TCP_KEEPALIVE=213_CURLOPT_TCP_KEEPIDLE=214_CURLOPT_TCP_KEEPINTVL=215_CURLOPT_SSL_OPTIONS=216_CURLOPT_MAIL_AUTH=10217_CURLOPT_SASL_IR=218_CURLOPT_XFERINFOFUNCTION=20219_CURLOPT_XOAUTH2_BEARER=10220_CURLOPT_DNS_INTERFACE=10221_CURLOPT_DNS_LOCAL_IP4=10222_CURLOPT_DNS_LOCAL_IP6=10223_CURLOPT_LOGIN_OPTIONS=10224_CURLOPT_SSL_ENABLE_NPN=225_CURLOPT_SSL_ENABLE_ALPN=226_CURLOPT_EXPECT_100_TIMEOUT_MS=227_CURLOPT_PROXYHEADER=10228_CURLOPT_HEADEROPT=229_CURLOPT_PINNEDPUBLICKEY=10230_CURLOPT_UNIX_SOCKET_PATH=10231_CURLOPT_SSL_VERIFYSTATUS=232_CURLOPT_SSL_FALSESTART=233_CURLOPT_PATH_AS_IS=234_CURLOPT_PROXY_SERVICE_NAME=10235_CURLOPT_SERVICE_NAME=10236_CURLOPT_PIPEWAIT=237_CURLOPT_DEFAULT_PROTOCOL=10238_CURLOPT_STREAM_WEIGHT=239_CURLOPT_STREAM_DEPENDS=10240_CURLOPT_STREAM_DEPENDS_E=10241_CURLOPT_LASTENTRY=10242
// file /usr/include/curl/curl.h line 864
enum anonymous_4 { CURLOPT_WRITEDATA=10001, CURLOPT_URL=10002, CURLOPT_PORT=3, CURLOPT_PROXY=10004, CURLOPT_USERPWD=10005, CURLOPT_PROXYUSERPWD=10006, CURLOPT_RANGE=10007, CURLOPT_READDATA=10009, CURLOPT_ERRORBUFFER=10010, CURLOPT_WRITEFUNCTION=20011, CURLOPT_READFUNCTION=20012, CURLOPT_TIMEOUT=13, CURLOPT_INFILESIZE=14, CURLOPT_POSTFIELDS=10015, CURLOPT_REFERER=10016, CURLOPT_FTPPORT=10017, CURLOPT_USERAGENT=10018, CURLOPT_LOW_SPEED_LIMIT=19, CURLOPT_LOW_SPEED_TIME=20, CURLOPT_RESUME_FROM=21, CURLOPT_COOKIE=10022, CURLOPT_HTTPHEADER=10023, CURLOPT_HTTPPOST=10024, CURLOPT_SSLCERT=10025, CURLOPT_KEYPASSWD=10026, CURLOPT_CRLF=27, CURLOPT_QUOTE=10028, CURLOPT_HEADERDATA=10029, CURLOPT_COOKIEFILE=10031, CURLOPT_SSLVERSION=32, CURLOPT_TIMECONDITION=33, CURLOPT_TIMEVALUE=34, CURLOPT_CUSTOMREQUEST=10036, CURLOPT_STDERR=10037, CURLOPT_POSTQUOTE=10039, CURLOPT_OBSOLETE40=10040, CURLOPT_VERBOSE=41, CURLOPT_HEADER=42, CURLOPT_NOPROGRESS=43, CURLOPT_NOBODY=44, CURLOPT_FAILONERROR=45, CURLOPT_UPLOAD=46, CURLOPT_POST=47, CURLOPT_DIRLISTONLY=48, CURLOPT_APPEND=50, CURLOPT_NETRC=51, CURLOPT_FOLLOWLOCATION=52, CURLOPT_TRANSFERTEXT=53, CURLOPT_PUT=54, CURLOPT_PROGRESSFUNCTION=20056, CURLOPT_PROGRESSDATA=10057, CURLOPT_AUTOREFERER=58, CURLOPT_PROXYPORT=59, CURLOPT_POSTFIELDSIZE=60, CURLOPT_HTTPPROXYTUNNEL=61, CURLOPT_INTERFACE=10062, CURLOPT_KRBLEVEL=10063, CURLOPT_SSL_VERIFYPEER=64, CURLOPT_CAINFO=10065, CURLOPT_MAXREDIRS=68, CURLOPT_FILETIME=69, CURLOPT_TELNETOPTIONS=10070, CURLOPT_MAXCONNECTS=71, CURLOPT_OBSOLETE72=72, CURLOPT_FRESH_CONNECT=74, CURLOPT_FORBID_REUSE=75, CURLOPT_RANDOM_FILE=10076, CURLOPT_EGDSOCKET=10077, CURLOPT_CONNECTTIMEOUT=78, CURLOPT_HEADERFUNCTION=20079, CURLOPT_HTTPGET=80, CURLOPT_SSL_VERIFYHOST=81, CURLOPT_COOKIEJAR=10082, CURLOPT_SSL_CIPHER_LIST=10083, CURLOPT_HTTP_VERSION=84, CURLOPT_FTP_USE_EPSV=85, CURLOPT_SSLCERTTYPE=10086, CURLOPT_SSLKEY=10087, CURLOPT_SSLKEYTYPE=10088, CURLOPT_SSLENGINE=10089, CURLOPT_SSLENGINE_DEFAULT=90, CURLOPT_DNS_USE_GLOBAL_CACHE=91, CURLOPT_DNS_CACHE_TIMEOUT=92, CURLOPT_PREQUOTE=10093, CURLOPT_DEBUGFUNCTION=20094, CURLOPT_DEBUGDATA=10095, CURLOPT_COOKIESESSION=96, CURLOPT_CAPATH=10097, CURLOPT_BUFFERSIZE=98, CURLOPT_NOSIGNAL=99, CURLOPT_SHARE=10100, CURLOPT_PROXYTYPE=101, CURLOPT_ACCEPT_ENCODING=10102, CURLOPT_PRIVATE=10103, CURLOPT_HTTP200ALIASES=10104, CURLOPT_UNRESTRICTED_AUTH=105, CURLOPT_FTP_USE_EPRT=106, CURLOPT_HTTPAUTH=107, CURLOPT_SSL_CTX_FUNCTION=20108, CURLOPT_SSL_CTX_DATA=10109, CURLOPT_FTP_CREATE_MISSING_DIRS=110, CURLOPT_PROXYAUTH=111, CURLOPT_FTP_RESPONSE_TIMEOUT=112, CURLOPT_IPRESOLVE=113, CURLOPT_MAXFILESIZE=114, CURLOPT_INFILESIZE_LARGE=30115, CURLOPT_RESUME_FROM_LARGE=30116, CURLOPT_MAXFILESIZE_LARGE=30117, CURLOPT_NETRC_FILE=10118, CURLOPT_USE_SSL=119, CURLOPT_POSTFIELDSIZE_LARGE=30120, CURLOPT_TCP_NODELAY=121, CURLOPT_FTPSSLAUTH=129, CURLOPT_IOCTLFUNCTION=20130, CURLOPT_IOCTLDATA=10131, CURLOPT_FTP_ACCOUNT=10134, CURLOPT_COOKIELIST=10135, CURLOPT_IGNORE_CONTENT_LENGTH=136, CURLOPT_FTP_SKIP_PASV_IP=137, CURLOPT_FTP_FILEMETHOD=138, CURLOPT_LOCALPORT=139, CURLOPT_LOCALPORTRANGE=140, CURLOPT_CONNECT_ONLY=141, CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142, CURLOPT_CONV_TO_NETWORK_FUNCTION=20143, CURLOPT_CONV_FROM_UTF8_FUNCTION=20144, CURLOPT_MAX_SEND_SPEED_LARGE=30145, CURLOPT_MAX_RECV_SPEED_LARGE=30146, CURLOPT_FTP_ALTERNATIVE_TO_USER=10147, CURLOPT_SOCKOPTFUNCTION=20148, CURLOPT_SOCKOPTDATA=10149, CURLOPT_SSL_SESSIONID_CACHE=150, CURLOPT_SSH_AUTH_TYPES=151, CURLOPT_SSH_PUBLIC_KEYFILE=10152, CURLOPT_SSH_PRIVATE_KEYFILE=10153, CURLOPT_FTP_SSL_CCC=154, CURLOPT_TIMEOUT_MS=155, CURLOPT_CONNECTTIMEOUT_MS=156, CURLOPT_HTTP_TRANSFER_DECODING=157, CURLOPT_HTTP_CONTENT_DECODING=158, CURLOPT_NEW_FILE_PERMS=159, CURLOPT_NEW_DIRECTORY_PERMS=160, CURLOPT_POSTREDIR=161, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162, CURLOPT_OPENSOCKETFUNCTION=20163, CURLOPT_OPENSOCKETDATA=10164, CURLOPT_COPYPOSTFIELDS=10165, CURLOPT_PROXY_TRANSFER_MODE=166, CURLOPT_SEEKFUNCTION=20167, CURLOPT_SEEKDATA=10168, CURLOPT_CRLFILE=10169, CURLOPT_ISSUERCERT=10170, CURLOPT_ADDRESS_SCOPE=171, CURLOPT_CERTINFO=172, CURLOPT_USERNAME=10173, CURLOPT_PASSWORD=10174, CURLOPT_PROXYUSERNAME=10175, CURLOPT_PROXYPASSWORD=10176, CURLOPT_NOPROXY=10177, CURLOPT_TFTP_BLKSIZE=178, CURLOPT_SOCKS5_GSSAPI_SERVICE=10179, CURLOPT_SOCKS5_GSSAPI_NEC=180, CURLOPT_PROTOCOLS=181, CURLOPT_REDIR_PROTOCOLS=182, CURLOPT_SSH_KNOWNHOSTS=10183, CURLOPT_SSH_KEYFUNCTION=20184, CURLOPT_SSH_KEYDATA=10185, CURLOPT_MAIL_FROM=10186, CURLOPT_MAIL_RCPT=10187, CURLOPT_FTP_USE_PRET=188, CURLOPT_RTSP_REQUEST=189, CURLOPT_RTSP_SESSION_ID=10190, CURLOPT_RTSP_STREAM_URI=10191, CURLOPT_RTSP_TRANSPORT=10192, CURLOPT_RTSP_CLIENT_CSEQ=193, CURLOPT_RTSP_SERVER_CSEQ=194, CURLOPT_INTERLEAVEDATA=10195, CURLOPT_INTERLEAVEFUNCTION=20196, CURLOPT_WILDCARDMATCH=197, CURLOPT_CHUNK_BGN_FUNCTION=20198, CURLOPT_CHUNK_END_FUNCTION=20199, CURLOPT_FNMATCH_FUNCTION=20200, CURLOPT_CHUNK_DATA=10201, CURLOPT_FNMATCH_DATA=10202, CURLOPT_RESOLVE=10203, CURLOPT_TLSAUTH_USERNAME=10204, CURLOPT_TLSAUTH_PASSWORD=10205, CURLOPT_TLSAUTH_TYPE=10206, CURLOPT_TRANSFER_ENCODING=207, CURLOPT_CLOSESOCKETFUNCTION=20208, CURLOPT_CLOSESOCKETDATA=10209, CURLOPT_GSSAPI_DELEGATION=210, CURLOPT_DNS_SERVERS=10211, CURLOPT_ACCEPTTIMEOUT_MS=212, CURLOPT_TCP_KEEPALIVE=213, CURLOPT_TCP_KEEPIDLE=214, CURLOPT_TCP_KEEPINTVL=215, CURLOPT_SSL_OPTIONS=216, CURLOPT_MAIL_AUTH=10217, CURLOPT_SASL_IR=218, CURLOPT_XFERINFOFUNCTION=20219, CURLOPT_XOAUTH2_BEARER=10220, CURLOPT_DNS_INTERFACE=10221, CURLOPT_DNS_LOCAL_IP4=10222, CURLOPT_DNS_LOCAL_IP6=10223, CURLOPT_LOGIN_OPTIONS=10224, CURLOPT_SSL_ENABLE_NPN=225, CURLOPT_SSL_ENABLE_ALPN=226, CURLOPT_EXPECT_100_TIMEOUT_MS=227, CURLOPT_PROXYHEADER=10228, CURLOPT_HEADEROPT=229, CURLOPT_PINNEDPUBLICKEY=10230, CURLOPT_UNIX_SOCKET_PATH=10231, CURLOPT_SSL_VERIFYSTATUS=232, CURLOPT_SSL_FALSESTART=233, CURLOPT_PATH_AS_IS=234, CURLOPT_PROXY_SERVICE_NAME=10235, CURLOPT_SERVICE_NAME=10236, CURLOPT_PIPEWAIT=237, CURLOPT_DEFAULT_PROTOCOL=10238, CURLOPT_STREAM_WEIGHT=239, CURLOPT_STREAM_DEPENDS=10240, CURLOPT_STREAM_DEPENDS_E=10241, CURLOPT_LASTENTRY=10242 };

// #anon_enum_FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0_FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1_FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2_FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3
// file /usr/include/FLAC/format.h line 381
enum anonymous_28 { FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0, FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1, FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2, FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3 };

// #anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1
// file /usr/include/FLAC/format.h line 194
enum anonymous_31 { FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1 };

// #anon_enum_FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0_FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1
// file /usr/include/FLAC/format.h line 396
enum anonymous_29 { FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0, FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1 };

// #anon_enum_FLAC__METADATA_TYPE_STREAMINFO=0_FLAC__METADATA_TYPE_PADDING=1_FLAC__METADATA_TYPE_APPLICATION=2_FLAC__METADATA_TYPE_SEEKTABLE=3_FLAC__METADATA_TYPE_VORBIS_COMMENT=4_FLAC__METADATA_TYPE_CUESHEET=5_FLAC__METADATA_TYPE_PICTURE=6_FLAC__METADATA_TYPE_UNDEFINED=7_FLAC__MAX_METADATA_TYPE=126
// file /usr/include/FLAC/format.h line 489
enum anonymous_36 { FLAC__METADATA_TYPE_STREAMINFO=0, FLAC__METADATA_TYPE_PADDING=1, FLAC__METADATA_TYPE_APPLICATION=2, FLAC__METADATA_TYPE_SEEKTABLE=3, FLAC__METADATA_TYPE_VORBIS_COMMENT=4, FLAC__METADATA_TYPE_CUESHEET=5, FLAC__METADATA_TYPE_PICTURE=6, FLAC__METADATA_TYPE_UNDEFINED=7, FLAC__MAX_METADATA_TYPE=126 };

// #anon_enum_FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC=0_FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER=1_FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH=2_FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM=3
// file /usr/include/FLAC/stream_decoder.h line 427
enum anonymous_53 { FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC=0, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER=1, FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH=2, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM=3 };

// #anon_enum_FLAC__STREAM_DECODER_INIT_STATUS_OK=0_FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER=1_FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS=2_FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR=3_FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE=4_FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED=5
// file /usr/include/FLAC/stream_decoder.h line 256
enum anonymous_48 { FLAC__STREAM_DECODER_INIT_STATUS_OK=0, FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER=1, FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS=2, FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR=3, FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE=4, FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED=5 };

// #anon_enum_FLAC__STREAM_DECODER_LENGTH_STATUS_OK=0_FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR=1_FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED=2
// file /usr/include/FLAC/stream_decoder.h line 371
enum anonymous_51 { FLAC__STREAM_DECODER_LENGTH_STATUS_OK=0, FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR=1, FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED=2 };

// #anon_enum_FLAC__STREAM_DECODER_READ_STATUS_CONTINUE=0_FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM=1_FLAC__STREAM_DECODER_READ_STATUS_ABORT=2
// file /usr/include/FLAC/stream_decoder.h line 294
enum anonymous_23 { FLAC__STREAM_DECODER_READ_STATUS_CONTINUE=0, FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM=1, FLAC__STREAM_DECODER_READ_STATUS_ABORT=2 };

// #anon_enum_FLAC__STREAM_DECODER_SEARCH_FOR_METADATA=0_FLAC__STREAM_DECODER_READ_METADATA=1_FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC=2_FLAC__STREAM_DECODER_READ_FRAME=3_FLAC__STREAM_DECODER_END_OF_STREAM=4_FLAC__STREAM_DECODER_OGG_ERROR=5_FLAC__STREAM_DECODER_SEEK_ERROR=6_FLAC__STREAM_DECODER_ABORTED=7_FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR=8_FLAC__STREAM_DECODER_UNINITIALIZED=9
// file /usr/include/FLAC/stream_decoder.h line 202
enum anonymous_45 { FLAC__STREAM_DECODER_SEARCH_FOR_METADATA=0, FLAC__STREAM_DECODER_READ_METADATA=1, FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC=2, FLAC__STREAM_DECODER_READ_FRAME=3, FLAC__STREAM_DECODER_END_OF_STREAM=4, FLAC__STREAM_DECODER_OGG_ERROR=5, FLAC__STREAM_DECODER_SEEK_ERROR=6, FLAC__STREAM_DECODER_ABORTED=7, FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR=8, FLAC__STREAM_DECODER_UNINITIALIZED=9 };

// #anon_enum_FLAC__STREAM_DECODER_SEEK_STATUS_OK=0_FLAC__STREAM_DECODER_SEEK_STATUS_ERROR=1_FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED=2
// file /usr/include/FLAC/stream_decoder.h line 325
enum anonymous_49 { FLAC__STREAM_DECODER_SEEK_STATUS_OK=0, FLAC__STREAM_DECODER_SEEK_STATUS_ERROR=1, FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED=2 };

// #anon_enum_FLAC__STREAM_DECODER_TELL_STATUS_OK=0_FLAC__STREAM_DECODER_TELL_STATUS_ERROR=1_FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED=2
// file /usr/include/FLAC/stream_decoder.h line 348
enum anonymous_50 { FLAC__STREAM_DECODER_TELL_STATUS_OK=0, FLAC__STREAM_DECODER_TELL_STATUS_ERROR=1, FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED=2 };

// #anon_enum_FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE=0_FLAC__STREAM_DECODER_WRITE_STATUS_ABORT=1
// file /usr/include/FLAC/stream_decoder.h line 394
enum anonymous_52 { FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE=0, FLAC__STREAM_DECODER_WRITE_STATUS_ABORT=1 };

// #anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21
// file /usr/include/FLAC/format.h line 732
enum anonymous_62 { FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0, FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1, FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2, FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3, FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4, FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5, FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6, FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7, FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8, FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9, FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10, FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11, FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12, FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13, FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14, FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15, FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16, FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17, FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18, FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19, FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20, FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21 };

// #anon_enum_FLAC__SUBFRAME_TYPE_CONSTANT=0_FLAC__SUBFRAME_TYPE_VERBATIM=1_FLAC__SUBFRAME_TYPE_FIXED=2_FLAC__SUBFRAME_TYPE_LPC=3
// file /usr/include/FLAC/format.h line 267
enum anonymous_38 { FLAC__SUBFRAME_TYPE_CONSTANT=0, FLAC__SUBFRAME_TYPE_VERBATIM=1, FLAC__SUBFRAME_TYPE_FIXED=2, FLAC__SUBFRAME_TYPE_LPC=3 };

// #anon_enum_PLAY=0_STOP=1_PAUSE=2_NEXT=3_QUIT=4
// file remote.c line 49
enum anonymous_11 { PLAY=0, STOP=1, PAUSE=2, NEXT=3, QUIT=4 };

// #anon_enum_opt_type_none=0_opt_type_bool=1_opt_type_char=2_opt_type_string=3_opt_type_int=4_opt_type_float=5_opt_type_double=6
// file cfgfile_options.h line 23
enum anonymous_1 { opt_type_none=0, opt_type_bool=1, opt_type_char=2, opt_type_string=3, opt_type_int=4, opt_type_float=5, opt_type_double=6 };

// #anon_enum_parse_ok=0_parse_syserr=1_parse_keynotfound=2_parse_nokey=3_parse_badvalue=4_parse_badtype=5
// file cfgfile_options.h line 33
enum anonymous_0 { parse_ok=0, parse_syserr=1, parse_keynotfound=2, parse_nokey=3, parse_badvalue=4, parse_badtype=5 };

// #anon_enum_stat_noarg=0_stat_intarg=1_stat_stringarg=2_stat_floatarg=3_stat_doublearg=4
// file status.h line 30
enum anonymous_67 { stat_noarg=0, stat_intarg=1, stat_stringarg=2, stat_floatarg=3, stat_doublearg=4 };

// tag-#anon#ST[*{S8}_S8_'key'||*{S8}_S8_'formatstr'|]
// file vorbis_comments.c line 35
struct anonymous_16;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-FLAC__StreamDecoderProtected#}_SYM#tag-FLAC__StreamDecoderProtected#_'protected_'||*{SYM#tag-FLAC__StreamDecoderPrivate#}_SYM#tag-FLAC__StreamDecoderPrivate#_'private_'|]#}_SYM#tag-#anon#ST[*{SYM#tag-FLAC__StreamDecoderProtected#}_SYM#tag-FLAC__StreamDecoderProtected#_'protected_'||*{SYM#tag-FLAC__StreamDecoderPrivate#}_SYM#tag-FLAC__StreamDecoderPrivate#_'private_'|]#_'decoder'||S32'is_oggflac'||S16'channels'||U16'_pad0'||S32'rate'||S32'bits_per_sample'||S64'totalsamples'||S64'currentsample'||S64'samples_decoded'||S64'samples_decoded_previous'||S64'bytes_read'||S64'bytes_read_previous'||*{SYM#tag-#anon#ST[EN#anon_enum_FLAC__METADATA_TYPE_STREAMINFO=0_FLAC__METADATA_TYPE_PADDING=1_FLAC__METADATA_TYPE_APPLICATION=2_FLAC__METADATA_TYPE_SEEKTABLE=3_FLAC__METADATA_TYPE_VORBIS_COMMENT=4_FLAC__METADATA_TYPE_CUESHEET=5_FLAC__METADATA_TYPE_PICTURE=6_FLAC__METADATA_TYPE_UNDEFINED=7_FLAC__MAX_METADATA_TYPE=126#{U32}_U32_'type'||S32'is_last'||U32'length'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'min_blocksize'||U32'max_blocksize'||U32'min_framesize'||U32'max_framesize'||U32'sample_rate'||U32'channels'||U32'bits_per_sample'||U32'_pad0'||U64'total_samples'||ARR16{U8}_U8_'md5sum'|]#'stream_info'||SYM#tag-#anon#ST[S32'dummy'|]#'padding'||SYM#tag-#anon#ST[ARR4{U8}_U8_'id'||U32'_pad0'||*{U8}_U8_'data'|]#'application'||SYM#tag-#anon#ST[U32'num_points'||U32'_pad0'||*{SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#}_SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#_'points'|]#'seek_table'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#'vendor_string'||U32'num_comments'||U32'_pad0'||*{SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#}_SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#_'comments'|]#'vorbis_comment'||SYM#tag-#anon#ST[ARR129{S8}_S8_'media_catalog_number'||U56'_pad0'||U64'lead_in'||S32'is_cd'||U32'num_tracks'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#_'tracks'|]#'cue_sheet'||SYM#tag-#anon#ST[EN#anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#{U32}_U32_'type'||U32'_pad0'||*{S8}_S8_'mime_type'||*{U8}_U8_'description'||U32'width'||U32'height'||U32'depth'||U32'colors'||U32'data_length'||U32'_pad1'||*{U8}_U8_'data'|]#'picture'||SYM#tag-#anon#ST[*{U8}_U8_'data'|]#'unknown'|]#'data'|]#}_SYM#tag-#anon#ST[EN#anon_enum_FLAC__METADATA_TYPE_STREAMINFO=0_FLAC__METADATA_TYPE_PADDING=1_FLAC__METADATA_TYPE_APPLICATION=2_FLAC__METADATA_TYPE_SEEKTABLE=3_FLAC__METADATA_TYPE_VORBIS_COMMENT=4_FLAC__METADATA_TYPE_CUESHEET=5_FLAC__METADATA_TYPE_PICTURE=6_FLAC__METADATA_TYPE_UNDEFINED=7_FLAC__MAX_METADATA_TYPE=126#{U32}_U32_'type'||S32'is_last'||U32'length'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'min_blocksize'||U32'max_blocksize'||U32'min_framesize'||U32'max_framesize'||U32'sample_rate'||U32'channels'||U32'bits_per_sample'||U32'_pad0'||U64'total_samples'||ARR16{U8}_U8_'md5sum'|]#'stream_info'||SYM#tag-#anon#ST[S32'dummy'|]#'padding'||SYM#tag-#anon#ST[ARR4{U8}_U8_'id'||U32'_pad0'||*{U8}_U8_'data'|]#'application'||SYM#tag-#anon#ST[U32'num_points'||U32'_pad0'||*{SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#}_SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#_'points'|]#'seek_table'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#'vendor_string'||U32'num_comments'||U32'_pad0'||*{SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#}_SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#_'comments'|]#'vorbis_comment'||SYM#tag-#anon#ST[ARR129{S8}_S8_'media_catalog_number'||U56'_pad0'||U64'lead_in'||S32'is_cd'||U32'num_tracks'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#_'tracks'|]#'cue_sheet'||SYM#tag-#anon#ST[EN#anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#{U32}_U32_'type'||U32'_pad0'||*{S8}_S8_'mime_type'||*{U8}_U8_'description'||U32'width'||U32'height'||U32'depth'||U32'colors'||U32'data_length'||U32'_pad1'||*{U8}_U8_'data'|]#'picture'||SYM#tag-#anon#ST[*{U8}_U8_'data'|]#'unknown'|]#'data'|]#_'comments'||S32'bos'||S32'eos'||*{*{S32}_S32_}_*{S32}_S32__'buf'||S32'buf_len'||S32'buf_start'||S32'buf_fill'||U32'_pad1'||SYM#tag-decoder_stats_t#'stats'|]
// file flac_format.c line 40
struct anonymous_21;

// tag-#anon#ST[*{SYM#tag-FLAC__StreamDecoderProtected#}_SYM#tag-FLAC__StreamDecoderProtected#_'protected_'||*{SYM#tag-FLAC__StreamDecoderPrivate#}_SYM#tag-FLAC__StreamDecoderPrivate#_'private_'|]
// file /usr/include/FLAC/stream_decoder.h line 463
struct anonymous_19;

// tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]
// file /usr/include/FLAC/format.h line 214
struct anonymous_32;

// tag-#anon#ST[*{U64(*{V}_V_|U64|U64|*{V}_V_)->U64}_U64(*{V}_V_|U64|U64|*{V}_V_)->U64_'read_func'||*{S32(*{V}_V_|S64|S32)->S32}_S32(*{V}_V_|S64|S32)->S32_'seek_func'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'close_func'||*{S64(*{V}_V_)->S64}_S64(*{V}_V_)->S64_'tell_func'|]
// file /usr/include/vorbis/vorbisfile.h line 39
struct anonymous_9;

// tag-#anon#ST[*{U8}_U8_'body_data'||S64'body_storage'||S64'body_fill'||S64'body_returned'||*{S32}_S32_'lacing_vals'||*{S64}_S64_'granule_vals'||S64'lacing_storage'||S64'lacing_fill'||S64'lacing_packet'||S64'lacing_returned'||ARR282{U8}_U8_'header'||U16'_pad0'||S32'header_fill'||S32'e_o_s'||S32'b_o_s'||S64'serialno'||S64'pageno'||S64'packetno'||S64'granulepos'|]
// file /usr/include/ogg/ogg.h line 53
struct anonymous_8;

// tag-#anon#ST[*{U8}_U8_'data'|]
// file /usr/include/FLAC/format.h line 827
struct anonymous_64;

// tag-#anon#ST[*{U8}_U8_'data'||S32'storage'||S32'fill'||S32'returned'||S32'unsynced'||S32'headerbytes'||S32'bodybytes'|]
// file /usr/include/ogg/ogg.h line 105
struct anonymous_7;

// tag-#anon#ST[*{U8}_U8_'header'||S64'header_len'||*{U8}_U8_'body'||S64'body_len'|]
// file /usr/include/ogg/ogg.h line 43
struct anonymous_66;

// tag-#anon#ST[*{U8}_U8_'packet'||S64'bytes'||S64'b_o_s'||S64'e_o_s'||S64'granulepos'||S64'packetno'|]
// file /usr/include/ogg/ogg.h line 90
struct anonymous_65;

// tag-#anon#ST[*{cS32}_cS32_'data'|]
// file /usr/include/FLAC/format.h line 291
struct anonymous_42;

// tag-#anon#ST[ARR129{S8}_S8_'media_catalog_number'||U56'_pad0'||U64'lead_in'||S32'is_cd'||U32'num_tracks'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#_'tracks'|]
// file /usr/include/FLAC/format.h line 703
struct anonymous_61;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_14;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_34;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#_'__cancel_jmp_buf'||ARR4{*{V}_V_}_*{V}_V__'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous_10;

// tag-#anon#ST[ARR4{U8}_U8_'id'||U32'_pad0'||*{U8}_U8_'data'|]
// file /usr/include/FLAC/format.h line 565
struct anonymous_56;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous_12;

// tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]
// file /usr/include/FLAC/format.h line 255
struct anonymous_37;

// tag-#anon#ST[EN#anon_enum_FLAC__METADATA_TYPE_STREAMINFO=0_FLAC__METADATA_TYPE_PADDING=1_FLAC__METADATA_TYPE_APPLICATION=2_FLAC__METADATA_TYPE_SEEKTABLE=3_FLAC__METADATA_TYPE_VORBIS_COMMENT=4_FLAC__METADATA_TYPE_CUESHEET=5_FLAC__METADATA_TYPE_PICTURE=6_FLAC__METADATA_TYPE_UNDEFINED=7_FLAC__MAX_METADATA_TYPE=126#{U32}_U32_'type'||S32'is_last'||U32'length'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'min_blocksize'||U32'max_blocksize'||U32'min_framesize'||U32'max_framesize'||U32'sample_rate'||U32'channels'||U32'bits_per_sample'||U32'_pad0'||U64'total_samples'||ARR16{U8}_U8_'md5sum'|]#'stream_info'||SYM#tag-#anon#ST[S32'dummy'|]#'padding'||SYM#tag-#anon#ST[ARR4{U8}_U8_'id'||U32'_pad0'||*{U8}_U8_'data'|]#'application'||SYM#tag-#anon#ST[U32'num_points'||U32'_pad0'||*{SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#}_SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#_'points'|]#'seek_table'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#'vendor_string'||U32'num_comments'||U32'_pad0'||*{SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#}_SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#_'comments'|]#'vorbis_comment'||SYM#tag-#anon#ST[ARR129{S8}_S8_'media_catalog_number'||U56'_pad0'||U64'lead_in'||S32'is_cd'||U32'num_tracks'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#_'tracks'|]#'cue_sheet'||SYM#tag-#anon#ST[EN#anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#{U32}_U32_'type'||U32'_pad0'||*{S8}_S8_'mime_type'||*{U8}_U8_'description'||U32'width'||U32'height'||U32'depth'||U32'colors'||U32'data_length'||U32'_pad1'||*{U8}_U8_'data'|]#'picture'||SYM#tag-#anon#ST[*{U8}_U8_'data'|]#'unknown'|]#'data'|]
// file /usr/include/FLAC/format.h line 834
struct anonymous_20;

// tag-#anon#ST[EN#anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#{U32}_U32_'type'||U32'_pad0'||*{S8}_S8_'mime_type'||*{U8}_U8_'description'||U32'width'||U32'height'||U32'depth'||U32'colors'||U32'data_length'||U32'_pad1'||*{U8}_U8_'data'|]
// file /usr/include/FLAC/format.h line 769
struct anonymous_63;

// tag-#anon#ST[EN#anon_enum_FLAC__SUBFRAME_TYPE_CONSTANT=0_FLAC__SUBFRAME_TYPE_VERBATIM=1_FLAC__SUBFRAME_TYPE_FIXED=2_FLAC__SUBFRAME_TYPE_LPC=3#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'value'|]#'constant'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]#'fixed'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}_S32_'qlp_coeff'||ARR32{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]#'lpc'||SYM#tag-#anon#ST[*{cS32}_cS32_'data'|]#'verbatim'|]#'data'||U32'wasted_bits'||U32'_pad1'|]
// file /usr/include/FLAC/format.h line 344
struct anonymous_25;

// tag-#anon#ST[F32'scale_factor'||F32'max_scale'|]
// file vgfilter.h line 55
struct anonymous_5;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_40;

// tag-#anon#ST[S32'dummy'|]
// file /usr/include/FLAC/format.h line 554
struct anonymous_55;

// tag-#anon#ST[S32'value'|]
// file /usr/include/FLAC/format.h line 284
struct anonymous_39;

// tag-#anon#ST[S32'verbosity'||S8'enabled'||U24'_pad0'||*{cS8}_cS8_'formatstr'||EN#anon_enum_stat_noarg=0_stat_intarg=1_stat_stringarg=2_stat_floatarg=3_stat_doublearg=4#{U32}_U32_'type'||U32'_pad1'||SYM#tag-#anon#UN[S32'intarg'||*{S8}_S8_'stringarg'||F32'floatarg'||F64'doublearg'|]#'arg'|]
// file status.h line 26
struct anonymous_3;

// tag-#anon#ST[S64'endbyte'||S32'endbit'||U32'_pad0'||*{U8}_U8_'buffer'||*{U8}_U8_'ptr'||S64'storage'|]
// file /usr/include/ogg/ogg.h line 32
struct anonymous_6;

// tag-#anon#ST[S8'mask'||S8'value'||U16'_pad0'||U32'after'|]
// file utf8.c line 341
struct anonymous;

// tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]
// file /usr/include/FLAC/format.h line 298
struct anonymous_43;

// tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}_S32_'qlp_coeff'||ARR32{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]
// file /usr/include/FLAC/format.h line 315
struct anonymous_44;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'blocksize'||U32'sample_rate'||U32'channels'||EN#anon_enum_FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0_FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1_FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2_FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3#{U32}_U32_'channel_assignment'||U32'bits_per_sample'||EN#anon_enum_FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0_FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1#{U32}_U32_'number_type'||SYM#tag-#anon#UN[U32'frame_number'||U64'sample_number'|]#'number'||U8'crc'||U56'_pad0'|]#'header'||ARR8{SYM#tag-#anon#ST[EN#anon_enum_FLAC__SUBFRAME_TYPE_CONSTANT=0_FLAC__SUBFRAME_TYPE_VERBATIM=1_FLAC__SUBFRAME_TYPE_FIXED=2_FLAC__SUBFRAME_TYPE_LPC=3#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'value'|]#'constant'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]#'fixed'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}_S32_'qlp_coeff'||ARR32{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]#'lpc'||SYM#tag-#anon#ST[*{cS32}_cS32_'data'|]#'verbatim'|]#'data'||U32'wasted_bits'||U32'_pad1'|]#}_SYM#tag-#anon#ST[EN#anon_enum_FLAC__SUBFRAME_TYPE_CONSTANT=0_FLAC__SUBFRAME_TYPE_VERBATIM=1_FLAC__SUBFRAME_TYPE_FIXED=2_FLAC__SUBFRAME_TYPE_LPC=3#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'value'|]#'constant'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]#'fixed'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}_S32_'qlp_coeff'||ARR32{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]#'lpc'||SYM#tag-#anon#ST[*{cS32}_cS32_'data'|]#'verbatim'|]#'data'||U32'wasted_bits'||U32'_pad1'|]#_'subframes'||SYM#tag-#anon#ST[U16'crc'|]#'footer'||U48'_pad0'|]
// file /usr/include/FLAC/format.h line 473
struct anonymous_27;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#'vendor_string'||U32'num_comments'||U32'_pad0'||*{SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#}_SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#_'comments'|]
// file /usr/include/FLAC/format.h line 634
struct anonymous_18;

// tag-#anon#ST[U16'crc'|]
// file /usr/include/FLAC/format.h line 460
struct anonymous_26;

// tag-#anon#ST[U32'blocksize'||U32'sample_rate'||U32'channels'||EN#anon_enum_FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0_FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1_FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2_FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3#{U32}_U32_'channel_assignment'||U32'bits_per_sample'||EN#anon_enum_FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0_FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1#{U32}_U32_'number_type'||SYM#tag-#anon#UN[U32'frame_number'||U64'sample_number'|]#'number'||U8'crc'||U56'_pad0'|]
// file /usr/include/FLAC/format.h line 411
struct anonymous_24;

// tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]
// file /usr/include/FLAC/format.h line 624
struct anonymous_17;

// tag-#anon#ST[U32'min_blocksize'||U32'max_blocksize'||U32'min_framesize'||U32'max_framesize'||U32'sample_rate'||U32'channels'||U32'bits_per_sample'||U32'_pad0'||U64'total_samples'||ARR16{U8}_U8_'md5sum'|]
// file /usr/include/FLAC/format.h line 529
struct anonymous_54;

// tag-#anon#ST[U32'num_points'||U32'_pad0'||*{SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#}_SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#_'points'|]
// file /usr/include/FLAC/format.h line 612
struct anonymous_58;

// tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]
// file /usr/include/FLAC/format.h line 233
struct anonymous_33;

// tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]
// file /usr/include/FLAC/format.h line 666
struct anonymous_60;

// tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]
// file /usr/include/FLAC/format.h line 647
struct anonymous_59;

// tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]
// file /usr/include/FLAC/format.h line 574
struct anonymous_57;

// tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous_15;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_22;

// tag-#anon#UN[S32'intarg'||*{S8}_S8_'stringarg'||F32'floatarg'||F64'doublearg'|]
// file status.h line 37
union anonymous_68;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_41;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'value'|]#'constant'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]#'fixed'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}_U32_'type'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}_S32_'qlp_coeff'||ARR32{S32}_S32_'warmup'||U32'_pad0'||*{cS32}_cS32_'residual'|]#'lpc'||SYM#tag-#anon#ST[*{cS32}_cS32_'data'|]#'verbatim'|]
// file /usr/include/FLAC/format.h line 346
union anonymous_46;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'min_blocksize'||U32'max_blocksize'||U32'min_framesize'||U32'max_framesize'||U32'sample_rate'||U32'channels'||U32'bits_per_sample'||U32'_pad0'||U64'total_samples'||ARR16{U8}_U8_'md5sum'|]#'stream_info'||SYM#tag-#anon#ST[S32'dummy'|]#'padding'||SYM#tag-#anon#ST[ARR4{U8}_U8_'id'||U32'_pad0'||*{U8}_U8_'data'|]#'application'||SYM#tag-#anon#ST[U32'num_points'||U32'_pad0'||*{SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#}_SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'_pad0'|]#_'points'|]#'seek_table'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#'vendor_string'||U32'num_comments'||U32'_pad0'||*{SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#}_SYM#tag-#anon#ST[U32'length'||U32'_pad0'||*{U8}_U8_'entry'|]#_'comments'|]#'vorbis_comment'||SYM#tag-#anon#ST[ARR129{S8}_S8_'media_catalog_number'||U56'_pad0'||U64'lead_in'||S32'is_cd'||U32'num_tracks'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}_S8_'isrc'||BF{U32}_U32_'type'||BF{U32}_U32_'pre_emphasis'||BF{U6}_U6_'_bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#}_SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'_pad0'|]#_'indices'|]#_'tracks'|]#'cue_sheet'||SYM#tag-#anon#ST[EN#anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#{U32}_U32_'type'||U32'_pad0'||*{S8}_S8_'mime_type'||*{U8}_U8_'description'||U32'width'||U32'height'||U32'depth'||U32'colors'||U32'data_length'||U32'_pad1'||*{U8}_U8_'data'|]#'picture'||SYM#tag-#anon#ST[*{U8}_U8_'data'|]#'unknown'|]
// file /usr/include/FLAC/format.h line 846
union anonymous_47;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'_pad0'||*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'||*{U32}_U32_'raw_bits'||U32'capacity_by_order'||U32'_pad0'|]#_'contents'|]#'partitioned_rice'|]
// file /usr/include/FLAC/format.h line 257
union anonymous_35;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_13;

// tag-#anon#UN[U32'frame_number'||U64'sample_number'|]
// file /usr/include/FLAC/format.h line 432
union anonymous_30;

// tag-FLAC__StreamDecoderPrivate
// file /usr/include/FLAC/stream_decoder.h line 458
struct FLAC__StreamDecoderPrivate;

// tag-FLAC__StreamDecoderProtected
// file /usr/include/FLAC/stream_decoder.h line 457
struct FLAC__StreamDecoderProtected;

// tag-OggVorbis_File
// file /usr/include/vorbis/vorbisfile.h line 111
struct OggVorbis_File;

// tag-SpeexBits
// file /usr/include/speex/speex_bits.h line 49
struct SpeexBits;

// tag-SpeexCallback
// file /usr/include/speex/speex_callbacks.h line 91
struct SpeexCallback;

// tag-SpeexHeader
// file /usr/include/speex/speex_header.h line 59
struct SpeexHeader;

// tag-SpeexMode
// file /usr/include/speex/speex.h line 215
struct SpeexMode;

// tag-SpeexStereoState
// file /usr/include/speex/speex_stereo.h line 50
struct SpeexStereoState;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-action_t
// file buffer.h line 29
struct action_t;

// tag-alloc_chain
// file /usr/include/vorbis/codec.h line 110
struct alloc_chain;

// tag-ao_device
// file /usr/include/ao/ao.h line 77
struct ao_device;

// tag-ao_info
// file /usr/include/ao/ao.h line 64
struct ao_info;

// tag-ao_option
// file /usr/include/ao/ao.h line 87
struct ao_option;

// tag-ao_sample_format
// file /usr/include/ao/ao.h line 79
struct ao_sample_format;

// tag-audio_device_t
// file audio.h line 37
struct audio_device_t;

// tag-audio_format_t
// file audio.h line 26
struct audio_format_t;

// tag-audio_play_arg_t
// file callbacks.h line 30
struct audio_play_arg_t;

// tag-audio_reopen_arg_t
// file callbacks.h line 35
struct audio_reopen_arg_t;

// tag-buf_t
// file buffer.h line 34
struct buf_t;

// tag-buffer_stats_t
// file buffer.h line 87
struct buffer_stats_t;

// tag-curl_slist
// file /usr/include/curl/curl.h line 136
struct curl_slist;

// tag-data_source_stats_t
// file transport.h line 27
struct data_source_stats_t;

// tag-data_source_t
// file transport.h line 39
struct data_source_t;

// tag-decoder_callbacks_t
// file format.h line 37
struct decoder_callbacks_t;

// tag-decoder_stats_t
// file format.h line 26
struct decoder_stats_t;

// tag-decoder_t
// file format.h line 45
struct decoder_t;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-file_option_t
// file cfgfile_options.h line 42
struct file_option_t;

// tag-file_private_t
// file file_transport.c line 30
struct file_private_t;

// tag-format_t
// file format.h line 43
struct format_t;

// tag-http_private_t
// file http_transport.c line 44
struct http_private_t;

// tag-ogg123_options_t
// file ogg123.h line 25
struct ogg123_options_t;

// tag-option
// file ../include/getopt.h line 83
struct option;

// tag-ovf_private_t
// file oggvorbis_format.c line 39
struct ovf_private_t;

// tag-playlist_element_t
// file playlist.h line 21
struct playlist_element_t;

// tag-playlist_t
// file playlist.h line 27
struct playlist_t;

// tag-print_statistics_arg_t
// file callbacks.h line 49
struct print_statistics_arg_t;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-signal_request_t
// file ogg123.h line 54
struct signal_request_t;

// tag-speex_private_t
// file speex_format.c line 44
struct speex_private_t;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-status_message_arg_t
// file callbacks.c line 227
struct status_message_arg_t;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-transport_t
// file transport.h line 37
struct transport_t;

// tag-vorbis_block
// file /usr/include/vorbis/codec.h line 88
struct vorbis_block;

// tag-vorbis_comment
// file /usr/include/vorbis/codec.h line 140
struct vorbis_comment;

// tag-vorbis_dsp_state
// file /usr/include/vorbis/codec.h line 59
struct vorbis_dsp_state;

// tag-vorbis_info
// file /usr/include/vorbis/codec.h line 28
struct vorbis_info;

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// FLAC__metadata_object_clone
// file /usr/include/FLAC/metadata.h line 1327
struct anonymous_20 * FLAC__metadata_object_clone(const struct anonymous_20 *);
// FLAC__stream_decoder_delete
// file /usr/include/FLAC/stream_decoder.h line 751
void FLAC__stream_decoder_delete(struct anonymous_19 *);
// FLAC__stream_decoder_finish
// file /usr/include/FLAC/stream_decoder.h line 1370
signed int FLAC__stream_decoder_finish(struct anonymous_19 *);
// FLAC__stream_decoder_get_state
// file /usr/include/FLAC/stream_decoder.h line 890
enum anonymous_45 FLAC__stream_decoder_get_state(const struct anonymous_19 *);
// FLAC__stream_decoder_init_ogg_stream
// file /usr/include/FLAC/stream_decoder.h line 1154
enum anonymous_48 FLAC__stream_decoder_init_ogg_stream(struct anonymous_19 *, enum anonymous_23 (*)(const struct anonymous_19 *, unsigned char *, unsigned long int *, void *), enum anonymous_49 (*)(const struct anonymous_19 *, unsigned long int, void *), enum anonymous_50 (*)(const struct anonymous_19 *, unsigned long int *, void *), enum anonymous_51 (*)(const struct anonymous_19 *, unsigned long int *, void *), signed int (*)(const struct anonymous_19 *, void *), enum anonymous_52 (*)(const struct anonymous_19 *, const struct anonymous_27 *, const signed int * const *, void *), void (*)(const struct anonymous_19 *, const struct anonymous_20 *, void *), void (*)(const struct anonymous_19 *, enum anonymous_53, void *), void *);
// FLAC__stream_decoder_init_stream
// file /usr/include/FLAC/stream_decoder.h line 1073
enum anonymous_48 FLAC__stream_decoder_init_stream(struct anonymous_19 *, enum anonymous_23 (*)(const struct anonymous_19 *, unsigned char *, unsigned long int *, void *), enum anonymous_49 (*)(const struct anonymous_19 *, unsigned long int, void *), enum anonymous_50 (*)(const struct anonymous_19 *, unsigned long int *, void *), enum anonymous_51 (*)(const struct anonymous_19 *, unsigned long int *, void *), signed int (*)(const struct anonymous_19 *, void *), enum anonymous_52 (*)(const struct anonymous_19 *, const struct anonymous_27 *, const signed int * const *, void *), void (*)(const struct anonymous_19 *, const struct anonymous_20 *, void *), void (*)(const struct anonymous_19 *, enum anonymous_53, void *), void *);
// FLAC__stream_decoder_new
// file /usr/include/FLAC/stream_decoder.h line 743
struct anonymous_19 * FLAC__stream_decoder_new(void);
// FLAC__stream_decoder_process_single
// file /usr/include/FLAC/stream_decoder.h line 1451
signed int FLAC__stream_decoder_process_single(struct anonymous_19 *);
// FLAC__stream_decoder_process_until_end_of_metadata
// file /usr/include/FLAC/stream_decoder.h line 1472
signed int FLAC__stream_decoder_process_until_end_of_metadata(struct anonymous_19 *);
// FLAC__stream_decoder_set_md5_checking
// file /usr/include/FLAC/stream_decoder.h line 798
signed int FLAC__stream_decoder_set_md5_checking(struct anonymous_19 *, signed int);
// FLAC__stream_decoder_set_metadata_respond
// file /usr/include/FLAC/stream_decoder.h line 812
signed int FLAC__stream_decoder_set_metadata_respond(struct anonymous_19 *, enum anonymous_36);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_10 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_10 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_10 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void);
// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void);
// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void);
// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void);
// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void);
// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void);
// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void);
// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void);
// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void);
// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void);
// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void);
// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void);
// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void);
// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void);
// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void);
// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void);
// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void);
// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void);
// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void);
// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void);
// add_ao_option
// file audio.c line 77
signed int add_ao_option(struct ao_option **op_h, const char *optstring);
// alphasort
// file /usr/include/dirent.h line 324
extern signed int alphasort(struct dirent **, struct dirent **);
// ao_append_global_option
// file /usr/include/ao/ao.h line 104
signed int ao_append_global_option(const char *, const char *);
// ao_append_option
// file /usr/include/ao/ao.h line 106
signed int ao_append_option(struct ao_option **, const char *, const char *);
// ao_close
// file /usr/include/ao/ao.h line 122
signed int ao_close(struct ao_device *);
// ao_default_driver_id
// file /usr/include/ao/ao.h line 126
signed int ao_default_driver_id(void);
// ao_driver_id
// file /usr/include/ao/ao.h line 125
signed int ao_driver_id(const char *);
// ao_driver_info
// file /usr/include/ao/ao.h line 127
struct ao_info * ao_driver_info(signed int);
// ao_driver_info_list
// file /usr/include/ao/ao.h line 128
struct ao_info ** ao_driver_info_list(signed int *);
// ao_initialize
// file /usr/include/ao/ao.h line 100
void ao_initialize(void);
// ao_is_big_endian
// file /usr/include/ao/ao.h line 132
signed int ao_is_big_endian(void);
// ao_onexit
// file audio.c line 121
void ao_onexit(void *arg);
// ao_open_file
// file /usr/include/ao/ao.h line 113
struct ao_device * ao_open_file(signed int, const char *, signed int, struct ao_sample_format *, struct ao_option *);
// ao_open_live
// file /usr/include/ao/ao.h line 110
struct ao_device * ao_open_live(signed int, struct ao_sample_format *, struct ao_option *);
// ao_play
// file /usr/include/ao/ao.h line 119
signed int ao_play(struct ao_device *, char *, unsigned int);
// ao_shutdown
// file /usr/include/ao/ao.h line 101
void ao_shutdown(void);
// append_audio_device
// file audio.c line 41
struct audio_device_t * append_audio_device(struct audio_device_t *devices_list, signed int driver_id, struct ao_option *options, char *filename);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// audio_devices_write
// file audio.c line 65
signed int audio_devices_write(struct audio_device_t *d, void *ptr, signed int nbytes);
// audio_format_equal
// file audio.c line 29
signed int audio_format_equal(struct audio_format_t *a, struct audio_format_t *b);
// audio_play_callback
// file callbacks.c line 33
signed int audio_play_callback(void *ptr, signed int nbytes, signed int eos, void *arg);
// audio_reopen_action
// file callbacks.c line 43
void audio_reopen_action(struct buf_t *buf, void *arg);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// buffer_abort_write
// file buffer.c line 641
void buffer_abort_write(struct buf_t *buf);
// buffer_abort_write::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// buffer_action_now
// file buffer.c line 659
void buffer_action_now(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg);
// buffer_action_now::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);

//

// buffer_append_action_at
// file buffer.c line 747
void buffer_append_action_at(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg, signed long int position);
// buffer_append_action_at::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);

//

// buffer_append_action_at_end
// file buffer.c line 704
void buffer_append_action_at_end(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg);
// buffer_append_action_at_end::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);

//

// buffer_create
// file buffer.c line 396
struct buf_t * buffer_create(signed long int size, signed long int prebuffer, signed int (*write_func)(void *, signed int, signed int, void *), void *arg, signed int audio_chunk_size);

//

// buffer_destroy
// file buffer.c line 471
void buffer_destroy(struct buf_t *buf);
// buffer_full
// file buffer.c line 795
signed long int buffer_full(struct buf_t *buf);
// buffer_get_data
// file buffer.c line 552
unsigned long int buffer_get_data(struct buf_t *buf, char *data, signed long int nbytes);
// buffer_get_data::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// buffer_init_vars
// file buffer.c line 63
void buffer_init_vars(struct buf_t *buf);
// buffer_insert_action_at
// file buffer.c line 726
void buffer_insert_action_at(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg, signed long int position);
// buffer_insert_action_at::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);

//

// buffer_insert_action_at_end
// file buffer.c line 682
void buffer_insert_action_at_end(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg);
// buffer_insert_action_at_end::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);

//

// buffer_mark_eos
// file buffer.c line 626
void buffer_mark_eos(struct buf_t *buf);
// buffer_mark_eos::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// buffer_mutex_unlock
// file buffer.c line 102
void buffer_mutex_unlock(void *arg);
// buffer_reset
// file buffer.c line 446
void buffer_reset(struct buf_t *buf);
// buffer_statistics
// file buffer.c line 801
struct buffer_stats_t * buffer_statistics(struct buf_t *buf);
// buffer_statistics::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// buffer_submit_data
// file buffer.c line 548
signed int buffer_submit_data(struct buf_t *buf, char *data, signed long int nbytes);
// buffer_thread_cleanup
// file buffer.c line 94
void buffer_thread_cleanup(void *arg);
// buffer_thread_func
// file buffer.c line 195
void * buffer_thread_func(void *arg);
// buffer_thread_func::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// buffer_thread_init
// file buffer.c line 78
void buffer_thread_init(struct buf_t *buf);
// buffer_thread_kill
// file buffer.c line 528
void buffer_thread_kill(struct buf_t *buf);
// buffer_thread_pause
// file buffer.c line 499
void buffer_thread_pause(struct buf_t *buf);
// buffer_thread_pause::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// buffer_thread_start
// file buffer.c line 488
signed int buffer_thread_start(struct buf_t *buf);
// buffer_thread_unpause
// file buffer.c line 513
void buffer_thread_unpause(struct buf_t *buf);
// buffer_thread_unpause::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// buffer_wait_for_empty
// file buffer.c line 770
void buffer_wait_for_empty(struct buf_t *buf);
// buffer_wait_for_empty::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// checknext
// file utf8.c line 331
static signed int checknext(const char *s, signed int count);
// clear_line
// file status.c line 92
void clear_line(signed int len);
// close_audio_devices
// file audio.c line 98
void close_audio_devices(struct audio_device_t *devices);
// cmdline_usage
// file cmdline_options.c line 301
void cmdline_usage(void);
// compute_dequeue_size
// file buffer.c line 169
signed int compute_dequeue_size(struct buf_t *buf, signed int request_size);
// convert_buffer
// file utf8.c line 252
static signed int convert_buffer(const char *fromcode, const char *tocode, const char *from, unsigned long int fromlen, char **to, unsigned long int *tolen);
// convert_set_charset
// file utf8.c line 235
void convert_set_charset(const char *charset);
// convert_string
// file utf8.c line 273
static signed int convert_string(const char *fromcode, const char *tocode, const char *from, char **to, char replace);
// curl_easy_cleanup
// file /usr/include/curl/easy.h line 31
void curl_easy_cleanup(void *);
// curl_easy_init
// file /usr/include/curl/easy.h line 28
void * curl_easy_init(void);
// curl_easy_perform
// file /usr/include/curl/easy.h line 30
enum anonymous_2 curl_easy_perform(void *);
// curl_easy_setopt
// file /usr/include/curl/easy.h line 29
enum anonymous_2 curl_easy_setopt(void *, enum anonymous_4, ...);
// curl_slist_append
// file /usr/include/curl/curl.h line 2062
struct curl_slist * curl_slist_append(struct curl_slist *, const char *);
// curl_slist_free_all
// file /usr/include/curl/curl.h line 2072
void curl_slist_free_all(struct curl_slist *);
// curl_thread_func
// file http_transport.c line 133
void * curl_thread_func(void *arg);
// current_time
// file ogg123.c line 356
double current_time(struct decoder_t *decoder);
// decoder_buffered_error_callback
// file callbacks.c line 271
void decoder_buffered_error_callback(void *arg, signed int severity, char *message, ...);
// decoder_buffered_metadata_callback
// file callbacks.c line 327
void decoder_buffered_metadata_callback(void *arg, signed int verbosity, char *message, ...);
// decoder_error_callback
// file callbacks.c line 193
void decoder_error_callback(void *arg, signed int severity, char *message, ...);
// decoder_metadata_callback
// file callbacks.c line 213
void decoder_metadata_callback(void *arg, signed int verbosity, char *message, ...);
// display_statistics
// file ogg123.c line 283
void display_statistics(struct anonymous_3 *stat_format, struct buf_t *audio_buffer, struct data_source_t *source, struct decoder_t *decoder);
// display_statistics_quick
// file ogg123.c line 339
void display_statistics_quick(struct anonymous_3 *stat_format, struct buf_t *audio_buffer, struct data_source_t *source, struct decoder_t *decoder);
// eof_callback
// file flac_format.c line 542
static signed int eof_callback(const struct anonymous_19 *decoder, void *client_data);
// error_callback
// file flac_format.c line 534
static void error_callback(const struct anonymous_19 *decoder, enum anonymous_53 status, void *client_data);
// execute_actions
// file buffer.c line 148
void execute_actions(struct buf_t *buf, struct action_t **action_list, signed long int position);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_can_transport
// file file_transport.c line 40
signed int file_can_transport(char *source_string);
// file_close
// file file_transport.c line 155
void file_close(struct data_source_t *source);
// file_open
// file file_transport.c line 45
struct data_source_t * file_open(char *source_string, struct ogg123_options_t *ogg123_opts);
// file_options_describe
// file cfgfile_options.c line 110
void file_options_describe(struct file_option_t *opts, struct _IO_FILE *f);
// file_options_init
// file cfgfile_options.c line 68
void file_options_init(struct file_option_t *opts);
// file_peek
// file file_transport.c line 87
signed int file_peek(struct data_source_t *source, void *ptr, unsigned long int size, unsigned long int nmemb);
// file_read
// file file_transport.c line 110
signed int file_read(struct data_source_t *source, void *ptr, unsigned long int size, unsigned long int nmemb);
// file_seek
// file file_transport.c line 125
signed int file_seek(struct data_source_t *source, signed long int offset, signed int whence);
// file_statistics
// file file_transport.c line 136
struct data_source_stats_t * file_statistics(struct data_source_t *source);
// file_tell
// file file_transport.c line 144
signed long int file_tell(struct data_source_t *source);
// flac_can_decode
// file flac_format.c line 103
signed int flac_can_decode(struct data_source_t *source);
// flac_cleanup
// file flac_format.c line 407
void flac_cleanup(struct decoder_t *decoder);
// flac_init
// file flac_format.c line 143
struct decoder_t * flac_init(struct data_source_t *source, struct ogg123_options_t *ogg123_opts, struct audio_format_t *audio_fmt, struct decoder_callbacks_t *callbacks, void *callback_arg);
// flac_read
// file flac_format.c line 250
signed int flac_read(struct decoder_t *decoder, void *ptr, signed int nbytes, signed int *eos, struct audio_format_t *audio_fmt);
// flac_seek
// file flac_format.c line 361
signed int flac_seek(struct decoder_t *decoder, double offset, signed int whence);
// flac_statistics
// file flac_format.c line 369
struct decoder_stats_t * flac_statistics(struct decoder_t *decoder);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_action
// file buffer.c line 162
void free_action(struct action_t *action);
// free_audio_devices
// file audio.c line 110
void free_audio_devices(struct audio_device_t *devices);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// get_format_by_name
// file format.c line 53
struct format_t * get_format_by_name(char *name);
// get_transport_by_name
// file transport.c line 42
struct transport_t * get_transport_by_name(char *name);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file ../include/getopt.h line 140
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getstatus
// file remote.c line 106
static enum anonymous_11 getstatus();
// gettext
// file /usr/include/libintl.h line 39
extern char * gettext(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// handle_seek_opt
// file ogg123.c line 205
signed int handle_seek_opt(struct ogg123_options_t *options, struct decoder_t *decoder, struct format_t *format);
// http_can_transport
// file http_transport.c line 170
signed int http_can_transport(char *source_string);
// http_close
// file http_transport.c line 324
void http_close(struct data_source_t *source);
// http_open
// file http_transport.c line 181
struct data_source_t * http_open(char *source_string, struct ogg123_options_t *ogg123_opts);
// http_peek
// file http_transport.c line 262
signed int http_peek(struct data_source_t *source, void *ptr, unsigned long int size, unsigned long int nmemb);
// http_read
// file http_transport.c line 278
signed int http_read(struct data_source_t *source, void *ptr, unsigned long int size, unsigned long int nmemb);
// http_seek
// file http_transport.c line 294
signed int http_seek(struct data_source_t *source, signed long int offset, signed int whence);
// http_statistics
// file http_transport.c line 300
struct data_source_stats_t * http_statistics(struct data_source_t *source);
// http_tell
// file http_transport.c line 318
signed long int http_tell(struct data_source_t *source);
// iconv
// file /usr/include/iconv.h line 42
extern unsigned long int iconv(void *, char ** restrict , unsigned long int *, char ** restrict , unsigned long int *);
// iconv_close
// file /usr/include/iconv.h line 51
extern signed int iconv_close(void *);
// iconv_open
// file /usr/include/iconv.h line 37
extern void * iconv_open(const char *, const char *);
// iconvert
// file iconvert.c line 51
signed int iconvert(const char *fromcode, const char *tocode, const char *from, unsigned long int fromlen, char **to, unsigned long int *tolen);
// in_order_add_action
// file buffer.c line 135
void in_order_add_action(struct action_t **action_list, struct action_t *action, signed int insert);
// invertpause
// file remote.c line 116
static void invertpause();
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// lookup_comment_prettyprint
// file vorbis_comments.c line 50
char * lookup_comment_prettyprint(char *comment, signed int *offset);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// malloc_action
// file buffer.c line 110
struct action_t * malloc_action(void (*action_func)(struct buf_t *, void *), void *action_arg);

//

// malloc_buffer_stats
// file buffer.c line 377
struct buffer_stats_t * malloc_buffer_stats();
// malloc_data_source_stats
// file transport.h line 60
struct data_source_stats_t * malloc_data_source_stats(struct data_source_stats_t *to_copy);
// malloc_decoder_stats
// file format.c line 75
struct decoder_stats_t * malloc_decoder_stats(struct decoder_stats_t *to_copy);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// metadata_callback
// file flac_format.c line 510
static void metadata_callback(const struct anonymous_19 *decoder, const struct anonymous_20 *metadata, void *client_data);
// new_audio_reopen_arg
// file callbacks.c line 122
struct audio_reopen_arg_t * new_audio_reopen_arg(struct audio_device_t *devices, struct audio_format_t *fmt);
// new_print_statistics_arg
// file callbacks.c line 171
struct print_statistics_arg_t * new_print_statistics_arg(struct anonymous_3 *stat_format, struct data_source_stats_t *data_source_statistics, struct decoder_stats_t *decoder_statistics);
// new_status_message_arg
// file callbacks.c line 233
struct status_message_arg_t * new_status_message_arg(signed int verbosity);
// nl_langinfo
// file /usr/include/langinfo.h line 583
extern char * nl_langinfo(signed int);
// ogg_page_serialno
// file /usr/include/ogg/ogg.h line 199
extern signed int ogg_page_serialno(const struct anonymous_66 *);
// ogg_stream_init
// file /usr/include/ogg/ogg.h line 184
extern signed int ogg_stream_init(struct anonymous_8 *, signed int);
// ogg_stream_packetout
// file /usr/include/ogg/ogg.h line 179
extern signed int ogg_stream_packetout(struct anonymous_8 *, struct anonymous_65 *);
// ogg_stream_pagein
// file /usr/include/ogg/ogg.h line 178
extern signed int ogg_stream_pagein(struct anonymous_8 *, struct anonymous_66 *);
// ogg_sync_buffer
// file /usr/include/ogg/ogg.h line 174
extern char * ogg_sync_buffer(struct anonymous_7 *, signed long int);
// ogg_sync_init
// file /usr/include/ogg/ogg.h line 168
extern signed int ogg_sync_init(struct anonymous_7 *);
// ogg_sync_pageout
// file /usr/include/ogg/ogg.h line 177
extern signed int ogg_sync_pageout(struct anonymous_7 *, struct anonymous_66 *);
// ogg_sync_wrote
// file /usr/include/ogg/ogg.h line 175
extern signed int ogg_sync_wrote(struct anonymous_7 *, signed long int);
// oggflac_can_decode
// file flac_format.c line 117
signed int oggflac_can_decode(struct data_source_t *source);
// options_init
// file ogg123.c line 147
void options_init(struct ogg123_options_t *opts);
// ov_bitrate
// file /usr/include/vorbis/vorbisfile.h line 160
extern signed long int ov_bitrate(struct OggVorbis_File *, signed int);
// ov_bitrate_instant
// file /usr/include/vorbis/vorbisfile.h line 161
extern signed long int ov_bitrate_instant(struct OggVorbis_File *);
// ov_clear
// file /usr/include/vorbis/vorbisfile.h line 149
extern signed int ov_clear(struct OggVorbis_File *);
// ov_comment
// file /usr/include/vorbis/vorbisfile.h line 187
extern struct vorbis_comment * ov_comment(struct OggVorbis_File *, signed int);
// ov_info
// file /usr/include/vorbis/vorbisfile.h line 186
extern struct vorbis_info * ov_info(struct OggVorbis_File *, signed int);
// ov_open_callbacks
// file /usr/include/vorbis/vorbisfile.h line 152
extern signed int ov_open_callbacks(void *, struct OggVorbis_File *, const char *, signed long int, struct anonymous_9);
// ov_pcm_tell
// file /usr/include/vorbis/vorbisfile.h line 183
extern signed long int ov_pcm_tell(struct OggVorbis_File *);
// ov_pcm_total
// file /usr/include/vorbis/vorbisfile.h line 167
extern signed long int ov_pcm_total(struct OggVorbis_File *, signed int);
// ov_read_filter
// file /usr/include/vorbis/vorbisfile.h line 191
extern signed long int ov_read_filter(struct OggVorbis_File *, char *, signed int, signed int, signed int, signed int, signed int *, void (*)(float **, signed long int, signed long int, void *), void *);
// ov_time_seek
// file /usr/include/vorbis/vorbisfile.h line 173
extern signed int ov_time_seek(struct OggVorbis_File *, double);
// ov_time_tell
// file /usr/include/vorbis/vorbisfile.h line 184
extern double ov_time_tell(struct OggVorbis_File *);
// ovf_can_decode
// file oggvorbis_format.c line 66
signed int ovf_can_decode(struct data_source_t *source);
// ovf_cleanup
// file oggvorbis_format.c line 289
void ovf_cleanup(struct decoder_t *decoder);
// ovf_init
// file oggvorbis_format.c line 72
struct decoder_t * ovf_init(struct data_source_t *source, struct ogg123_options_t *ogg123_opts, struct audio_format_t *audio_fmt, struct decoder_callbacks_t *callbacks, void *callback_arg);
// ovf_read
// file oggvorbis_format.c line 125
signed int ovf_read(struct decoder_t *decoder, void *ptr, signed int nbytes, signed int *eos, struct audio_format_t *audio_fmt);
// ovf_seek
// file oggvorbis_format.c line 240
signed int ovf_seek(struct decoder_t *decoder, double offset, signed int whence);
// ovf_statistics
// file oggvorbis_format.c line 262
struct decoder_stats_t * ovf_statistics(struct decoder_t *decoder);
// parse_cmdline_options
// file cmdline_options.c line 63
signed int parse_cmdline_options(signed int argc, char **argv, struct ogg123_options_t *ogg123_opts, struct file_option_t *file_opts);
// parse_config_file
// file cfgfile_options.c line 359
enum anonymous_0 parse_config_file(struct file_option_t *opts, const char *filename);
// parse_error
// file cfgfile_options.c line 50
signed int parse_error(enum anonymous_0 pcode, signed int lineno, const char *filename, char *line);
// parse_error_string
// file cfgfile_options.c line 425
const char * parse_error_string(enum anonymous_0 pcode);
// parse_line
// file cfgfile_options.c line 226
enum anonymous_0 parse_line(struct file_option_t *opts, char *line);
// parse_std_configs
// file cfgfile_options.c line 446
void parse_std_configs(struct file_option_t *opts);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// play
// file ogg123.c line 515
void play(char *source_string);
// playlist_append_directory
// file playlist.h line 51
signed int playlist_append_directory(struct playlist_t *list, char *dirname);
// playlist_append_file
// file playlist.h line 48
signed int playlist_append_file(struct playlist_t *list, char *filename);
// playlist_append_from_file
// file playlist.h line 55
signed int playlist_append_from_file(struct playlist_t *list, char *playlist_filename);
// playlist_array_destroy
// file playlist.h line 65
void playlist_array_destroy(char **array, signed int size);
// playlist_create
// file playlist.h line 36
struct playlist_t * playlist_create();
// playlist_destroy
// file playlist.h line 37
void playlist_destroy(struct playlist_t *list);
// playlist_element_create
// file playlist.c line 39
struct playlist_element_t * playlist_element_create(char *filename);
// playlist_element_destroy
// file playlist.c line 69
void playlist_element_destroy(struct playlist_element_t *element);
// playlist_length
// file playlist.h line 58
signed int playlist_length(struct playlist_t *list);
// playlist_to_array
// file playlist.h line 62
char ** playlist_to_array(struct playlist_t *list, signed int *size);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// print_audio_devices_info
// file ogg123.c line 369
void print_audio_devices_info(struct audio_device_t *d);
// print_flac_comments
// file flac_format.c line 611
void print_flac_comments(struct anonymous_18 *f_comments, struct decoder_callbacks_t *cb, void *callback_arg);
// print_flac_stream_info
// file flac_format.c line 582
void print_flac_stream_info(struct decoder_t *decoder);
// print_space
// file cfgfile_options.c line 39
signed int print_space(struct _IO_FILE *f, signed int s, signed int c);
// print_speex_comments
// file speex_format.c line 383
void print_speex_comments(char *comments, signed int length, struct decoder_callbacks_t *cb, void *callback_arg);
// print_speex_info
// file speex_format.c line 358
void print_speex_info(struct SpeexHeader *header, struct decoder_callbacks_t *cb, void *callback_arg);
// print_statistics_action
// file callbacks.c line 149
void print_statistics_action(struct buf_t *buf, void *arg);
// print_statistics_line
// file status.c line 127
signed int print_statistics_line(struct anonymous_3 *stats);
// print_vorbis_comment
// file vorbis_comments.h line 25
void print_vorbis_comment(char *comment, struct decoder_callbacks_t *cb, void *callback_arg);
// print_vorbis_comments
// file oggvorbis_format.c line 381
void print_vorbis_comments(struct vorbis_comment *vc, struct decoder_callbacks_t *cb, void *callback_arg);
// print_vorbis_stream_info
// file oggvorbis_format.c line 351
void print_vorbis_stream_info(struct decoder_t *decoder);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_header
// file speex_format.c line 464
void * process_header(struct anonymous_65 *op, signed int *frame_size, struct SpeexHeader **header, struct SpeexStereoState *stereo, struct decoder_callbacks_t *cb, void *callback_arg);
// progress_callback
// file http_transport.c line 80
signed int progress_callback(void *arg, unsigned long int dltotal, unsigned long int dlnow, unsigned long int ultotal, unsigned long int ulnow);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_41 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_41 *, const union anonymous_22 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_41 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_41 *, union anonymous_13 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_13 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_13 *, const union anonymous_22 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_13 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_13 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_13 *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_34 *, struct anonymous_34 *);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// read_callback
// file flac_format.c line 455
static enum anonymous_23 read_callback(const struct anonymous_19 *decoder, unsigned char *buffer, unsigned long int *bytes, void *client_data);
// read_speex_header
// file speex_format.c line 514
signed int read_speex_header(struct decoder_t *decoder);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// remote_mainloop
// file remote.h line 20
void remote_mainloop(void);
// remote_playloop
// file remote.h line 21
signed int remote_playloop(void);
// remote_time
// file remote.h line 22
void remote_time(double current, double total);
// remotethread
// file remote.c line 127
static void * remotethread(void *arg);
// resize_buffer
// file flac_format.c line 552
void resize_buffer(struct anonymous_21 *flac, signed int newchannels, signed int newsamples);
// scandir
// file /usr/include/dirent.h line 254
extern signed int scandir(const char *, struct dirent *** restrict , signed int (*)(struct dirent *), signed int (*)(struct dirent **, struct dirent **));
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_14 *, struct anonymous_14 *, struct anonymous_14 *, struct timeval *);
// select_format
// file format.c line 64
struct format_t * select_format(struct data_source_t *source);
// select_stats
// file ogg123.c line 248
void select_stats(struct anonymous_3 *stats, struct ogg123_options_t *opts, struct data_source_t *source, struct decoder_t *decoder, struct buf_t *audio_buffer);
// select_transport
// file transport.h line 58
struct transport_t * select_transport(char *source);
// sem_destroy
// file /usr/include/semaphore.h line 39
extern signed int sem_destroy(union anonymous_15 *);
// sem_init
// file /usr/include/semaphore.h line 36
extern signed int sem_init(union anonymous_15 *, signed int, unsigned int);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous_15 *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous_15 *);
// send_err
// file remote.c line 94
static void send_err(const char *fmt, ...);
// send_msg
// file remote.c line 81
static void send_msg(const char *fmt, ...);
// set_curl_opts
// file http_transport.c line 105
void set_curl_opts(struct http_private_t *private);
// set_seek_opt
// file ogg123.c line 182
void set_seek_opt(struct ogg123_options_t *ogg123_opts, char *buf);
// setlinebuf
// file /usr/include/stdio.h line 347
extern void setlinebuf(struct _IO_FILE *);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setstatus
// file remote.c line 111
static void setstatus(enum anonymous_11 s);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_34 *, signed int);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_34 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signal_handler
// file ogg123.c line 98
void signal_handler(signed int signo);
// speex_bits_init
// file /usr/include/speex/speex_bits.h line 62
void speex_bits_init(struct SpeexBits *);
// speex_bits_read_from
// file /usr/include/speex/speex_bits.h line 80
void speex_bits_read_from(struct SpeexBits *, char *, signed int);
// speex_can_decode
// file speex_format.c line 100
signed int speex_can_decode(struct data_source_t *source);
// speex_cleanup
// file speex_format.c line 328
void speex_cleanup(struct decoder_t *decoder);
// speex_decode
// file /usr/include/speex/speex.h line 361
signed int speex_decode(void *, struct SpeexBits *, float *);
// speex_decode_stereo
// file /usr/include/speex/speex_stereo.h line 78
void speex_decode_stereo(float *, signed int, struct SpeexStereoState *);
// speex_decoder_ctl
// file /usr/include/speex/speex.h line 380
signed int speex_decoder_ctl(void *, signed int, void *);
// speex_decoder_init
// file /usr/include/speex/speex.h line 345
void * speex_decoder_init(const struct SpeexMode *);
// speex_init
// file speex_format.c line 115
struct decoder_t * speex_init(struct data_source_t *source, struct ogg123_options_t *ogg123_opts, struct audio_format_t *audio_fmt, struct decoder_callbacks_t *callbacks, void *callback_arg);
// speex_packet_to_header
// file /usr/include/speex/speex_header.h line 84
struct SpeexHeader * speex_packet_to_header(char *, signed int);
// speex_read
// file speex_format.c line 171
signed int speex_read(struct decoder_t *decoder, void *ptr, signed int nbytes, signed int *eos, struct audio_format_t *audio_fmt);
// speex_seek
// file speex_format.c line 283
signed int speex_seek(struct decoder_t *decoder, double offset, signed int whence);
// speex_statistics
// file speex_format.c line 293
struct decoder_stats_t * speex_statistics(struct decoder_t *decoder);
// speex_std_stereo_request_handler
// file /usr/include/speex/speex_stereo.h line 84
signed int speex_std_stereo_request_handler(struct SpeexBits *, void *, void *);
// speex_stereo_state_destroy
// file /usr/include/speex/speex_stereo.h line 69
void speex_stereo_state_destroy(struct SpeexStereoState *);
// speex_stereo_state_init
// file /usr/include/speex/speex_stereo.h line 63
struct SpeexStereoState * speex_stereo_state_init();
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sprintf_clear_line
// file status.c line 105
signed int sprintf_clear_line(signed int len, char *buf);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stat_format_cleanup
// file status.c line 336
void stat_format_cleanup(struct anonymous_3 *stats);
// stat_format_create
// file status.h line 59
struct anonymous_3 * stat_format_create();
// status_clear_line
// file status.c line 369
void status_clear_line();
// status_clear_line::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// status_deinit
// file status.h line 63
void status_deinit();
// status_error
// file status.h line 72
void status_error(const char *fmt, ...);
// status_error::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// status_error_action
// file callbacks.c line 248
void status_error_action(struct buf_t *buf, void *arg);
// status_init
// file status.h line 62
void status_init(signed int verbosity);
// status_message
// file status.h line 70
void status_message(signed int verbosity, const char *fmt, ...);
// status_message::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// status_message_action
// file callbacks.c line 259
void status_message_action(struct buf_t *buf, void *arg);
// status_print_statistics
// file status.h line 66
void status_print_statistics(struct anonymous_3 *stats, struct buffer_stats_t *audio_statistics, struct data_source_stats_t *transport_statistics, struct decoder_stats_t *decoder_statistics);
// status_print_statistics::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// status_reset_output_lock
// file status.h line 64
void status_reset_output_lock();
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtotime
// file ogg123.c line 170
double strtotime(char *s);
// submit_data_chunk
// file buffer.c line 310
signed int submit_data_chunk(struct buf_t *buf, char *data, unsigned long int size);
// submit_data_chunk::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// tanh
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 76
extern double tanh(double);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// unlock_output_lock
// file status.c line 48
void unlock_output_lock(void *arg);
// utf8_decode
// file ../include/utf8.h line 30
signed int utf8_decode(const char *from, char **to);
// utf8_encode
// file utf8.c line 298
signed int utf8_encode(const char *from, char **to);
// utf8_validate
// file utf8.c line 359
signed int utf8_validate(const char *s);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vg_filter
// file vgfilter.h line 65
extern void vg_filter(float **pcm, signed long int channels, signed long int samples, void *filter_param);
// vg_init
// file vgfilter.h line 62
extern void vg_init(struct anonymous_5 *vg, struct vorbis_comment *vc);
// vorbis_comment_query
// file /usr/include/vorbis/codec.h line 172
extern char * vorbis_comment_query(struct vorbis_comment *, const char *, signed int);
// vorbisfile_cb_close
// file oggvorbis_format.c line 327
signed int vorbisfile_cb_close(void *arg);
// vorbisfile_cb_read
// file oggvorbis_format.c line 313
unsigned long int vorbisfile_cb_read(void *ptr, unsigned long int size, unsigned long int nmemb, void *arg);
// vorbisfile_cb_seek
// file oggvorbis_format.c line 320
signed int vorbisfile_cb_seek(void *arg, signed long int offset, signed int whence);
// vorbisfile_cb_tell
// file oggvorbis_format.c line 332
signed long int vorbisfile_cb_tell(void *arg);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vstatus_error
// file status.h line 73
void vstatus_error(const char *fmt, void **ap);
// vstatus_error::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// vstatus_message
// file status.h line 71
void vstatus_message(signed int verbosity, const char *fmt, void **ap);
// vstatus_message::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// vstatus_print_nolock
// file status.c line 201
void vstatus_print_nolock(const char *fmt, void **ap);
// write_buffer_state_string
// file status.c line 54
void write_buffer_state_string(char *dest, struct buffer_stats_t *buf_stats);
// write_callback
// file http_transport.c line 64
unsigned long int write_callback(void *ptr, unsigned long int size, unsigned long int nmemb, void *arg);
// write_callback_link1
// file flac_format.c line 480
static enum anonymous_52 write_callback_link1(const struct anonymous_19 *decoder, const struct anonymous_27 *frame, const signed int * const *buffer, void *client_data);
// write_time_string
// file status.c line 83
signed int write_time_string(char *dest, double time);

struct anonymous_16
{
  // key
  char *key;
  // formatstr
  char *formatstr;
};

struct decoder_stats_t
{
  // total_time
  double total_time;
  // current_time
  double current_time;
  // instant_bitrate
  signed long int instant_bitrate;
  // avg_bitrate
  signed long int avg_bitrate;
};

struct anonymous_21
{
  // decoder
  struct anonymous_19 *decoder;
  // is_oggflac
  signed int is_oggflac;
  // channels
  signed short int channels;
  // rate
  signed int rate;
  // bits_per_sample
  signed int bits_per_sample;
  // totalsamples
  signed long int totalsamples;
  // currentsample
  signed long int currentsample;
  // samples_decoded
  signed long int samples_decoded;
  // samples_decoded_previous
  signed long int samples_decoded_previous;
  // bytes_read
  signed long int bytes_read;
  // bytes_read_previous
  signed long int bytes_read_previous;
  // comments
  struct anonymous_20 *comments;
  // bos
  signed int bos;
  // eos
  signed int eos;
  // buf
  signed int **buf;
  // buf_len
  signed int buf_len;
  // buf_start
  signed int buf_start;
  // buf_fill
  signed int buf_fill;
  // stats
  struct decoder_stats_t stats;
};

struct anonymous_19
{
  // protected_
  struct FLAC__StreamDecoderProtected *protected_;
  // private_
  struct FLAC__StreamDecoderPrivate *private_;
};

struct anonymous_32
{
  // parameters
  unsigned int *parameters;
  // raw_bits
  unsigned int *raw_bits;
  // capacity_by_order
  unsigned int capacity_by_order;
};

struct anonymous_9
{
  // read_func
  unsigned long int (*read_func)(void *, unsigned long int, unsigned long int, void *);
  // seek_func
  signed int (*seek_func)(void *, signed long int, signed int);
  // close_func
  signed int (*close_func)(void *);
  // tell_func
  signed long int (*tell_func)(void *);
};

struct anonymous_8
{
  // body_data
  unsigned char *body_data;
  // body_storage
  signed long int body_storage;
  // body_fill
  signed long int body_fill;
  // body_returned
  signed long int body_returned;
  // lacing_vals
  signed int *lacing_vals;
  // granule_vals
  signed long int *granule_vals;
  // lacing_storage
  signed long int lacing_storage;
  // lacing_fill
  signed long int lacing_fill;
  // lacing_packet
  signed long int lacing_packet;
  // lacing_returned
  signed long int lacing_returned;
  // header
  unsigned char header[282l];
  // header_fill
  signed int header_fill;
  // e_o_s
  signed int e_o_s;
  // b_o_s
  signed int b_o_s;
  // serialno
  signed long int serialno;
  // pageno
  signed long int pageno;
  // packetno
  signed long int packetno;
  // granulepos
  signed long int granulepos;
};

struct anonymous_64
{
  // data
  unsigned char *data;
};

struct anonymous_7
{
  // data
  unsigned char *data;
  // storage
  signed int storage;
  // fill
  signed int fill;
  // returned
  signed int returned;
  // unsynced
  signed int unsynced;
  // headerbytes
  signed int headerbytes;
  // bodybytes
  signed int bodybytes;
};

struct anonymous_66
{
  // header
  unsigned char *header;
  // header_len
  signed long int header_len;
  // body
  unsigned char *body;
  // body_len
  signed long int body_len;
};

struct anonymous_65
{
  // packet
  unsigned char *packet;
  // bytes
  signed long int bytes;
  // b_o_s
  signed long int b_o_s;
  // e_o_s
  signed long int e_o_s;
  // granulepos
  signed long int granulepos;
  // packetno
  signed long int packetno;
};

struct anonymous_42
{
  // data
  const signed int *data;
};

struct anonymous_61
{
  // media_catalog_number
  char media_catalog_number[129l];
  // lead_in
  unsigned long int lead_in;
  // is_cd
  signed int is_cd;
  // num_tracks
  unsigned int num_tracks;
  // tracks
  struct anonymous_60 *tracks;
};

struct anonymous_14
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_34
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_12
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_10
{
  // __cancel_jmp_buf
  struct anonymous_12 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_56
{
  // id
  unsigned char id[4l];
  // data
  unsigned char *data;
};

struct anonymous_33
{
  // order
  unsigned int order;
  // contents
  const struct anonymous_32 *contents;
};

union anonymous_35
{
  // partitioned_rice
  struct anonymous_33 partitioned_rice;
};

struct anonymous_37
{
  // type
  enum anonymous_31 type;
  // data
  union anonymous_35 data;
};

struct anonymous_54
{
  // min_blocksize
  unsigned int min_blocksize;
  // max_blocksize
  unsigned int max_blocksize;
  // min_framesize
  unsigned int min_framesize;
  // max_framesize
  unsigned int max_framesize;
  // sample_rate
  unsigned int sample_rate;
  // channels
  unsigned int channels;
  // bits_per_sample
  unsigned int bits_per_sample;
  // total_samples
  unsigned long int total_samples;
  // md5sum
  unsigned char md5sum[16l];
};

struct anonymous_55
{
  // dummy
  signed int dummy;
};

struct anonymous_58
{
  // num_points
  unsigned int num_points;
  // points
  struct anonymous_57 *points;
};

struct anonymous_17
{
  // length
  unsigned int length;
  // entry
  unsigned char *entry;
};

struct anonymous_18
{
  // vendor_string
  struct anonymous_17 vendor_string;
  // num_comments
  unsigned int num_comments;
  // comments
  struct anonymous_17 *comments;
};

struct anonymous_63
{
  // type
  enum anonymous_62 type;
  // mime_type
  char *mime_type;
  // description
  unsigned char *description;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // depth
  unsigned int depth;
  // colors
  unsigned int colors;
  // data_length
  unsigned int data_length;
  // data
  unsigned char *data;
};

union anonymous_47
{
  // stream_info
  struct anonymous_54 stream_info;
  // padding
  struct anonymous_55 padding;
  // application
  struct anonymous_56 application;
  // seek_table
  struct anonymous_58 seek_table;
  // vorbis_comment
  struct anonymous_18 vorbis_comment;
  // cue_sheet
  struct anonymous_61 cue_sheet;
  // picture
  struct anonymous_63 picture;
  // unknown
  struct anonymous_64 unknown;
};

struct anonymous_20
{
  // type
  enum anonymous_36 type;
  // is_last
  signed int is_last;
  // length
  unsigned int length;
  // data
  union anonymous_47 data;
};

struct anonymous_39
{
  // value
  signed int value;
};

struct anonymous_43
{
  // entropy_coding_method
  struct anonymous_37 entropy_coding_method;
  // order
  unsigned int order;
  // warmup
  signed int warmup[4l];
  // residual
  const signed int *residual;
};

struct anonymous_44
{
  // entropy_coding_method
  struct anonymous_37 entropy_coding_method;
  // order
  unsigned int order;
  // qlp_coeff_precision
  unsigned int qlp_coeff_precision;
  // quantization_level
  signed int quantization_level;
  // qlp_coeff
  signed int qlp_coeff[32l];
  // warmup
  signed int warmup[32l];
  // residual
  const signed int *residual;
};

union anonymous_46
{
  // constant
  struct anonymous_39 constant;
  // fixed
  struct anonymous_43 fixed;
  // lpc
  struct anonymous_44 lpc;
  // verbatim
  struct anonymous_42 verbatim;
};

struct anonymous_25
{
  // type
  enum anonymous_38 type;
  // data
  union anonymous_46 data;
  // wasted_bits
  unsigned int wasted_bits;
};

struct anonymous_5
{
  // scale_factor
  float scale_factor;
  // max_scale
  float max_scale;
};

struct anonymous_40
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous_68
{
  // intarg
  signed int intarg;
  // stringarg
  char *stringarg;
  // floatarg
  float floatarg;
  // doublearg
  double doublearg;
};

struct anonymous_3
{
  // verbosity
  signed int verbosity;
  // enabled
  char enabled;
  // formatstr
  const char *formatstr;
  // type
  enum anonymous_67 type;
  // arg
  union anonymous_68 arg;
};

struct anonymous_6
{
  // endbyte
  signed long int endbyte;
  // endbit
  signed int endbit;
  // buffer
  unsigned char *buffer;
  // ptr
  unsigned char *ptr;
  // storage
  signed long int storage;
};

struct anonymous
{
  // mask
  char mask;
  // value
  char value;
  // after
  unsigned int after;
};

union anonymous_30
{
  // frame_number
  unsigned int frame_number;
  // sample_number
  unsigned long int sample_number;
};

struct anonymous_24
{
  // blocksize
  unsigned int blocksize;
  // sample_rate
  unsigned int sample_rate;
  // channels
  unsigned int channels;
  // channel_assignment
  enum anonymous_28 channel_assignment;
  // bits_per_sample
  unsigned int bits_per_sample;
  // number_type
  enum anonymous_29 number_type;
  // number
  union anonymous_30 number;
  // crc
  unsigned char crc;
};

struct anonymous_26
{
  // crc
  unsigned short int crc;
};

struct anonymous_27
{
  // header
  struct anonymous_24 header;
  // subframes
  struct anonymous_25 subframes[8l];
  // footer
  struct anonymous_26 footer;
};

struct anonymous_60
{
  // offset
  unsigned long int offset;
  // number
  unsigned char number;
  // isrc
  char isrc[13l];
  // type
  unsigned int type : 1;
  // pre_emphasis
  unsigned int pre_emphasis : 1;
  // num_indices
  unsigned char num_indices;
  // indices
  struct anonymous_59 *indices;
};

struct anonymous_59
{
  // offset
  unsigned long int offset;
  // number
  unsigned char number;
};

struct anonymous_57
{
  // sample_number
  unsigned long int sample_number;
  // stream_offset
  unsigned long int stream_offset;
  // frame_samples
  unsigned int frame_samples;
};

union anonymous_15
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous_22
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_41
{
  // __data
  struct anonymous_40 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_13
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct vorbis_dsp_state
{
  // analysisp
  signed int analysisp;
  // vi
  struct vorbis_info *vi;
  // pcm
  float **pcm;
  // pcmret
  float **pcmret;
  // pcm_storage
  signed int pcm_storage;
  // pcm_current
  signed int pcm_current;
  // pcm_returned
  signed int pcm_returned;
  // preextrapolate
  signed int preextrapolate;
  // eofflag
  signed int eofflag;
  // lW
  signed long int lW;
  // W
  signed long int W;
  // nW
  signed long int nW;
  // centerW
  signed long int centerW;
  // granulepos
  signed long int granulepos;
  // sequence
  signed long int sequence;
  // glue_bits
  signed long int glue_bits;
  // time_bits
  signed long int time_bits;
  // floor_bits
  signed long int floor_bits;
  // res_bits
  signed long int res_bits;
  // backend_state
  void *backend_state;
};

struct vorbis_block
{
  // pcm
  float **pcm;
  // opb
  struct anonymous_6 opb;
  // lW
  signed long int lW;
  // W
  signed long int W;
  // nW
  signed long int nW;
  // pcmend
  signed int pcmend;
  // mode
  signed int mode;
  // eofflag
  signed int eofflag;
  // granulepos
  signed long int granulepos;
  // sequence
  signed long int sequence;
  // vd
  struct vorbis_dsp_state *vd;
  // localstore
  void *localstore;
  // localtop
  signed long int localtop;
  // localalloc
  signed long int localalloc;
  // totaluse
  signed long int totaluse;
  // reap
  struct alloc_chain *reap;
  // glue_bits
  signed long int glue_bits;
  // time_bits
  signed long int time_bits;
  // floor_bits
  signed long int floor_bits;
  // res_bits
  signed long int res_bits;
  // internal
  void *internal;
};

struct OggVorbis_File
{
  // datasource
  void *datasource;
  // seekable
  signed int seekable;
  // offset
  signed long int offset;
  // end
  signed long int end;
  // oy
  struct anonymous_7 oy;
  // links
  signed int links;
  // offsets
  signed long int *offsets;
  // dataoffsets
  signed long int *dataoffsets;
  // serialnos
  signed long int *serialnos;
  // pcmlengths
  signed long int *pcmlengths;
  // vi
  struct vorbis_info *vi;
  // vc
  struct vorbis_comment *vc;
  // pcm_offset
  signed long int pcm_offset;
  // ready_state
  signed int ready_state;
  // current_serialno
  signed long int current_serialno;
  // current_link
  signed int current_link;
  // bittrack
  double bittrack;
  // samptrack
  double samptrack;
  // os
  struct anonymous_8 os;
  // vd
  struct vorbis_dsp_state vd;
  // vb
  struct vorbis_block vb;
  // callbacks
  struct anonymous_9 callbacks;
};

struct SpeexBits
{
  // chars
  char *chars;
  // nbBits
  signed int nbBits;
  // charPtr
  signed int charPtr;
  // bitPtr
  signed int bitPtr;
  // owner
  signed int owner;
  // overflow
  signed int overflow;
  // buf_size
  signed int buf_size;
  // reserved1
  signed int reserved1;
  // reserved2
  void *reserved2;
};

struct SpeexCallback
{
  // callback_id
  signed int callback_id;
  // func
  signed int (*func)(struct SpeexBits *, void *, void *);
  // data
  void *data;
  // reserved1
  void *reserved1;
  // reserved2
  signed int reserved2;
};

struct SpeexHeader
{
  // speex_string
  char speex_string[8l];
  // speex_version
  char speex_version[20l];
  // speex_version_id
  signed int speex_version_id;
  // header_size
  signed int header_size;
  // rate
  signed int rate;
  // mode
  signed int mode;
  // mode_bitstream_version
  signed int mode_bitstream_version;
  // nb_channels
  signed int nb_channels;
  // bitrate
  signed int bitrate;
  // frame_size
  signed int frame_size;
  // vbr
  signed int vbr;
  // frames_per_packet
  signed int frames_per_packet;
  // extra_headers
  signed int extra_headers;
  // reserved1
  signed int reserved1;
  // reserved2
  signed int reserved2;
};

struct SpeexMode
{
  // mode
  const void *mode;
  // query
  signed int (*query)(const void *, signed int, void *);
  // modeName
  const char *modeName;
  // modeID
  signed int modeID;
  // bitstream_version
  signed int bitstream_version;
  // enc_init
  void * (*enc_init)(struct SpeexMode *);
  // enc_destroy
  void (*enc_destroy)(void *);
  // enc
  signed int (*enc)(void *, void *, struct SpeexBits *);
  // dec_init
  void * (*dec_init)(struct SpeexMode *);
  // dec_destroy
  void (*dec_destroy)(void *);
  // dec
  signed int (*dec)(void *, struct SpeexBits *, void *);
  // enc_ctl
  signed int (*enc_ctl)(void *, signed int, void *);
  // dec_ctl
  signed int (*dec_ctl)(void *, signed int, void *);
};

struct SpeexStereoState
{
  // balance
  float balance;
  // e_ratio
  float e_ratio;
  // smooth_left
  float smooth_left;
  // smooth_right
  float smooth_right;
  // reserved1
  float reserved1;
  // reserved2
  float reserved2;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct action_t
{
  // position
  signed long int position;
  // action_func
  void (*action_func)(struct buf_t *, void *);
  // arg
  void *arg;
  // next
  struct action_t *next;
};

struct alloc_chain
{
  // ptr
  void *ptr;
  // next
  struct alloc_chain *next;
};

struct ao_info
{
  // type
  signed int type;
  // name
  char *name;
  // short_name
  char *short_name;
  // author
  char *author;
  // comment
  char *comment;
  // preferred_byte_format
  signed int preferred_byte_format;
  // priority
  signed int priority;
  // options
  char **options;
  // option_count
  signed int option_count;
};

struct ao_option
{
  // key
  char *key;
  // value
  char *value;
  // next
  struct ao_option *next;
};

struct ao_sample_format
{
  // bits
  signed int bits;
  // rate
  signed int rate;
  // channels
  signed int channels;
  // byte_format
  signed int byte_format;
  // matrix
  char *matrix;
};

struct audio_device_t
{
  // driver_id
  signed int driver_id;
  // device
  struct ao_device *device;
  // options
  struct ao_option *options;
  // filename
  char *filename;
  // next_device
  struct audio_device_t *next_device;
};

struct audio_format_t
{
  // big_endian
  signed int big_endian;
  // word_size
  signed int word_size;
  // signed_sample
  signed int signed_sample;
  // rate
  signed int rate;
  // channels
  signed int channels;
  // matrix
  char *matrix;
};

struct audio_play_arg_t
{
  // stat_format
  struct anonymous_3 *stat_format;
  // devices
  struct audio_device_t *devices;
};

struct audio_reopen_arg_t
{
  // devices
  struct audio_device_t *devices;
  // format
  struct audio_format_t *format;
};

struct buf_t
{
  // write_arg
  void *write_arg;
  // write_func
  signed int (*write_func)(void *, signed int, signed int, void *);
  // thread
  unsigned long int thread;
  // mutex
  union anonymous_13 mutex;
  // playback_cond
  union anonymous_41 playback_cond;
  // write_cond
  union anonymous_41 write_cond;
  // audio_chunk_size
  signed int audio_chunk_size;
  // prebuffer_size
  signed long int prebuffer_size;
  // size
  signed long int size;
  // cancel_flag
  signed int cancel_flag;
  // prebuffering
  signed int prebuffering;
  // paused
  signed int paused;
  // eos
  signed int eos;
  // abort_write
  signed int abort_write;
  // curfill
  signed long int curfill;
  // start
  signed long int start;
  // position
  signed long int position;
  // position_end
  signed long int position_end;
  // actions
  struct action_t *actions;
  // buffer
  char buffer[1l];
};

struct buffer_stats_t
{
  // size
  signed long int size;
  // fill
  double fill;
  // prebuffer_fill
  double prebuffer_fill;
  // prebuffering
  signed int prebuffering;
  // paused
  signed int paused;
  // eos
  signed int eos;
};

struct curl_slist
{
  // data
  char *data;
  // next
  struct curl_slist *next;
};

struct data_source_stats_t
{
  // bytes_read
  signed long int bytes_read;
  // input_buffer_used
  signed int input_buffer_used;
  // transfer_rate
  signed long int transfer_rate;
  // input_buffer
  struct buffer_stats_t input_buffer;
};

struct data_source_t
{
  // source_string
  char *source_string;
  // transport
  struct transport_t *transport;
  // private
  void *private;
};

struct decoder_callbacks_t
{
  // printf_error
  void (*printf_error)(void *, signed int, char *, ...);
  // printf_metadata
  void (*printf_metadata)(void *, signed int, char *, ...);
};

struct decoder_t
{
  // source
  struct data_source_t *source;
  // request_fmt
  struct audio_format_t request_fmt;
  // actual_fmt
  struct audio_format_t actual_fmt;
  // format
  struct format_t *format;
  // callbacks
  struct decoder_callbacks_t *callbacks;
  // callback_arg
  void *callback_arg;
  // private
  void *private;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct file_option_t
{
  // found
  char found;
  // name
  const char *name;
  // desc
  const char *desc;
  // type
  enum anonymous_1 type;
  // ptr
  void *ptr;
  // dfl
  void *dfl;
};

struct file_private_t
{
  // fp
  struct _IO_FILE *fp;
  // stats
  struct data_source_stats_t stats;
  // seekable
  signed int seekable;
};

struct format_t
{
  // name
  char *name;
  // can_decode
  signed int (*can_decode)(struct data_source_t *);
  // init
  struct decoder_t * (*init)(struct data_source_t *, struct ogg123_options_t *, struct audio_format_t *, struct decoder_callbacks_t *, void *);
  // read
  signed int (*read)(struct decoder_t *, void *, signed int, signed int *, struct audio_format_t *);
  // seek
  signed int (*seek)(struct decoder_t *, double, signed int);
  // statistics
  struct decoder_stats_t * (*statistics)(struct decoder_t *);
  // cleanup
  void (*cleanup)(struct decoder_t *);
};

struct http_private_t
{
  // cancel_flag
  signed int cancel_flag;
  // buf
  struct buf_t *buf;
  // curl_thread
  unsigned long int curl_thread;
  // curl_handle
  void *curl_handle;
  // header_list
  struct curl_slist *header_list;
  // error
  char error[256l];
  // data_source
  struct data_source_t *data_source;
  // stats
  struct data_source_stats_t stats;
};

struct ogg123_options_t
{
  // verbosity
  signed int verbosity;
  // shuffle
  signed int shuffle;
  // repeat
  signed int repeat;
  // delay
  signed long int delay;
  // nth
  signed int nth;
  // ntimes
  signed int ntimes;
  // seekoff
  double seekoff;
  // endpos
  double endpos;
  // seekmode
  signed int seekmode;
  // buffer_size
  signed long int buffer_size;
  // prebuffer
  float prebuffer;
  // input_buffer_size
  signed long int input_buffer_size;
  // input_prebuffer
  float input_prebuffer;
  // default_device
  char *default_device;
  // devices
  struct audio_device_t *devices;
  // status_freq
  double status_freq;
  // remote
  signed int remote;
  // playlist
  struct playlist_t *playlist;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct ovf_private_t
{
  // vf
  struct OggVorbis_File vf;
  // vc
  struct vorbis_comment *vc;
  // vi
  struct vorbis_info *vi;
  // current_section
  signed int current_section;
  // bos
  signed int bos;
  // stats
  struct decoder_stats_t stats;
  // vg
  struct anonymous_5 vg;
};

struct playlist_element_t
{
  // filename
  char *filename;
  // next
  struct playlist_element_t *next;
};

struct playlist_t
{
  // head
  struct playlist_element_t *head;
  // last
  struct playlist_element_t *last;
};

struct print_statistics_arg_t
{
  // stat_format
  struct anonymous_3 *stat_format;
  // data_source_statistics
  struct data_source_stats_t *data_source_statistics;
  // decoder_statistics
  struct decoder_stats_t *decoder_statistics;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct signal_request_t
{
  // cancel
  signed int cancel;
  // skipfile
  signed int skipfile;
  // exit
  signed int exit;
  // pause
  signed int pause;
  // last_ctrl_c
  signed long int last_ctrl_c;
};

struct speex_private_t
{
  // oy
  struct anonymous_7 oy;
  // og
  struct anonymous_66 og;
  // op
  struct anonymous_65 op;
  // os
  struct anonymous_8 os;
  // bits
  struct SpeexBits bits;
  // stereo
  struct SpeexStereoState *stereo;
  // header
  struct SpeexHeader *header;
  // st
  void *st;
  // comment_packet
  char *comment_packet;
  // comment_packet_len
  signed int comment_packet_len;
  // output
  float *output;
  // output_start
  signed int output_start;
  // output_left
  signed int output_left;
  // frames_per_packet
  signed int frames_per_packet;
  // frame_size
  signed int frame_size;
  // vbr
  signed int vbr;
  // bos
  signed int bos;
  // eof
  signed int eof;
  // samples_decoded
  signed long int samples_decoded;
  // samples_decoded_previous
  signed long int samples_decoded_previous;
  // bytes_read
  signed long int bytes_read;
  // bytes_read_previous
  signed long int bytes_read_previous;
  // totalsamples
  signed long int totalsamples;
  // currentsample
  signed long int currentsample;
  // stats
  struct decoder_stats_t stats;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct status_message_arg_t
{
  // verbosity
  signed int verbosity;
  // message
  char *message;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct transport_t
{
  // name
  char *name;
  // can_transport
  signed int (*can_transport)(char *);
  // open
  struct data_source_t * (*open)(char *, struct ogg123_options_t *);
  // peek
  signed int (*peek)(struct data_source_t *, void *, unsigned long int, unsigned long int);
  // read
  signed int (*read)(struct data_source_t *, void *, unsigned long int, unsigned long int);
  // seek
  signed int (*seek)(struct data_source_t *, signed long int, signed int);
  // statistics
  struct data_source_stats_t * (*statistics)(struct data_source_t *);
  // tell
  signed long int (*tell)(struct data_source_t *);
  // close
  void (*close)(struct data_source_t *);
};

struct vorbis_comment
{
  // user_comments
  char **user_comments;
  // comment_lengths
  signed int *comment_lengths;
  // comments
  signed int comments;
  // vendor
  char *vendor;
};

struct vorbis_info
{
  // version
  signed int version;
  // channels
  signed int channels;
  // rate
  signed long int rate;
  // bitrate_upper
  signed long int bitrate_upper;
  // bitrate_nominal
  signed long int bitrate_nominal;
  // bitrate_lower
  signed long int bitrate_lower;
  // bitrate_window
  signed long int bitrate_window;
  // codec_setup
  void *codec_setup;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};


// audio_buffer
// file ogg123.c line 66
struct buf_t *audio_buffer = (struct buf_t *)(void *)0;
// audio_play_arg
// file ogg123.c line 68
struct audio_play_arg_t audio_play_arg;
// convbuffer
// file ogg123.c line 61
unsigned char convbuffer[30240l];
// convsize
// file ogg123.c line 62
signed int convsize = (((16384 + 2 * 2 * 2 * 2 * 3 * 3 * 3 * 5 * 7) - 1) / (2 * 2 * 2 * 2 * 3 * 3 * 3 * 5 * 7)) * 2 * 2 * 2 * 2 * 3 * 3 * 3 * 5 * 7;
// current_charset
// file utf8.c line 233
static char *current_charset = ((char *)NULL);
// exit_status
// file status.c line 41
signed int exit_status = 0;
// file_opts
// file ogg123.c line 79
struct file_option_t file_opts[4l];
// int_0
// file ogg123.c line 77
signed int int_0 = 0;
// options
// file ogg123.c line 64
struct ogg123_options_t options;
// file_opts
// file ogg123.c line 79
struct file_option_t file_opts[4l] = { { .found=(char)0, .name="default_device", .desc="default output device",
    .type=(enum anonymous_1)opt_type_string, .ptr=(void *)&options.default_device,
    .dfl=(void *)0 },
    { .found=(char)0, .name="shuffle", .desc="shuffle playlist", .type=(enum anonymous_1)opt_type_bool,
    .ptr=(void *)&options.shuffle,
    .dfl=(void *)&int_0 },
    { .found=(char)0, .name="repeat", .desc="repeat playlist forever", .type=(enum anonymous_1)opt_type_bool,
    .ptr=(void *)&options.repeat,
    .dfl=(void *)&int_0 },
    { .found=(char)0, .name=(const char *)(void *)0, .desc=(const char *)(void *)0,
    .type=(enum anonymous_1)0, .ptr=(void *)0,
    .dfl=(void *)0 } };
// file_transport
// file file_transport.c line 37
struct transport_t file_transport;
// file_transport
// file file_transport.c line 37
struct transport_t file_transport = { .name="file", .can_transport=file_can_transport, .open=file_open,
    .peek=file_peek, .read=file_read, .seek=file_seek,
    .statistics=file_statistics, .tell=file_tell,
    .close=file_close };
// flac_format
// file flac_format.c line 77
struct format_t flac_format;
// flac_format
// file flac_format.c line 77
struct format_t flac_format = { .name="flac", .can_decode=flac_can_decode, .init=flac_init,
    .read=flac_read, .seek=flac_seek, .statistics=flac_statistics,
    .cleanup=flac_cleanup };
// formats
// file format.c line 41
struct format_t *formats[5l];
// oggflac_format
// file flac_format.c line 78
struct format_t oggflac_format;
// oggflac_format
// file flac_format.c line 78
struct format_t oggflac_format = { .name="oggflac", .can_decode=oggflac_can_decode, .init=flac_init,
    .read=flac_read, .seek=flac_seek, .statistics=flac_statistics,
    .cleanup=flac_cleanup };
// oggvorbis_format
// file oggvorbis_format.c line 54
struct format_t oggvorbis_format;
// oggvorbis_format
// file oggvorbis_format.c line 54
struct format_t oggvorbis_format = { .name="oggvorbis", .can_decode=ovf_can_decode, .init=ovf_init,
    .read=ovf_read, .seek=ovf_seek, .statistics=ovf_statistics,
    .cleanup=ovf_cleanup };
// speex_format
// file speex_format.c line 82
struct format_t speex_format;
// speex_format
// file speex_format.c line 82
struct format_t speex_format = { .name="speex", .can_decode=speex_can_decode, .init=speex_init,
    .read=speex_read, .seek=speex_seek, .statistics=speex_statistics,
    .cleanup=speex_cleanup };
// formats
// file format.c line 41
struct format_t *formats[5l] = { &flac_format, &oggflac_format, &speex_format, &oggvorbis_format, (struct format_t *)(void *)0 };
// http_transport
// file http_transport.c line 60
struct transport_t http_transport;
// http_transport
// file http_transport.c line 60
struct transport_t http_transport = { .name="http", .can_transport=http_can_transport, .open=http_open,
    .peek=http_peek, .read=http_read, .seek=http_seek,
    .statistics=http_statistics, .tell=http_tell,
    .close=http_close };
// int_1
// file ogg123.c line 76
signed int int_1 = 1;
// last_line_len
// file status.c line 39
signed int last_line_len = 0;
// long_options
// file cmdline_options.c line 36
struct option long_options[22l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=86 },
    { .name="buffer", .has_arg=1, .flag=((signed int *)NULL), .val=98 },
    { .name="config", .has_arg=2, .flag=((signed int *)NULL), .val=99 },
    { .name="device", .has_arg=1, .flag=((signed int *)NULL), .val=100 },
    { .name="file", .has_arg=1, .flag=((signed int *)NULL), .val=102 },
    { .name="skip", .has_arg=1, .flag=((signed int *)NULL), .val=107 },
    { .name="end", .has_arg=1, .flag=((signed int *)NULL), .val=75 },
    { .name="delay", .has_arg=1, .flag=((signed int *)NULL), .val=108 },
    { .name="device-option", .has_arg=1, .flag=((signed int *)NULL), .val=111 },
    { .name="prebuffer", .has_arg=1, .flag=((signed int *)NULL), .val=112 },
    { .name="quiet", .has_arg=0, .flag=((signed int *)NULL), .val=113 },
    { .name="remote", .has_arg=0, .flag=((signed int *)NULL), .val=82 },
    { .name="verbose", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name="nth", .has_arg=1, .flag=((signed int *)NULL), .val=120 },
    { .name="ntimes", .has_arg=1, .flag=((signed int *)NULL), .val=121 },
    { .name="shuffle", .has_arg=0, .flag=((signed int *)NULL), .val=122 },
    { .name="random", .has_arg=0, .flag=((signed int *)NULL), .val=90 },
    { .name="list", .has_arg=1, .flag=((signed int *)NULL), .val=64 },
    { .name="audio-buffer", .has_arg=1, .flag=((signed int *)NULL), .val=0 },
    { .name="repeat", .has_arg=0, .flag=((signed int *)NULL), .val=114 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// main_lock
// file remote.c line 57
static union anonymous_13 main_lock;
// max_verbosity
// file status.c line 40
signed int max_verbosity = 0;
// optarg
// file ../include/getopt.h line 36
extern char *optarg;
// optind
// file ../include/getopt.h line 50
extern signed int optind;
// output_lock
// file status.c line 43
union anonymous_13 output_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// output_lock_link1
// file remote.c line 60
static union anonymous_13 output_lock_link1;
// sem_command
// file remote.c line 58
static union anonymous_15 sem_command;
// sem_processed
// file remote.c line 59
static union anonymous_15 sem_processed;
// sig_request
// file ogg123.c line 92
struct signal_request_t sig_request = { .cancel=0, .skipfile=0, .exit=0, .pause=0, .last_ctrl_c=(signed long int)0 };
// speex_mode_list
// file /usr/include/speex/speex.h line 409
extern const struct SpeexMode * const speex_mode_list[3l];
// stat_format
// file ogg123.c line 65
struct anonymous_3 *stat_format;
// status
// file remote.c line 50
static enum anonymous_11 status = (enum anonymous_11)STOP;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// temp_buffer
// file status.c line 38
char temp_buffer[200l];
// test
// file utf8.c line 345
static struct anonymous test[6l] = { { .mask=(char)0x80, .value=(char)0, .after=(unsigned int)0 },
    { .mask=(char)0xe0, .value=(char)0xc0, .after=(unsigned int)1 },
    { .mask=(char)0xf0, .value=(char)0xe0, .after=(unsigned int)2 },
    { .mask=(char)0xf8, .value=(char)0xf0, .after=(unsigned int)3 },
    { .mask=(char)0xfc, .value=(char)0xf8, .after=(unsigned int)4 },
    { .mask=(char)0xfe, .value=(char)0xfc, .after=(unsigned int)5 } };
// transports
// file transport.c line 33
struct transport_t *transports[3l];
// transports
// file transport.c line 33
struct transport_t *transports[3l] = { &http_transport, &file_transport, (struct transport_t *)(void *)0 };
// vorbis_comment_keys
// file vorbis_comments.c line 38
struct anonymous_16 vorbis_comment_keys[8l] = { { .key="TRACKNUMBER=", .formatstr="Track number:" },
    { .key="REPLAYGAIN_TRACK_GAIN=", .formatstr="ReplayGain (Track):" },
    { .key="REPLAYGAIN_ALBUM_GAIN=", .formatstr="ReplayGain (Album):" },
    { .key="REPLAYGAIN_TRACK_PEAK=", .formatstr="ReplayGain Peak (Track):" },
    { .key="REPLAYGAIN_ALBUM_PEAK=", .formatstr="ReplayGain Peak (Album):" },
    { .key="COPYRIGHT=", .formatstr="Copyright" },
    { .key="=", .formatstr="Comment:" }, { .key=(char *)(void *)0, .formatstr="Comment:" } };
// vorbisfile_callbacks
// file oggvorbis_format.c line 55
struct anonymous_9 vorbisfile_callbacks;
// vorbisfile_callbacks
// file oggvorbis_format.c line 55
struct anonymous_9 vorbisfile_callbacks = { .read_func=vorbisfile_cb_read, .seek_func=vorbisfile_cb_seek, .close_func=vorbisfile_cb_close,
    .tell_func=vorbisfile_cb_tell };

// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void)
{
  asm("");
}

// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void)
{
  asm("");
}

// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void)
{
  asm("");
}

// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void)
{
  asm("");
}

// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void)
{
  asm("");
}

// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void)
{
  asm("");
}

// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void)
{
  asm("");
}

// add_ao_option
// file audio.c line 77
signed int add_ao_option(struct ao_option **op_h, const char *optstring)
{
  char *key;
  char *value;
  signed int result;
  key=strdup(optstring);
  char *tmp_post_1;
  if(key == ((char *)NULL))
    return 0;

  else
  {
    value=strchr(key, 58);
    if(!(value == ((char *)NULL)))
    {
      tmp_post_1 = value;
      value = value + 1l;
      *tmp_post_1 = (char)0;
    }

    result=ao_append_option(op_h, key, value);
    free((void *)key);
    return result;
  }
}

// ao_onexit
// file audio.c line 121
void ao_onexit(void *arg)
{
  struct audio_device_t *devices = (struct audio_device_t *)arg;
  close_audio_devices(devices);
  free_audio_devices(devices);
  ao_shutdown();
}

// append_audio_device
// file audio.c line 41
struct audio_device_t * append_audio_device(struct audio_device_t *devices_list, signed int driver_id, struct ao_option *options, char *filename)
{
  struct audio_device_t *head = devices_list;
  if(!(devices_list == ((struct audio_device_t *)NULL)))
  {
    for( ; !(devices_list->next_device == ((struct audio_device_t *)NULL)); devices_list = devices_list->next_device)
      ;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct audio_device_t) /*40ul*/ );
    devices_list->next_device = (struct audio_device_t *)return_value_malloc_1;
    devices_list = devices_list->next_device;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct audio_device_t) /*40ul*/ );
    devices_list = (struct audio_device_t *)return_value_malloc_2;
    head = devices_list;
  }
  devices_list->driver_id = driver_id;
  devices_list->options = options;
  devices_list->filename = filename;
  devices_list->device = (struct ao_device *)(void *)0;
  devices_list->next_device = (struct audio_device_t *)(void *)0;
  return devices_list;
}

// audio_devices_write
// file audio.c line 65
signed int audio_devices_write(struct audio_device_t *d, void *ptr, signed int nbytes)
{
  while(!(d == ((struct audio_device_t *)NULL)))
  {
    signed int return_value_ao_play_1;
    return_value_ao_play_1=ao_play(d->device, (char *)ptr, (unsigned int)nbytes);
    if(return_value_ao_play_1 == 0)
      return 0;

    d = d->next_device;
  }
  return 1;
}

// audio_format_equal
// file audio.c line 29
signed int audio_format_equal(struct audio_format_t *a, struct audio_format_t *b)
{
  _Bool tmp_if_expr_1;
  if(a->big_endian == b->big_endian)
    tmp_if_expr_1 = a->word_size == b->word_size ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = a->signed_sample == b->signed_sample ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = a->rate == b->rate ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = a->channels == b->channels ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  signed int return_value_strcmp_6;
  if(tmp_if_expr_4)
  {
    if(a->matrix == ((char *)NULL))
      tmp_if_expr_5 = b->matrix == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_strcmp_6=strcmp(a->matrix, b->matrix);
      tmp_if_expr_7 = !(return_value_strcmp_6 != 0) ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_8 = (_Bool)0;
  return (signed int)tmp_if_expr_8;
}

// audio_play_callback
// file callbacks.c line 33
signed int audio_play_callback(void *ptr, signed int nbytes, signed int eos, void *arg)
{
  struct audio_play_arg_t *play_arg = (struct audio_play_arg_t *)arg;
  signed int ret;
  ret=audio_devices_write(play_arg->devices, ptr, nbytes);
  return ret != 0 ? nbytes : 0;
}

// audio_reopen_action
// file callbacks.c line 43
void audio_reopen_action(struct buf_t *buf, void *arg)
{
  struct audio_reopen_arg_t *reopen_arg = (struct audio_reopen_arg_t *)arg;
  struct audio_device_t *current;
  struct ao_sample_format format;
  close_audio_devices(reopen_arg->devices);
  format.rate = reopen_arg->format->rate;
  format.channels = reopen_arg->format->channels;
  format.bits = reopen_arg->format->word_size * 8;
  format.byte_format = reopen_arg->format->big_endian != 0 ? 2 : 1;
  format.matrix = reopen_arg->format->matrix;
  current = reopen_arg->devices;
  char *return_value_gettext_2;
  char *return_value_gettext_3;
  char *return_value_gettext_4;
  char *return_value_gettext_5;
  char *return_value_gettext_6;
  char *return_value_gettext_7;
  char *return_value_gettext_8;
  char *return_value_gettext_9;
  char *return_value_gettext_10;
  signed int *return_value___errno_location_11;
  while(!(current == ((struct audio_device_t *)NULL)))
  {
    struct ao_info *info;
    info=ao_driver_info(current->driver_id);
    if(current->filename == ((char *)NULL))
      current->device=ao_open_live(current->driver_id, &format, current->options);

    else
      current->device=ao_open_file(current->driver_id, current->filename, 1, &format, current->options);
    if(current->device == ((struct ao_device *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      switch(*return_value___errno_location_1)
      {
        case 1:
        {
          return_value_gettext_2=gettext("ERROR: Device not available.\n");
          status_error(return_value_gettext_2);
          break;
        }
        case 3:
        {
          return_value_gettext_3=gettext("ERROR: %s requires an output filename to be specified with -f.\n");
          status_error(return_value_gettext_3, info->short_name);
          break;
        }
        case 4:
        {
          return_value_gettext_4=gettext("ERROR: Unsupported option value to %s device.\n");
          status_error(return_value_gettext_4, info->short_name);
          break;
        }
        case 5:
        {
          return_value_gettext_5=gettext("ERROR: Cannot open device %s.\n");
          status_error(return_value_gettext_5, info->short_name);
          break;
        }
        case 100:
        {
          return_value_gettext_6=gettext("ERROR: Device %s failure.\n");
          status_error(return_value_gettext_6, info->short_name);
          break;
        }
        case 2:
        {
          return_value_gettext_7=gettext("ERROR: An output file cannot be given for %s device.\n");
          status_error(return_value_gettext_7, info->short_name);
          break;
        }
        case 6:
        {
          return_value_gettext_8=gettext("ERROR: Cannot open file %s for writing.\n");
          status_error(return_value_gettext_8, current->filename);
          break;
        }
        case 7:
        {
          return_value_gettext_9=gettext("ERROR: File %s already exists.\n");
          status_error(return_value_gettext_9, current->filename);
          break;
        }
        default:
        {
          return_value_gettext_10=gettext("ERROR: This error should never happen (%d).  Panic!\n");
          return_value___errno_location_11=__errno_location();
          status_error(return_value_gettext_10, *return_value___errno_location_11);
        }
      }
      exit(1);
    }

    current = current->next_device;
  }
  if(!(reopen_arg->format->matrix == ((char *)NULL)))
    free((void *)reopen_arg->format->matrix);

  free((void *)reopen_arg->format);
  free((void *)reopen_arg);
}

// buffer_abort_write
// file buffer.c line 641
void buffer_abort_write(struct buf_t *buf)
{
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      buf->abort_write = 1;
      pthread_cond_signal(&buf->write_cond);
      pthread_cond_signal(&buf->playback_cond);
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// buffer_action_now
// file buffer.c line 659
void buffer_action_now(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg)
{
  struct action_t *action;
  action=malloc_action(action_func, action_arg);
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      action->position = buf->position;
      action->next = buf->actions;
      buf->actions = action;
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// buffer_append_action_at
// file buffer.c line 747
void buffer_append_action_at(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg, signed long int position)
{
  struct action_t *action;
  action=malloc_action(action_func, action_arg);
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      action->position = position;
      in_order_add_action(&buf->actions, action, 0);
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// buffer_append_action_at_end
// file buffer.c line 704
void buffer_append_action_at_end(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg)
{
  struct action_t *action;
  action=malloc_action(action_func, action_arg);
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      action->position = buf->position_end;
      in_order_add_action(&buf->actions, action, 0);
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// buffer_create
// file buffer.c line 396
struct buf_t * buffer_create(signed long int size, signed long int prebuffer, signed int (*write_func)(void *, signed int, signed int, void *), void *arg, signed int audio_chunk_size)
{
  struct buf_t *buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct buf_t) /*256ul*/  + sizeof(char) /*1ul*/  * (unsigned long int)(size - (signed long int)1));
  buf = (struct buf_t *)return_value_malloc_1;
  if(buf == ((struct buf_t *)NULL))
  {
    perror("malloc");
    exit(1);
  }

  memset((void *)buf, 0, sizeof(struct buf_t) /*256ul*/ );
  buf->write_func = write_func;
  buf->write_arg = arg;
  pthread_mutex_init(&buf->mutex, (const union anonymous_22 *)(void *)0);
  pthread_cond_init(&buf->write_cond, (const union anonymous_22 *)(void *)0);
  pthread_cond_init(&buf->playback_cond, (const union anonymous_22 *)(void *)0);
  if(audio_chunk_size == 0 || !(size >= (signed long int)audio_chunk_size))
    audio_chunk_size = (signed int)(size / (signed long int)2);

  if(!(size >= prebuffer))
    prebuffer = prebuffer / (signed long int)2;

  buf->audio_chunk_size = audio_chunk_size;
  buf->prebuffer_size = prebuffer;
  buf->size = size;
  buf->actions = ((struct action_t *)NULL);
  buffer_init_vars(buf);
  return buf;
}

// buffer_destroy
// file buffer.c line 471
void buffer_destroy(struct buf_t *buf)
{
  pthread_mutex_destroy(&buf->mutex);
  pthread_cond_signal(&buf->write_cond);
  pthread_cond_destroy(&buf->write_cond);
  pthread_cond_signal(&buf->playback_cond);
  pthread_cond_destroy(&buf->playback_cond);
  free((void *)buf);
}

// buffer_full
// file buffer.c line 795
signed long int buffer_full(struct buf_t *buf)
{
  return buf->curfill;
}

// buffer_get_data
// file buffer.c line 552
unsigned long int buffer_get_data(struct buf_t *buf, char *data, signed long int nbytes)
{
  signed int write_amount;
  signed int orig_size = (signed int)nbytes;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      while(nbytes >= 1l)
      {
        if(!(buf->abort_write == 0))
          break;

        if(buf->curfill == 0l)
        {
          if(!(buf->eos == 0))
            break;

        }

        if(buf->curfill == 0l)
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          if(!(buf->prebuffering == 0))
            tmp_if_expr_1 = !(buf->eos != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
          pthread_cond_wait(&buf->playback_cond, &buf->mutex);

        if(!(buf->abort_write == 0))
          break;

        write_amount=compute_dequeue_size(buf, (signed int)nbytes);
        pthread_mutex_unlock(&buf->mutex);
        execute_actions(buf, &buf->actions, buf->position);
        memcpy((void *)data, (const void *)(buf->buffer + buf->start), (unsigned long int)write_amount);
        pthread_mutex_lock(&buf->mutex);
        buf->curfill = buf->curfill - (signed long int)write_amount;
        data = data + (signed long int)write_amount;
        nbytes = nbytes - (signed long int)write_amount;
        buf->start = (buf->start + (signed long int)write_amount) % buf->size;
        pthread_cond_signal(&buf->write_cond);
      }
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L12:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
  pthread_testcancel();
  return (unsigned long int)((signed long int)orig_size - nbytes);
}

// buffer_init_vars
// file buffer.c line 63
void buffer_init_vars(struct buf_t *buf)
{
  buf->prebuffering = (signed int)(buf->prebuffer_size > (signed long int)0);
  buf->paused = 0;
  buf->eos = 0;
  buf->abort_write = 0;
  buf->cancel_flag = 0;
  buf->curfill = (signed long int)0;
  buf->start = (signed long int)0;
  buf->position = (signed long int)0;
  buf->position_end = (signed long int)0;
}

// buffer_insert_action_at
// file buffer.c line 726
void buffer_insert_action_at(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg, signed long int position)
{
  struct action_t *action;
  action=malloc_action(action_func, action_arg);
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      action->position = position;
      in_order_add_action(&buf->actions, action, 1);
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// buffer_insert_action_at_end
// file buffer.c line 682
void buffer_insert_action_at_end(struct buf_t *buf, void (*action_func)(struct buf_t *, void *), void *action_arg)
{
  struct action_t *action;
  action=malloc_action(action_func, action_arg);
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      action->position = buf->position_end;
      in_order_add_action(&buf->actions, action, 1);
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// buffer_mark_eos
// file buffer.c line 626
void buffer_mark_eos(struct buf_t *buf)
{
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      buf->eos = 1;
      buf->prebuffering = 0;
      pthread_cond_signal(&buf->playback_cond);
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// buffer_mutex_unlock
// file buffer.c line 102
void buffer_mutex_unlock(void *arg)
{
  struct buf_t *buf = (struct buf_t *)arg;
  pthread_mutex_unlock(&buf->mutex);
}

// buffer_reset
// file buffer.c line 446
void buffer_reset(struct buf_t *buf)
{
  struct action_t *action;
  pthread_mutex_destroy(&buf->mutex);
  pthread_cond_destroy(&buf->write_cond);
  pthread_cond_destroy(&buf->playback_cond);
  pthread_mutex_init(&buf->mutex, (const union anonymous_22 *)(void *)0);
  pthread_cond_init(&buf->write_cond, (const union anonymous_22 *)(void *)0);
  pthread_cond_init(&buf->playback_cond, (const union anonymous_22 *)(void *)0);
  while(!(buf->actions == ((struct action_t *)NULL)))
  {
    action = buf->actions;
    buf->actions = buf->actions->next;
    free((void *)action);
  }
  buffer_init_vars(buf);
}

// buffer_statistics
// file buffer.c line 801
struct buffer_stats_t * buffer_statistics(struct buf_t *buf)
{
  struct buffer_stats_t *stats;
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      stats=malloc_buffer_stats();
      stats->size = buf->size;
      stats->fill = ((double)buf->curfill / (double)buf->size) * 100.0;
      stats->prebuffer_fill = (double)buf->prebuffer_size / (double)buf->size;
      stats->prebuffering = buf->prebuffering;
      stats->paused = buf->paused;
      stats->eos = buf->eos;
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
  return stats;
}

// buffer_submit_data
// file buffer.c line 548
signed int buffer_submit_data(struct buf_t *buf, char *data, signed long int nbytes)
{
  signed int return_value_submit_data_chunk_1;
  return_value_submit_data_chunk_1=submit_data_chunk(buf, data, (unsigned long int)nbytes);
  return return_value_submit_data_chunk_1;
}

// buffer_thread_cleanup
// file buffer.c line 94
void buffer_thread_cleanup(void *arg)
{
  struct buf_t *buf = (struct buf_t *)arg;
}

// buffer_thread_func
// file buffer.c line 195
void * buffer_thread_func(void *arg)
{
  struct buf_t *buf = (struct buf_t *)arg;
  unsigned long int write_amount;
  buffer_thread_init(buf);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_5;
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_thread_cleanup;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);

  __CPROVER_DUMP_L3:
    ;
    do
    {
      if(!(buf->eos == 0))
      {
        if(!(buf->curfill == 0l))
          goto __CPROVER_DUMP_L4;

      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        if(buf->abort_write == 0)
        {
          if(!(buf->cancel_flag == 0) || !(sig_request.cancel == 0))
          {
            pthread_mutex_lock(&buf->mutex);
            pthread_cond_signal(&buf->write_cond);
            pthread_mutex_unlock(&buf->mutex);
          }

          else
          {
            pthread_mutex_lock(&buf->mutex);
            if(!(buf->prebuffering == 0))
              tmp_if_expr_1 = (_Bool)1;

            else
              tmp_if_expr_1 = buf->paused != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_1)
              tmp_if_expr_3 = (_Bool)1;

            else
            {
              if(!(buf->curfill >= (signed long int)buf->audio_chunk_size))
                tmp_if_expr_2 = !(buf->eos != 0) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_2 = (_Bool)0;
              tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_3)
              pthread_cond_wait(&buf->playback_cond, &buf->mutex);

            pthread_mutex_unlock(&buf->mutex);
            if(!(buf->cancel_flag == 0) || !(sig_request.cancel == 0))
            {
              pthread_mutex_lock(&buf->mutex);
              pthread_cond_signal(&buf->write_cond);
              pthread_mutex_unlock(&buf->mutex);
            }

            else
            {
              execute_actions(buf, &buf->actions, buf->position);
              pthread_mutex_lock(&buf->mutex);
              signed int return_value_compute_dequeue_size_4;
              return_value_compute_dequeue_size_4=compute_dequeue_size(buf, buf->audio_chunk_size);
              write_amount = (unsigned long int)return_value_compute_dequeue_size_4;
              pthread_mutex_unlock(&buf->mutex);
              if(!(write_amount == 0ul))
              {
                if(write_amount == (unsigned long int)buf->curfill)
                  tmp_if_expr_5 = buf->eos;

                else
                  tmp_if_expr_5 = 0;
                signed int return_value;
                return_value=buf->write_func((void *)(buf->buffer + buf->start), (signed int)write_amount, tmp_if_expr_5, buf->write_arg);
                write_amount = (unsigned long int)return_value;
                if(write_amount == 0ul)
                  buffer_abort_write(buf);

                pthread_mutex_lock(&buf->mutex);
                buf->curfill = buf->curfill - (signed long int)write_amount;
                buf->position = buf->position + (signed long int)write_amount;
                buf->start = (signed long int)(((unsigned long int)buf->start + write_amount) % (unsigned long int)buf->size);
                if(buf->eos == 0)
                {
                  if(!(buf->curfill >= (signed long int)buf->audio_chunk_size))
                    buf->prebuffering = (signed int)(buf->prebuffer_size > (signed long int)0);

                }

              }

              pthread_cond_signal(&buf->write_cond);
              pthread_mutex_unlock(&buf->mutex);
              goto __CPROVER_DUMP_L3;
            }
          }
        }

      }

    __CPROVER_DUMP_L19:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  return NULL;
}

// buffer_thread_init
// file buffer.c line 78
void buffer_thread_init(struct buf_t *buf)
{
  struct anonymous_34 set;
  sigfillset(&set);
  sigaddset(&set, 2);
  sigaddset(&set, 20);
  sigaddset(&set, 18);
  signed int return_value_pthread_sigmask_1;
  return_value_pthread_sigmask_1=pthread_sigmask(0, &set, (struct anonymous_34 *)(void *)0);
}

// buffer_thread_kill
// file buffer.c line 528
void buffer_thread_kill(struct buf_t *buf)
{
  buf->cancel_flag = 1;
  pthread_cond_signal(&buf->playback_cond);
  pthread_join(buf->thread, (void **)(void *)0);
  buffer_thread_cleanup((void *)buf);
}

// buffer_thread_pause
// file buffer.c line 499
void buffer_thread_pause(struct buf_t *buf)
{
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      buf->paused = 1;
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// buffer_thread_start
// file buffer.c line 488
signed int buffer_thread_start(struct buf_t *buf)
{
  signed int return_value_pthread_create_1;
  return_value_pthread_create_1=pthread_create(&buf->thread, (const union pthread_attr_t *)(void *)0, buffer_thread_func, (void *)buf);
  return return_value_pthread_create_1;
}

// buffer_thread_unpause
// file buffer.c line 513
void buffer_thread_unpause(struct buf_t *buf)
{
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      buf->paused = 0;
      pthread_cond_signal(&buf->playback_cond);
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// buffer_wait_for_empty
// file buffer.c line 770
void buffer_wait_for_empty(struct buf_t *buf)
{
  signed int empty = 0;
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&buf->mutex);
      while(empty == 0)
      {
        if(!(buf->abort_write == 0))
          break;

        if(!(buf->cancel_flag == 0))
          break;

        if(!(sig_request.cancel == 0))
          break;

        if(buf->curfill >= 1l)
          pthread_cond_wait(&buf->write_cond, &buf->mutex);

        else
          empty = 1;
      }
      pthread_mutex_unlock(&buf->mutex);

    __CPROVER_DUMP_L8:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// checknext
// file utf8.c line 331
static signed int checknext(const char *s, signed int count)
{
  signed int i = 0;
  for( ; !(i >= count); i = i + 1)
    if(!((0xc0 & (signed int)s[(signed long int)i]) == 0x80))
      return 0;

  return 1;
}

// clear_line
// file status.c line 92
void clear_line(signed int len)
{
  fputc(13, stderr);
  for( ; len >= 1; len = len - 1)
    fputc(32, stderr);
  fputc(13, stderr);
}

// close_audio_devices
// file audio.c line 98
void close_audio_devices(struct audio_device_t *devices)
{
  struct audio_device_t *current = devices;
  for( ; !(current == ((struct audio_device_t *)NULL)); current = current->next_device)
  {
    if(!(current->device == ((struct ao_device *)NULL)))
      ao_close(current->device);

    current->device = (struct ao_device *)(void *)0;
  }
}

// cmdline_usage
// file cmdline_options.c line 301
void cmdline_usage(void)
{
  signed int i;
  signed int j;
  signed int driver_count;
  struct ao_info **devices;
  devices=ao_driver_info_list(&driver_count);
  char *return_value_gettext_1;
  return_value_gettext_1=gettext("ogg123 from %s %s\n by the Xiph.Org Foundation (http://www.xiph.org/)\n\n");
  printf(return_value_gettext_1, (const void *)"vorbis-tools", (const void *)"1.4.0");
  char *return_value_gettext_2;
  return_value_gettext_2=gettext("Usage: ogg123 [options] file ...\nPlay Ogg audio files and network streams.\n\n");
  printf(return_value_gettext_2);
  char *return_value_gettext_3;
  return_value_gettext_3=gettext("Available codecs: ");
  printf(return_value_gettext_3);
  char *return_value_gettext_4;
  return_value_gettext_4=gettext("FLAC, ");
  printf(return_value_gettext_4);
  char *return_value_gettext_5;
  return_value_gettext_5=gettext("Speex, ");
  printf(return_value_gettext_5);
  char *return_value_gettext_6;
  return_value_gettext_6=gettext("Ogg Vorbis.\n\n");
  printf(return_value_gettext_6);
  char *return_value_gettext_7;
  return_value_gettext_7=gettext("Output options\n");
  printf(return_value_gettext_7);
  char *return_value_gettext_8;
  return_value_gettext_8=gettext("  -d dev, --device dev    Use output device \"dev\". Available devices:\n");
  printf(return_value_gettext_8);
  printf("                          ");
  char *return_value_gettext_9;
  return_value_gettext_9=gettext("Live:");
  printf(return_value_gettext_9);
  i = 0;
  j = 0;
  for( ; !(i >= driver_count); i = i + 1)
    if(devices[(signed long int)i]->type == 1)
    {
      printf("%c %s", j == 0 ? 32 : 44, devices[(signed long int)i]->short_name);
      j = j + 1;
    }

  printf("\n                          ");
  char *return_value_gettext_10;
  return_value_gettext_10=gettext("File:");
  printf(return_value_gettext_10);
  i = 0;
  j = 0;
  for( ; !(i >= driver_count); i = i + 1)
    if(devices[(signed long int)i]->type == 2)
    {
      printf("%c %s", j == 0 ? 32 : 44, devices[(signed long int)i]->short_name);
      j = j + 1;
    }

  printf("\n\n");
  char *return_value_gettext_11;
  return_value_gettext_11=gettext("  -f file, --file file    Set the output filename for a file device\n                          previously specified with --device.\n");
  printf(return_value_gettext_11);
  printf("\n");
  char *return_value_gettext_12;
  return_value_gettext_12=gettext("  --audio-buffer n        Use an output audio buffer of 'n' kilobytes\n");
  printf(return_value_gettext_12);
  char *return_value_gettext_13;
  return_value_gettext_13=gettext("  -o k:v, --device-option k:v\n                          Pass special option 'k' with value 'v' to the\n                          device previously specified with --device. See\n                          the ogg123 man page for available device options.\n");
  printf(return_value_gettext_13);
  printf("\n");
  char *return_value_gettext_14;
  return_value_gettext_14=gettext("Playlist options\n");
  printf(return_value_gettext_14);
  char *return_value_gettext_15;
  return_value_gettext_15=gettext("  -@ file, --list file    Read playlist of files and URLs from \"file\"\n");
  printf(return_value_gettext_15);
  char *return_value_gettext_16;
  return_value_gettext_16=gettext("  -r, --repeat            Repeat playlist indefinitely\n");
  printf(return_value_gettext_16);
  char *return_value_gettext_17;
  return_value_gettext_17=gettext("  -R, --remote            Use remote control interface\n");
  printf(return_value_gettext_17);
  char *return_value_gettext_18;
  return_value_gettext_18=gettext("  -z, --shuffle           Shuffle list of files before playing\n");
  printf(return_value_gettext_18);
  char *return_value_gettext_19;
  return_value_gettext_19=gettext("  -Z, --random            Play files randomly until interrupted\n");
  printf(return_value_gettext_19);
  printf("\n");
  char *return_value_gettext_20;
  return_value_gettext_20=gettext("Input options\n");
  printf(return_value_gettext_20);
  char *return_value_gettext_21;
  return_value_gettext_21=gettext("  -b n, --buffer n        Use an input buffer of 'n' kilobytes\n");
  printf(return_value_gettext_21);
  char *return_value_gettext_22;
  return_value_gettext_22=gettext("  -p n, --prebuffer n     Load n%% of the input buffer before playing\n");
  printf(return_value_gettext_22);
  printf("\n");
  char *return_value_gettext_23;
  return_value_gettext_23=gettext("Decode options\n");
  printf(return_value_gettext_23);
  char *return_value_gettext_24;
  return_value_gettext_24=gettext("  -k n, --skip n          Skip the first 'n' seconds (or hh:mm:ss format)\n");
  printf(return_value_gettext_24);
  char *return_value_gettext_25;
  return_value_gettext_25=gettext("  -K n, --end n           End at 'n' seconds (or hh:mm:ss format)\n");
  printf(return_value_gettext_25);
  char *return_value_gettext_26;
  return_value_gettext_26=gettext("  -x n, --nth n           Play every 'n'th block\n");
  printf(return_value_gettext_26);
  char *return_value_gettext_27;
  return_value_gettext_27=gettext("  -y n, --ntimes n        Repeat every played block 'n' times\n");
  printf(return_value_gettext_27);
  printf("\n");
  char *return_value_gettext_28;
  return_value_gettext_28=gettext("Miscellaneous options\n");
  printf(return_value_gettext_28);
  char *return_value_gettext_29;
  return_value_gettext_29=gettext("  -l s, --delay s         Set termination timeout in milliseconds. ogg123\n                          will skip to the next song on SIGINT (Ctrl-C),\n                          and will terminate if two SIGINTs are received\n                          within the specified timeout 's'. (default 500)\n");
  printf(return_value_gettext_29);
  printf("\n");
  char *return_value_gettext_30;
  return_value_gettext_30=gettext("  -h, --help              Display this help\n");
  printf(return_value_gettext_30);
  char *return_value_gettext_31;
  return_value_gettext_31=gettext("  -q, --quiet             Don't display anything (no title)\n");
  printf(return_value_gettext_31);
  char *return_value_gettext_32;
  return_value_gettext_32=gettext("  -v, --verbose           Display progress and other status information\n");
  printf(return_value_gettext_32);
  char *return_value_gettext_33;
  return_value_gettext_33=gettext("  -V, --version           Display ogg123 version\n");
  printf(return_value_gettext_33);
  printf("\n");
}

// compute_dequeue_size
// file buffer.c line 169
signed int compute_dequeue_size(struct buf_t *buf, signed int request_size)
{
  signed long int next_action_pos;
  signed long int tmp_if_expr_1;
  signed long int tmp_if_expr_2;
  signed long int tmp_if_expr_5;
  signed long int tmp_if_expr_3;
  signed long int tmp_if_expr_4;
  signed long int tmp_if_expr_6;
  signed long int tmp_if_expr_8;
  signed long int tmp_if_expr_7;
  if(!(buf->actions == ((struct action_t *)NULL)))
  {
    next_action_pos = buf->actions->position;
    if(!(buf->curfill >= (signed long int)request_size))
      tmp_if_expr_1 = (signed long int)buf->curfill;

    else
      tmp_if_expr_1 = (signed long int)request_size;
    if(!(buf->size + -buf->start >= next_action_pos + -buf->position))
      tmp_if_expr_2 = (signed long int)(buf->size - buf->start);

    else
      tmp_if_expr_2 = next_action_pos - buf->position;
    if(!(tmp_if_expr_1 >= tmp_if_expr_2))
    {
      if(!(buf->curfill >= (signed long int)request_size))
        tmp_if_expr_3 = (signed long int)buf->curfill;

      else
        tmp_if_expr_3 = (signed long int)request_size;
      tmp_if_expr_5 = tmp_if_expr_3;
    }

    else
    {
      if(!(buf->size + -buf->start >= next_action_pos + -buf->position))
        tmp_if_expr_4 = (signed long int)(buf->size - buf->start);

      else
        tmp_if_expr_4 = next_action_pos - buf->position;
      tmp_if_expr_5 = tmp_if_expr_4;
    }
    return (signed int)tmp_if_expr_5;
  }

  else
  {
    if(!((signed long int)request_size >= buf->size + -buf->start))
      tmp_if_expr_6 = (signed long int)request_size;

    else
      tmp_if_expr_6 = buf->size - buf->start;
    if(!(buf->curfill >= tmp_if_expr_6))
      tmp_if_expr_8 = buf->curfill;

    else
    {
      if(!((signed long int)request_size >= buf->size + -buf->start))
        tmp_if_expr_7 = (signed long int)request_size;

      else
        tmp_if_expr_7 = buf->size - buf->start;
      tmp_if_expr_8 = tmp_if_expr_7;
    }
    return (signed int)tmp_if_expr_8;
  }
}

// convert_buffer
// file utf8.c line 252
static signed int convert_buffer(const char *fromcode, const char *tocode, const char *from, unsigned long int fromlen, char **to, unsigned long int *tolen)
{
  signed int ret = -1;
  ret=iconvert(fromcode, tocode, from, fromlen, to, tolen);
  if(!(ret == -1))
    return ret;

  else
    return ret;
}

// convert_set_charset
// file utf8.c line 235
void convert_set_charset(const char *charset)
{
  if(charset == ((const char *)NULL))
    charset=getenv("CHARSET");

  if(charset == ((const char *)NULL))
    charset=nl_langinfo(14);

  free((void *)current_charset);
  current_charset = ((char *)NULL);
  if(!(charset == ((const char *)NULL)))
  {
    if(!(*charset == 0))
      current_charset=strdup(charset);

  }

}

// convert_string
// file utf8.c line 273
static signed int convert_string(const char *fromcode, const char *tocode, const char *from, char **to, char replace)
{
  signed int ret;
  unsigned long int fromlen;
  char *s;
  fromlen=strlen(from);
  ret=convert_buffer(fromcode, tocode, from, fromlen, to, ((unsigned long int *)NULL));
  if(ret == -2)
    return -1;

  else
    if(!(ret == -1))
      return ret;

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(fromlen + (unsigned long int)1);
      s = (char *)return_value_malloc_1;
      if(s == ((char *)NULL))
        return -1;

      else
      {
        strcpy(s, from);
        *to = s;
        for( ; !(*s == 0); s = s + 1l)
          if(!((-128 & (signed int)*s) == 0))
            *s = replace;

        return 3;
      }
    }
}

// curl_thread_func
// file http_transport.c line 133
void * curl_thread_func(void *arg)
{
  struct http_private_t *myarg = (struct http_private_t *)arg;
  enum anonymous_2 ret;
  struct anonymous_34 set;
  sigfillset(&set);
  sigaddset(&set, 2);
  sigaddset(&set, 20);
  sigaddset(&set, 18);
  signed int return_value_pthread_sigmask_2;
  return_value_pthread_sigmask_2=pthread_sigmask(0, &set, (struct anonymous_34 *)(void *)0);
  char *return_value_gettext_1;
  if(!(return_value_pthread_sigmask_2 == 0))
  {
    return_value_gettext_1=gettext("ERROR: Could not set signal mask.");
    status_error(return_value_gettext_1);
  }

  ret=curl_easy_perform((void *)myarg->curl_handle);
  if(!(myarg->cancel_flag == 0) || !(sig_request.cancel == 0))
  {
    buffer_abort_write(myarg->buf);
    ret = (enum anonymous_2)0;
  }

  else
    buffer_mark_eos(myarg->buf);
  if(!((signed int)ret == 0))
    status_error(myarg->error);

  curl_easy_cleanup(myarg->curl_handle);
  myarg->curl_handle = NULL;
  curl_slist_free_all(myarg->header_list);
  myarg->header_list = (struct curl_slist *)(void *)0;
  return (void *)ret;
}

// current_time
// file ogg123.c line 356
double current_time(struct decoder_t *decoder)
{
  struct decoder_stats_t *stats;
  double ret;
  stats=decoder->format->statistics(decoder);
  ret = stats->current_time;
  free((void *)stats);
  return ret;
}

// decoder_buffered_error_callback
// file callbacks.c line 271
void decoder_buffered_error_callback(void *arg, signed int severity, char *message, ...)
{
  void **ap;
  struct buf_t *buf = (struct buf_t *)arg;
  struct status_message_arg_t *sm_arg;
  sm_arg=new_status_message_arg(0);
  signed int n;
  signed int size = 80;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)size, (unsigned long int)1);
  sm_arg->message = (char *)return_value_calloc_2;
  if(sm_arg->message == ((char *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("Error: Out of memory in decoder_buffered_metadata_callback().\n");
    status_error(return_value_gettext_1);
    exit(1);
  }

  while((_Bool)1)
  {
    ap = (void **)&message;
    n=vsnprintf(sm_arg->message, (unsigned long int)size, message, ap);
    ap = ((void **)NULL);
    if(n >= 0 && !(n >= size))
      break;

    if(n >= 0)
      size = n + 1;

    else
      size = size * 2;
    void *return_value_realloc_4;
    return_value_realloc_4=realloc((void *)sm_arg->message, (unsigned long int)size);
    sm_arg->message = (char *)return_value_realloc_4;
    if(sm_arg->message == ((char *)NULL))
    {
      char *return_value_gettext_3;
      return_value_gettext_3=gettext("Error: Out of memory in decoder_buffered_metadata_callback().\n");
      status_error(return_value_gettext_3);
      exit(1);
    }

  }
  switch(severity)
  {
    case 0:
    {
      buffer_append_action_at_end(buf, status_error_action, (void *)sm_arg);
      break;
    }
    case 1:
    {
      sm_arg->verbosity = 2;
      buffer_append_action_at_end(buf, status_message_action, (void *)sm_arg);
      break;
    }
    case 2:
    {
      sm_arg->verbosity = 3;
      buffer_append_action_at_end(buf, status_message_action, (void *)sm_arg);
    }
  }
}

// decoder_buffered_metadata_callback
// file callbacks.c line 327
void decoder_buffered_metadata_callback(void *arg, signed int verbosity, char *message, ...)
{
  void **ap;
  struct buf_t *buf = (struct buf_t *)arg;
  struct status_message_arg_t *sm_arg;
  sm_arg=new_status_message_arg(0);
  signed int n;
  signed int size = 80;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)size, (unsigned long int)1);
  sm_arg->message = (char *)return_value_calloc_2;
  if(sm_arg->message == ((char *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("ERROR: Out of memory in decoder_buffered_metadata_callback().\n");
    status_error(return_value_gettext_1);
    exit(1);
  }

  while((_Bool)1)
  {
    ap = (void **)&message;
    n=vsnprintf(sm_arg->message, (unsigned long int)size, message, ap);
    ap = ((void **)NULL);
    if(n >= 0 && !(n >= size))
      break;

    if(n >= 0)
      size = n + 1;

    else
      size = size * 2;
    void *return_value_realloc_4;
    return_value_realloc_4=realloc((void *)sm_arg->message, (unsigned long int)size);
    sm_arg->message = (char *)return_value_realloc_4;
    if(sm_arg->message == ((char *)NULL))
    {
      char *return_value_gettext_3;
      return_value_gettext_3=gettext("ERROR: Out of memory in decoder_buffered_metadata_callback().\n");
      status_error(return_value_gettext_3);
      exit(1);
    }

  }
  sm_arg->verbosity = verbosity;
  buffer_append_action_at_end(buf, status_message_action, (void *)sm_arg);
}

// decoder_error_callback
// file callbacks.c line 193
void decoder_error_callback(void *arg, signed int severity, char *message, ...)
{
  void **ap = (void **)&message;
  switch(severity)
  {
    case 0:
    {
      vstatus_error(message, ap);
      break;
    }
    case 1:
    {
      vstatus_message(2, message, ap);
      break;
    }
    case 2:
      vstatus_message(3, message, ap);
  }
  ap = ((void **)NULL);
}

// decoder_metadata_callback
// file callbacks.c line 213
void decoder_metadata_callback(void *arg, signed int verbosity, char *message, ...)
{
  void **ap = (void **)&message;
  vstatus_message(verbosity, message, ap);
  ap = ((void **)NULL);
}

// display_statistics
// file ogg123.c line 283
void display_statistics(struct anonymous_3 *stat_format, struct buf_t *audio_buffer, struct data_source_t *source, struct decoder_t *decoder)
{
  struct print_statistics_arg_t *pstats_arg;
  struct buffer_stats_t *buffer_stats;
  struct data_source_stats_t *return_value;
  return_value=source->transport->statistics(source);
  struct decoder_stats_t *return_value_1;
  return_value_1=decoder->format->statistics(decoder);
  pstats_arg=new_print_statistics_arg(stat_format, return_value, return_value_1);
  _Bool tmp_if_expr_1;
  if(!(options.remote == 0))
    remote_time(pstats_arg->decoder_statistics->current_time, pstats_arg->decoder_statistics->total_time);

  else
  {
    if(pstats_arg->decoder_statistics->total_time < pstats_arg->decoder_statistics->current_time)
    {
      (stat_format + (signed long int)2)->enabled = (char)0;
      (stat_format + (signed long int)3)->enabled = (char)0;
    }

    if(!(pstats_arg->data_source_statistics->input_buffer_used == 0))
    {
      (stat_format + (signed long int)6)->enabled = (char)1;
      (stat_format + (signed long int)7)->enabled = (char)1;
    }

    if(!(audio_buffer == ((struct buf_t *)NULL)))
    {
      buffer_append_action_at_end(audio_buffer, print_statistics_action, (void *)pstats_arg);
      buffer_stats=buffer_statistics(audio_buffer);
      if(!(buffer_stats->paused == 0))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = buffer_stats->prebuffering != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        pstats_arg=new_print_statistics_arg(stat_format, (struct data_source_stats_t *)(void *)0, (struct decoder_stats_t *)(void *)0);
        print_statistics_action(audio_buffer, (void *)pstats_arg);
      }

      free((void *)buffer_stats);
    }

    else
      print_statistics_action((struct buf_t *)(void *)0, (void *)pstats_arg);
  }
}

// display_statistics_quick
// file ogg123.c line 339
void display_statistics_quick(struct anonymous_3 *stat_format, struct buf_t *audio_buffer, struct data_source_t *source, struct decoder_t *decoder)
{
  struct print_statistics_arg_t *pstats_arg;
  struct data_source_stats_t *return_value;
  return_value=source->transport->statistics(source);
  struct decoder_stats_t *return_value_1;
  return_value_1=decoder->format->statistics(decoder);
  pstats_arg=new_print_statistics_arg(stat_format, return_value, return_value_1);
  if(!(audio_buffer == ((struct buf_t *)NULL)))
    print_statistics_action(audio_buffer, (void *)pstats_arg);

  else
    print_statistics_action((struct buf_t *)(void *)0, (void *)pstats_arg);
}

// eof_callback
// file flac_format.c line 542
static signed int eof_callback(const struct anonymous_19 *decoder, void *client_data)
{
  struct decoder_t *e_decoder = (struct decoder_t *)client_data;
  struct anonymous_21 *priv = (struct anonymous_21 *)e_decoder->private;
  return priv->eos;
}

// error_callback
// file flac_format.c line 534
static void error_callback(const struct anonymous_19 *decoder, enum anonymous_53 status, void *client_data)
{
  ;
}

// execute_actions
// file buffer.c line 148
void execute_actions(struct buf_t *buf, struct action_t **action_list, signed long int position)
{
  struct action_t *action;
  if(!(*action_list == ((struct action_t *)NULL)))
  {
    if(position >= (*action_list)->position)
    {
      action = *action_list;
      action->action_func(buf, action->arg);
      *action_list = (*action_list)->next;
      free((void *)action);
    }

  }

}

// file_can_transport
// file file_transport.c line 40
signed int file_can_transport(char *source_string)
{
  return 1;
}

// file_close
// file file_transport.c line 155
void file_close(struct data_source_t *source)
{
  struct file_private_t *private = (struct file_private_t *)source->private;
  struct _IO_FILE *fp = private->fp;
  fclose(fp);
  free((void *)source->source_string);
  free(source->private);
  free((void *)source);
}

// file_open
// file file_transport.c line 45
struct data_source_t * file_open(char *source_string, struct ogg123_options_t *ogg123_opts)
{
  struct data_source_t *source;
  struct file_private_t *private;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct data_source_t) /*24ul*/ );
  source = (struct data_source_t *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct file_private_t) /*80ul*/ );
  private = (struct file_private_t *)return_value_malloc_2;
  if(!(source == ((struct data_source_t *)NULL)) && !(private == ((struct file_private_t *)NULL)))
  {
    source->source_string=strdup(source_string);
    source->transport = &file_transport;
    source->private = (void *)private;
    private->seekable = 1;
    private->stats.transfer_rate = (signed long int)0;
    private->stats.bytes_read = (signed long int)0;
    private->stats.input_buffer_used = 0;
  }

  else
  {
    char *return_value_gettext_3;
    return_value_gettext_3=gettext("ERROR: Out of memory.\n");
    fprintf(stderr, return_value_gettext_3);
    exit(1);
  }
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(source_string, "-");
  if(return_value_strcmp_4 == 0)
  {
    private->fp = stdin;
    private->seekable = 0;
  }

  else
    private->fp=fopen(source_string, "r");
  if(private->fp == ((struct _IO_FILE *)NULL))
  {
    free((void *)source->source_string);
    free((void *)private);
    free((void *)source);
    return (struct data_source_t *)(void *)0;
  }

  else
    return source;
}

// file_options_describe
// file cfgfile_options.c line 110
void file_options_describe(struct file_option_t *opts, struct _IO_FILE *f)
{
  signed int colWidths[4l] = { 0, 0, 7, 7 };
  signed int totalWidth = 0;
  struct file_option_t *opt = opts;
  while(!(opt->name == ((const char *)NULL)))
  {
    signed int len;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(opt->name);
    len = (signed int)(return_value_strlen_1 + (unsigned long int)1);
    if(!(colWidths[0l] >= len))
      colWidths[(signed long int)0] = len;

    opt = opt + 1l;
  }
  opt = opts;
  while(!(opt->name == ((const char *)NULL)))
  {
    signed int file_options_describe__1__2__len;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(opt->desc);
    file_options_describe__1__2__len = (signed int)(return_value_strlen_2 + (unsigned long int)1);
    if(!(colWidths[1l] >= file_options_describe__1__2__len))
      colWidths[(signed long int)1] = file_options_describe__1__2__len;

    opt = opt + 1l;
  }
  char *return_value_gettext_3;
  return_value_gettext_3=gettext("Name");
  signed int return_value_fprintf_4;
  return_value_fprintf_4=fprintf(f, "%-*s", colWidths[(signed long int)0], return_value_gettext_3);
  totalWidth = totalWidth + return_value_fprintf_4;
  char *return_value_gettext_5;
  return_value_gettext_5=gettext("Description");
  signed int return_value_fprintf_6;
  return_value_fprintf_6=fprintf(f, "%-*s", colWidths[(signed long int)1], return_value_gettext_5);
  totalWidth = totalWidth + return_value_fprintf_6;
  char *return_value_gettext_7;
  return_value_gettext_7=gettext("Type");
  signed int return_value_fprintf_8;
  return_value_fprintf_8=fprintf(f, "%-*s", colWidths[(signed long int)2], return_value_gettext_7);
  totalWidth = totalWidth + return_value_fprintf_8;
  char *return_value_gettext_9;
  return_value_gettext_9=gettext("Default");
  signed int return_value_fprintf_10;
  return_value_fprintf_10=fprintf(f, "%-*s", colWidths[(signed long int)3], return_value_gettext_9);
  totalWidth = totalWidth + return_value_fprintf_10;
  fputc(10, f);
  print_space(f, totalWidth, 45);
  fputc(10, f);
  opt = opts;
  char *return_value_gettext_13;
  signed int return_value_fprintf_14;
  char *return_value_gettext_15;
  signed int return_value_fprintf_16;
  char *return_value_gettext_17;
  signed int return_value_fprintf_18;
  char *return_value_gettext_19;
  signed int return_value_fprintf_20;
  char *return_value_gettext_21;
  signed int return_value_fprintf_22;
  char *return_value_gettext_23;
  signed int return_value_fprintf_24;
  char *return_value_gettext_25;
  signed int return_value_fprintf_26;
  char *return_value_gettext_29;
  char *return_value_gettext_30;
  while(!(opt->name == ((const char *)NULL)))
  {
    signed int w = colWidths[(signed long int)0];
    signed int return_value_fprintf_11;
    return_value_fprintf_11=fprintf(f, "%s", opt->name);
    w = w - return_value_fprintf_11;
    print_space(f, w, 32);
    w = colWidths[(signed long int)1];
    signed int return_value_fprintf_12;
    return_value_fprintf_12=fprintf(f, "%s", opt->desc);
    w = w - return_value_fprintf_12;
    print_space(f, w, 32);
    w = colWidths[(signed long int)2];
    switch((signed int)opt->type)
    {
      case opt_type_none:
      {
        return_value_gettext_13=gettext("none");
        return_value_fprintf_14=fprintf(f, return_value_gettext_13);
        w = w - return_value_fprintf_14;
        break;
      }
      case opt_type_bool:
      {
        return_value_gettext_15=gettext("bool");
        return_value_fprintf_16=fprintf(f, return_value_gettext_15);
        w = w - return_value_fprintf_16;
        break;
      }
      case opt_type_char:
      {
        return_value_gettext_17=gettext("char");
        return_value_fprintf_18=fprintf(f, return_value_gettext_17);
        w = w - return_value_fprintf_18;
        break;
      }
      case opt_type_string:
      {
        return_value_gettext_19=gettext("string");
        return_value_fprintf_20=fprintf(f, return_value_gettext_19);
        w = w - return_value_fprintf_20;
        break;
      }
      case opt_type_int:
      {
        return_value_gettext_21=gettext("int");
        return_value_fprintf_22=fprintf(f, return_value_gettext_21);
        w = w - return_value_fprintf_22;
        break;
      }
      case opt_type_float:
      {
        return_value_gettext_23=gettext("float");
        return_value_fprintf_24=fprintf(f, return_value_gettext_23);
        w = w - return_value_fprintf_24;
        break;
      }
      case opt_type_double:
      {
        return_value_gettext_25=gettext("double");
        return_value_fprintf_26=fprintf(f, return_value_gettext_25);
        w = w - return_value_fprintf_26;
        break;
      }
      default:
      {
        char *return_value_gettext_27;
        return_value_gettext_27=gettext("other");
        signed int return_value_fprintf_28;
        return_value_fprintf_28=fprintf(f, return_value_gettext_27);
        w = w - return_value_fprintf_28;
      }
    }
    print_space(f, w, 32);
    if(opt->dfl == NULL)
    {
      return_value_gettext_29=gettext("(NULL)");
      fputs(return_value_gettext_29, f);
    }

    else
      switch((signed int)opt->type)
      {
        case opt_type_none:
        {
          return_value_gettext_30=gettext("(none)");
          fputs(return_value_gettext_30, f);
          break;
        }
        case opt_type_char:
        {
          fputc((signed int)*((char *)opt->dfl), f);
          break;
        }
        case opt_type_string:
        {
          fputs(*((char **)opt->dfl), f);
          break;
        }
        case opt_type_bool:

        case opt_type_int:
        {
          fprintf(f, "%d", *((signed int *)opt->dfl));
          break;
        }
        case opt_type_float:
        {
          fprintf(f, "%f", (double)*((float *)opt->dfl));
          break;
        }
        case opt_type_double:
          fprintf(f, "%f", *((double *)opt->dfl));
      }
    fputc(10, f);
    opt = opt + 1l;
  }
}

// file_options_init
// file cfgfile_options.c line 68
void file_options_init(struct file_option_t *opts)
{
  for( ; !(opts == ((struct file_option_t *)NULL)); opts = opts + 1l)
  {
    if(opts->name == ((const char *)NULL))
      break;

    opts->found = (char)0;
    if(!(opts->dfl == NULL))
      switch((signed int)opts->type)
      {
        case opt_type_none:
          break;
        case opt_type_char:
        {
          *((char *)opts->ptr) = *((char *)opts->dfl);
          break;
        }
        case opt_type_string:
        {
          *((char **)opts->ptr) = *((char **)opts->dfl);
          break;
        }
        case opt_type_bool:

        case opt_type_int:
        {
          *((signed int *)opts->ptr) = *((signed int *)opts->dfl);
          break;
        }
        case opt_type_float:
        {
          *((float *)opts->ptr) = *((float *)opts->dfl);
          break;
        }
        case opt_type_double:
          *((double *)opts->ptr) = *((double *)opts->dfl);
      }

  }
}

// file_peek
// file file_transport.c line 87
signed int file_peek(struct data_source_t *source, void *ptr, unsigned long int size, unsigned long int nmemb)
{
  struct file_private_t *private = (struct file_private_t *)source->private;
  struct _IO_FILE *fp = private->fp;
  signed int items;
  signed long int start;
  if(private->seekable == 0)
    return 0;

  else
  {
    start=ftell(fp);
    unsigned long int return_value_fread_1;
    return_value_fread_1=fread(ptr, size, nmemb, fp);
    items = (signed int)return_value_fread_1;
    signed int return_value_fseek_2;
    return_value_fseek_2=fseek(fp, start, 0);
    if(!(return_value_fseek_2 == 0))
      items = 0;

    return items;
  }
}

// file_read
// file file_transport.c line 110
signed int file_read(struct data_source_t *source, void *ptr, unsigned long int size, unsigned long int nmemb)
{
  struct file_private_t *private = (struct file_private_t *)source->private;
  struct _IO_FILE *fp = private->fp;
  signed int bytes_read;
  unsigned long int return_value_fread_1;
  return_value_fread_1=fread(ptr, size, nmemb, fp);
  bytes_read = (signed int)return_value_fread_1;
  if(bytes_read >= 1)
    private->stats.bytes_read = private->stats.bytes_read + (signed long int)bytes_read;

  return bytes_read;
}

// file_seek
// file file_transport.c line 125
signed int file_seek(struct data_source_t *source, signed long int offset, signed int whence)
{
  struct file_private_t *private = (struct file_private_t *)source->private;
  struct _IO_FILE *fp = private->fp;
  if(private->seekable == 0)
    return -1;

  else
  {
    signed int return_value_fseek_1;
    return_value_fseek_1=fseek(fp, offset, whence);
    return return_value_fseek_1;
  }
}

// file_statistics
// file file_transport.c line 136
struct data_source_stats_t * file_statistics(struct data_source_t *source)
{
  struct file_private_t *private = (struct file_private_t *)source->private;
  struct data_source_stats_t *return_value_malloc_data_source_stats_1;
  return_value_malloc_data_source_stats_1=malloc_data_source_stats(&private->stats);
  return return_value_malloc_data_source_stats_1;
}

// file_tell
// file file_transport.c line 144
signed long int file_tell(struct data_source_t *source)
{
  struct file_private_t *private = (struct file_private_t *)source->private;
  struct _IO_FILE *fp = private->fp;
  if(private->seekable == 0)
    return (signed long int)-1;

  else
  {
    signed long int return_value_ftell_1;
    return_value_ftell_1=ftell(fp);
    return return_value_ftell_1;
  }
}

// flac_can_decode
// file flac_format.c line 103
signed int flac_can_decode(struct data_source_t *source)
{
  char buf[4l];
  signed int len;
  len=source->transport->peek(source, (void *)buf, sizeof(char) /*1ul*/ , (unsigned long int)4);
  _Bool tmp_if_expr_2;
  signed int return_value_memcmp_1;
  if(len >= 4)
  {
    return_value_memcmp_1=memcmp((const void *)buf, (const void *)"fLaC", (unsigned long int)4);
    tmp_if_expr_2 = return_value_memcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    return 1;

  else
    return 0;
}

// flac_cleanup
// file flac_format.c line 407
void flac_cleanup(struct decoder_t *decoder)
{
  struct anonymous_21 *priv = (struct anonymous_21 *)decoder->private;
  signed int i = 0;
  for( ; !(i >= (signed int)priv->channels); i = i + 1)
    free((void *)priv->buf[(signed long int)i]);
  free((void *)priv->buf);
  FLAC__stream_decoder_finish(priv->decoder);
  FLAC__stream_decoder_delete(priv->decoder);
  free(decoder->private);
  free((void *)decoder);
}

// flac_init
// file flac_format.c line 143
struct decoder_t * flac_init(struct data_source_t *source, struct ogg123_options_t *ogg123_opts, struct audio_format_t *audio_fmt, struct decoder_callbacks_t *callbacks, void *callback_arg)
{
  struct decoder_t *decoder;
  struct anonymous_21 *private;
  signed int ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct decoder_t) /*104ul*/ );
  decoder = (struct decoder_t *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct anonymous_21) /*144ul*/ );
  private = (struct anonymous_21 *)return_value_malloc_2;
  if(!(private == ((struct anonymous_21 *)NULL)) && !(decoder == ((struct decoder_t *)NULL)))
  {
    decoder->source = source;
    decoder->request_fmt = *audio_fmt;
    decoder->actual_fmt = decoder->request_fmt;
    decoder->callbacks = callbacks;
    decoder->callback_arg = callback_arg;
    decoder->private = (void *)private;
    private->stats.total_time = 0.0;
    private->stats.current_time = 0.0;
    private->stats.instant_bitrate = (signed long int)0;
    private->stats.avg_bitrate = (signed long int)0;
  }

  else
  {
    char *return_value_gettext_3;
    return_value_gettext_3=gettext("Error: Out of memory.\n");
    fprintf(stderr, return_value_gettext_3);
    exit(1);
  }
  private->bos = 1;
  private->eos = 0;
  private->comments = (struct anonymous_20 *)(void *)0;
  private->samples_decoded_previous = (signed long int)0;
  private->samples_decoded = private->samples_decoded_previous;
  private->bytes_read_previous = (signed long int)0;
  private->bytes_read = private->bytes_read_previous;
  private->currentsample = (signed long int)0;
  private->channels = (signed short int)0;
  private->buf = (signed int **)(void *)0;
  private->buf_len = 0;
  private->buf_fill = 0;
  private->buf_start = 0;
  signed int return_value_oggflac_can_decode_4;
  return_value_oggflac_can_decode_4=oggflac_can_decode(source);
  if(!(return_value_oggflac_can_decode_4 == 0))
  {
    private->is_oggflac = 1;
    decoder->format = &oggflac_format;
  }

  else
  {
    private->is_oggflac = 0;
    decoder->format = &flac_format;
  }
  private->decoder=FLAC__stream_decoder_new();
  FLAC__stream_decoder_set_md5_checking(private->decoder, 0);
  FLAC__stream_decoder_set_metadata_respond(private->decoder, (enum anonymous_36)FLAC__METADATA_TYPE_STREAMINFO);
  FLAC__stream_decoder_set_metadata_respond(private->decoder, (enum anonymous_36)FLAC__METADATA_TYPE_VORBIS_COMMENT);
  if(!(private->is_oggflac == 0))
    FLAC__stream_decoder_init_ogg_stream(private->decoder, read_callback, ((enum anonymous_49 (*)(const struct anonymous_19 *, unsigned long int, void *))NULL), ((enum anonymous_50 (*)(const struct anonymous_19 *, unsigned long int *, void *))NULL), ((enum anonymous_51 (*)(const struct anonymous_19 *, unsigned long int *, void *))NULL), eof_callback, write_callback_link1, metadata_callback, error_callback, (void *)decoder);

  else
    FLAC__stream_decoder_init_stream(private->decoder, read_callback, ((enum anonymous_49 (*)(const struct anonymous_19 *, unsigned long int, void *))NULL), ((enum anonymous_50 (*)(const struct anonymous_19 *, unsigned long int *, void *))NULL), ((enum anonymous_51 (*)(const struct anonymous_19 *, unsigned long int *, void *))NULL), eof_callback, write_callback_link1, metadata_callback, error_callback, (void *)decoder);
  FLAC__stream_decoder_process_until_end_of_metadata(private->decoder);
  FLAC__stream_decoder_process_single(private->decoder);
  decoder->actual_fmt.signed_sample = 1;
  decoder->actual_fmt.big_endian=ao_is_big_endian();
  return decoder;
}

// flac_read
// file flac_format.c line 250
signed int flac_read(struct decoder_t *decoder, void *ptr, signed int nbytes, signed int *eos, struct audio_format_t *audio_fmt)
{
  struct anonymous_21 *priv = (struct anonymous_21 *)decoder->private;
  struct decoder_callbacks_t *cb = decoder->callbacks;
  signed char *buf8 = (signed char *)ptr;
  signed short int *buf16 = (signed short int *)ptr;
  signed long int samples;
  signed long int realsamples = (signed long int)0;
  signed int ret;
  signed int i;
  signed int j;
  if(!(priv->bos == 0))
  {
    decoder->actual_fmt.rate = priv->rate;
    decoder->actual_fmt.channels = (signed int)priv->channels;
    decoder->actual_fmt.word_size = (priv->bits_per_sample + 7) / 8;
    switch(decoder->actual_fmt.channels)
    {
      case 1:
      {
        decoder->actual_fmt.matrix = "M";
        break;
      }
      case 2:
      {
        decoder->actual_fmt.matrix = "L,R";
        break;
      }
      case 3:
      {
        decoder->actual_fmt.matrix = "L,R,C";
        break;
      }
      case 4:
      {
        decoder->actual_fmt.matrix = "L,R,BL,BR";
        break;
      }
      case 5:
      {
        decoder->actual_fmt.matrix = "L,R,C,BL,BR";
        break;
      }
      case 6:
      {
        decoder->actual_fmt.matrix = "L,R,C,LFE,BL,BR";
        break;
      }
      case 7:
      {
        decoder->actual_fmt.matrix = "L,R,C,LFE,SL,SR,BC";
        break;
      }
      case 8:
      {
        decoder->actual_fmt.matrix = "L,R,C,LFE,SL,SR,BL,BR";
        break;
      }
      default:
        decoder->actual_fmt.matrix = (char *)(void *)0;
    }
    print_flac_stream_info(decoder);
    if(!(priv->comments == ((struct anonymous_20 *)NULL)))
      print_flac_comments(&priv->comments->data.vorbis_comment, cb, decoder->callback_arg);

    priv->bos = 0;
  }

  *audio_fmt = decoder->actual_fmt;
  _Bool tmp_if_expr_2;
  if(!(audio_fmt->channels == 0))
    tmp_if_expr_2 = audio_fmt->word_size != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(!tmp_if_expr_2)
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("Error: Corrupt input.\n");
    fprintf(stderr, return_value_gettext_1);
    exit(1);
  }

  samples = (signed long int)(nbytes / (audio_fmt->channels * audio_fmt->word_size));
  signed long int tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  enum anonymous_45 return_value_FLAC__stream_decoder_get_state_4;
  while(!(realsamples >= samples))
    if(priv->buf_fill >= 1)
    {
      signed int copy;
      if(!((signed long int)priv->buf_fill >= samples + -realsamples))
        tmp_if_expr_3 = (signed long int)priv->buf_fill;

      else
        tmp_if_expr_3 = samples - realsamples;
      copy = (signed int)tmp_if_expr_3;
      if(audio_fmt->word_size == 1)
      {
        i = 0;
        for( ; !(i >= (signed int)priv->channels); i = i + 1)
        {
          j = 0;
          for( ; !(j >= copy); j = j + 1)
            buf8[((signed long int)j + realsamples) * (signed long int)audio_fmt->channels + (signed long int)i] = (signed char)(0xFF & priv->buf[(signed long int)i][(signed long int)(j + priv->buf_start)]);
        }
      }

      else
        if(audio_fmt->word_size == 2)
        {
          i = 0;
          for( ; !(i >= (signed int)priv->channels); i = i + 1)
          {
            j = 0;
            for( ; !(j >= copy); j = j + 1)
              buf16[((signed long int)j + realsamples) * (signed long int)audio_fmt->channels + (signed long int)i] = (signed short int)(0xFFFF & priv->buf[(signed long int)i][(signed long int)(j + priv->buf_start)]);
          }
        }

      priv->buf_start = priv->buf_start + copy;
      priv->buf_fill = priv->buf_fill - copy;
      realsamples = realsamples + (signed long int)copy;
    }

    else
      if(priv->eos == 0)
      {
        ret=FLAC__stream_decoder_process_single(priv->decoder);
        if(ret == 0)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_FLAC__stream_decoder_get_state_4=FLAC__stream_decoder_get_state(priv->decoder);
          tmp_if_expr_5 = (signed int)return_value_FLAC__stream_decoder_get_state_4 == FLAC__STREAM_DECODER_END_OF_STREAM ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          priv->eos = 1;

      }

      else
        break;
  priv->currentsample = priv->currentsample + realsamples;
  return (signed int)(realsamples * (signed long int)audio_fmt->channels * (signed long int)audio_fmt->word_size);
}

// flac_seek
// file flac_format.c line 361
signed int flac_seek(struct decoder_t *decoder, double offset, signed int whence)
{
  return 0;
}

// flac_statistics
// file flac_format.c line 369
struct decoder_stats_t * flac_statistics(struct decoder_t *decoder)
{
  struct anonymous_21 *priv = (struct anonymous_21 *)decoder->private;
  signed long int instant_bitrate;
  priv->stats.total_time = (double)priv->totalsamples / (double)decoder->actual_fmt.rate;
  priv->stats.current_time = (double)priv->currentsample / (double)decoder->actual_fmt.rate;
  if(!(priv->bytes_read == priv->bytes_read_previous))
  {
    if(!(priv->samples_decoded == priv->samples_decoded_previous))
    {
      instant_bitrate = (signed long int)((8.0 * (double)(priv->bytes_read - priv->bytes_read_previous) * (double)decoder->actual_fmt.rate) / (double)(priv->samples_decoded - priv->samples_decoded_previous));
      priv->stats.instant_bitrate = (signed long int)(0.5 * (double)instant_bitrate + (1.0 - 0.5) * (double)priv->stats.instant_bitrate);
      priv->bytes_read_previous = priv->bytes_read;
      priv->samples_decoded_previous = priv->samples_decoded;
    }

  }

  priv->stats.avg_bitrate = (signed long int)0;
  struct decoder_stats_t *return_value_malloc_decoder_stats_1;
  return_value_malloc_decoder_stats_1=malloc_decoder_stats(&priv->stats);
  return return_value_malloc_decoder_stats_1;
}

// free_action
// file buffer.c line 162
void free_action(struct action_t *action)
{
  free((void *)action);
}

// free_audio_devices
// file audio.c line 110
void free_audio_devices(struct audio_device_t *devices)
{
  struct audio_device_t *current;
  for( ; !(devices == ((struct audio_device_t *)NULL)); devices = current)
  {
    current = devices->next_device;
    free((void *)devices);
  }
}

// get_format_by_name
// file format.c line 53
struct format_t * get_format_by_name(char *name)
{
  signed int i = 0;
  signed int return_value_strcmp_1;
  for( ; !(formats[(signed long int)i] == ((struct format_t *)NULL)); i = i + 1)
  {
    return_value_strcmp_1=strcmp(name, formats[(signed long int)i]->name);
    if(return_value_strcmp_1 == 0)
      break;

  }
  return formats[(signed long int)i];
}

// get_transport_by_name
// file transport.c line 42
struct transport_t * get_transport_by_name(char *name)
{
  signed int i = 0;
  signed int return_value_strcmp_1;
  for( ; !(transports[(signed long int)i] == ((struct transport_t *)NULL)); i = i + 1)
  {
    return_value_strcmp_1=strcmp(name, transports[(signed long int)i]->name);
    if(return_value_strcmp_1 == 0)
      break;

  }
  return transports[(signed long int)i];
}

// getstatus
// file remote.c line 106
static enum anonymous_11 getstatus()
{
  return status;
}

// handle_seek_opt
// file ogg123.c line 205
signed int handle_seek_opt(struct ogg123_options_t *options, struct decoder_t *decoder, struct format_t *format)
{
  float pos;
  struct decoder_stats_t *return_value;
  return_value=decoder->format->statistics(decoder);
  pos = (float)return_value->current_time;
  if(!(options->seekmode == 0))
  {
    if(options->seekmode == 1)
      pos = (float)options->seekoff;

    else
      pos = pos + (float)options->seekoff;
    if(pos < 0.000000f)
      pos = (float)0;

    struct decoder_stats_t *return_value_2;
    return_value_2=decoder->format->statistics(decoder);
    if((double)pos > return_value_2->total_time)
    {
      struct decoder_stats_t *return_value_1;
      return_value_1=decoder->format->statistics(decoder);
      pos = (float)(return_value_1->total_time - 0.01);
    }

    signed int return_value_3;
    return_value_3=format->seek(decoder, (double)pos, 1);
    if(return_value_3 == 0)
    {
      char *return_value_gettext_1;
      return_value_gettext_1=gettext("Could not skip to %f in audio stream.");
      status_error(return_value_gettext_1, options->seekoff);
    }

  }

  options->seekmode = 0;
  return 1;
}

// http_can_transport
// file http_transport.c line 170
signed int http_can_transport(char *source_string)
{
  signed int tmp;
  char *return_value_strchr_1;
  return_value_strchr_1=strchr(source_string, 58);
  tmp = (signed int)(return_value_strchr_1 - source_string);
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(!(tmp >= 10))
  {
    return_value_strlen_2=strlen(source_string);
    tmp_if_expr_3 = (unsigned long int)(tmp + 2) < return_value_strlen_2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_5;
  signed int return_value_strncmp_4;
  if(tmp_if_expr_3)
  {
    return_value_strncmp_4=strncmp(source_string + (signed long int)tmp, "://", (unsigned long int)3);
    tmp_if_expr_5 = !(return_value_strncmp_4 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  return (signed int)tmp_if_expr_5;
}

// http_close
// file http_transport.c line 324
void http_close(struct data_source_t *source)
{
  struct http_private_t *private = (struct http_private_t *)source->private;
  private->cancel_flag = 1;
  buffer_abort_write(private->buf);
  pthread_join(private->curl_thread, (void **)(void *)0);
  buffer_destroy(private->buf);
  private->buf = (struct buf_t *)(void *)0;
  free((void *)source->source_string);
  free(source->private);
  free((void *)source);
}

// http_open
// file http_transport.c line 181
struct data_source_t * http_open(char *source_string, struct ogg123_options_t *ogg123_opts)
{
  struct data_source_t *source;
  struct http_private_t *private;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct data_source_t) /*24ul*/ );
  source = (struct data_source_t *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct http_private_t) /*368ul*/ );
  private = (struct http_private_t *)return_value_malloc_2;
  if(!(source == ((struct data_source_t *)NULL)) && !(private == ((struct http_private_t *)NULL)))
  {
    source->source_string=strdup(source_string);
    source->transport = &http_transport;
    source->private = (void *)private;
    private->buf=buffer_create(ogg123_opts->input_buffer_size, (signed long int)((double)((float)ogg123_opts->input_buffer_size * ogg123_opts->input_prebuffer) / 100.0), (signed int (*)(void *, signed int, signed int, void *))(void *)0, (void *)0, 0);
    if(private->buf == ((struct buf_t *)NULL))
    {
      char *return_value_gettext_3;
      return_value_gettext_3=gettext("ERROR: Unable to create input buffer.\n");
      status_error(return_value_gettext_3);
      exit(1);
    }

    private->curl_handle = (void *)0;
    private->header_list = (struct curl_slist *)(void *)0;
    private->data_source = source;
    private->stats.transfer_rate = (signed long int)0;
    private->stats.bytes_read = (signed long int)0;
    private->stats.input_buffer_used = 0;
    private->cancel_flag = 0;
  }

  else
  {
    char *return_value_gettext_4;
    return_value_gettext_4=gettext("ERROR: Out of memory.\n");
    fprintf(stderr, return_value_gettext_4);
    exit(1);
  }
  private->header_list=curl_slist_append((struct curl_slist *)(void *)0, "Accept: application/ogg, audio/ogg, video/ogg, audio/x-flac;q=0.9");
  signed int return_value_pthread_create_5;
  if(!(private->header_list == ((struct curl_slist *)NULL)))
  {
    private->curl_handle=curl_easy_init();
    if(private->curl_handle == NULL)
      goto fail;

    set_curl_opts(private);
    return_value_pthread_create_5=pthread_create(&private->curl_thread, (const union pthread_attr_t *)(void *)0, curl_thread_func, (void *)private);
    if(!(return_value_pthread_create_5 == 0))
      goto fail;

    (stat_format + (signed long int)2)->enabled = (char)0;
    (stat_format + (signed long int)3)->enabled = (char)0;
    (stat_format + (signed long int)6)->enabled = (char)1;
    (stat_format + (signed long int)7)->enabled = (char)1;
    return source;
  }

  else
  {

  fail:
    ;
    if(!(private->curl_handle == NULL))
      curl_easy_cleanup(private->curl_handle);

    if(!(private->header_list == ((struct curl_slist *)NULL)))
      curl_slist_free_all(private->header_list);

    free((void *)source->source_string);
    free((void *)private);
    free((void *)source);
    return (struct data_source_t *)(void *)0;
  }
}

// http_peek
// file http_transport.c line 262
signed int http_peek(struct data_source_t *source, void *ptr, unsigned long int size, unsigned long int nmemb)
{
  return 0;
}

// http_read
// file http_transport.c line 278
signed int http_read(struct data_source_t *source, void *ptr, unsigned long int size, unsigned long int nmemb)
{
  struct http_private_t *private = (struct http_private_t *)source->private;
  signed int bytes_read;
  if(!(private->cancel_flag == 0) || !(sig_request.cancel == 0))
    return 0;

  else
  {
    unsigned long int return_value_buffer_get_data_1;
    return_value_buffer_get_data_1=buffer_get_data(private->buf, (char *)ptr, (signed long int)(size * nmemb));
    bytes_read = (signed int)return_value_buffer_get_data_1;
    private->stats.bytes_read = private->stats.bytes_read + (signed long int)bytes_read;
    return bytes_read;
  }
}

// http_seek
// file http_transport.c line 294
signed int http_seek(struct data_source_t *source, signed long int offset, signed int whence)
{
  return -1;
}

// http_statistics
// file http_transport.c line 300
struct data_source_stats_t * http_statistics(struct data_source_t *source)
{
  struct http_private_t *private = (struct http_private_t *)source->private;
  struct data_source_stats_t *data_source_stats;
  struct buffer_stats_t *buffer_stats;
  data_source_stats=malloc_data_source_stats(&private->stats);
  data_source_stats->input_buffer_used = 1;
  data_source_stats->transfer_rate = (signed long int)0;
  buffer_stats=buffer_statistics(private->buf);
  data_source_stats->input_buffer = *buffer_stats;
  free((void *)buffer_stats);
  return data_source_stats;
}

// http_tell
// file http_transport.c line 318
signed long int http_tell(struct data_source_t *source)
{
  return (signed long int)0;
}

// iconvert
// file iconvert.c line 51
signed int iconvert(const char *fromcode, const char *tocode, const char *from, unsigned long int fromlen, char **to, unsigned long int *tolen)
{
  signed int ret = 0;
  void *cd1;
  void *cd2;
  char *ib;
  char *ob;
  char *utfbuf = ((char *)NULL);
  char *outbuf;
  char *newbuf;
  unsigned long int utflen;
  unsigned long int outlen;
  unsigned long int ibl;
  unsigned long int obl;
  unsigned long int k;
  char tbuf[2048l];
  cd1=iconv_open("UTF-8", fromcode);
  _Bool tmp_if_expr_5;
  char *return_value_strchr_4;
  _Bool tmp_if_expr_7;
  char *return_value_strchr_6;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_13;
  signed int *return_value___errno_location_12;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_18;
  signed int *return_value___errno_location_15;
  _Bool tmp_if_expr_17;
  signed int *return_value___errno_location_16;
  char *tmp_post_21;
  void *return_value_realloc_23;
  _Bool tmp_if_expr_26;
  _Bool tmp_if_expr_25;
  signed int *return_value___errno_location_24;
  _Bool tmp_if_expr_29;
  _Bool tmp_if_expr_28;
  signed int *return_value___errno_location_27;
  _Bool tmp_if_expr_35;
  signed int *return_value___errno_location_34;
  _Bool tmp_if_expr_32;
  _Bool tmp_if_expr_31;
  signed int *return_value___errno_location_30;
  _Bool tmp_if_expr_33;
  void *return_value_malloc_36;
  _Bool tmp_if_expr_39;
  _Bool tmp_if_expr_38;
  signed int *return_value___errno_location_37;
  _Bool tmp_if_expr_45;
  signed int *return_value___errno_location_44;
  _Bool tmp_if_expr_42;
  _Bool tmp_if_expr_41;
  signed int *return_value___errno_location_40;
  _Bool tmp_if_expr_43;
  if(cd1 == (void *)-1)
    return -1;

  else
  {
    cd2 = (void *)-1;
    char *return_value_strchr_3;
    return_value_strchr_3=strchr("Uu", (signed int)tocode[(signed long int)0]);
    if(return_value_strchr_3 == ((char *)NULL))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strchr_4=strchr("Tt", (signed int)tocode[(signed long int)1]);
      tmp_if_expr_5 = !(return_value_strchr_4 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_strchr_6=strchr("Ff", (signed int)tocode[(signed long int)2]);
      tmp_if_expr_7 = !(return_value_strchr_6 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = (signed int)tocode[(signed long int)3] != 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
      tmp_if_expr_9 = (_Bool)1;

    else
      tmp_if_expr_9 = (signed int)tocode[(signed long int)4] != 56 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_9)
      tmp_if_expr_10 = (_Bool)1;

    else
      tmp_if_expr_10 = (signed int)tocode[(signed long int)5] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_10)
    {
      char *tocode1;
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(tocode);
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)11);
      tocode1 = (char *)return_value_malloc_2;
      if(tocode1 == ((char *)NULL))
        goto fail;

      strcpy(tocode1, tocode);
      strcat(tocode1, "//TRANSLIT");
      cd2=iconv_open(tocode1, "UTF-8");
      free((void *)tocode1);
      if(cd2 == (void *)-1)
        cd2=iconv_open(tocode, fromcode);

      if(cd2 == (void *)-1)
      {
        iconv_close(cd1);
        return -1;
      }

    }

    utflen = (unsigned long int)1;
    void *return_value_malloc_11;
    return_value_malloc_11=malloc(utflen);
    utfbuf = (char *)return_value_malloc_11;
    if(!(utfbuf == ((char *)NULL)))
    {
      ib = (char *)from;
      ibl = fromlen;
      ob = utfbuf;
      obl = utflen;
      do
      {
        k=iconv(cd1, &ib, &ibl, &ob, &obl);
        if(ibl == 0ul && !(k == 18446744073709551615ul))
          tmp_if_expr_14 = (_Bool)1;

        else
        {
          if(k == 18446744073709551615ul)
          {
            return_value___errno_location_12=__errno_location();
            tmp_if_expr_13 = *return_value___errno_location_12 == 7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_13 = (_Bool)0;
          tmp_if_expr_14 = ((tmp_if_expr_13 ? (ibl != 0ul ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (obl < (unsigned long int)6 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_14)
          tmp_if_expr_19 = (_Bool)1;

        else
        {
          if(k == 18446744073709551615ul)
          {
            return_value___errno_location_15=__errno_location();
            if(*return_value___errno_location_15 == 84)
              tmp_if_expr_17 = (_Bool)1;

            else
            {
              return_value___errno_location_16=__errno_location();
              tmp_if_expr_17 = *return_value___errno_location_16 == 22 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_18 = (_Bool)0;
          tmp_if_expr_19 = (tmp_if_expr_18 ? (ibl != 0ul ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        }
        /* assertion (k != (size_t)(-1) && !ibl) || (k == (size_t)(-1) && (*__errno_location ()) == 7 && ibl && obl < 6) || (k == (size_t)(-1) && ((*__errno_location ()) == 84 || (*__errno_location ()) == 22) && ibl) */
        assert(tmp_if_expr_19);
        if(ibl == 0ul)
          break;

        if(!(obl >= 6ul))
        {
          utflen = utflen * (unsigned long int)2;
          void *return_value_realloc_20;
          return_value_realloc_20=realloc((void *)utfbuf, utflen);
          newbuf = (char *)return_value_realloc_20;
          if(newbuf == ((char *)NULL))
            goto fail;

          ob = (ob - utfbuf) + newbuf;
          obl = utflen - (unsigned long int)(ob - newbuf);
          utfbuf = newbuf;
        }

        else
        {
          ib = ib + 1l;
          ibl = ibl - 1ul;
          tmp_post_21 = ob;
          ob = ob + 1l;
          *tmp_post_21 = (char)35;
          obl = obl - 1ul;
          ret = 2;
        }
      }
      while((_Bool)1);
      if(cd2 == (void *)-1)
      {
        if(!(tolen == ((unsigned long int *)NULL)))
          *tolen = (unsigned long int)(ob - utfbuf);

        if(to == ((char **)NULL))
        {
          free((void *)utfbuf);
          iconv_close(cd1);
          return ret;
        }

        void *return_value_realloc_22;
        return_value_realloc_22=realloc((void *)utfbuf, (unsigned long int)((ob - utfbuf) + (signed long int)1));
        newbuf = (char *)return_value_realloc_22;
        if(newbuf == ((char *)NULL))
          goto fail;

        ob = (ob - utfbuf) + newbuf;
        *ob = (char)0;
        *to = newbuf;
        iconv_close(cd1);
        return ret;
      }

      utflen = (unsigned long int)(ob - utfbuf);
      return_value_realloc_23=realloc((void *)utfbuf, utflen);
      newbuf = (char *)return_value_realloc_23;
      if(newbuf == ((char *)NULL))
        goto fail;

      utfbuf = newbuf;
      outlen = (unsigned long int)0;
      ib = utfbuf;
      ibl = utflen;
      while(!(ibl == 0ul))
      {
        ob = tbuf;
        obl = sizeof(char [2048l]) /*2048ul*/ ;
        k=iconv(cd2, &ib, &ibl, &ob, &obl);
        if(ibl == 0ul && !(k == 18446744073709551615ul))
          tmp_if_expr_26 = (_Bool)1;

        else
        {
          if(k == 18446744073709551615ul)
          {
            return_value___errno_location_24=__errno_location();
            tmp_if_expr_25 = *return_value___errno_location_24 == 7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_25 = (_Bool)0;
          tmp_if_expr_26 = (tmp_if_expr_25 ? (ibl != 0ul ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_26)
          tmp_if_expr_29 = (_Bool)1;

        else
        {
          if(k == 18446744073709551615ul)
          {
            return_value___errno_location_27=__errno_location();
            tmp_if_expr_28 = *return_value___errno_location_27 == 84 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_28 = (_Bool)0;
          tmp_if_expr_29 = (tmp_if_expr_28 ? (ibl != 0ul ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        }
        /* assertion (k != (size_t)(-1) && !ibl) || (k == (size_t)(-1) && (*__errno_location ()) == 7 && ibl) || (k == (size_t)(-1) && (*__errno_location ()) == 84 && ibl) */
        assert(tmp_if_expr_29);
        if(!(ibl == 0ul))
        {
          if(k == 18446744073709551615ul)
          {
            return_value___errno_location_34=__errno_location();
            tmp_if_expr_35 = *return_value___errno_location_34 == 7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_35 = (_Bool)0;
          if(!tmp_if_expr_35)
          {
            char *tb = "?";
            unsigned long int tbl = (unsigned long int)1;
            outlen = outlen + (unsigned long int)(ob - tbuf);
            ob = tbuf;
            obl = sizeof(char [2048l]) /*2048ul*/ ;
            k=iconv(cd2, &tb, &tbl, &ob, &obl);
            if(tbl == 0ul && !(k == 18446744073709551615ul))
              tmp_if_expr_32 = (_Bool)1;

            else
            {
              if(k == 18446744073709551615ul)
              {
                return_value___errno_location_30=__errno_location();
                tmp_if_expr_31 = *return_value___errno_location_30 == 84 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_31 = (_Bool)0;
              tmp_if_expr_32 = (tmp_if_expr_31 ? (tbl != 0ul ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
            }
            /* assertion (k != (size_t)(-1) && !tbl) || (k == (size_t)(-1) && (*__errno_location ()) == 84 && tbl) */
            assert(tmp_if_expr_32);
            ib = ib + 1l;
            ibl = ibl - 1ul;
            do
            {
              if(!(ibl == 0ul))
                tmp_if_expr_33 = ((signed int)*ib & 0x80) != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_33 = (_Bool)0;
              if(!tmp_if_expr_33)
                break;

              ib = ib + 1l;
              ibl = ibl - 1ul;
            }
            while((_Bool)1);
          }

        }

        outlen = outlen + (unsigned long int)(ob - tbuf);
      }
      ob = tbuf;
      obl = sizeof(char [2048l]) /*2048ul*/ ;
      k=iconv(cd2, ((char ** restrict )NULL), ((unsigned long int *)NULL), &ob, &obl);
      /* assertion k != (size_t)(-1) */
      assert(k != (unsigned long int)-1);
      outlen = outlen + (unsigned long int)(ob - tbuf);
      return_value_malloc_36=malloc(outlen + (unsigned long int)1);
      outbuf = (char *)return_value_malloc_36;
      if(outbuf == ((char *)NULL))
        goto fail;

      ib = utfbuf;
      ibl = utflen;
      ob = outbuf;
      obl = outlen;
      while(!(ibl == 0ul))
      {
        k=iconv(cd2, &ib, &ibl, &ob, &obl);
        if(ibl == 0ul && !(k == 18446744073709551615ul))
          tmp_if_expr_39 = (_Bool)1;

        else
        {
          if(k == 18446744073709551615ul)
          {
            return_value___errno_location_37=__errno_location();
            tmp_if_expr_38 = *return_value___errno_location_37 == 84 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_38 = (_Bool)0;
          tmp_if_expr_39 = (tmp_if_expr_38 ? (ibl != 0ul ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        }
        /* assertion (k != (size_t)(-1) && !ibl) || (k == (size_t)(-1) && (*__errno_location ()) == 84 && ibl) */
        assert(tmp_if_expr_39);
        if(ret == 0 && !(k == 0ul))
          ret = 1;

        if(!(ibl == 0ul))
        {
          if(k == 18446744073709551615ul)
          {
            return_value___errno_location_44=__errno_location();
            tmp_if_expr_45 = *return_value___errno_location_44 == 7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_45 = (_Bool)0;
          if(!tmp_if_expr_45)
          {
            char *iconvert__1__5__1__tb = "?";
            unsigned long int iconvert__1__5__1__tbl = (unsigned long int)1;
            k=iconv(cd2, &iconvert__1__5__1__tb, &iconvert__1__5__1__tbl, &ob, &obl);
            if(iconvert__1__5__1__tbl == 0ul && !(k == 18446744073709551615ul))
              tmp_if_expr_42 = (_Bool)1;

            else
            {
              if(k == 18446744073709551615ul)
              {
                return_value___errno_location_40=__errno_location();
                tmp_if_expr_41 = *return_value___errno_location_40 == 84 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_41 = (_Bool)0;
              tmp_if_expr_42 = (tmp_if_expr_41 ? (iconvert__1__5__1__tbl != 0ul ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
            }
            /* assertion (k != (size_t)(-1) && !tbl) || (k == (size_t)(-1) && (*__errno_location ()) == 84 && tbl) */
            assert(tmp_if_expr_42);
            ib = ib + 1l;
            ibl = ibl - 1ul;
            do
            {
              if(!(ibl == 0ul))
                tmp_if_expr_43 = ((signed int)*ib & 0x80) != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_43 = (_Bool)0;
              if(!tmp_if_expr_43)
                break;

              ib = ib + 1l;
              ibl = ibl - 1ul;
            }
            while((_Bool)1);
          }

        }

      }
      k=iconv(cd2, ((char ** restrict )NULL), ((unsigned long int *)NULL), &ob, &obl);
      /* assertion k != (size_t)(-1) */
      assert(k != (unsigned long int)-1);
      /* assertion !obl */
      assert(!(obl != 0ul));
      *ob = (char)0;
      free((void *)utfbuf);
      iconv_close(cd1);
      iconv_close(cd2);
      if(!(tolen == ((unsigned long int *)NULL)))
        *tolen = outlen;

      if(to == ((char **)NULL))
      {
        free((void *)outbuf);
        return ret;
      }

      *to = outbuf;
      return ret;
    }

    else
    {

    fail:
      ;
      free((void *)utfbuf);
      iconv_close(cd1);
      if(!(cd2 == (void *)-1))
        iconv_close(cd2);

      return -2;
    }
  }
}

// in_order_add_action
// file buffer.c line 135
void in_order_add_action(struct action_t **action_list, struct action_t *action, signed int insert)
{
  insert = insert > 0 ? 1 : 0;
  for( ; !(*action_list == ((struct action_t *)NULL)); action_list = &(*action_list)->next)
    if(!(action->position + (signed long int)insert >= (*action_list)->position))
      break;

  action->next = *action_list;
  *action_list = action;
}

// invertpause
// file remote.c line 116
static void invertpause()
{
  if((signed int)status == PLAY)
    status = (enum anonymous_11)PAUSE;

  else
    if((signed int)status == PAUSE)
      status = (enum anonymous_11)PLAY;

}

// lookup_comment_prettyprint
// file vorbis_comments.c line 50
char * lookup_comment_prettyprint(char *comment, signed int *offset)
{
  signed int i;
  signed int j;
  char *s;
  i = 0;
  for( ; !(vorbis_comment_keys[(signed long int)i].key == ((char *)NULL)); i = i + 1)
  {
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(vorbis_comment_keys[(signed long int)i].key);
    signed int return_value_strncasecmp_6;
    return_value_strncasecmp_6=strncasecmp(vorbis_comment_keys[(signed long int)i].key, comment, return_value_strlen_5);
    if(return_value_strncasecmp_6 == 0)
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(vorbis_comment_keys[(signed long int)i].key);
      *offset = (signed int)return_value_strlen_1;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(vorbis_comment_keys[(signed long int)i].formatstr);
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(return_value_strlen_2 + (unsigned long int)1);
      s = (char *)return_value_malloc_3;
      if(s == ((char *)NULL))
      {
        char *return_value_gettext_4;
        return_value_gettext_4=gettext("ERROR: Out of memory.\n");
        fprintf(stderr, return_value_gettext_4);
        exit(1);
      }

      strcpy(s, vorbis_comment_keys[(signed long int)i].formatstr);
      return s;
    }

  }
  unsigned long int return_value_strcspn_7;
  return_value_strcspn_7=strcspn(comment, "=");
  j = (signed int)return_value_strcspn_7;
  if(!(j == 0))
  {
    *offset = j + 1;
    void *return_value_malloc_8;
    return_value_malloc_8=malloc((unsigned long int)(j + 2));
    s = (char *)return_value_malloc_8;
    if(s == ((char *)NULL))
    {
      char *return_value_gettext_9;
      return_value_gettext_9=gettext("ERROR: Out of memory.\n");
      fprintf(stderr, return_value_gettext_9);
      exit(1);
    }

    strncpy(s, comment, (unsigned long int)j);
    strcpy(s + (signed long int)j, ":");
    signed int return_value_toupper_10;
    return_value_toupper_10=toupper((signed int)s[(signed long int)0]);
    s[(signed long int)0] = (char)return_value_toupper_10;
    i = 1;
    for( ; !(i >= j); i = i + 1)
    {
      signed int return_value_tolower_11;
      return_value_tolower_11=tolower((signed int)s[(signed long int)i]);
      s[(signed long int)i] = (char)return_value_tolower_11;
    }
    return s;
  }

  *offset = 0;
  unsigned long int return_value_strlen_12;
  return_value_strlen_12=strlen(vorbis_comment_keys[(signed long int)i].formatstr);
  void *return_value_malloc_13;
  return_value_malloc_13=malloc(return_value_strlen_12 + (unsigned long int)1);
  s = (char *)return_value_malloc_13;
  if(s == ((char *)NULL))
  {
    char *return_value_gettext_14;
    return_value_gettext_14=gettext("ERROR: Out of memory.\n");
    fprintf(stderr, return_value_gettext_14);
    exit(1);
  }

  strcpy(s, vorbis_comment_keys[(signed long int)i].formatstr);
  return s;
}

// main
// file ogg123.c line 391
signed int main(signed int argc, char **argv)
{
  signed int main__1__optind;
  char **playlist_array;
  signed int items;
  struct stat stat_buf;
  signed int i;
  setlocale(6, "");
  bindtextdomain("vorbis-tools", "/usr/share/locale");
  textdomain("vorbis-tools");
  ao_initialize();
  stat_format=stat_format_create();
  options_init(&options);
  file_options_init(file_opts);
  parse_std_configs(file_opts);
  options.playlist=playlist_create();
  main__1__optind=parse_cmdline_options(argc, argv, &options, file_opts);
  audio_play_arg.devices = options.devices;
  audio_play_arg.stat_format = stat_format;
  i = main__1__optind;
  char *return_value_gettext_1;
  for( ; !(i >= argc); i = i + 1)
  {
    signed int return_value_stat_3;
    return_value_stat_3=stat(argv[(signed long int)i], &stat_buf);
    if(return_value_stat_3 == 0)
    {
      if((61440u & stat_buf.st_mode) == 16384u)
      {
        signed int return_value_playlist_append_directory_2;
        return_value_playlist_append_directory_2=playlist_append_directory(options.playlist, argv[(signed long int)i]);
        if(return_value_playlist_append_directory_2 == 0)
        {
          return_value_gettext_1=gettext("WARNING: Could not read directory %s.\n");
          fprintf(stderr, return_value_gettext_1, argv[(signed long int)i]);
        }

      }

      else
        playlist_append_file(options.playlist, argv[(signed long int)i]);
    }

    else
      playlist_append_file(options.playlist, argv[(signed long int)i]);
  }
  signed int return_value_playlist_length_4;
  return_value_playlist_length_4=playlist_length(options.playlist);
  if(return_value_playlist_length_4 == 0)
  {
    cmdline_usage();
    exit(1);
  }

  else
  {
    playlist_array=playlist_to_array(options.playlist, &items);
    playlist_destroy(options.playlist);
    options.playlist = (struct playlist_t *)(void *)0;
  }
  status_init(options.verbosity);
  print_audio_devices_info(options.devices);
  if(options.buffer_size >= 1l)
  {
    options.buffer_size = (((options.buffer_size + (signed long int)(2 * 2 * 2 * 2 * 3 * 3 * 3 * 5 * 7)) - (signed long int)1) / (signed long int)(2 * 2 * 2 * 2 * 3 * 3 * 3 * 5 * 7)) * (signed long int)(2 * 2 * 2 * 2 * 3 * 3 * 3 * 5 * 7);
    audio_buffer=buffer_create(options.buffer_size, (signed long int)(((float)options.buffer_size * options.prebuffer) / (float)100), audio_play_callback, (void *)&audio_play_arg, (((16384 + 2 * 2 * 2 * 2 * 3 * 3 * 3 * 5 * 7) - 1) / (2 * 2 * 2 * 2 * 3 * 3 * 3 * 5 * 7)) * 2 * 2 * 2 * 2 * 3 * 3 * 3 * 5 * 7);
    if(audio_buffer == ((struct buf_t *)NULL))
    {
      char *return_value_gettext_5;
      return_value_gettext_5=gettext("Error: Could not create audio buffer.\n");
      status_error(return_value_gettext_5);
      exit(1);
    }

  }

  else
    audio_buffer = (struct buf_t *)(void *)0;
  signal(2, signal_handler);
  signal(20, signal_handler);
  signal(18, signal_handler);
  signal(15, signal_handler);
  if(!(options.remote == 0))
    remote_mainloop();

  else
    while((_Bool)1)
    {
      if(!(options.shuffle == 0))
      {
        signed int main__1__6__1__1__i;
        signed long int return_value_time_6;
        return_value_time_6=time((signed long int *)(void *)0);
        srandom((unsigned int)return_value_time_6);
        main__1__6__1__1__i = 0;
        for( ; !(main__1__6__1__1__i >= items); main__1__6__1__1__i = main__1__6__1__1__i + 1)
        {
          signed int j;
          signed long int return_value_random_7;
          return_value_random_7=random();
          j = (signed int)((signed long int)main__1__6__1__1__i + return_value_random_7 % (signed long int)(items - main__1__6__1__1__i));
          char *temp = playlist_array[(signed long int)main__1__6__1__1__i];
          playlist_array[(signed long int)main__1__6__1__1__i] = playlist_array[(signed long int)j];
          playlist_array[(signed long int)j] = temp;
        }
      }

      i = 0;
      for( ; sig_request.exit == 0 && !(i >= items); i = i + 1)
        play(playlist_array[(signed long int)i]);
      if(options.repeat == 0)
        break;

    }
  playlist_array_destroy(playlist_array, items);
  status_deinit();
  if(!(audio_buffer == ((struct buf_t *)NULL)))
  {
    buffer_destroy(audio_buffer);
    audio_buffer = (struct buf_t *)(void *)0;
  }

  ao_onexit((void *)options.devices);
  exit(exit_status);
}

// malloc_action
// file buffer.c line 110
struct action_t * malloc_action(void (*action_func)(struct buf_t *, void *), void *action_arg)
{
  struct action_t *action;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct action_t) /*32ul*/ );
  action = (struct action_t *)return_value_malloc_1;
  if(action == ((struct action_t *)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("ERROR: Out of memory in malloc_action().\n");
    fprintf(stderr, return_value_gettext_2);
    exit(1);
  }

  action->position = (signed long int)0;
  action->action_func = action_func;
  action->arg = action_arg;
  action->next = (struct action_t *)(void *)0;
  return action;
}

// malloc_buffer_stats
// file buffer.c line 377
struct buffer_stats_t * malloc_buffer_stats()
{
  struct buffer_stats_t *new_stats;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct buffer_stats_t) /*40ul*/ );
  new_stats = (struct buffer_stats_t *)return_value_malloc_1;
  if(new_stats == ((struct buffer_stats_t *)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("ERROR: Could not allocate memory in malloc_buffer_stats()\n");
    fprintf(stderr, return_value_gettext_2);
    exit(1);
  }

  return new_stats;
}

// malloc_data_source_stats
// file transport.h line 60
struct data_source_stats_t * malloc_data_source_stats(struct data_source_stats_t *to_copy)
{
  struct data_source_stats_t *new_stats;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct data_source_stats_t) /*64ul*/ );
  new_stats = (struct data_source_stats_t *)return_value_malloc_1;
  if(new_stats == ((struct data_source_stats_t *)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("ERROR: Could not allocate memory in malloc_data_source_stats()\n");
    fprintf(stderr, return_value_gettext_2);
    exit(1);
  }

  *new_stats = *to_copy;
  return new_stats;
}

// malloc_decoder_stats
// file format.c line 75
struct decoder_stats_t * malloc_decoder_stats(struct decoder_stats_t *to_copy)
{
  struct decoder_stats_t *new_stats;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct decoder_stats_t) /*32ul*/ );
  new_stats = (struct decoder_stats_t *)return_value_malloc_1;
  if(new_stats == ((struct decoder_stats_t *)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("ERROR: Could not allocate memory in malloc_decoder_stats()\n");
    fprintf(stderr, return_value_gettext_2);
    exit(1);
  }

  *new_stats = *to_copy;
  return new_stats;
}

// metadata_callback
// file flac_format.c line 510
static void metadata_callback(const struct anonymous_19 *decoder, const struct anonymous_20 *metadata, void *client_data)
{
  struct decoder_t *e_decoder = (struct decoder_t *)client_data;
  struct anonymous_21 *priv = (struct anonymous_21 *)e_decoder->private;
  switch((signed int)metadata->type)
  {
    case FLAC__METADATA_TYPE_STREAMINFO:
    {
      priv->totalsamples = (signed long int)metadata->data.stream_info.total_samples;
      priv->rate = (signed int)metadata->data.stream_info.sample_rate;
      break;
    }
    case FLAC__METADATA_TYPE_VORBIS_COMMENT:
      priv->comments=FLAC__metadata_object_clone(metadata);
  }
}

// new_audio_reopen_arg
// file callbacks.c line 122
struct audio_reopen_arg_t * new_audio_reopen_arg(struct audio_device_t *devices, struct audio_format_t *fmt)
{
  struct audio_reopen_arg_t *arg;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct audio_reopen_arg_t) /*16ul*/ );
  arg = (struct audio_reopen_arg_t *)return_value_calloc_2;
  if(arg == ((struct audio_reopen_arg_t *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("ERROR: Out of memory in new_audio_reopen_arg().\n");
    status_error(return_value_gettext_1);
    exit(1);
  }

  void *return_value_calloc_4;
  return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct audio_format_t) /*32ul*/ );
  arg->format = (struct audio_format_t *)return_value_calloc_4;
  if(arg->format == ((struct audio_format_t *)NULL))
  {
    char *return_value_gettext_3;
    return_value_gettext_3=gettext("ERROR: Out of memory in new_audio_reopen_arg().\n");
    status_error(return_value_gettext_3);
    exit(1);
  }

  arg->devices = devices;
  *arg->format = *fmt;
  if(!(fmt->matrix == ((char *)NULL)))
    arg->format->matrix=strdup(fmt->matrix);

  return arg;
}

// new_print_statistics_arg
// file callbacks.c line 171
struct print_statistics_arg_t * new_print_statistics_arg(struct anonymous_3 *stat_format, struct data_source_stats_t *data_source_statistics, struct decoder_stats_t *decoder_statistics)
{
  struct print_statistics_arg_t *arg;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct print_statistics_arg_t) /*24ul*/ );
  arg = (struct print_statistics_arg_t *)return_value_calloc_2;
  if(arg == ((struct print_statistics_arg_t *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("Error: Out of memory in new_print_statistics_arg().\n");
    status_error(return_value_gettext_1);
    exit(1);
  }

  arg->stat_format = stat_format;
  arg->data_source_statistics = data_source_statistics;
  arg->decoder_statistics = decoder_statistics;
  return arg;
}

// new_status_message_arg
// file callbacks.c line 233
struct status_message_arg_t * new_status_message_arg(signed int verbosity)
{
  struct status_message_arg_t *arg;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct status_message_arg_t) /*16ul*/ );
  arg = (struct status_message_arg_t *)return_value_calloc_2;
  if(arg == ((struct status_message_arg_t *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("ERROR: Out of memory in new_status_message_arg().\n");
    status_error(return_value_gettext_1);
    exit(1);
  }

  arg->verbosity = verbosity;
  return arg;
}

// oggflac_can_decode
// file flac_format.c line 117
signed int oggflac_can_decode(struct data_source_t *source)
{
  char buf[36l];
  signed int len;
  len=source->transport->peek(source, (void *)buf, sizeof(char) /*1ul*/ , (unsigned long int)36);
  signed int return_value_memcmp_2;
  signed int return_value_memcmp_1;
  signed int return_value_memcmp_4;
  signed int return_value_memcmp_3;
  if(len >= 36)
  {
    return_value_memcmp_2=memcmp((const void *)buf, (const void *)"OggS", (unsigned long int)4);
    return_value_memcmp_1=memcmp((const void *)(buf + (signed long int)28), (const void *)"fLaC", (unsigned long int)4);
    return 1;
  }

  else
    if(len >= 36)
    {
      return_value_memcmp_4=memcmp((const void *)buf, (const void *)"OggS", (unsigned long int)4);
      return_value_memcmp_3=memcmp((const void *)(buf + (signed long int)29), (const void *)"FLAC", (unsigned long int)4);
      return 1;
    }

    else
      return 0;
}

// options_init
// file ogg123.c line 147
void options_init(struct ogg123_options_t *opts)
{
  opts->verbosity = 2;
  opts->shuffle = 0;
  opts->delay = (signed long int)500;
  opts->nth = 1;
  opts->ntimes = 1;
  opts->seekoff = 0.0;
  opts->endpos = -1.0;
  opts->seekmode = 0;
  opts->buffer_size = (signed long int)(128 * 1024);
  opts->prebuffer = 0.0f;
  opts->input_buffer_size = (signed long int)(64 * 1024);
  opts->input_prebuffer = 50.0f;
  opts->default_device = (char *)(void *)0;
  opts->status_freq = 10.0;
  opts->playlist = (struct playlist_t *)(void *)0;
  opts->remote = 0;
  opts->repeat = 0;
}

// ovf_can_decode
// file oggvorbis_format.c line 66
signed int ovf_can_decode(struct data_source_t *source)
{
  return 1;
}

// ovf_cleanup
// file oggvorbis_format.c line 289
void ovf_cleanup(struct decoder_t *decoder)
{
  struct ovf_private_t *priv = (struct ovf_private_t *)decoder->private;
  ov_clear(&priv->vf);
  free(decoder->private);
  free((void *)decoder);
}

// ovf_init
// file oggvorbis_format.c line 72
struct decoder_t * ovf_init(struct data_source_t *source, struct ogg123_options_t *ogg123_opts, struct audio_format_t *audio_fmt, struct decoder_callbacks_t *callbacks, void *callback_arg)
{
  struct decoder_t *decoder;
  struct ovf_private_t *private;
  signed int ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct decoder_t) /*104ul*/ );
  decoder = (struct decoder_t *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct ovf_private_t) /*1008ul*/ );
  private = (struct ovf_private_t *)return_value_malloc_2;
  if(!(decoder == ((struct decoder_t *)NULL)) && !(private == ((struct ovf_private_t *)NULL)))
  {
    decoder->source = source;
    decoder->request_fmt = *audio_fmt;
    decoder->actual_fmt = decoder->request_fmt;
    decoder->format = &oggvorbis_format;
    decoder->callbacks = callbacks;
    decoder->callback_arg = callback_arg;
    decoder->private = (void *)private;
    private->bos = 1;
    private->current_section = -1;
    private->stats.total_time = 0.0;
    private->stats.current_time = 0.0;
    private->stats.instant_bitrate = (signed long int)0;
    private->stats.avg_bitrate = (signed long int)0;
    private->vg.scale_factor = (float)1.0;
    private->vg.max_scale = (float)1.0;
  }

  else
  {
    char *return_value_gettext_3;
    return_value_gettext_3=gettext("ERROR: Out of memory.\n");
    fprintf(stderr, return_value_gettext_3);
    exit(1);
  }
  ret=ov_open_callbacks((void *)decoder, &private->vf, (const char *)(void *)0, (signed long int)0, vorbisfile_callbacks);
  if(!(ret >= 0))
  {
    free((void *)private);
    return (struct decoder_t *)(void *)0;
  }

  else
    return decoder;
}

// ovf_read
// file oggvorbis_format.c line 125
signed int ovf_read(struct decoder_t *decoder, void *ptr, signed int nbytes, signed int *eos, struct audio_format_t *audio_fmt)
{
  struct ovf_private_t *priv = (struct ovf_private_t *)decoder->private;
  struct decoder_callbacks_t *cb = decoder->callbacks;
  signed int bytes_read = 0;
  signed int ret;
  signed int old_section;
  if(!(priv->bos == 0))
  {
    priv->vc=ov_comment(&priv->vf, -1);
    priv->vi=ov_info(&priv->vf, -1);
    decoder->actual_fmt.rate = (signed int)priv->vi->rate;
    decoder->actual_fmt.channels = priv->vi->channels;
    switch(decoder->actual_fmt.channels)
    {
      case 1:
      {
        decoder->actual_fmt.matrix = "M";
        break;
      }
      case 2:
      {
        decoder->actual_fmt.matrix = "L,R";
        break;
      }
      case 3:
      {
        decoder->actual_fmt.matrix = "L,C,R";
        break;
      }
      case 4:
      {
        decoder->actual_fmt.matrix = "L,R,BL,BR";
        break;
      }
      case 5:
      {
        decoder->actual_fmt.matrix = "L,C,R,BL,BR";
        break;
      }
      case 6:
      {
        decoder->actual_fmt.matrix = "L,C,R,BL,BR,LFE";
        break;
      }
      case 7:
      {
        decoder->actual_fmt.matrix = "L,C,R,SL,SR,BC,LFE";
        break;
      }
      case 8:
      {
        decoder->actual_fmt.matrix = "L,C,R,SL,SR,BL,BR,LFE";
        break;
      }
      default:
        decoder->actual_fmt.matrix = (char *)(void *)0;
    }
    vg_init(&priv->vg, priv->vc);
    print_vorbis_stream_info(decoder);
    print_vorbis_comments(priv->vc, cb, decoder->callback_arg);
    priv->bos = 0;
  }

  *audio_fmt = decoder->actual_fmt;
  char *return_value_gettext_2;
  char *return_value_gettext_3;
  while(nbytes >= audio_fmt->channels * audio_fmt->word_size)
  {
    old_section = priv->current_section;
    signed long int return_value_ov_read_filter_1;
    return_value_ov_read_filter_1=ov_read_filter(&priv->vf, (char *)ptr, nbytes, audio_fmt->big_endian, audio_fmt->word_size, audio_fmt->signed_sample, &priv->current_section, vg_filter, (void *)&priv->vg);
    ret = (signed int)return_value_ov_read_filter_1;
    if(ret == 0)
    {
      *eos = 1;
      break;
    }

    else
      if(ret == -3)
      {
        if(!(cb->printf_error == ((void (*)(void *, signed int, char *, ...))NULL)))
        {
          return_value_gettext_2=gettext("--- Hole in the stream; probably harmless\n");
          cb->printf_error(decoder->callback_arg, 2, return_value_gettext_2);
        }

      }

      else
        if(!(ret >= 0))
        {
          if(!(cb->printf_error == ((void (*)(void *, signed int, char *, ...))NULL)))
          {
            return_value_gettext_3=gettext("=== Vorbis library reported a stream error.\n");
            cb->printf_error(decoder->callback_arg, 0, return_value_gettext_3);
          }

          *eos = 1;
          break;
        }

        else
        {
          bytes_read = bytes_read + ret;
          ptr = (void *)((unsigned char *)ptr + (signed long int)ret);
          nbytes = nbytes - ret;
          if(!(old_section == priv->current_section))
          {
            if(!(old_section == -1))
            {
              *eos = 1;
              priv->bos = 1;
              break;
            }

          }

        }
  }
  return bytes_read;
}

// ovf_seek
// file oggvorbis_format.c line 240
signed int ovf_seek(struct decoder_t *decoder, double offset, signed int whence)
{
  struct ovf_private_t *priv = (struct ovf_private_t *)decoder->private;
  signed int ret;
  double cur;
  if(whence == 2)
  {
    cur=ov_time_tell(&priv->vf);
    if(cur >= 0.0)
    {
      offset = offset + cur;
      goto __CPROVER_DUMP_L2;
    }

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    ret=ov_time_seek(&priv->vf, offset);
    if(ret == 0)
      return 1;

    else
      return 0;
  }
}

// ovf_statistics
// file oggvorbis_format.c line 262
struct decoder_stats_t * ovf_statistics(struct decoder_t *decoder)
{
  struct ovf_private_t *priv = (struct ovf_private_t *)decoder->private;
  signed long int instant_bitrate;
  signed long int avg_bitrate;
  signed long int return_value_ov_pcm_total_1;
  return_value_ov_pcm_total_1=ov_pcm_total(&priv->vf, -1);
  priv->stats.total_time = (double)return_value_ov_pcm_total_1 / (double)decoder->actual_fmt.rate;
  signed long int return_value_ov_pcm_tell_2;
  return_value_ov_pcm_tell_2=ov_pcm_tell(&priv->vf);
  priv->stats.current_time = (double)return_value_ov_pcm_tell_2 / (double)decoder->actual_fmt.rate;
  instant_bitrate=ov_bitrate_instant(&priv->vf);
  if(instant_bitrate >= 1l)
    priv->stats.instant_bitrate = instant_bitrate;

  avg_bitrate=ov_bitrate(&priv->vf, priv->current_section);
  priv->stats.avg_bitrate = avg_bitrate > (signed long int)0 ? avg_bitrate : (signed long int)0;
  struct decoder_stats_t *return_value_malloc_decoder_stats_3;
  return_value_malloc_decoder_stats_3=malloc_decoder_stats(&priv->stats);
  return return_value_malloc_decoder_stats_3;
}

// parse_cmdline_options
// file cmdline_options.c line 63
signed int parse_cmdline_options(signed int argc, char **argv, struct ogg123_options_t *ogg123_opts, struct file_option_t *file_opts)
{
  signed int option_index = 1;
  struct ao_option *temp_options = (struct ao_option *)(void *)0;
  struct ao_option **current_options = &temp_options;
  struct ao_info *info;
  signed int temp_driver_id = -1;
  struct audio_device_t *current;
  signed int ret;
  signed int return_value_strcmp_3;
  signed int return_value_atoi_4;
  char *return_value_gettext_6;
  const char *return_value_parse_error_string_7;
  signed int return_value_atoi_12;
  signed int return_value_add_ao_option_14;
  double return_value_atof_15;
  _Bool tmp_if_expr_17;
  char *return_value_gettext_18;
  signed int return_value_playlist_append_from_file_22;
  char *return_value_gettext_21;
  do
  {
    ret=getopt_long(argc, argv, "b:c::d:f:hl:k:K:o:p:qrRvVx:y:zZ@:", long_options, &option_index);
    if(ret == -1)
      break;

    switch(ret)
    {
      case 0:
      {
        return_value_strcmp_3=strcmp(long_options[(signed long int)option_index].name, "audio-buffer");
        if(return_value_strcmp_3 == 0)
        {
          signed int return_value_atoi_1;
          return_value_atoi_1=atoi(optarg);
          ogg123_opts->buffer_size = (signed long int)(1024 * return_value_atoi_1);
        }

        else
        {
          char *return_value_gettext_2;
          return_value_gettext_2=gettext("Internal error parsing command line options.\n");
          status_error(return_value_gettext_2);
          exit(1);
        }
        break;
      }
      case 98:
      {
        return_value_atoi_4=atoi(optarg);
        ogg123_opts->input_buffer_size = (signed long int)(return_value_atoi_4 * 1024);
        if(!(ogg123_opts->input_buffer_size >= 8192l))
        {
          char *return_value_gettext_5;
          return_value_gettext_5=gettext("Input buffer size smaller than minimum size of %dkB.");
          status_error(return_value_gettext_5, 8);
          ogg123_opts->input_buffer_size = (signed long int)(8 * 1024);
        }

        break;
      }
      case 99:
      {
        if(!(optarg == ((char *)NULL)))
        {
          char *tmp;
          tmp=strdup(optarg);
          enum anonymous_0 pcode;
          pcode=parse_line(file_opts, tmp);
          if(!((signed int)pcode == parse_ok))
          {
            return_value_gettext_6=gettext("=== Error \"%s\" while parsing config option from command line.\n=== Option was: %s\n");
            return_value_parse_error_string_7=parse_error_string(pcode);
            status_error(return_value_gettext_6, return_value_parse_error_string_7, optarg);
          }

          free((void *)tmp);
        }

        else
        {
          char *return_value_gettext_8;
          return_value_gettext_8=gettext("Available options:\n");
          fprintf(stdout, return_value_gettext_8);
          file_options_describe(file_opts, stdout);
          exit(0);
        }
        break;
      }
      case 100:
      {
        temp_driver_id=ao_driver_id(optarg);
        if(!(temp_driver_id >= 0))
        {
          char *return_value_gettext_9;
          return_value_gettext_9=gettext("=== No such device %s.\n");
          status_error(return_value_gettext_9, optarg);
          exit(1);
        }

        current=append_audio_device(ogg123_opts->devices, temp_driver_id, (struct ao_option *)(void *)0, (char *)(void *)0);
        if(ogg123_opts->devices == ((struct audio_device_t *)NULL))
          ogg123_opts->devices = current;

        current_options = &current->options;
        break;
      }
      case 102:
      {
        if(temp_driver_id >= 0)
        {
          info=ao_driver_info(temp_driver_id);
          if(info->type == 2)
          {
            free((void *)current->filename);
            current->filename=strdup(optarg);
          }

          else
          {
            char *return_value_gettext_10;
            return_value_gettext_10=gettext("=== Driver %s is not a file output driver.\n");
            status_error(return_value_gettext_10, info->short_name);
            exit(1);
          }
        }

        else
        {
          char *return_value_gettext_11;
          return_value_gettext_11=gettext("=== Cannot specify output file without previously specifying a driver.\n");
          status_error(return_value_gettext_11);
          exit(1);
        }
        break;
      }
      case 107:
      {
        set_seek_opt(ogg123_opts, optarg);
        break;
      }
      case 75:
      {
        ogg123_opts->endpos=strtotime(optarg);
        break;
      }
      case 108:
      {
        return_value_atoi_12=atoi(optarg);
        ogg123_opts->delay = (signed long int)return_value_atoi_12;
        break;
      }
      case 111:
      {
        if(!(optarg == ((char *)NULL)))
        {
          return_value_add_ao_option_14=add_ao_option(current_options, optarg);
          if(return_value_add_ao_option_14 == 0)
          {
            char *return_value_gettext_13;
            return_value_gettext_13=gettext("=== Incorrect option format: %s.\n");
            status_error(return_value_gettext_13, optarg);
            exit(1);
          }

        }

        break;
      }
      case 104:
      {
        cmdline_usage();
        exit(0);
        break;
      }
      case 112:
      {
        return_value_atof_15=atof(optarg);
        ogg123_opts->input_prebuffer = (float)return_value_atof_15;
        if(ogg123_opts->input_prebuffer < 0.0f)
          tmp_if_expr_17 = (_Bool)1;

        else
          tmp_if_expr_17 = ogg123_opts->input_prebuffer > 100.0f ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_17)
        {
          char *return_value_gettext_16;
          return_value_gettext_16=gettext("--- Prebuffer value invalid. Range is 0-100.\n");
          status_error(return_value_gettext_16);
          ogg123_opts->input_prebuffer = ogg123_opts->input_prebuffer < 0.0f ? 0.0f : 100.0f;
        }

        break;
      }
      case 113:
      {
        ogg123_opts->verbosity = 0;
        break;
      }
      case 114:
      {
        ogg123_opts->repeat = 1;
        break;
      }
      case 82:
      {
        ogg123_opts->remote = 1;
        ogg123_opts->verbosity = 0;
        break;
      }
      case 118:
      {
        ogg123_opts->verbosity = ogg123_opts->verbosity + 1;
        break;
      }
      case 86:
      {
        return_value_gettext_18=gettext("ogg123 from %s %s");
        status_error(return_value_gettext_18, (const void *)"vorbis-tools", (const void *)"1.4.0");
        exit(0);
        break;
      }
      case 120:
      {
        ogg123_opts->nth=atoi(optarg);
        if(ogg123_opts->nth == 0)
        {
          char *return_value_gettext_19;
          return_value_gettext_19=gettext("--- Cannot play every 0th chunk!\n");
          status_error(return_value_gettext_19);
          ogg123_opts->nth = 1;
        }

        break;
      }
      case 121:
      {
        ogg123_opts->ntimes=atoi(optarg);
        if(ogg123_opts->ntimes == 0)
        {
          char *return_value_gettext_20;
          return_value_gettext_20=gettext("--- Cannot play every chunk 0 times.\n--- To do a test decode, use the null output driver.\n");
          status_error(return_value_gettext_20);
          ogg123_opts->ntimes = 1;
        }

        break;
      }
      case 122:
      {
        ogg123_opts->shuffle = 1;
        break;
      }
      case 90:
      {
        ogg123_opts->shuffle = 1;
        ogg123_opts->repeat = ogg123_opts->shuffle;
        break;
      }
      case 64:
      {
        return_value_playlist_append_from_file_22=playlist_append_from_file(ogg123_opts->playlist, optarg);
        if(return_value_playlist_append_from_file_22 == 0)
        {
          return_value_gettext_21=gettext("--- Cannot open playlist file %s.  Skipped.\n");
          status_error(return_value_gettext_21, optarg);
        }

        break;
      }
      case 63:
        break;
      default:
      {
        cmdline_usage();
        exit(1);
      }
    }
  }
  while((_Bool)1);
  if(ogg123_opts->endpos > 0.0)
  {
    if(ogg123_opts->seekoff > ogg123_opts->endpos)
    {
      char *return_value_gettext_23;
      return_value_gettext_23=gettext("=== Option conflict: End time is before start time.\n");
      status_error(return_value_gettext_23);
      exit(1);
    }

  }

  char *return_value_gettext_24;
  if(!(temp_driver_id >= 0))
  {
    if(!(ogg123_opts->default_device == ((char *)NULL)))
    {
      temp_driver_id=ao_driver_id(ogg123_opts->default_device);
      if(!(temp_driver_id >= 0))
      {
        return_value_gettext_24=gettext("--- Driver %s specified in configuration file invalid.\n");
        status_error(return_value_gettext_24, ogg123_opts->default_device);
      }

    }

    if(!(temp_driver_id >= 0))
      temp_driver_id=ao_default_driver_id();

    if(!(temp_driver_id >= 0))
    {
      char *return_value_gettext_25;
      return_value_gettext_25=gettext("=== Could not load default driver and no driver specified in config file. Exiting.\n");
      status_error(return_value_gettext_25);
      exit(1);
    }

    ogg123_opts->devices=append_audio_device(ogg123_opts->devices, temp_driver_id, temp_options, (char *)(void *)0);
  }

  struct audio_device_t *head = ogg123_opts->devices;
  for( ; !(head == ((struct audio_device_t *)NULL)); head = head->next_device)
  {
    if(ogg123_opts->verbosity >= 4)
      ao_append_global_option("debug", (const char *)(void *)0);

    if(ogg123_opts->verbosity >= 3)
      ao_append_option(&head->options, "verbose", (const char *)(void *)0);

    if(ogg123_opts->verbosity == 0)
      ao_append_option(&head->options, "quiet", (const char *)(void *)0);

  }
  return optind;
}

// parse_config_file
// file cfgfile_options.c line 359
enum anonymous_0 parse_config_file(struct file_option_t *opts, const char *filename)
{
  unsigned int len = (unsigned int)80;
  char *line;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)len);
  line = (char *)return_value_malloc_1;
  signed int readoffset;
  signed int thischar;
  signed int lineno;
  struct _IO_FILE *file;
  enum anonymous_0 pcode;
  char empty[1l] = { 0 };
  signed int return_value_feof_2;
  signed int return_value_parse_error_4;
  if(line == ((char *)NULL))
  {
    parse_error((enum anonymous_0)parse_syserr, 0, empty, empty);
    return (enum anonymous_0)parse_syserr;
  }

  else
  {
    file=fopen(filename, "r");
    if(file == ((struct _IO_FILE *)NULL))
    {
      parse_error((enum anonymous_0)parse_syserr, 0, empty, empty);
      free((void *)line);
      return (enum anonymous_0)parse_syserr;
    }

    else
    {
      lineno = 0;
      do
      {
        return_value_feof_2=feof(file);
        if(!(return_value_feof_2 == 0))
          break;

        lineno = lineno + 1;
        readoffset = 0;
        memset((void *)line, 0, (unsigned long int)len);
        do
        {
          thischar=fgetc(file);
          if(thischar == -1)
            break;

          if(!(len >= 1u + (unsigned int)readoffset))
          {
            len = len * (unsigned int)2;
            void *return_value_realloc_3;
            return_value_realloc_3=realloc((void *)line, (unsigned long int)len);
            line = (char *)return_value_realloc_3;
            if(line == ((char *)NULL))
            {
              parse_error((enum anonymous_0)parse_syserr, 0, empty, empty);
              fclose(file);
              return (enum anonymous_0)parse_syserr;
            }

          }

          if(thischar == 10)
          {
            line[(signed long int)readoffset] = (char)0;
            break;
          }

          else
            line[(signed long int)readoffset] = (char)(unsigned char)thischar;
          readoffset = readoffset + 1;
        }
        while((_Bool)1);
        pcode=parse_line(opts, line);
        if(!((signed int)pcode == parse_ok))
        {
          return_value_parse_error_4=parse_error(pcode, lineno, filename, line);
          if(return_value_parse_error_4 == 0)
          {
            free((void *)line);
            return pcode;
          }

        }

      }
      while((_Bool)1);
      free((void *)line);
      return (enum anonymous_0)parse_ok;
    }
  }
}

// parse_error
// file cfgfile_options.c line 50
signed int parse_error(enum anonymous_0 pcode, signed int lineno, const char *filename, char *line)
{
  signed int *return_value___errno_location_2;
  char *return_value_gettext_1;
  if((signed int)pcode == parse_syserr)
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 17))
    {
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 2))
      {
        return_value_gettext_1=gettext("System error");
        perror(return_value_gettext_1);
      }

    }

    return -1;
  }

  else
  {
    char *return_value_gettext_4;
    return_value_gettext_4=gettext("=== Parse error: %s on line %d of %s (%s)\n");
    const char *return_value_parse_error_string_5;
    return_value_parse_error_string_5=parse_error_string(pcode);
    status_error(return_value_gettext_4, return_value_parse_error_string_5, lineno, filename, line);
    return 0;
  }
}

// parse_error_string
// file cfgfile_options.c line 425
const char * parse_error_string(enum anonymous_0 pcode)
{
  char *return_value_gettext_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  char *return_value_gettext_4;
  char *return_value_gettext_5;
  char *return_value_gettext_6;
  char *return_value_gettext_7;
  char *return_value_gettext_8;
  switch((signed int)pcode)
  {
    case parse_ok:
    {
      return_value_gettext_1=gettext("Success");
      return return_value_gettext_1;
    }
    case parse_syserr:
    {
      return_value___errno_location_2=__errno_location();
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      return return_value_strerror_3;
    }
    case parse_keynotfound:
    {
      return_value_gettext_4=gettext("Key not found");
      return return_value_gettext_4;
    }
    case parse_nokey:
    {
      return_value_gettext_5=gettext("No key");
      return return_value_gettext_5;
    }
    case parse_badvalue:
    {
      return_value_gettext_6=gettext("Bad value");
      return return_value_gettext_6;
    }
    case parse_badtype:
    {
      return_value_gettext_7=gettext("Bad type in options list");
      return return_value_gettext_7;
    }
    default:
    {
      return_value_gettext_8=gettext("Unknown error");
      return return_value_gettext_8;
    }
  }
}

// parse_line
// file cfgfile_options.c line 226
enum anonymous_0 parse_line(struct file_option_t *opts, char *line)
{
  char *equals;
  char *value = "";
  struct file_option_t *opt;
  signed int len;
  for( ; (signed int)*line == 32; line = line + 1l)
    ;
  equals=strchr(line, 35);
  if(!(equals == ((char *)NULL)))
    *equals = (char)0;

  _Bool tmp_if_expr_1;
  if(*line == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_4;
  _Bool tmp_if_expr_6;
  signed int return_value_strncasecmp_11;
  _Bool tmp_if_expr_13;
  signed int return_value_strcasecmp_12;
  _Bool tmp_if_expr_14;
  signed int return_value_strncasecmp_7;
  _Bool tmp_if_expr_9;
  signed int return_value_strcasecmp_8;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_strlen_15;
  _Bool tmp_if_expr_16;
  signed int *return_value___errno_location_17;
  _Bool tmp_if_expr_19;
  signed int *return_value___errno_location_18;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_21;
  double return_value_atof_22;
  _Bool tmp_if_expr_23;
  if(tmp_if_expr_1)
    return (enum anonymous_0)parse_ok;

  else
  {
    equals=strchr(line, 61);
    if(!(equals == ((char *)NULL)))
    {
      value = equals + (signed long int)1;
      *equals = (char)0;
    }

    do
    {
      equals=strrchr(line, 32);
      if(equals == ((char *)NULL))
        break;

      *equals = (char)0;
    }
    while((_Bool)1);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(line);
    if(return_value_strlen_2 == 0ul)
      return (enum anonymous_0)parse_nokey;

    else
    {
      if(!(value == ((char *)NULL)))
      {
        for( ; (signed int)*value == 32; value = value + 1l)
          ;
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(value);
        len = (signed int)return_value_strlen_3;
        for( ; len >= 1; value[(signed long int)len] = (char)0)
        {
          if(!((signed int)value[(signed long int)(len + -1)] == 32))
            break;

          len = len - 1;
        }
      }

      opt = opts;
      while(!(opt->name == ((const char *)NULL)))
      {
        signed int return_value_strcasecmp_24;
        return_value_strcasecmp_24=strcasecmp(opt->name, line);
        if(return_value_strcasecmp_24 == 0)
        {
          signed long int tmpl;
          char *endptr;
          switch((signed int)opt->type)
          {
            case opt_type_none:
            {
              if(!(value == ((char *)NULL)))
                tmp_if_expr_5 = (_Bool)1;

              else
              {
                return_value_strlen_4=strlen(value);
                tmp_if_expr_5 = return_value_strlen_4 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_5)
                return (enum anonymous_0)parse_badvalue;

              opt->found = opt->found + 1;
              break;
            }
            case opt_type_bool:
            {
              if(value == ((char *)NULL))
                tmp_if_expr_6 = (_Bool)1;

              else
                tmp_if_expr_6 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_6)
                return (enum anonymous_0)parse_badvalue;

              tmpl=strtol(value, &endptr, 0);
              return_value_strncasecmp_11=strncasecmp(value, "y", (unsigned long int)1);
              if(return_value_strncasecmp_11 == 0)
                tmp_if_expr_13 = (_Bool)1;

              else
              {
                return_value_strcasecmp_12=strcasecmp(value, "true");
                tmp_if_expr_13 = !(return_value_strcasecmp_12 != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_13)
                tmp_if_expr_14 = (_Bool)1;

              else
                tmp_if_expr_14 = ((signed int)*endptr == 0 ? (tmpl != 0l ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_14)
                *((signed int *)opt->ptr) = 1;

              else
              {
                return_value_strncasecmp_7=strncasecmp(value, "n", (unsigned long int)1);
                if(return_value_strncasecmp_7 == 0)
                  tmp_if_expr_9 = (_Bool)1;

                else
                {
                  return_value_strcasecmp_8=strcasecmp(value, "false");
                  tmp_if_expr_9 = !(return_value_strcasecmp_8 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_9)
                  tmp_if_expr_10 = (_Bool)1;

                else
                  tmp_if_expr_10 = ((signed int)*endptr == 0 ? (!(tmpl != 0l) ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_10)
                  *((signed int *)opt->ptr) = 0;

                else
                  return (enum anonymous_0)parse_badvalue;
              }
              break;
            }
            case opt_type_char:
            {
              return_value_strlen_15=strlen(value);
              if(!(return_value_strlen_15 == 1ul))
                return (enum anonymous_0)parse_badvalue;

              opt->found = opt->found + 1;
              *((char *)opt->ptr) = value[(signed long int)0];
              break;
            }
            case opt_type_string:
            {
              opt->found = opt->found + 1;
              if(!(*((char **)opt->ptr) == ((char *)NULL)))
                free((void *)*((char **)opt->ptr));

              *((char **)opt->ptr)=strdup(value);
              break;
            }
            case opt_type_int:
            {
              if(value == ((char *)NULL))
                tmp_if_expr_16 = (_Bool)1;

              else
                tmp_if_expr_16 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_16)
                return (enum anonymous_0)parse_badvalue;

              return_value___errno_location_17=__errno_location();
              *return_value___errno_location_17 = 0;
              tmpl=strtol(value, &endptr, 0);
              if(tmpl == 0x7fffffffffffffffL || tmpl == -9223372036854775808l)
              {
                return_value___errno_location_18=__errno_location();
                tmp_if_expr_19 = *return_value___errno_location_18 == 34 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_19 = (_Bool)0;
              if(tmp_if_expr_19)
                tmp_if_expr_20 = (_Bool)1;

              else
                tmp_if_expr_20 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_20)
                return (enum anonymous_0)parse_badvalue;

              if(tmpl >= 2147483648l || !(tmpl >= -2147483648l))
                return (enum anonymous_0)parse_badvalue;

              opt->found = opt->found + 1;
              *((signed int *)opt->ptr) = (signed int)tmpl;
              break;
            }
            case opt_type_float:
            {
              if(value == ((char *)NULL))
                tmp_if_expr_21 = (_Bool)1;

              else
                tmp_if_expr_21 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_21)
                return (enum anonymous_0)parse_badvalue;

              opt->found = opt->found + 1;
              return_value_atof_22=atof(value);
              *((float *)opt->ptr) = (float)return_value_atof_22;
              break;
            }
            case opt_type_double:
            {
              if(value == ((char *)NULL))
                tmp_if_expr_23 = (_Bool)1;

              else
                tmp_if_expr_23 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_23)
                return (enum anonymous_0)parse_badvalue;

              opt->found = opt->found + 1;
              *((double *)opt->ptr)=atof(value);
              break;
            }
            default:
              return (enum anonymous_0)parse_badtype;
          }
          return (enum anonymous_0)parse_ok;
        }

        opt = opt + 1l;
      }
      return (enum anonymous_0)parse_keynotfound;
    }
  }
}

// parse_std_configs
// file cfgfile_options.c line 446
void parse_std_configs(struct file_option_t *opts)
{
  char filename[4096l];
  char *homedir;
  homedir=getenv("HOME");
  parse_config_file(opts, "/etc/ogg123rc");
  unsigned long int return_value_strlen_1;
  if(!(homedir == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(homedir);
    if(!(return_value_strlen_1 >= 4086ul))
    {
      strncpy(filename, homedir, (unsigned long int)4096);
      strcat(filename, "/.ogg123rc");
      parse_config_file(opts, filename);
    }

  }

}

// play
// file ogg123.c line 515
void play(char *source_string)
{
  struct transport_t *transport;
  struct format_t *format;
  struct data_source_t *source;
  struct decoder_t *decoder;
  struct decoder_callbacks_t decoder_callbacks;
  void *decoder_callbacks_arg;
  struct audio_format_t new_audio_fmt;
  struct audio_reopen_arg_t *reopen_arg;
  signed int eof = 0;
  signed int eos = 0;
  signed int ret;
  signed int nthc = 0;
  signed int ntimesc = 0;
  signed int next_status = 0;
  sig_request.cancel = 0;
  sig_request.skipfile = 0;
  sig_request.exit = 0;
  sig_request.pause = 0;
  new_audio_fmt.big_endian=ao_is_big_endian();
  new_audio_fmt.signed_sample = 1;
  new_audio_fmt.word_size = 2;
  if(!(audio_buffer == ((struct buf_t *)NULL)))
  {
    decoder_callbacks.printf_error = decoder_buffered_error_callback;
    decoder_callbacks.printf_metadata = decoder_buffered_metadata_callback;
    decoder_callbacks_arg = (void *)audio_buffer;
  }

  else
  {
    decoder_callbacks.printf_error = decoder_error_callback;
    decoder_callbacks.printf_metadata = decoder_metadata_callback;
    decoder_callbacks_arg = (void *)0;
  }
  transport=select_transport(source_string);
  if(transport == ((struct transport_t *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("No module could be found to read from %s.\n");
    status_error(return_value_gettext_1, source_string);
    goto __CPROVER_DUMP_L38;
  }

  source=transport->open(source_string, &options);
  if(source == ((struct data_source_t *)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("Cannot open %s.\n");
    status_error(return_value_gettext_2, source_string);
  }

  format=select_format(source);
  if(format == ((struct format_t *)NULL))
  {
    char *return_value_gettext_3;
    return_value_gettext_3=gettext("The file format of %s is not supported.\n");
    status_error(return_value_gettext_3, source_string);
  }

  decoder=format->init(source, &options, &new_audio_fmt, &decoder_callbacks, decoder_callbacks_arg);
  char *return_value_gettext_4;
  if(decoder == ((struct decoder_t *)NULL))
  {
    if(sig_request.cancel == 0)
    {
      return_value_gettext_4=gettext("Error opening %s using the %s module.  The file may be corrupted.\n");
      status_error(return_value_gettext_4, source_string, format->name);
    }

  }

  select_stats(stat_format, &options, source, decoder, audio_buffer);
  if(!(audio_buffer == ((struct buf_t *)NULL)))
  {
    buffer_reset(audio_buffer);
    buffer_thread_start(audio_buffer);
  }

  char *return_value_gettext_5;
  return_value_gettext_5=gettext("Playing: %s");
  decoder_callbacks.printf_metadata(decoder_callbacks_arg, 1, return_value_gettext_5, source_string);
  if(options.seekoff > 0.0)
  {
    signed int return_value;
    return_value=format->seek(decoder, options.seekoff, 1);
    if(return_value == 0)
    {
      char *return_value_gettext_6;
      return_value_gettext_6=gettext("Could not skip %f seconds of audio.");
      status_error(return_value_gettext_6, options.seekoff);
      if(!(audio_buffer == ((struct buf_t *)NULL)))
        buffer_thread_kill(audio_buffer);

    }

  }

  double return_value_current_time_11;
  signed int tmp_post_15;
  _Bool tmp_if_expr_12;
  if(sig_request.exit == 0 && eof == 0)
  {
    eos = 0;
    if(sig_request.exit == 0 && eos == 0)
    {
      if(!(sig_request.skipfile == 0))
      {
        eos = 1;
        eof = eos;
      }

      else
      {
        if(!(options.remote == 0))
        {
          signed int return_value_remote_playloop_7;
          return_value_remote_playloop_7=remote_playloop();
          if(!(return_value_remote_playloop_7 == 0))
          {
            eos = 1;
            eof = eos;
          }

          handle_seek_opt(&options, decoder, format);
        }

        if(!(sig_request.pause == 0))
        {
          if(!(audio_buffer == ((struct buf_t *)NULL)))
            buffer_thread_pause(audio_buffer);

          signed int return_value_getpid_8;
          return_value_getpid_8=getpid();
          kill(return_value_getpid_8, 19);
          if(!(audio_buffer == ((struct buf_t *)NULL)))
            buffer_thread_unpause(audio_buffer);

          sig_request.pause = 0;
        }

        ret=format->read(decoder, (void *)convbuffer, convsize, &eos, &new_audio_fmt);
        if(ret == 0)
        {
          eos = 1;
          eof = eos;
        }

        else
          if(!(ret >= 0))
          {
            char *return_value_gettext_9;
            return_value_gettext_9=gettext("ERROR: Decoding failure.\n");
            status_error(return_value_gettext_9);
          }

        signed int return_value_audio_format_equal_10;
        static struct audio_format_t old_audio_fmt = { .big_endian=0, .word_size=0, .signed_sample=0, .rate=0,
    .channels=0, .matrix=((char *)NULL) };
        return_value_audio_format_equal_10=audio_format_equal(&new_audio_fmt, &old_audio_fmt);
        static signed int status_interval = 0;
        if(return_value_audio_format_equal_10 == 0)
        {
          old_audio_fmt = new_audio_fmt;
          status_interval = (signed int)((double)(new_audio_fmt.word_size * new_audio_fmt.channels * new_audio_fmt.rate) / options.status_freq);
          next_status = 0;
          reopen_arg=new_audio_reopen_arg(options.devices, &new_audio_fmt);
          if(!(audio_buffer == ((struct buf_t *)NULL)))
            buffer_insert_action_at_end(audio_buffer, audio_reopen_action, (void *)reopen_arg);

          else
            audio_reopen_action((struct buf_t *)(void *)0, (void *)reopen_arg);
        }

        if(!(next_status >= 1))
        {
          display_statistics(stat_format, audio_buffer, source, decoder);
          next_status = status_interval;
        }

        else
          next_status = next_status - ret;
        if(options.endpos > 0.0)
        {
          return_value_current_time_11=current_time(decoder);
          eos = 1;
          eof = eos;
        }

        else
        {
          tmp_post_15 = nthc;
          nthc = nthc - 1;
          if(tmp_post_15 == 0)
          {
            if(!(audio_buffer == ((struct buf_t *)NULL)))
            {
              signed int return_value_buffer_submit_data_14;
              return_value_buffer_submit_data_14=buffer_submit_data(audio_buffer, (char *)convbuffer, (signed long int)ret);
              if(return_value_buffer_submit_data_14 == 0)
              {
                char *return_value_gettext_13;
                return_value_gettext_13=gettext("ERROR: buffer write failed.\n");
                status_error(return_value_gettext_13);
                eos = 1;
                eof = eos;
              }

            }

            else
              audio_play_callback((void *)convbuffer, ret, eos, (void *)&audio_play_arg);
            nthc = options.nth - 1;
          }

          if(sig_request.exit == 0 && sig_request.skipfile == 0)
          {
            ntimesc = ntimesc + 1;
            tmp_if_expr_12 = ntimesc < options.ntimes ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_12 = (_Bool)0;
          ntimesc = 0;
        }
      }
    }

  }

  if(!(audio_buffer == ((struct buf_t *)NULL)))
  {
    if(sig_request.exit == 0 && sig_request.skipfile == 0)
    {
      buffer_mark_eos(audio_buffer);
      buffer_wait_for_empty(audio_buffer);
    }

    buffer_thread_kill(audio_buffer);
  }

  display_statistics_quick(stat_format, audio_buffer, source, decoder);
  format->cleanup(decoder);
  transport->close(source);
  status_reset_output_lock();
  char *return_value_gettext_16;
  return_value_gettext_16=gettext("Done.");
  status_message(1, return_value_gettext_16);
  if(!(sig_request.exit == 0))
    exit(exit_status);


__CPROVER_DUMP_L38:
  ;
}

// playlist_append_directory
// file playlist.h line 51
signed int playlist_append_directory(struct playlist_t *list, char *dirname)
{
  signed int dir_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(dirname);
  dir_len = (signed int)return_value_strlen_1;
  signed int num_entries = 0;
  signed int i = 0;
  struct dirent **entries;
  struct stat stat_buf;
  char nextfile[256l];
  num_entries=scandir(dirname, &entries, ((signed int (*)(struct dirent *))NULL), alphasort);
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  if(!(num_entries >= 0))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= num_entries); i = i + 1)
    {
      signed int sub_len;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(entries[(signed long int)i]->d_name);
      sub_len = (signed int)return_value_strlen_2;
      if(!(1 + sub_len + dir_len >= 255))
      {
        return_value_strcmp_7=strcmp(entries[(signed long int)i]->d_name, ".");
        if(!(return_value_strcmp_7 == 0))
        {
          return_value_strcmp_6=strcmp(entries[(signed long int)i]->d_name, "..");
          if(!(return_value_strcmp_6 == 0))
          {
            strcpy(nextfile, dirname);
            strcat(nextfile, "/");
            strcat(nextfile, entries[(signed long int)i]->d_name);
            signed int return_value_stat_5;
            return_value_stat_5=stat(nextfile, &stat_buf);
            if(return_value_stat_5 == 0)
            {
              if((61440u & stat_buf.st_mode) == 16384u)
              {
                signed int return_value_playlist_append_directory_4;
                return_value_playlist_append_directory_4=playlist_append_directory(list, nextfile);
                if(return_value_playlist_append_directory_4 == 0)
                {
                  char *return_value_gettext_3;
                  return_value_gettext_3=gettext("Warning: Could not read directory %s.\n");
                  fprintf(stderr, return_value_gettext_3, (const void *)nextfile);
                }

              }

              else
                playlist_append_file(list, nextfile);
            }

          }

        }

      }

      free((void *)entries[(signed long int)i]);
    }
    free((void *)entries);
    return 1;
  }
}

// playlist_append_file
// file playlist.h line 48
signed int playlist_append_file(struct playlist_t *list, char *filename)
{
  list->last->next=playlist_element_create(filename);
  list->last = list->last->next;
  return 1;
}

// playlist_append_from_file
// file playlist.h line 55
signed int playlist_append_from_file(struct playlist_t *list, char *playlist_filename)
{
  struct _IO_FILE *fp;
  char filename[256l];
  struct stat stat_buf;
  signed int length;
  signed int i;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(playlist_filename, "-");
  if(return_value_strcmp_1 == 0)
    fp = stdin;

  else
    fp=fopen(playlist_filename, "r");
  signed int return_value_feof_2;
  _Bool tmp_if_expr_6;
  const unsigned short int **return_value___ctype_b_loc_5;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  char *return_value_gettext_9;
  if(fp == ((struct _IO_FILE *)NULL))
    return 0;

  else
  {
    do
    {
      return_value_feof_2=feof(fp);
      if(!(return_value_feof_2 == 0))
        break;

      char *return_value_fgets_3;
      return_value_fgets_3=fgets(filename, 255 + 1, fp);
      if(!(return_value_fgets_3 == ((char *)NULL)))
      {
        filename[(signed long int)255] = (char)0;
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(filename);
        length = (signed int)return_value_strlen_4;
        i = 0;
        do
        {
          if(!(i >= length))
          {
            return_value___ctype_b_loc_5=__ctype_b_loc();
            tmp_if_expr_6 = ((signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)filename[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
          if(!tmp_if_expr_6)
            break;

          i = i + 1;
        }
        while((_Bool)1);
        if(!(i == length))
        {
          if((signed int)filename[(signed long int)(length + -2)] == 13)
            tmp_if_expr_8 = (signed int)filename[(signed long int)(length - 1)] == 10 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8 = (_Bool)0;
          if(tmp_if_expr_8)
            filename[(signed long int)(length - 2)] = (char)0;

          else
          {
            if((signed int)filename[(signed long int)(length + -1)] == 10)
              tmp_if_expr_7 = (_Bool)1;

            else
              tmp_if_expr_7 = (signed int)filename[(signed long int)(length - 1)] == 13 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_7)
              filename[(signed long int)(length - 1)] = (char)0;

          }
          signed int return_value_stat_11;
          return_value_stat_11=stat(filename, &stat_buf);
          if(return_value_stat_11 == 0)
          {
            if((61440u & stat_buf.st_mode) == 16384u)
            {
              signed int return_value_playlist_append_directory_10;
              return_value_playlist_append_directory_10=playlist_append_directory(list, filename);
              if(return_value_playlist_append_directory_10 == 0)
              {
                return_value_gettext_9=gettext("Warning from playlist %s: Could not read directory %s.\n");
                fprintf(stderr, return_value_gettext_9, playlist_filename, (const void *)filename);
              }

            }

            else
              playlist_append_file(list, filename);
          }

          else
            playlist_append_file(list, filename);
        }

      }

    }
    while((_Bool)1);
    return 1;
  }
}

// playlist_array_destroy
// file playlist.h line 65
void playlist_array_destroy(char **array, signed int size)
{
  signed int i = 0;
  for( ; !(i >= size); i = i + 1)
    free((void *)array[(signed long int)i]);
  free((void *)array);
}

// playlist_create
// file playlist.h line 36
struct playlist_t * playlist_create()
{
  struct playlist_t *list;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct playlist_t) /*16ul*/ );
  list = (struct playlist_t *)return_value_malloc_1;
  if(!(list == ((struct playlist_t *)NULL)))
  {
    list->head=playlist_element_create((char *)(void *)0);
    list->last = list->head;
  }

  return list;
}

// playlist_destroy
// file playlist.h line 37
void playlist_destroy(struct playlist_t *list)
{
  struct playlist_element_t *next_element;
  for( ; !(list->head == ((struct playlist_element_t *)NULL)); list->head = next_element)
  {
    next_element = list->head->next;
    playlist_element_destroy(list->head);
  }
  free((void *)list);
}

// playlist_element_create
// file playlist.c line 39
struct playlist_element_t * playlist_element_create(char *filename)
{
  struct playlist_element_t *element;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct playlist_t) /*16ul*/ );
  element = (struct playlist_element_t *)return_value_malloc_1;
  if(element == ((struct playlist_element_t *)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("ERROR: Out of memory in create_playlist_member().\n");
    fprintf(stderr, return_value_gettext_2);
    exit(1);
  }

  if(filename == ((char *)NULL))
    element->filename = (char *)(void *)0;

  else
  {
    element->filename=strdup(filename);
    if(element->filename == ((char *)NULL))
    {
      char *return_value_gettext_3;
      return_value_gettext_3=gettext("ERROR: Out of memory in create_playlist_member().\n");
      fprintf(stderr, return_value_gettext_3);
      exit(1);
    }

  }
  element->next = (struct playlist_element_t *)(void *)0;
  return element;
}

// playlist_element_destroy
// file playlist.c line 69
void playlist_element_destroy(struct playlist_element_t *element)
{
  free((void *)element->filename);
  free((void *)element);
}

// playlist_length
// file playlist.h line 58
signed int playlist_length(struct playlist_t *list)
{
  signed int length;
  struct playlist_element_t *element = list->head;
  length = 0;
  for( ; !(element->next == ((struct playlist_element_t *)NULL)); element = element->next)
    length = length + 1;
  return length;
}

// playlist_to_array
// file playlist.h line 62
char ** playlist_to_array(struct playlist_t *list, signed int *size)
{
  char **array;
  signed int i;
  struct playlist_element_t *element;
  *size=playlist_length(list);
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)*size, sizeof(char *) /*8ul*/ );
  array = (char **)return_value_calloc_1;
  if(array == ((char **)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("ERROR: Out of memory in playlist_to_array().\n");
    fprintf(stderr, return_value_gettext_2);
    exit(1);
  }

  i = 0;
  element = list->head->next;
  for( ; !(i >= *size); element = element->next)
  {
    array[(signed long int)i]=strdup(element->filename);
    if(array[(signed long int)i] == ((char *)NULL))
    {
      char *return_value_gettext_3;
      return_value_gettext_3=gettext("ERROR: Out of memory in playlist_to_array().\n");
      fprintf(stderr, return_value_gettext_3);
      exit(1);
    }

    i = i + 1;
  }
  return array;
}

// print_audio_devices_info
// file ogg123.c line 369
void print_audio_devices_info(struct audio_device_t *d)
{
  struct ao_info *info;
  while(!(d == ((struct audio_device_t *)NULL)))
  {
    info=ao_driver_info(d->driver_id);
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("\nAudio Device:   %s");
    status_message(2, return_value_gettext_1, info->name);
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("Author:   %s");
    status_message(3, return_value_gettext_2, info->author);
    char *return_value_gettext_3;
    return_value_gettext_3=gettext("Comments: %s");
    status_message(3, return_value_gettext_3, info->comment);
    status_message(2, "");
    d = d->next_device;
  }
}

// print_flac_comments
// file flac_format.c line 611
void print_flac_comments(struct anonymous_18 *f_comments, struct decoder_callbacks_t *cb, void *callback_arg)
{
  signed int i;
  char *temp = (char *)(void *)0;
  signed int temp_len = 0;
  i = 0;
  for( ; !((unsigned int)i >= f_comments->num_comments); i = i + 1)
  {
    if(!((unsigned int)temp_len >= 1u + (f_comments->comments + (signed long int)i)->length))
    {
      temp_len = (signed int)((f_comments->comments + (signed long int)i)->length + (unsigned int)1);
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)temp, sizeof(char) /*1ul*/  * (unsigned long int)temp_len);
      temp = (char *)return_value_realloc_1;
    }

    strncpy(temp, (const char *)(f_comments->comments + (signed long int)i)->entry, (unsigned long int)(f_comments->comments + (signed long int)i)->length);
    temp[(signed long int)(f_comments->comments + (signed long int)i)->length] = (char)0;
    print_vorbis_comment(temp, cb, callback_arg);
  }
  free((void *)temp);
}

// print_flac_stream_info
// file flac_format.c line 582
void print_flac_stream_info(struct decoder_t *decoder)
{
  struct anonymous_21 *priv = (struct anonymous_21 *)decoder->private;
  struct decoder_callbacks_t *cb = decoder->callbacks;
  _Bool tmp_if_expr_1;
  if(cb == ((struct decoder_callbacks_t *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = cb->printf_metadata == (void (*)(void *, signed int, char *, ...))(void *)0 ? (_Bool)1 : (_Bool)0;
  char *return_value_gettext_2;
  char *return_value_gettext_3;
  if(!tmp_if_expr_1)
  {
    if(!(priv->is_oggflac == 0))
    {
      return_value_gettext_2=gettext("Ogg FLAC stream: %d bits, %d channel, %ld Hz");
      cb->printf_metadata(decoder->callback_arg, 2, return_value_gettext_2, priv->bits_per_sample, priv->channels, priv->rate);
    }

    else
    {
      return_value_gettext_3=gettext("FLAC stream: %d bits, %d channel, %ld Hz");
      cb->printf_metadata(decoder->callback_arg, 2, return_value_gettext_3, priv->bits_per_sample, priv->channels, priv->rate);
    }
  }

}

// print_space
// file cfgfile_options.c line 39
signed int print_space(struct _IO_FILE *f, signed int s, signed int c)
{
  signed int tmp = 0;
  do
  {
    fputc(c, f);
    tmp = tmp + 1;
    s = s - 1;
  }
  while(s >= 1);
  return tmp;
}

// print_speex_comments
// file speex_format.c line 383
void print_speex_comments(char *comments, signed int length, struct decoder_callbacks_t *cb, void *callback_arg)
{
  char *c = comments;
  signed int len;
  signed int i;
  signed int nb_fields;
  char *end;
  char *temp = (char *)(void *)0;
  signed int temp_len = 0;
  if(!(length >= 8))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("Invalid/corrupted comments");
    cb->printf_error(callback_arg, 1, return_value_gettext_1);
  }

  end = c + (signed long int)length;
  len = (signed int)((unsigned int)((signed int)c[(signed long int)(0 + 3)] << 24) & 0xff000000 | (unsigned int)((signed int)c[(signed long int)(0 + 2)] << 16 & 0xff0000) | (unsigned int)((signed int)c[(signed long int)(0 + 1)] << 8 & 0xff00) | (unsigned int)((signed int)c[(signed long int)0] & 0xff));
  c = c + (signed long int)4;
  if(!(end >= c + (signed long int)len))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("Invalid/corrupted comments");
    cb->printf_error(callback_arg, 1, return_value_gettext_2);
  }

  temp_len = len + 1;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(char) /*1ul*/  * (unsigned long int)temp_len);
  temp = (char *)return_value_malloc_3;
  strncpy(temp, c, (unsigned long int)len);
  temp[(signed long int)len] = (char)0;
  char *return_value_gettext_4;
  return_value_gettext_4=gettext("Encoded by: %s");
  cb->printf_metadata(callback_arg, 3, return_value_gettext_4, temp);
  c = c + (signed long int)len;
  if(!(end >= c + 4l))
  {
    char *return_value_gettext_5;
    return_value_gettext_5=gettext("Invalid/corrupted comments");
    cb->printf_error(callback_arg, 1, return_value_gettext_5);
    free((void *)temp);
  }

  nb_fields = (signed int)((unsigned int)((signed int)c[(signed long int)(0 + 3)] << 24) & 0xff000000 | (unsigned int)((signed int)c[(signed long int)(0 + 2)] << 16 & 0xff0000) | (unsigned int)((signed int)c[(signed long int)(0 + 1)] << 8 & 0xff00) | (unsigned int)((signed int)c[(signed long int)0] & 0xff));
  c = c + (signed long int)4;
  i = 0;
  if(!(i >= nb_fields))
  {
    if(!(end >= c + 4l))
    {
      char *return_value_gettext_6;
      return_value_gettext_6=gettext("Invalid/corrupted comments");
      cb->printf_error(callback_arg, 1, return_value_gettext_6);
      free((void *)temp);
    }

    len = (signed int)((unsigned int)((signed int)c[(signed long int)(0 + 3)] << 24) & 0xff000000 | (unsigned int)((signed int)c[(signed long int)(0 + 2)] << 16 & 0xff0000) | (unsigned int)((signed int)c[(signed long int)(0 + 1)] << 8 & 0xff00) | (unsigned int)((signed int)c[(signed long int)0] & 0xff));
    c = c + (signed long int)4;
    if(!(end >= c + (signed long int)len))
    {
      char *return_value_gettext_7;
      return_value_gettext_7=gettext("Invalid/corrupted comments");
      cb->printf_error(callback_arg, 1, return_value_gettext_7);
      free((void *)temp);
    }

    if(!(temp_len >= 1 + len))
    {
      temp_len = len + 1;
      void *return_value_realloc_8;
      return_value_realloc_8=realloc((void *)temp, sizeof(char) /*1ul*/  * (unsigned long int)temp_len);
      temp = (char *)return_value_realloc_8;
    }

    strncpy(temp, c, (unsigned long int)len);
    temp[(signed long int)len] = (char)0;
    print_vorbis_comment(temp, cb, callback_arg);
    c = c + (signed long int)len;
    i = i + 1;
  }

  free((void *)temp);
}

// print_speex_info
// file speex_format.c line 358
void print_speex_info(struct SpeexHeader *header, struct decoder_callbacks_t *cb, void *callback_arg)
{
  signed int modeID = header->mode;
  char *return_value_gettext_1;
  char *return_value_gettext_2;
  if(!(header->vbr == 0))
  {
    return_value_gettext_1=gettext("Ogg Speex stream: %d channel, %d Hz, %s mode (VBR)");
    cb->printf_metadata(callback_arg, 2, return_value_gettext_1, header->nb_channels, header->rate, speex_mode_list[(signed long int)modeID]->modeName);
  }

  else
  {
    return_value_gettext_2=gettext("Ogg Speex stream: %d channel, %d Hz, %s mode");
    cb->printf_metadata(callback_arg, 2, return_value_gettext_2, header->nb_channels, header->rate, speex_mode_list[(signed long int)modeID]->modeName);
  }
  char *return_value_gettext_3;
  return_value_gettext_3=gettext("Speex version: %s");
  cb->printf_metadata(callback_arg, 3, return_value_gettext_3, (const void *)header->speex_version);
}

// print_statistics_action
// file callbacks.c line 149
void print_statistics_action(struct buf_t *buf, void *arg)
{
  struct print_statistics_arg_t *stats_arg = (struct print_statistics_arg_t *)arg;
  struct buffer_stats_t *buffer_stats;
  if(!(buf == ((struct buf_t *)NULL)))
    buffer_stats=buffer_statistics(buf);

  else
    buffer_stats = (struct buffer_stats_t *)(void *)0;
  status_print_statistics(stats_arg->stat_format, buffer_stats, stats_arg->data_source_statistics, stats_arg->decoder_statistics);
  free((void *)stats_arg->data_source_statistics);
  free((void *)stats_arg->decoder_statistics);
  free((void *)stats_arg);
  free((void *)buffer_stats);
}

// print_statistics_line
// file status.c line 127
signed int print_statistics_line(struct anonymous_3 *stats)
{
  signed int len = 0;
  char *str = temp_buffer;
  _Bool tmp_if_expr_2;
  signed int return_value_sprintf_3;
  signed int return_value_sprintf_4;
  signed int return_value_sprintf_5;
  signed int return_value_sprintf_6;
  signed int return_value_sprintf_7;
  signed int return_value_sprintf_8;
  if(max_verbosity == 0)
    return 0;

  else
  {
    signed int return_value_sprintf_clear_line_1;
    return_value_sprintf_clear_line_1=sprintf_clear_line(last_line_len, str);
    str = str + (signed long int)return_value_sprintf_clear_line_1;
    while(!(stats->formatstr == ((const char *)NULL)))
    {
      if(!(max_verbosity >= stats->verbosity))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = !(stats->enabled != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        stats = stats + 1l;

      else
      {
        if(!(len == 0))
        {
          return_value_sprintf_3=sprintf(str + (signed long int)len, " ");
          len = len + return_value_sprintf_3;
        }

        switch((signed int)stats->type)
        {
          case stat_noarg:
          {
            return_value_sprintf_4=sprintf(str + (signed long int)len, "%s", stats->formatstr);
            len = len + return_value_sprintf_4;
            break;
          }
          case stat_intarg:
          {
            return_value_sprintf_5=sprintf(str + (signed long int)len, stats->formatstr, stats->arg.intarg);
            len = len + return_value_sprintf_5;
            break;
          }
          case stat_stringarg:
          {
            return_value_sprintf_6=sprintf(str + (signed long int)len, stats->formatstr, stats->arg.stringarg);
            len = len + return_value_sprintf_6;
            break;
          }
          case stat_floatarg:
          {
            return_value_sprintf_7=sprintf(str + (signed long int)len, stats->formatstr, stats->arg.floatarg);
            len = len + return_value_sprintf_7;
            break;
          }
          case stat_doublearg:
          {
            return_value_sprintf_8=sprintf(str + (signed long int)len, stats->formatstr, stats->arg.doublearg);
            len = len + return_value_sprintf_8;
          }
        }
        stats = stats + 1l;
      }
    }
    struct winsize max;
    signed int ioctlError;
    ioctlError=ioctl(2, (unsigned long int)0x5413, &max);
    if(ioctlError == 0)
    {
      const signed int limit = (signed int)max.ws_col - 1;
      if(!(limit >= len))
      {
        signed int pointsStart = limit - 3;
        if(!(pointsStart >= 0))
          pointsStart = 0;

        signed int position = pointsStart;
        for( ; !(position >= limit); position = position + 1)
          str[(signed long int)position] = (char)46;
        str[(signed long int)position] = (char)0;
        len = position;
      }

    }

    signed int return_value_sprintf_9;
    return_value_sprintf_9=sprintf(str + (signed long int)len, "\r");
    len = len + return_value_sprintf_9;
    fprintf(stderr, "%s", (const void *)temp_buffer);
    return len;
  }
}

// print_vorbis_comment
// file vorbis_comments.h line 25
void print_vorbis_comment(char *comment, struct decoder_callbacks_t *cb, void *callback_arg)
{
  char *comment_prettyprint;
  char *decoded_value;
  signed int offset;
  _Bool tmp_if_expr_1;
  if(cb == ((struct decoder_callbacks_t *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = cb->printf_metadata == (void (*)(void *, signed int, char *, ...))(void *)0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    comment_prettyprint=lookup_comment_prettyprint(comment, &offset);
    signed int return_value_utf8_decode_2;
    return_value_utf8_decode_2=utf8_decode(comment + (signed long int)offset, &decoded_value);
    if(return_value_utf8_decode_2 >= 0)
    {
      cb->printf_metadata(callback_arg, 1, "%s %s", comment_prettyprint, decoded_value);
      free((void *)decoded_value);
    }

    else
      cb->printf_metadata(callback_arg, 1, "%s %s", comment_prettyprint, comment + (signed long int)offset);
    free((void *)comment_prettyprint);
  }

}

// print_vorbis_comments
// file oggvorbis_format.c line 381
void print_vorbis_comments(struct vorbis_comment *vc, struct decoder_callbacks_t *cb, void *callback_arg)
{
  signed int i;
  char *temp = (char *)(void *)0;
  signed int temp_len = 0;
  i = 0;
  for( ; !(i >= vc->comments); i = i + 1)
  {
    if(!(temp_len >= 1 + vc->comment_lengths[(signed long int)i]))
    {
      temp_len = vc->comment_lengths[(signed long int)i] + 1;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)temp, sizeof(char) /*1ul*/  * (unsigned long int)temp_len);
      temp = (char *)return_value_realloc_1;
    }

    strncpy(temp, vc->user_comments[(signed long int)i], (unsigned long int)vc->comment_lengths[(signed long int)i]);
    temp[(signed long int)vc->comment_lengths[(signed long int)i]] = (char)0;
    print_vorbis_comment(temp, cb, callback_arg);
  }
  free((void *)temp);
}

// print_vorbis_stream_info
// file oggvorbis_format.c line 351
void print_vorbis_stream_info(struct decoder_t *decoder)
{
  struct ovf_private_t *priv = (struct ovf_private_t *)decoder->private;
  struct decoder_callbacks_t *cb = decoder->callbacks;
  _Bool tmp_if_expr_1;
  if(cb == ((struct decoder_callbacks_t *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = cb->printf_metadata == (void (*)(void *, signed int, char *, ...))(void *)0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("Ogg Vorbis stream: %d channel, %ld Hz");
    cb->printf_metadata(decoder->callback_arg, 2, return_value_gettext_2, priv->vi->channels, priv->vi->rate);
    char *return_value_gettext_3;
    return_value_gettext_3=gettext("Vorbis format: Version %d");
    cb->printf_metadata(decoder->callback_arg, 3, return_value_gettext_3, priv->vi->version);
    char *return_value_gettext_4;
    return_value_gettext_4=gettext("Bitrate hints: upper=%ld nominal=%ld lower=%ld window=%ld");
    cb->printf_metadata(decoder->callback_arg, 3, return_value_gettext_4, priv->vi->bitrate_upper, priv->vi->bitrate_nominal, priv->vi->bitrate_lower, priv->vi->bitrate_window);
    char *return_value_gettext_5;
    return_value_gettext_5=gettext("Encoded by: %s");
    cb->printf_metadata(decoder->callback_arg, 3, return_value_gettext_5, priv->vc->vendor);
  }

}

// process_header
// file speex_format.c line 464
void * process_header(struct anonymous_65 *op, signed int *frame_size, struct SpeexHeader **header, struct SpeexStereoState *stereo, struct decoder_callbacks_t *cb, void *callback_arg)
{
  void *st;
  struct SpeexMode *mode;
  signed int modeID;
  struct SpeexCallback callback;
  signed int enhance = 1;
  *header=speex_packet_to_header((char *)op->packet, (signed int)op->bytes);
  if(*header == ((struct SpeexHeader *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("Cannot read header");
    cb->printf_error(callback_arg, 0, return_value_gettext_1);
    return (void *)0;
  }

  _Bool tmp_if_expr_3;
  if((*header)->mode >= 3)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (*header)->mode < 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("Mode number %d does not (any longer) exist in this version");
    cb->printf_error(callback_arg, 0, return_value_gettext_2, (*header)->mode);
    return (void *)0;
  }

  modeID = (*header)->mode;
  mode = speex_mode_list[(signed long int)modeID];
  if(!(mode->bitstream_version >= (*header)->mode_bitstream_version))
  {
    char *return_value_gettext_4;
    return_value_gettext_4=gettext("The file was encoded with a newer version of Speex.\n You need to upgrade in order to play it.\n");
    cb->printf_error(callback_arg, 0, return_value_gettext_4);
    return (void *)0;
  }

  if(!((*header)->mode_bitstream_version >= mode->bitstream_version))
  {
    char *return_value_gettext_5;
    return_value_gettext_5=gettext("The file was encoded with an older version of Speex.\nYou would need to downgrade the version in order to play it.");
    cb->printf_error(callback_arg, 0, return_value_gettext_5);
    return (void *)0;
  }

  st=speex_decoder_init(mode);
  speex_decoder_ctl(st, 0, (void *)&enhance);
  speex_decoder_ctl(st, 3, (void *)frame_size);
  callback.callback_id = 9;
  callback.func = speex_std_stereo_request_handler;
  callback.data = (void *)stereo;
  speex_decoder_ctl(st, 20, (void *)&callback);
  speex_decoder_ctl(st, 24, (void *)&(*header)->rate);
  return st;
}

// progress_callback
// file http_transport.c line 80
signed int progress_callback(void *arg, unsigned long int dltotal, unsigned long int dlnow, unsigned long int ultotal, unsigned long int ulnow)
{
  struct http_private_t *myarg = (struct http_private_t *)arg;
  struct print_statistics_arg_t *pstats_arg;
  struct data_source_t *source = myarg->data_source;
  if(!(myarg->cancel_flag == 0) || !(sig_request.cancel == 0))
    return -1;

  else
  {
    struct data_source_stats_t *return_value;
    return_value=source->transport->statistics(source);
    pstats_arg=new_print_statistics_arg(stat_format, return_value, (struct decoder_stats_t *)(void *)0);
    print_statistics_action((struct buf_t *)(void *)0, (void *)pstats_arg);
    if(!(myarg->cancel_flag == 0) || !(sig_request.cancel == 0))
      return -1;

    else
      return 0;
  }
}

// read_callback
// file flac_format.c line 455
static enum anonymous_23 read_callback(const struct anonymous_19 *decoder, unsigned char *buffer, unsigned long int *bytes, void *client_data)
{
  struct decoder_t *e_decoder = (struct decoder_t *)client_data;
  struct anonymous_21 *priv = (struct anonymous_21 *)e_decoder->private;
  signed int read = 0;
  read=e_decoder->source->transport->read(e_decoder->source, (void *)buffer, sizeof(unsigned char) /*1ul*/ , *bytes);
  *bytes = (unsigned long int)read;
  priv->bytes_read = priv->bytes_read + (signed long int)read;
  if(read == 0)
    return (enum anonymous_23)FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;

  else
    return (enum anonymous_23)FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
}

// read_speex_header
// file speex_format.c line 514
signed int read_speex_header(struct decoder_t *decoder)
{
  struct speex_private_t *priv = (struct speex_private_t *)decoder->private;
  struct transport_t *trans = decoder->source->transport;
  signed int packet_count = 0;
  signed int stream_init = 0;
  char *data;
  signed int nb_read;
  if(!(packet_count >= 2))
  {
    data=ogg_sync_buffer(&priv->oy, (signed long int)200);
    nb_read=trans->read(decoder->source, (void *)data, sizeof(char) /*1ul*/ , (unsigned long int)200);
    ogg_sync_wrote(&priv->oy, (signed long int)nb_read);
    signed int return_value_ogg_sync_pageout_1;
    return_value_ogg_sync_pageout_1=ogg_sync_pageout(&priv->oy, &priv->og);
    if(return_value_ogg_sync_pageout_1 == 1)
    {
      if(stream_init == 0)
      {
        signed int return_value_ogg_page_serialno_2;
        return_value_ogg_page_serialno_2=ogg_page_serialno(&priv->og);
        ogg_stream_init(&priv->os, return_value_ogg_page_serialno_2);
        stream_init = 1;
      }

      ogg_stream_pagein(&priv->os, &priv->og);
      signed int return_value_ogg_stream_packetout_3;
      return_value_ogg_stream_packetout_3=ogg_stream_packetout(&priv->os, &priv->op);
      if(return_value_ogg_stream_packetout_3 == 1)
      {
        if(packet_count == 0)
        {
          priv->st=process_header(&priv->op, &priv->frame_size, &priv->header, priv->stereo, decoder->callbacks, decoder->callback_arg);
          if(priv->st == NULL)
            return 0;

          decoder->actual_fmt.rate = priv->header->rate;
          priv->frames_per_packet = priv->header->frames_per_packet;
          decoder->actual_fmt.channels = priv->header->nb_channels;
          priv->vbr = priv->header->vbr;
          if(priv->frames_per_packet == 0)
            priv->frames_per_packet = 1;

          if(decoder->actual_fmt.channels == 1)
          {
            decoder->actual_fmt.matrix = "M";
            decoder->actual_fmt.matrix = "L,R";
          }

          decoder->actual_fmt.matrix = (char *)(void *)0;
          void *return_value_calloc_4;
          return_value_calloc_4=calloc((unsigned long int)(priv->frame_size * decoder->actual_fmt.channels * priv->frames_per_packet), sizeof(float) /*4ul*/ );
          priv->output = (float *)return_value_calloc_4;
          priv->output_start = 0;
          priv->output_left = 0;
        }

        else
          if(packet_count == 1)
          {
            priv->comment_packet_len = (signed int)priv->op.bytes;
            void *return_value_malloc_5;
            return_value_malloc_5=malloc(sizeof(char) /*1ul*/  * (unsigned long int)priv->comment_packet_len);
            priv->comment_packet = (char *)return_value_malloc_5;
            memcpy((void *)priv->comment_packet, (const void *)priv->op.packet, (unsigned long int)priv->comment_packet_len);
          }

        packet_count = packet_count + 1;
      }

    }

  }

  return 1;
}

// remote_mainloop
// file remote.h line 20
void remote_mainloop(void)
{
  signed int r;
  unsigned long int th;
  enum anonymous_11 s;
  char fname[1025l];
  setlinebuf(stdout);
  send_msg("R ogg123 from vorbis-tools 1.4.0");
  pthread_mutex_init(&main_lock, (const union anonymous_22 *)(void *)0);
  sem_init(&sem_command, 0, (unsigned int)0);
  sem_init(&sem_processed, 0, (unsigned int)0);
  r=pthread_create(&th, (const union pthread_attr_t *)(void *)0, remotethread, (void *)fname);
  if(!(r == 0))
    send_err("E Could not create a thread (code %d)", r);

  else
  {
    pthread_mutex_lock(&main_lock);
    s=getstatus();
    pthread_mutex_unlock(&main_lock);
    while(!((signed int)s == QUIT))
    {
      if(!((signed int)s == NEXT))
      {
        sem_wait(&sem_command);
        pthread_mutex_lock(&main_lock);
        s=getstatus();
        pthread_mutex_unlock(&main_lock);
      }

      if((signed int)s == NEXT)
      {
        send_msg("I %s", (const void *)fname);
        send_msg("S 0.0 0 00000 xxxxxx 0 0 0 0 0 0 0 0");
        send_msg("P 2");
        pthread_mutex_lock(&main_lock);
        setstatus((enum anonymous_11)PLAY);
        s=getstatus();
        sem_post(&sem_processed);
        s=getstatus();
        pthread_mutex_unlock(&main_lock);
        pthread_mutex_lock(&main_lock);
        s=getstatus();
        pthread_mutex_unlock(&main_lock);
        play(fname);
        pthread_mutex_lock(&main_lock);
        s=getstatus();
        pthread_mutex_unlock(&main_lock);
      }

      else
        sem_post(&sem_processed);
    }
    send_msg("Q");
    sem_destroy(&sem_command);
    sem_destroy(&sem_processed);
    goto __CPROVER_DUMP_L7;
  }

__CPROVER_DUMP_L7:
  ;
}

// remote_playloop
// file remote.h line 21
signed int remote_playloop(void)
{
  enum anonymous_11 s;
  pthread_mutex_lock(&main_lock);
  s=getstatus();
  pthread_mutex_unlock(&main_lock);
  if((signed int)s == PAUSE)
  {
    send_msg("P 1");
    while((signed int)s == PAUSE)
    {
      sem_post(&sem_processed);
      sem_wait(&sem_command);
      pthread_mutex_lock(&main_lock);
      s=getstatus();
      pthread_mutex_unlock(&main_lock);
    }
    send_msg("P 2");
  }

  if((signed int)s == STOP || (signed int)s == QUIT)
    send_msg("P 0");

  return (signed int)((signed int)s == NEXT || (signed int)s == STOP || (signed int)s == QUIT);
}

// remote_time
// file remote.h line 22
void remote_time(double current, double total)
{
  send_msg("F 0 0 %.2f %.2f", current, total - current);
}

// remotethread
// file remote.c line 127
static void * remotethread(void *arg)
{
  signed int done = 0;
  signed int error = 0;
  signed int ignore = 0;
  char buf[1025l];
  char *b;
  struct anonymous_14 fd;
  buf[(signed long int)1024] = (char)0;
  signed int return_value_strncasecmp_7;
  signed int return_value_strncasecmp_6;
  signed int return_value_strncasecmp_5;
  signed int return_value_strncasecmp_4;
  signed int return_value_strncasecmp_3;
  signed int return_value_strncasecmp_2;
  while(done == 0)
  {
    buf[(signed long int)0] = (char)0;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fd)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&fd)->fds_bits[(signed long int)(0 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fd)->fds_bits[(signed long int)(0 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << 0 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    select(1, &fd, (struct anonymous_14 *)(void *)0, (struct anonymous_14 *)(void *)0, (struct timeval *)(void *)0);
    fgets(buf, 1024, stdin);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(buf);
    buf[(signed long int)(return_value_strlen_1 - (unsigned long int)1)] = (char)0;
    pthread_mutex_lock(&main_lock);
    error = 0;
    signed int return_value_strncasecmp_8;
    return_value_strncasecmp_8=strncasecmp(buf, "l", (unsigned long int)1);
    if(return_value_strncasecmp_8 == 0)
    {
      b=strchr(buf, 32);
      if(!(b == ((char *)NULL)))
      {
        strcpy((char *)arg, b + (signed long int)1);
        setstatus((enum anonymous_11)NEXT);
      }

      else
        error = 1;
    }

    else
    {
      return_value_strncasecmp_7=strncasecmp(buf, "p", (unsigned long int)1);
      if(return_value_strncasecmp_7 == 0)
        invertpause();

      else
      {
        return_value_strncasecmp_6=strncasecmp(buf, "j", (unsigned long int)1);
        if(return_value_strncasecmp_6 == 0)
        {
          b=strchr(buf, 32);
          if(!(b == ((char *)NULL)))
            set_seek_opt(&options, b + (signed long int)1);

          ignore = 1;
        }

        else
        {
          return_value_strncasecmp_5=strncasecmp(buf, "s", (unsigned long int)1);
          if(return_value_strncasecmp_5 == 0)
            setstatus((enum anonymous_11)STOP);

          else
          {
            return_value_strncasecmp_4=strncasecmp(buf, "r", (unsigned long int)1);
            if(return_value_strncasecmp_4 == 0)
              setstatus((enum anonymous_11)NEXT);

            else
            {
              return_value_strncasecmp_3=strncasecmp(buf, "h", (unsigned long int)1);
              if(return_value_strncasecmp_3 == 0)
              {
                send_msg("H +----------------------------------------------------+");
                send_msg("H | Ogg123 remote interface                            |");
                send_msg("H |----------------------------------------------------|");
                send_msg("H | Load <file>     -  load a file and starts playing  |");
                send_msg("H | Pause           -  pause or unpause playing        |");
                send_msg("H | Jump [+|-]<f>   -  jump <f> seconds forth or back  |");
                send_msg("H | Stop            -  stop playing                    |");
                send_msg("H | Reload          -  reload last song                |");
                send_msg("H | Quit            -  quit ogg123                     |");
                send_msg("H |----------------------------------------------------|");
                send_msg("H | refer to README.remote for documentation           |");
                send_msg("H +----------------------------------------------------+");
                ignore = 1;
              }

              else
              {
                return_value_strncasecmp_2=strncasecmp(buf, "q", (unsigned long int)1);
                if(return_value_strncasecmp_2 == 0)
                {
                  setstatus((enum anonymous_11)QUIT);
                  done = 1;
                }

                else
                  error = 1;
              }
            }
          }
        }
      }
    }
    if(!(ignore == 0))
    {
      pthread_mutex_unlock(&main_lock);
      ignore = 0;
    }

    else
      if(!(error == 0))
      {
        send_err("E Unknown command '%s'", (const void *)buf);
        pthread_mutex_unlock(&main_lock);
      }

      else
      {
        sem_post(&sem_command);
        pthread_mutex_unlock(&main_lock);
        sem_wait(&sem_processed);
      }
  }
  return (void *)0;
}

// resize_buffer
// file flac_format.c line 552
void resize_buffer(struct anonymous_21 *flac, signed int newchannels, signed int newsamples)
{
  signed int i;
  void *return_value_malloc_2;
  if(newchannels == (signed int)flac->channels)
  {
    if(!(newsamples == flac->buf_len))
      goto __CPROVER_DUMP_L1;

    flac->buf_start = 0;
    flac->buf_fill = 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(newchannels == (signed int)flac->channels))
    {
      i = 0;
      for( ; !(i >= (signed int)flac->channels); i = i + 1)
        free((void *)flac->buf[(signed long int)i]);
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)flac->buf, sizeof(signed int *) /*8ul*/  * (unsigned long int)newchannels);
      flac->buf = (signed int **)return_value_realloc_1;
      flac->channels = (signed short int)newchannels;
    }

    i = 0;
    for( ; !(i >= newchannels); i = i + 1)
    {
      return_value_malloc_2=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)newsamples);
      flac->buf[(signed long int)i] = (signed int *)return_value_malloc_2;
    }
    flac->buf_len = newsamples;
    flac->buf_start = 0;
    flac->buf_fill = 0;
  }
}

// select_format
// file format.c line 64
struct format_t * select_format(struct data_source_t *source)
{
  signed int i = 0;
  signed int return_value;
  if(!(formats[(signed long int)i] == ((struct format_t *)NULL)))
  {
    return_value=formats[(signed long int)i]->can_decode(source);
    if(return_value == 0)
      i = i + 1;

  }

  return formats[(signed long int)i];
}

// select_stats
// file ogg123.c line 248
void select_stats(struct anonymous_3 *stats, struct ogg123_options_t *opts, struct data_source_t *source, struct decoder_t *decoder, struct buf_t *audio_buffer)
{
  struct data_source_stats_t *data_source_stats;
  if(!(audio_buffer == ((struct buf_t *)NULL)))
  {
    (stats + (signed long int)8)->enabled = (char)1;
    (stats + (signed long int)9)->enabled = (char)1;
  }

  else
  {
    (stats + (signed long int)8)->enabled = (char)0;
    (stats + (signed long int)9)->enabled = (char)0;
  }
  data_source_stats=source->transport->statistics(source);
  if(!(data_source_stats->input_buffer_used == 0))
  {
    (stats + (signed long int)6)->enabled = (char)1;
    (stats + (signed long int)7)->enabled = (char)1;
  }

  else
  {
    (stats + (signed long int)6)->enabled = (char)0;
    (stats + (signed long int)7)->enabled = (char)0;
  }
  free((void *)data_source_stats);
  (stats + (signed long int)2)->enabled = (char)1;
  (stats + (signed long int)3)->enabled = (char)1;
}

// select_transport
// file transport.h line 58
struct transport_t * select_transport(char *source)
{
  signed int i = 0;
  signed int return_value;
  if(!(transports[(signed long int)i] == ((struct transport_t *)NULL)))
  {
    return_value=transports[(signed long int)i]->can_transport(source);
    if(return_value == 0)
      i = i + 1;

  }

  return transports[(signed long int)i];
}

// send_err
// file remote.c line 94
static void send_err(const char *fmt, ...)
{
  void **ap;
  pthread_mutex_lock(&output_lock_link1);
  fprintf(stderr, "@");
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  fprintf(stderr, "\n");
  pthread_mutex_unlock(&output_lock_link1);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// send_msg
// file remote.c line 81
static void send_msg(const char *fmt, ...)
{
  void **ap;
  pthread_mutex_lock(&output_lock_link1);
  fprintf(stdout, "@");
  ap = (void **)&fmt;
  vfprintf(stdout, fmt, ap);
  ap = ((void **)NULL);
  fprintf(stdout, "\n");
  pthread_mutex_unlock(&output_lock_link1);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// set_curl_opts
// file http_transport.c line 105
void set_curl_opts(struct http_private_t *private)
{
  void *handle = private->curl_handle;
  signed int set_curl_opts__1__1___curl_opt = CURLOPT_WRITEDATA;
  curl_easy_setopt(handle, (enum anonymous_4)set_curl_opts__1__1___curl_opt, private);
  signed int set_curl_opts__1__2___curl_opt = CURLOPT_WRITEFUNCTION;
  curl_easy_setopt(handle, (enum anonymous_4)set_curl_opts__1__2___curl_opt, write_callback);
  signed int set_curl_opts__1__3___curl_opt = CURLOPT_URL;
  curl_easy_setopt(handle, (enum anonymous_4)set_curl_opts__1__3___curl_opt, private->data_source->source_string);
  signed int set_curl_opts__1__4___curl_opt = CURLOPT_ERRORBUFFER;
  curl_easy_setopt(handle, (enum anonymous_4)set_curl_opts__1__4___curl_opt, (const void *)private->error);
  signed int set_curl_opts__1__5___curl_opt = CURLOPT_PROGRESSFUNCTION;
  curl_easy_setopt(handle, (enum anonymous_4)set_curl_opts__1__5___curl_opt, progress_callback);
  signed int set_curl_opts__1__6___curl_opt = CURLOPT_PROGRESSDATA;
  curl_easy_setopt(handle, (enum anonymous_4)set_curl_opts__1__6___curl_opt, private);
  signed int _curl_opt = CURLOPT_NOPROGRESS;
  curl_easy_setopt(handle, (enum anonymous_4)_curl_opt, 0);
  signed int set_curl_opts__1__8___curl_opt = CURLOPT_USERAGENT;
  curl_easy_setopt(handle, (enum anonymous_4)set_curl_opts__1__8___curl_opt, (const void *)"ogg123/1.4.0");
  signed int set_curl_opts__1__9___curl_opt = CURLOPT_HTTPHEADER;
  curl_easy_setopt(handle, (enum anonymous_4)set_curl_opts__1__9___curl_opt, private->header_list);
  signed int set_curl_opts__1__10___curl_opt = CURLOPT_FOLLOWLOCATION;
  curl_easy_setopt(handle, (enum anonymous_4)set_curl_opts__1__10___curl_opt, 1);
}

// set_seek_opt
// file ogg123.c line 182
void set_seek_opt(struct ogg123_options_t *ogg123_opts, char *buf)
{
  char *b = buf;
  for( ; !(*b == 0); b = b + 1l)
    if(!((signed int)*b == 32))
      break;

  if((signed int)*b == 45)
  {
    double return_value_strtotime_1;
    return_value_strtotime_1=strtotime(b + (signed long int)1);
    ogg123_opts->seekoff = (double)-1 * return_value_strtotime_1;
    ogg123_opts->seekmode = 2;
  }

  else
    if((signed int)*b == 43)
    {
      ogg123_opts->seekoff=strtotime(b + (signed long int)1);
      ogg123_opts->seekmode = 2;
    }

    else
    {
      ogg123_opts->seekoff=strtotime(b);
      ogg123_opts->seekmode = 1;
    }
}

// setstatus
// file remote.c line 111
static void setstatus(enum anonymous_11 s)
{
  status = s;
}

// signal_handler
// file ogg123.c line 98
void signal_handler(signed int signo)
{
  struct timeval tv;
  signed long int now;
  switch(signo)
  {
    case 2:
    {
      gettimeofday(&tv, ((struct timezone *)NULL));
      now = (signed long int)tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000;
      if(options.delay >= now + -sig_request.last_ctrl_c)
        sig_request.exit = 1;

      else
        sig_request.skipfile = 1;
      sig_request.cancel = 1;
      sig_request.last_ctrl_c = now;
      goto __CPROVER_DUMP_L6;
    }
    case 15:
    {
      sig_request.exit = 1;
      goto __CPROVER_DUMP_L6;
    }
    case 20:
      sig_request.pause = 1;
    case 18:

    default:

      __CPROVER_DUMP_L6:
        ;
  }
}

// speex_can_decode
// file speex_format.c line 100
signed int speex_can_decode(struct data_source_t *source)
{
  char buf[36l];
  signed int len;
  len=source->transport->peek(source, (void *)buf, sizeof(char) /*1ul*/ , (unsigned long int)36);
  _Bool tmp_if_expr_2;
  signed int return_value_memcmp_1;
  if(len >= 32)
  {
    return_value_memcmp_1=memcmp((const void *)buf, (const void *)"OggS", (unsigned long int)4);
    tmp_if_expr_2 = return_value_memcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_4;
  signed int return_value_memcmp_3;
  if(tmp_if_expr_2)
  {
    return_value_memcmp_3=memcmp((const void *)(buf + (signed long int)28), (const void *)"Speex   ", (unsigned long int)8);
    tmp_if_expr_4 = return_value_memcmp_3 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  if(tmp_if_expr_4)
    return 1;

  else
    return 0;
}

// speex_cleanup
// file speex_format.c line 328
void speex_cleanup(struct decoder_t *decoder)
{
  struct speex_private_t *priv = (struct speex_private_t *)decoder->private;
  speex_stereo_state_destroy(priv->stereo);
  free((void *)priv->comment_packet);
  free((void *)priv->output);
  free(decoder->private);
  free((void *)decoder);
}

// speex_init
// file speex_format.c line 115
struct decoder_t * speex_init(struct data_source_t *source, struct ogg123_options_t *ogg123_opts, struct audio_format_t *audio_fmt, struct decoder_callbacks_t *callbacks, void *callback_arg)
{
  struct decoder_t *decoder;
  struct speex_private_t *private;
  signed int ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct decoder_t) /*104ul*/ );
  decoder = (struct decoder_t *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct speex_private_t) /*728ul*/ );
  private = (struct speex_private_t *)return_value_malloc_2;
  if(!(decoder == ((struct decoder_t *)NULL)) && !(private == ((struct speex_private_t *)NULL)))
  {
    decoder->source = source;
    decoder->request_fmt = *audio_fmt;
    decoder->actual_fmt = decoder->request_fmt;
    decoder->format = &speex_format;
    decoder->callbacks = callbacks;
    decoder->callback_arg = callback_arg;
    decoder->private = (void *)private;
    private->bos = 1;
    private->eof = 0;
    private->samples_decoded_previous = (signed long int)0;
    private->samples_decoded = private->samples_decoded_previous;
    private->bytes_read_previous = (signed long int)0;
    private->bytes_read = private->bytes_read_previous;
    private->currentsample = (signed long int)0;
    private->comment_packet = (char *)(void *)0;
    private->comment_packet_len = 0;
    private->header = (struct SpeexHeader *)(void *)0;
    private->stereo=speex_stereo_state_init();
    private->stats.total_time = 0.0;
    private->stats.current_time = 0.0;
    private->stats.instant_bitrate = (signed long int)0;
    private->stats.avg_bitrate = (signed long int)0;
  }

  else
  {
    char *return_value_gettext_3;
    return_value_gettext_3=gettext("ERROR: Out of memory.\n");
    fprintf(stderr, return_value_gettext_3);
    exit(1);
  }
  ogg_sync_init(&private->oy);
  speex_bits_init(&private->bits);
  ret = 1;
  if(!(ret >= 0))
  {
    free((void *)private);
    return (struct decoder_t *)(void *)0;
  }

  else
    return decoder;
}

// speex_read
// file speex_format.c line 171
signed int speex_read(struct decoder_t *decoder, void *ptr, signed int nbytes, signed int *eos, struct audio_format_t *audio_fmt)
{
  struct speex_private_t *priv = (struct speex_private_t *)decoder->private;
  struct decoder_callbacks_t *cb = decoder->callbacks;
  struct transport_t *trans = decoder->source->transport;
  signed int bytes_requested = nbytes;
  signed int ret;
  signed short int *out = (signed short int *)ptr;
  if(!(priv->bos == 0))
  {
    ret=read_speex_header(decoder);
    if(ret == 0)
    {
      *eos = 1;
      return 0;
    }

    print_speex_info(priv->header, cb, decoder->callback_arg);
    if(!(priv->comment_packet == ((char *)NULL)))
      print_speex_comments(priv->comment_packet, priv->comment_packet_len, cb, decoder->callback_arg);

    priv->bos = 0;
  }

  *audio_fmt = decoder->actual_fmt;
  signed int tmp_if_expr_1;
  signed int return_value_ogg_stream_packetout_3;
  signed int return_value_ogg_sync_pageout_2;
  while(!(nbytes == 0))
  {
    char *data;
    signed int i;
    signed int j;
    signed int nb_read;
    if(priv->output_left >= 1)
    {
      signed int to_copy = nbytes / (2 * audio_fmt->channels);
      to_copy = to_copy * audio_fmt->channels;
      if(!(priv->output_left >= to_copy))
        tmp_if_expr_1 = priv->output_left;

      else
        tmp_if_expr_1 = to_copy;
      to_copy = tmp_if_expr_1;
      i = 0;
      for( ; !(i >= to_copy); i = i + 1)
        out[(signed long int)i] = (signed short int)priv->output[(signed long int)(i + priv->output_start)];
      out = out + (signed long int)to_copy;
      priv->output_start = priv->output_start + to_copy;
      priv->output_left = priv->output_left - to_copy;
      priv->currentsample = priv->currentsample + (signed long int)(to_copy / audio_fmt->channels);
      nbytes = nbytes - to_copy * 2;
    }

    else
    {
      return_value_ogg_stream_packetout_3=ogg_stream_packetout(&priv->os, &priv->op);
      if(return_value_ogg_stream_packetout_3 == 1)
      {
        float *temp_output = priv->output;
        speex_bits_read_from(&priv->bits, (char *)priv->op.packet, (signed int)priv->op.bytes);
        j = 0;
        for( ; !(j >= priv->frames_per_packet); j = j + 1)
        {
          speex_decode(priv->st, &priv->bits, temp_output);
          if(audio_fmt->channels == 2)
            speex_decode_stereo(temp_output, priv->frame_size, priv->stereo);

          priv->samples_decoded = priv->samples_decoded + (signed long int)priv->frame_size;
          i = 0;
          for( ; !(i >= audio_fmt->channels * priv->frame_size); i = i + 1)
            if(temp_output[(signed long int)i] > 32000.000000f)
              temp_output[(signed long int)i] = (float)32000.0;

            else
              if(temp_output[(signed long int)i] < -32000.000000f)
                temp_output[(signed long int)i] = (float)-32000.0;

          temp_output = temp_output + (signed long int)(priv->frame_size * audio_fmt->channels);
        }
        priv->output_start = 0;
        priv->output_left = priv->frame_size * audio_fmt->channels * priv->frames_per_packet;
      }

      else
      {
        return_value_ogg_sync_pageout_2=ogg_sync_pageout(&priv->oy, &priv->og);
        if(return_value_ogg_sync_pageout_2 == 1)
          ogg_stream_pagein(&priv->os, &priv->og);

        else
          if(priv->eof == 0)
          {
            data=ogg_sync_buffer(&priv->oy, (signed long int)200);
            nb_read=trans->read(decoder->source, (void *)data, sizeof(char) /*1ul*/ , (unsigned long int)200);
            if(nb_read == 0)
              priv->eof = 1;

            ogg_sync_wrote(&priv->oy, (signed long int)nb_read);
            priv->bytes_read = priv->bytes_read + (signed long int)nb_read;
          }

          else
          {
            *eos = 1;
            break;
          }
      }
    }
  }
  return bytes_requested - nbytes;
}

// speex_seek
// file speex_format.c line 283
signed int speex_seek(struct decoder_t *decoder, double offset, signed int whence)
{
  struct speex_private_t *priv = (struct speex_private_t *)decoder->private;
  return 0;
}

// speex_statistics
// file speex_format.c line 293
struct decoder_stats_t * speex_statistics(struct decoder_t *decoder)
{
  struct speex_private_t *priv = (struct speex_private_t *)decoder->private;
  signed long int instant_bitrate;
  signed long int avg_bitrate;
  priv->stats.total_time = (double)priv->totalsamples / (double)decoder->actual_fmt.rate;
  priv->stats.current_time = (double)priv->currentsample / (double)decoder->actual_fmt.rate;
  if(!(priv->bytes_read == priv->bytes_read_previous))
  {
    if(!(priv->samples_decoded == priv->samples_decoded_previous))
    {
      instant_bitrate = (signed long int)((8.0 * (double)(priv->bytes_read - priv->bytes_read_previous) * (double)decoder->actual_fmt.rate) / (double)(priv->samples_decoded - priv->samples_decoded_previous));
      priv->stats.instant_bitrate = (signed long int)(0.7 * (double)instant_bitrate + (1.0 - 0.7) * (double)priv->stats.instant_bitrate);
      priv->bytes_read_previous = priv->bytes_read;
      priv->samples_decoded_previous = priv->samples_decoded;
    }

  }

  priv->stats.avg_bitrate = (signed long int)0;
  struct decoder_stats_t *return_value_malloc_decoder_stats_1;
  return_value_malloc_decoder_stats_1=malloc_decoder_stats(&priv->stats);
  return return_value_malloc_decoder_stats_1;
}

// sprintf_clear_line
// file status.c line 105
signed int sprintf_clear_line(signed int len, char *buf)
{
  signed int i = 0;
  buf[(signed long int)i] = (char)13;
  i = i + 1;
  for( ; len >= 1; i = i + 1)
  {
    buf[(signed long int)i] = (char)32;
    len = len - 1;
  }
  buf[(signed long int)i] = (char)13;
  i = i + 1;
  buf[(signed long int)i] = (char)0;
  return i;
}

// stat_format_cleanup
// file status.c line 336
void stat_format_cleanup(struct anonymous_3 *stats)
{
  free((void *)(stats + (signed long int)1)->arg.stringarg);
  free((void *)(stats + (signed long int)2)->arg.stringarg);
  free((void *)(stats + (signed long int)3)->arg.stringarg);
  free((void *)(stats + (signed long int)7)->arg.stringarg);
  free((void *)(stats + (signed long int)9)->arg.stringarg);
  free((void *)stats);
}

// stat_format_create
// file status.h line 59
struct anonymous_3 * stat_format_create()
{
  struct anonymous_3 *stats;
  struct anonymous_3 *cur;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(10 + 1), sizeof(struct anonymous_3) /*32ul*/ );
  stats = (struct anonymous_3 *)return_value_calloc_1;
  if(stats == ((struct anonymous_3 *)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("Memory allocation error in stats_init()\n");
    fprintf(stderr, return_value_gettext_2);
    exit(1);
  }

  cur = stats + (signed long int)0;
  cur->verbosity = 3;
  cur->enabled = (char)0;
  cur->formatstr=gettext("File: %s");
  cur->type = (enum anonymous_67)stat_stringarg;
  cur = stats + (signed long int)1;
  cur->verbosity = 1;
  cur->enabled = (char)1;
  cur->formatstr=gettext("Time: %s");
  cur->type = (enum anonymous_67)stat_stringarg;
  void *return_value_calloc_3;
  return_value_calloc_3=calloc((unsigned long int)20, sizeof(char) /*1ul*/ );
  cur->arg.stringarg = (char *)return_value_calloc_3;
  if(cur->arg.stringarg == ((char *)NULL))
  {
    char *return_value_gettext_4;
    return_value_gettext_4=gettext("Memory allocation error in stats_init()\n");
    fprintf(stderr, return_value_gettext_4);
    exit(1);
  }

  write_time_string(cur->arg.stringarg, 0.0);
  cur = stats + (signed long int)2;
  cur->verbosity = 1;
  cur->enabled = (char)1;
  cur->formatstr = "[%s]";
  cur->type = (enum anonymous_67)stat_stringarg;
  void *return_value_calloc_5;
  return_value_calloc_5=calloc((unsigned long int)20, sizeof(char) /*1ul*/ );
  cur->arg.stringarg = (char *)return_value_calloc_5;
  if(cur->arg.stringarg == ((char *)NULL))
  {
    char *return_value_gettext_6;
    return_value_gettext_6=gettext("Memory allocation error in stats_init()\n");
    fprintf(stderr, return_value_gettext_6);
    exit(1);
  }

  write_time_string(cur->arg.stringarg, 0.0);
  cur = stats + (signed long int)3;
  cur->verbosity = 1;
  cur->enabled = (char)1;
  cur->formatstr=gettext("of %s");
  cur->type = (enum anonymous_67)stat_stringarg;
  void *return_value_calloc_7;
  return_value_calloc_7=calloc((unsigned long int)20, sizeof(char) /*1ul*/ );
  cur->arg.stringarg = (char *)return_value_calloc_7;
  if(cur->arg.stringarg == ((char *)NULL))
  {
    char *return_value_gettext_8;
    return_value_gettext_8=gettext("Memory allocation error in stats_init()\n");
    fprintf(stderr, return_value_gettext_8);
    exit(1);
  }

  write_time_string(cur->arg.stringarg, 0.0);
  cur = stats + (signed long int)4;
  cur->verbosity = 2;
  cur->enabled = (char)1;
  cur->formatstr = " (%5.1f kbps)";
  cur->type = (enum anonymous_67)stat_doublearg;
  cur = stats + (signed long int)5;
  cur->verbosity = 2;
  cur->enabled = (char)0;
  cur->formatstr=gettext("Avg bitrate: %5.1f");
  cur->type = (enum anonymous_67)stat_doublearg;
  cur = stats + (signed long int)6;
  cur->verbosity = 2;
  cur->enabled = (char)0;
  cur->formatstr=gettext(" Input Buffer %5.1f%%");
  cur->type = (enum anonymous_67)stat_doublearg;
  cur = stats + (signed long int)7;
  cur->verbosity = 2;
  cur->enabled = (char)0;
  cur->formatstr = "%s";
  cur->type = (enum anonymous_67)stat_stringarg;
  void *return_value_calloc_9;
  return_value_calloc_9=calloc((unsigned long int)25, sizeof(char) /*1ul*/ );
  cur->arg.stringarg = (char *)return_value_calloc_9;
  if(cur->arg.stringarg == ((char *)NULL))
  {
    char *return_value_gettext_10;
    return_value_gettext_10=gettext("Memory allocation error in stats_init()\n");
    fprintf(stderr, return_value_gettext_10);
    exit(1);
  }

  cur = stats + (signed long int)8;
  cur->verbosity = 2;
  cur->enabled = (char)0;
  cur->formatstr=gettext(" Output Buffer %5.1f%%");
  cur->type = (enum anonymous_67)stat_doublearg;
  cur = stats + (signed long int)9;
  cur->verbosity = 1;
  cur->enabled = (char)0;
  cur->formatstr = "%s";
  cur->type = (enum anonymous_67)stat_stringarg;
  void *return_value_calloc_11;
  return_value_calloc_11=calloc((unsigned long int)25, sizeof(char) /*1ul*/ );
  cur->arg.stringarg = (char *)return_value_calloc_11;
  if(cur->arg.stringarg == ((char *)NULL))
  {
    char *return_value_gettext_12;
    return_value_gettext_12=gettext("Memory allocation error in stats_init()\n");
    fprintf(stderr, return_value_gettext_12);
    exit(1);
  }

  cur = stats + (signed long int)10;
  cur->formatstr = (const char *)(void *)0;
  return stats;
}

// status_clear_line
// file status.c line 369
void status_clear_line()
{
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = unlock_output_lock;
    void *__cancel_arg = (void *)0;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&output_lock);
      clear_line(last_line_len);
      pthread_mutex_unlock(&output_lock);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// status_deinit
// file status.h line 63
void status_deinit()
{
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(2, 3);
  fcntl(2, 4, return_value_fcntl_1 & ~04000);
}

// status_error
// file status.h line 72
void status_error(const char *fmt, ...)
{
  void **ap;
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = unlock_output_lock;
    void *__cancel_arg = (void *)0;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&output_lock);
      ap = (void **)&fmt;
      clear_line(last_line_len);
      vstatus_print_nolock(fmt, ap);
      ap = ((void **)NULL);
      pthread_mutex_unlock(&output_lock);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
  exit_status = 1;
}

// status_error_action
// file callbacks.c line 248
void status_error_action(struct buf_t *buf, void *arg)
{
  struct status_message_arg_t *myarg = (struct status_message_arg_t *)arg;
  status_error("%s", myarg->message);
  free((void *)myarg->message);
  free((void *)myarg);
}

// status_init
// file status.h line 62
void status_init(signed int verbosity)
{
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(2, 3);
  fcntl(2, 4, return_value_fcntl_1 | 04000);
  max_verbosity = verbosity;
}

// status_message
// file status.h line 70
void status_message(signed int verbosity, const char *fmt, ...)
{
  void **ap;
  if(max_verbosity >= verbosity)
    do
    {
      struct anonymous_10 __cancel_buf;
      void (*__cancel_routine)(void *) = unlock_output_lock;
      void *__cancel_arg = (void *)0;
      signed int __not_first_call;
      __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)__not_first_call == 0l))
      {
        __cancel_routine(__cancel_arg);
        __pthread_unwind_next(&__cancel_buf);
      }

      __pthread_register_cancel(&__cancel_buf);
      do
      {
        pthread_mutex_lock(&output_lock);
        clear_line(last_line_len);
        ap = (void **)&fmt;
        vstatus_print_nolock(fmt, ap);
        ap = ((void **)NULL);
        pthread_mutex_unlock(&output_lock);

      __CPROVER_DUMP_L4:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&__cancel_buf);
    }
    while((_Bool)0);

}

// status_message_action
// file callbacks.c line 259
void status_message_action(struct buf_t *buf, void *arg)
{
  struct status_message_arg_t *myarg = (struct status_message_arg_t *)arg;
  status_message(myarg->verbosity, "%s", myarg->message);
  free((void *)myarg->message);
  free((void *)myarg);
}

// status_print_statistics
// file status.h line 66
void status_print_statistics(struct anonymous_3 *stats, struct buffer_stats_t *audio_statistics, struct data_source_stats_t *transport_statistics, struct decoder_stats_t *decoder_statistics)
{
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = unlock_output_lock;
    void *__cancel_arg = (void *)0;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&output_lock);
      if(return_value_pthread_mutex_trylock_1 == 0)
      {
        if(!(decoder_statistics == ((struct decoder_stats_t *)NULL)))
        {
          write_time_string((stats + (signed long int)1)->arg.stringarg, decoder_statistics->current_time);
          write_time_string((stats + (signed long int)2)->arg.stringarg, decoder_statistics->total_time - decoder_statistics->current_time);
          write_time_string((stats + (signed long int)3)->arg.stringarg, decoder_statistics->total_time);
          (stats + (signed long int)4)->arg.doublearg = (double)((float)decoder_statistics->instant_bitrate / 1000.0f);
          (stats + (signed long int)5)->arg.doublearg = (double)((float)decoder_statistics->avg_bitrate / 1000.0f);
        }

        if(!(transport_statistics == ((struct data_source_stats_t *)NULL)))
        {
          if(!(transport_statistics->input_buffer_used == 0))
          {
            (stats + (signed long int)6)->arg.doublearg = transport_statistics->input_buffer.fill;
            write_buffer_state_string((stats + (signed long int)7)->arg.stringarg, &transport_statistics->input_buffer);
          }

        }

        if(!(audio_statistics == ((struct buffer_stats_t *)NULL)))
        {
          (stats + (signed long int)8)->arg.doublearg = audio_statistics->fill;
          write_buffer_state_string((stats + (signed long int)9)->arg.stringarg, audio_statistics);
        }

        last_line_len=print_statistics_line(stats);
        pthread_mutex_unlock(&output_lock);
      }


    __CPROVER_DUMP_L7:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
}

// status_reset_output_lock
// file status.h line 64
void status_reset_output_lock()
{
  pthread_mutex_unlock(&output_lock);
}

// strtotime
// file ogg123.c line 170
double strtotime(char *s)
{
  double strtotime__1__time;
  strtotime__1__time=strtod(s, &s);
  double return_value_strtod_1;
  for( ; (signed int)*s == 58; strtotime__1__time = (double)60 * strtotime__1__time + return_value_strtod_1)
    return_value_strtod_1=strtod(s + (signed long int)1, &s);
  return strtotime__1__time;
}

// submit_data_chunk
// file buffer.c line 310
signed int submit_data_chunk(struct buf_t *buf, char *data, unsigned long int size)
{
  signed long int buf_write_pos;
  unsigned long int write_size;
  signed long int tmp_if_expr_1;
  unsigned long int tmp_if_expr_3;
  signed long int tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = buffer_mutex_unlock;
    void *__cancel_arg = (void *)buf;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);

  __CPROVER_DUMP_L3:
    ;
    do
    {
      if(size >= 1ul)
      {
        if(buf->abort_write == 0)
        {
          pthread_mutex_lock(&buf->mutex);
          if(buf->size + -buf->curfill >= 1l)
          {
            buf_write_pos = (buf->start + buf->curfill) % buf->size;
            if(!(buf->size + -buf->curfill >= buf->size + -buf_write_pos))
              tmp_if_expr_1 = buf->size - buf->curfill;

            else
              tmp_if_expr_1 = buf->size - buf_write_pos;
            if(!(size >= (unsigned long int)tmp_if_expr_1))
              tmp_if_expr_3 = size;

            else
            {
              if(!(buf->size + -buf->curfill >= buf->size + -buf_write_pos))
                tmp_if_expr_2 = buf->size - buf->curfill;

              else
                tmp_if_expr_2 = buf->size - buf_write_pos;
              tmp_if_expr_3 = (unsigned long int)tmp_if_expr_2;
            }
            write_size = tmp_if_expr_3;
            memcpy((void *)(buf->buffer + buf_write_pos), (const void *)data, write_size);
            buf->curfill = buf->curfill + (signed long int)write_size;
            data = data + (signed long int)write_size;
            size = size - write_size;
            buf->position_end = buf->position_end + (signed long int)write_size;
          }

          else
          {
            if(!(buf->cancel_flag == 0) || !(sig_request.cancel == 0))
            {
              pthread_mutex_unlock(&buf->mutex);
              goto __CPROVER_DUMP_L17;
            }

            pthread_cond_wait(&buf->write_cond, &buf->mutex);
          }
          if(!(buf->prebuffering == 0))
          {
            if(buf->curfill >= buf->prebuffer_size)
              buf->prebuffering = 0;

          }

          if(buf->prebuffering == 0)
            tmp_if_expr_4 = !(buf->paused != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
            pthread_cond_signal(&buf->playback_cond);

          pthread_mutex_unlock(&buf->mutex);
          goto __CPROVER_DUMP_L3;
        }

      }


    __CPROVER_DUMP_L17:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
  return (signed int)!(buf->abort_write != 0);
}

// unlock_output_lock
// file status.c line 48
void unlock_output_lock(void *arg)
{
  pthread_mutex_unlock(&output_lock);
}

// utf8_decode
// file ../include/utf8.h line 30
signed int utf8_decode(const char *from, char **to)
{
  char *charset;
  if((signed int)*from == 0)
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)1);
    *to = (char *)return_value_malloc_1;
    *(*to) = (char)0;
    return 1;
  }

  if(current_charset == ((char *)NULL))
    convert_set_charset(((const char *)NULL));

  charset = current_charset != ((char *)NULL) ? current_charset : "US-ASCII";
  signed int return_value_convert_string_2;
  return_value_convert_string_2=convert_string("UTF-8", charset, from, to, (char)63);
  return return_value_convert_string_2;
}

// utf8_encode
// file utf8.c line 298
signed int utf8_encode(const char *from, char **to)
{
  char *charset;
  if(current_charset == ((char *)NULL))
    convert_set_charset(((const char *)NULL));

  charset = current_charset != ((char *)NULL) ? current_charset : "US-ASCII";
  signed int return_value_convert_string_1;
  return_value_convert_string_1=convert_string(charset, "UTF-8", from, to, (char)35);
  return return_value_convert_string_1;
}

// utf8_validate
// file utf8.c line 359
signed int utf8_validate(const char *s)
{
  unsigned long int len;
  len=strlen(s);
  while(!(len == 0ul))
  {
    signed int i = 0;
    for( ; !((unsigned long int)i >= 6ul); i = i + 1)
      if(((signed int)*s & (signed int)test[(signed long int)i].mask) == (signed int)test[(signed long int)i].value)
      {
        unsigned int after = test[(signed long int)i].after;
        if(!(len >= (unsigned long int)(1u + after)))
          return 0;

        signed int return_value_checknext_1;
        return_value_checknext_1=checknext(s + (signed long int)1, (signed int)after);
        if(return_value_checknext_1 == 0)
          return 0;

        s = s + (signed long int)(after + (unsigned int)1);
        len = len - (unsigned long int)(after + (unsigned int)1);
        goto next;
      }

    return 0;

  next:
    ;
  }
  return 1;
}

// vg_filter
// file vgfilter.h line 65
extern void vg_filter(float **pcm, signed long int channels, signed long int samples, void *filter_param)
{
  signed int i;
  signed int j;
  float cur_sample;
  struct anonymous_5 *param = (struct anonymous_5 *)filter_param;
  float scale_factor = param->scale_factor;
  float max_scale = param->max_scale;
  double return_value_tanh_1;
  double return_value_tanh_2;
  if(scale_factor > max_scale)
  {
    i = 0;
    for( ; !((signed long int)i >= channels); i = i + 1)
    {
      j = 0;
      for( ; !((signed long int)j >= samples); j = j + 1)
      {
        cur_sample = pcm[(signed long int)i][(signed long int)j] * scale_factor;
        if(cur_sample < -5.000000e-1f)
        {
          return_value_tanh_1=tanh(((double)cur_sample + 0.5) / ((double)1 - 0.5));
          cur_sample = (float)(return_value_tanh_1 * ((double)1 - 0.5) - 0.5);
        }

        else
          if(cur_sample > 5.000000e-1f)
          {
            return_value_tanh_2=tanh(((double)cur_sample - 0.5) / ((double)1 - 0.5));
            cur_sample = (float)(return_value_tanh_2 * ((double)1 - 0.5) + 0.5);
          }

        pcm[(signed long int)i][(signed long int)j] = cur_sample;
      }
    }
  }

  else
    if(scale_factor > 0.000000f)
    {
      i = 0;
      for( ; !((signed long int)i >= channels); i = i + 1)
      {
        j = 0;
        for( ; !((signed long int)j >= samples); j = j + 1)
          pcm[(signed long int)i][(signed long int)j] = pcm[(signed long int)i][(signed long int)j] * scale_factor;
      }
    }

}

// vg_init
// file vgfilter.h line 62
extern void vg_init(struct anonymous_5 *vg, struct vorbis_comment *vc)
{
  float track_gain_db = (float)0.00;
  float track_peak = (float)1.00;
  char *tag = (char *)(void *)0;
  _Bool tmp_if_expr_4;
  double return_value_atof_1;
  _Bool tmp_if_expr_3;
  double return_value_atof_2;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  double return_value_atof_5;
  if(!(vc == ((struct vorbis_comment *)NULL)))
  {
    tag=vorbis_comment_query(vc, "replaygain_album_gain", 0);
    if(!(tag == ((char *)NULL)))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      tag=vorbis_comment_query(vc, "rg_audiophile", 0);
      tmp_if_expr_4 = tag != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      return_value_atof_1=atof(tag);
      track_gain_db = (float)return_value_atof_1;
    }

    else
    {
      tag=vorbis_comment_query(vc, "replaygain_track_gain", 0);
      if(!(tag == ((char *)NULL)))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        tag=vorbis_comment_query(vc, "rg_radio", 0);
        tmp_if_expr_3 = tag != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
      {
        return_value_atof_2=atof(tag);
        track_gain_db = (float)return_value_atof_2;
      }

    }
    tag=vorbis_comment_query(vc, "replaygain_album_peak", 0);
    if(!(tag == ((char *)NULL)))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      tag=vorbis_comment_query(vc, "replaygain_track_peak", 0);
      tmp_if_expr_6 = tag != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      tag=vorbis_comment_query(vc, "rg_peak", 0);
      tmp_if_expr_7 = tag != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
    {
      return_value_atof_5=atof(tag);
      track_peak = (float)return_value_atof_5;
    }

  }

  double return_value_pow_8;
  return_value_pow_8=pow(10.0, ((double)track_gain_db + 0.0) / (double)20);
  vg->scale_factor = (float)return_value_pow_8;
  vg->max_scale = (float)(1.0 / (double)track_peak);
}

// vorbisfile_cb_close
// file oggvorbis_format.c line 327
signed int vorbisfile_cb_close(void *arg)
{
  return 1;
}

// vorbisfile_cb_read
// file oggvorbis_format.c line 313
unsigned long int vorbisfile_cb_read(void *ptr, unsigned long int size, unsigned long int nmemb, void *arg)
{
  struct decoder_t *decoder = (struct decoder_t *)arg;
  signed int return_value;
  return_value=decoder->source->transport->read(decoder->source, ptr, size, nmemb);
  return (unsigned long int)return_value;
}

// vorbisfile_cb_seek
// file oggvorbis_format.c line 320
signed int vorbisfile_cb_seek(void *arg, signed long int offset, signed int whence)
{
  struct decoder_t *decoder = (struct decoder_t *)arg;
  signed int return_value;
  return_value=decoder->source->transport->seek(decoder->source, offset, whence);
  return return_value;
}

// vorbisfile_cb_tell
// file oggvorbis_format.c line 332
signed long int vorbisfile_cb_tell(void *arg)
{
  struct decoder_t *decoder = (struct decoder_t *)arg;
  signed long int return_value;
  return_value=decoder->source->transport->tell(decoder->source);
  return return_value;
}

// vstatus_error
// file status.h line 73
void vstatus_error(const char *fmt, void **ap)
{
  do
  {
    struct anonymous_10 __cancel_buf;
    void (*__cancel_routine)(void *) = unlock_output_lock;
    void *__cancel_arg = (void *)0;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&output_lock);
      clear_line(last_line_len);
      vstatus_print_nolock(fmt, ap);
      pthread_mutex_unlock(&output_lock);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
  exit_status = 1;
}

// vstatus_message
// file status.h line 71
void vstatus_message(signed int verbosity, const char *fmt, void **ap)
{
  if(max_verbosity >= verbosity)
    do
    {
      struct anonymous_10 __cancel_buf;
      void (*__cancel_routine)(void *) = unlock_output_lock;
      void *__cancel_arg = (void *)0;
      signed int __not_first_call;
      __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)__not_first_call == 0l))
      {
        __cancel_routine(__cancel_arg);
        __pthread_unwind_next(&__cancel_buf);
      }

      __pthread_register_cancel(&__cancel_buf);
      do
      {
        pthread_mutex_lock(&output_lock);
        clear_line(last_line_len);
        vstatus_print_nolock(fmt, ap);
        pthread_mutex_unlock(&output_lock);

      __CPROVER_DUMP_L4:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&__cancel_buf);
    }
    while((_Bool)0);

}

// vstatus_print_nolock
// file status.c line 201
void vstatus_print_nolock(const char *fmt, void **ap)
{
  if(!(last_line_len == 0))
    fputc(10, stderr);

  vfprintf(stderr, fmt, ap);
  fputc(10, stderr);
  last_line_len = 0;
}

// write_buffer_state_string
// file status.c line 54
void write_buffer_state_string(char *dest, struct buffer_stats_t *buf_stats)
{
  char *cur = dest;
  char *comma = ", ";
  char *sep = "(";
  if(!(buf_stats->prebuffering == 0))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("%sPrebuf to %.1f%%");
    signed int return_value_sprintf_2;
    return_value_sprintf_2=sprintf(cur, return_value_gettext_1, sep, (double)100.0f * buf_stats->prebuffer_fill);
    cur = cur + (signed long int)return_value_sprintf_2;
    sep = comma;
  }

  if(!(buf_stats->paused == 0))
  {
    char *return_value_gettext_3;
    return_value_gettext_3=gettext("%sPaused");
    signed int return_value_sprintf_4;
    return_value_sprintf_4=sprintf(cur, return_value_gettext_3, sep);
    cur = cur + (signed long int)return_value_sprintf_4;
    sep = comma;
  }

  if(!(buf_stats->eos == 0))
  {
    char *return_value_gettext_5;
    return_value_gettext_5=gettext("%sEOS");
    signed int return_value_sprintf_6;
    return_value_sprintf_6=sprintf(cur, return_value_gettext_5, sep);
    cur = cur + (signed long int)return_value_sprintf_6;
    sep = comma;
  }

  signed int return_value_sprintf_7;
  if(!(cur == dest))
  {
    return_value_sprintf_7=sprintf(cur, ")");
    cur = cur + (signed long int)return_value_sprintf_7;
  }

  else
    *cur = (char)0;
}

// write_callback
// file http_transport.c line 64
unsigned long int write_callback(void *ptr, unsigned long int size, unsigned long int nmemb, void *arg)
{
  struct http_private_t *myarg = (struct http_private_t *)arg;
  if(!(myarg->cancel_flag == 0) || !(sig_request.cancel == 0))
    return (unsigned long int)0;

  else
  {
    signed int return_value_buffer_submit_data_1;
    return_value_buffer_submit_data_1=buffer_submit_data(myarg->buf, (char *)ptr, (signed long int)(size * nmemb));
    if(return_value_buffer_submit_data_1 == 0)
      return (unsigned long int)0;

    else
      if(!(myarg->cancel_flag == 0) || !(sig_request.cancel == 0))
        return (unsigned long int)0;

      else
        return size * nmemb;
  }
}

// write_callback_link1
// file flac_format.c line 480
static enum anonymous_52 write_callback_link1(const struct anonymous_19 *decoder, const struct anonymous_27 *frame, const signed int * const *buffer, void *client_data)
{
  struct decoder_t *e_decoder = (struct decoder_t *)client_data;
  struct anonymous_21 *priv = (struct anonymous_21 *)e_decoder->private;
  signed int samples = (signed int)frame->header.blocksize;
  signed int channels = (signed int)frame->header.channels;
  signed int bits_per_sample;
  priv->bits_per_sample = (signed int)frame->header.bits_per_sample;
  bits_per_sample = priv->bits_per_sample;
  signed int i;
  signed int j;
  resize_buffer(priv, channels, samples);
  i = 0;
  for( ; !(i >= channels); i = i + 1)
  {
    j = 0;
    for( ; !(j >= samples); j = j + 1)
      priv->buf[(signed long int)i][(signed long int)j] = buffer[(signed long int)i][(signed long int)j];
  }
  priv->buf_start = 0;
  priv->buf_fill = samples;
  priv->samples_decoded = priv->samples_decoded + (signed long int)samples;
  return (enum anonymous_52)FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
}

// write_time_string
// file status.c line 83
signed int write_time_string(char *dest, double time)
{
  signed long int min = (signed long int)time / (signed long int)60;
  double sec = time - (double)(60.0f * (float)min);
  signed int return_value_sprintf_1;
  return_value_sprintf_1=sprintf(dest, "%02li:%05.2f", min, sec);
  return return_value_sprintf_1;
}

