// #anon_enum$FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0$FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1$FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2$FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3
// file /usr/include/FLAC/format.h line 381
enum anonymous$12 { FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0, FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1, FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2, FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3 };

// #anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1
// file /usr/include/FLAC/format.h line 194
enum anonymous$0 { FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1 };

// #anon_enum$FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0$FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1
// file /usr/include/FLAC/format.h line 396
enum anonymous$13 { FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0, FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1 };

// #anon_enum$FLAC__METADATA_TYPE_STREAMINFO=0$FLAC__METADATA_TYPE_PADDING=1$FLAC__METADATA_TYPE_APPLICATION=2$FLAC__METADATA_TYPE_SEEKTABLE=3$FLAC__METADATA_TYPE_VORBIS_COMMENT=4$FLAC__METADATA_TYPE_CUESHEET=5$FLAC__METADATA_TYPE_PICTURE=6$FLAC__METADATA_TYPE_UNDEFINED=7$FLAC__MAX_METADATA_TYPE=126
// file /usr/include/FLAC/format.h line 489
enum anonymous$18 { FLAC__METADATA_TYPE_STREAMINFO=0, FLAC__METADATA_TYPE_PADDING=1, FLAC__METADATA_TYPE_APPLICATION=2, FLAC__METADATA_TYPE_SEEKTABLE=3, FLAC__METADATA_TYPE_VORBIS_COMMENT=4, FLAC__METADATA_TYPE_CUESHEET=5, FLAC__METADATA_TYPE_PICTURE=6, FLAC__METADATA_TYPE_UNDEFINED=7, FLAC__MAX_METADATA_TYPE=126 };

// #anon_enum$FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC=0$FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER=1$FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH=2$FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM=3
// file /usr/include/FLAC/stream_decoder.h line 427
enum anonymous$45 { FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC=0, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER=1, FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH=2, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM=3 };

// #anon_enum$FLAC__STREAM_DECODER_INIT_STATUS_OK=0$FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER=1$FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS=2$FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR=3$FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE=4$FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED=5
// file /usr/include/FLAC/stream_decoder.h line 256
enum anonymous$39 { FLAC__STREAM_DECODER_INIT_STATUS_OK=0, FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER=1, FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS=2, FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR=3, FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE=4, FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED=5 };

// #anon_enum$FLAC__STREAM_DECODER_LENGTH_STATUS_OK=0$FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR=1$FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED=2
// file /usr/include/FLAC/stream_decoder.h line 371
enum anonymous$43 { FLAC__STREAM_DECODER_LENGTH_STATUS_OK=0, FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR=1, FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED=2 };

// #anon_enum$FLAC__STREAM_DECODER_READ_STATUS_CONTINUE=0$FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM=1$FLAC__STREAM_DECODER_READ_STATUS_ABORT=2
// file /usr/include/FLAC/stream_decoder.h line 294
enum anonymous$40 { FLAC__STREAM_DECODER_READ_STATUS_CONTINUE=0, FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM=1, FLAC__STREAM_DECODER_READ_STATUS_ABORT=2 };

// #anon_enum$FLAC__STREAM_DECODER_SEEK_STATUS_OK=0$FLAC__STREAM_DECODER_SEEK_STATUS_ERROR=1$FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED=2
// file /usr/include/FLAC/stream_decoder.h line 325
enum anonymous$41 { FLAC__STREAM_DECODER_SEEK_STATUS_OK=0, FLAC__STREAM_DECODER_SEEK_STATUS_ERROR=1, FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED=2 };

// #anon_enum$FLAC__STREAM_DECODER_TELL_STATUS_OK=0$FLAC__STREAM_DECODER_TELL_STATUS_ERROR=1$FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED=2
// file /usr/include/FLAC/stream_decoder.h line 348
enum anonymous$42 { FLAC__STREAM_DECODER_TELL_STATUS_OK=0, FLAC__STREAM_DECODER_TELL_STATUS_ERROR=1, FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED=2 };

// #anon_enum$FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE=0$FLAC__STREAM_DECODER_WRITE_STATUS_ABORT=1
// file /usr/include/FLAC/stream_decoder.h line 394
enum anonymous$44 { FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE=0, FLAC__STREAM_DECODER_WRITE_STATUS_ABORT=1 };

// #anon_enum$FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0$FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1$FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2$FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3$FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4$FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5$FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6$FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7$FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8$FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9$FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10$FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11$FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12$FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13$FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14$FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15$FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16$FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17$FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18$FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19$FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20$FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21
// file /usr/include/FLAC/format.h line 732
enum anonymous$33 { FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0, FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1, FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2, FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3, FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4, FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5, FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6, FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7, FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8, FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9, FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10, FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11, FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12, FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13, FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14, FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15, FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16, FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17, FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18, FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19, FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20, FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21 };

// #anon_enum$FLAC__SUBFRAME_TYPE_CONSTANT=0$FLAC__SUBFRAME_TYPE_VERBATIM=1$FLAC__SUBFRAME_TYPE_FIXED=2$FLAC__SUBFRAME_TYPE_LPC=3
// file /usr/include/FLAC/format.h line 267
enum anonymous$10 { FLAC__SUBFRAME_TYPE_CONSTANT=0, FLAC__SUBFRAME_TYPE_VERBATIM=1, FLAC__SUBFRAME_TYPE_FIXED=2, FLAC__SUBFRAME_TYPE_LPC=3 };

// tag-#anon#ST[*{S32(*{S8}$S8$|*{U8}$U8$)->S32}$S32(*{S8}$S8$|*{U8}$U8$)->S32$'id_func'||*{*{SYM#tag-pcm_struct#}$SYM#tag-pcm_struct#$(*{S8}$S8$|*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$)->*{SYM#tag-pcm_struct#}$SYM#tag-pcm_struct#$}$*{SYM#tag-pcm_struct#}$SYM#tag-pcm_struct#$(*{S8}$S8$|*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$)->*{SYM#tag-pcm_struct#}$SYM#tag-pcm_struct#$$'load_func'||*{S8}$S8$'format'|]
// file loader.c line 65
struct anonymous$47;

// tag-#anon#ST[*{SYM#tag-FLAC__StreamDecoderProtected#}$SYM#tag-FLAC__StreamDecoderProtected#$'protected_'||*{SYM#tag-FLAC__StreamDecoderPrivate#}$SYM#tag-FLAC__StreamDecoderPrivate#$'private_'|]
// file /usr/include/FLAC/stream_decoder.h line 463
struct anonymous;

// tag-#anon#ST[*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$'in'||*{SYM#tag-pcm_struct#}$SYM#tag-pcm_struct#$'pcm'||S64'fill'|]
// file loader.c line 807
struct anonymous$48;

// tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]
// file /usr/include/FLAC/format.h line 214
struct anonymous$1;

// tag-#anon#ST[*{U64(*{V}$V$|U64|U64|*{V}$V$)->U64}$U64(*{V}$V$|U64|U64|*{V}$V$)->U64$'read_func'||*{S32(*{V}$V$|S64|S32)->S32}$S32(*{V}$V$|S64|S32)->S32$'seek_func'||*{S32(*{V}$V$)->S32}$S32(*{V}$V$)->S32$'close_func'||*{S64(*{V}$V$)->S64}$S64(*{V}$V$)->S64$'tell_func'|]
// file /usr/include/vorbis/vorbisfile.h line 39
struct anonymous$49;

// tag-#anon#ST[*{U8}$U8$'body_data'||S64'body_storage'||S64'body_fill'||S64'body_returned'||*{S32}$S32$'lacing_vals'||*{S64}$S64$'granule_vals'||S64'lacing_storage'||S64'lacing_fill'||S64'lacing_packet'||S64'lacing_returned'||ARR282{U8}$U8$'header'||U16'$pad0'||S32'header_fill'||S32'e_o_s'||S32'b_o_s'||S64'serialno'||S64'pageno'||S64'packetno'||S64'granulepos'|]
// file /usr/include/ogg/ogg.h line 53
struct anonymous$51;

// tag-#anon#ST[*{U8}$U8$'data'|]
// file /usr/include/FLAC/format.h line 827
struct anonymous$36;

// tag-#anon#ST[*{U8}$U8$'data'||S32'storage'||S32'fill'||S32'returned'||S32'unsynced'||S32'headerbytes'||S32'bodybytes'|]
// file /usr/include/ogg/ogg.h line 105
struct anonymous$50;

// tag-#anon#ST[*{cS32}$cS32$'data'|]
// file /usr/include/FLAC/format.h line 291
struct anonymous$8;

// tag-#anon#ST[ARR129{S8}$S8$'media_catalog_number'||U56'$pad0'||U64'lead_in'||S32'is_cd'||U32'num_tracks'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}$S8$'isrc'||BF{U32}$U32$'type'||BF{U32}$U32$'pre_emphasis'||BF{U6}$U6$'$bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#$'indices'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}$S8$'isrc'||BF{U32}$U32$'type'||BF{U32}$U32$'pre_emphasis'||BF{U6}$U6$'$bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#$'indices'|]#$'tracks'|]
// file /usr/include/FLAC/format.h line 703
struct anonymous$32;

// tag-#anon#ST[ARR4{U8}$U8$'id'||U32'$pad0'||*{U8}$U8$'data'|]
// file /usr/include/FLAC/format.h line 565
struct anonymous$21;

// tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]
// file /usr/include/FLAC/format.h line 255
struct anonymous$4;

// tag-#anon#ST[EN#anon_enum$FLAC__METADATA_TYPE_STREAMINFO=0$FLAC__METADATA_TYPE_PADDING=1$FLAC__METADATA_TYPE_APPLICATION=2$FLAC__METADATA_TYPE_SEEKTABLE=3$FLAC__METADATA_TYPE_VORBIS_COMMENT=4$FLAC__METADATA_TYPE_CUESHEET=5$FLAC__METADATA_TYPE_PICTURE=6$FLAC__METADATA_TYPE_UNDEFINED=7$FLAC__MAX_METADATA_TYPE=126#{U32}$U32$'type'||S32'is_last'||U32'length'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'min_blocksize'||U32'max_blocksize'||U32'min_framesize'||U32'max_framesize'||U32'sample_rate'||U32'channels'||U32'bits_per_sample'||U32'$pad0'||U64'total_samples'||ARR16{U8}$U8$'md5sum'|]#'stream_info'||SYM#tag-#anon#ST[S32'dummy'|]#'padding'||SYM#tag-#anon#ST[ARR4{U8}$U8$'id'||U32'$pad0'||*{U8}$U8$'data'|]#'application'||SYM#tag-#anon#ST[U32'num_points'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'$pad0'|]#$'points'|]#'seek_table'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]#'vendor_string'||U32'num_comments'||U32'$pad0'||*{SYM#tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]#}$SYM#tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]#$'comments'|]#'vorbis_comment'||SYM#tag-#anon#ST[ARR129{S8}$S8$'media_catalog_number'||U56'$pad0'||U64'lead_in'||S32'is_cd'||U32'num_tracks'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}$S8$'isrc'||BF{U32}$U32$'type'||BF{U32}$U32$'pre_emphasis'||BF{U6}$U6$'$bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#$'indices'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}$S8$'isrc'||BF{U32}$U32$'type'||BF{U32}$U32$'pre_emphasis'||BF{U6}$U6$'$bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#$'indices'|]#$'tracks'|]#'cue_sheet'||SYM#tag-#anon#ST[EN#anon_enum$FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0$FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1$FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2$FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3$FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4$FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5$FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6$FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7$FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8$FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9$FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10$FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11$FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12$FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13$FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14$FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15$FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16$FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17$FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18$FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19$FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20$FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#{U32}$U32$'type'||U32'$pad0'||*{S8}$S8$'mime_type'||*{U8}$U8$'description'||U32'width'||U32'height'||U32'depth'||U32'colors'||U32'data_length'||U32'$pad1'||*{U8}$U8$'data'|]#'picture'||SYM#tag-#anon#ST[*{U8}$U8$'data'|]#'unknown'|]#'data'|]
// file /usr/include/FLAC/format.h line 834
struct anonymous$38;

// tag-#anon#ST[EN#anon_enum$FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0$FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1$FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2$FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3$FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4$FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5$FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6$FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7$FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8$FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9$FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10$FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11$FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12$FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13$FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14$FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15$FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16$FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17$FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18$FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19$FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20$FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#{U32}$U32$'type'||U32'$pad0'||*{S8}$S8$'mime_type'||*{U8}$U8$'description'||U32'width'||U32'height'||U32'depth'||U32'colors'||U32'data_length'||U32'$pad1'||*{U8}$U8$'data'|]
// file /usr/include/FLAC/format.h line 769
struct anonymous$35;

// tag-#anon#ST[EN#anon_enum$FLAC__SUBFRAME_TYPE_CONSTANT=0$FLAC__SUBFRAME_TYPE_VERBATIM=1$FLAC__SUBFRAME_TYPE_FIXED=2$FLAC__SUBFRAME_TYPE_LPC=3#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'value'|]#'constant'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]#'fixed'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}$S32$'qlp_coeff'||ARR32{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]#'lpc'||SYM#tag-#anon#ST[*{cS32}$cS32$'data'|]#'verbatim'|]#'data'||U32'wasted_bits'||U32'$pad1'|]
// file /usr/include/FLAC/format.h line 344
struct anonymous$11;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$31;

// tag-#anon#ST[S32'dummy'|]
// file /usr/include/FLAC/format.h line 554
struct anonymous$20;

// tag-#anon#ST[S32'value'|]
// file /usr/include/FLAC/format.h line 284
struct anonymous$5;

// tag-#anon#ST[S64'endbyte'||S32'endbit'||U32'$pad0'||*{U8}$U8$'buffer'||*{U8}$U8$'ptr'||S64'storage'|]
// file /usr/include/ogg/ogg.h line 32
struct anonymous$46;

// tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]
// file /usr/include/FLAC/format.h line 298
struct anonymous$6;

// tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}$S32$'qlp_coeff'||ARR32{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]
// file /usr/include/FLAC/format.h line 315
struct anonymous$7;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'blocksize'||U32'sample_rate'||U32'channels'||EN#anon_enum$FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0$FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1$FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2$FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3#{U32}$U32$'channel_assignment'||U32'bits_per_sample'||EN#anon_enum$FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0$FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1#{U32}$U32$'number_type'||SYM#tag-#anon#UN[U32'frame_number'||U64'sample_number'|]#'number'||U8'crc'||U56'$pad0'|]#'header'||ARR8{SYM#tag-#anon#ST[EN#anon_enum$FLAC__SUBFRAME_TYPE_CONSTANT=0$FLAC__SUBFRAME_TYPE_VERBATIM=1$FLAC__SUBFRAME_TYPE_FIXED=2$FLAC__SUBFRAME_TYPE_LPC=3#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'value'|]#'constant'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]#'fixed'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}$S32$'qlp_coeff'||ARR32{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]#'lpc'||SYM#tag-#anon#ST[*{cS32}$cS32$'data'|]#'verbatim'|]#'data'||U32'wasted_bits'||U32'$pad1'|]#}$SYM#tag-#anon#ST[EN#anon_enum$FLAC__SUBFRAME_TYPE_CONSTANT=0$FLAC__SUBFRAME_TYPE_VERBATIM=1$FLAC__SUBFRAME_TYPE_FIXED=2$FLAC__SUBFRAME_TYPE_LPC=3#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'value'|]#'constant'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]#'fixed'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}$S32$'qlp_coeff'||ARR32{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]#'lpc'||SYM#tag-#anon#ST[*{cS32}$cS32$'data'|]#'verbatim'|]#'data'||U32'wasted_bits'||U32'$pad1'|]#$'subframes'||SYM#tag-#anon#ST[U16'crc'|]#'footer'||U48'$pad0'|]
// file /usr/include/FLAC/format.h line 473
struct anonymous$17;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]#'vendor_string'||U32'num_comments'||U32'$pad0'||*{SYM#tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]#}$SYM#tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]#$'comments'|]
// file /usr/include/FLAC/format.h line 634
struct anonymous$28;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'main_cond'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'play_cond'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'key_cond'||S32'exiting'||U32'$pad0'||*{SYM#tag-ao_device#}$SYM#tag-ao_device#$'adev'||*{U8}$U8$'fragment'||S32'fragment_size'||S32'key_waiting'||S32'exit_fd'||U32'$pad1'|]
// file main.c line 261
struct anonymous$24;

// tag-#anon#ST[U16'crc'|]
// file /usr/include/FLAC/format.h line 460
struct anonymous$16;

// tag-#anon#ST[U32'blocksize'||U32'sample_rate'||U32'channels'||EN#anon_enum$FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0$FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1$FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2$FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3#{U32}$U32$'channel_assignment'||U32'bits_per_sample'||EN#anon_enum$FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0$FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1#{U32}$U32$'number_type'||SYM#tag-#anon#UN[U32'frame_number'||U64'sample_number'|]#'number'||U8'crc'||U56'$pad0'|]
// file /usr/include/FLAC/format.h line 411
struct anonymous$15;

// tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]
// file /usr/include/FLAC/format.h line 624
struct anonymous$27;

// tag-#anon#ST[U32'min_blocksize'||U32'max_blocksize'||U32'min_framesize'||U32'max_framesize'||U32'sample_rate'||U32'channels'||U32'bits_per_sample'||U32'$pad0'||U64'total_samples'||ARR16{U8}$U8$'md5sum'|]
// file /usr/include/FLAC/format.h line 529
struct anonymous$19;

// tag-#anon#ST[U32'num_points'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'$pad0'|]#$'points'|]
// file /usr/include/FLAC/format.h line 612
struct anonymous$26;

// tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]
// file /usr/include/FLAC/format.h line 233
struct anonymous$2;

// tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}$S8$'isrc'||BF{U32}$U32$'type'||BF{U32}$U32$'pre_emphasis'||BF{U6}$U6$'$bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#$'indices'|]
// file /usr/include/FLAC/format.h line 666
struct anonymous$30;

// tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]
// file /usr/include/FLAC/format.h line 647
struct anonymous$29;

// tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'$pad0'|]
// file /usr/include/FLAC/format.h line 574
struct anonymous$25;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$34;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$23;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'value'|]#'constant'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||ARR4{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]#'fixed'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0$FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#{U32}$U32$'type'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]#'data'|]#'entropy_coding_method'||U32'order'||U32'qlp_coeff_precision'||S32'quantization_level'||ARR32{S32}$S32$'qlp_coeff'||ARR32{S32}$S32$'warmup'||U32'$pad0'||*{cS32}$cS32$'residual'|]#'lpc'||SYM#tag-#anon#ST[*{cS32}$cS32$'data'|]#'verbatim'|]
// file /usr/include/FLAC/format.h line 346
union anonymous$9;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'min_blocksize'||U32'max_blocksize'||U32'min_framesize'||U32'max_framesize'||U32'sample_rate'||U32'channels'||U32'bits_per_sample'||U32'$pad0'||U64'total_samples'||ARR16{U8}$U8$'md5sum'|]#'stream_info'||SYM#tag-#anon#ST[S32'dummy'|]#'padding'||SYM#tag-#anon#ST[ARR4{U8}$U8$'id'||U32'$pad0'||*{U8}$U8$'data'|]#'application'||SYM#tag-#anon#ST[U32'num_points'||U32'$pad0'||*{SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'$pad0'|]#}$SYM#tag-#anon#ST[U64'sample_number'||U64'stream_offset'||U32'frame_samples'||U32'$pad0'|]#$'points'|]#'seek_table'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]#'vendor_string'||U32'num_comments'||U32'$pad0'||*{SYM#tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]#}$SYM#tag-#anon#ST[U32'length'||U32'$pad0'||*{U8}$U8$'entry'|]#$'comments'|]#'vorbis_comment'||SYM#tag-#anon#ST[ARR129{S8}$S8$'media_catalog_number'||U56'$pad0'||U64'lead_in'||S32'is_cd'||U32'num_tracks'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}$S8$'isrc'||BF{U32}$U32$'type'||BF{U32}$U32$'pre_emphasis'||BF{U6}$U6$'$bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#$'indices'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||ARR13{S8}$S8$'isrc'||BF{U32}$U32$'type'||BF{U32}$U32$'pre_emphasis'||BF{U6}$U6$'$bit_field_pad0'||U8'num_indices'||*{SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#}$SYM#tag-#anon#ST[U64'offset'||U8'number'||U56'$pad0'|]#$'indices'|]#$'tracks'|]#'cue_sheet'||SYM#tag-#anon#ST[EN#anon_enum$FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0$FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1$FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2$FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3$FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4$FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5$FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6$FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7$FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8$FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9$FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10$FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11$FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12$FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13$FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14$FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15$FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16$FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17$FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18$FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19$FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20$FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#{U32}$U32$'type'||U32'$pad0'||*{S8}$S8$'mime_type'||*{U8}$U8$'description'||U32'width'||U32'height'||U32'depth'||U32'colors'||U32'data_length'||U32'$pad1'||*{U8}$U8$'data'|]#'picture'||SYM#tag-#anon#ST[*{U8}$U8$'data'|]#'unknown'|]
// file /usr/include/FLAC/format.h line 846
union anonymous$37;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'order'||U32'$pad0'||*{cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#}$cSYM#tag-#anon#ST[*{U32}$U32$'parameters'||*{U32}$U32$'raw_bits'||U32'capacity_by_order'||U32'$pad0'|]#$'contents'|]#'partitioned_rice'|]
// file /usr/include/FLAC/format.h line 257
union anonymous$3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$22;

// tag-#anon#UN[U32'frame_number'||U64'sample_number'|]
// file /usr/include/FLAC/format.h line 432
union anonymous$14;

// tag-FLAC__StreamDecoderPrivate
// file /usr/include/FLAC/stream_decoder.h line 458
struct FLAC__StreamDecoderPrivate;

// tag-FLAC__StreamDecoderProtected
// file /usr/include/FLAC/stream_decoder.h line 457
struct FLAC__StreamDecoderProtected;

// tag-OggOpusFile
// file /usr/include/opus/opusfile.h line 133
struct OggOpusFile;

// tag-OggVorbis_File
// file /usr/include/vorbis/vorbisfile.h line 111
struct OggVorbis_File;

// tag-OpusFileCallbacks
// file /usr/include/opus/opusfile.h line 132
struct OpusFileCallbacks;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-alloc_chain
// file /usr/include/vorbis/codec.h line 110
struct alloc_chain;

// tag-ao_device
// file /usr/include/ao/ao.h line 77
struct ao_device;

// tag-ao_info
// file /usr/include/ao/ao.h line 64
struct ao_info;

// tag-ao_option
// file /usr/include/ao/ao.h line 87
struct ao_option;

// tag-ao_sample_format
// file /usr/include/ao/ao.h line 79
struct ao_sample_format;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pcm_struct
// file main.h line 29
struct pcm_struct;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-term
// file /usr/include/term.h line 670
struct term;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-termtype
// file /usr/include/term.h line 648
struct termtype;

// tag-tinfo_fkeys
// file mincurses.c line 61
struct tinfo_fkeys;

// tag-tries
// file mincurses.c line 78
struct tries;

// tag-vorbis_block
// file /usr/include/vorbis/codec.h line 88
struct vorbis_block;

// tag-vorbis_comment
// file /usr/include/vorbis/codec.h line 140
struct vorbis_comment;

// tag-vorbis_dsp_state
// file /usr/include/vorbis/codec.h line 59
struct vorbis_dsp_state;

// tag-vorbis_info
// file /usr/include/vorbis/codec.h line 28
struct vorbis_info;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// FLAC__stream_decoder_delete
// file /usr/include/FLAC/stream_decoder.h line 751
void FLAC__stream_decoder_delete(struct anonymous *);
// FLAC__stream_decoder_finish
// file /usr/include/FLAC/stream_decoder.h line 1370
signed int FLAC__stream_decoder_finish(struct anonymous *);
// FLAC__stream_decoder_init_ogg_stream
// file /usr/include/FLAC/stream_decoder.h line 1154
enum anonymous$39 FLAC__stream_decoder_init_ogg_stream(struct anonymous *, enum anonymous$40 (*)(const struct anonymous *, unsigned char *, unsigned long int *, void *), enum anonymous$41 (*)(const struct anonymous *, unsigned long int, void *), enum anonymous$42 (*)(const struct anonymous *, unsigned long int *, void *), enum anonymous$43 (*)(const struct anonymous *, unsigned long int *, void *), signed int (*)(const struct anonymous *, void *), enum anonymous$44 (*)(const struct anonymous *, const struct anonymous$17 *, const signed int * const *, void *), void (*)(const struct anonymous *, const struct anonymous$38 *, void *), void (*)(const struct anonymous *, enum anonymous$45, void *), void *);
// FLAC__stream_decoder_init_stream
// file /usr/include/FLAC/stream_decoder.h line 1073
enum anonymous$39 FLAC__stream_decoder_init_stream(struct anonymous *, enum anonymous$40 (*)(const struct anonymous *, unsigned char *, unsigned long int *, void *), enum anonymous$41 (*)(const struct anonymous *, unsigned long int, void *), enum anonymous$42 (*)(const struct anonymous *, unsigned long int *, void *), enum anonymous$43 (*)(const struct anonymous *, unsigned long int *, void *), signed int (*)(const struct anonymous *, void *), enum anonymous$44 (*)(const struct anonymous *, const struct anonymous$17 *, const signed int * const *, void *), void (*)(const struct anonymous *, const struct anonymous$38 *, void *), void (*)(const struct anonymous *, enum anonymous$45, void *), void *);
// FLAC__stream_decoder_new
// file /usr/include/FLAC/stream_decoder.h line 743
struct anonymous * FLAC__stream_decoder_new(void);
// FLAC__stream_decoder_process_until_end_of_stream
// file /usr/include/FLAC/stream_decoder.h line 1493
signed int FLAC__stream_decoder_process_until_end_of_stream(struct anonymous *);
// FLAC__stream_decoder_set_md5_checking
// file /usr/include/FLAC/stream_decoder.h line 798
signed int FLAC__stream_decoder_set_md5_checking(struct anonymous *, signed int);
// FLAC__stream_decoder_set_metadata_respond
// file /usr/include/FLAC/stream_decoder.h line 812
signed int FLAC__stream_decoder_set_metadata_respond(struct anonymous *, enum anonymous$18);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// _nc_add_to_try
// file mincurses.c line 119
extern signed int _nc_add_to_try(struct tries **, const char *, unsigned int);
// _nc_init_acs
// file /usr/include/term_entry.h line 159
extern void _nc_init_acs(void);
// _ov_header_fseek_wrap
// file /usr/include/vorbis/vorbisfile.h line 53
static signed int _ov_header_fseek_wrap(struct _IO_FILE *f, signed long int off, signed int whence);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// aiff_id
// file loader.c line 94
static signed int aiff_id(char *path, unsigned char *buf);
// aiff_load
// file loader.c line 487
static struct pcm_struct * aiff_load(char *path, struct _IO_FILE *in);
// ao_close
// file /usr/include/ao/ao.h line 122
signed int ao_close(struct ao_device *);
// ao_default_driver_id
// file /usr/include/ao/ao.h line 126
signed int ao_default_driver_id(void);
// ao_driver_id
// file /usr/include/ao/ao.h line 125
signed int ao_driver_id(const char *);
// ao_driver_info
// file /usr/include/ao/ao.h line 127
struct ao_info * ao_driver_info(signed int);
// ao_driver_info_list
// file /usr/include/ao/ao.h line 128
struct ao_info ** ao_driver_info_list(signed int *);
// ao_initialize
// file /usr/include/ao/ao.h line 100
void ao_initialize(void);
// ao_open_live
// file /usr/include/ao/ao.h line 110
struct ao_device * ao_open_live(signed int, struct ao_sample_format *, struct ao_option *);
// ao_play
// file /usr/include/ao/ao.h line 119
signed int ao_play(struct ao_device *, char *, unsigned int);
// ao_shutdown
// file /usr/include/ao/ao.h line 101
void ao_shutdown(void);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_warn_clipping
// file audio.c line 57
extern float check_warn_clipping(struct pcm_struct *pcm, signed int no_normalize);
// compute_pdual
// file main.c line 248
extern double compute_pdual(signed int score, signed int tests);
// compute_psingle
// file main.c line 239
extern double compute_psingle(signed int correct, signed int tests);
// convert_to_16
// file audio.c line 319
extern void convert_to_16(struct pcm_struct *pcm, signed int dither);
// convert_to_24
// file audio.c line 296
extern void convert_to_24(struct pcm_struct *pcm);
// convert_to_32
// file audio.c line 272
extern void convert_to_32(struct pcm_struct *pcm);
// convert_to_mono
// file audio.c line 119
extern float convert_to_mono(struct pcm_struct *pcm);
// convert_to_stereo
// file audio.c line 199
extern float convert_to_stereo(struct pcm_struct *pcm);
// cosf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern float cosf(float);
// dottrim
// file tty.c line 477
char * dottrim(char *in, signed int l);
// draw_playbar
// file tty.c line 167
static signed int draw_playbar(signed int row);
// draw_samples_box
// file tty.c line 229
static signed int draw_samples_box(signed int row);
// draw_timebar
// file tty.c line 147
static signed int draw_timebar(signed int row);
// draw_topbar
// file tty.c line 88
static signed int draw_topbar(signed int row);
// draw_trials_box
// file tty.c line 195
static signed int draw_trials_box(signed int row);
// eof_callback
// file loader.c line 918
static signed int eof_callback(const struct anonymous *decoder, void *client_data);
// error_callback
// file loader.c line 909
static void error_callback(const struct anonymous *decoder, enum anonymous$45 status, void *client_data);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// factorial
// file main.c line 230
double factorial(signed int x);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fifo_clear
// file mincurses.c line 211
static inline void fifo_clear();
// fifo_peek
// file mincurses.c line 155
static inline signed int fifo_peek();
// fifo_pull
// file mincurses.c line 161
static inline signed int fifo_pull();
// fifo_push
// file mincurses.c line 174
static inline signed int fifo_push(signed int nonblock);
// fill
// file tty.c line 67
void fill(char *buf, char c, signed int cols);
// fill_fragment1
// file audio.c line 561
extern void fill_fragment1(unsigned char *out, struct pcm_struct *pcm, signed long int start, signed long int *pos, signed long int end, signed int *loop, signed int fragsamples, float *fadewindow);
// fill_fragment2
// file audio.c line 653
extern void fill_fragment2(unsigned char *out, struct pcm_struct *pcm, signed long int start, signed long int *pos, signed long int end, signed int *loop, signed int fragsamples, float *fadewindow);
// find_aiff_chunk
// file loader.c line 430
static signed int find_aiff_chunk(struct _IO_FILE *in, char *path, char *type, unsigned int *len);
// find_definition
// file mincurses.c line 97
static signed int find_definition(struct tries *tree, const char *str);
// find_wav_chunk
// file loader.c line 131
static signed int find_wav_chunk(struct _IO_FILE *in, char *path, char *type, unsigned int *len);
// flac_id
// file loader.c line 104
static signed int flac_id(char *path, unsigned char *buf);
// flac_load
// file loader.c line 1022
static struct pcm_struct * flac_load(char *path, struct _IO_FILE *in);
// flac_load_i
// file loader.c line 924
static struct pcm_struct * flac_load_i(char *path, struct _IO_FILE *in, signed int oggp);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_pcm
// file loader.c line 1314
extern void free_pcm(struct pcm_struct *pcm);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// get_clamp
// file audio.c line 50
static float get_clamp(struct pcm_struct *pcm);
// get_val
// file audio.c line 446
extern float get_val(unsigned char *d, signed int bps);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// key_thread
// file main.c line 308
void * key_thread(void *arg);
// ldexp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 106
extern double ldexp(double, signed int);
// load_audio_file
// file loader.c line 1285
extern struct pcm_struct * load_audio_file(char *path);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// make_time_string
// file main.h line 70
extern char * make_time_string(double is, signed int pad);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// metadata_callback
// file loader.c line 893
static void metadata_callback(const struct anonymous *decoder, const struct anonymous$38 *metadata, void *client_data);
// min_bg
// file mincurses.c line 622
extern signed int min_bg(signed int c);
// min_blink
// file mincurses.c line 663
extern signed int min_blink(signed int flag);
// min_bold
// file mincurses.c line 648
extern signed int min_bold(signed int flag);
// min_clrbol
// file mincurses.c line 490
extern signed int min_clrbol(void);
// min_clreol
// file mincurses.c line 482
extern signed int min_clreol(void);
// min_color
// file mincurses.c line 637
extern signed int min_color(signed int f, signed int b);
// min_fg
// file mincurses.c line 607
extern signed int min_fg(signed int c);
// min_flush
// file mincurses.h line 28
extern signed int min_flush();
// min_getch
// file mincurses.h line 29
extern signed int min_getch(signed int nonblock);
// min_gfx
// file mincurses.c line 698
extern signed int min_gfx(signed int flag);
// min_hidecur
// file mincurses.c line 466
extern signed int min_hidecur(void);
// min_mvcur
// file mincurses.c line 326
extern void min_mvcur(signed int x, signed int y);
// min_panel_contract
// file mincurses.c line 430
extern signed int min_panel_contract(signed int l, signed int bottomp);
// min_panel_expand
// file mincurses.c line 406
extern signed int min_panel_expand(signed int l, signed int bottomp);
// min_panel_init
// file mincurses.c line 365
extern signed int min_panel_init(signed int pl);
// min_panel_remove
// file mincurses.h line 36
extern void min_panel_remove(void);
// min_putchar
// file mincurses.c line 291
extern signed int min_putchar(signed int c);
// min_putp
// file mincurses.c line 299
extern signed int min_putp(const char *str);
// min_putstr
// file mincurses.c line 319
extern signed int min_putstr(const char *str);
// min_putstrb
// file tty.c line 695
static void min_putstrb(char *s);
// min_reverse
// file mincurses.c line 718
extern signed int min_reverse(signed int flag);
// min_showcur
// file mincurses.c line 474
extern signed int min_showcur(void);
// min_underline
// file mincurses.c line 678
extern signed int min_underline(signed int flag);
// min_unset
// file mincurses.c line 521
extern signed int min_unset(void);
// min_write
// file mincurses.c line 303
extern signed int min_write(const char *str, signed int len);
// minc_init_keytry
// file mincurses.c line 121
static void minc_init_keytry();
// oggflac_id
// file loader.c line 108
static signed int oggflac_id(char *path, unsigned char *buf);
// oggflac_load
// file loader.c line 1026
static struct pcm_struct * oggflac_load(char *path, struct _IO_FILE *in);
// op_channel_count
// file /usr/include/opus/opusfile.h line 1493
signed int op_channel_count(const struct OggOpusFile *, signed int);
// op_free
// file /usr/include/opus/opusfile.h line 1414
void op_free(struct OggOpusFile *);
// op_open_callbacks
// file /usr/include/opus/opusfile.h line 1233
struct OggOpusFile * op_open_callbacks(void *, const struct OpusFileCallbacks *, const unsigned char *, unsigned long int, signed int *);
// op_pcm_total
// file /usr/include/opus/opusfile.h line 1533
signed long int op_pcm_total(const struct OggOpusFile *, signed int);
// op_read_float
// file /usr/include/opus/opusfile.h line 2012
signed int op_read_float(struct OggOpusFile *, float *, signed int, signed int *);
// opc_close
// file loader.c line 1155
signed int opc_close(void *_stream);
// opc_read
// file loader.c line 1143
signed int opc_read(void *_stream, unsigned char *_ptr, signed int _nbytes);
// opc_seek
// file loader.c line 1147
signed int opc_seek(void *_stream, signed long long int _offset, signed int _whence);
// opc_tell
// file loader.c line 1151
signed long long int opc_tell(void *_stream);
// opus_id
// file loader.c line 119
static signed int opus_id(char *path, unsigned char *buf);
// opus_load
// file loader.c line 1162
static struct pcm_struct * opus_load(char *path, struct _IO_FILE *in);
// ov_clear
// file /usr/include/vorbis/vorbisfile.h line 149
extern signed int ov_clear(struct OggVorbis_File *);
// ov_info
// file /usr/include/vorbis/vorbisfile.h line 186
extern struct vorbis_info * ov_info(struct OggVorbis_File *, signed int);
// ov_open_callbacks
// file /usr/include/vorbis/vorbisfile.h line 152
extern signed int ov_open_callbacks(void *, struct OggVorbis_File *, const char *, signed long int, struct anonymous$49);
// ov_pcm_total
// file /usr/include/vorbis/vorbisfile.h line 167
extern signed long int ov_pcm_total(struct OggVorbis_File *, signed int);
// ov_read_float
// file /usr/include/vorbis/vorbisfile.h line 189
extern signed long int ov_read_float(struct OggVorbis_File *, float ***, signed int, signed int *);
// panel_init
// file main.h line 71
extern void panel_init(struct pcm_struct **pcm, signed int test_files, signed int test_mode, double start, double end, double size, signed int flip_mode, signed int repeat_mode, signed int trials, signed int gabba);
// panel_redraw_full
// file tty.c line 276
void panel_redraw_full(void);
// panel_toggle_keymap
// file main.h line 81
extern void panel_toggle_keymap(void);
// panel_update_current
// file main.h line 75
extern void panel_update_current(double time);
// panel_update_end
// file main.h line 76
extern void panel_update_end(double time);
// panel_update_flip_mode
// file main.h line 78
extern void panel_update_flip_mode(signed int mode);
// panel_update_pause
// file main.h line 80
extern void panel_update_pause(signed int flag);
// panel_update_playing
// file main.h line 73
extern void panel_update_playing(signed int n);
// panel_update_repeat_mode
// file main.h line 77
extern void panel_update_repeat_mode(signed int mode);
// panel_update_start
// file main.h line 74
extern void panel_update_start(double time);
// panel_update_trials
// file main.h line 79
extern void panel_update_trials(char *choices, char *correct, signed int n);
// parse_time
// file main.c line 172
static signed int parse_time(char *s, double *t);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// playback_thread
// file main.c line 277
void * playback_thread(void *arg);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// print_into
// file tty.c line 74
void print_into(char *buf, signed int pos, char *s);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$23 *, const union anonymous$34 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$23 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$23 *, union anonymous$22 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$22 *, const union anonymous$34 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$22 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$22 *);
// put_val
// file audio.c line 438
extern void put_val(unsigned char *d, signed int bps, float v);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// randomize_samples
// file main.c line 204
void randomize_samples(signed int *r, signed int *cchoice, signed int test_mode);
// randrange
// file main.c line 200
signed int randrange(signed int range);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_IEEE80
// file loader.c line 460
static double read_IEEE80(unsigned char *buf);
// read_callback
// file loader.c line 814
static enum anonymous$40 read_callback(const struct anonymous *decoder, unsigned char *buffer, unsigned long int *bytes, void *client_data);
// reconcile_channel_maps
// file audio.c line 388
extern void reconcile_channel_maps(struct pcm_struct *A, struct pcm_struct *B);
// reset
// file mincurses.c line 595
static signed int reset();
// rint
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 279
extern double rint(double);
// setbg
// file mincurses.c line 541
static signed int setbg(signed int c);
// setblink
// file mincurses.c line 559
static signed int setblink(void);
// setbold
// file mincurses.c line 550
static signed int setbold(void);
// setfg
// file mincurses.c line 532
static signed int setfg(signed int c);
// setgfx
// file mincurses.c line 577
static signed int setgfx(void);
// setreverse
// file mincurses.c line 586
static signed int setreverse(void);
// setunderline
// file mincurses.c line 568
static signed int setunderline(void);
// setup_playback
// file audio.c line 711
extern struct ao_device * setup_playback(signed int rate, signed int ch, signed int bits, char *matrix, char *device);
// setup_term_customize
// file mincurses.c line 343
static void setup_term_customize(void);
// setup_windows
// file audio.c line 456
extern signed int setup_windows(struct pcm_struct **pcm, signed int test_files, float **fw1, float **fw2, float **fw3, float **b1, float **b2);
// setupterm
// file /usr/include/term.h line 740
extern signed int setupterm(const char *, signed int, signed int *);
// sinf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern float sinf(float);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sw_id
// file loader.c line 124
static signed int sw_id(char *path, unsigned char *buf);
// sw_load
// file loader.c line 742
static struct pcm_struct * sw_load(char *path, struct _IO_FILE *in);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tokenize_channels
// file audio.c line 366
static void tokenize_channels(char *matrix, signed int *out, signed int n);
// tparm
// file /usr/include/curses.h line 858
extern char * tparm(const char *, ...);
// tputs
// file /usr/include/term.h line 768
extern signed int tputs(const char *, signed int, signed int (*)(signed int));
// triangle_ditherval
// file audio.c line 265
static inline float triangle_ditherval(float *save);
// trim_path
// file loader.c line 49
static char * trim_path(char *in);
// unset
// file mincurses.c line 506
static signed int unset();
// usage
// file main.c line 83
void usage(struct _IO_FILE *out);
// vorbis_id
// file loader.c line 114
static signed int vorbis_id(char *path, unsigned char *buf);
// vorbis_load
// file loader.c line 1031
static struct pcm_struct * vorbis_load(char *path, struct _IO_FILE *in);
// wav_id
// file loader.c line 86
static signed int wav_id(char *path, unsigned char *buf);
// wav_load
// file loader.c line 153
static struct pcm_struct * wav_load(char *path, struct _IO_FILE *in);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_callback
// file loader.c line 836
static enum anonymous$44 write_callback(const struct anonymous *decoder, const struct anonymous$17 *frame, const signed int * const *buffer, void *client_data);

struct anonymous$47
{
  // id_func
  signed int (*id_func)(char *, unsigned char *);
  // load_func
  struct pcm_struct * (*load_func)(char *, struct _IO_FILE *);
  // format
  char *format;
};

struct anonymous
{
  // protected_
  struct FLAC__StreamDecoderProtected *protected_;
  // private_
  struct FLAC__StreamDecoderPrivate *private_;
};

struct anonymous$48
{
  // in
  struct _IO_FILE *in;
  // pcm
  struct pcm_struct *pcm;
  // fill
  signed long int fill;
};

struct anonymous$1
{
  // parameters
  unsigned int *parameters;
  // raw_bits
  unsigned int *raw_bits;
  // capacity_by_order
  unsigned int capacity_by_order;
};

struct anonymous$49
{
  // read_func
  unsigned long int (*read_func)(void *, unsigned long int, unsigned long int, void *);
  // seek_func
  signed int (*seek_func)(void *, signed long int, signed int);
  // close_func
  signed int (*close_func)(void *);
  // tell_func
  signed long int (*tell_func)(void *);
};

struct anonymous$51
{
  // body_data
  unsigned char *body_data;
  // body_storage
  signed long int body_storage;
  // body_fill
  signed long int body_fill;
  // body_returned
  signed long int body_returned;
  // lacing_vals
  signed int *lacing_vals;
  // granule_vals
  signed long int *granule_vals;
  // lacing_storage
  signed long int lacing_storage;
  // lacing_fill
  signed long int lacing_fill;
  // lacing_packet
  signed long int lacing_packet;
  // lacing_returned
  signed long int lacing_returned;
  // header
  unsigned char header[282l];
  // header_fill
  signed int header_fill;
  // e_o_s
  signed int e_o_s;
  // b_o_s
  signed int b_o_s;
  // serialno
  signed long int serialno;
  // pageno
  signed long int pageno;
  // packetno
  signed long int packetno;
  // granulepos
  signed long int granulepos;
};

struct anonymous$36
{
  // data
  unsigned char *data;
};

struct anonymous$50
{
  // data
  unsigned char *data;
  // storage
  signed int storage;
  // fill
  signed int fill;
  // returned
  signed int returned;
  // unsynced
  signed int unsynced;
  // headerbytes
  signed int headerbytes;
  // bodybytes
  signed int bodybytes;
};

struct anonymous$8
{
  // data
  const signed int *data;
};

struct anonymous$32
{
  // media_catalog_number
  char media_catalog_number[129l];
  // lead_in
  unsigned long int lead_in;
  // is_cd
  signed int is_cd;
  // num_tracks
  unsigned int num_tracks;
  // tracks
  struct anonymous$30 *tracks;
};

struct anonymous$21
{
  // id
  unsigned char id[4l];
  // data
  unsigned char *data;
};

struct anonymous$2
{
  // order
  unsigned int order;
  // contents
  const struct anonymous$1 *contents;
};

union anonymous$3
{
  // partitioned_rice
  struct anonymous$2 partitioned_rice;
};

struct anonymous$4
{
  // type
  enum anonymous$0 type;
  // data
  union anonymous$3 data;
};

struct anonymous$19
{
  // min_blocksize
  unsigned int min_blocksize;
  // max_blocksize
  unsigned int max_blocksize;
  // min_framesize
  unsigned int min_framesize;
  // max_framesize
  unsigned int max_framesize;
  // sample_rate
  unsigned int sample_rate;
  // channels
  unsigned int channels;
  // bits_per_sample
  unsigned int bits_per_sample;
  // total_samples
  unsigned long int total_samples;
  // md5sum
  unsigned char md5sum[16l];
};

struct anonymous$20
{
  // dummy
  signed int dummy;
};

struct anonymous$26
{
  // num_points
  unsigned int num_points;
  // points
  struct anonymous$25 *points;
};

struct anonymous$27
{
  // length
  unsigned int length;
  // entry
  unsigned char *entry;
};

struct anonymous$28
{
  // vendor_string
  struct anonymous$27 vendor_string;
  // num_comments
  unsigned int num_comments;
  // comments
  struct anonymous$27 *comments;
};

struct anonymous$35
{
  // type
  enum anonymous$33 type;
  // mime_type
  char *mime_type;
  // description
  unsigned char *description;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // depth
  unsigned int depth;
  // colors
  unsigned int colors;
  // data_length
  unsigned int data_length;
  // data
  unsigned char *data;
};

union anonymous$37
{
  // stream_info
  struct anonymous$19 stream_info;
  // padding
  struct anonymous$20 padding;
  // application
  struct anonymous$21 application;
  // seek_table
  struct anonymous$26 seek_table;
  // vorbis_comment
  struct anonymous$28 vorbis_comment;
  // cue_sheet
  struct anonymous$32 cue_sheet;
  // picture
  struct anonymous$35 picture;
  // unknown
  struct anonymous$36 unknown;
};

struct anonymous$38
{
  // type
  enum anonymous$18 type;
  // is_last
  signed int is_last;
  // length
  unsigned int length;
  // data
  union anonymous$37 data;
};

struct anonymous$5
{
  // value
  signed int value;
};

struct anonymous$6
{
  // entropy_coding_method
  struct anonymous$4 entropy_coding_method;
  // order
  unsigned int order;
  // warmup
  signed int warmup[4l];
  // residual
  const signed int *residual;
};

struct anonymous$7
{
  // entropy_coding_method
  struct anonymous$4 entropy_coding_method;
  // order
  unsigned int order;
  // qlp_coeff_precision
  unsigned int qlp_coeff_precision;
  // quantization_level
  signed int quantization_level;
  // qlp_coeff
  signed int qlp_coeff[32l];
  // warmup
  signed int warmup[32l];
  // residual
  const signed int *residual;
};

union anonymous$9
{
  // constant
  struct anonymous$5 constant;
  // fixed
  struct anonymous$6 fixed;
  // lpc
  struct anonymous$7 lpc;
  // verbatim
  struct anonymous$8 verbatim;
};

struct anonymous$11
{
  // type
  enum anonymous$10 type;
  // data
  union anonymous$9 data;
  // wasted_bits
  unsigned int wasted_bits;
};

struct anonymous$31
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$46
{
  // endbyte
  signed long int endbyte;
  // endbit
  signed int endbit;
  // buffer
  unsigned char *buffer;
  // ptr
  unsigned char *ptr;
  // storage
  signed long int storage;
};

union anonymous$14
{
  // frame_number
  unsigned int frame_number;
  // sample_number
  unsigned long int sample_number;
};

struct anonymous$15
{
  // blocksize
  unsigned int blocksize;
  // sample_rate
  unsigned int sample_rate;
  // channels
  unsigned int channels;
  // channel_assignment
  enum anonymous$12 channel_assignment;
  // bits_per_sample
  unsigned int bits_per_sample;
  // number_type
  enum anonymous$13 number_type;
  // number
  union anonymous$14 number;
  // crc
  unsigned char crc;
};

struct anonymous$16
{
  // crc
  unsigned short int crc;
};

struct anonymous$17
{
  // header
  struct anonymous$15 header;
  // subframes
  struct anonymous$11 subframes[8l];
  // footer
  struct anonymous$16 footer;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$22
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$23
{
  // __data
  struct anonymous$31 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous$24
{
  // mutex
  union anonymous$22 mutex;
  // main_cond
  union anonymous$23 main_cond;
  // play_cond
  union anonymous$23 play_cond;
  // key_cond
  union anonymous$23 key_cond;
  // exiting
  signed int exiting;
  // adev
  struct ao_device *adev;
  // fragment
  unsigned char *fragment;
  // fragment_size
  signed int fragment_size;
  // key_waiting
  signed int key_waiting;
  // exit_fd
  signed int exit_fd;
};

struct anonymous$30
{
  // offset
  unsigned long int offset;
  // number
  unsigned char number;
  // isrc
  char isrc[13l];
  // type
  unsigned int type : 1;
  // pre_emphasis
  unsigned int pre_emphasis : 1;
  // num_indices
  unsigned char num_indices;
  // indices
  struct anonymous$29 *indices;
};

struct anonymous$29
{
  // offset
  unsigned long int offset;
  // number
  unsigned char number;
};

struct anonymous$25
{
  // sample_number
  unsigned long int sample_number;
  // stream_offset
  unsigned long int stream_offset;
  // frame_samples
  unsigned int frame_samples;
};

union anonymous$34
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct vorbis_dsp_state
{
  // analysisp
  signed int analysisp;
  // vi
  struct vorbis_info *vi;
  // pcm
  float **pcm;
  // pcmret
  float **pcmret;
  // pcm_storage
  signed int pcm_storage;
  // pcm_current
  signed int pcm_current;
  // pcm_returned
  signed int pcm_returned;
  // preextrapolate
  signed int preextrapolate;
  // eofflag
  signed int eofflag;
  // lW
  signed long int lW;
  // W
  signed long int W;
  // nW
  signed long int nW;
  // centerW
  signed long int centerW;
  // granulepos
  signed long int granulepos;
  // sequence
  signed long int sequence;
  // glue_bits
  signed long int glue_bits;
  // time_bits
  signed long int time_bits;
  // floor_bits
  signed long int floor_bits;
  // res_bits
  signed long int res_bits;
  // backend_state
  void *backend_state;
};

struct vorbis_block
{
  // pcm
  float **pcm;
  // opb
  struct anonymous$46 opb;
  // lW
  signed long int lW;
  // W
  signed long int W;
  // nW
  signed long int nW;
  // pcmend
  signed int pcmend;
  // mode
  signed int mode;
  // eofflag
  signed int eofflag;
  // granulepos
  signed long int granulepos;
  // sequence
  signed long int sequence;
  // vd
  struct vorbis_dsp_state *vd;
  // localstore
  void *localstore;
  // localtop
  signed long int localtop;
  // localalloc
  signed long int localalloc;
  // totaluse
  signed long int totaluse;
  // reap
  struct alloc_chain *reap;
  // glue_bits
  signed long int glue_bits;
  // time_bits
  signed long int time_bits;
  // floor_bits
  signed long int floor_bits;
  // res_bits
  signed long int res_bits;
  // internal
  void *internal;
};

struct OggVorbis_File
{
  // datasource
  void *datasource;
  // seekable
  signed int seekable;
  // offset
  signed long int offset;
  // end
  signed long int end;
  // oy
  struct anonymous$50 oy;
  // links
  signed int links;
  // offsets
  signed long int *offsets;
  // dataoffsets
  signed long int *dataoffsets;
  // serialnos
  signed long int *serialnos;
  // pcmlengths
  signed long int *pcmlengths;
  // vi
  struct vorbis_info *vi;
  // vc
  struct vorbis_comment *vc;
  // pcm_offset
  signed long int pcm_offset;
  // ready_state
  signed int ready_state;
  // current_serialno
  signed long int current_serialno;
  // current_link
  signed int current_link;
  // bittrack
  double bittrack;
  // samptrack
  double samptrack;
  // os
  struct anonymous$51 os;
  // vd
  struct vorbis_dsp_state vd;
  // vb
  struct vorbis_block vb;
  // callbacks
  struct anonymous$49 callbacks;
};

struct OpusFileCallbacks
{
  // read
  signed int (*read)(void *, unsigned char *, signed int);
  // seek
  signed int (*seek)(void *, signed long long int, signed int);
  // tell
  signed long long int (*tell)(void *);
  // close
  signed int (*close)(void *);
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct alloc_chain
{
  // ptr
  void *ptr;
  // next
  struct alloc_chain *next;
};

struct ao_info
{
  // type
  signed int type;
  // name
  char *name;
  // short_name
  char *short_name;
  // author
  char *author;
  // comment
  char *comment;
  // preferred_byte_format
  signed int preferred_byte_format;
  // priority
  signed int priority;
  // options
  char **options;
  // option_count
  signed int option_count;
};

struct ao_option
{
  // key
  char *key;
  // value
  char *value;
  // next
  struct ao_option *next;
};

struct ao_sample_format
{
  // bits
  signed int bits;
  // rate
  signed int rate;
  // channels
  signed int channels;
  // byte_format
  signed int byte_format;
  // matrix
  char *matrix;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct pcm_struct
{
  // name
  char *name;
  // rate
  signed int rate;
  // currentbits
  signed int currentbits;
  // nativebits
  signed int nativebits;
  // ch
  signed int ch;
  // matrix
  char *matrix;
  // mix
  char *mix;
  // data
  unsigned char *data;
  // size
  signed long int size;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct termtype
{
  // term_names
  char *term_names;
  // str_table
  char *str_table;
  // Booleans
  char *Booleans;
  // Numbers
  signed short int *Numbers;
  // Strings
  char **Strings;
  // ext_str_table
  char *ext_str_table;
  // ext_Names
  char **ext_Names;
  // num_Booleans
  unsigned short int num_Booleans;
  // num_Numbers
  unsigned short int num_Numbers;
  // num_Strings
  unsigned short int num_Strings;
  // ext_Booleans
  unsigned short int ext_Booleans;
  // ext_Numbers
  unsigned short int ext_Numbers;
  // ext_Strings
  unsigned short int ext_Strings;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct term
{
  // type
  struct termtype type;
  // Filedes
  signed short int Filedes;
  // Ottyb
  struct termios Ottyb;
  // Nttyb
  struct termios Nttyb;
  // _baudrate
  signed int _baudrate;
  // _termname
  char *_termname;
};

struct tinfo_fkeys
{
  // offset
  unsigned int offset;
  // code
  unsigned long int code;
};

struct tries
{
  // child
  struct tries *child;
  // sibling
  struct tries *sibling;
  // ch
  unsigned char ch;
  // value
  unsigned short int value;
};

struct vorbis_comment
{
  // user_comments
  char **user_comments;
  // comment_lengths
  signed int *comment_lengths;
  // comments
  signed int comments;
  // vendor
  char *vendor;
};

struct vorbis_info
{
  // version
  signed int version;
  // channels
  signed int channels;
  // rate
  signed long int rate;
  // bitrate_upper
  signed long int bitrate_upper;
  // bitrate_nominal
  signed long int bitrate_nominal;
  // bitrate_lower
  signed long int bitrate_lower;
  // bitrate_window
  signed long int bitrate_window;
  // codec_setup
  void *codec_setup;
};


// OV_CALLBACKS_NOCLOSE
// file /usr/include/vorbis/vorbisfile.h line 82
static struct anonymous$49 OV_CALLBACKS_NOCLOSE;
// OV_CALLBACKS_NOCLOSE
// file /usr/include/vorbis/vorbisfile.h line 82
static struct anonymous$49 OV_CALLBACKS_NOCLOSE = { .read_func=(unsigned long int (*)(void *, unsigned long int, unsigned long int, void *))fread, .seek_func=(signed int (*)(void *, signed long int, signed int))_ov_header_fseek_wrap,
    .close_func=(signed int (*)(void *))(void *)0,
    .tell_func=(signed long int (*)(void *))ftell };
// _nc_tinfo_fkeys
// file mincurses.c line 69
extern struct tinfo_fkeys _nc_tinfo_fkeys[];
// acs
// file mincurses.c line 498
static signed int acs = 0;
// acs_map
// file /usr/include/curses.h line 274
extern unsigned long int acs_map[];
// bg
// file mincurses.c line 500
static signed int bg = -1;
// blink
// file mincurses.c line 502
static signed int blink = 0;
// bold
// file mincurses.c line 501
static signed int bold = 0;
// boxrow
// file tty.c line 85
static signed int boxrow;
// buf
// file loader.c line 1271
unsigned char buf[36l];
// buf_fill
// file mincurses.c line 270
static signed int buf_fill = 0;
// chlist
// file audio.c line 364
static const char *chlist[14l] = { "X", "M", "L", "R", "C", "LFE", "SL", "SR", "BC", "BL", "BR", "CL", "CR", (const char *)(void *)0 };
// cur_term
// file /usr/include/term.h line 685
extern struct term *cur_term;
// cursor_line_offset
// file mincurses.c line 267
static signed int cursor_line_offset = 0;
// fg
// file mincurses.c line 499
static signed int fg = -1;
// fifo
// file mincurses.c line 88
signed int fifo[160l];
// fliprow
// file tty.c line 86
static signed int fliprow;
// force
// file tty.c line 42
static signed int force = 0;
// formats
// file loader.c line 1274
static struct anonymous$47 formats[8l];
// formats
// file loader.c line 1274
static struct anonymous$47 formats[8l] = { { .id_func=wav_id, .load_func=wav_load, .format="wav" },
    { .id_func=aiff_id, .load_func=aiff_load, .format="aiff" },
    { .id_func=flac_id, .load_func=flac_load, .format="flac" },
    { .id_func=oggflac_id, .load_func=oggflac_load, .format="oggflac" },
    { .id_func=vorbis_id, .load_func=vorbis_load, .format="oggvorbis" },
    { .id_func=opus_id, .load_func=opus_load, .format="oggopus" },
    { .id_func=sw_id, .load_func=sw_load, .format="sw" },
    { .id_func=(signed int (*)(char *, unsigned char *))(void *)0, .load_func=(struct pcm_struct * (*)(char *, struct _IO_FILE *))(void *)0,
    .format=(char *)(void *)0 } };
// head
// file mincurses.c line 143
static signed int head = -1;
// initted
// file mincurses.c line 266
static signed int initted = 0;
// key_init
// file mincurses.c line 89
signed int key_init = 0;
// keytree
// file mincurses.c line 87
struct tries *keytree = (struct tries *)(void *)0;
// left_mix
// file audio.c line 166
static const float left_mix[33l] = { (const float)1., (const float)1., (const float)0., (const float)0.707, (const float)0.707, (const float)0.866, (const float)0.5, (const float)0.791, (const float)0.612, (const float)0.612, (const float)0.866, (const float)0.5, (const float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f };
// long_options
// file main.c line 56
struct option long_options[24l] = { { .name="ab", .has_arg=0, .flag=((signed int *)NULL), .val=97 },
    { .name="abx", .has_arg=0, .flag=((signed int *)NULL), .val=98 },
    { .name="beep-flip", .has_arg=0, .flag=((signed int *)NULL), .val=66 },
    { .name="casual", .has_arg=0, .flag=((signed int *)NULL), .val=99 },
    { .name="device", .has_arg=1, .flag=((signed int *)NULL), .val=100 },
    { .name="force-dither", .has_arg=0, .flag=((signed int *)NULL), .val=68 },
    { .name="end-time", .has_arg=0, .flag=((signed int *)NULL), .val=101 },
    { .name="gabbagabbahey", .has_arg=0, .flag=((signed int *)NULL), .val=103 },
    { .name="score-display", .has_arg=0, .flag=((signed int *)NULL), .val=103 },
    { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="mark-flip", .has_arg=0, .flag=((signed int *)NULL), .val=77 },
    { .name="trials", .has_arg=1, .flag=((signed int *)NULL), .val=110 },
    { .name="do-not-normalize", .has_arg=0, .flag=((signed int *)NULL), .val=78 },
    { .name="restart-after", .has_arg=0, .flag=((signed int *)NULL), .val=114 },
    { .name="restart-every", .has_arg=0, .flag=((signed int *)NULL), .val=82 },
    { .name="start-time", .has_arg=1, .flag=((signed int *)NULL), .val=115 },
    { .name="seamless-flip", .has_arg=0, .flag=((signed int *)NULL), .val=83 },
    { .name="force-truncate", .has_arg=0, .flag=((signed int *)NULL), .val=116 },
    { .name="verbose", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=86 },
    { .name="xxy", .has_arg=0, .flag=((signed int *)NULL), .val=120 },
    { .name="downmix-to-mono", .has_arg=0, .flag=((signed int *)NULL), .val=49 },
    { .name="downmix-to-stereo", .has_arg=0, .flag=((signed int *)NULL),
    .val=50 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// opus_callbacks
// file loader.c line 1159
static struct OpusFileCallbacks opus_callbacks;
// opus_callbacks
// file loader.c line 1159
static struct OpusFileCallbacks opus_callbacks = { .read=opc_read, .seek=opc_seek, .tell=opc_tell, .close=opc_close };
// orig
// file mincurses.c line 262
struct termios orig;
// outbuf
// file mincurses.c line 269
static char outbuf[160l];
// outfd
// file mincurses.c line 265
static signed int outfd;
// p_b
// file tty.c line 43
static signed int p_b;
// p_ch
// file tty.c line 43
static signed int p_ch;
// p_cur
// file tty.c line 44
static double p_cur;
// p_end
// file tty.c line 44
static double p_end;
// p_fm
// file tty.c line 43
static signed int p_fm;
// p_g
// file tty.c line 43
static signed int p_g;
// p_keymap
// file tty.c line 701
static signed int p_keymap = 0;
// p_len
// file tty.c line 44
static double p_len;
// p_pau
// file tty.c line 43
static signed int p_pau;
// p_pl
// file tty.c line 43
static signed int p_pl;
// p_r
// file tty.c line 43
static signed int p_r;
// p_rm
// file tty.c line 43
static signed int p_rm;
// p_st
// file tty.c line 44
static double p_st;
// p_tc
// file tty.c line 45
static char p_tc[150l];
// p_tl
// file tty.c line 45
static char p_tl[150l];
// p_tm
// file tty.c line 43
static signed int p_tm;
// p_tmax
// file tty.c line 43
static signed int p_tmax;
// p_tn
// file tty.c line 43
static signed int p_tn;
// p_tr
// file tty.c line 43
static signed int p_tr;
// panel_lines
// file mincurses.c line 268
static signed int panel_lines = 0;
// pcm_n
// file tty.c line 43
static signed int pcm_n;
// pcm_p
// file tty.c line 46
static struct pcm_struct **pcm_p;
// peek
// file mincurses.c line 145
static signed int peek = 0;
// playrow
// file tty.c line 83
static signed int playrow;
// rev
// file mincurses.c line 503
static signed int rev = 0;
// right_mix
// file audio.c line 182
static const float right_mix[33l] = { (const float)1., (const float)0., (const float)1., (const float)0.707, (const float)0.707, (const float)0.5, (const float)0.866, (const float)0.612, (const float)0.791, (const float)0.612, (const float)0.5, (const float)0.866, (const float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f };
// sb_verbose
// file main.c line 52
signed int sb_verbose = 0;
// short_options
// file main.c line 54
char *short_options = "abcd:De:hn:NrRs:tvVxBMSg12";
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// strnames
// file /usr/include/term.h line 717
extern const char * const strnames[];
// tail
// file mincurses.c line 144
static signed int tail = 0;
// term
// file mincurses.c line 263
struct termios term;
// timebuffer
// file tty.c line 48
static char timebuffer[80l];
// timerow
// file tty.c line 82
static signed int timerow;
// toprow
// file tty.c line 84
static signed int toprow;
// ul
// file mincurses.c line 504
static signed int ul = 0;
// was
// file tty.c line 361
static signed int was = -1;

// _ov_header_fseek_wrap
// file /usr/include/vorbis/vorbisfile.h line 53
static signed int _ov_header_fseek_wrap(struct _IO_FILE *f, signed long int off, signed int whence)
{
  if(f == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    signed int return_value_fseek$1;
    return_value_fseek$1=fseek(f, off, whence);
    return return_value_fseek$1;
  }
}

// aiff_id
// file loader.c line 94
static signed int aiff_id(char *path, unsigned char *buf)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)buf, (const void *)"FORM", (unsigned long int)4);
  if(!(return_value_memcmp$1 == 0))
    return 0;

  else
  {
    signed int return_value_memcmp$2;
    return_value_memcmp$2=memcmp((const void *)(buf + (signed long int)8), (const void *)"AIF", (unsigned long int)3);
    if(!(return_value_memcmp$2 == 0))
      return 0;

    else
      if(!((signed int)buf[11l] == 67))
      {
        if((signed int)buf[11l] == 70)
          goto __CPROVER_DUMP_L3;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return 1;
      }
  }
}

// aiff_load
// file loader.c line 487
static struct pcm_struct * aiff_load(char *path, struct _IO_FILE *in)
{
  struct pcm_struct *pcm = (struct pcm_struct *)(void *)0;
  signed int aifc;
  unsigned int len;
  unsigned char *buffer;
  unsigned char buf2[12l];
  signed int bend = 1;
  signed int fp = 0;
  signed int return_value_fseek$1;
  return_value_fseek$1=fseek(in, (signed long int)0, 0);
  unsigned long int return_value_fread$2;
  void *return_value_calloc$3;
  char *return_value_trim_path$4;
  char *return_value___strdup$5;
  signed int return_value_find_aiff_chunk$6;
  void *return_value___builtin_alloca$7;
  unsigned long int return_value_fread$8;
  double return_value_read_IEEE80$9;
  char *return_value___strdup$10;
  char *return_value___strdup$11;
  char *return_value___strdup$12;
  char *return_value___strdup$13;
  char *return_value___strdup$14;
  char *return_value___strdup$15;
  char *return_value___strdup$16;
  char *return_value___strdup$17;
  _Bool tmp_if_expr$22;
  signed int return_value_memcmp$21;
  signed int return_value_memcmp$19;
  signed int return_value_memcmp$18;
  signed int return_value_find_aiff_chunk$23;
  unsigned long int return_value_fread$24;
  signed int offset;
  _Bool tmp_if_expr$28;
  _Bool tmp_if_expr$25;
  _Bool tmp_if_expr$26;
  _Bool tmp_if_expr$27;
  _Bool tmp_if_expr$30;
  _Bool tmp_if_expr$29;
  signed long int tmp_if_expr$35;
  if(return_value_fseek$1 == -1)
    fprintf(stderr, "%s: Failed to seek\n", path);

  else
  {
    return_value_fread$2=fread((void *)buf2, (unsigned long int)1, (unsigned long int)12, in);
    if(!(return_value_fread$2 == 12ul))
      fprintf(stderr, "%s: Failed to read AIFF header\n", path);

    else
    {
      return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct pcm_struct) /*56ul*/ );
      pcm = (struct pcm_struct *)return_value_calloc$3;
      return_value_trim_path$4=trim_path(path);
      return_value___strdup$5=__strdup(return_value_trim_path$4);
      pcm->name = return_value___strdup$5;
      if((signed int)buf2[11l] == 67)
        aifc = 1;

      else
        aifc = 0;
      return_value_find_aiff_chunk$6=find_aiff_chunk(in, path, "COMM", &len);
      if(return_value_find_aiff_chunk$6 == 0)
        fprintf(stderr, "%s: No common chunk found in AIFF file\n", path);

      else
        if(!(len >= 18u))
          fprintf(stderr, "%s: Truncated common chunk in AIFF header\n", path);

        else
        {
          return_value___builtin_alloca$7=__builtin_alloca((unsigned long int)len);
          buffer = (unsigned char *)return_value___builtin_alloca$7;
          return_value_fread$8=fread((void *)buffer, (unsigned long int)1, (unsigned long int)len, in);
          if(!(return_value_fread$8 >= (unsigned long int)len))
            fprintf(stderr, "%s: Unexpected EOF in reading AIFF header\n", path);

          else
          {
            pcm->ch = (signed int)buffer[(signed long int)0] << 8 | (signed int)buffer[(signed long int)1] & 0xff;
            return_value_read_IEEE80$9=read_IEEE80(buffer + (signed long int)8);
            pcm->rate = (signed int)return_value_read_IEEE80$9;
            pcm->nativebits = (signed int)(buffer + (signed long int)6)[(signed long int)0] << 8 | (signed int)(buffer + (signed long int)6)[(signed long int)1] & 0xff;
            pcm->size = (signed long int)(((signed int)(buffer + (signed long int)2)[(signed long int)0] << 24 | (signed int)(buffer + (signed long int)2)[(signed long int)1] << 16 | (signed int)(buffer + (signed long int)2)[(signed long int)2] << 8 | (signed int)(buffer + (signed long int)2)[(signed long int)3] & 0xff) * pcm->ch * ((pcm->nativebits + 7) / 8));
            pcm->currentbits = -32;
            switch(pcm->ch)
            {
              case 1:
              {
                return_value___strdup$10=__strdup("M");
                pcm->matrix = return_value___strdup$10;
                return_value___strdup$11=__strdup("A");
                pcm->mix = return_value___strdup$11;
                break;
              }
              case 2:
              {
                return_value___strdup$12=__strdup("L,R");
                pcm->matrix = return_value___strdup$12;
                return_value___strdup$13=__strdup("BC");
                pcm->mix = return_value___strdup$13;
                break;
              }
              case 3:
              {
                return_value___strdup$14=__strdup("L,R,C");
                pcm->matrix = return_value___strdup$14;
                return_value___strdup$15=__strdup("BCD");
                pcm->mix = return_value___strdup$15;
                break;
              }
              default:
              {
                return_value___strdup$16=__strdup("L,R,BL,BR");
                pcm->matrix = return_value___strdup$16;
                return_value___strdup$17=__strdup("BCFG");
                pcm->mix = return_value___strdup$17;
              }
            }
            if(!(aifc == 0))
            {
              if(!(len >= 22u))
              {
                fprintf(stderr, "%s: AIFF-C header truncated.\n", path);
                goto err;
              }

              signed int return_value_memcmp$20;
              return_value_memcmp$20=memcmp((const void *)(buffer + (signed long int)18), (const void *)"NONE", (unsigned long int)4);
              if(return_value_memcmp$20 == 0)
                tmp_if_expr$22 = (_Bool)1;

              else
              {
                return_value_memcmp$21=memcmp((const void *)(buffer + (signed long int)18), (const void *)"twos", (unsigned long int)4);
                tmp_if_expr$22 = !(return_value_memcmp$21 != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$22)
                bend = 1;

              else
              {
                return_value_memcmp$19=memcmp((const void *)(buffer + (signed long int)18), (const void *)"sowt", (unsigned long int)4);
                if(return_value_memcmp$19 == 0)
                  bend = 0;

                else
                {
                  return_value_memcmp$18=memcmp((const void *)(buffer + (signed long int)18), (const void *)"fl32", (unsigned long int)4);
                  if(return_value_memcmp$18 == 0)
                  {
                    bend = 1;
                    fp = 1;
                  }

                  else
                  {
                    fprintf(stderr, "%s: Can't handle compressed AIFF-C (%c%c%c%c)\n", path, buffer[(signed long int)18], buffer[(signed long int)19], buffer[(signed long int)20], buffer[(signed long int)21]);
                    goto err;
                  }
                }
              }
            }

            return_value_find_aiff_chunk$23=find_aiff_chunk(in, path, "SSND", &len);
            if(return_value_find_aiff_chunk$23 == 0)
              fprintf(stderr, "%s: No SSND chunk found in AIFF file\n", path);

            else
              if(!(len >= 8u))
                fprintf(stderr, "%s: Corrupted SSND chunk in AIFF header\n", path);

              else
              {
                return_value_fread$24=fread((void *)buf2, (unsigned long int)1, (unsigned long int)8, in);
                if(!(return_value_fread$24 >= 8ul))
                  fprintf(stderr, "%s: Unexpected EOF reading AIFF header\n", path);

                else
                {
                  offset = (signed int)buf2[(signed long int)0] << 24 | (signed int)buf2[(signed long int)1] << 16 | (signed int)buf2[(signed long int)2] << 8 | (signed int)buf2[(signed long int)3] & 0xff;
                  if(fp == 0)
                  {
                    if(pcm->nativebits == 32)
                      tmp_if_expr$25 = (_Bool)1;

                    else
                      tmp_if_expr$25 = pcm->nativebits == 24 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr$25)
                      tmp_if_expr$26 = (_Bool)1;

                    else
                      tmp_if_expr$26 = pcm->nativebits == 16 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr$26)
                      tmp_if_expr$27 = (_Bool)1;

                    else
                      tmp_if_expr$27 = pcm->nativebits == 8 ? (_Bool)1 : (_Bool)0;
                    tmp_if_expr$28 = tmp_if_expr$27 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr$28 = (_Bool)0;
                  if(tmp_if_expr$28)
                    tmp_if_expr$30 = (_Bool)1;

                  else
                  {
                    if(fp == 1)
                      tmp_if_expr$29 = pcm->nativebits == 32 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$29 = (_Bool)0;
                    tmp_if_expr$30 = tmp_if_expr$29 ? (_Bool)1 : (_Bool)0;
                  }
                  if(!tmp_if_expr$30)
                    fprintf(stderr, "%s: Unsupported type of AIFF/AIFC file\n Must be 8-, 16-, 24- or 32-bit integer or 32-bit floating point PCM.\n", path);

                  else
                  {
                    if(fp == 1)
                      pcm->nativebits = -pcm->nativebits;

                    fseek(in, (signed long int)offset, 1);
                    if(!(pcm->nativebits == 8))
                    {
                      if(pcm->nativebits == 16)
                        goto __CPROVER_DUMP_L39;

                      if(pcm->nativebits == 24)
                        goto __CPROVER_DUMP_L40;

                      if(pcm->nativebits == 32 || pcm->nativebits == -32)
                        goto __CPROVER_DUMP_L41;

                    }

                    else
                    {
                      void *return_value_calloc$31;
                      return_value_calloc$31=calloc((unsigned long int)1, (unsigned long int)pcm->size * sizeof(float) /*4ul*/ );
                      pcm->data = (unsigned char *)return_value_calloc$31;
                      goto __CPROVER_DUMP_L42;

                    __CPROVER_DUMP_L39:
                      ;
                      void *return_value_calloc$32;
                      return_value_calloc$32=calloc((unsigned long int)1, (unsigned long int)(pcm->size / (signed long int)2) * sizeof(float) /*4ul*/ );
                      pcm->data = (unsigned char *)return_value_calloc$32;
                      goto __CPROVER_DUMP_L42;

                    __CPROVER_DUMP_L40:
                      ;
                      void *return_value_calloc$33;
                      return_value_calloc$33=calloc((unsigned long int)1, (unsigned long int)(pcm->size / (signed long int)3) * sizeof(float) /*4ul*/ );
                      pcm->data = (unsigned char *)return_value_calloc$33;
                      goto __CPROVER_DUMP_L42;

                    __CPROVER_DUMP_L41:
                      ;
                      void *return_value_calloc$34;
                      return_value_calloc$34=calloc((unsigned long int)1, (unsigned long int)(pcm->size / (signed long int)4) * sizeof(float) /*4ul*/ );
                      pcm->data = (unsigned char *)return_value_calloc$34;
                      goto __CPROVER_DUMP_L42;
                    }

                  __CPROVER_DUMP_L42:
                    ;
                    if(pcm->data == ((unsigned char *)NULL))
                      fprintf(stderr, "Unable to allocate enough memory to load sample into memory\n");

                    else
                    {
                      unsigned char *d = pcm->data;
                      float *f = (float *)pcm->data;
                      signed long int j = (signed long int)0;
                      signed long int k;
                      while(!(j >= pcm->size))
                      {
                        signed long int bytes;
                        if(pcm->size + -j >= 65537l)
                          tmp_if_expr$35 = (signed long int)65536;

                        else
                          tmp_if_expr$35 = pcm->size - j;
                        bytes = tmp_if_expr$35;
                        if(!(sb_verbose == 0))
                          fprintf(stderr, "\rLoading %s: %ld to go...       \r", pcm->name, (signed long int)(pcm->size - j));

                        unsigned long int return_value_fread$36;
                        return_value_fread$36=fread((void *)(d + j), (unsigned long int)1, (unsigned long int)bytes, in);
                        bytes = (signed long int)return_value_fread$36;
                        j = j + bytes;
                        if(bytes == 0l)
                          break;

                      }
                      if(!(j >= pcm->size))
                      {
                        if(!(sb_verbose == 0))
                          fprintf(stderr, "\r%s: File ended before declared length (%ld < %ld); continuing...\n", path, (signed long int)j, (signed long int)pcm->size);

                        pcm->size = j;
                      }

                      if(!(sb_verbose == 0))
                        fprintf(stderr, "\rLoading %s: parsing...      ", pcm->name);

                      if(!(pcm->nativebits == 8))
                      {
                        if(pcm->nativebits == 16)
                          goto __CPROVER_DUMP_L56;

                        if(pcm->nativebits == 24)
                          goto __CPROVER_DUMP_L62;

                        if(pcm->nativebits == 32)
                          goto __CPROVER_DUMP_L68;

                        if(pcm->nativebits == -32)
                          goto __CPROVER_DUMP_L74;

                      }

                      else
                      {
                        k = pcm->size;
                        j = pcm->size - (signed long int)1;
                        for( ; j >= 0l; j = j - 1l)
                        {
                          k = k - 1l;
                          f[k] = (float)(signed int)((signed int)d[j] - 128 << 24) * (1.f / 2147483648.f);
                        }
                        pcm->size = (signed long int)((unsigned long int)pcm->size * sizeof(float) /*4ul*/ );
                        goto __CPROVER_DUMP_L85;

                      __CPROVER_DUMP_L56:
                        ;
                        k = pcm->size / (signed long int)2;
                        if(!(bend == 0))
                        {
                          j = pcm->size - (signed long int)2;
                          for( ; j >= 0l; j = j - (signed long int)2)
                          {
                            k = k - 1l;
                            f[k] = (float)(signed int)((signed int)d[j] << 24 | (signed int)d[j + (signed long int)1] << 16) * (1.f / 2147483648.f);
                          }
                        }

                        else
                        {
                          j = pcm->size - (signed long int)2;
                          for( ; j >= 0l; j = j - (signed long int)2)
                          {
                            k = k - 1l;
                            f[k] = (float)(signed int)((signed int)d[j] << 16 | (signed int)d[j + (signed long int)1] << 24) * (1.f / 2147483648.f);
                          }
                        }
                        pcm->size = (signed long int)((unsigned long int)(pcm->size / (signed long int)2) * sizeof(float) /*4ul*/ );
                        goto __CPROVER_DUMP_L85;

                      __CPROVER_DUMP_L62:
                        ;
                        k = pcm->size / (signed long int)3;
                        if(!(bend == 0))
                        {
                          j = pcm->size - (signed long int)3;
                          for( ; j >= 0l; j = j - (signed long int)3)
                          {
                            k = k - 1l;
                            f[k] = (float)(signed int)((signed int)d[j + (signed long int)2] | (signed int)d[j + (signed long int)1] << 8 | (signed int)d[j] << 16) * (1.f / 2147483648.f);
                          }
                        }

                        else
                        {
                          j = pcm->size - (signed long int)3;
                          for( ; j >= 0l; j = j - (signed long int)3)
                          {
                            k = k - 1l;
                            f[k] = (float)(signed int)((signed int)d[j] | (signed int)d[j + (signed long int)1] << 8 | (signed int)d[j + (signed long int)2] << 16) * (1.f / 2147483648.f);
                          }
                        }
                        pcm->size = (signed long int)((unsigned long int)(pcm->size / (signed long int)3) * sizeof(float) /*4ul*/ );
                        goto __CPROVER_DUMP_L85;

                      __CPROVER_DUMP_L68:
                        ;
                        k = pcm->size / (signed long int)4;
                        if(!(bend == 0))
                        {
                          j = pcm->size - (signed long int)4;
                          for( ; j >= 0l; j = j - (signed long int)4)
                          {
                            k = k - 1l;
                            f[k] = (float)(signed int)((signed int)d[j + (signed long int)3] | (signed int)d[j + (signed long int)2] << 8 | (signed int)d[j + (signed long int)1] << 16 | (signed int)d[j] << 24) * (1.f / 2147483648.f);
                          }
                        }

                        else
                        {
                          j = pcm->size - (signed long int)4;
                          for( ; j >= 0l; j = j - (signed long int)4)
                          {
                            k = k - 1l;
                            f[k] = (float)(signed int)((signed int)d[j] | (signed int)d[j + (signed long int)1] << 8 | (signed int)d[j + (signed long int)2] << 16 | (signed int)d[j + (signed long int)3] << 24) * (1.f / 2147483648.f);
                          }
                        }
                        pcm->size = (signed long int)((unsigned long int)(pcm->size / (signed long int)4) * sizeof(float) /*4ul*/ );
                        goto __CPROVER_DUMP_L85;

                      __CPROVER_DUMP_L74:
                        ;
                        k = pcm->size / (signed long int)4;
                        j = pcm->size - (signed long int)4;
                        for( ; j >= 0l; j = j - (signed long int)4)
                        {
                          signed int val = 0;
                          signed int mantissa;
                          signed int exponent;
                          signed int sign;
                          if(!(bend == 0))
                          {
                            mantissa = (signed int)d[j + (signed long int)3] | (signed int)d[j + (signed long int)2] << 8 | ((signed int)d[j + (signed long int)1] & 0x7f) << 16 | 1 << 23;
                            exponent = 127 - ((signed int)d[j + (signed long int)1] >> 7 | ((signed int)d[j] & 0x7f) << 1);
                            sign = (signed int)d[j] >> 7;
                          }

                          else
                          {
                            mantissa = (signed int)d[j] | (signed int)d[j + (signed long int)1] << 8 | ((signed int)d[j + (signed long int)2] & 0x7f) << 16 | 1 << 23;
                            exponent = 127 - ((signed int)d[j + (signed long int)2] >> 7 | ((signed int)d[j + (signed long int)3] & 0x7f) << 1);
                            sign = (signed int)d[j + (signed long int)3] >> 7;
                          }
                          if(!(exponent >= 1))
                          {
                            if(exponent == -128)
                            {
                              fprintf(stderr, "%s: Input file contains invalid floating point values.\n", pcm->name);
                              exit(6);
                            }

                            if(!(sign == 0))
                              val = 8388608;

                            else
                              val = 8388607;
                          }

                          else
                            if(!(exponent >= 25))
                            {
                              val = mantissa >> exponent;
                              if((1 & val) + (0xffffff & mantissa << 24 + -exponent) >= 8388609)
                                val = val + 1;

                            }

                          if(!(sign == 0))
                            val = -val;

                          k = k - 1l;
                          f[k] = (float)((double)val / 8388608.);
                        }
                        pcm->size = (signed long int)((unsigned long int)(pcm->size / (signed long int)4) * sizeof(float) /*4ul*/ );
                      }

                    __CPROVER_DUMP_L85:
                      ;
                      if(!(sb_verbose == 0))
                        fprintf(stderr, "\rLoading %s: loaded.         ", pcm->name);

                      return pcm;
                    }
                  }
                }
              }
          }
        }
    }
  }

err:
  ;
  free_pcm(pcm);
  return (struct pcm_struct *)(void *)0;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// check_warn_clipping
// file audio.c line 57
extern float check_warn_clipping(struct pcm_struct *pcm, signed int no_normalize)
{
  signed int i;
  signed int j;
  signed int cpf = pcm->ch;
  signed int s = (signed int)((unsigned long int)pcm->size / sizeof(float) /*4ul*/ );
  float clamp;
  float min;
  float max;
  const signed long int max$array_size0 = (signed long int)cpf;
  signed int flag[max$array_size0];
  unsigned long int count = (unsigned long int)0;
  float *d = (float *)pcm->data;
  memset((void *)flag, 0, 4ul * (unsigned long int)max$array_size0);
  if(!(sb_verbose == 0))
    fprintf(stderr, "\rLoading %s: checking for clipping...", pcm->name);

  max=get_clamp(pcm);
  clamp = max;
  min = -1.f;
  i = 0;
  for( ; !(i >= s); i = i + pcm->ch)
  {
    j = 0;
    for( ; !(j >= pcm->ch); j = j + 1)
      if(d[(signed long int)(i + j)] < -1.000000f)
      {
        if(d[(signed long int)(i + j)] < min)
          min = d[(signed long int)(i + j)];

        flag[(signed long int)j] = flag[(signed long int)j] + 1;
      }

      else
        if(d[(signed long int)(i + j)] > clamp)
        {
          if(d[(signed long int)(i + j)] > max)
            max = d[(signed long int)(i + j)];

          flag[(signed long int)j] = flag[(signed long int)j] + 1;
        }

        else
        {
          if(flag[(signed long int)j] >= 2)
            count = count + (unsigned long int)flag[(signed long int)j];

          flag[(signed long int)j] = 0;
        }
  }
  j = 0;
  for( ; !(j >= cpf); j = j + 1)
    if(flag[(signed long int)j] >= 2)
      count = count + (unsigned long int)flag[(signed long int)j];

  double tmp_if_expr$2;
  double return_value_log$1;
  if(!(count == 0ul))
  {
    if(!(sb_verbose == 0))
      fprintf(stderr, "\n");

    if(pcm->nativebits >= 1)
    {
      fprintf(stderr, "CLIPPING WARNING: %ld probably clipped samples in %s;\n", (signed long int)count, pcm->name);
      fprintf(stderr, "                  (can't be repaired with normalization)\n");
    }

    else
      if(!(no_normalize == 0))
      {
        fprintf(stderr, "CLIPPING WARNING: %ld clipped samples in %s;\n", (signed long int)count, pcm->name);
        fprintf(stderr, "                  normalization disabled on command line.\n");
      }

      else
      {
        float att = (float)(-1. / (double)min);
        if(clamp / max < att)
          att = clamp / max;

        if(!(sb_verbose == 0))
        {
          if(IEEE_FLOAT_EQUAL(1. / (double)att, 0.000000))
            tmp_if_expr$2 = (double)-400.f;

          else
          {
            return_value_log$1=log((1. / (double)att) * (1. / (double)att));
            tmp_if_expr$2 = return_value_log$1 * (double)4.34294480f;
          }
          fprintf(stderr, "%ld overrange samples after decoding %s (peak %+0.1fdB)\n", (signed long int)count, pcm->name, tmp_if_expr$2);
        }

        return att;
      }
  }

  else
    if(!(sb_verbose == 0))
      fprintf(stderr, "\rLoading %s: done.                   \n", pcm->name);

  return (float)1.;
}

// compute_pdual
// file main.c line 248
extern double compute_pdual(signed int score, signed int tests)
{
  signed int i;
  double p = (double)0;
  if(!(score >= tests + -score))
    score = tests - score;

  i = score;
  for( ; tests >= i; i = i + 1)
  {
    double lp;
    double return_value_pow$1;
    return_value_pow$1=pow(.5, (double)tests);
    double return_value_factorial$2;
    return_value_factorial$2=factorial(tests);
    double return_value_factorial$3;
    return_value_factorial$3=factorial(tests - i);
    double return_value_factorial$4;
    return_value_factorial$4=factorial(i);
    lp = return_value_pow$1 * (return_value_factorial$2 / (return_value_factorial$3 * return_value_factorial$4));
    if(!(tests + -i == i))
      lp = lp * (double)2;

    p = p + lp;
  }
  return p;
}

// compute_psingle
// file main.c line 239
extern double compute_psingle(signed int correct, signed int tests)
{
  signed int i;
  double p = (double)0;
  i = correct;
  double return_value_pow$1;
  double return_value_factorial$2;
  double return_value_factorial$3;
  double return_value_factorial$4;
  for( ; tests >= i; i = i + 1)
  {
    return_value_pow$1=pow(.5, (double)tests);
    return_value_factorial$2=factorial(tests);
    return_value_factorial$3=factorial(tests - i);
    return_value_factorial$4=factorial(i);
    p = p + return_value_pow$1 * (return_value_factorial$2 / (return_value_factorial$3 * return_value_factorial$4));
  }
  return p;
}

// convert_to_16
// file audio.c line 319
extern void convert_to_16(struct pcm_struct *pcm, signed int dither)
{
  unsigned char *d = pcm->data;
  float *f = (float *)pcm->data;
  signed long int j;
  const signed long int j$array_size0 = (signed long int)pcm->ch;
  float t[j$array_size0];
  signed int ch = 0;
  memset((void *)t, 0, 4ul * (unsigned long int)j$array_size0);
  if(!(sb_verbose == 0))
    fprintf(stderr, "\r%s %s to 16 bit... ", dither != 0 ? "Dithering" : "Down-converting", pcm->name);

  j = (signed long int)0;
  for( ; !((unsigned long int)j >= (unsigned long int)pcm->size / sizeof(float) /*4ul*/ ); j = j + 1l)
  {
    float val;
    if(!(dither == 0))
    {
      float return_value_triangle_ditherval$1;
      return_value_triangle_ditherval$1=triangle_ditherval(t + (signed long int)ch);
      double return_value_rint$2;
      return_value_rint$2=rint((double)(f[j] * 32768.f + return_value_triangle_ditherval$1));
      val = (float)return_value_rint$2;
      ch = ch + 1;
      if(!(pcm->ch >= ch))
        ch = 0;

    }

    else
    {
      double return_value_rint$3;
      return_value_rint$3=rint((double)(f[j] * 32768.f));
      val = (float)return_value_rint$3;
    }
    if(val >= 32767.f)
    {
      d[j * (signed long int)2] = (unsigned char)0xff;
      d[j * (signed long int)2 + (signed long int)1] = (unsigned char)0x7f;
    }

    else
      if(val <= -32768.000000f)
      {
        d[j * (signed long int)2] = (unsigned char)0x00;
        d[j * (signed long int)2 + (signed long int)1] = (unsigned char)0x80;
      }

      else
      {
        signed int iv = (signed int)val;
        d[j * (signed long int)2] = (unsigned char)(iv & 0xff);
        d[j * (signed long int)2 + (signed long int)1] = (unsigned char)(iv >> 8 & 0xff);
      }
  }
  if(!(sb_verbose == 0))
    fprintf(stderr, "done.\n");

  pcm->currentbits = 16;
  pcm->size = pcm->size / (signed long int)sizeof(float) /*4ul*/ ;
  pcm->size = pcm->size * (signed long int)2;
}

// convert_to_24
// file audio.c line 296
extern void convert_to_24(struct pcm_struct *pcm)
{
  unsigned char *d = pcm->data;
  float *f = (float *)pcm->data;
  signed long int j;
  if(!(sb_verbose == 0))
    fprintf(stderr, "\rConverting %s to 24 bit... ", pcm->name);

  j = (signed long int)0;
  for( ; !((unsigned long int)j >= (unsigned long int)pcm->size / sizeof(float) /*4ul*/ ); j = j + 1l)
  {
    float val;
    double return_value_rint$1;
    return_value_rint$1=rint((double)(f[j] * 8388608.f));
    val = (float)return_value_rint$1;
    signed int iv;
    if(val < -8.388608e+6f)
      val = -8388608.f;

    if(val > 8388607.f)
      val = 8388607.f;

    iv = (signed int)val;
    d[j * (signed long int)3] = (unsigned char)(iv & 0xff);
    d[j * (signed long int)3 + (signed long int)1] = (unsigned char)(iv >> 8 & 0xff);
    d[j * (signed long int)3 + (signed long int)2] = (unsigned char)(iv >> 16 & 0xff);
  }
  if(!(sb_verbose == 0))
    fprintf(stderr, "done.\n");

  pcm->currentbits = 24;
  pcm->size = pcm->size / (signed long int)sizeof(float) /*4ul*/ ;
  pcm->size = pcm->size * (signed long int)3;
}

// convert_to_32
// file audio.c line 272
extern void convert_to_32(struct pcm_struct *pcm)
{
  unsigned char *d = pcm->data;
  float *f = (float *)pcm->data;
  signed long int j;
  if(!(sb_verbose == 0))
    fprintf(stderr, "\rConverting %s to 32 bit... ", pcm->name);

  j = (signed long int)0;
  for( ; !((unsigned long int)j >= (unsigned long int)pcm->size / sizeof(float) /*4ul*/ ); j = j + 1l)
  {
    float val;
    double return_value_rint$1;
    return_value_rint$1=rint((double)(f[j] * 2147483648.f));
    val = (float)return_value_rint$1;
    signed int iv;
    if(val < -2.147484e+9f)
      val = -2147483648.f;

    if(val > 2147483647.f)
      val = 2147483647.f;

    iv = (signed int)val;
    d[j * (signed long int)4] = (unsigned char)(iv & 0xff);
    d[j * (signed long int)4 + (signed long int)1] = (unsigned char)(iv >> 8 & 0xff);
    d[j * (signed long int)4 + (signed long int)2] = (unsigned char)(iv >> 16 & 0xff);
    d[j * (signed long int)4 + (signed long int)3] = (unsigned char)(iv >> 24 & 0xff);
  }
  if(!(sb_verbose == 0))
    fprintf(stderr, "done.\n");

  pcm->currentbits = 32;
  pcm->size = pcm->size / (signed long int)sizeof(float) /*4ul*/ ;
  pcm->size = pcm->size * (signed long int)4;
}

// convert_to_mono
// file audio.c line 119
extern float convert_to_mono(struct pcm_struct *pcm)
{
  signed int i;
  signed int j;
  signed int k;
  signed int cpf = pcm->ch;
  signed int s = (signed int)((unsigned long int)pcm->size / sizeof(float) /*4ul*/ );
  float *d = (float *)pcm->data;
  float max = (float)0;
  float min = (float)0;
  float att = 1.f;
  float clamp;
  clamp=get_clamp(pcm);
  if(!(pcm->currentbits == -32))
  {
    fprintf(stderr, "Internal error; non-float PCM passed to convert_to_mono.\n");
    exit(10);
  }

  if(!(sb_verbose == 0))
    fprintf(stderr, "Downmixing to mono... ");

  k = 0;
  i = 0;
  signed int tmp_post$1;
  for( ; !(i >= s); i = i + cpf)
  {
    float acc = 0.f;
    j = 0;
    for( ; !(j >= cpf); j = j + 1)
      acc = acc + d[(signed long int)(i + j)];
    if(acc > max)
      max = acc;

    if(acc < min)
      min = acc;

    tmp_post$1 = k;
    k = k + 1;
    d[(signed long int)tmp_post$1] = acc;
  }
  pcm->size = pcm->size / (signed long int)cpf;
  pcm->ch = 1;
  if(!(pcm->matrix == ((char *)NULL)))
    free((void *)pcm->matrix);

  char *return_value___strdup$2;
  return_value___strdup$2=__strdup("M");
  pcm->matrix = return_value___strdup$2;
  if(min < -1.000000f)
    att = (float)(-1. / (double)min);

  if(clamp / max < att)
    att = clamp / max;

  double tmp_if_expr$4;
  double return_value_log$3;
  if(!(sb_verbose == 0))
  {
    if(att < 1.000000f)
    {
      if(IEEE_FLOAT_EQUAL(1. / (double)att, 0.000000))
        tmp_if_expr$4 = (double)-400.f;

      else
      {
        return_value_log$3=log((1. / (double)att) * (1. / (double)att));
        tmp_if_expr$4 = return_value_log$3 * (double)4.34294480f;
      }
      fprintf(stderr, "done. peak: %+0.1fdB\n", tmp_if_expr$4);
    }

    else
      fprintf(stderr, "done.\n");
  }

  return att;
}

// convert_to_stereo
// file audio.c line 199
extern float convert_to_stereo(struct pcm_struct *pcm)
{
  signed int i;
  signed int j;
  signed int k;
  signed int cpf = pcm->ch;
  signed int s = (signed int)((unsigned long int)pcm->size / sizeof(float) /*4ul*/ );
  float *d = (float *)pcm->data;
  float max = (float)0;
  float min = (float)0;
  float att = 1.f;
  float clamp;
  clamp=get_clamp(pcm);
  float *lmix;
  float *rmix;
  if(!(pcm->currentbits == -32))
  {
    fprintf(stderr, "Internal error; non-float PCM passed to convert_to_mono.\n");
    exit(10);
  }

  if(!(pcm->ch >= 2))
  {
    fprintf(stderr, "Internal error; can't downmix mono to stereo.\n");
    exit(10);
  }

  if(!(sb_verbose == 0))
    fprintf(stderr, "Downmixing to stereo... ");

  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)cpf, sizeof(float) /*4ul*/ );
  lmix = (float *)return_value_calloc$1;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)cpf, sizeof(float) /*4ul*/ );
  rmix = (float *)return_value_calloc$2;
  j = 0;
  for( ; !(j >= cpf); j = j + 1)
  {
    lmix[(signed long int)j] = left_mix[(signed long int)((signed int)pcm->mix[(signed long int)j] - 65)];
    rmix[(signed long int)j] = right_mix[(signed long int)((signed int)pcm->mix[(signed long int)j] - 65)];
  }
  k = 0;
  i = 0;
  signed int tmp_post$3;
  signed int tmp_post$4;
  for( ; !(i >= s); i = i + cpf)
  {
    float L = 0.f;
    float R = 0.f;
    j = 0;
    for( ; !(j >= cpf); j = j + 1)
    {
      L = L + d[(signed long int)(i + j)] * lmix[(signed long int)j];
      R = R + d[(signed long int)(i + j)] * rmix[(signed long int)j];
    }
    if(L > max)
      max = L;

    if(L < min)
      min = L;

    if(R > max)
      max = R;

    if(R < min)
      min = R;

    tmp_post$3 = k;
    k = k + 1;
    d[(signed long int)tmp_post$3] = L;
    tmp_post$4 = k;
    k = k + 1;
    d[(signed long int)tmp_post$4] = R;
  }
  pcm->size = (pcm->size / (signed long int)cpf) * (signed long int)2;
  pcm->ch = 2;
  if(!(pcm->matrix == ((char *)NULL)))
    free((void *)pcm->matrix);

  char *return_value___strdup$5;
  return_value___strdup$5=__strdup("L,R");
  pcm->matrix = return_value___strdup$5;
  if(min < -1.000000f)
    att = (float)(-1. / (double)min);

  if(clamp / max < att)
    att = clamp / max;

  double tmp_if_expr$7;
  double return_value_log$6;
  if(!(sb_verbose == 0))
  {
    if(att < 1.f)
    {
      if(IEEE_FLOAT_EQUAL(1. / (double)att, 0.000000))
        tmp_if_expr$7 = (double)-400.f;

      else
      {
        return_value_log$6=log((1. / (double)att) * (1. / (double)att));
        tmp_if_expr$7 = return_value_log$6 * (double)4.34294480f;
      }
      fprintf(stderr, "done. peak: %+0.1fdB\n", tmp_if_expr$7);
    }

    else
      fprintf(stderr, "done.\n");
  }

  return att;
}

// dottrim
// file tty.c line 477
char * dottrim(char *in, signed int l)
{
  signed int m;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(in);
  m = (signed int)return_value_strlen$1;
  if(!(l >= m))
  {
    if(!(l >= 1))
      return "";

    if(!(l >= 2))
      return ".";

    if(!(l >= 3))
      return "..";

    if(!(l >= 4))
      return "...";

    in = in + (signed long int)(m - l);
    in[(signed long int)2] = (char)46;
    in[(signed long int)1] = in[(signed long int)2];
    in[(signed long int)0] = in[(signed long int)1];
  }

  return in;
}

// draw_playbar
// file tty.c line 167
static signed int draw_playbar(signed int row)
{
  signed int pre;
  double return_value_floor$1;
  return_value_floor$1=floor((p_st / p_len) * (double)cur_term->type.Numbers[(signed long int)0]);
  pre = (signed int)return_value_floor$1;
  signed int post;
  double return_value_floor$2;
  return_value_floor$2=floor((p_end / p_len) * (double)cur_term->type.Numbers[(signed long int)0] + (double)1.e-6f);
  post = (signed int)return_value_floor$2;
  signed int i;
  playrow = row;
  if(!((signed int)*cur_term->type.Numbers + -1 >= post))
    post = (signed int)cur_term->type.Numbers[(signed long int)0] - 1;

  i = 0;
  min_mvcur(0, row);
  min_bg(6);
  for( ; !(i >= pre); i = i + 1)
    min_putchar(32);
  min_bg(0);
  for( ; post >= i; i = i + 1)
    min_putchar(32);
  min_bg(6);
  for( ; !(i >= (signed int)*cur_term->type.Numbers); i = i + 1)
    min_putchar(32);
  min_unset();
  return 1;
}

// draw_samples_box
// file tty.c line 229
static signed int draw_samples_box(signed int row)
{
  const signed long int draw_samples_box$array_size0 = (signed long int)((signed int)cur_term->type.Numbers[(signed long int)0] + 1);
  char draw_samples_box$$1$$buf[draw_samples_box$array_size0];
  signed int i;
  boxrow = row;
  fliprow = row + pcm_n + 1;
  fill(draw_samples_box$$1$$buf, (char)acs_map[(signed long int)(unsigned char)113], (signed int)cur_term->type.Numbers[(signed long int)0]);
  draw_samples_box$$1$$buf[(signed long int)0] = (char)acs_map[(signed long int)(unsigned char)108];
  draw_samples_box$$1$$buf[(signed long int)((signed int)cur_term->type.Numbers[(signed long int)0] - 1)] = (char)acs_map[(signed long int)(unsigned char)107];
  min_mvcur(0, row);
  min_gfx(1);
  min_fg(6);
  min_putstr(draw_samples_box$$1$$buf);
  i = 0;
  unsigned long int return_value_strlen$1;
  for( ; !(i >= pcm_n); i = i + 1)
  {
    min_mvcur(0, row + i + 1);
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)120]);
    min_unset();
    fill(draw_samples_box$$1$$buf, (char)32, (signed int)cur_term->type.Numbers[(signed long int)0] - 3);
    if(i == p_pl)
    {
      min_putchar(62);
      min_bold(1);
    }

    else
      min_putchar(32);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(pcm_p[(signed long int)i]->name);
    if(!((unsigned long int)((signed int)*cur_term->type.Numbers + -4) >= return_value_strlen$2))
    {
      return_value_strlen$1=strlen(pcm_p[(signed long int)i]->name);
      print_into(draw_samples_box$$1$$buf, 0, ((pcm_p[(signed long int)i]->name + (signed long int)return_value_strlen$1) - (signed long int)cur_term->type.Numbers[(signed long int)0]) + (signed long int)4);
    }

    else
      print_into(draw_samples_box$$1$$buf, 0, pcm_p[(signed long int)i]->name);
    min_putstr(draw_samples_box$$1$$buf);
    if(i == p_pl)
      min_bold(0);

    min_gfx(1);
    min_fg(6);
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)120]);
  }
  min_mvcur(0, row + pcm_n + 1);
  fill(draw_samples_box$$1$$buf, (char)acs_map[(signed long int)(unsigned char)113], (signed int)cur_term->type.Numbers[(signed long int)0]);
  draw_samples_box$$1$$buf[(signed long int)0] = (char)acs_map[(signed long int)(unsigned char)109];
  draw_samples_box$$1$$buf[(signed long int)((signed int)cur_term->type.Numbers[(signed long int)0] - 1)] = (char)acs_map[(signed long int)(unsigned char)106];
  min_putstr(draw_samples_box$$1$$buf);
  min_unset();
  return pcm_n + 2;
}

// draw_timebar
// file tty.c line 147
static signed int draw_timebar(signed int row)
{
  const signed long int draw_timebar$array_size0 = (signed long int)((signed int)cur_term->type.Numbers[(signed long int)0] + 1);
  char draw_timebar$$1$$buf[draw_timebar$array_size0];
  timerow = row;
  fill(draw_timebar$$1$$buf, (char)acs_map[(signed long int)(unsigned char)113], (signed int)cur_term->type.Numbers[(signed long int)0]);
  min_mvcur(0, row);
  min_gfx(1);
  min_fg(6);
  min_putstr(draw_timebar$$1$$buf);
  min_unset();
  min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] - 12, row);
  min_putchar(32);
  char *draw_timebar$$1$$1$$time;
  draw_timebar$$1$$1$$time=make_time_string(p_len, 1);
  min_putstr(draw_timebar$$1$$1$$time);
  return 1;
}

// draw_topbar
// file tty.c line 88
static signed int draw_topbar(signed int row)
{
  const signed long int draw_topbar$array_size0 = (signed long int)((signed int)cur_term->type.Numbers[(signed long int)0] + 1);
  char draw_topbar$$1$$buf[draw_topbar$array_size0];
  signed int i = 0;
  signed int j;
  toprow = row;
  min_mvcur(0, row);
  min_gfx(1);
  min_fg(6);
  min_putchar((signed int)acs_map[(signed long int)(unsigned char)120]);
  min_unset();
  i = i + 1;
  switch(p_tm)
  {
    case 0:
    {
      min_putstr(" A/B TEST MODE ");
      j = 15;
      i = i + j;
      break;
    }
    case 1:
    {
      j = 17;
      i = i + j;
      min_putstr(" A/B/X TEST MODE ");
      break;
    }
    case 2:
    {
      j = 17;
      i = i + j;
      min_putstr(" X/X/Y TEST MODE ");
      break;
    }
    case 3:
    {
      j = 24;
      i = i + j;
      min_putstr(" CASUAL COMPARISON MODE ");
    }
  }
  min_gfx(1);
  min_fg(6);
  min_putchar((signed int)acs_map[(signed long int)(unsigned char)120]);
  min_unset();
  i = i + 1;
  sprintf(draw_topbar$$1$$buf, " %dch %dbit %dHz ", p_ch, p_b, p_r);
  unsigned long int return_value_strlen$1;
  do
  {
    return_value_strlen$1=strlen(draw_topbar$$1$$buf);
    if((unsigned long int)i >= (unsigned long int)*cur_term->type.Numbers + -return_value_strlen$1)
      break;

    min_putchar(32);
    i = i + 1;
  }
  while((_Bool)1);
  min_putstr(draw_topbar$$1$$buf);
  min_mvcur(0, row - 1);
  min_gfx(1);
  min_fg(6);
  min_putchar((signed int)acs_map[(signed long int)(unsigned char)108]);
  i = 0;
  for( ; !(i >= j); i = i + 1)
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)113]);
  min_putchar((signed int)acs_map[(signed long int)(unsigned char)107]);
  min_mvcur(0, row + 1);
  min_putchar((signed int)acs_map[(signed long int)(unsigned char)120]);
  min_fg(6);
  i = 0;
  for( ; !(i >= j); i = i + 1)
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)113]);
  min_putchar((signed int)acs_map[(signed long int)(unsigned char)109]);
  min_unset();
  return 2;
}

// draw_trials_box
// file tty.c line 195
static signed int draw_trials_box(signed int row)
{
  signed int i;
  const signed long int i$array_size0 = (signed long int)((signed int)cur_term->type.Numbers[(signed long int)0] + 1);
  char draw_trials_box$$1$$buf[i$array_size0];
  boxrow = row;
  fill(draw_trials_box$$1$$buf, (char)acs_map[(signed long int)(unsigned char)113], (signed int)cur_term->type.Numbers[(signed long int)0]);
  draw_trials_box$$1$$buf[(signed long int)0] = (char)acs_map[(signed long int)(unsigned char)108];
  draw_trials_box$$1$$buf[(signed long int)((signed int)cur_term->type.Numbers[(signed long int)0] - 1)] = (char)acs_map[(signed long int)(unsigned char)107];
  min_mvcur(0, row);
  min_gfx(1);
  min_fg(6);
  min_putstr(draw_trials_box$$1$$buf);
  row = row + 1;
  i = 0;
  for( ; !(i >= 1 + (p_g == 0 ? 0 : 1)); i = i + 1)
  {
    min_mvcur(0, row);
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)120]);
    min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] - 1, row);
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)120]);
    row = row + 1;
  }
  fliprow = row;
  min_mvcur(0, row);
  fill(draw_trials_box$$1$$buf, (char)acs_map[(signed long int)(unsigned char)113], (signed int)cur_term->type.Numbers[(signed long int)0]);
  draw_trials_box$$1$$buf[(signed long int)0] = (char)acs_map[(signed long int)(unsigned char)109];
  draw_trials_box$$1$$buf[(signed long int)((signed int)cur_term->type.Numbers[(signed long int)0] - 1)] = (char)acs_map[(signed long int)(unsigned char)106];
  min_putstr(draw_trials_box$$1$$buf);
  min_unset();
  return (p_g != 0 ? 1 : 0) + 3;
}

// eof_callback
// file loader.c line 918
static signed int eof_callback(const struct anonymous *decoder, void *client_data)
{
  struct anonymous$48 *flac = (struct anonymous$48 *)client_data;
  signed int return_value_feof$1;
  return_value_feof$1=feof(flac->in);
  return return_value_feof$1 != 0 ? 1 : 0;
}

// error_callback
// file loader.c line 909
static void error_callback(const struct anonymous *decoder, enum anonymous$45 status, void *client_data)
{
  struct anonymous$48 *flac = (struct anonymous$48 *)client_data;
  struct pcm_struct *pcm = flac->pcm;
  fprintf(stderr, "\r%s: Error decoding file.\n", pcm->name);
}

// factorial
// file main.c line 230
double factorial(signed int x)
{
  double f = 1.;
  for( ; x >= 2; x = x - 1)
    f = f * (double)x;
  return f;
}

// fifo_clear
// file mincurses.c line 211
static inline void fifo_clear()
{
  memset((void *)fifo, 0, sizeof(signed int [160l]) /*640ul*/ );
  head = -1;
  peek = 0;
  tail = peek;
}

// fifo_peek
// file mincurses.c line 155
static inline signed int fifo_peek()
{
  signed int ch = fifo[(signed long int)peek];
  if(peek == 160)
    peek = 0;

  else
    peek = peek + 1;
  return ch;
}

// fifo_pull
// file mincurses.c line 161
static inline signed int fifo_pull()
{
  signed int ch = fifo[(signed long int)head];
  if(peek == head)
  {
    if(head == 160)
      head = 0;

    else
      head = head + 1;
    if(head == tail)
    {
      head = -1;
      tail = 0;
    }

    peek = head;
  }

  else
  {
    if(head == 160)
      head = 0;

    else
      head = head + 1;
    if(head == tail)
    {
      head = -1;
      tail = 0;
    }

  }
  return ch;
}

// fifo_push
// file mincurses.c line 174
static inline signed int fifo_push(signed int nonblock)
{
  signed int n;
  signed int ch = 0;
  unsigned char c2 = (unsigned char)0;
  if(tail == -1)
    return -1;

  else
  {
    if(!(nonblock == 0))
    {
      struct pollfd fds = { .fd=0, .events=(signed short int)0x001, .revents=(signed short int)0 };
      poll(&fds, (unsigned long int)1, 0);
      if(fds.revents == 0)
        return -1;

    }

    signed long int return_value_read$1;
    return_value_read$1=read(0, (void *)&c2, (unsigned long int)1);
    n = (signed int)return_value_read$1;
    ch = (signed int)c2;
    if(!(n >= 1))
      ch = -1;

    fifo[(signed long int)tail] = ch;
    if(head == -1)
    {
      peek = tail;
      head = peek;
    }

    if(tail == 160)
      tail = 0;

    else
      tail = tail + 1;
    if(tail == head)
      tail = -1;

    return ch;
  }
}

// fill
// file tty.c line 67
void fill(char *buf, char c, signed int cols)
{
  signed int i = 0;
  for( ; !(i >= cols); i = i + 1)
    buf[(signed long int)i] = c;
  buf[(signed long int)i] = (char)0;
}

// fill_fragment1
// file audio.c line 561
extern void fill_fragment1(unsigned char *out, struct pcm_struct *pcm, signed long int start, signed long int *pos, signed long int end, signed int *loop, signed int fragsamples, float *fadewindow)
{
  signed int bps = (pcm->currentbits + 7) / 8;
  signed int cpf = pcm->ch;
  signed int bpf = bps * cpf;
  signed int fragsize = fragsamples * bpf;
  if(!(end >= (signed long int)(3 * fragsize)))
    end = (signed long int)(fragsize * 3);

  if(!(pcm->size >= end))
    end = pcm->size;

  if(!(start >= 0l))
    start = (signed long int)0;

  if(!(pcm->size + -((signed long int)(3 * fragsize)) >= start))
    start = pcm->size - (signed long int)(fragsize * 3);

  signed long int tmp_if_expr$5;
  if(!(*loop == 0))
  {
    signed int fill_fragment1$$1$$1$$lp = *loop;
    signed int fill_fragment1$$1$$1$$i;
    signed int j;
    unsigned char *A = pcm->data + *pos;
    unsigned char *fill_fragment1$$1$$1$$B = pcm->data + start + (signed long int)((fragsamples - fill_fragment1$$1$$1$$lp) * bpf);
    fill_fragment1$$1$$1$$i = 0;
    for( ; !(fill_fragment1$$1$$1$$i >= fragsamples); fill_fragment1$$1$$1$$i = fill_fragment1$$1$$1$$i + 1)
      if(!(fill_fragment1$$1$$1$$lp == 0))
      {
        float fill_fragment1$$1$$1$$1$$1$$1$$w;
        fill_fragment1$$1$$1$$lp = fill_fragment1$$1$$1$$lp - 1;
        fill_fragment1$$1$$1$$1$$1$$1$$w = fadewindow[(signed long int)fill_fragment1$$1$$1$$lp];
        j = 0;
        for( ; !(j >= cpf); j = j + 1)
        {
          float fill_fragment1$$1$$1$$1$$1$$1$$1$$1$$val;
          float return_value_get_val$1;
          return_value_get_val$1=get_val(A, bps);
          float return_value_get_val$2;
          return_value_get_val$2=get_val(fill_fragment1$$1$$1$$B, bps);
          fill_fragment1$$1$$1$$1$$1$$1$$1$$1$$val = return_value_get_val$1 * (1.f - fill_fragment1$$1$$1$$1$$1$$1$$w) + return_value_get_val$2 * fill_fragment1$$1$$1$$1$$1$$1$$w;
          put_val(out, bps, fill_fragment1$$1$$1$$1$$1$$1$$1$$1$$val);
          A = A + (signed long int)bps;
          fill_fragment1$$1$$1$$B = fill_fragment1$$1$$1$$B + (signed long int)bps;
          out = out + (signed long int)bps;
        }
      }

      else
      {
        memcpy((void *)out, (const void *)fill_fragment1$$1$$1$$B, (unsigned long int)bpf);
        fill_fragment1$$1$$1$$B = fill_fragment1$$1$$1$$B + (signed long int)bpf;
        out = out + (signed long int)bpf;
      }
    *loop = 0;
    *pos = fill_fragment1$$1$$1$$B - pcm->data;
  }

  else
    if(!(pcm->size + -((signed long int)fragsize) >= *pos))
    {
      fprintf(stderr, "Internal error; %ld>%ld, Monty fucked up.\n", (signed long int)*pos, (signed long int)pcm->size - (signed long int)fragsize);
      exit(100);
    }

    else
      if(!(end + -((signed long int)fragsize) >= *pos + (signed long int)fragsize))
      {
        signed int i;
        signed int fill_fragment1$$1$$2$$2$$j;
        unsigned char *fill_fragment1$$1$$2$$2$$A = pcm->data + *pos;
        unsigned char *B = pcm->data + start;
        signed int lp = (signed int)((end - *pos) / (signed long int)bpf);
        if(!(lp >= fragsamples))
          lp = fragsamples;

        i = 0;
        for( ; !(i >= fragsamples); i = i + 1)
        {
          lp = lp - 1;
          if(lp >= fragsamples)
          {
            memcpy((void *)out, (const void *)fill_fragment1$$1$$2$$2$$A, (unsigned long int)bpf);
            fill_fragment1$$1$$2$$2$$A = fill_fragment1$$1$$2$$2$$A + (signed long int)bpf;
            out = out + (signed long int)bpf;
          }

          else
          {
            float w = fadewindow[(signed long int)lp];
            fill_fragment1$$1$$2$$2$$j = 0;
            for( ; !(fill_fragment1$$1$$2$$2$$j >= cpf); fill_fragment1$$1$$2$$2$$j = fill_fragment1$$1$$2$$2$$j + 1)
            {
              float val;
              float return_value_get_val$3;
              return_value_get_val$3=get_val(fill_fragment1$$1$$2$$2$$A, bps);
              float return_value_get_val$4;
              return_value_get_val$4=get_val(B, bps);
              val = return_value_get_val$3 * (1.f - w) + return_value_get_val$4 * w;
              put_val(out, bps, val);
              fill_fragment1$$1$$2$$2$$A = fill_fragment1$$1$$2$$2$$A + (signed long int)bps;
              B = B + (signed long int)bps;
              out = out + (signed long int)bps;
            }
          }
        }
        *loop = lp < 0 ? 0 : lp;
        if(!(lp >= 1))
          tmp_if_expr$5 = B - pcm->data;

        else
          tmp_if_expr$5 = fill_fragment1$$1$$2$$2$$A - pcm->data;
        *pos = tmp_if_expr$5;
      }

      else
      {
        unsigned char *fill_fragment1$$1$$2$$3$$A = pcm->data + *pos;
        memcpy((void *)out, (const void *)fill_fragment1$$1$$2$$3$$A, (unsigned long int)fragsize);
        *loop = 0;
        *pos = *pos + (signed long int)fragsize;
      }
}

// fill_fragment2
// file audio.c line 653
extern void fill_fragment2(unsigned char *out, struct pcm_struct *pcm, signed long int start, signed long int *pos, signed long int end, signed int *loop, signed int fragsamples, float *fadewindow)
{
  signed int bps = (pcm->currentbits + 7) / 8;
  signed int cpf = pcm->ch;
  signed int bpf = bps * cpf;
  signed int fragsize = fragsamples * bpf;
  if(!(end >= (signed long int)(3 * fragsize)))
    end = (signed long int)(fragsize * 3);

  if(!(pcm->size >= end))
    end = pcm->size;

  if(!(start >= 0l))
    start = (signed long int)0;

  if(!(pcm->size + -((signed long int)(3 * fragsize)) >= start))
    start = pcm->size - (signed long int)(fragsize * 3);

  unsigned char *A = pcm->data + *pos;
  signed long int tmp_if_expr$3;
  if(end + -(*pos) >= (signed long int)(2 * fragsize))
  {
    memcpy((void *)out, (const void *)A, (unsigned long int)fragsize);
    *loop = 0;
    *pos = (A - pcm->data) + (signed long int)fragsize;
  }

  else
  {
    signed int i;
    signed int j;
    signed int lp = (signed int)((end - *pos) / (signed long int)bpf);
    unsigned char *B = pcm->data + start;
    if(!(lp >= fragsamples))
      B = B + (signed long int)((fragsamples - lp) * bpf);

    i = 0;
    for( ; !(i >= fragsamples); i = i + 1)
    {
      lp = lp - 1;
      if(lp >= fragsamples)
      {
        memcpy((void *)out, (const void *)A, (unsigned long int)bpf);
        A = A + (signed long int)bpf;
        out = out + (signed long int)bpf;
      }

      else
        if(lp >= 0)
        {
          float w = fadewindow[(signed long int)lp];
          j = 0;
          for( ; !(j >= cpf); j = j + 1)
          {
            float val;
            float return_value_get_val$1;
            return_value_get_val$1=get_val(A, bps);
            float return_value_get_val$2;
            return_value_get_val$2=get_val(B, bps);
            val = (float)((double)return_value_get_val$1 * (1. - (double)w) + (double)(return_value_get_val$2 * w));
            put_val(out, (signed int)val, (float)bps);
            A = A + (signed long int)bps;
            B = B + (signed long int)bps;
            out = out + (signed long int)bps;
          }
        }

        else
        {
          memcpy((void *)out, (const void *)B, (unsigned long int)bpf);
          B = B + (signed long int)bpf;
          out = out + (signed long int)bpf;
        }
    }
    *loop = lp > 0 ? (lp < fragsamples ? lp : fragsamples) : 0;
    if(lp >= 1)
      tmp_if_expr$3 = A - pcm->data;

    else
      tmp_if_expr$3 = B - pcm->data;
    *pos = tmp_if_expr$3;
  }
}

// find_aiff_chunk
// file loader.c line 430
static signed int find_aiff_chunk(struct _IO_FILE *in, char *path, char *type, unsigned int *len)
{
  unsigned char find_aiff_chunk$$1$$buf[8l];
  signed int restarted = 0;
  while((_Bool)1)
  {
    unsigned long int return_value_fread$1;
    return_value_fread$1=fread((void *)find_aiff_chunk$$1$$buf, (unsigned long int)1, (unsigned long int)8, in);
    if(!(return_value_fread$1 >= 8ul))
    {
      if(restarted == 0)
      {
        restarted = 1;
        fseek(in, (signed long int)12, 0);
        continue;
      }

      fprintf(stderr, "%s: Unexpected EOF in AIFF chunk\n", path);
      return 0;
    }

    *len = (unsigned int)((signed int)(find_aiff_chunk$$1$$buf + (signed long int)4)[(signed long int)0] << 24 | (signed int)(find_aiff_chunk$$1$$buf + (signed long int)4)[(signed long int)1] << 16 | (signed int)(find_aiff_chunk$$1$$buf + (signed long int)4)[(signed long int)2] << 8 | (signed int)(find_aiff_chunk$$1$$buf + (signed long int)4)[(signed long int)3] & 0xff);
    signed int return_value_memcmp$3;
    return_value_memcmp$3=memcmp((const void *)find_aiff_chunk$$1$$buf, (const void *)type, (unsigned long int)4);
    if(!(return_value_memcmp$3 == 0))
    {
      if(!((1u & *len) == 0u))
        *len = *len + 1u;

      signed int return_value_fseek$2;
      return_value_fseek$2=fseek(in, (signed long int)*len, 1);
      if(!(return_value_fseek$2 == 0))
        return 0;

    }

    else
      return 1;
  }
}

// find_definition
// file mincurses.c line 97
static signed int find_definition(struct tries *tree, const char *str)
{
  struct tries *ptr;
  signed int result = 0;
  _Bool tmp_if_expr$1;
  if(!(str == ((const char *)NULL)))
  {
    if(!((signed int)*str == 0))
    {
      ptr = tree;
      for( ; !(ptr == ((struct tries *)NULL)); ptr = ptr->sibling)
      {
        if((unsigned char)*str == ptr->ch)
        {
          if((signed int)str[1l] == 0)
            tmp_if_expr$1 = ptr->child != ((struct tries *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(tmp_if_expr$1)
            result = -1;

          else
          {
            result=find_definition(ptr->child, str + (signed long int)1);
            if(result == 0)
              result = (signed int)ptr->value;

            else
              if((signed int)str[1l] == 0)
                result = -1;

          }
        }

        if(!(result == 0))
          break;

      }
    }

  }

  return result;
}

// find_wav_chunk
// file loader.c line 131
static signed int find_wav_chunk(struct _IO_FILE *in, char *path, char *type, unsigned int *len)
{
  unsigned char find_wav_chunk$$1$$buf[8l];
  while((_Bool)1)
  {
    unsigned long int return_value_fread$1;
    return_value_fread$1=fread((void *)find_wav_chunk$$1$$buf, (unsigned long int)1, (unsigned long int)8, in);
    if(!(return_value_fread$1 >= 8ul))
    {
      fprintf(stderr, "%s: Unexpected EOF in reading WAV header\n", path);
      return 0;
    }

    signed int return_value_memcmp$3;
    return_value_memcmp$3=memcmp((const void *)find_wav_chunk$$1$$buf, (const void *)type, (unsigned long int)4);
    if(!(return_value_memcmp$3 == 0))
    {
      *len = (unsigned int)((signed int)(find_wav_chunk$$1$$buf + (signed long int)4)[(signed long int)3] << 24 | (signed int)(find_wav_chunk$$1$$buf + (signed long int)4)[(signed long int)2] << 16 | (signed int)(find_wav_chunk$$1$$buf + (signed long int)4)[(signed long int)1] << 8 | (signed int)(find_wav_chunk$$1$$buf + (signed long int)4)[(signed long int)0] & 0xff);
      signed int return_value_fseek$2;
      return_value_fseek$2=fseek(in, (signed long int)*len, 1);
      if(!(return_value_fseek$2 == 0))
        return 0;

      find_wav_chunk$$1$$buf[(signed long int)4] = (unsigned char)0;
    }

    else
    {
      *len = (unsigned int)((signed int)(find_wav_chunk$$1$$buf + (signed long int)4)[(signed long int)3] << 24 | (signed int)(find_wav_chunk$$1$$buf + (signed long int)4)[(signed long int)2] << 16 | (signed int)(find_wav_chunk$$1$$buf + (signed long int)4)[(signed long int)1] << 8 | (signed int)(find_wav_chunk$$1$$buf + (signed long int)4)[(signed long int)0] & 0xff);
      return 1;
    }
  }
}

// flac_id
// file loader.c line 104
static signed int flac_id(char *path, unsigned char *buf)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)buf, (const void *)"fLaC", (unsigned long int)4);
  return (signed int)(return_value_memcmp$1 == 0);
}

// flac_load
// file loader.c line 1022
static struct pcm_struct * flac_load(char *path, struct _IO_FILE *in)
{
  struct pcm_struct *return_value_flac_load_i$1;
  return_value_flac_load_i$1=flac_load_i(path, in, 0);
  return return_value_flac_load_i$1;
}

// flac_load_i
// file loader.c line 924
static struct pcm_struct * flac_load_i(char *path, struct _IO_FILE *in, signed int oggp)
{
  struct pcm_struct *pcm;
  struct anonymous$48 *flac;
  struct anonymous *decoder;
  signed int ret;
  signed int return_value_fseek$1;
  return_value_fseek$1=fseek(in, (signed long int)0, 0);
  void *return_value_calloc$2;
  void *return_value_calloc$3;
  char *return_value_trim_path$4;
  char *return_value___strdup$5;
  char *return_value___strdup$6;
  char *return_value___strdup$7;
  char *return_value___strdup$8;
  char *return_value___strdup$9;
  char *return_value___strdup$10;
  char *return_value___strdup$11;
  char *return_value___strdup$12;
  char *return_value___strdup$13;
  char *return_value___strdup$14;
  char *return_value___strdup$15;
  char *return_value___strdup$16;
  char *return_value___strdup$17;
  char *return_value___strdup$18;
  char *return_value___strdup$19;
  char *return_value___strdup$20;
  char *return_value___strdup$21;
  if(return_value_fseek$1 == -1)
    fprintf(stderr, "%s: Failed to seek\n", path);

  else
  {
    return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct pcm_struct) /*56ul*/ );
    pcm = (struct pcm_struct *)return_value_calloc$2;
    return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct anonymous$48) /*24ul*/ );
    flac = (struct anonymous$48 *)return_value_calloc$3;
    decoder=FLAC__stream_decoder_new();
    FLAC__stream_decoder_set_md5_checking(decoder, 1);
    FLAC__stream_decoder_set_metadata_respond(decoder, (enum anonymous$18)FLAC__METADATA_TYPE_STREAMINFO);
    return_value_trim_path$4=trim_path(path);
    return_value___strdup$5=__strdup(return_value_trim_path$4);
    pcm->name = return_value___strdup$5;
    flac->in = in;
    flac->pcm = pcm;
    if(!(oggp == 0))
      FLAC__stream_decoder_init_ogg_stream(decoder, read_callback, ((enum anonymous$41 (*)(const struct anonymous *, unsigned long int, void *))NULL), ((enum anonymous$42 (*)(const struct anonymous *, unsigned long int *, void *))NULL), ((enum anonymous$43 (*)(const struct anonymous *, unsigned long int *, void *))NULL), eof_callback, write_callback, metadata_callback, error_callback, (void *)flac);

    else
      FLAC__stream_decoder_init_stream(decoder, read_callback, ((enum anonymous$41 (*)(const struct anonymous *, unsigned long int, void *))NULL), ((enum anonymous$42 (*)(const struct anonymous *, unsigned long int *, void *))NULL), ((enum anonymous$43 (*)(const struct anonymous *, unsigned long int *, void *))NULL), eof_callback, write_callback, metadata_callback, error_callback, (void *)flac);
    ret=FLAC__stream_decoder_process_until_end_of_stream(decoder);
    FLAC__stream_decoder_finish(decoder);
    FLAC__stream_decoder_delete(decoder);
    free((void *)flac);
    if(ret == 0)
    {
      free_pcm(pcm);
      return (struct pcm_struct *)(void *)0;
    }

    switch(pcm->ch)
    {
      case 1:
      {
        return_value___strdup$6=__strdup("M");
        pcm->matrix = return_value___strdup$6;
        return_value___strdup$7=__strdup("A");
        pcm->mix = return_value___strdup$7;
        break;
      }
      case 2:
      {
        return_value___strdup$8=__strdup("L,R");
        pcm->matrix = return_value___strdup$8;
        return_value___strdup$9=__strdup("BC");
        pcm->mix = return_value___strdup$9;
        break;
      }
      case 3:
      {
        return_value___strdup$10=__strdup("L,R,C");
        pcm->matrix = return_value___strdup$10;
        return_value___strdup$11=__strdup("BCD");
        pcm->mix = return_value___strdup$11;
        break;
      }
      case 4:
      {
        return_value___strdup$12=__strdup("L,R,BL,BR");
        pcm->matrix = return_value___strdup$12;
        return_value___strdup$13=__strdup("BCFG");
        pcm->mix = return_value___strdup$13;
        break;
      }
      case 5:
      {
        return_value___strdup$14=__strdup("L,R,C,BL,BR");
        pcm->matrix = return_value___strdup$14;
        return_value___strdup$15=__strdup("BCDFG");
        pcm->mix = return_value___strdup$15;
        break;
      }
      case 6:
      {
        return_value___strdup$16=__strdup("L,R,C,LFE,BL,BR");
        pcm->matrix = return_value___strdup$16;
        return_value___strdup$17=__strdup("BCDEFG");
        pcm->mix = return_value___strdup$17;
        break;
      }
      case 7:
      {
        return_value___strdup$18=__strdup("L,R,C,LFE,BC,SL,SR");
        pcm->matrix = return_value___strdup$18;
        return_value___strdup$19=__strdup("BCDEJKL");
        pcm->mix = return_value___strdup$19;
        break;
      }
      default:
      {
        return_value___strdup$20=__strdup("L,R,C,LFE,BL,BR,SL,SR");
        pcm->matrix = return_value___strdup$20;
        return_value___strdup$21=__strdup("BCDEFGKL");
        pcm->mix = return_value___strdup$21;
      }
    }
    if(!(sb_verbose == 0))
      fprintf(stderr, "\rLoading %s: loaded.         ", pcm->name);

    return pcm;
  }

err:
  ;
  return (struct pcm_struct *)(void *)0;
}

// free_pcm
// file loader.c line 1314
extern void free_pcm(struct pcm_struct *pcm)
{
  if(!(pcm == ((struct pcm_struct *)NULL)))
  {
    if(!(pcm->name == ((char *)NULL)))
      free((void *)pcm->name);

    if(!(pcm->matrix == ((char *)NULL)))
      free((void *)pcm->matrix);

    if(!(pcm->mix == ((char *)NULL)))
      free((void *)pcm->mix);

    if(!(pcm->data == ((unsigned char *)NULL)))
      free((void *)pcm->data);

    memset((void *)pcm, 0, sizeof(struct pcm_struct) /*56ul*/ );
    free((void *)pcm);
  }

}

// get_clamp
// file audio.c line 50
static float get_clamp(struct pcm_struct *pcm)
{
  _Bool tmp_if_expr$1;
  if(pcm->nativebits >= 0)
    tmp_if_expr$1 = pcm->nativebits < 24 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    return 1.f - 1.f / (float)(1 << pcm->nativebits - 1);

  else
    return 1.f - 1.f / 2147483648.f;
}

// get_val
// file audio.c line 446
extern float get_val(unsigned char *d, signed int bps)
{
  if(bps == 2)
  {
    signed short int i = (signed short int)((signed int)d[(signed long int)0] | (signed int)d[(signed long int)1] << 8);
    return (float)i;
  }

  else
  {
    signed int get_val$$1$$2$$i = ((signed int)d[(signed long int)0] << 8 | (signed int)d[(signed long int)1] << 16 | (signed int)d[(signed long int)2] << 24) >> 8;
    return (float)get_val$$1$$2$$i;
  }
}

// key_thread
// file main.c line 308
void * key_thread(void *arg)
{
  struct anonymous$24 *s = (struct anonymous$24 *)arg;
  pthread_mutex_lock(&s->mutex);
  while((_Bool)1)
  {
    signed int ret = -1;
    if(!(s->exiting == 0))
      break;

    if(s->key_waiting == 0)
    {
      pthread_mutex_unlock(&s->mutex);
      struct pollfd fds[2l] = { { .fd=0, .events=(signed short int)0x001, .revents=(signed short int)0 },
    { .fd=s->exit_fd, .events=(signed short int)0x001, .revents=(signed short int)0 } };
      ret=poll(fds, (unsigned long int)2, -1);
      if(!((0x001 & (signed int)fds[1l].revents) == 0))
        break;

      if(!((0x001 & (signed int)fds[0l].revents) == 0))
        ret=min_getch(1);

      pthread_mutex_lock(&s->mutex);
    }

    if(!(s->exiting == 0))
      break;

    if(!(ret == -1))
    {
      s->key_waiting = ret;
      pthread_cond_signal(&s->main_cond);
      pthread_cond_wait(&s->key_cond, &s->mutex);
    }

  }
  pthread_mutex_unlock(&s->mutex);
  return (void *)0;
}

// load_audio_file
// file loader.c line 1285
extern struct pcm_struct * load_audio_file(char *path)
{
  struct _IO_FILE *f;
  f=fopen(path, "rb");
  signed int j = 0;
  signed int load_audio_file$$1$$fill;
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "Unable to open file %s: %s\n", path, return_value_strerror$2);
    return (struct pcm_struct *)(void *)0;
  }

  unsigned long int return_value_fread$3;
  return_value_fread$3=fread((void *)buf, (unsigned long int)1, (unsigned long int)36, f);
  load_audio_file$$1$$fill = (signed int)return_value_fread$3;
  if(!(load_audio_file$$1$$fill >= 36))
  {
    fprintf(stderr, "%s: Input file truncated or NULL\n", path);
    fclose(f);
    return (struct pcm_struct *)(void *)0;
  }

  else
  {
    if(!(formats[(signed long int)j].id_func == ((signed int (*)(char *, unsigned char *))NULL)))
    {
      signed int return_value;
      return_value=formats[(signed long int)j].id_func(path, buf);
      if(!(return_value == 0))
      {
        struct pcm_struct *ret;
        ret=formats[(signed long int)j].load_func(path, f);
        fclose(f);
        return ret;
      }

      j = j + 1;
    }

    fprintf(stderr, "%s: Unrecognized file format\n", path);
    return (struct pcm_struct *)(void *)0;
  }
}

// main
// file main.c line 357
signed int main(signed int argc, char **argv)
{
  float *fadewindow1;
  float *fadewindow2;
  float *fadewindow3;
  float *beep1;
  float *beep2;
  signed int fragsamples;
  signed int fragsize;
  unsigned char *fragmentA;
  unsigned char *fragmentB;
  unsigned long int playback_handle;
  unsigned long int fd_handle;
  struct anonymous$24 state;
  signed int exit_fds[2l];
  signed int main$$1$$c;
  signed int long_option_index;
  struct pcm_struct *pcm[10l];
  signed int test_mode = 3;
  signed int test_files;
  char *device = (char *)(void *)0;
  signed int force_dither = 0;
  signed int force_truncate = 0;
  signed int no_normalize = 0;
  float att = (float)1.;
  signed int downmix = 0;
  signed int restart_mode = 0;
  signed int beep_mode = 3;
  signed int tests = 20;
  double main$$1$$start = (double)0;
  double main$$1$$end = (double)-1;
  signed int outbits = 0;
  struct ao_device *adev = (struct ao_device *)(void *)0;
  signed int randomize[10l];
  signed int i;
  signed int j;
  signed int cchoice = -1;
  char choice_list[150l];
  char sample_list[150l];
  signed int tests_cursor = 0;
  signed int tests_total = 0;
  signed int running_score = 0;
  signed int flips[3l] = { 0, 0, 0 };
  signed int undos = 0;
  signed int seeks = 0;
  unsigned long int fragments_played = (unsigned long int)0;
  char *return_value___strdup$1;
  do
  {
    main$$1$$c=getopt_long(argc, argv, short_options, long_options, &long_option_index);
    if(main$$1$$c == -1)
      break;

    switch(main$$1$$c)
    {
      case 104:
      {
        usage(stdout);
        return 0;
      }
      case 97:
      {
        test_mode = 0;
        break;
      }
      case 98:
      {
        test_mode = 1;
        break;
      }
      case 99:
      {
        test_mode = 3;
        break;
      }
      case 120:
      {
        test_mode = 2;
        break;
      }
      case 77:
      {
        beep_mode = 1;
        break;
      }
      case 66:
      {
        beep_mode = 2;
        break;
      }
      case 83:
      {
        beep_mode = 3;
        break;
      }
      case 100:
      {
        return_value___strdup$1=__strdup(optarg);
        device = return_value___strdup$1;
        break;
      }
      case 68:
      {
        force_dither = 1;
        force_truncate = 0;
        break;
      }
      case 116:
      {
        force_dither = 0;
        force_truncate = 1;
        break;
      }
      case 110:
      {
        tests=atoi(optarg);
        if(!(tests >= 1))
        {
          fprintf(stderr, "Error parsing argument to -n\n");
          exit(1);
        }

        if(tests >= 151)
        {
          fprintf(stderr, "Error parsing argument to -n (max %d trials)\n", 150);
          exit(1);
        }

        break;
      }
      case 101:
      {
        parse_time(optarg, &main$$1$$end);
        if(main$$1$$end <= 0.000000)
        {
          fprintf(stderr, "Error parsing argument to -e\n");
          exit(1);
        }

        break;
      }
      case 115:
      {
        parse_time(optarg, &main$$1$$start);
        if(main$$1$$start <= 0.000000)
        {
          fprintf(stderr, "Error parsing argument to -s\n");
          exit(1);
        }

        break;
      }
      case 114:
      {
        restart_mode = 1;
        break;
      }
      case 82:
      {
        restart_mode = 2;
        break;
      }
      case 118:
      {
        sb_verbose = 1;
        break;
      }
      case 86:
      {
        fprintf(stdout, "Xiph.Org Squishyball %s\n", (const void *)"20140211");
        exit(0);
      }
      case 103:
      {
        running_score = 1;
        break;
      }
      case 78:
      {
        no_normalize = 1;
        break;
      }
      case 49:
      {
        downmix = 1;
        break;
      }
      case 50:
      {
        downmix = 2;
        break;
      }
      default:
      {
        usage(stderr);
        exit(1);
      }
    }
  }
  while((_Bool)1);
  if(test_mode == 3 && !(running_score == 0))
  {
    if(!(sb_verbose == 0))
      fprintf(stderr, "-g is meaningless in casual comparison mode.\n");

    running_score = 0;
  }

  test_files = argc - optind;
  if(test_mode == 3)
  {
    if(test_files >= 11 || !(test_files >= 1))
    {
      usage(stderr);
      exit(1);
    }

  }

  else
    if(!(test_files == 2))
    {
      usage(stderr);
      exit(1);
    }

  signed int return_value_pipe$2;
  return_value_pipe$2=pipe(exit_fds);
  if(!(return_value_pipe$2 == 0))
  {
    fprintf(stderr, "Failed to create interthread pipe.\n");
    exit(11);
  }

  outbits = 16;
  i = 0;
  for( ; !(i >= test_files); i = i + 1)
  {
    float latt;
    pcm[(signed long int)i]=load_audio_file(argv[(signed long int)(optind + i)]);
    if(pcm[(signed long int)i] == ((struct pcm_struct *)NULL))
      exit(2);

    latt=check_warn_clipping(pcm[(signed long int)i], no_normalize);
    if(downmix == 1)
    {
      if(pcm[(signed long int)i]->ch >= 2)
        latt=convert_to_mono(pcm[(signed long int)i]);

    }

    if(downmix == 2)
    {
      if(pcm[(signed long int)i]->ch >= 3)
        latt=convert_to_stereo(pcm[(signed long int)i]);

    }

    if(latt < att)
      att = latt;

    if(!(pcm[0l]->rate == pcm[(signed long int)i]->rate))
    {
      fprintf(stderr, "Input sample rates do not match!\n\t%s: %dHz\n\t%s: %dHz\nAborting\n", pcm[(signed long int)0]->name, pcm[(signed long int)0]->rate, pcm[(signed long int)i]->name, pcm[(signed long int)i]->rate);
      exit(3);
    }

    if(!(pcm[0l]->ch == pcm[(signed long int)i]->ch))
    {
      fprintf(stderr, "Input channel counts do not match!\n\t%s: %d channels\n\t%s: %d channels\nAborting\n", pcm[(signed long int)0]->name, pcm[(signed long int)0]->ch, pcm[(signed long int)i]->name, pcm[(signed long int)i]->ch);
      exit(3);
    }

    signed int return_value_abs$3;
    return_value_abs$3=abs(pcm[(signed long int)i]->nativebits);
    if(!(outbits >= return_value_abs$3))
      outbits=abs(pcm[(signed long int)i]->nativebits);

  }
  double tmp_if_expr$5;
  double return_value_log$4;
  if(att < 1.f && no_normalize == 0)
  {
    if(IEEE_FLOAT_EQUAL(att, 0.000000f))
      tmp_if_expr$5 = (double)-400.f;

    else
    {
      return_value_log$4=log((double)(att * att));
      tmp_if_expr$5 = return_value_log$4 * (double)4.34294480f;
    }
    fprintf(stderr, "Normalizing all inputs by %+0.1fdB...", tmp_if_expr$5);
    i = 0;
    for( ; !(i >= test_files); i = i + 1)
    {
      signed int s = (signed int)((unsigned long int)pcm[(signed long int)i]->size / sizeof(float) /*4ul*/ );
      float *d = (float *)pcm[(signed long int)i]->data;
      j = 0;
      for( ; !(j >= s); j = j + 1)
        d[(signed long int)j] = d[(signed long int)j] * att;
    }
    fprintf(stderr, " done\n");
    if(!(outbits >= 24))
      outbits = 24;

  }

  else
    no_normalize = 1;
  if(outbits == 32)
    outbits = 24;

  ao_initialize();
  adev=setup_playback(pcm[(signed long int)0]->rate, pcm[(signed long int)0]->ch, outbits, pcm[(signed long int)0]->matrix, device);
  if(adev == ((struct ao_device *)NULL))
  {
    if(outbits >= 17)
    {
      adev=setup_playback(pcm[(signed long int)0]->rate, pcm[(signed long int)0]->ch, 16, pcm[(signed long int)0]->matrix, device);
      if(adev == ((struct ao_device *)NULL))
      {
        fprintf(stderr, "Unable to open audio device for playback.\n");
        exit(4);
      }

      else
      {
        if(!(sb_verbose == 0))
          fprintf(stderr, "24-bit playback unavailable; down-converting to 16-bit\n");

        outbits = 16;
      }
    }

    else
    {
      fprintf(stderr, "Unable to open audio device for playback.\n");
      exit(4);
    }
  }

  _Bool tmp_if_expr$6;
  if(outbits == 16)
  {
    if(!(no_normalize == 0))
    {
      signed int flag = force_dither;
      i = 0;
      for( ; !(i >= test_files); i = i + 1)
        if(pcm[(signed long int)i]->nativebits >= 17)
          flag = 1;

      if(!(flag == 0) && !(force_truncate == 0))
        flag = 0;

      i = 0;
      for( ; !(i >= test_files); i = i + 1)
      {
        if(pcm[(signed long int)i]->nativebits >= 1)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = pcm[(signed long int)i]->nativebits <= 16 ? (_Bool)1 : (_Bool)0;
        convert_to_16(pcm[(signed long int)i], tmp_if_expr$6 ? 0 : flag);
      }
    }

    else
    {
      i = 0;
      for( ; !(i >= test_files); i = i + 1)
        convert_to_16(pcm[(signed long int)i], (signed int)!(force_truncate != 0));
    }
  }

  else
  {
    i = 0;
    for( ; !(i >= test_files); i = i + 1)
      convert_to_24(pcm[(signed long int)i]);
  }
  i = 1;
  signed int tmp_statement_expression$7;
  for( ; !(i >= test_files); i = i + 1)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$8;
    return_value___builtin_strcmp$8=__builtin_strcmp(pcm[(signed long int)0]->matrix, pcm[(signed long int)i]->matrix);
    tmp_statement_expression$7 = return_value___builtin_strcmp$8;
    if(!(tmp_statement_expression$7 == 0))
      reconcile_channel_maps(pcm[(signed long int)0], pcm[(signed long int)i]);

  }
  signed long int n = pcm[(signed long int)0]->size;
  signed int main$$1$$12$$flag = 0;
  i = 1;
  for( ; !(i >= test_files); i = i + 1)
  {
    if(!(pcm[(signed long int)i]->size == n))
      main$$1$$12$$flag = 1;

    if(!(pcm[(signed long int)i]->size >= n))
      n = pcm[(signed long int)i]->size;

  }
  char *return_value_make_time_string$9;
  if(!(main$$1$$12$$flag == 0))
  {
    if(!(sb_verbose == 0))
      fprintf(stderr, "Input sample lengths do not match!\n");

    i = 0;
    for( ; !(i >= test_files); i = i + 1)
    {
      if(!(sb_verbose == 0))
      {
        return_value_make_time_string$9=make_time_string((((double)pcm[(signed long int)i]->size / (double)pcm[(signed long int)i]->ch) / (double)((pcm[(signed long int)i]->currentbits + 7) / 8)) / (double)pcm[(signed long int)i]->rate, 0);
        fprintf(stderr, "\t%s: %s\n", pcm[(signed long int)i]->name, return_value_make_time_string$9);
      }

      pcm[(signed long int)i]->size = n;
    }
    if(!(sb_verbose == 0))
      fprintf(stderr, "Using the shortest sample for playback length...\n");

  }

  fragsamples=setup_windows(pcm, test_files, &fadewindow1, &fadewindow2, &fadewindow3, &beep1, &beep2);
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    randomize[(signed long int)i] = i;
  signed long int return_value_time$10;
  return_value_time$10=time((signed long int *)(void *)0);
  signed int return_value_getpid$11;
  return_value_getpid$11=getpid();
  srandom((unsigned int)(return_value_time$10 + (signed long int)return_value_getpid$11));
  randomize_samples(randomize, &cchoice, test_mode);
  signed int current_sample = randomize[(signed long int)0];
  signed int current_choice = 0;
  signed int flip_to = 0;
  signed int do_flip = 0;
  signed int do_select = 0;
  signed int do_pause = 0;
  signed int do_seek = 0;
  signed int loop = 0;
  signed long int seek_to = (signed long int)0;
  signed int bps = (pcm[(signed long int)0]->currentbits + 7) / 8;
  signed int ch = pcm[(signed long int)0]->ch;
  signed int bpf = ch * bps;
  signed int rate = pcm[(signed long int)0]->rate;
  signed int size = (signed int)pcm[(signed long int)0]->size;
  signed long int start_pos;
  double return_value_rint$12;
  return_value_rint$12=rint(main$$1$$start * (double)rate * (double)bpf);
  start_pos = (signed long int)return_value_rint$12;
  signed long int end_pos;
  double tmp_if_expr$14;
  double return_value_rint$13;
  if(main$$1$$end > 0.000000)
  {
    return_value_rint$13=rint(main$$1$$end * (double)rate * (double)bpf);
    tmp_if_expr$14 = return_value_rint$13;
  }

  else
    tmp_if_expr$14 = (double)size;
  end_pos = (signed long int)tmp_if_expr$14;
  signed long int current_pos;
  signed int paused = 0;
  double base = (double)(1.f / (float)(rate * bpf));
  double len = (double)pcm[(signed long int)0]->size * base;
  fragsize = fragsamples * bpf;
  if(main$$1$$end >= 0.000000 && main$$1$$start >= main$$1$$end)
  {
    fprintf(stderr, "Specified start and end times must not overlap.\n");
    exit(1);
  }

  if(main$$1$$end > len)
  {
    fprintf(stderr, "Specified end time beyond end of playback.\n");
    exit(1);
  }

  if(main$$1$$start >= len)
  {
    fprintf(stderr, "Specified start time beyond end of playback.\n");
    exit(1);
  }

  atexit(min_panel_remove);
  panel_init(pcm, test_files, test_mode, main$$1$$start, main$$1$$end > (double)0 ? main$$1$$end : len, len, beep_mode, restart_mode, tests, running_score);
  memset((void *)&state, 0, sizeof(struct anonymous$24) /*224ul*/ );
  pthread_mutex_init(&state.mutex, (const union anonymous$34 *)(void *)0);
  pthread_cond_init(&state.main_cond, (const union anonymous$34 *)(void *)0);
  pthread_cond_init(&state.play_cond, (const union anonymous$34 *)(void *)0);
  pthread_cond_init(&state.key_cond, (const union anonymous$34 *)(void *)0);
  state.adev = adev;
  state.exit_fd = exit_fds[(signed long int)0];
  void *return_value_calloc$15;
  return_value_calloc$15=calloc((unsigned long int)fragsize, (unsigned long int)1);
  fragmentA = (unsigned char *)return_value_calloc$15;
  void *return_value_calloc$16;
  return_value_calloc$16=calloc((unsigned long int)fragsize, (unsigned long int)1);
  fragmentB = (unsigned char *)return_value_calloc$16;
  if(fragmentA == ((unsigned char *)NULL) || fragmentB == ((unsigned char *)NULL))
  {
    fprintf(stderr, "Failed to allocate internal fragment memory\n");
    exit(5);
  }

  if(!(start_pos >= 0l))
    start_pos = (signed long int)0;

  if(!((signed long int)(size + -(3 * fragsize)) >= start_pos))
    start_pos = (signed long int)(size - fragsize * 3);

  if(!(end_pos >= (signed long int)fragsize))
    end_pos = (signed long int)fragsize;

  if(!((signed long int)size >= end_pos))
    end_pos = (signed long int)size;

  current_pos = start_pos;
  signed int return_value_pthread_create$17;
  return_value_pthread_create$17=pthread_create(&playback_handle, (const union pthread_attr_t *)(void *)0, playback_thread, (void *)&state);
  if(!(return_value_pthread_create$17 == 0))
  {
    fprintf(stderr, "Failed to create playback thread.\n");
    exit(7);
  }

  signed int return_value_pthread_create$18;
  return_value_pthread_create$18=pthread_create(&fd_handle, (const union pthread_attr_t *)(void *)0, key_thread, (void *)&state);
  if(!(return_value_pthread_create$18 == 0))
  {
    fprintf(stderr, "Failed to create playback thread.\n");
    exit(7);
  }

  pthread_mutex_lock(&state.mutex);
  float tmp_if_expr$21;
  while((_Bool)1)
  {
    signed int c;
    if(!(state.exiting == 0))
      break;

    if(state.fragment_size >= 1 && (state.key_waiting == 0 || !(do_flip == 0) || !(do_pause == 0) || !(do_select == 0)))
      pthread_cond_wait(&state.main_cond, &state.mutex);

    if(do_flip == 0 && do_pause == 0 && do_select == 0 && !(state.key_waiting == 0))
    {
      c = state.key_waiting;
      pthread_mutex_unlock(&state.mutex);
      if(!(c == -1))
      {
        if(c == 3)
          goto __CPROVER_DUMP_L105;

        if(c == 0403)
          goto __CPROVER_DUMP_L106;

        if(c == 0402)
          goto __CPROVER_DUMP_L108;

        if(c == 10 || c == 13)
          goto __CPROVER_DUMP_L109;

        if(c == 48)
          goto __CPROVER_DUMP_L110;

        if(c == 49 || c == 50 || c == 51 || c == 52 || c == 53 || c == 54 || c == 55 || c == 56 || c == 57)
          goto __CPROVER_DUMP_L111;

        if(c == 97)
          goto __CPROVER_DUMP_L112;

        if(c == 98)
          goto __CPROVER_DUMP_L113;

        if(c == 120)
          goto __CPROVER_DUMP_L114;

        if(c == 65)
          goto __CPROVER_DUMP_L115;

        if(c == 66)
          goto __CPROVER_DUMP_L116;

        if(c == 88)
          goto __CPROVER_DUMP_L117;

        if(c == 33)
          goto __CPROVER_DUMP_L118;

        if(c == 64)
          goto __CPROVER_DUMP_L119;

        if(c == 35)
          goto __CPROVER_DUMP_L120;

        if(c == 32)
          goto __CPROVER_DUMP_L121;

        if(c == 0404)
          goto __CPROVER_DUMP_L122;

        if(c == 0405)
          goto __CPROVER_DUMP_L123;

        if(c == 0611)
          goto __CPROVER_DUMP_L124;

        if(c == 0622)
          goto __CPROVER_DUMP_L125;

        if(c == 0x7f || c == 0407)
          goto __CPROVER_DUMP_L126;

        if(c == 102)
          goto __CPROVER_DUMP_L127;

        if(c == 114)
          goto __CPROVER_DUMP_L129;

        if(c == 115)
          goto __CPROVER_DUMP_L132;

        if(c == 83)
          goto __CPROVER_DUMP_L135;

        if(c == 101)
          goto __CPROVER_DUMP_L136;

        if(c == 69)
          goto __CPROVER_DUMP_L139;

        if(c == 63)
          goto __CPROVER_DUMP_L140;

        if(c == 43 || c == 331)
          goto __CPROVER_DUMP_L141;

        if(c == 45 || c == 330)
          goto __CPROVER_DUMP_L143;

      }

      else
      {
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L105:
        ;
        pthread_mutex_lock(&state.mutex);
        state.exiting = 1;
        pthread_mutex_unlock(&state.mutex);
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L106:
        ;
        if(current_choice >= 1)
        {
          flip_to = current_choice - 1;
          do_flip = 1;
        }

        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L108:
        ;
        flip_to = current_choice + 1;
        do_flip = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L109:
        ;
        flip_to = current_choice;
        do_select = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L110:
        ;
        flip_to = 9;
        do_flip = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L111:
        ;
        flip_to = c - 49;
        do_flip = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L112:
        ;
        flip_to = 0;
        do_flip = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L113:
        ;
        flip_to = 1;
        do_flip = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L114:
        ;
        flip_to = 2;
        do_flip = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L115:
        ;
        flip_to = 0;
        do_select = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L116:
        ;
        flip_to = 1;
        do_select = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L117:
        ;
        flip_to = 2;
        do_select = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L118:
        ;
        flip_to = 0;
        do_select = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L119:
        ;
        flip_to = 1;
        do_select = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L120:
        ;
        flip_to = 2;
        do_select = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L121:
        ;
        do_pause = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L122:
        ;
        seek_to = seek_to - (signed long int)(pcm[(signed long int)0]->rate * bpf * 2);
        do_seek = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L123:
        ;
        seek_to = seek_to + (signed long int)(pcm[(signed long int)0]->rate * bpf * 2);
        do_seek = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L124:
        ;
        seek_to = seek_to - (signed long int)(pcm[(signed long int)0]->rate * bpf * 10);
        do_seek = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L125:
        ;
        seek_to = seek_to + (signed long int)(pcm[(signed long int)0]->rate * bpf * 10);
        do_seek = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L126:
        ;
        seek_to = start_pos - current_pos;
        do_seek = 1;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L127:
        ;
        beep_mode = beep_mode + 1;
        if(beep_mode >= 4)
          beep_mode = 1;

        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L129:
        ;
        restart_mode = restart_mode + 1;
        if(restart_mode == 1 && test_mode == 3)
          restart_mode = restart_mode + 1;

        if(restart_mode >= 3)
          restart_mode = 0;

        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L132:
        ;
        start_pos = current_pos;
        if(!(start_pos >= 0l))
          start_pos = (signed long int)0;

        if(!(pcm[0l]->size + -((signed long int)(3 * fragsize)) >= start_pos))
          start_pos = pcm[(signed long int)0]->size - (signed long int)(fragsize * 3);

        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L135:
        ;
        start_pos = (signed long int)0;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L136:
        ;
        end_pos = current_pos;
        if(!(end_pos >= (signed long int)(3 * fragsize)))
          end_pos = (signed long int)(fragsize * 3);

        if(!(pcm[0l]->size >= end_pos))
          end_pos = pcm[(signed long int)0]->size;

        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L139:
        ;
        end_pos = pcm[(signed long int)0]->size;
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L140:
        ;
        panel_toggle_keymap();
        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L141:
        ;
        if(running_score == 0 && !(tests_cursor >= tests_total))
          tests_cursor = tests_cursor + 1;

        goto __CPROVER_DUMP_L144;

      __CPROVER_DUMP_L143:
        ;
        if(running_score == 0 && tests_cursor >= 1)
        {
          tests_cursor = tests_cursor - 1;
          undos = undos + 1;
        }

      }

    __CPROVER_DUMP_L144:
      ;
      if(flip_to == current_choice && !(do_flip == 0))
        do_flip = 0;

      switch(test_mode)
      {
        case 0:
        {
          if(flip_to >= 2)
          {
            do_flip = 0;
            do_select = 0;
          }

          break;
        }
        case 1:
          if(flip_to >= 2 && !(do_select == 0))
            do_select = 0;

        case 2:
        {
          if(flip_to >= 3)
          {
            do_flip = 0;
            do_select = 0;
          }

          break;
        }
        case 3:
        {
          if(flip_to >= test_files)
            do_flip = 0;

          if(!(do_select == 0))
            do_select = 0;

        }
      }
      for( ; !(end_pos >= current_pos + seek_to); seek_to = seek_to - (end_pos - start_pos))
        ;
      for( ; !(current_pos + seek_to >= start_pos); seek_to = seek_to + (end_pos - start_pos))
        ;
      pthread_mutex_lock(&state.mutex);
      state.key_waiting = 0;
      pthread_cond_signal(&state.key_cond);
    }

    double current = (double)current_pos * base;
    double start = (double)start_pos * base;
    double end = end_pos > (signed long int)0 ? (double)end_pos * base : len;
    pthread_mutex_unlock(&state.mutex);
    panel_update_start(start);
    panel_update_current(current);
    panel_update_end(end);
    panel_update_pause(paused);
    panel_update_playing(current_choice);
    panel_update_repeat_mode(restart_mode);
    panel_update_flip_mode(beep_mode);
    panel_update_trials(choice_list, sample_list, tests_cursor);
    min_flush();
    pthread_mutex_lock(&state.mutex);
    if(state.exiting == 0 && state.fragment_size == 0)
    {
      signed long int save_pos = current_pos;
      signed int save_loop = loop;
      pthread_mutex_unlock(&state.mutex);
      if(!(do_flip == 0))
      {
        current_choice = flip_to;
        if(restart_mode == 2)
        {
          seek_to = seek_to + (start_pos - current_pos);
          do_seek = 1;
        }

      }

      if(!(do_select == 0))
      {
        choice_list[(signed long int)tests_cursor] = (char)flip_to;
        sample_list[(signed long int)tests_cursor] = (char)(randomize[(signed long int)flip_to] == cchoice);
        tests_cursor = tests_cursor + 1;
        tests_total = tests_cursor;
        randomize_samples(randomize, &cchoice, test_mode);
        if(!(restart_mode == 0))
        {
          seek_to = seek_to + (start_pos - current_pos);
          do_seek = 1;
        }

        if(tests_cursor == tests)
        {
          pthread_mutex_lock(&state.mutex);
          state.exiting = 1;
          pthread_mutex_unlock(&state.mutex);
          break;
        }

      }

      if(do_pause == 0 && !(paused == 0))
      {
        current_sample = randomize[(signed long int)current_choice];
        memset((void *)fragmentA, 0, (unsigned long int)fragsize);
        if(!(do_seek == 0))
        {
          current_pos = current_pos + seek_to;
          seek_to = (signed long int)0;
          do_seek = 0;
          loop = 0;
        }

      }

      else
      {
        fragments_played = fragments_played + 1ul;
        fill_fragment1(fragmentA, pcm[(signed long int)current_sample], start_pos, &current_pos, end_pos, &loop, fragsamples, fadewindow1);
        if(!(do_flip == 0) || !(do_seek == 0) || !(do_select == 0))
        {
          current_sample = randomize[(signed long int)current_choice];
          if(!(do_seek == 0))
          {
            current_pos = save_pos + seek_to;
            fill_fragment2(fragmentB, pcm[(signed long int)current_sample], start_pos, &current_pos, end_pos, &loop, fragsamples, fadewindow1);
            seek_to = (signed long int)0;
            seeks = seeks + 1;
          }

          else
            fill_fragment1(fragmentB, pcm[(signed long int)current_sample], start_pos, &save_pos, end_pos, &save_loop, fragsamples, fadewindow1);
        }

      }
      if(!(do_flip == 0) || !(do_seek == 0) || !(do_select == 0))
      {
        signed int main$$1$$14$$7$$3$$5$$j;
        unsigned char *A = fragmentA;
        unsigned char *B = fragmentB;
        float *wA = fadewindow1;
        float *wB;
        float *beep = ((float *)NULL);
        if(!(do_select == 0))
        {
          wA = fadewindow3;
          beep = beep2;
        }

        if(!(do_flip == 0))
        {
          beep = ((float *)NULL);
          switch(beep_mode)
          {
            case 1:
            {
              wA = fadewindow2;
              flips[(signed long int)0] = flips[(signed long int)0] + 1;
              break;
            }
            case 2:
            {
              wA = fadewindow3;
              beep = beep1;
              flips[(signed long int)1] = flips[(signed long int)1] + 1;
              break;
            }
            case 3:
            {
              wA = fadewindow1;
              flips[(signed long int)2] = flips[(signed long int)2] + 1;
            }
          }
        }

        wB = (wA + (signed long int)fragsamples) - (signed long int)1;
        i = 0;
        for( ; !(i >= fragsamples); i = i + 1)
        {
          main$$1$$14$$7$$3$$5$$j = 0;
          for( ; !(main$$1$$14$$7$$3$$5$$j >= ch); main$$1$$14$$7$$3$$5$$j = main$$1$$14$$7$$3$$5$$j + 1)
          {
            float return_value_get_val$19;
            return_value_get_val$19=get_val(A, bps);
            float return_value_get_val$20;
            return_value_get_val$20=get_val(B, bps);
            if(!(beep == ((float *)NULL)))
              tmp_if_expr$21 = beep[(signed long int)i];

            else
              tmp_if_expr$21 = 0.f;
            put_val(A, bps, return_value_get_val$19 * wA[(signed long int)i] + return_value_get_val$20 * *(wB - (signed long int)i) + tmp_if_expr$21);
            A = A + (signed long int)bps;
            B = B + (signed long int)bps;
          }
        }
        do_flip = 0;
        do_select = 0;
        do_seek = 0;
      }

      else
        if(!(do_pause == 0))
        {
          unsigned char *main$$1$$14$$7$$3$$6$$A = fragmentA;
          signed int main$$1$$14$$7$$3$$6$$j;
          if(!(paused == 0))
          {
            float *main$$1$$14$$7$$3$$6$$1$$wA = (fadewindow1 + (signed long int)fragsamples) - (signed long int)1;
            i = 0;
            for( ; !(i >= fragsamples); i = i + 1)
            {
              main$$1$$14$$7$$3$$6$$j = 0;
              for( ; !(main$$1$$14$$7$$3$$6$$j >= ch); main$$1$$14$$7$$3$$6$$j = main$$1$$14$$7$$3$$6$$j + 1)
              {
                float return_value_get_val$22;
                return_value_get_val$22=get_val(main$$1$$14$$7$$3$$6$$A, bps);
                put_val(main$$1$$14$$7$$3$$6$$A, bps, return_value_get_val$22 * *(main$$1$$14$$7$$3$$6$$1$$wA - (signed long int)i));
                main$$1$$14$$7$$3$$6$$A = main$$1$$14$$7$$3$$6$$A + (signed long int)bps;
              }
            }
          }

          else
          {
            float *main$$1$$14$$7$$3$$6$$2$$wA = fadewindow1;
            i = 0;
            for( ; !(i >= fragsamples); i = i + 1)
            {
              main$$1$$14$$7$$3$$6$$j = 0;
              for( ; !(main$$1$$14$$7$$3$$6$$j >= ch); main$$1$$14$$7$$3$$6$$j = main$$1$$14$$7$$3$$6$$j + 1)
              {
                float return_value_get_val$23;
                return_value_get_val$23=get_val(main$$1$$14$$7$$3$$6$$A, bps);
                put_val(main$$1$$14$$7$$3$$6$$A, bps, return_value_get_val$23 * main$$1$$14$$7$$3$$6$$2$$wA[(signed long int)i]);
                main$$1$$14$$7$$3$$6$$A = main$$1$$14$$7$$3$$6$$A + (signed long int)bps;
              }
            }
          }
          paused = (signed int)!(paused != 0);
          do_pause = 0;
          memset((void *)fragmentB, 0, (unsigned long int)fragsize);
        }

      pthread_mutex_lock(&state.mutex);
      state.fragment = fragmentA;
      state.fragment_size = fragsize;
      pthread_cond_signal(&state.play_cond);
    }

  }
  min_panel_remove();
  write(exit_fds[(signed long int)1], (const void *)" ", (unsigned long int)1);
  pthread_cond_signal(&state.play_cond);
  pthread_cond_signal(&state.key_cond);
  pthread_mutex_unlock(&state.mutex);
  if(tests_cursor >= 1 && !(test_mode == 3))
  {
    signed int total1 = 0;
    i = 0;
    for( ; !(i >= tests_cursor); i = i + 1)
      total1 = total1 + (signed int)sample_list[(signed long int)i];
    switch(test_mode)
    {
      case 0:
      {
        fprintf(stdout, "\nA/B test results:\n");
        fprintf(stdout, "\tSample 1 (%s): %d/%d trials.\n", pcm[(signed long int)0]->name, tests_cursor - total1, tests_cursor);
        fprintf(stdout, "\tSample 2 (%s): %d/%d trials.\n", pcm[(signed long int)1]->name, total1, tests_cursor);
        break;
      }
      case 1:
      {
        fprintf(stdout, "\nA/B/X test results:\n");
        fprintf(stdout, "\tCorrect sample identified %d/%d trials.\n", total1, tests_cursor);
        break;
      }
      case 2:
      {
        fprintf(stdout, "\nX/X/Y test results:\n");
        fprintf(stdout, "\tCorrect sample identified %d/%d trials.\n", total1, tests_cursor);
      }
    }
    if(test_mode == 0)
    {
      double main$$1$$15$$3$$p;
      main$$1$$15$$3$$p=compute_pdual(total1, tests_cursor);
      if(total1 >= 1 && !(total1 >= tests_cursor))
        fprintf(stdout, "\tProbability of equal/more significant result via random chance: %.2f%%\n", main$$1$$15$$3$$p * (double)100);

      else
        fprintf(stdout, "\tProbability of equally significant result via random chance: %.2f%%\n", main$$1$$15$$3$$p * (double)100);
      if(main$$1$$15$$3$$p < .01)
        fprintf(stdout, "\tStatistically significant result (>=99%% confidence).\n");

    }

    else
    {
      double p;
      p=compute_psingle(total1, tests_cursor);
      if(!(total1 >= tests_cursor))
        fprintf(stdout, "\tProbability of %d or better correct via random chance: %.2f%%\n", total1, p * (double)100);

      else
        fprintf(stdout, "\tProbability of %d correct via random chance: %.2f%%\n", total1, p * (double)100);
      if(p < .01)
        fprintf(stdout, "\tStatistically significant result (>=99%% confidence).\n");

    }
    fprintf(stdout, "\nTesting metadata:\n");
    if(!(tests_cursor >= tests))
      fprintf(stdout, "\tTest was aborted early (%d/%d trials).\n", tests_cursor, tests);

    char *return_value_make_time_string$24;
    return_value_make_time_string$24=make_time_string((double)fragments_played * .1, 0);
    fprintf(stdout, "\tTotal time spent testing: %s\n", return_value_make_time_string$24);
    fprintf(stdout, "\tTotal seeks: %d\n", seeks);
    if(!(flips[0l] == 0))
      fprintf(stdout, "\tMark flip used %d times.\n", flips[(signed long int)0]);

    if(!(flips[1l] == 0))
      fprintf(stdout, "\tBeep flip used %d times.\n", flips[(signed long int)1]);

    if(!(flips[2l] == 0))
      fprintf(stdout, "\tSilent flip used %d times.\n", flips[(signed long int)2]);

    if(!(running_score == 0))
      fprintf(stdout, "\tRunning totals (-g) displayed during test.\n");

    else
      if(!(undos == 0))
        fprintf(stdout, "\tUndo was used %d time[s].\n", undos);

      else
        fprintf(stdout, "\tUndo was not used.\n");
    fprintf(stdout, "\n");
  }

  if(!(sb_verbose == 0))
    fprintf(stderr, "\nWaiting on keyboard thread...");

  pthread_join(fd_handle, (void **)(void *)0);
  if(!(sb_verbose == 0))
    fprintf(stderr, " joined.\nWaiting on playback thread...");

  pthread_join(playback_handle, (void **)(void *)0);
  if(!(sb_verbose == 0))
    fprintf(stderr, " joined.\n");

  free((void *)fadewindow1);
  free((void *)fadewindow2);
  free((void *)fadewindow3);
  free((void *)beep1);
  free((void *)beep2);
  free((void *)fragmentA);
  free((void *)fragmentB);
  i = 0;
  for( ; !(i >= test_files); i = i + 1)
    free_pcm(pcm[(signed long int)i]);
  if(!(sb_verbose == 0))
    fprintf(stderr, "Done.\n");

  return 0;
}

// make_time_string
// file main.h line 70
extern char * make_time_string(double is, signed int pad)
{
  double s;
  double return_value_rint$1;
  return_value_rint$1=rint(is * (double)100);
  s = return_value_rint$1 / 100. + 1.e-6;
  signed long int hrs = (signed long int)((s / (double)60) / (double)60);
  signed long int min = (signed long int)(s / (double)60 - (double)(hrs * (signed long int)60));
  signed long int sec = (signed long int)((s - (double)(hrs * (signed long int)60 * (signed long int)60)) - (double)(min * (signed long int)60));
  signed long int hsec = (signed long int)((s - (double)(signed int)s) * (double)100);
  if(!(pad == 0))
    snprintf(timebuffer, (unsigned long int)80, "%02ld:%02ld:%02ld.%02ld", hrs, min, sec, hsec);

  else
    if(hrs >= 1l)
      snprintf(timebuffer, (unsigned long int)80, "%ld:%02ld:%02ld.%02ld", hrs, min, sec, hsec);

    else
      if(min >= 1l)
        snprintf(timebuffer, (unsigned long int)80, "%ld:%02ld.%02ld", min, sec, hsec);

      else
        snprintf(timebuffer, (unsigned long int)80, "%ld.%02ld", sec, hsec);
  return timebuffer;
}

// metadata_callback
// file loader.c line 893
static void metadata_callback(const struct anonymous *decoder, const struct anonymous$38 *metadata, void *client_data)
{
  struct anonymous$48 *flac = (struct anonymous$48 *)client_data;
  struct pcm_struct *pcm = flac->pcm;
  if((signed int)metadata->type == FLAC__METADATA_TYPE_STREAMINFO)
  {
    pcm->size = (signed long int)metadata->data.stream_info.total_samples;
    pcm->rate = (signed int)metadata->data.stream_info.sample_rate;
  }

}

// min_bg
// file mincurses.c line 622
extern signed int min_bg(signed int c)
{
  signed int ret = 0;
  if(!(c >= 0))
  {
    if(bg >= 0)
    {
      bg = -1;
      signed int return_value_unset$1;
      return_value_unset$1=unset();
      ret = ret | return_value_unset$1;
      signed int return_value_reset$2;
      return_value_reset$2=reset();
      ret = ret | return_value_reset$2;
    }

  }

  else
    if(!(bg == c))
      ret=setbg(c);

  return ret;
}

// min_blink
// file mincurses.c line 663
extern signed int min_blink(signed int flag)
{
  signed int ret = 0;
  if(flag == 0)
  {
    if(!(blink == 0))
    {
      blink = 0;
      signed int return_value_unset$1;
      return_value_unset$1=unset();
      ret = ret | return_value_unset$1;
      signed int return_value_reset$2;
      return_value_reset$2=reset();
      ret = ret | return_value_reset$2;
    }

  }

  else
    if(blink == 0)
      ret=setblink();

  return ret;
}

// min_bold
// file mincurses.c line 648
extern signed int min_bold(signed int flag)
{
  signed int ret = 0;
  if(flag == 0)
  {
    if(!(bold == 0))
    {
      bold = 0;
      signed int return_value_unset$1;
      return_value_unset$1=unset();
      ret = ret | return_value_unset$1;
      signed int return_value_reset$2;
      return_value_reset$2=reset();
      ret = ret | return_value_reset$2;
    }

  }

  else
    if(bold == 0)
      ret=setbold();

  return ret;
}

// min_clrbol
// file mincurses.c line 490
extern signed int min_clrbol(void)
{
  if(!(cur_term->type.Strings[269l] == ((char *)NULL)))
  {
    min_putp(cur_term->type.Strings[(signed long int)269]);
    return 0;
  }

  else
    return 1;
}

// min_clreol
// file mincurses.c line 482
extern signed int min_clreol(void)
{
  if(!(cur_term->type.Strings[6l] == ((char *)NULL)))
  {
    min_putp(cur_term->type.Strings[(signed long int)6]);
    return 0;
  }

  else
    return 1;
}

// min_color
// file mincurses.c line 637
extern signed int min_color(signed int f, signed int b)
{
  signed int ret = 0;
  fg = -1;
  bg = -1;
  signed int return_value_unset$1;
  return_value_unset$1=unset();
  ret = ret | return_value_unset$1;
  signed int return_value_reset$2;
  return_value_reset$2=reset();
  ret = ret | return_value_reset$2;
  signed int return_value_min_fg$3;
  return_value_min_fg$3=min_fg(f);
  ret = ret | return_value_min_fg$3;
  signed int return_value_min_bg$4;
  return_value_min_bg$4=min_bg(b);
  ret = ret | return_value_min_bg$4;
  return ret;
}

// min_fg
// file mincurses.c line 607
extern signed int min_fg(signed int c)
{
  signed int ret = 0;
  if(!(c >= 0))
  {
    if(fg >= 0)
    {
      fg = -1;
      signed int return_value_unset$1;
      return_value_unset$1=unset();
      ret = ret | return_value_unset$1;
      signed int return_value_reset$2;
      return_value_reset$2=reset();
      ret = ret | return_value_reset$2;
    }

  }

  else
    if(!(fg == c))
      ret=setfg(c);

  return ret;
}

// min_flush
// file mincurses.h line 28
extern signed int min_flush()
{
  signed int len = buf_fill;
  char *b = outbuf;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  while(!(len == 0))
  {
    signed int ret;
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    signed long int return_value_write$2;
    return_value_write$2=write(outfd, (const void *)b, (unsigned long int)len);
    ret = (signed int)return_value_write$2;
    if(!(ret >= 1))
    {
      if(ret == 0)
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value___errno_location$3=__errno_location();
        tmp_if_expr$4 = *return_value___errno_location$3 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
        continue;

      return -1;
    }

    else
    {
      b = b + (signed long int)ret;
      len = len - ret;
    }
  }
  buf_fill = 0;
  return 0;
}

// min_getch
// file mincurses.h line 29
extern signed int min_getch(signed int nonblock)
{
  struct tries *ptr;
  signed int ch = 0;
  if(key_init == 0)
    minc_init_keytry();

  ptr = keytree;
  _Bool tmp_if_expr$1;
  for( ; (_Bool)1; ptr = ptr->child)
  {
    if(!(head == -1) && !(peek == head))
      tmp_if_expr$1 = fifo[(signed long int)head] >= 0401 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      break;

    else
      if(head == -1 || peek == tail)
      {
        ch=fifo_push(nonblock);
        if(ch == -1)
        {
          peek = head;
          return -1;
        }

      }

    ch=fifo_peek();
    if(ch >= 0401)
    {
      peek = head;
      if(tail == 0)
        tail = 160 - 1;

      else
        tail = tail - 1;
      if(head == tail)
        fifo_clear();

      return ch;
    }

    for( ; !(ptr == ((struct tries *)NULL)); ptr = ptr->sibling)
      if(ptr->ch == (unsigned char)ch)
        break;

    if(ptr == ((struct tries *)NULL))
      break;

    if(!((signed int)ptr->value == 0))
    {
      if(peek == tail)
        fifo_clear();

      else
        head = peek;
      return (signed int)ptr->value;
    }

  }
  ch=fifo_pull();
  peek = head;
  return ch;
}

// min_gfx
// file mincurses.c line 698
extern signed int min_gfx(signed int flag)
{
  signed int ret = 0;
  if(flag == 0)
  {
    if(!(acs == 0))
    {
      if(!(cur_term->type.Strings[38l] == ((char *)NULL)))
      {
        acs = 0;
        min_putp(cur_term->type.Strings[(signed long int)38]);
      }

      else
      {
        acs = 0;
        signed int return_value_unset$1;
        return_value_unset$1=unset();
        ret = ret | return_value_unset$1;
        signed int return_value_reset$2;
        return_value_reset$2=reset();
        ret = ret | return_value_reset$2;
      }
    }

  }

  else
    if(acs == 0)
      ret=setgfx();

  return ret;
}

// min_hidecur
// file mincurses.c line 466
extern signed int min_hidecur(void)
{
  if(!(cur_term->type.Strings[13l] == ((char *)NULL)))
  {
    min_putp(cur_term->type.Strings[(signed long int)13]);
    return 0;
  }

  else
    return 1;
}

// min_mvcur
// file mincurses.c line 326
extern void min_mvcur(signed int x, signed int y)
{
  signed int yoff = y - cursor_line_offset;
  for( ; !(yoff >= 0); yoff = yoff + 1)
  {
    if(!(cur_term->type.Strings[19l] == ((char *)NULL)))
      min_putp(cur_term->type.Strings[(signed long int)19]);

    cursor_line_offset = cursor_line_offset - 1;
  }
  for( ; yoff >= 1; yoff = yoff - 1)
  {
    if(!(cur_term->type.Strings[11l] == ((char *)NULL)))
      min_putp(cur_term->type.Strings[(signed long int)11]);

    cursor_line_offset = cursor_line_offset + 1;
  }
  char *return_value_tparm$1;
  if(!(cur_term->type.Strings[8l] == ((char *)NULL)))
  {
    return_value_tparm$1=tparm(cur_term->type.Strings[(signed long int)8], x);
    min_putp(return_value_tparm$1);
  }

}

// min_panel_contract
// file mincurses.c line 430
extern signed int min_panel_contract(signed int l, signed int bottomp)
{
  signed int ret = 0;
  if(l >= 1)
  {
    if(!(panel_lines >= l))
      l = panel_lines;

    if(!(bottomp == 0))
    {
      min_mvcur(0, panel_lines - l);
      if(!(cur_term->type.Strings[106l] == ((char *)NULL)))
      {
        char *return_value_tparm$1;
        return_value_tparm$1=tparm(cur_term->type.Strings[(signed long int)106], l);
        signed int return_value_min_putp$2;
        return_value_min_putp$2=min_putp(return_value_tparm$1);
        ret = ret | return_value_min_putp$2;
      }

      else
        ret = 1;
    }

    else
    {
      min_mvcur(0, 0);
      if(!(cur_term->type.Strings[106l] == ((char *)NULL)))
      {
        char *return_value_tparm$3;
        return_value_tparm$3=tparm(cur_term->type.Strings[(signed long int)106], l);
        signed int return_value_min_putp$4;
        return_value_min_putp$4=min_putp(return_value_tparm$3);
        ret = ret | return_value_min_putp$4;
      }

      else
        ret = 1;
    }
    panel_lines = panel_lines - l;
  }

  return ret;
}

// min_panel_expand
// file mincurses.c line 406
extern signed int min_panel_expand(signed int l, signed int bottomp)
{
  signed int i;
  signed int ret = 0;
  signed int return_value_min_putstr$1;
  if(!((signed int)cur_term->type.Numbers[2l] >= l + panel_lines))
    return 1;

  else
  {
    if(!(bottomp == 0))
    {
      min_mvcur(0, panel_lines);
      i = 0;
      for( ; !(i >= l + -1); i = i + 1)
      {
        return_value_min_putstr$1=min_putstr("\n\r");
        ret = ret | return_value_min_putstr$1;
      }
      panel_lines = panel_lines + l;
      cursor_line_offset = panel_lines - 1;
    }

    else
    {
      min_mvcur(0, (panel_lines + l) - 1);
      min_mvcur(0, 0);
      if(!(cur_term->type.Strings[110l] == ((char *)NULL)))
      {
        char *return_value_tparm$2;
        return_value_tparm$2=tparm(cur_term->type.Strings[(signed long int)110], l);
        signed int return_value_min_putp$3;
        return_value_min_putp$3=min_putp(return_value_tparm$2);
        ret = ret | return_value_min_putp$3;
      }

      else
        ret = 1;
      panel_lines = panel_lines + l;
      cursor_line_offset = 0;
    }
    return ret;
  }
}

// min_panel_init
// file mincurses.c line 365
extern signed int min_panel_init(signed int pl)
{
  signed int i;
  signed int ret = 0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  char *return_value_tparm$5;
  if(initted == 0)
  {
    signed int return_value_isatty$1;
    return_value_isatty$1=isatty(1);
    if(!(return_value_isatty$1 == 0))
      outfd = 1;

    else
      outfd = 2;
    tcgetattr(outfd, &orig);
    setupterm(((const char *)NULL), outfd, ((signed int *)NULL));
    setup_term_customize();
    _nc_init_acs();
    if(cur_term->type.Strings[19l] == ((char *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = !(cur_term->type.Strings[(signed long int)11] != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = !(cur_term->type.Strings[(signed long int)8] != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = pl > (signed int)cur_term->type.Numbers[(signed long int)2] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      tcsetattr(outfd, 1, &orig);
      return -1;
    }

    if(!(cur_term->type.Strings[89l] == ((char *)NULL)))
    {
      return_value_tparm$5=tparm(cur_term->type.Strings[(signed long int)89], 1);
      min_putp(return_value_tparm$5);
    }

    minc_init_keytry();
    panel_lines = pl;
    i = 0;
    for( ; !(i >= pl + -1); i = i + 1)
      min_putstr("\r\n");
    cursor_line_offset = pl - 1;
    initted = 1;
    min_flush();
  }

  return ret;
}

// min_panel_remove
// file mincurses.h line 36
extern void min_panel_remove(void)
{
  if(!(initted == 0))
  {
    if(!(cur_term->type.Strings[106l] == ((char *)NULL)))
    {
      min_mvcur(0, 0);
      char *return_value_tparm$1;
      return_value_tparm$1=tparm(cur_term->type.Strings[(signed long int)106], panel_lines);
      min_putp(return_value_tparm$1);
    }

    min_unset();
    min_showcur();
    min_flush();
    tcsetattr(outfd, 1, &orig);
    initted = 0;
  }

}

// min_putchar
// file mincurses.c line 291
extern signed int min_putchar(signed int c)
{
  outbuf[(signed long int)buf_fill] = (char)c;
  buf_fill = buf_fill + 1;
  signed int return_value_min_flush$1;
  if(buf_fill == 160)
  {
    return_value_min_flush$1=min_flush();
    return return_value_min_flush$1;
  }

  else
    return 0;
}

// min_putp
// file mincurses.c line 299
extern signed int min_putp(const char *str)
{
  signed int return_value_tputs$1;
  return_value_tputs$1=tputs(str, 1, min_putchar);
  return return_value_tputs$1;
}

// min_putstr
// file mincurses.c line 319
extern signed int min_putstr(const char *str)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  len = (signed int)return_value_strlen$1;
  signed int return_value_min_write$2;
  return_value_min_write$2=min_write(str, len);
  return return_value_min_write$2;
}

// min_putstrb
// file tty.c line 695
static void min_putstrb(char *s)
{
  min_bold(1);
  min_putstr(s);
  min_bold(0);
}

// min_reverse
// file mincurses.c line 718
extern signed int min_reverse(signed int flag)
{
  signed int ret = 0;
  if(flag == 0)
  {
    if(!(rev == 0))
    {
      rev = 0;
      signed int return_value_unset$1;
      return_value_unset$1=unset();
      ret = ret | return_value_unset$1;
      signed int return_value_reset$2;
      return_value_reset$2=reset();
      ret = ret | return_value_reset$2;
    }

  }

  else
    if(rev == 0)
      ret=setreverse();

  return ret;
}

// min_showcur
// file mincurses.c line 474
extern signed int min_showcur(void)
{
  if(!(cur_term->type.Strings[20l] == ((char *)NULL)))
  {
    min_putp(cur_term->type.Strings[(signed long int)20]);
    return 0;
  }

  else
    return 1;
}

// min_underline
// file mincurses.c line 678
extern signed int min_underline(signed int flag)
{
  signed int ret = 0;
  if(flag == 0)
  {
    if(!(ul == 0))
    {
      if(!(cur_term->type.Strings[44l] == ((char *)NULL)))
      {
        ul = 0;
        min_putp(cur_term->type.Strings[(signed long int)44]);
      }

      else
      {
        ul = 0;
        signed int return_value_unset$1;
        return_value_unset$1=unset();
        ret = ret | return_value_unset$1;
        signed int return_value_reset$2;
        return_value_reset$2=reset();
        ret = ret | return_value_reset$2;
      }
    }

  }

  else
    if(ul == 0)
      ret=setunderline();

  return ret;
}

// min_unset
// file mincurses.c line 521
extern signed int min_unset(void)
{
  fg = -1;
  bg = -1;
  bold = 0;
  rev = 0;
  blink = 0;
  acs = 0;
  ul = 0;
  signed int return_value_unset$1;
  return_value_unset$1=unset();
  return return_value_unset$1;
}

// min_write
// file mincurses.c line 303
extern signed int min_write(const char *str, signed int len)
{
  signed int ret = 0;
  while(!(len == 0))
  {
    signed int bytes = buf_fill + len > 160 ? 160 - buf_fill : len;
    memcpy((void *)(outbuf + (signed long int)buf_fill), (const void *)str, (unsigned long int)bytes);
    buf_fill = buf_fill + bytes;
    if(buf_fill == 160)
    {
      ret=min_flush();
      if(!(ret == 0))
        return ret;

    }

    str = str + (signed long int)bytes;
    len = len - bytes;
  }
  return 0;
}

// minc_init_keytry
// file mincurses.c line 121
static void minc_init_keytry()
{
  unsigned long int n;
  struct termtype *tp = &cur_term->type;
  n = (unsigned long int)0;
  for( ; !(_nc_tinfo_fkeys[(signed long int)n].code == 0ul); n = n + 1ul)
    if(!(_nc_tinfo_fkeys[(signed long int)n].offset >= 414u))
      _nc_add_to_try(&keytree, tp->Strings[(signed long int)_nc_tinfo_fkeys[(signed long int)n].offset], (unsigned int)_nc_tinfo_fkeys[(signed long int)n].code);

  n = (unsigned long int)414;
  char *tmp_if_expr$1;
  signed int return_value_find_definition$2;
  for( ; !(n >= (unsigned long int)tp->num_Strings); n = n + 1ul)
  {
    const char *name;
    if(n >= 414ul)
      tmp_if_expr$1 = tp->ext_Names[(signed long int)((n - (unsigned long int)((signed int)tp->num_Strings - (signed int)tp->ext_Strings)) + (unsigned long int)((signed int)tp->ext_Numbers + (signed int)tp->ext_Booleans))];

    else
      tmp_if_expr$1 = strnames[(signed long int)n];
    name = tmp_if_expr$1;
    char *value = tp->Strings[(signed long int)n];
    if(!(name == ((const char *)NULL)))
    {
      if((signed int)*name == 107)
      {
        if(!(value == ((char *)NULL)))
        {
          return_value_find_definition$2=find_definition(keytree, value);
          if(return_value_find_definition$2 == 0)
            _nc_add_to_try(&keytree, value, (unsigned int)((n - (unsigned long int)414) + (unsigned long int)0777));

        }

      }

    }

  }
  key_init = 1;
}

// oggflac_id
// file loader.c line 108
static signed int oggflac_id(char *path, unsigned char *buf)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)buf, (const void *)"OggS", (unsigned long int)4);
  _Bool tmp_if_expr$5;
  signed int return_value_memcmp$2;
  _Bool tmp_if_expr$4;
  signed int return_value_flac_id$3;
  if(return_value_memcmp$1 == 0)
  {
    return_value_memcmp$2=memcmp((const void *)(buf + (signed long int)28), (const void *)"\177FLAC", (unsigned long int)5);
    if(return_value_memcmp$2 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_flac_id$3=flac_id(path, buf + (signed long int)28);
      tmp_if_expr$4 = return_value_flac_id$3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$5 = (_Bool)0;
  return (signed int)tmp_if_expr$5;
}

// oggflac_load
// file loader.c line 1026
static struct pcm_struct * oggflac_load(char *path, struct _IO_FILE *in)
{
  struct pcm_struct *return_value_flac_load_i$1;
  return_value_flac_load_i$1=flac_load_i(path, in, 1);
  return return_value_flac_load_i$1;
}

// opc_close
// file loader.c line 1155
signed int opc_close(void *_stream)
{
  return 0;
}

// opc_read
// file loader.c line 1143
signed int opc_read(void *_stream, unsigned char *_ptr, signed int _nbytes)
{
  unsigned long int return_value_fread$1;
  return_value_fread$1=fread((void *)_ptr, (unsigned long int)1, (unsigned long int)_nbytes, (struct _IO_FILE *)_stream);
  return (signed int)return_value_fread$1;
}

// opc_seek
// file loader.c line 1147
signed int opc_seek(void *_stream, signed long long int _offset, signed int _whence)
{
  signed int return_value_fseek$1;
  return_value_fseek$1=fseek((struct _IO_FILE *)_stream, _offset, _whence);
  return return_value_fseek$1;
}

// opc_tell
// file loader.c line 1151
signed long long int opc_tell(void *_stream)
{
  signed long int return_value_ftell$1;
  return_value_ftell$1=ftell((struct _IO_FILE *)_stream);
  return return_value_ftell$1;
}

// opus_id
// file loader.c line 119
static signed int opus_id(char *path, unsigned char *buf)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)buf, (const void *)"OggS", (unsigned long int)4);
  _Bool tmp_if_expr$3;
  signed int return_value_memcmp$2;
  if(return_value_memcmp$1 == 0)
  {
    return_value_memcmp$2=memcmp((const void *)(buf + (signed long int)28), (const void *)"OpusHead", (unsigned long int)8);
    tmp_if_expr$3 = return_value_memcmp$2 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return (signed int)tmp_if_expr$3;
}

// opus_load
// file loader.c line 1162
static struct pcm_struct * opus_load(char *path, struct _IO_FILE *in)
{
  struct OggOpusFile *of;
  struct pcm_struct *pcm = (struct pcm_struct *)(void *)0;
  signed long int opus_load$$1$$fill = (signed long int)0;
  signed int throttle = 0;
  signed int last_section = -1;
  signed int return_value_fseek$1;
  return_value_fseek$1=fseek(in, (signed long int)0, 0);
  void *return_value_calloc$2;
  char *return_value_trim_path$3;
  char *return_value___strdup$4;
  signed long int return_value_op_pcm_total$5;
  void *return_value_calloc$6;
  char *return_value___strdup$7;
  char *return_value___strdup$8;
  char *return_value___strdup$9;
  char *return_value___strdup$10;
  char *return_value___strdup$11;
  char *return_value___strdup$12;
  char *return_value___strdup$13;
  char *return_value___strdup$14;
  char *return_value___strdup$15;
  char *return_value___strdup$16;
  char *return_value___strdup$17;
  char *return_value___strdup$18;
  char *return_value___strdup$19;
  char *return_value___strdup$20;
  char *return_value___strdup$21;
  char *return_value___strdup$22;
  signed long int tmp_post$25;
  float *tmp_post$26;
  if(return_value_fseek$1 == -1)
    fprintf(stderr, "%s: Failed to seek\n", path);

  else
  {
    of=op_open_callbacks((void *)in, &opus_callbacks, (const unsigned char *)(void *)0, (unsigned long int)0, (signed int *)(void *)0);
    if(of == ((struct OggOpusFile *)NULL))
      fprintf(stderr, "Input does not appear to be an Opus bitstream.\n");

    else
    {
      return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct pcm_struct) /*56ul*/ );
      pcm = (struct pcm_struct *)return_value_calloc$2;
      return_value_trim_path$3=trim_path(path);
      return_value___strdup$4=__strdup(return_value_trim_path$3);
      pcm->name = return_value___strdup$4;
      pcm->nativebits = -32;
      pcm->currentbits = -32;
      pcm->ch=op_channel_count(of, -1);
      pcm->rate = 48000;
      return_value_op_pcm_total$5=op_pcm_total(of, -1);
      pcm->size = (signed long int)((unsigned long int)(return_value_op_pcm_total$5 * (signed long int)pcm->ch) * sizeof(float) /*4ul*/ );
      return_value_calloc$6=calloc((unsigned long int)pcm->size, (unsigned long int)1);
      pcm->data = (unsigned char *)return_value_calloc$6;
      switch(pcm->ch)
      {
        case 1:
        {
          return_value___strdup$7=__strdup("M");
          pcm->matrix = return_value___strdup$7;
          return_value___strdup$8=__strdup("A");
          pcm->mix = return_value___strdup$8;
          break;
        }
        case 2:
        {
          return_value___strdup$9=__strdup("L,R");
          pcm->matrix = return_value___strdup$9;
          return_value___strdup$10=__strdup("BC");
          pcm->mix = return_value___strdup$10;
          break;
        }
        case 3:
        {
          return_value___strdup$11=__strdup("L,C,R");
          pcm->matrix = return_value___strdup$11;
          return_value___strdup$12=__strdup("BDC");
          pcm->mix = return_value___strdup$12;
          break;
        }
        case 4:
        {
          return_value___strdup$13=__strdup("L,R,BL,BR");
          pcm->matrix = return_value___strdup$13;
          return_value___strdup$14=__strdup("BCFG");
          pcm->mix = return_value___strdup$14;
          break;
        }
        case 5:
        {
          return_value___strdup$15=__strdup("L,C,R,BL,BR");
          pcm->matrix = return_value___strdup$15;
          return_value___strdup$16=__strdup("BDCFG");
          pcm->mix = return_value___strdup$16;
          break;
        }
        case 6:
        {
          return_value___strdup$17=__strdup("L,C,R,BL,BR,LFE");
          pcm->matrix = return_value___strdup$17;
          return_value___strdup$18=__strdup("BDCFGE");
          pcm->mix = return_value___strdup$18;
          break;
        }
        case 7:
        {
          return_value___strdup$19=__strdup("L,C,R,SL,SR,BC,LFE");
          pcm->matrix = return_value___strdup$19;
          return_value___strdup$20=__strdup("BDCKLJE");
          pcm->mix = return_value___strdup$20;
          break;
        }
        default:
        {
          return_value___strdup$21=__strdup("L,C,R,SL,SR,BL,BR,LFE");
          pcm->matrix = return_value___strdup$21;
          return_value___strdup$22=__strdup("BDCKLFGE");
          pcm->mix = return_value___strdup$22;
        }
      }
      while(!(sizeof(float) /*4ul*/  * (unsigned long int)opus_load$$1$$fill >= (unsigned long int)pcm->size))
      {
        signed int current_section;
        signed int i;
        signed int j;
        float pcmout[4096l];
        signed long int ret;
        signed int return_value_op_read_float$23;
        return_value_op_read_float$23=op_read_float(of, pcmout, 4096, &current_section);
        ret = (signed long int)return_value_op_read_float$23;
        float *d = (float *)pcm->data;
        float *s = pcmout;
        if(!(current_section == last_section))
        {
          last_section = current_section;
          signed int return_value_op_channel_count$24;
          return_value_op_channel_count$24=op_channel_count(of, -1);
          if(!(return_value_op_channel_count$24 == pcm->ch))
          {
            fprintf(stderr, "%s: Chained file changes channel count\n", path);
            goto err;
          }

        }

        if(!(ret >= 0l))
        {
          fprintf(stderr, "%s: Error while decoding file\n", path);
          goto err;
        }

        if(ret == 0l)
        {
          fprintf(stderr, "%s: Audio data ended prematurely\n", path);
          goto err;
        }

        i = 0;
        for( ; !((signed long int)i >= ret); i = i + 1)
        {
          j = 0;
          for( ; !(j >= pcm->ch); j = j + 1)
          {
            tmp_post$25 = opus_load$$1$$fill;
            opus_load$$1$$fill = opus_load$$1$$fill + 1l;
            tmp_post$26 = s;
            s = s + 1l;
            d[tmp_post$25] = *tmp_post$26;
          }
        }
        if((0x3f & throttle) == 0 && !(sb_verbose == 0))
          fprintf(stderr, "\rLoading %s: %ld to go...       ", pcm->name, (signed long int)((unsigned long int)pcm->size - (unsigned long int)opus_load$$1$$fill * sizeof(float) /*4ul*/ ));

        throttle = throttle + 1;
      }
      op_free(of);
      if(!(sb_verbose == 0))
        fprintf(stderr, "\rLoading %s: loaded.         ", pcm->name);

      return pcm;
    }
  }

err:
  ;
  op_free(of);
  free_pcm(pcm);
  return (struct pcm_struct *)(void *)0;
}

// panel_init
// file main.h line 71
extern void panel_init(struct pcm_struct **pcm, signed int test_files, signed int test_mode, double start, double end, double size, signed int flip_mode, signed int repeat_mode, signed int trials, signed int gabba)
{
  signed int return_value_min_panel_init$1;
  return_value_min_panel_init$1=min_panel_init((test_mode == 3 ? test_files + 6 : 7) + (gabba != 0 ? 1 : 0));
  if(!(return_value_min_panel_init$1 == 0))
  {
    fprintf(stderr, "Unable to initialize terminal (possibly insufficient lines)\n");
    exit(101);
  }

  if(!((signed int)*cur_term->type.Numbers >= 70))
  {
    fprintf(stderr, "Squisyhball requires a >=70 column terminal to run.\n");
    exit(102);
  }

  p_tm = test_mode;
  p_ch = pcm[(signed long int)0]->ch;
  p_b = pcm[(signed long int)0]->currentbits;
  p_r = pcm[(signed long int)0]->rate;
  p_pl = 0;
  p_st = start;
  p_cur = start;
  p_end = end;
  p_len = size;
  p_fm = flip_mode;
  p_rm = repeat_mode;
  p_tr = 0;
  p_tmax = trials;
  p_tn = 0;
  pcm_n = test_files;
  pcm_p = pcm;
  p_pau = 0;
  p_g = gabba;
  min_hidecur();
  panel_redraw_full();
}

// panel_redraw_full
// file tty.c line 276
void panel_redraw_full(void)
{
  signed int i = 2;
  if(p_tm == 3)
  {
    signed int return_value_draw_samples_box$1;
    return_value_draw_samples_box$1=draw_samples_box(i);
    i = i + return_value_draw_samples_box$1;
  }

  else
  {
    signed int return_value_draw_trials_box$2;
    return_value_draw_trials_box$2=draw_trials_box(i);
    i = i + return_value_draw_trials_box$2;
  }
  signed int return_value_draw_playbar$3;
  return_value_draw_playbar$3=draw_playbar(i);
  i = i + return_value_draw_playbar$3;
  signed int return_value_draw_timebar$4;
  return_value_draw_timebar$4=draw_timebar(i);
  i = i + return_value_draw_timebar$4;
  draw_topbar(1);
  force = 1;
  panel_update_pause(p_pau);
  panel_update_playing(p_pl);
  panel_update_start(p_st);
  panel_update_current(p_cur);
  panel_update_end(p_end);
  panel_update_repeat_mode(p_rm);
  panel_update_flip_mode(p_fm);
  if(!(p_tm == 3))
    panel_update_trials(p_tl, p_tc, p_tn);

  force = 0;
  min_flush();
}

// panel_toggle_keymap
// file main.h line 81
extern void panel_toggle_keymap(void)
{
  signed int l = 8;
  signed int o = 1;
  signed int x = ((signed int)cur_term->type.Numbers[(signed long int)0] - 70) / 2;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  if(p_keymap == 0)
  {
    signed int return_value_min_panel_expand$1;
    return_value_min_panel_expand$1=min_panel_expand(l, 0);
    if(!(return_value_min_panel_expand$1 == 0))
      goto __CPROVER_DUMP_L5;

    p_keymap = (signed int)!(p_keymap != 0);
    timerow = timerow + l;
    playrow = playrow + l;
    toprow = toprow + l;
    boxrow = boxrow + l;
    fliprow = fliprow + l;
    min_fg(6);
    tmp_post$2 = o;
    o = o + 1;
    min_mvcur(x, tmp_post$2);
    min_putstrb(" a b x 1 2 3... ");
    min_putstr(": Flip sample    ");
    min_putstrb("      A B ! @ # ");
    min_putstr(": Choose sample  ");
    tmp_post$3 = o;
    o = o + 1;
    min_mvcur(x, tmp_post$3);
    min_putstrb("        <enter> ");
    min_putstr(": Choose current ");
    if(p_g == 0)
    {
      min_putstrb("  + - <ins/del> ");
      min_putstr(": Undo/redo trial");
    }

    tmp_post$4 = o;
    o = o + 1;
    min_mvcur(x, tmp_post$4);
    min_putstrb("   <left/right> ");
    min_putstr(": Seek           ");
    min_putstrb("      <up/down> ");
    min_putstr(": Flip (casual)  ");
    tmp_post$5 = o;
    o = o + 1;
    min_mvcur(x, tmp_post$5);
    min_putstrb("        <space> ");
    min_putstr(": Pause/resume   ");
    min_putstrb("      <backspc> ");
    min_putstr(": Seek to start  ");
    tmp_post$6 = o;
    o = o + 1;
    min_mvcur(x, tmp_post$6);
    min_putstrb("        s S e E ");
    min_putstr(": set start/end  ");
    min_putstrb("            f r ");
    min_putstr(": Toggle modes   ");
    tmp_post$7 = o;
    o = o + 1;
    min_mvcur(x, tmp_post$7);
    min_putstrb("              ? ");
    min_putstr(": Toggle keymap  ");
    min_putstrb("      Control-c ");
    min_putstr(": Quit           ");
    min_unset();
  }

  else
  {
    p_keymap = (signed int)!(p_keymap != 0);
    min_panel_contract(l, 0);
    timerow = timerow - l;
    playrow = playrow - l;
    toprow = toprow - l;
    boxrow = boxrow - l;
    fliprow = fliprow - l;
  }

__CPROVER_DUMP_L5:
  ;
}

// panel_update_current
// file main.h line 75
extern void panel_update_current(double time)
{
  signed int now;
  double return_value_floor$1;
  return_value_floor$1=floor((time / p_len) * (double)cur_term->type.Numbers[(signed long int)0]);
  now = (signed int)return_value_floor$1;
  if(now >= (signed int)*cur_term->type.Numbers)
    now = (signed int)cur_term->type.Numbers[(signed long int)0] - 1;

  if(IEEE_FLOAT_NOTEQUAL(p_cur, time) || !(force == 0))
  {
    p_cur = time;
    min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] / 2 - 7, timerow);
    min_putchar(32);
    char *panel_update_current$$1$$1$$1$$time;
    panel_update_current$$1$$1$$1$$time=make_time_string(p_cur, 1);
    min_putstr(panel_update_current$$1$$1$$1$$time);
    min_putchar(32);
    if(!(force == 0) || !(was == now))
    {
      signed int pre;
      double return_value_floor$2;
      return_value_floor$2=floor((p_st / p_len) * (double)cur_term->type.Numbers[(signed long int)0]);
      pre = (signed int)return_value_floor$2;
      signed int post;
      double return_value_floor$3;
      return_value_floor$3=floor((p_end / p_len) * (double)cur_term->type.Numbers[(signed long int)0] + (double)1.e-6f);
      post = (signed int)return_value_floor$3;
      min_bold(1);
      min_gfx(1);
      if(was >= 0)
      {
        min_mvcur(was, playrow);
        if(!(post >= was) || !(was >= pre))
          min_color(3, 6);

        else
          min_color(3, 0);
        min_putchar(32);
      }

      was = now;
      min_mvcur(now, playrow);
      min_bg(0);
      min_putchar((signed int)acs_map[(signed long int)(unsigned char)120]);
      min_unset();
    }

    min_flush();
  }

}

// panel_update_end
// file main.h line 76
extern void panel_update_end(double time)
{
  if(IEEE_FLOAT_NOTEQUAL(p_end, time) || !(force == 0))
  {
    p_end = time;
    min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] / 2 + 7, timerow);
    min_putchar(32);
    if(p_end + 1.e-6 >= p_len)
    {
      min_fg(6);
      min_putstr("xx:xx:xx.xx");
      min_fg(-1);
    }

    else
    {
      char *panel_update_end$$1$$1$$2$$time;
      panel_update_end$$1$$1$$2$$time=make_time_string(p_end, 1);
      min_putstr(panel_update_end$$1$$1$$2$$time);
    }
    min_putchar(32);
    draw_playbar(playrow);
    signed int temp = force;
    force = 1;
    panel_update_current(p_cur);
    force = temp;
  }

}

// panel_update_flip_mode
// file main.h line 78
extern void panel_update_flip_mode(signed int mode)
{
  if(!(force == 0) || !(p_fm == mode))
  {
    min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] - 14, fliprow);
    min_fg(6);
    min_gfx(1);
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)113]);
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)113]);
    min_unset();
    p_fm = mode;
    switch(p_fm)
    {
      case 1:
      {
        min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] - 12, fliprow);
        min_putstr(" MARK FLIP ");
        break;
      }
      case 2:
      {
        min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] - 12, fliprow);
        min_putstr(" BEEP FLIP ");
        break;
      }
      case 3:
      {
        min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] - 14, fliprow);
        min_putstr(" SILENT FLIP ");
      }
    }
  }

}

// panel_update_pause
// file main.h line 80
extern void panel_update_pause(signed int flag)
{
  if(!(force == 0) || !(flag == p_pau))
  {
    p_pau = flag;
    min_mvcur(0, timerow);
    if(!(p_pau == 0))
    {
      min_blink(1);
      min_putstr("PAUSED ");
      min_blink(0);
    }

    else
    {
      min_putstr("PLAYING ");
      switch(p_tm)
      {
        case 0:

        case 1:
        {
          min_putchar(p_pl + 65);
          goto __CPROVER_DUMP_L5;
        }
        case 2:

        case 3:
          if(!(p_pl >= 9))
            min_putchar(p_pl + 49);

          else
            min_putchar(48);
        default:
        {

        __CPROVER_DUMP_L5:
          ;
          min_putchar(32);
        }
      }
    }
    min_gfx(1);
    min_fg(6);
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)113]);
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)113]);
    min_putchar((signed int)acs_map[(signed long int)(unsigned char)113]);
    min_unset();
  }

}

// panel_update_playing
// file main.h line 73
extern void panel_update_playing(signed int n)
{
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strlen$3;
  if(!(force == 0) || !(n == p_pl))
  {
    if(p_tm == 3)
    {
      min_mvcur(1, boxrow + 1 + p_pl);
      min_putchar(32);
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(pcm_p[(signed long int)p_pl]->name);
      if(!((unsigned long int)((signed int)*cur_term->type.Numbers + -4) >= return_value_strlen$2))
      {
        return_value_strlen$1=strlen(pcm_p[(signed long int)p_pl]->name);
        min_putstr(((pcm_p[(signed long int)p_pl]->name + (signed long int)return_value_strlen$1) - (signed long int)cur_term->type.Numbers[(signed long int)0]) + (signed long int)4);
      }

      else
        min_putstr(pcm_p[(signed long int)p_pl]->name);
      min_mvcur(1, boxrow + 1 + n);
      min_putchar(62);
      min_bold(1);
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(pcm_p[(signed long int)n]->name);
      if(!((unsigned long int)((signed int)*cur_term->type.Numbers + -4) >= return_value_strlen$4))
      {
        return_value_strlen$3=strlen(pcm_p[(signed long int)n]->name);
        min_putstr(((pcm_p[(signed long int)n]->name + (signed long int)return_value_strlen$3) - (signed long int)cur_term->type.Numbers[(signed long int)0]) + (signed long int)4);
      }

      else
        min_putstr(pcm_p[(signed long int)n]->name);
      min_unset();
    }

    p_pl = n;
    if(p_pau == 0)
    {
      min_mvcur(8, timerow);
      switch(p_tm)
      {
        case 0:

        case 1:
        {
          switch(p_pl)
          {
            case 0:
            {
              min_putchar(65);
              break;
            }
            case 1:
            {
              min_putchar(66);
              break;
            }
            case 2:
              min_putchar(88);
          }
          break;
        }
        case 2:

        case 3:
          if(!(p_pl >= 9))
            min_putchar(p_pl + 49);

          else
            min_putchar(48);
        default:
          ;
      }
    }

  }

}

// panel_update_repeat_mode
// file main.h line 77
extern void panel_update_repeat_mode(signed int mode)
{
  if(!(p_rm == mode))
  {
    signed int i;
    min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] - 30, fliprow);
    p_rm = mode;
    switch(p_rm)
    {
      case 0:
      {
        min_fg(6);
        min_gfx(1);
        i = 0;
        for( ; !(i >= 15); i = i + 1)
          min_putchar((signed int)acs_map[(signed long int)(unsigned char)113]);
        min_unset();
        break;
      }
      case 1:
      {
        min_putstr(" RESTART AFTER ");
        break;
      }
      case 2:
        min_putstr(" RESTART EVERY ");
    }
  }

}

// panel_update_start
// file main.h line 74
extern void panel_update_start(double time)
{
  if(IEEE_FLOAT_NOTEQUAL(p_st, time) || !(force == 0))
  {
    p_st = time;
    min_mvcur((signed int)cur_term->type.Numbers[(signed long int)0] / 2 - 21, timerow);
    min_putchar(32);
    if(p_st <= 0.000000)
    {
      min_fg(6);
      min_putstr("xx:xx:xx.xx");
      min_fg(-1);
    }

    else
    {
      char *panel_update_start$$1$$1$$2$$time;
      panel_update_start$$1$$1$$2$$time=make_time_string(p_st, 1);
      min_putstr(panel_update_start$$1$$1$$2$$time);
    }
    min_putchar(32);
    draw_playbar(playrow);
    signed int temp = force;
    force = 1;
    panel_update_current(p_cur);
    force = temp;
  }

}

// panel_update_trials
// file main.h line 79
extern void panel_update_trials(char *choices, char *correct, signed int n)
{
  _Bool tmp_if_expr$14;
  signed int return_value_memcmp$13;
  if(!(force == 0) || !(n == p_tn))
    tmp_if_expr$14 = (_Bool)1;

  else
  {
    return_value_memcmp$13=memcmp((const void *)p_tl, (const void *)choices, (unsigned long int)n);
    tmp_if_expr$14 = return_value_memcmp$13 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$14)
  {
    const signed long int panel_update_trials$array_size0 = (signed long int)((signed int)cur_term->type.Numbers[(signed long int)0] + 1);
    char panel_update_trials$$1$$1$$buf[panel_update_trials$array_size0];
    signed int i;
    p_tn = n;
    min_mvcur(1, boxrow + 1);
    sprintf(panel_update_trials$$1$$1$$buf, " %d/%d trials: ", p_tn, p_tmax);
    min_putstr(panel_update_trials$$1$$1$$buf);
    memcpy((void *)p_tl, (const void *)choices, (unsigned long int)n);
    memcpy((void *)p_tc, (const void *)correct, (unsigned long int)n);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(panel_update_trials$$1$$1$$buf);
    if(!((unsigned long int)*cur_term->type.Numbers + -return_value_strlen$2 + 18446744073709551613ul >= (unsigned long int)n))
    {
      min_fg(6);
      min_putstr("...");
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(panel_update_trials$$1$$1$$buf);
      i = (signed int)((unsigned long int)(n - (signed int)cur_term->type.Numbers[(signed long int)0]) + return_value_strlen$1 + (unsigned long int)6);
    }

    else
      i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      if(!(p_g == 0))
      {
        if((signed int)correct[(signed long int)i] == 0)
        {
          if(p_tm == 0)
            min_fg(5);

          else
            min_fg(1);
        }

        else
          if(p_tm == 0)
            min_fg(6);

          else
            min_fg(2);
      }

      if(!(p_tm >= 2))
        min_putchar((signed int)p_tl[(signed long int)i] + 65);

      else
        min_putchar((signed int)p_tl[(signed long int)i] + 49);
    }
    min_unset();
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(panel_update_trials$$1$$1$$buf);
    i = i + (signed int)return_value_strlen$3;
    for( ; !(i >= (signed int)*cur_term->type.Numbers + -2); i = i + 1)
      min_putchar(32);
    if(!(p_g == 0))
    {
      signed int count = 0;
      i = 0;
      for( ; !(i >= n); i = i + 1)
        count = count + (signed int)correct[(signed long int)i];
      min_mvcur(1, boxrow + 2);
      if(p_tm == 0)
      {
        signed int col = (signed int)cur_term->type.Numbers[(signed long int)0] - 4;
        signed int Ac;
        signed int Bc;
        char bufA[4096l];
        char bufB[4096l];
        char bufAn[10l];
        char bufBn[10l];
        char *Ap = bufA;
        char *Bp = bufB;
        double panel_update_trials$$1$$1$$5$$2$$p;
        panel_update_trials$$1$$1$$5$$2$$p=compute_pdual(count, n);
        snprintf(bufA, (unsigned long int)4096, "%s: ", pcm_p[(signed long int)0]->name);
        snprintf(bufB, (unsigned long int)4096, "%s: ", pcm_p[(signed long int)1]->name);
        snprintf(bufAn, (unsigned long int)10, "%d ", n - count);
        snprintf(bufBn, (unsigned long int)10, "%d ", count);
        if(n >= 2)
          sprintf(panel_update_trials$$1$$1$$buf, " p': %.2g ", (float)panel_update_trials$$1$$1$$5$$2$$p);

        else
          sprintf(panel_update_trials$$1$$1$$buf, " p': --- ");
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(panel_update_trials$$1$$1$$buf);
        col = col - (signed int)return_value_strlen$4;
        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen(bufA);
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(bufAn);
        Ac = (signed int)(return_value_strlen$5 + return_value_strlen$6);
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(bufB);
        unsigned long int return_value_strlen$8;
        return_value_strlen$8=strlen(bufBn);
        Bc = (signed int)(return_value_strlen$7 + return_value_strlen$8);
        if(!(col >= Ac + Bc))
        {
          if(col / 2 >= Ac)
          {
            unsigned long int return_value_strlen$9;
            return_value_strlen$9=strlen(bufBn);
            Bp=dottrim(bufB, (signed int)((unsigned long int)(col - Ac) - return_value_strlen$9));
          }

          else
            if(col / 2 >= Bc)
            {
              unsigned long int return_value_strlen$10;
              return_value_strlen$10=strlen(bufAn);
              Ap=dottrim(bufA, (signed int)((unsigned long int)(col - Bc) - return_value_strlen$10));
            }

            else
            {
              unsigned long int return_value_strlen$11;
              return_value_strlen$11=strlen(bufAn);
              Ap=dottrim(bufA, (signed int)((unsigned long int)(col / 2) - return_value_strlen$11));
              unsigned long int return_value_strlen$12;
              return_value_strlen$12=strlen(bufBn);
              Bp=dottrim(bufB, (signed int)((unsigned long int)(col - col / 2) - return_value_strlen$12));
            }
        }

        min_putchar(32);
        min_putstr(Ap);
        min_fg(5);
        min_putstr(bufAn);
        min_unset();
        min_putchar(32);
        min_putstr(Bp);
        min_fg(6);
        min_putstr(bufBn);
        min_unset();
        min_putstr(" p': ");
        if(panel_update_trials$$1$$1$$5$$2$$p < .01)
          min_fg(2);

        min_putstr(panel_update_trials$$1$$1$$buf + (signed long int)5);
      }

      else
      {
        double p;
        p=compute_psingle(count, n);
        sprintf(panel_update_trials$$1$$1$$buf, " Score: %d/%d  p': ", count, n);
        min_putstr(panel_update_trials$$1$$1$$buf);
        if(!(n == 0))
        {
          sprintf(panel_update_trials$$1$$1$$buf, "%.2g   ", (float)p);
          if(p < .01)
            min_fg(2);

        }

        else
        {
          min_fg(6);
          sprintf(panel_update_trials$$1$$1$$buf, "---    ");
        }
        min_putstr(panel_update_trials$$1$$1$$buf);
      }
    }

    min_unset();
  }

}

// parse_time
// file main.c line 172
static signed int parse_time(char *s, double *t)
{
  double secf;
  signed long int secl;
  const char *pos;
  char *end;
  signed int err = 0;
  secl = (signed long int)0;
  char *return_value___builtin_strchr$1;
  return_value___builtin_strchr$1=__builtin_strchr(optarg, 58);
  pos = return_value___builtin_strchr$1;
  if(!(pos == ((const char *)NULL)))
  {
    char *pos2;
    signed long int return_value_strtol$2;
    return_value_strtol$2=strtol(optarg, &end, 10);
    secl = return_value_strtol$2 * (signed long int)60;
    err = err | (signed int)(pos != end);
    pos = pos + 1l;
    char *return_value___builtin_strchr$3;
    return_value___builtin_strchr$3=__builtin_strchr(pos, 58);
    pos2 = return_value___builtin_strchr$3;
    if(!(pos2 == ((char *)NULL)))
    {
      signed long int return_value_strtol$4;
      return_value_strtol$4=strtol(pos, &end, 10);
      secl = (secl + return_value_strtol$4) * (signed long int)60;
      err = err | (signed int)(pos2 != end);
      pos = pos2 + (signed long int)1;
    }

  }

  else
    pos = optarg;
  secf=strtod(pos, &end);
  _Bool tmp_if_expr$5;
  if(!(err == 0))
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = (signed int)*end != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
    return -1;

  else
  {
    *t = (double)secl + secf;
    return 0;
  }
}

// playback_thread
// file main.c line 277
void * playback_thread(void *arg)
{
  struct anonymous$24 *s = (struct anonymous$24 *)arg;
  struct ao_device *adev = s->adev;
  pthread_mutex_lock(&s->mutex);
  while((_Bool)1)
  {
    if(!(s->exiting == 0))
      break;

    if(!(s->fragment_size == 0))
    {
      signed int ret;
      unsigned char *data = s->fragment;
      signed int n = s->fragment_size;
      pthread_mutex_unlock(&s->mutex);
      ret=ao_play(adev, (char *)(void *)data, (unsigned int)n);
      pthread_mutex_lock(&s->mutex);
      if(ret == 0)
        s->exiting = 1;

      s->fragment_size = 0;
      s->fragment = ((unsigned char *)NULL);
      pthread_cond_signal(&s->main_cond);
      if(!(s->exiting == 0))
        break;

    }

    pthread_cond_wait(&s->play_cond, &s->mutex);
  }
  pthread_mutex_unlock(&s->mutex);
  ao_close(adev);
  ao_shutdown();
  return (void *)0;
}

// print_into
// file tty.c line 74
void print_into(char *buf, signed int pos, char *s)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  len = (signed int)return_value_strlen$1;
  signed int len2;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(s);
  len2 = (signed int)return_value_strlen$2;
  signed int i = 0;
  for( ; !(i + pos >= len) && !(i >= len2); i = i + 1)
    buf[(signed long int)(i + pos)] = s[(signed long int)i];
}

// put_val
// file audio.c line 438
extern void put_val(unsigned char *d, signed int bps, float v)
{
  signed int i;
  double return_value_rint$1;
  return_value_rint$1=rint((double)v);
  i = (signed int)return_value_rint$1;
  d[(signed long int)0] = (unsigned char)(i & 0xff);
  d[(signed long int)1] = (unsigned char)(i >> 8 & 0xff);
  if(bps == 3)
    d[(signed long int)2] = (unsigned char)(i >> 16 & 0xff);

}

// randomize_samples
// file main.c line 204
void randomize_samples(signed int *r, signed int *cchoice, signed int test_mode)
{
  signed int return_value_randrange$1;
  signed int return_value_randrange$2;
  signed int tmp_if_expr$3;
  switch(test_mode)
  {
    case 1:
    {
      r[(signed long int)0] = 0;
      r[(signed long int)1] = 1;
      r[(signed long int)2]=randrange(2);
      *cchoice = r[(signed long int)1] == r[(signed long int)2] ? 1 : 0;
      break;
    }
    case 0:
    {
      r[(signed long int)0]=randrange(2);
      r[(signed long int)1] = 1 - r[(signed long int)0];
      *cchoice = 1;
      break;
    }
    case 2:
    {
      r[(signed long int)2] = 0;
      r[(signed long int)1] = r[(signed long int)2];
      r[(signed long int)0] = r[(signed long int)1];
      return_value_randrange$1=randrange(3);
      r[(signed long int)return_value_randrange$1] = 1;
      return_value_randrange$2=randrange(2);
      if(!(return_value_randrange$2 == 0))
      {
        r[(signed long int)0] = 1 - r[(signed long int)0];
        r[(signed long int)1] = 1 - r[(signed long int)1];
        r[(signed long int)2] = 1 - r[(signed long int)2];
      }

      if(*r == r[1l])
        tmp_if_expr$3 = 2;

      else
        tmp_if_expr$3 = r[(signed long int)1] == r[(signed long int)2] ? 0 : 1;
      *cchoice = r[(signed long int)tmp_if_expr$3];
    }
  }
}

// randrange
// file main.c line 200
signed int randrange(signed int range)
{
  signed int return_value_rand$1;
  return_value_rand$1=rand();
  double return_value_floor$2;
  return_value_floor$2=floor(((double)return_value_rand$1 / ((double)2147483647 + 1.0)) * (double)range);
  return (signed int)return_value_floor$2;
}

// read_IEEE80
// file loader.c line 460
static double read_IEEE80(unsigned char *buf)
{
  signed int s = (signed int)buf[(signed long int)0] & 0xff;
  signed int e = ((signed int)buf[(signed long int)0] & 0x7f) << 8 | (signed int)buf[(signed long int)1] & 0xff;
  double f = (double)((unsigned long int)((signed int)buf[(signed long int)2] & 0xff) << 24 | (unsigned long int)(((signed int)buf[(signed long int)3] & 0xff) << 16) | (unsigned long int)(((signed int)buf[(signed long int)4] & 0xff) << 8) | (unsigned long int)((signed int)buf[(signed long int)5] & 0xff));
  double return_value___builtin_huge_val$1;
  double return_value___builtin_huge_val$2;
  double return_value___builtin_huge_val$3;
  if(e == 32767)
  {
    if(!((0x80 & (signed int)buf[2l]) == 0))
    {
      return_value___builtin_huge_val$1=__builtin_huge_val();
      return return_value___builtin_huge_val$1;
    }

    else
      if(!(s == 0))
      {
        return_value___builtin_huge_val$2=__builtin_huge_val();
        return -return_value___builtin_huge_val$2;
      }

      else
      {
        return_value___builtin_huge_val$3=__builtin_huge_val();
        return return_value___builtin_huge_val$3;
      }
  }

  f=ldexp(f, 32);
  f = f + (double)(((signed int)buf[(signed long int)6] & 0xff) << 24 | ((signed int)buf[(signed long int)7] & 0xff) << 16 | ((signed int)buf[(signed long int)8] & 0xff) << 8 | (signed int)buf[(signed long int)9] & 0xff);
  double return_value_ldexp$4;
  return_value_ldexp$4=ldexp(f, e - 16446);
  return return_value_ldexp$4;
}

// read_callback
// file loader.c line 814
static enum anonymous$40 read_callback(const struct anonymous *decoder, unsigned char *buffer, unsigned long int *bytes, void *client_data)
{
  struct anonymous$48 *flac = (struct anonymous$48 *)client_data;
  struct pcm_struct *pcm = flac->pcm;
  signed int return_value_feof$2;
  return_value_feof$2=feof(flac->in);
  signed int return_value_ferror$1;
  if(!(return_value_feof$2 == 0))
  {
    *bytes = (unsigned long int)0;
    return (enum anonymous$40)FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
  }

  else
  {
    return_value_ferror$1=ferror(flac->in);
    if(!(return_value_ferror$1 == 0))
    {
      *bytes = (unsigned long int)0;
      return (enum anonymous$40)FLAC__STREAM_DECODER_READ_STATUS_ABORT;
    }

  }
  if(!(sb_verbose == 0))
    fprintf(stderr, "\rLoading %s: %ld to go...       ", flac->pcm->name, (signed long int)(pcm->size - flac->fill));

  *bytes=fread((void *)buffer, sizeof(unsigned char) /*1ul*/ , *bytes, flac->in);
  return (enum anonymous$40)FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
}

// reconcile_channel_maps
// file audio.c line 388
extern void reconcile_channel_maps(struct pcm_struct *A, struct pcm_struct *B)
{
  const signed long int reconcile_channel_maps$array_size0 = (signed long int)A->ch;
  const signed long int ai$array_size0 = (signed long int)A->ch;
  signed int ai[reconcile_channel_maps$array_size0];
  signed int bi[ai$array_size0];
  signed int i;
  signed int j;
  signed int k;
  signed long int o;
  signed int bps = (B->currentbits + 7) / 8;
  signed int bpf = B->ch * bps;
  const signed long int bpf$array_size0 = (signed long int)bpf;
  signed int p[bpf$array_size0];
  const signed long int p$array_size0 = (signed long int)bpf;
  unsigned char temp[p$array_size0];
  unsigned char *d;
  tokenize_channels(A->matrix, ai, A->ch);
  tokenize_channels(B->matrix, bi, A->ch);
  if(!(sb_verbose == 0))
  {
    fprintf(stderr, "remapping channels in %s: ", B->name);
    i = 0;
    for( ; !(i >= B->ch); i = i + 1)
      fprintf(stderr, "%d%s", bi[(signed long int)i], i + 1 == B->ch ? "" : ", ");
    fprintf(stderr, " -> ");
    i = 0;
    for( ; !(i >= A->ch); i = i + 1)
      fprintf(stderr, "%d%s", ai[(signed long int)i], i + 1 == A->ch ? "" : ", ");
    fprintf(stderr, "\n");
  }

  i = 0;
  for( ; !(i >= A->ch); i = i + 1)
  {
    k = 0;
    for( ; !(k >= bps); k = k + 1)
      p[(signed long int)(i * bps + k)] = i * bps + k;
    j = 0;
    for( ; !(j >= A->ch); j = j + 1)
      if(bi[(signed long int)i] == ai[(signed long int)j])
      {
        k = 0;
        for( ; !(k >= bps); k = k + 1)
          p[(signed long int)(i * bps + k)] = j * bps + k;
        break;
      }

  }
  d = B->data;
  o = (signed long int)0;
  for( ; !(o >= B->size); o = o + (signed long int)bpf)
  {
    i = 0;
    for( ; !(i >= bpf); i = i + 1)
      temp[(signed long int)p[(signed long int)i]] = d[(signed long int)i];
    memcpy((void *)d, (const void *)temp, (unsigned long int)bpf);
    d = d + (signed long int)bpf;
  }
  free((void *)B->matrix);
  char *return_value___strdup$1;
  return_value___strdup$1=__strdup(A->matrix);
  B->matrix = return_value___strdup$1;
}

// reset
// file mincurses.c line 595
static signed int reset()
{
  signed int ret = 0;
  signed int return_value_setgfx$1;
  if(!(acs == 0))
  {
    return_value_setgfx$1=setgfx();
    ret = ret | return_value_setgfx$1;
  }

  signed int return_value_setfg$2;
  if(fg >= 0)
  {
    return_value_setfg$2=setfg(fg);
    ret = ret | return_value_setfg$2;
  }

  signed int return_value_setbg$3;
  if(bg >= 0)
  {
    return_value_setbg$3=setbg(bg);
    ret = ret | return_value_setbg$3;
  }

  signed int return_value_setbold$4;
  if(!(bold == 0))
  {
    return_value_setbold$4=setbold();
    ret = ret | return_value_setbold$4;
  }

  signed int return_value_setblink$5;
  if(!(blink == 0))
  {
    return_value_setblink$5=setblink();
    ret = ret | return_value_setblink$5;
  }

  signed int return_value_setreverse$6;
  if(!(rev == 0))
  {
    return_value_setreverse$6=setreverse();
    ret = ret | return_value_setreverse$6;
  }

  signed int return_value_setunderline$7;
  if(!(ul == 0))
  {
    return_value_setunderline$7=setunderline();
    ret = ret | return_value_setunderline$7;
  }

  return ret;
}

// setbg
// file mincurses.c line 541
static signed int setbg(signed int c)
{
  if(!(cur_term->type.Strings[360l] == ((char *)NULL)))
  {
    bg = c;
    char *return_value_tparm$1;
    return_value_tparm$1=tparm(cur_term->type.Strings[(signed long int)360], c);
    min_putp(return_value_tparm$1);
    return 0;
  }

  return 1;
}

// setblink
// file mincurses.c line 559
static signed int setblink(void)
{
  if(!(cur_term->type.Strings[26l] == ((char *)NULL)))
  {
    min_putp(cur_term->type.Strings[(signed long int)26]);
    blink = 1;
    return 0;
  }

  else
    return 1;
}

// setbold
// file mincurses.c line 550
static signed int setbold(void)
{
  if(!(cur_term->type.Strings[27l] == ((char *)NULL)))
  {
    min_putp(cur_term->type.Strings[(signed long int)27]);
    bold = 1;
    return 0;
  }

  else
    return 1;
}

// setfg
// file mincurses.c line 532
static signed int setfg(signed int c)
{
  if(!(cur_term->type.Strings[359l] == ((char *)NULL)))
  {
    fg = c;
    char *return_value_tparm$1;
    return_value_tparm$1=tparm(cur_term->type.Strings[(signed long int)359], c);
    min_putp(return_value_tparm$1);
    return 0;
  }

  return 1;
}

// setgfx
// file mincurses.c line 577
static signed int setgfx(void)
{
  if(!(cur_term->type.Strings[25l] == ((char *)NULL)))
  {
    acs = 1;
    min_putp(cur_term->type.Strings[(signed long int)25]);
    return 0;
  }

  else
    return 1;
}

// setreverse
// file mincurses.c line 586
static signed int setreverse(void)
{
  if(!(cur_term->type.Strings[34l] == ((char *)NULL)))
  {
    min_putp(cur_term->type.Strings[(signed long int)34]);
    rev = 1;
    return 0;
  }

  else
    return 1;
}

// setunderline
// file mincurses.c line 568
static signed int setunderline(void)
{
  if(!(cur_term->type.Strings[36l] == ((char *)NULL)))
  {
    ul = 1;
    min_putp(cur_term->type.Strings[(signed long int)36]);
    return 0;
  }

  else
    return 1;
}

// setup_playback
// file audio.c line 711
extern struct ao_device * setup_playback(signed int rate, signed int ch, signed int bits, char *matrix, char *device)
{
  struct ao_option aoe = { .key=((char *)NULL), .value=((char *)NULL), .next=((struct ao_option *)NULL) };
  struct ao_device *ret = (struct ao_device *)(void *)0;
  struct ao_sample_format sf;
  char *aname = "";
  sf.rate = rate;
  sf.channels = ch;
  sf.bits = bits;
  sf.byte_format = 1;
  sf.matrix = ch > 2 ? matrix : ((char *)NULL);
  aoe.key = "quiet";
  _Bool tmp_if_expr$3;
  char *tmp_if_expr$4;
  signed int tmp_statement_expression$5;
  signed int *return_value___errno_location$7;
  if(device == ((char *)NULL))
  {
    signed int setup_playback$$1$$1$$id;
    setup_playback$$1$$1$$id=ao_default_driver_id();
    struct ao_info *ai;
    if(!(setup_playback$$1$$1$$id >= 0))
      return (struct ao_device *)(void *)0;

    ai=ao_driver_info(setup_playback$$1$$1$$id);
    if(ai == ((struct ao_info *)NULL))
      return (struct ao_device *)(void *)0;

    aname = ai->short_name;
    if(!(sb_verbose == 0))
      fprintf(stderr, "Opening [%s] %s for %d/%d and %d channel[s]...", aname, (const void *)"default", bits, rate, ch);

    ret=ao_open_live(setup_playback$$1$$1$$id, &sf, &aoe);
    if(!(sb_verbose == 0))
    {
      if(ret == ((struct ao_device *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        fprintf(stderr, " errno %d\n", *return_value___errno_location$1);
      }

      else
        fprintf(stderr, " ok!\n");
    }

  }

  else
  {
    char *test;
    signed int count;
    struct ao_info **info_list;
    info_list=ao_driver_info_list(&count);
    signed int number;
    signed long int return_value_strtol$2;
    return_value_strtol$2=strtol(device, &test, 10);
    number = (signed int)return_value_strtol$2;
    signed int i;
    if(*device == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = test[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      number = -1;

    if(!(sb_verbose == 0))
      fprintf(stderr, "Scanning for a device driver that recognizes '%s'...\n", device);

    i = 0;
    for( ; !(i >= count); i = i + 1)
    {
      signed int j;
      struct ao_info *info = info_list[(signed long int)i];
      struct ao_option ao = { .key=((char *)NULL), .value=((char *)NULL), .next=((struct ao_option *)NULL) };
      signed int id;
      id=ao_driver_id(info->short_name);
      char setup_playback$$1$$2$$1$$1$$buf[80l];
      sprintf(setup_playback$$1$$2$$1$$1$$buf, "%d", number);
      ao.key = number >= 0 ? "id" : "dev";
      if(number >= 0)
        tmp_if_expr$4 = setup_playback$$1$$2$$1$$1$$buf;

      else
        tmp_if_expr$4 = device;
      ao.value = tmp_if_expr$4;
      ao.next = &aoe;
      aname = info->short_name;
      j = 0;
      for( ; !(j >= info->option_count); j = j + 1)
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$6;
        return_value___builtin_strcmp$6=__builtin_strcmp(info->options[(signed long int)j], ao.key);
        tmp_statement_expression$5 = return_value___builtin_strcmp$6;
        if(tmp_statement_expression$5 == 0)
          break;

      }
      if(!(j >= info->option_count))
      {
        if(!(sb_verbose == 0))
          fprintf(stderr, "  ...trying to open [%s] %s for %d/%d and %d channel[s]...", aname, device, bits, rate, ch);

        ret=ao_open_live(id, &sf, &ao);
        if(!(ret == ((struct ao_device *)NULL)))
        {
          if(!(sb_verbose == 0))
            fprintf(stderr, " ok!\n");

          break;
        }

        if(!(sb_verbose == 0))
        {
          return_value___errno_location$7=__errno_location();
          fprintf(stderr, " errno %d\n", *return_value___errno_location$7);
        }

      }

    }
  }
  if(!(ret == ((struct ao_device *)NULL)) && !(sb_verbose == 0))
    fprintf(stderr, "Opened %s%s audio device %s%sfor %d bit %d channel %d Hz...\n", device != ((char *)NULL) ? "" : "default ", aname, device != ((char *)NULL) ? device : "", device != ((char *)NULL) ? " " : "", bits, ch, rate);

  return ret;
}

// setup_term_customize
// file mincurses.c line 343
static void setup_term_customize(void)
{
  if(!(cur_term == ((struct term *)NULL)))
  {
    term = cur_term->Nttyb;
    term.c_lflag = term.c_lflag & (unsigned int)~0000002;
    term.c_iflag = term.c_iflag & (unsigned int)~0000400;
    term.c_lflag = term.c_lflag & (unsigned int)~(0000010 | 0000100);
    term.c_iflag = term.c_iflag & (unsigned int)~(0000400 | 0000100 | 0000200);
    term.c_oflag = term.c_oflag & (unsigned int)~0000004;
    term.c_lflag = term.c_lflag & (unsigned int)~0000001;
    term.c_cc[(signed long int)6] = (unsigned char)1;
    term.c_cc[(signed long int)5] = (unsigned char)0;
    tcsetattr(outfd, 1, &term);
    cur_term->Nttyb = term;
  }

}

// setup_windows
// file audio.c line 456
extern signed int setup_windows(struct pcm_struct **pcm, signed int test_files, float **fw1, float **fw2, float **fw3, float **b1, float **b2)
{
  signed int i;
  signed int fragsamples = pcm[(signed long int)0]->rate / 10;
  float mul = (float)((double)(pcm[(signed long int)0]->currentbits == 24 ? 8388608.f : 32768.f) * .0625);
  signed int bps = (pcm[(signed long int)0]->currentbits + 7) / 8;
  signed int ch = pcm[(signed long int)0]->ch;
  signed int bpf = ch * bps;
  signed int maxsamples = (signed int)(pcm[(signed long int)0]->size / (signed long int)bpf);
  if(!(maxsamples >= 3 * fragsamples))
    fragsamples = maxsamples / 3;

  float *fadewindow1;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)fragsamples, sizeof(float) /*4ul*/ );
  *fw1 = (float *)return_value_calloc$1;
  fadewindow1 = *fw1;
  float *fadewindow2;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)fragsamples, sizeof(float) /*4ul*/ );
  *fw2 = (float *)return_value_calloc$2;
  fadewindow2 = *fw2;
  float *fadewindow3;
  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)fragsamples, sizeof(float) /*4ul*/ );
  *fw3 = (float *)return_value_calloc$3;
  fadewindow3 = *fw3;
  float *beep1;
  void *return_value_calloc$4;
  return_value_calloc$4=calloc((unsigned long int)fragsamples, sizeof(float) /*4ul*/ );
  *b1 = (float *)return_value_calloc$4;
  beep1 = *b1;
  float *beep2;
  void *return_value_calloc$5;
  return_value_calloc$5=calloc((unsigned long int)fragsamples, sizeof(float) /*4ul*/ );
  *b2 = (float *)return_value_calloc$5;
  beep2 = *b2;
  if(beep1 == ((float *)NULL) || beep2 == ((float *)NULL) || fadewindow1 == ((float *)NULL) || fadewindow2 == ((float *)NULL) || fadewindow3 == ((float *)NULL))
    exit(9);

  i = 0;
  for( ; !(i >= fragsamples); i = i + 1)
  {
    float val;
    val=cosf((float)((3.14159265358979323846 * (double).5f * (double)((float)i + .5f)) / (double)fragsamples));
    fadewindow1[(signed long int)i] = val * val;
  }
  i = 0;
  for( ; !(i >= fragsamples / 3); i = i + 1)
  {
    float setup_windows$$1$$2$$1$$val;
    setup_windows$$1$$2$$1$$val=cosf((float)((3.14159265358979323846 * (double)1.5f * (double)((float)i + .5f)) / (double)fragsamples));
    fadewindow2[(signed long int)i] = setup_windows$$1$$2$$1$$val * setup_windows$$1$$2$$1$$val;
  }
  for( ; !(i >= fragsamples); i = i + 1)
    fadewindow2[(signed long int)i] = 0.f;
  i = 0;
  for( ; !(i >= fragsamples / 2); i = i + 1)
  {
    float setup_windows$$1$$4$$1$$val;
    setup_windows$$1$$4$$1$$val=cosf((float)((3.14159265358979323846 * (double)((float)i + .5f)) / (double)fragsamples));
    fadewindow3[(signed long int)i] = setup_windows$$1$$4$$1$$val * setup_windows$$1$$4$$1$$val;
  }
  for( ; !(i >= fragsamples); i = i + 1)
    fadewindow3[(signed long int)i] = 0.f;
  i = 0;
  for( ; !(i >= fragsamples / 4); i = i + 1)
  {
    beep1[(signed long int)i] = 0.f;
    beep1[(signed long int)((fragsamples - i) - 1)] = 0.f;
  }
  float base = (float)(((double)(3.14159f * 2.f) * 1000.) / (double)pcm[(signed long int)0]->rate);
  for( ; !(i >= (3 * fragsamples) / 4); i = i + 1)
  {
    float f = (float)(i - fragsamples / 4) + .5f;
    float w;
    w=cosf((3.14159f * f) / (float)fragsamples);
    float b;
    float return_value_sinf$6;
    return_value_sinf$6=sinf(f * base);
    float return_value_sinf$7;
    return_value_sinf$7=sinf(f * base * (float)3);
    float return_value_sinf$8;
    return_value_sinf$8=sinf(f * base * (float)5);
    float return_value_sinf$9;
    return_value_sinf$9=sinf(f * base * (float)7);
    float return_value_sinf$10;
    return_value_sinf$10=sinf(f * base * (float)9);
    b = return_value_sinf$6 + return_value_sinf$7 * .33f + return_value_sinf$8 * .2f + return_value_sinf$9 * .14f + return_value_sinf$10 * .11f;
    w = w * w;
    beep1[(signed long int)i] = w * b * mul;
  }
  i = 0;
  for( ; !(i >= fragsamples / 4); i = i + 1)
  {
    beep2[(signed long int)i] = 0.f;
    beep2[(signed long int)((fragsamples - i) - 1)] = 0.f;
  }
  for( ; !(i >= fragsamples / 2); i = i + 1)
  {
    float setup_windows$$1$$9$$1$$f = (float)(i - fragsamples / 4) + .5f;
    float setup_windows$$1$$9$$1$$w;
    setup_windows$$1$$9$$1$$w=cosf((3.14159f * 2.f * setup_windows$$1$$9$$1$$f) / (float)fragsamples);
    float setup_windows$$1$$9$$1$$b;
    float return_value_sinf$11;
    return_value_sinf$11=sinf(setup_windows$$1$$9$$1$$f * base);
    float return_value_sinf$12;
    return_value_sinf$12=sinf(setup_windows$$1$$9$$1$$f * base * (float)3);
    float return_value_sinf$13;
    return_value_sinf$13=sinf(setup_windows$$1$$9$$1$$f * base * (float)5);
    float return_value_sinf$14;
    return_value_sinf$14=sinf(setup_windows$$1$$9$$1$$f * base * (float)7);
    float return_value_sinf$15;
    return_value_sinf$15=sinf(setup_windows$$1$$9$$1$$f * base * (float)9);
    setup_windows$$1$$9$$1$$b = return_value_sinf$11 + return_value_sinf$12 * .33f + return_value_sinf$13 * .2f + return_value_sinf$14 * .14f + return_value_sinf$15 * .11f;
    setup_windows$$1$$9$$1$$w = setup_windows$$1$$9$$1$$w * setup_windows$$1$$9$$1$$w;
    beep2[(signed long int)i] = setup_windows$$1$$9$$1$$w * setup_windows$$1$$9$$1$$b * mul;
  }
  base = (float)(((double)(3.14159f * 2.f) * 1500.) / (double)pcm[(signed long int)0]->rate);
  for( ; !(i >= (3 * fragsamples) / 4); i = i + 1)
  {
    float setup_windows$$1$$10$$1$$f = (float)(i - fragsamples / 2) + .5f;
    float setup_windows$$1$$10$$1$$w;
    setup_windows$$1$$10$$1$$w=cosf((3.14159f * 2.f * setup_windows$$1$$10$$1$$f) / (float)fragsamples);
    float setup_windows$$1$$10$$1$$b;
    float return_value_sinf$16;
    return_value_sinf$16=sinf(setup_windows$$1$$10$$1$$f * base);
    float return_value_sinf$17;
    return_value_sinf$17=sinf(setup_windows$$1$$10$$1$$f * base * (float)3);
    float return_value_sinf$18;
    return_value_sinf$18=sinf(setup_windows$$1$$10$$1$$f * base * (float)5);
    float return_value_sinf$19;
    return_value_sinf$19=sinf(setup_windows$$1$$10$$1$$f * base * (float)7);
    float return_value_sinf$20;
    return_value_sinf$20=sinf(setup_windows$$1$$10$$1$$f * base * (float)9);
    setup_windows$$1$$10$$1$$b = return_value_sinf$16 + return_value_sinf$17 * .33f + return_value_sinf$18 * .2f + return_value_sinf$19 * .14f + return_value_sinf$20 * .11f;
    setup_windows$$1$$10$$1$$w = setup_windows$$1$$10$$1$$w * setup_windows$$1$$10$$1$$w;
    beep2[(signed long int)i] = setup_windows$$1$$10$$1$$w * setup_windows$$1$$10$$1$$b * mul * (float)2;
  }
  return fragsamples;
}

// sw_id
// file loader.c line 124
static signed int sw_id(char *path, unsigned char *buf)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(path);
  signed int return_value_memcmp$2;
  return_value_memcmp$2=memcmp((const void *)((path + (signed long int)return_value_strlen$1) - (signed long int)3), (const void *)".sw", (unsigned long int)3);
  return (signed int)(return_value_memcmp$2 == 0);
}

// sw_load
// file loader.c line 742
static struct pcm_struct * sw_load(char *path, struct _IO_FILE *in)
{
  struct pcm_struct *pcm;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct pcm_struct) /*56ul*/ );
  pcm = (struct pcm_struct *)return_value_calloc$1;
  char *return_value_trim_path$2;
  return_value_trim_path$2=trim_path(path);
  char *return_value___strdup$3;
  return_value___strdup$3=__strdup(return_value_trim_path$2);
  pcm->name = return_value___strdup$3;
  pcm->nativebits = 16;
  pcm->currentbits = -32;
  pcm->ch = 1;
  pcm->rate = 48000;
  char *return_value___strdup$4;
  return_value___strdup$4=__strdup("M");
  pcm->matrix = return_value___strdup$4;
  char *return_value___strdup$5;
  return_value___strdup$5=__strdup("A");
  pcm->mix = return_value___strdup$5;
  signed int return_value_fseek$6;
  return_value_fseek$6=fseek(in, (signed long int)0, 2);
  _Bool tmp_if_expr$8;
  signed int return_value_fseek$7;
  void *return_value_calloc$9;
  signed long int tmp_if_expr$10;
  if(return_value_fseek$6 == -1)
    fprintf(stderr, "%s: Failed to seek\n", path);

  else
  {
    pcm->size=ftell(in);
    if(pcm->size == -1l)
      tmp_if_expr$8 = (_Bool)1;

    else
    {
      return_value_fseek$7=fseek(in, (signed long int)0, 0);
      tmp_if_expr$8 = return_value_fseek$7 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$8)
      fprintf(stderr, "%s: Failed to seek\n", path);

    else
    {
      return_value_calloc$9=calloc((unsigned long int)1, (unsigned long int)(pcm->size / (signed long int)2) * sizeof(float) /*4ul*/ );
      pcm->data = (unsigned char *)return_value_calloc$9;
      if(pcm->data == ((unsigned char *)NULL))
        fprintf(stderr, "Unable to allocate enough memory to load sample into memory\n");

      else
      {
        signed long int j = (signed long int)0;
        signed short int *d = (signed short int *)pcm->data;
        float *f = (float *)pcm->data;
        while(!(j >= pcm->size))
        {
          signed long int bytes;
          if(pcm->size + -j >= 65537l)
            tmp_if_expr$10 = (signed long int)65536;

          else
            tmp_if_expr$10 = pcm->size - j;
          bytes = tmp_if_expr$10;
          if(!(sb_verbose == 0))
            fprintf(stderr, "\rLoading %s: %ld to go...       ", pcm->name, (signed long int)(pcm->size - j));

          unsigned long int return_value_fread$11;
          return_value_fread$11=fread((void *)(pcm->data + j), (unsigned long int)1, (unsigned long int)bytes, in);
          bytes = (signed long int)return_value_fread$11;
          j = j + bytes;
          if(bytes == 0l)
            break;

        }
        if(!(j >= pcm->size))
        {
          if(!(sb_verbose == 0))
            fprintf(stderr, "\r%s: File ended before declared length (%ld < %ld); continuing...\n", path, (signed long int)j, (signed long int)pcm->size);

          pcm->size = j;
        }

        if(!(sb_verbose == 0))
          fprintf(stderr, "\rLoading %s: parsing...      ", pcm->name);

        j = pcm->size / (signed long int)2 - (signed long int)1;
        for( ; j >= 0l; j = j - 1l)
          f[j] = (float)((double)d[j] / 32768.);
        pcm->size = (signed long int)((unsigned long int)(pcm->size / (signed long int)2) * sizeof(float) /*4ul*/ );
        if(!(sb_verbose == 0))
          fprintf(stderr, "\rLoading %s: loaded.         ", pcm->name);

        return pcm;
      }
    }
  }

err:
  ;
  free_pcm(pcm);
  return (struct pcm_struct *)(void *)0;
}

// tokenize_channels
// file audio.c line 366
static void tokenize_channels(char *matrix, signed int *out, signed int n)
{
  signed int i = 0;
  char *copy;
  char *return_value___strdup$1;
  return_value___strdup$1=__strdup(matrix);
  copy = return_value___strdup$1;
  char *t;
  t=strtok(copy, ",");
  memset((void *)out, 0, sizeof(signed int) /*4ul*/  * (unsigned long int)n);
  signed int tmp_statement_expression$2;
  while(!(t == ((char *)NULL)))
  {
    signed int j = 0;
    for( ; !(chlist[(signed long int)j] == ((const char *)NULL)); j = j + 1)
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$3;
      return_value___builtin_strcmp$3=__builtin_strcmp(chlist[(signed long int)j], t);
      tmp_statement_expression$2 = return_value___builtin_strcmp$3;
      if(tmp_statement_expression$2 == 0)
        break;

    }
    out[(signed long int)i] = j;
    i = i + 1;
    t=strtok((char *)(void *)0, ",");
  }
  free((void *)copy);
}

// triangle_ditherval
// file audio.c line 265
static inline float triangle_ditherval(float *save)
{
  float r;
  signed int return_value_rand$1;
  return_value_rand$1=rand();
  r = (float)return_value_rand$1 / (float)2147483647 - .5f;
  float ret = *save - r;
  *save = r;
  return ret;
}

// trim_path
// file loader.c line 49
static char * trim_path(char *in)
{
  if(!(in == ((char *)NULL)))
  {
    char *a;
    a=strrchr(in, 47);
    char *b;
    b=strrchr(in, 92);
    char *c;
    c=strrchr(in, 58);
    signed int posa = (signed int)(a != ((char *)NULL) ? (a - in) + (signed long int)1 : (signed long int)0);
    signed int posb = (signed int)(b != ((char *)NULL) ? (b - in) + (signed long int)1 : (signed long int)0);
    signed int posc = (signed int)(c != ((char *)NULL) ? (c - in) + (signed long int)1 : (signed long int)0);
    if(!(posa >= posb))
      posa = posb;

    if(!(posa >= posc))
      posa = posc;

    return in + (signed long int)posa;
  }

  return (char *)(void *)0;
}

// unset
// file mincurses.c line 506
static signed int unset()
{
  signed int ret = 0;
  if(!(cur_term->type.Strings[38l] == ((char *)NULL)))
    min_putp(cur_term->type.Strings[(signed long int)38]);

  else
    ret = ret | 1;
  if(!(cur_term->type.Strings[39l] == ((char *)NULL)))
  {
    min_putp(cur_term->type.Strings[(signed long int)39]);
    min_putp(cur_term->type.Strings[(signed long int)38]);
    return ret;
  }

  else
    return 1;
}

// usage
// file main.c line 83
void usage(struct _IO_FILE *out)
{
  fprintf(out, "\nXiph Squishyball %s\nperform sample comparison testing on the command line\n\nUSAGE:\n  squishyball [options] fileA [fileB [fileN...]] [> results.txt]\n\nOPTIONS:\n  -a --ab                : Perform A/B test\n  -b --abx               : Perform A/B/X test\n  -B --beep-flip         : Mark transitions between samples with\n                           a short beep\n  -c --casual            : casual mode; load up to ten\n                           samples for non-randomized\n                           comparison without trials (default).\n  -d --device <N|dev>    : If a number, output to Nth\n                           sound device.  If a device name,\n                           use output driver/device matching\n                           that device name.\n  -D --force-dither      : Always use dither when converting\n                           to 16-bit for playback on output\n                           devices that do not support 24-bit\n                           playback. Currently only affects\n                           Vorbis and Opus playback; all other\n                           files are dithered by default during\n                           down-conversion.\n  -e --end-time <time>   : Set sample end time for playback\n  -g --gabbagabbahey     : Display a running trials score along\n                           with indicating if each trial choice\n                           was correct or incorrect.  Disables\n                           undo/redo.\n  -h --help              : Print this usage information.\n  -M --mark-flip         : Mark transitions between samples with\n                           a short period of silence\n  -n --trials <n>        : Set desired number of trials\n                           (default: 20)\n  -N --do-not-normalize  : Do not autonormalize samples to avoid\n                           clipping\n  -r --restart-after     : Restart playback from sample start\n                           after every trial.\n  -R --restart-every     : Restart playback from sample start\n                           after every 'flip' as well as after\n                           every trial.\n  -s --start-time <time> : Set start time within sample for\n                           playback\n  -S --seamless-flip     : Do not mark transitions between samples;\n                           flip with a seamless crossfade (default)\n  -t --force-truncate    : Always truncate (never dither) when\n                           down-converting samples to 16-bit for\n                           playback.\n  -v --verbose           : Produce more progress information.\n  -V --version           : Print version and exit.\n  -x --xxy               : Perform X/X/Y (triangle) test.\n  -1 --downmix-to-mono   : Downmix surround samples to mono.\n  -2 --downmix-to-stereo : Downmix surround samples to stereo.\n\nINTERACTION:\n    a b x    : Switch playback between A, B [and X] samples.\n     A B     : Choose A or B sample for A/B[/X] trial result.\n   1 2 3...  : Switch between first, second, etc samples.\n    ! @ #    : Choose sample 1, 2, or 3 for X/X/Y trial result.\n   + -, or   : Undo/redo last trial result selection.\n <ins> <del>\n   <enter>   : Choose current sample for this trial\n    <- ->    : Seek back/forward two seconds, +shift for 10 seconds\n  <up/down>  : Select sample from list (casual mode)\n   <space>   : Pause/resume playback\n  <backspc>  : Reset playback to start point\n      e      : set end playback point to current playback time.\n      E      : reset end playback time to end of sample\n      f      : Cycle through beep-flip/mark-flip/seamless-flip modes.\n      r      : Cycle through restart-after/restart-every/no-restart.\n      s      : set start playback point to current playback time.\n      S      : reset start playback time to 0:00:00.00\n      ?      : Print this keymap\n     ^-c     : Quit\n\nSUPPORTED FILE TYPES:\n  WAV and WAVEX    : 8-, 16-, 24-bit linear integer PCM (format 1)\n                     32 bit float (format 3)\n  AIFF and AIFC    : 8-, 16-, 24-bit linear integer PCM or\n                     32-bit floating point PCM\n  FLAC and OggFLAC : 16- and 24-bit\n  SW               : mono signed 16-bit little endian raw\n  OggVorbis        : all Vorbis I files\n  OggOpus          : all Opus files\n\n", (const void *)"20140211");
}

// vorbis_id
// file loader.c line 114
static signed int vorbis_id(char *path, unsigned char *buf)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)buf, (const void *)"OggS", (unsigned long int)4);
  _Bool tmp_if_expr$3;
  signed int return_value_memcmp$2;
  if(return_value_memcmp$1 == 0)
  {
    return_value_memcmp$2=memcmp((const void *)(buf + (signed long int)28), (const void *)"\001vorbis", (unsigned long int)7);
    tmp_if_expr$3 = return_value_memcmp$2 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return (signed int)tmp_if_expr$3;
}

// vorbis_load
// file loader.c line 1031
static struct pcm_struct * vorbis_load(char *path, struct _IO_FILE *in)
{
  struct OggVorbis_File vf;
  struct vorbis_info *vi = (struct vorbis_info *)(void *)0;
  struct pcm_struct *pcm = (struct pcm_struct *)(void *)0;
  signed long int vorbis_load$$1$$fill = (signed long int)0;
  signed int throttle = 0;
  signed int last_section = -1;
  memset((void *)&vf, 0, sizeof(struct OggVorbis_File) /*944ul*/ );
  signed int return_value_fseek$1;
  return_value_fseek$1=fseek(in, (signed long int)0, 0);
  signed int return_value_ov_open_callbacks$2;
  void *return_value_calloc$3;
  char *return_value_trim_path$4;
  char *return_value___strdup$5;
  signed long int return_value_ov_pcm_total$6;
  void *return_value_calloc$7;
  char *return_value___strdup$8;
  char *return_value___strdup$9;
  char *return_value___strdup$10;
  char *return_value___strdup$11;
  char *return_value___strdup$12;
  char *return_value___strdup$13;
  char *return_value___strdup$14;
  char *return_value___strdup$15;
  char *return_value___strdup$16;
  char *return_value___strdup$17;
  char *return_value___strdup$18;
  char *return_value___strdup$19;
  char *return_value___strdup$20;
  char *return_value___strdup$21;
  char *return_value___strdup$22;
  char *return_value___strdup$23;
  _Bool tmp_if_expr$24;
  signed long int tmp_post$25;
  if(return_value_fseek$1 == -1)
    fprintf(stderr, "%s: Failed to seek\n", path);

  else
  {
    return_value_ov_open_callbacks$2=ov_open_callbacks((void *)in, &vf, (const char *)(void *)0, (signed long int)0, OV_CALLBACKS_NOCLOSE);
    if(!(return_value_ov_open_callbacks$2 >= 0))
      fprintf(stderr, "Input does not appear to be an Ogg bitstream.\n");

    else
    {
      vi=ov_info(&vf, -1);
      return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct pcm_struct) /*56ul*/ );
      pcm = (struct pcm_struct *)return_value_calloc$3;
      return_value_trim_path$4=trim_path(path);
      return_value___strdup$5=__strdup(return_value_trim_path$4);
      pcm->name = return_value___strdup$5;
      pcm->nativebits = -32;
      pcm->currentbits = -32;
      pcm->ch = vi->channels;
      pcm->rate = (signed int)vi->rate;
      return_value_ov_pcm_total$6=ov_pcm_total(&vf, -1);
      pcm->size = (signed long int)((unsigned long int)(return_value_ov_pcm_total$6 * (signed long int)vi->channels) * sizeof(float) /*4ul*/ );
      return_value_calloc$7=calloc((unsigned long int)pcm->size, (unsigned long int)1);
      pcm->data = (unsigned char *)return_value_calloc$7;
      switch(pcm->ch)
      {
        case 1:
        {
          return_value___strdup$8=__strdup("M");
          pcm->matrix = return_value___strdup$8;
          return_value___strdup$9=__strdup("A");
          pcm->mix = return_value___strdup$9;
          break;
        }
        case 2:
        {
          return_value___strdup$10=__strdup("L,R");
          pcm->matrix = return_value___strdup$10;
          return_value___strdup$11=__strdup("BC");
          pcm->mix = return_value___strdup$11;
          break;
        }
        case 3:
        {
          return_value___strdup$12=__strdup("L,C,R");
          pcm->matrix = return_value___strdup$12;
          return_value___strdup$13=__strdup("BDC");
          pcm->mix = return_value___strdup$13;
          break;
        }
        case 4:
        {
          return_value___strdup$14=__strdup("L,R,BL,BR");
          pcm->matrix = return_value___strdup$14;
          return_value___strdup$15=__strdup("BCFG");
          pcm->mix = return_value___strdup$15;
          break;
        }
        case 5:
        {
          return_value___strdup$16=__strdup("L,C,R,BL,BR");
          pcm->matrix = return_value___strdup$16;
          return_value___strdup$17=__strdup("BDCFG");
          pcm->mix = return_value___strdup$17;
          break;
        }
        case 6:
        {
          return_value___strdup$18=__strdup("L,C,R,BL,BR,LFE");
          pcm->matrix = return_value___strdup$18;
          return_value___strdup$19=__strdup("BDCFGE");
          pcm->mix = return_value___strdup$19;
          break;
        }
        case 7:
        {
          return_value___strdup$20=__strdup("L,C,R,SL,SR,BC,LFE");
          pcm->matrix = return_value___strdup$20;
          return_value___strdup$21=__strdup("BDCKLJE");
          pcm->mix = return_value___strdup$21;
          break;
        }
        default:
        {
          return_value___strdup$22=__strdup("L,C,R,SL,SR,BL,BR,LFE");
          pcm->matrix = return_value___strdup$22;
          return_value___strdup$23=__strdup("BDCKLFGE");
          pcm->mix = return_value___strdup$23;
        }
      }
      while(!(sizeof(float) /*4ul*/  * (unsigned long int)vorbis_load$$1$$fill >= (unsigned long int)pcm->size))
      {
        signed int current_section;
        signed int i;
        signed int j;
        float **pcmout;
        signed long int ret;
        ret=ov_read_float(&vf, &pcmout, 4096, &current_section);
        float *d = (float *)pcm->data;
        if(!(current_section == last_section))
        {
          last_section = current_section;
          vi=ov_info(&vf, -1);
          if(!(vi->channels == pcm->ch))
            tmp_if_expr$24 = (_Bool)1;

          else
            tmp_if_expr$24 = vi->rate != (signed long int)pcm->rate ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$24)
          {
            fprintf(stderr, "%s: Chained file changes channel count/sample rate\n", path);
            goto err;
          }

        }

        if(!(ret >= 0l))
        {
          fprintf(stderr, "%s: Error while decoding file\n", path);
          goto err;
        }

        if(ret == 0l)
        {
          fprintf(stderr, "%s: Audio data ended prematurely\n", path);
          goto err;
        }

        i = 0;
        for( ; !((signed long int)i >= ret); i = i + 1)
        {
          j = 0;
          for( ; !(j >= pcm->ch); j = j + 1)
          {
            tmp_post$25 = vorbis_load$$1$$fill;
            vorbis_load$$1$$fill = vorbis_load$$1$$fill + 1l;
            d[tmp_post$25] = pcmout[(signed long int)j][(signed long int)i];
          }
        }
        if((0x3f & throttle) == 0 && !(sb_verbose == 0))
          fprintf(stderr, "\rLoading %s: %ld to go...       ", pcm->name, (signed long int)((unsigned long int)pcm->size - (unsigned long int)vorbis_load$$1$$fill * sizeof(float) /*4ul*/ ));

        throttle = throttle + 1;
      }
      ov_clear(&vf);
      if(!(sb_verbose == 0))
        fprintf(stderr, "\rLoading %s: loaded.         ", pcm->name);

      return pcm;
    }
  }

err:
  ;
  ov_clear(&vf);
  free_pcm(pcm);
  return (struct pcm_struct *)(void *)0;
}

// wav_id
// file loader.c line 86
static signed int wav_id(char *path, unsigned char *buf)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)buf, (const void *)"RIFF", (unsigned long int)4);
  if(!(return_value_memcmp$1 == 0))
    return 0;

  else
  {
    signed int return_value_memcmp$2;
    return_value_memcmp$2=memcmp((const void *)(buf + (signed long int)8), (const void *)"WAVE", (unsigned long int)4);
    if(!(return_value_memcmp$2 == 0))
      return 0;

    else
      return 1;
  }
}

// wav_load
// file loader.c line 153
static struct pcm_struct * wav_load(char *path, struct _IO_FILE *in)
{
  unsigned char wav_load$$1$$buf[40l];
  unsigned int len;
  struct pcm_struct *pcm = (struct pcm_struct *)(void *)0;
  signed int i;
  signed int return_value_fseek$1;
  return_value_fseek$1=fseek(in, (signed long int)12, 0);
  void *return_value_calloc$2;
  char *return_value_trim_path$3;
  char *return_value___strdup$4;
  signed int return_value_find_wav_chunk$5;
  unsigned long int return_value_fread$6;
  unsigned int mask;
  unsigned int format;
  unsigned int channels;
  unsigned int samplerate;
  unsigned int align;
  unsigned int samplesize;
  const char *mask_map[32l];
  char *return_value___strdup$7;
  char *return_value___strdup$8;
  char *return_value___strdup$9;
  char *return_value___strdup$10;
  char *return_value___strdup$11;
  char *return_value___strdup$12;
  char *return_value___strdup$13;
  char *return_value___strdup$14;
  char *return_value___strdup$15;
  char *return_value___strdup$16;
  char *return_value___strdup$17;
  char *return_value___strdup$18;
  char *return_value___strdup$19;
  char *return_value___strdup$20;
  char *return_value___strdup$21;
  char *return_value___strdup$22;
  signed int tmp_post$25;
  signed int return_value_find_wav_chunk$26;
  void *return_value_calloc$31;
  void *return_value_calloc$32;
  void *return_value_calloc$33;
  void *return_value_calloc$34;
  signed long int tmp_if_expr$35;
  if(return_value_fseek$1 == -1)
    fprintf(stderr, "%s: Failed to seek\n", path);

  else
  {
    return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct pcm_struct) /*56ul*/ );
    pcm = (struct pcm_struct *)return_value_calloc$2;
    return_value_trim_path$3=trim_path(path);
    return_value___strdup$4=__strdup(return_value_trim_path$3);
    pcm->name = return_value___strdup$4;
    return_value_find_wav_chunk$5=find_wav_chunk(in, path, "fmt ", &len);
    if(return_value_find_wav_chunk$5 == 0)
      fprintf(stderr, "%s: Failed to find fmt chunk in WAV file\n", path);

    else
      if(!(len >= 16u))
        fprintf(stderr, "%s: Unrecognised format chunk in WAV header\n", path);

      else
      {
        if(!(sb_verbose == 0))
        {
          if(!(len == 16u) && !(len == 18u) && !(len == 40u))
            fprintf(stderr, "%s: INVALID format chunk in WAV header.\n Trying to read anyway (may not work)...\n", path);

        }

        if(len >= 41u)
          len = (unsigned int)40;

        return_value_fread$6=fread((void *)wav_load$$1$$buf, (unsigned long int)1, (unsigned long int)len, in);
        if(!(return_value_fread$6 >= (unsigned long int)len))
          fprintf(stderr, "%s: Unexpected EOF in reading WAV header\n", path);

        else
        {
          mask = (unsigned int)0;
          format = (unsigned int)((signed int)wav_load$$1$$buf[(signed long int)1] << 8 | (signed int)wav_load$$1$$buf[(signed long int)0] & 0xff);
          channels = (unsigned int)((signed int)(wav_load$$1$$buf + (signed long int)2)[(signed long int)1] << 8 | (signed int)(wav_load$$1$$buf + (signed long int)2)[(signed long int)0] & 0xff);
          samplerate = (unsigned int)((signed int)(wav_load$$1$$buf + (signed long int)4)[(signed long int)3] << 24 | (signed int)(wav_load$$1$$buf + (signed long int)4)[(signed long int)2] << 16 | (signed int)(wav_load$$1$$buf + (signed long int)4)[(signed long int)1] << 8 | (signed int)(wav_load$$1$$buf + (signed long int)4)[(signed long int)0] & 0xff);
          align = (unsigned int)((signed int)(wav_load$$1$$buf + (signed long int)12)[(signed long int)1] << 8 | (signed int)(wav_load$$1$$buf + (signed long int)12)[(signed long int)0] & 0xff);
          samplesize = (unsigned int)((signed int)(wav_load$$1$$buf + (signed long int)14)[(signed long int)1] << 8 | (signed int)(wav_load$$1$$buf + (signed long int)14)[(signed long int)0] & 0xff);
          mask_map[0] = "L";
          mask_map[1] = "R";
          mask_map[2] = "C";
          mask_map[3] = "LFE";
          mask_map[4] = "BL";
          mask_map[5] = "BR";
          mask_map[6] = "CL";
          mask_map[7] = "CR";
          mask_map[8] = "BC";
          mask_map[9] = "SL";
          mask_map[10] = "SR";
          mask_map[11] = "X";
          mask_map[12] = "X";
          mask_map[13] = "X";
          mask_map[14] = "X";
          mask_map[15] = "X";
          mask_map[16] = "X";
          mask_map[17] = "X";
          mask_map[18] = "X";
          mask_map[19] = "X";
          mask_map[20] = "X";
          mask_map[21] = "X";
          mask_map[22] = "X";
          mask_map[23] = "X";
          mask_map[24] = "X";
          mask_map[25] = "X";
          mask_map[26] = "X";
          mask_map[27] = "X";
          mask_map[28] = "X";
          mask_map[29] = "X";
          mask_map[30] = "X";
          mask_map[31] = "X";
          if(format == 65534u)
          {
            if(!(len >= 40u))
            {
              fprintf(stderr, "%s: Extended WAV format header invalid (too small)\n", path);
              goto err;
            }

            mask = (unsigned int)((signed int)(wav_load$$1$$buf + (signed long int)20)[(signed long int)3] << 24 | (signed int)(wav_load$$1$$buf + (signed long int)20)[(signed long int)2] << 16 | (signed int)(wav_load$$1$$buf + (signed long int)20)[(signed long int)1] << 8 | (signed int)(wav_load$$1$$buf + (signed long int)20)[(signed long int)0] & 0xff);
            format = (unsigned int)((signed int)(wav_load$$1$$buf + (signed long int)24)[(signed long int)1] << 8 | (signed int)(wav_load$$1$$buf + (signed long int)24)[(signed long int)0] & 0xff);
          }

          if(mask == 0u)
            switch(channels)
            {
              case (unsigned int)1:
              {
                return_value___strdup$7=__strdup("M");
                pcm->matrix = return_value___strdup$7;
                return_value___strdup$8=__strdup("A");
                pcm->mix = return_value___strdup$8;
                break;
              }
              case (unsigned int)2:
              {
                return_value___strdup$9=__strdup("L,R");
                pcm->matrix = return_value___strdup$9;
                return_value___strdup$10=__strdup("BC");
                pcm->mix = return_value___strdup$10;
                break;
              }
              case (unsigned int)3:
              {
                return_value___strdup$11=__strdup("L,R,C");
                pcm->matrix = return_value___strdup$11;
                return_value___strdup$12=__strdup("BCD");
                pcm->mix = return_value___strdup$12;
                break;
              }
              case (unsigned int)4:
              {
                return_value___strdup$13=__strdup("L,R,BL,BR");
                pcm->matrix = return_value___strdup$13;
                return_value___strdup$14=__strdup("BCFG");
                pcm->mix = return_value___strdup$14;
                break;
              }
              case (unsigned int)5:
              {
                return_value___strdup$15=__strdup("L,R,C,BL,BR");
                pcm->matrix = return_value___strdup$15;
                return_value___strdup$16=__strdup("BCDFG");
                pcm->mix = return_value___strdup$16;
                break;
              }
              case (unsigned int)6:
              {
                return_value___strdup$17=__strdup("L,R,C,LFE,BL,BR");
                pcm->matrix = return_value___strdup$17;
                return_value___strdup$18=__strdup("BCDEFG");
                pcm->mix = return_value___strdup$18;
                break;
              }
              case (unsigned int)7:
              {
                return_value___strdup$19=__strdup("L,R,C,LFE,BC,SL,SR");
                pcm->matrix = return_value___strdup$19;
                return_value___strdup$20=__strdup("BCDEJKL");
                pcm->mix = return_value___strdup$20;
                break;
              }
              default:
              {
                return_value___strdup$21=__strdup("L,R,C,LFE,BL,BR,SL,SR");
                pcm->matrix = return_value___strdup$21;
                return_value___strdup$22=__strdup("BCDEFGKL");
                pcm->mix = return_value___strdup$22;
              }
            }

          else
          {
            signed int count = 0;
            void *return_value_calloc$23;
            return_value_calloc$23=calloc((unsigned long int)(32 * 4 + 1), sizeof(char) /*1ul*/ );
            pcm->matrix = (char *)return_value_calloc$23;
            void *return_value_calloc$24;
            return_value_calloc$24=calloc((unsigned long int)33, sizeof(char) /*1ul*/ );
            pcm->mix = (char *)return_value_calloc$24;
            i = 0;
            for( ; !(i >= 32); i = i + 1)
              if(!((mask & (unsigned int)(1 << i)) == 0u))
              {
                strcat(pcm->matrix, mask_map[(signed long int)i]);
                strcat(pcm->matrix, ",");
                tmp_post$25 = count;
                count = count + 1;
                pcm->mix[(signed long int)tmp_post$25] = (char)(66 + i);
              }

          }
          return_value_find_wav_chunk$26=find_wav_chunk(in, path, "data", &len);
          if(return_value_find_wav_chunk$26 == 0)
            fprintf(stderr, "%s: Failed to find fmt chunk in WAV file\n", path);

          else
          {
            if(!(sb_verbose == 0))
            {
              if(!(align == ((7u + samplesize) / 8u) * channels))
                fprintf(stderr, "%s: WAV 'block alignment' value is incorrect, ignoring.\nThe software that created this file is incorrect.\n", path);

            }

            if(format == 1u && (samplesize == 8u || samplesize == 16u || samplesize == 24u) || format == 3u && samplesize == 32u)
            {
              pcm->rate = (signed int)samplerate;
              pcm->ch = (signed int)channels;
              pcm->nativebits = (signed int)(format == (unsigned int)3 ? -samplesize : samplesize);
              pcm->currentbits = -32;
              if(!(len == 0u))
                pcm->size = (signed long int)len;

              else
              {
                signed long int pos;
                pos=ftell(in);
                signed int return_value_fseek$30;
                return_value_fseek$30=fseek(in, (signed long int)0, 2);
                if(return_value_fseek$30 == -1)
                {
                  signed int *return_value___errno_location$27;
                  return_value___errno_location$27=__errno_location();
                  char *return_value_strerror$28;
                  return_value_strerror$28=strerror(*return_value___errno_location$27);
                  fprintf(stderr, "%s failed to seek: %s\n", path, return_value_strerror$28);
                  goto err;
                }

                else
                {
                  signed long int return_value_ftell$29;
                  return_value_ftell$29=ftell(in);
                  pcm->size = return_value_ftell$29 - pos;
                  fseek(in, pos, 0);
                }
              }
            }

            else
            {
              fprintf(stderr, "%s: Wav file is unsupported subformat (must be 8,16, or 24-bit PCM\nor floating point PCM\n", path);
              goto err;
            }
            if(!(pcm->nativebits == 8))
            {
              if(pcm->nativebits == 16)
                goto __CPROVER_DUMP_L32;

              if(pcm->nativebits == 24)
                goto __CPROVER_DUMP_L33;

              if(pcm->nativebits == 32 || pcm->nativebits == -32)
                goto __CPROVER_DUMP_L34;

            }

            else
            {
              return_value_calloc$31=calloc((unsigned long int)1, (unsigned long int)pcm->size * sizeof(float) /*4ul*/ );
              pcm->data = (unsigned char *)return_value_calloc$31;
              goto __CPROVER_DUMP_L36;

            __CPROVER_DUMP_L32:
              ;
              return_value_calloc$32=calloc((unsigned long int)1, (unsigned long int)(pcm->size / (signed long int)2) * sizeof(float) /*4ul*/ );
              pcm->data = (unsigned char *)return_value_calloc$32;
              goto __CPROVER_DUMP_L36;

            __CPROVER_DUMP_L33:
              ;
              return_value_calloc$33=calloc((unsigned long int)1, (unsigned long int)(pcm->size / (signed long int)3) * sizeof(float) /*4ul*/ );
              pcm->data = (unsigned char *)return_value_calloc$33;
              goto __CPROVER_DUMP_L36;

            __CPROVER_DUMP_L34:
              ;
              return_value_calloc$34=calloc((unsigned long int)1, (unsigned long int)(pcm->size / (signed long int)4) * sizeof(float) /*4ul*/ );
              pcm->data = (unsigned char *)return_value_calloc$34;
              goto __CPROVER_DUMP_L36;
            }
            fprintf(stderr, "%s: Unsupported bit depth\n", path);
            goto err;

          __CPROVER_DUMP_L36:
            ;
            if(pcm->data == ((unsigned char *)NULL))
              fprintf(stderr, "Unable to allocate enough memory to load sample into memory\n");

            else
            {
              signed long int j = (signed long int)0;
              signed long int k;
              unsigned char *d = pcm->data;
              float *f = (float *)pcm->data;
              while(!(j >= pcm->size))
              {
                signed long int bytes;
                if(pcm->size + -j >= 65537l)
                  tmp_if_expr$35 = (signed long int)65536;

                else
                  tmp_if_expr$35 = pcm->size - j;
                bytes = tmp_if_expr$35;
                if(!(sb_verbose == 0))
                  fprintf(stderr, "\rLoading %s: %ld to go...       ", pcm->name, (signed long int)(pcm->size - j));

                unsigned long int return_value_fread$36;
                return_value_fread$36=fread((void *)(d + j), (unsigned long int)1, (unsigned long int)bytes, in);
                bytes = (signed long int)return_value_fread$36;
                j = j + bytes;
                if(bytes == 0l)
                  break;

              }
              if(!(j >= pcm->size))
              {
                if(!(sb_verbose == 0))
                  fprintf(stderr, "\r%s: File ended before declared length (%ld < %ld); continuing...\n", path, (signed long int)j, (signed long int)pcm->size);

                pcm->size = j;
              }

              if(!(sb_verbose == 0))
                fprintf(stderr, "\rLoading %s: parsing...      ", pcm->name);

              if(!(pcm->nativebits == 8))
              {
                if(pcm->nativebits == 16)
                  goto __CPROVER_DUMP_L50;

                if(pcm->nativebits == 24)
                  goto __CPROVER_DUMP_L53;

                if(pcm->nativebits == 32)
                  goto __CPROVER_DUMP_L56;

                if(pcm->nativebits == -32)
                  goto __CPROVER_DUMP_L59;

              }

              else
              {
                k = pcm->size;
                j = pcm->size - (signed long int)1;
                for( ; j >= 0l; j = j - 1l)
                {
                  k = k - 1l;
                  f[k] = (float)(signed int)((signed int)d[j] - 128 << 24) * (1.f / 2147483648.f);
                }
                pcm->size = (signed long int)((unsigned long int)pcm->size * sizeof(float) /*4ul*/ );
                goto __CPROVER_DUMP_L68;

              __CPROVER_DUMP_L50:
                ;
                k = pcm->size / (signed long int)2;
                j = pcm->size - (signed long int)2;
                for( ; j >= 0l; j = j - (signed long int)2)
                {
                  k = k - 1l;
                  f[k] = (float)(signed int)((signed int)d[j] << 16 | (signed int)d[j + (signed long int)1] << 24) * (1.f / 2147483648.f);
                }
                pcm->size = (signed long int)((unsigned long int)(pcm->size / (signed long int)2) * sizeof(float) /*4ul*/ );
                goto __CPROVER_DUMP_L68;

              __CPROVER_DUMP_L53:
                ;
                k = pcm->size / (signed long int)3;
                j = pcm->size - (signed long int)3;
                for( ; j >= 0l; j = j - (signed long int)3)
                {
                  k = k - 1l;
                  f[k] = (float)(signed int)((signed int)d[j] << 8 | (signed int)d[j + (signed long int)1] << 16 | (signed int)d[j + (signed long int)2] << 24) * (1.f / 2147483648.f);
                }
                pcm->size = (signed long int)((unsigned long int)(pcm->size / (signed long int)3) * sizeof(float) /*4ul*/ );
                goto __CPROVER_DUMP_L68;

              __CPROVER_DUMP_L56:
                ;
                k = pcm->size / (signed long int)4;
                j = pcm->size - (signed long int)4;
                for( ; j >= 0l; j = j - (signed long int)4)
                {
                  k = k - 1l;
                  f[k] = (float)(signed int)((signed int)d[j] | (signed int)d[j + (signed long int)1] << 8 | (signed int)d[j + (signed long int)2] << 16 | (signed int)d[j + (signed long int)3] << 24) * (1.f / 2147483648.f);
                }
                pcm->size = (signed long int)((unsigned long int)(pcm->size / (signed long int)4) * sizeof(float) /*4ul*/ );
                goto __CPROVER_DUMP_L68;

              __CPROVER_DUMP_L59:
                ;
                k = pcm->size / (signed long int)4;
                j = pcm->size - (signed long int)4;
                for( ; j >= 0l; j = j - (signed long int)4)
                {
                  signed int val = 0;
                  signed int mantissa = (signed int)d[j] | (signed int)d[j + (signed long int)1] << 8 | ((signed int)d[j + (signed long int)2] & 0x7f) << 16 | 1 << 23;
                  signed int exponent = 127 - ((signed int)d[j + (signed long int)2] >> 7 | ((signed int)d[j + (signed long int)3] & 0x7f) << 1);
                  signed int sign = (signed int)d[j + (signed long int)3] >> 7;
                  if(!(exponent >= 1))
                  {
                    if(exponent == -128)
                    {
                      fprintf(stderr, "%s: Input file contains invalid floating point values.\n", pcm->name);
                      exit(6);
                    }

                    if(!(sign == 0))
                      val = 8388608;

                    else
                      val = 8388607;
                  }

                  else
                    if(!(exponent >= 25))
                    {
                      val = mantissa >> exponent;
                      if((1 & val) + (0xffffff & mantissa << 24 + -exponent) >= 8388609)
                        val = val + 1;

                    }

                  if(!(sign == 0))
                    val = -val;

                  k = k - 1l;
                  f[k] = (float)((double)val / 8388608.);
                }
                pcm->size = (signed long int)((unsigned long int)(pcm->size / (signed long int)4) * sizeof(float) /*4ul*/ );
              }

            __CPROVER_DUMP_L68:
              ;
              if(!(sb_verbose == 0))
                fprintf(stderr, "\rLoading %s: loaded.         ", pcm->name);

              return pcm;
            }
          }
        }
      }
  }

err:
  ;
  free_pcm(pcm);
  return (struct pcm_struct *)(void *)0;
}

// write_callback
// file loader.c line 836
static enum anonymous$44 write_callback(const struct anonymous *decoder, const struct anonymous$17 *frame, const signed int * const *buffer, void *client_data)
{
  struct anonymous$48 *flac = (struct anonymous$48 *)client_data;
  struct pcm_struct *pcm = flac->pcm;
  signed int samples = (signed int)frame->header.blocksize;
  signed int channels = (signed int)frame->header.channels;
  signed int bits_per_sample = (signed int)frame->header.bits_per_sample;
  signed long int write_callback$$1$$fill = flac->fill;
  signed int i;
  signed int j;
  if(pcm->data == ((unsigned char *)NULL))
  {
    pcm->ch = channels;
    pcm->nativebits = ((bits_per_sample + 7) / 8) * 8;
    pcm->size = pcm->size * (signed long int)((unsigned long int)channels * sizeof(float) /*4ul*/ );
    pcm->currentbits = -32;
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)pcm->size, (unsigned long int)1);
    pcm->data = (unsigned char *)return_value_calloc$1;
  }

  signed long int tmp_post$2;
  signed long int tmp_post$3;
  if(!(channels == pcm->ch))
  {
    fprintf(stderr, "\r%s: number of channels changes part way through file\n", pcm->name);
    return (enum anonymous$44)FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
  }

  else
    if(!(pcm->nativebits == ((7 + bits_per_sample) / 8) * 8))
    {
      fprintf(stderr, "\r%s: bit depth changes part way through file\n", pcm->name);
      return (enum anonymous$44)FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
    }

    else
    {
      if(!(sb_verbose == 0))
        fprintf(stderr, "\rLoading %s: parsing...      ", pcm->name);

      float *d = (float *)pcm->data;
      signed int shift = pcm->nativebits - bits_per_sample;
      switch(pcm->nativebits)
      {
        case 16:
        {
          j = 0;
          for( ; !(j >= samples); j = j + 1)
          {
            i = 0;
            for( ; !(i >= channels); i = i + 1)
            {
              tmp_post$2 = write_callback$$1$$fill;
              write_callback$$1$$fill = write_callback$$1$$fill + 1l;
              d[tmp_post$2] = (float)(buffer[(signed long int)i][(signed long int)j] << shift) * (1.f / 32768.f);
            }
          }
          break;
        }
        case 24:
        {
          j = 0;
          for( ; !(j >= samples); j = j + 1)
          {
            i = 0;
            for( ; !(i >= channels); i = i + 1)
            {
              tmp_post$3 = write_callback$$1$$fill;
              write_callback$$1$$fill = write_callback$$1$$fill + 1l;
              d[tmp_post$3] = (float)(buffer[(signed long int)i][(signed long int)j] << shift) * (1.f / 8388608.f);
            }
          }
          break;
        }
        default:
        {
          fprintf(stderr, "\r%s: Only 16- and 24-bit FLACs are supported for decode right now.\n", pcm->name);
          return (enum anonymous$44)FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
        }
      }
      flac->fill = write_callback$$1$$fill;
      return (enum anonymous$44)FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
    }
}

