// tag-#anon#ST[*{S8}_S8_'filename'|]
// file log.c line 236
struct anonymous_3;

// tag-#anon#ST[*{S8}_S8_'header_req'||*{S8}_S8_'header_resp'|]
// file log.c line 232
struct anonymous_1;

// tag-#anon#ST[*{SYM#tag-_ftsent#}_SYM#tag-_ftsent#_'fts_cur'||*{SYM#tag-_ftsent#}_SYM#tag-_ftsent#_'fts_child'||*{*{SYM#tag-_ftsent#}_SYM#tag-_ftsent#_}_*{SYM#tag-_ftsent#}_SYM#tag-_ftsent#__'fts_array'||U64'fts_dev'||*{S8}_S8_'fts_path'||S32'fts_rfd'||S32'fts_pathlen'||S32'fts_nitems'||U32'_pad0'||*{S32(*{cV}_cV_|*{cV}_cV_)->S32}_S32(*{cV}_cV_|*{cV}_cV_)->S32_'fts_compar'||S32'fts_options'||U32'_pad1'|]
// file /usr/include/fts.h line 45
struct anonymous_21;

// tag-#anon#ST[ARR128{U8}_U8_'cert_verify_md'||ARR128{U8}_U8_'finish_md'||S32'finish_md_len'||ARR128{U8}_U8_'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'_pad0'||*{cSYM#tag-ssl_cipher_st#}_cSYM#tag-ssl_cipher_st#_'new_cipher'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}_S8_'ctype'||U56'_pad1'||*{SYM#tag-stack_st_X509_NAME#}_SYM#tag-stack_st_X509_NAME#_'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}_U8_'key_block'||*{cSYM#tag-evp_cipher_st#}_cSYM#tag-evp_cipher_st#_'new_sym_enc'||*{cSYM#tag-env_md_st#}_cSYM#tag-env_md_st#_'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}_cSYM#tag-ssl_comp_st#_'new_compression'||S32'cert_request'||U32'_pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous_20;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_5;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous_17;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}_U8_'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous_19;

// tag-#anon#ST[U32'n_buckets'||U32'size'||U32'n_occupied'||U32'upper_bound'||*{U32}_U32_'flags'||*{*{S8}_S8_}_*{S8}_S8__'keys'||*{*{V}_V_}_*{V}_V__'vals'|]
// file cachetgcrt.c line 42
struct anonymous_10;

// tag-#anon#ST[U32'n_buckets'||U32'size'||U32'n_occupied'||U32'upper_bound'||*{U32}_U32_'flags'||*{*{SYM#tag-dynbuf#}_SYM#tag-dynbuf#_}_*{SYM#tag-dynbuf#}_SYM#tag-dynbuf#__'keys'||*{*{SYM#tag-dynbuf#}_SYM#tag-dynbuf#_}_*{SYM#tag-dynbuf#}_SYM#tag-dynbuf#__'vals'|]
// file cachedsess.c line 68
struct anonymous_6;

// tag-#anon#ST[U32'n_buckets'||U32'size'||U32'n_occupied'||U32'upper_bound'||*{U32}_U32_'flags'||*{*{V}_V_}_*{V}_V__'keys'||*{*{V}_V_}_*{V}_V__'vals'|]
// file cachefkcrt.c line 56
struct anonymous_12;

// tag-#anon#UN[*{S32}_S32_'inherit'||*{SYM#tag-stack_st_ASIdOrRange#}_SYM#tag-stack_st_ASIdOrRange#_'asIdsOrRanges'|]
// file /usr/include/openssl/x509v3.h line 783
union anonymous_15;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-otherName_st#}_SYM#tag-otherName_st#_'otherName'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'rfc822Name'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'dNSName'||*{SYM#tag-asn1_type_st#}_SYM#tag-asn1_type_st#_'x400Address'||*{SYM#tag-X509_name_st#}_SYM#tag-X509_name_st#_'directoryName'||*{SYM#tag-EDIPartyName_st#}_SYM#tag-EDIPartyName_st#_'ediPartyName'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'uniformResourceIdentifier'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'iPAddress'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'registeredID'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ip'||*{SYM#tag-X509_name_st#}_SYM#tag-X509_name_st#_'dirn'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'rid'||*{SYM#tag-asn1_type_st#}_SYM#tag-asn1_type_st#_'other'|]
// file /usr/include/openssl/x509v3.h line 188
union anonymous_18;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-rsa_st#}_SYM#tag-rsa_st#_'rsa'||*{SYM#tag-dsa_st#}_SYM#tag-dsa_st#_'dsa'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous_13;

// tag-#anon#UN[*{S8}_S8_'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'asn1_string'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'object'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'integer'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'enumerated'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bit_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'octet_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'printablestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'t61string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bmpstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'universalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utctime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalizedtime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'visiblestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utf8string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'set'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'sequence'||*{SYM#tag-ASN1_VALUE_st#}_SYM#tag-ASN1_VALUE_st#_'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous_14;

// tag-#anon#UN[*{SYM#tag-stack_st_GENERAL_NAME#}_SYM#tag-stack_st_GENERAL_NAME#_'fullname'||*{SYM#tag-stack_st_X509_NAME_ENTRY#}_SYM#tag-stack_st_X509_NAME_ENTRY#_'relativename'|]
// file /usr/include/openssl/x509v3.h line 228
union anonymous_16;

// tag-#anon#UN[*{V(S32|S32|*{V}_V_)->V}_V(S32|S32|*{V}_V_)->V_'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32}_S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32_'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous_11;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_9;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous;

// tag-#anon#UN[SYM#tag-#anon#ST[*{S8}_S8_'header_req'||*{S8}_S8_'header_resp'|]#'file'||SYM#tag-#anon#ST[*{S8}_S8_'filename'|]#'dir'||SYM#tag-#anon#ST[*{S8}_S8_'filename'|]#'spec'|]
// file log.c line 231
union anonymous_2;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_4;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_0;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_7;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_8;

// tag-ACCESS_DESCRIPTION_st
// file /usr/include/openssl/x509v3.h line 211
struct ACCESS_DESCRIPTION_st;

// tag-ASIdentifierChoice_st
// file /usr/include/openssl/x509v3.h line 781
struct ASIdentifierChoice_st;

// tag-ASIdentifiers_st
// file /usr/include/openssl/x509.h line 293
struct ASIdentifiers_st;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-CRYPTO_dynlock_value
// file /usr/include/openssl/crypto.h line 264
struct CRYPTO_dynlock_value;

// tag-DIST_POINT_NAME_st
// file /usr/include/openssl/x509v3.h line 226
struct DIST_POINT_NAME_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-EDIPartyName_st
// file /usr/include/openssl/x509v3.h line 172
struct EDIPartyName_st;

// tag-GENERAL_NAME_st
// file /usr/include/openssl/x509v3.h line 177
struct GENERAL_NAME_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-X509V3_CONF_METHOD_st
// file /usr/include/openssl/x509v3.h line 126
struct X509V3_CONF_METHOD_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_extension_st
// file /usr/include/openssl/x509.h line 196
struct X509_extension_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_req_info_st
// file /usr/include/openssl/x509.h line 226
struct X509_req_info_st;

// tag-X509_req_st
// file /usr/include/openssl/x509.h line 235
struct X509_req_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_ftsent
// file /usr/include/fts.h line 46
struct _ftsent;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-bufferevent
// file /usr/include/event2/bufferevent.h line 111
struct bufferevent;

// tag-bufferevent_ssl_state
// file /usr/include/event2/bufferevent_ssl.h line 49
enum bufferevent_ssl_state { BUFFEREVENT_SSL_OPEN=0, BUFFEREVENT_SSL_CONNECTING=1, BUFFEREVENT_SSL_ACCEPTING=2 };

// tag-cache
// file cache.h line 54
struct cache;

// tag-cert
// file cert.h line 37
struct cert;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-crypto_threadid_st
// file /usr/include/openssl/crypto.h line 448
struct crypto_threadid_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-dynbuf
// file dynbuf.h line 36
struct dynbuf;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine
// file nat.c line 400
struct engine;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evbuffer
// file /usr/include/event2/bufferevent.h line 117
struct evbuffer;

// tag-evbuffer_eol_style
// file /usr/include/event2/buffer.h line 362
enum evbuffer_eol_style { EVBUFFER_EOL_ANY=0, EVBUFFER_EOL_CRLF=1, EVBUFFER_EOL_CRLF_STRICT=2, EVBUFFER_EOL_LF=3 };

// tag-evconnlistener
// file /usr/include/event2/listener.h line 37
struct evconnlistener;

// tag-evdns_base
// file /usr/include/event2/dns.h line 201
struct evdns_base;

// tag-evdns_getaddrinfo_request
// file /usr/include/event2/dns.h line 610
struct evdns_getaddrinfo_request;

// tag-event
// file /usr/include/event2/event.h line 272
struct event;

// tag-event_base
// file /usr/include/event2/event.h line 213
struct event_base;

// tag-event_method_feature
// file /usr/include/event2/event.h line 430
enum event_method_feature { EV_FEATURE_ET=1, EV_FEATURE_O1=2, EV_FEATURE_FDS=4 };

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lhash_st_CONF_VALUE
// file /usr/include/openssl/conf.h line 81
struct lhash_st_CONF_VALUE;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-log_content_ctx
// file log.h line 60
struct log_content_ctx;

// tag-logbuf
// file logbuf.h line 37
struct logbuf;

// tag-logger
// file logger.h line 42
struct logger;

// tag-ocsp_req_info_st
// file /usr/include/openssl/ocsp.h line 129
struct ocsp_req_info_st;

// tag-ocsp_request_st
// file /usr/include/openssl/ocsp.h line 151
struct ocsp_request_st;

// tag-ocsp_signature_st
// file /usr/include/openssl/ocsp.h line 141
struct ocsp_signature_st;

// tag-opts
// file opts.h line 57
struct opts;

// tag-otherName_st
// file /usr/include/openssl/x509v3.h line 167
struct otherName_st;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-proxy_ctx
// file proxy.h line 35
struct proxy_ctx;

// tag-proxy_listener_ctx
// file proxy.c line 66
struct proxy_listener_ctx;

// tag-proxyspec
// file opts.h line 40
struct proxyspec;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-pxy_conn_ctx
// file pxyconn.c line 116
struct pxy_conn_ctx;

// tag-pxy_conn_desc
// file pxyconn.c line 91
struct pxy_conn_desc;

// tag-pxy_ssl_shutdown_ctx
// file pxysslshut.c line 53
struct pxy_ssl_shutdown_ctx;

// tag-pxy_thr_ctx
// file pxythrmgr.c line 46
struct pxy_thr_ctx;

// tag-pxy_thrmgr_ctx
// file pxythrmgr.h line 41
struct pxy_thrmgr_ctx;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ACCESS_DESCRIPTION
// file /usr/include/openssl/x509v3.h line 216
struct stack_st_ACCESS_DESCRIPTION;

// tag-stack_st_ASIdOrRange
// file /usr/include/openssl/x509v3.h line 775
struct stack_st_ASIdOrRange;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_CONF_VALUE
// file /usr/include/openssl/conf.h line 80
struct stack_st_CONF_VALUE;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_GENERAL_SUBTREE
// file /usr/include/openssl/x509v3.h line 330
struct stack_st_GENERAL_SUBTREE;

// tag-stack_st_IPAddressFamily
// file /usr/include/openssl/x509.h line 292
struct stack_st_IPAddressFamily;

// tag-stack_st_OCSP_ONEREQ
// file /usr/include/openssl/ocsp.h line 120
struct stack_st_OCSP_ONEREQ;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-thrqueue
// file thrqueue.h line 36
struct thrqueue;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-v3_ext_ctx
// file /usr/include/openssl/ossl_typ.h line 166
struct v3_ext_ctx;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// ACCESS_DESCRIPTION_free
// file /usr/include/openssl/x509v3.h line 582
void ACCESS_DESCRIPTION_free(struct ACCESS_DESCRIPTION_st *);
// ASN1_INTEGER_set
// file /usr/include/openssl/asn1.h line 927
signed int ASN1_INTEGER_set(struct asn1_string_st *, signed long int);
// ASN1_INTEGER_to_BN
// file /usr/include/openssl/asn1.h line 930
struct bignum_st * ASN1_INTEGER_to_BN(const struct asn1_string_st *, struct bignum_st *);
// ASN1_STRING_length
// file /usr/include/openssl/asn1.h line 809
signed int ASN1_STRING_length(const struct asn1_string_st *);
// ASN1_STRING_set
// file /usr/include/openssl/asn1.h line 807
signed int ASN1_STRING_set(struct asn1_string_st *, const void *, signed int);
// ASN1_STRING_to_UTF8
// file /usr/include/openssl/asn1.h line 1010
signed int ASN1_STRING_to_UTF8(unsigned char **, struct asn1_string_st *);
// ASN1_STRING_type_new
// file /usr/include/openssl/asn1.h line 801
struct asn1_string_st * ASN1_STRING_type_new(signed int);
// BIO_ctrl
// file /usr/include/openssl/bio.h line 664
signed long int BIO_ctrl(struct bio_st *, signed int, signed long int, void *);
// BIO_free
// file /usr/include/openssl/bio.h line 657
signed int BIO_free(struct bio_st *);
// BIO_new
// file /usr/include/openssl/bio.h line 655
struct bio_st * BIO_new(struct bio_method_st *);
// BIO_s_mem
// file /usr/include/openssl/bio.h line 687
struct bio_method_st * BIO_s_mem(void);
// BN_add_word
// file /usr/include/openssl/bn.h line 486
signed int BN_add_word(struct bignum_st *, unsigned long int);
// BN_bin2bn
// file /usr/include/openssl/bn.h line 441
struct bignum_st * BN_bin2bn(const unsigned char *, signed int, struct bignum_st *);
// BN_free
// file /usr/include/openssl/bn.h line 492
void BN_free(struct bignum_st *);
// BN_to_ASN1_INTEGER
// file /usr/include/openssl/asn1.h line 929
struct asn1_string_st * BN_to_ASN1_INTEGER(const struct bignum_st *, struct asn1_string_st *);
// CONF_modules_finish
// file /usr/include/openssl/conf.h line 190
void CONF_modules_finish(void);
// CONF_modules_free
// file /usr/include/openssl/conf.h line 191
void CONF_modules_free(void);
// CONF_modules_unload
// file /usr/include/openssl/conf.h line 189
void CONF_modules_unload(signed int);
// CRYPTO_THREADID_set_callback
// file /usr/include/openssl/crypto.h line 455
signed int CRYPTO_THREADID_set_callback(void (*)(struct crypto_threadid_st *));
// CRYPTO_THREADID_set_numeric
// file /usr/include/openssl/crypto.h line 453
void CRYPTO_THREADID_set_numeric(struct crypto_threadid_st *, unsigned long int);
// CRYPTO_add_lock
// file /usr/include/openssl/crypto.h line 468
signed int CRYPTO_add_lock(signed int *, signed int, signed int, const char *, signed int);
// CRYPTO_cleanup_all_ex_data
// file /usr/include/openssl/crypto.h line 431
void CRYPTO_cleanup_all_ex_data(void);
// CRYPTO_free
// file /usr/include/openssl/crypto.h line 536
void CRYPTO_free(void *);
// CRYPTO_num_locks
// file /usr/include/openssl/crypto.h line 435
signed int CRYPTO_num_locks(void);
// CRYPTO_set_dynlock_create_callback
// file /usr/include/openssl/crypto.h line 474
void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value * (*)(const char *, signed int));
// CRYPTO_set_dynlock_destroy_callback
// file /usr/include/openssl/crypto.h line 482
void CRYPTO_set_dynlock_destroy_callback(void (*)(struct CRYPTO_dynlock_value *, const char *, signed int));
// CRYPTO_set_dynlock_lock_callback
// file /usr/include/openssl/crypto.h line 478
void CRYPTO_set_dynlock_lock_callback(void (*)(signed int, struct CRYPTO_dynlock_value *, const char *, signed int));
// CRYPTO_set_locking_callback
// file /usr/include/openssl/crypto.h line 437
void CRYPTO_set_locking_callback(void (*)(signed int, signed int, const char *, signed int));
// DH_free
// file /usr/include/openssl/dh.h line 201
void DH_free(struct dh_st *);
// DH_new
// file /usr/include/openssl/dh.h line 200
struct dh_st * DH_new(void);
// EC_KEY_free
// file /usr/include/openssl/ec.h line 772
void EC_KEY_free(struct ec_key_st *);
// EC_KEY_new_by_curve_name
// file /usr/include/openssl/ec.h line 767
struct ec_key_st * EC_KEY_new_by_curve_name(signed int);
// ENGINE_cleanup
// file /usr/include/openssl/engine.h line 591
void ENGINE_cleanup(void);
// ERR_free_strings
// file /usr/include/openssl/err.h line 353
void ERR_free_strings(void);
// ERR_func_error_string
// file /usr/include/openssl/err.h line 337
const char * ERR_func_error_string(unsigned long int);
// ERR_lib_error_string
// file /usr/include/openssl/err.h line 336
const char * ERR_lib_error_string(unsigned long int);
// ERR_print_errors_fp
// file /usr/include/openssl/err.h line 342
void ERR_print_errors_fp(struct _IO_FILE *);
// ERR_reason_error_string
// file /usr/include/openssl/err.h line 338
const char * ERR_reason_error_string(unsigned long int);
// ERR_remove_state
// file /usr/include/openssl/err.h line 357
void ERR_remove_state(unsigned long int);
// EVP_PKEY_assign
// file /usr/include/openssl/evp.h line 956
signed int EVP_PKEY_assign(struct evp_pkey_st *, signed int, void *);
// EVP_PKEY_free
// file /usr/include/openssl/evp.h line 981
void EVP_PKEY_free(struct evp_pkey_st *);
// EVP_PKEY_new
// file /usr/include/openssl/evp.h line 980
struct evp_pkey_st * EVP_PKEY_new(void);
// EVP_PKEY_type
// file /usr/include/openssl/evp.h line 949
signed int EVP_PKEY_type(signed int);
// EVP_cleanup
// file /usr/include/openssl/evp.h line 927
void EVP_cleanup(void);
// EVP_dss1
// file /usr/include/openssl/evp.h line 722
const struct env_md_st * EVP_dss1(void);
// EVP_ecdsa
// file /usr/include/openssl/evp.h line 723
const struct env_md_st * EVP_ecdsa(void);
// EVP_sha1
// file /usr/include/openssl/evp.h line 720
const struct env_md_st * EVP_sha1(void);
// GENERAL_NAMES_free
// file /usr/include/openssl/x509v3.h line 541
void GENERAL_NAMES_free(struct stack_st_GENERAL_NAME *);
// GENERAL_NAME_free
// file /usr/include/openssl/x509v3.h line 525
void GENERAL_NAME_free(struct GENERAL_NAME_st *);
// GENERAL_NAME_new
// file /usr/include/openssl/x509v3.h line 525
struct GENERAL_NAME_st * GENERAL_NAME_new(void);
// OBJ_obj2nid
// file /usr/include/openssl/objects.h line 1011
signed int OBJ_obj2nid(const struct asn1_object_st *);
// OBJ_sn2nid
// file /usr/include/openssl/objects.h line 1016
signed int OBJ_sn2nid(const char *);
// OCSP_REQUEST_free
// file /usr/include/openssl/ocsp.h line 556
void OCSP_REQUEST_free(struct ocsp_request_st *);
// OPENSSL_add_all_algorithms_noconf
// file /usr/include/openssl/evp.h line 905
void OPENSSL_add_all_algorithms_noconf(void);
// PEM_read_DHparams
// file /usr/include/openssl/pem.h line 477
struct dh_st * PEM_read_DHparams(struct _IO_FILE *, struct dh_st **, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_bio_X509
// file /usr/include/openssl/pem.h line 451
signed int PEM_write_bio_X509(struct bio_st *, struct x509_st *);
// RAND_bytes
// file /usr/include/openssl/rand.h line 101
signed int RAND_bytes(unsigned char *, signed int);
// RAND_poll
// file /usr/include/openssl/rand.h line 112
signed int RAND_poll(void);
// RAND_pseudo_bytes
// file /usr/include/openssl/rand.h line 102
signed int RAND_pseudo_bytes(unsigned char *, signed int);
// RAND_seed
// file /usr/include/openssl/rand.h line 103
void RAND_seed(const void *, signed int);
// RAND_status
// file /usr/include/openssl/rand.h line 108
signed int RAND_status(void);
// RSA_generate_key
// file /usr/include/openssl/rsa.h line 326
struct rsa_st * RSA_generate_key(signed int, unsigned long int, void (*)(signed int, signed int, void *), void *);
// SSL_CIPHER_get_name
// file /usr/include/openssl/ssl.h line 2145
const char * SSL_CIPHER_get_name(const struct ssl_cipher_st *);
// SSL_CTX_callback_ctrl
// file /usr/include/openssl/ssl.h line 2340
signed long int SSL_CTX_callback_ctrl(struct ssl_ctx_st *, signed int, void (*)(void));
// SSL_CTX_ctrl
// file /usr/include/openssl/ssl.h line 2339
signed long int SSL_CTX_ctrl(struct ssl_ctx_st *, signed int, signed long int, void *);
// SSL_CTX_free
// file /usr/include/openssl/ssl.h line 2132
void SSL_CTX_free(struct ssl_ctx_st *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_sess_set_get_cb
// file /usr/include/openssl/ssl.h line 1237
void SSL_CTX_sess_set_get_cb(struct ssl_ctx_st *, struct ssl_session_st * (*)(struct ssl_st *, unsigned char *, signed int, signed int *));
// SSL_CTX_sess_set_new_cb
// file /usr/include/openssl/ssl.h line 1225
void SSL_CTX_sess_set_new_cb(struct ssl_ctx_st *, signed int (*)(struct ssl_st *, struct ssl_session_st *));
// SSL_CTX_sess_set_remove_cb
// file /usr/include/openssl/ssl.h line 1230
void SSL_CTX_sess_set_remove_cb(struct ssl_ctx_st *, void (*)(struct ssl_ctx_st *, struct ssl_session_st *));
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_set_tmp_dh_callback
// file /usr/include/openssl/ssl.h line 2519
void SSL_CTX_set_tmp_dh_callback(struct ssl_ctx_st *, struct dh_st * (*)(struct ssl_st *, signed int, signed int));
// SSL_CTX_set_verify
// file /usr/include/openssl/ssl.h line 2262
void SSL_CTX_set_verify(struct ssl_ctx_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_CTX_use_PrivateKey
// file /usr/include/openssl/ssl.h line 2275
signed int SSL_CTX_use_PrivateKey(struct ssl_ctx_st *, struct evp_pkey_st *);
// SSL_CTX_use_PrivateKey_file
// file /usr/include/openssl/ssl.h line 2199
signed int SSL_CTX_use_PrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate
// file /usr/include/openssl/ssl.h line 2278
signed int SSL_CTX_use_certificate(struct ssl_ctx_st *, struct x509_st *);
// SSL_CTX_use_certificate_chain_file
// file /usr/include/openssl/ssl.h line 2202
signed int SSL_CTX_use_certificate_chain_file(struct ssl_ctx_st *, const char *);
// SSL_CTX_use_certificate_file
// file /usr/include/openssl/ssl.h line 2200
signed int SSL_CTX_use_certificate_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_SESSION_free
// file /usr/include/openssl/ssl.h line 2240
void SSL_SESSION_free(struct ssl_session_st *);
// SSL_SESSION_get_time
// file /usr/include/openssl/ssl.h line 2221
signed long int SSL_SESSION_get_time(const struct ssl_session_st *);
// SSL_SESSION_get_timeout
// file /usr/include/openssl/ssl.h line 2223
signed long int SSL_SESSION_get_timeout(const struct ssl_session_st *);
// SSL_SESSION_print
// file /usr/include/openssl/ssl.h line 2238
signed int SSL_SESSION_print(struct bio_st *, const struct ssl_session_st *);
// SSL_ctrl
// file /usr/include/openssl/ssl.h line 2337
signed long int SSL_ctrl(struct ssl_st *, signed int, signed long int, void *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get_certificate
// file /usr/include/openssl/ssl.h line 2426
struct x509_st * SSL_get_certificate(const struct ssl_st *);
// SSL_get_current_cipher
// file /usr/include/openssl/ssl.h line 2142
const struct ssl_cipher_st * SSL_get_current_cipher(const struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_get_peer_certificate
// file /usr/include/openssl/ssl.h line 2253
struct x509_st * SSL_get_peer_certificate(const struct ssl_st *);
// SSL_get_privatekey
// file /usr/include/openssl/ssl.h line 2429
struct evp_pkey_st * SSL_get_privatekey(const struct ssl_st *);
// SSL_get_servername
// file /usr/include/openssl/tls1.h line 309
const char * SSL_get_servername(const struct ssl_st *, const signed int);
// SSL_get_session
// file /usr/include/openssl/ssl.h line 2445
struct ssl_session_st * SSL_get_session(const struct ssl_st *);
// SSL_get_version
// file /usr/include/openssl/ssl.h line 2343
const char * SSL_get_version(const struct ssl_st *);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_set_SSL_CTX
// file /usr/include/openssl/ssl.h line 2448
struct ssl_ctx_st * SSL_set_SSL_CTX(struct ssl_st *, struct ssl_ctx_st *);
// SSL_set_session
// file /usr/include/openssl/ssl.h line 2242
signed int SSL_set_session(struct ssl_st *, struct ssl_session_st *);
// SSL_shutdown
// file /usr/include/openssl/ssl.h line 2397
signed int SSL_shutdown(struct ssl_st *);
// SSL_state_string
// file /usr/include/openssl/ssl.h line 2217
const char * SSL_state_string(const struct ssl_st *);
// SSL_state_string_long
// file /usr/include/openssl/ssl.h line 2219
const char * SSL_state_string_long(const struct ssl_st *);
// SSLeay
// file /usr/include/openssl/crypto.h line 397
unsigned long int SSLeay(void);
// SSLeay_version
// file /usr/include/openssl/crypto.h line 396
const char * SSLeay_version(signed int);
// SSLv23_method
// file /usr/include/openssl/ssl.h line 2360
const struct ssl_method_st * SSLv23_method(void);
// SSLv23_server_method
// file /usr/include/openssl/ssl.h line 2362
const struct ssl_method_st * SSLv23_server_method(void);
// TLSv1_1_method
// file /usr/include/openssl/ssl.h line 2371
const struct ssl_method_st * TLSv1_1_method(void);
// TLSv1_2_method
// file /usr/include/openssl/ssl.h line 2375
const struct ssl_method_st * TLSv1_2_method(void);
// TLSv1_method
// file /usr/include/openssl/ssl.h line 2367
const struct ssl_method_st * TLSv1_method(void);
// X509V3_EXT_conf
// file /usr/include/openssl/x509v3.h line 628
struct X509_extension_st * X509V3_EXT_conf(struct lhash_st_CONF_VALUE *, struct v3_ext_ctx *, char *, char *);
// X509V3_EXT_i2d
// file /usr/include/openssl/x509v3.h line 679
struct X509_extension_st * X509V3_EXT_i2d(signed int, signed int, void *);
// X509V3_set_ctx
// file /usr/include/openssl/x509v3.h line 649
void X509V3_set_ctx(struct v3_ext_ctx *, struct x509_st *, struct x509_st *, struct X509_req_st *, struct X509_crl_st *, signed int);
// X509_EXTENSION_free
// file /usr/include/openssl/x509.h line 812
void X509_EXTENSION_free(struct X509_extension_st *);
// X509_NAME_get_text_by_NID
// file /usr/include/openssl/x509.h line 1011
signed int X509_NAME_get_text_by_NID(struct X509_name_st *, signed int, char *, signed int);
// X509_NAME_oneline
// file /usr/include/openssl/x509.h line 875
char * X509_NAME_oneline(struct X509_name_st *, char *, signed int);
// X509_add_ext
// file /usr/include/openssl/x509.h line 1070
signed int X509_add_ext(struct x509_st *, struct X509_extension_st *, signed int);
// X509_check_private_key
// file /usr/include/openssl/x509.h line 957
signed int X509_check_private_key(struct x509_st *, struct evp_pkey_st *);
// X509_cmp_current_time
// file /usr/include/openssl/x509.h line 765
signed int X509_cmp_current_time(const struct asn1_string_st *);
// X509_digest
// file /usr/include/openssl/x509.h line 659
signed int X509_digest(const struct x509_st *, const struct env_md_st *, unsigned char *, unsigned int *);
// X509_free
// file /usr/include/openssl/x509.h line 823
void X509_free(struct x509_st *);
// X509_get_ext
// file /usr/include/openssl/x509.h line 1068
struct X509_extension_st * X509_get_ext(struct x509_st *, signed int);
// X509_get_ext_by_NID
// file /usr/include/openssl/x509.h line 1065
signed int X509_get_ext_by_NID(struct x509_st *, signed int, signed int);
// X509_get_ext_d2i
// file /usr/include/openssl/x509.h line 1071
void * X509_get_ext_d2i(struct x509_st *, signed int, signed int *, signed int *);
// X509_get_serialNumber
// file /usr/include/openssl/x509.h line 903
struct asn1_string_st * X509_get_serialNumber(struct x509_st *);
// X509_get_subject_name
// file /usr/include/openssl/x509.h line 907
struct X509_name_st * X509_get_subject_name(struct x509_st *);
// X509_gmtime_adj
// file /usr/include/openssl/x509.h line 769
struct asn1_string_st * X509_gmtime_adj(struct asn1_string_st *, signed long int);
// X509_new
// file /usr/include/openssl/x509.h line 823
struct x509_st * X509_new(void);
// X509_print
// file /usr/include/openssl/x509.h line 1001
signed int X509_print(struct bio_st *, struct x509_st *);
// X509_set_issuer_name
// file /usr/include/openssl/x509.h line 904
signed int X509_set_issuer_name(struct x509_st *, struct X509_name_st *);
// X509_set_pubkey
// file /usr/include/openssl/x509.h line 910
signed int X509_set_pubkey(struct x509_st *, struct evp_pkey_st *);
// X509_set_subject_name
// file /usr/include/openssl/x509.h line 906
signed int X509_set_subject_name(struct x509_st *, struct X509_name_st *);
// X509_set_version
// file /usr/include/openssl/x509.h line 901
signed int X509_set_version(struct x509_st *, signed long int);
// X509_sign
// file /usr/include/openssl/x509.h line 647
signed int X509_sign(struct x509_st *, struct evp_pkey_st *, const struct env_md_st *);
// __ac_X31_hash_string
// file khash.h line 387
static inline unsigned int __ac_X31_hash_string(const char *s);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// base64_dec
// file base64.h line 36
unsigned char * base64_dec(const char *in, unsigned long int insz, unsigned long int *outsz);
// base64_enc
// file base64.c line 144
char * base64_enc(const unsigned char *in, unsigned long int insz, unsigned long int *outsz);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous_8, unsigned int);
// bufferevent_disable
// file /usr/include/event2/bufferevent.h line 418
signed int bufferevent_disable(struct bufferevent *, signed short int);
// bufferevent_enable
// file /usr/include/event2/bufferevent.h line 408
signed int bufferevent_enable(struct bufferevent *, signed short int);
// bufferevent_free
// file /usr/include/event2/bufferevent.h line 282
void bufferevent_free(struct bufferevent *);
// bufferevent_free_and_close_fd
// file pxyconn.c line 1060
static void bufferevent_free_and_close_fd(struct bufferevent *bev, struct pxy_conn_ctx *ctx);
// bufferevent_get_input
// file /usr/include/event2/bufferevent.h line 384
struct evbuffer * bufferevent_get_input(struct bufferevent *);
// bufferevent_get_openssl_error
// file /usr/include/event2/bufferevent_ssl.h line 99
unsigned long int bufferevent_get_openssl_error(struct bufferevent *);
// bufferevent_get_output
// file /usr/include/event2/bufferevent.h line 398
struct evbuffer * bufferevent_get_output(struct bufferevent *);
// bufferevent_getfd
// file /usr/include/event2/bufferevent.h line 316
signed int bufferevent_getfd(struct bufferevent *);
// bufferevent_openssl_get_ssl
// file /usr/include/event2/bufferevent_ssl.h line 93
struct ssl_st * bufferevent_openssl_get_ssl(struct bufferevent *);
// bufferevent_openssl_socket_new
// file /usr/include/event2/bufferevent_ssl.h line 85
struct bufferevent * bufferevent_openssl_socket_new(struct event_base *, signed int, struct ssl_st *, enum bufferevent_ssl_state, signed int);
// bufferevent_setcb
// file /usr/include/event2/bufferevent.h line 299
void bufferevent_setcb(struct bufferevent *, void (*)(struct bufferevent *, void *), void (*)(struct bufferevent *, void *), void (*)(struct bufferevent *, signed short int, void *), void *);
// bufferevent_setwatermark
// file /usr/include/event2/bufferevent.h line 475
void bufferevent_setwatermark(struct bufferevent *, signed short int, unsigned long int, unsigned long int);
// bufferevent_socket_connect
// file /usr/include/event2/bufferevent.h line 205
signed int bufferevent_socket_connect(struct bufferevent *, struct sockaddr *, signed int);
// bufferevent_socket_new
// file /usr/include/event2/bufferevent.h line 184
struct bufferevent * bufferevent_socket_new(struct event_base *, signed int, signed int);
// cache_del
// file cache.h line 80
void cache_del(struct cache *cache, void *key);
// cache_free
// file cache.h line 76
void cache_free(struct cache *cache);
// cache_gc
// file cache.h line 77
void cache_gc(struct cache *cache);
// cache_get
// file cache.h line 78
void * cache_get(struct cache *cache, void *key);
// cache_new
// file cache.h line 74
struct cache * cache_new(void (*init_cb)(struct cache *));
// cache_new::init_cb_object
//
void init_cb_object(struct cache *);
// cache_reinit
// file cache.h line 75
void cache_reinit(struct cache *cache);
// cache_set
// file cache.h line 79
void cache_set(struct cache *cache, void *key, void *val);
// cachedsess_begin_cb
// file cachedsess.c line 74
static unsigned int cachedsess_begin_cb(void);
// cachedsess_del_cb
// file cachedsess.c line 92
static void cachedsess_del_cb(unsigned int it);
// cachedsess_end_cb
// file cachedsess.c line 80
static unsigned int cachedsess_end_cb(void);
// cachedsess_exist_cb
// file cachedsess.c line 86
static signed int cachedsess_exist_cb(unsigned int it);
// cachedsess_fini_cb
// file cachedsess.c line 161
static void cachedsess_fini_cb(void);
// cachedsess_free_key_cb
// file cachedsess.c line 110
static void cachedsess_free_key_cb(void *key);
// cachedsess_free_val_cb
// file cachedsess.c line 116
static void cachedsess_free_val_cb(void *val);
// cachedsess_get_cb
// file cachedsess.c line 98
static unsigned int cachedsess_get_cb(void *key);
// cachedsess_get_key_cb
// file cachedsess.c line 122
static void * cachedsess_get_key_cb(unsigned int it);
// cachedsess_get_val_cb
// file cachedsess.c line 128
static void * cachedsess_get_val_cb(unsigned int it);
// cachedsess_init_cb
// file cachedsess.h line 40
void cachedsess_init_cb(struct cache *cache);
// cachedsess_mkkey
// file cachedsess.h line 42
void * cachedsess_mkkey(struct sockaddr *addr, const unsigned int addrlen, const char *sni);
// cachedsess_mkval
// file cachedsess.h line 44
void * cachedsess_mkval(struct ssl_session_st *sess);
// cachedsess_put_cb
// file cachedsess.c line 104
static unsigned int cachedsess_put_cb(void *key, signed int *ret);
// cachedsess_set_val_cb
// file cachedsess.c line 134
static void cachedsess_set_val_cb(unsigned int it, void *val);
// cachedsess_unpackverify_val_cb
// file cachedsess.c line 140
static void * cachedsess_unpackverify_val_cb(void *val, signed int copy);
// cachefkcrt_begin_cb
// file cachefkcrt.c line 62
static unsigned int cachefkcrt_begin_cb(void);
// cachefkcrt_del_cb
// file cachefkcrt.c line 80
static void cachefkcrt_del_cb(unsigned int it);
// cachefkcrt_end_cb
// file cachefkcrt.c line 68
static unsigned int cachefkcrt_end_cb(void);
// cachefkcrt_exist_cb
// file cachefkcrt.c line 74
static signed int cachefkcrt_exist_cb(unsigned int it);
// cachefkcrt_fini_cb
// file cachefkcrt.c line 140
static void cachefkcrt_fini_cb(void);
// cachefkcrt_free_key_cb
// file cachefkcrt.c line 98
static void cachefkcrt_free_key_cb(void *key);
// cachefkcrt_free_val_cb
// file cachefkcrt.c line 104
static void cachefkcrt_free_val_cb(void *val);
// cachefkcrt_get_cb
// file cachefkcrt.c line 86
static unsigned int cachefkcrt_get_cb(void *key);
// cachefkcrt_get_key_cb
// file cachefkcrt.c line 110
static void * cachefkcrt_get_key_cb(unsigned int it);
// cachefkcrt_get_val_cb
// file cachefkcrt.c line 116
static void * cachefkcrt_get_val_cb(unsigned int it);
// cachefkcrt_init_cb
// file cachefkcrt.c line 146
void cachefkcrt_init_cb(struct cache *cache);
// cachefkcrt_mkkey
// file cachefkcrt.c line 166
void * cachefkcrt_mkkey(struct x509_st *keycrt);
// cachefkcrt_mkval
// file cachefkcrt.c line 177
void * cachefkcrt_mkval(struct x509_st *valcrt);
// cachefkcrt_put_cb
// file cachefkcrt.c line 92
static unsigned int cachefkcrt_put_cb(void *key, signed int *ret);
// cachefkcrt_set_val_cb
// file cachefkcrt.c line 122
static void cachefkcrt_set_val_cb(unsigned int it, void *val);
// cachefkcrt_unpackverify_val_cb
// file cachefkcrt.c line 128
static void * cachefkcrt_unpackverify_val_cb(void *val, signed int copy);
// cachemgr_fini
// file cachemgr.c line 107
void cachemgr_fini(void);
// cachemgr_gc
// file cachemgr.c line 122
void cachemgr_gc(void);
// cachemgr_gc_thread
// file cachemgr.c line 53
static void * cachemgr_gc_thread(void *arg);
// cachemgr_init
// file cachemgr.c line 92
signed int cachemgr_init(void);
// cachemgr_preinit
// file cachemgr.c line 65
signed int cachemgr_preinit(void);
// cachessess_begin_cb
// file cachessess.c line 72
static unsigned int cachessess_begin_cb(void);
// cachessess_del_cb
// file cachessess.c line 90
static void cachessess_del_cb(unsigned int it);
// cachessess_end_cb
// file cachessess.c line 78
static unsigned int cachessess_end_cb(void);
// cachessess_exist_cb
// file cachessess.c line 84
static signed int cachessess_exist_cb(unsigned int it);
// cachessess_fini_cb
// file cachessess.c line 159
static void cachessess_fini_cb(void);
// cachessess_free_key_cb
// file cachessess.c line 108
static void cachessess_free_key_cb(void *key);
// cachessess_free_val_cb
// file cachessess.c line 114
static void cachessess_free_val_cb(void *val);
// cachessess_get_cb
// file cachessess.c line 96
static unsigned int cachessess_get_cb(void *key);
// cachessess_get_key_cb
// file cachessess.c line 120
static void * cachessess_get_key_cb(unsigned int it);
// cachessess_get_val_cb
// file cachessess.c line 126
static void * cachessess_get_val_cb(unsigned int it);
// cachessess_init_cb
// file cachessess.h line 37
void cachessess_init_cb(struct cache *cache);
// cachessess_mkkey
// file cachessess.h line 39
void * cachessess_mkkey(const unsigned char *id, const unsigned long int idlen);
// cachessess_mkval
// file cachessess.h line 41
void * cachessess_mkval(struct ssl_session_st *sess);
// cachessess_put_cb
// file cachessess.c line 102
static unsigned int cachessess_put_cb(void *key, signed int *ret);
// cachessess_set_val_cb
// file cachessess.c line 132
static void cachessess_set_val_cb(unsigned int it, void *val);
// cachessess_unpackverify_val_cb
// file cachessess.c line 138
static void * cachessess_unpackverify_val_cb(void *val, signed int copy);
// cachetgcrt_begin_cb
// file cachetgcrt.c line 47
static unsigned int cachetgcrt_begin_cb(void);
// cachetgcrt_del_cb
// file cachetgcrt.c line 65
static void cachetgcrt_del_cb(unsigned int it);
// cachetgcrt_end_cb
// file cachetgcrt.c line 53
static unsigned int cachetgcrt_end_cb(void);
// cachetgcrt_exist_cb
// file cachetgcrt.c line 59
static signed int cachetgcrt_exist_cb(unsigned int it);
// cachetgcrt_fini_cb
// file cachetgcrt.c line 123
static void cachetgcrt_fini_cb(void);
// cachetgcrt_free_key_cb
// file cachetgcrt.c line 83
static void cachetgcrt_free_key_cb(void *key);
// cachetgcrt_free_val_cb
// file cachetgcrt.c line 89
static void cachetgcrt_free_val_cb(void *val);
// cachetgcrt_get_cb
// file cachetgcrt.c line 71
static unsigned int cachetgcrt_get_cb(void *key);
// cachetgcrt_get_key_cb
// file cachetgcrt.c line 95
static void * cachetgcrt_get_key_cb(unsigned int it);
// cachetgcrt_get_val_cb
// file cachetgcrt.c line 101
static void * cachetgcrt_get_val_cb(unsigned int it);
// cachetgcrt_init_cb
// file cachetgcrt.h line 36
void cachetgcrt_init_cb(struct cache *cache);
// cachetgcrt_mkkey
// file cachetgcrt.h line 38
void * cachetgcrt_mkkey(const char *keycn);
// cachetgcrt_mkval
// file cachetgcrt.h line 39
void * cachetgcrt_mkval(struct cert *valcrt);
// cachetgcrt_put_cb
// file cachetgcrt.c line 77
static unsigned int cachetgcrt_put_cb(void *key, signed int *ret);
// cachetgcrt_set_val_cb
// file cachetgcrt.c line 107
static void cachetgcrt_set_val_cb(unsigned int it, void *val);
// cachetgcrt_unpackverify_val_cb
// file cachetgcrt.c line 113
static void * cachetgcrt_unpackverify_val_cb(void *val, signed int copy);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cert_free
// file cert.c line 187
void cert_free(struct cert *c);
// cert_new
// file cert.c line 40
struct cert * cert_new(void);
// cert_new3
// file cert.c line 57
struct cert * cert_new3(struct evp_pkey_st *key, struct x509_st *crt, struct stack_st_X509 *chain);
// cert_new3_copy
// file cert.c line 76
struct cert * cert_new3_copy(struct evp_pkey_st *key, struct x509_st *crt, struct stack_st_X509 *chain);
// cert_new_load
// file cert.c line 99
struct cert * cert_new_load(const char *filename);
// cert_refcount_inc
// file cert.c line 129
void cert_refcount_inc(struct cert *c);
// cert_set_chain
// file cert.c line 166
void cert_set_chain(struct cert *c, struct stack_st_X509 *chain);
// cert_set_crt
// file cert.c line 153
void cert_set_crt(struct cert *c, struct x509_st *crt);
// cert_set_key
// file cert.c line 140
void cert_set_key(struct cert *c, struct evp_pkey_st *key);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// d2i_OCSP_REQUEST
// file /usr/include/openssl/ocsp.h line 556
struct ocsp_request_st * d2i_OCSP_REQUEST(struct ocsp_request_st **, const unsigned char **, signed long int);
// d2i_SSL_SESSION
// file /usr/include/openssl/ssl.h line 2249
struct ssl_session_st * d2i_SSL_SESSION(struct ssl_session_st **, const unsigned char **, signed long int);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// dirname
// file /usr/include/libgen.h line 26
extern char * dirname(char *);
// dynbuf_free
// file dynbuf.h line 45
void dynbuf_free(struct dynbuf *db);
// dynbuf_new
// file dynbuf.c line 117
struct dynbuf * dynbuf_new(unsigned char *buf, unsigned long int sz);
// dynbuf_new_alloc
// file dynbuf.h line 42
struct dynbuf * dynbuf_new_alloc(unsigned long int sz);
// dynbuf_new_copy
// file dynbuf.h line 43
struct dynbuf * dynbuf_new_copy(const unsigned char *buf, const unsigned long int sz);
// dynbuf_new_file
// file dynbuf.c line 81
struct dynbuf * dynbuf_new_file(const char *filename);
// endpwent
// file /usr/include/pwd.h line 78
extern void endpwent(void);
// evbuffer_add_buffer
// file /usr/include/event2/buffer.h line 411
signed int evbuffer_add_buffer(struct evbuffer *, struct evbuffer *);
// evbuffer_add_printf
// file /usr/include/event2/buffer.h line 477
signed int evbuffer_add_printf(struct evbuffer *, const char *, ...);
// evbuffer_copyout
// file /usr/include/event2/buffer.h line 342
signed long int evbuffer_copyout(struct evbuffer *, void *, unsigned long int);
// evbuffer_drain
// file /usr/include/event2/buffer.h line 505
signed int evbuffer_drain(struct evbuffer *, unsigned long int);
// evbuffer_get_length
// file /usr/include/event2/buffer.h line 218
unsigned long int evbuffer_get_length(struct evbuffer *);
// evbuffer_readln
// file /usr/include/event2/buffer.h line 396
char * evbuffer_readln(struct evbuffer *, unsigned long int *, enum evbuffer_eol_style);
// evconnlistener_free
// file /usr/include/event2/listener.h line 114
void evconnlistener_free(struct evconnlistener *);
// evconnlistener_get_base
// file /usr/include/event2/listener.h line 125
struct event_base * evconnlistener_get_base(struct evconnlistener *);
// evconnlistener_new
// file /usr/include/event2/listener.h line 90
struct evconnlistener * evconnlistener_new(struct event_base *, void (*)(struct evconnlistener *, signed int, struct sockaddr *, signed int, void *), void *, unsigned int, signed int, signed int);
// evconnlistener_set_error_cb
// file /usr/include/event2/listener.h line 136
void evconnlistener_set_error_cb(struct evconnlistener *, void (*)(struct evconnlistener *, void *));
// evdns_base_free
// file /usr/include/event2/dns.h line 231
void evdns_base_free(struct evdns_base *, signed int);
// evdns_base_new
// file /usr/include/event2/dns.h line 216
struct evdns_base * evdns_base_new(struct event_base *, signed int);
// evdns_base_resolv_conf_parse
// file /usr/include/event2/dns.h line 429
signed int evdns_base_resolv_conf_parse(struct evdns_base *, signed int, const char *);
// evdns_getaddrinfo
// file /usr/include/event2/dns.h line 628
struct evdns_getaddrinfo_request * evdns_getaddrinfo(struct evdns_base *, const char *, const char *, struct addrinfo *, void (*)(signed int, struct addrinfo *, void *), void *);
// event_add
// file /usr/include/event2/event.h line 937
signed int event_add(struct event *, struct timeval *);
// event_base_dispatch
// file /usr/include/event2/event.h line 364
signed int event_base_dispatch(struct event_base *);
// event_base_dump_events
// file /usr/include/event2/event.h line 1184
void event_base_dump_events(struct event_base *, struct _IO_FILE *);
// event_base_free
// file /usr/include/event2/event.h line 561
void event_base_free(struct event_base *);
// event_base_get_features
// file /usr/include/event2/event.h line 494
signed int event_base_get_features(struct event_base *);
// event_base_get_method
// file /usr/include/event2/event.h line 372
const char * event_base_get_method(struct event_base *);
// event_base_loopbreak
// file /usr/include/event2/event.h line 692
signed int event_base_loopbreak(struct event_base *);
// event_base_new
// file /usr/include/event2/event.h line 337
struct event_base * event_base_new(void);
// event_enable_debug_mode
// file /usr/include/event2/event.h line 317
void event_enable_debug_mode(void);
// event_free
// file /usr/include/event2/event.h line 889
void event_free(struct event *);
// event_get_version
// file /usr/include/event2/event.h line 1068
const char * event_get_version(void);
// event_new
// file /usr/include/event2/event.h line 840
struct event * event_new(struct event_base *, signed int, signed short int, void (*)(signed int, signed short int, void *), void *);
// event_reinit
// file /usr/include/event2/event.h line 349
signed int event_reinit(struct event_base *);
// evthread_use_pthreads
// file /usr/include/event2/thread.h line 208
signed int evthread_use_pthreads(void);
// evutil_closesocket
// file /usr/include/event2/util.h line 323
signed int evutil_closesocket(signed int);
// evutil_freeaddrinfo
// file /usr/include/event2/util.h line 645
void evutil_freeaddrinfo(struct addrinfo *);
// evutil_gai_strerror
// file /usr/include/event2/util.h line 647
const char * evutil_gai_strerror(signed int);
// evutil_getaddrinfo
// file /usr/include/event2/util.h line 641
signed int evutil_getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo **);
// evutil_make_listen_socket_reuseable
// file /usr/include/event2/util.h line 307
signed int evutil_make_listen_socket_reuseable(signed int);
// evutil_make_socket_nonblocking
// file /usr/include/event2/util.h line 294
signed int evutil_make_socket_nonblocking(signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// flock
// file /usr/include/x86_64-linux-gnu/sys/file.h line 51
extern signed int flock(signed int, signed int);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fsync
// file /usr/include/unistd.h line 956
extern signed int fsync(signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// fts_close
// file /usr/include/fts.h line 124
signed int fts_close(struct anonymous_21 *);
// fts_open
// file /usr/include/fts.h line 125
struct anonymous_21 * fts_open(char * const *, signed int, signed int (*)(const struct _ftsent **, const struct _ftsent **));
// fts_read
// file /usr/include/fts.h line 127
struct _ftsent * fts_read(struct anonymous_21 *);
// fts_set
// file /usr/include/fts.h line 128
signed int fts_set(struct anonymous_21 *, struct _ftsent *, signed int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getgrgid_r
// file /usr/include/grp.h line 143
extern signed int getgrgid_r(unsigned int, struct group *, char *, unsigned long int, struct group ** restrict );
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid_r
// file /usr/include/pwd.h line 144
extern signed int getpwuid_r(unsigned int, struct passwd *, char *, unsigned long int, struct passwd ** restrict );
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, union anonymous_8, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// i2d_SSL_SESSION
// file /usr/include/openssl/ssl.h line 2241
signed int i2d_SSL_SESSION(struct ssl_session_st *, unsigned char **);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// kh_del_cstrmap_t
// file cachetgcrt.c line 42
static inline void kh_del_cstrmap_t(struct anonymous_10 *h, unsigned int x);
// kh_del_dynbufmap_t
// file cachedsess.c line 68
static inline void kh_del_dynbufmap_t(struct anonymous_6 *h, unsigned int x);
// kh_del_dynbufmap_t_link1
// file cachessess.c line 66
static inline void kh_del_dynbufmap_t_link1(struct anonymous_6 *h_link1, unsigned int x_link1);
// kh_del_sha1map_t
// file cachefkcrt.c line 56
static inline void kh_del_sha1map_t(struct anonymous_12 *h, unsigned int x);
// kh_destroy_cstrmap_t
// file cachetgcrt.c line 42
static inline void kh_destroy_cstrmap_t(struct anonymous_10 *h);
// kh_destroy_dynbufmap_t
// file cachedsess.c line 68
static inline void kh_destroy_dynbufmap_t(struct anonymous_6 *h);
// kh_destroy_dynbufmap_t_link1
// file cachessess.c line 66
static inline void kh_destroy_dynbufmap_t_link1(struct anonymous_6 *h_link1);
// kh_destroy_sha1map_t
// file cachefkcrt.c line 56
static inline void kh_destroy_sha1map_t(struct anonymous_12 *h);
// kh_dynbuf_hash_func
// file cachedsess.c line 45
static inline unsigned int kh_dynbuf_hash_func(struct dynbuf *b);
// kh_dynbuf_hash_func_link1
// file cachessess.c line 43
static inline unsigned int kh_dynbuf_hash_func_link1(struct dynbuf *b_link1);
// kh_get_cstrmap_t
// file cachetgcrt.c line 42
static inline unsigned int kh_get_cstrmap_t(const struct anonymous_10 *h, char *key);
// kh_get_dynbufmap_t
// file cachedsess.c line 68
static inline unsigned int kh_get_dynbufmap_t(const struct anonymous_6 *h, struct dynbuf *key);
// kh_get_dynbufmap_t_link1
// file cachessess.c line 66
static inline unsigned int kh_get_dynbufmap_t_link1(const struct anonymous_6 *h_link1, struct dynbuf *key_link1);
// kh_get_sha1map_t
// file cachefkcrt.c line 56
static inline unsigned int kh_get_sha1map_t(const struct anonymous_12 *h, void *key);
// kh_init_cstrmap_t
// file cachetgcrt.c line 42
static inline struct anonymous_10 * kh_init_cstrmap_t(void);
// kh_init_dynbufmap_t
// file cachedsess.c line 68
static inline struct anonymous_6 * kh_init_dynbufmap_t(void);
// kh_init_dynbufmap_t_link1
// file cachessess.c line 66
static inline struct anonymous_6 * kh_init_dynbufmap_t_link1(void);
// kh_init_sha1map_t
// file cachefkcrt.c line 56
static inline struct anonymous_12 * kh_init_sha1map_t(void);
// kh_put_cstrmap_t
// file cachetgcrt.c line 42
static inline unsigned int kh_put_cstrmap_t(struct anonymous_10 *h, char *key, signed int *ret);
// kh_put_dynbufmap_t
// file cachedsess.c line 68
static inline unsigned int kh_put_dynbufmap_t(struct anonymous_6 *h, struct dynbuf *key, signed int *ret);
// kh_put_dynbufmap_t_link1
// file cachessess.c line 66
static inline unsigned int kh_put_dynbufmap_t_link1(struct anonymous_6 *h_link1, struct dynbuf *key_link1, signed int *ret_link1);
// kh_put_sha1map_t
// file cachefkcrt.c line 56
static inline unsigned int kh_put_sha1map_t(struct anonymous_12 *h, void *key, signed int *ret);
// kh_resize_cstrmap_t
// file cachetgcrt.c line 42
static inline signed int kh_resize_cstrmap_t(struct anonymous_10 *h, unsigned int new_n_buckets);
// kh_resize_dynbufmap_t
// file cachedsess.c line 68
static inline signed int kh_resize_dynbufmap_t(struct anonymous_6 *h, unsigned int new_n_buckets);
// kh_resize_dynbufmap_t_link1
// file cachessess.c line 66
static inline signed int kh_resize_dynbufmap_t_link1(struct anonymous_6 *h_link1, unsigned int new_n_buckets_link1);
// kh_resize_sha1map_t
// file cachefkcrt.c line 56
static inline signed int kh_resize_sha1map_t(struct anonymous_12 *h, unsigned int new_n_buckets);
// kh_x509fpr_hash_func
// file cachefkcrt.c line 42
static inline unsigned int kh_x509fpr_hash_func(void *b);
// log_connect_close
// file log.c line 210
static void log_connect_close(void);
// log_connect_open
// file log.c line 169
static signed int log_connect_open(const char *logfile);
// log_connect_writecb
// file log.c line 187
static signed long int log_connect_writecb(void *fh, const void *buf, unsigned long int sz);
// log_content_close
// file log.h line 65
signed int log_content_close(struct log_content_ctx **pctx);
// log_content_common_writecb
// file log.c line 507
static signed long int log_content_common_writecb(void *fh, const void *buf, unsigned long int sz);
// log_content_dir_closecb
// file log.c line 534
static void log_content_dir_closecb(void *fh);
// log_content_dir_opencb
// file log.c line 520
static signed int log_content_dir_opencb(void *fh);
// log_content_file_closecb
// file log.c line 603
static void log_content_file_closecb(void *fh);
// log_content_file_fini
// file log.c line 261
static void log_content_file_fini(void);
// log_content_file_preinit
// file log.c line 249
static signed int log_content_file_preinit(const char *logfile);
// log_content_file_prepcb
// file log.c line 618
static struct logbuf * log_content_file_prepcb(void *fh, unsigned long int prepflags, struct logbuf *lb);
// log_content_format_pathspec
// file log.c line 279
static char * log_content_format_pathspec(const char *logspec, char *srcaddr, char *dstaddr, char *exec_path, char *user, char *group);
// log_content_open
// file log.h line 61
signed int log_content_open(struct log_content_ctx **pctx, struct opts *opts, char *srcaddr, char *dstaddr, char *exec_path, char *user, char *group);
// log_content_spec_closecb
// file log.c line 583
static void log_content_spec_closecb(void *fh);
// log_content_spec_opencb
// file log.c line 546
static signed int log_content_spec_opencb(void *fh);
// log_content_submit
// file log.h line 63
signed int log_content_submit(struct log_content_ctx *ctx, struct logbuf *lb, signed int is_request);
// log_dbg_mode
// file log.h line 44
void log_dbg_mode(signed int mode);
// log_dbg_print_free
// file log.h line 42
signed int log_dbg_print_free(char *s);
// log_dbg_printf
// file log.h line 41
signed int log_dbg_printf(const char *fmt, ...);
// log_dbg_write_free
// file log.c line 115
signed int log_dbg_write_free(void *buf, unsigned long int sz);
// log_err_mode
// file log.h line 37
void log_err_mode(signed int mode);
// log_err_printf
// file log.h line 36
signed int log_err_printf(const char *fmt, ...);
// log_err_writecb
// file log.c line 65
static signed long int log_err_writecb(void *fh, const void *buf, unsigned long int sz);
// log_fini
// file log.h line 69
void log_fini(void);
// log_init
// file log.h line 68
signed int log_init(struct opts *opts);
// log_preinit
// file log.h line 67
signed int log_preinit(struct opts *opts);
// log_preinit::1::closecb_object
//
void closecb_object(void *);
// log_preinit::1::opencb_object
//
signed int opencb_object(void *);
// log_preinit::1::prepcb_object
//
struct logbuf * prepcb_object(void *, unsigned long int, struct logbuf *);
// log_preinit::1::writecb_object
//
signed long int writecb_object(void *, const void *, unsigned long int);
// logbuf_free
// file logbuf.h line 54
void logbuf_free(struct logbuf *lb);
// logbuf_new
// file logbuf.c line 47
struct logbuf * logbuf_new(void *buf, unsigned long int sz, void *fh, struct logbuf *next);
// logbuf_new_alloc
// file logbuf.h line 48
struct logbuf * logbuf_new_alloc(unsigned long int sz, void *fh, struct logbuf *next);
// logbuf_new_copy
// file logbuf.h line 49
struct logbuf * logbuf_new_copy(const void *buf, unsigned long int sz, void *fh, struct logbuf *next);
// logbuf_new_printf
// file logbuf.h line 50
struct logbuf * logbuf_new_printf(void *fh, struct logbuf *next, const char *fmt, ...);
// logbuf_size
// file logbuf.h line 52
signed long int logbuf_size(struct logbuf *lb);
// logbuf_write_free
// file logbuf.c line 149
signed long int logbuf_write_free(struct logbuf *lb, signed long int (*writefunc)(void *, const void *, unsigned long int));
// logbuf_write_free::writefunc_object
//
signed long int writefunc_object(void *, const void *, unsigned long int);
// logger_clear
// file logger.c line 59
static void logger_clear(struct logger *logger);
// logger_close
// file logger.h line 53
signed int logger_close(struct logger *logger, void *fh);
// logger_free
// file logger.h line 47
void logger_free(struct logger *logger);
// logger_join
// file logger.h line 50
signed int logger_join(struct logger *logger);
// logger_leave
// file logger.h line 49
void logger_leave(struct logger *logger);
// logger_new
// file logger.h line 44
struct logger * logger_new(signed int (*openfunc)(void *), void (*closefunc)(void *), signed long int (*writefunc)(void *, const void *, unsigned long int), struct logbuf * (*prepfunc)(void *, unsigned long int, struct logbuf *));
// logger_new::closefunc_object
//
void closefunc_object(void *);
// logger_new::openfunc_object
//
signed int openfunc_object(void *);
// logger_new::prepfunc_object
//
struct logbuf * prepfunc_object(void *, unsigned long int, struct logbuf *);
// logger_new::writefunc_object
//
signed long int writefunc_object(void *, const void *, unsigned long int);
// logger_open
// file logger.h line 52
signed int logger_open(struct logger *logger, void *fh);
// logger_print
// file logger.c line 273
signed int logger_print(struct logger *logger, void *fh, unsigned long int prepflags, const char *s);
// logger_print_freebuf
// file logger.h line 62
signed int logger_print_freebuf(struct logger *logger, void *fh, unsigned long int prepflags, char *s);
// logger_printf
// file logger.c line 244
signed int logger_printf(struct logger *logger, void *fh, unsigned long int prepflags, const char *fmt, ...);
// logger_start
// file logger.h line 48
signed int logger_start(struct logger *logger);
// logger_stop
// file logger.c line 224
signed int logger_stop(struct logger *logger);
// logger_submit
// file logger.h line 54
signed int logger_submit(struct logger *logger, void *fh, unsigned long int prepflags, struct logbuf *lb);
// logger_thread
// file logger.c line 159
static void * logger_thread(void *arg);
// logger_write
// file logger.c line 263
signed int logger_write(struct logger *logger, void *fh, unsigned long int prepflags, const void *buf, unsigned long int sz);
// logger_write_freebuf
// file logger.h line 64
signed int logger_write_freebuf(struct logger *logger, void *fh, unsigned long int prepflags, void *buf, unsigned long int sz);
// main_loadtgcrt
// file main.c line 192
static void main_loadtgcrt(const char *filename, void *arg);
// main_usage
// file main.c line 97
static void main_usage(void);
// main_version
// file main.c line 68
static void main_version(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// nat_exist
// file nat.c line 484
signed int nat_exist(const char *name);
// nat_fini
// file nat.c line 603
void nat_fini(void);
// nat_getdefaultname
// file nat.c line 459
const char * nat_getdefaultname(void);
// nat_getlookupcb
// file nat.c line 509
signed int (*nat_getlookupcb(const char *name))(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int);
// nat_getsocketcb
// file nat.c line 525
signed int (*nat_getsocketcb(const char *name))(signed int);
// nat_getsockname_lookup_cb
// file nat.c line 378
static signed int nat_getsockname_lookup_cb(struct sockaddr *dst_addr, unsigned int *dst_addrlen, signed int s, struct sockaddr *src_addr, unsigned int src_addrlen);
// nat_index
// file nat.c line 470
static signed int nat_index(const char *name);
// nat_init
// file nat.c line 588
signed int nat_init(void);
// nat_iptransparent_socket_cb
// file nat.c line 352
static signed int nat_iptransparent_socket_cb(signed int s);
// nat_ipv6ready
// file nat.c line 537
signed int nat_ipv6ready(const char *name);
// nat_list_engines
// file nat.c line 548
void nat_list_engines(void);
// nat_netfilter_lookup_cb
// file nat.c line 325
static signed int nat_netfilter_lookup_cb(struct sockaddr *dst_addr, unsigned int *dst_addrlen, signed int s, struct sockaddr *src_addr, unsigned int src_addrlen);
// nat_preinit
// file nat.c line 569
signed int nat_preinit(void);
// nat_used
// file nat.c line 496
signed int nat_used(const char *name);
// nat_version
// file nat.c line 615
void nat_version(void);
// oom_die
// file main.c line 248
void oom_die(const char *argv0);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opts_free
// file opts.c line 59
void opts_free(struct opts *opts);
// opts_has_ssl_spec
// file opts.c line 116
signed int opts_has_ssl_spec(struct opts *opts);
// opts_new
// file opts.c line 44
struct opts * opts_new(void);
// opts_proto_dbg_dump
// file opts.c line 216
void opts_proto_dbg_dump(struct opts *opts);
// opts_proto_disable
// file opts.c line 178
void opts_proto_disable(struct opts *opts, const char *optarg, const char *argv0);
// opts_proto_force
// file opts.c line 134
void opts_proto_force(struct opts *opts, const char *optarg, const char *argv0);
// proxy_debug_base
// file proxy.c line 145
static void proxy_debug_base(struct event_base *ev_base);
// proxy_free
// file proxy.h line 39
void proxy_free(struct proxy_ctx *ctx);
// proxy_gc_cb
// file proxy.c line 261
static void proxy_gc_cb(signed int fd, signed short int what, void *arg);
// proxy_listener_acceptcb
// file proxy.c line 117
static void proxy_listener_acceptcb(struct evconnlistener *listener, signed int fd, struct sockaddr *peeraddr, signed int peeraddrlen, void *arg);
// proxy_listener_ctx_free
// file proxy.c line 102
static void proxy_listener_ctx_free(struct proxy_listener_ctx *ctx);
// proxy_listener_ctx_new
// file proxy.c line 86
static struct proxy_listener_ctx * proxy_listener_ctx_new(struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts);
// proxy_listener_errorcb
// file proxy.c line 132
static void proxy_listener_errorcb(struct evconnlistener *listener, void *ctx);
// proxy_listener_setup
// file proxy.c line 163
static struct proxy_listener_ctx * proxy_listener_setup(struct event_base *evbase, struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts);
// proxy_new
// file proxy.h line 37
struct proxy_ctx * proxy_new(struct opts *opts);
// proxy_run
// file proxy.h line 38
void proxy_run(struct proxy_ctx *ctx);
// proxy_signal_cb
// file proxy.c line 242
static void proxy_signal_cb(signed int fd, signed short int what, void *arg);
// proxyspec_free
// file opts.c line 413
void proxyspec_free(struct proxyspec *spec);
// proxyspec_parse
// file opts.c line 263
struct proxyspec * proxyspec_parse(signed int *argc, char ***argv, const char *natengine);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_4 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_4 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_4 *, const union anonymous *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_4 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_4 *, union anonymous_0 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_0 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_0 *, const union anonymous *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_0 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pxy_bev_eventcb
// file pxyconn.c line 1635
static void pxy_bev_eventcb(struct bufferevent *bev, signed short int events, void *arg);
// pxy_bev_readcb
// file pxyconn.c line 1439
static void pxy_bev_readcb(struct bufferevent *bev, void *arg);
// pxy_bev_writecb
// file pxyconn.c line 1602
static void pxy_bev_writecb(struct bufferevent *bev, void *arg);
// pxy_bufferevent_setup
// file pxyconn.c line 1097
static struct bufferevent * pxy_bufferevent_setup(struct pxy_conn_ctx *ctx, signed int fd, struct ssl_st *ssl);
// pxy_conn_connect
// file pxyconn.c line 1949
static void pxy_conn_connect(struct pxy_conn_ctx *ctx);
// pxy_conn_ctx_free
// file pxyconn.c line 215
static void pxy_conn_ctx_free(struct pxy_conn_ctx *ctx);
// pxy_conn_ctx_new
// file pxyconn.c line 188
static struct pxy_conn_ctx * pxy_conn_ctx_new(struct proxyspec *spec, struct opts *opts, struct pxy_thrmgr_ctx *thrmgr, signed int fd);
// pxy_conn_setup
// file pxyconn.c line 2124
void pxy_conn_setup(signed int fd, struct sockaddr *peeraddr, signed int peeraddrlen, struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts);
// pxy_conn_terminate_free
// file pxyconn.c line 1421
void pxy_conn_terminate_free(struct pxy_conn_ctx *ctx);
// pxy_debug_crt
// file pxyconn.c line 301
static void pxy_debug_crt(struct x509_st *crt);
// pxy_dstssl_create
// file pxyconn.c line 960
static struct ssl_st * pxy_dstssl_create(struct pxy_conn_ctx *ctx);
// pxy_fd_readcb
// file pxyconn.c line 2030
static void pxy_fd_readcb(signed int fd, signed short int what, void *arg);
// pxy_http_reqhdr_filter_line
// file pxyconn.c line 1142
static char * pxy_http_reqhdr_filter_line(const char *line, struct pxy_conn_ctx *ctx);
// pxy_http_resphdr_filter_line
// file pxyconn.c line 1228
static char * pxy_http_resphdr_filter_line(const char *line, struct pxy_conn_ctx *ctx);
// pxy_log_connect_http
// file pxyconn.c line 419
static void pxy_log_connect_http(struct pxy_conn_ctx *ctx);
// pxy_log_connect_nonhttp
// file pxyconn.c line 336
static void pxy_log_connect_nonhttp(struct pxy_conn_ctx *ctx);
// pxy_ocsp_deny
// file pxyconn.c line 1355
static void pxy_ocsp_deny(struct pxy_conn_ctx *ctx);
// pxy_ocsp_is_valid_uri
// file pxyconn.c line 1299
static signed int pxy_ocsp_is_valid_uri(const char *uri, struct pxy_conn_ctx *ctx);
// pxy_ossl_servername_cb
// file pxyconn.c line 877
static signed int pxy_ossl_servername_cb(struct ssl_st *ssl, signed int *al, void *arg);
// pxy_ossl_sessget_cb
// file pxyconn.c line 580
static struct ssl_session_st * pxy_ossl_sessget_cb(struct ssl_st *ssl, unsigned char *id, signed int idlen, signed int *copy);
// pxy_ossl_sessnew_cb
// file pxyconn.c line 529
static signed int pxy_ossl_sessnew_cb(struct ssl_st *ssl, struct ssl_session_st *sess);
// pxy_ossl_sessremove_cb
// file pxyconn.c line 561
static void pxy_ossl_sessremove_cb(struct ssl_ctx_st *sslctx, struct ssl_session_st *sess);
// pxy_sni_resolve_cb
// file pxyconn.c line 1999
static void pxy_sni_resolve_cb(signed int errcode, struct addrinfo *ai, void *arg);
// pxy_srccert_create
// file pxyconn.c line 728
static struct cert * pxy_srccert_create(struct pxy_conn_ctx *ctx);
// pxy_srcssl_create
// file pxyconn.c line 810
static struct ssl_st * pxy_srcssl_create(struct pxy_conn_ctx *ctx, struct ssl_st *origssl);
// pxy_srcsslctx_create
// file pxyconn.c line 606
static struct ssl_ctx_st * pxy_srcsslctx_create(struct pxy_conn_ctx *ctx, struct x509_st *crt, struct stack_st_X509 *chain, struct evp_pkey_st *key);
// pxy_ssl_shutdown
// file pxysslshut.c line 168
void pxy_ssl_shutdown(struct opts *opts, struct event_base *evbase, struct ssl_st *ssl, signed int fd);
// pxy_ssl_shutdown_cb
// file pxysslshut.c line 90
static void pxy_ssl_shutdown_cb(signed int fd, signed short int what, void *arg);
// pxy_ssl_shutdown_ctx_free
// file pxysslshut.c line 78
static void pxy_ssl_shutdown_ctx_free(struct pxy_ssl_shutdown_ctx *ctx);
// pxy_ssl_shutdown_ctx_new
// file pxysslshut.c line 62
static struct pxy_ssl_shutdown_ctx * pxy_ssl_shutdown_ctx_new(struct opts *opts, struct event_base *evbase, struct ssl_st *ssl);
// pxy_thrmgr_attach
// file pxythrmgr.h line 47
signed int pxy_thrmgr_attach(struct pxy_thrmgr_ctx *ctx, struct event_base **evbase, struct evdns_base **dnsbase);
// pxy_thrmgr_detach
// file pxythrmgr.h line 49
void pxy_thrmgr_detach(struct pxy_thrmgr_ctx *ctx, signed int thridx);
// pxy_thrmgr_free
// file pxythrmgr.h line 45
void pxy_thrmgr_free(struct pxy_thrmgr_ctx *ctx);
// pxy_thrmgr_new
// file pxythrmgr.h line 43
struct pxy_thrmgr_ctx * pxy_thrmgr_new(struct opts *opts);
// pxy_thrmgr_run
// file pxythrmgr.h line 44
signed int pxy_thrmgr_run(struct pxy_thrmgr_ctx *ctx);
// pxy_thrmgr_thr
// file pxythrmgr.c line 76
static void * pxy_thrmgr_thr(void *arg);
// pxy_thrmgr_timer_cb
// file pxythrmgr.c line 65
static void pxy_thrmgr_timer_cb(signed int fd, signed short int what, void *arg);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// sk_dup
// file /usr/include/openssl/stack.h line 99
struct stack_st * sk_dup(struct stack_st *);
// sk_insert
// file /usr/include/openssl/stack.h line 87
signed int sk_insert(struct stack_st *, void *, signed int);
// sk_new_null
// file /usr/include/openssl/stack.h line 83
struct stack_st * sk_new_null(void);
// sk_num
// file /usr/include/openssl/stack.h line 77
signed int sk_num(const struct stack_st *);
// sk_pop_free
// file /usr/include/openssl/stack.h line 85
void sk_pop_free(struct stack_st *, void (*)(void *));
// sk_push
// file /usr/include/openssl/stack.h line 92
signed int sk_push(struct stack_st *, void *);
// sk_value
// file /usr/include/openssl/stack.h line 78
void * sk_value(const struct stack_st *, signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// ssl_dh_load
// file ssl.h line 120
struct dh_st * ssl_dh_load(const char *filename);
// ssl_dh_refcount_inc
// file ssl.c line 1096
void ssl_dh_refcount_inc(struct dh_st *dh);
// ssl_dnsname_match
// file ssl.c line 1162
signed int ssl_dnsname_match(const char *certname, unsigned long int certnamesz, const char *hostname, unsigned long int hostnamesz);
// ssl_ec_by_name
// file ssl.h line 126
struct ec_key_st * ssl_ec_by_name(const char *curvename);
// ssl_fini
// file ssl.h line 114
void ssl_fini(void);
// ssl_ia5string_strdup
// file ssl.c line 1369
static char * ssl_ia5string_strdup(struct asn1_string_st *ia5);
// ssl_init
// file ssl.c line 292
signed int ssl_init(void);
// ssl_is_ocspreq
// file ssl.h line 161
signed int ssl_is_ocspreq(const unsigned char *buf, unsigned long int sz);
// ssl_key_genrsa
// file ssl.h line 130
struct evp_pkey_st * ssl_key_genrsa(const signed int keysize);
// ssl_key_load
// file ssl.h line 129
struct evp_pkey_st * ssl_key_load(const char *filename);
// ssl_key_refcount_inc
// file ssl.h line 131
void ssl_key_refcount_inc(struct evp_pkey_st *key);
// ssl_openssl_version
// file ssl.h line 111
void ssl_openssl_version(void);
// ssl_rand
// file ssl.c line 670
signed int ssl_rand(void *p, unsigned long int sz);
// ssl_reinit
// file ssl.h line 113
void ssl_reinit(void);
// ssl_session_is_valid
// file ssl.c line 1533
signed int ssl_session_is_valid(struct ssl_session_st *sess);
// ssl_session_to_str
// file ssl.c line 1507
char * ssl_session_to_str(struct ssl_session_st *sess);
// ssl_ssl_state_to_str
// file ssl.h line 116
char * ssl_ssl_state_to_str(struct ssl_st *ssl);
// ssl_thr_dyn_create_cb
// file ssl.c line 232
static struct CRYPTO_dynlock_value * ssl_thr_dyn_create_cb(const char *file, signed int line);
// ssl_thr_dyn_destroy_cb
// file ssl.c line 260
static void ssl_thr_dyn_destroy_cb(struct CRYPTO_dynlock_value *dl, const char *file, signed int line);
// ssl_thr_dyn_lock_cb
// file ssl.c line 246
static void ssl_thr_dyn_lock_cb(signed int mode, struct CRYPTO_dynlock_value *dl, const char *file, signed int line);
// ssl_thr_id_cb
// file ssl.c line 280
static void ssl_thr_id_cb(struct crypto_threadid_st *id);
// ssl_thr_locking_cb
// file ssl.c line 218
static void ssl_thr_locking_cb(signed int mode, signed int type, const char *file, signed int line);
// ssl_tls_clienthello_parse_sni
// file ssl.h line 164
char * ssl_tls_clienthello_parse_sni(const unsigned char *buf, signed long int *sz);
// ssl_tmp_dh_callback
// file ssl.h line 119
struct dh_st * ssl_tmp_dh_callback(struct ssl_st *s, signed int is_export, signed int keylength);
// ssl_wildcardify
// file ssl.h line 169
char * ssl_wildcardify(const char *hostname);
// ssl_x509_aias
// file ssl.c line 1389
char ** ssl_x509_aias(struct x509_st *crt, const signed int type);
// ssl_x509_fingerprint_sha1
// file ssl.h line 144
signed int ssl_x509_fingerprint_sha1(struct x509_st *crt, unsigned char *fpr);
// ssl_x509_forge
// file ssl.h line 138
struct x509_st * ssl_x509_forge(struct x509_st *cacrt, struct evp_pkey_st *cakey, struct x509_st *origcrt, const char *extraname, struct evp_pkey_st *key);
// ssl_x509_is_valid
// file ssl.h line 150
signed int ssl_x509_is_valid(struct x509_st *crt);
// ssl_x509_load
// file ssl.h line 140
struct x509_st * ssl_x509_load(const char *filename);
// ssl_x509_names
// file ssl.h line 145
char ** ssl_x509_names(struct x509_st *crt);
// ssl_x509_names_match
// file ssl.h line 146
signed int ssl_x509_names_match(struct x509_st *crt, const char *dnsname);
// ssl_x509_names_to_str
// file ssl.h line 147
char * ssl_x509_names_to_str(struct x509_st *crt);
// ssl_x509_ocsps
// file ssl.c line 1428
char ** ssl_x509_ocsps(struct x509_st *crt);
// ssl_x509_refcount_inc
// file ssl.h line 153
void ssl_x509_refcount_inc(struct x509_st *crt);
// ssl_x509_serial_copyrand
// file ssl.c line 693
signed int ssl_x509_serial_copyrand(struct x509_st *dstcrt, struct x509_st *srccrt);
// ssl_x509_subject
// file ssl.h line 141
char * ssl_x509_subject(struct x509_st *crt);
// ssl_x509_subject_cn
// file ssl.c line 1057
char * ssl_x509_subject_cn(struct x509_st *crt, unsigned long int *psz);
// ssl_x509_to_pem
// file ssl.c line 1480
char * ssl_x509_to_pem(struct x509_st *crt);
// ssl_x509_to_str
// file ssl.c line 1453
char * ssl_x509_to_str(struct x509_st *crt);
// ssl_x509_v3ext_add
// file ssl.c line 626
signed int ssl_x509_v3ext_add(struct v3_ext_ctx *ctx, struct x509_st *crt, char *k, char *v);
// ssl_x509_v3ext_copy_by_nid
// file ssl.c line 648
signed int ssl_x509_v3ext_copy_by_nid(struct x509_st *crt, struct x509_st *origcrt, signed int nid);
// ssl_x509chain_load
// file ssl.h line 155
signed int ssl_x509chain_load(struct x509_st **crt, struct stack_st_X509 **chain, const char *filename);
// ssl_x509chain_use
// file ssl.c line 939
void ssl_x509chain_use(struct ssl_ctx_st *sslctx, struct x509_st *crt, struct stack_st_X509 *chain);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strpbrk
// file /usr/include/string.h line 314
extern char * strpbrk(const char *, const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// sys_dir_eachfile
// file sys.c line 437
signed int sys_dir_eachfile(const char *dirname, void (*cb)(const char *, void *), void *arg);
// sys_dir_eachfile::cb_object
//
void cb_object(const char *, void *);
// sys_get_cpu_cores
// file sys.c line 477
unsigned int sys_get_cpu_cores(void);
// sys_group_str
// file sys.c line 258
char * sys_group_str(unsigned int gid);
// sys_isdir
// file sys.c line 372
signed int sys_isdir(const char *path);
// sys_mkpath
// file sys.c line 389
signed int sys_mkpath(const char *path, unsigned int mode);
// sys_pidf_close
// file sys.c line 194
void sys_pidf_close(signed int fd, const char *fn);
// sys_pidf_open
// file sys.c line 149
signed int sys_pidf_open(const char *fn);
// sys_pidf_write
// file sys.c line 173
signed int sys_pidf_write(signed int fd);
// sys_privdrop
// file sys.c line 72
signed int sys_privdrop(const char *username, const char *groupname, const char *jaildir);
// sys_sockaddr_parse
// file sys.h line 47
signed int sys_sockaddr_parse(struct sockaddr_storage *addr, unsigned int *addrlen, char *naddr, char *nport, signed int af, signed int flags);
// sys_sockaddr_str
// file sys.c line 342
char * sys_sockaddr_str(struct sockaddr *addr, unsigned int addrlen);
// sys_user_str
// file sys.c line 205
char * sys_user_str(unsigned int uid);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// thrqueue_dequeue
// file thrqueue.c line 158
void * thrqueue_dequeue(struct thrqueue *queue);
// thrqueue_dequeue_nb
// file thrqueue.c line 184
void * thrqueue_dequeue_nb(struct thrqueue *queue);
// thrqueue_enqueue
// file thrqueue.c line 112
void * thrqueue_enqueue(struct thrqueue *queue, void *item);
// thrqueue_enqueue_nb
// file thrqueue.c line 136
void * thrqueue_enqueue_nb(struct thrqueue *queue, void *item);
// thrqueue_free
// file thrqueue.c line 96
void thrqueue_free(struct thrqueue *queue);
// thrqueue_new
// file thrqueue.c line 56
struct thrqueue * thrqueue_new(unsigned long int sz);
// thrqueue_unblock_dequeue
// file thrqueue.c line 222
void thrqueue_unblock_dequeue(struct thrqueue *queue);
// thrqueue_unblock_enqueue
// file thrqueue.c line 208
void thrqueue_unblock_enqueue(struct thrqueue *queue);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// url_dec
// file url.h line 36
char * url_dec(const char *in, unsigned long int insz, unsigned long int *outsz);
// util_skipws
// file util.h line 34
char * util_skipws(const char *s);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_3
{
  // filename
  char *filename;
};

struct anonymous_1
{
  // header_req
  char *header_req;
  // header_resp
  char *header_resp;
};

struct anonymous_21
{
  // fts_cur
  struct _ftsent *fts_cur;
  // fts_child
  struct _ftsent *fts_child;
  // fts_array
  struct _ftsent **fts_array;
  // fts_dev
  unsigned long int fts_dev;
  // fts_path
  char *fts_path;
  // fts_rfd
  signed int fts_rfd;
  // fts_pathlen
  signed int fts_pathlen;
  // fts_nitems
  signed int fts_nitems;
  // fts_compar
  signed int (*fts_compar)(const void *, const void *);
  // fts_options
  signed int fts_options;
};

struct anonymous_20
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous_5
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_17
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous_19
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

struct anonymous_10
{
  // n_buckets
  unsigned int n_buckets;
  // size
  unsigned int size;
  // n_occupied
  unsigned int n_occupied;
  // upper_bound
  unsigned int upper_bound;
  // flags
  unsigned int *flags;
  // keys
  char **keys;
  // vals
  void **vals;
};

struct anonymous_6
{
  // n_buckets
  unsigned int n_buckets;
  // size
  unsigned int size;
  // n_occupied
  unsigned int n_occupied;
  // upper_bound
  unsigned int upper_bound;
  // flags
  unsigned int *flags;
  // keys
  struct dynbuf **keys;
  // vals
  struct dynbuf **vals;
};

struct anonymous_12
{
  // n_buckets
  unsigned int n_buckets;
  // size
  unsigned int size;
  // n_occupied
  unsigned int n_occupied;
  // upper_bound
  unsigned int upper_bound;
  // flags
  unsigned int *flags;
  // keys
  void **keys;
  // vals
  void **vals;
};

union anonymous_15
{
  // inherit
  signed int *inherit;
  // asIdsOrRanges
  struct stack_st_ASIdOrRange *asIdsOrRanges;
};

union anonymous_18
{
  // ptr
  char *ptr;
  // otherName
  struct otherName_st *otherName;
  // rfc822Name
  struct asn1_string_st *rfc822Name;
  // dNSName
  struct asn1_string_st *dNSName;
  // x400Address
  struct asn1_type_st *x400Address;
  // directoryName
  struct X509_name_st *directoryName;
  // ediPartyName
  struct EDIPartyName_st *ediPartyName;
  // uniformResourceIdentifier
  struct asn1_string_st *uniformResourceIdentifier;
  // iPAddress
  struct asn1_string_st *iPAddress;
  // registeredID
  struct asn1_object_st *registeredID;
  // ip
  struct asn1_string_st *ip;
  // dirn
  struct X509_name_st *dirn;
  // ia5
  struct asn1_string_st *ia5;
  // rid
  struct asn1_object_st *rid;
  // other
  struct asn1_type_st *other;
};

union anonymous_13
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous_14
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous_16
{
  // fullname
  struct stack_st_GENERAL_NAME *fullname;
  // relativename
  struct stack_st_X509_NAME_ENTRY *relativename;
};

union anonymous_11
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous_9
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_2
{
  // file
  struct anonymous_1 file;
  // dir
  struct anonymous_3 dir;
  // spec
  struct anonymous_3 spec;
};

union anonymous_4
{
  // __data
  struct anonymous_5 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_7
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_8
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ACCESS_DESCRIPTION_st
{
  // method
  struct asn1_object_st *method;
  // location
  struct GENERAL_NAME_st *location;
};

struct ASIdentifierChoice_st
{
  // type
  signed int type;
  // u
  union anonymous_15 u;
};

struct ASIdentifiers_st
{
  // asnum
  struct ASIdentifierChoice_st *asnum;
  // rdi
  struct ASIdentifierChoice_st *rdi;
};

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct AUTHORITY_KEYID_st
{
  // keyid
  struct asn1_string_st *keyid;
  // issuer
  struct stack_st_GENERAL_NAME *issuer;
  // serial
  struct asn1_string_st *serial;
};

struct CRYPTO_dynlock_value
{
  // mutex
  union anonymous_0 mutex;
};

struct DIST_POINT_NAME_st
{
  // type
  signed int type;
  // name
  union anonymous_16 name;
  // dpname
  struct X509_name_st *dpname;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct EDIPartyName_st
{
  // nameAssigner
  struct asn1_string_st *nameAssigner;
  // partyName
  struct asn1_string_st *partyName;
};

struct GENERAL_NAME_st
{
  // type
  signed int type;
  // d
  union anonymous_18 d;
};

struct ISSUING_DIST_POINT_st
{
  // distpoint
  struct DIST_POINT_NAME_st *distpoint;
  // onlyuser
  signed int onlyuser;
  // onlyCA
  signed int onlyCA;
  // onlysomereasons
  struct asn1_string_st *onlysomereasons;
  // indirectCRL
  signed int indirectCRL;
  // onlyattr
  signed int onlyattr;
};

struct NAME_CONSTRAINTS_st
{
  // permittedSubtrees
  struct stack_st_GENERAL_SUBTREE *permittedSubtrees;
  // excludedSubtrees
  struct stack_st_GENERAL_SUBTREE *excludedSubtrees;
};

struct X509V3_CONF_METHOD_st
{
  // get_string
  char * (*get_string)(void *, char *, char *);
  // get_section
  struct stack_st_CONF_VALUE * (*get_section)(void *, char *);
  // free_string
  void (*free_string)(void *, char *);
  // free_section
  void (*free_section)(void *, struct stack_st_CONF_VALUE *);
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_extension_st
{
  // object
  struct asn1_object_st *object;
  // critical
  signed int critical;
  // value
  struct asn1_string_st *value;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_req_info_st
{
  // enc
  struct ASN1_ENCODING_st enc;
  // version
  struct asn1_string_st *version;
  // subject
  struct X509_name_st *subject;
  // pubkey
  struct X509_pubkey_st *pubkey;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct X509_req_st
{
  // req_info
  struct X509_req_info_st *req_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _ftsent
{
  // fts_cycle
  struct _ftsent *fts_cycle;
  // fts_parent
  struct _ftsent *fts_parent;
  // fts_link
  struct _ftsent *fts_link;
  // fts_number
  signed long int fts_number;
  // fts_pointer
  void *fts_pointer;
  // fts_accpath
  char *fts_accpath;
  // fts_path
  char *fts_path;
  // fts_errno
  signed int fts_errno;
  // fts_symfd
  signed int fts_symfd;
  // fts_pathlen
  unsigned short int fts_pathlen;
  // fts_namelen
  unsigned short int fts_namelen;
  // fts_ino
  unsigned long int fts_ino;
  // fts_dev
  unsigned long int fts_dev;
  // fts_nlink
  unsigned long int fts_nlink;
  // fts_level
  signed short int fts_level;
  // fts_info
  unsigned short int fts_info;
  // fts_flags
  unsigned short int fts_flags;
  // fts_instr
  unsigned short int fts_instr;
  // fts_statp
  struct stat *fts_statp;
  // fts_name
  char fts_name[1l];
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous_14 value;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous_11 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct cache
{
  // mutex
  union anonymous_0 mutex;
  // begin_cb
  unsigned int (*begin_cb)(void);
  // end_cb
  unsigned int (*end_cb)(void);
  // exist_cb
  signed int (*exist_cb)(unsigned int);
  // del_cb
  void (*del_cb)(unsigned int);
  // get_cb
  unsigned int (*get_cb)(void *);
  // put_cb
  unsigned int (*put_cb)(void *, signed int *);
  // free_key_cb
  void (*free_key_cb)(void *);
  // free_val_cb
  void (*free_val_cb)(void *);
  // get_key_cb
  void * (*get_key_cb)(unsigned int);
  // get_val_cb
  void * (*get_val_cb)(unsigned int);
  // set_val_cb
  void (*set_val_cb)(unsigned int, void *);
  // unpackverify_val_cb
  void * (*unpackverify_val_cb)(void *, signed int);
  // fini_cb
  void (*fini_cb)(void);
};

struct cert
{
  // key
  struct evp_pkey_st *key;
  // crt
  struct x509_st *crt;
  // chain
  struct stack_st_X509 *chain;
  // mutex
  union anonymous_0 mutex;
  // references
  unsigned long int references;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct crypto_threadid_st
{
  // ptr
  void *ptr;
  // val
  unsigned long int val;
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct dynbuf
{
  // buf
  unsigned char *buf;
  // sz
  unsigned long int sz;
};

struct engine
{
  // name
  const char *name;
  // ipv6
  unsigned int ipv6 : 1;
  // used
  unsigned int used : 1;
  // preinitcb
  signed int (*preinitcb)(void);
  // initcb
  signed int (*initcb)(void);
  // finicb
  void (*finicb)(void);
  // lookupcb
  signed int (*lookupcb)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int);
  // socketcb
  signed int (*socketcb)(signed int);
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous_13 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_9 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_CONF_VALUE
{
  // dummy
  signed int dummy;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct log_content_ctx
{
  // open
  unsigned int open : 1;
  // fd
  signed int fd;
  // u
  union anonymous_2 u;
};

struct logbuf
{
  // buf
  unsigned char *buf;
  // sz
  signed long int sz;
  // fh
  void *fh;
  // ctl
  unsigned long int ctl;
  // next
  struct logbuf *next;
};

struct logger
{
  // thr
  unsigned long int thr;
  // open
  signed int (*open)(void *);
  // close
  void (*close)(void *);
  // prep
  struct logbuf * (*prep)(void *, unsigned long int, struct logbuf *);
  // write
  signed long int (*write)(void *, const void *, unsigned long int);
  // queue
  struct thrqueue *queue;
};

struct ocsp_req_info_st
{
  // version
  struct asn1_string_st *version;
  // requestorName
  struct GENERAL_NAME_st *requestorName;
  // requestList
  struct stack_st_OCSP_ONEREQ *requestList;
  // requestExtensions
  struct stack_st_X509_EXTENSION *requestExtensions;
};

struct ocsp_request_st
{
  // tbsRequest
  struct ocsp_req_info_st *tbsRequest;
  // optionalSignature
  struct ocsp_signature_st *optionalSignature;
};

struct ocsp_signature_st
{
  // signatureAlgorithm
  struct X509_algor_st *signatureAlgorithm;
  // signature
  struct asn1_string_st *signature;
  // certs
  struct stack_st_X509 *certs;
};

struct opts
{
  // debug
  unsigned int debug : 1;
  // detach
  unsigned int detach : 1;
  // sslcomp
  unsigned int sslcomp : 1;
  // no_ssl3
  unsigned int no_ssl3 : 1;
  // no_tls10
  unsigned int no_tls10 : 1;
  // no_tls11
  unsigned int no_tls11 : 1;
  // no_tls12
  unsigned int no_tls12 : 1;
  // passthrough
  unsigned int passthrough : 1;
  // deny_ocsp
  unsigned int deny_ocsp : 1;
  // contentlog_isdir
  unsigned int contentlog_isdir : 1;
  // contentlog_isspec
  unsigned int contentlog_isspec : 1;
  // ciphers
  char *ciphers;
  // tgcrtdir
  char *tgcrtdir;
  // dropuser
  char *dropuser;
  // dropgroup
  char *dropgroup;
  // jaildir
  char *jaildir;
  // pidfile
  char *pidfile;
  // connectlog
  char *connectlog;
  // contentlog
  char *contentlog;
  // sslmethod
  const struct ssl_method_st * (*sslmethod)(void);
  // cacrt
  struct x509_st *cacrt;
  // cakey
  struct evp_pkey_st *cakey;
  // key
  struct evp_pkey_st *key;
  // chain
  struct stack_st_X509 *chain;
  // dh
  struct dh_st *dh;
  // ecdhcurve
  char *ecdhcurve;
  // spec
  struct proxyspec *spec;
};

struct otherName_st
{
  // type_id
  struct asn1_object_st *type_id;
  // value
  struct asn1_type_st *value;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct proxy_ctx
{
  // thrmgr
  struct pxy_thrmgr_ctx *thrmgr;
  // evbase
  struct event_base *evbase;
  // sev
  struct event *sev[4l];
  // gcev
  struct event *gcev;
  // lctx
  struct proxy_listener_ctx *lctx;
  // opts
  struct opts *opts;
};

struct proxy_listener_ctx
{
  // thrmgr
  struct pxy_thrmgr_ctx *thrmgr;
  // spec
  struct proxyspec *spec;
  // opts
  struct opts *opts;
  // evcl
  struct evconnlistener *evcl;
  // next
  struct proxy_listener_ctx *next;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct proxyspec
{
  // ssl
  unsigned int ssl : 1;
  // http
  unsigned int http : 1;
  // listen_addr
  struct sockaddr_storage listen_addr;
  // listen_addrlen
  unsigned int listen_addrlen;
  // connect_addr
  struct sockaddr_storage connect_addr;
  // connect_addrlen
  unsigned int connect_addrlen;
  // sni_port
  unsigned short int sni_port;
  // natengine
  char *natengine;
  // natlookup
  signed int (*natlookup)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int);
  // natsocket
  signed int (*natsocket)(signed int);
  // next
  struct proxyspec *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct pxy_conn_desc
{
  // bev
  struct bufferevent *bev;
  // ssl
  struct ssl_st *ssl;
  // closed
  unsigned int closed : 1;
};

struct pxy_conn_ctx
{
  // src
  struct pxy_conn_desc src;
  // dst
  struct pxy_conn_desc dst;
  // immutable_cert
  unsigned int immutable_cert : 1;
  // connected
  unsigned int connected : 1;
  // seen_req_header
  unsigned int seen_req_header : 1;
  // seen_resp_header
  unsigned int seen_resp_header : 1;
  // sent_http_conn_close
  unsigned int sent_http_conn_close : 1;
  // passthrough
  unsigned int passthrough : 1;
  // ocsp_denied
  unsigned int ocsp_denied : 1;
  // enomem
  unsigned int enomem : 1;
  // sni_peek_retries
  unsigned int sni_peek_retries : 6;
  // sni
  char *sni;
  // src_str
  char *src_str;
  // dst_str
  char *dst_str;
  // http_method
  char *http_method;
  // http_uri
  char *http_uri;
  // http_host
  char *http_host;
  // http_content_type
  char *http_content_type;
  // http_status_code
  char *http_status_code;
  // http_status_text
  char *http_status_text;
  // http_content_length
  char *http_content_length;
  // ssl_names
  char *ssl_names;
  // logctx
  struct log_content_ctx *logctx;
  // fd
  signed int fd;
  // ev
  struct event *ev;
  // addr
  struct sockaddr_storage addr;
  // addrlen
  unsigned int addrlen;
  // af
  signed int af;
  // origcrt
  struct x509_st *origcrt;
  // evbase
  struct event_base *evbase;
  // dnsbase
  struct evdns_base *dnsbase;
  // thridx
  signed int thridx;
  // thrmgr
  struct pxy_thrmgr_ctx *thrmgr;
  // spec
  struct proxyspec *spec;
  // opts
  struct opts *opts;
};

struct pxy_ssl_shutdown_ctx
{
  // opts
  struct opts *opts;
  // evbase
  struct event_base *evbase;
  // ev
  struct event *ev;
  // ssl
  struct ssl_st *ssl;
  // retries
  unsigned int retries;
};

struct pxy_thr_ctx
{
  // thr
  unsigned long int thr;
  // load
  unsigned long int load;
  // evbase
  struct event_base *evbase;
  // dnsbase
  struct evdns_base *dnsbase;
  // running
  signed int running;
};

struct pxy_thrmgr_ctx
{
  // num_thr
  signed int num_thr;
  // thr
  struct pxy_thr_ctx **thr;
  // mutex
  union anonymous_0 mutex;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous_19 tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous_20 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous_17 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ACCESS_DESCRIPTION
{
  // stack
  struct stack_st stack;
};

struct stack_st_ASIdOrRange
{
  // stack
  struct stack_st stack;
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_CONF_VALUE
{
  // stack
  struct stack_st stack;
};

struct stack_st_DIST_POINT
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_SUBTREE
{
  // stack
  struct stack_st stack;
};

struct stack_st_IPAddressFamily
{
  // stack
  struct stack_st stack;
};

struct stack_st_OCSP_ONEREQ
{
  // stack
  struct stack_st stack;
};

struct stack_st_OCSP_RESPID
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct thrqueue
{
  // data
  void **data;
  // sz
  unsigned long int sz;
  // n
  unsigned long int n;
  // in
  unsigned long int in;
  // out
  unsigned long int out;
  // block_enqueue
  unsigned int block_enqueue : 1;
  // block_dequeue
  unsigned int block_dequeue : 1;
  // mutex
  union anonymous_0 mutex;
  // notempty
  union anonymous_4 notempty;
  // notfull
  union anonymous_4 notfull;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct v3_ext_ctx
{
  // flags
  signed int flags;
  // issuer_cert
  struct x509_st *issuer_cert;
  // subject_cert
  struct x509_st *subject_cert;
  // subject_req
  struct X509_req_st *subject_req;
  // crl
  struct X509_crl_st *crl;
  // db_meth
  struct X509V3_CONF_METHOD_st *db_meth;
  // db
  void *db;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // rfc3779_addr
  struct stack_st_IPAddressFamily *rfc3779_addr;
  // rfc3779_asid
  struct ASIdentifiers_st *rfc3779_asid;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// __ac_HASH_UPPER
// file khash.h line 184
static const double __ac_HASH_UPPER = 0.77;
// __ac_HASH_UPPER_link1
// file khash.h line 184
static const double __ac_HASH_UPPER_link1 = 0.77;
// __ac_HASH_UPPER_link2
// file khash.h line 184
static const double __ac_HASH_UPPER_link2 = 0.77;
// __ac_HASH_UPPER_link3
// file khash.h line 184
static const double __ac_HASH_UPPER_link3 = 0.77;
// build_date
// file version.c line 36
const char *build_date = "2016-01-26";
// build_info
// file version.c line 37
const char *build_info = "V:FILE";
// cachemgr_dsess
// file cachemgr.c line 46
struct cache *cachemgr_dsess;
// cachemgr_fkcrt
// file cachemgr.c line 43
struct cache *cachemgr_fkcrt;
// cachemgr_ssess
// file cachemgr.c line 45
struct cache *cachemgr_ssess;
// cachemgr_tgcrt
// file cachemgr.c line 44
struct cache *cachemgr_tgcrt;
// certmap
// file cachefkcrt.c line 59
static struct anonymous_12 *certmap;
// certmap_link1
// file cachetgcrt.c line 44
static struct anonymous_10 *certmap_link1;
// connect_fd
// file log.c line 166
static signed int connect_fd = -1;
// connect_log
// file log.c line 165
struct logger *connect_log = (struct logger *)(void *)0;
// content_fd
// file log.c line 246
static signed int content_fd = -1;
// content_log
// file log.c line 245
struct logger *content_log = (struct logger *)(void *)0;
// dbg_mode
// file log.c line 112
static signed int dbg_mode = 0;
// dh1024_p
// file ssl.c line 456
static unsigned char dh1024_p[128l] = { (unsigned char)0x99, (unsigned char)0x28, (unsigned char)0x34, (unsigned char)0x48, (unsigned char)0x9E, (unsigned char)0xB7, (unsigned char)0xD1, (unsigned char)0x4F, (unsigned char)0x0D, (unsigned char)0x17, (unsigned char)0x09, (unsigned char)0x97, (unsigned char)0xB9, (unsigned char)0x9B, (unsigned char)0x20, (unsigned char)0xFE, (unsigned char)0xE5, (unsigned char)0x65, (unsigned char)0xE0, (unsigned char)0xE2, (unsigned char)0x56, (unsigned char)0x37, (unsigned char)0x80, (unsigned char)0xA2, (unsigned char)0x9F, (unsigned char)0x2C, (unsigned char)0x2D, (unsigned char)0x87, (unsigned char)0x10, (unsigned char)0x58, (unsigned char)0x39, (unsigned char)0xAD, (unsigned char)0xF3, (unsigned char)0xC5, (unsigned char)0xA9, (unsigned char)0x08, (unsigned char)0x24, (unsigned char)0xC7, (unsigned char)0xAA, (unsigned char)0xA9, (unsigned char)0x29, (unsigned char)0x3A, (unsigned char)0x13, (unsigned char)0xDF, (unsigned char)0x4E, (unsigned char)0x0A, (unsigned char)0x6D, (unsigned char)0x11, (unsigned char)0x39, (unsigned char)0xB1, (unsigned char)0x1C, (unsigned char)0x3F, (unsigned char)0xFE, (unsigned char)0xFE, (unsigned char)0x0A, (unsigned char)0x5E, (unsigned char)0xAD, (unsigned char)0x2E, (unsigned char)0x5C, (unsigned char)0x10, (unsigned char)0x97, (unsigned char)0x38, (unsigned char)0xAC, (unsigned char)0xE8, (unsigned char)0xEB, (unsigned char)0xAA, (unsigned char)0x4A, (unsigned char)0xA1, (unsigned char)0xC0, (unsigned char)0x5C, (unsigned char)0x1D, (unsigned char)0x27, (unsigned char)0x65, (unsigned char)0x9C, (unsigned char)0xC8, (unsigned char)0x53, (unsigned char)0xAC, (unsigned char)0x35, (unsigned char)0xDD, (unsigned char)0x84, (unsigned char)0x1F, (unsigned char)0x47, (unsigned char)0x0E, (unsigned char)0x04, (unsigned char)0xF1, (unsigned char)0x90, (unsigned char)0x61, (unsigned char)0x62, (unsigned char)0x2E, (unsigned char)0x29, (unsigned char)0x2C, (unsigned char)0xC6, (unsigned char)0x28, (unsigned char)0x91, (unsigned char)0x6D, (unsigned char)0xF0, (unsigned char)0xE2, (unsigned char)0x5E, (unsigned char)0xCE, (unsigned char)0x60, (unsigned char)0x3E, (unsigned char)0xF7, (unsigned char)0xF8, (unsigned char)0x37, (unsigned char)0x99, (unsigned char)0x4D, (unsigned char)0x9F, (unsigned char)0xFB, (unsigned char)0x68, (unsigned char)0xEC, (unsigned char)0x7F, (unsigned char)0x9D, (unsigned char)0x32, (unsigned char)0x74, (unsigned char)0xD1, (unsigned char)0xAA, (unsigned char)0xD4, (unsigned char)0x4C, (unsigned char)0xF5, (unsigned char)0xCD, (unsigned char)0xC2, (unsigned char)0xD7, (unsigned char)0xD7, (unsigned char)0xAC, (unsigned char)0xDA, (unsigned char)0x69, (unsigned char)0xF5, (unsigned char)0x2B };
// dh2048_p
// file ssl.c line 468
static unsigned char dh2048_p[256l] = { (unsigned char)0xAB, (unsigned char)0x88, (unsigned char)0x97, (unsigned char)0xCA, (unsigned char)0xF1, (unsigned char)0xE1, (unsigned char)0x60, (unsigned char)0x39, (unsigned char)0xFA, (unsigned char)0xB1, (unsigned char)0xA8, (unsigned char)0x7D, (unsigned char)0xB3, (unsigned char)0x7A, (unsigned char)0x38, (unsigned char)0x08, (unsigned char)0xF0, (unsigned char)0x7A, (unsigned char)0x3D, (unsigned char)0x21, (unsigned char)0xC4, (unsigned char)0xE6, (unsigned char)0xB8, (unsigned char)0x32, (unsigned char)0x3D, (unsigned char)0xAB, (unsigned char)0x0F, (unsigned char)0xE7, (unsigned char)0x8C, (unsigned char)0xA1, (unsigned char)0x59, (unsigned char)0x47, (unsigned char)0xB2, (unsigned char)0x0A, (unsigned char)0x7A, (unsigned char)0x3A, (unsigned char)0x20, (unsigned char)0x2A, (unsigned char)0x1B, (unsigned char)0xD4, (unsigned char)0xBA, (unsigned char)0xFC, (unsigned char)0x4C, (unsigned char)0xC5, (unsigned char)0xEE, (unsigned char)0xA2, (unsigned char)0xB9, (unsigned char)0xB9, (unsigned char)0x65, (unsigned char)0x47, (unsigned char)0xCC, (unsigned char)0x13, (unsigned char)0x99, (unsigned char)0xD7, (unsigned char)0xA6, (unsigned char)0xCA, (unsigned char)0xFF, (unsigned char)0x23, (unsigned char)0x05, (unsigned char)0x91, (unsigned char)0xAB, (unsigned char)0x5C, (unsigned char)0x82, (unsigned char)0xB8, (unsigned char)0xB4, (unsigned char)0xFD, (unsigned char)0xB1, (unsigned char)0x2E, (unsigned char)0x5B, (unsigned char)0x0F, (unsigned char)0x8E, (unsigned char)0x03, (unsigned char)0x3C, (unsigned char)0x23, (unsigned char)0xD6, (unsigned char)0x6A, (unsigned char)0xE2, (unsigned char)0x83, (unsigned char)0x95, (unsigned char)0xD2, (unsigned char)0x8E, (unsigned char)0xEB, (unsigned char)0xDF, (unsigned char)0x3A, (unsigned char)0xAF, (unsigned char)0x89, (unsigned char)0xF0, (unsigned char)0xA0, (unsigned char)0x14, (unsigned char)0x09, (unsigned char)0x12, (unsigned char)0xF6, (unsigned char)0x54, (unsigned char)0x54, (unsigned char)0x93, (unsigned char)0xF4, (unsigned char)0xD4, (unsigned char)0x41, (unsigned char)0x56, (unsigned char)0x7A, (unsigned char)0x0E, (unsigned char)0x56, (unsigned char)0x20, (unsigned char)0x1F, (unsigned char)0x1D, (unsigned char)0xBA, (unsigned char)0x3F, (unsigned char)0x07, (unsigned char)0xD2, (unsigned char)0x89, (unsigned char)0x1B, (unsigned char)0x40, (unsigned char)0xD0, (unsigned char)0x1C, (unsigned char)0x08, (unsigned char)0xDF, (unsigned char)0x00, (unsigned char)0x7F, (unsigned char)0x34, (unsigned char)0xF4, (unsigned char)0x28, (unsigned char)0x4E, (unsigned char)0xF7, (unsigned char)0x53, (unsigned char)0x8D, (unsigned char)0x4A, (unsigned char)0x00, (unsigned char)0xC3, (unsigned char)0xC0, (unsigned char)0x89, (unsigned char)0x9E, (unsigned char)0x63, (unsigned char)0x96, (unsigned char)0xE9, (unsigned char)0x52, (unsigned char)0xDF, (unsigned char)0xA5, (unsigned char)0x2C, (unsigned char)0x00, (unsigned char)0x4E, (unsigned char)0xB0, (unsigned char)0x82, (unsigned char)0x6A, (unsigned char)0x10, (unsigned char)0x28, (unsigned char)0x8D, (unsigned char)0xB9, (unsigned char)0xE7, (unsigned char)0x7A, (unsigned char)0xCB, (unsigned char)0xC3, (unsigned char)0xD6, (unsigned char)0xC1, (unsigned char)0xC0, (unsigned char)0x4D, (unsigned char)0x91, (unsigned char)0xC4, (unsigned char)0x6F, (unsigned char)0xD3, (unsigned char)0x99, (unsigned char)0xD1, (unsigned char)0x86, (unsigned char)0x71, (unsigned char)0x67, (unsigned char)0x0A, (unsigned char)0xA1, (unsigned char)0xFC, (unsigned char)0xF4, (unsigned char)0x7D, (unsigned char)0x40, (unsigned char)0x88, (unsigned char)0x8D, (unsigned char)0xAC, (unsigned char)0xCB, (unsigned char)0xBC, (unsigned char)0xEA, (unsigned char)0x17, (unsigned char)0x85, (unsigned char)0x0B, (unsigned char)0xC6, (unsigned char)0x12, (unsigned char)0x3E, (unsigned char)0x4A, (unsigned char)0xB9, (unsigned char)0x60, (unsigned char)0x74, (unsigned char)0x93, (unsigned char)0x54, (unsigned char)0x14, (unsigned char)0x39, (unsigned char)0x10, (unsigned char)0xBF, (unsigned char)0x21, (unsigned char)0xB0, (unsigned char)0x8B, (unsigned char)0xB1, (unsigned char)0x55, (unsigned char)0x3F, (unsigned char)0xBB, (unsigned char)0x6A, (unsigned char)0x1F, (unsigned char)0x42, (unsigned char)0x82, (unsigned char)0x0A, (unsigned char)0x40, (unsigned char)0x3A, (unsigned char)0x15, (unsigned char)0xCD, (unsigned char)0xD3, (unsigned char)0x79, (unsigned char)0xD0, (unsigned char)0x02, (unsigned char)0xA4, (unsigned char)0xF5, (unsigned char)0x79, (unsigned char)0x78, (unsigned char)0x03, (unsigned char)0xBD, (unsigned char)0x47, (unsigned char)0xCC, (unsigned char)0xD5, (unsigned char)0x08, (unsigned char)0x6A, (unsigned char)0x46, (unsigned char)0xAE, (unsigned char)0x36, (unsigned char)0xE4, (unsigned char)0xCD, (unsigned char)0xB1, (unsigned char)0x17, (unsigned char)0x48, (unsigned char)0x30, (unsigned char)0xB4, (unsigned char)0x02, (unsigned char)0xBC, (unsigned char)0x50, (unsigned char)0x68, (unsigned char)0xE3, (unsigned char)0xA2, (unsigned char)0x76, (unsigned char)0xD0, (unsigned char)0x5C, (unsigned char)0xB9, (unsigned char)0xE6, (unsigned char)0xBE, (unsigned char)0x4C, (unsigned char)0xFD, (unsigned char)0x50, (unsigned char)0xEF, (unsigned char)0xD0, (unsigned char)0x3F, (unsigned char)0x39, (unsigned char)0x4F, (unsigned char)0x53, (unsigned char)0x16, (unsigned char)0x3B };
// dh4096_p
// file ssl.c line 491
static unsigned char dh4096_p[512l] = { (unsigned char)0xB1, (unsigned char)0xCC, (unsigned char)0x09, (unsigned char)0x86, (unsigned char)0xEE, (unsigned char)0xF9, (unsigned char)0xB9, (unsigned char)0xC9, (unsigned char)0xB9, (unsigned char)0x87, (unsigned char)0xC4, (unsigned char)0xB9, (unsigned char)0xD7, (unsigned char)0x31, (unsigned char)0x95, (unsigned char)0x84, (unsigned char)0x94, (unsigned char)0x65, (unsigned char)0xED, (unsigned char)0x82, (unsigned char)0x64, (unsigned char)0x11, (unsigned char)0xA7, (unsigned char)0x0A, (unsigned char)0xFE, (unsigned char)0xC2, (unsigned char)0x60, (unsigned char)0xAE, (unsigned char)0x7C, (unsigned char)0x74, (unsigned char)0xFB, (unsigned char)0x72, (unsigned char)0x8F, (unsigned char)0x0D, (unsigned char)0xA6, (unsigned char)0xDD, (unsigned char)0x02, (unsigned char)0x49, (unsigned char)0x5B, (unsigned char)0x69, (unsigned char)0xD6, (unsigned char)0x96, (unsigned char)0x05, (unsigned char)0xBE, (unsigned char)0x5E, (unsigned char)0x9B, (unsigned char)0x09, (unsigned char)0x83, (unsigned char)0xD8, (unsigned char)0xF3, (unsigned char)0x91, (unsigned char)0x55, (unsigned char)0x30, (unsigned char)0x86, (unsigned char)0x97, (unsigned char)0x6C, (unsigned char)0x48, (unsigned char)0x7B, (unsigned char)0x99, (unsigned char)0x82, (unsigned char)0xCC, (unsigned char)0x1E, (unsigned char)0x1E, (unsigned char)0x25, (unsigned char)0xE6, (unsigned char)0x25, (unsigned char)0xCC, (unsigned char)0xA3, (unsigned char)0x66, (unsigned char)0xDE, (unsigned char)0x8A, (unsigned char)0x78, (unsigned char)0xEE, (unsigned char)0x7F, (unsigned char)0x4F, (unsigned char)0x86, (unsigned char)0x95, (unsigned char)0x06, (unsigned char)0xBE, (unsigned char)0x64, (unsigned char)0x86, (unsigned char)0xFD, (unsigned char)0x60, (unsigned char)0x6A, (unsigned char)0x3F, (unsigned char)0x0D, (unsigned char)0x8F, (unsigned char)0x62, (unsigned char)0x17, (unsigned char)0x89, (unsigned char)0xDB, (unsigned char)0xE1, (unsigned char)0x01, (unsigned char)0xC1, (unsigned char)0x75, (unsigned char)0x3A, (unsigned char)0x78, (unsigned char)0x42, (unsigned char)0xA8, (unsigned char)0x26, (unsigned char)0xEC, (unsigned char)0x00, (unsigned char)0x78, (unsigned char)0xF3, (unsigned char)0xDA, (unsigned char)0x40, (unsigned char)0x8D, (unsigned char)0x0D, (unsigned char)0x4D, (unsigned char)0x53, (unsigned char)0x82, (unsigned char)0xD7, (unsigned char)0x21, (unsigned char)0xC8, (unsigned char)0x46, (unsigned char)0xC9, (unsigned char)0xE3, (unsigned char)0x80, (unsigned char)0xB4, (unsigned char)0xCF, (unsigned char)0xEA, (unsigned char)0x46, (unsigned char)0x85, (unsigned char)0xE9, (unsigned char)0xC4, (unsigned char)0x9D, (unsigned char)0xD0, (unsigned char)0xC0, (unsigned char)0x4D, (unsigned char)0x27, (unsigned char)0x0F, (unsigned char)0xF8, (unsigned char)0x34, (unsigned char)0x3B, (unsigned char)0x86, (unsigned char)0x8F, (unsigned char)0xFC, (unsigned char)0x40, (unsigned char)0x56, (unsigned char)0x49, (unsigned char)0x64, (unsigned char)0x76, (unsigned char)0x61, (unsigned char)0xBC, (unsigned char)0x35, (unsigned char)0x6A, (unsigned char)0xB8, (unsigned char)0xC5, (unsigned char)0x32, (unsigned char)0x19, (unsigned char)0x00, (unsigned char)0x5E, (unsigned char)0x21, (unsigned char)0x1C, (unsigned char)0x34, (unsigned char)0xCB, (unsigned char)0x74, (unsigned char)0x5B, (unsigned char)0x60, (unsigned char)0x85, (unsigned char)0x8C, (unsigned char)0x38, (unsigned char)0x52, (unsigned char)0x50, (unsigned char)0x4D, (unsigned char)0xAA, (unsigned char)0x25, (unsigned char)0xE4, (unsigned char)0x1A, (unsigned char)0xE6, (unsigned char)0xE4, (unsigned char)0xDF, (unsigned char)0x0A, (unsigned char)0xD2, (unsigned char)0x8F, (unsigned char)0x2B, (unsigned char)0xD1, (unsigned char)0x35, (unsigned char)0xC7, (unsigned char)0x92, (unsigned char)0x7D, (unsigned char)0x6F, (unsigned char)0x54, (unsigned char)0x61, (unsigned char)0x8E, (unsigned char)0x3F, (unsigned char)0xFB, (unsigned char)0xE2, (unsigned char)0xC8, (unsigned char)0x81, (unsigned char)0xD0, (unsigned char)0xAC, (unsigned char)0x64, (unsigned char)0xE2, (unsigned char)0xA8, (unsigned char)0x30, (unsigned char)0xEA, (unsigned char)0x8E, (unsigned char)0xAD, (unsigned char)0xFE, (unsigned char)0xC0, (unsigned char)0x9E, (unsigned char)0x0B, (unsigned char)0xBF, (unsigned char)0x34, (unsigned char)0xAC, (unsigned char)0x79, (unsigned char)0x96, (unsigned char)0x38, (unsigned char)0x31, (unsigned char)0x1E, (unsigned char)0xEA, (unsigned char)0xF2, (unsigned char)0x7E, (unsigned char)0xEE, (unsigned char)0x0A, (unsigned char)0x10, (unsigned char)0x34, (unsigned char)0x7C, (unsigned char)0x1A, (unsigned char)0x30, (unsigned char)0x5F, (unsigned char)0xAF, (unsigned char)0x96, (unsigned char)0x2F, (unsigned char)0x7F, (unsigned char)0xB5, (unsigned char)0x1D, (unsigned char)0xA7, (unsigned char)0x3D, (unsigned char)0x35, (unsigned char)0x7A, (unsigned char)0x30, (unsigned char)0x70, (unsigned char)0x40, (unsigned char)0xE7, (unsigned char)0xD6, (unsigned char)0x22, (unsigned char)0x1E, (unsigned char)0xD0, (unsigned char)0x9A, (unsigned char)0x34, (unsigned char)0xC7, (unsigned char)0x6B, (unsigned char)0xE4, (unsigned char)0xF1, (unsigned char)0x78, (unsigned char)0xED, (unsigned char)0xD9, (unsigned char)0xCD, (unsigned char)0x18, (unsigned char)0xBF, (unsigned char)0x2A, (unsigned char)0x1A, (unsigned char)0x98, (unsigned char)0xB7, (unsigned char)0x6C, (unsigned char)0x6E, (unsigned char)0x18, (unsigned char)0x40, (unsigned char)0xB5, (unsigned char)0xBE, (unsigned char)0xDF, (unsigned char)0xE4, (unsigned char)0x78, (unsigned char)0x8E, (unsigned char)0x34, (unsigned char)0xB2, (unsigned char)0x7B, (unsigned char)0xE5, (unsigned char)0x88, (unsigned char)0xE6, (unsigned char)0xFD, (unsigned char)0x24, (unsigned char)0xBD, (unsigned char)0xBB, (unsigned char)0x2E, (unsigned char)0x30, (unsigned char)0x72, (unsigned char)0x54, (unsigned char)0xC7, (unsigned char)0xF4, (unsigned char)0xA0, (unsigned char)0xF1, (unsigned char)0x25, (unsigned char)0xFF, (unsigned char)0xB1, (unsigned char)0x37, (unsigned char)0x42, (unsigned char)0x07, (unsigned char)0x8C, (unsigned char)0xF2, (unsigned char)0xB9, (unsigned char)0xA1, (unsigned char)0xA4, (unsigned char)0xA7, (unsigned char)0x76, (unsigned char)0x39, (unsigned char)0xB8, (unsigned char)0x11, (unsigned char)0x17, (unsigned char)0xF3, (unsigned char)0xA8, (unsigned char)0x2E, (unsigned char)0x78, (unsigned char)0x68, (unsigned char)0xF4, (unsigned char)0xBF, (unsigned char)0x98, (unsigned char)0x25, (unsigned char)0x59, (unsigned char)0x17, (unsigned char)0x59, (unsigned char)0x9B, (unsigned char)0x0D, (unsigned char)0x0B, (unsigned char)0x9B, (unsigned char)0xE3, (unsigned char)0x0F, (unsigned char)0xFF, (unsigned char)0xDC, (unsigned char)0xC8, (unsigned char)0x47, (unsigned char)0x21, (unsigned char)0xE1, (unsigned char)0x0B, (unsigned char)0x9A, (unsigned char)0x44, (unsigned char)0x79, (unsigned char)0xC7, (unsigned char)0x5F, (unsigned char)0x8E, (unsigned char)0x83, (unsigned char)0x1E, (unsigned char)0x04, (unsigned char)0xA1, (unsigned char)0xB2, (unsigned char)0x9F, (unsigned char)0x9B, (unsigned char)0xFC, (unsigned char)0xB3, (unsigned char)0x4E, (unsigned char)0xD9, (unsigned char)0xF9, (unsigned char)0x8F, (unsigned char)0x03, (unsigned char)0xBC, (unsigned char)0x0A, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x5C, (unsigned char)0x59, (unsigned char)0xB7, (unsigned char)0x51, (unsigned char)0xAA, (unsigned char)0x75, (unsigned char)0xF8, (unsigned char)0x7A, (unsigned char)0x03, (unsigned char)0x07, (unsigned char)0x81, (unsigned char)0x6D, (unsigned char)0x67, (unsigned char)0x3E, (unsigned char)0x28, (unsigned char)0x37, (unsigned char)0xE4, (unsigned char)0x74, (unsigned char)0x5B, (unsigned char)0x8C, (unsigned char)0x2A, (unsigned char)0x4B, (unsigned char)0x6C, (unsigned char)0x10, (unsigned char)0x92, (unsigned char)0x75, (unsigned char)0xA5, (unsigned char)0x79, (unsigned char)0x4B, (unsigned char)0x6D, (unsigned char)0x30, (unsigned char)0xB7, (unsigned char)0x6E, (unsigned char)0xD6, (unsigned char)0x9E, (unsigned char)0x16, (unsigned char)0xC2, (unsigned char)0x87, (unsigned char)0x69, (unsigned char)0x34, (unsigned char)0xFE, (unsigned char)0xD7, (unsigned char)0x2A, (unsigned char)0x4F, (unsigned char)0xD6, (unsigned char)0xC0, (unsigned char)0xF3, (unsigned char)0xCD, (unsigned char)0x9C, (unsigned char)0x46, (unsigned char)0xED, (unsigned char)0xC0, (unsigned char)0xB2, (unsigned char)0x84, (unsigned char)0x8D, (unsigned char)0x7E, (unsigned char)0x93, (unsigned char)0xD2, (unsigned char)0xE9, (unsigned char)0xBE, (unsigned char)0x59, (unsigned char)0x18, (unsigned char)0x92, (unsigned char)0xC1, (unsigned char)0x2C, (unsigned char)0xD6, (unsigned char)0x6C, (unsigned char)0x71, (unsigned char)0x50, (unsigned char)0xA1, (unsigned char)0x98, (unsigned char)0xDA, (unsigned char)0xD1, (unsigned char)0xAC, (unsigned char)0xDB, (unsigned char)0x88, (unsigned char)0x40, (unsigned char)0x1F, (unsigned char)0x69, (unsigned char)0xDC, (unsigned char)0xDB, (unsigned char)0xB2, (unsigned char)0xA0, (unsigned char)0x90, (unsigned char)0x01, (unsigned char)0x8E, (unsigned char)0x12, (unsigned char)0xD6, (unsigned char)0x40, (unsigned char)0x1A, (unsigned char)0x8E, (unsigned char)0xC5, (unsigned char)0x69, (unsigned char)0x9C, (unsigned char)0x91, (unsigned char)0x67, (unsigned char)0xAC, (unsigned char)0xD8, (unsigned char)0x4C, (unsigned char)0x27, (unsigned char)0xCD, (unsigned char)0x08, (unsigned char)0xB8, (unsigned char)0x32, (unsigned char)0x97, (unsigned char)0xE1, (unsigned char)0x13, (unsigned char)0x0C, (unsigned char)0xFF, (unsigned char)0xB1, (unsigned char)0x06, (unsigned char)0x65, (unsigned char)0x03, (unsigned char)0x98, (unsigned char)0x6F, (unsigned char)0x9E, (unsigned char)0xF7, (unsigned char)0xB8, (unsigned char)0xA8, (unsigned char)0x75, (unsigned char)0xBA, (unsigned char)0x59, (unsigned char)0xFD, (unsigned char)0x23, (unsigned char)0x98, (unsigned char)0x94, (unsigned char)0x80, (unsigned char)0x9C, (unsigned char)0xA7, (unsigned char)0x46, (unsigned char)0x32, (unsigned char)0x98, (unsigned char)0x28, (unsigned char)0x7A, (unsigned char)0x0A, (unsigned char)0x3A, (unsigned char)0xA6, (unsigned char)0x95, (unsigned char)0x16, (unsigned char)0x6A, (unsigned char)0x52, (unsigned char)0x8E, (unsigned char)0x8F, (unsigned char)0x2C, (unsigned char)0xC9, (unsigned char)0x49, (unsigned char)0xB7, (unsigned char)0x59, (unsigned char)0x99, (unsigned char)0x2A, (unsigned char)0xE6, (unsigned char)0xCA, (unsigned char)0x82, (unsigned char)0x88, (unsigned char)0x36, (unsigned char)0xD3, (unsigned char)0x2B, (unsigned char)0xA4, (unsigned char)0x73, (unsigned char)0xFA, (unsigned char)0x89, (unsigned char)0xBB };
// dh512_p
// file ssl.c line 449
static unsigned char dh512_p[64l] = { (unsigned char)0xAB, (unsigned char)0xC0, (unsigned char)0x34, (unsigned char)0x16, (unsigned char)0x95, (unsigned char)0x8B, (unsigned char)0x57, (unsigned char)0xE5, (unsigned char)0x5C, (unsigned char)0xB3, (unsigned char)0x4E, (unsigned char)0x6E, (unsigned char)0x16, (unsigned char)0x0B, (unsigned char)0x35, (unsigned char)0xC5, (unsigned char)0x6A, (unsigned char)0xCC, (unsigned char)0x4F, (unsigned char)0xD3, (unsigned char)0xE5, (unsigned char)0x46, (unsigned char)0xE2, (unsigned char)0x23, (unsigned char)0x6A, (unsigned char)0x5B, (unsigned char)0xBB, (unsigned char)0x5D, (unsigned char)0x3D, (unsigned char)0x52, (unsigned char)0xEA, (unsigned char)0xCE, (unsigned char)0x4F, (unsigned char)0x7D, (unsigned char)0xCA, (unsigned char)0xFF, (unsigned char)0xB4, (unsigned char)0x8B, (unsigned char)0xC9, (unsigned char)0x78, (unsigned char)0xDC, (unsigned char)0xA0, (unsigned char)0xFC, (unsigned char)0xBE, (unsigned char)0xF3, (unsigned char)0xB5, (unsigned char)0xE6, (unsigned char)0x61, (unsigned char)0xA6, (unsigned char)0x6D, (unsigned char)0x58, (unsigned char)0xFC, (unsigned char)0xA0, (unsigned char)0x0F, (unsigned char)0xF7, (unsigned char)0x9B, (unsigned char)0x97, (unsigned char)0xE6, (unsigned char)0xC7, (unsigned char)0xE8, (unsigned char)0x1F, (unsigned char)0xCD, (unsigned char)0x16, (unsigned char)0x73 };
// dh_g
// file ssl.c line 448
static unsigned char dh_g[1l] = { (unsigned char)0x02 };
// dstsessmap
// file cachedsess.c line 71
static struct anonymous_6 *dstsessmap;
// engines
// file nat.c line 411
struct engine engines[3l];
// engines
// file nat.c line 411
struct engine engines[3l] = { { .name="netfilter", .ipv6=0, .used=0, .preinitcb=(signed int (*)(void))(void *)0, .initcb=(signed int (*)(void))(void *)0,
    .finicb=(void (*)(void))(void *)0,
    .lookupcb=nat_netfilter_lookup_cb, .socketcb=(signed int (*)(signed int))(void *)0 },
    { .name="tproxy", .ipv6=1, .used=0, .preinitcb=(signed int (*)(void))(void *)0, .initcb=(signed int (*)(void))(void *)0,
    .finicb=(void (*)(void))(void *)0,
    .lookupcb=nat_getsockname_lookup_cb, .socketcb=nat_iptransparent_socket_cb },
    { .name=(const char *)(void *)0, .ipv6=0, .used=0,
    .preinitcb=(signed int (*)(void))(void *)0, .initcb=(signed int (*)(void))(void *)0,
    .finicb=(void (*)(void))(void *)0,
    .lookupcb=(signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))(void *)0, .socketcb=(signed int (*)(signed int))(void *)0 } };
// err_log
// file log.c line 60
static struct logger *err_log = (struct logger *)(void *)0;
// err_mode
// file log.c line 62
static signed int err_mode = 0;
// err_started
// file log.c line 61
static signed int err_started = 0;
// features
// file version.c line 38
const char *features = "-DHAVE_NETFILTER";
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// signals
// file proxy.c line 59
static signed int signals[4l] = { 3, 1, 2, 13 };
// srcsessmap
// file cachessess.c line 69
static struct anonymous_6 *srcsessmap;
// ssl_initialized
// file ssl.c line 205
static signed int ssl_initialized = 0;
// ssl_mutex
// file ssl.c line 211
static union anonymous_0 *ssl_mutex;
// ssl_mutex_num
// file ssl.c line 212
static signed int ssl_mutex_num;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// version
// file version.c line 35
const char *version = "0.4.11";

// __ac_X31_hash_string
// file khash.h line 387
static inline unsigned int __ac_X31_hash_string(const char *s)
{
  unsigned int h = (unsigned int)*s;
  if(!(h == 0u))
  {
    s = s + 1l;
    for( ; !(*s == 0); s = s + 1l)
      h = ((h << 5) - h) + (unsigned int)*s;
  }

  return h;
}

// base64_dec
// file base64.h line 36
unsigned char * base64_dec(const char *in, unsigned long int insz, unsigned long int *outsz)
{
  unsigned long int i;
  unsigned long int o;
  signed int tmp;
  signed int digit;
  unsigned char *out;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(insz % 4ul == 0ul))
    return (unsigned char *)(void *)0;

  else
  {
    if(insz == 0ul)
    {
      *outsz = (unsigned long int)0;
      char *return_value_strdup_1;
      return_value_strdup_1=strdup("");
      return (unsigned char *)return_value_strdup_1;
    }

    if((signed int)in[-2l + (signed long int)insz] == 61)
      *outsz = (insz / (unsigned long int)4) * (unsigned long int)3 - (unsigned long int)2;

    else
      if((signed int)in[-1l + (signed long int)insz] == 61)
        *outsz = (insz / (unsigned long int)4) * (unsigned long int)3 - (unsigned long int)1;

      else
        *outsz = (insz / (unsigned long int)4) * (unsigned long int)3;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(*outsz + (unsigned long int)1);
    out = (unsigned char *)return_value_malloc_2;
    if(out == ((unsigned char *)NULL))
    {
      *outsz = (unsigned long int)0;
      return (unsigned char *)(void *)0;
    }

    else
    {
      i = (unsigned long int)0;
      o = (unsigned long int)0;
      for( ; !(i >= insz); o = o + (unsigned long int)3)
      {
        static const signed int revalphabet[256l] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
        digit = revalphabet[(signed long int)(unsigned char)in[(signed long int)i]];
        if(digit == -1)
          goto leave;

        tmp = digit << 18;
        digit = revalphabet[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)1)]];
        if(digit == -1)
          goto leave;

        tmp = tmp + (digit << 12);
        digit = revalphabet[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)2)]];
        if(digit == -1)
        {
          if(i == insz + 18446744073709551612ul)
            tmp_if_expr_3 = (signed int)in[(signed long int)(i + (unsigned long int)2)] == 61 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(tmp_if_expr_3)
            digit = 0;

          else
            goto leave;
        }

        tmp = tmp + (digit << 6);
        digit = revalphabet[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)3)]];
        if(digit == -1)
        {
          if(i == insz + 18446744073709551612ul)
            tmp_if_expr_4 = (signed int)in[(signed long int)(i + (unsigned long int)3)] == 61 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
            digit = 0;

          else
            goto leave;
        }

        tmp = tmp + digit;
        out[(signed long int)o] = (unsigned char)(tmp >> 16 & 0xff);
        if(!(1ul + o >= *outsz))
          out[(signed long int)(o + (unsigned long int)1)] = (unsigned char)(tmp >> 8 & 0xff);

        if(!(2ul + o >= *outsz))
          out[(signed long int)(o + (unsigned long int)2)] = (unsigned char)(tmp & 0xff);

        i = i + (unsigned long int)4;
      }
      out[(signed long int)*outsz] = (unsigned char)0;
      return out;

    leave:
      ;
      free((void *)out);
      return (unsigned char *)(void *)0;
    }
  }
}

// base64_enc
// file base64.c line 144
char * base64_enc(const unsigned char *in, unsigned long int insz, unsigned long int *outsz)
{
  unsigned long int i;
  unsigned long int o;
  char *out;
  if(insz == 0ul)
  {
    *outsz = (unsigned long int)0;
    char *return_value_strdup_1;
    return_value_strdup_1=strdup("");
    return return_value_strdup_1;
  }

  *outsz = ((insz + (unsigned long int)2) / (unsigned long int)3) * (unsigned long int)4;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(*outsz + (unsigned long int)1);
  out = (char *)return_value_malloc_2;
  if(out == ((char *)NULL))
  {
    *outsz = (unsigned long int)0;
    return (char *)(void *)0;
  }

  else
  {
    i = (unsigned long int)0;
    o = (unsigned long int)0;
    for( ; !(i >= insz); o = o + (unsigned long int)4)
    {
      signed int tmp = (signed int)in[(signed long int)i] << 16;
      if(!(1ul + i >= insz))
        tmp = tmp + ((signed int)in[(signed long int)(i + (unsigned long int)1)] << 8);

      if(!(2ul + i >= insz))
        tmp = tmp + (signed int)in[(signed long int)(i + (unsigned long int)2)];

      static const signed int alphabet[64l] = { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 };
      out[(signed long int)o] = (char)alphabet[(signed long int)(tmp >> 18 & 0x3f)];
      out[(signed long int)(o + (unsigned long int)1)] = (char)alphabet[(signed long int)(tmp >> 12 & 0x3f)];
      out[(signed long int)(o + (unsigned long int)2)] = (char)alphabet[(signed long int)(tmp >> 6 & 0x3f)];
      out[(signed long int)(o + (unsigned long int)3)] = (char)alphabet[(signed long int)(tmp & 0x3f)];
      if(!(insz >= 2ul + i))
        out[(signed long int)(o + (unsigned long int)2)] = (char)61;

      if(!(insz >= 3ul + i))
        out[(signed long int)(o + (unsigned long int)3)] = (char)61;

      i = i + (unsigned long int)3;
    }
    out[(signed long int)*outsz] = (char)0;
    return out;
  }
}

// bufferevent_free_and_close_fd
// file pxyconn.c line 1060
static void bufferevent_free_and_close_fd(struct bufferevent *bev, struct pxy_conn_ctx *ctx)
{
  signed int fd;
  fd=bufferevent_getfd(bev);
  struct ssl_st *ssl = (struct ssl_st *)(void *)0;
  if(!(ctx->spec->ssl == 0u))
  {
    if(ctx->passthrough == 0u)
      ssl=bufferevent_openssl_get_ssl(bev);

  }

  bufferevent_free(bev);
  if(!(ssl == ((struct ssl_st *)NULL)))
    pxy_ssl_shutdown(ctx->opts, ctx->evbase, ssl, fd);

  else
    evutil_closesocket(fd);
}

// cache_del
// file cache.h line 80
void cache_del(struct cache *cache, void *key)
{
  unsigned int it;
  pthread_mutex_lock(&cache->mutex);
  it=cache->get_cb(key);
  unsigned int return_value_2;
  return_value_2=cache->end_cb();
  if(!(it == return_value_2))
  {
    void *return_value;
    return_value=cache->get_val_cb(it);
    cache->free_val_cb(return_value);
    void *return_value_1;
    return_value_1=cache->get_key_cb(it);
    cache->free_key_cb(return_value_1);
    cache->del_cb(it);
  }

  cache->free_key_cb(key);
  pthread_mutex_unlock(&cache->mutex);
}

// cache_free
// file cache.h line 76
void cache_free(struct cache *cache)
{
  unsigned int it;
  it=cache->begin_cb();
  unsigned int return_value;
  return_value=cache->end_cb();
  if(!(it == return_value))
  {
    signed int return_value_3;
    return_value_3=cache->exist_cb(it);
    if(!(return_value_3 == 0))
    {
      void *return_value_1;
      return_value_1=cache->get_key_cb(it);
      cache->free_key_cb(return_value_1);
      void *return_value_2;
      return_value_2=cache->get_val_cb(it);
      cache->free_val_cb(return_value_2);
    }

    it = it + 1u;
  }

  cache->fini_cb();
  pthread_mutex_destroy(&cache->mutex);
  free((void *)cache);
}

// cache_gc
// file cache.h line 77
void cache_gc(struct cache *cache)
{
  unsigned int it;
  void *val;
  pthread_mutex_lock(&cache->mutex);
  it=cache->begin_cb();
  unsigned int return_value;
  return_value=cache->end_cb();
  if(!(it == return_value))
  {
    signed int return_value_3;
    return_value_3=cache->exist_cb(it);
    if(!(return_value_3 == 0))
    {
      val=cache->get_val_cb(it);
      void *return_value_2;
      return_value_2=cache->unpackverify_val_cb(val, 0);
      if(return_value_2 == NULL)
      {
        cache->free_val_cb(val);
        void *return_value_1;
        return_value_1=cache->get_key_cb(it);
        cache->free_key_cb(return_value_1);
        cache->del_cb(it);
      }

    }

    it = it + 1u;
  }

  pthread_mutex_unlock(&cache->mutex);
}

// cache_get
// file cache.h line 78
void * cache_get(struct cache *cache, void *key)
{
  void *rval = (void *)0;
  unsigned int it;
  if(key == NULL)
    return (void *)0;

  else
  {
    pthread_mutex_lock(&cache->mutex);
    it=cache->get_cb(key);
    unsigned int return_value_1;
    return_value_1=cache->end_cb();
    if(!(it == return_value_1))
    {
      void *val;
      val=cache->get_val_cb(it);
      rval=cache->unpackverify_val_cb(val, 1);
      if(rval == NULL)
      {
        cache->free_val_cb(val);
        void *return_value;
        return_value=cache->get_key_cb(it);
        cache->free_key_cb(return_value);
        cache->del_cb(it);
      }

    }

    cache->free_key_cb(key);
    pthread_mutex_unlock(&cache->mutex);
    return rval;
  }
}

// cache_new
// file cache.h line 74
struct cache * cache_new(void (*init_cb)(struct cache *))
{
  struct cache *cache;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct cache) /*144ul*/ );
  cache = (struct cache *)return_value_malloc_1;
  if(cache == ((struct cache *)NULL))
    return (struct cache *)(void *)0;

  else
  {
    init_cb(cache);
    pthread_mutex_init(&cache->mutex, (const union anonymous *)(void *)0);
    return cache;
  }
}

// cache_reinit
// file cache.h line 75
void cache_reinit(struct cache *cache)
{
  pthread_mutex_init(&cache->mutex, (const union anonymous *)(void *)0);
}

// cache_set
// file cache.h line 79
void cache_set(struct cache *cache, void *key, void *val)
{
  unsigned int it;
  signed int ret;
  if(!(key == NULL) && !(val == NULL))
  {
    pthread_mutex_lock(&cache->mutex);
    it=cache->put_cb(key, &ret);
    if(ret == 0)
    {
      cache->free_key_cb(key);
      void *return_value;
      return_value=cache->get_val_cb(it);
      cache->free_val_cb(return_value);
    }

    cache->set_val_cb(it, val);
    pthread_mutex_unlock(&cache->mutex);
  }

}

// cachedsess_begin_cb
// file cachedsess.c line 74
static unsigned int cachedsess_begin_cb(void)
{
  return (unsigned int)0;
}

// cachedsess_del_cb
// file cachedsess.c line 92
static void cachedsess_del_cb(unsigned int it)
{
  kh_del_dynbufmap_t(dstsessmap, it);
}

// cachedsess_end_cb
// file cachedsess.c line 80
static unsigned int cachedsess_end_cb(void)
{
  return dstsessmap->n_buckets;
}

// cachedsess_exist_cb
// file cachedsess.c line 86
static signed int cachedsess_exist_cb(unsigned int it)
{
  return (signed int)!((dstsessmap->flags[(signed long int)(it >> 4)] >> ((it & 0xfU) << 1) & (unsigned int)3) != 0u);
}

// cachedsess_fini_cb
// file cachedsess.c line 161
static void cachedsess_fini_cb(void)
{
  kh_destroy_dynbufmap_t(dstsessmap);
}

// cachedsess_free_key_cb
// file cachedsess.c line 110
static void cachedsess_free_key_cb(void *key)
{
  dynbuf_free((struct dynbuf *)key);
}

// cachedsess_free_val_cb
// file cachedsess.c line 116
static void cachedsess_free_val_cb(void *val)
{
  dynbuf_free((struct dynbuf *)val);
}

// cachedsess_get_cb
// file cachedsess.c line 98
static unsigned int cachedsess_get_cb(void *key)
{
  unsigned int return_value_kh_get_dynbufmap_t_1;
  return_value_kh_get_dynbufmap_t_1=kh_get_dynbufmap_t(dstsessmap, (struct dynbuf *)key);
  return return_value_kh_get_dynbufmap_t_1;
}

// cachedsess_get_key_cb
// file cachedsess.c line 122
static void * cachedsess_get_key_cb(unsigned int it)
{
  return (void *)dstsessmap->keys[(signed long int)it];
}

// cachedsess_get_val_cb
// file cachedsess.c line 128
static void * cachedsess_get_val_cb(unsigned int it)
{
  return (void *)dstsessmap->vals[(signed long int)it];
}

// cachedsess_init_cb
// file cachedsess.h line 40
void cachedsess_init_cb(struct cache *cache)
{
  dstsessmap=kh_init_dynbufmap_t();
  cache->begin_cb = cachedsess_begin_cb;
  cache->end_cb = cachedsess_end_cb;
  cache->exist_cb = cachedsess_exist_cb;
  cache->del_cb = cachedsess_del_cb;
  cache->get_cb = cachedsess_get_cb;
  cache->put_cb = cachedsess_put_cb;
  cache->free_key_cb = cachedsess_free_key_cb;
  cache->free_val_cb = cachedsess_free_val_cb;
  cache->get_key_cb = cachedsess_get_key_cb;
  cache->get_val_cb = cachedsess_get_val_cb;
  cache->set_val_cb = cachedsess_set_val_cb;
  cache->unpackverify_val_cb = cachedsess_unpackverify_val_cb;
  cache->fini_cb = cachedsess_fini_cb;
}

// cachedsess_mkkey
// file cachedsess.h line 42
void * cachedsess_mkkey(struct sockaddr *addr, const unsigned int addrlen, const char *sni)
{
  struct dynbuf tmp;
  struct dynbuf *db;
  signed short int port;
  unsigned long int snilen;
  switch((signed int)((struct sockaddr_storage *)addr)->ss_family)
  {
    case 2:
    {
      tmp.buf = (unsigned char *)&((struct sockaddr_in *)addr)->sin_addr;
      tmp.sz = sizeof(struct in_addr) /*4ul*/ ;
      port = (signed short int)((struct sockaddr_in *)addr)->sin_port;
      break;
    }
    case 10:
    {
      tmp.buf = (unsigned char *)&((struct sockaddr_in6 *)addr)->sin6_addr;
      tmp.sz = sizeof(struct in6_addr) /*16ul*/ ;
      port = (signed short int)((struct sockaddr_in6 *)addr)->sin6_port;
      break;
    }
    default:
      return (void *)0;
  }
  unsigned long int tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(!(sni == ((const char *)NULL)))
  {
    return_value_strlen_1=strlen(sni);
    tmp_if_expr_2 = return_value_strlen_1;
  }

  else
    tmp_if_expr_2 = (unsigned long int)0;
  snilen = tmp_if_expr_2;
  db=dynbuf_new_alloc(tmp.sz + sizeof(signed short int) /*2ul*/  + snilen);
  if(db == ((struct dynbuf *)NULL))
    return (void *)0;

  else
  {
    memcpy((void *)db->buf, (const void *)tmp.buf, tmp.sz);
    memcpy((void *)(db->buf + (signed long int)tmp.sz), (const void *)(char *)&port, sizeof(signed short int) /*2ul*/ );
    memcpy((void *)(db->buf + (signed long int)tmp.sz + (signed long int)sizeof(signed short int) /*2ul*/ ), (const void *)sni, snilen);
    return (void *)db;
  }
}

// cachedsess_mkval
// file cachedsess.h line 44
void * cachedsess_mkval(struct ssl_session_st *sess)
{
  struct dynbuf *db;
  unsigned char *p;
  unsigned long int asn1sz;
  signed int return_value_i2d_SSL_SESSION_1;
  return_value_i2d_SSL_SESSION_1=i2d_SSL_SESSION(sess, (unsigned char **)(void *)0);
  asn1sz = (unsigned long int)return_value_i2d_SSL_SESSION_1;
  _Bool tmp_if_expr_2;
  if(asn1sz == 0ul)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    db=dynbuf_new_alloc(asn1sz);
    tmp_if_expr_2 = !(db != ((struct dynbuf *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return (void *)0;

  else
  {
    p = db->buf;
    i2d_SSL_SESSION(sess, &p);
    return (void *)db;
  }
}

// cachedsess_put_cb
// file cachedsess.c line 104
static unsigned int cachedsess_put_cb(void *key, signed int *ret)
{
  unsigned int return_value_kh_put_dynbufmap_t_1;
  return_value_kh_put_dynbufmap_t_1=kh_put_dynbufmap_t(dstsessmap, (struct dynbuf *)key, ret);
  return return_value_kh_put_dynbufmap_t_1;
}

// cachedsess_set_val_cb
// file cachedsess.c line 134
static void cachedsess_set_val_cb(unsigned int it, void *val)
{
  dstsessmap->vals[(signed long int)it] = (struct dynbuf *)val;
}

// cachedsess_unpackverify_val_cb
// file cachedsess.c line 140
static void * cachedsess_unpackverify_val_cb(void *val, signed int copy)
{
  struct dynbuf *valbuf = (struct dynbuf *)val;
  struct ssl_session_st *sess;
  const unsigned char *p = (const unsigned char *)valbuf->buf;
  sess=d2i_SSL_SESSION((struct ssl_session_st **)(void *)0, &p, (signed long int)valbuf->sz);
  if(sess == ((struct ssl_session_st *)NULL))
    return (void *)0;

  else
  {
    signed int return_value_ssl_session_is_valid_1;
    return_value_ssl_session_is_valid_1=ssl_session_is_valid(sess);
    if(return_value_ssl_session_is_valid_1 == 0)
    {
      SSL_SESSION_free(sess);
      return (void *)0;
    }

    else
      if(!(copy == 0))
        return (void *)sess;

      else
      {
        SSL_SESSION_free(sess);
        return (void *)-1;
      }
  }
}

// cachefkcrt_begin_cb
// file cachefkcrt.c line 62
static unsigned int cachefkcrt_begin_cb(void)
{
  return (unsigned int)0;
}

// cachefkcrt_del_cb
// file cachefkcrt.c line 80
static void cachefkcrt_del_cb(unsigned int it)
{
  kh_del_sha1map_t(certmap, it);
}

// cachefkcrt_end_cb
// file cachefkcrt.c line 68
static unsigned int cachefkcrt_end_cb(void)
{
  return certmap->n_buckets;
}

// cachefkcrt_exist_cb
// file cachefkcrt.c line 74
static signed int cachefkcrt_exist_cb(unsigned int it)
{
  return (signed int)!((certmap->flags[(signed long int)(it >> 4)] >> ((it & 0xfU) << 1) & (unsigned int)3) != 0u);
}

// cachefkcrt_fini_cb
// file cachefkcrt.c line 140
static void cachefkcrt_fini_cb(void)
{
  kh_destroy_sha1map_t(certmap);
}

// cachefkcrt_free_key_cb
// file cachefkcrt.c line 98
static void cachefkcrt_free_key_cb(void *key)
{
  free(key);
}

// cachefkcrt_free_val_cb
// file cachefkcrt.c line 104
static void cachefkcrt_free_val_cb(void *val)
{
  X509_free((struct x509_st *)val);
}

// cachefkcrt_get_cb
// file cachefkcrt.c line 86
static unsigned int cachefkcrt_get_cb(void *key)
{
  unsigned int return_value_kh_get_sha1map_t_1;
  return_value_kh_get_sha1map_t_1=kh_get_sha1map_t(certmap, key);
  return return_value_kh_get_sha1map_t_1;
}

// cachefkcrt_get_key_cb
// file cachefkcrt.c line 110
static void * cachefkcrt_get_key_cb(unsigned int it)
{
  return certmap->keys[(signed long int)it];
}

// cachefkcrt_get_val_cb
// file cachefkcrt.c line 116
static void * cachefkcrt_get_val_cb(unsigned int it)
{
  return certmap->vals[(signed long int)it];
}

// cachefkcrt_init_cb
// file cachefkcrt.c line 146
void cachefkcrt_init_cb(struct cache *cache)
{
  certmap=kh_init_sha1map_t();
  cache->begin_cb = cachefkcrt_begin_cb;
  cache->end_cb = cachefkcrt_end_cb;
  cache->exist_cb = cachefkcrt_exist_cb;
  cache->del_cb = cachefkcrt_del_cb;
  cache->get_cb = cachefkcrt_get_cb;
  cache->put_cb = cachefkcrt_put_cb;
  cache->free_key_cb = cachefkcrt_free_key_cb;
  cache->free_val_cb = cachefkcrt_free_val_cb;
  cache->get_key_cb = cachefkcrt_get_key_cb;
  cache->get_val_cb = cachefkcrt_get_val_cb;
  cache->set_val_cb = cachefkcrt_set_val_cb;
  cache->unpackverify_val_cb = cachefkcrt_unpackverify_val_cb;
  cache->fini_cb = cachefkcrt_fini_cb;
}

// cachefkcrt_mkkey
// file cachefkcrt.c line 166
void * cachefkcrt_mkkey(struct x509_st *keycrt)
{
  unsigned char *fpr;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)20);
  fpr = (unsigned char *)return_value_malloc_1;
  if(fpr == ((unsigned char *)NULL))
    return (void *)0;

  else
  {
    ssl_x509_fingerprint_sha1(keycrt, fpr);
    return (void *)fpr;
  }
}

// cachefkcrt_mkval
// file cachefkcrt.c line 177
void * cachefkcrt_mkval(struct x509_st *valcrt)
{
  ssl_x509_refcount_inc(valcrt);
  return (void *)valcrt;
}

// cachefkcrt_put_cb
// file cachefkcrt.c line 92
static unsigned int cachefkcrt_put_cb(void *key, signed int *ret)
{
  unsigned int return_value_kh_put_sha1map_t_1;
  return_value_kh_put_sha1map_t_1=kh_put_sha1map_t(certmap, key, ret);
  return return_value_kh_put_sha1map_t_1;
}

// cachefkcrt_set_val_cb
// file cachefkcrt.c line 122
static void cachefkcrt_set_val_cb(unsigned int it, void *val)
{
  certmap->vals[(signed long int)it] = val;
}

// cachefkcrt_unpackverify_val_cb
// file cachefkcrt.c line 128
static void * cachefkcrt_unpackverify_val_cb(void *val, signed int copy)
{
  signed int return_value_ssl_x509_is_valid_1;
  return_value_ssl_x509_is_valid_1=ssl_x509_is_valid((struct x509_st *)val);
  if(return_value_ssl_x509_is_valid_1 == 0)
    return (void *)0;

  else
    if(!(copy == 0))
    {
      ssl_x509_refcount_inc((struct x509_st *)val);
      return val;
    }

    else
      return (void *)-1;
}

// cachemgr_fini
// file cachemgr.c line 107
void cachemgr_fini(void)
{
  cache_free(cachemgr_dsess);
  cache_free(cachemgr_ssess);
  cache_free(cachemgr_tgcrt);
  cache_free(cachemgr_fkcrt);
}

// cachemgr_gc
// file cachemgr.c line 122
void cachemgr_gc(void)
{
  unsigned long int fkcrt_thr;
  unsigned long int dsess_thr;
  unsigned long int ssess_thr;
  signed int rv;
  rv=pthread_create(&fkcrt_thr, (const union pthread_attr_t *)(void *)0, cachemgr_gc_thread, (void *)cachemgr_fkcrt);
  if(!(rv == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_create failed: %s\n", return_value_strerror_1);
  }

  rv=pthread_create(&ssess_thr, (const union pthread_attr_t *)(void *)0, cachemgr_gc_thread, (void *)cachemgr_ssess);
  if(!(rv == 0))
  {
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_create failed: %s\n", return_value_strerror_2);
  }

  rv=pthread_create(&dsess_thr, (const union pthread_attr_t *)(void *)0, cachemgr_gc_thread, (void *)cachemgr_dsess);
  if(!(rv == 0))
  {
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_create failed: %s\n", return_value_strerror_3);
  }

  rv=pthread_join(fkcrt_thr, (void **)(void *)0);
  if(!(rv == 0))
  {
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_join failed: %s\n", return_value_strerror_4);
  }

  rv=pthread_join(ssess_thr, (void **)(void *)0);
  if(!(rv == 0))
  {
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_join failed: %s\n", return_value_strerror_5);
  }

  rv=pthread_join(dsess_thr, (void **)(void *)0);
  if(!(rv == 0))
  {
    char *return_value_strerror_6;
    return_value_strerror_6=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_join failed: %s\n", return_value_strerror_6);
  }

}

// cachemgr_gc_thread
// file cachemgr.c line 53
static void * cachemgr_gc_thread(void *arg)
{
  cache_gc((struct cache *)arg);
  return (void *)0;
}

// cachemgr_init
// file cachemgr.c line 92
signed int cachemgr_init(void)
{
  cache_reinit(cachemgr_fkcrt);
  cache_reinit(cachemgr_tgcrt);
  cache_reinit(cachemgr_ssess);
  cache_reinit(cachemgr_dsess);
  return 0;
}

// cachemgr_preinit
// file cachemgr.c line 65
signed int cachemgr_preinit(void)
{
  cachemgr_fkcrt=cache_new(cachefkcrt_init_cb);
  if(!(cachemgr_fkcrt == ((struct cache *)NULL)))
  {
    cachemgr_tgcrt=cache_new(cachetgcrt_init_cb);
    if(!(cachemgr_tgcrt == ((struct cache *)NULL)))
    {
      cachemgr_ssess=cache_new(cachessess_init_cb);
      if(!(cachemgr_ssess == ((struct cache *)NULL)))
      {
        cachemgr_dsess=cache_new(cachedsess_init_cb);
        if(!(cachemgr_dsess == ((struct cache *)NULL)))
          return 0;


      out1:
        ;
        cache_free(cachemgr_ssess);
      }


    out2:
      ;
      cache_free(cachemgr_tgcrt);
    }


  out3:
    ;
    cache_free(cachemgr_fkcrt);
  }


out4:
  ;
  return -1;
}

// cachessess_begin_cb
// file cachessess.c line 72
static unsigned int cachessess_begin_cb(void)
{
  return (unsigned int)0;
}

// cachessess_del_cb
// file cachessess.c line 90
static void cachessess_del_cb(unsigned int it)
{
  kh_del_dynbufmap_t_link1(srcsessmap, it);
}

// cachessess_end_cb
// file cachessess.c line 78
static unsigned int cachessess_end_cb(void)
{
  return srcsessmap->n_buckets;
}

// cachessess_exist_cb
// file cachessess.c line 84
static signed int cachessess_exist_cb(unsigned int it)
{
  return (signed int)!((srcsessmap->flags[(signed long int)(it >> 4)] >> ((it & 0xfU) << 1) & (unsigned int)3) != 0u);
}

// cachessess_fini_cb
// file cachessess.c line 159
static void cachessess_fini_cb(void)
{
  kh_destroy_dynbufmap_t_link1(srcsessmap);
}

// cachessess_free_key_cb
// file cachessess.c line 108
static void cachessess_free_key_cb(void *key)
{
  dynbuf_free((struct dynbuf *)key);
}

// cachessess_free_val_cb
// file cachessess.c line 114
static void cachessess_free_val_cb(void *val)
{
  dynbuf_free((struct dynbuf *)val);
}

// cachessess_get_cb
// file cachessess.c line 96
static unsigned int cachessess_get_cb(void *key)
{
  unsigned int return_value_kh_get_dynbufmap_t_1;
  return_value_kh_get_dynbufmap_t_1=kh_get_dynbufmap_t_link1(srcsessmap, (struct dynbuf *)key);
  return return_value_kh_get_dynbufmap_t_1;
}

// cachessess_get_key_cb
// file cachessess.c line 120
static void * cachessess_get_key_cb(unsigned int it)
{
  return (void *)srcsessmap->keys[(signed long int)it];
}

// cachessess_get_val_cb
// file cachessess.c line 126
static void * cachessess_get_val_cb(unsigned int it)
{
  return (void *)srcsessmap->vals[(signed long int)it];
}

// cachessess_init_cb
// file cachessess.h line 37
void cachessess_init_cb(struct cache *cache)
{
  srcsessmap=kh_init_dynbufmap_t_link1();
  cache->begin_cb = cachessess_begin_cb;
  cache->end_cb = cachessess_end_cb;
  cache->exist_cb = cachessess_exist_cb;
  cache->del_cb = cachessess_del_cb;
  cache->get_cb = cachessess_get_cb;
  cache->put_cb = cachessess_put_cb;
  cache->free_key_cb = cachessess_free_key_cb;
  cache->free_val_cb = cachessess_free_val_cb;
  cache->get_key_cb = cachessess_get_key_cb;
  cache->get_val_cb = cachessess_get_val_cb;
  cache->set_val_cb = cachessess_set_val_cb;
  cache->unpackverify_val_cb = cachessess_unpackverify_val_cb;
  cache->fini_cb = cachessess_fini_cb;
}

// cachessess_mkkey
// file cachessess.h line 39
void * cachessess_mkkey(const unsigned char *id, const unsigned long int idlen)
{
  struct dynbuf *return_value_dynbuf_new_copy_1;
  return_value_dynbuf_new_copy_1=dynbuf_new_copy(id, idlen);
  return (void *)return_value_dynbuf_new_copy_1;
}

// cachessess_mkval
// file cachessess.h line 41
void * cachessess_mkval(struct ssl_session_st *sess)
{
  struct dynbuf *db;
  unsigned char *p;
  unsigned long int asn1sz;
  signed int return_value_i2d_SSL_SESSION_1;
  return_value_i2d_SSL_SESSION_1=i2d_SSL_SESSION(sess, (unsigned char **)(void *)0);
  asn1sz = (unsigned long int)return_value_i2d_SSL_SESSION_1;
  _Bool tmp_if_expr_2;
  if(asn1sz == 0ul)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    db=dynbuf_new_alloc(asn1sz);
    tmp_if_expr_2 = !(db != ((struct dynbuf *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return (void *)0;

  else
  {
    p = db->buf;
    i2d_SSL_SESSION(sess, &p);
    return (void *)db;
  }
}

// cachessess_put_cb
// file cachessess.c line 102
static unsigned int cachessess_put_cb(void *key, signed int *ret)
{
  unsigned int return_value_kh_put_dynbufmap_t_1;
  return_value_kh_put_dynbufmap_t_1=kh_put_dynbufmap_t_link1(srcsessmap, (struct dynbuf *)key, ret);
  return return_value_kh_put_dynbufmap_t_1;
}

// cachessess_set_val_cb
// file cachessess.c line 132
static void cachessess_set_val_cb(unsigned int it, void *val)
{
  srcsessmap->vals[(signed long int)it] = (struct dynbuf *)val;
}

// cachessess_unpackverify_val_cb
// file cachessess.c line 138
static void * cachessess_unpackverify_val_cb(void *val, signed int copy)
{
  struct dynbuf *valbuf = (struct dynbuf *)val;
  struct ssl_session_st *sess;
  const unsigned char *p = (const unsigned char *)valbuf->buf;
  sess=d2i_SSL_SESSION((struct ssl_session_st **)(void *)0, &p, (signed long int)valbuf->sz);
  if(sess == ((struct ssl_session_st *)NULL))
    return (void *)0;

  else
  {
    signed int return_value_ssl_session_is_valid_1;
    return_value_ssl_session_is_valid_1=ssl_session_is_valid(sess);
    if(return_value_ssl_session_is_valid_1 == 0)
    {
      SSL_SESSION_free(sess);
      return (void *)0;
    }

    else
      if(!(copy == 0))
        return (void *)sess;

      else
      {
        SSL_SESSION_free(sess);
        return (void *)-1;
      }
  }
}

// cachetgcrt_begin_cb
// file cachetgcrt.c line 47
static unsigned int cachetgcrt_begin_cb(void)
{
  return (unsigned int)0;
}

// cachetgcrt_del_cb
// file cachetgcrt.c line 65
static void cachetgcrt_del_cb(unsigned int it)
{
  kh_del_cstrmap_t(certmap_link1, it);
}

// cachetgcrt_end_cb
// file cachetgcrt.c line 53
static unsigned int cachetgcrt_end_cb(void)
{
  return certmap_link1->n_buckets;
}

// cachetgcrt_exist_cb
// file cachetgcrt.c line 59
static signed int cachetgcrt_exist_cb(unsigned int it)
{
  return (signed int)!((certmap_link1->flags[(signed long int)(it >> 4)] >> ((it & 0xfU) << 1) & (unsigned int)3) != 0u);
}

// cachetgcrt_fini_cb
// file cachetgcrt.c line 123
static void cachetgcrt_fini_cb(void)
{
  kh_destroy_cstrmap_t(certmap_link1);
}

// cachetgcrt_free_key_cb
// file cachetgcrt.c line 83
static void cachetgcrt_free_key_cb(void *key)
{
  free(key);
}

// cachetgcrt_free_val_cb
// file cachetgcrt.c line 89
static void cachetgcrt_free_val_cb(void *val)
{
  cert_free((struct cert *)val);
}

// cachetgcrt_get_cb
// file cachetgcrt.c line 71
static unsigned int cachetgcrt_get_cb(void *key)
{
  unsigned int return_value_kh_get_cstrmap_t_1;
  return_value_kh_get_cstrmap_t_1=kh_get_cstrmap_t(certmap_link1, (char *)key);
  return return_value_kh_get_cstrmap_t_1;
}

// cachetgcrt_get_key_cb
// file cachetgcrt.c line 95
static void * cachetgcrt_get_key_cb(unsigned int it)
{
  return (void *)certmap_link1->keys[(signed long int)it];
}

// cachetgcrt_get_val_cb
// file cachetgcrt.c line 101
static void * cachetgcrt_get_val_cb(unsigned int it)
{
  return certmap_link1->vals[(signed long int)it];
}

// cachetgcrt_init_cb
// file cachetgcrt.h line 36
void cachetgcrt_init_cb(struct cache *cache)
{
  certmap_link1=kh_init_cstrmap_t();
  cache->begin_cb = cachetgcrt_begin_cb;
  cache->end_cb = cachetgcrt_end_cb;
  cache->exist_cb = cachetgcrt_exist_cb;
  cache->del_cb = cachetgcrt_del_cb;
  cache->get_cb = cachetgcrt_get_cb;
  cache->put_cb = cachetgcrt_put_cb;
  cache->free_key_cb = cachetgcrt_free_key_cb;
  cache->free_val_cb = cachetgcrt_free_val_cb;
  cache->get_key_cb = cachetgcrt_get_key_cb;
  cache->get_val_cb = cachetgcrt_get_val_cb;
  cache->set_val_cb = cachetgcrt_set_val_cb;
  cache->unpackverify_val_cb = cachetgcrt_unpackverify_val_cb;
  cache->fini_cb = cachetgcrt_fini_cb;
}

// cachetgcrt_mkkey
// file cachetgcrt.h line 38
void * cachetgcrt_mkkey(const char *keycn)
{
  char *return_value_strdup_1;
  return_value_strdup_1=strdup(keycn);
  return (void *)return_value_strdup_1;
}

// cachetgcrt_mkval
// file cachetgcrt.h line 39
void * cachetgcrt_mkval(struct cert *valcrt)
{
  cert_refcount_inc(valcrt);
  return (void *)valcrt;
}

// cachetgcrt_put_cb
// file cachetgcrt.c line 77
static unsigned int cachetgcrt_put_cb(void *key, signed int *ret)
{
  unsigned int return_value_kh_put_cstrmap_t_1;
  return_value_kh_put_cstrmap_t_1=kh_put_cstrmap_t(certmap_link1, (char *)key, ret);
  return return_value_kh_put_cstrmap_t_1;
}

// cachetgcrt_set_val_cb
// file cachetgcrt.c line 107
static void cachetgcrt_set_val_cb(unsigned int it, void *val)
{
  certmap_link1->vals[(signed long int)it] = val;
}

// cachetgcrt_unpackverify_val_cb
// file cachetgcrt.c line 113
static void * cachetgcrt_unpackverify_val_cb(void *val, signed int copy)
{
  if(!(copy == 0))
  {
    cert_refcount_inc((struct cert *)val);
    return val;
  }

  else
    return (void *)-1;
}

// cert_free
// file cert.c line 187
void cert_free(struct cert *c)
{
  pthread_mutex_lock(&c->mutex);
  c->references = c->references - 1ul;
  if(!(c->references == 0ul))
    pthread_mutex_unlock(&c->mutex);

  else
  {
    pthread_mutex_unlock(&c->mutex);
    pthread_mutex_destroy(&c->mutex);
    if(!(c->key == ((struct evp_pkey_st *)NULL)))
      EVP_PKEY_free(c->key);

    if(!(c->crt == ((struct x509_st *)NULL)))
      X509_free(c->crt);

    if(!(c->chain == ((struct stack_st_X509 *)NULL)))
      sk_pop_free((struct stack_st *)c->chain, (void (*)(void *))(1 != 0 ? X509_free : (void (*)(struct x509_st *))0));

    free((void *)c);
  }
}

// cert_new
// file cert.c line 40
struct cert * cert_new(void)
{
  struct cert *c;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct cert) /*72ul*/ );
  c = (struct cert *)return_value_malloc_1;
  if(c == ((struct cert *)NULL))
    return (struct cert *)(void *)0;

  else
  {
    memset((void *)c, 0, sizeof(struct cert) /*72ul*/ );
    c->references = (unsigned long int)1;
    pthread_mutex_init(&c->mutex, (const union anonymous *)(void *)0);
    return c;
  }
}

// cert_new3
// file cert.c line 57
struct cert * cert_new3(struct evp_pkey_st *key, struct x509_st *crt, struct stack_st_X509 *chain)
{
  struct cert *c;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct cert) /*72ul*/ );
  c = (struct cert *)return_value_malloc_1;
  if(c == ((struct cert *)NULL))
    return (struct cert *)(void *)0;

  else
  {
    c->key = key;
    c->crt = crt;
    c->chain = chain;
    c->references = (unsigned long int)1;
    pthread_mutex_init(&c->mutex, (const union anonymous *)(void *)0);
    return c;
  }
}

// cert_new3_copy
// file cert.c line 76
struct cert * cert_new3_copy(struct evp_pkey_st *key, struct x509_st *crt, struct stack_st_X509 *chain)
{
  struct cert *c;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct cert) /*72ul*/ );
  c = (struct cert *)return_value_malloc_1;
  signed int return_value_sk_num_3;
  if(c == ((struct cert *)NULL))
    return (struct cert *)(void *)0;

  else
  {
    c->key = key;
    ssl_key_refcount_inc(c->key);
    c->crt = crt;
    ssl_x509_refcount_inc(c->crt);
    struct stack_st *return_value_sk_dup_2;
    return_value_sk_dup_2=sk_dup((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0));
    c->chain = (struct stack_st_X509 *)return_value_sk_dup_2;
    signed int i = 0;
    do
    {
      return_value_sk_num_3=sk_num((struct stack_st *)c->chain);
      if(i >= return_value_sk_num_3)
        break;

      void *return_value_sk_value_4;
      return_value_sk_value_4=sk_value((struct stack_st *)c->chain, i);
      ssl_x509_refcount_inc((struct x509_st *)return_value_sk_value_4);
      i = i + 1;
    }
    while((_Bool)1);
    c->references = (unsigned long int)1;
    pthread_mutex_init(&c->mutex, (const union anonymous *)(void *)0);
    return c;
  }
}

// cert_new_load
// file cert.c line 99
struct cert * cert_new_load(const char *filename)
{
  struct cert *c;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct cert) /*72ul*/ );
  c = (struct cert *)return_value_malloc_1;
  if(c == ((struct cert *)NULL))
    return (struct cert *)(void *)0;

  else
  {
    memset((void *)c, 0, sizeof(struct cert) /*72ul*/ );
    signed int return_value_ssl_x509chain_load_2;
    return_value_ssl_x509chain_load_2=ssl_x509chain_load(&c->crt, &c->chain, filename);
    if(return_value_ssl_x509chain_load_2 == -1)
    {
      free((void *)c);
      return (struct cert *)(void *)0;
    }

    else
    {
      c->key=ssl_key_load(filename);
      if(c->key == ((struct evp_pkey_st *)NULL))
      {
        X509_free(c->crt);
        if(!(c->chain == ((struct stack_st_X509 *)NULL)))
          sk_pop_free((struct stack_st *)c->chain, (void (*)(void *))(1 != 0 ? X509_free : (void (*)(struct x509_st *))0));

        free((void *)c);
        return (struct cert *)(void *)0;
      }

      else
      {
        c->references = (unsigned long int)1;
        pthread_mutex_init(&c->mutex, (const union anonymous *)(void *)0);
        return c;
      }
    }
  }
}

// cert_refcount_inc
// file cert.c line 129
void cert_refcount_inc(struct cert *c)
{
  pthread_mutex_lock(&c->mutex);
  c->references = c->references + 1ul;
  pthread_mutex_unlock(&c->mutex);
}

// cert_set_chain
// file cert.c line 166
void cert_set_chain(struct cert *c, struct stack_st_X509 *chain)
{
  pthread_mutex_lock(&c->mutex);
  if(!(c->chain == ((struct stack_st_X509 *)NULL)))
    sk_pop_free((struct stack_st *)c->chain, (void (*)(void *))(1 != 0 ? X509_free : (void (*)(struct x509_st *))0));

  signed int return_value_sk_num_2;
  if(!(chain == ((struct stack_st_X509 *)NULL)))
  {
    struct stack_st *return_value_sk_dup_1;
    return_value_sk_dup_1=sk_dup((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0));
    c->chain = (struct stack_st_X509 *)return_value_sk_dup_1;
    signed int i = 0;
    do
    {
      return_value_sk_num_2=sk_num((struct stack_st *)c->chain);
      if(i >= return_value_sk_num_2)
        break;

      void *return_value_sk_value_3;
      return_value_sk_value_3=sk_value((struct stack_st *)c->chain, i);
      ssl_x509_refcount_inc((struct x509_st *)return_value_sk_value_3);
      i = i + 1;
    }
    while((_Bool)1);
  }

  else
    c->chain = (struct stack_st_X509 *)(void *)0;
  pthread_mutex_unlock(&c->mutex);
}

// cert_set_crt
// file cert.c line 153
void cert_set_crt(struct cert *c, struct x509_st *crt)
{
  pthread_mutex_lock(&c->mutex);
  if(!(c->crt == ((struct x509_st *)NULL)))
    X509_free(c->crt);

  c->crt = crt;
  if(!(c->crt == ((struct x509_st *)NULL)))
    ssl_x509_refcount_inc(c->crt);

  pthread_mutex_unlock(&c->mutex);
}

// cert_set_key
// file cert.c line 140
void cert_set_key(struct cert *c, struct evp_pkey_st *key)
{
  pthread_mutex_lock(&c->mutex);
  if(!(c->key == ((struct evp_pkey_st *)NULL)))
    EVP_PKEY_free(c->key);

  c->key = key;
  if(!(c->key == ((struct evp_pkey_st *)NULL)))
    ssl_key_refcount_inc(c->key);

  pthread_mutex_unlock(&c->mutex);
}

// dynbuf_free
// file dynbuf.h line 45
void dynbuf_free(struct dynbuf *db)
{
  free((void *)db->buf);
  free((void *)db);
}

// dynbuf_new
// file dynbuf.c line 117
struct dynbuf * dynbuf_new(unsigned char *buf, unsigned long int sz)
{
  struct dynbuf *db;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct dynbuf) /*16ul*/ );
  db = (struct dynbuf *)return_value_malloc_1;
  if(db == ((struct dynbuf *)NULL))
    return (struct dynbuf *)(void *)0;

  else
  {
    db->buf = buf;
    db->sz = sz;
    return db;
  }
}

// dynbuf_new_alloc
// file dynbuf.h line 42
struct dynbuf * dynbuf_new_alloc(unsigned long int sz)
{
  struct dynbuf *db;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct dynbuf) /*16ul*/ );
  db = (struct dynbuf *)return_value_malloc_1;
  if(db == ((struct dynbuf *)NULL))
    return (struct dynbuf *)(void *)0;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sz);
    db->buf = (unsigned char *)return_value_malloc_2;
    if(db->buf == ((unsigned char *)NULL))
    {
      free((void *)db);
      return (struct dynbuf *)(void *)0;
    }

    else
    {
      db->sz = sz;
      return db;
    }
  }
}

// dynbuf_new_copy
// file dynbuf.h line 43
struct dynbuf * dynbuf_new_copy(const unsigned char *buf, const unsigned long int sz)
{
  struct dynbuf *db;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct dynbuf) /*16ul*/ );
  db = (struct dynbuf *)return_value_malloc_1;
  if(db == ((struct dynbuf *)NULL))
    return (struct dynbuf *)(void *)0;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sz);
    db->buf = (unsigned char *)return_value_malloc_2;
    if(db->buf == ((unsigned char *)NULL))
    {
      free((void *)db);
      return (struct dynbuf *)(void *)0;
    }

    else
    {
      memcpy((void *)db->buf, (const void *)buf, sz);
      db->sz = sz;
      return db;
    }
  }
}

// dynbuf_new_file
// file dynbuf.c line 81
struct dynbuf * dynbuf_new_file(const char *filename)
{
  struct dynbuf *db;
  struct _IO_FILE *f;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct dynbuf) /*16ul*/ );
  db = (struct dynbuf *)return_value_malloc_1;
  if(db == ((struct dynbuf *)NULL))
    return (struct dynbuf *)(void *)0;

  else
  {
    f=fopen(filename, "rb");
    if(f == ((struct _IO_FILE *)NULL))
    {
      free((void *)db);
      return (struct dynbuf *)(void *)0;
    }

    else
    {
      fseek(f, (signed long int)0, 2);
      signed long int return_value_ftell_2;
      return_value_ftell_2=ftell(f);
      db->sz = (unsigned long int)return_value_ftell_2;
      fseek(f, (signed long int)0, 0);
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(db->sz);
      db->buf = (unsigned char *)return_value_malloc_3;
      if(db->buf == ((unsigned char *)NULL))
      {
        free((void *)db);
        fclose(f);
        return (struct dynbuf *)(void *)0;
      }

      else
      {
        unsigned long int return_value_fread_4;
        return_value_fread_4=fread((void *)db->buf, db->sz, (unsigned long int)1, f);
        if(!(return_value_fread_4 == 1ul))
        {
          free((void *)db->buf);
          free((void *)db);
          fclose(f);
          return (struct dynbuf *)(void *)0;
        }

        else
        {
          fclose(f);
          return db;
        }
      }
    }
  }
}

// kh_del_cstrmap_t
// file cachetgcrt.c line 42
static inline void kh_del_cstrmap_t(struct anonymous_10 *h, unsigned int x)
{
  if(!(x == h->n_buckets))
  {
    if((3u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u)
    {
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] | (unsigned int)(1ul << ((x & 0xfU) << 1));
      h->size = h->size - 1u;
    }

  }

}

// kh_del_dynbufmap_t
// file cachedsess.c line 68
static inline void kh_del_dynbufmap_t(struct anonymous_6 *h, unsigned int x)
{
  if(!(x == h->n_buckets))
  {
    if((3u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u)
    {
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] | (unsigned int)(1ul << ((x & 0xfU) << 1));
      h->size = h->size - 1u;
    }

  }

}

// kh_del_dynbufmap_t_link1
// file cachessess.c line 66
static inline void kh_del_dynbufmap_t_link1(struct anonymous_6 *h_link1, unsigned int x_link1)
{
  if(!(x_link1 == h_link1->n_buckets))
  {
    if((3u & h_link1->flags[(signed long int)(x_link1 >> 4)] >> ((0xfU & x_link1) << 1)) == 0u)
    {
      h_link1->flags[(signed long int)(x_link1 >> 4)] = h_link1->flags[(signed long int)(x_link1 >> 4)] | (unsigned int)(1ul << ((x_link1 & 0xfU) << 1));
      h_link1->size = h_link1->size - 1u;
    }

  }

}

// kh_del_sha1map_t
// file cachefkcrt.c line 56
static inline void kh_del_sha1map_t(struct anonymous_12 *h, unsigned int x)
{
  if(!(x == h->n_buckets))
  {
    if((3u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u)
    {
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] | (unsigned int)(1ul << ((x & 0xfU) << 1));
      h->size = h->size - 1u;
    }

  }

}

// kh_destroy_cstrmap_t
// file cachetgcrt.c line 42
static inline void kh_destroy_cstrmap_t(struct anonymous_10 *h)
{
  if(!(h == ((struct anonymous_10 *)NULL)))
  {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }

}

// kh_destroy_dynbufmap_t
// file cachedsess.c line 68
static inline void kh_destroy_dynbufmap_t(struct anonymous_6 *h)
{
  if(!(h == ((struct anonymous_6 *)NULL)))
  {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }

}

// kh_destroy_dynbufmap_t_link1
// file cachessess.c line 66
static inline void kh_destroy_dynbufmap_t_link1(struct anonymous_6 *h_link1)
{
  if(!(h_link1 == ((struct anonymous_6 *)NULL)))
  {
    free((void *)h_link1->keys);
    free((void *)h_link1->flags);
    free((void *)h_link1->vals);
    free((void *)h_link1);
  }

}

// kh_destroy_sha1map_t
// file cachefkcrt.c line 56
static inline void kh_destroy_sha1map_t(struct anonymous_12 *h)
{
  if(!(h == ((struct anonymous_12 *)NULL)))
  {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }

}

// kh_dynbuf_hash_func
// file cachedsess.c line 45
static inline unsigned int kh_dynbuf_hash_func(struct dynbuf *b)
{
  unsigned int *p = (unsigned int *)b->buf;
  unsigned int h;
  signed int rem = (signed int)(b->sz % sizeof(unsigned int) /*4ul*/ );
  if(!(rem == 0))
    memcpy((void *)&h, (const void *)((b->buf + (signed long int)b->sz) - (signed long int)rem), (unsigned long int)rem);

  else
    h = (unsigned int)0;
  unsigned int *tmp_post_1;
  for( ; !(p >= (unsigned int *)(b->buf + (signed long int)b->sz + -((signed long int)rem))); h = h ^ *tmp_post_1)
  {
    tmp_post_1 = p;
    p = p + 1l;
  }
  return h;
}

// kh_dynbuf_hash_func_link1
// file cachessess.c line 43
static inline unsigned int kh_dynbuf_hash_func_link1(struct dynbuf *b_link1)
{
  unsigned int *p_link1 = (unsigned int *)b_link1->buf;
  unsigned int h_link1;
  signed int rem_link1 = (signed int)(b_link1->sz % sizeof(unsigned int) /*4ul*/ );
  if(!(rem_link1 == 0))
    memcpy((void *)&h_link1, (const void *)((b_link1->buf + (signed long int)b_link1->sz) - (signed long int)rem_link1), (unsigned long int)rem_link1);

  else
    h_link1 = (unsigned int)0;
  unsigned int *tmp_post_1_link1;
  for( ; !(p_link1 >= (unsigned int *)(b_link1->buf + (signed long int)b_link1->sz + -((signed long int)rem_link1))); h_link1 = h_link1 ^ *tmp_post_1_link1)
  {
    tmp_post_1_link1 = p_link1;
    p_link1 = p_link1 + 1l;
  }
  return h_link1;
}

// kh_get_cstrmap_t
// file cachetgcrt.c line 42
static inline unsigned int kh_get_cstrmap_t(const struct anonymous_10 *h, char *key)
{
  signed int return_value_strcmp_1;
  unsigned int tmp_if_expr_2;
  if(!(h->n_buckets == 0u))
  {
    unsigned int k;
    unsigned int i;
    unsigned int last;
    unsigned int mask;
    unsigned int step = (unsigned int)0;
    mask = h->n_buckets - (unsigned int)1;
    k=__ac_X31_hash_string(key);
    i = k & mask;
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        return_value_strcmp_1=strcmp(h->keys[(signed long int)i], key);
        if(return_value_strcmp_1 == 0)
          break;

      }

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
        return h->n_buckets;

    }
    if(!((3u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
      tmp_if_expr_2 = h->n_buckets;

    else
      tmp_if_expr_2 = i;
    return tmp_if_expr_2;
  }

  else
    return (unsigned int)0;
}

// kh_get_dynbufmap_t
// file cachedsess.c line 68
static inline unsigned int kh_get_dynbufmap_t(const struct anonymous_6 *h, struct dynbuf *key)
{
  signed int return_value_memcmp_1;
  unsigned int tmp_if_expr_2;
  if(!(h->n_buckets == 0u))
  {
    unsigned int k;
    unsigned int i;
    unsigned int last;
    unsigned int mask;
    unsigned int step = (unsigned int)0;
    mask = h->n_buckets - (unsigned int)1;
    k=kh_dynbuf_hash_func(key);
    i = k & mask;
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        if(h->keys[(signed long int)i]->sz == key->sz)
        {
          return_value_memcmp_1=memcmp((const void *)h->keys[(signed long int)i]->buf, (const void *)key->buf, h->keys[(signed long int)i]->sz);
          if(return_value_memcmp_1 == 0)
            break;

        }

      }

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
        return h->n_buckets;

    }
    if(!((3u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
      tmp_if_expr_2 = h->n_buckets;

    else
      tmp_if_expr_2 = i;
    return tmp_if_expr_2;
  }

  else
    return (unsigned int)0;
}

// kh_get_dynbufmap_t_link1
// file cachessess.c line 66
static inline unsigned int kh_get_dynbufmap_t_link1(const struct anonymous_6 *h_link1, struct dynbuf *key_link1)
{
  signed int return_value_memcmp_1_link1;
  unsigned int tmp_if_expr_2_link1;
  if(!(h_link1->n_buckets == 0u))
  {
    unsigned int k_link1;
    unsigned int i_link1;
    unsigned int last_link1;
    unsigned int mask_link1;
    unsigned int step_link1 = (unsigned int)0;
    mask_link1 = h_link1->n_buckets - (unsigned int)1;
    k_link1=kh_dynbuf_hash_func_link1(key_link1);
    i_link1 = k_link1 & mask_link1;
    last_link1 = i_link1;
    while((2u & h_link1->flags[(signed long int)(i_link1 >> 4)] >> ((0xfU & i_link1) << 1)) == 0u)
    {
      if((1u & h_link1->flags[(signed long int)(i_link1 >> 4)] >> ((0xfU & i_link1) << 1)) == 0u)
      {
        if(h_link1->keys[(signed long int)i_link1]->sz == key_link1->sz)
        {
          return_value_memcmp_1_link1=memcmp((const void *)h_link1->keys[(signed long int)i_link1]->buf, (const void *)key_link1->buf, h_link1->keys[(signed long int)i_link1]->sz);
          if(return_value_memcmp_1_link1 == 0)
            break;

        }

      }

      step_link1 = step_link1 + 1u;
      i_link1 = i_link1 + step_link1 & mask_link1;
      if(i_link1 == last_link1)
        return h_link1->n_buckets;

    }
    if(!((3u & h_link1->flags[(signed long int)(i_link1 >> 4)] >> ((0xfU & i_link1) << 1)) == 0u))
      tmp_if_expr_2_link1 = h_link1->n_buckets;

    else
      tmp_if_expr_2_link1 = i_link1;
    return tmp_if_expr_2_link1;
  }

  else
    return (unsigned int)0;
}

// kh_get_sha1map_t
// file cachefkcrt.c line 56
static inline unsigned int kh_get_sha1map_t(const struct anonymous_12 *h, void *key)
{
  signed int return_value_memcmp_1;
  unsigned int tmp_if_expr_2;
  if(!(h->n_buckets == 0u))
  {
    unsigned int k;
    unsigned int i;
    unsigned int last;
    unsigned int mask;
    unsigned int step = (unsigned int)0;
    mask = h->n_buckets - (unsigned int)1;
    k=kh_x509fpr_hash_func(key);
    i = k & mask;
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        return_value_memcmp_1=memcmp((const void *)(char *)h->keys[(signed long int)i], (const void *)(char *)key, (unsigned long int)20);
        if(return_value_memcmp_1 == 0)
          break;

      }

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
        return h->n_buckets;

    }
    if(!((3u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
      tmp_if_expr_2 = h->n_buckets;

    else
      tmp_if_expr_2 = i;
    return tmp_if_expr_2;
  }

  else
    return (unsigned int)0;
}

// kh_init_cstrmap_t
// file cachetgcrt.c line 42
static inline struct anonymous_10 * kh_init_cstrmap_t(void)
{
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_10) /*40ul*/ );
  return (struct anonymous_10 *)return_value_calloc_1;
}

// kh_init_dynbufmap_t
// file cachedsess.c line 68
static inline struct anonymous_6 * kh_init_dynbufmap_t(void)
{
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_6) /*40ul*/ );
  return (struct anonymous_6 *)return_value_calloc_1;
}

// kh_init_dynbufmap_t_link1
// file cachessess.c line 66
static inline struct anonymous_6 * kh_init_dynbufmap_t_link1(void)
{
  void *return_value_calloc_1_link1;
  return_value_calloc_1_link1=calloc((unsigned long int)1, sizeof(struct anonymous_6) /*40ul*/ );
  return (struct anonymous_6 *)return_value_calloc_1_link1;
}

// kh_init_sha1map_t
// file cachefkcrt.c line 56
static inline struct anonymous_12 * kh_init_sha1map_t(void)
{
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_12) /*40ul*/ );
  return (struct anonymous_12 *)return_value_calloc_1;
}

// kh_put_cstrmap_t
// file cachetgcrt.c line 42
static inline unsigned int kh_put_cstrmap_t(struct anonymous_10 *h, char *key, signed int *ret)
{
  unsigned int x;
  signed int return_value_kh_resize_cstrmap_t_2;
  if(h->n_occupied >= h->upper_bound)
  {
    if(!(h->size << 1 >= h->n_buckets))
    {
      signed int return_value_kh_resize_cstrmap_t_1;
      return_value_kh_resize_cstrmap_t_1=kh_resize_cstrmap_t(h, h->n_buckets - (unsigned int)1);
      if(!(return_value_kh_resize_cstrmap_t_1 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }

    else
    {
      return_value_kh_resize_cstrmap_t_2=kh_resize_cstrmap_t(h, h->n_buckets + (unsigned int)1);
      if(!(return_value_kh_resize_cstrmap_t_2 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }
  }

  unsigned int k;
  unsigned int i;
  unsigned int site;
  unsigned int last;
  unsigned int mask = h->n_buckets - (unsigned int)1;
  unsigned int step = (unsigned int)0;
  site = h->n_buckets;
  x = site;
  k=__ac_X31_hash_string(key);
  i = k & mask;
  signed int return_value_strcmp_3;
  _Bool tmp_if_expr_4;
  if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
    x = i;

  else
  {
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        return_value_strcmp_3=strcmp(h->keys[(signed long int)i], key);
        if(return_value_strcmp_3 == 0)
          break;

      }

      if(!((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        site = i;

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
      {
        x = site;
        break;
      }

    }
    if(x == h->n_buckets)
    {
      if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        tmp_if_expr_4 = site != h->n_buckets ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        x = site;

      else
        x = i;
    }

  }
  if(!((2u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
  {
    h->keys[(signed long int)x] = key;
    h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
    h->size = h->size + 1u;
    h->n_occupied = h->n_occupied + 1u;
    *ret = 1;
  }

  else
    if(!((1u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
    {
      h->keys[(signed long int)x] = key;
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
      h->size = h->size + 1u;
      *ret = 2;
    }

    else
      *ret = 0;
  return x;
}

// kh_put_dynbufmap_t
// file cachedsess.c line 68
static inline unsigned int kh_put_dynbufmap_t(struct anonymous_6 *h, struct dynbuf *key, signed int *ret)
{
  unsigned int x;
  signed int return_value_kh_resize_dynbufmap_t_2;
  if(h->n_occupied >= h->upper_bound)
  {
    if(!(h->size << 1 >= h->n_buckets))
    {
      signed int return_value_kh_resize_dynbufmap_t_1;
      return_value_kh_resize_dynbufmap_t_1=kh_resize_dynbufmap_t(h, h->n_buckets - (unsigned int)1);
      if(!(return_value_kh_resize_dynbufmap_t_1 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }

    else
    {
      return_value_kh_resize_dynbufmap_t_2=kh_resize_dynbufmap_t(h, h->n_buckets + (unsigned int)1);
      if(!(return_value_kh_resize_dynbufmap_t_2 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }
  }

  unsigned int k;
  unsigned int i;
  unsigned int site;
  unsigned int last;
  unsigned int mask = h->n_buckets - (unsigned int)1;
  unsigned int step = (unsigned int)0;
  site = h->n_buckets;
  x = site;
  k=kh_dynbuf_hash_func(key);
  i = k & mask;
  signed int return_value_memcmp_3;
  _Bool tmp_if_expr_4;
  if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
    x = i;

  else
  {
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        if(h->keys[(signed long int)i]->sz == key->sz)
        {
          return_value_memcmp_3=memcmp((const void *)h->keys[(signed long int)i]->buf, (const void *)key->buf, h->keys[(signed long int)i]->sz);
          if(return_value_memcmp_3 == 0)
            break;

        }

      }

      if(!((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        site = i;

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
      {
        x = site;
        break;
      }

    }
    if(x == h->n_buckets)
    {
      if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        tmp_if_expr_4 = site != h->n_buckets ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        x = site;

      else
        x = i;
    }

  }
  if(!((2u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
  {
    h->keys[(signed long int)x] = key;
    h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
    h->size = h->size + 1u;
    h->n_occupied = h->n_occupied + 1u;
    *ret = 1;
  }

  else
    if(!((1u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
    {
      h->keys[(signed long int)x] = key;
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
      h->size = h->size + 1u;
      *ret = 2;
    }

    else
      *ret = 0;
  return x;
}

// kh_put_dynbufmap_t_link1
// file cachessess.c line 66
static inline unsigned int kh_put_dynbufmap_t_link1(struct anonymous_6 *h_link1, struct dynbuf *key_link1, signed int *ret_link1)
{
  unsigned int x_link1;
  signed int return_value_kh_resize_dynbufmap_t_2_link1;
  if(h_link1->n_occupied >= h_link1->upper_bound)
  {
    if(!(h_link1->size << 1 >= h_link1->n_buckets))
    {
      signed int return_value_kh_resize_dynbufmap_t_1_link1;
      return_value_kh_resize_dynbufmap_t_1_link1=kh_resize_dynbufmap_t_link1(h_link1, h_link1->n_buckets - (unsigned int)1);
      if(!(return_value_kh_resize_dynbufmap_t_1_link1 >= 0))
      {
        *ret_link1 = -1;
        return h_link1->n_buckets;
      }

    }

    else
    {
      return_value_kh_resize_dynbufmap_t_2_link1=kh_resize_dynbufmap_t_link1(h_link1, h_link1->n_buckets + (unsigned int)1);
      if(!(return_value_kh_resize_dynbufmap_t_2_link1 >= 0))
      {
        *ret_link1 = -1;
        return h_link1->n_buckets;
      }

    }
  }

  unsigned int k_link1;
  unsigned int i_link1;
  unsigned int site_link1;
  unsigned int last_link1;
  unsigned int mask_link1 = h_link1->n_buckets - (unsigned int)1;
  unsigned int step_link1 = (unsigned int)0;
  site_link1 = h_link1->n_buckets;
  x_link1 = site_link1;
  k_link1=kh_dynbuf_hash_func_link1(key_link1);
  i_link1 = k_link1 & mask_link1;
  signed int return_value_memcmp_3_link1;
  _Bool tmp_if_expr_4_link1;
  if(!((2u & h_link1->flags[(signed long int)(i_link1 >> 4)] >> ((0xfU & i_link1) << 1)) == 0u))
    x_link1 = i_link1;

  else
  {
    last_link1 = i_link1;
    while((2u & h_link1->flags[(signed long int)(i_link1 >> 4)] >> ((0xfU & i_link1) << 1)) == 0u)
    {
      if((1u & h_link1->flags[(signed long int)(i_link1 >> 4)] >> ((0xfU & i_link1) << 1)) == 0u)
      {
        if(h_link1->keys[(signed long int)i_link1]->sz == key_link1->sz)
        {
          return_value_memcmp_3_link1=memcmp((const void *)h_link1->keys[(signed long int)i_link1]->buf, (const void *)key_link1->buf, h_link1->keys[(signed long int)i_link1]->sz);
          if(return_value_memcmp_3_link1 == 0)
            break;

        }

      }

      if(!((1u & h_link1->flags[(signed long int)(i_link1 >> 4)] >> ((0xfU & i_link1) << 1)) == 0u))
        site_link1 = i_link1;

      step_link1 = step_link1 + 1u;
      i_link1 = i_link1 + step_link1 & mask_link1;
      if(i_link1 == last_link1)
      {
        x_link1 = site_link1;
        break;
      }

    }
    if(x_link1 == h_link1->n_buckets)
    {
      if(!((2u & h_link1->flags[(signed long int)(i_link1 >> 4)] >> ((0xfU & i_link1) << 1)) == 0u))
        tmp_if_expr_4_link1 = site_link1 != h_link1->n_buckets ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4_link1 = (_Bool)0;
      if(tmp_if_expr_4_link1)
        x_link1 = site_link1;

      else
        x_link1 = i_link1;
    }

  }
  if(!((2u & h_link1->flags[(signed long int)(x_link1 >> 4)] >> ((0xfU & x_link1) << 1)) == 0u))
  {
    h_link1->keys[(signed long int)x_link1] = key_link1;
    h_link1->flags[(signed long int)(x_link1 >> 4)] = h_link1->flags[(signed long int)(x_link1 >> 4)] & (unsigned int)~(3ul << ((x_link1 & 0xfU) << 1));
    h_link1->size = h_link1->size + 1u;
    h_link1->n_occupied = h_link1->n_occupied + 1u;
    *ret_link1 = 1;
  }

  else
    if(!((1u & h_link1->flags[(signed long int)(x_link1 >> 4)] >> ((0xfU & x_link1) << 1)) == 0u))
    {
      h_link1->keys[(signed long int)x_link1] = key_link1;
      h_link1->flags[(signed long int)(x_link1 >> 4)] = h_link1->flags[(signed long int)(x_link1 >> 4)] & (unsigned int)~(3ul << ((x_link1 & 0xfU) << 1));
      h_link1->size = h_link1->size + 1u;
      *ret_link1 = 2;
    }

    else
      *ret_link1 = 0;
  return x_link1;
}

// kh_put_sha1map_t
// file cachefkcrt.c line 56
static inline unsigned int kh_put_sha1map_t(struct anonymous_12 *h, void *key, signed int *ret)
{
  unsigned int x;
  signed int return_value_kh_resize_sha1map_t_2;
  if(h->n_occupied >= h->upper_bound)
  {
    if(!(h->size << 1 >= h->n_buckets))
    {
      signed int return_value_kh_resize_sha1map_t_1;
      return_value_kh_resize_sha1map_t_1=kh_resize_sha1map_t(h, h->n_buckets - (unsigned int)1);
      if(!(return_value_kh_resize_sha1map_t_1 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }

    else
    {
      return_value_kh_resize_sha1map_t_2=kh_resize_sha1map_t(h, h->n_buckets + (unsigned int)1);
      if(!(return_value_kh_resize_sha1map_t_2 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }
  }

  unsigned int k;
  unsigned int i;
  unsigned int site;
  unsigned int last;
  unsigned int mask = h->n_buckets - (unsigned int)1;
  unsigned int step = (unsigned int)0;
  site = h->n_buckets;
  x = site;
  k=kh_x509fpr_hash_func(key);
  i = k & mask;
  signed int return_value_memcmp_3;
  _Bool tmp_if_expr_4;
  if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
    x = i;

  else
  {
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        return_value_memcmp_3=memcmp((const void *)(char *)h->keys[(signed long int)i], (const void *)(char *)key, (unsigned long int)20);
        if(return_value_memcmp_3 == 0)
          break;

      }

      if(!((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        site = i;

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
      {
        x = site;
        break;
      }

    }
    if(x == h->n_buckets)
    {
      if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        tmp_if_expr_4 = site != h->n_buckets ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        x = site;

      else
        x = i;
    }

  }
  if(!((2u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
  {
    h->keys[(signed long int)x] = key;
    h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
    h->size = h->size + 1u;
    h->n_occupied = h->n_occupied + 1u;
    *ret = 1;
  }

  else
    if(!((1u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
    {
      h->keys[(signed long int)x] = key;
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
      h->size = h->size + 1u;
      *ret = 2;
    }

    else
      *ret = 0;
  return x;
}

// kh_resize_cstrmap_t
// file cachetgcrt.c line 42
static inline signed int kh_resize_cstrmap_t(struct anonymous_10 *h, unsigned int new_n_buckets)
{
  unsigned int *new_flags = ((unsigned int *)NULL);
  unsigned int j = (unsigned int)1;
  new_n_buckets = new_n_buckets - 1u;
  new_n_buckets = new_n_buckets | new_n_buckets >> 1;
  new_n_buckets = new_n_buckets | new_n_buckets >> 2;
  new_n_buckets = new_n_buckets | new_n_buckets >> 4;
  new_n_buckets = new_n_buckets | new_n_buckets >> 8;
  new_n_buckets = new_n_buckets | new_n_buckets >> 16;
  new_n_buckets = new_n_buckets + 1u;
  if(!(new_n_buckets >= 4u))
    new_n_buckets = (unsigned int)4;

  if(h->size >= (unsigned int)((double)new_n_buckets * __ac_HASH_UPPER_link3 + 0.5))
    j = (unsigned int)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    new_flags = (unsigned int *)return_value_malloc_1;
    if(new_flags == ((unsigned int *)NULL))
      return -1;

    memset((void *)new_flags, 0xaa, (unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    if(!(h->n_buckets >= new_n_buckets))
    {
      char **new_keys;
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(char *) /*8ul*/ );
      new_keys = (char **)return_value_realloc_2;
      if(new_keys == ((char **)NULL))
      {
        free((void *)new_flags);
        return -1;
      }

      h->keys = new_keys;
      {
        void **new_vals;
        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
        new_vals = (void **)return_value_realloc_3;
        if(new_vals == ((void **)NULL))
        {
          free((void *)new_flags);
          return -1;
        }

        h->vals = new_vals;
      }
    }

  }
  _Bool tmp_if_expr_4;
  void *return_value_realloc_6;
  if(!(j == 0u))
  {
    j = (unsigned int)0;
    for( ; !(j == h->n_buckets); j = j + 1u)
      if((3u & h->flags[(signed long int)(j >> 4)] >> ((0xfU & j) << 1)) == 0u)
      {
        char *key = h->keys[(signed long int)j];
        void *val;
        unsigned int new_mask = new_n_buckets - (unsigned int)1;
        val = h->vals[(signed long int)j];
        h->flags[(signed long int)(j >> 4)] = h->flags[(signed long int)(j >> 4)] | (unsigned int)(1ul << ((j & 0xfU) << 1));
        while((_Bool)1)
        {
          unsigned int k;
          unsigned int i;
          unsigned int step = (unsigned int)0;
          k=__ac_X31_hash_string(key);
          i = k & new_mask;
          for( ; (2u & new_flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u; i = i + step & new_mask)
            step = step + 1u;
          new_flags[(signed long int)(i >> 4)] = new_flags[(signed long int)(i >> 4)] & (unsigned int)~(2ul << ((i & 0xfU) << 1));
          if(!(i >= h->n_buckets))
            tmp_if_expr_4 = (h->flags[(signed long int)(i >> 4)] >> ((i & 0xfU) << 1) & (unsigned int)3) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
          {
            char *tmp = h->keys[(signed long int)i];
            h->keys[(signed long int)i] = key;
            key = tmp;
            {
              void *kh_resize_cstrmap_t__1__2__1__1__1__1__1__2__tmp = h->vals[(signed long int)i];
              h->vals[(signed long int)i] = val;
              val = kh_resize_cstrmap_t__1__2__1__1__1__1__1__2__tmp;
            }
            h->flags[(signed long int)(i >> 4)] = h->flags[(signed long int)(i >> 4)] | (unsigned int)(1ul << ((i & 0xfU) << 1));
          }

          else
          {
            h->keys[(signed long int)i] = key;
            h->vals[(signed long int)i] = val;
            break;
          }
        }
      }

    if(!(new_n_buckets >= h->n_buckets))
    {
      void *return_value_realloc_5;
      return_value_realloc_5=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(char *) /*8ul*/ );
      h->keys = (char **)return_value_realloc_5;
      return_value_realloc_6=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
      h->vals = (void **)return_value_realloc_6;
    }

    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (unsigned int)((double)h->n_buckets * __ac_HASH_UPPER_link3 + 0.5);
  }

  return 0;
}

// kh_resize_dynbufmap_t
// file cachedsess.c line 68
static inline signed int kh_resize_dynbufmap_t(struct anonymous_6 *h, unsigned int new_n_buckets)
{
  unsigned int *new_flags = ((unsigned int *)NULL);
  unsigned int j = (unsigned int)1;
  new_n_buckets = new_n_buckets - 1u;
  new_n_buckets = new_n_buckets | new_n_buckets >> 1;
  new_n_buckets = new_n_buckets | new_n_buckets >> 2;
  new_n_buckets = new_n_buckets | new_n_buckets >> 4;
  new_n_buckets = new_n_buckets | new_n_buckets >> 8;
  new_n_buckets = new_n_buckets | new_n_buckets >> 16;
  new_n_buckets = new_n_buckets + 1u;
  if(!(new_n_buckets >= 4u))
    new_n_buckets = (unsigned int)4;

  if(h->size >= (unsigned int)((double)new_n_buckets * __ac_HASH_UPPER_link1 + 0.5))
    j = (unsigned int)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    new_flags = (unsigned int *)return_value_malloc_1;
    if(new_flags == ((unsigned int *)NULL))
      return -1;

    memset((void *)new_flags, 0xaa, (unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    if(!(h->n_buckets >= new_n_buckets))
    {
      struct dynbuf **new_keys;
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(struct dynbuf *) /*8ul*/ );
      new_keys = (struct dynbuf **)return_value_realloc_2;
      if(new_keys == ((struct dynbuf **)NULL))
      {
        free((void *)new_flags);
        return -1;
      }

      h->keys = new_keys;
      {
        struct dynbuf **new_vals;
        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(struct dynbuf *) /*8ul*/ );
        new_vals = (struct dynbuf **)return_value_realloc_3;
        if(new_vals == ((struct dynbuf **)NULL))
        {
          free((void *)new_flags);
          return -1;
        }

        h->vals = new_vals;
      }
    }

  }
  _Bool tmp_if_expr_4;
  void *return_value_realloc_6;
  if(!(j == 0u))
  {
    j = (unsigned int)0;
    for( ; !(j == h->n_buckets); j = j + 1u)
      if((3u & h->flags[(signed long int)(j >> 4)] >> ((0xfU & j) << 1)) == 0u)
      {
        struct dynbuf *key = h->keys[(signed long int)j];
        struct dynbuf *val;
        unsigned int new_mask = new_n_buckets - (unsigned int)1;
        val = h->vals[(signed long int)j];
        h->flags[(signed long int)(j >> 4)] = h->flags[(signed long int)(j >> 4)] | (unsigned int)(1ul << ((j & 0xfU) << 1));
        while((_Bool)1)
        {
          unsigned int k;
          unsigned int i;
          unsigned int step = (unsigned int)0;
          k=kh_dynbuf_hash_func(key);
          i = k & new_mask;
          for( ; (2u & new_flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u; i = i + step & new_mask)
            step = step + 1u;
          new_flags[(signed long int)(i >> 4)] = new_flags[(signed long int)(i >> 4)] & (unsigned int)~(2ul << ((i & 0xfU) << 1));
          if(!(i >= h->n_buckets))
            tmp_if_expr_4 = (h->flags[(signed long int)(i >> 4)] >> ((i & 0xfU) << 1) & (unsigned int)3) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
          {
            struct dynbuf *tmp = h->keys[(signed long int)i];
            h->keys[(signed long int)i] = key;
            key = tmp;
            {
              struct dynbuf *kh_resize_dynbufmap_t__1__2__1__1__1__1__1__2__tmp = h->vals[(signed long int)i];
              h->vals[(signed long int)i] = val;
              val = kh_resize_dynbufmap_t__1__2__1__1__1__1__1__2__tmp;
            }
            h->flags[(signed long int)(i >> 4)] = h->flags[(signed long int)(i >> 4)] | (unsigned int)(1ul << ((i & 0xfU) << 1));
          }

          else
          {
            h->keys[(signed long int)i] = key;
            h->vals[(signed long int)i] = val;
            break;
          }
        }
      }

    if(!(new_n_buckets >= h->n_buckets))
    {
      void *return_value_realloc_5;
      return_value_realloc_5=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(struct dynbuf *) /*8ul*/ );
      h->keys = (struct dynbuf **)return_value_realloc_5;
      return_value_realloc_6=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(struct dynbuf *) /*8ul*/ );
      h->vals = (struct dynbuf **)return_value_realloc_6;
    }

    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (unsigned int)((double)h->n_buckets * __ac_HASH_UPPER_link1 + 0.5);
  }

  return 0;
}

// kh_resize_dynbufmap_t_link1
// file cachessess.c line 66
static inline signed int kh_resize_dynbufmap_t_link1(struct anonymous_6 *h_link1, unsigned int new_n_buckets_link1)
{
  unsigned int *new_flags_link1 = ((unsigned int *)NULL);
  unsigned int j_link1 = (unsigned int)1;
  new_n_buckets_link1 = new_n_buckets_link1 - 1u;
  new_n_buckets_link1 = new_n_buckets_link1 | new_n_buckets_link1 >> 1;
  new_n_buckets_link1 = new_n_buckets_link1 | new_n_buckets_link1 >> 2;
  new_n_buckets_link1 = new_n_buckets_link1 | new_n_buckets_link1 >> 4;
  new_n_buckets_link1 = new_n_buckets_link1 | new_n_buckets_link1 >> 8;
  new_n_buckets_link1 = new_n_buckets_link1 | new_n_buckets_link1 >> 16;
  new_n_buckets_link1 = new_n_buckets_link1 + 1u;
  if(!(new_n_buckets_link1 >= 4u))
    new_n_buckets_link1 = (unsigned int)4;

  if(h_link1->size >= (unsigned int)((double)new_n_buckets_link1 * __ac_HASH_UPPER_link2 + 0.5))
    j_link1 = (unsigned int)0;

  else
  {
    void *return_value_malloc_1_link1;
    return_value_malloc_1_link1=malloc((unsigned long int)(new_n_buckets_link1 < (unsigned int)16 ? (unsigned int)1 : new_n_buckets_link1 >> 4) * sizeof(unsigned int) /*4ul*/ );
    new_flags_link1 = (unsigned int *)return_value_malloc_1_link1;
    if(new_flags_link1 == ((unsigned int *)NULL))
      return -1;

    memset((void *)new_flags_link1, 0xaa, (unsigned long int)(new_n_buckets_link1 < (unsigned int)16 ? (unsigned int)1 : new_n_buckets_link1 >> 4) * sizeof(unsigned int) /*4ul*/ );
    if(!(h_link1->n_buckets >= new_n_buckets_link1))
    {
      struct dynbuf **new_keys_link1;
      void *return_value_realloc_2_link1;
      return_value_realloc_2_link1=realloc((void *)h_link1->keys, (unsigned long int)new_n_buckets_link1 * sizeof(struct dynbuf *) /*8ul*/ );
      new_keys_link1 = (struct dynbuf **)return_value_realloc_2_link1;
      if(new_keys_link1 == ((struct dynbuf **)NULL))
      {
        free((void *)new_flags_link1);
        return -1;
      }

      h_link1->keys = new_keys_link1;
      {
        struct dynbuf **new_vals_link1;
        void *return_value_realloc_3_link1;
        return_value_realloc_3_link1=realloc((void *)h_link1->vals, (unsigned long int)new_n_buckets_link1 * sizeof(struct dynbuf *) /*8ul*/ );
        new_vals_link1 = (struct dynbuf **)return_value_realloc_3_link1;
        if(new_vals_link1 == ((struct dynbuf **)NULL))
        {
          free((void *)new_flags_link1);
          return -1;
        }

        h_link1->vals = new_vals_link1;
      }
    }

  }
  _Bool tmp_if_expr_4_link1;
  void *return_value_realloc_6_link1;
  if(!(j_link1 == 0u))
  {
    j_link1 = (unsigned int)0;
    for( ; !(j_link1 == h_link1->n_buckets); j_link1 = j_link1 + 1u)
      if((3u & h_link1->flags[(signed long int)(j_link1 >> 4)] >> ((0xfU & j_link1) << 1)) == 0u)
      {
        struct dynbuf *key_link1 = h_link1->keys[(signed long int)j_link1];
        struct dynbuf *val_link1;
        unsigned int new_mask_link1 = new_n_buckets_link1 - (unsigned int)1;
        val_link1 = h_link1->vals[(signed long int)j_link1];
        h_link1->flags[(signed long int)(j_link1 >> 4)] = h_link1->flags[(signed long int)(j_link1 >> 4)] | (unsigned int)(1ul << ((j_link1 & 0xfU) << 1));
        while((_Bool)1)
        {
          unsigned int k_link1;
          unsigned int i_link1;
          unsigned int step_link1 = (unsigned int)0;
          k_link1=kh_dynbuf_hash_func_link1(key_link1);
          i_link1 = k_link1 & new_mask_link1;
          for( ; (2u & new_flags_link1[(signed long int)(i_link1 >> 4)] >> ((0xfU & i_link1) << 1)) == 0u; i_link1 = i_link1 + step_link1 & new_mask_link1)
            step_link1 = step_link1 + 1u;
          new_flags_link1[(signed long int)(i_link1 >> 4)] = new_flags_link1[(signed long int)(i_link1 >> 4)] & (unsigned int)~(2ul << ((i_link1 & 0xfU) << 1));
          if(!(i_link1 >= h_link1->n_buckets))
            tmp_if_expr_4_link1 = (h_link1->flags[(signed long int)(i_link1 >> 4)] >> ((i_link1 & 0xfU) << 1) & (unsigned int)3) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4_link1 = (_Bool)0;
          if(tmp_if_expr_4_link1)
          {
            struct dynbuf *tmp_link1 = h_link1->keys[(signed long int)i_link1];
            h_link1->keys[(signed long int)i_link1] = key_link1;
            key_link1 = tmp_link1;
            {
              struct dynbuf *kh_resize_dynbufmap_t__1__2__1__1__1__1__1__2__tmp_link1 = h_link1->vals[(signed long int)i_link1];
              h_link1->vals[(signed long int)i_link1] = val_link1;
              val_link1 = kh_resize_dynbufmap_t__1__2__1__1__1__1__1__2__tmp_link1;
            }
            h_link1->flags[(signed long int)(i_link1 >> 4)] = h_link1->flags[(signed long int)(i_link1 >> 4)] | (unsigned int)(1ul << ((i_link1 & 0xfU) << 1));
          }

          else
          {
            h_link1->keys[(signed long int)i_link1] = key_link1;
            h_link1->vals[(signed long int)i_link1] = val_link1;
            break;
          }
        }
      }

    if(!(new_n_buckets_link1 >= h_link1->n_buckets))
    {
      void *return_value_realloc_5_link1;
      return_value_realloc_5_link1=realloc((void *)h_link1->keys, (unsigned long int)new_n_buckets_link1 * sizeof(struct dynbuf *) /*8ul*/ );
      h_link1->keys = (struct dynbuf **)return_value_realloc_5_link1;
      return_value_realloc_6_link1=realloc((void *)h_link1->vals, (unsigned long int)new_n_buckets_link1 * sizeof(struct dynbuf *) /*8ul*/ );
      h_link1->vals = (struct dynbuf **)return_value_realloc_6_link1;
    }

    free((void *)h_link1->flags);
    h_link1->flags = new_flags_link1;
    h_link1->n_buckets = new_n_buckets_link1;
    h_link1->n_occupied = h_link1->size;
    h_link1->upper_bound = (unsigned int)((double)h_link1->n_buckets * __ac_HASH_UPPER_link2 + 0.5);
  }

  return 0;
}

// kh_resize_sha1map_t
// file cachefkcrt.c line 56
static inline signed int kh_resize_sha1map_t(struct anonymous_12 *h, unsigned int new_n_buckets)
{
  unsigned int *new_flags = ((unsigned int *)NULL);
  unsigned int j = (unsigned int)1;
  new_n_buckets = new_n_buckets - 1u;
  new_n_buckets = new_n_buckets | new_n_buckets >> 1;
  new_n_buckets = new_n_buckets | new_n_buckets >> 2;
  new_n_buckets = new_n_buckets | new_n_buckets >> 4;
  new_n_buckets = new_n_buckets | new_n_buckets >> 8;
  new_n_buckets = new_n_buckets | new_n_buckets >> 16;
  new_n_buckets = new_n_buckets + 1u;
  if(!(new_n_buckets >= 4u))
    new_n_buckets = (unsigned int)4;

  if(h->size >= (unsigned int)((double)new_n_buckets * __ac_HASH_UPPER + 0.5))
    j = (unsigned int)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    new_flags = (unsigned int *)return_value_malloc_1;
    if(new_flags == ((unsigned int *)NULL))
      return -1;

    memset((void *)new_flags, 0xaa, (unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    if(!(h->n_buckets >= new_n_buckets))
    {
      void **new_keys;
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
      new_keys = (void **)return_value_realloc_2;
      if(new_keys == ((void **)NULL))
      {
        free((void *)new_flags);
        return -1;
      }

      h->keys = new_keys;
      {
        void **new_vals;
        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
        new_vals = (void **)return_value_realloc_3;
        if(new_vals == ((void **)NULL))
        {
          free((void *)new_flags);
          return -1;
        }

        h->vals = new_vals;
      }
    }

  }
  _Bool tmp_if_expr_4;
  void *return_value_realloc_6;
  if(!(j == 0u))
  {
    j = (unsigned int)0;
    for( ; !(j == h->n_buckets); j = j + 1u)
      if((3u & h->flags[(signed long int)(j >> 4)] >> ((0xfU & j) << 1)) == 0u)
      {
        void *key = h->keys[(signed long int)j];
        void *val;
        unsigned int new_mask = new_n_buckets - (unsigned int)1;
        val = h->vals[(signed long int)j];
        h->flags[(signed long int)(j >> 4)] = h->flags[(signed long int)(j >> 4)] | (unsigned int)(1ul << ((j & 0xfU) << 1));
        while((_Bool)1)
        {
          unsigned int k;
          unsigned int i;
          unsigned int step = (unsigned int)0;
          k=kh_x509fpr_hash_func(key);
          i = k & new_mask;
          for( ; (2u & new_flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u; i = i + step & new_mask)
            step = step + 1u;
          new_flags[(signed long int)(i >> 4)] = new_flags[(signed long int)(i >> 4)] & (unsigned int)~(2ul << ((i & 0xfU) << 1));
          if(!(i >= h->n_buckets))
            tmp_if_expr_4 = (h->flags[(signed long int)(i >> 4)] >> ((i & 0xfU) << 1) & (unsigned int)3) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
          {
            void *kh_resize_sha1map_t__1__2__1__1__1__1__1__1__tmp = h->keys[(signed long int)i];
            h->keys[(signed long int)i] = key;
            key = kh_resize_sha1map_t__1__2__1__1__1__1__1__1__tmp;
            {
              void *tmp = h->vals[(signed long int)i];
              h->vals[(signed long int)i] = val;
              val = tmp;
            }
            h->flags[(signed long int)(i >> 4)] = h->flags[(signed long int)(i >> 4)] | (unsigned int)(1ul << ((i & 0xfU) << 1));
          }

          else
          {
            h->keys[(signed long int)i] = key;
            h->vals[(signed long int)i] = val;
            break;
          }
        }
      }

    if(!(new_n_buckets >= h->n_buckets))
    {
      void *return_value_realloc_5;
      return_value_realloc_5=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
      h->keys = (void **)return_value_realloc_5;
      return_value_realloc_6=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
      h->vals = (void **)return_value_realloc_6;
    }

    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (unsigned int)((double)h->n_buckets * __ac_HASH_UPPER + 0.5);
  }

  return 0;
}

// kh_x509fpr_hash_func
// file cachefkcrt.c line 42
static inline unsigned int kh_x509fpr_hash_func(void *b)
{
  unsigned int *p = (unsigned int *)((char *)b + (signed long int)20);
  unsigned int h = (unsigned int)0;
  do
  {
    p = p - 1l;
    if(!(p >= (unsigned int *)b))
      break;

    h = h ^ *p;
  }
  while((_Bool)1);
  return h;
}

// log_connect_close
// file log.c line 210
static void log_connect_close(void)
{
  close(connect_fd);
}

// log_connect_open
// file log.c line 169
static signed int log_connect_open(const char *logfile)
{
  connect_fd=open(logfile, 01 | 02000 | 0100, 0660);
  if(connect_fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_err_printf("Failed to open '%s' for writing: %s\n", logfile, return_value_strerror_2);
    return -1;
  }

  return 0;
}

// log_connect_writecb
// file log.c line 187
static signed long int log_connect_writecb(void *fh, const void *buf, unsigned long int sz)
{
  char timebuf[32l];
  signed long int epoch;
  struct tm *utc;
  unsigned long int n;
  time(&epoch);
  utc=gmtime(&epoch);
  n=strftime(timebuf, sizeof(char [32l]) /*32ul*/ , "%Y-%m-%d %H:%M:%S UTC ", utc);
  _Bool tmp_if_expr_5;
  signed long int return_value_write_4;
  if(n == 0ul)
  {
    log_err_printf("Error from strftime(): buffer too small\n");
    return (signed long int)-1;
  }

  else
  {
    signed long int return_value_write_3;
    return_value_write_3=write(connect_fd, (const void *)timebuf, n);
    if(return_value_write_3 == -1l)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_write_4=write(connect_fd, buf, sz);
      tmp_if_expr_5 = return_value_write_4 == (signed long int)-1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_err_printf("Warning: Failed to write to connect log: %s\n", return_value_strerror_2);
    }

    return (signed long int)0;
  }
}

// log_content_close
// file log.h line 65
signed int log_content_close(struct log_content_ctx **pctx)
{
  signed int rv = 0;
  _Bool tmp_if_expr_1;
  if(*pctx == ((struct log_content_ctx *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !((*pctx)->open != 0u) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -1;

  else
  {
    signed int return_value_logger_close_2;
    return_value_logger_close_2=logger_close(content_log, (void *)*pctx);
    if(return_value_logger_close_2 == -1)
      rv = -1;

    *pctx = (struct log_content_ctx *)(void *)0;
    return rv;
  }
}

// log_content_common_writecb
// file log.c line 507
static signed long int log_content_common_writecb(void *fh, const void *buf, unsigned long int sz)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  signed long int return_value_write_3;
  return_value_write_3=write(ctx->fd, buf, sz);
  if(return_value_write_3 == -1l)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_err_printf("Warning: Failed to write to content log: %s\n", return_value_strerror_2);
    return (signed long int)-1;
  }

  return (signed long int)0;
}

// log_content_dir_closecb
// file log.c line 534
static void log_content_dir_closecb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  if(!(ctx->u.dir.filename == ((char *)NULL)))
    free((void *)ctx->u.dir.filename);

  if(!(ctx->fd == 1))
    close(ctx->fd);

  free((void *)ctx);
}

// log_content_dir_opencb
// file log.c line 520
static signed int log_content_dir_opencb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  ctx->fd=open(ctx->u.dir.filename, 01 | 02000 | 0100, 0660);
  if(ctx->fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    log_err_printf("Failed to open '%s': %s (%i)\n", ctx->u.dir.filename, return_value_strerror_2, *return_value___errno_location_3);
    return -1;
  }

  return 0;
}

// log_content_file_closecb
// file log.c line 603
static void log_content_file_closecb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  if(!(ctx->u.file.header_req == ((char *)NULL)))
    free((void *)ctx->u.file.header_req);

  if(!(ctx->u.file.header_resp == ((char *)NULL)))
    free((void *)ctx->u.file.header_resp);

  free((void *)ctx);
}

// log_content_file_fini
// file log.c line 261
static void log_content_file_fini(void)
{
  if(!(content_fd == -1))
  {
    close(content_fd);
    content_fd = -1;
  }

}

// log_content_file_preinit
// file log.c line 249
static signed int log_content_file_preinit(const char *logfile)
{
  content_fd=open(logfile, 01 | 02000 | 0100, 0660);
  if(content_fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_err_printf("Failed to open '%s' for writing: %s\n", logfile, return_value_strerror_2);
    return -1;
  }

  return 0;
}

// log_content_file_prepcb
// file log.c line 618
static struct logbuf * log_content_file_prepcb(void *fh, unsigned long int prepflags, struct logbuf *lb)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  signed int is_request = (signed int)!(!((prepflags & (unsigned long int)1) != 0ul));
  struct logbuf *head;
  signed long int epoch;
  struct tm *utc;
  char *header;
  char *tmp_if_expr_1;
  if(!(is_request == 0))
    tmp_if_expr_1 = ctx->u.file.header_req;

  else
    tmp_if_expr_1 = ctx->u.file.header_resp;
  header = tmp_if_expr_1;
  signed long int return_value_logbuf_size_2;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strftime_4;
  if(!(header == ((char *)NULL)))
  {
    return_value_logbuf_size_2=logbuf_size(lb);
    head=logbuf_new_printf(lb->fh, lb, " (%zu):\n", return_value_logbuf_size_2);
    if(head == ((struct logbuf *)NULL))
    {
      log_err_printf("Failed to allocate memory\n");
      logbuf_free(lb);
      return (struct logbuf *)(void *)0;
    }

    lb = head;
    return_value_strlen_3=strlen(header);
    head=logbuf_new_copy((const void *)header, return_value_strlen_3, lb->fh, lb);
    if(head == ((struct logbuf *)NULL))
    {
      log_err_printf("Failed to allocate memory\n");
      logbuf_free(lb);
      return (struct logbuf *)(void *)0;
    }

    lb = head;
    head=logbuf_new_alloc((unsigned long int)32, lb->fh, lb);
    if(head == ((struct logbuf *)NULL))
    {
      log_err_printf("Failed to allocate memory\n");
      logbuf_free(lb);
      return (struct logbuf *)(void *)0;
    }

    lb = head;
    time(&epoch);
    utc=gmtime(&epoch);
    return_value_strftime_4=strftime((char *)lb->buf, (unsigned long int)lb->sz, "%Y-%m-%d %H:%M:%S UTC ", utc);
    lb->sz = (signed long int)return_value_strftime_4;
  }


out:
  ;
  return lb;
}

// log_content_format_pathspec
// file log.c line 279
static char * log_content_format_pathspec(const char *logspec, char *srcaddr, char *dstaddr, char *exec_path, char *user, char *group)
{
  unsigned long int path_buflen = (unsigned long int)1024;
  char *path_buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(path_buflen);
  path_buf = (char *)return_value_malloc_1;
  unsigned long int tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  unsigned long int tmp_if_expr_5;
  unsigned long int return_value_strlen_4;
  unsigned long int tmp_if_expr_7;
  unsigned long int return_value_strlen_6;
  unsigned long int tmp_if_expr_9;
  unsigned long int return_value_strlen_8;
  signed long int epoch;
  struct tm *utc;
  if(path_buf == ((char *)NULL))
  {
    log_err_printf("failed to allocate path buffer\n");
    return (char *)(void *)0;
  }

  else
  {
    path_buf[(signed long int)0] = (char)0;
    unsigned long int path_len = (unsigned long int)0;
    const char *p = logspec;
    for( ; !((signed int)*p == 0); p = p + 1l)
    {
      const char *elem = (const char *)(void *)0;
      unsigned long int elem_len = (unsigned long int)0;
      const char iso8601[15l] = { '%', 'Y', '%', 'm', '%', 'd', 'T', '%', 'H', '%', 'M', '%', 'S', 'Z', 0 };
      char timebuf[24l];
      if((signed int)*p == 37)
      {
        p = p + 1l;
        switch((signed int)*p)
        {
          case 0:
          {
            p = p - 1l;
            elem_len = (unsigned long int)0;
            break;
          }
          case 37:
          {
            elem = p;
            elem_len = (unsigned long int)1;
            break;
          }
          case 100:
          {
            elem = dstaddr;
            elem_len=strlen(dstaddr);
            break;
          }
          case 115:
          {
            elem = srcaddr;
            elem_len=strlen(srcaddr);
            break;
          }
          case 120:
          {
            if(!(exec_path == ((char *)NULL)))
            {
              char *match = exec_path;
              do
              {
                match=strchr(match, 47);
                if(match == ((char *)NULL))
                  break;

                match = match + 1l;
                elem = match;
              }
              while((_Bool)1);
              if(!(elem == ((const char *)NULL)))
              {
                return_value_strlen_2=strlen(elem);
                tmp_if_expr_3 = return_value_strlen_2;
              }

              else
                tmp_if_expr_3 = (unsigned long int)0;
              elem_len = tmp_if_expr_3;
            }

            else
              elem_len = (unsigned long int)0;
            break;
          }
          case 88:
          {
            elem = exec_path;
            if(!(exec_path == ((char *)NULL)))
            {
              return_value_strlen_4=strlen(exec_path);
              tmp_if_expr_5 = return_value_strlen_4;
            }

            else
              tmp_if_expr_5 = (unsigned long int)0;
            elem_len = tmp_if_expr_5;
            break;
          }
          case 117:
          {
            elem = user;
            if(!(user == ((char *)NULL)))
            {
              return_value_strlen_6=strlen(user);
              tmp_if_expr_7 = return_value_strlen_6;
            }

            else
              tmp_if_expr_7 = (unsigned long int)0;
            elem_len = tmp_if_expr_7;
            break;
          }
          case 103:
          {
            elem = group;
            if(!(group == ((char *)NULL)))
            {
              return_value_strlen_8=strlen(group);
              tmp_if_expr_9 = return_value_strlen_8;
            }

            else
              tmp_if_expr_9 = (unsigned long int)0;
            elem_len = tmp_if_expr_9;
            break;
          }
          case 84:
          {
            time(&epoch);
            utc=gmtime(&epoch);
            strftime(timebuf, sizeof(char [24l]) /*24ul*/ , iso8601, utc);
            elem = timebuf;
            elem_len = sizeof(char [24l]) /*24ul*/ ;
          }
        }
        goto __CPROVER_DUMP_L27;
      }

      elem = p;
      elem_len = (unsigned long int)1;

    __CPROVER_DUMP_L27:
      ;
      if(elem_len >= 1ul)
      {
        if(!(path_buflen + -path_len >= 1ul + elem_len))
        {
          path_buflen = path_buflen + elem_len + (unsigned long int)1024;
          char *newbuf;
          void *return_value_realloc_10;
          return_value_realloc_10=realloc((void *)path_buf, path_buflen);
          newbuf = (char *)return_value_realloc_10;
          if(newbuf == ((char *)NULL))
          {
            log_err_printf("failed to reallocate path buffer\n");
            free((void *)path_buf);
            return (char *)(void *)0;
          }

          path_buf = newbuf;
        }

        strncat(path_buf, elem, elem_len);
        path_len = path_len + elem_len;
      }

    }
    /* assertion path_buflen > path_len */
    assert(path_buflen > path_len);
    path_buf[(signed long int)path_len] = (char)0;
    return path_buf;
  }
}

// log_content_open
// file log.h line 61
signed int log_content_open(struct log_content_ctx **pctx, struct opts *opts, char *srcaddr, char *dstaddr, char *exec_path, char *user, char *group)
{
  struct log_content_ctx *ctx;
  if(!(*pctx == ((struct log_content_ctx *)NULL)))
    return 0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct log_content_ctx) /*24ul*/ );
    *pctx = (struct log_content_ctx *)return_value_malloc_1;
    if(*pctx == ((struct log_content_ctx *)NULL))
      return -1;

    else
    {
      ctx = *pctx;
      if(!(opts->contentlog_isdir == 0u))
      {
        char timebuf[24l];
        signed long int epoch;
        struct tm *utc;
        signed long int return_value_time_2;
        return_value_time_2=time(&epoch);
        if(return_value_time_2 == -1l)
        {
          log_err_printf("Failed to get time\n");
          goto errout;
        }

        utc=gmtime(&epoch);
        if(utc == ((struct tm *)NULL))
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          char *return_value_strerror_4;
          return_value_strerror_4=strerror(*return_value___errno_location_3);
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          log_err_printf("Failed to convert time: %s (%i)\n", return_value_strerror_4, *return_value___errno_location_5);
          goto errout;
        }

        unsigned long int return_value_strftime_9;
        return_value_strftime_9=strftime(timebuf, sizeof(char [24l]) /*24ul*/ , "%Y%m%dT%H%M%SZ", utc);
        if(return_value_strftime_9 == 0ul)
        {
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          char *return_value_strerror_7;
          return_value_strerror_7=strerror(*return_value___errno_location_6);
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          log_err_printf("Failed to format time: %s (%i)\n", return_value_strerror_7, *return_value___errno_location_8);
          goto errout;
        }

        signed int return_value_asprintf_13;
        return_value_asprintf_13=asprintf(&ctx->u.dir.filename, "%s/%s-%s-%s.log", opts->contentlog, (const void *)timebuf, srcaddr, dstaddr);
        if(!(return_value_asprintf_13 >= 0))
        {
          signed int *return_value___errno_location_10;
          return_value___errno_location_10=__errno_location();
          char *return_value_strerror_11;
          return_value_strerror_11=strerror(*return_value___errno_location_10);
          signed int *return_value___errno_location_12;
          return_value___errno_location_12=__errno_location();
          log_err_printf("Failed to format filename: %s (%i)\n", return_value_strerror_11, *return_value___errno_location_12);
          goto errout;
        }

      }

      else
        if(!(opts->contentlog_isspec == 0u))
        {
          ctx->u.spec.filename=log_content_format_pathspec(opts->contentlog, srcaddr, dstaddr, exec_path, user, group);
          if(ctx->u.spec.filename == ((char *)NULL))
            goto errout;

        }

        else
        {
          ctx->fd = content_fd;
          signed int return_value_asprintf_14;
          return_value_asprintf_14=asprintf(&ctx->u.file.header_req, "%s -> %s", srcaddr, dstaddr);
          if(!(return_value_asprintf_14 >= 0))
            goto errout;

          signed int return_value_asprintf_15;
          return_value_asprintf_15=asprintf(&ctx->u.file.header_resp, "%s -> %s", dstaddr, srcaddr);
          if(!(return_value_asprintf_15 >= 0))
          {
            free((void *)ctx->u.file.header_req);
            goto errout;
          }

        }
      signed int return_value_logger_open_16;
      return_value_logger_open_16=logger_open(content_log, (void *)ctx);
      if(!(return_value_logger_open_16 == -1))
      {
        ctx->open = (unsigned int)1;
        return 0;
      }

      else
      {

      errout:
        ;
        free((void *)ctx);
        *pctx = (struct log_content_ctx *)(void *)0;
        return -1;
      }
    }
  }
}

// log_content_spec_closecb
// file log.c line 583
static void log_content_spec_closecb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  if(!(ctx->u.spec.filename == ((char *)NULL)))
    free((void *)ctx->u.spec.filename);

  if(!(ctx->fd == -1))
    close(ctx->fd);

  free((void *)ctx);
}

// log_content_spec_opencb
// file log.c line 546
static signed int log_content_spec_opencb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  char *filedir;
  char *filename2;
  filename2=strdup(ctx->u.spec.filename);
  if(filename2 == ((char *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    log_err_printf("Could not duplicate filname: %s (%i)\n", return_value_strerror_2, *return_value___errno_location_3);
    return -1;
  }

  filedir=dirname(filename2);
  if(filedir == ((char *)NULL))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    log_err_printf("Could not get dirname: %s (%i)\n", return_value_strerror_5, *return_value___errno_location_6);
    free((void *)filename2);
    return -1;
  }

  signed int return_value_sys_mkpath_10;
  return_value_sys_mkpath_10=sys_mkpath(filedir, (unsigned int)0755);
  if(return_value_sys_mkpath_10 == -1)
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    char *return_value_strerror_8;
    return_value_strerror_8=strerror(*return_value___errno_location_7);
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    log_err_printf("Could not create directory '%s': %s (%i)\n", filedir, return_value_strerror_8, *return_value___errno_location_9);
    free((void *)filename2);
    return -1;
  }

  free((void *)filename2);
  ctx->fd=open(ctx->u.spec.filename, 01 | 02000 | 0100, 0660);
  if(ctx->fd == -1)
  {
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    char *return_value_strerror_12;
    return_value_strerror_12=strerror(*return_value___errno_location_11);
    log_err_printf("Failed to open '%s': %s\n", ctx->u.spec.filename, return_value_strerror_12);
    return -1;
  }

  return 0;
}

// log_content_submit
// file log.h line 63
signed int log_content_submit(struct log_content_ctx *ctx, struct logbuf *lb, signed int is_request)
{
  unsigned long int prepflags = (unsigned long int)0;
  if(ctx->open == 0u)
  {
    log_err_printf("log_content_submit called on closed ctx\n");
    return -1;
  }

  else
  {
    if(!(is_request == 0))
      prepflags = prepflags | (unsigned long int)1;

    signed int return_value_logger_submit_1;
    return_value_logger_submit_1=logger_submit(content_log, (void *)ctx, prepflags, lb);
    return return_value_logger_submit_1;
  }
}

// log_dbg_mode
// file log.h line 44
void log_dbg_mode(signed int mode)
{
  dbg_mode = mode;
}

// log_dbg_print_free
// file log.h line 42
signed int log_dbg_print_free(char *s)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  signed int return_value_log_dbg_write_free_2;
  return_value_log_dbg_write_free_2=log_dbg_write_free((void *)s, return_value_strlen_1 + (unsigned long int)1);
  return return_value_log_dbg_write_free_2;
}

// log_dbg_printf
// file log.h line 41
signed int log_dbg_printf(const char *fmt, ...)
{
  void **ap;
  char *buf;
  signed int rv;
  if(dbg_mode == 0)
    return 0;

  else
  {
    ap = (void **)&fmt;
    rv=vasprintf(&buf, fmt, ap);
    ap = ((void **)NULL);
    if(!(rv >= 0))
      return -1;

    else
    {
      signed int return_value_log_dbg_print_free_1;
      return_value_log_dbg_print_free_1=log_dbg_print_free(buf);
      return return_value_log_dbg_print_free_1;
    }
  }
}

// log_dbg_write_free
// file log.c line 115
signed int log_dbg_write_free(void *buf, unsigned long int sz)
{
  if(dbg_mode == 0)
    return 0;

  else
  {
    if(!(err_started == 0))
    {
      signed int return_value_logger_write_freebuf_1;
      return_value_logger_write_freebuf_1=logger_write_freebuf(err_log, (void *)0, (unsigned long int)0, buf, sz);
      return return_value_logger_write_freebuf_1;
    }

    else
    {
      log_err_writecb((void *)0, buf, sz);
      free(buf);
    }
    return 0;
  }
}

// log_err_mode
// file log.h line 37
void log_err_mode(signed int mode)
{
  err_mode = mode;
}

// log_err_printf
// file log.h line 36
signed int log_err_printf(const char *fmt, ...)
{
  void **ap;
  char *buf;
  signed int rv;
  ap = (void **)&fmt;
  rv=vasprintf(&buf, fmt, ap);
  ap = ((void **)NULL);
  if(!(rv >= 0))
    return -1;

  else
  {
    if(!(err_started == 0))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(buf);
      signed int return_value_logger_write_freebuf_2;
      return_value_logger_write_freebuf_2=logger_write_freebuf(err_log, (void *)0, (unsigned long int)0, (void *)buf, return_value_strlen_1 + (unsigned long int)1);
      return return_value_logger_write_freebuf_2;
    }

    else
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(buf);
      log_err_writecb((void *)0, (const void *)(unsigned char *)buf, return_value_strlen_3 + (unsigned long int)1);
      free((void *)buf);
    }
    return 0;
  }
}

// log_err_writecb
// file log.c line 65
static signed long int log_err_writecb(void *fh, const void *buf, unsigned long int sz)
{
  unsigned long int return_value_fwrite_1;
  switch(err_mode)
  {
    case 0:
    {
      return_value_fwrite_1=fwrite(buf, sz - (unsigned long int)1, (unsigned long int)1, stderr);
      return (signed long int)return_value_fwrite_1;
    }
    case 1:
    {
      syslog(3, "%s", (const char *)buf);
      return (signed long int)0;
    }
    default:
      return (signed long int)-1;
  }
}

// log_fini
// file log.h line 69
void log_fini(void)
{
  if(!(content_log == ((struct logger *)NULL)))
    logger_leave(content_log);

  if(!(connect_log == ((struct logger *)NULL)))
    logger_leave(connect_log);

  logger_leave(err_log);
  if(!(content_log == ((struct logger *)NULL)))
    logger_join(content_log);

  if(!(connect_log == ((struct logger *)NULL)))
    logger_join(connect_log);

  logger_join(err_log);
  if(!(content_log == ((struct logger *)NULL)))
    logger_free(content_log);

  if(!(connect_log == ((struct logger *)NULL)))
    logger_free(connect_log);

  logger_free(err_log);
  if(!(content_log == ((struct logger *)NULL)))
    log_content_file_fini();

  if(!(connect_log == ((struct logger *)NULL)))
    log_connect_close();

}

// log_init
// file log.h line 68
signed int log_init(struct opts *opts)
{
  signed int return_value_logger_start_1;
  signed int return_value_logger_start_2;
  signed int return_value_logger_start_3;
  if(!(err_log == ((struct logger *)NULL)))
  {
    return_value_logger_start_1=logger_start(err_log);
    if(!(return_value_logger_start_1 == -1))
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(opts->debug == 0u)
      err_started = 1;

    if(!(connect_log == ((struct logger *)NULL)))
    {
      return_value_logger_start_2=logger_start(connect_log);
      if(!(return_value_logger_start_2 == -1))
        goto __CPROVER_DUMP_L3;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(!(content_log == ((struct logger *)NULL)))
      {
        return_value_logger_start_3=logger_start(content_log);
        if(!(return_value_logger_start_3 == -1))
          goto __CPROVER_DUMP_L4;

        return -1;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        return 0;
      }
    }
  }
}

// log_preinit
// file log.h line 67
signed int log_preinit(struct opts *opts)
{
  signed int (*opencb)(void *);
  void (*closecb)(void *);
  signed long int (*writecb)(void *, const void *, unsigned long int);
  struct logbuf * (*prepcb)(void *, unsigned long int, struct logbuf *);
  if(!(opts->contentlog == ((char *)NULL)))
  {
    if(!(opts->contentlog_isdir == 0u))
    {
      opencb = log_content_dir_opencb;
      closecb = log_content_dir_closecb;
      writecb = log_content_common_writecb;
      prepcb = (struct logbuf * (*)(void *, unsigned long int, struct logbuf *))(void *)0;
    }

    else
      if(!(opts->contentlog_isspec == 0u))
      {
        opencb = log_content_spec_opencb;
        closecb = log_content_spec_closecb;
        writecb = log_content_common_writecb;
        prepcb = (struct logbuf * (*)(void *, unsigned long int, struct logbuf *))(void *)0;
      }

      else
      {
        signed int return_value_log_content_file_preinit_1;
        return_value_log_content_file_preinit_1=log_content_file_preinit(opts->contentlog);
        if(return_value_log_content_file_preinit_1 == -1)
          goto out;

        opencb = (signed int (*)(void *))(void *)0;
        closecb = log_content_file_closecb;
        writecb = log_content_common_writecb;
        prepcb = log_content_file_prepcb;
      }
    content_log=logger_new(opencb, closecb, writecb, prepcb);
    if(!(content_log == ((struct logger *)NULL)))
      goto __CPROVER_DUMP_L4;

    log_content_file_fini();
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    if(!(opts->connectlog == ((char *)NULL)))
    {
      signed int return_value_log_connect_open_2;
      return_value_log_connect_open_2=log_connect_open(opts->connectlog);
      if(return_value_log_connect_open_2 == -1)
        goto out;

      connect_log=logger_new((signed int (*)(void *))(void *)0, (void (*)(void *))(void *)0, log_connect_writecb, (struct logbuf * (*)(void *, unsigned long int, struct logbuf *))(void *)0);
      if(connect_log == ((struct logger *)NULL))
      {
        log_connect_close();
        goto out;
      }

    }

    err_log=logger_new((signed int (*)(void *))(void *)0, (void (*)(void *))(void *)0, log_err_writecb, (struct logbuf * (*)(void *, unsigned long int, struct logbuf *))(void *)0);
    if(!(err_log == ((struct logger *)NULL)))
      return 0;

  }

out:
  ;
  if(!(content_log == ((struct logger *)NULL)))
  {
    log_content_file_fini();
    logger_free(content_log);
  }

  if(!(connect_log == ((struct logger *)NULL)))
  {
    log_connect_close();
    logger_free(connect_log);
  }

  return -1;
}

// logbuf_free
// file logbuf.h line 54
void logbuf_free(struct logbuf *lb)
{
  if(!(lb->buf == ((unsigned char *)NULL)))
    free((void *)lb->buf);

  if(!(lb->next == ((struct logbuf *)NULL)))
    logbuf_free(lb->next);

  free((void *)lb);
}

// logbuf_new
// file logbuf.c line 47
struct logbuf * logbuf_new(void *buf, unsigned long int sz, void *fh, struct logbuf *next)
{
  struct logbuf *lb;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct logbuf) /*40ul*/ );
  lb = (struct logbuf *)return_value_malloc_1;
  if(lb == ((struct logbuf *)NULL))
    return (struct logbuf *)(void *)0;

  else
  {
    lb->buf = (unsigned char *)buf;
    lb->sz = (signed long int)sz;
    lb->fh = fh;
    lb->ctl = (unsigned long int)0;
    lb->next = next;
    return lb;
  }
}

// logbuf_new_alloc
// file logbuf.h line 48
struct logbuf * logbuf_new_alloc(unsigned long int sz, void *fh, struct logbuf *next)
{
  struct logbuf *lb;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct logbuf) /*40ul*/ );
  lb = (struct logbuf *)return_value_malloc_1;
  if(lb == ((struct logbuf *)NULL))
    return (struct logbuf *)(void *)0;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sz);
    lb->buf = (unsigned char *)return_value_malloc_2;
    if(lb->buf == ((unsigned char *)NULL))
    {
      free((void *)lb);
      return (struct logbuf *)(void *)0;
    }

    else
    {
      lb->sz = (signed long int)sz;
      lb->fh = fh;
      lb->ctl = (unsigned long int)0;
      lb->next = next;
      return lb;
    }
  }
}

// logbuf_new_copy
// file logbuf.h line 49
struct logbuf * logbuf_new_copy(const void *buf, unsigned long int sz, void *fh, struct logbuf *next)
{
  struct logbuf *lb;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct logbuf) /*40ul*/ );
  lb = (struct logbuf *)return_value_malloc_1;
  if(lb == ((struct logbuf *)NULL))
    return (struct logbuf *)(void *)0;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sz);
    lb->buf = (unsigned char *)return_value_malloc_2;
    if(lb->buf == ((unsigned char *)NULL))
    {
      free((void *)lb);
      return (struct logbuf *)(void *)0;
    }

    else
    {
      memcpy((void *)lb->buf, buf, sz);
      lb->sz = (signed long int)sz;
      lb->fh = fh;
      lb->ctl = (unsigned long int)0;
      lb->next = next;
      return lb;
    }
  }
}

// logbuf_new_printf
// file logbuf.h line 50
struct logbuf * logbuf_new_printf(void *fh, struct logbuf *next, const char *fmt, ...)
{
  void **ap;
  struct logbuf *lb;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct logbuf) /*40ul*/ );
  lb = (struct logbuf *)return_value_malloc_1;
  if(lb == ((struct logbuf *)NULL))
    return (struct logbuf *)(void *)0;

  else
  {
    ap = (void **)&fmt;
    signed int return_value_vasprintf_2;
    return_value_vasprintf_2=vasprintf((char **)&lb->buf, fmt, ap);
    lb->sz = (signed long int)return_value_vasprintf_2;
    ap = ((void **)NULL);
    if(!(lb->sz >= 0l))
    {
      free((void *)lb);
      return (struct logbuf *)(void *)0;
    }

    else
    {
      lb->fh = fh;
      lb->ctl = (unsigned long int)0;
      lb->next = next;
      return lb;
    }
  }
}

// logbuf_size
// file logbuf.h line 52
signed long int logbuf_size(struct logbuf *lb)
{
  signed long int sz = lb->sz;
  if(!(lb->next == ((struct logbuf *)NULL)))
  {
    signed long int return_value_logbuf_size_1;
    return_value_logbuf_size_1=logbuf_size(lb->next);
    sz = sz + return_value_logbuf_size_1;
  }

  return sz;
}

// logbuf_write_free
// file logbuf.c line 149
signed long int logbuf_write_free(struct logbuf *lb, signed long int (*writefunc)(void *, const void *, unsigned long int))
{
  signed long int rv1;
  signed long int rv2 = (signed long int)0;
  rv1=writefunc(lb->fh, (const void *)lb->buf, (unsigned long int)lb->sz);
  if(!(lb->buf == ((unsigned char *)NULL)))
    free((void *)lb->buf);

  if(!(lb->next == ((struct logbuf *)NULL)))
  {
    if(rv1 == -1l)
      logbuf_free(lb->next);

    else
    {
      lb->next->fh = lb->fh;
      rv2=logbuf_write_free(lb->next, writefunc);
    }
  }

  free((void *)lb);
  if(rv1 == -1l || rv2 == -1l)
    return (signed long int)-1;

  else
    return rv1 + rv2;
}

// logger_clear
// file logger.c line 59
static void logger_clear(struct logger *logger)
{
  memset((void *)logger, 0, sizeof(struct logger) /*48ul*/ );
}

// logger_close
// file logger.h line 53
signed int logger_close(struct logger *logger, void *fh)
{
  struct logbuf *lb;
  if(logger->close == ((void (*)(void *))NULL))
    return 0;

  else
  {
    lb=logbuf_new((void *)0, (unsigned long int)0, (void *)0, (struct logbuf *)(void *)0);
    lb->fh = fh;
    lb->ctl = lb->ctl | (unsigned long int)2;
    void *return_value_thrqueue_enqueue_1;
    return_value_thrqueue_enqueue_1=thrqueue_enqueue(logger->queue, (void *)lb);
    return return_value_thrqueue_enqueue_1 != NULL ? 0 : -1;
  }
}

// logger_free
// file logger.h line 47
void logger_free(struct logger *logger)
{
  if(!(logger->queue == ((struct thrqueue *)NULL)))
    thrqueue_free(logger->queue);

  free((void *)logger);
}

// logger_join
// file logger.h line 50
signed int logger_join(struct logger *logger)
{
  signed int rv;
  rv=pthread_join(logger->thr, (void **)(void *)0);
  if(!(rv == 0))
    return -1;

  else
    return 0;
}

// logger_leave
// file logger.h line 49
void logger_leave(struct logger *logger)
{
  thrqueue_unblock_dequeue(logger->queue);
  sched_yield();
}

// logger_new
// file logger.h line 44
struct logger * logger_new(signed int (*openfunc)(void *), void (*closefunc)(void *), signed long int (*writefunc)(void *, const void *, unsigned long int), struct logbuf * (*prepfunc)(void *, unsigned long int, struct logbuf *))
{
  struct logger *logger;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct logger) /*48ul*/ );
  logger = (struct logger *)return_value_malloc_1;
  if(logger == ((struct logger *)NULL))
    return (struct logger *)(void *)0;

  else
  {
    logger_clear(logger);
    logger->open = openfunc;
    logger->close = closefunc;
    logger->write = writefunc;
    logger->prep = prepfunc;
    logger->queue = (struct thrqueue *)(void *)0;
    return logger;
  }
}

// logger_open
// file logger.h line 52
signed int logger_open(struct logger *logger, void *fh)
{
  struct logbuf *lb;
  if(logger->open == ((signed int (*)(void *))NULL))
    return 0;

  else
  {
    lb=logbuf_new((void *)0, (unsigned long int)0, (void *)0, (struct logbuf *)(void *)0);
    lb->fh = fh;
    lb->ctl = lb->ctl | (unsigned long int)1;
    void *return_value_thrqueue_enqueue_1;
    return_value_thrqueue_enqueue_1=thrqueue_enqueue(logger->queue, (void *)lb);
    return return_value_thrqueue_enqueue_1 != NULL ? 0 : -1;
  }
}

// logger_print
// file logger.c line 273
signed int logger_print(struct logger *logger, void *fh, unsigned long int prepflags, const char *s)
{
  struct logbuf *lb;
  unsigned long int tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(!(s == ((const char *)NULL)))
  {
    return_value_strlen_1=strlen(s);
    tmp_if_expr_2 = return_value_strlen_1;
  }

  else
    tmp_if_expr_2 = (unsigned long int)0;
  lb=logbuf_new_copy((const void *)s, tmp_if_expr_2, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    signed int return_value_logger_submit_3;
    return_value_logger_submit_3=logger_submit(logger, fh, prepflags, lb);
    return return_value_logger_submit_3;
  }
}

// logger_print_freebuf
// file logger.h line 62
signed int logger_print_freebuf(struct logger *logger, void *fh, unsigned long int prepflags, char *s)
{
  struct logbuf *lb;
  unsigned long int tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(!(s == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(s);
    tmp_if_expr_2 = return_value_strlen_1;
  }

  else
    tmp_if_expr_2 = (unsigned long int)0;
  lb=logbuf_new((void *)s, tmp_if_expr_2, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    signed int return_value_logger_submit_3;
    return_value_logger_submit_3=logger_submit(logger, fh, prepflags, lb);
    return return_value_logger_submit_3;
  }
}

// logger_printf
// file logger.c line 244
signed int logger_printf(struct logger *logger, void *fh, unsigned long int prepflags, const char *fmt, ...)
{
  void **ap;
  struct logbuf *lb;
  lb=logbuf_new((void *)0, (unsigned long int)0, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    ap = (void **)&fmt;
    signed int return_value_vasprintf_1;
    return_value_vasprintf_1=vasprintf((char **)&lb->buf, fmt, ap);
    lb->sz = (signed long int)return_value_vasprintf_1;
    ap = ((void **)NULL);
    if(!(lb->sz >= 0l))
    {
      logbuf_free(lb);
      return -1;
    }

    else
    {
      signed int return_value_logger_submit_2;
      return_value_logger_submit_2=logger_submit(logger, fh, prepflags, lb);
      return return_value_logger_submit_2;
    }
  }
}

// logger_start
// file logger.h line 48
signed int logger_start(struct logger *logger)
{
  signed int rv;
  if(!(logger->queue == ((struct thrqueue *)NULL)))
    thrqueue_free(logger->queue);

  logger->queue=thrqueue_new((unsigned long int)1024);
  rv=pthread_create(&logger->thr, (const union pthread_attr_t *)(void *)0, logger_thread, (void *)logger);
  if(!(rv == 0))
    return -1;

  else
  {
    sched_yield();
    return 0;
  }
}

// logger_stop
// file logger.c line 224
signed int logger_stop(struct logger *logger)
{
  logger_leave(logger);
  signed int return_value_logger_join_1;
  return_value_logger_join_1=logger_join(logger);
  return return_value_logger_join_1;
}

// logger_submit
// file logger.h line 54
signed int logger_submit(struct logger *logger, void *fh, unsigned long int prepflags, struct logbuf *lb)
{
  if(!(logger->prep == ((struct logbuf * (*)(void *, unsigned long int, struct logbuf *))NULL)))
    lb=logger->prep(fh, prepflags, lb);

  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    lb->fh = fh;
    lb->ctl = (unsigned long int)0;
    void *return_value_thrqueue_enqueue_1;
    return_value_thrqueue_enqueue_1=thrqueue_enqueue(logger->queue, (void *)lb);
    return return_value_thrqueue_enqueue_1 != NULL ? 0 : -1;
  }
}

// logger_thread
// file logger.c line 159
static void * logger_thread(void *arg)
{
  struct logger *logger = (struct logger *)arg;
  struct logbuf *lb;
  void *return_value_thrqueue_dequeue_1;
  do
  {
    return_value_thrqueue_dequeue_1=thrqueue_dequeue(logger->queue);
    lb = (struct logbuf *)return_value_thrqueue_dequeue_1;
    if(lb == ((struct logbuf *)NULL))
      break;

    if(!((1ul & lb->ctl) == 0ul))
      logger->open(lb->fh);

    else
      if(!((2ul & lb->ctl) == 0ul))
        logger->close(lb->fh);

      else
        logbuf_write_free(lb, logger->write);
  }
  while((_Bool)1);
  return (void *)0;
}

// logger_write
// file logger.c line 263
signed int logger_write(struct logger *logger, void *fh, unsigned long int prepflags, const void *buf, unsigned long int sz)
{
  struct logbuf *lb;
  lb=logbuf_new_copy(buf, sz, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    signed int return_value_logger_submit_1;
    return_value_logger_submit_1=logger_submit(logger, fh, prepflags, lb);
    return return_value_logger_submit_1;
  }
}

// logger_write_freebuf
// file logger.h line 64
signed int logger_write_freebuf(struct logger *logger, void *fh, unsigned long int prepflags, void *buf, unsigned long int sz)
{
  struct logbuf *lb;
  lb=logbuf_new(buf, sz, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    signed int return_value_logger_submit_1;
    return_value_logger_submit_1=logger_submit(logger, fh, prepflags, lb);
    return return_value_logger_submit_1;
  }
}

// main
// file main.c line 258
signed int main(signed int argc, char **argv)
{
  const char *argv0;
  signed int ch;
  struct opts *opts;
  char *natengine;
  signed int pidfd = -1;
  signed int rv = 1;
  argv0 = argv[(signed long int)0];
  opts=opts_new();
  const char *return_value_nat_getdefaultname_2;
  return_value_nat_getdefaultname_2=nat_getdefaultname();
  if(!(return_value_nat_getdefaultname_2 == ((const char *)NULL)))
  {
    const char *return_value_nat_getdefaultname_1;
    return_value_nat_getdefaultname_1=nat_getdefaultname();
    natengine=strdup(return_value_nat_getdefaultname_1);
    if(natengine == ((char *)NULL))
      oom_die(argv0);

  }

  else
    natengine = (char *)(void *)0;
  signed int return_value_ssl_x509chain_load_12;
  signed int return_value_sys_isdir_16;
  struct ec_key_st *ec;
  do
  {
    ch=getopt(argc, argv, "g:G:Zk:c:C:K:t:OPs:r:R:e:Eu:m:j:p:l:L:S:F:dDVh");
    if(ch == -1)
      break;

    switch(ch)
    {
      case 99:
      {
        if(!(opts->cacrt == ((struct x509_st *)NULL)))
          X509_free(opts->cacrt);

        opts->cacrt=ssl_x509_load(optarg);
        if(opts->cacrt == ((struct x509_st *)NULL))
        {
          fprintf(stderr, "%s: error loading CA cert from '%s':\n", argv0, optarg);
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          if(!(*return_value___errno_location_5 == 0))
          {
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            char *return_value_strerror_4;
            return_value_strerror_4=strerror(*return_value___errno_location_3);
            fprintf(stderr, "%s\n", return_value_strerror_4);
          }

          else
            ERR_print_errors_fp(stderr);
          exit(1);
        }

        ssl_x509_refcount_inc(opts->cacrt);
        sk_insert((struct stack_st *)opts->chain, (void *)opts->cacrt, 0);
        if(opts->cakey == ((struct evp_pkey_st *)NULL))
          opts->cakey=ssl_key_load(optarg);

        if(opts->dh == ((struct dh_st *)NULL))
          opts->dh=ssl_dh_load(optarg);

        break;
      }
      case 107:
      {
        if(!(opts->cakey == ((struct evp_pkey_st *)NULL)))
          EVP_PKEY_free(opts->cakey);

        opts->cakey=ssl_key_load(optarg);
        if(opts->cakey == ((struct evp_pkey_st *)NULL))
        {
          fprintf(stderr, "%s: error loading CA key from '%s':\n", argv0, optarg);
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          if(!(*return_value___errno_location_8 == 0))
          {
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            char *return_value_strerror_7;
            return_value_strerror_7=strerror(*return_value___errno_location_6);
            fprintf(stderr, "%s\n", return_value_strerror_7);
          }

          else
            ERR_print_errors_fp(stderr);
          exit(1);
        }

        if(opts->cacrt == ((struct x509_st *)NULL))
        {
          opts->cacrt=ssl_x509_load(optarg);
          if(!(opts->cacrt == ((struct x509_st *)NULL)))
          {
            ssl_x509_refcount_inc(opts->cacrt);
            sk_insert((struct stack_st *)opts->chain, (void *)opts->cacrt, 0);
          }

        }

        if(opts->dh == ((struct dh_st *)NULL))
          opts->dh=ssl_dh_load(optarg);

        break;
      }
      case 67:
      {
        return_value_ssl_x509chain_load_12=ssl_x509chain_load((struct x509_st **)(void *)0, &opts->chain, optarg);
        if(return_value_ssl_x509chain_load_12 == -1)
        {
          fprintf(stderr, "%s: error loading chain from '%s':\n", argv0, optarg);
          signed int *return_value___errno_location_11;
          return_value___errno_location_11=__errno_location();
          if(!(*return_value___errno_location_11 == 0))
          {
            signed int *return_value___errno_location_9;
            return_value___errno_location_9=__errno_location();
            char *return_value_strerror_10;
            return_value_strerror_10=strerror(*return_value___errno_location_9);
            fprintf(stderr, "%s\n", return_value_strerror_10);
          }

          else
            ERR_print_errors_fp(stderr);
          exit(1);
        }

        break;
      }
      case 75:
      {
        if(!(opts->key == ((struct evp_pkey_st *)NULL)))
          EVP_PKEY_free(opts->key);

        opts->key=ssl_key_load(optarg);
        if(opts->key == ((struct evp_pkey_st *)NULL))
        {
          fprintf(stderr, "%s: error loading leaf key from '%s':\n", argv0, optarg);
          signed int *return_value___errno_location_15;
          return_value___errno_location_15=__errno_location();
          if(!(*return_value___errno_location_15 == 0))
          {
            signed int *return_value___errno_location_13;
            return_value___errno_location_13=__errno_location();
            char *return_value_strerror_14;
            return_value_strerror_14=strerror(*return_value___errno_location_13);
            fprintf(stderr, "%s\n", return_value_strerror_14);
          }

          else
            ERR_print_errors_fp(stderr);
          exit(1);
        }

        if(opts->dh == ((struct dh_st *)NULL))
          opts->dh=ssl_dh_load(optarg);

        break;
      }
      case 116:
      {
        return_value_sys_isdir_16=sys_isdir(optarg);
        if(return_value_sys_isdir_16 == 0)
        {
          fprintf(stderr, "%s: '%s' is not a directory\n", argv0, optarg);
          exit(1);
        }

        if(!(opts->tgcrtdir == ((char *)NULL)))
          free((void *)opts->tgcrtdir);

        opts->tgcrtdir=strdup(optarg);
        if(opts->tgcrtdir == ((char *)NULL))
          oom_die(argv0);

        break;
      }
      case 79:
      {
        opts->deny_ocsp = (unsigned int)1;
        break;
      }
      case 80:
      {
        opts->passthrough = (unsigned int)1;
        break;
      }
      case 103:
      {
        if(!(opts->dh == ((struct dh_st *)NULL)))
          DH_free(opts->dh);

        opts->dh=ssl_dh_load(optarg);
        if(opts->dh == ((struct dh_st *)NULL))
        {
          fprintf(stderr, "%s: error loading DH params from '%s':\n", argv0, optarg);
          signed int *return_value___errno_location_19;
          return_value___errno_location_19=__errno_location();
          if(!(*return_value___errno_location_19 == 0))
          {
            signed int *return_value___errno_location_17;
            return_value___errno_location_17=__errno_location();
            char *return_value_strerror_18;
            return_value_strerror_18=strerror(*return_value___errno_location_17);
            fprintf(stderr, "%s\n", return_value_strerror_18);
          }

          else
            ERR_print_errors_fp(stderr);
          exit(1);
        }

        break;
      }
      case 71:
      {
        if(!(opts->ecdhcurve == ((char *)NULL)))
          free((void *)opts->ecdhcurve);

        ec=ssl_ec_by_name(optarg);
        if(ec == ((struct ec_key_st *)NULL))
        {
          fprintf(stderr, "%s: unknown curve '%s'\n", argv0, optarg);
          exit(1);
        }

        EC_KEY_free(ec);
        opts->ecdhcurve=strdup(optarg);
        if(opts->ecdhcurve == ((char *)NULL))
          oom_die(argv0);

        break;
      }
      case 90:
      {
        opts->sslcomp = (unsigned int)0;
        break;
      }
      case 115:
      {
        if(!(opts->ciphers == ((char *)NULL)))
          free((void *)opts->ciphers);

        opts->ciphers=strdup(optarg);
        if(opts->ciphers == ((char *)NULL))
          oom_die(argv0);

        break;
      }
      case 114:
      {
        opts_proto_force(opts, optarg, argv0);
        break;
      }
      case 82:
      {
        opts_proto_disable(opts, optarg, argv0);
        break;
      }
      case 101:
      {
        free((void *)natengine);
        natengine=strdup(optarg);
        if(natengine == ((char *)NULL))
          oom_die(argv0);

        break;
      }
      case 69:
      {
        nat_list_engines();
        exit(0);
        break;
      }
      case 117:
      {
        if(!(opts->dropuser == ((char *)NULL)))
          free((void *)opts->dropuser);

        opts->dropuser=strdup(optarg);
        if(opts->dropuser == ((char *)NULL))
          oom_die(argv0);

        break;
      }
      case 109:
      {
        if(!(opts->dropgroup == ((char *)NULL)))
          free((void *)opts->dropgroup);

        opts->dropgroup=strdup(optarg);
        if(opts->dropgroup == ((char *)NULL))
          oom_die(argv0);

        break;
      }
      case 112:
      {
        if(!(opts->pidfile == ((char *)NULL)))
          free((void *)opts->pidfile);

        opts->pidfile=strdup(optarg);
        if(opts->pidfile == ((char *)NULL))
          oom_die(argv0);

        break;
      }
      case 106:
      {
        if(!(opts->jaildir == ((char *)NULL)))
          free((void *)opts->jaildir);

        opts->jaildir=strdup(optarg);
        if(opts->jaildir == ((char *)NULL))
          oom_die(argv0);

        break;
      }
      case 108:
      {
        if(!(opts->connectlog == ((char *)NULL)))
          free((void *)opts->connectlog);

        opts->connectlog=strdup(optarg);
        if(opts->connectlog == ((char *)NULL))
          oom_die(argv0);

        break;
      }
      case 76:
      {
        if(!(opts->contentlog == ((char *)NULL)))
          free((void *)opts->contentlog);

        opts->contentlog=strdup(optarg);
        if(opts->contentlog == ((char *)NULL))
          oom_die(argv0);

        opts->contentlog_isdir = (unsigned int)0;
        opts->contentlog_isspec = (unsigned int)0;
        break;
      }
      case 83:
      {
        if(!(opts->contentlog == ((char *)NULL)))
          free((void *)opts->contentlog);

        opts->contentlog=strdup(optarg);
        if(opts->contentlog == ((char *)NULL))
          oom_die(argv0);

        opts->contentlog_isdir = (unsigned int)1;
        opts->contentlog_isspec = (unsigned int)0;
        break;
      }
      case 70:
      {
        if(!(opts->contentlog == ((char *)NULL)))
          free((void *)opts->contentlog);

        opts->contentlog=strdup(optarg);
        if(opts->contentlog == ((char *)NULL))
          oom_die(argv0);

        opts->contentlog_isdir = (unsigned int)0;
        opts->contentlog_isspec = (unsigned int)1;
        break;
      }
      case 100:
      {
        opts->detach = (unsigned int)1;
        break;
      }
      case 68:
      {
        log_dbg_mode(1);
        opts->debug = (unsigned int)1;
        break;
      }
      case 86:
      {
        main_version();
        exit(0);
      }
      case 104:
      {
        main_usage();
        exit(0);
      }
      case 63:
        exit(1);
      default:
      {
        main_usage();
        exit(1);
      }
    }
  }
  while((_Bool)1);
  argc = argc - optind;
  argv = argv + (signed long int)optind;
  opts->spec=proxyspec_parse(&argc, &argv, natengine);
  if(!(opts->detach == 0u))
  {
    if(!((signed long int)opts->debug == 0l))
    {
      fprintf(stderr, "%s: -d and -D are mutually exclusive.\n", argv0);
      exit(1);
    }

  }

  if(opts->spec == ((struct proxyspec *)NULL))
  {
    fprintf(stderr, "%s: no proxyspec specified.\n", argv0);
    exit(1);
  }

  struct proxyspec *spec = opts->spec;
  _Bool tmp_if_expr_20;
  signed int return_value_nat_ipv6ready_21;
  for( ; !(spec == ((struct proxyspec *)NULL)); spec = spec->next)
  {
    if(!(spec->connect_addrlen == 0u))
      tmp_if_expr_20 = (_Bool)1;

    else
      tmp_if_expr_20 = spec->sni_port != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_20)
    {
      if(spec->natengine == ((char *)NULL))
      {
        fprintf(stderr, "%s: no supported NAT engines on this platform.\nOnly static addr and SNI proxyspecs supported.\n", argv0);
        exit(1);
      }

      if((signed int)spec->listen_addr.ss_family == 10)
      {
        return_value_nat_ipv6ready_21=nat_ipv6ready(spec->natengine);
        if(return_value_nat_ipv6ready_21 == 0)
        {
          fprintf(stderr, "%s: IPv6 not supported by '%s'\n", argv0, spec->natengine);
          exit(1);
        }

      }

      spec->natlookup=nat_getlookupcb(spec->natengine);
      spec->natsocket=nat_getsocketcb(spec->natengine);
    }

  }
  signed int return_value_opts_has_ssl_spec_24;
  return_value_opts_has_ssl_spec_24=opts_has_ssl_spec(opts);
  _Bool tmp_if_expr_22;
  signed int return_value_X509_check_private_key_23;
  if(!(return_value_opts_has_ssl_spec_24 == 0))
  {
    if(!(opts->cacrt == ((struct x509_st *)NULL)))
      tmp_if_expr_22 = (_Bool)1;

    else
      tmp_if_expr_22 = !(opts->tgcrtdir != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_22)
    {
      if(opts->cakey == ((struct evp_pkey_st *)NULL))
      {
        fprintf(stderr, "%s: no CA key specified (-k).\n", argv0);
        exit(1);
      }

    }

    if(!(opts->cakey == ((struct evp_pkey_st *)NULL)))
    {
      if(opts->cacrt == ((struct x509_st *)NULL))
      {
        fprintf(stderr, "%s: no CA cert specified (-c).\n", argv0);
        exit(1);
      }

    }

    if(!(opts->cakey == ((struct evp_pkey_st *)NULL)))
    {
      if(!(opts->cacrt == ((struct x509_st *)NULL)))
      {
        return_value_X509_check_private_key_23=X509_check_private_key(opts->cacrt, opts->cakey);
        if(!(return_value_X509_check_private_key_23 == 1))
        {
          fprintf(stderr, "%s: CA cert does not match key.\n", argv0);
          ERR_print_errors_fp(stderr);
          exit(1);
        }

      }

    }

  }

  if(!(opts->pidfile == ((char *)NULL)))
  {
    pidfd=sys_pidf_open(opts->pidfile);
    if(pidfd == -1)
    {
      fprintf(stderr, "%s: cannot open PID file '%s' - process already running?\n", argv0, opts->pidfile);
      exit(1);
    }

  }

  if(opts->ciphers == ((char *)NULL))
  {
    opts->ciphers=strdup("ALL:-aNULL");
    if(opts->ciphers == ((char *)NULL))
      oom_die(argv0);

  }

  unsigned int return_value_geteuid_26;
  unsigned int return_value_getuid_25;
  if(opts->dropuser == ((char *)NULL))
  {
    return_value_geteuid_26=geteuid();
    if(return_value_geteuid_26 == 0u)
    {
      return_value_getuid_25=getuid();
      if(return_value_getuid_25 == 0u)
      {
        if(opts->contentlog_isdir == 0u)
        {
          if(opts->contentlog_isspec == 0u)
          {
            opts->dropuser=strdup("nobody");
            if(opts->dropuser == ((char *)NULL))
              oom_die(argv0);

          }

        }

      }

    }

  }

  signed int return_value_opts_has_ssl_spec_27;
  return_value_opts_has_ssl_spec_27=opts_has_ssl_spec(opts);
  if(!(return_value_opts_has_ssl_spec_27 == 0))
  {
    if(!(opts->cakey == ((struct evp_pkey_st *)NULL)))
    {
      if(opts->key == ((struct evp_pkey_st *)NULL))
      {
        opts->key=ssl_key_genrsa(1024);
        if(opts->key == ((struct evp_pkey_st *)NULL))
        {
          fprintf(stderr, "%s: error generating RSA key:\n", argv0);
          ERR_print_errors_fp(stderr);
          exit(1);
        }

        if(!((signed long int)opts->debug == 0l))
          log_dbg_printf("Generated RSA key for leaf certs.\n");

      }

    }

  }

  if(!(opts->dropgroup == ((char *)NULL)))
  {
    if(opts->dropuser == ((char *)NULL))
    {
      fprintf(stderr, "%s: -m depends on -u.\n", argv0);
      exit(1);
    }

  }

  char *tmp_if_expr_29;
  if(!((signed long int)opts->debug == 0l))
  {
    main_version();
    opts_proto_dbg_dump(opts);
    log_dbg_printf("proxyspecs:\n");
    struct proxyspec *main__1__13__1__spec = opts->spec;
    for( ; !(main__1__13__1__spec == ((struct proxyspec *)NULL)); main__1__13__1__spec = main__1__13__1__spec->next)
    {
      char *lbuf;
      char *cbuf = (char *)(void *)0;
      lbuf=sys_sockaddr_str((struct sockaddr *)&main__1__13__1__spec->listen_addr, main__1__13__1__spec->listen_addrlen);
      if(!(main__1__13__1__spec->connect_addrlen == 0u))
        cbuf=sys_sockaddr_str((struct sockaddr *)&main__1__13__1__spec->connect_addr, main__1__13__1__spec->connect_addrlen);

      if(!(main__1__13__1__spec->sni_port == 0))
      {
        signed int return_value_asprintf_28;
        return_value_asprintf_28=asprintf(&cbuf, "sni %i", main__1__13__1__spec->sni_port);
        if(!(return_value_asprintf_28 >= 0))
        {
          fprintf(stderr, "%s: out of memory\n", argv0);
          exit(1);
        }

      }

      if(!(main__1__13__1__spec->natengine == ((char *)NULL)))
        tmp_if_expr_29 = main__1__13__1__spec->natengine;

      else
        tmp_if_expr_29 = cbuf;
      log_dbg_printf("- %s %s %s %s\n", lbuf, main__1__13__1__spec->ssl != 0u ? "ssl" : "tcp", main__1__13__1__spec->http != 0u ? "http" : "plain", tmp_if_expr_29);
      if(!(lbuf == ((char *)NULL)))
        free((void *)lbuf);

      if(!(cbuf == ((char *)NULL)))
        free((void *)cbuf);

    }
    if(!(opts->cacrt == ((struct x509_st *)NULL)))
    {
      char *subj;
      subj=ssl_x509_subject(opts->cacrt);
      log_dbg_printf("Loaded CA: '%s'\n", subj);
      free((void *)subj);
    }

    else
      log_dbg_printf("No CA loaded.\n");
  }

  signed int return_value_cachemgr_preinit_30;
  return_value_cachemgr_preinit_30=cachemgr_preinit();
  if(return_value_cachemgr_preinit_30 == -1)
  {
    fprintf(stderr, "%s: failed to preinit cachemgr.\n", argv0);
    exit(1);
  }

  signed int return_value_log_preinit_31;
  return_value_log_preinit_31=log_preinit(opts);
  if(return_value_log_preinit_31 == -1)
  {
    fprintf(stderr, "%s: failed to preinit logging.\n", argv0);
    exit(1);
  }

  signed int return_value_nat_preinit_32;
  return_value_nat_preinit_32=nat_preinit();
  if(return_value_nat_preinit_32 == -1)
  {
    fprintf(stderr, "%s: failed to preinit NAT lookup.\n", argv0);
    exit(1);
  }

  struct proxy_ctx *proxy;
  proxy=proxy_new(opts);
  if(proxy == ((struct proxy_ctx *)NULL))
  {
    fprintf(stderr, "%s: failed to initialize proxy.\n", argv0);
    exit(1);
  }

  if(!(opts->tgcrtdir == ((char *)NULL)))
    sys_dir_eachfile(opts->tgcrtdir, main_loadtgcrt, (void *)opts);

  signed int return_value_sys_privdrop_35;
  return_value_sys_privdrop_35=sys_privdrop(opts->dropuser, opts->dropgroup, opts->jaildir);
  if(return_value_sys_privdrop_35 == -1)
  {
    signed int *return_value___errno_location_33;
    return_value___errno_location_33=__errno_location();
    char *return_value_strerror_34;
    return_value_strerror_34=strerror(*return_value___errno_location_33);
    fprintf(stderr, "%s: failed to drop privileges: %s\n", argv0, return_value_strerror_34);
    exit(1);
  }

  if(!(opts->detach == 0u))
  {
    if(!((signed long int)opts->debug == 0l))
      log_dbg_printf("Detaching from TTY, see syslog for errors after this point\n");

    signed int return_value_daemon_38;
    return_value_daemon_38=daemon(1, 0);
    if(return_value_daemon_38 == -1)
    {
      signed int *return_value___errno_location_36;
      return_value___errno_location_36=__errno_location();
      char *return_value_strerror_37;
      return_value_strerror_37=strerror(*return_value___errno_location_36);
      fprintf(stderr, "%s: failed to detach from TTY: %s\n", argv0, return_value_strerror_37);
      exit(1);
    }

    log_err_mode(1);
    ssl_reinit();
  }

  signed int return_value_log_init_41;
  return_value_log_init_41=log_init(opts);
  if(return_value_log_init_41 == -1)
  {
    signed int *return_value___errno_location_39;
    return_value___errno_location_39=__errno_location();
    char *return_value_strerror_40;
    return_value_strerror_40=strerror(*return_value___errno_location_39);
    fprintf(stderr, "%s: failed to init log facility: %s\n", argv0, return_value_strerror_40);
    goto out_log_failed;
  }

  signed int return_value_sys_pidf_write_44;
  if(!(opts->pidfile == ((char *)NULL)))
  {
    return_value_sys_pidf_write_44=sys_pidf_write(pidfd);
    if(return_value_sys_pidf_write_44 == -1)
    {
      signed int *return_value___errno_location_42;
      return_value___errno_location_42=__errno_location();
      char *return_value_strerror_43;
      return_value_strerror_43=strerror(*return_value___errno_location_42);
      log_err_printf("Failed to write PID to PID file '%s': %s\n", opts->pidfile, return_value_strerror_43);
      goto out_pidwrite_failed;
    }

  }

  signed int return_value_cachemgr_init_45;
  return_value_cachemgr_init_45=cachemgr_init();
  signed int return_value_nat_init_46;
  if(return_value_cachemgr_init_45 == -1)
    log_err_printf("Failed to init cache manager.\n");

  else
  {
    return_value_nat_init_46=nat_init();
    if(return_value_nat_init_46 == -1)
      log_err_printf("Failed to init NAT state table lookup.\n");

    else
    {
      rv = 0;
      proxy_run(proxy);
      proxy_free(proxy);
      nat_fini();
    }

  out_nat_failed:
    ;
    cachemgr_fini();
  }

out_cachemgr_failed:
  ;
  if(!(opts->pidfile == ((char *)NULL)))
    sys_pidf_close(pidfd, opts->pidfile);


out_pidwrite_failed:
  ;
  log_fini();

out_log_failed:
  ;
  opts_free(opts);
  ssl_fini();
  return rv;
}

// main_loadtgcrt
// file main.c line 192
static void main_loadtgcrt(const char *filename, void *arg)
{
  struct opts *opts = (struct opts *)arg;
  struct cert *cert;
  char **names;
  cert=cert_new_load(filename);
  if(cert == ((struct cert *)NULL))
  {
    log_err_printf("Failed to load cert and key from PEM file '%s'\n", filename);
    log_fini();
    exit(1);
  }

  signed int return_value_X509_check_private_key_1;
  return_value_X509_check_private_key_1=X509_check_private_key(cert->crt, cert->key);
  if(!(return_value_X509_check_private_key_1 == 1))
  {
    log_err_printf("Cert does not match key in PEM file '%s':\n", filename);
    ERR_print_errors_fp(stderr);
    log_fini();
    exit(1);
  }

  if(!((signed long int)opts->debug == 0l))
    log_dbg_printf("Targets for '%s':", filename);

  names=ssl_x509_names(cert->crt);
  char **p = names;
  for( ; !(*p == ((char *)NULL)); p = p + 1l)
  {
    char *sep;
    sep=strchr(*p, 33);
    if(!(sep == ((char *)NULL)))
      *sep = (char)0;

    if(!((signed long int)opts->debug == 0l))
      log_dbg_printf(" '%s'", *p);

    void *return_value_cachetgcrt_mkkey_2;
    return_value_cachetgcrt_mkkey_2=cachetgcrt_mkkey(*p);
    void *return_value_cachetgcrt_mkval_3;
    return_value_cachetgcrt_mkval_3=cachetgcrt_mkval(cert);
    cache_set(cachemgr_tgcrt, return_value_cachetgcrt_mkkey_2, return_value_cachetgcrt_mkval_3);
    free((void *)*p);
  }
  if(!((signed long int)opts->debug == 0l))
    log_dbg_printf("\n");

  free((void *)names);
  cert_free(cert);
}

// main_usage
// file main.c line 97
static void main_usage(void)
{
  const char *dflt;
  const char *warn;
  dflt=nat_getdefaultname();
  if(dflt == ((const char *)NULL))
  {
    dflt = "n/a";
    warn = "\nWarning: no supported NAT engine on this platform!\nOnly static and SNI proxyspecs are supported.\n";
  }

  else
    warn = "";
  fprintf(stderr, "Usage: %s [options...] [proxyspecs...]\n  -c pemfile  use CA cert (and key) from pemfile to sign forged certs\n  -k pemfile  use CA key (and cert) from pemfile to sign forged certs\n  -C pemfile  use CA chain from pemfile (intermediate and root CA certs)\n  -K pemfile  use key from pemfile for leaf certs (default: generate)\n  -t certdir  use cert+chain+key PEM files from certdir to target all sites\n              matching the common names (non-matching: generate if CA)\n  -O          deny all OCSP requests on all proxyspecs\n  -P          passthrough SSL connections if they cannot be split because of\n              client cert auth or no matching cert and no CA (default: drop)\n  -g pemfile  use DH group params from pemfile (default: keyfiles or auto)\n  -G curve    use ECDH named curve (default: %s for non-RSA leafkey)\n  -Z          disable SSL/TLS compression on all connections\n  -r proto    only support one of ssl3 tls10 tls11 tls12 (default: all)\n  -R proto    disable one of ssl3 tls10 tls11 tls12 (default: none)\n  -s ciphers  use the given OpenSSL cipher suite spec (default: ALL:-aNULL)\n  -e engine   specify default NAT engine to use (default: %s)\n  -E          list available NAT engines and exit\n  -u user     drop privileges to user (default if run as root: nobody)\n  -m group    when using -u, override group (default: primary group of user)\n  -j jaildir  chroot() to jaildir (impacts -S/-F and sni, see manual page)\n  -p pidfile  write pid to pidfile (default: no pid file)\n  -l logfile  connect log: log one line summary per connection to logfile\n  -L logfile  content log: full data to file or named pipe (excludes -S/-F)\n  -S logdir   content log: full data to separate files in dir (excludes -L/-F)\n  -F pathspec content log: full data to sep files with %% subst (excl. -L/-S):\n              %%T - initial connection time as an ISO 8601 UTC timestamp\n              %%d - dest address:port\n              %%s - source address:port\n              %%%% - literal '%%'\n      e.g.    \"/var/log/sslsplit/%%T-%%s-%%d.log\"\n  -d          daemon mode: run in background, log error messages to syslog\n  -D          debug mode: run in foreground, log debug messages on stderr\n  -V          print version information and exit\n  -h          print usage information and exit\n  proxyspec = type listenaddr+port [natengine|targetaddr+port|\"sni\"+port]\n      e.g.    http 0.0.0.0 8080 www.roe.ch 80  # http/4; static hostname dst\n              https ::1 8443 2001:db8::1 443   # https/6; static address dst\n              https 127.0.0.1 9443 sni 443     # https/4; SNI DNS lookups\n              tcp 127.0.0.1 10025              # tcp/4; default NAT engine\n              ssl 2001:db8::2 9999 pf          # ssl/6; NAT engine 'pf'\nExample:\n  %s -k ca.key -c ca.pem -P  https 127.0.0.1 8443  https ::1 8443\n%s", (const void *)"sslsplit", (const void *)"secp160r2", dflt, (const void *)"sslsplit", warn);
}

// main_version
// file main.c line 68
static void main_version(void)
{
  fprintf(stderr, "%s %s (built %s)\n", (const void *)"SSLsplit", version, build_date);
  fprintf(stderr, "Copyright (c) 2009-2014, Daniel Roethlisberger <daniel@roe.ch>\n");
  fprintf(stderr, "http://www.roe.ch/SSLsplit\n");
  if(!(*build_info == 0))
    fprintf(stderr, "Build info: %s\n", build_info);

  if(!(*features == 0))
    fprintf(stderr, "Features: %s\n", features);

  nat_version();
  fprintf(stderr, "Local process info support: ");
  fprintf(stderr, "no\n");
  ssl_openssl_version();
  fprintf(stderr, "compiled against libevent %s\n", (const void *)"2.0.21-stable");
  const char *return_value_event_get_version_1;
  return_value_event_get_version_1=event_get_version();
  fprintf(stderr, "rtlinked against libevent %s\n", return_value_event_get_version_1);
  unsigned int return_value_sys_get_cpu_cores_2;
  return_value_sys_get_cpu_cores_2=sys_get_cpu_cores();
  fprintf(stderr, "%d CPU cores detected\n", return_value_sys_get_cpu_cores_2);
}

// nat_exist
// file nat.c line 484
signed int nat_exist(const char *name)
{
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  signed int return_value_nat_index_1;
  return_value_nat_index_1=nat_index(name);
  return (signed int)!(!(engines[(signed long int)return_value_nat_index_1].name != ((const char *)NULL)));
}

// nat_fini
// file nat.c line 603
void nat_fini(void)
{
  signed int i = 0;
  _Bool tmp_if_expr_1;
  if(!(engines[(signed long int)i].finicb == ((void (*)(void))NULL)))
    tmp_if_expr_1 = engines[(signed long int)i].used != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    log_dbg_printf("NAT engine fini '%s'\n", engines[(signed long int)i].name);
    engines[(signed long int)i].finicb();
    i = i + 1;
  }

}

// nat_getdefaultname
// file nat.c line 459
const char * nat_getdefaultname(void)
{
  return engines[(signed long int)0].name;
}

// nat_getlookupcb
// file nat.c line 509
signed int (*nat_getlookupcb(const char *name))(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int)
{
  signed int i;
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  i=nat_index(name);
  engines[(signed long int)i].used = (unsigned int)1;
  return engines[(signed long int)i].lookupcb;
}

// nat_getsocketcb
// file nat.c line 525
signed int (*nat_getsocketcb(const char *name))(signed int)
{
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  signed int return_value_nat_index_1;
  return_value_nat_index_1=nat_index(name);
  return engines[(signed long int)return_value_nat_index_1].socketcb;
}

// nat_getsockname_lookup_cb
// file nat.c line 378
static signed int nat_getsockname_lookup_cb(struct sockaddr *dst_addr, unsigned int *dst_addrlen, signed int s, struct sockaddr *src_addr, unsigned int src_addrlen)
{
  signed int return_value_getsockname_3;
  return_value_getsockname_3=getsockname(s, dst_addr, dst_addrlen);
  if(return_value_getsockname_3 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_err_printf("Error from getsockname(): %s\n", return_value_strerror_2);
    return -1;
  }

  return 0;
}

// nat_index
// file nat.c line 470
static signed int nat_index(const char *name)
{
  signed int return_value_strcmp_1;
  if(!(name == ((const char *)NULL)))
  {
    signed int i = 0;
    for( ; !(engines[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    {
      return_value_strcmp_1=strcmp(name, engines[(signed long int)i].name);
      if(return_value_strcmp_1 == 0)
        return i;

    }
  }

  return (signed int)(sizeof(struct engine [3l]) /*168ul*/  / sizeof(struct engine) /*56ul*/  - (unsigned long int)1);
}

// nat_init
// file nat.c line 588
signed int nat_init(void)
{
  signed int i = 0;
  _Bool tmp_if_expr_1;
  if(!(engines[(signed long int)i].initcb == ((signed int (*)(void))NULL)))
    tmp_if_expr_1 = engines[(signed long int)i].used != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    log_dbg_printf("NAT engine init '%s'\n", engines[(signed long int)i].name);
    signed int return_value;
    return_value=engines[(signed long int)i].initcb();
    if(return_value == -1)
      return -1;

    i = i + 1;
  }

  return 0;
}

// nat_iptransparent_socket_cb
// file nat.c line 352
static signed int nat_iptransparent_socket_cb(signed int s)
{
  signed int on = 1;
  signed int rv;
  rv=setsockopt(s, 0, 19, (void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(rv == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_err_printf("Error from setsockopt(IP_TRANSPARENT): %s\n", return_value_strerror_2);
  }

  return rv;
}

// nat_ipv6ready
// file nat.c line 537
signed int nat_ipv6ready(const char *name)
{
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  signed int return_value_nat_index_1;
  return_value_nat_index_1=nat_index(name);
  return (signed int)engines[(signed long int)return_value_nat_index_1].ipv6;
}

// nat_list_engines
// file nat.c line 548
void nat_list_engines(void)
{
  signed int i = 0;
  for( ; !(engines[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    fprintf(stdout, "%s%s\n", engines[(signed long int)i].name, i != 0 ? "" : " (default)");
  fflush(stdout);
}

// nat_netfilter_lookup_cb
// file nat.c line 325
static signed int nat_netfilter_lookup_cb(struct sockaddr *dst_addr, unsigned int *dst_addrlen, signed int s, struct sockaddr *src_addr, unsigned int src_addrlen)
{
  signed int rv;
  if(!((signed int)src_addr->sa_family == 2))
  {
    log_err_printf("The netfilter NAT engine only supports IPv4 state lookups\n");
    return -1;
  }

  else
  {
    rv=getsockopt(s, 0, 80, (void *)dst_addr, dst_addrlen);
    if(rv == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_err_printf("Error from getsockopt(SO_ORIGINAL_DST): %s\n", return_value_strerror_2);
    }

    return rv;
  }
}

// nat_preinit
// file nat.c line 569
signed int nat_preinit(void)
{
  signed int i = 0;
  _Bool tmp_if_expr_1;
  if(!(engines[(signed long int)i].preinitcb == ((signed int (*)(void))NULL)))
    tmp_if_expr_1 = engines[(signed long int)i].used != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    log_dbg_printf("NAT engine preinit '%s'\n", engines[(signed long int)i].name);
    signed int return_value;
    return_value=engines[(signed long int)i].preinitcb();
    if(return_value == -1)
      return -1;

    i = i + 1;
  }

  return 0;
}

// nat_used
// file nat.c line 496
signed int nat_used(const char *name)
{
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  signed int return_value_nat_index_1;
  return_value_nat_index_1=nat_index(name);
  return (signed int)!(!(engines[(signed long int)return_value_nat_index_1].used != 0u));
}

// nat_version
// file nat.c line 615
void nat_version(void)
{
  fprintf(stderr, "NAT engines:");
  signed int i = 0;
  for( ; !(engines[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, " %s%s", engines[(signed long int)i].name, i != 0 ? "" : "*");
  if(engines[0l].name == ((const char *)NULL))
    fprintf(stderr, " -");

  fprintf(stderr, "\n");
  fprintf(stderr, "netfilter:");
  fprintf(stderr, " IP_TRANSPARENT");
  fprintf(stderr, " SOL_IPV6");
  fprintf(stderr, " !IPV6_ORIGINAL_DST");
  fprintf(stderr, "\n");
}

// oom_die
// file main.c line 248
void oom_die(const char *argv0)
{
  fprintf(stderr, "%s: out of memory\n", argv0);
  exit(1);
}

// opts_free
// file opts.c line 59
void opts_free(struct opts *opts)
{
  sk_pop_free((struct stack_st *)opts->chain, (void (*)(void *))(1 != 0 ? X509_free : (void (*)(struct x509_st *))0));
  if(!(opts->cacrt == ((struct x509_st *)NULL)))
    X509_free(opts->cacrt);

  if(!(opts->cakey == ((struct evp_pkey_st *)NULL)))
    EVP_PKEY_free(opts->cakey);

  if(!(opts->key == ((struct evp_pkey_st *)NULL)))
    EVP_PKEY_free(opts->key);

  if(!(opts->dh == ((struct dh_st *)NULL)))
    DH_free(opts->dh);

  if(!(opts->ecdhcurve == ((char *)NULL)))
    free((void *)opts->ecdhcurve);

  if(!(opts->spec == ((struct proxyspec *)NULL)))
    proxyspec_free(opts->spec);

  if(!(opts->ciphers == ((char *)NULL)))
    free((void *)opts->ciphers);

  if(!(opts->tgcrtdir == ((char *)NULL)))
    free((void *)opts->tgcrtdir);

  if(!(opts->dropuser == ((char *)NULL)))
    free((void *)opts->dropuser);

  if(!(opts->dropgroup == ((char *)NULL)))
    free((void *)opts->dropgroup);

  if(!(opts->jaildir == ((char *)NULL)))
    free((void *)opts->jaildir);

  if(!(opts->pidfile == ((char *)NULL)))
    free((void *)opts->pidfile);

  if(!(opts->connectlog == ((char *)NULL)))
    free((void *)opts->connectlog);

  if(!(opts->contentlog == ((char *)NULL)))
    free((void *)opts->contentlog);

  memset((void *)opts, 0, sizeof(struct opts) /*136ul*/ );
  free((void *)opts);
}

// opts_has_ssl_spec
// file opts.c line 116
signed int opts_has_ssl_spec(struct opts *opts)
{
  struct proxyspec *p = opts->spec;
  for( ; !(p == ((struct proxyspec *)NULL)); p = p->next)
    if(!(p->ssl == 0u))
      return 1;

  return 0;
}

// opts_new
// file opts.c line 44
struct opts * opts_new(void)
{
  struct opts *opts;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct opts) /*136ul*/ );
  opts = (struct opts *)return_value_malloc_1;
  memset((void *)opts, 0, sizeof(struct opts) /*136ul*/ );
  opts->sslcomp = (unsigned int)1;
  struct stack_st *return_value_sk_new_null_2;
  return_value_sk_new_null_2=sk_new_null();
  opts->chain = (struct stack_st_X509 *)return_value_sk_new_null_2;
  opts->sslmethod = SSLv23_method;
  return opts;
}

// opts_proto_dbg_dump
// file opts.c line 216
void opts_proto_dbg_dump(struct opts *opts)
{
  char *tmp_if_expr_2;
  char *tmp_if_expr_1;
  if(opts->sslmethod == TLSv1_method)
    tmp_if_expr_2 = "tls10";

  else
  {
    if(opts->sslmethod == TLSv1_1_method)
      tmp_if_expr_1 = "tls11";

    else
      tmp_if_expr_1 = opts->sslmethod == TLSv1_2_method ? "tls12" : "negotiate";
    tmp_if_expr_2 = tmp_if_expr_1;
  }
  log_dbg_printf("SSL/TLS protocol: %s%s%s%s%s%s\n", tmp_if_expr_2, (const void *)"", (const void *)"", opts->no_tls10 != 0u ? " -tls10" : "", opts->no_tls11 != 0u ? " -tls11" : "", opts->no_tls12 != 0u ? " -tls12" : "");
}

// opts_proto_disable
// file opts.c line 178
void opts_proto_disable(struct opts *opts, const char *optarg, const char *argv0)
{
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(optarg, "tls10");
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(return_value_strcmp_3 == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strcmp_4=strcmp(optarg, "tls1");
    tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(tmp_if_expr_5)
    opts->no_tls10 = (unsigned int)1;

  else
  {
    return_value_strcmp_2=strcmp(optarg, "tls11");
    if(return_value_strcmp_2 == 0)
      opts->no_tls11 = (unsigned int)1;

    else
    {
      return_value_strcmp_1=strcmp(optarg, "tls12");
      if(return_value_strcmp_1 == 0)
        opts->no_tls12 = (unsigned int)1;

      else
      {
        fprintf(stderr, "%s: Unsupported SSL/TLS protocol '%s'\n", argv0, optarg);
        exit(1);
      }
    }
  }
}

// opts_proto_force
// file opts.c line 134
void opts_proto_force(struct opts *opts, const char *optarg, const char *argv0)
{
  if(!(opts->sslmethod == SSLv23_method))
  {
    fprintf(stderr, "%s: cannot use -r multiple times\n", argv0);
    exit(1);
  }

  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(optarg, "tls10");
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(return_value_strcmp_3 == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strcmp_4=strcmp(optarg, "tls1");
    tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(tmp_if_expr_5)
    opts->sslmethod = TLSv1_method;

  else
  {
    return_value_strcmp_2=strcmp(optarg, "tls11");
    if(return_value_strcmp_2 == 0)
      opts->sslmethod = TLSv1_1_method;

    else
    {
      return_value_strcmp_1=strcmp(optarg, "tls12");
      if(return_value_strcmp_1 == 0)
        opts->sslmethod = TLSv1_2_method;

      else
      {
        fprintf(stderr, "%s: Unsupported SSL/TLS protocol '%s'\n", argv0, optarg);
        exit(1);
      }
    }
  }
}

// proxy_debug_base
// file proxy.c line 145
static void proxy_debug_base(struct event_base *ev_base)
{
  const char *return_value_event_base_get_method_1;
  return_value_event_base_get_method_1=event_base_get_method(ev_base);
  log_dbg_printf("Using libevent backend '%s'\n", return_value_event_base_get_method_1);
  enum event_method_feature f;
  signed int return_value_event_base_get_features_2;
  return_value_event_base_get_features_2=event_base_get_features(ev_base);
  f = (enum event_method_feature)return_value_event_base_get_features_2;
  log_dbg_printf("Event base supports: edge %s, O(1) %s, anyfd %s\n", ((signed int)f & EV_FEATURE_ET) != 0 ? "yes" : "no", ((signed int)f & EV_FEATURE_O1) != 0 ? "yes" : "no", ((signed int)f & EV_FEATURE_FDS) != 0 ? "yes" : "no");
}

// proxy_free
// file proxy.h line 39
void proxy_free(struct proxy_ctx *ctx)
{
  if(!(ctx->gcev == ((struct event *)NULL)))
    event_free(ctx->gcev);

  if(!(ctx->lctx == ((struct proxy_listener_ctx *)NULL)))
    proxy_listener_ctx_free(ctx->lctx);

  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 4ul); i = i + 1ul)
    if(!(ctx->sev[(signed long int)i] == ((struct event *)NULL)))
      event_free(ctx->sev[(signed long int)i]);

  if(!(ctx->thrmgr == ((struct pxy_thrmgr_ctx *)NULL)))
    pxy_thrmgr_free(ctx->thrmgr);

  if(!(ctx->evbase == ((struct event_base *)NULL)))
    event_base_free(ctx->evbase);

  free((void *)ctx);
}

// proxy_gc_cb
// file proxy.c line 261
static void proxy_gc_cb(signed int fd, signed short int what, void *arg)
{
  struct proxy_ctx *ctx = (struct proxy_ctx *)arg;
  if(!((signed long int)ctx->opts->debug == 0l))
    log_dbg_printf("Garbage collecting caches started.\n");

  cachemgr_gc();
  if(!((signed long int)ctx->opts->debug == 0l))
    log_dbg_printf("Garbage collecting caches done.\n");

}

// proxy_listener_acceptcb
// file proxy.c line 117
static void proxy_listener_acceptcb(struct evconnlistener *listener, signed int fd, struct sockaddr *peeraddr, signed int peeraddrlen, void *arg)
{
  struct proxy_listener_ctx *cfg = (struct proxy_listener_ctx *)arg;
  pxy_conn_setup(fd, peeraddr, peeraddrlen, cfg->thrmgr, cfg->spec, cfg->opts);
}

// proxy_listener_ctx_free
// file proxy.c line 102
static void proxy_listener_ctx_free(struct proxy_listener_ctx *ctx)
{
  if(!(ctx->evcl == ((struct evconnlistener *)NULL)))
    evconnlistener_free(ctx->evcl);

  if(!(ctx->next == ((struct proxy_listener_ctx *)NULL)))
    proxy_listener_ctx_free(ctx->next);

  free((void *)ctx);
}

// proxy_listener_ctx_new
// file proxy.c line 86
static struct proxy_listener_ctx * proxy_listener_ctx_new(struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts)
{
  struct proxy_listener_ctx *ctx;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct proxy_listener_ctx) /*40ul*/ );
  ctx = (struct proxy_listener_ctx *)return_value_malloc_1;
  if(ctx == ((struct proxy_listener_ctx *)NULL))
    return (struct proxy_listener_ctx *)(void *)0;

  else
  {
    memset((void *)ctx, 0, sizeof(struct proxy_listener_ctx) /*40ul*/ );
    ctx->thrmgr = thrmgr;
    ctx->spec = spec;
    ctx->opts = opts;
    return ctx;
  }
}

// proxy_listener_errorcb
// file proxy.c line 132
static void proxy_listener_errorcb(struct evconnlistener *listener, void *ctx)
{
  struct event_base *evbase;
  evbase=evconnlistener_get_base(listener);
  signed int err;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  err = *return_value___errno_location_1;
  char *return_value_strerror_2;
  return_value_strerror_2=strerror(err);
  log_err_printf("Error %d on listener: %s\n", err, return_value_strerror_2);
  event_base_loopbreak(evbase);
}

// proxy_listener_setup
// file proxy.c line 163
static struct proxy_listener_ctx * proxy_listener_setup(struct event_base *evbase, struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts)
{
  struct proxy_listener_ctx *plc;
  signed int fd;
  signed int on = 1;
  signed int rv;
  fd=socket((signed int)spec->listen_addr.ss_family, 1, 6);
  if(fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_err_printf("Error from socket(): %s\n", return_value_strerror_2);
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  rv=evutil_make_socket_nonblocking(fd);
  if(rv == -1)
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    log_err_printf("Error making socket nonblocking: %s\n", return_value_strerror_4);
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  rv=setsockopt(fd, 1, 9, (void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(rv == -1)
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    char *return_value_strerror_6;
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    log_err_printf("Error from setsockopt(SO_KEEPALIVE): %s\n", return_value_strerror_6);
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  rv=evutil_make_listen_socket_reuseable(fd);
  if(rv == -1)
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    char *return_value_strerror_8;
    return_value_strerror_8=strerror(*return_value___errno_location_7);
    log_err_printf("Error from setsockopt(SO_REUSABLE): %s\n", return_value_strerror_8);
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  signed int return_value;
  if(!(spec->natsocket == ((signed int (*)(signed int))NULL)))
  {
    return_value=spec->natsocket(fd);
    log_err_printf("Error from spec->natsocket()\n");
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  else
  {
    rv=bind(fd, (struct sockaddr *)&spec->listen_addr, spec->listen_addrlen);
    if(rv == -1)
    {
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      char *return_value_strerror_10;
      return_value_strerror_10=strerror(*return_value___errno_location_9);
      log_err_printf("Error from bind(): %s\n", return_value_strerror_10);
      evutil_closesocket(fd);
      return (struct proxy_listener_ctx *)(void *)0;
    }

    plc=proxy_listener_ctx_new(thrmgr, spec, opts);
    if(plc == ((struct proxy_listener_ctx *)NULL))
    {
      log_err_printf("Error creating listener context\n");
      evutil_closesocket(fd);
      return (struct proxy_listener_ctx *)(void *)0;
    }

    else
    {
      plc->evcl=evconnlistener_new(evbase, proxy_listener_acceptcb, (void *)plc, 1u << 1, 1024, fd);
      if(plc->evcl == ((struct evconnlistener *)NULL))
      {
        signed int *return_value___errno_location_11;
        return_value___errno_location_11=__errno_location();
        char *return_value_strerror_12;
        return_value_strerror_12=strerror(*return_value___errno_location_11);
        log_err_printf("Error creating evconnlistener: %s\n", return_value_strerror_12);
        proxy_listener_ctx_free(plc);
        evutil_closesocket(fd);
        return (struct proxy_listener_ctx *)(void *)0;
      }

      evconnlistener_set_error_cb(plc->evcl, proxy_listener_errorcb);
      return plc;
    }
  }
}

// proxy_new
// file proxy.h line 37
struct proxy_ctx * proxy_new(struct opts *opts)
{
  struct proxy_listener_ctx *head;
  struct proxy_ctx *ctx;
  struct evdns_base *dnsbase;
  signed int rc;
  evthread_use_pthreads();
  if(!((signed long int)opts->debug == 0l))
    event_enable_debug_mode();

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct proxy_ctx) /*72ul*/ );
  ctx = (struct proxy_ctx *)return_value_malloc_1;
  struct timeval gc_delay;
  if(ctx == ((struct proxy_ctx *)NULL))
    log_err_printf("Error allocating memory\n");

  else
  {
    memset((void *)ctx, 0, sizeof(struct proxy_ctx) /*72ul*/ );
    ctx->opts = opts;
    ctx->evbase=event_base_new();
    if(ctx->evbase == ((struct event_base *)NULL))
      log_err_printf("Error getting event base\n");

    else
    {
      dnsbase=evdns_base_new(ctx->evbase, 0);
      if(dnsbase == ((struct evdns_base *)NULL))
        log_err_printf("Error creating dns event base\n");

      else
      {
        rc=evdns_base_resolv_conf_parse(dnsbase, 15, "/etc/resolv.conf");
        evdns_base_free(dnsbase, 0);
        if(!(rc == 0))
          log_err_printf("evdns cannot parse resolv.conf: %s (%d)\n", rc == 1 ? "failed to open file" : (rc == 2 ? "failed to stat file" : (rc == 3 ? "file too large" : (rc == 4 ? "out of memory" : (rc == 5 ? "short read from file" : (rc == 6 ? "no nameservers listed in file" : "unknown error"))))), rc);

        else
        {
          if(!((signed long int)opts->debug == 0l))
            proxy_debug_base(ctx->evbase);

          ctx->thrmgr=pxy_thrmgr_new(opts);
          if(ctx->thrmgr == ((struct pxy_thrmgr_ctx *)NULL))
            log_err_printf("Error creating thread manager\n");

          else
          {
            ctx->lctx = (struct proxy_listener_ctx *)(void *)0;
            head = ctx->lctx;
            struct proxyspec *spec = opts->spec;
            for( ; !(spec == ((struct proxyspec *)NULL)); spec = spec->next)
            {
              head=proxy_listener_setup(ctx->evbase, ctx->thrmgr, spec, opts);
              if(head == ((struct proxy_listener_ctx *)NULL))
                goto leave2;

              head->next = ctx->lctx;
              ctx->lctx = head;
            }
            unsigned long int i = (unsigned long int)0;
            for( ; !(i >= 4ul); i = i + 1ul)
            {
              ctx->sev[(signed long int)i]=event_new(ctx->evbase, signals[(signed long int)i], (signed short int)(0x08 | 0x10), proxy_signal_cb, (void *)ctx);
              if(ctx->sev[(signed long int)i] == ((struct event *)NULL))
                goto leave3;

              event_add(ctx->sev[(signed long int)i], (struct timeval *)(void *)0);
            }
            gc_delay = (struct timeval){ .tv_sec=(signed long int)60, .tv_usec=(signed long int)0 };
            ctx->gcev=event_new(ctx->evbase, -1, (signed short int)0x10, proxy_gc_cb, (void *)ctx);
            if(!(ctx->gcev == ((struct event *)NULL)))
            {
              event_add(ctx->gcev, &gc_delay);
              return ctx;
            }


          leave4:
            ;
            if(!(ctx->gcev == ((struct event *)NULL)))
              event_free(ctx->gcev);


          leave3:
            ;
            unsigned long int proxy_new__1__11__i = (unsigned long int)0;
            for( ; !(proxy_new__1__11__i >= 4ul); proxy_new__1__11__i = proxy_new__1__11__i + 1ul)
              if(!(ctx->sev[(signed long int)proxy_new__1__11__i] == ((struct event *)NULL)))
                event_free(ctx->sev[(signed long int)proxy_new__1__11__i]);


          leave2:
            ;
            if(!(ctx->lctx == ((struct proxy_listener_ctx *)NULL)))
              proxy_listener_ctx_free(ctx->lctx);

            pxy_thrmgr_free(ctx->thrmgr);
          }
        }
      }

    leave1b:
      ;
      event_base_free(ctx->evbase);
    }

  leave1:
    ;
    free((void *)ctx);
  }

leave0:
  ;
  return (struct proxy_ctx *)(void *)0;
}

// proxy_run
// file proxy.h line 38
void proxy_run(struct proxy_ctx *ctx)
{
  if(!(ctx->opts->detach == 0u))
    event_reinit(ctx->evbase);

  if(!((signed long int)ctx->opts->debug == 0l))
    event_base_dump_events(ctx->evbase, stderr);

  signed int return_value_pxy_thrmgr_run_1;
  return_value_pxy_thrmgr_run_1=pxy_thrmgr_run(ctx->thrmgr);
  if(return_value_pxy_thrmgr_run_1 == -1)
    log_err_printf("Failed to start thread manager\n");

  else
  {
    if(!((signed long int)ctx->opts->debug == 0l))
      log_dbg_printf("Starting main event loop.\n");

    event_base_dispatch(ctx->evbase);
    if(!((signed long int)ctx->opts->debug == 0l))
      log_dbg_printf("Main event loop stopped.\n");

  }
}

// proxy_signal_cb
// file proxy.c line 242
static void proxy_signal_cb(signed int fd, signed short int what, void *arg)
{
  struct proxy_ctx *ctx = (struct proxy_ctx *)arg;
  if(!((signed long int)ctx->opts->debug == 0l))
    log_dbg_printf("Received signal %i\n", fd);

  if(fd == 13)
    log_err_printf("Warning: Received SIGPIPE; ignoring.\n");

  else
    event_base_loopbreak(ctx->evbase);
}

// proxyspec_free
// file opts.c line 413
void proxyspec_free(struct proxyspec *spec)
{
  while(!(spec == ((struct proxyspec *)NULL)))
  {
    struct proxyspec *next = spec->next;
    if(!(spec->natengine == ((char *)NULL)))
      free((void *)spec->natengine);

    memset((void *)spec, 0, sizeof(struct proxyspec) /*312ul*/ );
    free((void *)spec);
    spec = next;
  }
}

// proxyspec_parse
// file opts.c line 263
struct proxyspec * proxyspec_parse(signed int *argc, char ***argv, const char *natengine)
{
  struct proxyspec *curspec;
  struct proxyspec *spec = (struct proxyspec *)(void *)0;
  char *addr;
  signed int af;
  signed int state = 0;
  signed int tmp_post_1;
  void *return_value_malloc_2;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  char *return_value_strstr_8;
  char *return_value_strpbrk_7;
  signed int return_value_strcmp_11;
  _Bool tmp_if_expr_13;
  signed int return_value_strcmp_12;
  _Bool tmp_if_expr_15;
  signed int return_value_strcmp_14;
  _Bool tmp_if_expr_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_10;
  signed int return_value_nat_exist_9;
  signed int return_value_atoi_18;
  do
  {
    tmp_post_1 = *argc;
    *argc = *argc - 1;
    if(tmp_post_1 == 0)
      break;

    switch(state)
    {
      case 0:
      {
        return_value_malloc_2=malloc(sizeof(struct proxyspec) /*312ul*/ );
        curspec = (struct proxyspec *)return_value_malloc_2;
        memset((void *)curspec, 0, sizeof(struct proxyspec) /*312ul*/ );
        curspec->next = spec;
        spec = curspec;
        return_value_strcmp_6=strcmp(*(*argv), "tcp");
        if(return_value_strcmp_6 == 0)
        {
          spec->ssl = (unsigned int)0;
          spec->http = (unsigned int)0;
        }

        else
        {
          return_value_strcmp_5=strcmp(*(*argv), "ssl");
          if(return_value_strcmp_5 == 0)
          {
            spec->ssl = (unsigned int)1;
            spec->http = (unsigned int)0;
          }

          else
          {
            return_value_strcmp_4=strcmp(*(*argv), "http");
            if(return_value_strcmp_4 == 0)
            {
              spec->ssl = (unsigned int)0;
              spec->http = (unsigned int)1;
            }

            else
            {
              return_value_strcmp_3=strcmp(*(*argv), "https");
              if(return_value_strcmp_3 == 0)
              {
                spec->ssl = (unsigned int)1;
                spec->http = (unsigned int)1;
              }

              else
              {
                fprintf(stderr, "Unknown connection type '%s'\n", *(*argv));
                exit(1);
              }
            }
          }
        }
        state = state + 1;
        break;
      }
      case 1:
      {
        addr = *(*argv);
        state = state + 1;
        break;
      }
      case 2:
      {
        return_value_strstr_8=strstr(addr, ":");
        if(!(return_value_strstr_8 == ((char *)NULL)))
          af = 10;

        else
        {
          return_value_strpbrk_7=strpbrk(addr, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-");
          if(return_value_strpbrk_7 == ((char *)NULL))
            af = 2;

          else
            af = 0;
        }
        af=sys_sockaddr_parse(&spec->listen_addr, &spec->listen_addrlen, addr, *(*argv), af, 0x0001);
        if(af == -1)
          exit(1);

        if(!(natengine == ((const char *)NULL)))
        {
          spec->natengine=strdup(natengine);
          if(spec->natengine == ((char *)NULL))
          {
            fprintf(stderr, "Out of memory\n");
            exit(1);
          }

        }

        else
          spec->natengine = (char *)(void *)0;
        state = state + 1;
        break;
      }
      case 3:
      {
        return_value_strcmp_11=strcmp(*(*argv), "tcp");
        if(return_value_strcmp_11 == 0)
          tmp_if_expr_13 = (_Bool)1;

        else
        {
          return_value_strcmp_12=strcmp(*(*argv), "ssl");
          tmp_if_expr_13 = !(return_value_strcmp_12 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_13)
          tmp_if_expr_15 = (_Bool)1;

        else
        {
          return_value_strcmp_14=strcmp(*(*argv), "http");
          tmp_if_expr_15 = !(return_value_strcmp_14 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_15)
          tmp_if_expr_17 = (_Bool)1;

        else
        {
          return_value_strcmp_16=strcmp(*(*argv), "https");
          tmp_if_expr_17 = !(return_value_strcmp_16 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_17)
        {
          *argv = *argv - 1l;
          *argc = *argc + 1;
          state = 0;
        }

        else
        {
          return_value_strcmp_10=strcmp(*(*argv), "sni");
          if(return_value_strcmp_10 == 0)
          {
            free((void *)spec->natengine);
            spec->natengine = (char *)(void *)0;
            if(spec->ssl == 0u)
            {
              fprintf(stderr, "SNI hostname lookup only works for ssl and https proxyspecs\n");
              exit(1);
            }

            state = 5;
          }

          else
          {
            return_value_nat_exist_9=nat_exist(*(*argv));
            if(!(return_value_nat_exist_9 == 0))
            {
              free((void *)spec->natengine);
              spec->natengine=strdup(*(*argv));
              if(spec->natengine == ((char *)NULL))
              {
                fprintf(stderr, "Out of memory\n");
                exit(1);
              }

              state = 0;
            }

            else
            {
              free((void *)spec->natengine);
              spec->natengine = (char *)(void *)0;
              addr = *(*argv);
              state = state + 1;
            }
          }
        }
        break;
      }
      case 4:
      {
        af=sys_sockaddr_parse(&spec->connect_addr, &spec->connect_addrlen, addr, *(*argv), af, 0);
        if(af == -1)
          exit(1);

        state = 0;
        break;
      }
      case 5:
      {
        return_value_atoi_18=atoi(*(*argv));
        spec->sni_port = (unsigned short int)return_value_atoi_18;
        if(spec->sni_port == 0)
        {
          fprintf(stderr, "Invalid port '%s'\n", *(*argv));
          exit(1);
        }

        state = 0;
      }
    }
    *argv = *argv + 1l;
  }
  while((_Bool)1);
  if(!(state == 0) && !(state == 3))
  {
    fprintf(stderr, "Incomplete proxyspec!\n");
    exit(1);
  }

  return spec;
}

// pxy_bev_eventcb
// file pxyconn.c line 1635
static void pxy_bev_eventcb(struct bufferevent *bev, signed short int events, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  struct pxy_conn_desc *this;
  struct pxy_conn_desc *tmp_if_expr_1;
  if(bev == ctx->src.bev)
    tmp_if_expr_1 = &ctx->src;

  else
    tmp_if_expr_1 = &ctx->dst;
  this = tmp_if_expr_1;
  struct pxy_conn_desc *other;
  struct pxy_conn_desc *tmp_if_expr_2;
  if(bev == ctx->src.bev)
    tmp_if_expr_2 = &ctx->dst;

  else
    tmp_if_expr_2 = &ctx->src;
  other = tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  char *tmp_if_expr_11;
  char *tmp_if_expr_19;
  signed int *return_value___errno_location_17;
  char *return_value_strerror_18;
  const char *tmp_if_expr_21;
  const char *return_value_ERR_reason_error_string_20;
  const char *tmp_if_expr_23;
  const char *return_value_ERR_lib_error_string_22;
  const char *tmp_if_expr_25;
  const char *return_value_ERR_func_error_string_24;
  char *tmp_if_expr_33;
  signed int *return_value___errno_location_31;
  char *return_value_strerror_32;
  const char *tmp_if_expr_35;
  const char *return_value_ERR_reason_error_string_34;
  const char *tmp_if_expr_37;
  const char *return_value_ERR_lib_error_string_36;
  const char *tmp_if_expr_39;
  const char *return_value_ERR_func_error_string_38;
  if(!((0x80 & (signed int)events) == 0))
  {
    if(bev == ctx->dst.bev)
    {
      ctx->connected = (unsigned int)1;
      if(!(ctx->spec->ssl == 0u))
      {
        if(ctx->passthrough == 0u)
        {
          ctx->src.ssl=pxy_srcssl_create(ctx, this->ssl);
          if(ctx->src.ssl == ((struct ssl_st *)NULL))
          {
            bufferevent_free_and_close_fd(bev, ctx);
            ctx->dst.bev = (struct bufferevent *)(void *)0;
            ctx->dst.ssl = (struct ssl_st *)(void *)0;
            if(!(ctx->opts->passthrough == 0u))
            {
              if(ctx->enomem == 0u)
              {
                ctx->passthrough = (unsigned int)1;
                ctx->connected = (unsigned int)0;
                log_dbg_printf("No cert found; falling back to passthrough\n");
                pxy_fd_readcb(ctx->fd, (signed short int)0, (void *)ctx);
                goto __CPROVER_DUMP_L69;
              }

            }

            evutil_closesocket(ctx->fd);
            pxy_conn_ctx_free(ctx);
            goto __CPROVER_DUMP_L69;
          }

        }

      }

      ctx->src.bev=pxy_bufferevent_setup(ctx, ctx->fd, ctx->src.ssl);
      if(ctx->src.bev == ((struct bufferevent *)NULL))
      {
        if(!(ctx->src.ssl == ((struct ssl_st *)NULL)))
        {
          SSL_free(ctx->src.ssl);
          ctx->src.ssl = (struct ssl_st *)(void *)0;
        }

        bufferevent_free_and_close_fd(bev, ctx);
        evutil_closesocket(ctx->fd);
        pxy_conn_ctx_free(ctx);
        goto __CPROVER_DUMP_L69;
      }

      if(!(ctx->opts->connectlog == ((char *)NULL)))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        if(!(ctx->opts->contentlog == ((char *)NULL)))
          tmp_if_expr_4 = !(ctx->passthrough != 0u) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
      {
        ctx->dst_str=sys_sockaddr_str((struct sockaddr *)&ctx->addr, ctx->addrlen);
        if(ctx->dst_str == ((char *)NULL))
        {
          ctx->enomem = (unsigned int)1;
          pxy_conn_terminate_free(ctx);
          goto __CPROVER_DUMP_L69;
        }

      }

      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          signed int return_value_log_content_open_7;
          return_value_log_content_open_7=log_content_open(&ctx->logctx, ctx->opts, ctx->src_str, ctx->dst_str, (char *)(void *)0, (char *)(void *)0, (char *)(void *)0);
          if(return_value_log_content_open_7 == -1)
          {
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            if(*return_value___errno_location_6 == 12)
              ctx->enomem = (unsigned int)1;

            pxy_conn_terminate_free(ctx);
            goto __CPROVER_DUMP_L69;
          }

        }

      }

    }


  connected:
    ;
    if(this->ssl == ((struct ssl_st *)NULL))
      tmp_if_expr_10 = (_Bool)1;

    else
      tmp_if_expr_10 = bev == ctx->src.bev ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_10)
    {
      if(ctx->spec->http == 0u)
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = ctx->passthrough != 0u ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_9)
      {
        if(!(ctx->opts->connectlog == ((char *)NULL)))
          tmp_if_expr_8 = (_Bool)1;

        else
          tmp_if_expr_8 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_8)
          pxy_log_connect_nonhttp(ctx);

      }

    }

    if(!((signed long int)ctx->opts->debug == 0l))
    {
      if(!(this->ssl == ((struct ssl_st *)NULL)))
      {
        if(bev == ctx->dst.bev)
          tmp_if_expr_11 = ctx->dst_str;

        else
          tmp_if_expr_11 = ctx->src_str;
        const char *return_value_SSL_get_version_12;
        return_value_SSL_get_version_12=SSL_get_version(this->ssl);
        const struct ssl_cipher_st *return_value_SSL_get_current_cipher_13;
        return_value_SSL_get_current_cipher_13=SSL_get_current_cipher(this->ssl);
        const char *return_value_SSL_CIPHER_get_name_14;
        return_value_SSL_CIPHER_get_name_14=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher_13);
        log_dbg_printf("SSL connected %s %s %s %s\n", bev == ctx->dst.bev ? "to" : "from", tmp_if_expr_11, return_value_SSL_get_version_12, return_value_SSL_CIPHER_get_name_14);
      }

      else
      {
        log_dbg_printf("TCP connected to %s\n", ctx->dst_str);
        log_dbg_printf("TCP connected from %s\n", ctx->src_str);
      }
    }

  }

  else
  {
    if(!((0x20 & (signed int)events) == 0))
    {
      unsigned long int sslerr;
      signed int have_sslerr = 0;
      sslerr=bufferevent_get_openssl_error(bev);
      if(!(sslerr == 0ul))
        have_sslerr = 1;

      signed int *return_value___errno_location_43;
      return_value___errno_location_43=__errno_location();
      if(*return_value___errno_location_43 == 0 && sslerr == 0ul)
      {
        if(!((signed long int)ctx->opts->debug == 0l))
          log_dbg_printf("Unclean SSL shutdown.\n");

      }

      else
        if((4095 & (signed int)sslerr) == 1040)
        {
          signed int *return_value___errno_location_15;
          return_value___errno_location_15=__errno_location();
          signed int *return_value___errno_location_16;
          return_value___errno_location_16=__errno_location();
          if(!(*return_value___errno_location_16 == 0))
          {
            return_value___errno_location_17=__errno_location();
            return_value_strerror_18=strerror(*return_value___errno_location_17);
            tmp_if_expr_19 = return_value_strerror_18;
          }

          else
            tmp_if_expr_19 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_reason_error_string_20=ERR_reason_error_string(sslerr);
            tmp_if_expr_21 = return_value_ERR_reason_error_string_20;
          }

          else
            tmp_if_expr_21 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_lib_error_string_22=ERR_lib_error_string(sslerr);
            tmp_if_expr_23 = return_value_ERR_lib_error_string_22;
          }

          else
            tmp_if_expr_23 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_func_error_string_24=ERR_func_error_string(sslerr);
            tmp_if_expr_25 = return_value_ERR_func_error_string_24;
          }

          else
            tmp_if_expr_25 = "-";
          log_dbg_printf("Error from bufferevent: %i:%s %lu:%i:%s:%i:%s:%i:%s\n", *return_value___errno_location_15, tmp_if_expr_19, sslerr, (signed int)(sslerr & (unsigned long int)0xfffL), tmp_if_expr_21, (signed int)((unsigned long int)sslerr >> 24L & (unsigned long int)0xffL), tmp_if_expr_23, (signed int)((unsigned long int)sslerr >> 12L & (unsigned long int)0xfffL), tmp_if_expr_25);
          do
          {
            sslerr=bufferevent_get_openssl_error(bev);
            if(sslerr == 0ul)
              break;

            const char *return_value_ERR_reason_error_string_26;
            return_value_ERR_reason_error_string_26=ERR_reason_error_string(sslerr);
            const char *return_value_ERR_lib_error_string_27;
            return_value_ERR_lib_error_string_27=ERR_lib_error_string(sslerr);
            const char *return_value_ERR_func_error_string_28;
            return_value_ERR_func_error_string_28=ERR_func_error_string(sslerr);
            log_dbg_printf("Additional SSL error: %lu:%i:%s:%i:%s:%i:%s\n", sslerr, (signed int)(sslerr & (unsigned long int)0xfffL), return_value_ERR_reason_error_string_26, (signed int)((unsigned long int)sslerr >> 24L & (unsigned long int)0xffL), return_value_ERR_lib_error_string_27, (signed int)((unsigned long int)sslerr >> 12L & (unsigned long int)0xfffL), return_value_ERR_func_error_string_28);
          }
          while((_Bool)1);
        }

        else
        {
          signed int *return_value___errno_location_29;
          return_value___errno_location_29=__errno_location();
          signed int *return_value___errno_location_30;
          return_value___errno_location_30=__errno_location();
          if(!(*return_value___errno_location_30 == 0))
          {
            return_value___errno_location_31=__errno_location();
            return_value_strerror_32=strerror(*return_value___errno_location_31);
            tmp_if_expr_33 = return_value_strerror_32;
          }

          else
            tmp_if_expr_33 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_reason_error_string_34=ERR_reason_error_string(sslerr);
            tmp_if_expr_35 = return_value_ERR_reason_error_string_34;
          }

          else
            tmp_if_expr_35 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_lib_error_string_36=ERR_lib_error_string(sslerr);
            tmp_if_expr_37 = return_value_ERR_lib_error_string_36;
          }

          else
            tmp_if_expr_37 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_func_error_string_38=ERR_func_error_string(sslerr);
            tmp_if_expr_39 = return_value_ERR_func_error_string_38;
          }

          else
            tmp_if_expr_39 = "-";
          log_err_printf("Error from bufferevent: %i:%s %lu:%i:%s:%i:%s:%i:%s\n", *return_value___errno_location_29, tmp_if_expr_33, sslerr, (signed int)(sslerr & (unsigned long int)0xfffL), tmp_if_expr_35, (signed int)((unsigned long int)sslerr >> 24L & (unsigned long int)0xffL), tmp_if_expr_37, (signed int)((unsigned long int)sslerr >> 12L & (unsigned long int)0xfffL), tmp_if_expr_39);
          do
          {
            sslerr=bufferevent_get_openssl_error(bev);
            if(sslerr == 0ul)
              break;

            const char *return_value_ERR_reason_error_string_40;
            return_value_ERR_reason_error_string_40=ERR_reason_error_string(sslerr);
            const char *return_value_ERR_lib_error_string_41;
            return_value_ERR_lib_error_string_41=ERR_lib_error_string(sslerr);
            const char *return_value_ERR_func_error_string_42;
            return_value_ERR_func_error_string_42=ERR_func_error_string(sslerr);
            log_err_printf("Additional SSL error: %lu:%i:%s:%i:%s:%i:%s\n", sslerr, (signed int)(sslerr & (unsigned long int)0xfffL), return_value_ERR_reason_error_string_40, (signed int)((unsigned long int)sslerr >> 24L & (unsigned long int)0xffL), return_value_ERR_lib_error_string_41, (signed int)((unsigned long int)sslerr >> 12L & (unsigned long int)0xfffL), return_value_ERR_func_error_string_42);
          }
          while((_Bool)1);
        }
      if(ctx->connected == 0u)
      {
        if(bev == ctx->dst.bev)
        {
          if(!(ctx->dst.ssl == ((struct ssl_st *)NULL)))
          {
            if(!(ctx->opts->passthrough == 0u))
            {
              if(!(have_sslerr == 0))
              {
                bufferevent_free_and_close_fd(bev, ctx);
                ctx->dst.bev = (struct bufferevent *)(void *)0;
                ctx->dst.ssl = (struct ssl_st *)(void *)0;
                ctx->passthrough = (unsigned int)1;
                log_dbg_printf("SSL dst connection failed; falling back to passthrough\n");
                pxy_fd_readcb(ctx->fd, (signed short int)0, (void *)ctx);
                goto __CPROVER_DUMP_L69;
              }

            }

          }

        }

        evutil_closesocket(ctx->fd);
        other->closed = (unsigned int)1;
      }

      else
        if(other->closed == 0u)
        {
          struct evbuffer *pxy_bev_eventcb__1__2__5__outbuf;
          pxy_bev_eventcb__1__2__5__outbuf=bufferevent_get_output(other->bev);
          unsigned long int return_value_evbuffer_get_length_44;
          return_value_evbuffer_get_length_44=evbuffer_get_length(pxy_bev_eventcb__1__2__5__outbuf);
          if(return_value_evbuffer_get_length_44 == 0ul)
          {
            bufferevent_free_and_close_fd(other->bev, ctx);
            other->closed = (unsigned int)1;
          }

        }

      goto leave;
    }

    if(!((0x10 & (signed int)events) == 0))
    {
      if(other->closed == 0u)
      {
        struct evbuffer *inbuf;
        struct evbuffer *outbuf;
        inbuf=bufferevent_get_input(bev);
        outbuf=bufferevent_get_output(other->bev);
        unsigned long int return_value_evbuffer_get_length_46;
        return_value_evbuffer_get_length_46=evbuffer_get_length(inbuf);
        if(return_value_evbuffer_get_length_46 >= 1ul)
          evbuffer_add_buffer(outbuf, inbuf);

        else
        {
          unsigned long int return_value_evbuffer_get_length_45;
          return_value_evbuffer_get_length_45=evbuffer_get_length(outbuf);
          if(return_value_evbuffer_get_length_45 == 0ul)
          {
            bufferevent_free_and_close_fd(other->bev, ctx);
            other->closed = (unsigned int)1;
          }

        }
      }

    }

    else
    {
      log_err_printf("Unknown bufferevent 0x%02X\n", (signed int)events);
      goto __CPROVER_DUMP_L69;
    }

  leave:
    ;
    if(!((signed long int)ctx->opts->debug == 0l))
    {
      log_dbg_printf("%s disconnected to %s\n", this->ssl != ((struct ssl_st *)NULL) ? "SSL" : "TCP", ctx->dst_str);
      log_dbg_printf("%s disconnected from %s\n", this->ssl != ((struct ssl_st *)NULL) ? "SSL" : "TCP", ctx->src_str);
    }

    this->closed = (unsigned int)1;
    bufferevent_free_and_close_fd(bev, ctx);
    if(!(other->closed == 0u))
      pxy_conn_ctx_free(ctx);

  }

__CPROVER_DUMP_L69:
  ;
}

// pxy_bev_readcb
// file pxyconn.c line 1439
static void pxy_bev_readcb(struct bufferevent *bev, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  struct pxy_conn_desc *other;
  struct pxy_conn_desc *tmp_if_expr_1;
  if(bev == ctx->src.bev)
    tmp_if_expr_1 = &ctx->dst;

  else
    tmp_if_expr_1 = &ctx->src;
  other = tmp_if_expr_1;
  if(ctx->connected == 0u)
  {
    log_err_printf("readcb called when other end not connected - aborting.\n");
    log_fini();
    exit(1);
  }

  struct evbuffer *inbuf;
  inbuf=bufferevent_get_input(bev);
  if(!(other->closed == 0u))
  {
    unsigned long int return_value_evbuffer_get_length_2;
    return_value_evbuffer_get_length_2=evbuffer_get_length(inbuf);
    evbuffer_drain(inbuf, return_value_evbuffer_get_length_2);
    goto __CPROVER_DUMP_L47;
  }

  struct evbuffer *outbuf;
  outbuf=bufferevent_get_output(other->bev);
  _Bool tmp_if_expr_6;
  if(!(ctx->spec->http == 0u))
    tmp_if_expr_6 = !(ctx->seen_req_header != 0u) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_6 = (_Bool)0;
  _Bool tmp_if_expr_7;
  if(tmp_if_expr_6)
    tmp_if_expr_7 = bev == ctx->src.bev ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  _Bool tmp_if_expr_8;
  if(tmp_if_expr_7)
    tmp_if_expr_8 = !(ctx->passthrough != 0u) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_8 = (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_8)
  {
    struct logbuf *pxy_bev_readcb__1__3__lb = (struct logbuf *)(void *)0;
    struct logbuf *pxy_bev_readcb__1__3__tail = (struct logbuf *)(void *)0;
    char *line;
    do
    {
      line=evbuffer_readln(inbuf, (unsigned long int *)(void *)0, (enum evbuffer_eol_style)EVBUFFER_EOL_CRLF);
      if(line == ((char *)NULL))
        break;

      char *replace;
      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          struct logbuf *pxy_bev_readcb__1__3__1__1__tmp;
          pxy_bev_readcb__1__3__1__1__tmp=logbuf_new_printf((void *)0, (struct logbuf *)(void *)0, "%s\r\n", line);
          if(!(pxy_bev_readcb__1__3__tail == ((struct logbuf *)NULL)))
          {
            if(!(pxy_bev_readcb__1__3__1__1__tmp == ((struct logbuf *)NULL)))
            {
              pxy_bev_readcb__1__3__tail->next = pxy_bev_readcb__1__3__1__1__tmp;
              pxy_bev_readcb__1__3__tail = pxy_bev_readcb__1__3__tail->next;
            }

          }

          else
          {
            pxy_bev_readcb__1__3__tail = pxy_bev_readcb__1__3__1__1__tmp;
            pxy_bev_readcb__1__3__lb = pxy_bev_readcb__1__3__tail;
          }
        }

      }

      replace=pxy_http_reqhdr_filter_line(line, ctx);
      if(replace == line)
        evbuffer_add_printf(outbuf, "%s\r\n", line);

      else
        if(!(replace == ((char *)NULL)))
        {
          evbuffer_add_printf(outbuf, "%s\r\n", replace);
          free((void *)replace);
        }

      free((void *)line);
      if(!(ctx->seen_req_header == 0u))
      {
        if(!(ctx->opts->deny_ocsp == 0u))
          pxy_ocsp_deny(ctx);

        break;
      }

    }
    while((_Bool)1);
    if(!(pxy_bev_readcb__1__3__lb == ((struct logbuf *)NULL)))
    {
      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          signed int return_value_log_content_submit_3;
          return_value_log_content_submit_3=log_content_submit(ctx->logctx, pxy_bev_readcb__1__3__lb, 1);
          if(return_value_log_content_submit_3 == -1)
          {
            logbuf_free(pxy_bev_readcb__1__3__lb);
            log_err_printf("Warning: Content log submission failed\n");
          }

        }

      }

    }

    if(ctx->seen_req_header == 0u)
      goto __CPROVER_DUMP_L47;

  }

  else
    if(!(ctx->spec->http == 0u))
    {
      if(ctx->seen_resp_header == 0u)
      {
        if(bev == ctx->dst.bev)
        {
          if(ctx->passthrough == 0u)
          {
            struct logbuf *pxy_bev_readcb__1__4__lb = (struct logbuf *)(void *)0;
            struct logbuf *tail = (struct logbuf *)(void *)0;
            char *pxy_bev_readcb__1__4__line;
            do
            {
              pxy_bev_readcb__1__4__line=evbuffer_readln(inbuf, (unsigned long int *)(void *)0, (enum evbuffer_eol_style)EVBUFFER_EOL_CRLF);
              if(pxy_bev_readcb__1__4__line == ((char *)NULL))
                break;

              char *pxy_bev_readcb__1__4__1__replace;
              if(!(ctx->opts->contentlog == ((char *)NULL)))
              {
                if(ctx->passthrough == 0u)
                {
                  struct logbuf *tmp;
                  tmp=logbuf_new_printf((void *)0, (struct logbuf *)(void *)0, "%s\r\n", pxy_bev_readcb__1__4__line);
                  if(!(tail == ((struct logbuf *)NULL)))
                  {
                    if(!(tmp == ((struct logbuf *)NULL)))
                    {
                      tail->next = tmp;
                      tail = tail->next;
                    }

                  }

                  else
                  {
                    tail = tmp;
                    pxy_bev_readcb__1__4__lb = tail;
                  }
                }

              }

              pxy_bev_readcb__1__4__1__replace=pxy_http_resphdr_filter_line(pxy_bev_readcb__1__4__line, ctx);
              if(pxy_bev_readcb__1__4__1__replace == pxy_bev_readcb__1__4__line)
                evbuffer_add_printf(outbuf, "%s\r\n", pxy_bev_readcb__1__4__line);

              else
                if(!(pxy_bev_readcb__1__4__1__replace == ((char *)NULL)))
                {
                  evbuffer_add_printf(outbuf, "%s\r\n", pxy_bev_readcb__1__4__1__replace);
                  free((void *)pxy_bev_readcb__1__4__1__replace);
                }

              free((void *)pxy_bev_readcb__1__4__line);
              if(!(ctx->seen_resp_header == 0u))
              {
                if(!(ctx->opts->connectlog == ((char *)NULL)))
                  tmp_if_expr_4 = (_Bool)1;

                else
                  tmp_if_expr_4 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_4)
                  pxy_log_connect_http(ctx);

                break;
              }

            }
            while((_Bool)1);
            if(!(pxy_bev_readcb__1__4__lb == ((struct logbuf *)NULL)))
            {
              if(!(ctx->opts->contentlog == ((char *)NULL)))
              {
                if(ctx->passthrough == 0u)
                {
                  signed int return_value_log_content_submit_5;
                  return_value_log_content_submit_5=log_content_submit(ctx->logctx, pxy_bev_readcb__1__4__lb, 0);
                  if(return_value_log_content_submit_5 == -1)
                  {
                    logbuf_free(pxy_bev_readcb__1__4__lb);
                    log_err_printf("Warning: Content log submission failed\n");
                  }

                }

              }

            }

            if(ctx->seen_resp_header == 0u)
              goto __CPROVER_DUMP_L47;

          }

        }

      }

    }

  signed long int return_value_evbuffer_copyout_12;
  if(!(ctx->enomem == 0u))
    pxy_conn_terminate_free(ctx);

  else
  {
    unsigned long int return_value_evbuffer_get_length_9;
    return_value_evbuffer_get_length_9=evbuffer_get_length(inbuf);
    if(!(return_value_evbuffer_get_length_9 == 0ul))
    {
      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          struct logbuf *lb;
          unsigned long int return_value_evbuffer_get_length_10;
          return_value_evbuffer_get_length_10=evbuffer_get_length(inbuf);
          lb=logbuf_new_alloc(return_value_evbuffer_get_length_10, (void *)0, (struct logbuf *)(void *)0);
          if(!(lb == ((struct logbuf *)NULL)))
          {
            return_value_evbuffer_copyout_12=evbuffer_copyout(inbuf, (void *)lb->buf, (unsigned long int)lb->sz);
            if(!(return_value_evbuffer_copyout_12 == -1l))
            {
              signed int return_value_log_content_submit_11;
              return_value_log_content_submit_11=log_content_submit(ctx->logctx, lb, (signed int)(bev == ctx->src.bev));
              if(return_value_log_content_submit_11 == -1)
              {
                logbuf_free(lb);
                log_err_printf("Warning: Content log submission failed\n");
              }

            }

          }

        }

      }

      evbuffer_add_buffer(outbuf, inbuf);
      unsigned long int return_value_evbuffer_get_length_13;
      return_value_evbuffer_get_length_13=evbuffer_get_length(outbuf);
      if(return_value_evbuffer_get_length_13 >= 131072ul)
      {
        bufferevent_setwatermark(other->bev, (signed short int)0x04, (unsigned long int)((128 * 1024) / 2), (unsigned long int)(128 * 1024));
        bufferevent_disable(bev, (signed short int)0x02);
      }

    }

  }

__CPROVER_DUMP_L47:
  ;
}

// pxy_bev_writecb
// file pxyconn.c line 1602
static void pxy_bev_writecb(struct bufferevent *bev, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  struct pxy_conn_desc *other;
  struct pxy_conn_desc *tmp_if_expr_1;
  if(bev == ctx->src.bev)
    tmp_if_expr_1 = &ctx->dst;

  else
    tmp_if_expr_1 = &ctx->src;
  other = tmp_if_expr_1;
  struct evbuffer *outbuf;
  outbuf=bufferevent_get_output(bev);
  unsigned long int return_value_evbuffer_get_length_2;
  return_value_evbuffer_get_length_2=evbuffer_get_length(outbuf);
  if(return_value_evbuffer_get_length_2 >= 1ul)
  {
    bufferevent_setwatermark(bev, (signed short int)0x04, (unsigned long int)0, (unsigned long int)0);
    if(other->closed == 0u)
      bufferevent_enable(other->bev, (signed short int)0x02);

  }

  else
    if(!(other->closed == 0u))
    {
      bufferevent_free_and_close_fd(bev, ctx);
      pxy_conn_ctx_free(ctx);
    }

}

// pxy_bufferevent_setup
// file pxyconn.c line 1097
static struct bufferevent * pxy_bufferevent_setup(struct pxy_conn_ctx *ctx, signed int fd, struct ssl_st *ssl)
{
  struct bufferevent *bev;
  if(!(ssl == ((struct ssl_st *)NULL)))
    bev=bufferevent_openssl_socket_new(ctx->evbase, fd, ssl, (enum bufferevent_ssl_state)(fd == -1 ? BUFFEREVENT_SSL_CONNECTING : BUFFEREVENT_SSL_ACCEPTING), 4);

  else
    bev=bufferevent_socket_new(ctx->evbase, fd, 4);
  if(bev == ((struct bufferevent *)NULL))
  {
    log_err_printf("Error creating bufferevent socket\n");
    return (struct bufferevent *)(void *)0;
  }

  else
  {
    bufferevent_setcb(bev, pxy_bev_readcb, pxy_bev_writecb, pxy_bev_eventcb, (void *)ctx);
    bufferevent_enable(bev, (signed short int)(0x02 | 0x04));
    return bev;
  }
}

// pxy_conn_connect
// file pxyconn.c line 1949
static void pxy_conn_connect(struct pxy_conn_ctx *ctx)
{
  if(ctx->addrlen == 0u)
  {
    log_err_printf("No target address; aborting connection\n");
    evutil_closesocket(ctx->fd);
    pxy_conn_ctx_free(ctx);
  }

  else
    if(!(ctx->spec->ssl == 0u))
    {
      if(ctx->passthrough != 0u)
        goto __CPROVER_DUMP_L2;

      ctx->dst.ssl=pxy_dstssl_create(ctx);
      if(!(ctx->dst.ssl == ((struct ssl_st *)NULL)))
        goto __CPROVER_DUMP_L2;

      log_err_printf("Error creating SSL\n");
      evutil_closesocket(ctx->fd);
      pxy_conn_ctx_free(ctx);
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      ctx->dst.bev=pxy_bufferevent_setup(ctx, -1, ctx->dst.ssl);
      if(ctx->dst.bev == ((struct bufferevent *)NULL))
      {
        if(!(ctx->dst.ssl == ((struct ssl_st *)NULL)))
        {
          SSL_free(ctx->dst.ssl);
          ctx->dst.ssl = (struct ssl_st *)(void *)0;
        }

        evutil_closesocket(ctx->fd);
        pxy_conn_ctx_free(ctx);
      }

      else
      {
        if(!((signed long int)ctx->opts->debug == 0l))
        {
          char *ip;
          ip=sys_sockaddr_str((struct sockaddr *)&ctx->addr, ctx->addrlen);
          log_dbg_printf("Connecting to %s\n", ip);
          if(!(ip == ((char *)NULL)))
            free((void *)ip);

        }

        bufferevent_socket_connect(ctx->dst.bev, (struct sockaddr *)&ctx->addr, (signed int)ctx->addrlen);
      }
    }
}

// pxy_conn_ctx_free
// file pxyconn.c line 215
static void pxy_conn_ctx_free(struct pxy_conn_ctx *ctx)
{
  pxy_thrmgr_detach(ctx->thrmgr, ctx->thridx);
  if(!(ctx->src_str == ((char *)NULL)))
    free((void *)ctx->src_str);

  if(!(ctx->dst_str == ((char *)NULL)))
    free((void *)ctx->dst_str);

  if(!(ctx->http_method == ((char *)NULL)))
    free((void *)ctx->http_method);

  if(!(ctx->http_uri == ((char *)NULL)))
    free((void *)ctx->http_uri);

  if(!(ctx->http_host == ((char *)NULL)))
    free((void *)ctx->http_host);

  if(!(ctx->http_content_type == ((char *)NULL)))
    free((void *)ctx->http_content_type);

  if(!(ctx->http_status_code == ((char *)NULL)))
    free((void *)ctx->http_status_code);

  if(!(ctx->http_status_text == ((char *)NULL)))
    free((void *)ctx->http_status_text);

  if(!(ctx->http_content_length == ((char *)NULL)))
    free((void *)ctx->http_content_length);

  if(!(ctx->ssl_names == ((char *)NULL)))
    free((void *)ctx->ssl_names);

  if(!(ctx->origcrt == ((struct x509_st *)NULL)))
    X509_free(ctx->origcrt);

  if(!(ctx->ev == ((struct event *)NULL)))
    event_free(ctx->ev);

  if(!(ctx->sni == ((char *)NULL)))
    free((void *)ctx->sni);

  if(!(ctx->opts->contentlog == ((char *)NULL)))
  {
    if(ctx->passthrough == 0u)
    {
      if(!(ctx->logctx == ((struct log_content_ctx *)NULL)))
      {
        signed int return_value_log_content_close_1;
        return_value_log_content_close_1=log_content_close(&ctx->logctx);
        if(return_value_log_content_close_1 == -1)
          log_err_printf("Warning: Content log close failed\n");

      }

    }

  }

  free((void *)ctx);
}

// pxy_conn_ctx_new
// file pxyconn.c line 188
static struct pxy_conn_ctx * pxy_conn_ctx_new(struct proxyspec *spec, struct opts *opts, struct pxy_thrmgr_ctx *thrmgr, signed int fd)
{
  struct pxy_conn_ctx *ctx;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct pxy_conn_ctx) /*360ul*/ );
  ctx = (struct pxy_conn_ctx *)return_value_malloc_1;
  if(ctx == ((struct pxy_conn_ctx *)NULL))
    return (struct pxy_conn_ctx *)(void *)0;

  else
  {
    memset((void *)ctx, 0, sizeof(struct pxy_conn_ctx) /*360ul*/ );
    ctx->spec = spec;
    ctx->opts = opts;
    ctx->fd = fd;
    ctx->thridx=pxy_thrmgr_attach(thrmgr, &ctx->evbase, &ctx->dnsbase);
    ctx->thrmgr = thrmgr;
    return ctx;
  }
}

// pxy_conn_setup
// file pxyconn.c line 2124
void pxy_conn_setup(signed int fd, struct sockaddr *peeraddr, signed int peeraddrlen, struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts)
{
  struct pxy_conn_ctx *ctx;
  ctx=pxy_conn_ctx_new(spec, opts, thrmgr, fd);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(ctx == ((struct pxy_conn_ctx *)NULL))
  {
    log_err_printf("Error allocating memory\n");
    evutil_closesocket(fd);
  }

  else
  {
    ctx->af = (signed int)peeraddr->sa_family;
    if(!(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL)))
    {
      ctx->addrlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
      signed int return_value;
      return_value=spec->natlookup((struct sockaddr *)&ctx->addr, &ctx->addrlen, fd, peeraddr, (unsigned int)peeraddrlen);
      if(return_value == -1)
      {
        log_err_printf("Connection not found in NAT state table, aborting connection\n");
        evutil_closesocket(fd);
        pxy_conn_ctx_free(ctx);
      }

    }

    else
      if(spec->connect_addrlen >= 1u)
      {
        ctx->addrlen = spec->connect_addrlen;
        memcpy((void *)&ctx->addr, (const void *)&spec->connect_addr, (unsigned long int)ctx->addrlen);
      }

      else
        if(ctx->spec->ssl == 0u)
        {
          log_err_printf("SNI mode used for non-SSL connection; aborting connection\n");
          evutil_closesocket(fd);
          pxy_conn_ctx_free(ctx);
          goto __CPROVER_DUMP_L16;
        }

    if(!(ctx->opts->connectlog == ((char *)NULL)))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      if(!(ctx->opts->contentlog == ((char *)NULL)))
        tmp_if_expr_2 = !(ctx->passthrough != 0u) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
    {
      ctx->src_str=sys_sockaddr_str(peeraddr, (unsigned int)peeraddrlen);
      if(ctx->src_str == ((char *)NULL))
        goto memout;

    }

    if(!(ctx->spec->ssl == 0u))
    {
      ctx->ev=event_new(ctx->evbase, fd, (signed short int)0x02, pxy_fd_readcb, (void *)ctx);
      if(ctx->ev == ((struct event *)NULL))
        goto memout;

      event_add(ctx->ev, (struct timeval *)(void *)0);
    }

    else
      pxy_fd_readcb(fd, (signed short int)0, (void *)ctx);
    goto __CPROVER_DUMP_L16;

  memout:
    ;
    log_err_printf("Aborting connection setup (out of memory)!\n");
    evutil_closesocket(fd);
    pxy_conn_ctx_free(ctx);
    goto __CPROVER_DUMP_L16;
  }

__CPROVER_DUMP_L16:
  ;
}

// pxy_conn_terminate_free
// file pxyconn.c line 1421
void pxy_conn_terminate_free(struct pxy_conn_ctx *ctx)
{
  log_err_printf("Terminating connection%s!\n", ctx->enomem != 0u ? " (out of memory)" : "");
  if(!(ctx->dst.bev == ((struct bufferevent *)NULL)))
  {
    if(ctx->dst.closed == 0u)
      bufferevent_free_and_close_fd(ctx->dst.bev, ctx);

  }

  if(!(ctx->src.bev == ((struct bufferevent *)NULL)))
  {
    if(ctx->src.closed == 0u)
      bufferevent_free_and_close_fd(ctx->src.bev, ctx);

  }

  pxy_conn_ctx_free(ctx);
}

// pxy_debug_crt
// file pxyconn.c line 301
static void pxy_debug_crt(struct x509_st *crt)
{
  char *sj;
  sj=ssl_x509_subject(crt);
  if(!(sj == ((char *)NULL)))
  {
    log_dbg_printf("Subject DN: %s\n", sj);
    free((void *)sj);
  }

  char *names;
  names=ssl_x509_names_to_str(crt);
  if(!(names == ((char *)NULL)))
  {
    log_dbg_printf("Common Names: %s\n", names);
    free((void *)names);
  }

  unsigned char fpr[20l];
  signed int return_value_ssl_x509_fingerprint_sha1_1;
  return_value_ssl_x509_fingerprint_sha1_1=ssl_x509_fingerprint_sha1(crt, fpr);
  if(return_value_ssl_x509_fingerprint_sha1_1 == -1)
    log_err_printf("Warning: Error generating X509 fingerprint\n");

  else
    log_dbg_printf("Fingerprint: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n", fpr[(signed long int)0], fpr[(signed long int)1], fpr[(signed long int)2], fpr[(signed long int)3], fpr[(signed long int)4], fpr[(signed long int)5], fpr[(signed long int)6], fpr[(signed long int)7], fpr[(signed long int)8], fpr[(signed long int)9], fpr[(signed long int)10], fpr[(signed long int)11], fpr[(signed long int)12], fpr[(signed long int)13], fpr[(signed long int)14], fpr[(signed long int)15], fpr[(signed long int)16], fpr[(signed long int)17], fpr[(signed long int)18], fpr[(signed long int)19]);
}

// pxy_dstssl_create
// file pxyconn.c line 960
static struct ssl_st * pxy_dstssl_create(struct pxy_conn_ctx *ctx)
{
  struct ssl_ctx_st *sslctx;
  struct ssl_st *ssl;
  struct ssl_session_st *sess;
  const struct ssl_method_st *return_value;
  return_value=ctx->opts->sslmethod();
  sslctx=SSL_CTX_new(return_value);
  if(sslctx == ((struct ssl_ctx_st *)NULL))
  {
    ctx->enomem = (unsigned int)1;
    return (struct ssl_st *)(void *)0;
  }

  else
  {
    SSL_CTX_ctrl(sslctx, 32, 0x80000BFFL, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00800000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00040000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00000800L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00004000L, (void *)0);
    if(ctx->opts->sslcomp == 0u)
      SSL_CTX_ctrl(sslctx, 32, 0x00020000L, (void *)0);

    SSL_CTX_ctrl(sslctx, 32, 0x01000000L, (void *)0);
    if(!(ctx->opts->no_ssl3 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x02000000L, (void *)0);

    if(!(ctx->opts->no_tls10 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x04000000L, (void *)0);

    if(!(ctx->opts->no_tls11 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x10000000L, (void *)0);

    if(!(ctx->opts->no_tls12 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x08000000L, (void *)0);

    SSL_CTX_set_cipher_list(sslctx, ctx->opts->ciphers);
    SSL_CTX_set_verify(sslctx, 0x00, (signed int (*)(signed int, struct x509_store_ctx_st *))(void *)0);
    ssl=SSL_new(sslctx);
    SSL_CTX_free(sslctx);
    if(ssl == ((struct ssl_st *)NULL))
    {
      ctx->enomem = (unsigned int)1;
      return (struct ssl_st *)(void *)0;
    }

    else
    {
      if(!(ctx->sni == ((char *)NULL)))
        SSL_ctrl(ssl, 55, (signed long int)0, (void *)(char *)ctx->sni);

      signed long int return_value_SSL_ctrl_1;
      return_value_SSL_ctrl_1=SSL_ctrl(ssl, 33, (signed long int)0, (void *)0);
      SSL_ctrl(ssl, 33, return_value_SSL_ctrl_1 | 0x00000010L, (void *)0);
      void *return_value_cachedsess_mkkey_2;
      return_value_cachedsess_mkkey_2=cachedsess_mkkey((struct sockaddr *)&ctx->addr, ctx->addrlen, ctx->sni);
      void *return_value_cache_get_3;
      return_value_cache_get_3=cache_get(cachemgr_dsess, return_value_cachedsess_mkkey_2);
      sess = (struct ssl_session_st *)return_value_cache_get_3;
      if(!(sess == ((struct ssl_session_st *)NULL)))
      {
        if(!((signed long int)ctx->opts->debug == 0l))
          log_dbg_printf("Attempt reuse dst SSL session\n");

        SSL_set_session(ssl, sess);
        SSL_SESSION_free(sess);
      }

      return ssl;
    }
  }
}

// pxy_fd_readcb
// file pxyconn.c line 2030
static void pxy_fd_readcb(signed int fd, signed short int what, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  char *tmp_if_expr_1;
  unsigned int tmp_post_2;
  if(!(ctx->spec->ssl == 0u))
  {
    if(ctx->passthrough == 0u)
    {
      unsigned char buf[1024l];
      signed long int n;
      n=recv(fd, (void *)buf, sizeof(unsigned char [1024l]) /*1024ul*/ , 2);
      if(n == -1l)
      {
        log_err_printf("Error peeking on fd, aborting connection\n");
        evutil_closesocket(fd);
        pxy_conn_ctx_free(ctx);
        goto __CPROVER_DUMP_L10;
      }

      if(n == 0l)
      {
        evutil_closesocket(fd);
        pxy_conn_ctx_free(ctx);
        goto __CPROVER_DUMP_L10;
      }

      ctx->sni=ssl_tls_clienthello_parse_sni(buf, &n);
      if(!((signed long int)ctx->opts->debug == 0l))
      {
        if(!(ctx->sni == ((char *)NULL)))
          tmp_if_expr_1 = ctx->sni;

        else
          tmp_if_expr_1 = "n/a";
        log_dbg_printf("SNI peek: [%s] [%s]\n", tmp_if_expr_1, (!(ctx->sni != ((char *)NULL)) ? (n == (signed long int)-1 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? "incomplete" : "complete");
      }

      if(ctx->sni == ((char *)NULL))
      {
        if(n == -1l)
        {
          tmp_post_2 = (unsigned int)ctx->sni_peek_retries;
          ctx->sni_peek_retries = (unsigned int)ctx->sni_peek_retries + 1u;
          if(!(tmp_post_2 >= 50u))
          {
            struct timeval retry_delay = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)100 };
            event_free(ctx->ev);
            ctx->ev=event_new(ctx->evbase, fd, (signed short int)0, pxy_fd_readcb, (void *)ctx);
            if(ctx->ev == ((struct event *)NULL))
            {
              log_err_printf("Error creating retry event, aborting connection\n");
              evutil_closesocket(fd);
              pxy_conn_ctx_free(ctx);
              goto __CPROVER_DUMP_L10;
            }

            event_add(ctx->ev, &retry_delay);
            goto __CPROVER_DUMP_L10;
          }

        }

      }

      event_free(ctx->ev);
      ctx->ev = (struct event *)(void *)0;
    }

  }

  if(!(ctx->sni == ((char *)NULL)))
  {
    if(ctx->addrlen == 0u)
    {
      if(!(ctx->spec->sni_port == 0))
      {
        char sniport[6l];
        struct addrinfo hints;
        memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
        hints.ai_family = ctx->af;
        hints.ai_flags = 0x0020;
        hints.ai_socktype = 1;
        hints.ai_protocol = 6;
        snprintf(sniport, sizeof(char [6l]) /*6ul*/ , "%i", ctx->spec->sni_port);
        evdns_getaddrinfo(ctx->dnsbase, ctx->sni, sniport, &hints, pxy_sni_resolve_cb, (void *)ctx);
        goto __CPROVER_DUMP_L10;
      }

    }

  }

  pxy_conn_connect(ctx);

__CPROVER_DUMP_L10:
  ;
}

// pxy_http_reqhdr_filter_line
// file pxyconn.c line 1142
static char * pxy_http_reqhdr_filter_line(const char *line, struct pxy_conn_ctx *ctx)
{
  char *tmp_if_expr_2;
  char *return_value_strchr_1;
  _Bool tmp_if_expr_14;
  signed int return_value_strncasecmp_13;
  signed int return_value_strncasecmp_12;
  signed int return_value_strncasecmp_11;
  signed int return_value_strncasecmp_8;
  _Bool tmp_if_expr_10;
  signed int return_value_strncasecmp_9;
  if(ctx->http_method == ((char *)NULL))
  {
    char *space1;
    char *space2;
    space1=strchr(line, 32);
    if(!(space1 == ((char *)NULL)))
    {
      return_value_strchr_1=strchr(space1 + (signed long int)1, 32);
      tmp_if_expr_2 = return_value_strchr_1;
    }

    else
      tmp_if_expr_2 = (char *)(void *)0;
    space2 = tmp_if_expr_2;
    if(space1 == ((char *)NULL))
      ctx->seen_req_header = (unsigned int)1;

    else
    {
      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)((space1 - line) + (signed long int)1));
      ctx->http_method = (char *)return_value_malloc_3;
      if(!(ctx->http_method == ((char *)NULL)))
      {
        memcpy((void *)ctx->http_method, (const void *)line, (unsigned long int)(space1 - line));
        ctx->http_method[space1 - line] = (char)0;
      }

      else
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }
      space1 = space1 + 1l;
      if(space2 == ((char *)NULL))
      {
        ctx->seen_req_header = (unsigned int)1;
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(space1);
        space2 = space1 + (signed long int)return_value_strlen_4;
      }

      void *return_value_malloc_5;
      return_value_malloc_5=malloc((unsigned long int)((space2 - space1) + (signed long int)1));
      ctx->http_uri = (char *)return_value_malloc_5;
      if(!(ctx->http_uri == ((char *)NULL)))
      {
        memcpy((void *)ctx->http_uri, (const void *)space1, (unsigned long int)(space2 - space1));
        ctx->http_uri[space2 - space1] = (char)0;
      }

      else
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }
    }
  }

  else
  {
    char *newhdr;
    if(ctx->http_host == ((char *)NULL))
    {
      return_value_strncasecmp_13=strncasecmp(line, "Host:", (unsigned long int)5);
      tmp_if_expr_14 = !(return_value_strncasecmp_13 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_14 = (_Bool)0;
    if(tmp_if_expr_14)
    {
      char *return_value_util_skipws_6;
      return_value_util_skipws_6=util_skipws(line + (signed long int)5);
      ctx->http_host=strdup(return_value_util_skipws_6);
      if(ctx->http_host == ((char *)NULL))
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }

    }

    else
    {
      return_value_strncasecmp_12=strncasecmp(line, "Content-Type:", (unsigned long int)13);
      if(return_value_strncasecmp_12 == 0)
      {
        char *return_value_util_skipws_7;
        return_value_util_skipws_7=util_skipws(line + (signed long int)13);
        ctx->http_content_type=strdup(return_value_util_skipws_7);
        if(ctx->http_content_type == ((char *)NULL))
        {
          ctx->enomem = (unsigned int)1;
          return (char *)(void *)0;
        }

      }

      else
      {
        return_value_strncasecmp_11=strncasecmp(line, "Connection:", (unsigned long int)11);
        if(return_value_strncasecmp_11 == 0)
        {
          ctx->sent_http_conn_close = (unsigned int)1;
          newhdr=strdup("Connection: close");
          if(newhdr == ((char *)NULL))
          {
            ctx->enomem = (unsigned int)1;
            return (char *)(void *)0;
          }

          return newhdr;
        }

        else
        {
          return_value_strncasecmp_8=strncasecmp(line, "Accept-Encoding:", (unsigned long int)16);
          if(return_value_strncasecmp_8 == 0)
            tmp_if_expr_10 = (_Bool)1;

          else
          {
            return_value_strncasecmp_9=strncasecmp(line, "Keep-Alive:", (unsigned long int)11);
            tmp_if_expr_10 = !(return_value_strncasecmp_9 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_10)
            return (char *)(void *)0;

          else
            if((signed int)*line == 0)
            {
              ctx->seen_req_header = (unsigned int)1;
              if(ctx->sent_http_conn_close == 0u)
              {
                newhdr=strdup("Connection: close\r\n");
                if(newhdr == ((char *)NULL))
                {
                  ctx->enomem = (unsigned int)1;
                  return (char *)(void *)0;
                }

                return newhdr;
              }

            }

        }
      }
    }
  }
  return (char *)line;
}

// pxy_http_resphdr_filter_line
// file pxyconn.c line 1228
static char * pxy_http_resphdr_filter_line(const char *line, struct pxy_conn_ctx *ctx)
{
  char *tmp_if_expr_2;
  char *return_value_strchr_1;
  _Bool tmp_if_expr_7;
  signed int return_value_strncmp_6;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_17;
  signed int return_value_strncasecmp_16;
  signed int return_value_strncasecmp_9;
  _Bool tmp_if_expr_11;
  signed int return_value_strncasecmp_10;
  _Bool tmp_if_expr_13;
  signed int return_value_strncasecmp_12;
  _Bool tmp_if_expr_15;
  signed int return_value_strncasecmp_14;
  if(ctx->http_status_code == ((char *)NULL))
  {
    char *space1;
    char *space2;
    space1=strchr(line, 32);
    if(!(space1 == ((char *)NULL)))
    {
      return_value_strchr_1=strchr(space1 + (signed long int)1, 32);
      tmp_if_expr_2 = return_value_strchr_1;
    }

    else
      tmp_if_expr_2 = (char *)(void *)0;
    space2 = tmp_if_expr_2;
    if(space1 == ((char *)NULL))
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_strncmp_6=strncmp(line, "HTTP", (unsigned long int)4);
      tmp_if_expr_7 = !(!(return_value_strncmp_6 != 0)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      ctx->seen_resp_header = (unsigned int)1;

    else
    {
      unsigned long int len_code;
      unsigned long int len_text;
      if(!(space2 == ((char *)NULL)))
      {
        len_code = (unsigned long int)((space2 - space1) - (signed long int)1);
        len_text=strlen(space2 + (signed long int)1);
      }

      else
      {
        len_code=strlen(space1 + (signed long int)1);
        len_text = (unsigned long int)0;
      }
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(len_code + (unsigned long int)1);
      ctx->http_status_code = (char *)return_value_malloc_3;
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(len_text + (unsigned long int)1);
      ctx->http_status_text = (char *)return_value_malloc_4;
      if(ctx->http_status_code == ((char *)NULL))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = !(ctx->http_status_text != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }

      memcpy((void *)ctx->http_status_code, (const void *)(space1 + (signed long int)1), len_code);
      ctx->http_status_code[(signed long int)len_code] = (char)0;
      if(!(space2 == ((char *)NULL)))
        memcpy((void *)ctx->http_status_text, (const void *)(space2 + (signed long int)1), len_text);

      ctx->http_status_text[(signed long int)len_text] = (char)0;
    }
  }

  else
  {
    if(ctx->http_content_length == ((char *)NULL))
    {
      return_value_strncasecmp_16=strncasecmp(line, "Content-Length:", (unsigned long int)15);
      tmp_if_expr_17 = !(return_value_strncasecmp_16 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_17 = (_Bool)0;
    if(tmp_if_expr_17)
    {
      char *return_value_util_skipws_8;
      return_value_util_skipws_8=util_skipws(line + (signed long int)15);
      ctx->http_content_length=strdup(return_value_util_skipws_8);
      if(ctx->http_content_length == ((char *)NULL))
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }

    }

    else
    {
      return_value_strncasecmp_9=strncasecmp(line, "Public-Key-Pins:", (unsigned long int)16);
      if(return_value_strncasecmp_9 == 0)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_strncasecmp_10=strncasecmp(line, "Public-Key-Pins-Report-Only:", (unsigned long int)28);
        tmp_if_expr_11 = !(return_value_strncasecmp_10 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        return_value_strncasecmp_12=strncasecmp(line, "Strict-Transport-Security:", (unsigned long int)26);
        tmp_if_expr_13 = !(return_value_strncasecmp_12 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_13)
        tmp_if_expr_15 = (_Bool)1;

      else
      {
        return_value_strncasecmp_14=strncasecmp(line, "Alternate-Protocol:", (unsigned long int)19);
        tmp_if_expr_15 = !(return_value_strncasecmp_14 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_15)
        return (char *)(void *)0;

      else
        if((signed int)*line == 0)
          ctx->seen_resp_header = (unsigned int)1;

    }
  }
  return (char *)line;
}

// pxy_log_connect_http
// file pxyconn.c line 419
static void pxy_log_connect_http(struct pxy_conn_ctx *ctx)
{
  char *msg;
  signed int rv;
  _Bool tmp_if_expr_1;
  char *tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  char *tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  char *tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  char *tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  char *tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  char *tmp_if_expr_12;
  _Bool tmp_if_expr_13;
  char *tmp_if_expr_14;
  _Bool tmp_if_expr_15;
  char *tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  char *tmp_if_expr_18;
  _Bool tmp_if_expr_19;
  char *tmp_if_expr_20;
  _Bool tmp_if_expr_21;
  char *tmp_if_expr_22;
  _Bool tmp_if_expr_23;
  char *tmp_if_expr_24;
  _Bool tmp_if_expr_25;
  char *tmp_if_expr_26;
  _Bool tmp_if_expr_27;
  char *tmp_if_expr_28;
  _Bool tmp_if_expr_29;
  char *tmp_if_expr_30;
  _Bool tmp_if_expr_31;
  char *tmp_if_expr_32;
  if(ctx->spec->ssl == 0u)
  {
    if(!(ctx->src_str == ((char *)NULL)))
      tmp_if_expr_1 = *ctx->src_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = ctx->src_str;

    else
      tmp_if_expr_2 = "-";
    if(!(ctx->dst_str == ((char *)NULL)))
      tmp_if_expr_3 = *ctx->dst_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = ctx->dst_str;

    else
      tmp_if_expr_4 = "-";
    if(!(ctx->http_host == ((char *)NULL)))
      tmp_if_expr_5 = *ctx->http_host != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = ctx->http_host;

    else
      tmp_if_expr_6 = "-";
    if(!(ctx->http_method == ((char *)NULL)))
      tmp_if_expr_7 = *ctx->http_method != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
      tmp_if_expr_8 = ctx->http_method;

    else
      tmp_if_expr_8 = "-";
    if(!(ctx->http_uri == ((char *)NULL)))
      tmp_if_expr_9 = *ctx->http_uri != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_9 = (_Bool)0;
    if(tmp_if_expr_9)
      tmp_if_expr_10 = ctx->http_uri;

    else
      tmp_if_expr_10 = "-";
    if(!(ctx->http_status_code == ((char *)NULL)))
      tmp_if_expr_11 = *ctx->http_status_code != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_11 = (_Bool)0;
    if(tmp_if_expr_11)
      tmp_if_expr_12 = ctx->http_status_code;

    else
      tmp_if_expr_12 = "-";
    if(!(ctx->http_content_length == ((char *)NULL)))
      tmp_if_expr_13 = *ctx->http_content_length != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_13 = (_Bool)0;
    if(tmp_if_expr_13)
      tmp_if_expr_14 = ctx->http_content_length;

    else
      tmp_if_expr_14 = "-";
    rv=asprintf(&msg, "http %s %s %s %s %s %s %s%s\n", tmp_if_expr_2, tmp_if_expr_4, tmp_if_expr_6, tmp_if_expr_8, tmp_if_expr_10, tmp_if_expr_12, tmp_if_expr_14, ctx->ocsp_denied != 0u ? " ocsp:denied" : "");
  }

  else
  {
    if(!(ctx->src_str == ((char *)NULL)))
      tmp_if_expr_15 = *ctx->src_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_15 = (_Bool)0;
    if(tmp_if_expr_15)
      tmp_if_expr_16 = ctx->src_str;

    else
      tmp_if_expr_16 = "-";
    if(!(ctx->dst_str == ((char *)NULL)))
      tmp_if_expr_17 = *ctx->dst_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_17 = (_Bool)0;
    if(tmp_if_expr_17)
      tmp_if_expr_18 = ctx->dst_str;

    else
      tmp_if_expr_18 = "-";
    if(!(ctx->http_host == ((char *)NULL)))
      tmp_if_expr_19 = *ctx->http_host != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_19 = (_Bool)0;
    if(tmp_if_expr_19)
      tmp_if_expr_20 = ctx->http_host;

    else
      tmp_if_expr_20 = "-";
    if(!(ctx->http_method == ((char *)NULL)))
      tmp_if_expr_21 = *ctx->http_method != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_21 = (_Bool)0;
    if(tmp_if_expr_21)
      tmp_if_expr_22 = ctx->http_method;

    else
      tmp_if_expr_22 = "-";
    if(!(ctx->http_uri == ((char *)NULL)))
      tmp_if_expr_23 = *ctx->http_uri != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_23 = (_Bool)0;
    if(tmp_if_expr_23)
      tmp_if_expr_24 = ctx->http_uri;

    else
      tmp_if_expr_24 = "-";
    if(!(ctx->http_status_code == ((char *)NULL)))
      tmp_if_expr_25 = *ctx->http_status_code != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_25 = (_Bool)0;
    if(tmp_if_expr_25)
      tmp_if_expr_26 = ctx->http_status_code;

    else
      tmp_if_expr_26 = "-";
    if(!(ctx->http_content_length == ((char *)NULL)))
      tmp_if_expr_27 = *ctx->http_content_length != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_27 = (_Bool)0;
    if(tmp_if_expr_27)
      tmp_if_expr_28 = ctx->http_content_length;

    else
      tmp_if_expr_28 = "-";
    if(!(ctx->sni == ((char *)NULL)))
      tmp_if_expr_29 = *ctx->sni != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_29 = (_Bool)0;
    if(tmp_if_expr_29)
      tmp_if_expr_30 = ctx->sni;

    else
      tmp_if_expr_30 = "-";
    if(!(ctx->ssl_names == ((char *)NULL)))
      tmp_if_expr_31 = *ctx->ssl_names != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_31 = (_Bool)0;
    if(tmp_if_expr_31)
      tmp_if_expr_32 = ctx->ssl_names;

    else
      tmp_if_expr_32 = "-";
    const char *return_value_SSL_get_version_33;
    return_value_SSL_get_version_33=SSL_get_version(ctx->src.ssl);
    const struct ssl_cipher_st *return_value_SSL_get_current_cipher_34;
    return_value_SSL_get_current_cipher_34=SSL_get_current_cipher(ctx->src.ssl);
    const char *return_value_SSL_CIPHER_get_name_35;
    return_value_SSL_CIPHER_get_name_35=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher_34);
    const char *return_value_SSL_get_version_36;
    return_value_SSL_get_version_36=SSL_get_version(ctx->dst.ssl);
    const struct ssl_cipher_st *return_value_SSL_get_current_cipher_37;
    return_value_SSL_get_current_cipher_37=SSL_get_current_cipher(ctx->dst.ssl);
    const char *return_value_SSL_CIPHER_get_name_38;
    return_value_SSL_CIPHER_get_name_38=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher_37);
    rv=asprintf(&msg, "https %s %s %s %s %s %s %s sni:%s names:%s sproto:%s:%s dproto:%s:%s%s\n", tmp_if_expr_16, tmp_if_expr_18, tmp_if_expr_20, tmp_if_expr_22, tmp_if_expr_24, tmp_if_expr_26, tmp_if_expr_28, tmp_if_expr_30, tmp_if_expr_32, return_value_SSL_get_version_33, return_value_SSL_CIPHER_get_name_35, return_value_SSL_get_version_36, return_value_SSL_CIPHER_get_name_38, ctx->ocsp_denied != 0u ? " ocsp:denied" : "");
  }
  if(msg == ((char *)NULL) || !(rv >= 0))
    ctx->enomem = (unsigned int)1;

  else
  {
    if(ctx->opts->detach == 0u)
      log_err_printf("%s", msg);

    if(!(ctx->opts->connectlog == ((char *)NULL)))
    {
      signed int return_value_logger_print_freebuf_39;
      return_value_logger_print_freebuf_39=logger_print_freebuf(connect_log, (void *)0, (unsigned long int)0, msg);
      if(return_value_logger_print_freebuf_39 == -1)
      {
        free((void *)msg);
        log_err_printf("Warning: Connection logging failed\n");
      }

    }

    else
      free((void *)msg);
  }

out:
  ;
  goto __CPROVER_DUMP_L72;

__CPROVER_DUMP_L72:
  ;
}

// pxy_log_connect_nonhttp
// file pxyconn.c line 336
static void pxy_log_connect_nonhttp(struct pxy_conn_ctx *ctx)
{
  char *msg;
  signed int rv;
  _Bool tmp_if_expr_19;
  if(ctx->spec->ssl == 0u)
    tmp_if_expr_19 = (_Bool)1;

  else
    tmp_if_expr_19 = ctx->passthrough != 0u ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_1;
  char *tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  char *tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  char *tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  char *tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  char *tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  char *tmp_if_expr_12;
  if(tmp_if_expr_19)
  {
    if(!(ctx->src_str == ((char *)NULL)))
      tmp_if_expr_1 = *ctx->src_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = ctx->src_str;

    else
      tmp_if_expr_2 = "-";
    if(!(ctx->dst_str == ((char *)NULL)))
      tmp_if_expr_3 = *ctx->dst_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = ctx->dst_str;

    else
      tmp_if_expr_4 = "-";
    rv=asprintf(&msg, "%s %s %s\n", ctx->passthrough != 0u ? "passthrough" : "tcp", tmp_if_expr_2, tmp_if_expr_4);
  }

  else
  {
    if(!(ctx->src_str == ((char *)NULL)))
      tmp_if_expr_5 = *ctx->src_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = ctx->src_str;

    else
      tmp_if_expr_6 = "-";
    if(!(ctx->dst_str == ((char *)NULL)))
      tmp_if_expr_7 = *ctx->dst_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
      tmp_if_expr_8 = ctx->dst_str;

    else
      tmp_if_expr_8 = "-";
    if(!(ctx->sni == ((char *)NULL)))
      tmp_if_expr_9 = *ctx->sni != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_9 = (_Bool)0;
    if(tmp_if_expr_9)
      tmp_if_expr_10 = ctx->sni;

    else
      tmp_if_expr_10 = "-";
    if(!(ctx->ssl_names == ((char *)NULL)))
      tmp_if_expr_11 = *ctx->ssl_names != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_11 = (_Bool)0;
    if(tmp_if_expr_11)
      tmp_if_expr_12 = ctx->ssl_names;

    else
      tmp_if_expr_12 = "-";
    const char *return_value_SSL_get_version_13;
    return_value_SSL_get_version_13=SSL_get_version(ctx->src.ssl);
    const struct ssl_cipher_st *return_value_SSL_get_current_cipher_14;
    return_value_SSL_get_current_cipher_14=SSL_get_current_cipher(ctx->src.ssl);
    const char *return_value_SSL_CIPHER_get_name_15;
    return_value_SSL_CIPHER_get_name_15=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher_14);
    const char *return_value_SSL_get_version_16;
    return_value_SSL_get_version_16=SSL_get_version(ctx->dst.ssl);
    const struct ssl_cipher_st *return_value_SSL_get_current_cipher_17;
    return_value_SSL_get_current_cipher_17=SSL_get_current_cipher(ctx->dst.ssl);
    const char *return_value_SSL_CIPHER_get_name_18;
    return_value_SSL_CIPHER_get_name_18=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher_17);
    rv=asprintf(&msg, "ssl %s %s sni:%s names:%s sproto:%s:%s dproto:%s:%s\n", tmp_if_expr_6, tmp_if_expr_8, tmp_if_expr_10, tmp_if_expr_12, return_value_SSL_get_version_13, return_value_SSL_CIPHER_get_name_15, return_value_SSL_get_version_16, return_value_SSL_CIPHER_get_name_18);
  }
  if(msg == ((char *)NULL) || !(rv >= 0))
    ctx->enomem = (unsigned int)1;

  else
  {
    if(ctx->opts->detach == 0u)
      log_err_printf("%s", msg);

    if(!(ctx->opts->connectlog == ((char *)NULL)))
    {
      signed int return_value_logger_print_freebuf_20;
      return_value_logger_print_freebuf_20=logger_print_freebuf(connect_log, (void *)0, (unsigned long int)0, msg);
      if(return_value_logger_print_freebuf_20 == -1)
      {
        free((void *)msg);
        log_err_printf("Warning: Connection logging failed\n");
      }

    }

    else
      free((void *)msg);
  }

out:
  ;
  goto __CPROVER_DUMP_L34;

__CPROVER_DUMP_L34:
  ;
}

// pxy_ocsp_deny
// file pxyconn.c line 1355
static void pxy_ocsp_deny(struct pxy_conn_ctx *ctx)
{
  struct evbuffer *inbuf;
  struct evbuffer *outbuf;
  signed int return_value_pxy_ocsp_is_valid_uri_1;
  signed int return_value_strncasecmp_3;
  signed long int return_value_evbuffer_copyout_7;
  if(!(ctx->http_method == ((char *)NULL)))
  {
    signed int return_value_strncasecmp_2;
    return_value_strncasecmp_2=strncasecmp(ctx->http_method, "GET", (unsigned long int)3);
    if(return_value_strncasecmp_2 == 0)
    {
      return_value_pxy_ocsp_is_valid_uri_1=pxy_ocsp_is_valid_uri(ctx->http_uri, ctx);
      if(!(return_value_pxy_ocsp_is_valid_uri_1 == 0))
        goto deny;

    }

    signed int return_value_strncasecmp_4;
    return_value_strncasecmp_4=strncasecmp(ctx->http_method, "POST", (unsigned long int)4);
    if(return_value_strncasecmp_4 == 0)
    {
      if(!(ctx->http_content_type == ((char *)NULL)))
      {
        return_value_strncasecmp_3=strncasecmp(ctx->http_content_type, "application/ocsp-request", (unsigned long int)24);
        if(return_value_strncasecmp_3 == 0)
          goto deny;

      }

    }

    goto __CPROVER_DUMP_L12;

  deny:
    ;
    inbuf=bufferevent_get_input(ctx->src.bev);
    outbuf=bufferevent_get_output(ctx->src.bev);
    unsigned long int return_value_evbuffer_get_length_9;
    return_value_evbuffer_get_length_9=evbuffer_get_length(inbuf);
    if(return_value_evbuffer_get_length_9 >= 1ul)
    {
      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          struct logbuf *lb;
          unsigned long int return_value_evbuffer_get_length_5;
          return_value_evbuffer_get_length_5=evbuffer_get_length(inbuf);
          lb=logbuf_new_alloc(return_value_evbuffer_get_length_5, (void *)0, (struct logbuf *)(void *)0);
          if(!(lb == ((struct logbuf *)NULL)))
          {
            return_value_evbuffer_copyout_7=evbuffer_copyout(inbuf, (void *)lb->buf, (unsigned long int)lb->sz);
            if(!(return_value_evbuffer_copyout_7 == -1l))
            {
              signed int return_value_log_content_submit_6;
              return_value_log_content_submit_6=log_content_submit(ctx->logctx, lb, 1);
              if(return_value_log_content_submit_6 == -1)
              {
                logbuf_free(lb);
                log_err_printf("Warning: Content log submission failed\n");
              }

            }

          }

        }

      }

      unsigned long int return_value_evbuffer_get_length_8;
      return_value_evbuffer_get_length_8=evbuffer_get_length(inbuf);
      evbuffer_drain(inbuf, return_value_evbuffer_get_length_8);
    }

    bufferevent_free_and_close_fd(ctx->dst.bev, ctx);
    ctx->dst.closed = (unsigned int)1;
    static const char ocspresp[104l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '0', ' ', '2', '0', '0', ' ', 'O', 'K', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', '/', 'o', 'c', 's', 'p', '-', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'L', 'e', 'n', 'g', 't', 'h', ':', ' ', '5', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', '0', 3, '\n', 1, 3, 0 };
    evbuffer_add_printf(outbuf, ocspresp);
    ctx->ocsp_denied = (unsigned int)1;
    if(!(ctx->opts->contentlog == ((char *)NULL)))
    {
      if(ctx->passthrough == 0u)
      {
        struct logbuf *pxy_ocsp_deny__1__2__lb;
        pxy_ocsp_deny__1__2__lb=logbuf_new_copy((const void *)ocspresp, sizeof(const char [104l]) /*104ul*/  - (unsigned long int)1, (void *)0, (struct logbuf *)(void *)0);
        if(!(pxy_ocsp_deny__1__2__lb == ((struct logbuf *)NULL)))
        {
          signed int return_value_log_content_submit_10;
          return_value_log_content_submit_10=log_content_submit(ctx->logctx, pxy_ocsp_deny__1__2__lb, 0);
          if(return_value_log_content_submit_10 == -1)
          {
            logbuf_free(pxy_ocsp_deny__1__2__lb);
            log_err_printf("Warning: Content log submission failed\n");
          }

        }

      }

    }

  }


__CPROVER_DUMP_L12:
  ;
}

// pxy_ocsp_is_valid_uri
// file pxyconn.c line 1299
static signed int pxy_ocsp_is_valid_uri(const char *uri, struct pxy_conn_ctx *ctx)
{
  char *buf_url;
  unsigned long int sz_url;
  char *buf_b64;
  unsigned long int sz_b64;
  unsigned char *buf_asn1;
  unsigned long int sz_asn1;
  signed int ret;
  buf_url=strrchr(uri, 47);
  if(buf_url == ((char *)NULL))
    return 0;

  else
  {
    buf_url = buf_url + 1l;
    if(!((signed int)*buf_url == 77))
    {
      if((signed int)*buf_url == 37)
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      char *return_value_strchr_1;
      return_value_strchr_1=strchr(uri, 63);
      if(!(return_value_strchr_1 == ((char *)NULL)))
        return 0;

      else
      {
        sz_url=strlen(buf_url);
        if(!(sz_url >= 32ul))
          return 0;

        else
        {
          buf_b64=url_dec(buf_url, sz_url, &sz_b64);
          if(buf_b64 == ((char *)NULL))
          {
            ctx->enomem = (unsigned int)1;
            return 0;
          }

          else
          {
            buf_asn1=base64_dec(buf_b64, sz_b64, &sz_asn1);
            if(buf_asn1 == ((unsigned char *)NULL))
            {
              ctx->enomem = (unsigned int)1;
              free((void *)buf_b64);
              return 0;
            }

            else
            {
              ret=ssl_is_ocspreq(buf_asn1, sz_asn1);
              free((void *)buf_asn1);
              free((void *)buf_b64);
              return ret;
            }
          }
        }
      }
    }
  }
}

// pxy_ossl_servername_cb
// file pxyconn.c line 877
static signed int pxy_ossl_servername_cb(struct ssl_st *ssl, signed int *al, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  const char *sn;
  struct x509_st *sslcrt;
  sn=SSL_get_servername(ssl, 0);
  _Bool tmp_if_expr_6;
  signed int return_value_ssl_x509_names_match_5;
  _Bool tmp_if_expr_4;
  if(sn == ((const char *)NULL))
    return 3;

  else
  {
    if(!((signed long int)ctx->opts->debug == 0l))
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(sn, ctx->sni);
      if(!(return_value_strcmp_1 == 0))
        log_err_printf("Warning: SNI parser yielded different hostname than OpenSSL callback for the same ClientHello message: [%s] != [%s]\n", ctx->sni, sn);

    }

    if(ctx->immutable_cert == 0u)
    {
      sslcrt=SSL_get_certificate(ssl);
      return_value_ssl_x509_names_match_5=ssl_x509_names_match(sslcrt, sn);
      tmp_if_expr_6 = !(return_value_ssl_x509_names_match_5 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
    {
      struct x509_st *newcrt;
      struct ssl_ctx_st *newsslctx;
      if(!((signed long int)ctx->opts->debug == 0l))
        log_dbg_printf("Certificate cache: UPDATE (SNI mismatch)\n");

      newcrt=ssl_x509_forge(ctx->opts->cacrt, ctx->opts->cakey, sslcrt, sn, ctx->opts->key);
      if(newcrt == ((struct x509_st *)NULL))
      {
        ctx->enomem = (unsigned int)1;
        return 3;
      }

      void *return_value_cachefkcrt_mkkey_2;
      return_value_cachefkcrt_mkkey_2=cachefkcrt_mkkey(ctx->origcrt);
      void *return_value_cachefkcrt_mkval_3;
      return_value_cachefkcrt_mkval_3=cachefkcrt_mkval(newcrt);
      cache_set(cachemgr_fkcrt, return_value_cachefkcrt_mkkey_2, return_value_cachefkcrt_mkval_3);
      if(!((signed long int)ctx->opts->debug == 0l))
      {
        log_dbg_printf("===> Updated forged server certificate:\n");
        pxy_debug_crt(newcrt);
      }

      if(!(ctx->opts->connectlog == ((char *)NULL)))
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        if(!(ctx->ssl_names == ((char *)NULL)))
          free((void *)ctx->ssl_names);

        ctx->ssl_names=ssl_x509_names_to_str(newcrt);
        if(ctx->ssl_names == ((char *)NULL))
          ctx->enomem = (unsigned int)1;

      }

      newsslctx=pxy_srcsslctx_create(ctx, newcrt, ctx->opts->chain, ctx->opts->key);
      if(newsslctx == ((struct ssl_ctx_st *)NULL))
      {
        X509_free(newcrt);
        ctx->enomem = (unsigned int)1;
        return 3;
      }

      SSL_set_SSL_CTX(ssl, newsslctx);
      SSL_CTX_free(newsslctx);
      X509_free(newcrt);
    }

    else
      if(!((signed long int)ctx->opts->debug == 0l))
        log_dbg_printf("Certificate cache: KEEP (SNI match or target mode)\n");

    return 0;
  }
}

// pxy_ossl_sessget_cb
// file pxyconn.c line 580
static struct ssl_session_st * pxy_ossl_sessget_cb(struct ssl_st *ssl, unsigned char *id, signed int idlen, signed int *copy)
{
  struct ssl_session_st *sess;
  *copy = 0;
  void *return_value_cachessess_mkkey_1;
  return_value_cachessess_mkkey_1=cachessess_mkkey(id, (const unsigned long int)idlen);
  void *return_value_cache_get_2;
  return_value_cache_get_2=cache_get(cachemgr_ssess, return_value_cachessess_mkkey_1);
  sess = (struct ssl_session_st *)return_value_cache_get_2;
  log_dbg_printf("SSL session cache: %s\n", sess != ((struct ssl_session_st *)NULL) ? "HIT" : "MISS");
  return sess;
}

// pxy_ossl_sessnew_cb
// file pxyconn.c line 529
static signed int pxy_ossl_sessnew_cb(struct ssl_st *ssl, struct ssl_session_st *sess)
{
  if(!(sess == ((struct ssl_session_st *)NULL)))
  {
    void *return_value_cachessess_mkkey_1;
    return_value_cachessess_mkkey_1=cachessess_mkkey(sess->session_id, (const unsigned long int)sess->session_id_length);
    void *return_value_cachessess_mkval_2;
    return_value_cachessess_mkval_2=cachessess_mkval(sess);
    cache_set(cachemgr_ssess, return_value_cachessess_mkkey_1, return_value_cachessess_mkval_2);
  }

  return 0;
}

// pxy_ossl_sessremove_cb
// file pxyconn.c line 561
static void pxy_ossl_sessremove_cb(struct ssl_ctx_st *sslctx, struct ssl_session_st *sess)
{
  if(!(sess == ((struct ssl_session_st *)NULL)))
  {
    void *return_value_cachessess_mkkey_1;
    return_value_cachessess_mkkey_1=cachessess_mkkey(sess->session_id, (const unsigned long int)sess->session_id_length);
    cache_del(cachemgr_ssess, return_value_cachessess_mkkey_1);
  }

}

// pxy_sni_resolve_cb
// file pxyconn.c line 1999
static void pxy_sni_resolve_cb(signed int errcode, struct addrinfo *ai, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  if(!(errcode == 0))
  {
    const char *return_value_evutil_gai_strerror_1;
    return_value_evutil_gai_strerror_1=evutil_gai_strerror(errcode);
    log_err_printf("Cannot resolve SNI hostname '%s': %s\n", ctx->sni, return_value_evutil_gai_strerror_1);
    evutil_closesocket(ctx->fd);
    pxy_conn_ctx_free(ctx);
    goto __CPROVER_DUMP_L2;
  }

  memcpy((void *)&ctx->addr, (const void *)ai->ai_addr, (unsigned long int)ai->ai_addrlen);
  ctx->addrlen = ai->ai_addrlen;
  evutil_freeaddrinfo(ai);
  pxy_conn_connect(ctx);

__CPROVER_DUMP_L2:
  ;
}

// pxy_srccert_create
// file pxyconn.c line 728
static struct cert * pxy_srccert_create(struct pxy_conn_ctx *ctx)
{
  struct cert *cert = (struct cert *)(void *)0;
  if(!(ctx->opts->tgcrtdir == ((char *)NULL)))
  {
    if(!(ctx->sni == ((char *)NULL)))
    {
      void *return_value_cachetgcrt_mkkey_1;
      return_value_cachetgcrt_mkkey_1=cachetgcrt_mkkey(ctx->sni);
      void *return_value_cache_get_2;
      return_value_cache_get_2=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey_1);
      cert = (struct cert *)return_value_cache_get_2;
      if(cert == ((struct cert *)NULL))
      {
        char *pxy_srccert_create__1__1__1__1__wildcarded;
        pxy_srccert_create__1__1__1__1__wildcarded=ssl_wildcardify(ctx->sni);
        if(pxy_srccert_create__1__1__1__1__wildcarded == ((char *)NULL))
        {
          ctx->enomem = (unsigned int)1;
          return (struct cert *)(void *)0;
        }

        void *return_value_cachetgcrt_mkkey_3;
        return_value_cachetgcrt_mkkey_3=cachetgcrt_mkkey(pxy_srccert_create__1__1__1__1__wildcarded);
        void *return_value_cache_get_4;
        return_value_cache_get_4=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey_3);
        cert = (struct cert *)return_value_cache_get_4;
        free((void *)pxy_srccert_create__1__1__1__1__wildcarded);
      }

      if(!(cert == ((struct cert *)NULL)))
      {
        if(!((signed long int)ctx->opts->debug == 0l))
          log_dbg_printf("Target cert by SNI\n");

      }

    }

    else
      if(!(ctx->origcrt == ((struct x509_st *)NULL)))
      {
        char **names;
        names=ssl_x509_names(ctx->origcrt);
        char **p = names;
        for( ; !(*p == ((char *)NULL)); p = p + 1l)
        {
          if(cert == ((struct cert *)NULL))
          {
            void *return_value_cachetgcrt_mkkey_5;
            return_value_cachetgcrt_mkkey_5=cachetgcrt_mkkey(*p);
            void *return_value_cache_get_6;
            return_value_cache_get_6=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey_5);
            cert = (struct cert *)return_value_cache_get_6;
          }

          if(cert == ((struct cert *)NULL))
          {
            char *wildcarded;
            wildcarded=ssl_wildcardify(*p);
            if(wildcarded == ((char *)NULL))
              ctx->enomem = (unsigned int)1;

            else
            {
              void *return_value_cachetgcrt_mkkey_7;
              return_value_cachetgcrt_mkkey_7=cachetgcrt_mkkey(wildcarded);
              void *return_value_cache_get_8;
              return_value_cache_get_8=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey_7);
              cert = (struct cert *)return_value_cache_get_8;
              free((void *)wildcarded);
            }
          }

          free((void *)*p);
        }
        free((void *)names);
        if(!(ctx->enomem == 0u))
          return (struct cert *)(void *)0;

        if(!(cert == ((struct cert *)NULL)))
        {
          if(!((signed long int)ctx->opts->debug == 0l))
            log_dbg_printf("Target cert by origcrt\n");

        }

      }

    if(!(cert == ((struct cert *)NULL)))
      ctx->immutable_cert = (unsigned int)1;

  }

  if(cert == ((struct cert *)NULL))
  {
    if(!(ctx->origcrt == ((struct x509_st *)NULL)))
    {
      if(!(ctx->opts->key == ((struct evp_pkey_st *)NULL)))
      {
        cert=cert_new();
        void *return_value_cachefkcrt_mkkey_9;
        return_value_cachefkcrt_mkkey_9=cachefkcrt_mkkey(ctx->origcrt);
        void *return_value_cache_get_10;
        return_value_cache_get_10=cache_get(cachemgr_fkcrt, return_value_cachefkcrt_mkkey_9);
        cert->crt = (struct x509_st *)return_value_cache_get_10;
        if(!(cert->crt == ((struct x509_st *)NULL)))
        {
          if(!((signed long int)ctx->opts->debug == 0l))
            log_dbg_printf("Certificate cache: HIT\n");

        }

        else
        {
          if(!((signed long int)ctx->opts->debug == 0l))
            log_dbg_printf("Certificate cache: MISS\n");

          cert->crt=ssl_x509_forge(ctx->opts->cacrt, ctx->opts->cakey, ctx->origcrt, (const char *)(void *)0, ctx->opts->key);
          void *return_value_cachefkcrt_mkkey_11;
          return_value_cachefkcrt_mkkey_11=cachefkcrt_mkkey(ctx->origcrt);
          void *return_value_cachefkcrt_mkval_12;
          return_value_cachefkcrt_mkval_12=cachefkcrt_mkval(cert->crt);
          cache_set(cachemgr_fkcrt, return_value_cachefkcrt_mkkey_11, return_value_cachefkcrt_mkval_12);
        }
        cert_set_key(cert, ctx->opts->key);
        cert_set_chain(cert, ctx->opts->chain);
      }

    }

  }

  return cert;
}

// pxy_srcssl_create
// file pxyconn.c line 810
static struct ssl_st * pxy_srcssl_create(struct pxy_conn_ctx *ctx, struct ssl_st *origssl)
{
  struct cert *cert;
  void *return_value_cachedsess_mkkey_1;
  return_value_cachedsess_mkkey_1=cachedsess_mkkey((struct sockaddr *)&ctx->addr, ctx->addrlen, ctx->sni);
  struct ssl_session_st *return_value_SSL_get_session_2;
  return_value_SSL_get_session_2=SSL_get_session(origssl);
  void *return_value_cachedsess_mkval_3;
  return_value_cachedsess_mkval_3=cachedsess_mkval(return_value_SSL_get_session_2);
  cache_set(cachemgr_dsess, return_value_cachedsess_mkkey_1, return_value_cachedsess_mkval_3);
  ctx->origcrt=SSL_get_peer_certificate(origssl);
  if(!((signed long int)ctx->opts->debug == 0l))
  {
    if(!(ctx->origcrt == ((struct x509_st *)NULL)))
    {
      log_dbg_printf("===> Original server certificate:\n");
      pxy_debug_crt(ctx->origcrt);
    }

    else
      log_dbg_printf("===> Original server has no cert!\n");
  }

  cert=pxy_srccert_create(ctx);
  _Bool tmp_if_expr_5;
  struct x509_st *tmp_if_expr_4;
  if(cert == ((struct cert *)NULL))
    return (struct ssl_st *)(void *)0;

  else
  {
    if(!((signed long int)ctx->opts->debug == 0l))
    {
      log_dbg_printf("===> Forged server certificate:\n");
      pxy_debug_crt(cert->crt);
    }

    if(!(ctx->opts->connectlog == ((char *)NULL)))
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
    {
      if(!(ctx->origcrt == ((struct x509_st *)NULL)))
        tmp_if_expr_4 = ctx->origcrt;

      else
        tmp_if_expr_4 = cert->crt;
      ctx->ssl_names=ssl_x509_names_to_str(tmp_if_expr_4);
      if(ctx->ssl_names == ((char *)NULL))
        ctx->enomem = (unsigned int)1;

    }

    struct ssl_ctx_st *sslctx;
    sslctx=pxy_srcsslctx_create(ctx, cert->crt, cert->chain, cert->key);
    cert_free(cert);
    if(sslctx == ((struct ssl_ctx_st *)NULL))
    {
      ctx->enomem = (unsigned int)1;
      return (struct ssl_st *)(void *)0;
    }

    else
    {
      struct ssl_st *ssl;
      ssl=SSL_new(sslctx);
      SSL_CTX_free(sslctx);
      if(ssl == ((struct ssl_st *)NULL))
      {
        ctx->enomem = (unsigned int)1;
        return (struct ssl_st *)(void *)0;
      }

      else
      {
        signed long int return_value_SSL_ctrl_6;
        return_value_SSL_ctrl_6=SSL_ctrl(ssl, 33, (signed long int)0, (void *)0);
        SSL_ctrl(ssl, 33, return_value_SSL_ctrl_6 | 0x00000010L, (void *)0);
        return ssl;
      }
    }
  }
}

// pxy_srcsslctx_create
// file pxyconn.c line 606
static struct ssl_ctx_st * pxy_srcsslctx_create(struct pxy_conn_ctx *ctx, struct x509_st *crt, struct stack_st_X509 *chain, struct evp_pkey_st *key)
{
  struct ssl_ctx_st *sslctx;
  const struct ssl_method_st *return_value;
  return_value=ctx->opts->sslmethod();
  sslctx=SSL_CTX_new(return_value);
  signed int return_value_EVP_PKEY_type_1;
  signed int return_value_EVP_PKEY_type_2;
  if(sslctx == ((struct ssl_ctx_st *)NULL))
    return (struct ssl_ctx_st *)(void *)0;

  else
  {
    SSL_CTX_ctrl(sslctx, 32, 0x80000BFFL, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00800000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00040000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00000800L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00004000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00010000L, (void *)0);
    if(ctx->opts->sslcomp == 0u)
      SSL_CTX_ctrl(sslctx, 32, 0x00020000L, (void *)0);

    SSL_CTX_ctrl(sslctx, 32, 0x01000000L, (void *)0);
    if(!(ctx->opts->no_ssl3 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x02000000L, (void *)0);

    if(!(ctx->opts->no_tls10 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x04000000L, (void *)0);

    if(!(ctx->opts->no_tls11 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x10000000L, (void *)0);

    if(!(ctx->opts->no_tls12 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x08000000L, (void *)0);

    SSL_CTX_set_cipher_list(sslctx, ctx->opts->ciphers);
    SSL_CTX_sess_set_new_cb(sslctx, pxy_ossl_sessnew_cb);
    SSL_CTX_sess_set_remove_cb(sslctx, pxy_ossl_sessremove_cb);
    SSL_CTX_sess_set_get_cb(sslctx, pxy_ossl_sessget_cb);
    SSL_CTX_ctrl(sslctx, 44, (signed long int)(0x0002 | 0x0100 | 0x0200), (void *)0);
    SSL_CTX_callback_ctrl(sslctx, 53, (void (*)(void))pxy_ossl_servername_cb);
    SSL_CTX_ctrl(sslctx, 54, (signed long int)0, (void *)ctx);
    if(!(ctx->opts->dh == ((struct dh_st *)NULL)))
      SSL_CTX_ctrl(sslctx, 3, (signed long int)0, (void *)(char *)ctx->opts->dh);

    else
    {
      return_value_EVP_PKEY_type_1=EVP_PKEY_type(key->type);
      if(!(return_value_EVP_PKEY_type_1 == 6))
        SSL_CTX_set_tmp_dh_callback(sslctx, ssl_tmp_dh_callback);

    }
    if(!(ctx->opts->ecdhcurve == ((char *)NULL)))
    {
      struct ec_key_st *ecdh;
      ecdh=ssl_ec_by_name(ctx->opts->ecdhcurve);
      SSL_CTX_ctrl(sslctx, 4, (signed long int)0, (void *)(char *)ecdh);
      EC_KEY_free(ecdh);
    }

    else
    {
      return_value_EVP_PKEY_type_2=EVP_PKEY_type(key->type);
      if(!(return_value_EVP_PKEY_type_2 == 6))
      {
        struct ec_key_st *pxy_srcsslctx_create__1__9__ecdh;
        pxy_srcsslctx_create__1__9__ecdh=ssl_ec_by_name((const char *)(void *)0);
        SSL_CTX_ctrl(sslctx, 4, (signed long int)0, (void *)(char *)pxy_srcsslctx_create__1__9__ecdh);
        EC_KEY_free(pxy_srcsslctx_create__1__9__ecdh);
      }

    }
    SSL_CTX_use_certificate(sslctx, crt);
    SSL_CTX_use_PrivateKey(sslctx, key);
    signed int i = 0;
    signed int return_value_sk_num_3;
    return_value_sk_num_3=sk_num((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0));
    if(!(i >= return_value_sk_num_3))
    {
      struct x509_st *c;
      void *return_value_sk_value_4;
      return_value_sk_value_4=sk_value((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0), i);
      c = (struct x509_st *)return_value_sk_value_4;
      ssl_x509_refcount_inc(c);
      SSL_CTX_ctrl(sslctx, 14, (signed long int)0, (void *)(char *)c);
      i = i + 1;
    }

    return sslctx;
  }
}

// pxy_ssl_shutdown
// file pxysslshut.c line 168
void pxy_ssl_shutdown(struct opts *opts, struct event_base *evbase, struct ssl_st *ssl, signed int fd)
{
  struct pxy_ssl_shutdown_ctx *sslshutctx;
  sslshutctx=pxy_ssl_shutdown_ctx_new(opts, evbase, ssl);
  if(sslshutctx == ((struct pxy_ssl_shutdown_ctx *)NULL))
  {
    if(!((signed long int)opts->debug == 0l))
    {
      log_dbg_printf("SSL_free() in state ");
      char *return_value_ssl_ssl_state_to_str_1;
      return_value_ssl_ssl_state_to_str_1=ssl_ssl_state_to_str(ssl);
      log_dbg_print_free(return_value_ssl_ssl_state_to_str_1);
      log_dbg_printf("\n");
    }

    SSL_free(ssl);
    evutil_closesocket(fd);
  }

  else
    pxy_ssl_shutdown_cb(fd, (signed short int)0, (void *)sslshutctx);
}

// pxy_ssl_shutdown_cb
// file pxysslshut.c line 90
static void pxy_ssl_shutdown_cb(signed int fd, signed short int what, void *arg)
{
  struct pxy_ssl_shutdown_ctx *ctx = (struct pxy_ssl_shutdown_ctx *)arg;
  struct timeval retry_delay = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)100 };
  signed short int want = (signed short int)0;
  signed int rv;
  signed int sslerr;
  if(!(ctx->ev == ((struct event *)NULL)))
  {
    event_free(ctx->ev);
    ctx->ev = (struct event *)(void *)0;
  }

  rv=SSL_shutdown(ctx->ssl);
  unsigned int tmp_post_1;
  if(!(rv == 1))
  {
    if(rv == -1)
    {
      sslerr=SSL_get_error(ctx->ssl, rv);
      switch(sslerr)
      {
        case 2:
        {
          want = (signed short int)0x02;
          break;
        }
        case 3:
        {
          want = (signed short int)0x04;
          break;
        }
        case 6:
          break;
        case 5:

        case 1:
          goto complete;
        default:
        {
          log_err_printf("Unhandled SSL_shutdown() error %i.  Closing fd.\n", sslerr);
          goto complete;
        }
      }
    }

    else
    {

    retry:
      ;
      tmp_post_1 = ctx->retries;
      ctx->retries = ctx->retries + 1u;
      if(tmp_post_1 >= 50u)
        log_err_printf("Failed to shutdown SSL connection cleanly: Max retries reached. Closing fd.\n");

      else
      {
        ctx->ev=event_new(ctx->evbase, fd, want, pxy_ssl_shutdown_cb, (void *)ctx);
        if(!(ctx->ev == ((struct event *)NULL)))
        {
          event_add(ctx->ev, want != 0 ? (struct timeval *)(void *)0 : &retry_delay);
          goto __CPROVER_DUMP_L12;
        }

        log_err_printf("Failed to shutdown SSL connection cleanly: Cannot create event. Closing fd.\n");
      }
    }
  }


complete:
  ;
  if(!((signed long int)ctx->opts->debug == 0l))
  {
    log_dbg_printf("SSL_free() in state ");
    char *return_value_ssl_ssl_state_to_str_2;
    return_value_ssl_ssl_state_to_str_2=ssl_ssl_state_to_str(ctx->ssl);
    log_dbg_print_free(return_value_ssl_ssl_state_to_str_2);
    log_dbg_printf("\n");
  }

  SSL_free(ctx->ssl);
  evutil_closesocket(fd);
  pxy_ssl_shutdown_ctx_free(ctx);

__CPROVER_DUMP_L12:
  ;
}

// pxy_ssl_shutdown_ctx_free
// file pxysslshut.c line 78
static void pxy_ssl_shutdown_ctx_free(struct pxy_ssl_shutdown_ctx *ctx)
{
  free((void *)ctx);
}

// pxy_ssl_shutdown_ctx_new
// file pxysslshut.c line 62
static struct pxy_ssl_shutdown_ctx * pxy_ssl_shutdown_ctx_new(struct opts *opts, struct event_base *evbase, struct ssl_st *ssl)
{
  struct pxy_ssl_shutdown_ctx *ctx;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct pxy_ssl_shutdown_ctx) /*40ul*/ );
  ctx = (struct pxy_ssl_shutdown_ctx *)return_value_malloc_1;
  if(ctx == ((struct pxy_ssl_shutdown_ctx *)NULL))
    return (struct pxy_ssl_shutdown_ctx *)(void *)0;

  else
  {
    ctx->opts = opts;
    ctx->evbase = evbase;
    ctx->ssl = ssl;
    ctx->ev = (struct event *)(void *)0;
    ctx->retries = (unsigned int)0;
    return ctx;
  }
}

// pxy_thrmgr_attach
// file pxythrmgr.h line 47
signed int pxy_thrmgr_attach(struct pxy_thrmgr_ctx *ctx, struct event_base **evbase, struct evdns_base **dnsbase)
{
  signed int thridx;
  unsigned long int minload;
  thridx = 0;
  pthread_mutex_lock(&ctx->mutex);
  minload = ctx->thr[(signed long int)thridx]->load;
  signed int idx = 1;
  for( ; !(idx >= ctx->num_thr); idx = idx + 1)
    if(!(ctx->thr[(signed long int)idx]->load >= minload))
    {
      minload = ctx->thr[(signed long int)idx]->load;
      thridx = idx;
    }

  *evbase = ctx->thr[(signed long int)thridx]->evbase;
  *dnsbase = ctx->thr[(signed long int)thridx]->dnsbase;
  ctx->thr[(signed long int)thridx]->load = ctx->thr[(signed long int)thridx]->load + 1ul;
  pthread_mutex_unlock(&ctx->mutex);
  return thridx;
}

// pxy_thrmgr_detach
// file pxythrmgr.h line 49
void pxy_thrmgr_detach(struct pxy_thrmgr_ctx *ctx, signed int thridx)
{
  pthread_mutex_lock(&ctx->mutex);
  ctx->thr[(signed long int)thridx]->load = ctx->thr[(signed long int)thridx]->load - 1ul;
  pthread_mutex_unlock(&ctx->mutex);
}

// pxy_thrmgr_free
// file pxythrmgr.h line 45
void pxy_thrmgr_free(struct pxy_thrmgr_ctx *ctx)
{
  if(!(ctx == ((struct pxy_thrmgr_ctx *)NULL)))
  {
    pthread_mutex_destroy(&ctx->mutex);
    if(!(ctx->thr == ((struct pxy_thr_ctx **)NULL)))
    {
      signed int idx = 0;
      for( ; !(idx >= ctx->num_thr); idx = idx + 1)
      {
        event_base_loopbreak(ctx->thr[(signed long int)idx]->evbase);
        sched_yield();
      }
      signed int pxy_thrmgr_free__1__1__2__idx = 0;
      for( ; !(pxy_thrmgr_free__1__1__2__idx >= ctx->num_thr); pxy_thrmgr_free__1__1__2__idx = pxy_thrmgr_free__1__1__2__idx + 1)
        pthread_join(ctx->thr[(signed long int)pxy_thrmgr_free__1__1__2__idx]->thr, (void **)(void *)0);
      signed int pxy_thrmgr_free__1__1__3__idx = 0;
      for( ; !(pxy_thrmgr_free__1__1__3__idx >= ctx->num_thr); pxy_thrmgr_free__1__1__3__idx = pxy_thrmgr_free__1__1__3__idx + 1)
      {
        evdns_base_free(ctx->thr[(signed long int)pxy_thrmgr_free__1__1__3__idx]->dnsbase, 0);
        event_base_free(ctx->thr[(signed long int)pxy_thrmgr_free__1__1__3__idx]->evbase);
        free((void *)ctx->thr[(signed long int)pxy_thrmgr_free__1__1__3__idx]);
      }
      free((void *)ctx->thr);
    }

    free((void *)ctx);
  }

}

// pxy_thrmgr_new
// file pxythrmgr.h line 43
struct pxy_thrmgr_ctx * pxy_thrmgr_new(struct opts *opts)
{
  struct pxy_thrmgr_ctx *ctx;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct pxy_thrmgr_ctx) /*56ul*/ );
  ctx = (struct pxy_thrmgr_ctx *)return_value_malloc_1;
  if(ctx == ((struct pxy_thrmgr_ctx *)NULL))
    return (struct pxy_thrmgr_ctx *)(void *)0;

  else
  {
    memset((void *)ctx, 0, sizeof(struct pxy_thrmgr_ctx) /*56ul*/ );
    unsigned int return_value_sys_get_cpu_cores_2;
    return_value_sys_get_cpu_cores_2=sys_get_cpu_cores();
    ctx->num_thr = (signed int)((unsigned int)2 * return_value_sys_get_cpu_cores_2);
    return ctx;
  }
}

// pxy_thrmgr_run
// file pxythrmgr.h line 44
signed int pxy_thrmgr_run(struct pxy_thrmgr_ctx *ctx)
{
  signed int idx = -1;
  if(ctx == ((struct pxy_thrmgr_ctx *)NULL))
    return -1;

  else
  {
    pthread_mutex_init(&ctx->mutex, (const union anonymous *)(void *)0);
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)ctx->num_thr * sizeof(struct pxy_thr_ctx *) /*8ul*/ );
    ctx->thr = (struct pxy_thr_ctx **)return_value_malloc_1;
    if(ctx->thr == ((struct pxy_thr_ctx **)NULL))
      log_dbg_printf("Failed to allocate memory\n");

    else
    {
      memset((void *)ctx->thr, 0, (unsigned long int)ctx->num_thr * sizeof(struct pxy_thr_ctx *) /*8ul*/ );
      idx = 0;
      for( ; !(idx >= ctx->num_thr); idx = idx + 1)
      {
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(struct pxy_thr_ctx) /*40ul*/ );
        ctx->thr[(signed long int)idx] = (struct pxy_thr_ctx *)return_value_malloc_2;
        if(ctx->thr[(signed long int)idx] == ((struct pxy_thr_ctx *)NULL))
        {
          log_dbg_printf("Failed to allocate memory\n");
          goto leave;
        }

        memset((void *)ctx->thr[(signed long int)idx], 0, sizeof(struct pxy_thr_ctx) /*40ul*/ );
        ctx->thr[(signed long int)idx]->evbase=event_base_new();
        if(ctx->thr[(signed long int)idx]->evbase == ((struct event_base *)NULL))
        {
          log_dbg_printf("Failed to create evbase %d\n", idx);
          goto leave;
        }

        ctx->thr[(signed long int)idx]->dnsbase=evdns_base_new(ctx->thr[(signed long int)idx]->evbase, 1);
        if(ctx->thr[(signed long int)idx]->dnsbase == ((struct evdns_base *)NULL))
        {
          log_dbg_printf("Failed to create dnsbase %d\n", idx);
          goto leave;
        }

        ctx->thr[(signed long int)idx]->load = (unsigned long int)0;
        ctx->thr[(signed long int)idx]->running = 0;
      }
      log_dbg_printf("Initialized %d connection handling threads\n", ctx->num_thr);
      idx = 0;
      for( ; !(idx >= ctx->num_thr); idx = idx + 1)
      {
        signed int return_value_pthread_create_3;
        return_value_pthread_create_3=pthread_create(&ctx->thr[(signed long int)idx]->thr, (const union pthread_attr_t *)(void *)0, pxy_thrmgr_thr, (void *)ctx->thr[(signed long int)idx]);
        if(!(return_value_pthread_create_3 == 0))
          goto leave_thr;

        while(ctx->thr[(signed long int)idx]->running == 0)
          sched_yield();
      }
      log_dbg_printf("Started %d connection handling threads\n", ctx->num_thr);
      return 0;

    leave_thr:
      ;
      idx = idx - 1;
      for( ; idx >= 0; idx = idx - 1)
      {
        pthread_cancel(ctx->thr[(signed long int)idx]->thr);
        pthread_join(ctx->thr[(signed long int)idx]->thr, (void **)(void *)0);
      }
      idx = ctx->num_thr - 1;
    }

  leave:
    ;
    for( ; idx >= 0; idx = idx - 1)
      if(!(ctx->thr[(signed long int)idx] == ((struct pxy_thr_ctx *)NULL)))
      {
        if(!(ctx->thr[(signed long int)idx]->dnsbase == ((struct evdns_base *)NULL)))
          evdns_base_free(ctx->thr[(signed long int)idx]->dnsbase, 0);

        if(!(ctx->thr[(signed long int)idx]->evbase == ((struct event_base *)NULL)))
          event_base_free(ctx->thr[(signed long int)idx]->evbase);

        free((void *)ctx->thr[(signed long int)idx]);
      }

    pthread_mutex_destroy(&ctx->mutex);
    if(!(ctx->thr == ((struct pxy_thr_ctx **)NULL)))
    {
      free((void *)ctx->thr);
      ctx->thr = (struct pxy_thr_ctx **)(void *)0;
    }

    return -1;
  }
}

// pxy_thrmgr_thr
// file pxythrmgr.c line 76
static void * pxy_thrmgr_thr(void *arg)
{
  struct pxy_thr_ctx *ctx = (struct pxy_thr_ctx *)arg;
  struct timeval timer_delay = { .tv_sec=(signed long int)60, .tv_usec=(signed long int)0 };
  struct event *ev;
  ev=event_new(ctx->evbase, -1, (signed short int)0x10, pxy_thrmgr_timer_cb, (void *)0);
  if(ev == ((struct event *)NULL))
    return (void *)0;

  else
  {
    event_add(ev, &timer_delay);
    ctx->running = 1;
    event_base_dispatch(ctx->evbase);
    event_free(ev);
    return (void *)0;
  }
}

// pxy_thrmgr_timer_cb
// file pxythrmgr.c line 65
static void pxy_thrmgr_timer_cb(signed int fd, signed short int what, void *arg)
{
  ;
}

// ssl_dh_load
// file ssl.h line 120
struct dh_st * ssl_dh_load(const char *filename)
{
  struct dh_st *dh;
  struct _IO_FILE *fh;
  signed int return_value_ssl_init_1;
  return_value_ssl_init_1=ssl_init();
  if(return_value_ssl_init_1 == -1)
    return (struct dh_st *)(void *)0;

  else
  {
    fh=fopen(filename, "r");
    if(fh == ((struct _IO_FILE *)NULL))
      return (struct dh_st *)(void *)0;

    else
    {
      dh=PEM_read_DHparams(fh, (struct dh_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
      fclose(fh);
      return dh;
    }
  }
}

// ssl_dh_refcount_inc
// file ssl.c line 1096
void ssl_dh_refcount_inc(struct dh_st *dh)
{
  CRYPTO_add_lock(&dh->references, 1, 26, "ssl.c", 1099);
}

// ssl_dnsname_match
// file ssl.c line 1162
signed int ssl_dnsname_match(const char *certname, unsigned long int certnamesz, const char *hostname, unsigned long int hostnamesz)
{
  signed int return_value_memcmp_1;
  void *return_value_memchr_3;
  signed int return_value_memcmp_5;
  void *return_value_memchr_4;
  if(!(hostnamesz >= certnamesz))
    return 0;

  else
    if(hostnamesz == certnamesz)
    {
      return_value_memcmp_1=memcmp((const void *)certname, (const void *)hostname, certnamesz);
      if(!(return_value_memcmp_1 == 0))
        goto __CPROVER_DUMP_L2;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed int return_value_memcmp_2;
      return_value_memcmp_2=memcmp((const void *)certname, (const void *)"xn--", (unsigned long int)4);
      if(return_value_memcmp_2 == 0)
        return 0;

      else
        if(certnamesz == 1ul)
        {
          if(!((signed int)*certname == 42))
            goto __CPROVER_DUMP_L4;

          return_value_memchr_3=memchr((const void *)hostname, 46, hostnamesz);
          if(!(return_value_memchr_3 == NULL))
            goto __CPROVER_DUMP_L4;

          return 1;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(certnamesz >= 3ul)
          {
            if(!((signed int)*certname == 42))
              goto __CPROVER_DUMP_L5;

            if(!((signed int)certname[1l] == 46))
              goto __CPROVER_DUMP_L5;

            return_value_memcmp_5=memcmp((const void *)&certname[(signed long int)1], (const void *)&hostname[(signed long int)(hostnamesz - (certnamesz - (unsigned long int)1))], certnamesz - (unsigned long int)1);
            if(!(return_value_memcmp_5 == 0))
              goto __CPROVER_DUMP_L5;

            return_value_memchr_4=memchr((const void *)hostname, 46, hostnamesz);
            if(!((const char *)return_value_memchr_4 == hostname + (signed long int)hostnamesz + -(-1l + (signed long int)certnamesz)))
              goto __CPROVER_DUMP_L5;

            return 1;
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            return 0;
          }
        }
    }
}

// ssl_ec_by_name
// file ssl.h line 126
struct ec_key_st * ssl_ec_by_name(const char *curvename)
{
  signed int nid;
  if(curvename == ((const char *)NULL))
    curvename = "secp160r2";

  nid=OBJ_sn2nid(curvename);
  if(nid == 0)
    return (struct ec_key_st *)(void *)0;

  else
  {
    struct ec_key_st *return_value_EC_KEY_new_by_curve_name_1;
    return_value_EC_KEY_new_by_curve_name_1=EC_KEY_new_by_curve_name(nid);
    return return_value_EC_KEY_new_by_curve_name_1;
  }
}

// ssl_fini
// file ssl.h line 114
void ssl_fini(void)
{
  if(!(ssl_initialized == 0))
  {
    ERR_remove_state((unsigned long int)0);
    CRYPTO_set_locking_callback((void (*)(signed int, signed int, const char *, signed int))(void *)0);
    CRYPTO_set_dynlock_create_callback((struct CRYPTO_dynlock_value * (*)(const char *, signed int))(void *)0);
    CRYPTO_set_dynlock_lock_callback((void (*)(signed int, struct CRYPTO_dynlock_value *, const char *, signed int))(void *)0);
    CRYPTO_set_dynlock_destroy_callback((void (*)(struct CRYPTO_dynlock_value *, const char *, signed int))(void *)0);
    CRYPTO_THREADID_set_callback((void (*)(struct crypto_threadid_st *))(void *)0);
    signed int i = 0;
    for( ; !(i >= ssl_mutex_num); i = i + 1)
      pthread_mutex_destroy(&ssl_mutex[(signed long int)i]);
    free((void *)ssl_mutex);
    ENGINE_cleanup();
    CONF_modules_finish();
    CONF_modules_unload(1);
    CONF_modules_free();
    EVP_cleanup();
    ERR_free_strings();
    CRYPTO_cleanup_all_ex_data();
  }

}

// ssl_ia5string_strdup
// file ssl.c line 1369
static char * ssl_ia5string_strdup(struct asn1_string_st *ia5)
{
  char *str;
  _Bool tmp_if_expr_1;
  if(ia5 == ((struct asn1_string_st *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(ia5->length != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (char *)(void *)0;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(ia5->length + 1));
    str = (char *)return_value_malloc_2;
    if(str == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)str, (const void *)ia5->data, (unsigned long int)ia5->length);
      str[(signed long int)ia5->length] = (char)0;
      return str;
    }
  }
}

// ssl_init
// file ssl.c line 292
signed int ssl_init(void)
{
  signed int fd;
  char buf[256l];
  signed int return_value_RAND_status_4;
  if(!(ssl_initialized == 0))
    return 0;

  else
  {
    SSL_library_init();
    SSL_load_error_strings();
    OPENSSL_add_all_algorithms_noconf();
    ssl_mutex_num=CRYPTO_num_locks();
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)ssl_mutex_num * sizeof(union anonymous_0) /*40ul*/ );
    ssl_mutex = (union anonymous_0 *)return_value_malloc_1;
    signed int i = 0;
    for( ; !(i >= ssl_mutex_num); i = i + 1)
      pthread_mutex_init(&ssl_mutex[(signed long int)i], (const union anonymous *)(void *)0);
    CRYPTO_set_locking_callback(ssl_thr_locking_cb);
    CRYPTO_set_dynlock_create_callback(ssl_thr_dyn_create_cb);
    CRYPTO_set_dynlock_lock_callback(ssl_thr_dyn_lock_cb);
    CRYPTO_set_dynlock_destroy_callback(ssl_thr_dyn_destroy_cb);
    CRYPTO_THREADID_set_callback(ssl_thr_id_cb);
    fd=open("/dev/urandom", 00);
    if(fd == -1)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      log_err_printf("Error opening /dev/urandom for reading: %s\n", return_value_strerror_3);
      return -1;
    }

    do
    {
      return_value_RAND_status_4=RAND_status();
      if(!(return_value_RAND_status_4 == 0))
        break;

      signed long int return_value_read_7;
      return_value_read_7=read(fd, (void *)buf, sizeof(char [256l]) /*256ul*/ );
      if(return_value_read_7 == -1l)
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        char *return_value_strerror_6;
        return_value_strerror_6=strerror(*return_value___errno_location_5);
        log_err_printf("Error reading from /dev/urandom: %s\n", return_value_strerror_6);
        close(fd);
        return -1;
      }

      RAND_seed((const void *)buf, (signed int)sizeof(char [256l]) /*256ul*/ );
    }
    while((_Bool)1);
    close(fd);
    signed int return_value_RAND_poll_8;
    return_value_RAND_poll_8=RAND_poll();
    if(return_value_RAND_poll_8 == 0)
    {
      log_err_printf("RAND_poll() failed.\n");
      return -1;
    }

    else
    {
      ssl_initialized = 1;
      return 0;
    }
  }
}

// ssl_is_ocspreq
// file ssl.h line 161
signed int ssl_is_ocspreq(const unsigned char *buf, unsigned long int sz)
{
  struct ocsp_request_st *req;
  const unsigned char *p = (const unsigned char *)buf;
  req=d2i_OCSP_REQUEST((struct ocsp_request_st **)(void *)0, &p, (signed long int)sz);
  if(req == ((struct ocsp_request_st *)NULL))
    return 0;

  else
  {
    OCSP_REQUEST_free(req);
    return 1;
  }
}

// ssl_key_genrsa
// file ssl.h line 130
struct evp_pkey_st * ssl_key_genrsa(const signed int keysize)
{
  struct evp_pkey_st *pkey;
  struct rsa_st *rsa;
  rsa=RSA_generate_key(keysize, (unsigned long int)3, (void (*)(signed int, signed int, void *))(void *)0, (void *)0);
  if(rsa == ((struct rsa_st *)NULL))
    return (struct evp_pkey_st *)(void *)0;

  else
  {
    pkey=EVP_PKEY_new();
    EVP_PKEY_assign(pkey, 6, (void *)(char *)rsa);
    return pkey;
  }
}

// ssl_key_load
// file ssl.h line 129
struct evp_pkey_st * ssl_key_load(const char *filename)
{
  struct evp_pkey_st *key = (struct evp_pkey_st *)(void *)0;
  struct ssl_ctx_st *tmpctx;
  struct ssl_st *tmpssl;
  signed int rv;
  signed int return_value_ssl_init_1;
  return_value_ssl_init_1=ssl_init();
  if(return_value_ssl_init_1 == -1)
    return (struct evp_pkey_st *)(void *)0;

  else
  {
    const struct ssl_method_st *return_value_SSLv23_server_method_2;
    return_value_SSLv23_server_method_2=SSLv23_server_method();
    tmpctx=SSL_CTX_new(return_value_SSLv23_server_method_2);
    if(!(tmpctx == ((struct ssl_ctx_st *)NULL)))
    {
      rv=SSL_CTX_use_PrivateKey_file(tmpctx, filename, 1);
      if(rv == 1)
      {
        tmpssl=SSL_new(tmpctx);
        if(!(tmpssl == ((struct ssl_st *)NULL)))
        {
          key=SSL_get_privatekey(tmpssl);
          if(!(key == ((struct evp_pkey_st *)NULL)))
            ssl_key_refcount_inc(key);

          SSL_free(tmpssl);
        }

      }


    leave2:
      ;
      SSL_CTX_free(tmpctx);
    }


  leave1:
    ;
    return key;
  }
}

// ssl_key_refcount_inc
// file ssl.h line 131
void ssl_key_refcount_inc(struct evp_pkey_st *key)
{
  CRYPTO_add_lock(&key->references, 1, 10, "ssl.c", 1114);
}

// ssl_openssl_version
// file ssl.h line 111
void ssl_openssl_version(void)
{
  fprintf(stderr, "compiled against %s (%lx)\n", (const void *)"OpenSSL 1.0.2e 3 Dec 2015", (unsigned long int)0x1000205fL);
  const char *return_value_SSLeay_version_1;
  return_value_SSLeay_version_1=SSLeay_version(0);
  unsigned long int return_value_SSLeay_2;
  return_value_SSLeay_2=SSLeay();
  fprintf(stderr, "rtlinked against %s (%lx)\n", return_value_SSLeay_version_1, return_value_SSLeay_2);
  fprintf(stderr, "TLS Server Name Indication (SNI) supported\n");
  fprintf(stderr, "OpenSSL is thread-safe with THREADID\n");
  fprintf(stderr, "Using SSL_MODE_RELEASE_BUFFERS\n");
  fprintf(stderr, "SSL/TLS protocol availability: %s\n", (const void *)"ssl3 tls10 tls11 tls12 ");
  fprintf(stderr, "SSL/TLS algorithm availability:");
  fprintf(stderr, " RSA");
  fprintf(stderr, " DSA");
  fprintf(stderr, " ECDSA");
  fprintf(stderr, " DH");
  fprintf(stderr, " ECDH");
  fprintf(stderr, " EC");
  fprintf(stderr, "\n");
  fprintf(stderr, "OpenSSL option availability:");
  fprintf(stderr, " SSL_OP_NO_COMPRESSION");
  fprintf(stderr, " SSL_OP_NO_TICKET");
  fprintf(stderr, " SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION");
  fprintf(stderr, " SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS");
  fprintf(stderr, " SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION");
  fprintf(stderr, " SSL_OP_TLS_ROLLBACK_BUG");
  fprintf(stderr, "\n");
}

// ssl_rand
// file ssl.c line 670
signed int ssl_rand(void *p, unsigned long int sz)
{
  signed int rv;
  rv=RAND_pseudo_bytes((unsigned char *)p, (signed int)sz);
  if(rv == -1)
  {
    rv=RAND_bytes((unsigned char *)p, (signed int)sz);
    if(rv == 1)
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// ssl_reinit
// file ssl.h line 113
void ssl_reinit(void)
{
  if(!(ssl_initialized == 0))
  {
    signed int i = 0;
    for( ; !(i >= ssl_mutex_num); i = i + 1)
      pthread_mutex_init(&ssl_mutex[(signed long int)i], (const union anonymous *)(void *)0);
  }

}

// ssl_session_is_valid
// file ssl.c line 1533
signed int ssl_session_is_valid(struct ssl_session_st *sess)
{
  signed long int curtimet;
  signed long int curtime;
  signed long int timeout;
  curtimet=time((signed long int *)(void *)0);
  if(curtimet == -1l)
    return 0;

  else
  {
    curtime = curtimet;
    if(!(curtime == curtimet) || !(curtime >= 0l))
      return 0;

    else
    {
      timeout=SSL_SESSION_get_timeout(sess);
      if(!(0x7fffffffffffffffL + -timeout >= curtime))
        return 0;

      else
      {
        signed long int return_value_SSL_SESSION_get_time_1;
        return_value_SSL_SESSION_get_time_1=SSL_SESSION_get_time(sess);
        return (signed int)(return_value_SSL_SESSION_get_time_1 < curtime + timeout);
      }
    }
  }
}

// ssl_session_to_str
// file ssl.c line 1507
char * ssl_session_to_str(struct ssl_session_st *sess)
{
  struct bio_st *bio;
  char *p;
  char *ret;
  unsigned long int sz;
  struct bio_method_st *return_value_BIO_s_mem_1;
  return_value_BIO_s_mem_1=BIO_s_mem();
  bio=BIO_new(return_value_BIO_s_mem_1);
  if(bio == ((struct bio_st *)NULL))
    return (char *)(void *)0;

  else
  {
    SSL_SESSION_print(bio, sess);
    signed long int return_value_BIO_ctrl_2;
    return_value_BIO_ctrl_2=BIO_ctrl(bio, 3, (signed long int)0, (void *)(char *)&p);
    sz = (unsigned long int)return_value_BIO_ctrl_2;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sz + (unsigned long int)1);
    ret = (char *)return_value_malloc_3;
    if(ret == ((char *)NULL))
    {
      BIO_free(bio);
      return (char *)(void *)0;
    }

    else
    {
      memcpy((void *)ret, (const void *)p, sz);
      ret[(signed long int)sz] = (char)0;
      BIO_free(bio);
      return ret;
    }
  }
}

// ssl_ssl_state_to_str
// file ssl.h line 116
char * ssl_ssl_state_to_str(struct ssl_st *ssl)
{
  char *str = (char *)(void *)0;
  signed int rv;
  const char *return_value_SSL_state_string_1;
  return_value_SSL_state_string_1=SSL_state_string(ssl);
  const char *return_value_SSL_state_string_long_2;
  return_value_SSL_state_string_long_2=SSL_state_string_long(ssl);
  rv=asprintf(&str, "%08x = %s%s%s%04x = %s (%s) [%s]", ssl->state, (ssl->state & 0x1000) != 0 ? "SSL_ST_CONNECT|" : "", (ssl->state & 0x2000) != 0 ? "SSL_ST_ACCEPT|" : "", (ssl->state & 0x4000) != 0 ? "SSL_ST_BEFORE|" : "", ssl->state & 0x0FFF, return_value_SSL_state_string_1, return_value_SSL_state_string_long_2, ssl->type == 0x1000 ? "connect socket" : "accept socket");
  return rv < 0 ? (char *)(void *)0 : str;
}

// ssl_thr_dyn_create_cb
// file ssl.c line 232
static struct CRYPTO_dynlock_value * ssl_thr_dyn_create_cb(const char *file, signed int line)
{
  struct CRYPTO_dynlock_value *dl;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct CRYPTO_dynlock_value) /*40ul*/ );
  dl = (struct CRYPTO_dynlock_value *)return_value_malloc_1;
  if(!(dl == ((struct CRYPTO_dynlock_value *)NULL)))
    pthread_mutex_init(&dl->mutex, (const union anonymous *)(void *)0);

  return dl;
}

// ssl_thr_dyn_destroy_cb
// file ssl.c line 260
static void ssl_thr_dyn_destroy_cb(struct CRYPTO_dynlock_value *dl, const char *file, signed int line)
{
  pthread_mutex_destroy(&dl->mutex);
  free((void *)dl);
}

// ssl_thr_dyn_lock_cb
// file ssl.c line 246
static void ssl_thr_dyn_lock_cb(signed int mode, struct CRYPTO_dynlock_value *dl, const char *file, signed int line)
{
  if(!((1 & mode) == 0))
    pthread_mutex_lock(&dl->mutex);

  else
    pthread_mutex_unlock(&dl->mutex);
}

// ssl_thr_id_cb
// file ssl.c line 280
static void ssl_thr_id_cb(struct crypto_threadid_st *id)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  CRYPTO_THREADID_set_numeric(id, (unsigned long int)return_value_pthread_self_1);
}

// ssl_thr_locking_cb
// file ssl.c line 218
static void ssl_thr_locking_cb(signed int mode, signed int type, const char *file, signed int line)
{
  if(!(type >= ssl_mutex_num))
  {
    if(!((1 & mode) == 0))
      pthread_mutex_lock(&ssl_mutex[(signed long int)type]);

    else
      pthread_mutex_unlock(&ssl_mutex[(signed long int)type]);
  }

}

// ssl_tls_clienthello_parse_sni
// file ssl.h line 164
char * ssl_tls_clienthello_parse_sni(const unsigned char *buf, signed long int *sz)
{
  const unsigned char *p = buf;
  signed long int n = *sz;
  char *servername = (char *)(void *)0;
  signed long int msglen;
  signed long int sidlen;
  signed long int suiteslen;
  signed long int compslen;
  signed long int tlsextslen;
  if(!(n >= 1l))
    *sz = (signed long int)-1;

  else
    if((signed int)*p == 22)
    {
      p = p + 1l;
      n = n - 1l;
      if(!(n >= 2l))
        *sz = (signed long int)-1;

      else
        if((signed int)*p == 3)
        {
          p = p + (signed long int)2;
          n = n - (signed long int)2;
          if(!(n >= 2l))
            *sz = (signed long int)-1;

          else
          {
            p = p + (signed long int)2;
            n = n - (signed long int)2;
            if(!(n >= 1l))
              *sz = (signed long int)-1;

            else
              if((signed int)*p == 1)
              {
                p = p + 1l;
                n = n - 1l;
                if(!(n >= 3l))
                  *sz = (signed long int)-1;

                else
                {
                  msglen = (signed long int)((signed int)p[(signed long int)2] + ((signed int)p[(signed long int)1] << 8) + ((signed int)p[(signed long int)0] << 16));
                  if(msglen >= 4l)
                  {
                    p = p + (signed long int)3;
                    n = n - (signed long int)3;
                    if(!(n >= msglen))
                      *sz = (signed long int)-1;

                    else
                    {
                      n = msglen;
                      if(n >= 2l)
                      {
                        if((signed int)*p == 3)
                        {
                          p = p + (signed long int)2;
                          n = n - (signed long int)2;
                          if(n >= 32l)
                          {
                            p = p + (signed long int)32;
                            n = n - (signed long int)32;
                            if(n >= 1l)
                            {
                              sidlen = (signed long int)*p;
                              p = p + (signed long int)1;
                              n = n - (signed long int)1;
                              if(n >= sidlen)
                              {
                                p = p + sidlen;
                                n = n - sidlen;
                                if(n >= 2l)
                                {
                                  suiteslen = (signed long int)((signed int)p[(signed long int)1] + ((signed int)p[(signed long int)0] << 8));
                                  p = p + (signed long int)2;
                                  n = n - (signed long int)2;
                                  if(n >= suiteslen)
                                  {
                                    p = p + suiteslen;
                                    n = n - suiteslen;
                                    if(n >= 1l)
                                    {
                                      compslen = (signed long int)*p;
                                      p = p + 1l;
                                      n = n - 1l;
                                      if(n >= compslen)
                                      {
                                        p = p + compslen;
                                        n = n - compslen;
                                        if(n >= 2l)
                                        {
                                          tlsextslen = (signed long int)((signed int)p[(signed long int)1] + ((signed int)p[(signed long int)0] << 8));
                                          p = p + (signed long int)2;
                                          n = n - (signed long int)2;
                                          if(n >= tlsextslen)
                                          {
                                            n = tlsextslen;
                                            while(n >= 1l)
                                            {
                                              if(!(n >= 4l))
                                                break;

                                              unsigned short int exttype = (unsigned short int)((signed int)p[(signed long int)1] + ((signed int)p[(signed long int)0] << 8));
                                              signed long int extlen = (signed long int)((signed int)p[(signed long int)3] + ((signed int)p[(signed long int)2] << 8));
                                              p = p + (signed long int)4;
                                              n = n - (signed long int)4;
                                              if(!(n >= extlen))
                                                break;

                                              if((signed int)exttype == 0)
                                              {
                                                signed long int extn = extlen;
                                                const unsigned char *extp = p;
                                                if(!(extn >= 2l))
                                                  break;

                                                signed long int namelistlen = (signed long int)((signed int)extp[(signed long int)1] + ((signed int)extp[(signed long int)0] << 8));
                                                extp = extp + (signed long int)2;
                                                extn = extn - (signed long int)2;
                                                if(!(namelistlen == extn))
                                                  break;

                                                while(extn >= 1l)
                                                {
                                                  if(!(extn >= 3l))
                                                    goto out;

                                                  unsigned char sntype = extp[(signed long int)0];
                                                  signed long int snlen = (signed long int)((signed int)extp[(signed long int)2] + ((signed int)extp[(signed long int)1] << 8));
                                                  extp = extp + (signed long int)3;
                                                  extn = extn - (signed long int)3;
                                                  if(!(extn >= snlen))
                                                    goto out;

                                                  if(snlen >= 256l)
                                                    goto out;

                                                  if((signed int)sntype == 0)
                                                  {
                                                    void *return_value_malloc_1;
                                                    return_value_malloc_1=malloc((unsigned long int)(snlen + (signed long int)1));
                                                    servername = (char *)return_value_malloc_1;
                                                    memcpy((void *)servername, (const void *)extp, (unsigned long int)snlen);
                                                    servername[snlen] = (char)0;
                                                    goto out;
                                                  }

                                                  extp = extp + snlen;
                                                  extn = extn - snlen;
                                                }
                                              }

                                              p = p + extlen;
                                              n = n - extlen;
                                            }
                                          }

                                        }

                                      }

                                    }

                                  }

                                }

                              }

                            }

                          }

                        }

                      }

                    }
                  }

                }
              }

          }
        }

    }


out:
  ;
  return servername;
}

// ssl_tmp_dh_callback
// file ssl.h line 119
struct dh_st * ssl_tmp_dh_callback(struct ssl_st *s, signed int is_export, signed int keylength)
{
  struct dh_st *dh;
  dh=DH_new();
  _Bool tmp_if_expr_1;
  if(dh == ((struct dh_st *)NULL))
  {
    log_err_printf("DH_new() failed\n");
    return (struct dh_st *)(void *)0;
  }

  else
  {
    switch(keylength)
    {
      case 512:
      {
        dh->p=BN_bin2bn(dh512_p, (signed int)sizeof(unsigned char [64l]) /*64ul*/ , (struct bignum_st *)(void *)0);
        break;
      }
      case 1024:
      {
        dh->p=BN_bin2bn(dh1024_p, (signed int)sizeof(unsigned char [128l]) /*128ul*/ , (struct bignum_st *)(void *)0);
        break;
      }
      case 2048:
      {
        dh->p=BN_bin2bn(dh2048_p, (signed int)sizeof(unsigned char [256l]) /*256ul*/ , (struct bignum_st *)(void *)0);
        break;
      }
      case 4096:
      {
        dh->p=BN_bin2bn(dh4096_p, (signed int)sizeof(unsigned char [512l]) /*512ul*/ , (struct bignum_st *)(void *)0);
        break;
      }
      default:
      {
        log_err_printf("Unhandled DH keylength %i%s\n", keylength, is_export != 0 ? " (export)" : "");
        DH_free(dh);
        return (struct dh_st *)(void *)0;
      }
    }
    dh->g=BN_bin2bn(dh_g, (signed int)sizeof(unsigned char [1l]) /*1ul*/ , (struct bignum_st *)(void *)0);
    if(dh->p == ((struct bignum_st *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(dh->g != ((struct bignum_st *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      log_err_printf("Failed to load DH p and g from memory\n");
      DH_free(dh);
      return (struct dh_st *)(void *)0;
    }

    else
      return dh;
  }
}

// ssl_wildcardify
// file ssl.h line 169
char * ssl_wildcardify(const char *hostname)
{
  char *dot;
  char *wildcarded;
  unsigned long int dotsz;
  dot=strchr(hostname, 46);
  char *return_value_strdup_1;
  if(dot == ((char *)NULL))
  {
    return_value_strdup_1=strdup("*");
    return return_value_strdup_1;
  }

  else
  {
    dotsz=strlen(dot);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(dotsz + (unsigned long int)2);
    wildcarded = (char *)return_value_malloc_2;
    if(wildcarded == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      wildcarded[(signed long int)0] = (char)42;
      strncpy(wildcarded + (signed long int)1, dot, dotsz);
      wildcarded[(signed long int)(dotsz + (unsigned long int)1)] = (char)0;
      return wildcarded;
    }
  }
}

// ssl_x509_aias
// file ssl.c line 1389
char ** ssl_x509_aias(struct x509_st *crt, const signed int type)
{
  struct stack_st_ACCESS_DESCRIPTION *aias;
  char **res;
  signed int count;
  signed int i;
  signed int j;
  void *return_value_X509_get_ext_d2i_1;
  return_value_X509_get_ext_d2i_1=X509_get_ext_d2i(crt, 177, (signed int *)(void *)0, (signed int *)(void *)0);
  aias = (struct stack_st_ACCESS_DESCRIPTION *)return_value_X509_get_ext_d2i_1;
  _Bool tmp_if_expr_2;
  if(aias == ((struct stack_st_ACCESS_DESCRIPTION *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    count=sk_num((struct stack_st *)(1 != 0 ? aias : (struct stack_st_ACCESS_DESCRIPTION *)0));
    tmp_if_expr_2 = !(count != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_OBJ_obj2nid_5;
  if(tmp_if_expr_2)
    return (char **)(void *)0;

  else
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)(count + 1) * sizeof(char *) /*8ul*/ );
    res = (char **)return_value_malloc_3;
    if(res == ((char **)NULL))
    {
      sk_pop_free((struct stack_st *)(1 != 0 ? aias : (struct stack_st_ACCESS_DESCRIPTION *)0), (void (*)(void *))(1 != 0 ? ACCESS_DESCRIPTION_free : (void (*)(struct ACCESS_DESCRIPTION_st *))0));
      return (char **)(void *)0;
    }

    else
    {
      i = 0;
      j = 0;
      for( ; !(i >= count); i = i + 1)
      {
        struct ACCESS_DESCRIPTION_st *aia;
        void *return_value_sk_value_4;
        return_value_sk_value_4=sk_value((struct stack_st *)(1 != 0 ? aias : (struct stack_st_ACCESS_DESCRIPTION *)0), i);
        aia = (struct ACCESS_DESCRIPTION_st *)return_value_sk_value_4;
        if(!(aia == ((struct ACCESS_DESCRIPTION_st *)NULL)))
        {
          return_value_OBJ_obj2nid_5=OBJ_obj2nid(aia->method);
          if(return_value_OBJ_obj2nid_5 == type)
          {
            if(aia->location->type == 6)
            {
              res[(signed long int)j]=ssl_ia5string_strdup(aia->location->d.ia5);
              if(!(res[(signed long int)j] == ((char *)NULL)))
                j = j + 1;

            }

          }

        }

      }
      res[(signed long int)j] = (char *)(void *)0;
      sk_pop_free((struct stack_st *)(1 != 0 ? aias : (struct stack_st_ACCESS_DESCRIPTION *)0), (void (*)(void *))(1 != 0 ? ACCESS_DESCRIPTION_free : (void (*)(struct ACCESS_DESCRIPTION_st *))0));
      return res;
    }
  }
}

// ssl_x509_fingerprint_sha1
// file ssl.h line 144
signed int ssl_x509_fingerprint_sha1(struct x509_st *crt, unsigned char *fpr)
{
  unsigned int sz = (unsigned int)20;
  const struct env_md_st *return_value_EVP_sha1_1;
  return_value_EVP_sha1_1=EVP_sha1();
  signed int return_value_X509_digest_2;
  return_value_X509_digest_2=X509_digest(crt, return_value_EVP_sha1_1, fpr, &sz);
  return return_value_X509_digest_2 != 0 ? 0 : -1;
}

// ssl_x509_forge
// file ssl.h line 138
struct x509_st * ssl_x509_forge(struct x509_st *cacrt, struct evp_pkey_st *cakey, struct x509_st *origcrt, const char *extraname, struct evp_pkey_st *key)
{
  struct X509_name_st *subject;
  struct X509_name_st *issuer;
  struct stack_st_GENERAL_NAME *names;
  struct GENERAL_NAME_st *gn;
  struct x509_st *crt;
  subject=X509_get_subject_name(origcrt);
  issuer=X509_get_subject_name(cacrt);
  _Bool tmp_if_expr_3;
  signed int return_value_X509_set_subject_name_2;
  _Bool tmp_if_expr_5;
  signed int return_value_X509_set_issuer_name_4;
  _Bool tmp_if_expr_7;
  signed int return_value_ssl_x509_serial_copyrand_6;
  _Bool tmp_if_expr_9;
  struct asn1_string_st *return_value_X509_gmtime_adj_8;
  _Bool tmp_if_expr_11;
  struct asn1_string_st *return_value_X509_gmtime_adj_10;
  _Bool tmp_if_expr_13;
  signed int return_value_X509_set_pubkey_12;
  struct v3_ext_ctx ctx;
  signed int return_value_ssl_x509_v3ext_add_14;
  _Bool tmp_if_expr_16;
  signed int return_value_ssl_x509_v3ext_add_15;
  _Bool tmp_if_expr_18;
  signed int return_value_ssl_x509_v3ext_add_17;
  _Bool tmp_if_expr_20;
  signed int return_value_ssl_x509_v3ext_add_19;
  _Bool tmp_if_expr_22;
  signed int return_value_ssl_x509_v3ext_add_21;
  const struct env_md_st *md;
  signed int return_value_EVP_PKEY_type_30;
  signed int return_value_X509_sign_31;
  if(issuer == ((struct X509_name_st *)NULL) || subject == ((struct X509_name_st *)NULL))
    return (struct x509_st *)(void *)0;

  else
  {
    crt=X509_new();
    if(crt == ((struct x509_st *)NULL))
      return (struct x509_st *)(void *)0;

    else
    {
      signed int return_value_X509_set_version_1;
      return_value_X509_set_version_1=X509_set_version(crt, (signed long int)0x02);
      if(return_value_X509_set_version_1 == 0)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_X509_set_subject_name_2=X509_set_subject_name(crt, subject);
        tmp_if_expr_3 = !(return_value_X509_set_subject_name_2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_X509_set_issuer_name_4=X509_set_issuer_name(crt, issuer);
        tmp_if_expr_5 = !(return_value_X509_set_issuer_name_4 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_ssl_x509_serial_copyrand_6=ssl_x509_serial_copyrand(crt, origcrt);
        tmp_if_expr_7 = return_value_ssl_x509_serial_copyrand_6 == -1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        return_value_X509_gmtime_adj_8=X509_gmtime_adj(crt->cert_info->validity->notBefore, (signed long int)-60 * (signed long int)60 * (signed long int)24);
        tmp_if_expr_9 = !(return_value_X509_gmtime_adj_8 != ((struct asn1_string_st *)NULL)) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_X509_gmtime_adj_10=X509_gmtime_adj(crt->cert_info->validity->notAfter, (signed long int)60 * (signed long int)60 * (signed long int)24 * (signed long int)364);
        tmp_if_expr_11 = !(return_value_X509_gmtime_adj_10 != ((struct asn1_string_st *)NULL)) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        return_value_X509_set_pubkey_12=X509_set_pubkey(crt, key);
        tmp_if_expr_13 = !(return_value_X509_set_pubkey_12 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_13)
      {
        X509V3_set_ctx(&ctx, cacrt, crt, (struct X509_req_st *)(void *)0, (struct X509_crl_st *)(void *)0, 0);
        return_value_ssl_x509_v3ext_add_14=ssl_x509_v3ext_add(&ctx, crt, "basicConstraints", "CA:FALSE");
        if(return_value_ssl_x509_v3ext_add_14 == -1)
          tmp_if_expr_16 = (_Bool)1;

        else
        {
          return_value_ssl_x509_v3ext_add_15=ssl_x509_v3ext_add(&ctx, crt, "keyUsage", "digitalSignature,keyEncipherment");
          tmp_if_expr_16 = return_value_ssl_x509_v3ext_add_15 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_16)
          tmp_if_expr_18 = (_Bool)1;

        else
        {
          return_value_ssl_x509_v3ext_add_17=ssl_x509_v3ext_add(&ctx, crt, "extendedKeyUsage", "serverAuth");
          tmp_if_expr_18 = return_value_ssl_x509_v3ext_add_17 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_18)
          tmp_if_expr_20 = (_Bool)1;

        else
        {
          return_value_ssl_x509_v3ext_add_19=ssl_x509_v3ext_add(&ctx, crt, "subjectKeyIdentifier", "hash");
          tmp_if_expr_20 = return_value_ssl_x509_v3ext_add_19 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_20)
          tmp_if_expr_22 = (_Bool)1;

        else
        {
          return_value_ssl_x509_v3ext_add_21=ssl_x509_v3ext_add(&ctx, crt, "authorityKeyIdentifier", "keyid,issuer:always");
          tmp_if_expr_22 = return_value_ssl_x509_v3ext_add_21 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr_22)
        {
          if(extraname == ((const char *)NULL))
          {
            signed int return_value_ssl_x509_v3ext_copy_by_nid_23;
            return_value_ssl_x509_v3ext_copy_by_nid_23=ssl_x509_v3ext_copy_by_nid(crt, origcrt, 85);
            if(return_value_ssl_x509_v3ext_copy_by_nid_23 == -1)
              goto errout;

          }

          else
          {
            void *return_value_X509_get_ext_d2i_24;
            return_value_X509_get_ext_d2i_24=X509_get_ext_d2i(origcrt, 85, ((signed int *)NULL), ((signed int *)NULL));
            names = (struct stack_st_GENERAL_NAME *)return_value_X509_get_ext_d2i_24;
            if(names == ((struct stack_st_GENERAL_NAME *)NULL))
            {
              char *cfval;
              signed int return_value_asprintf_25;
              return_value_asprintf_25=asprintf(&cfval, "DNS:%s", extraname);
              if(!(return_value_asprintf_25 >= 0))
                goto errout;

              signed int return_value_ssl_x509_v3ext_add_26;
              return_value_ssl_x509_v3ext_add_26=ssl_x509_v3ext_add(&ctx, crt, "subjectAltName", cfval);
              if(return_value_ssl_x509_v3ext_add_26 == -1)
              {
                free((void *)cfval);
                goto errout;
              }

              free((void *)cfval);
            }

            else
            {
              gn=GENERAL_NAME_new();
              if(gn == ((struct GENERAL_NAME_st *)NULL))
                goto errout2;

              gn->type = 2;
              struct asn1_string_st *return_value_ASN1_STRING_type_new_27;
              return_value_ASN1_STRING_type_new_27=ASN1_STRING_type_new(22);
              gn->d.dNSName = (struct asn1_string_st *)return_value_ASN1_STRING_type_new_27;
              if(gn->d.dNSName == ((struct asn1_string_st *)NULL))
                goto errout3;

              unsigned long int return_value_strlen_28;
              return_value_strlen_28=strlen(extraname);
              ASN1_STRING_set(gn->d.dNSName, (const void *)(unsigned char *)extraname, (signed int)return_value_strlen_28);
              sk_push((struct stack_st *)(1 != 0 ? names : (struct stack_st_GENERAL_NAME *)0), (void *)(1 != 0 ? gn : (struct GENERAL_NAME_st *)0));
              struct X509_extension_st *ext;
              ext=X509V3_EXT_i2d(85, 0, (void *)names);
              signed int return_value_X509_add_ext_29;
              return_value_X509_add_ext_29=X509_add_ext(crt, ext, -1);
              if(return_value_X509_add_ext_29 == 0)
              {
                if(!(ext == ((struct X509_extension_st *)NULL)))
                  X509_EXTENSION_free(ext);

                goto errout3;
              }

              X509_EXTENSION_free(ext);
              sk_pop_free((struct stack_st *)(1 != 0 ? names : (struct stack_st_GENERAL_NAME *)0), (void (*)(void *))(1 != 0 ? GENERAL_NAME_free : (void (*)(struct GENERAL_NAME_st *))0));
            }
          }
          return_value_EVP_PKEY_type_30=EVP_PKEY_type(cakey->type);
          switch(return_value_EVP_PKEY_type_30)
          {
            case 6:
            {
              md=EVP_sha1();
              break;
            }
            case 116:
            {
              md=EVP_dss1();
              break;
            }
            case 408:
            {
              md=EVP_ecdsa();
              break;
            }
            default:
              goto errout;
          }
          return_value_X509_sign_31=X509_sign(crt, cakey, md);
          if(!(return_value_X509_sign_31 == 0))
          {
            return crt;

          errout3:
            ;
            GENERAL_NAME_free(gn);

          errout2:
            ;
            sk_pop_free((struct stack_st *)(1 != 0 ? names : (struct stack_st_GENERAL_NAME *)0), (void (*)(void *))(1 != 0 ? GENERAL_NAME_free : (void (*)(struct GENERAL_NAME_st *))0));
          }

        }

      }


    errout:
      ;
      X509_free(crt);
      return (struct x509_st *)(void *)0;
    }
  }
}

// ssl_x509_is_valid
// file ssl.h line 150
signed int ssl_x509_is_valid(struct x509_st *crt)
{
  signed int return_value_X509_cmp_current_time_1;
  return_value_X509_cmp_current_time_1=X509_cmp_current_time(crt->cert_info->validity->notAfter);
  if(!(return_value_X509_cmp_current_time_1 >= 1))
    return 0;

  else
  {
    signed int return_value_X509_cmp_current_time_2;
    return_value_X509_cmp_current_time_2=X509_cmp_current_time(crt->cert_info->validity->notBefore);
    if(return_value_X509_cmp_current_time_2 >= 1)
      return 0;

    else
      return 1;
  }
}

// ssl_x509_load
// file ssl.h line 140
struct x509_st * ssl_x509_load(const char *filename)
{
  struct x509_st *crt = (struct x509_st *)(void *)0;
  struct ssl_ctx_st *tmpctx;
  struct ssl_st *tmpssl;
  signed int rv;
  signed int return_value_ssl_init_1;
  return_value_ssl_init_1=ssl_init();
  if(return_value_ssl_init_1 == -1)
    return (struct x509_st *)(void *)0;

  else
  {
    const struct ssl_method_st *return_value_SSLv23_server_method_2;
    return_value_SSLv23_server_method_2=SSLv23_server_method();
    tmpctx=SSL_CTX_new(return_value_SSLv23_server_method_2);
    if(!(tmpctx == ((struct ssl_ctx_st *)NULL)))
    {
      rv=SSL_CTX_use_certificate_file(tmpctx, filename, 1);
      if(rv == 1)
      {
        tmpssl=SSL_new(tmpctx);
        if(!(tmpssl == ((struct ssl_st *)NULL)))
        {
          crt=SSL_get_certificate(tmpssl);
          if(!(crt == ((struct x509_st *)NULL)))
            ssl_x509_refcount_inc(crt);

          SSL_free(tmpssl);
        }

      }


    leave2:
      ;
      SSL_CTX_free(tmpctx);
    }


  leave1:
    ;
    return crt;
  }
}

// ssl_x509_names
// file ssl.h line 145
char ** ssl_x509_names(struct x509_st *crt)
{
  struct stack_st_GENERAL_NAME *altnames;
  char *cn;
  unsigned long int cnsz;
  char **res;
  char **p;
  unsigned long int count;
  cn=ssl_x509_subject_cn(crt, &cnsz);
  void *return_value_X509_get_ext_d2i_1;
  return_value_X509_get_ext_d2i_1=X509_get_ext_d2i(crt, 85, (signed int *)(void *)0, (signed int *)(void *)0);
  altnames = (struct stack_st_GENERAL_NAME *)return_value_X509_get_ext_d2i_1;
  signed int tmp_if_expr_3;
  signed int return_value_sk_num_2;
  if(!(altnames == ((struct stack_st_GENERAL_NAME *)NULL)))
  {
    return_value_sk_num_2=sk_num((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0));
    tmp_if_expr_3 = return_value_sk_num_2;
  }

  else
    tmp_if_expr_3 = 0;
  count = (unsigned long int)(tmp_if_expr_3 + (cn != ((char *)NULL) ? 2 : 1));
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(count * sizeof(char *) /*8ul*/ );
  res = (char **)return_value_malloc_4;
  char **tmp_post_5;
  signed int return_value_sk_num_6;
  signed int tmp_if_expr_9;
  if(res == ((char **)NULL))
    return (char **)(void *)0;

  else
  {
    p = res;
    if(!(cn == ((char *)NULL)))
    {
      tmp_post_5 = p;
      p = p + 1l;
      *tmp_post_5 = cn;
    }

    if(altnames == ((struct stack_st_GENERAL_NAME *)NULL))
    {
      *p = (char *)(void *)0;
      return res;
    }

    else
    {
      signed int i = 0;
      do
      {
        return_value_sk_num_6=sk_num((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0));
        if(i >= return_value_sk_num_6)
          break;

        struct GENERAL_NAME_st *gn;
        void *return_value_sk_value_7;
        return_value_sk_value_7=sk_value((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0), i);
        gn = (struct GENERAL_NAME_st *)return_value_sk_value_7;
        if(gn->type == 2)
        {
          unsigned char *altname;
          signed int altnamesz;
          ASN1_STRING_to_UTF8(&altname, gn->d.dNSName);
          if(altname == ((unsigned char *)NULL))
            break;

          altnamesz=ASN1_STRING_length(gn->d.dNSName);
          if(!(altnamesz >= 0))
          {
            CRYPTO_free((void *)(char *)altname);
            break;
          }

          void *return_value_malloc_8;
          return_value_malloc_8=malloc((unsigned long int)(altnamesz + 1));
          *p = (char *)return_value_malloc_8;
          if(*p == ((char *)NULL))
          {
            CRYPTO_free((void *)(char *)altname);
            GENERAL_NAMES_free(altnames);
            p = res;
            for( ; !(*p == ((char *)NULL)); p = p + 1l)
              free((void *)*p);
            free((void *)res);
            return (char **)(void *)0;
          }

          signed int j = 0;
          for( ; !(j >= altnamesz); j = j + 1)
          {
            if(!(altname[(signed long int)j] == 0))
              tmp_if_expr_9 = (signed int)altname[(signed long int)j];

            else
              tmp_if_expr_9 = 33;
            (*p)[(signed long int)j] = (char)tmp_if_expr_9;
          }
          (*p)[(signed long int)altnamesz] = (char)0;
          CRYPTO_free((void *)(char *)altname);
          p = p + 1l;
        }

        i = i + 1;
      }
      while((_Bool)1);
      *p = (char *)(void *)0;
      GENERAL_NAMES_free(altnames);
      return res;
    }
  }
}

// ssl_x509_names_match
// file ssl.h line 146
signed int ssl_x509_names_match(struct x509_st *crt, const char *dnsname)
{
  struct stack_st_GENERAL_NAME *altnames;
  char *cn;
  unsigned long int cnsz;
  unsigned long int dnsnamesz;
  dnsnamesz=strlen(dnsname);
  cn=ssl_x509_subject_cn(crt, &cnsz);
  signed int return_value_ssl_dnsname_match_1;
  signed int return_value_sk_num_3;
  if(!(cn == ((char *)NULL)))
  {
    return_value_ssl_dnsname_match_1=ssl_dnsname_match(cn, cnsz, dnsname, dnsnamesz);
    if(return_value_ssl_dnsname_match_1 == 0)
      goto __CPROVER_DUMP_L1;

    free((void *)cn);
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(cn == ((char *)NULL)))
      free((void *)cn);

    void *return_value_X509_get_ext_d2i_2;
    return_value_X509_get_ext_d2i_2=X509_get_ext_d2i(crt, 85, ((signed int *)NULL), ((signed int *)NULL));
    altnames = (struct stack_st_GENERAL_NAME *)return_value_X509_get_ext_d2i_2;
    if(altnames == ((struct stack_st_GENERAL_NAME *)NULL))
      return 0;

    else
    {
      signed int i = 0;
      do
      {
        return_value_sk_num_3=sk_num((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0));
        if(i >= return_value_sk_num_3)
          break;

        struct GENERAL_NAME_st *gn;
        void *return_value_sk_value_4;
        return_value_sk_value_4=sk_value((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0), i);
        gn = (struct GENERAL_NAME_st *)return_value_sk_value_4;
        if(gn->type == 2)
        {
          unsigned char *altname;
          signed int altnamesz;
          ASN1_STRING_to_UTF8(&altname, gn->d.dNSName);
          altnamesz=ASN1_STRING_length(gn->d.dNSName);
          if(!(altnamesz >= 0))
            break;

          signed int return_value_ssl_dnsname_match_5;
          return_value_ssl_dnsname_match_5=ssl_dnsname_match((char *)altname, (unsigned long int)altnamesz, dnsname, dnsnamesz);
          if(!(return_value_ssl_dnsname_match_5 == 0))
          {
            CRYPTO_free((void *)(char *)altname);
            GENERAL_NAMES_free(altnames);
            return 1;
          }

          CRYPTO_free((void *)(char *)altname);
        }

        i = i + 1;
      }
      while((_Bool)1);
      GENERAL_NAMES_free(altnames);
      return 0;
    }
  }
}

// ssl_x509_names_to_str
// file ssl.h line 147
char * ssl_x509_names_to_str(struct x509_st *crt)
{
  char **names;
  unsigned long int sz;
  char *buf = (char *)(void *)0;
  char *next;
  names=ssl_x509_names(crt);
  void *return_value_malloc_2;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  if(names == ((char **)NULL))
    return (char *)(void *)0;

  else
  {
    sz = (unsigned long int)0;
    char **ssl_x509_names_to_str__1__1__p = names;
    for( ; !(*ssl_x509_names_to_str__1__1__p == ((char *)NULL)); ssl_x509_names_to_str__1__1__p = ssl_x509_names_to_str__1__1__p + 1l)
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(*ssl_x509_names_to_str__1__1__p);
      sz = sz + return_value_strlen_1 + (unsigned long int)1;
    }
    if(!(sz == 0ul))
    {
      return_value_malloc_2=malloc(sz);
      buf = (char *)return_value_malloc_2;
      if(!(buf == ((char *)NULL)))
      {
        next = buf;
        char **ssl_x509_names_to_str__1__3__p = names;
        for( ; !(*ssl_x509_names_to_str__1__3__p == ((char *)NULL)); ssl_x509_names_to_str__1__3__p = ssl_x509_names_to_str__1__3__p + 1l)
        {
          char *src = *ssl_x509_names_to_str__1__3__p;
          for( ; !(*src == 0); *tmp_post_3 = *tmp_post_4)
          {
            tmp_post_3 = next;
            next = next + 1l;
            tmp_post_4 = src;
            src = src + 1l;
          }
          tmp_post_5 = next;
          next = next + 1l;
          *tmp_post_5 = (char)47;
        }
        next = next - 1l;
        *next = (char)0;
      }


    out2:
      ;
      char **p = names;
      for( ; !(*p == ((char *)NULL)); p = p + 1l)
        free((void *)*p);
    }


  out1:
    ;
    free((void *)names);
    return buf;
  }
}

// ssl_x509_ocsps
// file ssl.c line 1428
char ** ssl_x509_ocsps(struct x509_st *crt)
{
  char **return_value_ssl_x509_aias_1;
  return_value_ssl_x509_aias_1=ssl_x509_aias(crt, 178);
  return return_value_ssl_x509_aias_1;
}

// ssl_x509_refcount_inc
// file ssl.h line 153
void ssl_x509_refcount_inc(struct x509_st *crt)
{
  CRYPTO_add_lock(&crt->references, 1, 3, "ssl.c", 1129);
}

// ssl_x509_serial_copyrand
// file ssl.c line 693
signed int ssl_x509_serial_copyrand(struct x509_st *dstcrt, struct x509_st *srccrt)
{
  struct asn1_string_st *srcptr;
  struct asn1_string_st *dstptr;
  struct bignum_st *bnserial;
  unsigned int rand;
  signed int rv;
  rv=ssl_rand((void *)&rand, sizeof(unsigned int) /*4ul*/ );
  dstptr=X509_get_serialNumber(dstcrt);
  srcptr=X509_get_serialNumber(srccrt);
  if(dstptr == ((struct asn1_string_st *)NULL) || srcptr == ((struct asn1_string_st *)NULL) || rv == -1)
    return -1;

  else
  {
    bnserial=ASN1_INTEGER_to_BN(srcptr, (struct bignum_st *)(void *)0);
    if(bnserial == ((struct bignum_st *)NULL))
      ASN1_INTEGER_set(dstptr, (signed long int)rand);

    else
    {
      BN_add_word(bnserial, (unsigned long int)rand);
      BN_to_ASN1_INTEGER(bnserial, dstptr);
      BN_free(bnserial);
    }
    return 0;
  }
}

// ssl_x509_subject
// file ssl.h line 141
char * ssl_x509_subject(struct x509_st *crt)
{
  struct X509_name_st *return_value_X509_get_subject_name_1;
  return_value_X509_get_subject_name_1=X509_get_subject_name(crt);
  char *return_value_X509_NAME_oneline_2;
  return_value_X509_NAME_oneline_2=X509_NAME_oneline(return_value_X509_get_subject_name_1, (char *)(void *)0, 0);
  return return_value_X509_NAME_oneline_2;
}

// ssl_x509_subject_cn
// file ssl.c line 1057
char * ssl_x509_subject_cn(struct x509_st *crt, unsigned long int *psz)
{
  struct X509_name_st *ptr;
  char *cn;
  unsigned long int sz;
  ptr=X509_get_subject_name(crt);
  _Bool tmp_if_expr_3;
  void *return_value_malloc_2;
  if(ptr == ((struct X509_name_st *)NULL))
    return (char *)(void *)0;

  else
  {
    signed int return_value_X509_NAME_get_text_by_NID_1;
    return_value_X509_NAME_get_text_by_NID_1=X509_NAME_get_text_by_NID(ptr, 13, (char *)(void *)0, 0);
    sz = (unsigned long int)(return_value_X509_NAME_get_text_by_NID_1 + 1);
    if(sz == 0ul)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_malloc_2=malloc(sz);
      cn = (char *)return_value_malloc_2;
      tmp_if_expr_3 = !(cn != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return (char *)(void *)0;

    else
    {
      signed int return_value_X509_NAME_get_text_by_NID_4;
      return_value_X509_NAME_get_text_by_NID_4=X509_NAME_get_text_by_NID(ptr, 13, cn, (signed int)sz);
      if(return_value_X509_NAME_get_text_by_NID_4 == -1)
      {
        free((void *)cn);
        return (char *)(void *)0;
      }

      else
      {
        *psz = sz;
        return cn;
      }
    }
  }
}

// ssl_x509_to_pem
// file ssl.c line 1480
char * ssl_x509_to_pem(struct x509_st *crt)
{
  struct bio_st *bio;
  char *p;
  char *ret;
  unsigned long int sz;
  struct bio_method_st *return_value_BIO_s_mem_1;
  return_value_BIO_s_mem_1=BIO_s_mem();
  bio=BIO_new(return_value_BIO_s_mem_1);
  if(bio == ((struct bio_st *)NULL))
    return (char *)(void *)0;

  else
  {
    PEM_write_bio_X509(bio, crt);
    signed long int return_value_BIO_ctrl_2;
    return_value_BIO_ctrl_2=BIO_ctrl(bio, 3, (signed long int)0, (void *)(char *)&p);
    sz = (unsigned long int)return_value_BIO_ctrl_2;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sz + (unsigned long int)1);
    ret = (char *)return_value_malloc_3;
    if(ret == ((char *)NULL))
    {
      BIO_free(bio);
      return (char *)(void *)0;
    }

    else
    {
      memcpy((void *)ret, (const void *)p, sz);
      ret[(signed long int)sz] = (char)0;
      BIO_free(bio);
      return ret;
    }
  }
}

// ssl_x509_to_str
// file ssl.c line 1453
char * ssl_x509_to_str(struct x509_st *crt)
{
  struct bio_st *bio;
  char *p;
  char *ret;
  unsigned long int sz;
  struct bio_method_st *return_value_BIO_s_mem_1;
  return_value_BIO_s_mem_1=BIO_s_mem();
  bio=BIO_new(return_value_BIO_s_mem_1);
  if(bio == ((struct bio_st *)NULL))
    return (char *)(void *)0;

  else
  {
    X509_print(bio, crt);
    signed long int return_value_BIO_ctrl_2;
    return_value_BIO_ctrl_2=BIO_ctrl(bio, 3, (signed long int)0, (void *)(char *)&p);
    sz = (unsigned long int)return_value_BIO_ctrl_2;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sz + (unsigned long int)1);
    ret = (char *)return_value_malloc_3;
    if(ret == ((char *)NULL))
    {
      BIO_free(bio);
      return (char *)(void *)0;
    }

    else
    {
      memcpy((void *)ret, (const void *)p, sz);
      ret[(signed long int)sz] = (char)0;
      BIO_free(bio);
      return ret;
    }
  }
}

// ssl_x509_v3ext_add
// file ssl.c line 626
signed int ssl_x509_v3ext_add(struct v3_ext_ctx *ctx, struct x509_st *crt, char *k, char *v)
{
  struct X509_extension_st *ext;
  ext=X509V3_EXT_conf((struct lhash_st_CONF_VALUE *)(void *)0, ctx, k, v);
  if(ext == ((struct X509_extension_st *)NULL))
    return -1;

  else
  {
    signed int return_value_X509_add_ext_1;
    return_value_X509_add_ext_1=X509_add_ext(crt, ext, -1);
    if(!(return_value_X509_add_ext_1 == 1))
    {
      X509_EXTENSION_free(ext);
      return -1;
    }

    else
    {
      X509_EXTENSION_free(ext);
      return 0;
    }
  }
}

// ssl_x509_v3ext_copy_by_nid
// file ssl.c line 648
signed int ssl_x509_v3ext_copy_by_nid(struct x509_st *crt, struct x509_st *origcrt, signed int nid)
{
  struct X509_extension_st *ext;
  signed int pos;
  pos=X509_get_ext_by_NID(origcrt, nid, -1);
  if(pos == -1)
    return 0;

  else
  {
    ext=X509_get_ext(origcrt, pos);
    if(ext == ((struct X509_extension_st *)NULL))
      return -1;

    else
    {
      signed int return_value_X509_add_ext_1;
      return_value_X509_add_ext_1=X509_add_ext(crt, ext, -1);
      if(!(return_value_X509_add_ext_1 == 1))
        return -1;

      else
        return 1;
    }
  }
}

// ssl_x509chain_load
// file ssl.h line 155
signed int ssl_x509chain_load(struct x509_st **crt, struct stack_st_X509 **chain, const char *filename)
{
  struct x509_st *tmpcrt;
  struct ssl_ctx_st *tmpctx;
  struct ssl_st *tmpssl;
  struct stack_st_X509 *tmpchain;
  signed int rv;
  signed int return_value_ssl_init_1;
  return_value_ssl_init_1=ssl_init();
  signed long int return_value_SSL_CTX_ctrl_4;
  signed int return_value_sk_num_5;
  if(return_value_ssl_init_1 == -1)
    return -1;

  else
  {
    const struct ssl_method_st *return_value_SSLv23_server_method_2;
    return_value_SSLv23_server_method_2=SSLv23_server_method();
    tmpctx=SSL_CTX_new(return_value_SSLv23_server_method_2);
    if(!(tmpctx == ((struct ssl_ctx_st *)NULL)))
    {
      rv=SSL_CTX_use_certificate_chain_file(tmpctx, filename);
      if(rv == 1)
      {
        tmpssl=SSL_new(tmpctx);
        if(!(tmpssl == ((struct ssl_st *)NULL)))
        {
          tmpcrt=SSL_get_certificate(tmpssl);
          if(!(tmpcrt == ((struct x509_st *)NULL)))
          {
            if(*chain == ((struct stack_st_X509 *)NULL))
            {
              struct stack_st *return_value_sk_new_null_3;
              return_value_sk_new_null_3=sk_new_null();
              *chain = (struct stack_st_X509 *)return_value_sk_new_null_3;
              if(*chain == ((struct stack_st_X509 *)NULL))
                goto leave3;

            }

            return_value_SSL_CTX_ctrl_4=SSL_CTX_ctrl(tmpctx, 115, (signed long int)0, (void *)&tmpchain);
            rv = (signed int)return_value_SSL_CTX_ctrl_4;
            if(rv == 1)
            {
              if(!(crt == ((struct x509_st **)NULL)))
                *crt = tmpcrt;

              else
                sk_push((struct stack_st *)*chain, (void *)(1 != 0 ? tmpcrt : (struct x509_st *)0));
              ssl_x509_refcount_inc(tmpcrt);
              signed int i = 0;
              do
              {
                return_value_sk_num_5=sk_num((struct stack_st *)(1 != 0 ? tmpchain : (struct stack_st_X509 *)0));
                if(i >= return_value_sk_num_5)
                  break;

                void *return_value_sk_value_6;
                return_value_sk_value_6=sk_value((struct stack_st *)(1 != 0 ? tmpchain : (struct stack_st_X509 *)0), i);
                tmpcrt = (struct x509_st *)return_value_sk_value_6;
                ssl_x509_refcount_inc(tmpcrt);
                sk_push((struct stack_st *)*chain, (void *)(1 != 0 ? tmpcrt : (struct x509_st *)0));
                i = i + 1;
              }
              while((_Bool)1);
              SSL_free(tmpssl);
              SSL_CTX_free(tmpctx);
              return 0;
            }

          }


        leave3:
          ;
          SSL_free(tmpssl);
        }

      }


    leave2:
      ;
      SSL_CTX_free(tmpctx);
    }


  leave1:
    ;
    return -1;
  }
}

// ssl_x509chain_use
// file ssl.c line 939
void ssl_x509chain_use(struct ssl_ctx_st *sslctx, struct x509_st *crt, struct stack_st_X509 *chain)
{
  SSL_CTX_use_certificate(sslctx, crt);
  signed int i = 0;
  signed int return_value_sk_num_1;
  do
  {
    return_value_sk_num_1=sk_num((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0));
    if(i >= return_value_sk_num_1)
      break;

    struct x509_st *tmpcrt;
    void *return_value_sk_value_2;
    return_value_sk_value_2=sk_value((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0), i);
    tmpcrt = (struct x509_st *)return_value_sk_value_2;
    ssl_x509_refcount_inc(tmpcrt);
    sk_push((struct stack_st *)sslctx->extra_certs, (void *)(1 != 0 ? tmpcrt : (struct x509_st *)0));
    SSL_CTX_ctrl(sslctx, 14, (signed long int)0, (void *)(char *)tmpcrt);
    i = i + 1;
  }
  while((_Bool)1);
}

// sys_dir_eachfile
// file sys.c line 437
signed int sys_dir_eachfile(const char *dirname, void (*cb)(const char *, void *), void *arg)
{
  struct anonymous_21 *tree;
  struct _ftsent *node;
  char *paths[2l];
  paths[(signed long int)1] = (char *)(void *)0;
  paths[(signed long int)0]=strdup(dirname);
  _Bool tmp_if_expr_3;
  if(paths[0l] == ((char *)NULL))
    return -1;

  else
  {
    tree=fts_open(paths, 0x0004 | 0x0002, (signed int (*)(const struct _ftsent **, const struct _ftsent **))(void *)0);
    if(tree == ((struct anonymous_21 *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_err_printf("Cannot open directory '%s': %s\n", dirname, return_value_strerror_2);
      return -1;
    }

    do
    {
      node=fts_read(tree);
      if(node == ((struct _ftsent *)NULL))
        break;

      if((signed int)node->fts_level >= 1)
        tmp_if_expr_3 = (signed int)node->fts_name[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        fts_set(tree, node, 4);

      else
        if(!((8 & (signed int)node->fts_info) == 0))
          cb(node->fts_path, arg);

    }
    while((_Bool)1);
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    if(!(*return_value___errno_location_6 == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_err_printf("Error reading directory entry: %s\n", return_value_strerror_5);
      return -1;
    }

    fts_close(tree);
    free((void *)paths[(signed long int)0]);
    return 0;
  }
}

// sys_get_cpu_cores
// file sys.c line 477
unsigned int sys_get_cpu_cores(void)
{
  signed long int return_value_sysconf_1;
  return_value_sysconf_1=sysconf(84);
  return (unsigned int)return_value_sysconf_1;
}

// sys_group_str
// file sys.c line 258
char * sys_group_str(unsigned int gid)
{
  static signed int bufsize = 0;
  if(bufsize == 0)
  {
    signed long int return_value_sysconf_1;
    return_value_sysconf_1=sysconf(69);
    bufsize = (signed int)return_value_sysconf_1;
    if(bufsize == -1)
      bufsize = 64;

  }

  char *buf;
  char *newbuf;
  struct group grp;
  struct group *result = (struct group *)(void *)0;
  signed int rv;
  char *name;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)bufsize);
  buf = (char *)return_value_malloc_2;
  if(buf == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      rv=getgrgid_r(gid, &grp, buf, (unsigned long int)bufsize, &result);
      if(rv == 0)
      {
        if(!(result == ((struct group *)NULL)))
        {
          name=strdup(grp.gr_name);
          free((void *)buf);
          return name;
        }

        free((void *)buf);
        signed int return_value_asprintf_3;
        return_value_asprintf_3=asprintf(&name, "%llu", (signed long long int)gid);
        if(!(return_value_asprintf_3 >= 0))
          return (char *)(void *)0;

        return name;
      }

      bufsize = bufsize * 2;
      void *return_value_realloc_4;
      return_value_realloc_4=realloc((void *)buf, (unsigned long int)bufsize);
      newbuf = (char *)return_value_realloc_4;
      if(newbuf == ((char *)NULL))
      {
        free((void *)buf);
        return (char *)(void *)0;
      }

      buf = newbuf;
    }
    while(rv == 34);
    free((void *)buf);
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(rv);
    log_err_printf("Failed to lookup gid: %s (%i)\n", return_value_strerror_5, rv);
    return (char *)(void *)0;
  }
}

// sys_isdir
// file sys.c line 372
signed int sys_isdir(const char *path)
{
  struct stat s;
  signed int return_value_stat_1;
  return_value_stat_1=stat(path, &s);
  if(return_value_stat_1 == -1)
    return 0;

  else
    if(!((16384u & s.st_mode) == 0u))
      return 1;

    else
      return 0;
}

// sys_mkpath
// file sys.c line 389
signed int sys_mkpath(const char *path, unsigned int mode)
{
  signed long int sys_mkpath_array_size0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(path);
  sys_mkpath_array_size0 = (signed long int)(return_value_strlen_1 + (unsigned long int)1);
  char parent[sys_mkpath_array_size0];
  char *p;
  memcpy((void *)parent, (const void *)path, (unsigned long int)sys_mkpath_array_size0);
  p = parent;

__CPROVER_DUMP_L1:
  ;
  while((_Bool)1)
  {
    if((signed int)*p == 47)
    {
      p = p + 1l;
      goto __CPROVER_DUMP_L1;
    }

    p=strchr(p, 47);
    if(!(p == ((char *)NULL)))
      *p = (char)0;

    struct stat sbuf;
    signed int return_value_stat_5;
    return_value_stat_5=stat(parent, &sbuf);
    if(return_value_stat_5 == -1)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      if(*return_value___errno_location_3 == 2)
      {
        signed int return_value_mkdir_2;
        return_value_mkdir_2=mkdir(parent, mode);
        if(!(return_value_mkdir_2 == 0))
          return -1;

      }

      else
        return -1;
    }

    else
      if(!((61440u & sbuf.st_mode) == 16384u))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = 20;
        return -1;
      }

    if(!(p == ((char *)NULL)))
    {
      *p = (char)47;
      p = p + 1l;
    }

    if(p == ((char *)NULL))
      break;

  }
  return 0;
}

// sys_pidf_close
// file sys.c line 194
void sys_pidf_close(signed int fd, const char *fn)
{
  unlink(fn);
  close(fd);
}

// sys_pidf_open
// file sys.c line 149
signed int sys_pidf_open(const char *fn)
{
  signed int fd;
  fd=open(fn, 02 | 0100, 0640);
  if(fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_err_printf("Failed to open '%s': %s\n", fn, return_value_strerror_2);
    return -1;
  }

  signed int return_value_flock_5;
  return_value_flock_5=flock(fd, 2 | 4);
  if(return_value_flock_5 == -1)
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    log_err_printf("Failed to lock '%s': %s\n", fn, return_value_strerror_4);
    close(fd);
    return -1;
  }

  return fd;
}

// sys_pidf_write
// file sys.c line 173
signed int sys_pidf_write(signed int fd)
{
  char pidbuf[(signed long int)(sizeof(signed int) * 4) /*16l*/ ];
  signed int rv;
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  rv=snprintf(pidbuf, sizeof(char [16l]) /*16ul*/ , "%d\n", return_value_getpid_1);
  if(rv == -1 || rv >= (signed int)sizeof(char [16l]) /*16*/ )
    return -1;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(pidbuf);
    write(fd, (const void *)pidbuf, return_value_strlen_2);
    fsync(fd);
    signed int return_value_fcntl_3;
    return_value_fcntl_3=fcntl(fd, 1);
    fcntl(fd, 2, return_value_fcntl_3 | 1);
    return 0;
  }
}

// sys_privdrop
// file sys.c line 72
signed int sys_privdrop(const char *username, const char *groupname, const char *jaildir)
{
  struct passwd *pw = (struct passwd *)(void *)0;
  struct group *gr = (struct group *)(void *)0;
  signed int ret = -1;
  if(!(groupname == ((const char *)NULL)))
  {
    gr=getgrnam(groupname);
    if(gr == ((struct group *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_err_printf("Failed to getgrnam group '%s': %s\n", groupname, return_value_strerror_2);
      goto error;
    }

  }

  if(!(username == ((const char *)NULL)))
  {
    pw=getpwnam(username);
    if(pw == ((struct passwd *)NULL))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      log_err_printf("Failed to getpwnam user '%s': %s\n", username, return_value_strerror_4);
      goto error;
    }

    if(!(gr == ((struct group *)NULL)))
      pw->pw_gid = gr->gr_gid;

    signed int return_value_initgroups_7;
    return_value_initgroups_7=initgroups(username, pw->pw_gid);
    if(return_value_initgroups_7 == -1)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      log_err_printf("Failed to initgroups user '%s': %s\n", username, return_value_strerror_6);
      goto error;
    }

  }

  if(!(jaildir == ((const char *)NULL)))
  {
    signed int return_value_chroot_10;
    return_value_chroot_10=chroot(jaildir);
    if(return_value_chroot_10 == -1)
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      char *return_value_strerror_9;
      return_value_strerror_9=strerror(*return_value___errno_location_8);
      log_err_printf("Failed to chroot to '%s': %s\n", jaildir, return_value_strerror_9);
      goto error;
    }

    signed int return_value_chdir_13;
    return_value_chdir_13=chdir("/");
    if(return_value_chdir_13 == -1)
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      log_err_printf("Failed to chdir to '/': %s\n", return_value_strerror_12);
      goto error;
    }

  }

  unsigned int return_value_getuid_24;
  unsigned int return_value_geteuid_25;
  if(!(username == ((const char *)NULL)))
  {
    signed int return_value_setgid_16;
    return_value_setgid_16=setgid(pw->pw_gid);
    if(return_value_setgid_16 == -1)
    {
      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      char *return_value_strerror_15;
      return_value_strerror_15=strerror(*return_value___errno_location_14);
      log_err_printf("Failed to setgid to %i: %s\n", pw->pw_gid, return_value_strerror_15);
      goto error;
    }

    signed int return_value_setuid_19;
    return_value_setuid_19=setuid(pw->pw_uid);
    if(return_value_setuid_19 == -1)
    {
      signed int *return_value___errno_location_17;
      return_value___errno_location_17=__errno_location();
      char *return_value_strerror_18;
      return_value_strerror_18=strerror(*return_value___errno_location_17);
      log_err_printf("Failed to setuid to %i: %s\n", pw->pw_uid, return_value_strerror_18);
      goto error;
    }

  }

  else
  {
    return_value_getuid_24=getuid();
    return_value_geteuid_25=geteuid();
    if(!(return_value_getuid_24 == return_value_geteuid_25))
    {
      unsigned int return_value_getuid_22;
      return_value_getuid_22=getuid();
      signed int return_value_setuid_23;
      return_value_setuid_23=setuid(return_value_getuid_22);
      if(return_value_setuid_23 == -1)
      {
        signed int *return_value___errno_location_20;
        return_value___errno_location_20=__errno_location();
        char *return_value_strerror_21;
        return_value_strerror_21=strerror(*return_value___errno_location_20);
        log_err_printf("Failed to setuid(getuid()): %s\n", return_value_strerror_21);
        goto error;
      }

    }

  }
  ret = 0;

error:
  ;
  if(!(pw == ((struct passwd *)NULL)))
    endpwent();

  return ret;
}

// sys_sockaddr_parse
// file sys.h line 47
signed int sys_sockaddr_parse(struct sockaddr_storage *addr, unsigned int *addrlen, char *naddr, char *nport, signed int af, signed int flags)
{
  struct addrinfo hints;
  struct addrinfo *ai;
  signed int rv;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = af;
  hints.ai_socktype = 1;
  hints.ai_protocol = 6;
  hints.ai_flags = 0x0020 | flags;
  rv=evutil_getaddrinfo(naddr, nport, &hints, &ai);
  if(!(rv == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(rv);
    log_err_printf("Cannot resolve address '%s' port '%s': %s\n", naddr, nport, return_value_gai_strerror_1);
    return -1;
  }

  memcpy((void *)addr, (const void *)ai->ai_addr, (unsigned long int)ai->ai_addrlen);
  *addrlen = ai->ai_addrlen;
  af = ai->ai_family;
  freeaddrinfo(ai);
  return af;
}

// sys_sockaddr_str
// file sys.c line 342
char * sys_sockaddr_str(struct sockaddr *addr, unsigned int addrlen)
{
  char host[46l];
  char serv[6l];
  char *buf;
  signed int rv;
  unsigned long int bufsz = sizeof(char [46l]) /*46ul*/  + sizeof(char [6l]) /*6ul*/  + (unsigned long int)3;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(bufsz);
  buf = (char *)return_value_malloc_1;
  if(buf == ((char *)NULL))
  {
    log_err_printf("Cannot allocate memory\n");
    return (char *)(void *)0;
  }

  else
  {
    rv=getnameinfo(addr, addrlen, host, (unsigned int)sizeof(char [46l]) /*46ul*/ , serv, (unsigned int)sizeof(char [6l]) /*6ul*/ , 1 | 2);
    if(!(rv == 0))
    {
      const char *return_value_gai_strerror_2;
      return_value_gai_strerror_2=gai_strerror(rv);
      log_err_printf("Cannot get nameinfo for socket address: %s\n", return_value_gai_strerror_2);
      free((void *)buf);
      return (char *)(void *)0;
    }

    snprintf(buf, bufsz, "[%s]:%s", (const void *)host, (const void *)serv);
    return buf;
  }
}

// sys_user_str
// file sys.c line 205
char * sys_user_str(unsigned int uid)
{
  static signed int bufsize = 0;
  if(bufsize == 0)
  {
    signed long int return_value_sysconf_1;
    return_value_sysconf_1=sysconf(70);
    bufsize = (signed int)return_value_sysconf_1;
    if(bufsize == -1)
      bufsize = 64;

  }

  char *buf;
  char *newbuf;
  struct passwd pwd;
  struct passwd *result = (struct passwd *)(void *)0;
  signed int rv;
  char *name;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)bufsize);
  buf = (char *)return_value_malloc_2;
  if(buf == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      rv=getpwuid_r(uid, &pwd, buf, (unsigned long int)bufsize, &result);
      if(rv == 0)
      {
        if(!(result == ((struct passwd *)NULL)))
        {
          name=strdup(pwd.pw_name);
          free((void *)buf);
          return name;
        }

        free((void *)buf);
        signed int return_value_asprintf_3;
        return_value_asprintf_3=asprintf(&name, "%llu", (signed long long int)uid);
        if(!(return_value_asprintf_3 >= 0))
          return (char *)(void *)0;

        return name;
      }

      bufsize = bufsize * 2;
      void *return_value_realloc_4;
      return_value_realloc_4=realloc((void *)buf, (unsigned long int)bufsize);
      newbuf = (char *)return_value_realloc_4;
      if(newbuf == ((char *)NULL))
      {
        free((void *)buf);
        return (char *)(void *)0;
      }

      buf = newbuf;
    }
    while(rv == 34);
    free((void *)buf);
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(rv);
    log_err_printf("Failed to lookup uid: %s (%i)\n", return_value_strerror_5, rv);
    return (char *)(void *)0;
  }
}

// thrqueue_dequeue
// file thrqueue.c line 158
void * thrqueue_dequeue(struct thrqueue *queue)
{
  void *item;
  pthread_mutex_lock(&queue->mutex);
  while(queue->n == 0ul)
  {
    if(queue->block_dequeue == 0u)
    {
      pthread_mutex_unlock(&queue->mutex);
      return (void *)0;
    }

    pthread_cond_wait(&queue->notempty, &queue->mutex);
  }
  unsigned long int tmp_post_1 = queue->out;
  queue->out = queue->out + 1ul;
  item = queue->data[(signed long int)tmp_post_1];
  queue->out = queue->out % queue->sz;
  queue->n = queue->n - 1ul;
  pthread_mutex_unlock(&queue->mutex);
  pthread_cond_signal(&queue->notfull);
  return item;
}

// thrqueue_dequeue_nb
// file thrqueue.c line 184
void * thrqueue_dequeue_nb(struct thrqueue *queue)
{
  void *item;
  pthread_mutex_lock(&queue->mutex);
  unsigned long int tmp_post_1;
  if(queue->n == 0ul)
  {
    pthread_mutex_unlock(&queue->mutex);
    return (void *)0;
  }

  else
  {
    tmp_post_1 = queue->out;
    queue->out = queue->out + 1ul;
    item = queue->data[(signed long int)tmp_post_1];
    queue->out = queue->out % queue->sz;
    queue->n = queue->n - 1ul;
    pthread_mutex_unlock(&queue->mutex);
    pthread_cond_signal(&queue->notfull);
    return item;
  }
}

// thrqueue_enqueue
// file thrqueue.c line 112
void * thrqueue_enqueue(struct thrqueue *queue, void *item)
{
  pthread_mutex_lock(&queue->mutex);
  while(queue->n == queue->sz)
  {
    if(queue->block_enqueue == 0u)
    {
      pthread_mutex_unlock(&queue->mutex);
      return (void *)0;
    }

    pthread_cond_wait(&queue->notfull, &queue->mutex);
  }
  unsigned long int tmp_post_1 = queue->in;
  queue->in = queue->in + 1ul;
  queue->data[(signed long int)tmp_post_1] = item;
  queue->in = queue->in % queue->sz;
  queue->n = queue->n + 1ul;
  pthread_mutex_unlock(&queue->mutex);
  pthread_cond_broadcast(&queue->notempty);
  return item;
}

// thrqueue_enqueue_nb
// file thrqueue.c line 136
void * thrqueue_enqueue_nb(struct thrqueue *queue, void *item)
{
  pthread_mutex_lock(&queue->mutex);
  unsigned long int tmp_post_1;
  if(queue->n == queue->sz)
  {
    pthread_mutex_unlock(&queue->mutex);
    return (void *)0;
  }

  else
  {
    tmp_post_1 = queue->in;
    queue->in = queue->in + 1ul;
    queue->data[(signed long int)tmp_post_1] = item;
    queue->in = queue->in % queue->sz;
    queue->n = queue->n + 1ul;
    pthread_mutex_unlock(&queue->mutex);
    pthread_cond_signal(&queue->notempty);
    return item;
  }
}

// thrqueue_free
// file thrqueue.c line 96
void thrqueue_free(struct thrqueue *queue)
{
  free((void *)queue->data);
  pthread_mutex_destroy(&queue->mutex);
  pthread_cond_destroy(&queue->notempty);
  pthread_cond_destroy(&queue->notfull);
  free((void *)queue);
}

// thrqueue_new
// file thrqueue.c line 56
struct thrqueue * thrqueue_new(unsigned long int sz)
{
  struct thrqueue *queue;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct thrqueue) /*184ul*/ );
  queue = (struct thrqueue *)return_value_malloc_1;
  void *return_value_malloc_2;
  signed int return_value_pthread_mutex_init_3;
  signed int return_value_pthread_cond_init_4;
  signed int return_value_pthread_cond_init_5;
  if(!(queue == ((struct thrqueue *)NULL)))
  {
    return_value_malloc_2=malloc(sz * sizeof(void *) /*8ul*/ );
    queue->data = (void **)return_value_malloc_2;
    if(!(queue->data == ((void **)NULL)))
    {
      return_value_pthread_mutex_init_3=pthread_mutex_init(&queue->mutex, (const union anonymous *)(void *)0);
      if(return_value_pthread_mutex_init_3 == 0)
      {
        return_value_pthread_cond_init_4=pthread_cond_init(&queue->notempty, (const union anonymous *)(void *)0);
        if(return_value_pthread_cond_init_4 == 0)
        {
          return_value_pthread_cond_init_5=pthread_cond_init(&queue->notfull, (const union anonymous *)(void *)0);
          if(return_value_pthread_cond_init_5 == 0)
          {
            queue->sz = sz;
            queue->n = (unsigned long int)0;
            queue->in = (unsigned long int)0;
            queue->out = (unsigned long int)0;
            queue->block_enqueue = (unsigned int)1;
            queue->block_dequeue = (unsigned int)1;
            return queue;
          }


        out4:
          ;
          pthread_cond_destroy(&queue->notempty);
        }


      out3:
        ;
        pthread_mutex_destroy(&queue->mutex);
      }


    out2:
      ;
      free((void *)queue->data);
    }


  out1:
    ;
    free((void *)queue);
  }


out0:
  ;
  return (struct thrqueue *)(void *)0;
}

// thrqueue_unblock_dequeue
// file thrqueue.c line 222
void thrqueue_unblock_dequeue(struct thrqueue *queue)
{
  queue->block_dequeue = (unsigned int)0;
  pthread_cond_broadcast(&queue->notempty);
  sched_yield();
}

// thrqueue_unblock_enqueue
// file thrqueue.c line 208
void thrqueue_unblock_enqueue(struct thrqueue *queue)
{
  queue->block_enqueue = (unsigned int)0;
  pthread_cond_broadcast(&queue->notfull);
  sched_yield();
}

// url_dec
// file url.h line 36
char * url_dec(const char *in, unsigned long int insz, unsigned long int *outsz)
{
  unsigned long int i;
  unsigned long int o;
  signed int hi;
  signed int lo;
  char *out;
  if(insz == 0ul)
  {
    *outsz = (unsigned long int)0;
    char *return_value_strdup_1;
    return_value_strdup_1=strdup("");
    return return_value_strdup_1;
  }

  i = (unsigned long int)0;
  o = (unsigned long int)0;
  for( ; !(i >= insz); i = i + 1ul)
    if((signed int)in[(signed long int)i] == 37)
      o = o + 1ul;

  if(!(insz >= 2ul * o))
  {
    *outsz = (unsigned long int)0;
    return (char *)(void *)0;
  }

  else
  {
    *outsz = insz - (unsigned long int)2 * o;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(*outsz + (unsigned long int)1);
    out = (char *)return_value_malloc_2;
    if(out == ((char *)NULL))
    {
      *outsz = (unsigned long int)0;
      return (char *)(void *)0;
    }

    else
    {
      i = (unsigned long int)0;
      o = (unsigned long int)0;
      for( ; !(i >= insz); o = o + 1ul)
      {
        if(!((signed int)in[(signed long int)i] == 37))
          out[(signed long int)o] = in[(signed long int)i];

        else
        {
          if(2ul + i >= insz)
            goto leave;

          static const signed int hex2dec[256l] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
          hi = hex2dec[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)1)]];
          if(hi == -1)
            goto leave;

          lo = hex2dec[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)2)]];
          if(lo == -1)
            goto leave;

          out[(signed long int)o] = (char)((hi & 0xF) << 4 | lo & 0xF);
          i = i + (unsigned long int)2;
        }
        i = i + 1ul;
      }
      out[(signed long int)*outsz] = (char)0;
      return out;

    leave:
      ;
      free((void *)out);
      return (char *)(void *)0;
    }
  }
}

// util_skipws
// file util.h line 34
char * util_skipws(const char *s)
{
  unsigned long int return_value_strspn_1;
  return_value_strspn_1=strspn(s, " \t");
  return (char *)s + (signed long int)return_value_strspn_1;
}

