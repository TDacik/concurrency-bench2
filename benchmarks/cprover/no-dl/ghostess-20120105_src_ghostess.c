// #anon_enum$ATK_LAYER_INVALID=0$ATK_LAYER_BACKGROUND=1$ATK_LAYER_CANVAS=2$ATK_LAYER_WIDGET=3$ATK_LAYER_MDI=4$ATK_LAYER_POPUP=5$ATK_LAYER_OVERLAY=6$ATK_LAYER_WINDOW=7
// file /usr/include/atk-1.0/atk/atkobject.h line 376
enum anonymous$1 { ATK_LAYER_INVALID=0, ATK_LAYER_BACKGROUND=1, ATK_LAYER_CANVAS=2, ATK_LAYER_WIDGET=3, ATK_LAYER_MDI=4, ATK_LAYER_POPUP=5, ATK_LAYER_OVERLAY=6, ATK_LAYER_WINDOW=7 };

// #anon_enum$ATK_ROLE_INVALID=0$ATK_ROLE_ACCEL_LABEL=1$ATK_ROLE_ALERT=2$ATK_ROLE_ANIMATION=3$ATK_ROLE_ARROW=4$ATK_ROLE_CALENDAR=5$ATK_ROLE_CANVAS=6$ATK_ROLE_CHECK_BOX=7$ATK_ROLE_CHECK_MENU_ITEM=8$ATK_ROLE_COLOR_CHOOSER=9$ATK_ROLE_COLUMN_HEADER=10$ATK_ROLE_COMBO_BOX=11$ATK_ROLE_DATE_EDITOR=12$ATK_ROLE_DESKTOP_ICON=13$ATK_ROLE_DESKTOP_FRAME=14$ATK_ROLE_DIAL=15$ATK_ROLE_DIALOG=16$ATK_ROLE_DIRECTORY_PANE=17$ATK_ROLE_DRAWING_AREA=18$ATK_ROLE_FILE_CHOOSER=19$ATK_ROLE_FILLER=20$ATK_ROLE_FONT_CHOOSER=21$ATK_ROLE_FRAME=22$ATK_ROLE_GLASS_PANE=23$ATK_ROLE_HTML_CONTAINER=24$ATK_ROLE_ICON=25$ATK_ROLE_IMAGE=26$ATK_ROLE_INTERNAL_FRAME=27$ATK_ROLE_LABEL=28$ATK_ROLE_LAYERED_PANE=29$ATK_ROLE_LIST=30$ATK_ROLE_LIST_ITEM=31$ATK_ROLE_MENU=32$ATK_ROLE_MENU_BAR=33$ATK_ROLE_MENU_ITEM=34$ATK_ROLE_OPTION_PANE=35$ATK_ROLE_PAGE_TAB=36$ATK_ROLE_PAGE_TAB_LIST=37$ATK_ROLE_PANEL=38$ATK_ROLE_PASSWORD_TEXT=39$ATK_ROLE_POPUP_MENU=40$ATK_ROLE_PROGRESS_BAR=41$ATK_ROLE_PUSH_BUTTON=42$ATK_ROLE_RADIO_BUTTON=43$ATK_ROLE_RADIO_MENU_ITEM=44$ATK_ROLE_ROOT_PANE=45$ATK_ROLE_ROW_HEADER=46$ATK_ROLE_SCROLL_BAR=47$ATK_ROLE_SCROLL_PANE=48$ATK_ROLE_SEPARATOR=49$ATK_ROLE_SLIDER=50$ATK_ROLE_SPLIT_PANE=51$ATK_ROLE_SPIN_BUTTON=52$ATK_ROLE_STATUSBAR=53$ATK_ROLE_TABLE=54$ATK_ROLE_TABLE_CELL=55$ATK_ROLE_TABLE_COLUMN_HEADER=56$ATK_ROLE_TABLE_ROW_HEADER=57$ATK_ROLE_TEAR_OFF_MENU_ITEM=58$ATK_ROLE_TERMINAL=59$ATK_ROLE_TEXT=60$ATK_ROLE_TOGGLE_BUTTON=61$ATK_ROLE_TOOL_BAR=62$ATK_ROLE_TOOL_TIP=63$ATK_ROLE_TREE=64$ATK_ROLE_TREE_TABLE=65$ATK_ROLE_UNKNOWN=66$ATK_ROLE_VIEWPORT=67$ATK_ROLE_WINDOW=68$ATK_ROLE_HEADER=69$ATK_ROLE_FOOTER=70$ATK_ROLE_PARAGRAPH=71$ATK_ROLE_RULER=72$ATK_ROLE_APPLICATION=73$ATK_ROLE_AUTOCOMPLETE=74$ATK_ROLE_EDITBAR=75$ATK_ROLE_EMBEDDED=76$ATK_ROLE_ENTRY=77$ATK_ROLE_CHART=78$ATK_ROLE_CAPTION=79$ATK_ROLE_DOCUMENT_FRAME=80$ATK_ROLE_HEADING=81$ATK_ROLE_PAGE=82$ATK_ROLE_SECTION=83$ATK_ROLE_REDUNDANT_OBJECT=84$ATK_ROLE_FORM=85$ATK_ROLE_LINK=86$ATK_ROLE_INPUT_METHOD_WINDOW=87$ATK_ROLE_TABLE_ROW=88$ATK_ROLE_TREE_ITEM=89$ATK_ROLE_DOCUMENT_SPREADSHEET=90$ATK_ROLE_DOCUMENT_PRESENTATION=91$ATK_ROLE_DOCUMENT_TEXT=92$ATK_ROLE_DOCUMENT_WEB=93$ATK_ROLE_DOCUMENT_EMAIL=94$ATK_ROLE_COMMENT=95$ATK_ROLE_LIST_BOX=96$ATK_ROLE_GROUPING=97$ATK_ROLE_IMAGE_MAP=98$ATK_ROLE_NOTIFICATION=99$ATK_ROLE_INFO_BAR=100$ATK_ROLE_LEVEL_BAR=101$ATK_ROLE_TITLE_BAR=102$ATK_ROLE_BLOCK_QUOTE=103$ATK_ROLE_AUDIO=104$ATK_ROLE_VIDEO=105$ATK_ROLE_DEFINITION=106$ATK_ROLE_ARTICLE=107$ATK_ROLE_LANDMARK=108$ATK_ROLE_LOG=109$ATK_ROLE_MARQUEE=110$ATK_ROLE_MATH=111$ATK_ROLE_RATING=112$ATK_ROLE_TIMER=113$ATK_ROLE_DESCRIPTION_LIST=114$ATK_ROLE_DESCRIPTION_TERM=115$ATK_ROLE_DESCRIPTION_VALUE=116$ATK_ROLE_STATIC=117$ATK_ROLE_MATH_FRACTION=118$ATK_ROLE_MATH_ROOT=119$ATK_ROLE_SUBSCRIPT=120$ATK_ROLE_SUPERSCRIPT=121$ATK_ROLE_LAST_DEFINED=122
// file /usr/include/atk-1.0/atk/atkobject.h line 232
enum anonymous$0 { ATK_ROLE_INVALID=0, ATK_ROLE_ACCEL_LABEL=1, ATK_ROLE_ALERT=2, ATK_ROLE_ANIMATION=3, ATK_ROLE_ARROW=4, ATK_ROLE_CALENDAR=5, ATK_ROLE_CANVAS=6, ATK_ROLE_CHECK_BOX=7, ATK_ROLE_CHECK_MENU_ITEM=8, ATK_ROLE_COLOR_CHOOSER=9, ATK_ROLE_COLUMN_HEADER=10, ATK_ROLE_COMBO_BOX=11, ATK_ROLE_DATE_EDITOR=12, ATK_ROLE_DESKTOP_ICON=13, ATK_ROLE_DESKTOP_FRAME=14, ATK_ROLE_DIAL=15, ATK_ROLE_DIALOG=16, ATK_ROLE_DIRECTORY_PANE=17, ATK_ROLE_DRAWING_AREA=18, ATK_ROLE_FILE_CHOOSER=19, ATK_ROLE_FILLER=20, ATK_ROLE_FONT_CHOOSER=21, ATK_ROLE_FRAME=22, ATK_ROLE_GLASS_PANE=23, ATK_ROLE_HTML_CONTAINER=24, ATK_ROLE_ICON=25, ATK_ROLE_IMAGE=26, ATK_ROLE_INTERNAL_FRAME=27, ATK_ROLE_LABEL=28, ATK_ROLE_LAYERED_PANE=29, ATK_ROLE_LIST=30, ATK_ROLE_LIST_ITEM=31, ATK_ROLE_MENU=32, ATK_ROLE_MENU_BAR=33, ATK_ROLE_MENU_ITEM=34, ATK_ROLE_OPTION_PANE=35, ATK_ROLE_PAGE_TAB=36, ATK_ROLE_PAGE_TAB_LIST=37, ATK_ROLE_PANEL=38, ATK_ROLE_PASSWORD_TEXT=39, ATK_ROLE_POPUP_MENU=40, ATK_ROLE_PROGRESS_BAR=41, ATK_ROLE_PUSH_BUTTON=42, ATK_ROLE_RADIO_BUTTON=43, ATK_ROLE_RADIO_MENU_ITEM=44, ATK_ROLE_ROOT_PANE=45, ATK_ROLE_ROW_HEADER=46, ATK_ROLE_SCROLL_BAR=47, ATK_ROLE_SCROLL_PANE=48, ATK_ROLE_SEPARATOR=49, ATK_ROLE_SLIDER=50, ATK_ROLE_SPLIT_PANE=51, ATK_ROLE_SPIN_BUTTON=52, ATK_ROLE_STATUSBAR=53, ATK_ROLE_TABLE=54, ATK_ROLE_TABLE_CELL=55, ATK_ROLE_TABLE_COLUMN_HEADER=56, ATK_ROLE_TABLE_ROW_HEADER=57, ATK_ROLE_TEAR_OFF_MENU_ITEM=58, ATK_ROLE_TERMINAL=59, ATK_ROLE_TEXT=60, ATK_ROLE_TOGGLE_BUTTON=61, ATK_ROLE_TOOL_BAR=62, ATK_ROLE_TOOL_TIP=63, ATK_ROLE_TREE=64, ATK_ROLE_TREE_TABLE=65, ATK_ROLE_UNKNOWN=66, ATK_ROLE_VIEWPORT=67, ATK_ROLE_WINDOW=68, ATK_ROLE_HEADER=69, ATK_ROLE_FOOTER=70, ATK_ROLE_PARAGRAPH=71, ATK_ROLE_RULER=72, ATK_ROLE_APPLICATION=73, ATK_ROLE_AUTOCOMPLETE=74, ATK_ROLE_EDITBAR=75, ATK_ROLE_EMBEDDED=76, ATK_ROLE_ENTRY=77, ATK_ROLE_CHART=78, ATK_ROLE_CAPTION=79, ATK_ROLE_DOCUMENT_FRAME=80, ATK_ROLE_HEADING=81, ATK_ROLE_PAGE=82, ATK_ROLE_SECTION=83, ATK_ROLE_REDUNDANT_OBJECT=84, ATK_ROLE_FORM=85, ATK_ROLE_LINK=86, ATK_ROLE_INPUT_METHOD_WINDOW=87, ATK_ROLE_TABLE_ROW=88, ATK_ROLE_TREE_ITEM=89, ATK_ROLE_DOCUMENT_SPREADSHEET=90, ATK_ROLE_DOCUMENT_PRESENTATION=91, ATK_ROLE_DOCUMENT_TEXT=92, ATK_ROLE_DOCUMENT_WEB=93, ATK_ROLE_DOCUMENT_EMAIL=94, ATK_ROLE_COMMENT=95, ATK_ROLE_LIST_BOX=96, ATK_ROLE_GROUPING=97, ATK_ROLE_IMAGE_MAP=98, ATK_ROLE_NOTIFICATION=99, ATK_ROLE_INFO_BAR=100, ATK_ROLE_LEVEL_BAR=101, ATK_ROLE_TITLE_BAR=102, ATK_ROLE_BLOCK_QUOTE=103, ATK_ROLE_AUDIO=104, ATK_ROLE_VIDEO=105, ATK_ROLE_DEFINITION=106, ATK_ROLE_ARTICLE=107, ATK_ROLE_LANDMARK=108, ATK_ROLE_LOG=109, ATK_ROLE_MARQUEE=110, ATK_ROLE_MATH=111, ATK_ROLE_RATING=112, ATK_ROLE_TIMER=113, ATK_ROLE_DESCRIPTION_LIST=114, ATK_ROLE_DESCRIPTION_TERM=115, ATK_ROLE_DESCRIPTION_VALUE=116, ATK_ROLE_STATIC=117, ATK_ROLE_MATH_FRACTION=118, ATK_ROLE_MATH_ROOT=119, ATK_ROLE_SUBSCRIPT=120, ATK_ROLE_SUPERSCRIPT=121, ATK_ROLE_LAST_DEFINED=122 };

// #anon_enum$GDK_ACTION_DEFAULT=1$GDK_ACTION_COPY=2$GDK_ACTION_MOVE=4$GDK_ACTION_LINK=8$GDK_ACTION_PRIVATE=16$GDK_ACTION_ASK=32
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 40
enum anonymous$51 { GDK_ACTION_DEFAULT=1, GDK_ACTION_COPY=2, GDK_ACTION_MOVE=4, GDK_ACTION_LINK=8, GDK_ACTION_PRIVATE=16, GDK_ACTION_ASK=32 };

// #anon_enum$GDK_AXIS_IGNORE=0$GDK_AXIS_X=1$GDK_AXIS_Y=2$GDK_AXIS_PRESSURE=3$GDK_AXIS_XTILT=4$GDK_AXIS_YTILT=5$GDK_AXIS_WHEEL=6$GDK_AXIS_LAST=7
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 73
enum anonymous$30 { GDK_AXIS_IGNORE=0, GDK_AXIS_X=1, GDK_AXIS_Y=2, GDK_AXIS_PRESSURE=3, GDK_AXIS_XTILT=4, GDK_AXIS_YTILT=5, GDK_AXIS_WHEEL=6, GDK_AXIS_LAST=7 };

// #anon_enum$GDK_CROSSING_NORMAL=0$GDK_CROSSING_GRAB=1$GDK_CROSSING_UNGRAB=2$GDK_CROSSING_GTK_GRAB=3$GDK_CROSSING_GTK_UNGRAB=4$GDK_CROSSING_STATE_CHANGED=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 225
enum anonymous$36 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5 };

// #anon_enum$GDK_DRAG_PROTO_MOTIF=0$GDK_DRAG_PROTO_XDND=1$GDK_DRAG_PROTO_ROOTWIN=2$GDK_DRAG_PROTO_NONE=3$GDK_DRAG_PROTO_WIN32_DROPFILES=4$GDK_DRAG_PROTO_OLE2=5$GDK_DRAG_PROTO_LOCAL=6
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 50
enum anonymous$50 { GDK_DRAG_PROTO_MOTIF=0, GDK_DRAG_PROTO_XDND=1, GDK_DRAG_PROTO_ROOTWIN=2, GDK_DRAG_PROTO_NONE=3, GDK_DRAG_PROTO_WIN32_DROPFILES=4, GDK_DRAG_PROTO_OLE2=5, GDK_DRAG_PROTO_LOCAL=6 };

// #anon_enum$GDK_FONT_FONT=0$GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous$13 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum$GDK_INPUT_OUTPUT=0$GDK_INPUT_ONLY=1
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 54
enum anonymous$44 { GDK_INPUT_OUTPUT=0, GDK_INPUT_ONLY=1 };

// #anon_enum$GDK_LSB_FIRST=0$GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous$12 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum$GDK_MODE_DISABLED=0$GDK_MODE_SCREEN=1$GDK_MODE_WINDOW=2
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 66
enum anonymous$35 { GDK_MODE_DISABLED=0, GDK_MODE_SCREEN=1, GDK_MODE_WINDOW=2 };

// #anon_enum$GDK_NOTHING=-1$GDK_DELETE=0$GDK_DESTROY=1$GDK_EXPOSE=2$GDK_MOTION_NOTIFY=3$GDK_BUTTON_PRESS=4$GDK_2BUTTON_PRESS=5$GDK_3BUTTON_PRESS=6$GDK_BUTTON_RELEASE=7$GDK_KEY_PRESS=8$GDK_KEY_RELEASE=9$GDK_ENTER_NOTIFY=10$GDK_LEAVE_NOTIFY=11$GDK_FOCUS_CHANGE=12$GDK_CONFIGURE=13$GDK_MAP=14$GDK_UNMAP=15$GDK_PROPERTY_NOTIFY=16$GDK_SELECTION_CLEAR=17$GDK_SELECTION_REQUEST=18$GDK_SELECTION_NOTIFY=19$GDK_PROXIMITY_IN=20$GDK_PROXIMITY_OUT=21$GDK_DRAG_ENTER=22$GDK_DRAG_LEAVE=23$GDK_DRAG_MOTION=24$GDK_DRAG_STATUS=25$GDK_DROP_START=26$GDK_DROP_FINISHED=27$GDK_CLIENT_EVENT=28$GDK_VISIBILITY_NOTIFY=29$GDK_NO_EXPOSE=30$GDK_SCROLL=31$GDK_WINDOW_STATE=32$GDK_SETTING=33$GDK_OWNER_CHANGE=34$GDK_GRAB_BROKEN=35$GDK_DAMAGE=36$GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous$26 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum$GDK_NOTIFY_ANCESTOR=0$GDK_NOTIFY_VIRTUAL=1$GDK_NOTIFY_INFERIOR=2$GDK_NOTIFY_NONLINEAR=3$GDK_NOTIFY_NONLINEAR_VIRTUAL=4$GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 210
enum anonymous$33 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum$GDK_OWNER_CHANGE_NEW_OWNER=0$GDK_OWNER_CHANGE_DESTROY=1$GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 259
enum anonymous$40 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum$GDK_SCROLL_UP=0$GDK_SCROLL_DOWN=1$GDK_SCROLL_LEFT=2$GDK_SCROLL_RIGHT=3
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 194
enum anonymous$32 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3 };

// #anon_enum$GDK_SETTING_ACTION_NEW=0$GDK_SETTING_ACTION_CHANGED=1$GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 252
enum anonymous$38 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum$GDK_SHIFT_MASK=1$GDK_LOCK_MASK=2$GDK_CONTROL_MASK=4$GDK_MOD1_MASK=8$GDK_MOD2_MASK=16$GDK_MOD3_MASK=32$GDK_MOD4_MASK=64$GDK_MOD5_MASK=128$GDK_BUTTON1_MASK=256$GDK_BUTTON2_MASK=512$GDK_BUTTON3_MASK=1024$GDK_BUTTON4_MASK=2048$GDK_BUTTON5_MASK=4096$GDK_SUPER_MASK=67108864$GDK_HYPER_MASK=134217728$GDK_META_MASK=268435456$GDK_RELEASE_MASK=1073741824$GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous$23 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum$GDK_SOURCE_MOUSE=0$GDK_SOURCE_PEN=1$GDK_SOURCE_ERASER=2$GDK_SOURCE_CURSOR=3
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 58
enum anonymous$34 { GDK_SOURCE_MOUSE=0, GDK_SOURCE_PEN=1, GDK_SOURCE_ERASER=2, GDK_SOURCE_CURSOR=3 };

// #anon_enum$GDK_VISIBILITY_UNOBSCURED=0$GDK_VISIBILITY_PARTIAL=1$GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 187
enum anonymous$31 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum$GDK_VISUAL_STATIC_GRAY=0$GDK_VISUAL_GRAYSCALE=1$GDK_VISUAL_STATIC_COLOR=2$GDK_VISUAL_PSEUDO_COLOR=3$GDK_VISUAL_TRUE_COLOR=4$GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous$29 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum$GDK_WINDOW_ROOT=0$GDK_WINDOW_TOPLEVEL=1$GDK_WINDOW_CHILD=2$GDK_WINDOW_DIALOG=3$GDK_WINDOW_TEMP=4$GDK_WINDOW_FOREIGN=5$GDK_WINDOW_OFFSCREEN=6
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 73
enum anonymous$45 { GDK_WINDOW_ROOT=0, GDK_WINDOW_TOPLEVEL=1, GDK_WINDOW_CHILD=2, GDK_WINDOW_DIALOG=3, GDK_WINDOW_TEMP=4, GDK_WINDOW_FOREIGN=5, GDK_WINDOW_OFFSCREEN=6 };

// #anon_enum$GDK_WINDOW_STATE_WITHDRAWN=1$GDK_WINDOW_STATE_ICONIFIED=2$GDK_WINDOW_STATE_MAXIMIZED=4$GDK_WINDOW_STATE_STICKY=8$GDK_WINDOW_STATE_FULLSCREEN=16$GDK_WINDOW_STATE_ABOVE=32$GDK_WINDOW_STATE_BELOW=64
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 241
enum anonymous$37 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64 };

// #anon_enum$GDK_WINDOW_TYPE_HINT_NORMAL=0$GDK_WINDOW_TYPE_HINT_DIALOG=1$GDK_WINDOW_TYPE_HINT_MENU=2$GDK_WINDOW_TYPE_HINT_TOOLBAR=3$GDK_WINDOW_TYPE_HINT_SPLASHSCREEN=4$GDK_WINDOW_TYPE_HINT_UTILITY=5$GDK_WINDOW_TYPE_HINT_DOCK=6$GDK_WINDOW_TYPE_HINT_DESKTOP=7$GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU=8$GDK_WINDOW_TYPE_HINT_POPUP_MENU=9$GDK_WINDOW_TYPE_HINT_TOOLTIP=10$GDK_WINDOW_TYPE_HINT_NOTIFICATION=11$GDK_WINDOW_TYPE_HINT_COMBO=12$GDK_WINDOW_TYPE_HINT_DND=13
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 133
enum anonymous$46 { GDK_WINDOW_TYPE_HINT_NORMAL=0, GDK_WINDOW_TYPE_HINT_DIALOG=1, GDK_WINDOW_TYPE_HINT_MENU=2, GDK_WINDOW_TYPE_HINT_TOOLBAR=3, GDK_WINDOW_TYPE_HINT_SPLASHSCREEN=4, GDK_WINDOW_TYPE_HINT_UTILITY=5, GDK_WINDOW_TYPE_HINT_DOCK=6, GDK_WINDOW_TYPE_HINT_DESKTOP=7, GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU=8, GDK_WINDOW_TYPE_HINT_POPUP_MENU=9, GDK_WINDOW_TYPE_HINT_TOOLTIP=10, GDK_WINDOW_TYPE_HINT_NOTIFICATION=11, GDK_WINDOW_TYPE_HINT_COMBO=12, GDK_WINDOW_TYPE_HINT_DND=13 };

// #anon_enum$GDK_X_CURSOR=0$GDK_ARROW=2$GDK_BASED_ARROW_DOWN=4$GDK_BASED_ARROW_UP=6$GDK_BOAT=8$GDK_BOGOSITY=10$GDK_BOTTOM_LEFT_CORNER=12$GDK_BOTTOM_RIGHT_CORNER=14$GDK_BOTTOM_SIDE=16$GDK_BOTTOM_TEE=18$GDK_BOX_SPIRAL=20$GDK_CENTER_PTR=22$GDK_CIRCLE=24$GDK_CLOCK=26$GDK_COFFEE_MUG=28$GDK_CROSS=30$GDK_CROSS_REVERSE=32$GDK_CROSSHAIR=34$GDK_DIAMOND_CROSS=36$GDK_DOT=38$GDK_DOTBOX=40$GDK_DOUBLE_ARROW=42$GDK_DRAFT_LARGE=44$GDK_DRAFT_SMALL=46$GDK_DRAPED_BOX=48$GDK_EXCHANGE=50$GDK_FLEUR=52$GDK_GOBBLER=54$GDK_GUMBY=56$GDK_HAND1=58$GDK_HAND2=60$GDK_HEART=62$GDK_ICON=64$GDK_IRON_CROSS=66$GDK_LEFT_PTR=68$GDK_LEFT_SIDE=70$GDK_LEFT_TEE=72$GDK_LEFTBUTTON=74$GDK_LL_ANGLE=76$GDK_LR_ANGLE=78$GDK_MAN=80$GDK_MIDDLEBUTTON=82$GDK_MOUSE=84$GDK_PENCIL=86$GDK_PIRATE=88$GDK_PLUS=90$GDK_QUESTION_ARROW=92$GDK_RIGHT_PTR=94$GDK_RIGHT_SIDE=96$GDK_RIGHT_TEE=98$GDK_RIGHTBUTTON=100$GDK_RTL_LOGO=102$GDK_SAILBOAT=104$GDK_SB_DOWN_ARROW=106$GDK_SB_H_DOUBLE_ARROW=108$GDK_SB_LEFT_ARROW=110$GDK_SB_RIGHT_ARROW=112$GDK_SB_UP_ARROW=114$GDK_SB_V_DOUBLE_ARROW=116$GDK_SHUTTLE=118$GDK_SIZING=120$GDK_SPIDER=122$GDK_SPRAYCAN=124$GDK_STAR=126$GDK_TARGET=128$GDK_TCROSS=130$GDK_TOP_LEFT_ARROW=132$GDK_TOP_LEFT_CORNER=134$GDK_TOP_RIGHT_CORNER=136$GDK_TOP_SIDE=138$GDK_TOP_TEE=140$GDK_TREK=142$GDK_UL_ANGLE=144$GDK_UMBRELLA=146$GDK_UR_ANGLE=148$GDK_WATCH=150$GDK_XTERM=152$GDK_LAST_CURSOR=153$GDK_BLANK_CURSOR=-2$GDK_CURSOR_IS_PIXMAP=-1
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 43
enum anonymous$43 { GDK_X_CURSOR=0, GDK_ARROW=2, GDK_BASED_ARROW_DOWN=4, GDK_BASED_ARROW_UP=6, GDK_BOAT=8, GDK_BOGOSITY=10, GDK_BOTTOM_LEFT_CORNER=12, GDK_BOTTOM_RIGHT_CORNER=14, GDK_BOTTOM_SIDE=16, GDK_BOTTOM_TEE=18, GDK_BOX_SPIRAL=20, GDK_CENTER_PTR=22, GDK_CIRCLE=24, GDK_CLOCK=26, GDK_COFFEE_MUG=28, GDK_CROSS=30, GDK_CROSS_REVERSE=32, GDK_CROSSHAIR=34, GDK_DIAMOND_CROSS=36, GDK_DOT=38, GDK_DOTBOX=40, GDK_DOUBLE_ARROW=42, GDK_DRAFT_LARGE=44, GDK_DRAFT_SMALL=46, GDK_DRAPED_BOX=48, GDK_EXCHANGE=50, GDK_FLEUR=52, GDK_GOBBLER=54, GDK_GUMBY=56, GDK_HAND1=58, GDK_HAND2=60, GDK_HEART=62, GDK_ICON=64, GDK_IRON_CROSS=66, GDK_LEFT_PTR=68, GDK_LEFT_SIDE=70, GDK_LEFT_TEE=72, GDK_LEFTBUTTON=74, GDK_LL_ANGLE=76, GDK_LR_ANGLE=78, GDK_MAN=80, GDK_MIDDLEBUTTON=82, GDK_MOUSE=84, GDK_PENCIL=86, GDK_PIRATE=88, GDK_PLUS=90, GDK_QUESTION_ARROW=92, GDK_RIGHT_PTR=94, GDK_RIGHT_SIDE=96, GDK_RIGHT_TEE=98, GDK_RIGHTBUTTON=100, GDK_RTL_LOGO=102, GDK_SAILBOAT=104, GDK_SB_DOWN_ARROW=106, GDK_SB_H_DOUBLE_ARROW=108, GDK_SB_LEFT_ARROW=110, GDK_SB_RIGHT_ARROW=112, GDK_SB_UP_ARROW=114, GDK_SB_V_DOUBLE_ARROW=116, GDK_SHUTTLE=118, GDK_SIZING=120, GDK_SPIDER=122, GDK_SPRAYCAN=124, GDK_STAR=126, GDK_TARGET=128, GDK_TCROSS=130, GDK_TOP_LEFT_ARROW=132, GDK_TOP_LEFT_CORNER=134, GDK_TOP_RIGHT_CORNER=136, GDK_TOP_SIDE=138, GDK_TOP_TEE=140, GDK_TREK=142, GDK_UL_ANGLE=144, GDK_UMBRELLA=146, GDK_UR_ANGLE=148, GDK_WATCH=150, GDK_XTERM=152, GDK_LAST_CURSOR=153, GDK_BLANK_CURSOR=-2, GDK_CURSOR_IS_PIXMAP=-1 };

// #anon_enum$GTK_ACCEL_VISIBLE=1$GTK_ACCEL_LOCKED=2$GTK_ACCEL_MASK=7
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 51
enum anonymous$24 { GTK_ACCEL_VISIBLE=1, GTK_ACCEL_LOCKED=2, GTK_ACCEL_MASK=7 };

// #anon_enum$GTK_DIR_TAB_FORWARD=0$GTK_DIR_TAB_BACKWARD=1$GTK_DIR_UP=2$GTK_DIR_DOWN=3$GTK_DIR_LEFT=4$GTK_DIR_RIGHT=5
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 122
enum anonymous$47 { GTK_DIR_TAB_FORWARD=0, GTK_DIR_TAB_BACKWARD=1, GTK_DIR_UP=2, GTK_DIR_DOWN=3, GTK_DIR_LEFT=4, GTK_DIR_RIGHT=5 };

// #anon_enum$GTK_JUSTIFY_LEFT=0$GTK_JUSTIFY_RIGHT=1$GTK_JUSTIFY_CENTER=2$GTK_JUSTIFY_FILL=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 181
enum anonymous$20 { GTK_JUSTIFY_LEFT=0, GTK_JUSTIFY_RIGHT=1, GTK_JUSTIFY_CENTER=2, GTK_JUSTIFY_FILL=3 };

// #anon_enum$GTK_ORIENTATION_HORIZONTAL=0$GTK_ORIENTATION_VERTICAL=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 262
enum anonymous$4 { GTK_ORIENTATION_HORIZONTAL=0, GTK_ORIENTATION_VERTICAL=1 };

// #anon_enum$GTK_POLICY_ALWAYS=0$GTK_POLICY_AUTOMATIC=1$GTK_POLICY_NEVER=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 305
enum anonymous$5 { GTK_POLICY_ALWAYS=0, GTK_POLICY_AUTOMATIC=1, GTK_POLICY_NEVER=2 };

// #anon_enum$GTK_RC_FG=1$GTK_RC_BG=2$GTK_RC_TEXT=4$GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous$14 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum$GTK_SHADOW_NONE=0$GTK_SHADOW_IN=1$GTK_SHADOW_OUT=2$GTK_SHADOW_ETCHED_IN=3$GTK_SHADOW_ETCHED_OUT=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 389
enum anonymous$11 { GTK_SHADOW_NONE=0, GTK_SHADOW_IN=1, GTK_SHADOW_OUT=2, GTK_SHADOW_ETCHED_IN=3, GTK_SHADOW_ETCHED_OUT=4 };

// #anon_enum$GTK_STATE_NORMAL=0$GTK_STATE_ACTIVE=1$GTK_STATE_PRELIGHT=2$GTK_STATE_SELECTED=3$GTK_STATE_INSENSITIVE=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 399
enum anonymous$49 { GTK_STATE_NORMAL=0, GTK_STATE_ACTIVE=1, GTK_STATE_PRELIGHT=2, GTK_STATE_SELECTED=3, GTK_STATE_INSENSITIVE=4 };

// #anon_enum$GTK_TEXT_DIR_NONE=0$GTK_TEXT_DIR_LTR=1$GTK_TEXT_DIR_RTL=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 173
enum anonymous$48 { GTK_TEXT_DIR_NONE=0, GTK_TEXT_DIR_LTR=1, GTK_TEXT_DIR_RTL=2 };

// #anon_enum$GTK_UPDATE_CONTINUOUS=0$GTK_UPDATE_DISCONTINUOUS=1$GTK_UPDATE_DELAYED=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 434
enum anonymous$3 { GTK_UPDATE_CONTINUOUS=0, GTK_UPDATE_DISCONTINUOUS=1, GTK_UPDATE_DELAYED=2 };

// #anon_enum$GTK_WIDGET_HELP_TOOLTIP=0$GTK_WIDGET_HELP_WHATS_THIS=1
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 127
enum anonymous$42 { GTK_WIDGET_HELP_TOOLTIP=0, GTK_WIDGET_HELP_WHATS_THIS=1 };

// #anon_enum$GTK_WINDOW_TOPLEVEL=0$GTK_WINDOW_POPUP=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 460
enum anonymous$16 { GTK_WINDOW_TOPLEVEL=0, GTK_WINDOW_POPUP=1 };

// #anon_enum$GTK_WIN_POS_NONE=0$GTK_WIN_POS_CENTER=1$GTK_WIN_POS_MOUSE=2$GTK_WIN_POS_CENTER_ALWAYS=3$GTK_WIN_POS_CENTER_ON_PARENT=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 450
enum anonymous$17 { GTK_WIN_POS_NONE=0, GTK_WIN_POS_CENTER=1, GTK_WIN_POS_MOUSE=2, GTK_WIN_POS_CENTER_ALWAYS=3, GTK_WIN_POS_CENTER_ON_PARENT=4 };

// #anon_enum$G_PARAM_READABLE=1$G_PARAM_WRITABLE=2$G_PARAM_READWRITE=3$G_PARAM_CONSTRUCT=4$G_PARAM_CONSTRUCT_ONLY=8$G_PARAM_LAX_VALIDATION=16$G_PARAM_STATIC_NAME=32$G_PARAM_PRIVATE=32$G_PARAM_STATIC_NICK=64$G_PARAM_STATIC_BLURB=128$G_PARAM_EXPLICIT_NOTIFY=1073741824$G_PARAM_DEPRECATED=-2147483648
// file /usr/include/glib-2.0/gobject/gparam.h line 150
enum anonymous$28 { G_PARAM_READABLE=1, G_PARAM_WRITABLE=2, G_PARAM_READWRITE=3, G_PARAM_CONSTRUCT=4, G_PARAM_CONSTRUCT_ONLY=8, G_PARAM_LAX_VALIDATION=16, G_PARAM_STATIC_NAME=32, G_PARAM_PRIVATE=32, G_PARAM_STATIC_NICK=64, G_PARAM_STATIC_BLURB=128, G_PARAM_EXPLICIT_NOTIFY=1073741824, G_PARAM_DEPRECATED=-2147483648 };

// #anon_enum$G_SIGNAL_MATCH_ID=1$G_SIGNAL_MATCH_DETAIL=2$G_SIGNAL_MATCH_CLOSURE=4$G_SIGNAL_MATCH_FUNC=8$G_SIGNAL_MATCH_DATA=16$G_SIGNAL_MATCH_UNBLOCKED=32
// file /usr/include/glib-2.0/gobject/gsignal.h line 173
enum anonymous$9 { G_SIGNAL_MATCH_ID=1, G_SIGNAL_MATCH_DETAIL=2, G_SIGNAL_MATCH_CLOSURE=4, G_SIGNAL_MATCH_FUNC=8, G_SIGNAL_MATCH_DATA=16, G_SIGNAL_MATCH_UNBLOCKED=32 };

// #anon_enum$G_TYPE_FLAG_ABSTRACT=16$G_TYPE_FLAG_VALUE_ABSTRACT=32
// file /usr/include/glib-2.0/gobject/gtype.h line 993
enum anonymous$25 { G_TYPE_FLAG_ABSTRACT=16, G_TYPE_FLAG_VALUE_ABSTRACT=32 };

// #anon_enum$LO_INT32=105$LO_FLOAT=102$LO_STRING=115$LO_BLOB=98$LO_INT64=104$LO_TIMETAG=116$LO_DOUBLE=100$LO_SYMBOL=83$LO_CHAR=99$LO_MIDI=109$LO_TRUE=84$LO_FALSE=70$LO_NIL=78$LO_INFINITUM=73
// file /usr/include/lo/lo_osc_types.h line 72
enum anonymous$15 { LO_INT32=105, LO_FLOAT=102, LO_STRING=115, LO_BLOB=98, LO_INT64=104, LO_TIMETAG=116, LO_DOUBLE=100, LO_SYMBOL=83, LO_CHAR=99, LO_MIDI=109, LO_TRUE=84, LO_FALSE=70, LO_NIL=78, LO_INFINITUM=73 };

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}$SYM#tag-_GdkDrawable#$'toplevel_under_pointer'||*{SYM#tag-_GdkDrawable#}$SYM#tag-_GdkDrawable#$'window_under_pointer'||F64'toplevel_x'||F64'toplevel_y'||U32'state'||U32'button'||U64'motion_hint_serial'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 63
struct anonymous$22;

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}$SYM#tag-_GdkDrawable#$'window'||*{SYM#tag-_GdkDrawable#}$SYM#tag-_GdkDrawable#$'native_window'||U64'serial'||S32'owner_events'||U32'time'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 47
struct anonymous$21;

// tag-#anon#ST[*{V()->V}$V()->V$'f'||*{V}$V$'d'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 165
struct anonymous;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$18;

// tag-#anon#ST[U32'sec'||U32'frac'|]
// file /usr/include/lo/lo_osc_types.h line 46
struct anonymous$6;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 445
union anonymous$41;

// tag-#anon#UN[S32'i'||S32'i32'||S64'h'||S64'i64'||F32'f'||F32'f32'||F64'd'||F64'f64'||S8's'||S8'S'||U8'c'||ARR4{U8}$U8$'m'||SYM#tag-#anon#ST[U32'sec'||U32'frac'|]#'t'|]
// file /usr/include/lo/lo_osc_types.h line 115
union anonymous$7;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}$V$'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous$27;

// tag-#anon#UN[S32'value'||SYM#tag-snd_seq_timestamp#'time'||U32'position'||SYM#tag-snd_seq_queue_skew#'skew'||ARR2{U32}$U32$'d32'||ARR8{U8}$U8$'d8'|]
// file /usr/include/alsa/seq_event.h line 284
union anonymous$10;

// tag-#anon#UN[S8'char_data'||U8'uchar_data'||S32'bool_data'||S32'int_data'||U32'uint_data'||S64'long_data'||U64'ulong_data'||F32'float_data'||F64'double_data'||*{S8}$S8$'string_data'||*{SYM#tag-_GtkObject#}$SYM#tag-_GtkObject#$'object_data'||*{V}$V$'pointer_data'||SYM#tag-#anon#ST[*{V()->V}$V()->V$'f'||*{V}$V$'d'|]#'signal_data'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 149
union anonymous$39;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$19;

// tag-#anon#UN[SYM#tag-_argc_state#'argv'||SYM#tag-_file_state#'file'|]
// file getarg.h line 50
union anonymous$2;

// tag-#anon#UN[SYM#tag-snd_seq_ev_note#'note'||SYM#tag-snd_seq_ev_ctrl#'control'||SYM#tag-snd_seq_ev_raw8#'raw8'||SYM#tag-snd_seq_ev_raw32#'raw32'||SYM#tag-snd_seq_ev_ext#'ext'||SYM#tag-snd_seq_ev_queue_control#'queue'||SYM#tag-snd_seq_timestamp#'time'||SYM#tag-snd_seq_addr#'addr'||SYM#tag-snd_seq_connect#'connect'||SYM#tag-snd_seq_result#'result'||U128'$pad'|]
// file /usr/include/alsa/seq_event.h line 307
union anonymous$8;

// tag-JackOptions
// file /usr/include/jack/types.h line 90
enum JackOptions { JackNullOption=0, JackNoStartServer=1, JackUseExactName=2, JackServerName=4, JackLoadName=8, JackLoadInit=16, JackSessionID=32 };

// tag-JackSessionEventType
// file /usr/include/jack/session.h line 46
enum JackSessionEventType { JackSessionSave=1, JackSessionSaveAndQuit=2, JackSessionSaveTemplate=3 };

// tag-JackSessionFlags
// file /usr/include/jack/session.h line 83
enum JackSessionFlags { JackSessionSaveError=1, JackSessionNeedTerminal=2 };

// tag-JackStatus
// file /usr/include/jack/types.h line 149
enum JackStatus { JackFailure=1, JackInvalidOption=2, JackNameNotUnique=4, JackServerStarted=8, JackServerFailed=16, JackServerError=32, JackNoSuchClient=64, JackLoadFailure=128, JackInitFailure=256, JackShmFailure=512, JackVersionError=1024, JackBackendError=2048, JackClientZombie=4096 };

// tag-_AtkObject
// file /usr/include/atk-1.0/atk/atkobject.h line 440
struct _AtkObject;

// tag-_AtkRelationSet
// file /usr/include/atk-1.0/atk/atkobject.h line 442
struct _AtkRelationSet;

// tag-_Blinky
// file eyecandy.h line 38
struct _Blinky;

// tag-_BlinkyClass
// file eyecandy.h line 39
struct _BlinkyClass;

// tag-_DSSI_Descriptor
// file /usr/include/dssi.h line 77
struct _DSSI_Descriptor;

// tag-_DSSI_Program_Descriptor
// file /usr/include/dssi.h line 57
struct _DSSI_Program_Descriptor;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GObjectClass
// file /usr/include/glib-2.0/gobject/gobject.h line 188
struct _GObjectClass;

// tag-_GObjectConstructParam
// file /usr/include/glib-2.0/gobject/gobject.h line 191
struct _GObjectConstructParam;

// tag-_GParamSpec
// file /usr/include/glib-2.0/gobject/gparam.h line 193
struct _GParamSpec;

// tag-_GPtrArray
// file /usr/include/glib-2.0/glib/garray.h line 39
struct _GPtrArray;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 80
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkCursor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 104
struct _GdkCursor;

// tag-_GdkDevice
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 47
struct _GdkDevice;

// tag-_GdkDeviceAxis
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 46
struct _GdkDeviceAxis;

// tag-_GdkDeviceKey
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 45
struct _GdkDeviceKey;

// tag-_GdkDisplay
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 115
struct _GdkDisplay;

// tag-_GdkDisplayPointerHooks
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 37
struct _GdkDisplayPointerHooks;

// tag-_GdkDragContext
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 38
struct _GdkDragContext;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEvent
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 68
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 47
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 52
struct _GdkEventButton;

// tag-_GdkEventClient
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 62
struct _GdkEventClient;

// tag-_GdkEventConfigure
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 57
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 56
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 63
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 48
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 55
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 66
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 51
struct _GdkEventMotion;

// tag-_GdkEventNoExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 49
struct _GdkEventNoExpose;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 60
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 58
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 61
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 53
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 59
struct _GdkEventSelection;

// tag-_GdkEventSetting
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 65
struct _GdkEventSetting;

// tag-_GdkEventVisibility
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 50
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 64
struct _GdkEventWindowState;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkScreen
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 116
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GdkWindowAttr
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 41
struct _GdkWindowAttr;

// tag-_GtkAccelGroup
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 60
struct _GtkAccelGroup;

// tag-_GtkAccelGroupEntry
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 63
struct _GtkAccelGroupEntry;

// tag-_GtkAccelKey
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 62
struct _GtkAccelKey;

// tag-_GtkAdjustment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 48
struct _GtkAdjustment;

// tag-_GtkArg
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 48
struct _GtkArg;

// tag-_GtkBin
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 48
struct _GtkBin;

// tag-_GtkBox
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 49
struct _GtkBox;

// tag-_GtkButton
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 48
struct _GtkButton;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkDialog
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 94
struct _GtkDialog;

// tag-_GtkFileSelection
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 46
struct _GtkFileSelection;

// tag-_GtkFrame
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 49
struct _GtkFrame;

// tag-_GtkItem
// file /usr/include/gtk-2.0/gtk/gtkitem.h line 48
struct _GtkItem;

// tag-_GtkLabel
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 49
struct _GtkLabel;

// tag-_GtkLabelSelectionInfo
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 52
struct _GtkLabelSelectionInfo;

// tag-_GtkMenu
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 49
struct _GtkMenu;

// tag-_GtkMenuItem
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 48
struct _GtkMenuItem;

// tag-_GtkMenuShell
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 48
struct _GtkMenuShell;

// tag-_GtkMisc
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 48
struct _GtkMisc;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkObjectClass
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 104
struct _GtkObjectClass;

// tag-_GtkRange
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 53
struct _GtkRange;

// tag-_GtkRangeLayout
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 50
struct _GtkRangeLayout;

// tag-_GtkRangeStepTimer
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 51
struct _GtkRangeStepTimer;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 52
struct _GtkScrolledWindow;

// tag-_GtkSelectionData
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 479
struct _GtkSelectionData;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkToggleButton
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 48
struct _GtkToggleButton;

// tag-_GtkTooltip
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 484
struct _GtkTooltip;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_GtkWidgetClass
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 480
struct _GtkWidgetClass;

// tag-_GtkWindow
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 485
struct _GtkWindow;

// tag-_GtkWindowGeometryInfo
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 50
struct _GtkWindowGeometryInfo;

// tag-_GtkWindowGroup
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 51
struct _GtkWindowGroup;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_LADSPA_Descriptor
// file /usr/include/ladspa.h line 373
struct _LADSPA_Descriptor;

// tag-_LADSPA_PortRangeHint
// file /usr/include/ladspa.h line 337
struct _LADSPA_PortRangeHint;

// tag-_PangoAttrList
// file /usr/include/pango-1.0/pango/pango-attributes.h line 111
struct _PangoAttrList;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-_PangoLayout
// file /usr/include/pango-1.0/pango/pango-layout.h line 32
struct _PangoLayout;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_argc_state
// file getarg.h line 35
struct _argc_state;

// tag-_cairo_font_options
// file /usr/include/cairo/cairo.h line 1366
struct _cairo_font_options;

// tag-_configure_item_t
// file ghostess.h line 91
struct _configure_item_t;

// tag-_d3h_dll_t
// file ghostess.h line 65
struct _d3h_dll_t;

// tag-_d3h_instance_t
// file ghostess.h line 120
struct _d3h_instance_t;

// tag-_d3h_plugin_t
// file ghostess.h line 75
struct _d3h_plugin_t;

// tag-_file_state
// file getarg.h line 41
struct _file_state;

// tag-_getarg_state
// file getarg.h line 33
struct _getarg_state;

// tag-_initial_port_set_t
// file ghostess.h line 99
struct _initial_port_set_t;

// tag-_instance_template_t
// file ghostess.h line 109
struct _instance_template_t;

// tag-_jack_client
// file /usr/include/jack/types.h line 72
struct _jack_client;

// tag-_jack_port
// file /usr/include/jack/types.h line 66
struct _jack_port;

// tag-_jack_session_event
// file /usr/include/jack/session.h line 100
struct _jack_session_event;

// tag-_plugin_strip
// file ghostess.h line 63
struct _plugin_strip;

// tag-_snd_seq
// file /usr/include/alsa/seq.h line 47
struct _snd_seq;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sched_param
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 72
struct sched_param;

// tag-snd_midi_event
// file /usr/include/alsa/seq_midi_event.h line 43
struct snd_midi_event;

// tag-snd_seq_addr
// file /usr/include/alsa/seq_event.h line 178
struct snd_seq_addr;

// tag-snd_seq_connect
// file /usr/include/alsa/seq_event.h line 184
struct snd_seq_connect;

// tag-snd_seq_ev_ctrl
// file /usr/include/alsa/seq_event.h line 239
struct snd_seq_ev_ctrl;

// tag-snd_seq_ev_ext
// file /usr/include/alsa/seq_event.h line 257
struct snd_seq_ev_ext;

// tag-snd_seq_ev_note
// file /usr/include/alsa/seq_event.h line 230
struct snd_seq_ev_note;

// tag-snd_seq_ev_queue_control
// file /usr/include/alsa/seq_event.h line 281
struct snd_seq_ev_queue_control;

// tag-snd_seq_ev_raw32
// file /usr/include/alsa/seq_event.h line 252
struct snd_seq_ev_raw32;

// tag-snd_seq_ev_raw8
// file /usr/include/alsa/seq_event.h line 247
struct snd_seq_ev_raw8;

// tag-snd_seq_event
// file /usr/include/alsa/seq_event.h line 296
struct snd_seq_event;

// tag-snd_seq_queue_skew
// file /usr/include/alsa/seq_event.h line 275
struct snd_seq_queue_skew;

// tag-snd_seq_real_time
// file /usr/include/alsa/seq_event.h line 191
struct snd_seq_real_time;

// tag-snd_seq_result
// file /usr/include/alsa/seq_event.h line 269
struct snd_seq_result;

// tag-snd_seq_timestamp
// file /usr/include/alsa/seq_event.h line 200
union snd_seq_timestamp;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __atomic_load_8
// file eyecandy.c line 49 function blinky_get_type
signed int __atomic_load_8(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// add_configure_item
// file ghostess.c line 832
void add_configure_item(struct _configure_item_t **head, char *key, char *value);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// audio_callback
// file ghostess.c line 232
signed int audio_callback(unsigned int nframes, void *arg);
// blinky_class_init
// file eyecandy.c line 52
static void blinky_class_init(struct _BlinkyClass *class);
// blinky_class_intern_init
// file eyecandy.c line 49
static void blinky_class_intern_init(void *klass);
// blinky_destroy
// file eyecandy.c line 98
static void blinky_destroy(struct _GtkObject *object);
// blinky_expose
// file eyecandy.c line 194
static signed int blinky_expose(struct _GtkWidget *widget, struct _GdkEventExpose *event);
// blinky_get_state
// file eyecandy.c line 114
unsigned int blinky_get_state(struct _Blinky *blinky);
// blinky_get_type
// file eyecandy.c line 49
unsigned long int blinky_get_type(void);
// blinky_init
// file eyecandy.c line 82
static void blinky_init(struct _Blinky *blinky);
// blinky_new
// file eyecandy.c line 88
struct _GtkWidget * blinky_new(unsigned int state);
// blinky_realize
// file eyecandy.c line 134
static void blinky_realize(struct _GtkWidget *widget);
// blinky_set_state
// file eyecandy.c line 123
void blinky_set_state(struct _Blinky *blinky, unsigned int state);
// blinky_size_allocate
// file eyecandy.c line 176
static void blinky_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation);
// blinky_size_request
// file eyecandy.c line 169
static void blinky_size_request(struct _GtkWidget *widget, struct _GtkRequisition *requisition);
// blinky_update
// file eyecandy.c line 219
static void blinky_update(struct _Blinky *blinky);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// copy_configure_items
// file ghostess.c line 853
void copy_configure_items(struct _instance_template_t *temp, struct _d3h_instance_t *inst);
// copy_initial_port_set
// file ghostess.c line 737
static void copy_initial_port_set(struct _instance_template_t *temp, struct _d3h_instance_t *inst);
// create_about_window
// file gui_interface.c line 294
void create_about_window(const char *tag);
// create_file_selection
// file gui_interface.c line 256
void create_file_selection(const char *tag);
// create_main_window
// file gui_interface.c line 59
void create_main_window(const char *tag, signed int instance_count);
// create_notice_window
// file gui_interface.c line 338
void create_notice_window(const char *tag);
// create_plugin_strip
// file gui_interface.h line 56
struct _plugin_strip * create_plugin_strip(struct _GtkWidget *parent_window, struct _d3h_instance_t *instance);
// create_ui_context_menu
// file gui_interface.c line 222
void create_ui_context_menu(struct _GtkWidget *parent_window);
// create_windows
// file gui_interface.h line 58
void create_windows(const char *host_tag, signed int instance_count);
// display_notice
// file gui_callbacks.c line 324
void display_notice(char *message1, char *message2);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// escape_for_shell
// file ghostess.c line 869
void escape_for_shell(char **p, const char *text);
// execlp
// file /usr/include/unistd.h line 584
extern signed int execlp(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern float expf(float);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// file_selection_handler$object
//
void file_selection_handler$object(struct _GtkWidget *, void *);
// file_selection_set_path
// file gui_callbacks.c line 53
void file_selection_set_path(char *filename);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_instance_template
// file ghostess.c line 779
static void free_instance_template(struct _instance_template_t *t);
// free_programs
// file ghostess.c line 1312
void free_programs(struct _d3h_instance_t *instance);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// g_ascii_formatd
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 168
extern char * g_ascii_formatd(char *, signed int, const char *, double);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_idle_add
// file /usr/include/glib-2.0/glib/gmain.h line 584
extern unsigned int g_idle_add(signed int (*)(void *), void *);
// g_intern_static_string
// file /usr/include/glib-2.0/glib/gquark.h line 64
extern const char * g_intern_static_string(const char *);
// g_object_new
// file /usr/include/glib-2.0/gobject/gobject.h line 420
extern void * g_object_new(unsigned long int, const char *, ...);
// g_once_init_enter
// file /usr/include/glib-2.0/glib/gthread.h line 232
extern signed int g_once_init_enter(volatile void *);
// g_once_init_leave
// file /usr/include/glib-2.0/glib/gthread.h line 234
extern void g_once_init_leave(volatile void *, unsigned long int);
// g_return_if_fail_warning
// file /usr/include/glib-2.0/glib/gmessages.h line 124
extern void g_return_if_fail_warning(const char *, const char *, const char *);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_strtod
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 146
extern double g_strtod(const char *, char **);
// g_type_check_class_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2177
extern struct _GTypeClass * g_type_check_class_cast(struct _GTypeClass *, unsigned long int);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// g_type_check_instance_is_a
// file /usr/include/glib-2.0/gobject/gtype.h line 2171
extern signed int g_type_check_instance_is_a(struct _GTypeInstance *, unsigned long int);
// g_type_class_adjust_private_offset
// file /usr/include/glib-2.0/gobject/gtype.h line 1302
extern void g_type_class_adjust_private_offset(void *, signed int *);
// g_type_class_peek_parent
// file /usr/include/glib-2.0/gobject/gtype.h line 709
extern void * g_type_class_peek_parent(void *);
// g_type_register_static_simple
// file /usr/include/glib-2.0/gobject/gtype.h line 1259
extern unsigned long int g_type_register_static_simple(unsigned long int, const char *, unsigned int, void (*)(void *, void *), unsigned int, void (*)(struct _GTypeInstance *, void *), enum anonymous$25);
// gdk_color_alloc
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 154
signed int gdk_color_alloc(struct _GdkColormap *, struct _GdkColor *);
// gdk_colormap_get_system
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 100
struct _GdkColormap * gdk_colormap_get_system(void);
// gdk_draw_rectangle
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 285
void gdk_draw_rectangle(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, signed int, signed int, signed int);
// gdk_gc_new
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 225
struct _GdkGC * gdk_gc_new(struct _GdkDrawable *);
// gdk_gc_set_foreground
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 238
void gdk_gc_set_foreground(struct _GdkGC *, const struct _GdkColor *);
// gdk_window_clear_area
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 367
void gdk_window_clear_area(struct _GdkDrawable *, signed int, signed int, signed int, signed int);
// gdk_window_move_resize
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 357
void gdk_window_move_resize(struct _GdkDrawable *, signed int, signed int, signed int, signed int);
// gdk_window_new
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 332
struct _GdkDrawable * gdk_window_new(struct _GdkDrawable *, struct _GdkWindowAttr *, signed int);
// gdk_window_set_user_data
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 384
void gdk_window_set_user_data(struct _GdkDrawable *, void *);
// get_port_default
// file ghostess.c line 2346
float get_port_default(const struct _LADSPA_Descriptor *plugin, signed int port);
// getarg
// file getarg.h line 31
char * getarg(void);
// getarg_cleanup
// file getarg.h line 28
void getarg_cleanup(void);
// getarg_init_with_command_line
// file getarg.h line 29
void getarg_init_with_command_line(signed int argc, char **argv);
// getarg_init_with_file
// file getarg.c line 152
signed int getarg_init_with_file(char *filename);
// getarg_internal
// file getarg.c line 268
static char * getarg_internal(void);
// getarg_pop_state
// file getarg.c line 58
static void getarg_pop_state(void);
// getarg_print_possible_error
// file getarg.h line 27
void getarg_print_possible_error(void);
// getarg_push_file
// file getarg.c line 119
static signed int getarg_push_file(char *filename);
// getarg_read_file_arg
// file getarg.c line 164
static signed int getarg_read_file_arg(struct _getarg_state *state);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// ghss_debug
// file ghostess.c line 154
void ghss_debug(signed int type, const char *format, ...);
// gtk_accel_group_new
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 123
struct _GtkAccelGroup * gtk_accel_group_new(void);
// gtk_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 104
unsigned long int gtk_box_get_type(void);
// gtk_box_pack_end
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 114
void gtk_box_pack_end(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_box_pack_start
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 109
void gtk_box_pack_start(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 93
struct _GtkWidget * gtk_button_new_with_label(const char *);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_container_set_border_width
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 108
void gtk_container_set_border_width(struct _GtkContainer *, unsigned int);
// gtk_file_selection_get_filename
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 106
const char * gtk_file_selection_get_filename(struct _GtkFileSelection *);
// gtk_file_selection_get_type
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 102
unsigned long int gtk_file_selection_get_type(void);
// gtk_file_selection_new
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 103
struct _GtkWidget * gtk_file_selection_new(const char *);
// gtk_file_selection_set_filename
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 104
void gtk_file_selection_set_filename(struct _GtkFileSelection *, const char *);
// gtk_frame_get_type
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 72
unsigned long int gtk_frame_get_type(void);
// gtk_frame_new
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 73
struct _GtkWidget * gtk_frame_new(const char *);
// gtk_frame_set_shadow_type
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 88
void gtk_frame_set_shadow_type(struct _GtkFrame *, enum anonymous$11);
// gtk_hbox_new
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 63
struct _GtkWidget * gtk_hbox_new(signed int, signed int);
// gtk_init
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 94
void gtk_init(signed int *, char ***);
// gtk_label_get_type
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 109
unsigned long int gtk_label_get_type(void);
// gtk_label_new
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 110
struct _GtkWidget * gtk_label_new(const char *);
// gtk_label_set_justify
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 138
void gtk_label_set_justify(struct _GtkLabel *, enum anonymous$20);
// gtk_label_set_line_wrap
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 152
void gtk_label_set_line_wrap(struct _GtkLabel *, signed int);
// gtk_label_set_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 112
void gtk_label_set_text(struct _GtkLabel *, const char *);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_menu_bar_new
// file /usr/include/gtk-2.0/gtk/gtkmenubar.h line 69
struct _GtkWidget * gtk_menu_bar_new(void);
// gtk_menu_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 125
unsigned long int gtk_menu_get_type(void);
// gtk_menu_item_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 99
unsigned long int gtk_menu_item_get_type(void);
// gtk_menu_item_new
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 100
struct _GtkWidget * gtk_menu_item_new(void);
// gtk_menu_item_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 101
struct _GtkWidget * gtk_menu_item_new_with_label(const char *);
// gtk_menu_item_set_right_justified
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 113
void gtk_menu_item_set_right_justified(struct _GtkMenuItem *, signed int);
// gtk_menu_item_set_submenu
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 103
void gtk_menu_item_set_submenu(struct _GtkMenuItem *, struct _GtkWidget *);
// gtk_menu_new
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 126
struct _GtkWidget * gtk_menu_new(void);
// gtk_menu_popup
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 129
void gtk_menu_popup(struct _GtkMenu *, struct _GtkWidget *, struct _GtkWidget *, void (*)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *), void *, unsigned int, unsigned int);
// gtk_menu_shell_append
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 101
void gtk_menu_shell_append(struct _GtkMenuShell *, struct _GtkWidget *);
// gtk_misc_get_type
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 68
unsigned long int gtk_misc_get_type(void);
// gtk_misc_set_alignment
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 69
void gtk_misc_set_alignment(struct _GtkMisc *, float, float);
// gtk_misc_set_padding
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 75
void gtk_misc_set_padding(struct _GtkMisc *, signed int, signed int);
// gtk_object_get_type
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 146
unsigned long int gtk_object_get_type(void);
// gtk_object_set_data
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 181
void gtk_object_set_data(struct _GtkObject *, const char *, void *);
// gtk_object_set_data_full
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 184
void gtk_object_set_data_full(struct _GtkObject *, const char *, void *, void (*)(void *));
// gtk_range_get_type
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 136
unsigned long int gtk_range_get_type(void);
// gtk_range_set_update_policy
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 139
void gtk_range_set_update_policy(struct _GtkRange *, enum anonymous$3);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 102
unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_new
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 103
struct _GtkWidget * gtk_scrolled_window_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_scrolled_window_set_policy
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 113
void gtk_scrolled_window_set_policy(struct _GtkScrolledWindow *, enum anonymous$5, enum anonymous$5);
// gtk_signal_compat_matched
// file /usr/include/gtk-2.0/gtk/gtksignal.h line 141
void gtk_signal_compat_matched(struct _GtkObject *, void (*)(void), void *, enum anonymous$9, unsigned int);
// gtk_signal_connect_full
// file /usr/include/gtk-2.0/gtk/gtksignal.h line 121
unsigned long int gtk_signal_connect_full(struct _GtkObject *, const char *, void (*)(void), void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *), void *, void (*)(void *), signed int, signed int);
// gtk_style_attach
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 443
struct _GtkStyle * gtk_style_attach(struct _GtkStyle *, struct _GdkDrawable *);
// gtk_style_new
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 441
struct _GtkStyle * gtk_style_new(void);
// gtk_style_set_background
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 456
void gtk_style_set_background(struct _GtkStyle *, struct _GdkDrawable *, enum anonymous$49);
// gtk_timeout_add
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 174
unsigned int gtk_timeout_add(unsigned int, signed int (*)(void *), void *);
// gtk_timeout_callback
// file ghostess.c line 1328
signed int gtk_timeout_callback(void *data);
// gtk_timeout_remove
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 182
void gtk_timeout_remove(unsigned int);
// gtk_toggle_button_get_type
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 74
unsigned long int gtk_toggle_button_get_type(void);
// gtk_toggle_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 77
struct _GtkWidget * gtk_toggle_button_new_with_label(const char *);
// gtk_toggle_button_set_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 82
void gtk_toggle_button_set_active(struct _GtkToggleButton *, signed int);
// gtk_type_class
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 239
void * gtk_type_class(unsigned long int);
// gtk_vbox_new
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 63
struct _GtkWidget * gtk_vbox_new(signed int, signed int);
// gtk_viewport_new
// file /usr/include/gtk-2.0/gtk/gtkviewport.h line 75
struct _GtkWidget * gtk_viewport_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_widget_add_accelerator
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 892
void gtk_widget_add_accelerator(struct _GtkWidget *, const char *, struct _GtkAccelGroup *, unsigned int, enum anonymous$23, enum anonymous$24);
// gtk_widget_draw
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 883
void gtk_widget_draw(struct _GtkWidget *, const struct _GdkRectangle *);
// gtk_widget_get_colormap
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1053
struct _GdkColormap * gtk_widget_get_colormap(struct _GtkWidget *);
// gtk_widget_get_events
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1114
signed int gtk_widget_get_events(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 833
unsigned long int gtk_widget_get_type(void);
// gtk_widget_get_visual
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1054
struct _GdkVisual * gtk_widget_get_visual(struct _GtkWidget *);
// gtk_widget_hide
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 853
void gtk_widget_hide(struct _GtkWidget *);
// gtk_widget_ref
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 841
struct _GtkWidget * gtk_widget_ref(struct _GtkWidget *);
// gtk_widget_set_sensitive
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 964
void gtk_widget_set_sensitive(struct _GtkWidget *, signed int);
// gtk_widget_set_size_request
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1027
void gtk_widget_set_size_request(struct _GtkWidget *, signed int, signed int);
// gtk_widget_show
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 851
void gtk_widget_show(struct _GtkWidget *);
// gtk_widget_unref
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 842
void gtk_widget_unref(struct _GtkWidget *);
// gtk_window_add_accel_group
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 191
void gtk_window_add_accel_group(struct _GtkWindow *, struct _GtkAccelGroup *);
// gtk_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 178
unsigned long int gtk_window_get_type(void);
// gtk_window_new
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 179
struct _GtkWidget * gtk_window_new(enum anonymous$16);
// gtk_window_set_modal
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 307
void gtk_window_set_modal(struct _GtkWindow *, signed int);
// gtk_window_set_position
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 195
void gtk_window_set_position(struct _GtkWindow *, enum anonymous$17);
// gtk_window_set_title
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 180
void gtk_window_set_title(struct _GtkWindow *, const char *);
// instance_sort_cmp
// file ghostess.c line 1042
static signed int instance_sort_cmp(const void *a, const void *b);
// instance_template_set_port
// file ghostess.c line 790
static void instance_template_set_port(struct _instance_template_t *t, unsigned long int port, float value);
// jack_activate
// file /usr/include/jack/jack.h line 183
signed int jack_activate(struct _jack_client *);
// jack_client_close
// file /usr/include/jack/jack.h line 104
signed int jack_client_close(struct _jack_client *);
// jack_client_open
// file /usr/include/jack/jack.h line 88
struct _jack_client * jack_client_open(const char *, enum JackOptions, enum JackStatus *, ...);
// jack_connect
// file /usr/include/jack/jack.h line 848
signed int jack_connect(struct _jack_client *, const char *, const char *);
// jack_frame_time
// file /usr/include/jack/jack.h line 1179
unsigned int jack_frame_time(const struct _jack_client *);
// jack_get_buffer_size
// file /usr/include/jack/jack.h line 565
unsigned int jack_get_buffer_size(struct _jack_client *);
// jack_get_client_name
// file /usr/include/jack/jack.h line 118
char * jack_get_client_name(struct _jack_client *);
// jack_get_ports
// file /usr/include/jack/jack.h line 1137
const char ** jack_get_ports(struct _jack_client *, const char *, const char *, unsigned long int);
// jack_get_sample_rate
// file /usr/include/jack/jack.h line 554
unsigned int jack_get_sample_rate(struct _jack_client *);
// jack_last_frame_time
// file /usr/include/jack/jack.h line 1195
unsigned int jack_last_frame_time(const struct _jack_client *);
// jack_port_get_buffer
// file /usr/include/jack/jack.h line 649
void * jack_port_get_buffer(struct _jack_port *, unsigned int);
// jack_port_name
// file /usr/include/jack/jack.h line 657
const char * jack_port_name(const struct _jack_port *);
// jack_port_register
// file /usr/include/jack/jack.h line 624
struct _jack_port * jack_port_register(struct _jack_client *, const char *, const char *, unsigned long int, unsigned long int);
// jack_session_event_free
// file /usr/include/jack/session.h line 197
void jack_session_event_free(struct _jack_session_event *);
// jack_session_reply
// file /usr/include/jack/session.h line 188
signed int jack_session_reply(struct _jack_client *, struct _jack_session_event *);
// jack_set_process_callback
// file /usr/include/jack/jack.h line 342
signed int jack_set_process_callback(struct _jack_client *, signed int (*)(unsigned int, void *), void *);
// jack_set_session_callback
// file /usr/include/jack/session.h line 175
signed int jack_set_session_callback(struct _jack_client *, void (*)(struct _jack_session_event *, void *), void *);
// lo_address_free
// file /usr/include/lo/lo.h line 89
void lo_address_free(void *);
// lo_address_get_hostname
// file /usr/include/lo/lo_lowlevel.h line 391
const char * lo_address_get_hostname(void *);
// lo_address_get_port
// file /usr/include/lo/lo_lowlevel.h line 399
const char * lo_address_get_port(void *);
// lo_address_new
// file /usr/include/lo/lo.h line 60
void * lo_address_new(const char *, const char *);
// lo_arg_pp
// file /usr/include/lo/lo_lowlevel.h line 1054
void lo_arg_pp(enum anonymous$15, void *);
// lo_message_get_source
// file /usr/include/lo/lo_lowlevel.h line 297
void * lo_message_get_source(void *);
// lo_send_internal
// file /usr/include/lo/lo_lowlevel.h line 973
signed int lo_send_internal(void *, const char *, const signed int, const char *, const char *, ...);
// lo_server_thread_add_method
// file /usr/include/lo/lo_serverthread.h line 119
void * lo_server_thread_add_method(void *, const char *, const char *, signed int (*)(const char *, const char *, union anonymous$7 **, signed int, void *, void *), void *);
// lo_server_thread_get_url
// file /usr/include/lo/lo_serverthread.h line 159
char * lo_server_thread_get_url(void *);
// lo_server_thread_new
// file /usr/include/lo/lo_serverthread.h line 44
void * lo_server_thread_new(const char *, void (*)(signed int, const char *, const char *));
// lo_server_thread_start
// file /usr/include/lo/lo_serverthread.h line 139
signed int lo_server_thread_start(void *);
// lo_url_get_hostname
// file /usr/include/lo/lo_lowlevel.h line 930
char * lo_url_get_hostname(const char *);
// lo_url_get_path
// file /usr/include/lo/lo_lowlevel.h line 944
char * lo_url_get_path(const char *);
// lo_url_get_port
// file /usr/include/lo/lo_lowlevel.h line 937
char * lo_url_get_port(const char *);
// load
// file ghostess.c line 668
char * load(const char *dllName, void **dll);
// logf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern float logf(float);
// lrintf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 325
extern signed long int lrintf(float);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// midi_open
// file midi.h line 33
signed int midi_open(void);
// midi_thread_function
// file midi.h line 34
void * midi_thread_function(void *arg);
// new_instance_template
// file ghostess.c line 750
static struct _instance_template_t * new_instance_template(void);
// on_about_dismiss
// file gui_callbacks.c line 206
void on_about_dismiss(struct _GtkWidget *widget, void *data);
// on_delete_event_wrapper
// file gui_callbacks.c line 145
signed int on_delete_event_wrapper(struct _GtkWidget *widget, union _GdkEvent *event, void *data);
// on_delete_event_wrapper::1::handler$object
//
void handler$object(struct _GtkWidget *, void *);
// on_file_selection_cancel
// file gui_callbacks.c line 164
void on_file_selection_cancel(struct _GtkWidget *widget, void *data);
// on_file_selection_ok
// file gui_callbacks.c line 157
void on_file_selection_ok(struct _GtkWidget *widget, void *data);
// on_menu_about_activate
// file gui_callbacks.c line 103
void on_menu_about_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_patchlist_activate
// file gui_callbacks.c line 83
void on_menu_patchlist_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_quit_activate
// file gui_callbacks.c line 94
void on_menu_quit_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_save_activate
// file gui_callbacks.c line 72
void on_menu_save_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_notice_dismiss
// file gui_callbacks.c line 332
void on_notice_dismiss(struct _GtkWidget *widget, void *data);
// on_patchlist_file_ok
// file gui_callbacks.c line 188
void on_patchlist_file_ok(struct _GtkWidget *widget, void *data);
// on_save_file_ok
// file gui_callbacks.c line 171
void on_save_file_ok(struct _GtkWidget *widget, void *data);
// on_strip_ui_button_event
// file gui_callbacks.c line 235
signed int on_strip_ui_button_event(struct _GtkWidget *widget, struct _GdkEventButton *event, void *data);
// on_strip_ui_button_toggled
// file gui_callbacks.c line 212
void on_strip_ui_button_toggled(struct _GtkWidget *widget, void *data);
// on_ui_context_menu_activate
// file gui_callbacks.c line 274
void on_ui_context_menu_activate(struct _GtkWidget *widget, void *data);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// osc_configure_handler
// file ghostess.c line 2575
signed int osc_configure_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv);
// osc_control_handler
// file ghostess.c line 2516
signed int osc_control_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv);
// osc_debug_handler
// file ghostess.c line 2734
signed int osc_debug_handler(const char *path, const char *types, union anonymous$7 **argv, signed int argc, void *data, void *user_data);
// osc_error
// file ghostess.c line 2424
void osc_error(signed int num, const char *msg, const char *path);
// osc_exiting_handler
// file ghostess.c line 2430
signed int osc_exiting_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv);
// osc_message_handler
// file ghostess.c line 2753
signed int osc_message_handler(const char *path, const char *types, union anonymous$7 **argv, signed int argc, void *data, void *user_data);
// osc_midi_handler
// file ghostess.c line 2447
signed int osc_midi_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv);
// osc_program_handler
// file ghostess.c line 2539
signed int osc_program_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv);
// osc_update_handler
// file ghostess.c line 2643
signed int osc_update_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv, void *source);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$19 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$19 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setschedparam
// file /usr/include/pthread.h line 431
extern signed int pthread_setschedparam(unsigned long int, signed int, struct sched_param *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$18 *, struct anonymous$18 *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// query_programs
// file ghostess.c line 1267
void query_programs(struct _d3h_instance_t *instance);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reset_instance_template
// file ghostess.c line 757
static void reset_instance_template(struct _instance_template_t *t);
// session_callback
// file ghostess.c line 657
void session_callback(struct _jack_session_event *event, void *arg);
// session_gui_idle_callback
// file ghostess.c line 627
signed int session_gui_idle_callback(void *arg);
// setControl
// file ghostess.c line 176
void setControl(struct _d3h_instance_t *instance, signed long int controlIn, struct snd_seq_event *event);
// set_initial_port_settings
// file ghostess.c line 817
void set_initial_port_settings(struct _d3h_instance_t *instance);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$18 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$18 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signalHandler
// file ghostess.c line 168
void signalHandler(signed int sig);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snd_midi_event_encode
// file /usr/include/alsa/seq_midi_event.h line 53
signed long int snd_midi_event_encode(struct snd_midi_event *, const unsigned char *, signed long int, struct snd_seq_event *);
// snd_midi_event_new
// file /usr/include/alsa/seq_midi_event.h line 45
signed int snd_midi_event_new(unsigned long int, struct snd_midi_event **);
// snd_midi_event_reset_encode
// file /usr/include/alsa/seq_midi_event.h line 49
void snd_midi_event_reset_encode(struct snd_midi_event *);
// snd_seq_client_id
// file /usr/include/alsa/seq.h line 87
signed int snd_seq_client_id(struct _snd_seq *);
// snd_seq_create_simple_port
// file /usr/include/alsa/seqmid.h line 328
signed int snd_seq_create_simple_port(struct _snd_seq *, const char *, unsigned int, unsigned int);
// snd_seq_event_input
// file /usr/include/alsa/seq.h line 522
signed int snd_seq_event_input(struct _snd_seq *, struct snd_seq_event **);
// snd_seq_event_input_pending
// file /usr/include/alsa/seq.h line 523
signed int snd_seq_event_input_pending(struct _snd_seq *, signed int);
// snd_seq_open
// file /usr/include/alsa/seq.h line 78
signed int snd_seq_open(struct _snd_seq **, const char *, signed int, signed int);
// snd_seq_poll_descriptors
// file /usr/include/alsa/seq.h line 84
signed int snd_seq_poll_descriptors(struct _snd_seq *, struct pollfd *, unsigned int, signed short int);
// snd_seq_poll_descriptors_count
// file /usr/include/alsa/seq.h line 83
signed int snd_seq_poll_descriptors_count(struct _snd_seq *, signed short int);
// snd_seq_set_client_name
// file /usr/include/alsa/seqmid.h line 344
signed int snd_seq_set_client_name(struct _snd_seq *, const char *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// start_ui
// file ghostess.c line 1079
void start_ui(struct _d3h_instance_t *instance);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// ui_osc_free
// file ghostess.c line 1055
void ui_osc_free(struct _d3h_instance_t *instance);
// update_eyecandy
// file gui_callbacks.h line 47
void update_eyecandy(struct _d3h_instance_t *instance);
// update_from_exiting
// file gui_callbacks.h line 46
void update_from_exiting(struct _d3h_instance_t *instance);
// update_ui_button_internal
// file gui_callbacks.c line 260
void update_ui_button_internal(struct _d3h_instance_t *instance, signed int value);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write_configuration
// file ghostess.c line 911
signed int write_configuration(char *filename, const char *uuid);
// write_patchlist
// file ghostess.c line 996
signed int write_patchlist(char *filename);

struct anonymous$22
{
  // toplevel_under_pointer
  struct _GdkDrawable *toplevel_under_pointer;
  // window_under_pointer
  struct _GdkDrawable *window_under_pointer;
  // toplevel_x
  double toplevel_x;
  // toplevel_y
  double toplevel_y;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // motion_hint_serial
  unsigned long int motion_hint_serial;
};

struct anonymous$21
{
  // window
  struct _GdkDrawable *window;
  // native_window
  struct _GdkDrawable *native_window;
  // serial
  unsigned long int serial;
  // owner_events
  signed int owner_events;
  // time
  unsigned int time;
};

struct anonymous
{
  // f
  void (*f)(void);
  // d
  void *d;
};

struct anonymous$18
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$6
{
  // sec
  unsigned int sec;
  // frac
  unsigned int frac;
};

union anonymous$41
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

union anonymous$7
{
  // i
  signed int i;
  // i32
  signed int i32;
  // h
  signed long int h;
  // i64
  signed long int i64;
  // f
  float f;
  // f32
  float f32;
  // d
  double d;
  // f64
  double f64;
  // s
  char s;
  // S
  char S;
  // c
  unsigned char c;
  // m
  unsigned char m[4l];
  // t
  struct anonymous$6 t;
};

union anonymous$27
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

struct snd_seq_real_time
{
  // tv_sec
  unsigned int tv_sec;
  // tv_nsec
  unsigned int tv_nsec;
};

union snd_seq_timestamp
{
  // tick
  unsigned int tick;
  // time
  struct snd_seq_real_time time;
};

struct snd_seq_queue_skew
{
  // value
  unsigned int value;
  // base
  unsigned int base;
};

union anonymous$10
{
  // value
  signed int value;
  // time
  union snd_seq_timestamp time;
  // position
  unsigned int position;
  // skew
  struct snd_seq_queue_skew skew;
  // d32
  unsigned int d32[2l];
  // d8
  unsigned char d8[8l];
};

union anonymous$39
{
  // char_data
  char char_data;
  // uchar_data
  unsigned char uchar_data;
  // bool_data
  signed int bool_data;
  // int_data
  signed int int_data;
  // uint_data
  unsigned int uint_data;
  // long_data
  signed long int long_data;
  // ulong_data
  unsigned long int ulong_data;
  // float_data
  float float_data;
  // double_data
  double double_data;
  // string_data
  char *string_data;
  // object_data
  struct _GtkObject *object_data;
  // pointer_data
  void *pointer_data;
  // signal_data
  struct anonymous signal_data;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$19
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _argc_state
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // next_arg
  signed int next_arg;
};

struct _file_state
{
  // filename
  char *filename;
  // fh
  struct _IO_FILE *fh;
  // next
  signed long int next;
};

union anonymous$2
{
  // argv
  struct _argc_state argv;
  // file
  struct _file_state file;
};

struct snd_seq_ev_note
{
  // channel
  unsigned char channel;
  // note
  unsigned char note;
  // velocity
  unsigned char velocity;
  // off_velocity
  unsigned char off_velocity;
  // duration
  unsigned int duration;
};

struct snd_seq_ev_ctrl
{
  // channel
  unsigned char channel;
  // unused
  unsigned char unused[3l];
  // param
  unsigned int param;
  // value
  signed int value;
};

struct snd_seq_ev_raw8
{
  // d
  unsigned char d[12l];
};

struct snd_seq_ev_raw32
{
  // d
  unsigned int d[3l];
};

struct snd_seq_ev_ext
{
  // len
  unsigned int len;
  // ptr
  void *ptr;
} __attribute__ ((__packed__));

struct snd_seq_ev_queue_control
{
  // queue
  unsigned char queue;
  // unused
  unsigned char unused[3l];
  // param
  union anonymous$10 param;
};

struct snd_seq_addr
{
  // client
  unsigned char client;
  // port
  unsigned char port;
};

struct snd_seq_connect
{
  // sender
  struct snd_seq_addr sender;
  // dest
  struct snd_seq_addr dest;
};

struct snd_seq_result
{
  // event
  signed int event;
  // result
  signed int result;
};

union anonymous$8
{
  // note
  struct snd_seq_ev_note note;
  // control
  struct snd_seq_ev_ctrl control;
  // raw8
  struct snd_seq_ev_raw8 raw8;
  // raw32
  struct snd_seq_ev_raw32 raw32;
  // ext
  struct snd_seq_ev_ext ext;
  // queue
  struct snd_seq_ev_queue_control queue;
  // time
  union snd_seq_timestamp time;
  // addr
  struct snd_seq_addr addr;
  // connect
  struct snd_seq_connect connect;
  // result
  struct snd_seq_result result;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _AtkObject
{
  // parent
  struct _GObject parent;
  // description
  char *description;
  // name
  char *name;
  // accessible_parent
  struct _AtkObject *accessible_parent;
  // role
  enum anonymous$0 role;
  // relation_set
  struct _AtkRelationSet *relation_set;
  // layer
  enum anonymous$1 layer;
};

struct _AtkRelationSet
{
  // parent
  struct _GObject parent;
  // relations
  struct _GPtrArray *relations;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct _Blinky
{
  // widget
  struct _GtkWidget widget;
  // state
  unsigned int state;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GObjectClass
{
  // g_type_class
  struct _GTypeClass g_type_class;
  // construct_properties
  struct _GSList *construct_properties;
  // constructor
  struct _GObject * (*constructor)(unsigned long int, unsigned int, struct _GObjectConstructParam *);
  // set_property
  void (*set_property)(struct _GObject *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_property
  void (*get_property)(struct _GObject *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // dispose
  void (*dispose)(struct _GObject *);
  // finalize
  void (*finalize)(struct _GObject *);
  // dispatch_properties_changed
  void (*dispatch_properties_changed)(struct _GObject *, unsigned int, struct _GParamSpec **);
  // notify
  void (*notify)(struct _GObject *, struct _GParamSpec *);
  // constructed
  void (*constructed)(struct _GObject *);
  // flags
  unsigned long int flags;
  // pdummy
  void *pdummy[6l];
};

struct _GtkObjectClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // set_arg
  void (*set_arg)(struct _GtkObject *, struct _GtkArg *, unsigned int);
  // get_arg
  void (*get_arg)(struct _GtkObject *, struct _GtkArg *, unsigned int);
  // destroy
  void (*destroy)(struct _GtkObject *);
};

struct _GtkWidgetClass
{
  // parent_class
  struct _GtkObjectClass parent_class;
  // activate_signal
  unsigned int activate_signal;
  // set_scroll_adjustments_signal
  unsigned int set_scroll_adjustments_signal;
  // dispatch_child_properties_changed
  void (*dispatch_child_properties_changed)(struct _GtkWidget *, unsigned int, struct _GParamSpec **);
  // show
  void (*show)(struct _GtkWidget *);
  // show_all
  void (*show_all)(struct _GtkWidget *);
  // hide
  void (*hide)(struct _GtkWidget *);
  // hide_all
  void (*hide_all)(struct _GtkWidget *);
  // map
  void (*map)(struct _GtkWidget *);
  // unmap
  void (*unmap)(struct _GtkWidget *);
  // realize
  void (*realize)(struct _GtkWidget *);
  // unrealize
  void (*unrealize)(struct _GtkWidget *);
  // size_request
  void (*size_request)(struct _GtkWidget *, struct _GtkRequisition *);
  // size_allocate
  void (*size_allocate)(struct _GtkWidget *, struct _GdkRectangle *);
  // state_changed
  void (*state_changed)(struct _GtkWidget *, enum anonymous$49);
  // parent_set
  void (*parent_set)(struct _GtkWidget *, struct _GtkWidget *);
  // hierarchy_changed
  void (*hierarchy_changed)(struct _GtkWidget *, struct _GtkWidget *);
  // style_set
  void (*style_set)(struct _GtkWidget *, struct _GtkStyle *);
  // direction_changed
  void (*direction_changed)(struct _GtkWidget *, enum anonymous$48);
  // grab_notify
  void (*grab_notify)(struct _GtkWidget *, signed int);
  // child_notify
  void (*child_notify)(struct _GtkWidget *, struct _GParamSpec *);
  // mnemonic_activate
  signed int (*mnemonic_activate)(struct _GtkWidget *, signed int);
  // grab_focus
  void (*grab_focus)(struct _GtkWidget *);
  // focus
  signed int (*focus)(struct _GtkWidget *, enum anonymous$47);
  // event
  signed int (*event)(struct _GtkWidget *, union _GdkEvent *);
  // button_press_event
  signed int (*button_press_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // button_release_event
  signed int (*button_release_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // scroll_event
  signed int (*scroll_event)(struct _GtkWidget *, struct _GdkEventScroll *);
  // motion_notify_event
  signed int (*motion_notify_event)(struct _GtkWidget *, struct _GdkEventMotion *);
  // delete_event
  signed int (*delete_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // destroy_event
  signed int (*destroy_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // expose_event
  signed int (*expose_event)(struct _GtkWidget *, struct _GdkEventExpose *);
  // key_press_event
  signed int (*key_press_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // key_release_event
  signed int (*key_release_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // enter_notify_event
  signed int (*enter_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // leave_notify_event
  signed int (*leave_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // configure_event
  signed int (*configure_event)(struct _GtkWidget *, struct _GdkEventConfigure *);
  // focus_in_event
  signed int (*focus_in_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // focus_out_event
  signed int (*focus_out_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // map_event
  signed int (*map_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // unmap_event
  signed int (*unmap_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // property_notify_event
  signed int (*property_notify_event)(struct _GtkWidget *, struct _GdkEventProperty *);
  // selection_clear_event
  signed int (*selection_clear_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_request_event
  signed int (*selection_request_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_notify_event
  signed int (*selection_notify_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // proximity_in_event
  signed int (*proximity_in_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // proximity_out_event
  signed int (*proximity_out_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // visibility_notify_event
  signed int (*visibility_notify_event)(struct _GtkWidget *, struct _GdkEventVisibility *);
  // client_event
  signed int (*client_event)(struct _GtkWidget *, struct _GdkEventClient *);
  // no_expose_event
  signed int (*no_expose_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // window_state_event
  signed int (*window_state_event)(struct _GtkWidget *, struct _GdkEventWindowState *);
  // selection_get
  void (*selection_get)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // selection_received
  void (*selection_received)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int);
  // drag_begin
  void (*drag_begin)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_end
  void (*drag_end)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_data_get
  void (*drag_data_get)(struct _GtkWidget *, struct _GdkDragContext *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // drag_data_delete
  void (*drag_data_delete)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_leave
  void (*drag_leave)(struct _GtkWidget *, struct _GdkDragContext *, unsigned int);
  // drag_motion
  signed int (*drag_motion)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_drop
  signed int (*drag_drop)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_data_received
  void (*drag_data_received)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, struct _GtkSelectionData *, unsigned int, unsigned int);
  // popup_menu
  signed int (*popup_menu)(struct _GtkWidget *);
  // show_help
  signed int (*show_help)(struct _GtkWidget *, enum anonymous$42);
  // get_accessible
  struct _AtkObject * (*get_accessible)(struct _GtkWidget *);
  // screen_changed
  void (*screen_changed)(struct _GtkWidget *, struct _GdkScreen *);
  // can_activate_accel
  signed int (*can_activate_accel)(struct _GtkWidget *, unsigned int);
  // grab_broken_event
  signed int (*grab_broken_event)(struct _GtkWidget *, struct _GdkEventGrabBroken *);
  // composited_changed
  void (*composited_changed)(struct _GtkWidget *);
  // query_tooltip
  signed int (*query_tooltip)(struct _GtkWidget *, signed int, signed int, signed int, struct _GtkTooltip *);
  // _gtk_reserved5
  void (*_gtk_reserved5)(void);
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
};

struct _BlinkyClass
{
  // parent_class
  struct _GtkWidgetClass parent_class;
};

struct _DSSI_Descriptor
{
  // DSSI_API_Version
  signed int DSSI_API_Version;
  // LADSPA_Plugin
  const struct _LADSPA_Descriptor *LADSPA_Plugin;
  // configure
  char * (*configure)(void *, const char *, const char *);
  // get_program
  const struct _DSSI_Program_Descriptor * (*get_program)(void *, unsigned long int);
  // select_program
  void (*select_program)(void *, unsigned long int, unsigned long int);
  // get_midi_controller_for_port
  signed int (*get_midi_controller_for_port)(void *, unsigned long int);
  // run_synth
  void (*run_synth)(void *, unsigned long int, struct snd_seq_event *, unsigned long int);
  // run_synth_adding
  void (*run_synth_adding)(void *, unsigned long int, struct snd_seq_event *, unsigned long int);
  // run_multiple_synths
  void (*run_multiple_synths)(unsigned long int, void **, unsigned long int, struct snd_seq_event **, unsigned long int *);
  // run_multiple_synths_adding
  void (*run_multiple_synths_adding)(unsigned long int, void **, unsigned long int, struct snd_seq_event **, unsigned long int *);
};

struct _DSSI_Program_Descriptor
{
  // Bank
  unsigned long int Bank;
  // Program
  unsigned long int Program;
  // Name
  const char *Name;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GObjectConstructParam
{
  // pspec
  struct _GParamSpec *pspec;
  // value
  struct _GValue *value;
};

struct _GParamSpec
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // name
  const char *name;
  // flags
  enum anonymous$28 flags;
  // value_type
  unsigned long int value_type;
  // owner_type
  unsigned long int owner_type;
  // _nick
  char *_nick;
  // _blurb
  char *_blurb;
  // qdata
  struct _GData *qdata;
  // ref_count
  unsigned int ref_count;
  // param_id
  unsigned int param_id;
};

struct _GPtrArray
{
  // pdata
  void **pdata;
  // len
  unsigned int len;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous$27 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkCursor
{
  // type
  enum anonymous$43 type;
  // ref_count
  unsigned int ref_count;
};

struct _GdkDevice
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // source
  enum anonymous$34 source;
  // mode
  enum anonymous$35 mode;
  // has_cursor
  signed int has_cursor;
  // num_axes
  signed int num_axes;
  // axes
  struct _GdkDeviceAxis *axes;
  // num_keys
  signed int num_keys;
  // keys
  struct _GdkDeviceKey *keys;
};

struct _GdkDeviceAxis
{
  // use
  enum anonymous$30 use;
  // min
  double min;
  // max
  double max;
};

struct _GdkDeviceKey
{
  // keyval
  unsigned int keyval;
  // modifiers
  enum anonymous$23 modifiers;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkDisplay
{
  // parent_instance
  struct _GObject parent_instance;
  // queued_events
  struct _GList *queued_events;
  // queued_tail
  struct _GList *queued_tail;
  // button_click_time
  unsigned int button_click_time[2l];
  // button_window
  struct _GdkDrawable *button_window[2l];
  // button_number
  signed int button_number[2l];
  // double_click_time
  unsigned int double_click_time;
  // core_pointer
  struct _GdkDevice *core_pointer;
  // pointer_hooks
  const struct _GdkDisplayPointerHooks *pointer_hooks;
  // closed
  unsigned int closed : 1;
  // ignore_core_events
  unsigned int ignore_core_events : 1;
  // double_click_distance
  unsigned int double_click_distance;
  // button_x
  signed int button_x[2l];
  // button_y
  signed int button_y[2l];
  // pointer_grabs
  struct _GList *pointer_grabs;
  // keyboard_grab
  struct anonymous$21 keyboard_grab;
  // pointer_info
  struct anonymous$22 pointer_info;
  // last_event_time
  unsigned int last_event_time;
};

struct _GdkDisplayPointerHooks
{
  // get_pointer
  void (*get_pointer)(struct _GdkDisplay *, struct _GdkScreen **, signed int *, signed int *, enum anonymous$23 *);
  // window_get_pointer
  struct _GdkDrawable * (*window_get_pointer)(struct _GdkDisplay *, struct _GdkDrawable *, signed int *, signed int *, enum anonymous$23 *);
  // window_at_pointer
  struct _GdkDrawable * (*window_at_pointer)(struct _GdkDisplay *, signed int *, signed int *);
};

struct _GdkDragContext
{
  // parent_instance
  struct _GObject parent_instance;
  // protocol
  enum anonymous$50 protocol;
  // is_source
  signed int is_source;
  // source_window
  struct _GdkDrawable *source_window;
  // dest_window
  struct _GdkDrawable *dest_window;
  // targets
  struct _GList *targets;
  // actions
  enum anonymous$51 actions;
  // suggested_action
  enum anonymous$51 suggested_action;
  // action
  enum anonymous$51 action;
  // start_time
  unsigned int start_time;
  // windowing_data
  void *windowing_data;
};

struct _GdkEventAny
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventExpose
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // area
  struct _GdkRectangle area;
  // region
  struct _GdkRegion *region;
  // count
  signed int count;
};

struct _GdkEventNoExpose
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous$31 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous$32 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventKey
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkDrawable *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous$36 mode;
  // detail
  enum anonymous$33 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  unsigned int requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // owner
  unsigned int owner;
  // reason
  enum anonymous$40 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventClient
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // message_type
  struct _GdkAtom *message_type;
  // data_format
  unsigned short int data_format;
  // data
  union anonymous$41 data;
};

struct _GdkEventDND
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous$37 changed_mask;
  // new_window_state
  enum anonymous$37 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous$38 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous$26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkDrawable *grab_window;
};

union _GdkEvent
{
  // type
  enum anonymous$26 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // no_expose
  struct _GdkEventNoExpose no_expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // client
  struct _GdkEventClient client;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
};

struct _GdkFont
{
  // type
  enum anonymous$13 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkScreen
{
  // parent_instance
  struct _GObject parent_instance;
  // closed
  unsigned int closed : 1;
  // normal_gcs
  struct _GdkGC *normal_gcs[32l];
  // exposure_gcs
  struct _GdkGC *exposure_gcs[32l];
  // subwindow_gcs
  struct _GdkGC *subwindow_gcs[32l];
  // font_options
  struct _cairo_font_options *font_options;
  // resolution
  double resolution;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous$29 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous$12 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GdkWindowAttr
{
  // title
  char *title;
  // event_mask
  signed int event_mask;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // wclass
  enum anonymous$44 wclass;
  // visual
  struct _GdkVisual *visual;
  // colormap
  struct _GdkColormap *colormap;
  // window_type
  enum anonymous$45 window_type;
  // cursor
  struct _GdkCursor *cursor;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // override_redirect
  signed int override_redirect;
  // type_hint
  enum anonymous$46 type_hint;
};

struct _GtkAccelGroup
{
  // parent
  struct _GObject parent;
  // lock_count
  unsigned int lock_count;
  // modifier_mask
  enum anonymous$23 modifier_mask;
  // acceleratables
  struct _GSList *acceleratables;
  // n_accels
  unsigned int n_accels;
  // priv_accels
  struct _GtkAccelGroupEntry *priv_accels;
};

struct _GtkAccelKey
{
  // accel_key
  unsigned int accel_key;
  // accel_mods
  enum anonymous$23 accel_mods;
  // accel_flags
  unsigned int accel_flags : 16;
};

struct _GtkAccelGroupEntry
{
  // key
  struct _GtkAccelKey key;
  // closure
  struct _GClosure *closure;
  // accel_path_quark
  unsigned int accel_path_quark;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GtkObject parent_instance;
  // lower
  double lower;
  // upper
  double upper;
  // value
  double value;
  // step_increment
  double step_increment;
  // page_increment
  double page_increment;
  // page_size
  double page_size;
};

struct _GtkArg
{
  // type
  unsigned long int type;
  // name
  char *name;
  // d
  union anonymous$39 d;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // child
  struct _GtkWidget *child;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // spacing
  signed short int spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // event_window
  struct _GdkDrawable *event_window;
  // label_text
  char *label_text;
  // activate_timeout
  unsigned int activate_timeout;
  // constructed
  unsigned int constructed : 1;
  // in_button
  unsigned int in_button : 1;
  // button_down
  unsigned int button_down : 1;
  // relief
  unsigned int relief : 2;
  // use_underline
  unsigned int use_underline : 1;
  // use_stock
  unsigned int use_stock : 1;
  // depressed
  unsigned int depressed : 1;
  // depress_on_activate
  unsigned int depress_on_activate : 1;
  // focus_on_click
  unsigned int focus_on_click : 1;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // title
  char *title;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // wm_role
  char *wm_role;
  // focus_widget
  struct _GtkWidget *focus_widget;
  // default_widget
  struct _GtkWidget *default_widget;
  // transient_parent
  struct _GtkWindow *transient_parent;
  // geometry_info
  struct _GtkWindowGeometryInfo *geometry_info;
  // frame
  struct _GdkDrawable *frame;
  // group
  struct _GtkWindowGroup *group;
  // configure_request_count
  unsigned short int configure_request_count;
  // allow_shrink
  unsigned int allow_shrink : 1;
  // allow_grow
  unsigned int allow_grow : 1;
  // configure_notify_received
  unsigned int configure_notify_received : 1;
  // need_default_position
  unsigned int need_default_position : 1;
  // need_default_size
  unsigned int need_default_size : 1;
  // position
  unsigned int position : 3;
  // type
  unsigned int type : 4;
  // has_user_ref_count
  unsigned int has_user_ref_count : 1;
  // has_focus
  unsigned int has_focus : 1;
  // modal
  unsigned int modal : 1;
  // destroy_with_parent
  unsigned int destroy_with_parent : 1;
  // has_frame
  unsigned int has_frame : 1;
  // iconify_initially
  unsigned int iconify_initially : 1;
  // stick_initially
  unsigned int stick_initially : 1;
  // maximize_initially
  unsigned int maximize_initially : 1;
  // decorated
  unsigned int decorated : 1;
  // type_hint
  unsigned int type_hint : 3;
  // gravity
  unsigned int gravity : 5;
  // is_active
  unsigned int is_active : 1;
  // has_toplevel_focus
  unsigned int has_toplevel_focus : 1;
  // frame_left
  unsigned int frame_left;
  // frame_top
  unsigned int frame_top;
  // frame_right
  unsigned int frame_right;
  // frame_bottom
  unsigned int frame_bottom;
  // keys_changed_handler
  unsigned int keys_changed_handler;
  // mnemonic_modifier
  enum anonymous$23 mnemonic_modifier;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // vbox
  struct _GtkWidget *vbox;
  // action_area
  struct _GtkWidget *action_area;
  // separator
  struct _GtkWidget *separator;
};

struct _GtkFileSelection
{
  // parent_instance
  struct _GtkDialog parent_instance;
  // dir_list
  struct _GtkWidget *dir_list;
  // file_list
  struct _GtkWidget *file_list;
  // selection_entry
  struct _GtkWidget *selection_entry;
  // selection_text
  struct _GtkWidget *selection_text;
  // main_vbox
  struct _GtkWidget *main_vbox;
  // ok_button
  struct _GtkWidget *ok_button;
  // cancel_button
  struct _GtkWidget *cancel_button;
  // help_button
  struct _GtkWidget *help_button;
  // history_pulldown
  struct _GtkWidget *history_pulldown;
  // history_menu
  struct _GtkWidget *history_menu;
  // history_list
  struct _GList *history_list;
  // fileop_dialog
  struct _GtkWidget *fileop_dialog;
  // fileop_entry
  struct _GtkWidget *fileop_entry;
  // fileop_file
  char *fileop_file;
  // cmpl_state
  void *cmpl_state;
  // fileop_c_dir
  struct _GtkWidget *fileop_c_dir;
  // fileop_del_file
  struct _GtkWidget *fileop_del_file;
  // fileop_ren_file
  struct _GtkWidget *fileop_ren_file;
  // button_area
  struct _GtkWidget *button_area;
  // action_area
  struct _GtkWidget *action_area;
  // selected_names
  struct _GPtrArray *selected_names;
  // last_selected
  char *last_selected;
};

struct _GtkFrame
{
  // bin
  struct _GtkBin bin;
  // label_widget
  struct _GtkWidget *label_widget;
  // shadow_type
  signed short int shadow_type;
  // label_xalign
  float label_xalign;
  // label_yalign
  float label_yalign;
  // child_allocation
  struct _GdkRectangle child_allocation;
};

struct _GtkItem
{
  // bin
  struct _GtkBin bin;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // label
  char *label;
  // jtype
  unsigned int jtype : 2;
  // wrap
  unsigned int wrap : 1;
  // use_underline
  unsigned int use_underline : 1;
  // use_markup
  unsigned int use_markup : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // single_line_mode
  unsigned int single_line_mode : 1;
  // have_transform
  unsigned int have_transform : 1;
  // in_click
  unsigned int in_click : 1;
  // wrap_mode
  unsigned int wrap_mode : 3;
  // pattern_set
  unsigned int pattern_set : 1;
  // track_links
  unsigned int track_links : 1;
  // mnemonic_keyval
  unsigned int mnemonic_keyval;
  // text
  char *text;
  // attrs
  struct _PangoAttrList *attrs;
  // effective_attrs
  struct _PangoAttrList *effective_attrs;
  // layout
  struct _PangoLayout *layout;
  // mnemonic_widget
  struct _GtkWidget *mnemonic_widget;
  // mnemonic_window
  struct _GtkWindow *mnemonic_window;
  // select_info
  struct _GtkLabelSelectionInfo *select_info;
};

struct _GtkMenuShell
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // active_menu_item
  struct _GtkWidget *active_menu_item;
  // parent_menu_shell
  struct _GtkWidget *parent_menu_shell;
  // button
  unsigned int button;
  // activate_time
  unsigned int activate_time;
  // active
  unsigned int active : 1;
  // have_grab
  unsigned int have_grab : 1;
  // have_xgrab
  unsigned int have_xgrab : 1;
  // ignore_leave
  unsigned int ignore_leave : 1;
  // menu_flag
  unsigned int menu_flag : 1;
  // ignore_enter
  unsigned int ignore_enter : 1;
  // keyboard_mode
  unsigned int keyboard_mode : 1;
};

struct _GtkMenu
{
  // menu_shell
  struct _GtkMenuShell menu_shell;
  // parent_menu_item
  struct _GtkWidget *parent_menu_item;
  // old_active_menu_item
  struct _GtkWidget *old_active_menu_item;
  // accel_group
  struct _GtkAccelGroup *accel_group;
  // accel_path
  char *accel_path;
  // position_func
  void (*position_func)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *);
  // position_func_data
  void *position_func_data;
  // toggle_size
  unsigned int toggle_size;
  // toplevel
  struct _GtkWidget *toplevel;
  // tearoff_window
  struct _GtkWidget *tearoff_window;
  // tearoff_hbox
  struct _GtkWidget *tearoff_hbox;
  // tearoff_scrollbar
  struct _GtkWidget *tearoff_scrollbar;
  // tearoff_adjustment
  struct _GtkAdjustment *tearoff_adjustment;
  // view_window
  struct _GdkDrawable *view_window;
  // bin_window
  struct _GdkDrawable *bin_window;
  // scroll_offset
  signed int scroll_offset;
  // saved_scroll_offset
  signed int saved_scroll_offset;
  // scroll_step
  signed int scroll_step;
  // timeout_id
  unsigned int timeout_id;
  // navigation_region
  struct _GdkRegion *navigation_region;
  // navigation_timeout
  unsigned int navigation_timeout;
  // needs_destruction_ref_count
  unsigned int needs_destruction_ref_count : 1;
  // torn_off
  unsigned int torn_off : 1;
  // tearoff_active
  unsigned int tearoff_active : 1;
  // scroll_fast
  unsigned int scroll_fast : 1;
  // upper_arrow_visible
  unsigned int upper_arrow_visible : 1;
  // lower_arrow_visible
  unsigned int lower_arrow_visible : 1;
  // upper_arrow_prelight
  unsigned int upper_arrow_prelight : 1;
  // lower_arrow_prelight
  unsigned int lower_arrow_prelight : 1;
};

struct _GtkMenuItem
{
  // item
  struct _GtkItem item;
  // submenu
  struct _GtkWidget *submenu;
  // event_window
  struct _GdkDrawable *event_window;
  // toggle_size
  unsigned short int toggle_size;
  // accelerator_width
  unsigned short int accelerator_width;
  // accel_path
  char *accel_path;
  // show_submenu_indicator
  unsigned int show_submenu_indicator : 1;
  // submenu_placement
  unsigned int submenu_placement : 1;
  // submenu_direction
  unsigned int submenu_direction : 1;
  // right_justify
  unsigned int right_justify : 1;
  // timer_from_keypress
  unsigned int timer_from_keypress : 1;
  // from_menubar
  unsigned int from_menubar : 1;
  // timer
  unsigned int timer;
};

struct _GtkRange
{
  // widget
  struct _GtkWidget widget;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // update_policy
  enum anonymous$3 update_policy;
  // inverted
  unsigned int inverted : 1;
  // flippable
  unsigned int flippable : 1;
  // has_stepper_a
  unsigned int has_stepper_a : 1;
  // has_stepper_b
  unsigned int has_stepper_b : 1;
  // has_stepper_c
  unsigned int has_stepper_c : 1;
  // has_stepper_d
  unsigned int has_stepper_d : 1;
  // need_recalc
  unsigned int need_recalc : 1;
  // slider_size_fixed
  unsigned int slider_size_fixed : 1;
  // min_slider_size
  signed int min_slider_size;
  // orientation
  enum anonymous$4 orientation;
  // range_rect
  struct _GdkRectangle range_rect;
  // slider_start
  signed int slider_start;
  // slider_end
  signed int slider_end;
  // round_digits
  signed int round_digits;
  // trough_click_forward
  unsigned int trough_click_forward : 1;
  // update_pending
  unsigned int update_pending : 1;
  // layout
  struct _GtkRangeLayout *layout;
  // timer
  struct _GtkRangeStepTimer *timer;
  // slide_initial_slider_position
  signed int slide_initial_slider_position;
  // slide_initial_coordinate
  signed int slide_initial_coordinate;
  // update_timeout_id
  unsigned int update_timeout_id;
  // event_window
  struct _GdkDrawable *event_window;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous$14 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // hscrollbar
  struct _GtkWidget *hscrollbar;
  // vscrollbar
  struct _GtkWidget *vscrollbar;
  // hscrollbar_policy
  unsigned int hscrollbar_policy : 2;
  // vscrollbar_policy
  unsigned int vscrollbar_policy : 2;
  // hscrollbar_visible
  unsigned int hscrollbar_visible : 1;
  // vscrollbar_visible
  unsigned int vscrollbar_visible : 1;
  // window_placement
  unsigned int window_placement : 2;
  // focus_out
  unsigned int focus_out : 1;
  // shadow_type
  unsigned short int shadow_type;
};

struct _GtkSelectionData
{
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // type
  struct _GdkAtom *type;
  // format
  signed int format;
  // data
  unsigned char *data;
  // length
  signed int length;
  // display
  struct _GdkDisplay *display;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkToggleButton
{
  // button
  struct _GtkButton button;
  // active
  unsigned int active : 1;
  // draw_indicator
  unsigned int draw_indicator : 1;
  // inconsistent
  unsigned int inconsistent : 1;
};

struct _GtkWindowGroup
{
  // parent_instance
  struct _GObject parent_instance;
  // grabs
  struct _GSList *grabs;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _LADSPA_Descriptor
{
  // UniqueID
  unsigned long int UniqueID;
  // Label
  const char *Label;
  // Properties
  signed int Properties;
  // Name
  const char *Name;
  // Maker
  const char *Maker;
  // Copyright
  const char *Copyright;
  // PortCount
  unsigned long int PortCount;
  // PortDescriptors
  const signed int *PortDescriptors;
  // PortNames
  const char * const *PortNames;
  // PortRangeHints
  const struct _LADSPA_PortRangeHint *PortRangeHints;
  // ImplementationData
  void *ImplementationData;
  // instantiate
  void * (*instantiate)(struct _LADSPA_Descriptor *, unsigned long int);
  // connect_port
  void (*connect_port)(void *, unsigned long int, float *);
  // activate
  void (*activate)(void *);
  // run
  void (*run)(void *, unsigned long int);
  // run_adding
  void (*run_adding)(void *, unsigned long int);
  // set_run_adding_gain
  void (*set_run_adding_gain)(void *, float);
  // deactivate
  void (*deactivate)(void *);
  // cleanup
  void (*cleanup)(void *);
};

struct _LADSPA_PortRangeHint
{
  // HintDescriptor
  signed int HintDescriptor;
  // LowerBound
  float LowerBound;
  // UpperBound
  float UpperBound;
};

struct _configure_item_t
{
  // next
  struct _configure_item_t *next;
  // key
  char *key;
  // value
  char *value;
};

struct _d3h_dll_t
{
  // next
  struct _d3h_dll_t *next;
  // name
  char *name;
  // directory
  char *directory;
  // is_DSSI_dll
  signed int is_DSSI_dll;
  // descfn
  const struct _DSSI_Descriptor * (*descfn)(unsigned long int);
};

struct _d3h_instance_t
{
  // number
  signed int number;
  // plugin
  struct _d3h_plugin_t *plugin;
  // id
  signed int id;
  // channel
  signed int channel;
  // channel_next_instance
  struct _d3h_instance_t *channel_next_instance;
  // friendly_name
  char *friendly_name;
  // configure_items
  struct _configure_item_t *configure_items;
  // pluginProgramsValid
  signed int pluginProgramsValid;
  // pluginProgramsAlloc
  signed int pluginProgramsAlloc;
  // pluginProgramCount
  signed int pluginProgramCount;
  // pluginPrograms
  struct _DSSI_Program_Descriptor *pluginPrograms;
  // currentBank
  signed long int currentBank;
  // currentProgram
  signed long int currentProgram;
  // pendingBankLSB
  signed int pendingBankLSB;
  // pendingBankMSB
  signed int pendingBankMSB;
  // pendingProgramChange
  signed int pendingProgramChange;
  // firstControlIn
  signed int firstControlIn;
  // pluginPortControlInNumbers
  signed int *pluginPortControlInNumbers;
  // controllerMap
  signed long int controllerMap[128l];
  // have_initial_values
  signed int have_initial_values;
  // initial_value_set
  signed int *initial_value_set;
  // initial_value
  float *initial_value;
  // strip
  struct _plugin_strip *strip;
  // midi_activity_tick
  signed int midi_activity_tick;
  // ui_running
  signed int ui_running;
  // ui_visible
  signed int ui_visible;
  // ui_initial_show_sent
  signed int ui_initial_show_sent;
  // uiNeedsProgramUpdate
  signed int uiNeedsProgramUpdate;
  // ui_osc_address
  void *ui_osc_address;
  // ui_osc_source
  void *ui_osc_source;
  // ui_osc_control_path
  char *ui_osc_control_path;
  // ui_osc_configure_path
  char *ui_osc_configure_path;
  // ui_osc_hide_path
  char *ui_osc_hide_path;
  // ui_osc_program_path
  char *ui_osc_program_path;
  // ui_osc_quit_path
  char *ui_osc_quit_path;
  // ui_osc_rate_path
  char *ui_osc_rate_path;
  // ui_osc_show_path
  char *ui_osc_show_path;
};

struct _d3h_plugin_t
{
  // next
  struct _d3h_plugin_t *next;
  // number
  signed int number;
  // dll
  struct _d3h_dll_t *dll;
  // label
  char *label;
  // is_first_in_dll
  signed int is_first_in_dll;
  // descriptor
  const struct _DSSI_Descriptor *descriptor;
  // ins
  signed int ins;
  // outs
  signed int outs;
  // controlIns
  signed int controlIns;
  // controlOuts
  signed int controlOuts;
  // instances
  signed int instances;
};

struct _getarg_state
{
  // up
  struct _getarg_state *up;
  // is_file
  signed int is_file;
  // state
  union anonymous$2 state;
};

struct _initial_port_set_t
{
  // allocated
  unsigned long int allocated;
  // have_settings
  signed int have_settings;
  // highest_set
  unsigned long int highest_set;
  // set
  signed int *set;
  // value
  float *value;
};

struct _instance_template_t
{
  // channel
  signed int channel;
  // configure_items
  struct _configure_item_t *configure_items;
  // program_set
  signed int program_set;
  // bank
  unsigned long int bank;
  // program
  unsigned long int program;
  // ports
  struct _initial_port_set_t ports;
};

struct _jack_session_event
{
  // type
  enum JackSessionEventType type;
  // session_dir
  const char *session_dir;
  // client_uuid
  const char *client_uuid;
  // command_line
  char *command_line;
  // flags
  enum JackSessionFlags flags;
  // future
  unsigned int future;
};

struct _plugin_strip
{
  // instance
  struct _d3h_instance_t *instance;
  // container
  struct _GtkWidget *container;
  // midi_status
  struct _GtkWidget *midi_status;
  // previous_midi_state
  signed int previous_midi_state;
  // ui_button
  struct _GtkWidget *ui_button;
  // pan_adjustment
  struct _GtkObject *pan_adjustment;
  // level_adjustment
  struct _GtkObject *level_adjustment;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sched_param
{
  // __sched_priority
  signed int __sched_priority;
};

struct snd_seq_event
{
  // type
  unsigned char type;
  // flags
  unsigned char flags;
  // tag
  unsigned char tag;
  // queue
  unsigned char queue;
  // time
  union snd_seq_timestamp time;
  // source
  struct snd_seq_addr source;
  // dest
  struct snd_seq_addr dest;
  // data
  union anonymous$8 data;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};


// Blinky_private_offset
// file eyecandy.c line 49
static signed int Blinky_private_offset;
// _signals
// file ghostess.c line 118
static struct anonymous$18 _signals;
// about_label
// file gui_interface.c line 52
struct _GtkWidget *about_label;
// about_window
// file gui_interface.c line 51
struct _GtkWidget *about_window;
// alsaClient
// file midi-alsa.c line 42
static struct _snd_seq *alsaClient;
// alsaClient_npfd
// file midi-alsa.c line 43
static signed int alsaClient_npfd;
// alsaClient_pfd
// file midi-alsa.c line 44
struct pollfd *alsaClient_pfd;
// alsa_client_id
// file midi-alsa.c line 46
signed int alsa_client_id;
// alsa_port_id
// file midi-alsa.c line 47
signed int alsa_port_id;
// argbuf
// file getarg.c line 40
static char *argbuf = (char *)(void *)0;
// autoconnect
// file ghostess.c line 128
signed int autoconnect = 1;
// blinky_parent_class
// file eyecandy.c line 49
static void *blinky_parent_class = (void *)0;
// blinky_style
// file eyecandy.c line 47
static struct _GtkStyle *blinky_style = (struct _GtkStyle *)(void *)0;
// channel2instances
// file ghostess.c line 109
static struct _d3h_instance_t *channel2instances[16l];
// col_darkgreen
// file eyecandy.c line 46
static struct _GdkColor col_darkgreen;
// col_green
// file eyecandy.c line 46
static struct _GdkColor col_green;
// controlInsTotal
// file ghostess.c line 107
static signed int controlInsTotal;
// controlOutsTotal
// file ghostess.c line 107
static signed int controlOutsTotal;
// debug_flags
// file ghostess.c line 127
signed int debug_flags = 1;
// dlls
// file ghostess.c line 92
static struct _d3h_dll_t *dlls;
// dssi_path
// file ghostess.c line 130
char *dssi_path = (char *)(void *)0;
// file_selection
// file gui_interface.c line 49
struct _GtkWidget *file_selection;
// file_selection_handler
// file gui_callbacks.c line 45
static void (*file_selection_handler)(struct _GtkWidget *, void *);
// getarg_error
// file getarg.c line 37
char *getarg_error = (char *)(void *)0;
// host_argv0
// file ghostess.c line 125
char *host_argv0;
// host_exiting
// file ghostess.c line 120
signed int host_exiting = 0;
// host_name
// file ghostess.c line 123
char *host_name;
// host_name_default
// file ghostess.c line 122
char *host_name_default = "ghostess";
// host_osc_url
// file ghostess.c line 124
char *host_osc_url = (char *)(void *)0;
// inputPorts
// file ghostess.c line 84
static struct _jack_port **inputPorts;
// insTotal
// file ghostess.c line 104
static signed int insTotal;
// instanceEventBuffers
// file ghostess.c line 101
static struct snd_seq_event **instanceEventBuffers;
// instanceEventCounts
// file ghostess.c line 102
static unsigned long int *instanceEventCounts;
// instanceHandles
// file ghostess.c line 100
static void **instanceHandles;
// instance_count
// file ghostess.c line 98
static signed int instance_count = 0;
// instances
// file ghostess.c line 97
static struct _d3h_instance_t instances[32l];
// jackClient
// file ghostess.c line 83
struct _jack_client *jackClient;
// jack_session_uuid
// file ghostess.c line 89
char *jack_session_uuid = (char *)(void *)0;
// last_patchlist_filename
// file gui_callbacks.c line 48
static char *last_patchlist_filename = (char *)(void *)0;
// last_save_filename
// file gui_callbacks.c line 47
static char *last_save_filename = (char *)(void *)0;
// main_timeout_tick
// file ghostess.c line 133
signed int main_timeout_tick = 0;
// main_window
// file gui_interface.c line 40
struct _GtkWidget *main_window;
// midiEventBuffer
// file ghostess.c line 135
struct snd_seq_event midiEventBuffer[1024l];
// midiEventBufferMutex
// file ghostess.c line 141
union anonymous$19 midiEventBufferMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// midiEventReadIndex
// file ghostess.c line 136
signed int midiEventReadIndex = 0;
// midiEventWriteIndex
// file ghostess.c line 136
signed int midiEventWriteIndex = 0;
// midi_thread
// file ghostess.c line 139
static unsigned long int midi_thread;
// midi_thread_running
// file ghostess.c line 140
signed int midi_thread_running = 0;
// notice_label_1
// file gui_interface.c line 55
struct _GtkWidget *notice_label_1;
// notice_label_2
// file gui_interface.c line 56
struct _GtkWidget *notice_label_2;
// notice_window
// file gui_interface.c line 54
struct _GtkWidget *notice_window;
// outputPorts
// file ghostess.c line 84
static struct _jack_port **outputPorts;
// outsTotal
// file ghostess.c line 104
static signed int outsTotal;
// pluginAudioInInstances
// file ghostess.c line 110
static struct _d3h_instance_t **pluginAudioInInstances;
// pluginAudioInPortNumbers
// file ghostess.c line 111
static unsigned long int *pluginAudioInPortNumbers;
// pluginControlInInstances
// file ghostess.c line 112
static struct _d3h_instance_t **pluginControlInInstances;
// pluginControlInPortNumbers
// file ghostess.c line 113
static unsigned long int *pluginControlInPortNumbers;
// pluginControlIns
// file ghostess.c line 108
static float *pluginControlIns;
// pluginControlOuts
// file ghostess.c line 108
static float *pluginControlOuts;
// pluginInputBuffers
// file ghostess.c line 105
static float **pluginInputBuffers;
// pluginOutputBuffers
// file ghostess.c line 105
static float **pluginOutputBuffers;
// pluginPortUpdated
// file ghostess.c line 114
static signed int *pluginPortUpdated;
// plugin_count
// file ghostess.c line 95
static signed int plugin_count = 0;
// plugin_hbox
// file gui_interface.c line 41
struct _GtkWidget *plugin_hbox;
// plugins
// file ghostess.c line 94
static struct _d3h_plugin_t *plugins;
// project_directory
// file ghostess.c line 131
char *project_directory = (char *)(void *)0;
// sample_rate
// file ghostess.c line 90
static float sample_rate;
// serverThread
// file ghostess.c line 116
void *serverThread;
// snd_seq_event_types
// file /usr/include/alsa/seq.h line 634
extern const unsigned int snd_seq_event_types[];
// state_list
// file getarg.c line 39
static struct _getarg_state *state_list = (struct _getarg_state *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// ui_context_menu
// file gui_interface.c line 43
struct _GtkWidget *ui_context_menu;
// ui_context_menu_exit
// file gui_interface.c line 47
struct _GtkWidget *ui_context_menu_exit;
// ui_context_menu_hide
// file gui_interface.c line 46
struct _GtkWidget *ui_context_menu_hide;
// ui_context_menu_instance
// file gui_callbacks.c line 50
static struct _d3h_instance_t *ui_context_menu_instance;
// ui_context_menu_launch
// file gui_interface.c line 44
struct _GtkWidget *ui_context_menu_launch;
// ui_context_menu_show
// file gui_interface.c line 45
struct _GtkWidget *ui_context_menu_show;

// add_configure_item
// file ghostess.c line 832
void add_configure_item(struct _configure_item_t **head, char *key, char *value)
{
  struct _configure_item_t *item = *head;
  signed int tmp_statement_expression$1;
  for( ; !(item == ((struct _configure_item_t *)NULL)); item = item->next)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(key, item->key);
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(tmp_statement_expression$1 == 0)
      break;

  }
  if(!(item == ((struct _configure_item_t *)NULL)))
    free((void *)item->value);

  else
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct _configure_item_t) /*24ul*/ );
    item = (struct _configure_item_t *)return_value_malloc$3;
    item->next = *head;
    *head = item;
    char *return_value___strdup$4;
    return_value___strdup$4=__strdup(key);
    item->key = return_value___strdup$4;
  }
  char *return_value___strdup$5;
  return_value___strdup$5=__strdup(value);
  item->value = return_value___strdup$5;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// audio_callback
// file ghostess.c line 232
signed int audio_callback(unsigned int nframes, void *arg)
{
  signed int i;
  unsigned int last_frame_time;
  last_frame_time=jack_last_frame_time(jackClient);
  unsigned int last_tick_offset = (unsigned int)0;
  signed int have_full_midi_buffer = 0;
  struct _d3h_instance_t *instance;
  i = 0;
  for( ; !(i >= instance_count); i = i + 1)
    instanceEventCounts[(signed long int)i] = (unsigned long int)0;
  for( ; !(midiEventReadIndex == midiEventWriteIndex); midiEventReadIndex = (midiEventReadIndex + 1) % 1024)
  {
    struct snd_seq_event *ev = &midiEventBuffer[(signed long int)midiEventReadIndex];
    unsigned int previous_frame_time;
    if(!((6u & snd_seq_event_types[(signed long int)ev->type]) == 0u))
    {
      if((signed int)ev->dest.client == 0)
      {
        if(!(channel2instances[(signed long int)ev->data.note.channel] == ((struct _d3h_instance_t *)NULL)))
          goto __CPROVER_DUMP_L4;

      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        previous_frame_time = last_frame_time - nframes;
        if(!(ev->time.tick >= previous_frame_time))
          ev->time.tick = (unsigned int)0;

        else
        {
          ev->time.tick = ev->time.tick - previous_frame_time;
          if(!(nframes + 4294967295u >= ev->time.tick))
          {
            if(!(ev->time.tick >= 2u * nframes))
            {
              ev->time.tick = ev->time.tick + previous_frame_time;
              break;
            }

            else
              ev->time.tick = nframes - (unsigned int)1;
          }

        }
        if(!(ev->time.tick >= last_tick_offset))
          ev->time.tick = last_tick_offset;

        else
          last_tick_offset = ev->time.tick;
        if(!(ev->dest.client == 0))
          instance = &instances[(signed long int)ev->dest.port];

        else
          instance = channel2instances[(signed long int)ev->data.note.channel];
        while(!(instance == ((struct _d3h_instance_t *)NULL)))
        {
          i = instance->number;
          if((signed int)ev->type == 10)
          {
            signed int controller = (signed int)ev->data.control.param;
            ghss_debug(16, ": %s MIDI CC %d(0x%02x) = %d", instance->friendly_name, controller, controller, ev->data.control.value);
            if(controller == 0)
              instance->pendingBankMSB = ev->data.control.value;

            else
              if(controller == 32)
                instance->pendingBankLSB = ev->data.control.value;

              else
                if(controller >= 1 && !(controller >= 128))
                {
                  signed long int controlIn = instance->controllerMap[(signed long int)controller];
                  if(controlIn >= 0l)
                    setControl(instance, controlIn, ev);

                  else
                  {
                    instanceEventBuffers[(signed long int)i][(signed long int)instanceEventCounts[(signed long int)i]] = *ev;
                    instanceEventCounts[(signed long int)i] = instanceEventCounts[(signed long int)i] + 1ul;
                  }
                }

          }

          else
            if((signed int)ev->type == 11)
            {
              instance->pendingProgramChange = ev->data.control.value;
              instance->uiNeedsProgramUpdate = 1;
            }

            else
            {
              instanceEventBuffers[(signed long int)i][(signed long int)instanceEventCounts[(signed long int)i]] = *ev;
              instanceEventCounts[(signed long int)i] = instanceEventCounts[(signed long int)i] + 1ul;
            }
          if(instanceEventCounts[(signed long int)i] == 1024ul)
            have_full_midi_buffer = 1;

          instance->midi_activity_tick = main_timeout_tick;
          if(ev->dest.client == 0)
            instance = instance->channel_next_instance;

          else
            break;
        }
        if(!(have_full_midi_buffer == 0))
          break;

      }
    }

  }
  i = 0;
  for( ; !(i >= instance_count); i = i + 1)
  {
    instance = &instances[(signed long int)i];
    if(instance->pendingProgramChange >= 0)
    {
      signed int pc = instance->pendingProgramChange;
      signed int msb = instance->pendingBankMSB;
      signed int lsb = instance->pendingBankLSB;
      if(lsb >= 0)
      {
        if(msb >= 0)
          instance->currentBank = (signed long int)(lsb + 128 * msb);

        else
          instance->currentBank = (signed long int)lsb + (signed long int)128 * (instance->currentBank / (signed long int)128);
      }

      else
        if(msb >= 0)
          instance->currentBank = instance->currentBank % (signed long int)128 + (signed long int)(128 * msb);

      instance->currentProgram = (signed long int)pc;
      instance->pendingProgramChange = -1;
      instance->pendingBankMSB = -1;
      instance->pendingBankLSB = -1;
      if(!(instance->plugin->descriptor->select_program == ((void (*)(void *, unsigned long int, unsigned long int))NULL)))
        instance->plugin->descriptor->select_program(instanceHandles[(signed long int)instance->number], (unsigned long int)instance->currentBank, (unsigned long int)instance->currentProgram);

    }

  }
  i = 0;
  for( ; !(i >= insTotal); i = i + 1)
  {
    float *buffer;
    void *return_value_jack_port_get_buffer$1;
    return_value_jack_port_get_buffer$1=jack_port_get_buffer(inputPorts[(signed long int)i], nframes);
    buffer = (float *)return_value_jack_port_get_buffer$1;
    if(!(buffer == pluginInputBuffers[(signed long int)i]))
    {
      pluginInputBuffers[(signed long int)i] = buffer;
      instance = pluginAudioInInstances[(signed long int)i];
      instance->plugin->descriptor->LADSPA_Plugin->connect_port(instanceHandles[(signed long int)instance->number], pluginAudioInPortNumbers[(signed long int)i], buffer);
    }

  }
  i = 0;
  while(!(i >= instance_count))
  {
    instance = &instances[(signed long int)i];
    if(!(instance->plugin->descriptor->run_multiple_synths == ((void (*)(unsigned long int, void **, unsigned long int, struct snd_seq_event **, unsigned long int *))NULL)))
    {
      instance->plugin->descriptor->run_multiple_synths((unsigned long int)instance->plugin->instances, instanceHandles + (signed long int)i, (unsigned long int)nframes, instanceEventBuffers + (signed long int)i, instanceEventCounts + (signed long int)i);
      i = i + instance->plugin->instances;
    }

    else
      if(!(instance->plugin->descriptor->run_synth == ((void (*)(void *, unsigned long int, struct snd_seq_event *, unsigned long int))NULL)))
      {
        instance->plugin->descriptor->run_synth(instanceHandles[(signed long int)i], (unsigned long int)nframes, instanceEventBuffers[(signed long int)i], instanceEventCounts[(signed long int)i]);
        i = i + 1;
      }

      else
        if(!(instance->plugin->descriptor->LADSPA_Plugin->run == ((void (*)(void *, unsigned long int))NULL)))
        {
          instance->plugin->descriptor->LADSPA_Plugin->run(instanceHandles[(signed long int)i], (unsigned long int)nframes);
          i = i + 1;
        }

  }
  i = 0;
  for( ; !(i >= outsTotal); i = i + 1)
  {
    float *audio_callback$$1$$6$$1$$buffer;
    void *return_value_jack_port_get_buffer$2;
    return_value_jack_port_get_buffer$2=jack_port_get_buffer(outputPorts[(signed long int)i], nframes);
    audio_callback$$1$$6$$1$$buffer = (float *)return_value_jack_port_get_buffer$2;
    memcpy((void *)audio_callback$$1$$6$$1$$buffer, (const void *)pluginOutputBuffers[(signed long int)i], (unsigned long int)nframes * sizeof(float) /*4ul*/ );
  }
  return 0;
}

// blinky_class_init
// file eyecandy.c line 52
static void blinky_class_init(struct _BlinkyClass *class)
{
  struct _GtkObjectClass *object_class;
  struct _GtkWidgetClass *widget_class;
  object_class = (struct _GtkObjectClass *)class;
  widget_class = (struct _GtkWidgetClass *)class;
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  blinky_parent_class=gtk_type_class(return_value_gtk_widget_get_type$1);
  object_class->destroy = blinky_destroy;
  widget_class->realize = blinky_realize;
  widget_class->expose_event = blinky_expose;
  widget_class->size_request = blinky_size_request;
  widget_class->size_allocate = blinky_size_allocate;
  col_green.red = (unsigned short int)0;
  col_green.green = (unsigned short int)0xFFFF;
  col_green.blue = (unsigned short int)0;
  struct _GdkColormap *return_value_gdk_colormap_get_system$2;
  return_value_gdk_colormap_get_system$2=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system$2, &col_green);
  col_darkgreen.red = (unsigned short int)0;
  col_darkgreen.green = (unsigned short int)0x5555;
  col_darkgreen.blue = (unsigned short int)0;
  struct _GdkColormap *return_value_gdk_colormap_get_system$3;
  return_value_gdk_colormap_get_system$3=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system$3, &col_darkgreen);
}

// blinky_class_intern_init
// file eyecandy.c line 49
static void blinky_class_intern_init(void *klass)
{
  blinky_parent_class=g_type_class_peek_parent(klass);
  if(!(Blinky_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &Blinky_private_offset);

  blinky_class_init((struct _BlinkyClass *)klass);
}

// blinky_destroy
// file eyecandy.c line 98
static void blinky_destroy(struct _GtkObject *object)
{
  struct _Blinky *blinky;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(object == ((struct _GtkObject *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_destroy", "object != NULL");
      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$4;
  do
  {
    signed int blinky_destroy$$1$$2$$1$$_g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)object;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$3 = __r;
    if(!(tmp_statement_expression$3 == 0))
      blinky_destroy$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      blinky_destroy$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = blinky_destroy$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_destroy", "IS_BLINKY(object)");
      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_blinky_get_type$5;
  return_value_blinky_get_type$5=blinky_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_blinky_get_type$5);
  blinky = (struct _Blinky *)return_value_g_type_check_instance_cast$6;
  unsigned long int return_value_gtk_object_get_type$9;
  return_value_gtk_object_get_type$9=gtk_object_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast$10;
  return_value_g_type_check_class_cast$10=g_type_check_class_cast((struct _GTypeClass *)blinky_parent_class, return_value_gtk_object_get_type$9);
  unsigned long int return_value_gtk_object_get_type$7;
  struct _GTypeClass *return_value_g_type_check_class_cast$8;
  if(!(((struct _GtkObjectClass *)return_value_g_type_check_class_cast$10)->destroy == ((void (*)(struct _GtkObject *))NULL)))
  {
    return_value_gtk_object_get_type$7=gtk_object_get_type();
    return_value_g_type_check_class_cast$8=g_type_check_class_cast((struct _GTypeClass *)blinky_parent_class, return_value_gtk_object_get_type$7);
    ((struct _GtkObjectClass *)return_value_g_type_check_class_cast$8)->destroy(object);
  }


__CPROVER_DUMP_L15:
  ;
}

// blinky_expose
// file eyecandy.c line 194
static signed int blinky_expose(struct _GtkWidget *widget, struct _GdkEventExpose *event)
{
  gdk_window_clear_area(widget->window, 0, 0, widget->allocation.width, widget->allocation.height);
  if(blinky_style == ((struct _GtkStyle *)NULL))
  {
    blinky_style=gtk_style_new();
    blinky_style->fg_gc[(signed long int)GTK_STATE_NORMAL]=gdk_gc_new(widget->window);
  }

  unsigned long int return_value_blinky_get_type$1;
  return_value_blinky_get_type$1=blinky_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_blinky_get_type$1);
  if(!(((struct _Blinky *)return_value_g_type_check_instance_cast$2)->state == 0u))
    gdk_gc_set_foreground(blinky_style->fg_gc[(signed long int)GTK_STATE_NORMAL], &col_green);

  else
    gdk_gc_set_foreground(blinky_style->fg_gc[(signed long int)GTK_STATE_NORMAL], &col_darkgreen);
  gdk_draw_rectangle(widget->window, blinky_style->fg_gc[(signed long int)widget->state], (signed int)!(0 != 0), 0, 0, widget->allocation.width, widget->allocation.height);
  return 0;
}

// blinky_get_state
// file eyecandy.c line 114
unsigned int blinky_get_state(struct _Blinky *blinky)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int blinky_get_state$$1$$1$$1$$_g_boolean_var_;
    if(!(blinky == ((struct _Blinky *)NULL)))
      blinky_get_state$$1$$1$$1$$_g_boolean_var_ = 1;

    else
      blinky_get_state$$1$$1$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$1 = blinky_get_state$$1$$1$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_get_state", "blinky != NULL");
      return (unsigned int)0;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$4;
  do
  {
    signed int _g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)blinky;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$3 = __r;
    if(!(tmp_statement_expression$3 == 0))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_get_state", "IS_BLINKY(blinky)");
      return (unsigned int)0;
    }

  }
  while((_Bool)0);
  return blinky->state;
}

// blinky_get_type
// file eyecandy.c line 49
unsigned long int blinky_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8$5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("Blinky");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_widget_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _BlinkyClass) /*720ul*/ , (void (*)(void *, void *))blinky_class_intern_init, (unsigned int)sizeof(struct _Blinky) /*104ul*/ , (void (*)(struct _GTypeInstance *, void *))blinky_init, (enum anonymous$25)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// blinky_init
// file eyecandy.c line 82
static void blinky_init(struct _Blinky *blinky)
{
  blinky->state = (unsigned int)0;
}

// blinky_new
// file eyecandy.c line 88
struct _GtkWidget * blinky_new(unsigned int state)
{
  struct _Blinky *blinky;
  unsigned long int return_value_blinky_get_type$1;
  return_value_blinky_get_type$1=blinky_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_blinky_get_type$1, (const char *)(void *)0);
  blinky = (struct _Blinky *)return_value_g_object_new$2;
  blinky_set_state(blinky, state);
  unsigned long int return_value_gtk_widget_get_type$3;
  return_value_gtk_widget_get_type$3=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)blinky, return_value_gtk_widget_get_type$3);
  return (struct _GtkWidget *)return_value_g_type_check_instance_cast$4;
}

// blinky_realize
// file eyecandy.c line 134
static void blinky_realize(struct _GtkWidget *widget)
{
  struct _Blinky *blinky;
  struct _GdkWindowAttr attributes;
  signed int attributes_mask;
  signed int tmp_statement_expression$1;
  do
  {
    signed int blinky_realize$$1$$1$$1$$_g_boolean_var_;
    if(!(widget == ((struct _GtkWidget *)NULL)))
      blinky_realize$$1$$1$$1$$_g_boolean_var_ = 1;

    else
      blinky_realize$$1$$1$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$1 = blinky_realize$$1$$1$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_realize", "widget != NULL");
      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$4;
  do
  {
    signed int _g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)widget;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$3 = __r;
    if(!(tmp_statement_expression$3 == 0))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_realize", "IS_BLINKY(widget)");
      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value_gtk_object_get_type$5;
    return_value_gtk_object_get_type$5=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_object_get_type$5);
    ((struct _GtkObject *)return_value_g_type_check_instance_cast$6)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast$6)->flags | (unsigned int)64;
  }
  while((_Bool)0);
  unsigned long int return_value_blinky_get_type$7;
  return_value_blinky_get_type$7=blinky_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_blinky_get_type$7);
  blinky = (struct _Blinky *)return_value_g_type_check_instance_cast$8;
  attributes.x = widget->allocation.x;
  attributes.y = widget->allocation.y;
  attributes.width = widget->allocation.width;
  attributes.height = widget->allocation.height;
  attributes.wclass = (enum anonymous$44)GDK_INPUT_OUTPUT;
  attributes.window_type = (enum anonymous$45)GDK_WINDOW_CHILD;
  signed int return_value_gtk_widget_get_events$9;
  return_value_gtk_widget_get_events$9=gtk_widget_get_events(widget);
  attributes.event_mask = return_value_gtk_widget_get_events$9 | 2;
  attributes.visual=gtk_widget_get_visual(widget);
  attributes.colormap=gtk_widget_get_colormap(widget);
  attributes_mask = 4 | 8 | 64 | 32;
  widget->window=gdk_window_new(widget->parent->window, &attributes, attributes_mask);
  widget->style=gtk_style_attach(widget->style, widget->window);
  gdk_window_set_user_data(widget->window, (void *)widget);
  gtk_style_set_background(widget->style, widget->window, (enum anonymous$49)GTK_STATE_ACTIVE);

__CPROVER_DUMP_L15:
  ;
}

// blinky_set_state
// file eyecandy.c line 123
void blinky_set_state(struct _Blinky *blinky, unsigned int state)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(blinky == ((struct _Blinky *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_set_state", "blinky != NULL");
      goto __CPROVER_DUMP_L14;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$4;
  do
  {
    signed int blinky_set_state$$1$$2$$1$$_g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)blinky;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$3 = __r;
    if(!(tmp_statement_expression$3 == 0))
      blinky_set_state$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      blinky_set_state$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = blinky_set_state$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_set_state", "IS_BLINKY(blinky)");
      goto __CPROVER_DUMP_L14;
    }

  }
  while((_Bool)0);
  blinky->state = state;
  blinky_update(blinky);

__CPROVER_DUMP_L14:
  ;
}

// blinky_size_allocate
// file eyecandy.c line 176
static void blinky_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation)
{
  struct _Blinky *blinky;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(widget == ((struct _GtkWidget *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_size_allocate", "widget != NULL");
      goto __CPROVER_DUMP_L19;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$4;
  do
  {
    signed int blinky_size_allocate$$1$$2$$1$$_g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)widget;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$3 = __r;
    if(!(tmp_statement_expression$3 == 0))
      blinky_size_allocate$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      blinky_size_allocate$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = blinky_size_allocate$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_size_allocate", "IS_BLINKY(widget)");
      goto __CPROVER_DUMP_L19;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression$5;
  do
  {
    signed int blinky_size_allocate$$1$$3$$1$$_g_boolean_var_;
    if(!(allocation == ((struct _GdkRectangle *)NULL)))
      blinky_size_allocate$$1$$3$$1$$_g_boolean_var_ = 1;

    else
      blinky_size_allocate$$1$$3$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$5 = blinky_size_allocate$$1$$3$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$5 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_size_allocate", "allocation != NULL");
      goto __CPROVER_DUMP_L19;
    }

  }
  while((_Bool)0);
  widget->allocation = *allocation;
  unsigned long int return_value_gtk_object_get_type$8;
  return_value_gtk_object_get_type$8=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_object_get_type$8);
  if(!((64u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$9)->flags) == 0u))
  {
    unsigned long int return_value_blinky_get_type$6;
    return_value_blinky_get_type$6=blinky_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_blinky_get_type$6);
    blinky = (struct _Blinky *)return_value_g_type_check_instance_cast$7;
    gdk_window_move_resize(widget->window, allocation->x, allocation->y, allocation->width, allocation->height);
  }


__CPROVER_DUMP_L19:
  ;
}

// blinky_size_request
// file eyecandy.c line 169
static void blinky_size_request(struct _GtkWidget *widget, struct _GtkRequisition *requisition)
{
  requisition->width = 4;
  requisition->height = 16;
}

// blinky_update
// file eyecandy.c line 219
static void blinky_update(struct _Blinky *blinky)
{
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)blinky, return_value_gtk_widget_get_type$1);
  gtk_widget_draw((struct _GtkWidget *)return_value_g_type_check_instance_cast$2, (const struct _GdkRectangle *)(void *)0);
}

// copy_configure_items
// file ghostess.c line 853
void copy_configure_items(struct _instance_template_t *temp, struct _d3h_instance_t *inst)
{
  struct _configure_item_t *item = temp->configure_items;
  struct _configure_item_t *newitem;
  while(!(item == ((struct _configure_item_t *)NULL)))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct _configure_item_t) /*24ul*/ );
    newitem = (struct _configure_item_t *)return_value_malloc$1;
    newitem->next = inst->configure_items;
    inst->configure_items = newitem;
    char *return_value___strdup$2;
    return_value___strdup$2=__strdup(item->key);
    newitem->key = return_value___strdup$2;
    char *return_value___strdup$3;
    return_value___strdup$3=__strdup(item->value);
    newitem->value = return_value___strdup$3;
    item = item->next;
  }
}

// copy_initial_port_set
// file ghostess.c line 737
static void copy_initial_port_set(struct _instance_template_t *temp, struct _d3h_instance_t *inst)
{
  unsigned long int port_count = inst->plugin->descriptor->LADSPA_Plugin->PortCount;
  unsigned long int number_set = temp->ports.highest_set + (unsigned long int)1;
  inst->have_initial_values = 1;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc(sizeof(signed int) /*4ul*/ , port_count);
  inst->initial_value_set = (signed int *)return_value_calloc$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(float) /*4ul*/  * port_count);
  inst->initial_value = (float *)return_value_malloc$2;
  memcpy((void *)inst->initial_value_set, (const void *)temp->ports.set, sizeof(signed int) /*4ul*/  * number_set);
  memcpy((void *)inst->initial_value, (const void *)temp->ports.value, sizeof(float) /*4ul*/  * number_set);
}

// create_about_window
// file gui_interface.c line 294
void create_about_window(const char *tag)
{
  struct _GtkWidget *vbox2;
  struct _GtkWidget *closeabout;
  about_window=gtk_window_new((enum anonymous$16)GTK_WINDOW_TOPLEVEL);
  unsigned long int return_value_gtk_object_get_type$1;
  return_value_gtk_object_get_type$1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type$1);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast$2, "about_window", (void *)about_window);
  unsigned long int return_value_gtk_window_get_type$3;
  return_value_gtk_window_get_type$3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_window_get_type$3);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, "About ghostess");
  vbox2=gtk_vbox_new(0, 0);
  gtk_widget_ref(vbox2);
  unsigned long int return_value_gtk_object_get_type$5;
  return_value_gtk_object_get_type$5=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type$5);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$6, "vbox2", (void *)vbox2, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(vbox2);
  unsigned long int return_value_gtk_container_get_type$7;
  return_value_gtk_container_get_type$7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_container_get_type$7);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$8, vbox2);
  about_label=gtk_label_new("Some message\ngoes here");
  gtk_widget_ref(about_label);
  unsigned long int return_value_gtk_object_get_type$9;
  return_value_gtk_object_get_type$9=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type$9);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$10, "about_label", (void *)about_label, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(about_label);
  unsigned long int return_value_gtk_box_get_type$11;
  return_value_gtk_box_get_type$11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type$11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$12, about_label, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_label_get_type$13;
  return_value_gtk_label_get_type$13=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)about_label, return_value_gtk_label_get_type$13);
  gtk_label_set_line_wrap((struct _GtkLabel *)return_value_g_type_check_instance_cast$14, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_label_get_type$15;
  return_value_gtk_label_get_type$15=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)about_label, return_value_gtk_label_get_type$15);
  gtk_label_set_justify((struct _GtkLabel *)return_value_g_type_check_instance_cast$16, (enum anonymous$20)GTK_JUSTIFY_CENTER);
  unsigned long int return_value_gtk_misc_get_type$17;
  return_value_gtk_misc_get_type$17=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)about_label, return_value_gtk_misc_get_type$17);
  gtk_misc_set_padding((struct _GtkMisc *)return_value_g_type_check_instance_cast$18, 5, 5);
  closeabout=gtk_button_new_with_label("Dismiss");
  gtk_widget_ref(closeabout);
  unsigned long int return_value_gtk_object_get_type$19;
  return_value_gtk_object_get_type$19=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type$19);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$20, "closeabout", (void *)closeabout, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(closeabout);
  unsigned long int return_value_gtk_box_get_type$21;
  return_value_gtk_box_get_type$21=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type$21);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$22, closeabout, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_object_get_type$23;
  return_value_gtk_object_get_type$23=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type$23);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$24, "destroy", (void (*)(void))gtk_main_quit, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$25;
  return_value_gtk_object_get_type$25=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type$25);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$26, "delete_event", (void (*)(void))on_delete_event_wrapper, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)on_about_dismiss, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$27;
  return_value_gtk_object_get_type$27=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)closeabout, return_value_gtk_object_get_type$27);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$28, "clicked", (void (*)(void))on_about_dismiss, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
}

// create_file_selection
// file gui_interface.c line 256
void create_file_selection(const char *tag)
{
  char *title;
  struct _GtkWidget *ok_button;
  struct _GtkWidget *cancel_button;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(tag);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(return_value_strlen$1 + (unsigned long int)22);
  title = (char *)return_value_malloc$2;
  sprintf(title, "%s - File Selection", tag);
  file_selection=gtk_file_selection_new(title);
  free((void *)title);
  unsigned long int return_value_gtk_object_get_type$3;
  return_value_gtk_object_get_type$3=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type$3);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast$4, "file_selection", (void *)file_selection);
  unsigned long int return_value_gtk_container_get_type$5;
  return_value_gtk_container_get_type$5=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_container_get_type$5);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$6, (unsigned int)10);
  unsigned long int return_value_gtk_window_get_type$7;
  return_value_gtk_window_get_type$7=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_window_get_type$7);
  ((struct _GtkWindow *)return_value_g_type_check_instance_cast$8)->type = (unsigned int)GTK_WINDOW_TOPLEVEL;
  unsigned long int return_value_gtk_file_selection_get_type$9;
  return_value_gtk_file_selection_get_type$9=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type$9);
  ok_button = ((struct _GtkFileSelection *)return_value_g_type_check_instance_cast$10)->ok_button;
  unsigned long int return_value_gtk_object_get_type$11;
  return_value_gtk_object_get_type$11=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type$11);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast$12, "ok_button", (void *)ok_button);
  gtk_widget_show(ok_button);
  do
  {
    unsigned long int return_value_gtk_object_get_type$13;
    return_value_gtk_object_get_type$13=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)ok_button, return_value_gtk_object_get_type$13);
    ((struct _GtkObject *)return_value_g_type_check_instance_cast$14)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast$14)->flags | (unsigned int)8192;
  }
  while((_Bool)0);
  unsigned long int return_value_gtk_file_selection_get_type$15;
  return_value_gtk_file_selection_get_type$15=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type$15);
  cancel_button = ((struct _GtkFileSelection *)return_value_g_type_check_instance_cast$16)->cancel_button;
  unsigned long int return_value_gtk_object_get_type$17;
  return_value_gtk_object_get_type$17=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type$17);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast$18, "cancel_button", (void *)cancel_button);
  gtk_widget_show(cancel_button);
  do
  {
    unsigned long int return_value_gtk_object_get_type$19;
    return_value_gtk_object_get_type$19=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
    return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)cancel_button, return_value_gtk_object_get_type$19);
    ((struct _GtkObject *)return_value_g_type_check_instance_cast$20)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast$20)->flags | (unsigned int)8192;
  }
  while((_Bool)0);
  unsigned long int return_value_gtk_object_get_type$21;
  return_value_gtk_object_get_type$21=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type$21);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$22, "destroy", (void (*)(void))gtk_main_quit, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$23;
  return_value_gtk_object_get_type$23=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type$23);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$24, "delete_event", (void (*)(void))on_delete_event_wrapper, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)on_file_selection_cancel, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_file_selection_get_type$25;
  return_value_gtk_file_selection_get_type$25=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type$25);
  unsigned long int return_value_gtk_object_get_type$27;
  return_value_gtk_object_get_type$27=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkFileSelection *)return_value_g_type_check_instance_cast$26)->ok_button, return_value_gtk_object_get_type$27);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$28, "clicked", (void (*)(void))on_file_selection_ok, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_file_selection_get_type$29;
  return_value_gtk_file_selection_get_type$29=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type$29);
  unsigned long int return_value_gtk_object_get_type$31;
  return_value_gtk_object_get_type$31=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
  return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkFileSelection *)return_value_g_type_check_instance_cast$30)->cancel_button, return_value_gtk_object_get_type$31);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$32, "clicked", (void (*)(void))on_file_selection_cancel, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
}

// create_main_window
// file gui_interface.c line 59
void create_main_window(const char *tag, signed int instance_count)
{
  struct _GtkWidget *vbox1;
  struct _GtkWidget *menubar1;
  struct _GtkWidget *file1;
  struct _GtkWidget *file1_menu;
  struct _GtkWidget *menu_save;
  struct _GtkWidget *menu_patchlist;
  struct _GtkWidget *separator1;
  struct _GtkWidget *menu_quit;
  struct _GtkWidget *help1;
  struct _GtkWidget *help1_menu;
  struct _GtkWidget *menu_about;
  struct _GtkWidget *scrolledwindow1;
  struct _GtkWidget *viewport1;
  struct _GtkAccelGroup *accel_group;
  accel_group=gtk_accel_group_new();
  main_window=gtk_window_new((enum anonymous$16)GTK_WINDOW_TOPLEVEL);
  unsigned long int return_value_gtk_object_get_type$1;
  return_value_gtk_object_get_type$1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$1);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast$2, "main_window", (void *)main_window);
  unsigned long int return_value_gtk_window_get_type$3;
  return_value_gtk_window_get_type$3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_window_get_type$3);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, tag);
  vbox1=gtk_vbox_new(0, 0);
  gtk_widget_ref(vbox1);
  unsigned long int return_value_gtk_object_get_type$5;
  return_value_gtk_object_get_type$5=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$5);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$6, "vbox1", (void *)vbox1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(vbox1);
  unsigned long int return_value_gtk_container_get_type$7;
  return_value_gtk_container_get_type$7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_container_get_type$7);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$8, vbox1);
  menubar1=gtk_menu_bar_new();
  gtk_widget_ref(menubar1);
  unsigned long int return_value_gtk_object_get_type$9;
  return_value_gtk_object_get_type$9=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$9);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$10, "menubar1", (void *)menubar1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menubar1);
  unsigned long int return_value_gtk_box_get_type$11;
  return_value_gtk_box_get_type$11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type$11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$12, menubar1, 0, 0, (unsigned int)0);
  file1=gtk_menu_item_new_with_label("File");
  gtk_widget_ref(file1);
  unsigned long int return_value_gtk_object_get_type$13;
  return_value_gtk_object_get_type$13=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$13);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$14, "file1", (void *)file1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(file1);
  unsigned long int return_value_gtk_container_get_type$15;
  return_value_gtk_container_get_type$15=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)menubar1, return_value_gtk_container_get_type$15);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$16, file1);
  file1_menu=gtk_menu_new();
  gtk_widget_ref(file1_menu);
  unsigned long int return_value_gtk_object_get_type$17;
  return_value_gtk_object_get_type$17=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$17);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$18, "file1_menu", (void *)file1_menu, (void (*)(void *))gtk_widget_unref);
  unsigned long int return_value_gtk_menu_item_get_type$19;
  return_value_gtk_menu_item_get_type$19=gtk_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)file1, return_value_gtk_menu_item_get_type$19);
  gtk_menu_item_set_submenu((struct _GtkMenuItem *)return_value_g_type_check_instance_cast$20, file1_menu);
  menu_save=gtk_menu_item_new_with_label("Save Configuration...");
  gtk_widget_ref(menu_save);
  unsigned long int return_value_gtk_object_get_type$21;
  return_value_gtk_object_get_type$21=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$21);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$22, "menu_save", (void *)menu_save, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menu_save);
  unsigned long int return_value_gtk_container_get_type$23;
  return_value_gtk_container_get_type$23=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)file1_menu, return_value_gtk_container_get_type$23);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$24, menu_save);
  gtk_widget_add_accelerator(menu_save, "activate", accel_group, (unsigned int)0x053, (enum anonymous$23)GDK_CONTROL_MASK, (enum anonymous$24)GTK_ACCEL_VISIBLE);
  menu_patchlist=gtk_menu_item_new_with_label("Patchlist Export for Freewheeling...");
  gtk_widget_ref(menu_patchlist);
  unsigned long int return_value_gtk_object_get_type$25;
  return_value_gtk_object_get_type$25=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$25);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$26, "menu_patchlist", (void *)menu_patchlist, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menu_patchlist);
  unsigned long int return_value_gtk_container_get_type$27;
  return_value_gtk_container_get_type$27=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)file1_menu, return_value_gtk_container_get_type$27);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$28, menu_patchlist);
  gtk_widget_add_accelerator(menu_patchlist, "activate", accel_group, (unsigned int)0x050, (enum anonymous$23)GDK_CONTROL_MASK, (enum anonymous$24)GTK_ACCEL_VISIBLE);
  separator1=gtk_menu_item_new();
  gtk_widget_ref(separator1);
  unsigned long int return_value_gtk_object_get_type$29;
  return_value_gtk_object_get_type$29=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$29);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$30, "separator1", (void *)separator1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(separator1);
  unsigned long int return_value_gtk_container_get_type$31;
  return_value_gtk_container_get_type$31=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
  return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)file1_menu, return_value_gtk_container_get_type$31);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$32, separator1);
  gtk_widget_set_sensitive(separator1, 0);
  menu_quit=gtk_menu_item_new_with_label("Quit");
  gtk_widget_ref(menu_quit);
  unsigned long int return_value_gtk_object_get_type$33;
  return_value_gtk_object_get_type$33=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
  return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$33);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$34, "menu_quit", (void *)menu_quit, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menu_quit);
  unsigned long int return_value_gtk_container_get_type$35;
  return_value_gtk_container_get_type$35=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)file1_menu, return_value_gtk_container_get_type$35);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$36, menu_quit);
  gtk_widget_add_accelerator(menu_quit, "activate", accel_group, (unsigned int)0x051, (enum anonymous$23)GDK_CONTROL_MASK, (enum anonymous$24)GTK_ACCEL_VISIBLE);
  help1=gtk_menu_item_new_with_label("About");
  gtk_widget_ref(help1);
  unsigned long int return_value_gtk_object_get_type$37;
  return_value_gtk_object_get_type$37=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
  return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$37);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$38, "help1", (void *)help1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(help1);
  unsigned long int return_value_gtk_container_get_type$39;
  return_value_gtk_container_get_type$39=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
  return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)menubar1, return_value_gtk_container_get_type$39);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$40, help1);
  unsigned long int return_value_gtk_menu_item_get_type$41;
  return_value_gtk_menu_item_get_type$41=gtk_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
  return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)help1, return_value_gtk_menu_item_get_type$41);
  gtk_menu_item_set_right_justified((struct _GtkMenuItem *)return_value_g_type_check_instance_cast$42, (signed int)!(0 != 0));
  help1_menu=gtk_menu_new();
  gtk_widget_ref(help1_menu);
  unsigned long int return_value_gtk_object_get_type$43;
  return_value_gtk_object_get_type$43=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
  return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$43);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$44, "help1_menu", (void *)help1_menu, (void (*)(void *))gtk_widget_unref);
  unsigned long int return_value_gtk_menu_item_get_type$45;
  return_value_gtk_menu_item_get_type$45=gtk_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$46;
  return_value_g_type_check_instance_cast$46=g_type_check_instance_cast((struct _GTypeInstance *)help1, return_value_gtk_menu_item_get_type$45);
  gtk_menu_item_set_submenu((struct _GtkMenuItem *)return_value_g_type_check_instance_cast$46, help1_menu);
  menu_about=gtk_menu_item_new_with_label("About ghostess");
  gtk_widget_ref(menu_about);
  unsigned long int return_value_gtk_object_get_type$47;
  return_value_gtk_object_get_type$47=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
  return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$47);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$48, "menu_about", (void *)menu_about, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menu_about);
  unsigned long int return_value_gtk_container_get_type$49;
  return_value_gtk_container_get_type$49=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$50;
  return_value_g_type_check_instance_cast$50=g_type_check_instance_cast((struct _GTypeInstance *)help1_menu, return_value_gtk_container_get_type$49);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$50, menu_about);
  plugin_hbox=gtk_hbox_new(0, 0);
  gtk_widget_ref(plugin_hbox);
  unsigned long int return_value_gtk_object_get_type$51;
  return_value_gtk_object_get_type$51=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$52;
  return_value_g_type_check_instance_cast$52=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$51);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$52, "plugin_hbox", (void *)plugin_hbox, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(plugin_hbox);
  if(instance_count >= 6)
  {
    scrolledwindow1=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
    gtk_widget_ref(scrolledwindow1);
    unsigned long int return_value_gtk_object_get_type$53;
    return_value_gtk_object_get_type$53=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
    return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$53);
    gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$54, "scrolledwindow1", (void *)scrolledwindow1, (void (*)(void *))gtk_widget_unref);
    gtk_widget_show(scrolledwindow1);
    unsigned long int return_value_gtk_scrolled_window_get_type$55;
    return_value_gtk_scrolled_window_get_type$55=gtk_scrolled_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$56;
    return_value_g_type_check_instance_cast$56=g_type_check_instance_cast((struct _GTypeInstance *)scrolledwindow1, return_value_gtk_scrolled_window_get_type$55);
    gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$56, (enum anonymous$5)GTK_POLICY_AUTOMATIC, (enum anonymous$5)GTK_POLICY_NEVER);
    unsigned long int return_value_gtk_scrolled_window_get_type$57;
    return_value_gtk_scrolled_window_get_type$57=gtk_scrolled_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$58;
    return_value_g_type_check_instance_cast$58=g_type_check_instance_cast((struct _GTypeInstance *)scrolledwindow1, return_value_gtk_scrolled_window_get_type$57);
    unsigned long int return_value_gtk_range_get_type$59;
    return_value_gtk_range_get_type$59=gtk_range_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$60;
    return_value_g_type_check_instance_cast$60=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$58)->vscrollbar, return_value_gtk_range_get_type$59);
    gtk_range_set_update_policy((struct _GtkRange *)return_value_g_type_check_instance_cast$60, (enum anonymous$3)GTK_POLICY_AUTOMATIC);
    unsigned long int return_value_gtk_box_get_type$61;
    return_value_gtk_box_get_type$61=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$62;
    return_value_g_type_check_instance_cast$62=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type$61);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$62, scrolledwindow1, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
    unsigned long int return_value_gtk_widget_get_type$63;
    return_value_gtk_widget_get_type$63=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$64;
    return_value_g_type_check_instance_cast$64=g_type_check_instance_cast((struct _GTypeInstance *)scrolledwindow1, return_value_gtk_widget_get_type$63);
    gtk_widget_set_size_request((struct _GtkWidget *)return_value_g_type_check_instance_cast$64, 400, -1);
    viewport1=gtk_viewport_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
    gtk_widget_ref(viewport1);
    unsigned long int return_value_gtk_object_get_type$65;
    return_value_gtk_object_get_type$65=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$66;
    return_value_g_type_check_instance_cast$66=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$65);
    gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$66, "viewport1", (void *)viewport1, (void (*)(void *))gtk_widget_unref);
    gtk_widget_show(viewport1);
    unsigned long int return_value_gtk_container_get_type$67;
    return_value_gtk_container_get_type$67=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$68;
    return_value_g_type_check_instance_cast$68=g_type_check_instance_cast((struct _GTypeInstance *)scrolledwindow1, return_value_gtk_container_get_type$67);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$68, viewport1);
    unsigned long int return_value_gtk_container_get_type$69;
    return_value_gtk_container_get_type$69=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$70;
    return_value_g_type_check_instance_cast$70=g_type_check_instance_cast((struct _GTypeInstance *)viewport1, return_value_gtk_container_get_type$69);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$70, plugin_hbox);
  }

  else
  {
    unsigned long int return_value_gtk_box_get_type$71;
    return_value_gtk_box_get_type$71=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$72;
    return_value_g_type_check_instance_cast$72=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type$71);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$72, plugin_hbox, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  }
  unsigned long int return_value_gtk_object_get_type$73;
  return_value_gtk_object_get_type$73=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$74;
  return_value_g_type_check_instance_cast$74=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$73);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$74, "destroy", (void (*)(void))gtk_main_quit, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$75;
  return_value_gtk_object_get_type$75=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$76;
  return_value_g_type_check_instance_cast$76=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type$75);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$76, "delete_event", (void (*)(void))on_delete_event_wrapper, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)on_menu_quit_activate, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$77;
  return_value_gtk_object_get_type$77=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$78;
  return_value_g_type_check_instance_cast$78=g_type_check_instance_cast((struct _GTypeInstance *)menu_save, return_value_gtk_object_get_type$77);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$78, "activate", (void (*)(void))on_menu_save_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$79;
  return_value_gtk_object_get_type$79=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$80;
  return_value_g_type_check_instance_cast$80=g_type_check_instance_cast((struct _GTypeInstance *)menu_patchlist, return_value_gtk_object_get_type$79);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$80, "activate", (void (*)(void))on_menu_patchlist_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$81;
  return_value_gtk_object_get_type$81=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$82;
  return_value_g_type_check_instance_cast$82=g_type_check_instance_cast((struct _GTypeInstance *)menu_quit, return_value_gtk_object_get_type$81);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$82, "activate", (void (*)(void))on_menu_quit_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$83;
  return_value_gtk_object_get_type$83=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$84;
  return_value_g_type_check_instance_cast$84=g_type_check_instance_cast((struct _GTypeInstance *)menu_about, return_value_gtk_object_get_type$83);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$84, "activate", (void (*)(void))on_menu_about_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_window_get_type$85;
  return_value_gtk_window_get_type$85=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$86;
  return_value_g_type_check_instance_cast$86=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_window_get_type$85);
  gtk_window_add_accel_group((struct _GtkWindow *)return_value_g_type_check_instance_cast$86, accel_group);
}

// create_notice_window
// file gui_interface.c line 338
void create_notice_window(const char *tag)
{
  char *title;
  struct _GtkWidget *vbox3;
  struct _GtkWidget *hbox1;
  struct _GtkWidget *notice_dismiss;
  notice_window=gtk_window_new((enum anonymous$16)GTK_WINDOW_TOPLEVEL);
  unsigned long int return_value_gtk_object_get_type$1;
  return_value_gtk_object_get_type$1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type$1);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast$2, "notice_window", (void *)notice_window);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(tag);
  void *return_value_malloc$4;
  return_value_malloc$4=malloc(return_value_strlen$3 + (unsigned long int)8);
  title = (char *)return_value_malloc$4;
  sprintf(title, "%s Notice", tag);
  unsigned long int return_value_gtk_window_get_type$5;
  return_value_gtk_window_get_type$5=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_window_get_type$5);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$6, title);
  free((void *)title);
  unsigned long int return_value_gtk_window_get_type$7;
  return_value_gtk_window_get_type$7=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_window_get_type$7);
  gtk_window_set_position((struct _GtkWindow *)return_value_g_type_check_instance_cast$8, (enum anonymous$17)GTK_WIN_POS_MOUSE);
  unsigned long int return_value_gtk_window_get_type$9;
  return_value_gtk_window_get_type$9=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_window_get_type$9);
  gtk_window_set_modal((struct _GtkWindow *)return_value_g_type_check_instance_cast$10, (signed int)!(0 != 0));
  vbox3=gtk_vbox_new(0, 0);
  gtk_widget_ref(vbox3);
  unsigned long int return_value_gtk_object_get_type$11;
  return_value_gtk_object_get_type$11=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type$11);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$12, "vbox3", (void *)vbox3, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(vbox3);
  unsigned long int return_value_gtk_container_get_type$13;
  return_value_gtk_container_get_type$13=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_container_get_type$13);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$14, vbox3);
  notice_label_1=gtk_label_new("Some message\ngoes here");
  gtk_widget_ref(notice_label_1);
  unsigned long int return_value_gtk_object_get_type$15;
  return_value_gtk_object_get_type$15=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type$15);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$16, "notice_label_1", (void *)notice_label_1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(notice_label_1);
  unsigned long int return_value_gtk_box_get_type$17;
  return_value_gtk_box_get_type$17=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)vbox3, return_value_gtk_box_get_type$17);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$18, notice_label_1, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_label_get_type$19;
  return_value_gtk_label_get_type$19=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_1, return_value_gtk_label_get_type$19);
  gtk_label_set_line_wrap((struct _GtkLabel *)return_value_g_type_check_instance_cast$20, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_misc_get_type$21;
  return_value_gtk_misc_get_type$21=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_1, return_value_gtk_misc_get_type$21);
  gtk_misc_set_padding((struct _GtkMisc *)return_value_g_type_check_instance_cast$22, 10, 5);
  notice_label_2=gtk_label_new("more text\ngoes here");
  gtk_widget_ref(notice_label_2);
  unsigned long int return_value_gtk_object_get_type$23;
  return_value_gtk_object_get_type$23=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type$23);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$24, "notice_label_2", (void *)notice_label_2, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(notice_label_2);
  unsigned long int return_value_gtk_box_get_type$25;
  return_value_gtk_box_get_type$25=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)vbox3, return_value_gtk_box_get_type$25);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$26, notice_label_2, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_label_get_type$27;
  return_value_gtk_label_get_type$27=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_2, return_value_gtk_label_get_type$27);
  gtk_label_set_line_wrap((struct _GtkLabel *)return_value_g_type_check_instance_cast$28, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_misc_get_type$29;
  return_value_gtk_misc_get_type$29=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_2, return_value_gtk_misc_get_type$29);
  gtk_misc_set_padding((struct _GtkMisc *)return_value_g_type_check_instance_cast$30, 10, 5);
  hbox1=gtk_hbox_new(0, 0);
  gtk_widget_ref(hbox1);
  unsigned long int return_value_gtk_object_get_type$31;
  return_value_gtk_object_get_type$31=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
  return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type$31);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$32, "hbox1", (void *)hbox1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(hbox1);
  unsigned long int return_value_gtk_box_get_type$33;
  return_value_gtk_box_get_type$33=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
  return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)vbox3, return_value_gtk_box_get_type$33);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$34, hbox1, 0, 0, (unsigned int)0);
  notice_dismiss=gtk_button_new_with_label("Dismiss");
  gtk_widget_ref(notice_dismiss);
  unsigned long int return_value_gtk_object_get_type$35;
  return_value_gtk_object_get_type$35=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type$35);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$36, "notice_dismiss", (void *)notice_dismiss, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(notice_dismiss);
  unsigned long int return_value_gtk_box_get_type$37;
  return_value_gtk_box_get_type$37=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
  return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)hbox1, return_value_gtk_box_get_type$37);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$38, notice_dismiss, (signed int)!(0 != 0), 0, (unsigned int)0);
  unsigned long int return_value_gtk_container_get_type$39;
  return_value_gtk_container_get_type$39=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
  return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)notice_dismiss, return_value_gtk_container_get_type$39);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$40, (unsigned int)7);
  unsigned long int return_value_gtk_object_get_type$41;
  return_value_gtk_object_get_type$41=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
  return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type$41);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$42, "destroy", (void (*)(void))gtk_main_quit, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$43;
  return_value_gtk_object_get_type$43=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
  return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type$43);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$44, "delete_event", (void (*)(void))on_delete_event_wrapper, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)on_notice_dismiss, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$45;
  return_value_gtk_object_get_type$45=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$46;
  return_value_g_type_check_instance_cast$46=g_type_check_instance_cast((struct _GTypeInstance *)notice_dismiss, return_value_gtk_object_get_type$45);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$46, "clicked", (void (*)(void))on_notice_dismiss, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
}

// create_plugin_strip
// file gui_interface.h line 56
struct _plugin_strip * create_plugin_strip(struct _GtkWidget *parent_window, struct _d3h_instance_t *instance)
{
  struct _plugin_strip *ps;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct _plugin_strip) /*56ul*/ );
  ps = (struct _plugin_strip *)return_value_calloc$1;
  struct _GtkWidget *vbox1;
  char buf[12l];
  struct _GtkWidget *hbox1;
  struct _GtkWidget *striplabel1;
  struct _GtkWidget *striplabel2;
  struct _GtkWidget *hbox2;
  ps->instance = instance;
  ps->container=gtk_frame_new((const char *)(void *)0);
  gtk_widget_ref(ps->container);
  unsigned long int return_value_gtk_object_get_type$2;
  return_value_gtk_object_get_type$2=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type$2);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$3, "frame1", (void *)ps->container, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(ps->container);
  unsigned long int return_value_gtk_container_get_type$4;
  return_value_gtk_container_get_type$4=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)ps->container, return_value_gtk_container_get_type$4);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$5, (unsigned int)2);
  unsigned long int return_value_gtk_frame_get_type$6;
  return_value_gtk_frame_get_type$6=gtk_frame_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)ps->container, return_value_gtk_frame_get_type$6);
  gtk_frame_set_shadow_type((struct _GtkFrame *)return_value_g_type_check_instance_cast$7, (enum anonymous$11)GTK_SHADOW_OUT);
  vbox1=gtk_vbox_new(0, 0);
  gtk_widget_ref(vbox1);
  unsigned long int return_value_gtk_object_get_type$8;
  return_value_gtk_object_get_type$8=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type$8);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$9, "vbox1", (void *)vbox1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(vbox1);
  unsigned long int return_value_gtk_container_get_type$10;
  return_value_gtk_container_get_type$10=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)ps->container, return_value_gtk_container_get_type$10);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$11, vbox1);
  hbox1=gtk_hbox_new(0, 0);
  gtk_widget_ref(hbox1);
  unsigned long int return_value_gtk_object_get_type$12;
  return_value_gtk_object_get_type$12=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type$12);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$13, "hbox1", (void *)hbox1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(hbox1);
  unsigned long int return_value_gtk_box_get_type$14;
  return_value_gtk_box_get_type$14=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type$14);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$15, hbox1, 0, 0, (unsigned int)0);
  ps->midi_status=blinky_new((unsigned int)0);
  gtk_widget_ref(ps->midi_status);
  unsigned long int return_value_gtk_object_get_type$16;
  return_value_gtk_object_get_type$16=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type$16);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$17, "midi_status", (void *)ps->midi_status, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(ps->midi_status);
  unsigned long int return_value_gtk_box_get_type$18;
  return_value_gtk_box_get_type$18=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)hbox1, return_value_gtk_box_get_type$18);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$19, ps->midi_status, 0, 0, (unsigned int)1);
  ps->previous_midi_state = 0;
  snprintf(buf, (unsigned long int)12, "Inst %d", instance->id);
  striplabel1=gtk_label_new(buf);
  gtk_widget_ref(striplabel1);
  unsigned long int return_value_gtk_object_get_type$20;
  return_value_gtk_object_get_type$20=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type$20);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$21, "striplabel1", (void *)striplabel1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(striplabel1);
  unsigned long int return_value_gtk_box_get_type$22;
  return_value_gtk_box_get_type$22=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
  return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)hbox1, return_value_gtk_box_get_type$22);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$23, striplabel1, 0, 0, (unsigned int)1);
  snprintf(buf, (unsigned long int)12, "%s", instance->plugin->label);
  striplabel2=gtk_label_new(buf);
  gtk_widget_ref(striplabel2);
  unsigned long int return_value_gtk_object_get_type$24;
  return_value_gtk_object_get_type$24=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type$24);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$25, "striplabel2", (void *)striplabel2, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(striplabel2);
  unsigned long int return_value_gtk_box_get_type$26;
  return_value_gtk_box_get_type$26=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type$26);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$27, striplabel2, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_misc_get_type$28;
  return_value_gtk_misc_get_type$28=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
  return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)striplabel2, return_value_gtk_misc_get_type$28);
  gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast$29, (float)0, (float)0.5);
  unsigned long int return_value_gtk_misc_get_type$30;
  return_value_gtk_misc_get_type$30=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
  return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)striplabel2, return_value_gtk_misc_get_type$30);
  gtk_misc_set_padding((struct _GtkMisc *)return_value_g_type_check_instance_cast$31, 3, 0);
  hbox2=gtk_hbox_new((signed int)!(0 != 0), 0);
  gtk_widget_ref(hbox2);
  unsigned long int return_value_gtk_object_get_type$32;
  return_value_gtk_object_get_type$32=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type$32);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$33, "hbox2", (void *)hbox2, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(hbox2);
  unsigned long int return_value_gtk_box_get_type$34;
  return_value_gtk_box_get_type$34=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$35;
  return_value_g_type_check_instance_cast$35=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type$34);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$35, hbox2, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_container_get_type$36;
  return_value_gtk_container_get_type$36=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
  return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)hbox2, return_value_gtk_container_get_type$36);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$37, (unsigned int)3);
  ps->ui_button=gtk_toggle_button_new_with_label("UI");
  gtk_widget_ref(ps->ui_button);
  unsigned long int return_value_gtk_object_get_type$38;
  return_value_gtk_object_get_type$38=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
  return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type$38);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$39, "ui_button", (void *)ps->ui_button, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(ps->ui_button);
  unsigned long int return_value_gtk_box_get_type$40;
  return_value_gtk_box_get_type$40=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
  return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)hbox2, return_value_gtk_box_get_type$40);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$41, ps->ui_button, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_object_get_type$42;
  return_value_gtk_object_get_type$42=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$43;
  return_value_g_type_check_instance_cast$43=g_type_check_instance_cast((struct _GTypeInstance *)ps->ui_button, return_value_gtk_object_get_type$42);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$43, "toggled", (void (*)(void))on_strip_ui_button_toggled, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)ps, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$44;
  return_value_gtk_object_get_type$44=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$45;
  return_value_g_type_check_instance_cast$45=g_type_check_instance_cast((struct _GTypeInstance *)ps->ui_button, return_value_gtk_object_get_type$44);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$45, "button_press_event", (void (*)(void))on_strip_ui_button_event, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)ps, (void (*)(void *))(void *)0, 0, 0);
  return ps;
}

// create_ui_context_menu
// file gui_interface.c line 222
void create_ui_context_menu(struct _GtkWidget *parent_window)
{
  ui_context_menu=gtk_menu_new();
  gtk_widget_ref(ui_context_menu);
  unsigned long int return_value_gtk_object_get_type$1;
  return_value_gtk_object_get_type$1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type$1);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast$2, "ui_context_menu", (void *)ui_context_menu, (void (*)(void *))gtk_widget_unref);
  ui_context_menu_launch=gtk_menu_item_new_with_label("Launch UI");
  gtk_widget_show(ui_context_menu_launch);
  unsigned long int return_value_gtk_menu_get_type$3;
  return_value_gtk_menu_get_type$3=gtk_menu_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type$3);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenu *)return_value_g_type_check_instance_cast$4, ui_context_menu_launch);
  ui_context_menu_show=gtk_menu_item_new_with_label("Show UI");
  gtk_widget_show(ui_context_menu_show);
  unsigned long int return_value_gtk_menu_get_type$5;
  return_value_gtk_menu_get_type$5=gtk_menu_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type$5);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenu *)return_value_g_type_check_instance_cast$6, ui_context_menu_show);
  ui_context_menu_hide=gtk_menu_item_new_with_label("Hide UI");
  gtk_widget_show(ui_context_menu_hide);
  unsigned long int return_value_gtk_menu_get_type$7;
  return_value_gtk_menu_get_type$7=gtk_menu_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type$7);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenu *)return_value_g_type_check_instance_cast$8, ui_context_menu_hide);
  ui_context_menu_exit=gtk_menu_item_new_with_label("Exit UI");
  gtk_widget_show(ui_context_menu_exit);
  unsigned long int return_value_gtk_menu_get_type$9;
  return_value_gtk_menu_get_type$9=gtk_menu_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type$9);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenu *)return_value_g_type_check_instance_cast$10, ui_context_menu_exit);
  unsigned long int return_value_gtk_object_get_type$11;
  return_value_gtk_object_get_type$11=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu_launch, return_value_gtk_object_get_type$11);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$12, "activate", (void (*)(void))on_ui_context_menu_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$13;
  return_value_gtk_object_get_type$13=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu_show, return_value_gtk_object_get_type$13);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$14, "activate", (void (*)(void))on_ui_context_menu_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)1, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$15;
  return_value_gtk_object_get_type$15=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu_hide, return_value_gtk_object_get_type$15);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$16, "activate", (void (*)(void))on_ui_context_menu_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)2, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$17;
  return_value_gtk_object_get_type$17=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu_exit, return_value_gtk_object_get_type$17);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$18, "activate", (void (*)(void))on_ui_context_menu_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)3, (void (*)(void *))(void *)0, 0, 0);
}

// create_windows
// file gui_interface.h line 58
void create_windows(const char *host_tag, signed int instance_count)
{
  char tag[64l];
  unsigned long int return_value_strlen$8;
  return_value_strlen$8=strlen(host_tag);
  char *return_value_strstr$7;
  if(return_value_strlen$8 == 0ul)
    strcpy(tag, host_name_default);

  else
  {
    return_value_strstr$7=strstr(host_tag, host_name_default);
    if(!(return_value_strstr$7 == ((char *)NULL)))
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(host_tag);
      if(return_value_strlen$2 >= 64ul)
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(host_tag);
        snprintf(tag, (unsigned long int)64, "...%s", (host_tag + (signed long int)return_value_strlen$1) - (signed long int)60);
      }

      else
        strcpy(tag, host_tag);
    }

    else
    {
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(host_name_default);
      unsigned long int return_value_strlen$6;
      return_value_strlen$6=strlen(host_tag);
      if(return_value_strlen$5 + return_value_strlen$6 >= 63ul)
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(host_tag);
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(host_name_default);
        snprintf(tag, (unsigned long int)64, "%s ...%s", host_name_default, (host_tag + (signed long int)return_value_strlen$3 + (signed long int)return_value_strlen$4) - (signed long int)59);
      }

      else
        snprintf(tag, (unsigned long int)64, "%s %s", host_name_default, host_tag);
    }
  }
  create_main_window(tag, instance_count);
  create_ui_context_menu(main_window);
  create_file_selection(tag);
  create_about_window(tag);
  create_notice_window(tag);
}

// display_notice
// file gui_callbacks.c line 324
void display_notice(char *message1, char *message2)
{
  unsigned long int return_value_gtk_label_get_type$1;
  return_value_gtk_label_get_type$1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_1, return_value_gtk_label_get_type$1);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, message1);
  unsigned long int return_value_gtk_label_get_type$3;
  return_value_gtk_label_get_type$3=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_2, return_value_gtk_label_get_type$3);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, message2);
  gtk_widget_show(notice_window);
}

// escape_for_shell
// file ghostess.c line 869
void escape_for_shell(char **p, const char *text)
{
  signed int len;
  signed int i;
  signed int c;
  if(!(*p == ((char *)NULL)))
    free((void *)*p);

  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$2;
  if(text == ((const char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strlen$2=strlen(text);
    len = (signed int)return_value_strlen$2;
    tmp_if_expr$3 = len == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
  {
    char *return_value___strdup$1;
    return_value___strdup$1=__strdup("''");
    *p = return_value___strdup$1;
    goto __CPROVER_DUMP_L17;
  }

  i = 0;
  c = 0;
  for( ; !(i >= len); i = i + 1)
    if((signed int)text[(signed long int)i] == 39)
      c = c + 1;

  if(c == 0)
  {
    void *return_value_malloc$4;
    return_value_malloc$4=malloc((unsigned long int)(len + 3));
    *p = (char *)return_value_malloc$4;
    sprintf(*p, "'%s'", text);
    goto __CPROVER_DUMP_L17;
  }

  void *return_value_malloc$5;
  return_value_malloc$5=malloc((unsigned long int)(len + c * 3 + 3));
  *p = (char *)return_value_malloc$5;
  c = 0;
  signed int tmp_post$6;
  if(!((signed int)*text == 39))
  {
    tmp_post$6 = c;
    c = c + 1;
    (*p)[(signed long int)tmp_post$6] = (char)39;
  }

  i = 0;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  for( ; !(i >= len); i = i + 1)
    if((signed int)text[(signed long int)i] == 39)
    {
      if(!(i == 0))
      {
        tmp_post$7 = c;
        c = c + 1;
        (*p)[(signed long int)tmp_post$7] = (char)39;
      }

      tmp_post$8 = c;
      c = c + 1;
      (*p)[(signed long int)tmp_post$8] = (char)92;
      tmp_post$9 = c;
      c = c + 1;
      (*p)[(signed long int)tmp_post$9] = (char)39;
      if(!(i == len + -1))
      {
        tmp_post$10 = c;
        c = c + 1;
        (*p)[(signed long int)tmp_post$10] = (char)39;
      }

    }

    else
    {
      tmp_post$11 = c;
      c = c + 1;
      (*p)[(signed long int)tmp_post$11] = text[(signed long int)i];
    }
  signed int tmp_post$12;
  if(!((signed int)text[(signed long int)(len + -1)] == 39))
  {
    tmp_post$12 = c;
    c = c + 1;
    (*p)[(signed long int)tmp_post$12] = (char)39;
  }

  signed int tmp_post$13 = c;
  c = c + 1;
  (*p)[(signed long int)tmp_post$13] = (char)0;

__CPROVER_DUMP_L17:
  ;
}

// file_selection_set_path
// file gui_callbacks.c line 53
void file_selection_set_path(char *filename)
{
  unsigned long int return_value_strlen$8;
  if(!(filename == ((char *)NULL)))
  {
    unsigned long int return_value_gtk_file_selection_get_type$1;
    return_value_gtk_file_selection_get_type$1=gtk_file_selection_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type$1);
    gtk_file_selection_set_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast$2, filename);
  }

  else
    if(!(project_directory == ((char *)NULL)))
    {
      return_value_strlen$8=strlen(project_directory);
      if(!(return_value_strlen$8 == 0ul))
      {
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(project_directory);
        if(!((signed int)project_directory[-1l + (signed long int)return_value_strlen$7] == 47))
        {
          char *buffer;
          buffer=g_strdup_printf("%s/", project_directory);
          unsigned long int return_value_gtk_file_selection_get_type$3;
          return_value_gtk_file_selection_get_type$3=gtk_file_selection_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
          return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type$3);
          gtk_file_selection_set_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast$4, buffer);
          g_free((void *)buffer);
        }

        else
        {
          unsigned long int return_value_gtk_file_selection_get_type$5;
          return_value_gtk_file_selection_get_type$5=gtk_file_selection_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
          return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type$5);
          gtk_file_selection_set_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast$6, project_directory);
        }
      }

    }

}

// free_instance_template
// file ghostess.c line 779
static void free_instance_template(struct _instance_template_t *t)
{
  reset_instance_template(t);
  if(!(t->ports.allocated == 0ul))
  {
    free((void *)t->ports.set);
    free((void *)t->ports.value);
  }

  free((void *)t);
}

// free_programs
// file ghostess.c line 1312
void free_programs(struct _d3h_instance_t *instance)
{
  signed int i;
  if(!(instance->pluginPrograms == ((struct _DSSI_Program_Descriptor *)NULL)))
  {
    i = 0;
    for( ; !(i >= instance->pluginProgramCount); i = i + 1)
      free((void *)(instance->pluginPrograms + (signed long int)i)->Name);
    free((void *)(char *)instance->pluginPrograms);
  }

  instance->pluginProgramsValid = 0;
  instance->pluginProgramsAlloc = 0;
  instance->pluginProgramCount = 0;
  instance->pluginPrograms = (struct _DSSI_Program_Descriptor *)(void *)0;
}

// get_port_default
// file ghostess.c line 2346
float get_port_default(const struct _LADSPA_Descriptor *plugin, signed int port)
{
  float value;
  struct _LADSPA_PortRangeHint hint = plugin->PortRangeHints[(signed long int)port];
  float lower = hint.LowerBound * ((hint.HintDescriptor & 0x8) != 0 ? sample_rate : 1.0f);
  float upper = hint.UpperBound * ((hint.HintDescriptor & 0x8) != 0 ? sample_rate : 1.0f);
  if((0x3C0 & hint.HintDescriptor) == 0)
  {
    if((0x1 & hint.HintDescriptor) == 0 || (0x2 & hint.HintDescriptor) == 0)
      return 0.0f;

    if(lower <= 0.0f && upper >= 0.0f)
      return 0.0f;

    return lower;
  }

  else
  {
    if((0x3C0 & hint.HintDescriptor) == 0x200)
      return 0.0f;

    else
      if((0x3C0 & hint.HintDescriptor) == 0x240)
        return 1.0f;

      else
        if((0x3C0 & hint.HintDescriptor) == 0x280)
          return 100.0f;

        else
          if((0x3C0 & hint.HintDescriptor) == 0x2C0)
            return 440.0f;

    value = 0.0f;
    if(!((0x1 & hint.HintDescriptor) == 0))
    {
      if((0x3C0 & hint.HintDescriptor) == 0x40)
        value = lower;

    }

    if(!((0x2 & hint.HintDescriptor) == 0))
    {
      if((0x3C0 & hint.HintDescriptor) == 0x140)
        value = upper;

      if(!((0x1 & hint.HintDescriptor) == 0))
      {
        if(lower > 0.0f && upper > 0.0f && !((0x10 & hint.HintDescriptor) == 0))
        {
          if((0x3C0 & hint.HintDescriptor) == 0x80)
          {
            float return_value_logf$1;
            return_value_logf$1=logf(lower);
            float return_value_logf$2;
            return_value_logf$2=logf(upper);
            value=expf(return_value_logf$1 * 0.75f + return_value_logf$2 * 0.25f);
          }

          else
            if((0x3C0 & hint.HintDescriptor) == 0xC0)
            {
              float return_value_logf$3;
              return_value_logf$3=logf(lower);
              float return_value_logf$4;
              return_value_logf$4=logf(upper);
              value=expf(return_value_logf$3 * 0.5f + return_value_logf$4 * 0.5f);
            }

            else
              if((0x3C0 & hint.HintDescriptor) == 0x100)
              {
                float return_value_logf$5;
                return_value_logf$5=logf(lower);
                float return_value_logf$6;
                return_value_logf$6=logf(upper);
                value=expf(return_value_logf$5 * 0.25f + return_value_logf$6 * 0.75f);
              }

        }

        else
          if((0x3C0 & hint.HintDescriptor) == 0x80)
            value = lower * 0.75f + upper * 0.25f;

          else
            if((0x3C0 & hint.HintDescriptor) == 0xC0)
              value = lower * 0.5f + upper * 0.5f;

            else
              if((0x3C0 & hint.HintDescriptor) == 0x100)
                value = lower * 0.25f + upper * 0.75f;

      }

    }

    if(!((0x20 & hint.HintDescriptor) == 0))
    {
      signed long int return_value_lrintf$7;
      return_value_lrintf$7=lrintf(value);
      value = (float)return_value_lrintf$7;
    }

    return value;
  }
}

// getarg
// file getarg.h line 31
char * getarg(void)
{
  char *arg;
  _Bool tmp_if_expr$3;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$4;
  signed int return_value_getarg_push_file$6;
  do
  {

  again:
    ;
    arg=getarg_internal();
    if(arg == ((char *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$2;
      return_value___builtin_strcmp$2=__builtin_strcmp(arg, "-f");
      tmp_statement_expression$1 = return_value___builtin_strcmp$2;
      tmp_if_expr$3 = tmp_statement_expression$1 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      return arg;

    arg=getarg_internal();
    if(arg == ((char *)NULL))
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strlen$4=strlen(arg);
      tmp_if_expr$5 = !(return_value_strlen$4 != 0ul) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      getarg_error = "configuration file name expected after '-f'";
      return (char *)(void *)0;
    }

    return_value_getarg_push_file$6=getarg_push_file(arg);
  }
  while(!(return_value_getarg_push_file$6 == 0));
  return (char *)(void *)0;
}

// getarg_cleanup
// file getarg.h line 28
void getarg_cleanup(void)
{
  while(!(state_list == ((struct _getarg_state *)NULL)))
    getarg_pop_state();
}

// getarg_init_with_command_line
// file getarg.h line 29
void getarg_init_with_command_line(signed int argc, char **argv)
{
  struct _getarg_state *state;
  getarg_cleanup();
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct _getarg_state) /*40ul*/ );
  state = (struct _getarg_state *)return_value_calloc$1;
  state->up = (struct _getarg_state *)(void *)0;
  state->is_file = 0;
  state->state.argv.argc = argc;
  state->state.argv.argv = argv;
  state->state.argv.next_arg = 0;
  state_list = state;
  void *return_value_malloc$2;
  if(argbuf == ((char *)NULL))
  {
    return_value_malloc$2=malloc((unsigned long int)(32767 + 1));
    argbuf = (char *)return_value_malloc$2;
  }

  getarg_error = (char *)(void *)0;
}

// getarg_init_with_file
// file getarg.c line 152
signed int getarg_init_with_file(char *filename)
{
  getarg_cleanup();
  getarg_error = (char *)(void *)0;
  signed int return_value_getarg_push_file$1;
  return_value_getarg_push_file$1=getarg_push_file(filename);
  return return_value_getarg_push_file$1;
}

// getarg_internal
// file getarg.c line 268
static char * getarg_internal(void)
{
  struct _getarg_state *state;
  char *arg;
  do
  {

  again:
    ;
    state = state_list;
    if(state == ((struct _getarg_state *)NULL))
      return (char *)(void *)0;

    if(!(state->is_file == 0))
    {
      signed int return_value_getarg_read_file_arg$1;
      return_value_getarg_read_file_arg$1=getarg_read_file_arg(state);
      if(!(return_value_getarg_read_file_arg$1 == 0))
        return argbuf;

      else
        if(!(getarg_error == ((char *)NULL)))
          return (char *)(void *)0;

        else
        {
          getarg_pop_state();
          goto again;
        }
    }

    if(!(state->state.argv.next_arg >= state->state.argv.argc))
    {
      arg = state->state.argv.argv[(signed long int)state->state.argv.next_arg];
      state->state.argv.next_arg = state->state.argv.next_arg + 1;
      return arg;
    }

    getarg_pop_state();
  }
  while((_Bool)1);
}

// getarg_pop_state
// file getarg.c line 58
static void getarg_pop_state(void)
{
  struct _getarg_state *state;
  if(!(state_list == ((struct _getarg_state *)NULL)))
  {
    state = state_list;
    state_list = state->up;
    if(!(state->is_file == 0))
    {
      free((void *)state->state.file.filename);
      fclose(state->state.file.fh);
    }

    free((void *)state);
  }

  if(state_list == ((struct _getarg_state *)NULL) && !(argbuf == ((char *)NULL)))
  {
    free((void *)argbuf);
    argbuf = (char *)(void *)0;
  }

}

// getarg_print_possible_error
// file getarg.h line 27
void getarg_print_possible_error(void)
{
  if(!(getarg_error == ((char *)NULL)))
    ghss_debug(1, " configuration error: %s", getarg_error);

}

// getarg_push_file
// file getarg.c line 119
static signed int getarg_push_file(char *filename)
{
  struct _getarg_state *state;
  char *fn;
  char *return_value___strdup$1;
  return_value___strdup$1=__strdup(filename);
  fn = return_value___strdup$1;
  struct _IO_FILE *fh;
  fh=fopen(filename, "r");
  if(fh == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    snprintf(argbuf, (unsigned long int)2048, "could not open configuration file '%s': %s", fn, return_value_strerror$3);
    getarg_error = argbuf;
    free((void *)fn);
    return 0;
  }

  void *return_value_calloc$4;
  return_value_calloc$4=calloc((unsigned long int)1, sizeof(struct _getarg_state) /*40ul*/ );
  state = (struct _getarg_state *)return_value_calloc$4;
  state->up = state_list;
  state->is_file = 1;
  state->state.file.filename = fn;
  state->state.file.fh = fh;
  state->state.file.next = (signed long int)0;
  state_list = state;
  void *return_value_malloc$5;
  if(argbuf == ((char *)NULL))
  {
    return_value_malloc$5=malloc((unsigned long int)(32767 + 1));
    argbuf = (char *)return_value_malloc$5;
  }

  return 1;
}

// getarg_read_file_arg
// file getarg.c line 164
static signed int getarg_read_file_arg(struct _getarg_state *state)
{
  char c;
  signed int len;
  signed int done;
  signed int parse_state;
  signed int return_value_fseek$3;
  return_value_fseek$3=fseek(state->state.file.fh, state->state.file.next, 0);
  if(!(return_value_fseek$3 >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    snprintf(argbuf, (unsigned long int)2048, "seek error on configuration file '%s': %s", state->state.file.filename, return_value_strerror$2);
    getarg_error = argbuf;
    return 0;
  }

  parse_state = 0;
  done = parse_state;
  len = done;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$12;
  while(done == 0)
  {
    if(len >= 32767)
    {
      snprintf(argbuf, (unsigned long int)2048, "argument too long reading configuration file '%s'", state->state.file.filename);
      getarg_error = argbuf;
      return 0;
    }

    signed int return_value_fgetc$4;
    return_value_fgetc$4=fgetc(state->state.file.fh);
    c = (char)return_value_fgetc$4;
    if((signed int)c == -1)
    {
      signed int return_value_ferror$7;
      return_value_ferror$7=ferror(state->state.file.fh);
      if(!(return_value_ferror$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        snprintf(argbuf, (unsigned long int)2048, "error reading configuration file '%s': %s", state->state.file.filename, return_value_strerror$6);
        getarg_error = argbuf;
        return 0;
      }

      else
      {
        if(!(len == 0))
          break;

        return 0;
      }
    }

    state->state.file.next = state->state.file.next + 1l;
    switch(parse_state)
    {
      case 0:
      {
        if((signed int)c == 92)
        {
          parse_state = 1;
          goto __CPROVER_DUMP_L22;
        }

        else
          if((signed int)c == 9 || (signed int)c == 10 || (signed int)c == 32)
            goto __CPROVER_DUMP_L22;

          else
            if((signed int)c == 39)
            {
              parse_state = 3;
              goto __CPROVER_DUMP_L22;
            }

        parse_state = 2;
        tmp_post$8 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post$8] = c;
        break;
      }
      case 1:
      {
        if((signed int)c == 9 || (signed int)c == 10 || (signed int)c == 32)
        {
          parse_state = 0;
          goto __CPROVER_DUMP_L22;
        }

        parse_state = 2;
        tmp_post$9 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post$9] = c;
        break;
      }
      case 2:
      {
        if((signed int)c == 9 || (signed int)c == 10 || (signed int)c == 32)
        {
          done = 1;
          break;
        }

        else
          if((signed int)c == 92)
          {
            parse_state = 4;
            goto __CPROVER_DUMP_L22;
          }

          else
            if((signed int)c == 39)
            {
              parse_state = 3;
              goto __CPROVER_DUMP_L22;
            }

        tmp_post$10 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post$10] = c;
        break;
      }
      case 3:
      {
        if((signed int)c == 39)
        {
          parse_state = 2;
          goto __CPROVER_DUMP_L22;
        }

        tmp_post$11 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post$11] = c;
        break;
      }
      case 4:
      {
        parse_state = 2;
        tmp_post$12 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post$12] = c;
      }
    }

  __CPROVER_DUMP_L22:
    ;
  }
  argbuf[(signed long int)len] = (char)0;
  return 1;
}

// ghss_debug
// file ghostess.c line 154
void ghss_debug(signed int type, const char *format, ...)
{
  void **args = (void **)&format;
  if(!((debug_flags & type) == 0))
  {
    fputs(host_name, stderr);
    vfprintf(stderr, format, args);
    fputs("\n", stderr);
  }

  args = ((void **)NULL);
}

// gtk_timeout_callback
// file ghostess.c line 1328
signed int gtk_timeout_callback(void *data)
{
  signed int i;
  struct _d3h_instance_t *instance;
  i = 0;
  for( ; !(i >= instance_count); i = i + 1)
  {
    instance = &instances[(signed long int)i];
    if(!(instance->uiNeedsProgramUpdate == 0))
    {
      if(!(instance->pendingProgramChange >= 0))
      {
        signed int bank = (signed int)instance->currentBank;
        signed int program = (signed int)instance->currentProgram;
        instance->uiNeedsProgramUpdate = 0;
        if(!(instance->ui_osc_address == NULL))
          lo_send_internal(instance->ui_osc_address, "ghostess.c", 1344, instance->ui_osc_program_path, "ii", bank, program, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

      }

    }

  }
  i = 0;
  for( ; !(i >= controlInsTotal); i = i + 1)
    if(!(pluginPortUpdated[(signed long int)i] == 0))
    {
      signed int port = (signed int)pluginControlInPortNumbers[(signed long int)i];
      float value = pluginControlIns[(signed long int)i];
      instance = pluginControlInInstances[(signed long int)i];
      pluginPortUpdated[(signed long int)i] = 0;
      if(!(instance->ui_osc_address == NULL))
        lo_send_internal(instance->ui_osc_address, "ghostess.c", 1356, instance->ui_osc_control_path, "if", port, value, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

    }

  i = 0;
  for( ; !(i >= instance_count); i = i + 1)
    update_eyecandy(&instances[(signed long int)i]);
  main_timeout_tick = main_timeout_tick + 1;
  if(!(host_exiting == 0))
  {
    gtk_main_quit();
    return 0;
  }

  else
    return (signed int)!(0 != 0);
}

// instance_sort_cmp
// file ghostess.c line 1042
static signed int instance_sort_cmp(const void *a, const void *b)
{
  struct _d3h_instance_t *ia = (struct _d3h_instance_t *)a;
  struct _d3h_instance_t *ib = (struct _d3h_instance_t *)b;
  if(!(ia->plugin->number == ib->plugin->number))
    return ia->plugin->number - ib->plugin->number;

  else
    return ia->id - ib->id;
}

// instance_template_set_port
// file ghostess.c line 790
static void instance_template_set_port(struct _instance_template_t *t, unsigned long int port, float value)
{
  unsigned long int n;
  if(port >= t->ports.allocated)
  {
    n = (unsigned long int)256;
    for( ; port >= n; n = n << 1)
      ;
    if(!(t->ports.allocated == 0ul))
    {
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)t->ports.set, sizeof(signed int) /*4ul*/  * n);
      t->ports.set = (signed int *)return_value_realloc$1;
      memset((void *)&t->ports.set[(signed long int)t->ports.allocated], 0, sizeof(signed int) /*4ul*/  * (n - t->ports.allocated));
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)t->ports.value, sizeof(float) /*4ul*/  * n);
      t->ports.value = (float *)return_value_realloc$2;
    }

    else
    {
      void *return_value_calloc$3;
      return_value_calloc$3=calloc(sizeof(signed int) /*4ul*/ , n);
      t->ports.set = (signed int *)return_value_calloc$3;
      void *return_value_malloc$4;
      return_value_malloc$4=malloc(sizeof(float) /*4ul*/  * n);
      t->ports.value = (float *)return_value_malloc$4;
    }
    t->ports.allocated = n;
  }

  t->ports.have_settings = 1;
  if(!(t->ports.highest_set >= port))
    t->ports.highest_set = port;

  t->ports.set[(signed long int)port] = 1;
  t->ports.value[(signed long int)port] = value;
}

// load
// file ghostess.c line 668
char * load(const char *dllName, void **dll)
{
  char *path;
  char *origPath;
  char *element;
  char *filePath;
  const char *message;
  *dll = NULL;
  char *return_value_strrchr$2;
  if((signed int)*dllName == 47)
  {
    *dll=dlopen(dllName, 0x00002 | 0);
    if(!(*dll == NULL))
    {
      char *return_value___strdup$1;
      return_value___strdup$1=__strdup(dllName);
      path = return_value___strdup$1;
      char *return_value_strrchr$3;
      return_value_strrchr$3=strrchr(dllName, 47);
      if(return_value_strrchr$3 == dllName)
        path[(signed long int)1] = (char)0;

      else
      {
        return_value_strrchr$2=strrchr(path, 47);
        *return_value_strrchr$2 = (char)0;
      }
      return path;
    }

    message=dlerror();
    if(!(message == ((const char *)NULL)))
      ghss_debug(8, ": dlopen of '%s' failed: %s", dllName, message);

    else
      ghss_debug(8, ": dlopen of '%s' failed", dllName);
    return (char *)(void *)0;
  }

  else
  {
    if(dssi_path == ((char *)NULL))
    {
      dssi_path=getenv("DSSI_PATH");
      if(dssi_path == ((char *)NULL))
      {
        dssi_path = "/usr/local/lib/dssi:/usr/lib/dssi";
        ghss_debug(8, " warning: DSSI_PATH not set, defaulting to '%s'", dssi_path);
      }

    }

    char *return_value___strdup$4;
    return_value___strdup$4=__strdup(dssi_path);
    path = return_value___strdup$4;
    origPath = path;
    do
    {
      element=strtok(path, ":");
      if(element == ((char *)NULL))
        break;

      path = ((char *)NULL);
      if(!((signed int)*element == 47))
        ghss_debug(8, ": ignoring DSSI_PATH relative element '%s'", element);

      else
      {
        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen(element);
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(dllName);
        void *return_value_malloc$7;
        return_value_malloc$7=malloc(return_value_strlen$5 + return_value_strlen$6 + (unsigned long int)2);
        filePath = (char *)return_value_malloc$7;
        sprintf(filePath, "%s/%s", element, dllName);
        *dll=dlopen(filePath, 0x00002 | 0);
        if(!(*dll == NULL))
        {
          ghss_debug(8, ": '%s' found at '%s'", dllName, filePath);
          free((void *)filePath);
          char *return_value___strdup$8;
          return_value___strdup$8=__strdup(element);
          path = return_value___strdup$8;
          free((void *)origPath);
          return path;
        }

        message=dlerror();
        if(!(message == ((const char *)NULL)))
          ghss_debug(8, ": dlopen of '%s' failed: %s", filePath, message);

        else
          ghss_debug(8, ": dlopen of '%s' failed", filePath);
        free((void *)filePath);
      }
    }
    while((_Bool)1);
    free((void *)origPath);
    return (char *)(void *)0;
  }
}

// main
// file ghostess.c line 1375
signed int main(signed int argc, char **argv)
{
  signed int gtk_timeout_tag;
  struct _d3h_dll_t *dll;
  struct _d3h_plugin_t *plugin;
  struct _instance_template_t *itemplate;
  struct _d3h_instance_t *instance;
  void *pluginObject;
  char *dllName;
  char *label;
  const char **ports;
  char *tmp;
  char *arg0;
  char *arg1;
  signed int i;
  signed int reps;
  signed int j;
  signed int in;
  signed int out;
  signed int controlIn;
  signed int controlOut;
  enum JackStatus status;
  gtk_init(&argc, &argv);
  setsid();
  sigemptyset(&_signals);
  sigaddset(&_signals, 1);
  sigaddset(&_signals, 2);
  sigaddset(&_signals, 3);
  sigaddset(&_signals, 13);
  sigaddset(&_signals, 15);
  sigaddset(&_signals, 10);
  sigaddset(&_signals, 12);
  pthread_sigmask(0, &_signals, ((struct anonymous$18 *)NULL));
  host_name = host_name_default;
  controlOutsTotal = 0;
  controlInsTotal = controlOutsTotal;
  outsTotal = controlInsTotal;
  insTotal = outsTotal;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  signed int tmp_statement_expression$8;
  _Bool tmp_if_expr$6;
  unsigned long int return_value_strlen$5;
  signed int tmp_statement_expression$13;
  _Bool tmp_if_expr$17;
  signed int tmp_statement_expression$15;
  _Bool tmp_if_expr$11;
  unsigned long int return_value_strlen$10;
  signed int tmp_statement_expression$21;
  _Bool tmp_if_expr$19;
  unsigned long int return_value_strlen$18;
  signed int tmp_statement_expression$23;
  _Bool tmp_if_expr$27;
  signed int tmp_statement_expression$25;
  unsigned long int return_value_strlen$29;
  signed int tmp_statement_expression$35;
  _Bool tmp_if_expr$31;
  unsigned long int return_value_strlen$30;
  _Bool tmp_if_expr$33;
  _Bool tmp_if_expr$34;
  signed int tmp_statement_expression$40;
  _Bool tmp_if_expr$38;
  unsigned long int return_value_strlen$37;
  signed int tmp_statement_expression$47;
  _Bool tmp_if_expr$43;
  unsigned long int return_value_strlen$42;
  _Bool tmp_if_expr$46;
  unsigned long int return_value_strlen$45;
  signed int tmp_statement_expression$55;
  _Bool tmp_if_expr$50;
  unsigned long int return_value_strlen$49;
  _Bool tmp_if_expr$53;
  unsigned long int return_value_strlen$52;
  signed int tmp_statement_expression$57;
  signed int tmp_statement_expression$65;
  signed int tmp_statement_expression$63;
  signed int tmp_statement_expression$67;
  signed int tmp_statement_expression$70;
  signed int tmp_post$75;
  _Bool tmp_if_expr$78;
  signed int tmp_statement_expression$76;
  signed int tmp_post$80;
  _Bool tmp_if_expr$83;
  signed int tmp_statement_expression$81;
  char *tmp_if_expr$84;
  _Bool tmp_if_expr$96;
  unsigned long int return_value_strlen$94;
  signed int return_value_strcasecmp$95;
  signed int tmp_post$118;
  signed int tmp_post$119;
  signed int tmp_post$120;
  signed int tmp_post$121;
  if(!(argc >= 2))
  {
    fprintf(stderr, "%s %s\n", host_name, (const void *)"20120105");
    fprintf(stderr, "Copyright (C) 2006-2012 Sean Bolton and others.\n");
    fprintf(stderr, "%s comes with ABSOLUTELY NO WARRANTY. This is free software, and you are\n", host_name);
    fprintf(stderr, "welcome to redistribute it under certain conditions; see the file COPYING for details.\n");
    fprintf(stderr, "Usage: %s [-debug <level>] [-hostname <hostname>] [-projdir <projdir>] [-uuid <uuid>] [-noauto] [-f <cfgfile>]\n", argv[(signed long int)0]);
    fprintf(stderr, "       [-<n>] [-chan <c>] [-conf <k> <v>] [-prog <b> <p>] [-port <p> <f>] <soname>[:<label>] [...]\n\n");
    fprintf(stderr, "  <level>    Debug information flags, bitfield, 1 = errors only, -1 = all\n");
    fprintf(stderr, "  <hostname> JACK and ALSA client name to use, default \"ghostess\"\n");
    fprintf(stderr, "  <projdir>  DSSI project directory, default none\n");
    fprintf(stderr, "  <uuid>     JACK session management UUID, default none\n");
    fprintf(stderr, "  <cfgfile>  File containing more configuration; same format as command line\n");
    fprintf(stderr, "  <n>        Number of instances of the following plugin to create, default 1\n");
    fprintf(stderr, "  <c>        MIDI channel for following instance, numbered from 0\n");
    fprintf(stderr, "  <k> <v>    Configure item key and value for following instance (repeatable for different keys)\n");
    fprintf(stderr, "  <b> <p>    Bank and program number for following instance\n");
    fprintf(stderr, "  <p> <f>    Port number and value for following instance (repeatable for different ports)\n");
    fprintf(stderr, "  <soname>   Name of DSSI plugin library (*.so) to load\n");
    fprintf(stderr, "  <label>    Name of DSSI plugin within library to instantiate, default first\n");
    return 2;
  }

  else
  {
    host_argv0 = argv[(signed long int)0];
    ghss_debug(1, ": ghostess starting...");
    getarg_init_with_command_line(argc - 1, &argv[(signed long int)1]);
    itemplate=new_instance_template();
    reps = 1;
    do
    {
      arg0=getarg();
      if(arg0 == ((char *)NULL))
        break;

      unsigned long int main$$1$$2$$1$$__s1_len;
      unsigned long int main$$1$$2$$1$$__s2_len;
      signed int return_value___builtin_strcmp$4;
      return_value___builtin_strcmp$4=__builtin_strcmp(arg0, "-debug");
      tmp_statement_expression$3 = return_value___builtin_strcmp$4;
      if(tmp_statement_expression$3 == 0)
      {
        arg0=getarg();
        if(arg0 == ((char *)NULL))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_strlen$1=strlen(arg0);
          tmp_if_expr$2 = !(return_value_strlen$1 != 0ul) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
        {
          getarg_print_possible_error();
          ghss_debug(1, ": debug level expected after '-debug'");
          return 2;
        }

        debug_flags=atoi(arg0);
        ghss_debug(2, ": debug level now %08x", debug_flags);
        continue;
      }

      unsigned long int main$$1$$2$$3$$__s1_len;
      unsigned long int main$$1$$2$$3$$__s2_len;
      signed int return_value___builtin_strcmp$9;
      return_value___builtin_strcmp$9=__builtin_strcmp(arg0, "-hostname");
      tmp_statement_expression$8 = return_value___builtin_strcmp$9;
      if(tmp_statement_expression$8 == 0)
      {
        arg0=getarg();
        if(arg0 == ((char *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          return_value_strlen$5=strlen(arg0);
          tmp_if_expr$6 = !(return_value_strlen$5 != 0ul) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
        {
          getarg_print_possible_error();
          ghss_debug(1, ": host name base expected after '-hostname'");
          return 2;
        }

        if(!(host_name == host_name_default))
          free((void *)host_name);

        char *return_value___strdup$7;
        return_value___strdup$7=__strdup(arg0);
        host_name = return_value___strdup$7;
        continue;
      }

      unsigned long int main$$1$$2$$5$$__s1_len;
      unsigned long int main$$1$$2$$5$$__s2_len;
      signed int return_value___builtin_strcmp$14;
      return_value___builtin_strcmp$14=__builtin_strcmp(arg0, "-projdir");
      tmp_statement_expression$13 = return_value___builtin_strcmp$14;
      if(tmp_statement_expression$13 == 0)
        tmp_if_expr$17 = (_Bool)1;

      else
      {
        unsigned long int main$$1$$2$$6$$__s1_len;
        unsigned long int main$$1$$2$$6$$__s2_len;
        signed int return_value___builtin_strcmp$16;
        return_value___builtin_strcmp$16=__builtin_strcmp(arg0, "-p");
        tmp_statement_expression$15 = return_value___builtin_strcmp$16;
        tmp_if_expr$17 = !(tmp_statement_expression$15 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$17)
      {
        arg0=getarg();
        if(arg0 == ((char *)NULL))
          tmp_if_expr$11 = (_Bool)1;

        else
        {
          return_value_strlen$10=strlen(arg0);
          tmp_if_expr$11 = !(return_value_strlen$10 != 0ul) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$11)
        {
          getarg_print_possible_error();
          ghss_debug(1, ": project directory expected after '-projdir'");
          return 2;
        }

        if(!(project_directory == ((char *)NULL)))
          free((void *)project_directory);

        char *return_value___strdup$12;
        return_value___strdup$12=__strdup(arg0);
        project_directory = return_value___strdup$12;
        continue;
      }

      unsigned long int main$$1$$2$$8$$__s1_len;
      unsigned long int main$$1$$2$$8$$__s2_len;
      signed int return_value___builtin_strcmp$22;
      return_value___builtin_strcmp$22=__builtin_strcmp(arg0, "-uuid");
      tmp_statement_expression$21 = return_value___builtin_strcmp$22;
      if(tmp_statement_expression$21 == 0)
      {
        arg0=getarg();
        if(arg0 == ((char *)NULL))
          tmp_if_expr$19 = (_Bool)1;

        else
        {
          return_value_strlen$18=strlen(arg0);
          tmp_if_expr$19 = !(return_value_strlen$18 != 0ul) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$19)
        {
          getarg_print_possible_error();
          ghss_debug(1, ": uuid expected after '-uuid'");
          return 2;
        }

        if(!(jack_session_uuid == ((char *)NULL)))
          free((void *)jack_session_uuid);

        char *return_value___strdup$20;
        return_value___strdup$20=__strdup(arg0);
        jack_session_uuid = return_value___strdup$20;
        continue;
      }

      unsigned long int main$$1$$2$$10$$__s1_len;
      unsigned long int main$$1$$2$$10$$__s2_len;
      signed int return_value___builtin_strcmp$24;
      return_value___builtin_strcmp$24=__builtin_strcmp(arg0, "-noauto");
      tmp_statement_expression$23 = return_value___builtin_strcmp$24;
      if(tmp_statement_expression$23 == 0)
        tmp_if_expr$27 = (_Bool)1;

      else
      {
        unsigned long int main$$1$$2$$11$$__s1_len;
        unsigned long int main$$1$$2$$11$$__s2_len;
        signed int return_value___builtin_strcmp$26;
        return_value___builtin_strcmp$26=__builtin_strcmp(arg0, "-c");
        tmp_statement_expression$25 = return_value___builtin_strcmp$26;
        tmp_if_expr$27 = !(tmp_statement_expression$25 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$27)
        autoconnect = 0;

      else
      {
        if(instance_count >= 32)
        {
          ghss_debug(1, ": too many plugin instances specified (limit is %d)", 32);
          return 2;
        }

        if((signed int)*arg0 == 45)
        {
          return_value_strlen$29=strlen(arg0);
          if(return_value_strlen$29 >= 2ul)
          {
            signed long int return_value_strtol$28;
            return_value_strtol$28=strtol(&arg0[(signed long int)1], &tmp, 10);
            j = (signed int)return_value_strtol$28;
            if((signed int)*tmp == 0)
            {
              if(j >= 1)
              {
                reps = j;
                continue;
              }

            }

          }

        }

        unsigned long int main$$1$$2$$15$$__s1_len;
        unsigned long int main$$1$$2$$15$$__s2_len;
        signed int return_value___builtin_strcmp$36;
        return_value___builtin_strcmp$36=__builtin_strcmp(arg0, "-chan");
        tmp_statement_expression$35 = return_value___builtin_strcmp$36;
        if(tmp_statement_expression$35 == 0)
        {
          arg0=getarg();
          if(arg0 == ((char *)NULL))
            tmp_if_expr$31 = (_Bool)1;

          else
          {
            return_value_strlen$30=strlen(arg0);
            tmp_if_expr$31 = !(return_value_strlen$30 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$31)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": MIDI channel expected after '-chan'");
            return 2;
          }

          signed long int return_value_strtol$32;
          return_value_strtol$32=strtol(arg0, &tmp, 10);
          itemplate->channel = (signed int)return_value_strtol$32;
          if(!((signed int)*tmp == 0))
            tmp_if_expr$33 = (_Bool)1;

          else
            tmp_if_expr$33 = itemplate->channel < 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$33)
            tmp_if_expr$34 = (_Bool)1;

          else
            tmp_if_expr$34 = itemplate->channel > 15 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$34)
          {
            ghss_debug(1, ": bad MIDI channel '%s'", arg0);
            return 2;
          }

          continue;
        }

        unsigned long int main$$1$$2$$17$$__s1_len;
        unsigned long int main$$1$$2$$17$$__s2_len;
        signed int return_value___builtin_strcmp$41;
        return_value___builtin_strcmp$41=__builtin_strcmp(arg0, "-conf");
        tmp_statement_expression$40 = return_value___builtin_strcmp$41;
        if(tmp_statement_expression$40 == 0)
        {
          arg0=getarg();
          if(arg0 == ((char *)NULL))
            tmp_if_expr$38 = (_Bool)1;

          else
          {
            return_value_strlen$37=strlen(arg0);
            tmp_if_expr$38 = !(return_value_strlen$37 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$38)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": key and value expected after '-conf'");
            return 2;
          }

          char *return_value___strdup$39;
          return_value___strdup$39=__strdup(arg0);
          arg0 = return_value___strdup$39;
          arg1=getarg();
          if(arg1 == ((char *)NULL))
          {
            getarg_print_possible_error();
            ghss_debug(1, ": key and value expected after '-conf'");
            free((void *)arg0);
            return 2;
          }

          add_configure_item(&itemplate->configure_items, arg0, arg1);
          free((void *)arg0);
          continue;
        }

        unsigned long int main$$1$$2$$19$$__s1_len;
        unsigned long int main$$1$$2$$19$$__s2_len;
        signed int return_value___builtin_strcmp$48;
        return_value___builtin_strcmp$48=__builtin_strcmp(arg0, "-prog");
        tmp_statement_expression$47 = return_value___builtin_strcmp$48;
        if(tmp_statement_expression$47 == 0)
        {
          arg0=getarg();
          if(arg0 == ((char *)NULL))
            tmp_if_expr$43 = (_Bool)1;

          else
          {
            return_value_strlen$42=strlen(arg0);
            tmp_if_expr$43 = !(return_value_strlen$42 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$43)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": bank and program number expected after '-prog'");
            return 2;
          }

          char *return_value___strdup$44;
          return_value___strdup$44=__strdup(arg0);
          arg0 = return_value___strdup$44;
          arg1=getarg();
          if(arg1 == ((char *)NULL))
            tmp_if_expr$46 = (_Bool)1;

          else
          {
            return_value_strlen$45=strlen(arg1);
            tmp_if_expr$46 = !(return_value_strlen$45 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$46)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": bank and program number expected after '-prog'");
            free((void *)arg0);
            return 2;
          }

          itemplate->bank=strtoul(arg0, &tmp, 10);
          if(!((signed int)*tmp == 0))
          {
            ghss_debug(1, ": bad bank number '%s'", arg0);
            free((void *)arg0);
            return 2;
          }

          free((void *)arg0);
          itemplate->program=strtoul(arg1, &tmp, 10);
          if(!((signed int)*tmp == 0))
          {
            ghss_debug(1, ": bad program number '%s'", arg1);
            return 2;
          }

          itemplate->program_set = 1;
          continue;
        }

        unsigned long int main$$1$$2$$21$$__s1_len;
        unsigned long int main$$1$$2$$21$$__s2_len;
        signed int return_value___builtin_strcmp$56;
        return_value___builtin_strcmp$56=__builtin_strcmp(arg0, "-port");
        tmp_statement_expression$55 = return_value___builtin_strcmp$56;
        if(tmp_statement_expression$55 == 0)
        {
          unsigned long int port;
          float value;
          arg0=getarg();
          if(arg0 == ((char *)NULL))
            tmp_if_expr$50 = (_Bool)1;

          else
          {
            return_value_strlen$49=strlen(arg0);
            tmp_if_expr$50 = !(return_value_strlen$49 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$50)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": port number and value expected after '-port'");
            return 2;
          }

          char *return_value___strdup$51;
          return_value___strdup$51=__strdup(arg0);
          arg0 = return_value___strdup$51;
          arg1=getarg();
          if(arg1 == ((char *)NULL))
            tmp_if_expr$53 = (_Bool)1;

          else
          {
            return_value_strlen$52=strlen(arg1);
            tmp_if_expr$53 = !(return_value_strlen$52 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$53)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": port number and value expected after '-port'");
            free((void *)arg0);
            return 2;
          }

          port=strtoul(arg0, &tmp, 10);
          if(!((signed int)*tmp == 0))
          {
            ghss_debug(1, ": bad port number '%s'", arg0);
            free((void *)arg0);
            return 2;
          }

          free((void *)arg0);
          double return_value_g_strtod$54;
          return_value_g_strtod$54=g_strtod(arg1, &tmp);
          value = (float)return_value_g_strtod$54;
          if(!((signed int)*tmp == 0))
          {
            ghss_debug(1, ": bad port value '%s'", arg1);
            return 2;
          }

          instance_template_set_port(itemplate, port, value);
          continue;
        }

        unsigned long int main$$1$$2$$23$$__s1_len;
        unsigned long int main$$1$$2$$23$$__s2_len;
        signed int return_value___builtin_strcmp$58;
        return_value___builtin_strcmp$58=__builtin_strcmp(arg0, "-comment");
        tmp_statement_expression$57 = return_value___builtin_strcmp$58;
        if(tmp_statement_expression$57 == 0)
        {
          arg0=getarg();
          if(arg0 == ((char *)NULL))
          {
            getarg_print_possible_error();
            ghss_debug(1, ": comment expected after '-comment'");
            return 2;
          }

        }

        else
        {
          char *return_value___builtin_strchr$59;
          return_value___builtin_strchr$59=__builtin_strchr(arg0, 58);
          tmp = return_value___builtin_strchr$59;
          if(!(tmp == ((char *)NULL)))
          {
            void *return_value_calloc$60;
            return_value_calloc$60=calloc((unsigned long int)1, (unsigned long int)((tmp - arg0) + (signed long int)1));
            dllName = (char *)return_value_calloc$60;
            __builtin_strncpy(dllName, arg0, (unsigned long int)(tmp - arg0));
            char *return_value___strdup$61;
            return_value___strdup$61=__strdup(tmp + (signed long int)1);
            label = return_value___strdup$61;
          }

          else
          {
            char *return_value___strdup$62;
            return_value___strdup$62=__strdup(arg0);
            dllName = return_value___strdup$62;
            label = (char *)(void *)0;
          }
          plugin = plugins;
          for( ; !(plugin == ((struct _d3h_plugin_t *)NULL)); plugin = plugin->next)
            if(!(label == ((char *)NULL)))
            {
              unsigned long int main$$1$$2$$27$$1$$1$$1$$__s1_len;
              unsigned long int main$$1$$2$$27$$1$$1$$1$$__s2_len;
              signed int return_value___builtin_strcmp$66;
              return_value___builtin_strcmp$66=__builtin_strcmp(dllName, plugin->dll->name);
              tmp_statement_expression$65 = return_value___builtin_strcmp$66;
              if(tmp_statement_expression$65 == 0)
              {
                unsigned long int main$$1$$2$$27$$1$$1$$2$$__s1_len;
                unsigned long int main$$1$$2$$27$$1$$1$$2$$__s2_len;
                signed int return_value___builtin_strcmp$64;
                return_value___builtin_strcmp$64=__builtin_strcmp(label, plugin->label);
                tmp_statement_expression$63 = return_value___builtin_strcmp$64;
                if(tmp_statement_expression$63 == 0)
                  break;

              }

            }

            else
            {
              unsigned long int main$$1$$2$$27$$1$$2$$1$$__s1_len;
              unsigned long int main$$1$$2$$27$$1$$2$$1$$__s2_len;
              signed int return_value___builtin_strcmp$68;
              return_value___builtin_strcmp$68=__builtin_strcmp(dllName, plugin->dll->name);
              tmp_statement_expression$67 = return_value___builtin_strcmp$68;
              if(tmp_statement_expression$67 == 0)
              {
                if(!(plugin->is_first_in_dll == 0))
                  break;

              }

            }
          if(!(plugin == ((struct _d3h_plugin_t *)NULL)))
          {
            free((void *)dllName);
            free((void *)label);
          }

          else
          {
            void *return_value_calloc$69;
            return_value_calloc$69=calloc((unsigned long int)1, sizeof(struct _d3h_plugin_t) /*72ul*/ );
            plugin = (struct _d3h_plugin_t *)return_value_calloc$69;
            plugin->number = plugin_count;
            plugin->label = label;
            dll = dlls;
            for( ; !(dll == ((struct _d3h_dll_t *)NULL)); dll = dll->next)
            {
              unsigned long int main$$1$$2$$29$$1$$1$$1$$__s1_len;
              unsigned long int main$$1$$2$$29$$1$$1$$1$$__s2_len;
              signed int return_value___builtin_strcmp$71;
              return_value___builtin_strcmp$71=__builtin_strcmp(dllName, dll->name);
              tmp_statement_expression$70 = return_value___builtin_strcmp$71;
              if(tmp_statement_expression$70 == 0)
                break;

            }
            if(dll == ((struct _d3h_dll_t *)NULL))
            {
              void *return_value_calloc$72;
              return_value_calloc$72=calloc((unsigned long int)1, sizeof(struct _d3h_dll_t) /*40ul*/ );
              dll = (struct _d3h_dll_t *)return_value_calloc$72;
              dll->name = dllName;
              dll->directory=load(dllName, &pluginObject);
              if(dll->directory == ((char *)NULL) || pluginObject == NULL)
              {
                ghss_debug(1, ": failed to load plugin library %s", dllName);
                return 1;
              }

              void *return_value_dlsym$73;
              return_value_dlsym$73=dlsym(pluginObject, "dssi_descriptor");
              dll->descfn = (const struct _DSSI_Descriptor * (*)(unsigned long int))return_value_dlsym$73;
              if(!(dll->descfn == ((const struct _DSSI_Descriptor * (*)(unsigned long int))NULL)))
                dll->is_DSSI_dll = 1;

              else
              {
                void *return_value_dlsym$74;
                return_value_dlsym$74=dlsym(pluginObject, "ladspa_descriptor");
                dll->descfn = (const struct _DSSI_Descriptor * (*)(unsigned long int))return_value_dlsym$74;
                if(dll->descfn == ((const struct _DSSI_Descriptor * (*)(unsigned long int))NULL))
                {
                  ghss_debug(1, ": %s is not a DSSI or LADSPA plugin library", dllName);
                  return 1;
                }

                dll->is_DSSI_dll = 0;
              }
              dll->next = dlls;
              dlls = dll;
            }

            plugin->dll = dll;
            j = 0;
            if(!(dll->is_DSSI_dll == 0))
            {
              const struct _DSSI_Descriptor *main$$1$$2$$29$$3$$desc;
              tmp_post$75 = j;
              j = j + 1;
              main$$1$$2$$29$$3$$desc=dll->descfn((unsigned long int)tmp_post$75);
              if(!(main$$1$$2$$29$$3$$desc == ((const struct _DSSI_Descriptor *)NULL)))
              {
                if(plugin->label == ((char *)NULL))
                  tmp_if_expr$78 = (_Bool)1;

                else
                {
                  unsigned long int main$$1$$2$$29$$3$$1$$1$$__s1_len;
                  unsigned long int main$$1$$2$$29$$3$$1$$1$$__s2_len;
                  signed int return_value___builtin_strcmp$77;
                  return_value___builtin_strcmp$77=__builtin_strcmp(main$$1$$2$$29$$3$$desc->LADSPA_Plugin->Label, plugin->label);
                  tmp_statement_expression$76 = return_value___builtin_strcmp$77;
                  tmp_if_expr$78 = !(tmp_statement_expression$76 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$78)
                  plugin->descriptor = main$$1$$2$$29$$3$$desc;

              }

            }

            else
            {
              struct _LADSPA_Descriptor *desc;
              void *return_value_calloc$79;
              return_value_calloc$79=calloc((unsigned long int)1, sizeof(struct _DSSI_Descriptor) /*80ul*/ );
              plugin->descriptor = (const struct _DSSI_Descriptor *)return_value_calloc$79;
              ((struct _DSSI_Descriptor *)plugin->descriptor)->DSSI_API_Version = 1;
              tmp_post$80 = j;
              j = j + 1;
              const struct _DSSI_Descriptor *return_value;
              return_value=dll->descfn((unsigned long int)tmp_post$80);
              desc = (struct _LADSPA_Descriptor *)return_value;
              if(!(desc == ((struct _LADSPA_Descriptor *)NULL)))
              {
                if(plugin->label == ((char *)NULL))
                  tmp_if_expr$83 = (_Bool)1;

                else
                {
                  unsigned long int __s1_len;
                  unsigned long int __s2_len;
                  signed int return_value___builtin_strcmp$82;
                  return_value___builtin_strcmp$82=__builtin_strcmp(desc->Label, plugin->label);
                  tmp_statement_expression$81 = return_value___builtin_strcmp$82;
                  tmp_if_expr$83 = !(tmp_statement_expression$81 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$83)
                  ((struct _DSSI_Descriptor *)plugin->descriptor)->LADSPA_Plugin = desc;

              }

              if(plugin->descriptor->LADSPA_Plugin == ((const struct _LADSPA_Descriptor *)NULL))
              {
                free((void *)plugin->descriptor);
                plugin->descriptor = (const struct _DSSI_Descriptor *)(void *)0;
              }

            }
            if(plugin->descriptor == ((const struct _DSSI_Descriptor *)NULL))
            {
              if(!(plugin->label == ((char *)NULL)))
                tmp_if_expr$84 = plugin->label;

              else
                tmp_if_expr$84 = "(none)";
              ghss_debug(1, ": plugin label '%s' not found in library '%s'", tmp_if_expr$84, dllName);
              return 1;
            }

            j = 1;
            plugin->is_first_in_dll = j;
            if(plugin->label == ((char *)NULL))
            {
              char *return_value___strdup$85;
              return_value___strdup$85=__strdup(plugin->descriptor->LADSPA_Plugin->Label);
              plugin->label = return_value___strdup$85;
            }

            plugin->ins = 0;
            plugin->outs = 0;
            plugin->controlIns = 0;
            plugin->controlOuts = 0;
            j = 0;
            if(!((unsigned long int)j >= plugin->descriptor->LADSPA_Plugin->PortCount))
            {
              signed int pod = plugin->descriptor->LADSPA_Plugin->PortDescriptors[(signed long int)j];
              if(!((0x8 & pod) == 0))
              {
                if(!((0x1 & pod) == 0))
                  plugin->ins = plugin->ins + 1;

                else
                  if(!((0x2 & pod) == 0))
                    plugin->outs = plugin->outs + 1;

              }

              else
                if(!((0x4 & pod) == 0))
                {
                  if(!((0x1 & pod) == 0))
                    plugin->controlIns = plugin->controlIns + 1;

                  else
                    if(!((0x2 & pod) == 0))
                      plugin->controlOuts = plugin->controlOuts + 1;

                }

              j = j + 1;
            }

            plugin->instances = 0;
            plugin->next = plugins;
            plugins = plugin;
            plugin_count = plugin_count + 1;
          }
          j = 0;
          for( ; !(j >= reps); j = j + 1)
            if(!(instance_count >= 32))
            {
              instance = &instances[(signed long int)instance_count];
              instance->plugin = plugin;
              instance->id = instance_count;
              instance->channel = itemplate->channel;
              instance->channel_next_instance = (struct _d3h_instance_t *)(void *)0;
              unsigned long int return_value_strlen$86;
              return_value_strlen$86=strlen(plugin->dll->name);
              unsigned long int return_value_strlen$87;
              return_value_strlen$87=strlen(plugin->label);
              void *return_value_malloc$88;
              return_value_malloc$88=malloc(return_value_strlen$86 + return_value_strlen$87 + (unsigned long int)9);
              tmp = (char *)return_value_malloc$88;
              instance->friendly_name = tmp;
              char *return_value_strrchr$90;
              return_value_strrchr$90=strrchr(plugin->dll->name, 47);
              if(!(return_value_strrchr$90 == ((char *)NULL)))
              {
                char *return_value_strrchr$89;
                return_value_strrchr$89=strrchr(plugin->dll->name, 47);
                strcpy(tmp, return_value_strrchr$89 + (signed long int)1);
              }

              else
                strcpy(tmp, plugin->dll->name);
              unsigned long int return_value_strlen$93;
              return_value_strlen$93=strlen(tmp);
              if(return_value_strlen$93 >= 4ul)
              {
                return_value_strlen$94=strlen(tmp);
                return_value_strcasecmp$95=strcasecmp((tmp + (signed long int)return_value_strlen$94) - (signed long int)3, ".so");
                tmp_if_expr$96 = !(return_value_strcasecmp$95 != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$96 = (_Bool)0;
              if(tmp_if_expr$96)
              {
                unsigned long int return_value_strlen$91;
                return_value_strlen$91=strlen(tmp);
                tmp = (tmp + (signed long int)return_value_strlen$91) - (signed long int)3;
              }

              else
              {
                unsigned long int return_value_strlen$92;
                return_value_strlen$92=strlen(tmp);
                tmp = tmp + (signed long int)return_value_strlen$92;
              }
              sprintf(tmp, "/%s/inst%02d", plugin->label, instance->id);
              instance->configure_items = (struct _configure_item_t *)(void *)0;
              copy_configure_items(itemplate, instance);
              instance->pluginProgramsValid = 0;
              instance->pluginProgramsAlloc = 0;
              instance->pluginProgramCount = 0;
              instance->pluginPrograms = (struct _DSSI_Program_Descriptor *)(void *)0;
              if(!(itemplate->program_set == 0))
              {
                instance->currentBank = (signed long int)itemplate->bank;
                instance->currentProgram = (signed long int)itemplate->program;
                instance->pendingProgramChange = 0;
              }

              else
              {
                instance->currentBank = (signed long int)0;
                instance->currentProgram = (signed long int)0;
                instance->pendingProgramChange = -1;
              }
              instance->pendingBankLSB = -1;
              instance->pendingBankMSB = -1;
              if(!(itemplate->ports.have_settings == 0))
              {
                if(itemplate->ports.highest_set >= plugin->descriptor->LADSPA_Plugin->PortCount)
                {
                  ghss_debug(1, ": out-of-range port number %lu given for %s (instance %d)", itemplate->ports.highest_set, plugin->label, instance_count);
                  return 2;
                }

                copy_initial_port_set(itemplate, instance);
              }

              else
                instance->have_initial_values = 0;
              instance->midi_activity_tick = -2;
              instance->ui_running = 0;
              instance->ui_visible = 0;
              instance->ui_initial_show_sent = 0;
              instance->uiNeedsProgramUpdate = 0;
              instance->ui_osc_address = (void *)0;
              instance->ui_osc_source = (void *)0;
              instance->ui_osc_configure_path = (char *)(void *)0;
              instance->ui_osc_control_path = (char *)(void *)0;
              instance->ui_osc_hide_path = (char *)(void *)0;
              instance->ui_osc_program_path = (char *)(void *)0;
              instance->ui_osc_quit_path = (char *)(void *)0;
              instance->ui_osc_rate_path = (char *)(void *)0;
              instance->ui_osc_show_path = (char *)(void *)0;
              insTotal = insTotal + plugin->ins;
              outsTotal = outsTotal + plugin->outs;
              controlInsTotal = controlInsTotal + plugin->controlIns;
              controlOutsTotal = controlOutsTotal + plugin->controlOuts;
              itemplate->channel = itemplate->channel + 1 & 15;
              plugin->instances = plugin->instances + 1;
              instance_count = instance_count + 1;
            }

            else
            {
              ghss_debug(1, ": too many plugin instances specified");
              return 2;
            }
          reset_instance_template(itemplate);
          reps = 1;
        }
      }
    }
    while((_Bool)1);
    free_instance_template(itemplate);
    if(!(getarg_error == ((char *)NULL)))
    {
      getarg_print_possible_error();
      ghss_debug(1, ": aborting.");
      return 2;
    }

    else
    {
      getarg_cleanup();
      if(instance_count == 0)
      {
        ghss_debug(1, ": no plugin instances specified");
        return 2;
      }

      else
      {
        if(instance_count >= 2)
          qsort((void *)instances, (unsigned long int)instance_count, sizeof(struct _d3h_instance_t) /*1264ul*/ , instance_sort_cmp);

        i = 0;
        for( ; !(i >= 16); i = i + 1)
          channel2instances[(signed long int)i] = (struct _d3h_instance_t *)(void *)0;
        i = 0;
        for( ; !(i >= instance_count); i = i + 1)
        {
          instance = &instances[(signed long int)i];
          instance->number = i;
          if(!(channel2instances[(signed long int)instance->channel] == ((struct _d3h_instance_t *)NULL)))
            instance->channel_next_instance = channel2instances[(signed long int)instance->channel];

          channel2instances[(signed long int)instance->channel] = instance;
          fprintf(stderr, "%s: instance %2d on channel %2d, plugin %2d is '%s'\n", host_name, i, instance->channel, instance->plugin->number, instance->friendly_name);
        }
        jackClient=jack_client_open(host_name, (enum JackOptions)JackSessionID, &status, jack_session_uuid);
        if(jackClient == ((struct _jack_client *)NULL))
        {
          fprintf(stderr, "%s: Error: Failed to connect to JACK server\n", host_name);
          return 1;
        }

        else
        {
          if(!((JackNameNotUnique & (signed int)status) == 0))
          {
            if(!(host_name == host_name_default))
              free((void *)host_name);

            char *return_value_jack_get_client_name$97;
            return_value_jack_get_client_name$97=jack_get_client_name(jackClient);
            char *return_value___strdup$98;
            return_value___strdup$98=__strdup(return_value_jack_get_client_name$97);
            host_name = return_value___strdup$98;
          }

          /* assertion sizeof(jack_default_audio_sample_t) == sizeof(float) */
          assert(sizeof(float) /*4ul*/  == sizeof(float) /*4ul*/ );
          /* assertion sizeof(jack_default_audio_sample_t) == sizeof(LADSPA_Data) */
          assert(sizeof(float) /*4ul*/  == sizeof(float) /*4ul*/ );
          unsigned int return_value_jack_get_sample_rate$99;
          return_value_jack_get_sample_rate$99=jack_get_sample_rate(jackClient);
          sample_rate = (float)return_value_jack_get_sample_rate$99;
          void *return_value_malloc$100;
          return_value_malloc$100=malloc((unsigned long int)insTotal * sizeof(struct _jack_port *) /*8ul*/ );
          inputPorts = (struct _jack_port **)return_value_malloc$100;
          void *return_value_calloc$101;
          return_value_calloc$101=calloc((unsigned long int)insTotal, sizeof(float *) /*8ul*/ );
          pluginInputBuffers = (float **)return_value_calloc$101;
          void *return_value_malloc$102;
          return_value_malloc$102=malloc((unsigned long int)insTotal * sizeof(struct _d3h_instance_t *) /*8ul*/ );
          pluginAudioInInstances = (struct _d3h_instance_t **)return_value_malloc$102;
          void *return_value_malloc$103;
          return_value_malloc$103=malloc((unsigned long int)insTotal * sizeof(unsigned long int) /*8ul*/ );
          pluginAudioInPortNumbers = (unsigned long int *)return_value_malloc$103;
          void *return_value_calloc$104;
          return_value_calloc$104=calloc((unsigned long int)controlInsTotal, sizeof(float) /*4ul*/ );
          pluginControlIns = (float *)return_value_calloc$104;
          void *return_value_malloc$105;
          return_value_malloc$105=malloc((unsigned long int)controlInsTotal * sizeof(struct _d3h_instance_t *) /*8ul*/ );
          pluginControlInInstances = (struct _d3h_instance_t **)return_value_malloc$105;
          void *return_value_malloc$106;
          return_value_malloc$106=malloc((unsigned long int)controlInsTotal * sizeof(unsigned long int) /*8ul*/ );
          pluginControlInPortNumbers = (unsigned long int *)return_value_malloc$106;
          void *return_value_malloc$107;
          return_value_malloc$107=malloc((unsigned long int)controlInsTotal * sizeof(signed int) /*4ul*/ );
          pluginPortUpdated = (signed int *)return_value_malloc$107;
          void *return_value_malloc$108;
          return_value_malloc$108=malloc((unsigned long int)outsTotal * sizeof(struct _jack_port *) /*8ul*/ );
          outputPorts = (struct _jack_port **)return_value_malloc$108;
          void *return_value_malloc$109;
          return_value_malloc$109=malloc((unsigned long int)outsTotal * sizeof(float *) /*8ul*/ );
          pluginOutputBuffers = (float **)return_value_malloc$109;
          void *return_value_calloc$110;
          return_value_calloc$110=calloc((unsigned long int)controlOutsTotal, sizeof(float) /*4ul*/ );
          pluginControlOuts = (float *)return_value_calloc$110;
          void *return_value_malloc$111;
          return_value_malloc$111=malloc((unsigned long int)instance_count * sizeof(void *) /*8ul*/ );
          instanceHandles = (void **)return_value_malloc$111;
          void *return_value_malloc$112;
          return_value_malloc$112=malloc((unsigned long int)instance_count * sizeof(struct snd_seq_event *) /*8ul*/ );
          instanceEventBuffers = (struct snd_seq_event **)return_value_malloc$112;
          void *return_value_malloc$113;
          return_value_malloc$113=malloc((unsigned long int)instance_count * sizeof(unsigned long int) /*8ul*/ );
          instanceEventCounts = (unsigned long int *)return_value_malloc$113;
          i = 0;
          for( ; !(i >= instance_count); i = i + 1)
          {
            void *return_value_malloc$114;
            return_value_malloc$114=malloc((unsigned long int)1024 * sizeof(struct snd_seq_event) /*32ul*/ );
            instanceEventBuffers[(signed long int)i] = (struct snd_seq_event *)return_value_malloc$114;
            void *return_value_malloc$115;
            return_value_malloc$115=malloc(instances[(signed long int)i].plugin->descriptor->LADSPA_Plugin->PortCount * sizeof(signed int) /*4ul*/ );
            instances[(signed long int)i].pluginPortControlInNumbers = (signed int *)return_value_malloc$115;
          }
          in = 0;
          out = 0;
          i = 0;
          for( ; !(i >= instance_count); i = i + 1)
          {
            signed int inst_in = 0;
            signed int inst_out = 0;
            instance = &instances[(signed long int)i];
            plugin = instance->plugin;
            j = 0;
            for( ; !((unsigned long int)j >= plugin->descriptor->LADSPA_Plugin->PortCount); j = j + 1)
            {
              signed int main$$1$$11$$1$$1$$1$$pod = plugin->descriptor->LADSPA_Plugin->PortDescriptors[(signed long int)j];
              if(!((0x1 & main$$1$$11$$1$$1$$1$$pod) == 0) && !((0x8 & main$$1$$11$$1$$1$$1$$pod) == 0))
              {
                char portname[65l];
                snprintf(portname, (unsigned long int)65, "inst%02d %s %s", instance->id, plugin->label, plugin->descriptor->LADSPA_Plugin->PortNames[(signed long int)j]);
                inputPorts[(signed long int)in]=jack_port_register(jackClient, portname, "32 bit float mono audio", (unsigned long int)1, (unsigned long int)0);
                if(inputPorts[(signed long int)in] == ((struct _jack_port *)NULL))
                {
                  snprintf(portname, (unsigned long int)65, "inst%02d %s in %d %s", instance->id, plugin->label, inst_in, plugin->descriptor->LADSPA_Plugin->PortNames[(signed long int)j]);
                  inputPorts[(signed long int)in]=jack_port_register(jackClient, portname, "32 bit float mono audio", (unsigned long int)1, (unsigned long int)0);
                }

                if(inputPorts[(signed long int)in] == ((struct _jack_port *)NULL))
                {
                  fprintf(stderr, "%s: Error: Could not create instance '%s' input port '%s'\n", host_name, instance->friendly_name, (const void *)portname);
                  return 1;
                }

                inst_in = inst_in + 1;
                in = in + 1;
              }

              else
                if(!((0x2 & main$$1$$11$$1$$1$$1$$pod) == 0) && !((0x8 & main$$1$$11$$1$$1$$1$$pod) == 0))
                {
                  char main$$1$$11$$1$$1$$1$$2$$portname[65l];
                  snprintf(main$$1$$11$$1$$1$$1$$2$$portname, (unsigned long int)65, "inst%02d %s %s", instance->id, plugin->label, plugin->descriptor->LADSPA_Plugin->PortNames[(signed long int)j]);
                  outputPorts[(signed long int)out]=jack_port_register(jackClient, main$$1$$11$$1$$1$$1$$2$$portname, "32 bit float mono audio", (unsigned long int)2, (unsigned long int)0);
                  if(outputPorts[(signed long int)out] == ((struct _jack_port *)NULL))
                  {
                    snprintf(main$$1$$11$$1$$1$$1$$2$$portname, (unsigned long int)65, "inst%02d %s out %d %s", instance->id, plugin->label, inst_out, plugin->descriptor->LADSPA_Plugin->PortNames[(signed long int)j]);
                    outputPorts[(signed long int)out]=jack_port_register(jackClient, main$$1$$11$$1$$1$$1$$2$$portname, "32 bit float mono audio", (unsigned long int)2, (unsigned long int)0);
                  }

                  if(outputPorts[(signed long int)out] == ((struct _jack_port *)NULL))
                  {
                    ghss_debug(1, " error: Could not create instance '%s' output port '%s'", instance->friendly_name, (const void *)main$$1$$11$$1$$1$$1$$2$$portname);
                    return 1;
                  }

                  inst_out = inst_out + 1;
                  unsigned int return_value_jack_get_buffer_size$116;
                  return_value_jack_get_buffer_size$116=jack_get_buffer_size(jackClient);
                  void *return_value_calloc$117;
                  return_value_calloc$117=calloc((unsigned long int)return_value_jack_get_buffer_size$116, sizeof(float) /*4ul*/ );
                  pluginOutputBuffers[(signed long int)out] = (float *)return_value_calloc$117;
                  out = out + 1;
                }

            }
          }
          jack_set_process_callback(jackClient, audio_callback, NULL);
          ghss_debug(2, ": setting JACK session callback");
          jack_set_session_callback(jackClient, session_callback, NULL);
          i = 0;
          if(!(i >= instance_count))
          {
            plugin = instances[(signed long int)i].plugin;
            instanceHandles[(signed long int)i]=plugin->descriptor->LADSPA_Plugin->instantiate(plugin->descriptor->LADSPA_Plugin, (unsigned long int)sample_rate);
            if(instanceHandles[(signed long int)i] == NULL)
            {
              ghss_debug(1, " error: Failed to instantiate instance %d, plugin '%s'!", i, plugin->label);
              return 1;
            }

            i = i + 1;
          }

          serverThread=lo_server_thread_new((const char *)(void *)0, osc_error);
          host_osc_url=lo_server_thread_get_url(serverThread);
          ghss_debug(64, ": host OSC URL is %s", host_osc_url);
          lo_server_thread_add_method(serverThread, (const char *)(void *)0, (const char *)(void *)0, osc_message_handler, (void *)0);
          lo_server_thread_start(serverThread);
          create_windows(host_name, instance_count);
          in = 0;
          for( ; !(in >= controlInsTotal); in = in + 1)
            pluginPortUpdated[(signed long int)in] = 0;
          controlOut = 0;
          controlIn = controlOut;
          out = controlIn;
          in = out;
          i = 0;
          for( ; !(i >= instance_count); i = i + 1)
          {
            instance = &instances[(signed long int)i];
            instance->firstControlIn = controlIn;
            j = 0;
            for( ; !(j >= 128); j = j + 1)
              instance->controllerMap[(signed long int)j] = (signed long int)-1;
            plugin = instance->plugin;
            j = 0;
            for( ; !((unsigned long int)j >= plugin->descriptor->LADSPA_Plugin->PortCount); j = j + 1)
            {
              signed int main$$1$$15$$1$$2$$1$$pod = plugin->descriptor->LADSPA_Plugin->PortDescriptors[(signed long int)j];
              instance->pluginPortControlInNumbers[(signed long int)j] = -1;
              if(!((0x8 & main$$1$$15$$1$$2$$1$$pod) == 0))
              {
                if(!(instance->have_initial_values == 0))
                {
                  if(!(instance->initial_value_set[(signed long int)j] == 0))
                  {
                    ghss_debug(1, " %s error: port setting given for audio port %d", instance->friendly_name, j);
                    return 2;
                  }

                }

                if(!((0x1 & main$$1$$15$$1$$2$$1$$pod) == 0))
                {
                  pluginAudioInInstances[(signed long int)in] = instance;
                  tmp_post$118 = in;
                  in = in + 1;
                  pluginAudioInPortNumbers[(signed long int)tmp_post$118] = (unsigned long int)j;
                }

                else
                  if(!((0x2 & main$$1$$15$$1$$2$$1$$pod) == 0))
                  {
                    tmp_post$119 = out;
                    out = out + 1;
                    plugin->descriptor->LADSPA_Plugin->connect_port(instanceHandles[(signed long int)i], (unsigned long int)j, pluginOutputBuffers[(signed long int)tmp_post$119]);
                  }

              }

              else
                if(!((0x4 & main$$1$$15$$1$$2$$1$$pod) == 0))
                {
                  if(!((0x1 & main$$1$$15$$1$$2$$1$$pod) == 0))
                  {
                    if(!(plugin->descriptor->get_midi_controller_for_port == ((signed int (*)(void *, unsigned long int))NULL)))
                    {
                      signed int controller;
                      controller=plugin->descriptor->get_midi_controller_for_port(instanceHandles[(signed long int)i], (unsigned long int)j);
                      if(controller == 0)
                        ghss_debug(1, " error: buggy plugin %s:%s wants mapping for bank MSB", plugin->dll->name, plugin->label);

                      else
                        if(controller == 32)
                          ghss_debug(1, " error: buggy plugin %s:%s wants mapping for bank LSB", plugin->dll->name, plugin->label);

                        else
                          if(!((0x20000000 & controller) == 0))
                            instance->controllerMap[(signed long int)(controller & 0x7f)] = (signed long int)controlIn;

                    }

                    pluginControlInInstances[(signed long int)controlIn] = instance;
                    pluginControlInPortNumbers[(signed long int)controlIn] = (unsigned long int)j;
                    instance->pluginPortControlInNumbers[(signed long int)j] = controlIn;
                    pluginControlIns[(signed long int)controlIn]=get_port_default(plugin->descriptor->LADSPA_Plugin, j);
                    tmp_post$120 = controlIn;
                    controlIn = controlIn + 1;
                    plugin->descriptor->LADSPA_Plugin->connect_port(instanceHandles[(signed long int)i], (unsigned long int)j, &pluginControlIns[(signed long int)tmp_post$120]);
                  }

                  else
                    if(!((0x2 & main$$1$$15$$1$$2$$1$$pod) == 0))
                    {
                      if(!(instance->have_initial_values == 0))
                      {
                        if(!(instance->initial_value_set[(signed long int)j] == 0))
                        {
                          ghss_debug(1, ": port setting given for control out port %d, plugin %s, instance %d", j, plugin->label, instance_count);
                          return 2;
                        }

                      }

                      tmp_post$121 = controlOut;
                      controlOut = controlOut + 1;
                      plugin->descriptor->LADSPA_Plugin->connect_port(instanceHandles[(signed long int)i], (unsigned long int)j, &pluginControlOuts[(signed long int)tmp_post$121]);
                    }

                }

            }
            instance->strip=create_plugin_strip(main_window, instance);
            unsigned long int return_value_gtk_box_get_type$122;
            return_value_gtk_box_get_type$122=gtk_box_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast$123;
            return_value_g_type_check_instance_cast$123=g_type_check_instance_cast((struct _GTypeInstance *)plugin_hbox, return_value_gtk_box_get_type$122);
            gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$123, instance->strip->container, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
          }
          /* assertion in == insTotal */
          assert(in == insTotal);
          /* assertion out == outsTotal */
          assert(out == outsTotal);
          /* assertion controlIn == controlInsTotal */
          assert(controlIn == controlInsTotal);
          /* assertion controlOut == controlOutsTotal */
          assert(controlOut == controlOutsTotal);
          signed int return_value_midi_open$124;
          return_value_midi_open$124=midi_open();
          if(return_value_midi_open$124 == 0)
            return 1;

          else
          {
            i = 0;
            for( ; !(i >= instance_count); i = i + 1)
            {
              instance = &instances[(signed long int)i];
              plugin = instance->plugin;
              if(!(plugin->descriptor->configure == ((char * (*)(void *, const char *, const char *))NULL)))
              {
                struct _configure_item_t *item;
                if(!(project_directory == ((char *)NULL)))
                  add_configure_item(&instance->configure_items, "DSSI:PROJECT_DIRECTORY", project_directory);

                item = instance->configure_items;
                if(!(item == ((struct _configure_item_t *)NULL)))
                {
                  tmp=plugin->descriptor->configure(instanceHandles[(signed long int)i], item->key, item->value);
                  if(!(tmp == ((char *)NULL)))
                  {
                    ghss_debug(8, ": on configure '%s' '%s', plugin '%s' returned '%s'", item->key, item->value, instance->friendly_name, tmp);
                    free((void *)tmp);
                  }

                  item = item->next;
                }

              }

              else
                if(!(instance->configure_items == ((struct _configure_item_t *)NULL)))
                  ghss_debug(1, " %s warning: configure items specified for plugin without configure()", instance->friendly_name);

              if(!(plugin->descriptor->select_program == ((void (*)(void *, unsigned long int, unsigned long int))NULL)))
              {
                if(!(instance->pendingProgramChange >= 0))
                {
                  if(!(instance->plugin->descriptor->get_program == ((const struct _DSSI_Program_Descriptor * (*)(void *, unsigned long int))NULL)))
                  {
                    const struct _DSSI_Program_Descriptor *descriptor;
                    descriptor=instance->plugin->descriptor->get_program(instanceHandles[(signed long int)instance->number], (unsigned long int)0);
                    if(!(descriptor == ((const struct _DSSI_Program_Descriptor *)NULL)))
                    {
                      instance->currentBank = (signed long int)descriptor->Bank;
                      instance->currentProgram = (signed long int)descriptor->Program;
                    }

                  }

                }

                plugin->descriptor->select_program(instanceHandles[(signed long int)i], (unsigned long int)instance->currentBank, (unsigned long int)instance->currentProgram);
                instance->uiNeedsProgramUpdate = 1;
              }

              else
                if(instance->pendingProgramChange >= 0)
                  ghss_debug(1, " %s warning: program specified for plugin without select_program()", instance->friendly_name);

              instance->pendingProgramChange = -1;
              if(!(instance->have_initial_values == 0))
              {
                set_initial_port_settings(instance);
                instance->have_initial_values = 0;
              }

              if(!(plugin->descriptor->LADSPA_Plugin->activate == ((void (*)(void *))NULL)))
                plugin->descriptor->LADSPA_Plugin->activate(instanceHandles[(signed long int)i]);

            }
            signed int return_value_jack_activate$125;
            return_value_jack_activate$125=jack_activate(jackClient);
            if(!(return_value_jack_activate$125 == 0))
            {
              ghss_debug(1, ": cannot activate JACK client");
              return 1;
            }

            else
            {
              if(!(autoconnect == 0))
              {
                ports=jack_get_ports(jackClient, (const char *)(void *)0, "^32 bit float mono audio$", (unsigned long int)(4 | 1));
                if(!(ports == ((const char **)NULL)))
                {
                  if(!(*ports == ((const char *)NULL)))
                  {
                    i = 0;
                    j = 0;
                    for( ; !(i >= outsTotal); i = i + 1)
                    {
                      const char *return_value_jack_port_name$126;
                      return_value_jack_port_name$126=jack_port_name(outputPorts[(signed long int)i]);
                      signed int return_value_jack_connect$127;
                      return_value_jack_connect$127=jack_connect(jackClient, return_value_jack_port_name$126, ports[(signed long int)j]);
                      if(!(return_value_jack_connect$127 == 0))
                        fprintf(stderr, "cannot connect output port %d\n", i);

                      j = j + 1;
                      if(ports[(signed long int)j] == ((const char *)NULL))
                        j = 0;

                    }
                    free((void *)ports);
                  }

                }

              }

              signal(2, signalHandler);
              signal(15, signalHandler);
              signal(1, signalHandler);
              signal(3, signalHandler);
              pthread_sigmask(1, &_signals, ((struct anonymous$18 *)NULL));
              signed int return_value_pthread_create$128;
              return_value_pthread_create$128=pthread_create(&midi_thread, (const union pthread_attr_t *)(void *)0, midi_thread_function, (void *)0);
              if(!(return_value_pthread_create$128 == 0))
              {
                ghss_debug(1, ": could not create MIDI thread");
                return 1;
              }

              else
              {
                unsigned int return_value_gtk_timeout_add$129;
                return_value_gtk_timeout_add$129=gtk_timeout_add((unsigned int)50, gtk_timeout_callback, (void *)0);
                gtk_timeout_tag = (signed int)return_value_gtk_timeout_add$129;
                fprintf(stderr, "%s ready\n", host_name);
                gtk_widget_show(main_window);
                host_exiting = 0;
                gtk_main();
                jack_client_close(jackClient);
                gtk_timeout_remove((unsigned int)gtk_timeout_tag);
                i = 0;
                for( ; !(i >= instance_count); i = i + 1)
                {
                  instance = &instances[(signed long int)i];
                  if(!(instance->ui_osc_address == NULL))
                  {
                    instance->ui_running = 0;
                    lo_send_internal(instance->ui_osc_address, "ghostess.c", 2307, instance->ui_osc_quit_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
                    ui_osc_free(instance);
                  }

                  if(!(instance->plugin->descriptor->LADSPA_Plugin->deactivate == ((void (*)(void *))NULL)))
                    instance->plugin->descriptor->LADSPA_Plugin->deactivate(instanceHandles[(signed long int)i]);

                  if(!(instance->plugin->descriptor->LADSPA_Plugin->cleanup == ((void (*)(void *))NULL)))
                    instance->plugin->descriptor->LADSPA_Plugin->cleanup(instanceHandles[(signed long int)i]);

                  free_programs(instance);
                }
                do
                {
                  sleep((unsigned int)1);
                  ghss_debug(2, ": waiting for midi thread to finish");
                }
                while(!(midi_thread_running == 0));
                pthread_join(midi_thread, (void **)(void *)0);
                if(!(host_name == host_name_default))
                  free((void *)host_name);

                if(!(host_osc_url == ((char *)NULL)))
                  free((void *)host_osc_url);

                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// midi_open
// file midi.h line 33
signed int midi_open(void)
{
  signed int return_value_snd_seq_open$1;
  return_value_snd_seq_open$1=snd_seq_open(&alsaClient, "hw", 1 | 2, 0);
  if(!(return_value_snd_seq_open$1 >= 0))
  {
    ghss_debug(1, ": failed to open ALSA sequencer interface");
    return 0;
  }

  else
  {
    snd_seq_set_client_name(alsaClient, host_name);
    alsa_client_id=snd_seq_client_id(alsaClient);
    alsa_port_id=snd_seq_create_simple_port(alsaClient, "input", (unsigned int)(1 << 1 | 1 << 6), (unsigned int)(1 << 20));
    if(!(alsa_port_id >= 0))
    {
      ghss_debug(1, ": failed to create ALSA sequencer port");
      return 0;
    }

    else
    {
      alsaClient_npfd=snd_seq_poll_descriptors_count(alsaClient, (signed short int)0x001);
      void *return_value_calloc$2;
      return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)alsaClient_npfd * sizeof(struct pollfd) /*8ul*/ );
      alsaClient_pfd = (struct pollfd *)return_value_calloc$2;
      snd_seq_poll_descriptors(alsaClient, alsaClient_pfd, (unsigned int)alsaClient_npfd, (signed short int)0x001);
      ghss_debug(1, ": listening using ALSA MIDI");
      return 1;
    }
  }
}

// midi_thread_function
// file midi.h line 34
void * midi_thread_function(void *arg)
{
  signed int rc;
  struct sched_param rtparam;
  struct snd_seq_event *ev = ((struct snd_seq_event *)NULL);
  memset((void *)&rtparam, 0, sizeof(struct sched_param) /*4ul*/ );
  rtparam.__sched_priority = 1;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  rc=pthread_setschedparam(return_value_pthread_self$1, 1, &rtparam);
  if(!(rc == 0))
  {
    if(rc == 1)
      ghss_debug(4, " midi thread: no permission for SCHED_FIFO, continuing...");

    else
      ghss_debug(4, " midi thread: error getting SCHED_FIFO, continuing...");
  }

  midi_thread_running = 1;
  signed int return_value_snd_seq_event_input_pending$4;
  do
  {
    rc=poll(alsaClient_pfd, (unsigned long int)alsaClient_npfd, 500);
    if(!(rc >= 1))
    {
      if(!(rc == 4) && !(rc >= 0))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        ghss_debug(4, " midi thread: poll error: %s", return_value_strerror$3);
        usleep((unsigned int)500);
      }

    }

    else
    {
      pthread_mutex_lock(&midiEventBufferMutex);
      do
      {
        signed int return_value_snd_seq_event_input$5;
        return_value_snd_seq_event_input$5=snd_seq_event_input(alsaClient, &ev);
        if(return_value_snd_seq_event_input$5 >= 1)
        {
          if(midiEventReadIndex == 1 + midiEventWriteIndex)
          {
            ghss_debug(4, " midi thread: MIDI event buffer overflow!");
            goto __CPROVER_DUMP_L10;
          }

          midiEventBuffer[(signed long int)midiEventWriteIndex] = *ev;
          ev = &midiEventBuffer[(signed long int)midiEventWriteIndex];
          if((signed int)ev->type == 6)
          {
            if((signed int)ev->data.note.velocity == 0)
              ev->type = (unsigned char)7;

          }

          ev->time.tick=jack_frame_time(jackClient);
          ev->dest.client = (unsigned char)0;
          midiEventWriteIndex = (midiEventWriteIndex + 1) % 1024;
        }


      __CPROVER_DUMP_L10:
        ;
        return_value_snd_seq_event_input_pending$4=snd_seq_event_input_pending(alsaClient, 0);
      }
      while(return_value_snd_seq_event_input_pending$4 >= 1);
      pthread_mutex_unlock(&midiEventBufferMutex);
    }
  }
  while(host_exiting == 0);
  midi_thread_running = 0;
  return (void *)0;
}

// new_instance_template
// file ghostess.c line 750
static struct _instance_template_t * new_instance_template(void)
{
  struct _instance_template_t *t;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct _instance_template_t) /*80ul*/ );
  t = (struct _instance_template_t *)return_value_calloc$1;
  return t;
}

// on_about_dismiss
// file gui_callbacks.c line 206
void on_about_dismiss(struct _GtkWidget *widget, void *data)
{
  gtk_widget_hide(about_window);
}

// on_delete_event_wrapper
// file gui_callbacks.c line 145
signed int on_delete_event_wrapper(struct _GtkWidget *widget, union _GdkEvent *event, void *data)
{
  void (*handler)(struct _GtkWidget *, void *) = (void (*)(struct _GtkWidget *, void *))data;
  handler(widget, (void *)0);
  return (signed int)!(0 != 0);
}

// on_file_selection_cancel
// file gui_callbacks.c line 164
void on_file_selection_cancel(struct _GtkWidget *widget, void *data)
{
  ghss_debug(256, ": on_save_file_cancel called");
  gtk_widget_hide(file_selection);
}

// on_file_selection_ok
// file gui_callbacks.c line 157
void on_file_selection_ok(struct _GtkWidget *widget, void *data)
{
  gtk_widget_hide(file_selection);
  file_selection_handler(widget, data);
}

// on_menu_about_activate
// file gui_callbacks.c line 103
void on_menu_about_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  char buf[1024l];
  signed int maxlen = 1024;
  signed int len;
  snprintf(buf, (unsigned long int)maxlen, "%s 20120105\nCopyright (C) 2012 by Sean Bolton and others.\n\nThis is sloppy, hurried HACKWARE -- please do not consider this exemplary of the authors' skills or preferences, nor of good DSSI or general programming practices.  (In particular, I don't want anyone attributing my mess to Chris or Steve ;-)\n\n%s comes with ABSOLUTELY NO WARRANTY. It is free software, and you are welcome to redistribute it under certain conditions; see the file COPYING for details.\n\n", host_name_default, host_name_default);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  len = (signed int)return_value_strlen$1;
  snprintf(buf + (signed long int)len, (unsigned long int)(maxlen - len), "Host OSC URL: %s\n", host_osc_url);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(buf);
  len = (signed int)return_value_strlen$2;
  snprintf(buf + (signed long int)len, (unsigned long int)(maxlen - len), "ALSA MIDI input port: %d:%d\n", alsa_client_id, alsa_port_id);
  unsigned long int return_value_gtk_label_get_type$3;
  return_value_gtk_label_get_type$3=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)about_label, return_value_gtk_label_get_type$3);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, buf);
  gtk_widget_show(about_window);
}

// on_menu_patchlist_activate
// file gui_callbacks.c line 83
void on_menu_patchlist_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  file_selection_set_path(last_patchlist_filename);
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_window_get_type$1);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$2, "ghostess - Export Patchlist for Freewheeling");
  file_selection_handler = on_patchlist_file_ok;
  gtk_widget_show(file_selection);
}

// on_menu_quit_activate
// file gui_callbacks.c line 94
void on_menu_quit_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  gtk_main_quit();
  host_exiting = 1;
}

// on_menu_save_activate
// file gui_callbacks.c line 72
void on_menu_save_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  file_selection_set_path(last_save_filename);
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_window_get_type$1);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$2, "ghostess - Save Configuration");
  file_selection_handler = on_save_file_ok;
  gtk_widget_show(file_selection);
}

// on_notice_dismiss
// file gui_callbacks.c line 332
void on_notice_dismiss(struct _GtkWidget *widget, void *data)
{
  gtk_widget_hide(notice_window);
}

// on_patchlist_file_ok
// file gui_callbacks.c line 188
void on_patchlist_file_ok(struct _GtkWidget *widget, void *data)
{
  if(!(last_patchlist_filename == ((char *)NULL)))
    free((void *)last_patchlist_filename);

  unsigned long int return_value_gtk_file_selection_get_type$1;
  return_value_gtk_file_selection_get_type$1=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type$1);
  const char *return_value_gtk_file_selection_get_filename$3;
  return_value_gtk_file_selection_get_filename$3=gtk_file_selection_get_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast$2);
  char *return_value_g_strdup$4;
  return_value_g_strdup$4=g_strdup(return_value_gtk_file_selection_get_filename$3);
  last_patchlist_filename = (char *)return_value_g_strdup$4;
  ghss_debug(256, " on_patchlist_file_ok: file '%s' selected", last_patchlist_filename);
  signed int return_value_write_patchlist$7;
  return_value_write_patchlist$7=write_patchlist(last_patchlist_filename);
  if(return_value_write_patchlist$7 == 0)
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    display_notice("Patchlist export failed:", return_value_strerror$6);
  }

  else
    display_notice("Patchlist exported.", "");
}

// on_save_file_ok
// file gui_callbacks.c line 171
void on_save_file_ok(struct _GtkWidget *widget, void *data)
{
  if(!(last_save_filename == ((char *)NULL)))
    free((void *)last_save_filename);

  unsigned long int return_value_gtk_file_selection_get_type$1;
  return_value_gtk_file_selection_get_type$1=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type$1);
  const char *return_value_gtk_file_selection_get_filename$3;
  return_value_gtk_file_selection_get_filename$3=gtk_file_selection_get_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast$2);
  char *return_value_g_strdup$4;
  return_value_g_strdup$4=g_strdup(return_value_gtk_file_selection_get_filename$3);
  last_save_filename = (char *)return_value_g_strdup$4;
  ghss_debug(256, " on_save_file_ok: file '%s' selected", last_save_filename);
  signed int return_value_write_configuration$7;
  return_value_write_configuration$7=write_configuration(last_save_filename, (const char *)(void *)0);
  if(return_value_write_configuration$7 == 0)
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    display_notice("Save Configuration failed:", return_value_strerror$6);
  }

  else
    display_notice("Configuration Saved.", "");
}

// on_strip_ui_button_event
// file gui_callbacks.c line 235
signed int on_strip_ui_button_event(struct _GtkWidget *widget, struct _GdkEventButton *event, void *data)
{
  struct _d3h_instance_t *instance = ((struct _plugin_strip *)data)->instance;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(!(event->button == 3u))
    return 0;

  else
  {
    ghss_debug(256, " on_strip_ui_button_event: third button click on instance %d", instance->number);
    gtk_widget_set_sensitive(ui_context_menu_launch, (signed int)!(instance->ui_running != 0));
    if(!(instance->ui_running == 0))
      tmp_if_expr$1 = !(instance->ui_visible != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    gtk_widget_set_sensitive(ui_context_menu_show, (signed int)tmp_if_expr$1);
    if(!(instance->ui_running == 0))
      tmp_if_expr$2 = instance->ui_visible != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    gtk_widget_set_sensitive(ui_context_menu_hide, (signed int)tmp_if_expr$2);
    gtk_widget_set_sensitive(ui_context_menu_exit, instance->ui_running);
    ui_context_menu_instance = instance;
    unsigned long int return_value_gtk_menu_get_type$3;
    return_value_gtk_menu_get_type$3=gtk_menu_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type$3);
    gtk_menu_popup((struct _GtkMenu *)return_value_g_type_check_instance_cast$4, (struct _GtkWidget *)(void *)0, (struct _GtkWidget *)(void *)0, (void (*)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *))(void *)0, (void *)0, event->button, event->time);
    return (signed int)!(0 != 0);
  }
}

// on_strip_ui_button_toggled
// file gui_callbacks.c line 212
void on_strip_ui_button_toggled(struct _GtkWidget *widget, void *data)
{
  struct _d3h_instance_t *instance = ((struct _plugin_strip *)data)->instance;
  signed int state;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_toggle_button_get_type$1);
  state = (signed int)((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2)->active;
  ghss_debug(256, " on_strip_ui_button_toggled: instance %d button changed to %s", instance->number, state != 0 ? "on" : "off");
  if(!(instance->ui_osc_address == NULL))
  {
    if(!(state == 0))
    {
      lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 222, instance->ui_osc_show_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
      instance->ui_visible = 1;
    }

    else
    {
      lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 225, instance->ui_osc_hide_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
      instance->ui_visible = 0;
    }
  }

  else
    if(!(state == 0))
    {
      if(instance->ui_running == 0)
      {
        instance->ui_visible = 1;
        start_ui(instance);
      }

    }

}

// on_ui_context_menu_activate
// file gui_callbacks.c line 274
void on_ui_context_menu_activate(struct _GtkWidget *widget, void *data)
{
  signed int mode = (signed int)(signed long int)data;
  struct _d3h_instance_t *instance = ui_context_menu_instance;
  ghss_debug(256, " on_ui_context_menu_activate: menu mode %d selected", mode);
  switch(mode)
  {
    case 0:
    {
      if(instance->ui_osc_address == NULL)
      {
        instance->ui_visible = 1;
        start_ui(instance);
        update_ui_button_internal(instance, (signed int)!(0 != 0));
      }

      break;
    }
    case 1:
    {
      if(!(instance->ui_osc_address == NULL))
      {
        lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 295, instance->ui_osc_show_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
        instance->ui_visible = 1;
        update_ui_button_internal(instance, (signed int)!(0 != 0));
      }

      break;
    }
    case 2:
    {
      if(!(instance->ui_osc_address == NULL))
      {
        lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 303, instance->ui_osc_hide_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
        instance->ui_visible = 0;
        update_ui_button_internal(instance, 0);
      }

      break;
    }
    case 3:
    {
      if(!(instance->ui_osc_address == NULL))
      {
        lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 311, instance->ui_osc_quit_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
        ui_osc_free(instance);
      }

      instance->ui_running = 0;
      instance->ui_visible = 0;
      update_ui_button_internal(instance, 0);
    }
  }
}

// osc_configure_handler
// file ghostess.c line 2575
signed int osc_configure_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv)
{
  const char *key = (const char *)&argv[(signed long int)0]->s;
  const char *value = (const char *)&argv[(signed long int)1]->s;
  char *message;
  signed int i;
  struct _d3h_instance_t *inst;
  ghss_debug(64, " osc_configure_handler: UI for '%s' sent '%s', '%s'", instance->friendly_name, key, value);
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$1;
  signed int return_value_strncmp$2;
  if(instance->plugin->instances == 1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strlen$1=strlen("GLOBAL:");
    return_value_strncmp$2=strncmp(key, "GLOBAL:", return_value_strlen$1);
    tmp_if_expr$3 = return_value_strncmp$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
  {
    if(!(instance->plugin->descriptor->configure == ((char * (*)(void *, const char *, const char *))NULL)))
    {
      add_configure_item(&instance->configure_items, (char *)key, (char *)value);
      message=instance->plugin->descriptor->configure(instanceHandles[(signed long int)instance->number], key, value);
      if(!(message == ((char *)NULL)))
      {
        ghss_debug(8, ": on configure '%s' '%s', plugin '%s' returned '%s'", key, value, instance->friendly_name, message);
        free((void *)message);
      }

    }

    instance->pluginProgramsValid = 0;
    return 0;
  }

  else
  {
    i = 0;
    for( ; !(instances[(signed long int)i].plugin == instance->plugin); i = i + instances[(signed long int)i].plugin->instances)
      ;
    for( ; instances[(signed long int)i].plugin == instance->plugin; i = i + 1)
    {
      inst = &instances[(signed long int)i];
      if(!(inst->plugin->descriptor->configure == ((char * (*)(void *, const char *, const char *))NULL)))
      {
        add_configure_item(&inst->configure_items, (char *)key, (char *)value);
        message=inst->plugin->descriptor->configure(instanceHandles[(signed long int)i], key, value);
        if(!(message == ((char *)NULL)))
        {
          ghss_debug(8, ": on configure '%s' '%s', plugin '%s' returned '%s'", key, value, inst->friendly_name, message);
          free((void *)message);
        }

      }

      instance->pluginProgramsValid = 0;
      if(!(i == instance->number))
      {
        if(!(inst->ui_osc_address == NULL))
          lo_send_internal(inst->ui_osc_address, "ghostess.c", 2635, inst->ui_osc_configure_path, "ss", key, value, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

      }

    }
    return 0;
  }
}

// osc_control_handler
// file ghostess.c line 2516
signed int osc_control_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv)
{
  signed int port = argv[(signed long int)0]->i;
  float value = argv[(signed long int)1]->f;
  _Bool tmp_if_expr$1;
  if(!(port >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (unsigned long int)port > instance->plugin->descriptor->LADSPA_Plugin->PortCount ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    ghss_debug(64, " OSC control handler: %s port number (%d) is out of range", instance->friendly_name, port);
    return 0;
  }

  else
    if(instance->pluginPortControlInNumbers[(signed long int)port] == -1)
    {
      ghss_debug(64, " OSC control handler: %s port %d is not a control in", instance->friendly_name, port);
      return 0;
    }

    else
    {
      pluginControlIns[(signed long int)instance->pluginPortControlInNumbers[(signed long int)port]] = value;
      ghss_debug(64, " OSC control handler: %s port %d = %f", instance->friendly_name, port, value);
      return 0;
    }
}

// osc_debug_handler
// file ghostess.c line 2734
signed int osc_debug_handler(const char *path, const char *types, union anonymous$7 **argv, signed int argc, void *data, void *user_data)
{
  signed int i;
  ghss_debug(64, ": got unhandled OSC message:");
  ghss_debug(64, ": path: <%s>", path);
  fflush(stderr);
  i = 0;
  for( ; !(i >= argc); i = i + 1)
  {
    printf("%s: arg %d '%c' ", host_name, i, types[(signed long int)i]);
    lo_arg_pp((enum anonymous$15)types[(signed long int)i], (void *)argv[(signed long int)i]);
    printf("\n");
  }
  fflush(stdout);
  ghss_debug(64, ":");
  return 1;
}

// osc_error
// file ghostess.c line 2424
void osc_error(signed int num, const char *msg, const char *path)
{
  ghss_debug(64, ": liblo server error %d in path %s: %s", num, path, msg);
}

// osc_exiting_handler
// file ghostess.c line 2430
signed int osc_exiting_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv)
{
  ghss_debug(64, " OSC: got exiting notification from %s", instance->friendly_name);
  instance->ui_running = 0;
  if(!(instance->ui_osc_address == NULL))
    ui_osc_free(instance);

  update_from_exiting(instance);
  return 0;
}

// osc_message_handler
// file ghostess.c line 2753
signed int osc_message_handler(const char *path, const char *types, union anonymous$7 **argv, signed int argc, void *data, void *user_data)
{
  signed int i;
  struct _d3h_instance_t *instance = (struct _d3h_instance_t *)(void *)0;
  const char *method;
  unsigned int flen = (unsigned int)0;
  void *source;
  signed int send_to_ui = 0;
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(path, "/dssi/", (unsigned long int)6);
  signed int return_value_osc_debug_handler$1;
  signed int return_value_osc_debug_handler$5;
  _Bool tmp_if_expr$7;
  signed int return_value_osc_debug_handler$6;
  signed int tmp_statement_expression$8;
  _Bool tmp_if_expr$16;
  signed int tmp_statement_expression$12;
  signed int tmp_statement_expression$44;
  _Bool tmp_if_expr$48;
  signed int tmp_statement_expression$46;
  signed int tmp_statement_expression$39;
  _Bool tmp_if_expr$43;
  signed int tmp_statement_expression$41;
  signed int tmp_statement_expression$37;
  signed int tmp_statement_expression$32;
  _Bool tmp_if_expr$36;
  signed int tmp_statement_expression$34;
  signed int tmp_statement_expression$27;
  _Bool tmp_if_expr$31;
  signed int tmp_statement_expression$29;
  signed int tmp_statement_expression$25;
  signed int tmp_statement_expression$23;
  if(!(return_value_strncmp$2 == 0))
  {
    return_value_osc_debug_handler$1=osc_debug_handler(path, types, argv, argc, data, user_data);
    return return_value_osc_debug_handler$1;
  }

  else
  {
    i = 0;
    for( ; !(i >= instance_count); i = i + 1)
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(instances[(signed long int)i].friendly_name);
      flen = (unsigned int)return_value_strlen$3;
      signed int return_value_strncmp$4;
      return_value_strncmp$4=strncmp(path + (signed long int)6, instances[(signed long int)i].friendly_name, (unsigned long int)flen);
      if(return_value_strncmp$4 == 0)
      {
        if((signed int)path[6l + (signed long int)flen] == 47)
        {
          instance = &instances[(signed long int)i];
          break;
        }

      }

    }
    if(instance == ((struct _d3h_instance_t *)NULL))
    {
      return_value_osc_debug_handler$5=osc_debug_handler(path, types, argv, argc, data, user_data);
      return return_value_osc_debug_handler$5;
    }

    else
    {
      method = path + (signed long int)6 + (signed long int)flen;
      if(!((signed int)*method == 47))
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)method[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        return_value_osc_debug_handler$6=osc_debug_handler(path, types, argv, argc, data, user_data);
        return return_value_osc_debug_handler$6;
      }

      else
      {
        method = method + 1l;
        source=lo_message_get_source((void *)data);
        if(!(instance->ui_osc_source == NULL))
        {
          if(!(instance->ui_osc_address == NULL))
          {
            unsigned long int osc_message_handler$$1$$3$$1$$__s1_len;
            unsigned long int osc_message_handler$$1$$3$$1$$__s2_len;
            const char *return_value_lo_address_get_hostname$9;
            return_value_lo_address_get_hostname$9=lo_address_get_hostname(source);
            const char *return_value_lo_address_get_hostname$10;
            return_value_lo_address_get_hostname$10=lo_address_get_hostname(instance->ui_osc_source);
            signed int return_value___builtin_strcmp$11;
            return_value___builtin_strcmp$11=__builtin_strcmp(return_value_lo_address_get_hostname$9, return_value_lo_address_get_hostname$10);
            tmp_statement_expression$8 = return_value___builtin_strcmp$11;
            if(!(tmp_statement_expression$8 == 0))
              tmp_if_expr$16 = (_Bool)1;

            else
            {
              unsigned long int __s1_len;
              unsigned long int __s2_len;
              const char *return_value_lo_address_get_port$13;
              return_value_lo_address_get_port$13=lo_address_get_port(source);
              const char *return_value_lo_address_get_port$14;
              return_value_lo_address_get_port$14=lo_address_get_port(instance->ui_osc_source);
              signed int return_value___builtin_strcmp$15;
              return_value___builtin_strcmp$15=__builtin_strcmp(return_value_lo_address_get_port$13, return_value_lo_address_get_port$14);
              tmp_statement_expression$12 = return_value___builtin_strcmp$15;
              tmp_if_expr$16 = tmp_statement_expression$12 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$16)
              send_to_ui = 1;

          }

        }

        unsigned long int osc_message_handler$$1$$4$$__s1_len;
        unsigned long int osc_message_handler$$1$$4$$__s2_len;
        signed int return_value___builtin_strcmp$45;
        return_value___builtin_strcmp$45=__builtin_strcmp(method, "configure");
        tmp_statement_expression$44 = return_value___builtin_strcmp$45;
        if(tmp_statement_expression$44 == 0 && argc == 2)
        {
          unsigned long int osc_message_handler$$1$$5$$__s1_len;
          unsigned long int osc_message_handler$$1$$5$$__s2_len;
          signed int return_value___builtin_strcmp$47;
          return_value___builtin_strcmp$47=__builtin_strcmp(types, "ss");
          tmp_statement_expression$46 = return_value___builtin_strcmp$47;
          tmp_if_expr$48 = !(tmp_statement_expression$46 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$48 = (_Bool)0;
        if(tmp_if_expr$48)
        {
          if(!(send_to_ui == 0))
            lo_send_internal(instance->ui_osc_address, "ghostess.c", 2799, instance->ui_osc_configure_path, "ss", &argv[(signed long int)0]->s, &argv[(signed long int)1]->s, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

          signed int return_value_osc_configure_handler$17;
          return_value_osc_configure_handler$17=osc_configure_handler(instance, argv);
          return return_value_osc_configure_handler$17;
        }

        else
        {
          unsigned long int osc_message_handler$$1$$7$$__s1_len;
          unsigned long int osc_message_handler$$1$$7$$__s2_len;
          signed int return_value___builtin_strcmp$40;
          return_value___builtin_strcmp$40=__builtin_strcmp(method, "control");
          tmp_statement_expression$39 = return_value___builtin_strcmp$40;
          if(tmp_statement_expression$39 == 0 && argc == 2)
          {
            unsigned long int osc_message_handler$$1$$8$$__s1_len;
            unsigned long int osc_message_handler$$1$$8$$__s2_len;
            signed int return_value___builtin_strcmp$42;
            return_value___builtin_strcmp$42=__builtin_strcmp(types, "if");
            tmp_statement_expression$41 = return_value___builtin_strcmp$42;
            tmp_if_expr$43 = !(tmp_statement_expression$41 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$43 = (_Bool)0;
          if(tmp_if_expr$43)
          {
            if(!(send_to_ui == 0))
              lo_send_internal(instance->ui_osc_address, "ghostess.c", 2808, instance->ui_osc_control_path, "if", argv[(signed long int)0]->i, argv[(signed long int)1]->f, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

            signed int return_value_osc_control_handler$18;
            return_value_osc_control_handler$18=osc_control_handler(instance, argv);
            return return_value_osc_control_handler$18;
          }

          else
          {
            unsigned long int osc_message_handler$$1$$10$$__s1_len;
            unsigned long int osc_message_handler$$1$$10$$__s2_len;
            signed int return_value___builtin_strcmp$38;
            return_value___builtin_strcmp$38=__builtin_strcmp(method, "exiting");
            tmp_statement_expression$37 = return_value___builtin_strcmp$38;
            if(tmp_statement_expression$37 == 0 && argc == 0)
            {
              signed int return_value_osc_exiting_handler$19;
              return_value_osc_exiting_handler$19=osc_exiting_handler(instance, argv);
              return return_value_osc_exiting_handler$19;
            }

            else
            {
              unsigned long int osc_message_handler$$1$$12$$__s1_len;
              unsigned long int osc_message_handler$$1$$12$$__s2_len;
              signed int return_value___builtin_strcmp$33;
              return_value___builtin_strcmp$33=__builtin_strcmp(method, "midi");
              tmp_statement_expression$32 = return_value___builtin_strcmp$33;
              if(tmp_statement_expression$32 == 0 && argc == 1)
              {
                unsigned long int osc_message_handler$$1$$13$$__s1_len;
                unsigned long int osc_message_handler$$1$$13$$__s2_len;
                signed int return_value___builtin_strcmp$35;
                return_value___builtin_strcmp$35=__builtin_strcmp(types, "m");
                tmp_statement_expression$34 = return_value___builtin_strcmp$35;
                tmp_if_expr$36 = !(tmp_statement_expression$34 != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$36 = (_Bool)0;
              if(tmp_if_expr$36)
              {
                signed int return_value_osc_midi_handler$20;
                return_value_osc_midi_handler$20=osc_midi_handler(instance, argv);
                return return_value_osc_midi_handler$20;
              }

              else
              {
                unsigned long int osc_message_handler$$1$$15$$__s1_len;
                unsigned long int osc_message_handler$$1$$15$$__s2_len;
                signed int return_value___builtin_strcmp$28;
                return_value___builtin_strcmp$28=__builtin_strcmp(method, "program");
                tmp_statement_expression$27 = return_value___builtin_strcmp$28;
                if(tmp_statement_expression$27 == 0 && argc == 2)
                {
                  unsigned long int osc_message_handler$$1$$16$$__s1_len;
                  unsigned long int osc_message_handler$$1$$16$$__s2_len;
                  signed int return_value___builtin_strcmp$30;
                  return_value___builtin_strcmp$30=__builtin_strcmp(types, "ii");
                  tmp_statement_expression$29 = return_value___builtin_strcmp$30;
                  tmp_if_expr$31 = !(tmp_statement_expression$29 != 0) ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$31 = (_Bool)0;
                if(tmp_if_expr$31)
                {
                  if(!(send_to_ui == 0))
                    lo_send_internal(instance->ui_osc_address, "ghostess.c", 2825, instance->ui_osc_program_path, "ii", argv[(signed long int)0]->i, argv[(signed long int)1]->i, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

                  signed int return_value_osc_program_handler$21;
                  return_value_osc_program_handler$21=osc_program_handler(instance, argv);
                  return return_value_osc_program_handler$21;
                }

                else
                {
                  unsigned long int osc_message_handler$$1$$18$$__s1_len;
                  unsigned long int osc_message_handler$$1$$18$$__s2_len;
                  signed int return_value___builtin_strcmp$26;
                  return_value___builtin_strcmp$26=__builtin_strcmp(method, "update");
                  tmp_statement_expression$25 = return_value___builtin_strcmp$26;
                  if(tmp_statement_expression$25 == 0)
                  {
                    if(argc == 1)
                    {
                      unsigned long int osc_message_handler$$1$$19$$__s1_len;
                      unsigned long int osc_message_handler$$1$$19$$__s2_len;
                      signed int return_value___builtin_strcmp$24;
                      return_value___builtin_strcmp$24=__builtin_strcmp(types, "s");
                      tmp_statement_expression$23 = return_value___builtin_strcmp$24;
                      if(tmp_statement_expression$23 == 0)
                      {
                        signed int return_value_osc_update_handler$22;
                        return_value_osc_update_handler$22=osc_update_handler(instance, argv, source);
                        return return_value_osc_update_handler$22;
                      }

                    }

                  }

                }
              }
            }
          }
        }
        signed int return_value_osc_debug_handler$49;
        return_value_osc_debug_handler$49=osc_debug_handler(path, types, argv, argc, data, user_data);
        return return_value_osc_debug_handler$49;
      }
    }
  }
}

// osc_midi_handler
// file ghostess.c line 2447
signed int osc_midi_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv)
{
  signed long int count;
  static struct snd_seq_event alsaEncodeBuffer[10l];
  struct snd_seq_event *ev = &alsaEncodeBuffer[(signed long int)0];
  ghss_debug(64, " OSC: got midi request for %s (%02x %02x %02x %02x)", instance->friendly_name, argv[(signed long int)0]->m[(signed long int)0], argv[(signed long int)0]->m[(signed long int)1], argv[(signed long int)0]->m[(signed long int)2], argv[(signed long int)0]->m[(signed long int)3]);
  static struct snd_midi_event *alsaCoder = (struct snd_midi_event *)(void *)0;
  if(alsaCoder == ((struct snd_midi_event *)NULL))
  {
    signed int return_value_snd_midi_event_new$1;
    return_value_snd_midi_event_new$1=snd_midi_event_new((unsigned long int)10, &alsaCoder);
    if(!(return_value_snd_midi_event_new$1 == 0))
    {
      ghss_debug(64, " OSC midi handler: Failed to initialise ALSA MIDI coder!");
      return 0;
    }

  }

  snd_midi_event_reset_encode(alsaCoder);
  count=snd_midi_event_encode(alsaCoder, argv[(signed long int)0]->m + (signed long int)1, (signed long int)3, alsaEncodeBuffer);
  _Bool tmp_if_expr$2;
  if(count == 0l)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !((snd_seq_event_types[(signed long int)ev->type] & (unsigned int)(1 << 1 | 1 << 2)) != 0u) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    ev->dest.client = (unsigned char)1;
    ev->dest.port = (unsigned char)instance->number;
    ev->time.tick = (unsigned int)0;
    if((signed int)ev->type == 6)
    {
      if((signed int)ev->data.note.velocity == 0)
        ev->type = (unsigned char)7;

    }

    pthread_mutex_lock(&midiEventBufferMutex);
    if(midiEventReadIndex == 1 + midiEventWriteIndex)
      ghss_debug(64, " OSC midi handler warning: MIDI event buffer overflow!");

    else
    {
      if((signed int)ev->type == 10)
      {
        if(ev->data.control.param == 0u)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = ev->data.control.param == (unsigned int)32 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        ghss_debug(64, " OSC midi handler warning: %s UI sent bank select controller (should use /program OSC call), ignoring", instance->friendly_name);

      else
        if((signed int)ev->type == 11)
          ghss_debug(64, " OSC midi handler warning: %s UI sent program change (should use /program OSC call), ignoring", instance->friendly_name);

        else
        {
          midiEventBuffer[(signed long int)midiEventWriteIndex] = *ev;
          midiEventWriteIndex = (midiEventWriteIndex + 1) % 1024;
        }
    }
    pthread_mutex_unlock(&midiEventBufferMutex);
    return 0;
  }
}

// osc_program_handler
// file ghostess.c line 2539
signed int osc_program_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv)
{
  signed int bank = argv[(signed long int)0]->i;
  signed int program = argv[(signed long int)1]->i;
  signed int i;
  signed int found = 0;
  if(!((64 & debug_flags) == 0))
  {
    if(instance->pluginProgramsValid == 0)
      query_programs(instance);

    i = 0;
    for( ; !(i >= instance->pluginProgramCount); i = i + 1)
      if((instance->pluginPrograms + (signed long int)i)->Bank == (unsigned long int)bank)
      {
        if((instance->pluginPrograms + (signed long int)i)->Program == (unsigned long int)program)
        {
          ghss_debug(64, " OSC program handler: %s setting bank %d, program %d, name %s", instance->friendly_name, bank, program, (instance->pluginPrograms + (signed long int)i)->Name);
          found = 1;
          break;
        }

      }

    if(found == 0)
      ghss_debug(64, " OSC program handler: %s UI requested unknown program: bank %d, program %d: sending to plugin anyway (plugin should ignore it)", instance->friendly_name, bank, program);

  }

  instance->pendingBankMSB = bank / 128;
  instance->pendingBankLSB = bank % 128;
  instance->pendingProgramChange = program;
  return 0;
}

// osc_update_handler
// file ghostess.c line 2643
signed int osc_update_handler(struct _d3h_instance_t *instance, union anonymous$7 **argv, void *source)
{
  const char *url = (char *)&argv[(signed long int)0]->s;
  const char *path;
  unsigned int i;
  char *host;
  char *port;
  struct _configure_item_t *item;
  printf("%s: OSC: got update request from <%s>\n", host_name, url);
  if(!(instance->ui_osc_address == NULL))
    lo_address_free(instance->ui_osc_address);

  host=lo_url_get_hostname(url);
  port=lo_url_get_port(url);
  instance->ui_osc_address=lo_address_new(host, port);
  free((void *)host);
  free((void *)port);
  if(!(instance->ui_osc_source == NULL))
    lo_address_free(instance->ui_osc_source);

  const char *return_value_lo_address_get_hostname$1;
  return_value_lo_address_get_hostname$1=lo_address_get_hostname(source);
  host = (char *)return_value_lo_address_get_hostname$1;
  const char *return_value_lo_address_get_port$2;
  return_value_lo_address_get_port$2=lo_address_get_port(source);
  port = (char *)return_value_lo_address_get_port$2;
  instance->ui_osc_source=lo_address_new(host, port);
  path=lo_url_get_path(url);
  if(!(instance->ui_osc_configure_path == ((char *)NULL)))
    free((void *)instance->ui_osc_configure_path);

  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(path);
  void *return_value_malloc$4;
  return_value_malloc$4=malloc(return_value_strlen$3 + (unsigned long int)11);
  instance->ui_osc_configure_path = (char *)return_value_malloc$4;
  sprintf(instance->ui_osc_configure_path, "%s/configure", path);
  if(!(instance->ui_osc_control_path == ((char *)NULL)))
    free((void *)instance->ui_osc_control_path);

  unsigned long int return_value_strlen$5;
  return_value_strlen$5=strlen(path);
  void *return_value_malloc$6;
  return_value_malloc$6=malloc(return_value_strlen$5 + (unsigned long int)10);
  instance->ui_osc_control_path = (char *)return_value_malloc$6;
  sprintf(instance->ui_osc_control_path, "%s/control", path);
  if(!(instance->ui_osc_hide_path == ((char *)NULL)))
    free((void *)instance->ui_osc_hide_path);

  unsigned long int return_value_strlen$7;
  return_value_strlen$7=strlen(path);
  void *return_value_malloc$8;
  return_value_malloc$8=malloc(return_value_strlen$7 + (unsigned long int)10);
  instance->ui_osc_hide_path = (char *)return_value_malloc$8;
  sprintf(instance->ui_osc_hide_path, "%s/hide", path);
  if(!(instance->ui_osc_program_path == ((char *)NULL)))
    free((void *)instance->ui_osc_program_path);

  unsigned long int return_value_strlen$9;
  return_value_strlen$9=strlen(path);
  void *return_value_malloc$10;
  return_value_malloc$10=malloc(return_value_strlen$9 + (unsigned long int)10);
  instance->ui_osc_program_path = (char *)return_value_malloc$10;
  sprintf(instance->ui_osc_program_path, "%s/program", path);
  if(!(instance->ui_osc_rate_path == ((char *)NULL)))
    free((void *)instance->ui_osc_rate_path);

  unsigned long int return_value_strlen$11;
  return_value_strlen$11=strlen(path);
  void *return_value_malloc$12;
  return_value_malloc$12=malloc(return_value_strlen$11 + (unsigned long int)13);
  instance->ui_osc_rate_path = (char *)return_value_malloc$12;
  sprintf(instance->ui_osc_rate_path, "%s/sample-rate", path);
  if(!(instance->ui_osc_show_path == ((char *)NULL)))
    free((void *)instance->ui_osc_show_path);

  unsigned long int return_value_strlen$13;
  return_value_strlen$13=strlen(path);
  void *return_value_malloc$14;
  return_value_malloc$14=malloc(return_value_strlen$13 + (unsigned long int)10);
  instance->ui_osc_show_path = (char *)return_value_malloc$14;
  sprintf(instance->ui_osc_show_path, "%s/show", path);
  if(!(instance->ui_osc_quit_path == ((char *)NULL)))
    free((void *)instance->ui_osc_quit_path);

  unsigned long int return_value_strlen$15;
  return_value_strlen$15=strlen(path);
  void *return_value_malloc$16;
  return_value_malloc$16=malloc(return_value_strlen$15 + (unsigned long int)10);
  instance->ui_osc_quit_path = (char *)return_value_malloc$16;
  sprintf(instance->ui_osc_quit_path, "%s/quit", path);
  free((void *)(char *)path);
  signed long int return_value_lrintf$17;
  return_value_lrintf$17=lrintf(sample_rate);
  lo_send_internal(instance->ui_osc_address, "ghostess.c", 2698, instance->ui_osc_rate_path, "i", return_value_lrintf$17, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
  item = instance->configure_items;
  for( ; !(item == ((struct _configure_item_t *)NULL)); item = item->next)
    lo_send_internal(instance->ui_osc_address, "ghostess.c", 2703, instance->ui_osc_configure_path, "ss", item->key, item->value, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
  if(!(instance->plugin->descriptor->select_program == ((void (*)(void *, unsigned long int, unsigned long int))NULL)))
  {
    if(!(instance->pendingProgramChange >= 0))
    {
      unsigned long int bank = (unsigned long int)instance->currentBank;
      unsigned long int program = (unsigned long int)instance->currentProgram;
      instance->uiNeedsProgramUpdate = 0;
      lo_send_internal(instance->ui_osc_address, "ghostess.c", 2713, instance->ui_osc_program_path, "ii", bank, program, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
    }

  }

  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)instance->plugin->controlIns); i = i + 1u)
  {
    signed int in = (signed int)(i + (unsigned int)instance->firstControlIn);
    signed int osc_update_handler$$1$$3$$1$$port = (signed int)pluginControlInPortNumbers[(signed long int)in];
    lo_send_internal(instance->ui_osc_address, "ghostess.c", 2721, instance->ui_osc_control_path, "if", osc_update_handler$$1$$3$$1$$port, pluginControlIns[(signed long int)in], (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
    if(i % 50u == 49u)
      usleep((unsigned int)300000);

  }
  if(!(instance->ui_visible == 0))
  {
    if(instance->ui_initial_show_sent == 0)
    {
      lo_send_internal(instance->ui_osc_address, "ghostess.c", 2727, instance->ui_osc_show_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
      instance->ui_initial_show_sent = 1;
    }

  }

  return 0;
}

// query_programs
// file ghostess.c line 1267
void query_programs(struct _d3h_instance_t *instance)
{
  signed int i;
  const struct _DSSI_Program_Descriptor *descriptor;
  if(instance->pluginProgramsValid == 0)
  {
    if(instance->plugin->descriptor->get_program == ((const struct _DSSI_Program_Descriptor * (*)(void *, unsigned long int))NULL))
    {
      instance->pluginProgramsValid = 1;
      instance->pluginProgramCount = 0;
    }

    else
    {
      i = 0;
      for( ; !(i >= instance->pluginProgramCount); i = i + 1)
        free((void *)(instance->pluginPrograms + (signed long int)i)->Name);
      instance->pluginProgramCount = 0;
      i = 0;
      descriptor=instance->plugin->descriptor->get_program(instanceHandles[(signed long int)instance->number], (unsigned long int)i);
      if(!(descriptor == ((const struct _DSSI_Program_Descriptor *)NULL)))
      {
        if(i >= instance->pluginProgramsAlloc)
        {
          instance->pluginProgramsAlloc = instance->pluginProgramsAlloc + 128;
          void *return_value_realloc$1;
          return_value_realloc$1=realloc((void *)instance->pluginPrograms, (unsigned long int)instance->pluginProgramsAlloc * sizeof(struct _DSSI_Program_Descriptor) /*24ul*/ );
          instance->pluginPrograms = (struct _DSSI_Program_Descriptor *)return_value_realloc$1;
        }

        (instance->pluginPrograms + (signed long int)i)->Bank = descriptor->Bank;
        (instance->pluginPrograms + (signed long int)i)->Program = descriptor->Program;
        char *return_value___strdup$2;
        return_value___strdup$2=__strdup(descriptor->Name);
        (instance->pluginPrograms + (signed long int)i)->Name = return_value___strdup$2;
        ghss_debug(128, " %s: program %d is MIDI bank %lu program %lu, named '%s'", instance->friendly_name, i, (instance->pluginPrograms + (signed long int)i)->Bank, (instance->pluginPrograms + (signed long int)i)->Program, (instance->pluginPrograms + (signed long int)i)->Name);
        instance->pluginProgramCount = instance->pluginProgramCount + 1;
        i = i + 1;
      }

      instance->pluginProgramsValid = 1;
    }
  }

}

// reset_instance_template
// file ghostess.c line 757
static void reset_instance_template(struct _instance_template_t *t)
{
  struct _configure_item_t *c;
  signed int i;
  do
  {
    c = t->configure_items;
    if(c == ((struct _configure_item_t *)NULL))
      break;

    t->configure_items = c->next;
    free((void *)c->key);
    free((void *)c->value);
    free((void *)c);
  }
  while((_Bool)1);
  t->program_set = 0;
  t->bank = (unsigned long int)0;
  t->program = (unsigned long int)0;
  t->ports.have_settings = 0;
  t->ports.highest_set = (unsigned long int)0;
  i = 0;
  for( ; !((unsigned long int)i >= t->ports.allocated); i = i + 1)
    t->ports.set[(signed long int)i] = 0;
}

// session_callback
// file ghostess.c line 657
void session_callback(struct _jack_session_event *event, void *arg)
{
  g_idle_add(session_gui_idle_callback, (void *)event);
}

// session_gui_idle_callback
// file ghostess.c line 627
signed int session_gui_idle_callback(void *arg)
{
  char *filename;
  char *command;
  struct _jack_session_event *session_event = (struct _jack_session_event *)arg;
  filename=g_strdup_printf("%sghostess.cfg", session_event->session_dir);
  command = "/bin/sh ${SESSION_DIR}ghostess.cfg";
  ghss_debug(2 | 256, " session_gui_idle_callback: %s to '%s'", (signed int)session_event->type == JackSessionSaveAndQuit ? "save-and-quit" : "save", filename);
  write_configuration(filename, session_event->client_uuid);
  g_free((void *)filename);
  session_event->command_line=g_strdup(command);
  jack_session_reply(jackClient, session_event);
  if((signed int)session_event->type == JackSessionSaveAndQuit)
    host_exiting = (signed int)!(0 != 0);

  jack_session_event_free(session_event);
  return 0;
}

// setControl
// file ghostess.c line 176
void setControl(struct _d3h_instance_t *instance, signed long int controlIn, struct snd_seq_event *event)
{
  signed long int port = (signed long int)pluginControlInPortNumbers[controlIn];
  const struct _LADSPA_Descriptor *p = instance->plugin->descriptor->LADSPA_Plugin;
  signed int d = (p->PortRangeHints + port)->HintDescriptor;
  float lb = (p->PortRangeHints + port)->LowerBound;
  float ub = (p->PortRangeHints + port)->UpperBound;
  float value = (float)event->data.control.value;
  if(!((0x8 & d) == 0))
  {
    lb = lb * sample_rate;
    ub = ub * sample_rate;
  }

  if((0x1 & d) == 0)
  {
    if((0x2 & d) == 0)
      goto __CPROVER_DUMP_L9;

    else
      value = (ub - 127.0f) + value;
  }

  else
    if((0x2 & d) == 0)
      value = lb + value;

    else
      if(lb > 0.0f && ub > 0.0f && !((0x10 & d) == 0))
      {
        lb=logf(lb);
        ub=logf(ub);
        value = lb + ((ub - lb) * value) / 127.0f;
        value=expf(value);
      }

      else
        value = lb + ((ub - lb) * value) / 127.0f;
  if(!((0x20 & d) == 0))
  {
    signed long int return_value_lrintf$1;
    return_value_lrintf$1=lrintf(value);
    value = (float)return_value_lrintf$1;
  }

  ghss_debug(16, ": %s MIDI controller %d=%d -> control in %ld=%f", instance->friendly_name, event->data.control.param, event->data.control.value, controlIn, value);
  pluginControlIns[controlIn] = value;
  pluginPortUpdated[controlIn] = 1;

__CPROVER_DUMP_L9:
  ;
}

// set_initial_port_settings
// file ghostess.c line 817
void set_initial_port_settings(struct _d3h_instance_t *instance)
{
  signed int i;
  signed int in;
  i = 0;
  for( ; !((unsigned long int)i >= instance->plugin->descriptor->LADSPA_Plugin->PortCount); i = i + 1)
    if(!(instance->initial_value_set[(signed long int)i] == 0))
    {
      in = instance->pluginPortControlInNumbers[(signed long int)i];
      pluginControlIns[(signed long int)in] = instance->initial_value[(signed long int)i];
      pluginPortUpdated[(signed long int)in] = 1;
    }

}

// signalHandler
// file ghostess.c line 168
void signalHandler(signed int sig)
{
  ghss_debug(2, ": signal caught, trying to clean up and exit");
  host_exiting = 1;
}

// start_ui
// file ghostess.c line 1079
void start_ui(struct _d3h_instance_t *instance)
{
  const char *directory = instance->plugin->dll->directory;
  const char *dllName = instance->plugin->dll->name;
  const char *label = instance->plugin->descriptor->LADSPA_Plugin->Label;
  struct dirent *entry;
  char *dllBase;
  char *return_value___strdup$1;
  return_value___strdup$1=__strdup(dllName);
  dllBase = return_value___strdup$1;
  char *subpath;
  char *path;
  char *origPath;
  struct __dirstream *subdir;
  char *filename;
  struct stat buf;
  char *osc_url;
  char tag[12l];
  signed int fuzzy;
  signed int pid;
  unsigned long int return_value_strlen$5;
  return_value_strlen$5=strlen(dllBase);
  unsigned long int return_value_strlen$3;
  signed int return_value_strcasecmp$4;
  if(return_value_strlen$5 >= 4ul)
  {
    return_value_strlen$3=strlen(dllBase);
    return_value_strcasecmp$4=strcasecmp((dllBase + (signed long int)return_value_strlen$3) - (signed long int)3, ".so");
    if(return_value_strcasecmp$4 == 0)
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(dllBase);
      dllBase[(signed long int)(return_value_strlen$2 - (unsigned long int)3)] = (char)0;
    }

  }

  if((signed int)*dllBase == 47)
  {
    subpath = dllBase;
    char *return_value_strrchr$6;
    return_value_strrchr$6=strrchr(subpath, 47);
    char *return_value___strdup$7;
    return_value___strdup$7=__strdup(return_value_strrchr$6 + (signed long int)1);
    dllBase = return_value___strdup$7;
  }

  else
  {
    unsigned long int return_value_strlen$8;
    return_value_strlen$8=strlen(directory);
    unsigned long int return_value_strlen$9;
    return_value_strlen$9=strlen(dllBase);
    void *return_value_malloc$10;
    return_value_malloc$10=malloc(return_value_strlen$8 + return_value_strlen$9 + (unsigned long int)2);
    subpath = (char *)return_value_malloc$10;
    sprintf(subpath, "%s/%s", directory, dllBase);
  }
  fuzzy = 0;
  _Bool tmp_if_expr$16;
  unsigned long int return_value_strlen$14;
  signed int return_value_strncmp$15;
  _Bool tmp_if_expr$18;
  unsigned long int return_value_strlen$17;
  _Bool tmp_if_expr$23;
  unsigned long int return_value_strlen$21;
  signed int return_value_strncmp$22;
  _Bool tmp_if_expr$25;
  unsigned long int return_value_strlen$24;
  for( ; !(fuzzy >= 2); fuzzy = fuzzy + 1)
  {
    subdir=opendir(subpath);
    if(subdir == ((struct __dirstream *)NULL))
    {
      ghss_debug(32, " warning: can't open plugin UI directory '%s'", subpath);
      break;
    }

    do
    {
      entry=readdir(subdir);
      if(entry == ((struct dirent *)NULL))
        break;

      if(!((signed int)entry->d_name[0l] == 46))
      {
        char *return_value___builtin_strchr$11;
        return_value___builtin_strchr$11=__builtin_strchr(entry->d_name, 95);
        if(!(return_value___builtin_strchr$11 == ((char *)NULL)))
        {
          if(!(fuzzy == 0))
          {
            ghss_debug(32, ": checking %s against %s", (const void *)entry->d_name, dllBase);
            unsigned long int return_value_strlen$12;
            return_value_strlen$12=strlen(entry->d_name);
            unsigned long int return_value_strlen$13;
            return_value_strlen$13=strlen(dllBase);
            if(return_value_strlen$13 >= return_value_strlen$12)
              tmp_if_expr$16 = (_Bool)1;

            else
            {
              return_value_strlen$14=strlen(dllBase);
              return_value_strncmp$15=strncmp(entry->d_name, dllBase, return_value_strlen$14);
              tmp_if_expr$16 = return_value_strncmp$15 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$16)
              tmp_if_expr$18 = (_Bool)1;

            else
            {
              return_value_strlen$17=strlen(dllBase);
              tmp_if_expr$18 = (signed int)entry->d_name[(signed long int)return_value_strlen$17] != 95 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$18)
              continue;

          }

          else
          {
            ghss_debug(32, ": checking %s against %s", (const void *)entry->d_name, label);
            unsigned long int return_value_strlen$19;
            return_value_strlen$19=strlen(entry->d_name);
            unsigned long int return_value_strlen$20;
            return_value_strlen$20=strlen(label);
            if(return_value_strlen$20 >= return_value_strlen$19)
              tmp_if_expr$23 = (_Bool)1;

            else
            {
              return_value_strlen$21=strlen(label);
              return_value_strncmp$22=strncmp(entry->d_name, label, return_value_strlen$21);
              tmp_if_expr$23 = return_value_strncmp$22 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$23)
              tmp_if_expr$25 = (_Bool)1;

            else
            {
              return_value_strlen$24=strlen(label);
              tmp_if_expr$25 = (signed int)entry->d_name[(signed long int)return_value_strlen$24] != 95 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$25)
              continue;

          }
          unsigned long int return_value_strlen$26;
          return_value_strlen$26=strlen(subpath);
          unsigned long int return_value_strlen$27;
          return_value_strlen$27=strlen(entry->d_name);
          void *return_value_malloc$28;
          return_value_malloc$28=malloc(return_value_strlen$26 + return_value_strlen$27 + (unsigned long int)2);
          filename = (char *)return_value_malloc$28;
          sprintf(filename, "%s/%s", subpath, (const void *)entry->d_name);
          signed int return_value_stat$31;
          return_value_stat$31=stat(filename, &buf);
          if(!(return_value_stat$31 == 0))
          {
            signed int *return_value___errno_location$29;
            return_value___errno_location$29=__errno_location();
            char *return_value_strerror$30;
            return_value_strerror$30=strerror(*return_value___errno_location$29);
            ghss_debug(32, ": stat of UI %s failed: %s", return_value_strerror$30);
            free((void *)filename);
            continue;
          }

          if(!((73u & buf.st_mode) == 0u) && ((61440u & buf.st_mode) == 32768u || (61440u & buf.st_mode) == 40960u))
          {
            unsigned long int return_value_strlen$32;
            return_value_strlen$32=strlen(host_osc_url);
            unsigned long int return_value_strlen$33;
            return_value_strlen$33=strlen(instance->friendly_name);
            void *return_value_malloc$34;
            return_value_malloc$34=malloc(return_value_strlen$32 + return_value_strlen$33 + (unsigned long int)7);
            osc_url = (char *)return_value_malloc$34;
            sprintf(osc_url, "%sdssi/%s", host_osc_url, instance->friendly_name);
            snprintf(tag, (unsigned long int)12, "Inst %d", instance->id);
            ghss_debug(32, ": trying to execute UI '%s', URL to host will be '%s'", filename, osc_url);
            pid=fork();
            if(pid == 0)
            {
              signed int return_value_fork$37;
              return_value_fork$37=fork();
              if(return_value_fork$37 == 0)
              {
                execlp(filename, filename, osc_url, dllName, label, (const void *)tag, (void *)0);
                signed int *return_value___errno_location$35;
                return_value___errno_location$35=__errno_location();
                char *return_value_strerror$36;
                return_value_strerror$36=strerror(*return_value___errno_location$35);
                ghss_debug(1, ": exec of UI failed: %s", return_value_strerror$36);
              }

              _exit(1);
            }

            else
              if(pid >= 1)
                waitpid(pid, (signed int *)(void *)0, 0);

            instance->ui_running = 1;
            instance->ui_initial_show_sent = 0;
            free((void *)osc_url);
            free((void *)filename);
            closedir(subdir);
            free((void *)subpath);
            free((void *)dllBase);
            goto __CPROVER_DUMP_L36;
          }

          free((void *)filename);
        }

      }

    }
    while((_Bool)1);
    closedir(subdir);
  }
  free((void *)subpath);
  free((void *)dllBase);
  origPath=getenv("PATH");
  if(!(origPath == ((char *)NULL)))
  {
    char *return_value___strdup$38;
    return_value___strdup$38=__strdup(origPath);
    path = return_value___strdup$38;
    origPath = path;
    do
    {
      subpath=strtok(path, ":");
      if(subpath == ((char *)NULL))
        break;

      path = ((char *)NULL);
      if(!((signed int)*subpath == 47))
        ghss_debug(32, ": ignoring PATH relative subpath '%s'", subpath);

      else
      {
        unsigned long int return_value_strlen$39;
        return_value_strlen$39=strlen(subpath);
        void *return_value_malloc$40;
        return_value_malloc$40=malloc(return_value_strlen$39 + (unsigned long int)24);
        filename = (char *)return_value_malloc$40;
        sprintf(filename, "%s/ghostess_universal_gui", subpath);
        signed int return_value_stat$41;
        return_value_stat$41=stat(filename, &buf);
        if(!(return_value_stat$41 == 0))
          free((void *)filename);

        else
        {
          if(!((73u & buf.st_mode) == 0u) && ((61440u & buf.st_mode) == 32768u || (61440u & buf.st_mode) == 40960u))
          {
            unsigned long int return_value_strlen$42;
            return_value_strlen$42=strlen(host_osc_url);
            unsigned long int return_value_strlen$43;
            return_value_strlen$43=strlen(instance->friendly_name);
            void *return_value_malloc$44;
            return_value_malloc$44=malloc(return_value_strlen$42 + return_value_strlen$43 + (unsigned long int)7);
            osc_url = (char *)return_value_malloc$44;
            sprintf(osc_url, "%sdssi/%s", host_osc_url, instance->friendly_name);
            snprintf(tag, (unsigned long int)12, "Inst %d", instance->id);
            ghss_debug(32, ": trying to execute universal GUI '%s', URL to host will be '%s'", filename, osc_url);
            pid=fork();
            if(pid == 0)
            {
              signed int return_value_fork$47;
              return_value_fork$47=fork();
              if(return_value_fork$47 == 0)
              {
                execlp(filename, filename, osc_url, dllName, label, (const void *)tag, (void *)0);
                signed int *return_value___errno_location$45;
                return_value___errno_location$45=__errno_location();
                char *return_value_strerror$46;
                return_value_strerror$46=strerror(*return_value___errno_location$45);
                ghss_debug(1, ": exec of universal GUI failed: %s", return_value_strerror$46);
              }

              exit(1);
            }

            else
              if(pid >= 1)
                waitpid(pid, (signed int *)(void *)0, 0);

            instance->ui_running = 1;
            instance->ui_initial_show_sent = 0;
            free((void *)osc_url);
            free((void *)filename);
            goto __CPROVER_DUMP_L36;
          }

          free((void *)filename);
        }
      }
    }
    while((_Bool)1);
    free((void *)origPath);
  }

  ghss_debug(32, ": no UI found for plugin '%s'", label);

__CPROVER_DUMP_L36:
  ;
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// ui_osc_free
// file ghostess.c line 1055
void ui_osc_free(struct _d3h_instance_t *instance)
{
  lo_address_free(instance->ui_osc_address);
  if(!(instance->ui_osc_source == NULL))
    lo_address_free(instance->ui_osc_source);

  free((void *)instance->ui_osc_control_path);
  free((void *)instance->ui_osc_configure_path);
  free((void *)instance->ui_osc_hide_path);
  free((void *)instance->ui_osc_program_path);
  free((void *)instance->ui_osc_quit_path);
  free((void *)instance->ui_osc_rate_path);
  free((void *)instance->ui_osc_show_path);
  instance->ui_osc_address = (void *)0;
  instance->ui_osc_source = (void *)0;
  instance->ui_osc_control_path = (char *)(void *)0;
  instance->ui_osc_configure_path = (char *)(void *)0;
  instance->ui_osc_hide_path = (char *)(void *)0;
  instance->ui_osc_program_path = (char *)(void *)0;
  instance->ui_osc_quit_path = (char *)(void *)0;
  instance->ui_osc_rate_path = (char *)(void *)0;
  instance->ui_osc_show_path = (char *)(void *)0;
}

// update_eyecandy
// file gui_callbacks.h line 47
void update_eyecandy(struct _d3h_instance_t *instance)
{
  signed int state = (signed int)(main_timeout_tick - instance->midi_activity_tick <= 1);
  if(!(instance->strip->previous_midi_state == state))
  {
    unsigned long int return_value_blinky_get_type$1;
    return_value_blinky_get_type$1=blinky_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)instance->strip->midi_status, return_value_blinky_get_type$1);
    blinky_set_state((struct _Blinky *)return_value_g_type_check_instance_cast$2, (unsigned int)state);
    instance->strip->previous_midi_state = state;
  }

}

// update_from_exiting
// file gui_callbacks.h line 46
void update_from_exiting(struct _d3h_instance_t *instance)
{
  update_ui_button_internal(instance, 0);
}

// update_ui_button_internal
// file gui_callbacks.c line 260
void update_ui_button_internal(struct _d3h_instance_t *instance, signed int value)
{
  unsigned long int return_value_gtk_object_get_type$1;
  return_value_gtk_object_get_type$1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)instance->strip->ui_button, return_value_gtk_object_get_type$1);
  gtk_signal_compat_matched((struct _GtkObject *)return_value_g_type_check_instance_cast$2, (void (*)(void))on_strip_ui_button_toggled, (void *)instance->strip, (enum anonymous$9)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)1);
  unsigned long int return_value_gtk_toggle_button_get_type$3;
  return_value_gtk_toggle_button_get_type$3=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)instance->strip->ui_button, return_value_gtk_toggle_button_get_type$3);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$4, value);
  unsigned long int return_value_gtk_object_get_type$5;
  return_value_gtk_object_get_type$5=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)instance->strip->ui_button, return_value_gtk_object_get_type$5);
  gtk_signal_compat_matched((struct _GtkObject *)return_value_g_type_check_instance_cast$6, (void (*)(void))on_strip_ui_button_toggled, (void *)instance->strip, (enum anonymous$9)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)2);
}

// write_configuration
// file ghostess.c line 911
signed int write_configuration(char *filename, const char *uuid)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  signed int rc = 0;
  signed int id;
  signed int instno;
  signed int i;
  signed int in;
  signed int port;
  struct _d3h_instance_t *instance;
  char *arg1 = (char *)(void *)0;
  char *arg2 = (char *)(void *)0;
  struct _configure_item_t *item;
  fp=fopen(filename, "w");
  signed int return_value_fprintf$1;
  signed int return_value_fprintf$3;
  signed int tmp_statement_expression$5;
  signed int tmp_statement_expression$13;
  signed int return_value_fprintf$18;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    return_value_fprintf$1=fprintf(fp, "#!/bin/sh\n");
    if(return_value_fprintf$1 >= 0)
    {
      if(!(dssi_path == ((char *)NULL)))
      {
        escape_for_shell(&arg1, dssi_path);
        signed int return_value_fprintf$2;
        return_value_fprintf$2=fprintf(fp, "DSSI_PATH=%s\nexport DSSI_PATH\n", arg1);
        if(!(return_value_fprintf$2 >= 0))
          goto error;

      }

      return_value_fprintf$3=fprintf(fp, "exec %s \\\n", host_argv0);
      if(return_value_fprintf$3 >= 0)
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$6;
        return_value___builtin_strcmp$6=__builtin_strcmp(host_name, host_name_default);
        tmp_statement_expression$5 = return_value___builtin_strcmp$6;
        if(!(tmp_statement_expression$5 == 0))
        {
          escape_for_shell(&arg1, host_name);
          signed int return_value_fprintf$4;
          return_value_fprintf$4=fprintf(fp, " -hostname %s \\\n", arg1);
          if(!(return_value_fprintf$4 >= 0))
            goto error;

        }

        if(!(project_directory == ((char *)NULL)))
        {
          escape_for_shell(&arg1, project_directory);
          signed int return_value_fprintf$7;
          return_value_fprintf$7=fprintf(fp, " -projdir %s \\\n", arg1);
          if(!(return_value_fprintf$7 >= 0))
            goto error;

        }

        if(!(uuid == ((const char *)NULL)))
        {
          escape_for_shell(&arg1, uuid);
          signed int return_value_fprintf$8;
          return_value_fprintf$8=fprintf(fp, " -uuid %s \\\n", arg1);
          if(!(return_value_fprintf$8 >= 0))
            goto error;

        }

        if(autoconnect == 0 || !(uuid == ((const char *)NULL)))
        {
          signed int return_value_fprintf$9;
          return_value_fprintf$9=fprintf(fp, " -noauto \\\n");
          if(!(return_value_fprintf$9 >= 0))
            goto error;

        }

        id = 0;
        for( ; !(id >= instance_count); id = id + 1)
        {
          instno = 0;
          for( ; !(instances[(signed long int)instno].id == id); instno = instno + 1)
            ;
          instance = &instances[(signed long int)instno];
          escape_for_shell(&arg1, instance->friendly_name);
          signed int return_value_fprintf$10;
          return_value_fprintf$10=fprintf(fp, "-comment %s \\\n", arg1);
          if(!(return_value_fprintf$10 >= 0))
            goto error;

          signed int return_value_fprintf$11;
          return_value_fprintf$11=fprintf(fp, " -chan %d \\\n", instance->channel);
          if(!(return_value_fprintf$11 >= 0))
            goto error;

          item = instance->configure_items;
          for( ; !(item == ((struct _configure_item_t *)NULL)); item = item->next)
          {
            unsigned long int write_configuration$$1$$7$$1$$2$$1$$1$$__s1_len;
            unsigned long int write_configuration$$1$$7$$1$$2$$1$$1$$__s2_len;
            signed int return_value___builtin_strcmp$14;
            return_value___builtin_strcmp$14=__builtin_strcmp(item->key, "DSSI:PROJECT_DIRECTORY");
            tmp_statement_expression$13 = return_value___builtin_strcmp$14;
            if(!(tmp_statement_expression$13 == 0))
            {
              escape_for_shell(&arg1, item->key);
              escape_for_shell(&arg2, item->value);
              signed int return_value_fprintf$12;
              return_value_fprintf$12=fprintf(fp, " -conf %s %s \\\n", arg1, arg2);
              if(!(return_value_fprintf$12 >= 0))
                goto error;

            }

          }
          if(!(instance->plugin->descriptor->select_program == ((void (*)(void *, unsigned long int, unsigned long int))NULL)))
          {
            signed int return_value_fprintf$15;
            return_value_fprintf$15=fprintf(fp, " -prog %lu %lu \\\n", instance->currentBank, instance->currentProgram);
            if(!(return_value_fprintf$15 >= 0))
              goto error;

          }

          i = 0;
          for( ; !(i >= instance->plugin->controlIns); i = i + 1)
          {
            char buf[39l];
            in = i + instance->firstControlIn;
            port = (signed int)pluginControlInPortNumbers[(signed long int)in];
            g_ascii_formatd(buf, (signed int)sizeof(char [39l]) /*39ul*/ , "%.6g", (double)pluginControlIns[(signed long int)in]);
            signed int return_value_fprintf$16;
            return_value_fprintf$16=fprintf(fp, " -port %d %s \\\n", port, (const void *)buf);
            if(!(return_value_fprintf$16 >= 0))
              goto error;

          }
          escape_for_shell(&arg1, instance->plugin->dll->name);
          escape_for_shell(&arg2, instance->plugin->label);
          signed int return_value_fprintf$17;
          return_value_fprintf$17=fprintf(fp, " %s:%s \\\n", arg1, arg2);
          if(!(return_value_fprintf$17 >= 0))
            goto error;

        }
        return_value_fprintf$18=fprintf(fp, "\n");
        if(return_value_fprintf$18 >= 0)
          rc = 1;

      }

    }

  }


error:
  ;
  if(!(arg1 == ((char *)NULL)))
    free((void *)arg1);

  if(!(arg2 == ((char *)NULL)))
    free((void *)arg2);

  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  return rc;
}

// write_patchlist
// file ghostess.c line 996
signed int write_patchlist(char *filename)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  signed int rc = 0;
  signed int id;
  signed int instno;
  signed int i;
  signed int j;
  struct _d3h_instance_t *instance;
  char tmp[255l];
  fp=fopen(filename, "w");
  _Bool tmp_if_expr$1;
  signed int return_value_fprintf$2;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    fprintf(fp, "<patchlist>\n");
    id = 0;
    for( ; !(id >= instance_count); id = id + 1)
    {
      instno = 0;
      for( ; !(instances[(signed long int)instno].id == id); instno = instno + 1)
        ;
      instance = &instances[(signed long int)instno];
      if(instance->pluginProgramsValid == 0)
        query_programs(instance);

      i = 0;
      for( ; !(i >= instance->pluginProgramCount); i = i + 1)
      {
        __builtin_strncpy(tmp, (instance->pluginPrograms + (signed long int)i)->Name, (unsigned long int)254);
        tmp[(signed long int)254] = (char)0;
        j = 0;
        for( ; !(tmp[(signed long int)j] == 0); j = j + 1)
        {
          if((signed int)tmp[(signed long int)j] == 60)
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = (signed int)tmp[(signed long int)j] == 62 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
            tmp[(signed long int)j] = (char)32;

          else
            if((signed int)tmp[(signed long int)j] == 34)
              tmp[(signed long int)j] = (char)39;

        }
        fprintf(fp, "<patch channel=\"%d\" name=\"%s\" bank=\"%d\" program=\"%d\"/>\n", instance->channel, (const void *)tmp, (signed int)(instance->pluginPrograms + (signed long int)i)->Bank, (signed int)(instance->pluginPrograms + (signed long int)i)->Program);
      }
    }
    return_value_fprintf$2=fprintf(fp, "</patchlist>\n");
    if(return_value_fprintf$2 >= 0)
      rc = 1;

  }


error:
  ;
  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  return rc;
}

