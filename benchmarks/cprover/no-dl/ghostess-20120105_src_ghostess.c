// #anon_enum_ATK_LAYER_INVALID=0_ATK_LAYER_BACKGROUND=1_ATK_LAYER_CANVAS=2_ATK_LAYER_WIDGET=3_ATK_LAYER_MDI=4_ATK_LAYER_POPUP=5_ATK_LAYER_OVERLAY=6_ATK_LAYER_WINDOW=7
// file /usr/include/atk-1.0/atk/atkobject.h line 376
enum anonymous_1 { ATK_LAYER_INVALID=0, ATK_LAYER_BACKGROUND=1, ATK_LAYER_CANVAS=2, ATK_LAYER_WIDGET=3, ATK_LAYER_MDI=4, ATK_LAYER_POPUP=5, ATK_LAYER_OVERLAY=6, ATK_LAYER_WINDOW=7 };

// #anon_enum_ATK_ROLE_INVALID=0_ATK_ROLE_ACCEL_LABEL=1_ATK_ROLE_ALERT=2_ATK_ROLE_ANIMATION=3_ATK_ROLE_ARROW=4_ATK_ROLE_CALENDAR=5_ATK_ROLE_CANVAS=6_ATK_ROLE_CHECK_BOX=7_ATK_ROLE_CHECK_MENU_ITEM=8_ATK_ROLE_COLOR_CHOOSER=9_ATK_ROLE_COLUMN_HEADER=10_ATK_ROLE_COMBO_BOX=11_ATK_ROLE_DATE_EDITOR=12_ATK_ROLE_DESKTOP_ICON=13_ATK_ROLE_DESKTOP_FRAME=14_ATK_ROLE_DIAL=15_ATK_ROLE_DIALOG=16_ATK_ROLE_DIRECTORY_PANE=17_ATK_ROLE_DRAWING_AREA=18_ATK_ROLE_FILE_CHOOSER=19_ATK_ROLE_FILLER=20_ATK_ROLE_FONT_CHOOSER=21_ATK_ROLE_FRAME=22_ATK_ROLE_GLASS_PANE=23_ATK_ROLE_HTML_CONTAINER=24_ATK_ROLE_ICON=25_ATK_ROLE_IMAGE=26_ATK_ROLE_INTERNAL_FRAME=27_ATK_ROLE_LABEL=28_ATK_ROLE_LAYERED_PANE=29_ATK_ROLE_LIST=30_ATK_ROLE_LIST_ITEM=31_ATK_ROLE_MENU=32_ATK_ROLE_MENU_BAR=33_ATK_ROLE_MENU_ITEM=34_ATK_ROLE_OPTION_PANE=35_ATK_ROLE_PAGE_TAB=36_ATK_ROLE_PAGE_TAB_LIST=37_ATK_ROLE_PANEL=38_ATK_ROLE_PASSWORD_TEXT=39_ATK_ROLE_POPUP_MENU=40_ATK_ROLE_PROGRESS_BAR=41_ATK_ROLE_PUSH_BUTTON=42_ATK_ROLE_RADIO_BUTTON=43_ATK_ROLE_RADIO_MENU_ITEM=44_ATK_ROLE_ROOT_PANE=45_ATK_ROLE_ROW_HEADER=46_ATK_ROLE_SCROLL_BAR=47_ATK_ROLE_SCROLL_PANE=48_ATK_ROLE_SEPARATOR=49_ATK_ROLE_SLIDER=50_ATK_ROLE_SPLIT_PANE=51_ATK_ROLE_SPIN_BUTTON=52_ATK_ROLE_STATUSBAR=53_ATK_ROLE_TABLE=54_ATK_ROLE_TABLE_CELL=55_ATK_ROLE_TABLE_COLUMN_HEADER=56_ATK_ROLE_TABLE_ROW_HEADER=57_ATK_ROLE_TEAR_OFF_MENU_ITEM=58_ATK_ROLE_TERMINAL=59_ATK_ROLE_TEXT=60_ATK_ROLE_TOGGLE_BUTTON=61_ATK_ROLE_TOOL_BAR=62_ATK_ROLE_TOOL_TIP=63_ATK_ROLE_TREE=64_ATK_ROLE_TREE_TABLE=65_ATK_ROLE_UNKNOWN=66_ATK_ROLE_VIEWPORT=67_ATK_ROLE_WINDOW=68_ATK_ROLE_HEADER=69_ATK_ROLE_FOOTER=70_ATK_ROLE_PARAGRAPH=71_ATK_ROLE_RULER=72_ATK_ROLE_APPLICATION=73_ATK_ROLE_AUTOCOMPLETE=74_ATK_ROLE_EDITBAR=75_ATK_ROLE_EMBEDDED=76_ATK_ROLE_ENTRY=77_ATK_ROLE_CHART=78_ATK_ROLE_CAPTION=79_ATK_ROLE_DOCUMENT_FRAME=80_ATK_ROLE_HEADING=81_ATK_ROLE_PAGE=82_ATK_ROLE_SECTION=83_ATK_ROLE_REDUNDANT_OBJECT=84_ATK_ROLE_FORM=85_ATK_ROLE_LINK=86_ATK_ROLE_INPUT_METHOD_WINDOW=87_ATK_ROLE_TABLE_ROW=88_ATK_ROLE_TREE_ITEM=89_ATK_ROLE_DOCUMENT_SPREADSHEET=90_ATK_ROLE_DOCUMENT_PRESENTATION=91_ATK_ROLE_DOCUMENT_TEXT=92_ATK_ROLE_DOCUMENT_WEB=93_ATK_ROLE_DOCUMENT_EMAIL=94_ATK_ROLE_COMMENT=95_ATK_ROLE_LIST_BOX=96_ATK_ROLE_GROUPING=97_ATK_ROLE_IMAGE_MAP=98_ATK_ROLE_NOTIFICATION=99_ATK_ROLE_INFO_BAR=100_ATK_ROLE_LEVEL_BAR=101_ATK_ROLE_TITLE_BAR=102_ATK_ROLE_BLOCK_QUOTE=103_ATK_ROLE_AUDIO=104_ATK_ROLE_VIDEO=105_ATK_ROLE_DEFINITION=106_ATK_ROLE_ARTICLE=107_ATK_ROLE_LANDMARK=108_ATK_ROLE_LOG=109_ATK_ROLE_MARQUEE=110_ATK_ROLE_MATH=111_ATK_ROLE_RATING=112_ATK_ROLE_TIMER=113_ATK_ROLE_DESCRIPTION_LIST=114_ATK_ROLE_DESCRIPTION_TERM=115_ATK_ROLE_DESCRIPTION_VALUE=116_ATK_ROLE_STATIC=117_ATK_ROLE_MATH_FRACTION=118_ATK_ROLE_MATH_ROOT=119_ATK_ROLE_SUBSCRIPT=120_ATK_ROLE_SUPERSCRIPT=121_ATK_ROLE_LAST_DEFINED=122
// file /usr/include/atk-1.0/atk/atkobject.h line 232
enum anonymous_0 { ATK_ROLE_INVALID=0, ATK_ROLE_ACCEL_LABEL=1, ATK_ROLE_ALERT=2, ATK_ROLE_ANIMATION=3, ATK_ROLE_ARROW=4, ATK_ROLE_CALENDAR=5, ATK_ROLE_CANVAS=6, ATK_ROLE_CHECK_BOX=7, ATK_ROLE_CHECK_MENU_ITEM=8, ATK_ROLE_COLOR_CHOOSER=9, ATK_ROLE_COLUMN_HEADER=10, ATK_ROLE_COMBO_BOX=11, ATK_ROLE_DATE_EDITOR=12, ATK_ROLE_DESKTOP_ICON=13, ATK_ROLE_DESKTOP_FRAME=14, ATK_ROLE_DIAL=15, ATK_ROLE_DIALOG=16, ATK_ROLE_DIRECTORY_PANE=17, ATK_ROLE_DRAWING_AREA=18, ATK_ROLE_FILE_CHOOSER=19, ATK_ROLE_FILLER=20, ATK_ROLE_FONT_CHOOSER=21, ATK_ROLE_FRAME=22, ATK_ROLE_GLASS_PANE=23, ATK_ROLE_HTML_CONTAINER=24, ATK_ROLE_ICON=25, ATK_ROLE_IMAGE=26, ATK_ROLE_INTERNAL_FRAME=27, ATK_ROLE_LABEL=28, ATK_ROLE_LAYERED_PANE=29, ATK_ROLE_LIST=30, ATK_ROLE_LIST_ITEM=31, ATK_ROLE_MENU=32, ATK_ROLE_MENU_BAR=33, ATK_ROLE_MENU_ITEM=34, ATK_ROLE_OPTION_PANE=35, ATK_ROLE_PAGE_TAB=36, ATK_ROLE_PAGE_TAB_LIST=37, ATK_ROLE_PANEL=38, ATK_ROLE_PASSWORD_TEXT=39, ATK_ROLE_POPUP_MENU=40, ATK_ROLE_PROGRESS_BAR=41, ATK_ROLE_PUSH_BUTTON=42, ATK_ROLE_RADIO_BUTTON=43, ATK_ROLE_RADIO_MENU_ITEM=44, ATK_ROLE_ROOT_PANE=45, ATK_ROLE_ROW_HEADER=46, ATK_ROLE_SCROLL_BAR=47, ATK_ROLE_SCROLL_PANE=48, ATK_ROLE_SEPARATOR=49, ATK_ROLE_SLIDER=50, ATK_ROLE_SPLIT_PANE=51, ATK_ROLE_SPIN_BUTTON=52, ATK_ROLE_STATUSBAR=53, ATK_ROLE_TABLE=54, ATK_ROLE_TABLE_CELL=55, ATK_ROLE_TABLE_COLUMN_HEADER=56, ATK_ROLE_TABLE_ROW_HEADER=57, ATK_ROLE_TEAR_OFF_MENU_ITEM=58, ATK_ROLE_TERMINAL=59, ATK_ROLE_TEXT=60, ATK_ROLE_TOGGLE_BUTTON=61, ATK_ROLE_TOOL_BAR=62, ATK_ROLE_TOOL_TIP=63, ATK_ROLE_TREE=64, ATK_ROLE_TREE_TABLE=65, ATK_ROLE_UNKNOWN=66, ATK_ROLE_VIEWPORT=67, ATK_ROLE_WINDOW=68, ATK_ROLE_HEADER=69, ATK_ROLE_FOOTER=70, ATK_ROLE_PARAGRAPH=71, ATK_ROLE_RULER=72, ATK_ROLE_APPLICATION=73, ATK_ROLE_AUTOCOMPLETE=74, ATK_ROLE_EDITBAR=75, ATK_ROLE_EMBEDDED=76, ATK_ROLE_ENTRY=77, ATK_ROLE_CHART=78, ATK_ROLE_CAPTION=79, ATK_ROLE_DOCUMENT_FRAME=80, ATK_ROLE_HEADING=81, ATK_ROLE_PAGE=82, ATK_ROLE_SECTION=83, ATK_ROLE_REDUNDANT_OBJECT=84, ATK_ROLE_FORM=85, ATK_ROLE_LINK=86, ATK_ROLE_INPUT_METHOD_WINDOW=87, ATK_ROLE_TABLE_ROW=88, ATK_ROLE_TREE_ITEM=89, ATK_ROLE_DOCUMENT_SPREADSHEET=90, ATK_ROLE_DOCUMENT_PRESENTATION=91, ATK_ROLE_DOCUMENT_TEXT=92, ATK_ROLE_DOCUMENT_WEB=93, ATK_ROLE_DOCUMENT_EMAIL=94, ATK_ROLE_COMMENT=95, ATK_ROLE_LIST_BOX=96, ATK_ROLE_GROUPING=97, ATK_ROLE_IMAGE_MAP=98, ATK_ROLE_NOTIFICATION=99, ATK_ROLE_INFO_BAR=100, ATK_ROLE_LEVEL_BAR=101, ATK_ROLE_TITLE_BAR=102, ATK_ROLE_BLOCK_QUOTE=103, ATK_ROLE_AUDIO=104, ATK_ROLE_VIDEO=105, ATK_ROLE_DEFINITION=106, ATK_ROLE_ARTICLE=107, ATK_ROLE_LANDMARK=108, ATK_ROLE_LOG=109, ATK_ROLE_MARQUEE=110, ATK_ROLE_MATH=111, ATK_ROLE_RATING=112, ATK_ROLE_TIMER=113, ATK_ROLE_DESCRIPTION_LIST=114, ATK_ROLE_DESCRIPTION_TERM=115, ATK_ROLE_DESCRIPTION_VALUE=116, ATK_ROLE_STATIC=117, ATK_ROLE_MATH_FRACTION=118, ATK_ROLE_MATH_ROOT=119, ATK_ROLE_SUBSCRIPT=120, ATK_ROLE_SUPERSCRIPT=121, ATK_ROLE_LAST_DEFINED=122 };

// #anon_enum_GDK_ACTION_DEFAULT=1_GDK_ACTION_COPY=2_GDK_ACTION_MOVE=4_GDK_ACTION_LINK=8_GDK_ACTION_PRIVATE=16_GDK_ACTION_ASK=32
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 40
enum anonymous_51 { GDK_ACTION_DEFAULT=1, GDK_ACTION_COPY=2, GDK_ACTION_MOVE=4, GDK_ACTION_LINK=8, GDK_ACTION_PRIVATE=16, GDK_ACTION_ASK=32 };

// #anon_enum_GDK_AXIS_IGNORE=0_GDK_AXIS_X=1_GDK_AXIS_Y=2_GDK_AXIS_PRESSURE=3_GDK_AXIS_XTILT=4_GDK_AXIS_YTILT=5_GDK_AXIS_WHEEL=6_GDK_AXIS_LAST=7
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 73
enum anonymous_30 { GDK_AXIS_IGNORE=0, GDK_AXIS_X=1, GDK_AXIS_Y=2, GDK_AXIS_PRESSURE=3, GDK_AXIS_XTILT=4, GDK_AXIS_YTILT=5, GDK_AXIS_WHEEL=6, GDK_AXIS_LAST=7 };

// #anon_enum_GDK_CROSSING_NORMAL=0_GDK_CROSSING_GRAB=1_GDK_CROSSING_UNGRAB=2_GDK_CROSSING_GTK_GRAB=3_GDK_CROSSING_GTK_UNGRAB=4_GDK_CROSSING_STATE_CHANGED=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 225
enum anonymous_36 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5 };

// #anon_enum_GDK_DRAG_PROTO_MOTIF=0_GDK_DRAG_PROTO_XDND=1_GDK_DRAG_PROTO_ROOTWIN=2_GDK_DRAG_PROTO_NONE=3_GDK_DRAG_PROTO_WIN32_DROPFILES=4_GDK_DRAG_PROTO_OLE2=5_GDK_DRAG_PROTO_LOCAL=6
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 50
enum anonymous_50 { GDK_DRAG_PROTO_MOTIF=0, GDK_DRAG_PROTO_XDND=1, GDK_DRAG_PROTO_ROOTWIN=2, GDK_DRAG_PROTO_NONE=3, GDK_DRAG_PROTO_WIN32_DROPFILES=4, GDK_DRAG_PROTO_OLE2=5, GDK_DRAG_PROTO_LOCAL=6 };

// #anon_enum_GDK_FONT_FONT=0_GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous_13 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum_GDK_INPUT_OUTPUT=0_GDK_INPUT_ONLY=1
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 54
enum anonymous_44 { GDK_INPUT_OUTPUT=0, GDK_INPUT_ONLY=1 };

// #anon_enum_GDK_LSB_FIRST=0_GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous_12 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum_GDK_MODE_DISABLED=0_GDK_MODE_SCREEN=1_GDK_MODE_WINDOW=2
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 66
enum anonymous_35 { GDK_MODE_DISABLED=0, GDK_MODE_SCREEN=1, GDK_MODE_WINDOW=2 };

// #anon_enum_GDK_NOTHING=-1_GDK_DELETE=0_GDK_DESTROY=1_GDK_EXPOSE=2_GDK_MOTION_NOTIFY=3_GDK_BUTTON_PRESS=4_GDK_2BUTTON_PRESS=5_GDK_3BUTTON_PRESS=6_GDK_BUTTON_RELEASE=7_GDK_KEY_PRESS=8_GDK_KEY_RELEASE=9_GDK_ENTER_NOTIFY=10_GDK_LEAVE_NOTIFY=11_GDK_FOCUS_CHANGE=12_GDK_CONFIGURE=13_GDK_MAP=14_GDK_UNMAP=15_GDK_PROPERTY_NOTIFY=16_GDK_SELECTION_CLEAR=17_GDK_SELECTION_REQUEST=18_GDK_SELECTION_NOTIFY=19_GDK_PROXIMITY_IN=20_GDK_PROXIMITY_OUT=21_GDK_DRAG_ENTER=22_GDK_DRAG_LEAVE=23_GDK_DRAG_MOTION=24_GDK_DRAG_STATUS=25_GDK_DROP_START=26_GDK_DROP_FINISHED=27_GDK_CLIENT_EVENT=28_GDK_VISIBILITY_NOTIFY=29_GDK_NO_EXPOSE=30_GDK_SCROLL=31_GDK_WINDOW_STATE=32_GDK_SETTING=33_GDK_OWNER_CHANGE=34_GDK_GRAB_BROKEN=35_GDK_DAMAGE=36_GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous_26 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum_GDK_NOTIFY_ANCESTOR=0_GDK_NOTIFY_VIRTUAL=1_GDK_NOTIFY_INFERIOR=2_GDK_NOTIFY_NONLINEAR=3_GDK_NOTIFY_NONLINEAR_VIRTUAL=4_GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 210
enum anonymous_33 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum_GDK_OWNER_CHANGE_NEW_OWNER=0_GDK_OWNER_CHANGE_DESTROY=1_GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 259
enum anonymous_40 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum_GDK_SCROLL_UP=0_GDK_SCROLL_DOWN=1_GDK_SCROLL_LEFT=2_GDK_SCROLL_RIGHT=3
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 194
enum anonymous_32 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3 };

// #anon_enum_GDK_SETTING_ACTION_NEW=0_GDK_SETTING_ACTION_CHANGED=1_GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 252
enum anonymous_38 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum_GDK_SHIFT_MASK=1_GDK_LOCK_MASK=2_GDK_CONTROL_MASK=4_GDK_MOD1_MASK=8_GDK_MOD2_MASK=16_GDK_MOD3_MASK=32_GDK_MOD4_MASK=64_GDK_MOD5_MASK=128_GDK_BUTTON1_MASK=256_GDK_BUTTON2_MASK=512_GDK_BUTTON3_MASK=1024_GDK_BUTTON4_MASK=2048_GDK_BUTTON5_MASK=4096_GDK_SUPER_MASK=67108864_GDK_HYPER_MASK=134217728_GDK_META_MASK=268435456_GDK_RELEASE_MASK=1073741824_GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous_23 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum_GDK_SOURCE_MOUSE=0_GDK_SOURCE_PEN=1_GDK_SOURCE_ERASER=2_GDK_SOURCE_CURSOR=3
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 58
enum anonymous_34 { GDK_SOURCE_MOUSE=0, GDK_SOURCE_PEN=1, GDK_SOURCE_ERASER=2, GDK_SOURCE_CURSOR=3 };

// #anon_enum_GDK_VISIBILITY_UNOBSCURED=0_GDK_VISIBILITY_PARTIAL=1_GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 187
enum anonymous_31 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum_GDK_VISUAL_STATIC_GRAY=0_GDK_VISUAL_GRAYSCALE=1_GDK_VISUAL_STATIC_COLOR=2_GDK_VISUAL_PSEUDO_COLOR=3_GDK_VISUAL_TRUE_COLOR=4_GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous_29 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum_GDK_WINDOW_ROOT=0_GDK_WINDOW_TOPLEVEL=1_GDK_WINDOW_CHILD=2_GDK_WINDOW_DIALOG=3_GDK_WINDOW_TEMP=4_GDK_WINDOW_FOREIGN=5_GDK_WINDOW_OFFSCREEN=6
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 73
enum anonymous_45 { GDK_WINDOW_ROOT=0, GDK_WINDOW_TOPLEVEL=1, GDK_WINDOW_CHILD=2, GDK_WINDOW_DIALOG=3, GDK_WINDOW_TEMP=4, GDK_WINDOW_FOREIGN=5, GDK_WINDOW_OFFSCREEN=6 };

// #anon_enum_GDK_WINDOW_STATE_WITHDRAWN=1_GDK_WINDOW_STATE_ICONIFIED=2_GDK_WINDOW_STATE_MAXIMIZED=4_GDK_WINDOW_STATE_STICKY=8_GDK_WINDOW_STATE_FULLSCREEN=16_GDK_WINDOW_STATE_ABOVE=32_GDK_WINDOW_STATE_BELOW=64
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 241
enum anonymous_37 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64 };

// #anon_enum_GDK_WINDOW_TYPE_HINT_NORMAL=0_GDK_WINDOW_TYPE_HINT_DIALOG=1_GDK_WINDOW_TYPE_HINT_MENU=2_GDK_WINDOW_TYPE_HINT_TOOLBAR=3_GDK_WINDOW_TYPE_HINT_SPLASHSCREEN=4_GDK_WINDOW_TYPE_HINT_UTILITY=5_GDK_WINDOW_TYPE_HINT_DOCK=6_GDK_WINDOW_TYPE_HINT_DESKTOP=7_GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU=8_GDK_WINDOW_TYPE_HINT_POPUP_MENU=9_GDK_WINDOW_TYPE_HINT_TOOLTIP=10_GDK_WINDOW_TYPE_HINT_NOTIFICATION=11_GDK_WINDOW_TYPE_HINT_COMBO=12_GDK_WINDOW_TYPE_HINT_DND=13
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 133
enum anonymous_46 { GDK_WINDOW_TYPE_HINT_NORMAL=0, GDK_WINDOW_TYPE_HINT_DIALOG=1, GDK_WINDOW_TYPE_HINT_MENU=2, GDK_WINDOW_TYPE_HINT_TOOLBAR=3, GDK_WINDOW_TYPE_HINT_SPLASHSCREEN=4, GDK_WINDOW_TYPE_HINT_UTILITY=5, GDK_WINDOW_TYPE_HINT_DOCK=6, GDK_WINDOW_TYPE_HINT_DESKTOP=7, GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU=8, GDK_WINDOW_TYPE_HINT_POPUP_MENU=9, GDK_WINDOW_TYPE_HINT_TOOLTIP=10, GDK_WINDOW_TYPE_HINT_NOTIFICATION=11, GDK_WINDOW_TYPE_HINT_COMBO=12, GDK_WINDOW_TYPE_HINT_DND=13 };

// #anon_enum_GDK_X_CURSOR=0_GDK_ARROW=2_GDK_BASED_ARROW_DOWN=4_GDK_BASED_ARROW_UP=6_GDK_BOAT=8_GDK_BOGOSITY=10_GDK_BOTTOM_LEFT_CORNER=12_GDK_BOTTOM_RIGHT_CORNER=14_GDK_BOTTOM_SIDE=16_GDK_BOTTOM_TEE=18_GDK_BOX_SPIRAL=20_GDK_CENTER_PTR=22_GDK_CIRCLE=24_GDK_CLOCK=26_GDK_COFFEE_MUG=28_GDK_CROSS=30_GDK_CROSS_REVERSE=32_GDK_CROSSHAIR=34_GDK_DIAMOND_CROSS=36_GDK_DOT=38_GDK_DOTBOX=40_GDK_DOUBLE_ARROW=42_GDK_DRAFT_LARGE=44_GDK_DRAFT_SMALL=46_GDK_DRAPED_BOX=48_GDK_EXCHANGE=50_GDK_FLEUR=52_GDK_GOBBLER=54_GDK_GUMBY=56_GDK_HAND1=58_GDK_HAND2=60_GDK_HEART=62_GDK_ICON=64_GDK_IRON_CROSS=66_GDK_LEFT_PTR=68_GDK_LEFT_SIDE=70_GDK_LEFT_TEE=72_GDK_LEFTBUTTON=74_GDK_LL_ANGLE=76_GDK_LR_ANGLE=78_GDK_MAN=80_GDK_MIDDLEBUTTON=82_GDK_MOUSE=84_GDK_PENCIL=86_GDK_PIRATE=88_GDK_PLUS=90_GDK_QUESTION_ARROW=92_GDK_RIGHT_PTR=94_GDK_RIGHT_SIDE=96_GDK_RIGHT_TEE=98_GDK_RIGHTBUTTON=100_GDK_RTL_LOGO=102_GDK_SAILBOAT=104_GDK_SB_DOWN_ARROW=106_GDK_SB_H_DOUBLE_ARROW=108_GDK_SB_LEFT_ARROW=110_GDK_SB_RIGHT_ARROW=112_GDK_SB_UP_ARROW=114_GDK_SB_V_DOUBLE_ARROW=116_GDK_SHUTTLE=118_GDK_SIZING=120_GDK_SPIDER=122_GDK_SPRAYCAN=124_GDK_STAR=126_GDK_TARGET=128_GDK_TCROSS=130_GDK_TOP_LEFT_ARROW=132_GDK_TOP_LEFT_CORNER=134_GDK_TOP_RIGHT_CORNER=136_GDK_TOP_SIDE=138_GDK_TOP_TEE=140_GDK_TREK=142_GDK_UL_ANGLE=144_GDK_UMBRELLA=146_GDK_UR_ANGLE=148_GDK_WATCH=150_GDK_XTERM=152_GDK_LAST_CURSOR=153_GDK_BLANK_CURSOR=-2_GDK_CURSOR_IS_PIXMAP=-1
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 43
enum anonymous_43 { GDK_X_CURSOR=0, GDK_ARROW=2, GDK_BASED_ARROW_DOWN=4, GDK_BASED_ARROW_UP=6, GDK_BOAT=8, GDK_BOGOSITY=10, GDK_BOTTOM_LEFT_CORNER=12, GDK_BOTTOM_RIGHT_CORNER=14, GDK_BOTTOM_SIDE=16, GDK_BOTTOM_TEE=18, GDK_BOX_SPIRAL=20, GDK_CENTER_PTR=22, GDK_CIRCLE=24, GDK_CLOCK=26, GDK_COFFEE_MUG=28, GDK_CROSS=30, GDK_CROSS_REVERSE=32, GDK_CROSSHAIR=34, GDK_DIAMOND_CROSS=36, GDK_DOT=38, GDK_DOTBOX=40, GDK_DOUBLE_ARROW=42, GDK_DRAFT_LARGE=44, GDK_DRAFT_SMALL=46, GDK_DRAPED_BOX=48, GDK_EXCHANGE=50, GDK_FLEUR=52, GDK_GOBBLER=54, GDK_GUMBY=56, GDK_HAND1=58, GDK_HAND2=60, GDK_HEART=62, GDK_ICON=64, GDK_IRON_CROSS=66, GDK_LEFT_PTR=68, GDK_LEFT_SIDE=70, GDK_LEFT_TEE=72, GDK_LEFTBUTTON=74, GDK_LL_ANGLE=76, GDK_LR_ANGLE=78, GDK_MAN=80, GDK_MIDDLEBUTTON=82, GDK_MOUSE=84, GDK_PENCIL=86, GDK_PIRATE=88, GDK_PLUS=90, GDK_QUESTION_ARROW=92, GDK_RIGHT_PTR=94, GDK_RIGHT_SIDE=96, GDK_RIGHT_TEE=98, GDK_RIGHTBUTTON=100, GDK_RTL_LOGO=102, GDK_SAILBOAT=104, GDK_SB_DOWN_ARROW=106, GDK_SB_H_DOUBLE_ARROW=108, GDK_SB_LEFT_ARROW=110, GDK_SB_RIGHT_ARROW=112, GDK_SB_UP_ARROW=114, GDK_SB_V_DOUBLE_ARROW=116, GDK_SHUTTLE=118, GDK_SIZING=120, GDK_SPIDER=122, GDK_SPRAYCAN=124, GDK_STAR=126, GDK_TARGET=128, GDK_TCROSS=130, GDK_TOP_LEFT_ARROW=132, GDK_TOP_LEFT_CORNER=134, GDK_TOP_RIGHT_CORNER=136, GDK_TOP_SIDE=138, GDK_TOP_TEE=140, GDK_TREK=142, GDK_UL_ANGLE=144, GDK_UMBRELLA=146, GDK_UR_ANGLE=148, GDK_WATCH=150, GDK_XTERM=152, GDK_LAST_CURSOR=153, GDK_BLANK_CURSOR=-2, GDK_CURSOR_IS_PIXMAP=-1 };

// #anon_enum_GTK_ACCEL_VISIBLE=1_GTK_ACCEL_LOCKED=2_GTK_ACCEL_MASK=7
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 51
enum anonymous_24 { GTK_ACCEL_VISIBLE=1, GTK_ACCEL_LOCKED=2, GTK_ACCEL_MASK=7 };

// #anon_enum_GTK_DIR_TAB_FORWARD=0_GTK_DIR_TAB_BACKWARD=1_GTK_DIR_UP=2_GTK_DIR_DOWN=3_GTK_DIR_LEFT=4_GTK_DIR_RIGHT=5
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 122
enum anonymous_47 { GTK_DIR_TAB_FORWARD=0, GTK_DIR_TAB_BACKWARD=1, GTK_DIR_UP=2, GTK_DIR_DOWN=3, GTK_DIR_LEFT=4, GTK_DIR_RIGHT=5 };

// #anon_enum_GTK_JUSTIFY_LEFT=0_GTK_JUSTIFY_RIGHT=1_GTK_JUSTIFY_CENTER=2_GTK_JUSTIFY_FILL=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 181
enum anonymous_20 { GTK_JUSTIFY_LEFT=0, GTK_JUSTIFY_RIGHT=1, GTK_JUSTIFY_CENTER=2, GTK_JUSTIFY_FILL=3 };

// #anon_enum_GTK_ORIENTATION_HORIZONTAL=0_GTK_ORIENTATION_VERTICAL=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 262
enum anonymous_4 { GTK_ORIENTATION_HORIZONTAL=0, GTK_ORIENTATION_VERTICAL=1 };

// #anon_enum_GTK_POLICY_ALWAYS=0_GTK_POLICY_AUTOMATIC=1_GTK_POLICY_NEVER=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 305
enum anonymous_5 { GTK_POLICY_ALWAYS=0, GTK_POLICY_AUTOMATIC=1, GTK_POLICY_NEVER=2 };

// #anon_enum_GTK_RC_FG=1_GTK_RC_BG=2_GTK_RC_TEXT=4_GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous_14 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum_GTK_SHADOW_NONE=0_GTK_SHADOW_IN=1_GTK_SHADOW_OUT=2_GTK_SHADOW_ETCHED_IN=3_GTK_SHADOW_ETCHED_OUT=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 389
enum anonymous_11 { GTK_SHADOW_NONE=0, GTK_SHADOW_IN=1, GTK_SHADOW_OUT=2, GTK_SHADOW_ETCHED_IN=3, GTK_SHADOW_ETCHED_OUT=4 };

// #anon_enum_GTK_STATE_NORMAL=0_GTK_STATE_ACTIVE=1_GTK_STATE_PRELIGHT=2_GTK_STATE_SELECTED=3_GTK_STATE_INSENSITIVE=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 399
enum anonymous_49 { GTK_STATE_NORMAL=0, GTK_STATE_ACTIVE=1, GTK_STATE_PRELIGHT=2, GTK_STATE_SELECTED=3, GTK_STATE_INSENSITIVE=4 };

// #anon_enum_GTK_TEXT_DIR_NONE=0_GTK_TEXT_DIR_LTR=1_GTK_TEXT_DIR_RTL=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 173
enum anonymous_48 { GTK_TEXT_DIR_NONE=0, GTK_TEXT_DIR_LTR=1, GTK_TEXT_DIR_RTL=2 };

// #anon_enum_GTK_UPDATE_CONTINUOUS=0_GTK_UPDATE_DISCONTINUOUS=1_GTK_UPDATE_DELAYED=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 434
enum anonymous_3 { GTK_UPDATE_CONTINUOUS=0, GTK_UPDATE_DISCONTINUOUS=1, GTK_UPDATE_DELAYED=2 };

// #anon_enum_GTK_WIDGET_HELP_TOOLTIP=0_GTK_WIDGET_HELP_WHATS_THIS=1
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 127
enum anonymous_42 { GTK_WIDGET_HELP_TOOLTIP=0, GTK_WIDGET_HELP_WHATS_THIS=1 };

// #anon_enum_GTK_WINDOW_TOPLEVEL=0_GTK_WINDOW_POPUP=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 460
enum anonymous_16 { GTK_WINDOW_TOPLEVEL=0, GTK_WINDOW_POPUP=1 };

// #anon_enum_GTK_WIN_POS_NONE=0_GTK_WIN_POS_CENTER=1_GTK_WIN_POS_MOUSE=2_GTK_WIN_POS_CENTER_ALWAYS=3_GTK_WIN_POS_CENTER_ON_PARENT=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 450
enum anonymous_17 { GTK_WIN_POS_NONE=0, GTK_WIN_POS_CENTER=1, GTK_WIN_POS_MOUSE=2, GTK_WIN_POS_CENTER_ALWAYS=3, GTK_WIN_POS_CENTER_ON_PARENT=4 };

// #anon_enum_G_PARAM_READABLE=1_G_PARAM_WRITABLE=2_G_PARAM_READWRITE=3_G_PARAM_CONSTRUCT=4_G_PARAM_CONSTRUCT_ONLY=8_G_PARAM_LAX_VALIDATION=16_G_PARAM_STATIC_NAME=32_G_PARAM_PRIVATE=32_G_PARAM_STATIC_NICK=64_G_PARAM_STATIC_BLURB=128_G_PARAM_EXPLICIT_NOTIFY=1073741824_G_PARAM_DEPRECATED=-2147483648
// file /usr/include/glib-2.0/gobject/gparam.h line 150
enum anonymous_28 { G_PARAM_READABLE=1, G_PARAM_WRITABLE=2, G_PARAM_READWRITE=3, G_PARAM_CONSTRUCT=4, G_PARAM_CONSTRUCT_ONLY=8, G_PARAM_LAX_VALIDATION=16, G_PARAM_STATIC_NAME=32, G_PARAM_PRIVATE=32, G_PARAM_STATIC_NICK=64, G_PARAM_STATIC_BLURB=128, G_PARAM_EXPLICIT_NOTIFY=1073741824, G_PARAM_DEPRECATED=-2147483648 };

// #anon_enum_G_SIGNAL_MATCH_ID=1_G_SIGNAL_MATCH_DETAIL=2_G_SIGNAL_MATCH_CLOSURE=4_G_SIGNAL_MATCH_FUNC=8_G_SIGNAL_MATCH_DATA=16_G_SIGNAL_MATCH_UNBLOCKED=32
// file /usr/include/glib-2.0/gobject/gsignal.h line 173
enum anonymous_9 { G_SIGNAL_MATCH_ID=1, G_SIGNAL_MATCH_DETAIL=2, G_SIGNAL_MATCH_CLOSURE=4, G_SIGNAL_MATCH_FUNC=8, G_SIGNAL_MATCH_DATA=16, G_SIGNAL_MATCH_UNBLOCKED=32 };

// #anon_enum_G_TYPE_FLAG_ABSTRACT=16_G_TYPE_FLAG_VALUE_ABSTRACT=32
// file /usr/include/glib-2.0/gobject/gtype.h line 993
enum anonymous_25 { G_TYPE_FLAG_ABSTRACT=16, G_TYPE_FLAG_VALUE_ABSTRACT=32 };

// #anon_enum_LO_INT32=105_LO_FLOAT=102_LO_STRING=115_LO_BLOB=98_LO_INT64=104_LO_TIMETAG=116_LO_DOUBLE=100_LO_SYMBOL=83_LO_CHAR=99_LO_MIDI=109_LO_TRUE=84_LO_FALSE=70_LO_NIL=78_LO_INFINITUM=73
// file /usr/include/lo/lo_osc_types.h line 72
enum anonymous_15 { LO_INT32=105, LO_FLOAT=102, LO_STRING=115, LO_BLOB=98, LO_INT64=104, LO_TIMETAG=116, LO_DOUBLE=100, LO_SYMBOL=83, LO_CHAR=99, LO_MIDI=109, LO_TRUE=84, LO_FALSE=70, LO_NIL=78, LO_INFINITUM=73 };

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'toplevel_under_pointer'||*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'window_under_pointer'||F64'toplevel_x'||F64'toplevel_y'||U32'state'||U32'button'||U64'motion_hint_serial'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 63
struct anonymous_22;

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'window'||*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'native_window'||U64'serial'||S32'owner_events'||U32'time'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 47
struct anonymous_21;

// tag-#anon#ST[*{V()->V}_V()->V_'f'||*{V}_V_'d'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 165
struct anonymous;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_18;

// tag-#anon#ST[U32'sec'||U32'frac'|]
// file /usr/include/lo/lo_osc_types.h line 46
struct anonymous_6;

// tag-#anon#UN[ARR20{S8}_S8_'b'||ARR10{S16}_S16_'s'||ARR5{S64}_S64_'l'|]
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 445
union anonymous_41;

// tag-#anon#UN[S32'i'||S32'i32'||S64'h'||S64'i64'||F32'f'||F32'f32'||F64'd'||F64'f64'||S8's'||S8'S'||U8'c'||ARR4{U8}_U8_'m'||SYM#tag-#anon#ST[U32'sec'||U32'frac'|]#'t'|]
// file /usr/include/lo/lo_osc_types.h line 115
union anonymous_7;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}_V_'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous_27;

// tag-#anon#UN[S32'value'||SYM#tag-snd_seq_timestamp#'time'||U32'position'||SYM#tag-snd_seq_queue_skew#'skew'||ARR2{U32}_U32_'d32'||ARR8{U8}_U8_'d8'|]
// file /usr/include/alsa/seq_event.h line 284
union anonymous_10;

// tag-#anon#UN[S8'char_data'||U8'uchar_data'||S32'bool_data'||S32'int_data'||U32'uint_data'||S64'long_data'||U64'ulong_data'||F32'float_data'||F64'double_data'||*{S8}_S8_'string_data'||*{SYM#tag-_GtkObject#}_SYM#tag-_GtkObject#_'object_data'||*{V}_V_'pointer_data'||SYM#tag-#anon#ST[*{V()->V}_V()->V_'f'||*{V}_V_'d'|]#'signal_data'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 149
union anonymous_39;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_19;

// tag-#anon#UN[SYM#tag-_argc_state#'argv'||SYM#tag-_file_state#'file'|]
// file getarg.h line 50
union anonymous_2;

// tag-#anon#UN[SYM#tag-snd_seq_ev_note#'note'||SYM#tag-snd_seq_ev_ctrl#'control'||SYM#tag-snd_seq_ev_raw8#'raw8'||SYM#tag-snd_seq_ev_raw32#'raw32'||SYM#tag-snd_seq_ev_ext#'ext'||SYM#tag-snd_seq_ev_queue_control#'queue'||SYM#tag-snd_seq_timestamp#'time'||SYM#tag-snd_seq_addr#'addr'||SYM#tag-snd_seq_connect#'connect'||SYM#tag-snd_seq_result#'result'||U128'_pad'|]
// file /usr/include/alsa/seq_event.h line 307
union anonymous_8;

// tag-JackOptions
// file /usr/include/jack/types.h line 90
enum JackOptions { JackNullOption=0, JackNoStartServer=1, JackUseExactName=2, JackServerName=4, JackLoadName=8, JackLoadInit=16, JackSessionID=32 };

// tag-JackSessionEventType
// file /usr/include/jack/session.h line 46
enum JackSessionEventType { JackSessionSave=1, JackSessionSaveAndQuit=2, JackSessionSaveTemplate=3 };

// tag-JackSessionFlags
// file /usr/include/jack/session.h line 83
enum JackSessionFlags { JackSessionSaveError=1, JackSessionNeedTerminal=2 };

// tag-JackStatus
// file /usr/include/jack/types.h line 149
enum JackStatus { JackFailure=1, JackInvalidOption=2, JackNameNotUnique=4, JackServerStarted=8, JackServerFailed=16, JackServerError=32, JackNoSuchClient=64, JackLoadFailure=128, JackInitFailure=256, JackShmFailure=512, JackVersionError=1024, JackBackendError=2048, JackClientZombie=4096 };

// tag-_AtkObject
// file /usr/include/atk-1.0/atk/atkobject.h line 440
struct _AtkObject;

// tag-_AtkRelationSet
// file /usr/include/atk-1.0/atk/atkobject.h line 442
struct _AtkRelationSet;

// tag-_Blinky
// file eyecandy.h line 38
struct _Blinky;

// tag-_BlinkyClass
// file eyecandy.h line 39
struct _BlinkyClass;

// tag-_DSSI_Descriptor
// file /usr/include/dssi.h line 77
struct _DSSI_Descriptor;

// tag-_DSSI_Program_Descriptor
// file /usr/include/dssi.h line 57
struct _DSSI_Program_Descriptor;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GObjectClass
// file /usr/include/glib-2.0/gobject/gobject.h line 188
struct _GObjectClass;

// tag-_GObjectConstructParam
// file /usr/include/glib-2.0/gobject/gobject.h line 191
struct _GObjectConstructParam;

// tag-_GParamSpec
// file /usr/include/glib-2.0/gobject/gparam.h line 193
struct _GParamSpec;

// tag-_GPtrArray
// file /usr/include/glib-2.0/glib/garray.h line 39
struct _GPtrArray;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 80
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkCursor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 104
struct _GdkCursor;

// tag-_GdkDevice
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 47
struct _GdkDevice;

// tag-_GdkDeviceAxis
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 46
struct _GdkDeviceAxis;

// tag-_GdkDeviceKey
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 45
struct _GdkDeviceKey;

// tag-_GdkDisplay
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 115
struct _GdkDisplay;

// tag-_GdkDisplayPointerHooks
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 37
struct _GdkDisplayPointerHooks;

// tag-_GdkDragContext
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 38
struct _GdkDragContext;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEvent
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 68
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 47
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 52
struct _GdkEventButton;

// tag-_GdkEventClient
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 62
struct _GdkEventClient;

// tag-_GdkEventConfigure
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 57
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 56
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 63
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 48
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 55
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 66
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 51
struct _GdkEventMotion;

// tag-_GdkEventNoExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 49
struct _GdkEventNoExpose;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 60
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 58
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 61
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 53
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 59
struct _GdkEventSelection;

// tag-_GdkEventSetting
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 65
struct _GdkEventSetting;

// tag-_GdkEventVisibility
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 50
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 64
struct _GdkEventWindowState;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkScreen
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 116
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GdkWindowAttr
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 41
struct _GdkWindowAttr;

// tag-_GtkAccelGroup
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 60
struct _GtkAccelGroup;

// tag-_GtkAccelGroupEntry
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 63
struct _GtkAccelGroupEntry;

// tag-_GtkAccelKey
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 62
struct _GtkAccelKey;

// tag-_GtkAdjustment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 48
struct _GtkAdjustment;

// tag-_GtkArg
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 48
struct _GtkArg;

// tag-_GtkBin
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 48
struct _GtkBin;

// tag-_GtkBox
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 49
struct _GtkBox;

// tag-_GtkButton
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 48
struct _GtkButton;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkDialog
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 94
struct _GtkDialog;

// tag-_GtkFileSelection
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 46
struct _GtkFileSelection;

// tag-_GtkFrame
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 49
struct _GtkFrame;

// tag-_GtkItem
// file /usr/include/gtk-2.0/gtk/gtkitem.h line 48
struct _GtkItem;

// tag-_GtkLabel
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 49
struct _GtkLabel;

// tag-_GtkLabelSelectionInfo
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 52
struct _GtkLabelSelectionInfo;

// tag-_GtkMenu
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 49
struct _GtkMenu;

// tag-_GtkMenuItem
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 48
struct _GtkMenuItem;

// tag-_GtkMenuShell
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 48
struct _GtkMenuShell;

// tag-_GtkMisc
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 48
struct _GtkMisc;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkObjectClass
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 104
struct _GtkObjectClass;

// tag-_GtkRange
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 53
struct _GtkRange;

// tag-_GtkRangeLayout
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 50
struct _GtkRangeLayout;

// tag-_GtkRangeStepTimer
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 51
struct _GtkRangeStepTimer;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 52
struct _GtkScrolledWindow;

// tag-_GtkSelectionData
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 479
struct _GtkSelectionData;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkToggleButton
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 48
struct _GtkToggleButton;

// tag-_GtkTooltip
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 484
struct _GtkTooltip;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_GtkWidgetClass
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 480
struct _GtkWidgetClass;

// tag-_GtkWindow
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 485
struct _GtkWindow;

// tag-_GtkWindowGeometryInfo
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 50
struct _GtkWindowGeometryInfo;

// tag-_GtkWindowGroup
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 51
struct _GtkWindowGroup;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_LADSPA_Descriptor
// file /usr/include/ladspa.h line 373
struct _LADSPA_Descriptor;

// tag-_LADSPA_PortRangeHint
// file /usr/include/ladspa.h line 337
struct _LADSPA_PortRangeHint;

// tag-_PangoAttrList
// file /usr/include/pango-1.0/pango/pango-attributes.h line 111
struct _PangoAttrList;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-_PangoLayout
// file /usr/include/pango-1.0/pango/pango-layout.h line 32
struct _PangoLayout;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_argc_state
// file getarg.h line 35
struct _argc_state;

// tag-_cairo_font_options
// file /usr/include/cairo/cairo.h line 1366
struct _cairo_font_options;

// tag-_configure_item_t
// file ghostess.h line 91
struct _configure_item_t;

// tag-_d3h_dll_t
// file ghostess.h line 65
struct _d3h_dll_t;

// tag-_d3h_instance_t
// file ghostess.h line 120
struct _d3h_instance_t;

// tag-_d3h_plugin_t
// file ghostess.h line 75
struct _d3h_plugin_t;

// tag-_file_state
// file getarg.h line 41
struct _file_state;

// tag-_getarg_state
// file getarg.h line 33
struct _getarg_state;

// tag-_initial_port_set_t
// file ghostess.h line 99
struct _initial_port_set_t;

// tag-_instance_template_t
// file ghostess.h line 109
struct _instance_template_t;

// tag-_jack_client
// file /usr/include/jack/types.h line 72
struct _jack_client;

// tag-_jack_port
// file /usr/include/jack/types.h line 66
struct _jack_port;

// tag-_jack_session_event
// file /usr/include/jack/session.h line 100
struct _jack_session_event;

// tag-_plugin_strip
// file ghostess.h line 63
struct _plugin_strip;

// tag-_snd_seq
// file /usr/include/alsa/seq.h line 47
struct _snd_seq;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sched_param
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 72
struct sched_param;

// tag-snd_midi_event
// file /usr/include/alsa/seq_midi_event.h line 43
struct snd_midi_event;

// tag-snd_seq_addr
// file /usr/include/alsa/seq_event.h line 178
struct snd_seq_addr;

// tag-snd_seq_connect
// file /usr/include/alsa/seq_event.h line 184
struct snd_seq_connect;

// tag-snd_seq_ev_ctrl
// file /usr/include/alsa/seq_event.h line 239
struct snd_seq_ev_ctrl;

// tag-snd_seq_ev_ext
// file /usr/include/alsa/seq_event.h line 257
struct snd_seq_ev_ext;

// tag-snd_seq_ev_note
// file /usr/include/alsa/seq_event.h line 230
struct snd_seq_ev_note;

// tag-snd_seq_ev_queue_control
// file /usr/include/alsa/seq_event.h line 281
struct snd_seq_ev_queue_control;

// tag-snd_seq_ev_raw32
// file /usr/include/alsa/seq_event.h line 252
struct snd_seq_ev_raw32;

// tag-snd_seq_ev_raw8
// file /usr/include/alsa/seq_event.h line 247
struct snd_seq_ev_raw8;

// tag-snd_seq_event
// file /usr/include/alsa/seq_event.h line 296
struct snd_seq_event;

// tag-snd_seq_queue_skew
// file /usr/include/alsa/seq_event.h line 275
struct snd_seq_queue_skew;

// tag-snd_seq_real_time
// file /usr/include/alsa/seq_event.h line 191
struct snd_seq_real_time;

// tag-snd_seq_result
// file /usr/include/alsa/seq_event.h line 269
struct snd_seq_result;

// tag-snd_seq_timestamp
// file /usr/include/alsa/seq_event.h line 200
union snd_seq_timestamp;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __atomic_load_8
// file eyecandy.c line 49 function blinky_get_type
signed int __atomic_load_8(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// add_configure_item
// file ghostess.c line 832
void add_configure_item(struct _configure_item_t **head, char *key, char *value);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// audio_callback
// file ghostess.c line 232
signed int audio_callback(unsigned int nframes, void *arg);
// blinky_class_init
// file eyecandy.c line 52
static void blinky_class_init(struct _BlinkyClass *class);
// blinky_class_intern_init
// file eyecandy.c line 49
static void blinky_class_intern_init(void *klass);
// blinky_destroy
// file eyecandy.c line 98
static void blinky_destroy(struct _GtkObject *object);
// blinky_expose
// file eyecandy.c line 194
static signed int blinky_expose(struct _GtkWidget *widget, struct _GdkEventExpose *event);
// blinky_get_state
// file eyecandy.c line 114
unsigned int blinky_get_state(struct _Blinky *blinky);
// blinky_get_type
// file eyecandy.c line 49
unsigned long int blinky_get_type(void);
// blinky_init
// file eyecandy.c line 82
static void blinky_init(struct _Blinky *blinky);
// blinky_new
// file eyecandy.c line 88
struct _GtkWidget * blinky_new(unsigned int state);
// blinky_realize
// file eyecandy.c line 134
static void blinky_realize(struct _GtkWidget *widget);
// blinky_set_state
// file eyecandy.c line 123
void blinky_set_state(struct _Blinky *blinky, unsigned int state);
// blinky_size_allocate
// file eyecandy.c line 176
static void blinky_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation);
// blinky_size_request
// file eyecandy.c line 169
static void blinky_size_request(struct _GtkWidget *widget, struct _GtkRequisition *requisition);
// blinky_update
// file eyecandy.c line 219
static void blinky_update(struct _Blinky *blinky);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// copy_configure_items
// file ghostess.c line 853
void copy_configure_items(struct _instance_template_t *temp, struct _d3h_instance_t *inst);
// copy_initial_port_set
// file ghostess.c line 737
static void copy_initial_port_set(struct _instance_template_t *temp, struct _d3h_instance_t *inst);
// create_about_window
// file gui_interface.c line 294
void create_about_window(const char *tag);
// create_file_selection
// file gui_interface.c line 256
void create_file_selection(const char *tag);
// create_main_window
// file gui_interface.c line 59
void create_main_window(const char *tag, signed int instance_count);
// create_notice_window
// file gui_interface.c line 338
void create_notice_window(const char *tag);
// create_plugin_strip
// file gui_interface.h line 56
struct _plugin_strip * create_plugin_strip(struct _GtkWidget *parent_window, struct _d3h_instance_t *instance);
// create_ui_context_menu
// file gui_interface.c line 222
void create_ui_context_menu(struct _GtkWidget *parent_window);
// create_windows
// file gui_interface.h line 58
void create_windows(const char *host_tag, signed int instance_count);
// display_notice
// file gui_callbacks.c line 324
void display_notice(char *message1, char *message2);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// escape_for_shell
// file ghostess.c line 869
void escape_for_shell(char **p, const char *text);
// execlp
// file /usr/include/unistd.h line 584
extern signed int execlp(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern float expf(float);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);

//

// file_selection_set_path
// file gui_callbacks.c line 53
void file_selection_set_path(char *filename);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_instance_template
// file ghostess.c line 779
static void free_instance_template(struct _instance_template_t *t);
// free_programs
// file ghostess.c line 1312
void free_programs(struct _d3h_instance_t *instance);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// g_ascii_formatd
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 168
extern char * g_ascii_formatd(char *, signed int, const char *, double);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_idle_add
// file /usr/include/glib-2.0/glib/gmain.h line 584
extern unsigned int g_idle_add(signed int (*)(void *), void *);
// g_intern_static_string
// file /usr/include/glib-2.0/glib/gquark.h line 64
extern const char * g_intern_static_string(const char *);
// g_object_new
// file /usr/include/glib-2.0/gobject/gobject.h line 420
extern void * g_object_new(unsigned long int, const char *, ...);
// g_once_init_enter
// file /usr/include/glib-2.0/glib/gthread.h line 232
extern signed int g_once_init_enter(volatile void *);
// g_once_init_leave
// file /usr/include/glib-2.0/glib/gthread.h line 234
extern void g_once_init_leave(volatile void *, unsigned long int);
// g_return_if_fail_warning
// file /usr/include/glib-2.0/glib/gmessages.h line 124
extern void g_return_if_fail_warning(const char *, const char *, const char *);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_strtod
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 146
extern double g_strtod(const char *, char **);
// g_type_check_class_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2177
extern struct _GTypeClass * g_type_check_class_cast(struct _GTypeClass *, unsigned long int);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// g_type_check_instance_is_a
// file /usr/include/glib-2.0/gobject/gtype.h line 2171
extern signed int g_type_check_instance_is_a(struct _GTypeInstance *, unsigned long int);
// g_type_class_adjust_private_offset
// file /usr/include/glib-2.0/gobject/gtype.h line 1302
extern void g_type_class_adjust_private_offset(void *, signed int *);
// g_type_class_peek_parent
// file /usr/include/glib-2.0/gobject/gtype.h line 709
extern void * g_type_class_peek_parent(void *);
// g_type_register_static_simple
// file /usr/include/glib-2.0/gobject/gtype.h line 1259
extern unsigned long int g_type_register_static_simple(unsigned long int, const char *, unsigned int, void (*)(void *, void *), unsigned int, void (*)(struct _GTypeInstance *, void *), enum anonymous_25);
// gdk_color_alloc
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 154
signed int gdk_color_alloc(struct _GdkColormap *, struct _GdkColor *);
// gdk_colormap_get_system
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 100
struct _GdkColormap * gdk_colormap_get_system(void);
// gdk_draw_rectangle
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 285
void gdk_draw_rectangle(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, signed int, signed int, signed int);
// gdk_gc_new
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 225
struct _GdkGC * gdk_gc_new(struct _GdkDrawable *);
// gdk_gc_set_foreground
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 238
void gdk_gc_set_foreground(struct _GdkGC *, const struct _GdkColor *);
// gdk_window_clear_area
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 367
void gdk_window_clear_area(struct _GdkDrawable *, signed int, signed int, signed int, signed int);
// gdk_window_move_resize
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 357
void gdk_window_move_resize(struct _GdkDrawable *, signed int, signed int, signed int, signed int);
// gdk_window_new
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 332
struct _GdkDrawable * gdk_window_new(struct _GdkDrawable *, struct _GdkWindowAttr *, signed int);
// gdk_window_set_user_data
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 384
void gdk_window_set_user_data(struct _GdkDrawable *, void *);
// get_port_default
// file ghostess.c line 2346
float get_port_default(const struct _LADSPA_Descriptor *plugin, signed int port);
// getarg
// file getarg.h line 31
char * getarg(void);
// getarg_cleanup
// file getarg.h line 28
void getarg_cleanup(void);
// getarg_init_with_command_line
// file getarg.h line 29
void getarg_init_with_command_line(signed int argc, char **argv);
// getarg_init_with_file
// file getarg.c line 152
signed int getarg_init_with_file(char *filename);
// getarg_internal
// file getarg.c line 268
static char * getarg_internal(void);
// getarg_pop_state
// file getarg.c line 58
static void getarg_pop_state(void);
// getarg_print_possible_error
// file getarg.h line 27
void getarg_print_possible_error(void);
// getarg_push_file
// file getarg.c line 119
static signed int getarg_push_file(char *filename);
// getarg_read_file_arg
// file getarg.c line 164
static signed int getarg_read_file_arg(struct _getarg_state *state);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// ghss_debug
// file ghostess.c line 154
void ghss_debug(signed int type, const char *format, ...);
// gtk_accel_group_new
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 123
struct _GtkAccelGroup * gtk_accel_group_new(void);
// gtk_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 104
unsigned long int gtk_box_get_type(void);
// gtk_box_pack_end
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 114
void gtk_box_pack_end(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_box_pack_start
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 109
void gtk_box_pack_start(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 93
struct _GtkWidget * gtk_button_new_with_label(const char *);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_container_set_border_width
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 108
void gtk_container_set_border_width(struct _GtkContainer *, unsigned int);
// gtk_file_selection_get_filename
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 106
const char * gtk_file_selection_get_filename(struct _GtkFileSelection *);
// gtk_file_selection_get_type
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 102
unsigned long int gtk_file_selection_get_type(void);
// gtk_file_selection_new
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 103
struct _GtkWidget * gtk_file_selection_new(const char *);
// gtk_file_selection_set_filename
// file /usr/include/gtk-2.0/gtk/gtkfilesel.h line 104
void gtk_file_selection_set_filename(struct _GtkFileSelection *, const char *);
// gtk_frame_get_type
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 72
unsigned long int gtk_frame_get_type(void);
// gtk_frame_new
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 73
struct _GtkWidget * gtk_frame_new(const char *);
// gtk_frame_set_shadow_type
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 88
void gtk_frame_set_shadow_type(struct _GtkFrame *, enum anonymous_11);
// gtk_hbox_new
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 63
struct _GtkWidget * gtk_hbox_new(signed int, signed int);
// gtk_init
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 94
void gtk_init(signed int *, char ***);
// gtk_label_get_type
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 109
unsigned long int gtk_label_get_type(void);
// gtk_label_new
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 110
struct _GtkWidget * gtk_label_new(const char *);
// gtk_label_set_justify
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 138
void gtk_label_set_justify(struct _GtkLabel *, enum anonymous_20);
// gtk_label_set_line_wrap
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 152
void gtk_label_set_line_wrap(struct _GtkLabel *, signed int);
// gtk_label_set_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 112
void gtk_label_set_text(struct _GtkLabel *, const char *);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_menu_bar_new
// file /usr/include/gtk-2.0/gtk/gtkmenubar.h line 69
struct _GtkWidget * gtk_menu_bar_new(void);
// gtk_menu_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 125
unsigned long int gtk_menu_get_type(void);
// gtk_menu_item_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 99
unsigned long int gtk_menu_item_get_type(void);
// gtk_menu_item_new
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 100
struct _GtkWidget * gtk_menu_item_new(void);
// gtk_menu_item_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 101
struct _GtkWidget * gtk_menu_item_new_with_label(const char *);
// gtk_menu_item_set_right_justified
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 113
void gtk_menu_item_set_right_justified(struct _GtkMenuItem *, signed int);
// gtk_menu_item_set_submenu
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 103
void gtk_menu_item_set_submenu(struct _GtkMenuItem *, struct _GtkWidget *);
// gtk_menu_new
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 126
struct _GtkWidget * gtk_menu_new(void);
// gtk_menu_popup
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 129
void gtk_menu_popup(struct _GtkMenu *, struct _GtkWidget *, struct _GtkWidget *, void (*)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *), void *, unsigned int, unsigned int);
// gtk_menu_shell_append
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 101
void gtk_menu_shell_append(struct _GtkMenuShell *, struct _GtkWidget *);
// gtk_misc_get_type
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 68
unsigned long int gtk_misc_get_type(void);
// gtk_misc_set_alignment
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 69
void gtk_misc_set_alignment(struct _GtkMisc *, float, float);
// gtk_misc_set_padding
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 75
void gtk_misc_set_padding(struct _GtkMisc *, signed int, signed int);
// gtk_object_get_type
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 146
unsigned long int gtk_object_get_type(void);
// gtk_object_set_data
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 181
void gtk_object_set_data(struct _GtkObject *, const char *, void *);
// gtk_object_set_data_full
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 184
void gtk_object_set_data_full(struct _GtkObject *, const char *, void *, void (*)(void *));
// gtk_range_get_type
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 136
unsigned long int gtk_range_get_type(void);
// gtk_range_set_update_policy
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 139
void gtk_range_set_update_policy(struct _GtkRange *, enum anonymous_3);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 102
unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_new
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 103
struct _GtkWidget * gtk_scrolled_window_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_scrolled_window_set_policy
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 113
void gtk_scrolled_window_set_policy(struct _GtkScrolledWindow *, enum anonymous_5, enum anonymous_5);
// gtk_signal_compat_matched
// file /usr/include/gtk-2.0/gtk/gtksignal.h line 141
void gtk_signal_compat_matched(struct _GtkObject *, void (*)(void), void *, enum anonymous_9, unsigned int);
// gtk_signal_connect_full
// file /usr/include/gtk-2.0/gtk/gtksignal.h line 121
unsigned long int gtk_signal_connect_full(struct _GtkObject *, const char *, void (*)(void), void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *), void *, void (*)(void *), signed int, signed int);
// gtk_style_attach
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 443
struct _GtkStyle * gtk_style_attach(struct _GtkStyle *, struct _GdkDrawable *);
// gtk_style_new
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 441
struct _GtkStyle * gtk_style_new(void);
// gtk_style_set_background
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 456
void gtk_style_set_background(struct _GtkStyle *, struct _GdkDrawable *, enum anonymous_49);
// gtk_timeout_add
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 174
unsigned int gtk_timeout_add(unsigned int, signed int (*)(void *), void *);
// gtk_timeout_callback
// file ghostess.c line 1328
signed int gtk_timeout_callback(void *data);
// gtk_timeout_remove
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 182
void gtk_timeout_remove(unsigned int);
// gtk_toggle_button_get_type
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 74
unsigned long int gtk_toggle_button_get_type(void);
// gtk_toggle_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 77
struct _GtkWidget * gtk_toggle_button_new_with_label(const char *);
// gtk_toggle_button_set_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 82
void gtk_toggle_button_set_active(struct _GtkToggleButton *, signed int);
// gtk_type_class
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 239
void * gtk_type_class(unsigned long int);
// gtk_vbox_new
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 63
struct _GtkWidget * gtk_vbox_new(signed int, signed int);
// gtk_viewport_new
// file /usr/include/gtk-2.0/gtk/gtkviewport.h line 75
struct _GtkWidget * gtk_viewport_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_widget_add_accelerator
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 892
void gtk_widget_add_accelerator(struct _GtkWidget *, const char *, struct _GtkAccelGroup *, unsigned int, enum anonymous_23, enum anonymous_24);
// gtk_widget_draw
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 883
void gtk_widget_draw(struct _GtkWidget *, const struct _GdkRectangle *);
// gtk_widget_get_colormap
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1053
struct _GdkColormap * gtk_widget_get_colormap(struct _GtkWidget *);
// gtk_widget_get_events
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1114
signed int gtk_widget_get_events(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 833
unsigned long int gtk_widget_get_type(void);
// gtk_widget_get_visual
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1054
struct _GdkVisual * gtk_widget_get_visual(struct _GtkWidget *);
// gtk_widget_hide
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 853
void gtk_widget_hide(struct _GtkWidget *);
// gtk_widget_ref
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 841
struct _GtkWidget * gtk_widget_ref(struct _GtkWidget *);
// gtk_widget_set_sensitive
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 964
void gtk_widget_set_sensitive(struct _GtkWidget *, signed int);
// gtk_widget_set_size_request
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1027
void gtk_widget_set_size_request(struct _GtkWidget *, signed int, signed int);
// gtk_widget_show
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 851
void gtk_widget_show(struct _GtkWidget *);
// gtk_widget_unref
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 842
void gtk_widget_unref(struct _GtkWidget *);
// gtk_window_add_accel_group
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 191
void gtk_window_add_accel_group(struct _GtkWindow *, struct _GtkAccelGroup *);
// gtk_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 178
unsigned long int gtk_window_get_type(void);
// gtk_window_new
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 179
struct _GtkWidget * gtk_window_new(enum anonymous_16);
// gtk_window_set_modal
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 307
void gtk_window_set_modal(struct _GtkWindow *, signed int);
// gtk_window_set_position
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 195
void gtk_window_set_position(struct _GtkWindow *, enum anonymous_17);
// gtk_window_set_title
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 180
void gtk_window_set_title(struct _GtkWindow *, const char *);
// instance_sort_cmp
// file ghostess.c line 1042
static signed int instance_sort_cmp(const void *a, const void *b);
// instance_template_set_port
// file ghostess.c line 790
static void instance_template_set_port(struct _instance_template_t *t, unsigned long int port, float value);
// jack_activate
// file /usr/include/jack/jack.h line 183
signed int jack_activate(struct _jack_client *);
// jack_client_close
// file /usr/include/jack/jack.h line 104
signed int jack_client_close(struct _jack_client *);
// jack_client_open
// file /usr/include/jack/jack.h line 88
struct _jack_client * jack_client_open(const char *, enum JackOptions, enum JackStatus *, ...);
// jack_connect
// file /usr/include/jack/jack.h line 848
signed int jack_connect(struct _jack_client *, const char *, const char *);
// jack_frame_time
// file /usr/include/jack/jack.h line 1179
unsigned int jack_frame_time(const struct _jack_client *);
// jack_get_buffer_size
// file /usr/include/jack/jack.h line 565
unsigned int jack_get_buffer_size(struct _jack_client *);
// jack_get_client_name
// file /usr/include/jack/jack.h line 118
char * jack_get_client_name(struct _jack_client *);
// jack_get_ports
// file /usr/include/jack/jack.h line 1137
const char ** jack_get_ports(struct _jack_client *, const char *, const char *, unsigned long int);
// jack_get_sample_rate
// file /usr/include/jack/jack.h line 554
unsigned int jack_get_sample_rate(struct _jack_client *);
// jack_last_frame_time
// file /usr/include/jack/jack.h line 1195
unsigned int jack_last_frame_time(const struct _jack_client *);
// jack_port_get_buffer
// file /usr/include/jack/jack.h line 649
void * jack_port_get_buffer(struct _jack_port *, unsigned int);
// jack_port_name
// file /usr/include/jack/jack.h line 657
const char * jack_port_name(const struct _jack_port *);
// jack_port_register
// file /usr/include/jack/jack.h line 624
struct _jack_port * jack_port_register(struct _jack_client *, const char *, const char *, unsigned long int, unsigned long int);
// jack_session_event_free
// file /usr/include/jack/session.h line 197
void jack_session_event_free(struct _jack_session_event *);
// jack_session_reply
// file /usr/include/jack/session.h line 188
signed int jack_session_reply(struct _jack_client *, struct _jack_session_event *);
// jack_set_process_callback
// file /usr/include/jack/jack.h line 342
signed int jack_set_process_callback(struct _jack_client *, signed int (*)(unsigned int, void *), void *);
// jack_set_session_callback
// file /usr/include/jack/session.h line 175
signed int jack_set_session_callback(struct _jack_client *, void (*)(struct _jack_session_event *, void *), void *);
// lo_address_free
// file /usr/include/lo/lo.h line 89
void lo_address_free(void *);
// lo_address_get_hostname
// file /usr/include/lo/lo_lowlevel.h line 391
const char * lo_address_get_hostname(void *);
// lo_address_get_port
// file /usr/include/lo/lo_lowlevel.h line 399
const char * lo_address_get_port(void *);
// lo_address_new
// file /usr/include/lo/lo.h line 60
void * lo_address_new(const char *, const char *);
// lo_arg_pp
// file /usr/include/lo/lo_lowlevel.h line 1054
void lo_arg_pp(enum anonymous_15, void *);
// lo_message_get_source
// file /usr/include/lo/lo_lowlevel.h line 297
void * lo_message_get_source(void *);
// lo_send_internal
// file /usr/include/lo/lo_lowlevel.h line 973
signed int lo_send_internal(void *, const char *, const signed int, const char *, const char *, ...);
// lo_server_thread_add_method
// file /usr/include/lo/lo_serverthread.h line 119
void * lo_server_thread_add_method(void *, const char *, const char *, signed int (*)(const char *, const char *, union anonymous_7 **, signed int, void *, void *), void *);
// lo_server_thread_get_url
// file /usr/include/lo/lo_serverthread.h line 159
char * lo_server_thread_get_url(void *);
// lo_server_thread_new
// file /usr/include/lo/lo_serverthread.h line 44
void * lo_server_thread_new(const char *, void (*)(signed int, const char *, const char *));
// lo_server_thread_start
// file /usr/include/lo/lo_serverthread.h line 139
signed int lo_server_thread_start(void *);
// lo_url_get_hostname
// file /usr/include/lo/lo_lowlevel.h line 930
char * lo_url_get_hostname(const char *);
// lo_url_get_path
// file /usr/include/lo/lo_lowlevel.h line 944
char * lo_url_get_path(const char *);
// lo_url_get_port
// file /usr/include/lo/lo_lowlevel.h line 937
char * lo_url_get_port(const char *);
// load
// file ghostess.c line 668
char * load(const char *dllName, void **dll);
// logf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern float logf(float);
// lrintf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 325
extern signed long int lrintf(float);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// midi_open
// file midi.h line 33
signed int midi_open(void);
// midi_thread_function
// file midi.h line 34
void * midi_thread_function(void *arg);
// new_instance_template
// file ghostess.c line 750
static struct _instance_template_t * new_instance_template(void);
// on_about_dismiss
// file gui_callbacks.c line 206
void on_about_dismiss(struct _GtkWidget *widget, void *data);
// on_delete_event_wrapper
// file gui_callbacks.c line 145
signed int on_delete_event_wrapper(struct _GtkWidget *widget, union _GdkEvent *event, void *data);

//

// on_file_selection_cancel
// file gui_callbacks.c line 164
void on_file_selection_cancel(struct _GtkWidget *widget, void *data);
// on_file_selection_ok
// file gui_callbacks.c line 157
void on_file_selection_ok(struct _GtkWidget *widget, void *data);
// on_menu_about_activate
// file gui_callbacks.c line 103
void on_menu_about_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_patchlist_activate
// file gui_callbacks.c line 83
void on_menu_patchlist_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_quit_activate
// file gui_callbacks.c line 94
void on_menu_quit_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_save_activate
// file gui_callbacks.c line 72
void on_menu_save_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_notice_dismiss
// file gui_callbacks.c line 332
void on_notice_dismiss(struct _GtkWidget *widget, void *data);
// on_patchlist_file_ok
// file gui_callbacks.c line 188
void on_patchlist_file_ok(struct _GtkWidget *widget, void *data);
// on_save_file_ok
// file gui_callbacks.c line 171
void on_save_file_ok(struct _GtkWidget *widget, void *data);
// on_strip_ui_button_event
// file gui_callbacks.c line 235
signed int on_strip_ui_button_event(struct _GtkWidget *widget, struct _GdkEventButton *event, void *data);
// on_strip_ui_button_toggled
// file gui_callbacks.c line 212
void on_strip_ui_button_toggled(struct _GtkWidget *widget, void *data);
// on_ui_context_menu_activate
// file gui_callbacks.c line 274
void on_ui_context_menu_activate(struct _GtkWidget *widget, void *data);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// osc_configure_handler
// file ghostess.c line 2575
signed int osc_configure_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv);
// osc_control_handler
// file ghostess.c line 2516
signed int osc_control_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv);
// osc_debug_handler
// file ghostess.c line 2734
signed int osc_debug_handler(const char *path, const char *types, union anonymous_7 **argv, signed int argc, void *data, void *user_data);
// osc_error
// file ghostess.c line 2424
void osc_error(signed int num, const char *msg, const char *path);
// osc_exiting_handler
// file ghostess.c line 2430
signed int osc_exiting_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv);
// osc_message_handler
// file ghostess.c line 2753
signed int osc_message_handler(const char *path, const char *types, union anonymous_7 **argv, signed int argc, void *data, void *user_data);
// osc_midi_handler
// file ghostess.c line 2447
signed int osc_midi_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv);
// osc_program_handler
// file ghostess.c line 2539
signed int osc_program_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv);
// osc_update_handler
// file ghostess.c line 2643
signed int osc_update_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv, void *source);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_19 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_19 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setschedparam
// file /usr/include/pthread.h line 431
extern signed int pthread_setschedparam(unsigned long int, signed int, struct sched_param *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_18 *, struct anonymous_18 *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// query_programs
// file ghostess.c line 1267
void query_programs(struct _d3h_instance_t *instance);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reset_instance_template
// file ghostess.c line 757
static void reset_instance_template(struct _instance_template_t *t);
// session_callback
// file ghostess.c line 657
void session_callback(struct _jack_session_event *event, void *arg);
// session_gui_idle_callback
// file ghostess.c line 627
signed int session_gui_idle_callback(void *arg);
// setControl
// file ghostess.c line 176
void setControl(struct _d3h_instance_t *instance, signed long int controlIn, struct snd_seq_event *event);
// set_initial_port_settings
// file ghostess.c line 817
void set_initial_port_settings(struct _d3h_instance_t *instance);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_18 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_18 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signalHandler
// file ghostess.c line 168
void signalHandler(signed int sig);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snd_midi_event_encode
// file /usr/include/alsa/seq_midi_event.h line 53
signed long int snd_midi_event_encode(struct snd_midi_event *, const unsigned char *, signed long int, struct snd_seq_event *);
// snd_midi_event_new
// file /usr/include/alsa/seq_midi_event.h line 45
signed int snd_midi_event_new(unsigned long int, struct snd_midi_event **);
// snd_midi_event_reset_encode
// file /usr/include/alsa/seq_midi_event.h line 49
void snd_midi_event_reset_encode(struct snd_midi_event *);
// snd_seq_client_id
// file /usr/include/alsa/seq.h line 87
signed int snd_seq_client_id(struct _snd_seq *);
// snd_seq_create_simple_port
// file /usr/include/alsa/seqmid.h line 328
signed int snd_seq_create_simple_port(struct _snd_seq *, const char *, unsigned int, unsigned int);
// snd_seq_event_input
// file /usr/include/alsa/seq.h line 522
signed int snd_seq_event_input(struct _snd_seq *, struct snd_seq_event **);
// snd_seq_event_input_pending
// file /usr/include/alsa/seq.h line 523
signed int snd_seq_event_input_pending(struct _snd_seq *, signed int);
// snd_seq_open
// file /usr/include/alsa/seq.h line 78
signed int snd_seq_open(struct _snd_seq **, const char *, signed int, signed int);
// snd_seq_poll_descriptors
// file /usr/include/alsa/seq.h line 84
signed int snd_seq_poll_descriptors(struct _snd_seq *, struct pollfd *, unsigned int, signed short int);
// snd_seq_poll_descriptors_count
// file /usr/include/alsa/seq.h line 83
signed int snd_seq_poll_descriptors_count(struct _snd_seq *, signed short int);
// snd_seq_set_client_name
// file /usr/include/alsa/seqmid.h line 344
signed int snd_seq_set_client_name(struct _snd_seq *, const char *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// start_ui
// file ghostess.c line 1079
void start_ui(struct _d3h_instance_t *instance);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// ui_osc_free
// file ghostess.c line 1055
void ui_osc_free(struct _d3h_instance_t *instance);
// update_eyecandy
// file gui_callbacks.h line 47
void update_eyecandy(struct _d3h_instance_t *instance);
// update_from_exiting
// file gui_callbacks.h line 46
void update_from_exiting(struct _d3h_instance_t *instance);
// update_ui_button_internal
// file gui_callbacks.c line 260
void update_ui_button_internal(struct _d3h_instance_t *instance, signed int value);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write_configuration
// file ghostess.c line 911
signed int write_configuration(char *filename, const char *uuid);
// write_patchlist
// file ghostess.c line 996
signed int write_patchlist(char *filename);

struct anonymous_22
{
  // toplevel_under_pointer
  struct _GdkDrawable *toplevel_under_pointer;
  // window_under_pointer
  struct _GdkDrawable *window_under_pointer;
  // toplevel_x
  double toplevel_x;
  // toplevel_y
  double toplevel_y;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // motion_hint_serial
  unsigned long int motion_hint_serial;
};

struct anonymous_21
{
  // window
  struct _GdkDrawable *window;
  // native_window
  struct _GdkDrawable *native_window;
  // serial
  unsigned long int serial;
  // owner_events
  signed int owner_events;
  // time
  unsigned int time;
};

struct anonymous
{
  // f
  void (*f)(void);
  // d
  void *d;
};

struct anonymous_18
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_6
{
  // sec
  unsigned int sec;
  // frac
  unsigned int frac;
};

union anonymous_41
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

union anonymous_7
{
  // i
  signed int i;
  // i32
  signed int i32;
  // h
  signed long int h;
  // i64
  signed long int i64;
  // f
  float f;
  // f32
  float f32;
  // d
  double d;
  // f64
  double f64;
  // s
  char s;
  // S
  char S;
  // c
  unsigned char c;
  // m
  unsigned char m[4l];
  // t
  struct anonymous_6 t;
};

union anonymous_27
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

struct snd_seq_real_time
{
  // tv_sec
  unsigned int tv_sec;
  // tv_nsec
  unsigned int tv_nsec;
};

union snd_seq_timestamp
{
  // tick
  unsigned int tick;
  // time
  struct snd_seq_real_time time;
};

struct snd_seq_queue_skew
{
  // value
  unsigned int value;
  // base
  unsigned int base;
};

union anonymous_10
{
  // value
  signed int value;
  // time
  union snd_seq_timestamp time;
  // position
  unsigned int position;
  // skew
  struct snd_seq_queue_skew skew;
  // d32
  unsigned int d32[2l];
  // d8
  unsigned char d8[8l];
};

union anonymous_39
{
  // char_data
  char char_data;
  // uchar_data
  unsigned char uchar_data;
  // bool_data
  signed int bool_data;
  // int_data
  signed int int_data;
  // uint_data
  unsigned int uint_data;
  // long_data
  signed long int long_data;
  // ulong_data
  unsigned long int ulong_data;
  // float_data
  float float_data;
  // double_data
  double double_data;
  // string_data
  char *string_data;
  // object_data
  struct _GtkObject *object_data;
  // pointer_data
  void *pointer_data;
  // signal_data
  struct anonymous signal_data;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_19
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _argc_state
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // next_arg
  signed int next_arg;
};

struct _file_state
{
  // filename
  char *filename;
  // fh
  struct _IO_FILE *fh;
  // next
  signed long int next;
};

union anonymous_2
{
  // argv
  struct _argc_state argv;
  // file
  struct _file_state file;
};

struct snd_seq_ev_note
{
  // channel
  unsigned char channel;
  // note
  unsigned char note;
  // velocity
  unsigned char velocity;
  // off_velocity
  unsigned char off_velocity;
  // duration
  unsigned int duration;
};

struct snd_seq_ev_ctrl
{
  // channel
  unsigned char channel;
  // unused
  unsigned char unused[3l];
  // param
  unsigned int param;
  // value
  signed int value;
};

struct snd_seq_ev_raw8
{
  // d
  unsigned char d[12l];
};

struct snd_seq_ev_raw32
{
  // d
  unsigned int d[3l];
};

struct snd_seq_ev_ext
{
  // len
  unsigned int len;
  // ptr
  void *ptr;
} __attribute__ ((__packed__));

struct snd_seq_ev_queue_control
{
  // queue
  unsigned char queue;
  // unused
  unsigned char unused[3l];
  // param
  union anonymous_10 param;
};

struct snd_seq_addr
{
  // client
  unsigned char client;
  // port
  unsigned char port;
};

struct snd_seq_connect
{
  // sender
  struct snd_seq_addr sender;
  // dest
  struct snd_seq_addr dest;
};

struct snd_seq_result
{
  // event
  signed int event;
  // result
  signed int result;
};

union anonymous_8
{
  // note
  struct snd_seq_ev_note note;
  // control
  struct snd_seq_ev_ctrl control;
  // raw8
  struct snd_seq_ev_raw8 raw8;
  // raw32
  struct snd_seq_ev_raw32 raw32;
  // ext
  struct snd_seq_ev_ext ext;
  // queue
  struct snd_seq_ev_queue_control queue;
  // time
  union snd_seq_timestamp time;
  // addr
  struct snd_seq_addr addr;
  // connect
  struct snd_seq_connect connect;
  // result
  struct snd_seq_result result;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _AtkObject
{
  // parent
  struct _GObject parent;
  // description
  char *description;
  // name
  char *name;
  // accessible_parent
  struct _AtkObject *accessible_parent;
  // role
  enum anonymous_0 role;
  // relation_set
  struct _AtkRelationSet *relation_set;
  // layer
  enum anonymous_1 layer;
};

struct _AtkRelationSet
{
  // parent
  struct _GObject parent;
  // relations
  struct _GPtrArray *relations;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct _Blinky
{
  // widget
  struct _GtkWidget widget;
  // state
  unsigned int state;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GObjectClass
{
  // g_type_class
  struct _GTypeClass g_type_class;
  // construct_properties
  struct _GSList *construct_properties;
  // constructor
  struct _GObject * (*constructor)(unsigned long int, unsigned int, struct _GObjectConstructParam *);
  // set_property
  void (*set_property)(struct _GObject *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_property
  void (*get_property)(struct _GObject *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // dispose
  void (*dispose)(struct _GObject *);
  // finalize
  void (*finalize)(struct _GObject *);
  // dispatch_properties_changed
  void (*dispatch_properties_changed)(struct _GObject *, unsigned int, struct _GParamSpec **);
  // notify
  void (*notify)(struct _GObject *, struct _GParamSpec *);
  // constructed
  void (*constructed)(struct _GObject *);
  // flags
  unsigned long int flags;
  // pdummy
  void *pdummy[6l];
};

struct _GtkObjectClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // set_arg
  void (*set_arg)(struct _GtkObject *, struct _GtkArg *, unsigned int);
  // get_arg
  void (*get_arg)(struct _GtkObject *, struct _GtkArg *, unsigned int);
  // destroy
  void (*destroy)(struct _GtkObject *);
};

struct _GtkWidgetClass
{
  // parent_class
  struct _GtkObjectClass parent_class;
  // activate_signal
  unsigned int activate_signal;
  // set_scroll_adjustments_signal
  unsigned int set_scroll_adjustments_signal;
  // dispatch_child_properties_changed
  void (*dispatch_child_properties_changed)(struct _GtkWidget *, unsigned int, struct _GParamSpec **);
  // show
  void (*show)(struct _GtkWidget *);
  // show_all
  void (*show_all)(struct _GtkWidget *);
  // hide
  void (*hide)(struct _GtkWidget *);
  // hide_all
  void (*hide_all)(struct _GtkWidget *);
  // map
  void (*map)(struct _GtkWidget *);
  // unmap
  void (*unmap)(struct _GtkWidget *);
  // realize
  void (*realize)(struct _GtkWidget *);
  // unrealize
  void (*unrealize)(struct _GtkWidget *);
  // size_request
  void (*size_request)(struct _GtkWidget *, struct _GtkRequisition *);
  // size_allocate
  void (*size_allocate)(struct _GtkWidget *, struct _GdkRectangle *);
  // state_changed
  void (*state_changed)(struct _GtkWidget *, enum anonymous_49);
  // parent_set
  void (*parent_set)(struct _GtkWidget *, struct _GtkWidget *);
  // hierarchy_changed
  void (*hierarchy_changed)(struct _GtkWidget *, struct _GtkWidget *);
  // style_set
  void (*style_set)(struct _GtkWidget *, struct _GtkStyle *);
  // direction_changed
  void (*direction_changed)(struct _GtkWidget *, enum anonymous_48);
  // grab_notify
  void (*grab_notify)(struct _GtkWidget *, signed int);
  // child_notify
  void (*child_notify)(struct _GtkWidget *, struct _GParamSpec *);
  // mnemonic_activate
  signed int (*mnemonic_activate)(struct _GtkWidget *, signed int);
  // grab_focus
  void (*grab_focus)(struct _GtkWidget *);
  // focus
  signed int (*focus)(struct _GtkWidget *, enum anonymous_47);
  // event
  signed int (*event)(struct _GtkWidget *, union _GdkEvent *);
  // button_press_event
  signed int (*button_press_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // button_release_event
  signed int (*button_release_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // scroll_event
  signed int (*scroll_event)(struct _GtkWidget *, struct _GdkEventScroll *);
  // motion_notify_event
  signed int (*motion_notify_event)(struct _GtkWidget *, struct _GdkEventMotion *);
  // delete_event
  signed int (*delete_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // destroy_event
  signed int (*destroy_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // expose_event
  signed int (*expose_event)(struct _GtkWidget *, struct _GdkEventExpose *);
  // key_press_event
  signed int (*key_press_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // key_release_event
  signed int (*key_release_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // enter_notify_event
  signed int (*enter_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // leave_notify_event
  signed int (*leave_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // configure_event
  signed int (*configure_event)(struct _GtkWidget *, struct _GdkEventConfigure *);
  // focus_in_event
  signed int (*focus_in_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // focus_out_event
  signed int (*focus_out_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // map_event
  signed int (*map_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // unmap_event
  signed int (*unmap_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // property_notify_event
  signed int (*property_notify_event)(struct _GtkWidget *, struct _GdkEventProperty *);
  // selection_clear_event
  signed int (*selection_clear_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_request_event
  signed int (*selection_request_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_notify_event
  signed int (*selection_notify_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // proximity_in_event
  signed int (*proximity_in_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // proximity_out_event
  signed int (*proximity_out_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // visibility_notify_event
  signed int (*visibility_notify_event)(struct _GtkWidget *, struct _GdkEventVisibility *);
  // client_event
  signed int (*client_event)(struct _GtkWidget *, struct _GdkEventClient *);
  // no_expose_event
  signed int (*no_expose_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // window_state_event
  signed int (*window_state_event)(struct _GtkWidget *, struct _GdkEventWindowState *);
  // selection_get
  void (*selection_get)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // selection_received
  void (*selection_received)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int);
  // drag_begin
  void (*drag_begin)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_end
  void (*drag_end)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_data_get
  void (*drag_data_get)(struct _GtkWidget *, struct _GdkDragContext *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // drag_data_delete
  void (*drag_data_delete)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_leave
  void (*drag_leave)(struct _GtkWidget *, struct _GdkDragContext *, unsigned int);
  // drag_motion
  signed int (*drag_motion)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_drop
  signed int (*drag_drop)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_data_received
  void (*drag_data_received)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, struct _GtkSelectionData *, unsigned int, unsigned int);
  // popup_menu
  signed int (*popup_menu)(struct _GtkWidget *);
  // show_help
  signed int (*show_help)(struct _GtkWidget *, enum anonymous_42);
  // get_accessible
  struct _AtkObject * (*get_accessible)(struct _GtkWidget *);
  // screen_changed
  void (*screen_changed)(struct _GtkWidget *, struct _GdkScreen *);
  // can_activate_accel
  signed int (*can_activate_accel)(struct _GtkWidget *, unsigned int);
  // grab_broken_event
  signed int (*grab_broken_event)(struct _GtkWidget *, struct _GdkEventGrabBroken *);
  // composited_changed
  void (*composited_changed)(struct _GtkWidget *);
  // query_tooltip
  signed int (*query_tooltip)(struct _GtkWidget *, signed int, signed int, signed int, struct _GtkTooltip *);
  // _gtk_reserved5
  void (*_gtk_reserved5)(void);
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
};

struct _BlinkyClass
{
  // parent_class
  struct _GtkWidgetClass parent_class;
};

struct _DSSI_Descriptor
{
  // DSSI_API_Version
  signed int DSSI_API_Version;
  // LADSPA_Plugin
  const struct _LADSPA_Descriptor *LADSPA_Plugin;
  // configure
  char * (*configure)(void *, const char *, const char *);
  // get_program
  const struct _DSSI_Program_Descriptor * (*get_program)(void *, unsigned long int);
  // select_program
  void (*select_program)(void *, unsigned long int, unsigned long int);
  // get_midi_controller_for_port
  signed int (*get_midi_controller_for_port)(void *, unsigned long int);
  // run_synth
  void (*run_synth)(void *, unsigned long int, struct snd_seq_event *, unsigned long int);
  // run_synth_adding
  void (*run_synth_adding)(void *, unsigned long int, struct snd_seq_event *, unsigned long int);
  // run_multiple_synths
  void (*run_multiple_synths)(unsigned long int, void **, unsigned long int, struct snd_seq_event **, unsigned long int *);
  // run_multiple_synths_adding
  void (*run_multiple_synths_adding)(unsigned long int, void **, unsigned long int, struct snd_seq_event **, unsigned long int *);
};

struct _DSSI_Program_Descriptor
{
  // Bank
  unsigned long int Bank;
  // Program
  unsigned long int Program;
  // Name
  const char *Name;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GObjectConstructParam
{
  // pspec
  struct _GParamSpec *pspec;
  // value
  struct _GValue *value;
};

struct _GParamSpec
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // name
  const char *name;
  // flags
  enum anonymous_28 flags;
  // value_type
  unsigned long int value_type;
  // owner_type
  unsigned long int owner_type;
  // _nick
  char *_nick;
  // _blurb
  char *_blurb;
  // qdata
  struct _GData *qdata;
  // ref_count
  unsigned int ref_count;
  // param_id
  unsigned int param_id;
};

struct _GPtrArray
{
  // pdata
  void **pdata;
  // len
  unsigned int len;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous_27 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkCursor
{
  // type
  enum anonymous_43 type;
  // ref_count
  unsigned int ref_count;
};

struct _GdkDevice
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // source
  enum anonymous_34 source;
  // mode
  enum anonymous_35 mode;
  // has_cursor
  signed int has_cursor;
  // num_axes
  signed int num_axes;
  // axes
  struct _GdkDeviceAxis *axes;
  // num_keys
  signed int num_keys;
  // keys
  struct _GdkDeviceKey *keys;
};

struct _GdkDeviceAxis
{
  // use
  enum anonymous_30 use;
  // min
  double min;
  // max
  double max;
};

struct _GdkDeviceKey
{
  // keyval
  unsigned int keyval;
  // modifiers
  enum anonymous_23 modifiers;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkDisplay
{
  // parent_instance
  struct _GObject parent_instance;
  // queued_events
  struct _GList *queued_events;
  // queued_tail
  struct _GList *queued_tail;
  // button_click_time
  unsigned int button_click_time[2l];
  // button_window
  struct _GdkDrawable *button_window[2l];
  // button_number
  signed int button_number[2l];
  // double_click_time
  unsigned int double_click_time;
  // core_pointer
  struct _GdkDevice *core_pointer;
  // pointer_hooks
  const struct _GdkDisplayPointerHooks *pointer_hooks;
  // closed
  unsigned int closed : 1;
  // ignore_core_events
  unsigned int ignore_core_events : 1;
  // double_click_distance
  unsigned int double_click_distance;
  // button_x
  signed int button_x[2l];
  // button_y
  signed int button_y[2l];
  // pointer_grabs
  struct _GList *pointer_grabs;
  // keyboard_grab
  struct anonymous_21 keyboard_grab;
  // pointer_info
  struct anonymous_22 pointer_info;
  // last_event_time
  unsigned int last_event_time;
};

struct _GdkDisplayPointerHooks
{
  // get_pointer
  void (*get_pointer)(struct _GdkDisplay *, struct _GdkScreen **, signed int *, signed int *, enum anonymous_23 *);
  // window_get_pointer
  struct _GdkDrawable * (*window_get_pointer)(struct _GdkDisplay *, struct _GdkDrawable *, signed int *, signed int *, enum anonymous_23 *);
  // window_at_pointer
  struct _GdkDrawable * (*window_at_pointer)(struct _GdkDisplay *, signed int *, signed int *);
};

struct _GdkDragContext
{
  // parent_instance
  struct _GObject parent_instance;
  // protocol
  enum anonymous_50 protocol;
  // is_source
  signed int is_source;
  // source_window
  struct _GdkDrawable *source_window;
  // dest_window
  struct _GdkDrawable *dest_window;
  // targets
  struct _GList *targets;
  // actions
  enum anonymous_51 actions;
  // suggested_action
  enum anonymous_51 suggested_action;
  // action
  enum anonymous_51 action;
  // start_time
  unsigned int start_time;
  // windowing_data
  void *windowing_data;
};

struct _GdkEventAny
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventExpose
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // area
  struct _GdkRectangle area;
  // region
  struct _GdkRegion *region;
  // count
  signed int count;
};

struct _GdkEventNoExpose
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous_31 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous_32 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventKey
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkDrawable *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous_36 mode;
  // detail
  enum anonymous_33 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  unsigned int requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // owner
  unsigned int owner;
  // reason
  enum anonymous_40 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventClient
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // message_type
  struct _GdkAtom *message_type;
  // data_format
  unsigned short int data_format;
  // data
  union anonymous_41 data;
};

struct _GdkEventDND
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous_37 changed_mask;
  // new_window_state
  enum anonymous_37 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous_38 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous_26 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkDrawable *grab_window;
};

union _GdkEvent
{
  // type
  enum anonymous_26 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // no_expose
  struct _GdkEventNoExpose no_expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // client
  struct _GdkEventClient client;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
};

struct _GdkFont
{
  // type
  enum anonymous_13 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkScreen
{
  // parent_instance
  struct _GObject parent_instance;
  // closed
  unsigned int closed : 1;
  // normal_gcs
  struct _GdkGC *normal_gcs[32l];
  // exposure_gcs
  struct _GdkGC *exposure_gcs[32l];
  // subwindow_gcs
  struct _GdkGC *subwindow_gcs[32l];
  // font_options
  struct _cairo_font_options *font_options;
  // resolution
  double resolution;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous_29 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous_12 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GdkWindowAttr
{
  // title
  char *title;
  // event_mask
  signed int event_mask;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // wclass
  enum anonymous_44 wclass;
  // visual
  struct _GdkVisual *visual;
  // colormap
  struct _GdkColormap *colormap;
  // window_type
  enum anonymous_45 window_type;
  // cursor
  struct _GdkCursor *cursor;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // override_redirect
  signed int override_redirect;
  // type_hint
  enum anonymous_46 type_hint;
};

struct _GtkAccelGroup
{
  // parent
  struct _GObject parent;
  // lock_count
  unsigned int lock_count;
  // modifier_mask
  enum anonymous_23 modifier_mask;
  // acceleratables
  struct _GSList *acceleratables;
  // n_accels
  unsigned int n_accels;
  // priv_accels
  struct _GtkAccelGroupEntry *priv_accels;
};

struct _GtkAccelKey
{
  // accel_key
  unsigned int accel_key;
  // accel_mods
  enum anonymous_23 accel_mods;
  // accel_flags
  unsigned int accel_flags : 16;
};

struct _GtkAccelGroupEntry
{
  // key
  struct _GtkAccelKey key;
  // closure
  struct _GClosure *closure;
  // accel_path_quark
  unsigned int accel_path_quark;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GtkObject parent_instance;
  // lower
  double lower;
  // upper
  double upper;
  // value
  double value;
  // step_increment
  double step_increment;
  // page_increment
  double page_increment;
  // page_size
  double page_size;
};

struct _GtkArg
{
  // type
  unsigned long int type;
  // name
  char *name;
  // d
  union anonymous_39 d;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // child
  struct _GtkWidget *child;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // spacing
  signed short int spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // event_window
  struct _GdkDrawable *event_window;
  // label_text
  char *label_text;
  // activate_timeout
  unsigned int activate_timeout;
  // constructed
  unsigned int constructed : 1;
  // in_button
  unsigned int in_button : 1;
  // button_down
  unsigned int button_down : 1;
  // relief
  unsigned int relief : 2;
  // use_underline
  unsigned int use_underline : 1;
  // use_stock
  unsigned int use_stock : 1;
  // depressed
  unsigned int depressed : 1;
  // depress_on_activate
  unsigned int depress_on_activate : 1;
  // focus_on_click
  unsigned int focus_on_click : 1;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // title
  char *title;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // wm_role
  char *wm_role;
  // focus_widget
  struct _GtkWidget *focus_widget;
  // default_widget
  struct _GtkWidget *default_widget;
  // transient_parent
  struct _GtkWindow *transient_parent;
  // geometry_info
  struct _GtkWindowGeometryInfo *geometry_info;
  // frame
  struct _GdkDrawable *frame;
  // group
  struct _GtkWindowGroup *group;
  // configure_request_count
  unsigned short int configure_request_count;
  // allow_shrink
  unsigned int allow_shrink : 1;
  // allow_grow
  unsigned int allow_grow : 1;
  // configure_notify_received
  unsigned int configure_notify_received : 1;
  // need_default_position
  unsigned int need_default_position : 1;
  // need_default_size
  unsigned int need_default_size : 1;
  // position
  unsigned int position : 3;
  // type
  unsigned int type : 4;
  // has_user_ref_count
  unsigned int has_user_ref_count : 1;
  // has_focus
  unsigned int has_focus : 1;
  // modal
  unsigned int modal : 1;
  // destroy_with_parent
  unsigned int destroy_with_parent : 1;
  // has_frame
  unsigned int has_frame : 1;
  // iconify_initially
  unsigned int iconify_initially : 1;
  // stick_initially
  unsigned int stick_initially : 1;
  // maximize_initially
  unsigned int maximize_initially : 1;
  // decorated
  unsigned int decorated : 1;
  // type_hint
  unsigned int type_hint : 3;
  // gravity
  unsigned int gravity : 5;
  // is_active
  unsigned int is_active : 1;
  // has_toplevel_focus
  unsigned int has_toplevel_focus : 1;
  // frame_left
  unsigned int frame_left;
  // frame_top
  unsigned int frame_top;
  // frame_right
  unsigned int frame_right;
  // frame_bottom
  unsigned int frame_bottom;
  // keys_changed_handler
  unsigned int keys_changed_handler;
  // mnemonic_modifier
  enum anonymous_23 mnemonic_modifier;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // vbox
  struct _GtkWidget *vbox;
  // action_area
  struct _GtkWidget *action_area;
  // separator
  struct _GtkWidget *separator;
};

struct _GtkFileSelection
{
  // parent_instance
  struct _GtkDialog parent_instance;
  // dir_list
  struct _GtkWidget *dir_list;
  // file_list
  struct _GtkWidget *file_list;
  // selection_entry
  struct _GtkWidget *selection_entry;
  // selection_text
  struct _GtkWidget *selection_text;
  // main_vbox
  struct _GtkWidget *main_vbox;
  // ok_button
  struct _GtkWidget *ok_button;
  // cancel_button
  struct _GtkWidget *cancel_button;
  // help_button
  struct _GtkWidget *help_button;
  // history_pulldown
  struct _GtkWidget *history_pulldown;
  // history_menu
  struct _GtkWidget *history_menu;
  // history_list
  struct _GList *history_list;
  // fileop_dialog
  struct _GtkWidget *fileop_dialog;
  // fileop_entry
  struct _GtkWidget *fileop_entry;
  // fileop_file
  char *fileop_file;
  // cmpl_state
  void *cmpl_state;
  // fileop_c_dir
  struct _GtkWidget *fileop_c_dir;
  // fileop_del_file
  struct _GtkWidget *fileop_del_file;
  // fileop_ren_file
  struct _GtkWidget *fileop_ren_file;
  // button_area
  struct _GtkWidget *button_area;
  // action_area
  struct _GtkWidget *action_area;
  // selected_names
  struct _GPtrArray *selected_names;
  // last_selected
  char *last_selected;
};

struct _GtkFrame
{
  // bin
  struct _GtkBin bin;
  // label_widget
  struct _GtkWidget *label_widget;
  // shadow_type
  signed short int shadow_type;
  // label_xalign
  float label_xalign;
  // label_yalign
  float label_yalign;
  // child_allocation
  struct _GdkRectangle child_allocation;
};

struct _GtkItem
{
  // bin
  struct _GtkBin bin;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // label
  char *label;
  // jtype
  unsigned int jtype : 2;
  // wrap
  unsigned int wrap : 1;
  // use_underline
  unsigned int use_underline : 1;
  // use_markup
  unsigned int use_markup : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // single_line_mode
  unsigned int single_line_mode : 1;
  // have_transform
  unsigned int have_transform : 1;
  // in_click
  unsigned int in_click : 1;
  // wrap_mode
  unsigned int wrap_mode : 3;
  // pattern_set
  unsigned int pattern_set : 1;
  // track_links
  unsigned int track_links : 1;
  // mnemonic_keyval
  unsigned int mnemonic_keyval;
  // text
  char *text;
  // attrs
  struct _PangoAttrList *attrs;
  // effective_attrs
  struct _PangoAttrList *effective_attrs;
  // layout
  struct _PangoLayout *layout;
  // mnemonic_widget
  struct _GtkWidget *mnemonic_widget;
  // mnemonic_window
  struct _GtkWindow *mnemonic_window;
  // select_info
  struct _GtkLabelSelectionInfo *select_info;
};

struct _GtkMenuShell
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // active_menu_item
  struct _GtkWidget *active_menu_item;
  // parent_menu_shell
  struct _GtkWidget *parent_menu_shell;
  // button
  unsigned int button;
  // activate_time
  unsigned int activate_time;
  // active
  unsigned int active : 1;
  // have_grab
  unsigned int have_grab : 1;
  // have_xgrab
  unsigned int have_xgrab : 1;
  // ignore_leave
  unsigned int ignore_leave : 1;
  // menu_flag
  unsigned int menu_flag : 1;
  // ignore_enter
  unsigned int ignore_enter : 1;
  // keyboard_mode
  unsigned int keyboard_mode : 1;
};

struct _GtkMenu
{
  // menu_shell
  struct _GtkMenuShell menu_shell;
  // parent_menu_item
  struct _GtkWidget *parent_menu_item;
  // old_active_menu_item
  struct _GtkWidget *old_active_menu_item;
  // accel_group
  struct _GtkAccelGroup *accel_group;
  // accel_path
  char *accel_path;
  // position_func
  void (*position_func)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *);
  // position_func_data
  void *position_func_data;
  // toggle_size
  unsigned int toggle_size;
  // toplevel
  struct _GtkWidget *toplevel;
  // tearoff_window
  struct _GtkWidget *tearoff_window;
  // tearoff_hbox
  struct _GtkWidget *tearoff_hbox;
  // tearoff_scrollbar
  struct _GtkWidget *tearoff_scrollbar;
  // tearoff_adjustment
  struct _GtkAdjustment *tearoff_adjustment;
  // view_window
  struct _GdkDrawable *view_window;
  // bin_window
  struct _GdkDrawable *bin_window;
  // scroll_offset
  signed int scroll_offset;
  // saved_scroll_offset
  signed int saved_scroll_offset;
  // scroll_step
  signed int scroll_step;
  // timeout_id
  unsigned int timeout_id;
  // navigation_region
  struct _GdkRegion *navigation_region;
  // navigation_timeout
  unsigned int navigation_timeout;
  // needs_destruction_ref_count
  unsigned int needs_destruction_ref_count : 1;
  // torn_off
  unsigned int torn_off : 1;
  // tearoff_active
  unsigned int tearoff_active : 1;
  // scroll_fast
  unsigned int scroll_fast : 1;
  // upper_arrow_visible
  unsigned int upper_arrow_visible : 1;
  // lower_arrow_visible
  unsigned int lower_arrow_visible : 1;
  // upper_arrow_prelight
  unsigned int upper_arrow_prelight : 1;
  // lower_arrow_prelight
  unsigned int lower_arrow_prelight : 1;
};

struct _GtkMenuItem
{
  // item
  struct _GtkItem item;
  // submenu
  struct _GtkWidget *submenu;
  // event_window
  struct _GdkDrawable *event_window;
  // toggle_size
  unsigned short int toggle_size;
  // accelerator_width
  unsigned short int accelerator_width;
  // accel_path
  char *accel_path;
  // show_submenu_indicator
  unsigned int show_submenu_indicator : 1;
  // submenu_placement
  unsigned int submenu_placement : 1;
  // submenu_direction
  unsigned int submenu_direction : 1;
  // right_justify
  unsigned int right_justify : 1;
  // timer_from_keypress
  unsigned int timer_from_keypress : 1;
  // from_menubar
  unsigned int from_menubar : 1;
  // timer
  unsigned int timer;
};

struct _GtkRange
{
  // widget
  struct _GtkWidget widget;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // update_policy
  enum anonymous_3 update_policy;
  // inverted
  unsigned int inverted : 1;
  // flippable
  unsigned int flippable : 1;
  // has_stepper_a
  unsigned int has_stepper_a : 1;
  // has_stepper_b
  unsigned int has_stepper_b : 1;
  // has_stepper_c
  unsigned int has_stepper_c : 1;
  // has_stepper_d
  unsigned int has_stepper_d : 1;
  // need_recalc
  unsigned int need_recalc : 1;
  // slider_size_fixed
  unsigned int slider_size_fixed : 1;
  // min_slider_size
  signed int min_slider_size;
  // orientation
  enum anonymous_4 orientation;
  // range_rect
  struct _GdkRectangle range_rect;
  // slider_start
  signed int slider_start;
  // slider_end
  signed int slider_end;
  // round_digits
  signed int round_digits;
  // trough_click_forward
  unsigned int trough_click_forward : 1;
  // update_pending
  unsigned int update_pending : 1;
  // layout
  struct _GtkRangeLayout *layout;
  // timer
  struct _GtkRangeStepTimer *timer;
  // slide_initial_slider_position
  signed int slide_initial_slider_position;
  // slide_initial_coordinate
  signed int slide_initial_coordinate;
  // update_timeout_id
  unsigned int update_timeout_id;
  // event_window
  struct _GdkDrawable *event_window;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous_14 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // hscrollbar
  struct _GtkWidget *hscrollbar;
  // vscrollbar
  struct _GtkWidget *vscrollbar;
  // hscrollbar_policy
  unsigned int hscrollbar_policy : 2;
  // vscrollbar_policy
  unsigned int vscrollbar_policy : 2;
  // hscrollbar_visible
  unsigned int hscrollbar_visible : 1;
  // vscrollbar_visible
  unsigned int vscrollbar_visible : 1;
  // window_placement
  unsigned int window_placement : 2;
  // focus_out
  unsigned int focus_out : 1;
  // shadow_type
  unsigned short int shadow_type;
};

struct _GtkSelectionData
{
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // type
  struct _GdkAtom *type;
  // format
  signed int format;
  // data
  unsigned char *data;
  // length
  signed int length;
  // display
  struct _GdkDisplay *display;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkToggleButton
{
  // button
  struct _GtkButton button;
  // active
  unsigned int active : 1;
  // draw_indicator
  unsigned int draw_indicator : 1;
  // inconsistent
  unsigned int inconsistent : 1;
};

struct _GtkWindowGroup
{
  // parent_instance
  struct _GObject parent_instance;
  // grabs
  struct _GSList *grabs;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _LADSPA_Descriptor
{
  // UniqueID
  unsigned long int UniqueID;
  // Label
  const char *Label;
  // Properties
  signed int Properties;
  // Name
  const char *Name;
  // Maker
  const char *Maker;
  // Copyright
  const char *Copyright;
  // PortCount
  unsigned long int PortCount;
  // PortDescriptors
  const signed int *PortDescriptors;
  // PortNames
  const char * const *PortNames;
  // PortRangeHints
  const struct _LADSPA_PortRangeHint *PortRangeHints;
  // ImplementationData
  void *ImplementationData;
  // instantiate
  void * (*instantiate)(struct _LADSPA_Descriptor *, unsigned long int);
  // connect_port
  void (*connect_port)(void *, unsigned long int, float *);
  // activate
  void (*activate)(void *);
  // run
  void (*run)(void *, unsigned long int);
  // run_adding
  void (*run_adding)(void *, unsigned long int);
  // set_run_adding_gain
  void (*set_run_adding_gain)(void *, float);
  // deactivate
  void (*deactivate)(void *);
  // cleanup
  void (*cleanup)(void *);
};

struct _LADSPA_PortRangeHint
{
  // HintDescriptor
  signed int HintDescriptor;
  // LowerBound
  float LowerBound;
  // UpperBound
  float UpperBound;
};

struct _configure_item_t
{
  // next
  struct _configure_item_t *next;
  // key
  char *key;
  // value
  char *value;
};

struct _d3h_dll_t
{
  // next
  struct _d3h_dll_t *next;
  // name
  char *name;
  // directory
  char *directory;
  // is_DSSI_dll
  signed int is_DSSI_dll;
  // descfn
  const struct _DSSI_Descriptor * (*descfn)(unsigned long int);
};

struct _d3h_instance_t
{
  // number
  signed int number;
  // plugin
  struct _d3h_plugin_t *plugin;
  // id
  signed int id;
  // channel
  signed int channel;
  // channel_next_instance
  struct _d3h_instance_t *channel_next_instance;
  // friendly_name
  char *friendly_name;
  // configure_items
  struct _configure_item_t *configure_items;
  // pluginProgramsValid
  signed int pluginProgramsValid;
  // pluginProgramsAlloc
  signed int pluginProgramsAlloc;
  // pluginProgramCount
  signed int pluginProgramCount;
  // pluginPrograms
  struct _DSSI_Program_Descriptor *pluginPrograms;
  // currentBank
  signed long int currentBank;
  // currentProgram
  signed long int currentProgram;
  // pendingBankLSB
  signed int pendingBankLSB;
  // pendingBankMSB
  signed int pendingBankMSB;
  // pendingProgramChange
  signed int pendingProgramChange;
  // firstControlIn
  signed int firstControlIn;
  // pluginPortControlInNumbers
  signed int *pluginPortControlInNumbers;
  // controllerMap
  signed long int controllerMap[128l];
  // have_initial_values
  signed int have_initial_values;
  // initial_value_set
  signed int *initial_value_set;
  // initial_value
  float *initial_value;
  // strip
  struct _plugin_strip *strip;
  // midi_activity_tick
  signed int midi_activity_tick;
  // ui_running
  signed int ui_running;
  // ui_visible
  signed int ui_visible;
  // ui_initial_show_sent
  signed int ui_initial_show_sent;
  // uiNeedsProgramUpdate
  signed int uiNeedsProgramUpdate;
  // ui_osc_address
  void *ui_osc_address;
  // ui_osc_source
  void *ui_osc_source;
  // ui_osc_control_path
  char *ui_osc_control_path;
  // ui_osc_configure_path
  char *ui_osc_configure_path;
  // ui_osc_hide_path
  char *ui_osc_hide_path;
  // ui_osc_program_path
  char *ui_osc_program_path;
  // ui_osc_quit_path
  char *ui_osc_quit_path;
  // ui_osc_rate_path
  char *ui_osc_rate_path;
  // ui_osc_show_path
  char *ui_osc_show_path;
};

struct _d3h_plugin_t
{
  // next
  struct _d3h_plugin_t *next;
  // number
  signed int number;
  // dll
  struct _d3h_dll_t *dll;
  // label
  char *label;
  // is_first_in_dll
  signed int is_first_in_dll;
  // descriptor
  const struct _DSSI_Descriptor *descriptor;
  // ins
  signed int ins;
  // outs
  signed int outs;
  // controlIns
  signed int controlIns;
  // controlOuts
  signed int controlOuts;
  // instances
  signed int instances;
};

struct _getarg_state
{
  // up
  struct _getarg_state *up;
  // is_file
  signed int is_file;
  // state
  union anonymous_2 state;
};

struct _initial_port_set_t
{
  // allocated
  unsigned long int allocated;
  // have_settings
  signed int have_settings;
  // highest_set
  unsigned long int highest_set;
  // set
  signed int *set;
  // value
  float *value;
};

struct _instance_template_t
{
  // channel
  signed int channel;
  // configure_items
  struct _configure_item_t *configure_items;
  // program_set
  signed int program_set;
  // bank
  unsigned long int bank;
  // program
  unsigned long int program;
  // ports
  struct _initial_port_set_t ports;
};

struct _jack_session_event
{
  // type
  enum JackSessionEventType type;
  // session_dir
  const char *session_dir;
  // client_uuid
  const char *client_uuid;
  // command_line
  char *command_line;
  // flags
  enum JackSessionFlags flags;
  // future
  unsigned int future;
};

struct _plugin_strip
{
  // instance
  struct _d3h_instance_t *instance;
  // container
  struct _GtkWidget *container;
  // midi_status
  struct _GtkWidget *midi_status;
  // previous_midi_state
  signed int previous_midi_state;
  // ui_button
  struct _GtkWidget *ui_button;
  // pan_adjustment
  struct _GtkObject *pan_adjustment;
  // level_adjustment
  struct _GtkObject *level_adjustment;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sched_param
{
  // __sched_priority
  signed int __sched_priority;
};

struct snd_seq_event
{
  // type
  unsigned char type;
  // flags
  unsigned char flags;
  // tag
  unsigned char tag;
  // queue
  unsigned char queue;
  // time
  union snd_seq_timestamp time;
  // source
  struct snd_seq_addr source;
  // dest
  struct snd_seq_addr dest;
  // data
  union anonymous_8 data;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};


// Blinky_private_offset
// file eyecandy.c line 49
static signed int Blinky_private_offset;
// _signals
// file ghostess.c line 118
static struct anonymous_18 _signals;
// about_label
// file gui_interface.c line 52
struct _GtkWidget *about_label;
// about_window
// file gui_interface.c line 51
struct _GtkWidget *about_window;
// alsaClient
// file midi-alsa.c line 42
static struct _snd_seq *alsaClient;
// alsaClient_npfd
// file midi-alsa.c line 43
static signed int alsaClient_npfd;
// alsaClient_pfd
// file midi-alsa.c line 44
struct pollfd *alsaClient_pfd;
// alsa_client_id
// file midi-alsa.c line 46
signed int alsa_client_id;
// alsa_port_id
// file midi-alsa.c line 47
signed int alsa_port_id;
// argbuf
// file getarg.c line 40
static char *argbuf = (char *)(void *)0;
// autoconnect
// file ghostess.c line 128
signed int autoconnect = 1;
// blinky_parent_class
// file eyecandy.c line 49
static void *blinky_parent_class = (void *)0;
// blinky_style
// file eyecandy.c line 47
static struct _GtkStyle *blinky_style = (struct _GtkStyle *)(void *)0;
// channel2instances
// file ghostess.c line 109
static struct _d3h_instance_t *channel2instances[16l];
// col_darkgreen
// file eyecandy.c line 46
static struct _GdkColor col_darkgreen;
// col_green
// file eyecandy.c line 46
static struct _GdkColor col_green;
// controlInsTotal
// file ghostess.c line 107
static signed int controlInsTotal;
// controlOutsTotal
// file ghostess.c line 107
static signed int controlOutsTotal;
// debug_flags
// file ghostess.c line 127
signed int debug_flags = 1;
// dlls
// file ghostess.c line 92
static struct _d3h_dll_t *dlls;
// dssi_path
// file ghostess.c line 130
char *dssi_path = (char *)(void *)0;
// file_selection
// file gui_interface.c line 49
struct _GtkWidget *file_selection;
// file_selection_handler
// file gui_callbacks.c line 45
static void (*file_selection_handler)(struct _GtkWidget *, void *);
// getarg_error
// file getarg.c line 37
char *getarg_error = (char *)(void *)0;
// host_argv0
// file ghostess.c line 125
char *host_argv0;
// host_exiting
// file ghostess.c line 120
signed int host_exiting = 0;
// host_name
// file ghostess.c line 123
char *host_name;
// host_name_default
// file ghostess.c line 122
char *host_name_default = "ghostess";
// host_osc_url
// file ghostess.c line 124
char *host_osc_url = (char *)(void *)0;
// inputPorts
// file ghostess.c line 84
static struct _jack_port **inputPorts;
// insTotal
// file ghostess.c line 104
static signed int insTotal;
// instanceEventBuffers
// file ghostess.c line 101
static struct snd_seq_event **instanceEventBuffers;
// instanceEventCounts
// file ghostess.c line 102
static unsigned long int *instanceEventCounts;
// instanceHandles
// file ghostess.c line 100
static void **instanceHandles;
// instance_count
// file ghostess.c line 98
static signed int instance_count = 0;
// instances
// file ghostess.c line 97
static struct _d3h_instance_t instances[32l];
// jackClient
// file ghostess.c line 83
struct _jack_client *jackClient;
// jack_session_uuid
// file ghostess.c line 89
char *jack_session_uuid = (char *)(void *)0;
// last_patchlist_filename
// file gui_callbacks.c line 48
static char *last_patchlist_filename = (char *)(void *)0;
// last_save_filename
// file gui_callbacks.c line 47
static char *last_save_filename = (char *)(void *)0;
// main_timeout_tick
// file ghostess.c line 133
signed int main_timeout_tick = 0;
// main_window
// file gui_interface.c line 40
struct _GtkWidget *main_window;
// midiEventBuffer
// file ghostess.c line 135
struct snd_seq_event midiEventBuffer[1024l];
// midiEventBufferMutex
// file ghostess.c line 141
union anonymous_19 midiEventBufferMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// midiEventReadIndex
// file ghostess.c line 136
signed int midiEventReadIndex = 0;
// midiEventWriteIndex
// file ghostess.c line 136
signed int midiEventWriteIndex = 0;
// midi_thread
// file ghostess.c line 139
static unsigned long int midi_thread;
// midi_thread_running
// file ghostess.c line 140
signed int midi_thread_running = 0;
// notice_label_1
// file gui_interface.c line 55
struct _GtkWidget *notice_label_1;
// notice_label_2
// file gui_interface.c line 56
struct _GtkWidget *notice_label_2;
// notice_window
// file gui_interface.c line 54
struct _GtkWidget *notice_window;
// outputPorts
// file ghostess.c line 84
static struct _jack_port **outputPorts;
// outsTotal
// file ghostess.c line 104
static signed int outsTotal;
// pluginAudioInInstances
// file ghostess.c line 110
static struct _d3h_instance_t **pluginAudioInInstances;
// pluginAudioInPortNumbers
// file ghostess.c line 111
static unsigned long int *pluginAudioInPortNumbers;
// pluginControlInInstances
// file ghostess.c line 112
static struct _d3h_instance_t **pluginControlInInstances;
// pluginControlInPortNumbers
// file ghostess.c line 113
static unsigned long int *pluginControlInPortNumbers;
// pluginControlIns
// file ghostess.c line 108
static float *pluginControlIns;
// pluginControlOuts
// file ghostess.c line 108
static float *pluginControlOuts;
// pluginInputBuffers
// file ghostess.c line 105
static float **pluginInputBuffers;
// pluginOutputBuffers
// file ghostess.c line 105
static float **pluginOutputBuffers;
// pluginPortUpdated
// file ghostess.c line 114
static signed int *pluginPortUpdated;
// plugin_count
// file ghostess.c line 95
static signed int plugin_count = 0;
// plugin_hbox
// file gui_interface.c line 41
struct _GtkWidget *plugin_hbox;
// plugins
// file ghostess.c line 94
static struct _d3h_plugin_t *plugins;
// project_directory
// file ghostess.c line 131
char *project_directory = (char *)(void *)0;
// sample_rate
// file ghostess.c line 90
static float sample_rate;
// serverThread
// file ghostess.c line 116
void *serverThread;
// snd_seq_event_types
// file /usr/include/alsa/seq.h line 634
extern const unsigned int snd_seq_event_types[];
// state_list
// file getarg.c line 39
static struct _getarg_state *state_list = (struct _getarg_state *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// ui_context_menu
// file gui_interface.c line 43
struct _GtkWidget *ui_context_menu;
// ui_context_menu_exit
// file gui_interface.c line 47
struct _GtkWidget *ui_context_menu_exit;
// ui_context_menu_hide
// file gui_interface.c line 46
struct _GtkWidget *ui_context_menu_hide;
// ui_context_menu_instance
// file gui_callbacks.c line 50
static struct _d3h_instance_t *ui_context_menu_instance;
// ui_context_menu_launch
// file gui_interface.c line 44
struct _GtkWidget *ui_context_menu_launch;
// ui_context_menu_show
// file gui_interface.c line 45
struct _GtkWidget *ui_context_menu_show;

// add_configure_item
// file ghostess.c line 832
void add_configure_item(struct _configure_item_t **head, char *key, char *value)
{
  struct _configure_item_t *item = *head;
  signed int tmp_statement_expression_1;
  for( ; !(item == ((struct _configure_item_t *)NULL)); item = item->next)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(key, item->key);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
      break;

  }
  if(!(item == ((struct _configure_item_t *)NULL)))
    free((void *)item->value);

  else
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct _configure_item_t) /*24ul*/ );
    item = (struct _configure_item_t *)return_value_malloc_3;
    item->next = *head;
    *head = item;
    char *return_value___strdup_4;
    return_value___strdup_4=__strdup(key);
    item->key = return_value___strdup_4;
  }
  char *return_value___strdup_5;
  return_value___strdup_5=__strdup(value);
  item->value = return_value___strdup_5;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// audio_callback
// file ghostess.c line 232
signed int audio_callback(unsigned int nframes, void *arg)
{
  signed int i;
  unsigned int last_frame_time;
  last_frame_time=jack_last_frame_time(jackClient);
  unsigned int last_tick_offset = (unsigned int)0;
  signed int have_full_midi_buffer = 0;
  struct _d3h_instance_t *instance;
  i = 0;
  for( ; !(i >= instance_count); i = i + 1)
    instanceEventCounts[(signed long int)i] = (unsigned long int)0;
  for( ; !(midiEventReadIndex == midiEventWriteIndex); midiEventReadIndex = (midiEventReadIndex + 1) % 1024)
  {
    struct snd_seq_event *ev = &midiEventBuffer[(signed long int)midiEventReadIndex];
    unsigned int previous_frame_time;
    if(!((6u & snd_seq_event_types[(signed long int)ev->type]) == 0u))
    {
      if((signed int)ev->dest.client == 0)
      {
        if(!(channel2instances[(signed long int)ev->data.note.channel] == ((struct _d3h_instance_t *)NULL)))
          goto __CPROVER_DUMP_L4;

      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        previous_frame_time = last_frame_time - nframes;
        if(!(ev->time.tick >= previous_frame_time))
          ev->time.tick = (unsigned int)0;

        else
        {
          ev->time.tick = ev->time.tick - previous_frame_time;
          if(!(nframes + 4294967295u >= ev->time.tick))
          {
            if(!(ev->time.tick >= 2u * nframes))
            {
              ev->time.tick = ev->time.tick + previous_frame_time;
              break;
            }

            else
              ev->time.tick = nframes - (unsigned int)1;
          }

        }
        if(!(ev->time.tick >= last_tick_offset))
          ev->time.tick = last_tick_offset;

        else
          last_tick_offset = ev->time.tick;
        if(!(ev->dest.client == 0))
          instance = &instances[(signed long int)ev->dest.port];

        else
          instance = channel2instances[(signed long int)ev->data.note.channel];
        while(!(instance == ((struct _d3h_instance_t *)NULL)))
        {
          i = instance->number;
          if((signed int)ev->type == 10)
          {
            signed int controller = (signed int)ev->data.control.param;
            ghss_debug(16, ": %s MIDI CC %d(0x%02x) = %d", instance->friendly_name, controller, controller, ev->data.control.value);
            if(controller == 0)
              instance->pendingBankMSB = ev->data.control.value;

            else
              if(controller == 32)
                instance->pendingBankLSB = ev->data.control.value;

              else
                if(controller >= 1 && !(controller >= 128))
                {
                  signed long int controlIn = instance->controllerMap[(signed long int)controller];
                  if(controlIn >= 0l)
                    setControl(instance, controlIn, ev);

                  else
                  {
                    instanceEventBuffers[(signed long int)i][(signed long int)instanceEventCounts[(signed long int)i]] = *ev;
                    instanceEventCounts[(signed long int)i] = instanceEventCounts[(signed long int)i] + 1ul;
                  }
                }

          }

          else
            if((signed int)ev->type == 11)
            {
              instance->pendingProgramChange = ev->data.control.value;
              instance->uiNeedsProgramUpdate = 1;
            }

            else
            {
              instanceEventBuffers[(signed long int)i][(signed long int)instanceEventCounts[(signed long int)i]] = *ev;
              instanceEventCounts[(signed long int)i] = instanceEventCounts[(signed long int)i] + 1ul;
            }
          if(instanceEventCounts[(signed long int)i] == 1024ul)
            have_full_midi_buffer = 1;

          instance->midi_activity_tick = main_timeout_tick;
          if(ev->dest.client == 0)
            instance = instance->channel_next_instance;

          else
            break;
        }
        if(!(have_full_midi_buffer == 0))
          break;

      }
    }

  }
  i = 0;
  for( ; !(i >= instance_count); i = i + 1)
  {
    instance = &instances[(signed long int)i];
    if(instance->pendingProgramChange >= 0)
    {
      signed int pc = instance->pendingProgramChange;
      signed int msb = instance->pendingBankMSB;
      signed int lsb = instance->pendingBankLSB;
      if(lsb >= 0)
      {
        if(msb >= 0)
          instance->currentBank = (signed long int)(lsb + 128 * msb);

        else
          instance->currentBank = (signed long int)lsb + (signed long int)128 * (instance->currentBank / (signed long int)128);
      }

      else
        if(msb >= 0)
          instance->currentBank = instance->currentBank % (signed long int)128 + (signed long int)(128 * msb);

      instance->currentProgram = (signed long int)pc;
      instance->pendingProgramChange = -1;
      instance->pendingBankMSB = -1;
      instance->pendingBankLSB = -1;
      if(!(instance->plugin->descriptor->select_program == ((void (*)(void *, unsigned long int, unsigned long int))NULL)))
        instance->plugin->descriptor->select_program(instanceHandles[(signed long int)instance->number], (unsigned long int)instance->currentBank, (unsigned long int)instance->currentProgram);

    }

  }
  i = 0;
  for( ; !(i >= insTotal); i = i + 1)
  {
    float *buffer;
    void *return_value_jack_port_get_buffer_1;
    return_value_jack_port_get_buffer_1=jack_port_get_buffer(inputPorts[(signed long int)i], nframes);
    buffer = (float *)return_value_jack_port_get_buffer_1;
    if(!(buffer == pluginInputBuffers[(signed long int)i]))
    {
      pluginInputBuffers[(signed long int)i] = buffer;
      instance = pluginAudioInInstances[(signed long int)i];
      instance->plugin->descriptor->LADSPA_Plugin->connect_port(instanceHandles[(signed long int)instance->number], pluginAudioInPortNumbers[(signed long int)i], buffer);
    }

  }
  i = 0;
  while(!(i >= instance_count))
  {
    instance = &instances[(signed long int)i];
    if(!(instance->plugin->descriptor->run_multiple_synths == ((void (*)(unsigned long int, void **, unsigned long int, struct snd_seq_event **, unsigned long int *))NULL)))
    {
      instance->plugin->descriptor->run_multiple_synths((unsigned long int)instance->plugin->instances, instanceHandles + (signed long int)i, (unsigned long int)nframes, instanceEventBuffers + (signed long int)i, instanceEventCounts + (signed long int)i);
      i = i + instance->plugin->instances;
    }

    else
      if(!(instance->plugin->descriptor->run_synth == ((void (*)(void *, unsigned long int, struct snd_seq_event *, unsigned long int))NULL)))
      {
        instance->plugin->descriptor->run_synth(instanceHandles[(signed long int)i], (unsigned long int)nframes, instanceEventBuffers[(signed long int)i], instanceEventCounts[(signed long int)i]);
        i = i + 1;
      }

      else
        if(!(instance->plugin->descriptor->LADSPA_Plugin->run == ((void (*)(void *, unsigned long int))NULL)))
        {
          instance->plugin->descriptor->LADSPA_Plugin->run(instanceHandles[(signed long int)i], (unsigned long int)nframes);
          i = i + 1;
        }

  }
  i = 0;
  for( ; !(i >= outsTotal); i = i + 1)
  {
    float *audio_callback__1__6__1__buffer;
    void *return_value_jack_port_get_buffer_2;
    return_value_jack_port_get_buffer_2=jack_port_get_buffer(outputPorts[(signed long int)i], nframes);
    audio_callback__1__6__1__buffer = (float *)return_value_jack_port_get_buffer_2;
    memcpy((void *)audio_callback__1__6__1__buffer, (const void *)pluginOutputBuffers[(signed long int)i], (unsigned long int)nframes * sizeof(float) /*4ul*/ );
  }
  return 0;
}

// blinky_class_init
// file eyecandy.c line 52
static void blinky_class_init(struct _BlinkyClass *class)
{
  struct _GtkObjectClass *object_class;
  struct _GtkWidgetClass *widget_class;
  object_class = (struct _GtkObjectClass *)class;
  widget_class = (struct _GtkWidgetClass *)class;
  unsigned long int return_value_gtk_widget_get_type_1;
  return_value_gtk_widget_get_type_1=gtk_widget_get_type();
  blinky_parent_class=gtk_type_class(return_value_gtk_widget_get_type_1);
  object_class->destroy = blinky_destroy;
  widget_class->realize = blinky_realize;
  widget_class->expose_event = blinky_expose;
  widget_class->size_request = blinky_size_request;
  widget_class->size_allocate = blinky_size_allocate;
  col_green.red = (unsigned short int)0;
  col_green.green = (unsigned short int)0xFFFF;
  col_green.blue = (unsigned short int)0;
  struct _GdkColormap *return_value_gdk_colormap_get_system_2;
  return_value_gdk_colormap_get_system_2=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system_2, &col_green);
  col_darkgreen.red = (unsigned short int)0;
  col_darkgreen.green = (unsigned short int)0x5555;
  col_darkgreen.blue = (unsigned short int)0;
  struct _GdkColormap *return_value_gdk_colormap_get_system_3;
  return_value_gdk_colormap_get_system_3=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system_3, &col_darkgreen);
}

// blinky_class_intern_init
// file eyecandy.c line 49
static void blinky_class_intern_init(void *klass)
{
  blinky_parent_class=g_type_class_peek_parent(klass);
  if(!(Blinky_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &Blinky_private_offset);

  blinky_class_init((struct _BlinkyClass *)klass);
}

// blinky_destroy
// file eyecandy.c line 98
static void blinky_destroy(struct _GtkObject *object)
{
  struct _Blinky *blinky;
  signed int tmp_statement_expression_1;
  do
  {
    signed int _g_boolean_var_;
    if(!(object == ((struct _GtkObject *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression_1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression_1 == 0l)
    {

      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression_2;
  signed int tmp_statement_expression_3;
  _Bool tmp_if_expr_4;
  do
  {
    signed int blinky_destroy__1__2__1___g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)object;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_3 = __r;
    if(!(tmp_statement_expression_3 == 0))
      blinky_destroy__1__2__1___g_boolean_var_ = 1;

    else
      blinky_destroy__1__2__1___g_boolean_var_ = 0;
    tmp_statement_expression_2 = blinky_destroy__1__2__1___g_boolean_var_;
    if((signed long int)tmp_statement_expression_2 == 0l)
    {

      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_blinky_get_type_5;
  return_value_blinky_get_type_5=blinky_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_blinky_get_type_5);
  blinky = (struct _Blinky *)return_value_g_type_check_instance_cast_6;
  unsigned long int return_value_gtk_object_get_type_9;
  return_value_gtk_object_get_type_9=gtk_object_get_type();
  struct _GTypeClass *return_value_g_type_check_class_cast_10;
  return_value_g_type_check_class_cast_10=g_type_check_class_cast((struct _GTypeClass *)blinky_parent_class, return_value_gtk_object_get_type_9);
  unsigned long int return_value_gtk_object_get_type_7;
  struct _GTypeClass *return_value_g_type_check_class_cast_8;
  if(!(((struct _GtkObjectClass *)return_value_g_type_check_class_cast_10)->destroy == ((void (*)(struct _GtkObject *))NULL)))
  {
    return_value_gtk_object_get_type_7=gtk_object_get_type();
    return_value_g_type_check_class_cast_8=g_type_check_class_cast((struct _GTypeClass *)blinky_parent_class, return_value_gtk_object_get_type_7);
    ((struct _GtkObjectClass *)return_value_g_type_check_class_cast_8)->destroy(object);
  }


__CPROVER_DUMP_L15:
  ;
}

// blinky_expose
// file eyecandy.c line 194
static signed int blinky_expose(struct _GtkWidget *widget, struct _GdkEventExpose *event)
{
  gdk_window_clear_area(widget->window, 0, 0, widget->allocation.width, widget->allocation.height);
  if(blinky_style == ((struct _GtkStyle *)NULL))
  {
    blinky_style=gtk_style_new();
    blinky_style->fg_gc[(signed long int)GTK_STATE_NORMAL]=gdk_gc_new(widget->window);
  }

  unsigned long int return_value_blinky_get_type_1;
  return_value_blinky_get_type_1=blinky_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_blinky_get_type_1);
  if(!(((struct _Blinky *)return_value_g_type_check_instance_cast_2)->state == 0u))
    gdk_gc_set_foreground(blinky_style->fg_gc[(signed long int)GTK_STATE_NORMAL], &col_green);

  else
    gdk_gc_set_foreground(blinky_style->fg_gc[(signed long int)GTK_STATE_NORMAL], &col_darkgreen);
  gdk_draw_rectangle(widget->window, blinky_style->fg_gc[(signed long int)widget->state], (signed int)!(0 != 0), 0, 0, widget->allocation.width, widget->allocation.height);
  return 0;
}

// blinky_get_state
// file eyecandy.c line 114
unsigned int blinky_get_state(struct _Blinky *blinky)
{
  signed int tmp_statement_expression_1;
  do
  {
    signed int blinky_get_state__1__1__1___g_boolean_var_;
    if(!(blinky == ((struct _Blinky *)NULL)))
      blinky_get_state__1__1__1___g_boolean_var_ = 1;

    else
      blinky_get_state__1__1__1___g_boolean_var_ = 0;
    tmp_statement_expression_1 = blinky_get_state__1__1__1___g_boolean_var_;
    if((signed long int)tmp_statement_expression_1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_get_state", "blinky != NULL");
      return (unsigned int)0;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression_2;
  signed int tmp_statement_expression_3;
  _Bool tmp_if_expr_4;
  do
  {
    signed int _g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)blinky;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_3 = __r;
    if(!(tmp_statement_expression_3 == 0))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression_2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression_2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_get_state", "IS_BLINKY(blinky)");
      return (unsigned int)0;
    }

  }
  while((_Bool)0);
  return blinky->state;
}

// blinky_get_type
// file eyecandy.c line 49
unsigned long int blinky_get_type(void)
{
  _Bool tmp_statement_expression_3;
  void *tmp_statement_expression_4;
  signed int return_value___atomic_load_8_5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8_5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression_4 = (void *)return_value___atomic_load_8_5;
  _Bool tmp_if_expr_7;
  signed int return_value_g_once_init_enter_6;
  if(tmp_statement_expression_4 == NULL)
  {
    return_value_g_once_init_enter_6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr_7 = return_value_g_once_init_enter_6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_7 = (_Bool)0;
  tmp_statement_expression_3 = tmp_if_expr_7;
  if(tmp_statement_expression_3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_widget_get_type_1;
    return_value_gtk_widget_get_type_1=gtk_widget_get_type();
    const char *return_value_g_intern_static_string_2;
    return_value_g_intern_static_string_2=g_intern_static_string("Blinky");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_widget_get_type_1, return_value_g_intern_static_string_2, (unsigned int)sizeof(struct _BlinkyClass) /*720ul*/ , (void (*)(void *, void *))blinky_class_intern_init, (unsigned int)sizeof(struct _Blinky) /*104ul*/ , (void (*)(struct _GTypeInstance *, void *))blinky_init, (enum anonymous_25)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// blinky_init
// file eyecandy.c line 82
static void blinky_init(struct _Blinky *blinky)
{
  blinky->state = (unsigned int)0;
}

// blinky_new
// file eyecandy.c line 88
struct _GtkWidget * blinky_new(unsigned int state)
{
  struct _Blinky *blinky;
  unsigned long int return_value_blinky_get_type_1;
  return_value_blinky_get_type_1=blinky_get_type();
  void *return_value_g_object_new_2;
  return_value_g_object_new_2=g_object_new(return_value_blinky_get_type_1, (const char *)(void *)0);
  blinky = (struct _Blinky *)return_value_g_object_new_2;
  blinky_set_state(blinky, state);
  unsigned long int return_value_gtk_widget_get_type_3;
  return_value_gtk_widget_get_type_3=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)blinky, return_value_gtk_widget_get_type_3);
  return (struct _GtkWidget *)return_value_g_type_check_instance_cast_4;
}

// blinky_realize
// file eyecandy.c line 134
static void blinky_realize(struct _GtkWidget *widget)
{
  struct _Blinky *blinky;
  struct _GdkWindowAttr attributes;
  signed int attributes_mask;
  signed int tmp_statement_expression_1;
  do
  {
    signed int blinky_realize__1__1__1___g_boolean_var_;
    if(!(widget == ((struct _GtkWidget *)NULL)))
      blinky_realize__1__1__1___g_boolean_var_ = 1;

    else
      blinky_realize__1__1__1___g_boolean_var_ = 0;
    tmp_statement_expression_1 = blinky_realize__1__1__1___g_boolean_var_;
    if((signed long int)tmp_statement_expression_1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_realize", "widget != NULL");
      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression_2;
  signed int tmp_statement_expression_3;
  _Bool tmp_if_expr_4;
  do
  {
    signed int _g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)widget;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_3 = __r;
    if(!(tmp_statement_expression_3 == 0))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression_2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression_2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_realize", "IS_BLINKY(widget)");
      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value_gtk_object_get_type_5;
    return_value_gtk_object_get_type_5=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_object_get_type_5);
    ((struct _GtkObject *)return_value_g_type_check_instance_cast_6)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast_6)->flags | (unsigned int)64;
  }
  while((_Bool)0);
  unsigned long int return_value_blinky_get_type_7;
  return_value_blinky_get_type_7=blinky_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_blinky_get_type_7);
  blinky = (struct _Blinky *)return_value_g_type_check_instance_cast_8;
  attributes.x = widget->allocation.x;
  attributes.y = widget->allocation.y;
  attributes.width = widget->allocation.width;
  attributes.height = widget->allocation.height;
  attributes.wclass = (enum anonymous_44)GDK_INPUT_OUTPUT;
  attributes.window_type = (enum anonymous_45)GDK_WINDOW_CHILD;
  signed int return_value_gtk_widget_get_events_9;
  return_value_gtk_widget_get_events_9=gtk_widget_get_events(widget);
  attributes.event_mask = return_value_gtk_widget_get_events_9 | 2;
  attributes.visual=gtk_widget_get_visual(widget);
  attributes.colormap=gtk_widget_get_colormap(widget);
  attributes_mask = 4 | 8 | 64 | 32;
  widget->window=gdk_window_new(widget->parent->window, &attributes, attributes_mask);
  widget->style=gtk_style_attach(widget->style, widget->window);
  gdk_window_set_user_data(widget->window, (void *)widget);
  gtk_style_set_background(widget->style, widget->window, (enum anonymous_49)GTK_STATE_ACTIVE);

__CPROVER_DUMP_L15:
  ;
}

// blinky_set_state
// file eyecandy.c line 123
void blinky_set_state(struct _Blinky *blinky, unsigned int state)
{
  signed int tmp_statement_expression_1;
  do
  {
    signed int _g_boolean_var_;
    if(!(blinky == ((struct _Blinky *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression_1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression_1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_set_state", "blinky != NULL");
      goto __CPROVER_DUMP_L14;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression_2;
  signed int tmp_statement_expression_3;
  _Bool tmp_if_expr_4;
  do
  {
    signed int blinky_set_state__1__2__1___g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)blinky;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_3 = __r;
    if(!(tmp_statement_expression_3 == 0))
      blinky_set_state__1__2__1___g_boolean_var_ = 1;

    else
      blinky_set_state__1__2__1___g_boolean_var_ = 0;
    tmp_statement_expression_2 = blinky_set_state__1__2__1___g_boolean_var_;
    if((signed long int)tmp_statement_expression_2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_set_state", "IS_BLINKY(blinky)");
      goto __CPROVER_DUMP_L14;
    }

  }
  while((_Bool)0);
  blinky->state = state;
  blinky_update(blinky);

__CPROVER_DUMP_L14:
  ;
}

// blinky_size_allocate
// file eyecandy.c line 176
static void blinky_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation)
{
  struct _Blinky *blinky;
  signed int tmp_statement_expression_1;
  do
  {
    signed int _g_boolean_var_;
    if(!(widget == ((struct _GtkWidget *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression_1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression_1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_size_allocate", "widget != NULL");
      goto __CPROVER_DUMP_L19;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression_2;
  signed int tmp_statement_expression_3;
  _Bool tmp_if_expr_4;
  do
  {
    signed int blinky_size_allocate__1__2__1___g_boolean_var_;
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)widget;
    unsigned long int __t;
    __t=blinky_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_4 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_3 = __r;
    if(!(tmp_statement_expression_3 == 0))
      blinky_size_allocate__1__2__1___g_boolean_var_ = 1;

    else
      blinky_size_allocate__1__2__1___g_boolean_var_ = 0;
    tmp_statement_expression_2 = blinky_size_allocate__1__2__1___g_boolean_var_;
    if((signed long int)tmp_statement_expression_2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_size_allocate", "IS_BLINKY(widget)");
      goto __CPROVER_DUMP_L19;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression_5;
  do
  {
    signed int blinky_size_allocate__1__3__1___g_boolean_var_;
    if(!(allocation == ((struct _GdkRectangle *)NULL)))
      blinky_size_allocate__1__3__1___g_boolean_var_ = 1;

    else
      blinky_size_allocate__1__3__1___g_boolean_var_ = 0;
    tmp_statement_expression_5 = blinky_size_allocate__1__3__1___g_boolean_var_;
    if((signed long int)tmp_statement_expression_5 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"blinky_size_allocate", "allocation != NULL");
      goto __CPROVER_DUMP_L19;
    }

  }
  while((_Bool)0);
  widget->allocation = *allocation;
  unsigned long int return_value_gtk_object_get_type_8;
  return_value_gtk_object_get_type_8=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
  return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_object_get_type_8);
  if(!((64u & ((struct _GtkObject *)return_value_g_type_check_instance_cast_9)->flags) == 0u))
  {
    unsigned long int return_value_blinky_get_type_6;
    return_value_blinky_get_type_6=blinky_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
    return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_blinky_get_type_6);
    blinky = (struct _Blinky *)return_value_g_type_check_instance_cast_7;
    gdk_window_move_resize(widget->window, allocation->x, allocation->y, allocation->width, allocation->height);
  }


__CPROVER_DUMP_L19:
  ;
}

// blinky_size_request
// file eyecandy.c line 169
static void blinky_size_request(struct _GtkWidget *widget, struct _GtkRequisition *requisition)
{
  requisition->width = 4;
  requisition->height = 16;
}

// blinky_update
// file eyecandy.c line 219
static void blinky_update(struct _Blinky *blinky)
{
  unsigned long int return_value_gtk_widget_get_type_1;
  return_value_gtk_widget_get_type_1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)blinky, return_value_gtk_widget_get_type_1);
  gtk_widget_draw((struct _GtkWidget *)return_value_g_type_check_instance_cast_2, (const struct _GdkRectangle *)(void *)0);
}

// copy_configure_items
// file ghostess.c line 853
void copy_configure_items(struct _instance_template_t *temp, struct _d3h_instance_t *inst)
{
  struct _configure_item_t *item = temp->configure_items;
  struct _configure_item_t *newitem;
  while(!(item == ((struct _configure_item_t *)NULL)))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct _configure_item_t) /*24ul*/ );
    newitem = (struct _configure_item_t *)return_value_malloc_1;
    newitem->next = inst->configure_items;
    inst->configure_items = newitem;
    char *return_value___strdup_2;
    return_value___strdup_2=__strdup(item->key);
    newitem->key = return_value___strdup_2;
    char *return_value___strdup_3;
    return_value___strdup_3=__strdup(item->value);
    newitem->value = return_value___strdup_3;
    item = item->next;
  }
}

// copy_initial_port_set
// file ghostess.c line 737
static void copy_initial_port_set(struct _instance_template_t *temp, struct _d3h_instance_t *inst)
{
  unsigned long int port_count = inst->plugin->descriptor->LADSPA_Plugin->PortCount;
  unsigned long int number_set = temp->ports.highest_set + (unsigned long int)1;
  inst->have_initial_values = 1;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(signed int) /*4ul*/ , port_count);
  inst->initial_value_set = (signed int *)return_value_calloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(float) /*4ul*/  * port_count);
  inst->initial_value = (float *)return_value_malloc_2;
  memcpy((void *)inst->initial_value_set, (const void *)temp->ports.set, sizeof(signed int) /*4ul*/  * number_set);
  memcpy((void *)inst->initial_value, (const void *)temp->ports.value, sizeof(float) /*4ul*/  * number_set);
}

// create_about_window
// file gui_interface.c line 294
void create_about_window(const char *tag)
{
  struct _GtkWidget *vbox2;
  struct _GtkWidget *closeabout;
  about_window=gtk_window_new((enum anonymous_16)GTK_WINDOW_TOPLEVEL);
  unsigned long int return_value_gtk_object_get_type_1;
  return_value_gtk_object_get_type_1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type_1);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast_2, "about_window", (void *)about_window);
  unsigned long int return_value_gtk_window_get_type_3;
  return_value_gtk_window_get_type_3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_window_get_type_3);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, "About ghostess");
  vbox2=gtk_vbox_new(0, 0);
  gtk_widget_ref(vbox2);
  unsigned long int return_value_gtk_object_get_type_5;
  return_value_gtk_object_get_type_5=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type_5);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_6, "vbox2", (void *)vbox2, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(vbox2);
  unsigned long int return_value_gtk_container_get_type_7;
  return_value_gtk_container_get_type_7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_container_get_type_7);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_8, vbox2);
  about_label=gtk_label_new("Some message\ngoes here");
  gtk_widget_ref(about_label);
  unsigned long int return_value_gtk_object_get_type_9;
  return_value_gtk_object_get_type_9=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type_9);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_10, "about_label", (void *)about_label, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(about_label);
  unsigned long int return_value_gtk_box_get_type_11;
  return_value_gtk_box_get_type_11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type_11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_12, about_label, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_label_get_type_13;
  return_value_gtk_label_get_type_13=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)about_label, return_value_gtk_label_get_type_13);
  gtk_label_set_line_wrap((struct _GtkLabel *)return_value_g_type_check_instance_cast_14, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_label_get_type_15;
  return_value_gtk_label_get_type_15=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)about_label, return_value_gtk_label_get_type_15);
  gtk_label_set_justify((struct _GtkLabel *)return_value_g_type_check_instance_cast_16, (enum anonymous_20)GTK_JUSTIFY_CENTER);
  unsigned long int return_value_gtk_misc_get_type_17;
  return_value_gtk_misc_get_type_17=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)about_label, return_value_gtk_misc_get_type_17);
  gtk_misc_set_padding((struct _GtkMisc *)return_value_g_type_check_instance_cast_18, 5, 5);
  closeabout=gtk_button_new_with_label("Dismiss");
  gtk_widget_ref(closeabout);
  unsigned long int return_value_gtk_object_get_type_19;
  return_value_gtk_object_get_type_19=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
  return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type_19);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_20, "closeabout", (void *)closeabout, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(closeabout);
  unsigned long int return_value_gtk_box_get_type_21;
  return_value_gtk_box_get_type_21=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type_21);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_22, closeabout, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_object_get_type_23;
  return_value_gtk_object_get_type_23=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type_23);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_24, "destroy", (void (*)(void))gtk_main_quit, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_25;
  return_value_gtk_object_get_type_25=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)about_window, return_value_gtk_object_get_type_25);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_26, "delete_event", (void (*)(void))on_delete_event_wrapper, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)on_about_dismiss, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_27;
  return_value_gtk_object_get_type_27=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)closeabout, return_value_gtk_object_get_type_27);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_28, "clicked", (void (*)(void))on_about_dismiss, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
}

// create_file_selection
// file gui_interface.c line 256
void create_file_selection(const char *tag)
{
  char *title;
  struct _GtkWidget *ok_button;
  struct _GtkWidget *cancel_button;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(tag);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)22);
  title = (char *)return_value_malloc_2;
  sprintf(title, "%s - File Selection", tag);
  file_selection=gtk_file_selection_new(title);
  free((void *)title);
  unsigned long int return_value_gtk_object_get_type_3;
  return_value_gtk_object_get_type_3=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type_3);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast_4, "file_selection", (void *)file_selection);
  unsigned long int return_value_gtk_container_get_type_5;
  return_value_gtk_container_get_type_5=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_container_get_type_5);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_6, (unsigned int)10);
  unsigned long int return_value_gtk_window_get_type_7;
  return_value_gtk_window_get_type_7=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_window_get_type_7);
  ((struct _GtkWindow *)return_value_g_type_check_instance_cast_8)->type = (unsigned int)GTK_WINDOW_TOPLEVEL;
  unsigned long int return_value_gtk_file_selection_get_type_9;
  return_value_gtk_file_selection_get_type_9=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type_9);
  ok_button = ((struct _GtkFileSelection *)return_value_g_type_check_instance_cast_10)->ok_button;
  unsigned long int return_value_gtk_object_get_type_11;
  return_value_gtk_object_get_type_11=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type_11);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast_12, "ok_button", (void *)ok_button);
  gtk_widget_show(ok_button);
  do
  {
    unsigned long int return_value_gtk_object_get_type_13;
    return_value_gtk_object_get_type_13=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
    return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)ok_button, return_value_gtk_object_get_type_13);
    ((struct _GtkObject *)return_value_g_type_check_instance_cast_14)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast_14)->flags | (unsigned int)8192;
  }
  while((_Bool)0);
  unsigned long int return_value_gtk_file_selection_get_type_15;
  return_value_gtk_file_selection_get_type_15=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type_15);
  cancel_button = ((struct _GtkFileSelection *)return_value_g_type_check_instance_cast_16)->cancel_button;
  unsigned long int return_value_gtk_object_get_type_17;
  return_value_gtk_object_get_type_17=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type_17);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast_18, "cancel_button", (void *)cancel_button);
  gtk_widget_show(cancel_button);
  do
  {
    unsigned long int return_value_gtk_object_get_type_19;
    return_value_gtk_object_get_type_19=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
    return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)cancel_button, return_value_gtk_object_get_type_19);
    ((struct _GtkObject *)return_value_g_type_check_instance_cast_20)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast_20)->flags | (unsigned int)8192;
  }
  while((_Bool)0);
  unsigned long int return_value_gtk_object_get_type_21;
  return_value_gtk_object_get_type_21=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type_21);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_22, "destroy", (void (*)(void))gtk_main_quit, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_23;
  return_value_gtk_object_get_type_23=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_object_get_type_23);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_24, "delete_event", (void (*)(void))on_delete_event_wrapper, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)on_file_selection_cancel, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_file_selection_get_type_25;
  return_value_gtk_file_selection_get_type_25=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type_25);
  unsigned long int return_value_gtk_object_get_type_27;
  return_value_gtk_object_get_type_27=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkFileSelection *)return_value_g_type_check_instance_cast_26)->ok_button, return_value_gtk_object_get_type_27);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_28, "clicked", (void (*)(void))on_file_selection_ok, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_file_selection_get_type_29;
  return_value_gtk_file_selection_get_type_29=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
  return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type_29);
  unsigned long int return_value_gtk_object_get_type_31;
  return_value_gtk_object_get_type_31=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
  return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkFileSelection *)return_value_g_type_check_instance_cast_30)->cancel_button, return_value_gtk_object_get_type_31);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_32, "clicked", (void (*)(void))on_file_selection_cancel, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
}

// create_main_window
// file gui_interface.c line 59
void create_main_window(const char *tag, signed int instance_count)
{
  struct _GtkWidget *vbox1;
  struct _GtkWidget *menubar1;
  struct _GtkWidget *file1;
  struct _GtkWidget *file1_menu;
  struct _GtkWidget *menu_save;
  struct _GtkWidget *menu_patchlist;
  struct _GtkWidget *separator1;
  struct _GtkWidget *menu_quit;
  struct _GtkWidget *help1;
  struct _GtkWidget *help1_menu;
  struct _GtkWidget *menu_about;
  struct _GtkWidget *scrolledwindow1;
  struct _GtkWidget *viewport1;
  struct _GtkAccelGroup *accel_group;
  accel_group=gtk_accel_group_new();
  main_window=gtk_window_new((enum anonymous_16)GTK_WINDOW_TOPLEVEL);
  unsigned long int return_value_gtk_object_get_type_1;
  return_value_gtk_object_get_type_1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_1);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast_2, "main_window", (void *)main_window);
  unsigned long int return_value_gtk_window_get_type_3;
  return_value_gtk_window_get_type_3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_window_get_type_3);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, tag);
  vbox1=gtk_vbox_new(0, 0);
  gtk_widget_ref(vbox1);
  unsigned long int return_value_gtk_object_get_type_5;
  return_value_gtk_object_get_type_5=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_5);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_6, "vbox1", (void *)vbox1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(vbox1);
  unsigned long int return_value_gtk_container_get_type_7;
  return_value_gtk_container_get_type_7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_container_get_type_7);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_8, vbox1);
  menubar1=gtk_menu_bar_new();
  gtk_widget_ref(menubar1);
  unsigned long int return_value_gtk_object_get_type_9;
  return_value_gtk_object_get_type_9=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_9);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_10, "menubar1", (void *)menubar1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menubar1);
  unsigned long int return_value_gtk_box_get_type_11;
  return_value_gtk_box_get_type_11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type_11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_12, menubar1, 0, 0, (unsigned int)0);
  file1=gtk_menu_item_new_with_label("File");
  gtk_widget_ref(file1);
  unsigned long int return_value_gtk_object_get_type_13;
  return_value_gtk_object_get_type_13=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_13);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_14, "file1", (void *)file1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(file1);
  unsigned long int return_value_gtk_container_get_type_15;
  return_value_gtk_container_get_type_15=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)menubar1, return_value_gtk_container_get_type_15);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_16, file1);
  file1_menu=gtk_menu_new();
  gtk_widget_ref(file1_menu);
  unsigned long int return_value_gtk_object_get_type_17;
  return_value_gtk_object_get_type_17=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_17);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_18, "file1_menu", (void *)file1_menu, (void (*)(void *))gtk_widget_unref);
  unsigned long int return_value_gtk_menu_item_get_type_19;
  return_value_gtk_menu_item_get_type_19=gtk_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
  return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)file1, return_value_gtk_menu_item_get_type_19);
  gtk_menu_item_set_submenu((struct _GtkMenuItem *)return_value_g_type_check_instance_cast_20, file1_menu);
  menu_save=gtk_menu_item_new_with_label("Save Configuration...");
  gtk_widget_ref(menu_save);
  unsigned long int return_value_gtk_object_get_type_21;
  return_value_gtk_object_get_type_21=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_21);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_22, "menu_save", (void *)menu_save, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menu_save);
  unsigned long int return_value_gtk_container_get_type_23;
  return_value_gtk_container_get_type_23=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)file1_menu, return_value_gtk_container_get_type_23);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_24, menu_save);
  gtk_widget_add_accelerator(menu_save, "activate", accel_group, (unsigned int)0x053, (enum anonymous_23)GDK_CONTROL_MASK, (enum anonymous_24)GTK_ACCEL_VISIBLE);
  menu_patchlist=gtk_menu_item_new_with_label("Patchlist Export for Freewheeling...");
  gtk_widget_ref(menu_patchlist);
  unsigned long int return_value_gtk_object_get_type_25;
  return_value_gtk_object_get_type_25=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_25);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_26, "menu_patchlist", (void *)menu_patchlist, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menu_patchlist);
  unsigned long int return_value_gtk_container_get_type_27;
  return_value_gtk_container_get_type_27=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)file1_menu, return_value_gtk_container_get_type_27);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_28, menu_patchlist);
  gtk_widget_add_accelerator(menu_patchlist, "activate", accel_group, (unsigned int)0x050, (enum anonymous_23)GDK_CONTROL_MASK, (enum anonymous_24)GTK_ACCEL_VISIBLE);
  separator1=gtk_menu_item_new();
  gtk_widget_ref(separator1);
  unsigned long int return_value_gtk_object_get_type_29;
  return_value_gtk_object_get_type_29=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
  return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_29);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_30, "separator1", (void *)separator1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(separator1);
  unsigned long int return_value_gtk_container_get_type_31;
  return_value_gtk_container_get_type_31=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
  return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)file1_menu, return_value_gtk_container_get_type_31);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_32, separator1);
  gtk_widget_set_sensitive(separator1, 0);
  menu_quit=gtk_menu_item_new_with_label("Quit");
  gtk_widget_ref(menu_quit);
  unsigned long int return_value_gtk_object_get_type_33;
  return_value_gtk_object_get_type_33=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
  return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_33);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_34, "menu_quit", (void *)menu_quit, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menu_quit);
  unsigned long int return_value_gtk_container_get_type_35;
  return_value_gtk_container_get_type_35=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_36;
  return_value_g_type_check_instance_cast_36=g_type_check_instance_cast((struct _GTypeInstance *)file1_menu, return_value_gtk_container_get_type_35);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_36, menu_quit);
  gtk_widget_add_accelerator(menu_quit, "activate", accel_group, (unsigned int)0x051, (enum anonymous_23)GDK_CONTROL_MASK, (enum anonymous_24)GTK_ACCEL_VISIBLE);
  help1=gtk_menu_item_new_with_label("About");
  gtk_widget_ref(help1);
  unsigned long int return_value_gtk_object_get_type_37;
  return_value_gtk_object_get_type_37=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_38;
  return_value_g_type_check_instance_cast_38=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_37);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_38, "help1", (void *)help1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(help1);
  unsigned long int return_value_gtk_container_get_type_39;
  return_value_gtk_container_get_type_39=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_40;
  return_value_g_type_check_instance_cast_40=g_type_check_instance_cast((struct _GTypeInstance *)menubar1, return_value_gtk_container_get_type_39);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_40, help1);
  unsigned long int return_value_gtk_menu_item_get_type_41;
  return_value_gtk_menu_item_get_type_41=gtk_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_42;
  return_value_g_type_check_instance_cast_42=g_type_check_instance_cast((struct _GTypeInstance *)help1, return_value_gtk_menu_item_get_type_41);
  gtk_menu_item_set_right_justified((struct _GtkMenuItem *)return_value_g_type_check_instance_cast_42, (signed int)!(0 != 0));
  help1_menu=gtk_menu_new();
  gtk_widget_ref(help1_menu);
  unsigned long int return_value_gtk_object_get_type_43;
  return_value_gtk_object_get_type_43=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_44;
  return_value_g_type_check_instance_cast_44=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_43);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_44, "help1_menu", (void *)help1_menu, (void (*)(void *))gtk_widget_unref);
  unsigned long int return_value_gtk_menu_item_get_type_45;
  return_value_gtk_menu_item_get_type_45=gtk_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_46;
  return_value_g_type_check_instance_cast_46=g_type_check_instance_cast((struct _GTypeInstance *)help1, return_value_gtk_menu_item_get_type_45);
  gtk_menu_item_set_submenu((struct _GtkMenuItem *)return_value_g_type_check_instance_cast_46, help1_menu);
  menu_about=gtk_menu_item_new_with_label("About ghostess");
  gtk_widget_ref(menu_about);
  unsigned long int return_value_gtk_object_get_type_47;
  return_value_gtk_object_get_type_47=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_48;
  return_value_g_type_check_instance_cast_48=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_47);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_48, "menu_about", (void *)menu_about, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(menu_about);
  unsigned long int return_value_gtk_container_get_type_49;
  return_value_gtk_container_get_type_49=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_50;
  return_value_g_type_check_instance_cast_50=g_type_check_instance_cast((struct _GTypeInstance *)help1_menu, return_value_gtk_container_get_type_49);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_50, menu_about);
  plugin_hbox=gtk_hbox_new(0, 0);
  gtk_widget_ref(plugin_hbox);
  unsigned long int return_value_gtk_object_get_type_51;
  return_value_gtk_object_get_type_51=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_52;
  return_value_g_type_check_instance_cast_52=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_51);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_52, "plugin_hbox", (void *)plugin_hbox, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(plugin_hbox);
  if(instance_count >= 6)
  {
    scrolledwindow1=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
    gtk_widget_ref(scrolledwindow1);
    unsigned long int return_value_gtk_object_get_type_53;
    return_value_gtk_object_get_type_53=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_54;
    return_value_g_type_check_instance_cast_54=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_53);
    gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_54, "scrolledwindow1", (void *)scrolledwindow1, (void (*)(void *))gtk_widget_unref);
    gtk_widget_show(scrolledwindow1);
    unsigned long int return_value_gtk_scrolled_window_get_type_55;
    return_value_gtk_scrolled_window_get_type_55=gtk_scrolled_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_56;
    return_value_g_type_check_instance_cast_56=g_type_check_instance_cast((struct _GTypeInstance *)scrolledwindow1, return_value_gtk_scrolled_window_get_type_55);
    gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_56, (enum anonymous_5)GTK_POLICY_AUTOMATIC, (enum anonymous_5)GTK_POLICY_NEVER);
    unsigned long int return_value_gtk_scrolled_window_get_type_57;
    return_value_gtk_scrolled_window_get_type_57=gtk_scrolled_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_58;
    return_value_g_type_check_instance_cast_58=g_type_check_instance_cast((struct _GTypeInstance *)scrolledwindow1, return_value_gtk_scrolled_window_get_type_57);
    unsigned long int return_value_gtk_range_get_type_59;
    return_value_gtk_range_get_type_59=gtk_range_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_60;
    return_value_g_type_check_instance_cast_60=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_58)->vscrollbar, return_value_gtk_range_get_type_59);
    gtk_range_set_update_policy((struct _GtkRange *)return_value_g_type_check_instance_cast_60, (enum anonymous_3)GTK_POLICY_AUTOMATIC);
    unsigned long int return_value_gtk_box_get_type_61;
    return_value_gtk_box_get_type_61=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_62;
    return_value_g_type_check_instance_cast_62=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type_61);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_62, scrolledwindow1, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
    unsigned long int return_value_gtk_widget_get_type_63;
    return_value_gtk_widget_get_type_63=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_64;
    return_value_g_type_check_instance_cast_64=g_type_check_instance_cast((struct _GTypeInstance *)scrolledwindow1, return_value_gtk_widget_get_type_63);
    gtk_widget_set_size_request((struct _GtkWidget *)return_value_g_type_check_instance_cast_64, 400, -1);
    viewport1=gtk_viewport_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
    gtk_widget_ref(viewport1);
    unsigned long int return_value_gtk_object_get_type_65;
    return_value_gtk_object_get_type_65=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_66;
    return_value_g_type_check_instance_cast_66=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_65);
    gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_66, "viewport1", (void *)viewport1, (void (*)(void *))gtk_widget_unref);
    gtk_widget_show(viewport1);
    unsigned long int return_value_gtk_container_get_type_67;
    return_value_gtk_container_get_type_67=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_68;
    return_value_g_type_check_instance_cast_68=g_type_check_instance_cast((struct _GTypeInstance *)scrolledwindow1, return_value_gtk_container_get_type_67);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_68, viewport1);
    unsigned long int return_value_gtk_container_get_type_69;
    return_value_gtk_container_get_type_69=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_70;
    return_value_g_type_check_instance_cast_70=g_type_check_instance_cast((struct _GTypeInstance *)viewport1, return_value_gtk_container_get_type_69);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_70, plugin_hbox);
  }

  else
  {
    unsigned long int return_value_gtk_box_get_type_71;
    return_value_gtk_box_get_type_71=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_72;
    return_value_g_type_check_instance_cast_72=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type_71);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_72, plugin_hbox, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  }
  unsigned long int return_value_gtk_object_get_type_73;
  return_value_gtk_object_get_type_73=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_74;
  return_value_g_type_check_instance_cast_74=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_73);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_74, "destroy", (void (*)(void))gtk_main_quit, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_75;
  return_value_gtk_object_get_type_75=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_76;
  return_value_g_type_check_instance_cast_76=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_object_get_type_75);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_76, "delete_event", (void (*)(void))on_delete_event_wrapper, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)on_menu_quit_activate, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_77;
  return_value_gtk_object_get_type_77=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_78;
  return_value_g_type_check_instance_cast_78=g_type_check_instance_cast((struct _GTypeInstance *)menu_save, return_value_gtk_object_get_type_77);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_78, "activate", (void (*)(void))on_menu_save_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_79;
  return_value_gtk_object_get_type_79=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_80;
  return_value_g_type_check_instance_cast_80=g_type_check_instance_cast((struct _GTypeInstance *)menu_patchlist, return_value_gtk_object_get_type_79);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_80, "activate", (void (*)(void))on_menu_patchlist_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_81;
  return_value_gtk_object_get_type_81=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_82;
  return_value_g_type_check_instance_cast_82=g_type_check_instance_cast((struct _GTypeInstance *)menu_quit, return_value_gtk_object_get_type_81);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_82, "activate", (void (*)(void))on_menu_quit_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_83;
  return_value_gtk_object_get_type_83=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_84;
  return_value_g_type_check_instance_cast_84=g_type_check_instance_cast((struct _GTypeInstance *)menu_about, return_value_gtk_object_get_type_83);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_84, "activate", (void (*)(void))on_menu_about_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_window_get_type_85;
  return_value_gtk_window_get_type_85=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_86;
  return_value_g_type_check_instance_cast_86=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_window_get_type_85);
  gtk_window_add_accel_group((struct _GtkWindow *)return_value_g_type_check_instance_cast_86, accel_group);
}

// create_notice_window
// file gui_interface.c line 338
void create_notice_window(const char *tag)
{
  char *title;
  struct _GtkWidget *vbox3;
  struct _GtkWidget *hbox1;
  struct _GtkWidget *notice_dismiss;
  notice_window=gtk_window_new((enum anonymous_16)GTK_WINDOW_TOPLEVEL);
  unsigned long int return_value_gtk_object_get_type_1;
  return_value_gtk_object_get_type_1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type_1);
  gtk_object_set_data((struct _GtkObject *)return_value_g_type_check_instance_cast_2, "notice_window", (void *)notice_window);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(tag);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(return_value_strlen_3 + (unsigned long int)8);
  title = (char *)return_value_malloc_4;
  sprintf(title, "%s Notice", tag);
  unsigned long int return_value_gtk_window_get_type_5;
  return_value_gtk_window_get_type_5=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_window_get_type_5);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, title);
  free((void *)title);
  unsigned long int return_value_gtk_window_get_type_7;
  return_value_gtk_window_get_type_7=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_window_get_type_7);
  gtk_window_set_position((struct _GtkWindow *)return_value_g_type_check_instance_cast_8, (enum anonymous_17)GTK_WIN_POS_MOUSE);
  unsigned long int return_value_gtk_window_get_type_9;
  return_value_gtk_window_get_type_9=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_window_get_type_9);
  gtk_window_set_modal((struct _GtkWindow *)return_value_g_type_check_instance_cast_10, (signed int)!(0 != 0));
  vbox3=gtk_vbox_new(0, 0);
  gtk_widget_ref(vbox3);
  unsigned long int return_value_gtk_object_get_type_11;
  return_value_gtk_object_get_type_11=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type_11);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_12, "vbox3", (void *)vbox3, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(vbox3);
  unsigned long int return_value_gtk_container_get_type_13;
  return_value_gtk_container_get_type_13=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_container_get_type_13);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_14, vbox3);
  notice_label_1=gtk_label_new("Some message\ngoes here");
  gtk_widget_ref(notice_label_1);
  unsigned long int return_value_gtk_object_get_type_15;
  return_value_gtk_object_get_type_15=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type_15);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_16, "notice_label_1", (void *)notice_label_1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(notice_label_1);
  unsigned long int return_value_gtk_box_get_type_17;
  return_value_gtk_box_get_type_17=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)vbox3, return_value_gtk_box_get_type_17);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_18, notice_label_1, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_label_get_type_19;
  return_value_gtk_label_get_type_19=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
  return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_1, return_value_gtk_label_get_type_19);
  gtk_label_set_line_wrap((struct _GtkLabel *)return_value_g_type_check_instance_cast_20, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_misc_get_type_21;
  return_value_gtk_misc_get_type_21=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_1, return_value_gtk_misc_get_type_21);
  gtk_misc_set_padding((struct _GtkMisc *)return_value_g_type_check_instance_cast_22, 10, 5);
  notice_label_2=gtk_label_new("more text\ngoes here");
  gtk_widget_ref(notice_label_2);
  unsigned long int return_value_gtk_object_get_type_23;
  return_value_gtk_object_get_type_23=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type_23);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_24, "notice_label_2", (void *)notice_label_2, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(notice_label_2);
  unsigned long int return_value_gtk_box_get_type_25;
  return_value_gtk_box_get_type_25=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)vbox3, return_value_gtk_box_get_type_25);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_26, notice_label_2, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_label_get_type_27;
  return_value_gtk_label_get_type_27=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_2, return_value_gtk_label_get_type_27);
  gtk_label_set_line_wrap((struct _GtkLabel *)return_value_g_type_check_instance_cast_28, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_misc_get_type_29;
  return_value_gtk_misc_get_type_29=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
  return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_2, return_value_gtk_misc_get_type_29);
  gtk_misc_set_padding((struct _GtkMisc *)return_value_g_type_check_instance_cast_30, 10, 5);
  hbox1=gtk_hbox_new(0, 0);
  gtk_widget_ref(hbox1);
  unsigned long int return_value_gtk_object_get_type_31;
  return_value_gtk_object_get_type_31=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
  return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type_31);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_32, "hbox1", (void *)hbox1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(hbox1);
  unsigned long int return_value_gtk_box_get_type_33;
  return_value_gtk_box_get_type_33=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
  return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)vbox3, return_value_gtk_box_get_type_33);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_34, hbox1, 0, 0, (unsigned int)0);
  notice_dismiss=gtk_button_new_with_label("Dismiss");
  gtk_widget_ref(notice_dismiss);
  unsigned long int return_value_gtk_object_get_type_35;
  return_value_gtk_object_get_type_35=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_36;
  return_value_g_type_check_instance_cast_36=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type_35);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_36, "notice_dismiss", (void *)notice_dismiss, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(notice_dismiss);
  unsigned long int return_value_gtk_box_get_type_37;
  return_value_gtk_box_get_type_37=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_38;
  return_value_g_type_check_instance_cast_38=g_type_check_instance_cast((struct _GTypeInstance *)hbox1, return_value_gtk_box_get_type_37);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_38, notice_dismiss, (signed int)!(0 != 0), 0, (unsigned int)0);
  unsigned long int return_value_gtk_container_get_type_39;
  return_value_gtk_container_get_type_39=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_40;
  return_value_g_type_check_instance_cast_40=g_type_check_instance_cast((struct _GTypeInstance *)notice_dismiss, return_value_gtk_container_get_type_39);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_40, (unsigned int)7);
  unsigned long int return_value_gtk_object_get_type_41;
  return_value_gtk_object_get_type_41=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_42;
  return_value_g_type_check_instance_cast_42=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type_41);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_42, "destroy", (void (*)(void))gtk_main_quit, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_43;
  return_value_gtk_object_get_type_43=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_44;
  return_value_g_type_check_instance_cast_44=g_type_check_instance_cast((struct _GTypeInstance *)notice_window, return_value_gtk_object_get_type_43);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_44, "delete_event", (void (*)(void))on_delete_event_wrapper, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)on_notice_dismiss, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_45;
  return_value_gtk_object_get_type_45=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_46;
  return_value_g_type_check_instance_cast_46=g_type_check_instance_cast((struct _GTypeInstance *)notice_dismiss, return_value_gtk_object_get_type_45);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_46, "clicked", (void (*)(void))on_notice_dismiss, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
}

// create_plugin_strip
// file gui_interface.h line 56
struct _plugin_strip * create_plugin_strip(struct _GtkWidget *parent_window, struct _d3h_instance_t *instance)
{
  struct _plugin_strip *ps;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _plugin_strip) /*56ul*/ );
  ps = (struct _plugin_strip *)return_value_calloc_1;
  struct _GtkWidget *vbox1;
  char buf[12l];
  struct _GtkWidget *hbox1;
  struct _GtkWidget *striplabel1;
  struct _GtkWidget *striplabel2;
  struct _GtkWidget *hbox2;
  ps->instance = instance;
  ps->container=gtk_frame_new((const char *)(void *)0);
  gtk_widget_ref(ps->container);
  unsigned long int return_value_gtk_object_get_type_2;
  return_value_gtk_object_get_type_2=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_3;
  return_value_g_type_check_instance_cast_3=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type_2);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_3, "frame1", (void *)ps->container, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(ps->container);
  unsigned long int return_value_gtk_container_get_type_4;
  return_value_gtk_container_get_type_4=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
  return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)ps->container, return_value_gtk_container_get_type_4);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_5, (unsigned int)2);
  unsigned long int return_value_gtk_frame_get_type_6;
  return_value_gtk_frame_get_type_6=gtk_frame_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
  return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)ps->container, return_value_gtk_frame_get_type_6);
  gtk_frame_set_shadow_type((struct _GtkFrame *)return_value_g_type_check_instance_cast_7, (enum anonymous_11)GTK_SHADOW_OUT);
  vbox1=gtk_vbox_new(0, 0);
  gtk_widget_ref(vbox1);
  unsigned long int return_value_gtk_object_get_type_8;
  return_value_gtk_object_get_type_8=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
  return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type_8);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_9, "vbox1", (void *)vbox1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(vbox1);
  unsigned long int return_value_gtk_container_get_type_10;
  return_value_gtk_container_get_type_10=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
  return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)ps->container, return_value_gtk_container_get_type_10);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_11, vbox1);
  hbox1=gtk_hbox_new(0, 0);
  gtk_widget_ref(hbox1);
  unsigned long int return_value_gtk_object_get_type_12;
  return_value_gtk_object_get_type_12=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
  return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type_12);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_13, "hbox1", (void *)hbox1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(hbox1);
  unsigned long int return_value_gtk_box_get_type_14;
  return_value_gtk_box_get_type_14=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_15;
  return_value_g_type_check_instance_cast_15=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type_14);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_15, hbox1, 0, 0, (unsigned int)0);
  ps->midi_status=blinky_new((unsigned int)0);
  gtk_widget_ref(ps->midi_status);
  unsigned long int return_value_gtk_object_get_type_16;
  return_value_gtk_object_get_type_16=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
  return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type_16);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_17, "midi_status", (void *)ps->midi_status, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(ps->midi_status);
  unsigned long int return_value_gtk_box_get_type_18;
  return_value_gtk_box_get_type_18=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_19;
  return_value_g_type_check_instance_cast_19=g_type_check_instance_cast((struct _GTypeInstance *)hbox1, return_value_gtk_box_get_type_18);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_19, ps->midi_status, 0, 0, (unsigned int)1);
  ps->previous_midi_state = 0;
  snprintf(buf, (unsigned long int)12, "Inst %d", instance->id);
  striplabel1=gtk_label_new(buf);
  gtk_widget_ref(striplabel1);
  unsigned long int return_value_gtk_object_get_type_20;
  return_value_gtk_object_get_type_20=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
  return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type_20);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_21, "striplabel1", (void *)striplabel1, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(striplabel1);
  unsigned long int return_value_gtk_box_get_type_22;
  return_value_gtk_box_get_type_22=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_23;
  return_value_g_type_check_instance_cast_23=g_type_check_instance_cast((struct _GTypeInstance *)hbox1, return_value_gtk_box_get_type_22);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_23, striplabel1, 0, 0, (unsigned int)1);
  snprintf(buf, (unsigned long int)12, "%s", instance->plugin->label);
  striplabel2=gtk_label_new(buf);
  gtk_widget_ref(striplabel2);
  unsigned long int return_value_gtk_object_get_type_24;
  return_value_gtk_object_get_type_24=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_25;
  return_value_g_type_check_instance_cast_25=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type_24);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_25, "striplabel2", (void *)striplabel2, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(striplabel2);
  unsigned long int return_value_gtk_box_get_type_26;
  return_value_gtk_box_get_type_26=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_27;
  return_value_g_type_check_instance_cast_27=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type_26);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_27, striplabel2, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_misc_get_type_28;
  return_value_gtk_misc_get_type_28=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_29;
  return_value_g_type_check_instance_cast_29=g_type_check_instance_cast((struct _GTypeInstance *)striplabel2, return_value_gtk_misc_get_type_28);
  gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast_29, (float)0, (float)0.5);
  unsigned long int return_value_gtk_misc_get_type_30;
  return_value_gtk_misc_get_type_30=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_31;
  return_value_g_type_check_instance_cast_31=g_type_check_instance_cast((struct _GTypeInstance *)striplabel2, return_value_gtk_misc_get_type_30);
  gtk_misc_set_padding((struct _GtkMisc *)return_value_g_type_check_instance_cast_31, 3, 0);
  hbox2=gtk_hbox_new((signed int)!(0 != 0), 0);
  gtk_widget_ref(hbox2);
  unsigned long int return_value_gtk_object_get_type_32;
  return_value_gtk_object_get_type_32=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_33;
  return_value_g_type_check_instance_cast_33=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type_32);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_33, "hbox2", (void *)hbox2, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(hbox2);
  unsigned long int return_value_gtk_box_get_type_34;
  return_value_gtk_box_get_type_34=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_35;
  return_value_g_type_check_instance_cast_35=g_type_check_instance_cast((struct _GTypeInstance *)vbox1, return_value_gtk_box_get_type_34);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_35, hbox2, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_container_get_type_36;
  return_value_gtk_container_get_type_36=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_37;
  return_value_g_type_check_instance_cast_37=g_type_check_instance_cast((struct _GTypeInstance *)hbox2, return_value_gtk_container_get_type_36);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_37, (unsigned int)3);
  ps->ui_button=gtk_toggle_button_new_with_label("UI");
  gtk_widget_ref(ps->ui_button);
  unsigned long int return_value_gtk_object_get_type_38;
  return_value_gtk_object_get_type_38=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_39;
  return_value_g_type_check_instance_cast_39=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type_38);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_39, "ui_button", (void *)ps->ui_button, (void (*)(void *))gtk_widget_unref);
  gtk_widget_show(ps->ui_button);
  unsigned long int return_value_gtk_box_get_type_40;
  return_value_gtk_box_get_type_40=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_41;
  return_value_g_type_check_instance_cast_41=g_type_check_instance_cast((struct _GTypeInstance *)hbox2, return_value_gtk_box_get_type_40);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_41, ps->ui_button, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_object_get_type_42;
  return_value_gtk_object_get_type_42=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_43;
  return_value_g_type_check_instance_cast_43=g_type_check_instance_cast((struct _GTypeInstance *)ps->ui_button, return_value_gtk_object_get_type_42);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_43, "toggled", (void (*)(void))on_strip_ui_button_toggled, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)ps, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_44;
  return_value_gtk_object_get_type_44=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_45;
  return_value_g_type_check_instance_cast_45=g_type_check_instance_cast((struct _GTypeInstance *)ps->ui_button, return_value_gtk_object_get_type_44);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_45, "button_press_event", (void (*)(void))on_strip_ui_button_event, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)ps, (void (*)(void *))(void *)0, 0, 0);
  return ps;
}

// create_ui_context_menu
// file gui_interface.c line 222
void create_ui_context_menu(struct _GtkWidget *parent_window)
{
  ui_context_menu=gtk_menu_new();
  gtk_widget_ref(ui_context_menu);
  unsigned long int return_value_gtk_object_get_type_1;
  return_value_gtk_object_get_type_1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)parent_window, return_value_gtk_object_get_type_1);
  gtk_object_set_data_full((struct _GtkObject *)return_value_g_type_check_instance_cast_2, "ui_context_menu", (void *)ui_context_menu, (void (*)(void *))gtk_widget_unref);
  ui_context_menu_launch=gtk_menu_item_new_with_label("Launch UI");
  gtk_widget_show(ui_context_menu_launch);
  unsigned long int return_value_gtk_menu_get_type_3;
  return_value_gtk_menu_get_type_3=gtk_menu_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type_3);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenu *)return_value_g_type_check_instance_cast_4, ui_context_menu_launch);
  ui_context_menu_show=gtk_menu_item_new_with_label("Show UI");
  gtk_widget_show(ui_context_menu_show);
  unsigned long int return_value_gtk_menu_get_type_5;
  return_value_gtk_menu_get_type_5=gtk_menu_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type_5);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenu *)return_value_g_type_check_instance_cast_6, ui_context_menu_show);
  ui_context_menu_hide=gtk_menu_item_new_with_label("Hide UI");
  gtk_widget_show(ui_context_menu_hide);
  unsigned long int return_value_gtk_menu_get_type_7;
  return_value_gtk_menu_get_type_7=gtk_menu_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type_7);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenu *)return_value_g_type_check_instance_cast_8, ui_context_menu_hide);
  ui_context_menu_exit=gtk_menu_item_new_with_label("Exit UI");
  gtk_widget_show(ui_context_menu_exit);
  unsigned long int return_value_gtk_menu_get_type_9;
  return_value_gtk_menu_get_type_9=gtk_menu_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type_9);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenu *)return_value_g_type_check_instance_cast_10, ui_context_menu_exit);
  unsigned long int return_value_gtk_object_get_type_11;
  return_value_gtk_object_get_type_11=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu_launch, return_value_gtk_object_get_type_11);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_12, "activate", (void (*)(void))on_ui_context_menu_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_13;
  return_value_gtk_object_get_type_13=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu_show, return_value_gtk_object_get_type_13);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_14, "activate", (void (*)(void))on_ui_context_menu_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)1, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_15;
  return_value_gtk_object_get_type_15=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu_hide, return_value_gtk_object_get_type_15);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_16, "activate", (void (*)(void))on_ui_context_menu_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)2, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_17;
  return_value_gtk_object_get_type_17=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu_exit, return_value_gtk_object_get_type_17);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_18, "activate", (void (*)(void))on_ui_context_menu_activate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)3, (void (*)(void *))(void *)0, 0, 0);
}

// create_windows
// file gui_interface.h line 58
void create_windows(const char *host_tag, signed int instance_count)
{
  char tag[64l];
  unsigned long int return_value_strlen_8;
  return_value_strlen_8=strlen(host_tag);
  char *return_value_strstr_7;
  if(return_value_strlen_8 == 0ul)
    strcpy(tag, host_name_default);

  else
  {
    return_value_strstr_7=strstr(host_tag, host_name_default);
    if(!(return_value_strstr_7 == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(host_tag);
      if(return_value_strlen_2 >= 64ul)
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(host_tag);
        snprintf(tag, (unsigned long int)64, "...%s", (host_tag + (signed long int)return_value_strlen_1) - (signed long int)60);
      }

      else
        strcpy(tag, host_tag);
    }

    else
    {
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(host_name_default);
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(host_tag);
      if(return_value_strlen_5 + return_value_strlen_6 >= 63ul)
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(host_tag);
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(host_name_default);
        snprintf(tag, (unsigned long int)64, "%s ...%s", host_name_default, (host_tag + (signed long int)return_value_strlen_3 + (signed long int)return_value_strlen_4) - (signed long int)59);
      }

      else
        snprintf(tag, (unsigned long int)64, "%s %s", host_name_default, host_tag);
    }
  }
  create_main_window(tag, instance_count);
  create_ui_context_menu(main_window);
  create_file_selection(tag);
  create_about_window(tag);
  create_notice_window(tag);
}

// display_notice
// file gui_callbacks.c line 324
void display_notice(char *message1, char *message2)
{
  unsigned long int return_value_gtk_label_get_type_1;
  return_value_gtk_label_get_type_1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_1, return_value_gtk_label_get_type_1);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_2, message1);
  unsigned long int return_value_gtk_label_get_type_3;
  return_value_gtk_label_get_type_3=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)notice_label_2, return_value_gtk_label_get_type_3);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_4, message2);
  gtk_widget_show(notice_window);
}

// escape_for_shell
// file ghostess.c line 869
void escape_for_shell(char **p, const char *text)
{
  signed int len;
  signed int i;
  signed int c;
  if(!(*p == ((char *)NULL)))
    free((void *)*p);

  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(text == ((const char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strlen_2=strlen(text);
    len = (signed int)return_value_strlen_2;
    tmp_if_expr_3 = len == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    char *return_value___strdup_1;
    return_value___strdup_1=__strdup("''");
    *p = return_value___strdup_1;
    goto __CPROVER_DUMP_L17;
  }

  i = 0;
  c = 0;
  for( ; !(i >= len); i = i + 1)
    if((signed int)text[(signed long int)i] == 39)
      c = c + 1;

  if(c == 0)
  {
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)(len + 3));
    *p = (char *)return_value_malloc_4;
    sprintf(*p, "'%s'", text);
    goto __CPROVER_DUMP_L17;
  }

  void *return_value_malloc_5;
  return_value_malloc_5=malloc((unsigned long int)(len + c * 3 + 3));
  *p = (char *)return_value_malloc_5;
  c = 0;
  signed int tmp_post_6;
  if(!((signed int)*text == 39))
  {
    tmp_post_6 = c;
    c = c + 1;
    (*p)[(signed long int)tmp_post_6] = (char)39;
  }

  i = 0;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  signed int tmp_post_11;
  for( ; !(i >= len); i = i + 1)
    if((signed int)text[(signed long int)i] == 39)
    {
      if(!(i == 0))
      {
        tmp_post_7 = c;
        c = c + 1;
        (*p)[(signed long int)tmp_post_7] = (char)39;
      }

      tmp_post_8 = c;
      c = c + 1;
      (*p)[(signed long int)tmp_post_8] = (char)92;
      tmp_post_9 = c;
      c = c + 1;
      (*p)[(signed long int)tmp_post_9] = (char)39;
      if(!(i == len + -1))
      {
        tmp_post_10 = c;
        c = c + 1;
        (*p)[(signed long int)tmp_post_10] = (char)39;
      }

    }

    else
    {
      tmp_post_11 = c;
      c = c + 1;
      (*p)[(signed long int)tmp_post_11] = text[(signed long int)i];
    }
  signed int tmp_post_12;
  if(!((signed int)text[(signed long int)(len + -1)] == 39))
  {
    tmp_post_12 = c;
    c = c + 1;
    (*p)[(signed long int)tmp_post_12] = (char)39;
  }

  signed int tmp_post_13 = c;
  c = c + 1;
  (*p)[(signed long int)tmp_post_13] = (char)0;

__CPROVER_DUMP_L17:
  ;
}

// file_selection_set_path
// file gui_callbacks.c line 53
void file_selection_set_path(char *filename)
{
  unsigned long int return_value_strlen_8;
  if(!(filename == ((char *)NULL)))
  {
    unsigned long int return_value_gtk_file_selection_get_type_1;
    return_value_gtk_file_selection_get_type_1=gtk_file_selection_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type_1);
    gtk_file_selection_set_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast_2, filename);
  }

  else
    if(!(project_directory == ((char *)NULL)))
    {
      return_value_strlen_8=strlen(project_directory);
      if(!(return_value_strlen_8 == 0ul))
      {
        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen(project_directory);
        if(!((signed int)project_directory[-1l + (signed long int)return_value_strlen_7] == 47))
        {
          char *buffer;
          buffer=g_strdup_printf("%s/", project_directory);
          unsigned long int return_value_gtk_file_selection_get_type_3;
          return_value_gtk_file_selection_get_type_3=gtk_file_selection_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
          return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type_3);
          gtk_file_selection_set_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast_4, buffer);
          g_free((void *)buffer);
        }

        else
        {
          unsigned long int return_value_gtk_file_selection_get_type_5;
          return_value_gtk_file_selection_get_type_5=gtk_file_selection_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
          return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type_5);
          gtk_file_selection_set_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast_6, project_directory);
        }
      }

    }

}

// free_instance_template
// file ghostess.c line 779
static void free_instance_template(struct _instance_template_t *t)
{
  reset_instance_template(t);
  if(!(t->ports.allocated == 0ul))
  {
    free((void *)t->ports.set);
    free((void *)t->ports.value);
  }

  free((void *)t);
}

// free_programs
// file ghostess.c line 1312
void free_programs(struct _d3h_instance_t *instance)
{
  signed int i;
  if(!(instance->pluginPrograms == ((struct _DSSI_Program_Descriptor *)NULL)))
  {
    i = 0;
    for( ; !(i >= instance->pluginProgramCount); i = i + 1)
      free((void *)(instance->pluginPrograms + (signed long int)i)->Name);
    free((void *)(char *)instance->pluginPrograms);
  }

  instance->pluginProgramsValid = 0;
  instance->pluginProgramsAlloc = 0;
  instance->pluginProgramCount = 0;
  instance->pluginPrograms = (struct _DSSI_Program_Descriptor *)(void *)0;
}

// get_port_default
// file ghostess.c line 2346
float get_port_default(const struct _LADSPA_Descriptor *plugin, signed int port)
{
  float value;
  struct _LADSPA_PortRangeHint hint = plugin->PortRangeHints[(signed long int)port];
  float lower = hint.LowerBound * ((hint.HintDescriptor & 0x8) != 0 ? sample_rate : 1.0f);
  float upper = hint.UpperBound * ((hint.HintDescriptor & 0x8) != 0 ? sample_rate : 1.0f);
  if((0x3C0 & hint.HintDescriptor) == 0)
  {
    if((0x1 & hint.HintDescriptor) == 0 || (0x2 & hint.HintDescriptor) == 0)
      return 0.0f;

    if(lower <= 0.0f && upper >= 0.0f)
      return 0.0f;

    return lower;
  }

  else
  {
    if((0x3C0 & hint.HintDescriptor) == 0x200)
      return 0.0f;

    else
      if((0x3C0 & hint.HintDescriptor) == 0x240)
        return 1.0f;

      else
        if((0x3C0 & hint.HintDescriptor) == 0x280)
          return 100.0f;

        else
          if((0x3C0 & hint.HintDescriptor) == 0x2C0)
            return 440.0f;

    value = 0.0f;
    if(!((0x1 & hint.HintDescriptor) == 0))
    {
      if((0x3C0 & hint.HintDescriptor) == 0x40)
        value = lower;

    }

    if(!((0x2 & hint.HintDescriptor) == 0))
    {
      if((0x3C0 & hint.HintDescriptor) == 0x140)
        value = upper;

      if(!((0x1 & hint.HintDescriptor) == 0))
      {
        if(lower > 0.0f && upper > 0.0f && !((0x10 & hint.HintDescriptor) == 0))
        {
          if((0x3C0 & hint.HintDescriptor) == 0x80)
          {
            float return_value_logf_1;
            return_value_logf_1=logf(lower);
            float return_value_logf_2;
            return_value_logf_2=logf(upper);
            value=expf(return_value_logf_1 * 0.75f + return_value_logf_2 * 0.25f);
          }

          else
            if((0x3C0 & hint.HintDescriptor) == 0xC0)
            {
              float return_value_logf_3;
              return_value_logf_3=logf(lower);
              float return_value_logf_4;
              return_value_logf_4=logf(upper);
              value=expf(return_value_logf_3 * 0.5f + return_value_logf_4 * 0.5f);
            }

            else
              if((0x3C0 & hint.HintDescriptor) == 0x100)
              {
                float return_value_logf_5;
                return_value_logf_5=logf(lower);
                float return_value_logf_6;
                return_value_logf_6=logf(upper);
                value=expf(return_value_logf_5 * 0.25f + return_value_logf_6 * 0.75f);
              }

        }

        else
          if((0x3C0 & hint.HintDescriptor) == 0x80)
            value = lower * 0.75f + upper * 0.25f;

          else
            if((0x3C0 & hint.HintDescriptor) == 0xC0)
              value = lower * 0.5f + upper * 0.5f;

            else
              if((0x3C0 & hint.HintDescriptor) == 0x100)
                value = lower * 0.25f + upper * 0.75f;

      }

    }

    if(!((0x20 & hint.HintDescriptor) == 0))
    {
      signed long int return_value_lrintf_7;
      return_value_lrintf_7=lrintf(value);
      value = (float)return_value_lrintf_7;
    }

    return value;
  }
}

// getarg
// file getarg.h line 31
char * getarg(void)
{
  char *arg;
  _Bool tmp_if_expr_3;
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_4;
  signed int return_value_getarg_push_file_6;
  do
  {

  again:
    ;
    arg=getarg_internal();
    if(arg == ((char *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_2;
      return_value___builtin_strcmp_2=__builtin_strcmp(arg, "-f");
      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
      tmp_if_expr_3 = tmp_statement_expression_1 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return arg;

    arg=getarg_internal();
    if(arg == ((char *)NULL))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strlen_4=strlen(arg);
      tmp_if_expr_5 = !(return_value_strlen_4 != 0ul) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      getarg_error = "configuration file name expected after '-f'";
      return (char *)(void *)0;
    }

    return_value_getarg_push_file_6=getarg_push_file(arg);
  }
  while(!(return_value_getarg_push_file_6 == 0));
  return (char *)(void *)0;
}

// getarg_cleanup
// file getarg.h line 28
void getarg_cleanup(void)
{
  while(!(state_list == ((struct _getarg_state *)NULL)))
    getarg_pop_state();
}

// getarg_init_with_command_line
// file getarg.h line 29
void getarg_init_with_command_line(signed int argc, char **argv)
{
  struct _getarg_state *state;
  getarg_cleanup();
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _getarg_state) /*40ul*/ );
  state = (struct _getarg_state *)return_value_calloc_1;
  state->up = (struct _getarg_state *)(void *)0;
  state->is_file = 0;
  state->state.argv.argc = argc;
  state->state.argv.argv = argv;
  state->state.argv.next_arg = 0;
  state_list = state;
  void *return_value_malloc_2;
  if(argbuf == ((char *)NULL))
  {
    return_value_malloc_2=malloc((unsigned long int)(32767 + 1));
    argbuf = (char *)return_value_malloc_2;
  }

  getarg_error = (char *)(void *)0;
}

// getarg_init_with_file
// file getarg.c line 152
signed int getarg_init_with_file(char *filename)
{
  getarg_cleanup();
  getarg_error = (char *)(void *)0;
  signed int return_value_getarg_push_file_1;
  return_value_getarg_push_file_1=getarg_push_file(filename);
  return return_value_getarg_push_file_1;
}

// getarg_internal
// file getarg.c line 268
static char * getarg_internal(void)
{
  struct _getarg_state *state;
  char *arg;
  do
  {

  again:
    ;
    state = state_list;
    if(state == ((struct _getarg_state *)NULL))
      return (char *)(void *)0;

    if(!(state->is_file == 0))
    {
      signed int return_value_getarg_read_file_arg_1;
      return_value_getarg_read_file_arg_1=getarg_read_file_arg(state);
      if(!(return_value_getarg_read_file_arg_1 == 0))
        return argbuf;

      else
        if(!(getarg_error == ((char *)NULL)))
          return (char *)(void *)0;

        else
        {
          getarg_pop_state();
          goto again;
        }
    }

    if(!(state->state.argv.next_arg >= state->state.argv.argc))
    {
      arg = state->state.argv.argv[(signed long int)state->state.argv.next_arg];
      state->state.argv.next_arg = state->state.argv.next_arg + 1;
      return arg;
    }

    getarg_pop_state();
  }
  while((_Bool)1);
}

// getarg_pop_state
// file getarg.c line 58
static void getarg_pop_state(void)
{
  struct _getarg_state *state;
  if(!(state_list == ((struct _getarg_state *)NULL)))
  {
    state = state_list;
    state_list = state->up;
    if(!(state->is_file == 0))
    {
      free((void *)state->state.file.filename);
      fclose(state->state.file.fh);
    }

    free((void *)state);
  }

  if(state_list == ((struct _getarg_state *)NULL) && !(argbuf == ((char *)NULL)))
  {
    free((void *)argbuf);
    argbuf = (char *)(void *)0;
  }

}

// getarg_print_possible_error
// file getarg.h line 27
void getarg_print_possible_error(void)
{
  if(!(getarg_error == ((char *)NULL)))
    ghss_debug(1, " configuration error: %s", getarg_error);

}

// getarg_push_file
// file getarg.c line 119
static signed int getarg_push_file(char *filename)
{
  struct _getarg_state *state;
  char *fn;
  char *return_value___strdup_1;
  return_value___strdup_1=__strdup(filename);
  fn = return_value___strdup_1;
  struct _IO_FILE *fh;
  fh=fopen(filename, "r");
  if(fh == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    snprintf(argbuf, (unsigned long int)2048, "could not open configuration file '%s': %s", fn, return_value_strerror_3);
    getarg_error = argbuf;
    free((void *)fn);
    return 0;
  }

  void *return_value_calloc_4;
  return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct _getarg_state) /*40ul*/ );
  state = (struct _getarg_state *)return_value_calloc_4;
  state->up = state_list;
  state->is_file = 1;
  state->state.file.filename = fn;
  state->state.file.fh = fh;
  state->state.file.next = (signed long int)0;
  state_list = state;
  void *return_value_malloc_5;
  if(argbuf == ((char *)NULL))
  {
    return_value_malloc_5=malloc((unsigned long int)(32767 + 1));
    argbuf = (char *)return_value_malloc_5;
  }

  return 1;
}

// getarg_read_file_arg
// file getarg.c line 164
static signed int getarg_read_file_arg(struct _getarg_state *state)
{
  char c;
  signed int len;
  signed int done;
  signed int parse_state;
  signed int return_value_fseek_3;
  return_value_fseek_3=fseek(state->state.file.fh, state->state.file.next, 0);
  if(!(return_value_fseek_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    snprintf(argbuf, (unsigned long int)2048, "seek error on configuration file '%s': %s", state->state.file.filename, return_value_strerror_2);
    getarg_error = argbuf;
    return 0;
  }

  parse_state = 0;
  done = parse_state;
  len = done;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  signed int tmp_post_11;
  signed int tmp_post_12;
  while(done == 0)
  {
    if(len >= 32767)
    {
      snprintf(argbuf, (unsigned long int)2048, "argument too long reading configuration file '%s'", state->state.file.filename);
      getarg_error = argbuf;
      return 0;
    }

    signed int return_value_fgetc_4;
    return_value_fgetc_4=fgetc(state->state.file.fh);
    c = (char)return_value_fgetc_4;
    if((signed int)c == -1)
    {
      signed int return_value_ferror_7;
      return_value_ferror_7=ferror(state->state.file.fh);
      if(!(return_value_ferror_7 == 0))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        char *return_value_strerror_6;
        return_value_strerror_6=strerror(*return_value___errno_location_5);
        snprintf(argbuf, (unsigned long int)2048, "error reading configuration file '%s': %s", state->state.file.filename, return_value_strerror_6);
        getarg_error = argbuf;
        return 0;
      }

      else
      {
        if(!(len == 0))
          break;

        return 0;
      }
    }

    state->state.file.next = state->state.file.next + 1l;
    switch(parse_state)
    {
      case 0:
      {
        if((signed int)c == 92)
        {
          parse_state = 1;
          goto __CPROVER_DUMP_L22;
        }

        else
          if((signed int)c == 9 || (signed int)c == 10 || (signed int)c == 32)
            goto __CPROVER_DUMP_L22;

          else
            if((signed int)c == 39)
            {
              parse_state = 3;
              goto __CPROVER_DUMP_L22;
            }

        parse_state = 2;
        tmp_post_8 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post_8] = c;
        break;
      }
      case 1:
      {
        if((signed int)c == 9 || (signed int)c == 10 || (signed int)c == 32)
        {
          parse_state = 0;
          goto __CPROVER_DUMP_L22;
        }

        parse_state = 2;
        tmp_post_9 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post_9] = c;
        break;
      }
      case 2:
      {
        if((signed int)c == 9 || (signed int)c == 10 || (signed int)c == 32)
        {
          done = 1;
          break;
        }

        else
          if((signed int)c == 92)
          {
            parse_state = 4;
            goto __CPROVER_DUMP_L22;
          }

          else
            if((signed int)c == 39)
            {
              parse_state = 3;
              goto __CPROVER_DUMP_L22;
            }

        tmp_post_10 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post_10] = c;
        break;
      }
      case 3:
      {
        if((signed int)c == 39)
        {
          parse_state = 2;
          goto __CPROVER_DUMP_L22;
        }

        tmp_post_11 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post_11] = c;
        break;
      }
      case 4:
      {
        parse_state = 2;
        tmp_post_12 = len;
        len = len + 1;
        argbuf[(signed long int)tmp_post_12] = c;
      }
    }

  __CPROVER_DUMP_L22:
    ;
  }
  argbuf[(signed long int)len] = (char)0;
  return 1;
}

// ghss_debug
// file ghostess.c line 154
void ghss_debug(signed int type, const char *format, ...)
{
  void **args = (void **)&format;
  if(!((debug_flags & type) == 0))
  {
    fputs(host_name, stderr);
    vfprintf(stderr, format, args);
    fputs("\n", stderr);
  }

  args = ((void **)NULL);
}

// gtk_timeout_callback
// file ghostess.c line 1328
signed int gtk_timeout_callback(void *data)
{
  signed int i;
  struct _d3h_instance_t *instance;
  i = 0;
  for( ; !(i >= instance_count); i = i + 1)
  {
    instance = &instances[(signed long int)i];
    if(!(instance->uiNeedsProgramUpdate == 0))
    {
      if(!(instance->pendingProgramChange >= 0))
      {
        signed int bank = (signed int)instance->currentBank;
        signed int program = (signed int)instance->currentProgram;
        instance->uiNeedsProgramUpdate = 0;
        if(!(instance->ui_osc_address == NULL))
          lo_send_internal(instance->ui_osc_address, "ghostess.c", 1344, instance->ui_osc_program_path, "ii", bank, program, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

      }

    }

  }
  i = 0;
  for( ; !(i >= controlInsTotal); i = i + 1)
    if(!(pluginPortUpdated[(signed long int)i] == 0))
    {
      signed int port = (signed int)pluginControlInPortNumbers[(signed long int)i];
      float value = pluginControlIns[(signed long int)i];
      instance = pluginControlInInstances[(signed long int)i];
      pluginPortUpdated[(signed long int)i] = 0;
      if(!(instance->ui_osc_address == NULL))
        lo_send_internal(instance->ui_osc_address, "ghostess.c", 1356, instance->ui_osc_control_path, "if", port, value, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

    }

  i = 0;
  for( ; !(i >= instance_count); i = i + 1)
    update_eyecandy(&instances[(signed long int)i]);
  main_timeout_tick = main_timeout_tick + 1;
  if(!(host_exiting == 0))
  {
    gtk_main_quit();
    return 0;
  }

  else
    return (signed int)!(0 != 0);
}

// instance_sort_cmp
// file ghostess.c line 1042
static signed int instance_sort_cmp(const void *a, const void *b)
{
  struct _d3h_instance_t *ia = (struct _d3h_instance_t *)a;
  struct _d3h_instance_t *ib = (struct _d3h_instance_t *)b;
  if(!(ia->plugin->number == ib->plugin->number))
    return ia->plugin->number - ib->plugin->number;

  else
    return ia->id - ib->id;
}

// instance_template_set_port
// file ghostess.c line 790
static void instance_template_set_port(struct _instance_template_t *t, unsigned long int port, float value)
{
  unsigned long int n;
  if(port >= t->ports.allocated)
  {
    n = (unsigned long int)256;
    for( ; port >= n; n = n << 1)
      ;
    if(!(t->ports.allocated == 0ul))
    {
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)t->ports.set, sizeof(signed int) /*4ul*/  * n);
      t->ports.set = (signed int *)return_value_realloc_1;
      memset((void *)&t->ports.set[(signed long int)t->ports.allocated], 0, sizeof(signed int) /*4ul*/  * (n - t->ports.allocated));
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)t->ports.value, sizeof(float) /*4ul*/  * n);
      t->ports.value = (float *)return_value_realloc_2;
    }

    else
    {
      void *return_value_calloc_3;
      return_value_calloc_3=calloc(sizeof(signed int) /*4ul*/ , n);
      t->ports.set = (signed int *)return_value_calloc_3;
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(sizeof(float) /*4ul*/  * n);
      t->ports.value = (float *)return_value_malloc_4;
    }
    t->ports.allocated = n;
  }

  t->ports.have_settings = 1;
  if(!(t->ports.highest_set >= port))
    t->ports.highest_set = port;

  t->ports.set[(signed long int)port] = 1;
  t->ports.value[(signed long int)port] = value;
}

// load
// file ghostess.c line 668
char * load(const char *dllName, void **dll)
{
  char *path;
  char *origPath;
  char *element;
  char *filePath;
  const char *message;
  *dll = NULL;
  char *return_value_strrchr_2;
  if((signed int)*dllName == 47)
  {
    *dll=dlopen(dllName, 0x00002 | 0);
    if(!(*dll == NULL))
    {
      char *return_value___strdup_1;
      return_value___strdup_1=__strdup(dllName);
      path = return_value___strdup_1;
      char *return_value_strrchr_3;
      return_value_strrchr_3=strrchr(dllName, 47);
      if(return_value_strrchr_3 == dllName)
        path[(signed long int)1] = (char)0;

      else
      {
        return_value_strrchr_2=strrchr(path, 47);
        *return_value_strrchr_2 = (char)0;
      }
      return path;
    }

    message=dlerror();
    if(!(message == ((const char *)NULL)))
      ghss_debug(8, ": dlopen of '%s' failed: %s", dllName, message);

    else
      ghss_debug(8, ": dlopen of '%s' failed", dllName);
    return (char *)(void *)0;
  }

  else
  {
    if(dssi_path == ((char *)NULL))
    {
      dssi_path=getenv("DSSI_PATH");
      if(dssi_path == ((char *)NULL))
      {
        dssi_path = "/usr/local/lib/dssi:/usr/lib/dssi";
        ghss_debug(8, " warning: DSSI_PATH not set, defaulting to '%s'", dssi_path);
      }

    }

    char *return_value___strdup_4;
    return_value___strdup_4=__strdup(dssi_path);
    path = return_value___strdup_4;
    origPath = path;
    do
    {
      element=strtok(path, ":");
      if(element == ((char *)NULL))
        break;

      path = ((char *)NULL);
      if(!((signed int)*element == 47))
        ghss_debug(8, ": ignoring DSSI_PATH relative element '%s'", element);

      else
      {
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(element);
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(dllName);
        void *return_value_malloc_7;
        return_value_malloc_7=malloc(return_value_strlen_5 + return_value_strlen_6 + (unsigned long int)2);
        filePath = (char *)return_value_malloc_7;
        sprintf(filePath, "%s/%s", element, dllName);
        *dll=dlopen(filePath, 0x00002 | 0);
        if(!(*dll == NULL))
        {
          ghss_debug(8, ": '%s' found at '%s'", dllName, filePath);
          free((void *)filePath);
          char *return_value___strdup_8;
          return_value___strdup_8=__strdup(element);
          path = return_value___strdup_8;
          free((void *)origPath);
          return path;
        }

        message=dlerror();
        if(!(message == ((const char *)NULL)))
          ghss_debug(8, ": dlopen of '%s' failed: %s", filePath, message);

        else
          ghss_debug(8, ": dlopen of '%s' failed", filePath);
        free((void *)filePath);
      }
    }
    while((_Bool)1);
    free((void *)origPath);
    return (char *)(void *)0;
  }
}

// main
// file ghostess.c line 1375
signed int main(signed int argc, char **argv)
{
  signed int gtk_timeout_tag;
  struct _d3h_dll_t *dll;
  struct _d3h_plugin_t *plugin;
  struct _instance_template_t *itemplate;
  struct _d3h_instance_t *instance;
  void *pluginObject;
  char *dllName;
  char *label;
  const char **ports;
  char *tmp;
  char *arg0;
  char *arg1;
  signed int i;
  signed int reps;
  signed int j;
  signed int in;
  signed int out;
  signed int controlIn;
  signed int controlOut;
  enum JackStatus status;
  gtk_init(&argc, &argv);
  setsid();
  sigemptyset(&_signals);
  sigaddset(&_signals, 1);
  sigaddset(&_signals, 2);
  sigaddset(&_signals, 3);
  sigaddset(&_signals, 13);
  sigaddset(&_signals, 15);
  sigaddset(&_signals, 10);
  sigaddset(&_signals, 12);
  pthread_sigmask(0, &_signals, ((struct anonymous_18 *)NULL));
  host_name = host_name_default;
  controlOutsTotal = 0;
  controlInsTotal = controlOutsTotal;
  outsTotal = controlInsTotal;
  insTotal = outsTotal;
  signed int tmp_statement_expression_3;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  signed int tmp_statement_expression_8;
  _Bool tmp_if_expr_6;
  unsigned long int return_value_strlen_5;
  signed int tmp_statement_expression_13;
  _Bool tmp_if_expr_17;
  signed int tmp_statement_expression_15;
  _Bool tmp_if_expr_11;
  unsigned long int return_value_strlen_10;
  signed int tmp_statement_expression_21;
  _Bool tmp_if_expr_19;
  unsigned long int return_value_strlen_18;
  signed int tmp_statement_expression_23;
  _Bool tmp_if_expr_27;
  signed int tmp_statement_expression_25;
  unsigned long int return_value_strlen_29;
  signed int tmp_statement_expression_35;
  _Bool tmp_if_expr_31;
  unsigned long int return_value_strlen_30;
  _Bool tmp_if_expr_33;
  _Bool tmp_if_expr_34;
  signed int tmp_statement_expression_40;
  _Bool tmp_if_expr_38;
  unsigned long int return_value_strlen_37;
  signed int tmp_statement_expression_47;
  _Bool tmp_if_expr_43;
  unsigned long int return_value_strlen_42;
  _Bool tmp_if_expr_46;
  unsigned long int return_value_strlen_45;
  signed int tmp_statement_expression_55;
  _Bool tmp_if_expr_50;
  unsigned long int return_value_strlen_49;
  _Bool tmp_if_expr_53;
  unsigned long int return_value_strlen_52;
  signed int tmp_statement_expression_57;
  signed int tmp_statement_expression_65;
  signed int tmp_statement_expression_63;
  signed int tmp_statement_expression_67;
  signed int tmp_statement_expression_70;
  signed int tmp_post_75;
  _Bool tmp_if_expr_78;
  signed int tmp_statement_expression_76;
  signed int tmp_post_80;
  _Bool tmp_if_expr_83;
  signed int tmp_statement_expression_81;
  char *tmp_if_expr_84;
  _Bool tmp_if_expr_96;
  unsigned long int return_value_strlen_94;
  signed int return_value_strcasecmp_95;
  signed int tmp_post_118;
  signed int tmp_post_119;
  signed int tmp_post_120;
  signed int tmp_post_121;
  if(!(argc >= 2))
  {
    fprintf(stderr, "%s %s\n", host_name, (const void *)"20120105");
    fprintf(stderr, "Copyright (C) 2006-2012 Sean Bolton and others.\n");
    fprintf(stderr, "%s comes with ABSOLUTELY NO WARRANTY. This is free software, and you are\n", host_name);
    fprintf(stderr, "welcome to redistribute it under certain conditions; see the file COPYING for details.\n");
    fprintf(stderr, "Usage: %s [-debug <level>] [-hostname <hostname>] [-projdir <projdir>] [-uuid <uuid>] [-noauto] [-f <cfgfile>]\n", argv[(signed long int)0]);
    fprintf(stderr, "       [-<n>] [-chan <c>] [-conf <k> <v>] [-prog <b> <p>] [-port <p> <f>] <soname>[:<label>] [...]\n\n");
    fprintf(stderr, "  <level>    Debug information flags, bitfield, 1 = errors only, -1 = all\n");
    fprintf(stderr, "  <hostname> JACK and ALSA client name to use, default \"ghostess\"\n");
    fprintf(stderr, "  <projdir>  DSSI project directory, default none\n");
    fprintf(stderr, "  <uuid>     JACK session management UUID, default none\n");
    fprintf(stderr, "  <cfgfile>  File containing more configuration; same format as command line\n");
    fprintf(stderr, "  <n>        Number of instances of the following plugin to create, default 1\n");
    fprintf(stderr, "  <c>        MIDI channel for following instance, numbered from 0\n");
    fprintf(stderr, "  <k> <v>    Configure item key and value for following instance (repeatable for different keys)\n");
    fprintf(stderr, "  <b> <p>    Bank and program number for following instance\n");
    fprintf(stderr, "  <p> <f>    Port number and value for following instance (repeatable for different ports)\n");
    fprintf(stderr, "  <soname>   Name of DSSI plugin library (*.so) to load\n");
    fprintf(stderr, "  <label>    Name of DSSI plugin within library to instantiate, default first\n");
    return 2;
  }

  else
  {
    host_argv0 = argv[(signed long int)0];
    ghss_debug(1, ": ghostess starting...");
    getarg_init_with_command_line(argc - 1, &argv[(signed long int)1]);
    itemplate=new_instance_template();
    reps = 1;
    do
    {
      arg0=getarg();
      if(arg0 == ((char *)NULL))
        break;

      unsigned long int main__1__2__1____s1_len;
      unsigned long int main__1__2__1____s2_len;
      signed int return_value___builtin_strcmp_4;
      return_value___builtin_strcmp_4=__builtin_strcmp(arg0, "-debug");
      tmp_statement_expression_3 = return_value___builtin_strcmp_4;
      if(tmp_statement_expression_3 == 0)
      {
        arg0=getarg();
        if(arg0 == ((char *)NULL))
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          return_value_strlen_1=strlen(arg0);
          tmp_if_expr_2 = !(return_value_strlen_1 != 0ul) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
        {
          getarg_print_possible_error();
          ghss_debug(1, ": debug level expected after '-debug'");
          return 2;
        }

        debug_flags=atoi(arg0);
        ghss_debug(2, ": debug level now %08x", debug_flags);
        continue;
      }

      unsigned long int main__1__2__3____s1_len;
      unsigned long int main__1__2__3____s2_len;
      signed int return_value___builtin_strcmp_9;
      return_value___builtin_strcmp_9=__builtin_strcmp(arg0, "-hostname");
      tmp_statement_expression_8 = return_value___builtin_strcmp_9;
      if(tmp_statement_expression_8 == 0)
      {
        arg0=getarg();
        if(arg0 == ((char *)NULL))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_strlen_5=strlen(arg0);
          tmp_if_expr_6 = !(return_value_strlen_5 != 0ul) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
        {
          getarg_print_possible_error();
          ghss_debug(1, ": host name base expected after '-hostname'");
          return 2;
        }

        if(!(host_name == host_name_default))
          free((void *)host_name);

        char *return_value___strdup_7;
        return_value___strdup_7=__strdup(arg0);
        host_name = return_value___strdup_7;
        continue;
      }

      unsigned long int main__1__2__5____s1_len;
      unsigned long int main__1__2__5____s2_len;
      signed int return_value___builtin_strcmp_14;
      return_value___builtin_strcmp_14=__builtin_strcmp(arg0, "-projdir");
      tmp_statement_expression_13 = return_value___builtin_strcmp_14;
      if(tmp_statement_expression_13 == 0)
        tmp_if_expr_17 = (_Bool)1;

      else
      {
        unsigned long int main__1__2__6____s1_len;
        unsigned long int main__1__2__6____s2_len;
        signed int return_value___builtin_strcmp_16;
        return_value___builtin_strcmp_16=__builtin_strcmp(arg0, "-p");
        tmp_statement_expression_15 = return_value___builtin_strcmp_16;
        tmp_if_expr_17 = !(tmp_statement_expression_15 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_17)
      {
        arg0=getarg();
        if(arg0 == ((char *)NULL))
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          return_value_strlen_10=strlen(arg0);
          tmp_if_expr_11 = !(return_value_strlen_10 != 0ul) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_11)
        {
          getarg_print_possible_error();
          ghss_debug(1, ": project directory expected after '-projdir'");
          return 2;
        }

        if(!(project_directory == ((char *)NULL)))
          free((void *)project_directory);

        char *return_value___strdup_12;
        return_value___strdup_12=__strdup(arg0);
        project_directory = return_value___strdup_12;
        continue;
      }

      unsigned long int main__1__2__8____s1_len;
      unsigned long int main__1__2__8____s2_len;
      signed int return_value___builtin_strcmp_22;
      return_value___builtin_strcmp_22=__builtin_strcmp(arg0, "-uuid");
      tmp_statement_expression_21 = return_value___builtin_strcmp_22;
      if(tmp_statement_expression_21 == 0)
      {
        arg0=getarg();
        if(arg0 == ((char *)NULL))
          tmp_if_expr_19 = (_Bool)1;

        else
        {
          return_value_strlen_18=strlen(arg0);
          tmp_if_expr_19 = !(return_value_strlen_18 != 0ul) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_19)
        {
          getarg_print_possible_error();
          ghss_debug(1, ": uuid expected after '-uuid'");
          return 2;
        }

        if(!(jack_session_uuid == ((char *)NULL)))
          free((void *)jack_session_uuid);

        char *return_value___strdup_20;
        return_value___strdup_20=__strdup(arg0);
        jack_session_uuid = return_value___strdup_20;
        continue;
      }

      unsigned long int main__1__2__10____s1_len;
      unsigned long int main__1__2__10____s2_len;
      signed int return_value___builtin_strcmp_24;
      return_value___builtin_strcmp_24=__builtin_strcmp(arg0, "-noauto");
      tmp_statement_expression_23 = return_value___builtin_strcmp_24;
      if(tmp_statement_expression_23 == 0)
        tmp_if_expr_27 = (_Bool)1;

      else
      {
        unsigned long int main__1__2__11____s1_len;
        unsigned long int main__1__2__11____s2_len;
        signed int return_value___builtin_strcmp_26;
        return_value___builtin_strcmp_26=__builtin_strcmp(arg0, "-c");
        tmp_statement_expression_25 = return_value___builtin_strcmp_26;
        tmp_if_expr_27 = !(tmp_statement_expression_25 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_27)
        autoconnect = 0;

      else
      {
        if(instance_count >= 32)
        {
          ghss_debug(1, ": too many plugin instances specified (limit is %d)", 32);
          return 2;
        }

        if((signed int)*arg0 == 45)
        {
          return_value_strlen_29=strlen(arg0);
          if(return_value_strlen_29 >= 2ul)
          {
            signed long int return_value_strtol_28;
            return_value_strtol_28=strtol(&arg0[(signed long int)1], &tmp, 10);
            j = (signed int)return_value_strtol_28;
            if((signed int)*tmp == 0)
            {
              if(j >= 1)
              {
                reps = j;
                continue;
              }

            }

          }

        }

        unsigned long int main__1__2__15____s1_len;
        unsigned long int main__1__2__15____s2_len;
        signed int return_value___builtin_strcmp_36;
        return_value___builtin_strcmp_36=__builtin_strcmp(arg0, "-chan");
        tmp_statement_expression_35 = return_value___builtin_strcmp_36;
        if(tmp_statement_expression_35 == 0)
        {
          arg0=getarg();
          if(arg0 == ((char *)NULL))
            tmp_if_expr_31 = (_Bool)1;

          else
          {
            return_value_strlen_30=strlen(arg0);
            tmp_if_expr_31 = !(return_value_strlen_30 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_31)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": MIDI channel expected after '-chan'");
            return 2;
          }

          signed long int return_value_strtol_32;
          return_value_strtol_32=strtol(arg0, &tmp, 10);
          itemplate->channel = (signed int)return_value_strtol_32;
          if(!((signed int)*tmp == 0))
            tmp_if_expr_33 = (_Bool)1;

          else
            tmp_if_expr_33 = itemplate->channel < 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_33)
            tmp_if_expr_34 = (_Bool)1;

          else
            tmp_if_expr_34 = itemplate->channel > 15 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_34)
          {
            ghss_debug(1, ": bad MIDI channel '%s'", arg0);
            return 2;
          }

          continue;
        }

        unsigned long int main__1__2__17____s1_len;
        unsigned long int main__1__2__17____s2_len;
        signed int return_value___builtin_strcmp_41;
        return_value___builtin_strcmp_41=__builtin_strcmp(arg0, "-conf");
        tmp_statement_expression_40 = return_value___builtin_strcmp_41;
        if(tmp_statement_expression_40 == 0)
        {
          arg0=getarg();
          if(arg0 == ((char *)NULL))
            tmp_if_expr_38 = (_Bool)1;

          else
          {
            return_value_strlen_37=strlen(arg0);
            tmp_if_expr_38 = !(return_value_strlen_37 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_38)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": key and value expected after '-conf'");
            return 2;
          }

          char *return_value___strdup_39;
          return_value___strdup_39=__strdup(arg0);
          arg0 = return_value___strdup_39;
          arg1=getarg();
          if(arg1 == ((char *)NULL))
          {
            getarg_print_possible_error();
            ghss_debug(1, ": key and value expected after '-conf'");
            free((void *)arg0);
            return 2;
          }

          add_configure_item(&itemplate->configure_items, arg0, arg1);
          free((void *)arg0);
          continue;
        }

        unsigned long int main__1__2__19____s1_len;
        unsigned long int main__1__2__19____s2_len;
        signed int return_value___builtin_strcmp_48;
        return_value___builtin_strcmp_48=__builtin_strcmp(arg0, "-prog");
        tmp_statement_expression_47 = return_value___builtin_strcmp_48;
        if(tmp_statement_expression_47 == 0)
        {
          arg0=getarg();
          if(arg0 == ((char *)NULL))
            tmp_if_expr_43 = (_Bool)1;

          else
          {
            return_value_strlen_42=strlen(arg0);
            tmp_if_expr_43 = !(return_value_strlen_42 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_43)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": bank and program number expected after '-prog'");
            return 2;
          }

          char *return_value___strdup_44;
          return_value___strdup_44=__strdup(arg0);
          arg0 = return_value___strdup_44;
          arg1=getarg();
          if(arg1 == ((char *)NULL))
            tmp_if_expr_46 = (_Bool)1;

          else
          {
            return_value_strlen_45=strlen(arg1);
            tmp_if_expr_46 = !(return_value_strlen_45 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_46)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": bank and program number expected after '-prog'");
            free((void *)arg0);
            return 2;
          }

          itemplate->bank=strtoul(arg0, &tmp, 10);
          if(!((signed int)*tmp == 0))
          {
            ghss_debug(1, ": bad bank number '%s'", arg0);
            free((void *)arg0);
            return 2;
          }

          free((void *)arg0);
          itemplate->program=strtoul(arg1, &tmp, 10);
          if(!((signed int)*tmp == 0))
          {
            ghss_debug(1, ": bad program number '%s'", arg1);
            return 2;
          }

          itemplate->program_set = 1;
          continue;
        }

        unsigned long int main__1__2__21____s1_len;
        unsigned long int main__1__2__21____s2_len;
        signed int return_value___builtin_strcmp_56;
        return_value___builtin_strcmp_56=__builtin_strcmp(arg0, "-port");
        tmp_statement_expression_55 = return_value___builtin_strcmp_56;
        if(tmp_statement_expression_55 == 0)
        {
          unsigned long int port;
          float value;
          arg0=getarg();
          if(arg0 == ((char *)NULL))
            tmp_if_expr_50 = (_Bool)1;

          else
          {
            return_value_strlen_49=strlen(arg0);
            tmp_if_expr_50 = !(return_value_strlen_49 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_50)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": port number and value expected after '-port'");
            return 2;
          }

          char *return_value___strdup_51;
          return_value___strdup_51=__strdup(arg0);
          arg0 = return_value___strdup_51;
          arg1=getarg();
          if(arg1 == ((char *)NULL))
            tmp_if_expr_53 = (_Bool)1;

          else
          {
            return_value_strlen_52=strlen(arg1);
            tmp_if_expr_53 = !(return_value_strlen_52 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_53)
          {
            getarg_print_possible_error();
            ghss_debug(1, ": port number and value expected after '-port'");
            free((void *)arg0);
            return 2;
          }

          port=strtoul(arg0, &tmp, 10);
          if(!((signed int)*tmp == 0))
          {
            ghss_debug(1, ": bad port number '%s'", arg0);
            free((void *)arg0);
            return 2;
          }

          free((void *)arg0);
          double return_value_g_strtod_54;
          return_value_g_strtod_54=g_strtod(arg1, &tmp);
          value = (float)return_value_g_strtod_54;
          if(!((signed int)*tmp == 0))
          {
            ghss_debug(1, ": bad port value '%s'", arg1);
            return 2;
          }

          instance_template_set_port(itemplate, port, value);
          continue;
        }

        unsigned long int main__1__2__23____s1_len;
        unsigned long int main__1__2__23____s2_len;
        signed int return_value___builtin_strcmp_58;
        return_value___builtin_strcmp_58=__builtin_strcmp(arg0, "-comment");
        tmp_statement_expression_57 = return_value___builtin_strcmp_58;
        if(tmp_statement_expression_57 == 0)
        {
          arg0=getarg();
          if(arg0 == ((char *)NULL))
          {
            getarg_print_possible_error();
            ghss_debug(1, ": comment expected after '-comment'");
            return 2;
          }

        }

        else
        {
          char *return_value___builtin_strchr_59;
          return_value___builtin_strchr_59=__builtin_strchr(arg0, 58);
          tmp = return_value___builtin_strchr_59;
          if(!(tmp == ((char *)NULL)))
          {
            void *return_value_calloc_60;
            return_value_calloc_60=calloc((unsigned long int)1, (unsigned long int)((tmp - arg0) + (signed long int)1));
            dllName = (char *)return_value_calloc_60;
            __builtin_strncpy(dllName, arg0, (unsigned long int)(tmp - arg0));
            char *return_value___strdup_61;
            return_value___strdup_61=__strdup(tmp + (signed long int)1);
            label = return_value___strdup_61;
          }

          else
          {
            char *return_value___strdup_62;
            return_value___strdup_62=__strdup(arg0);
            dllName = return_value___strdup_62;
            label = (char *)(void *)0;
          }
          plugin = plugins;
          for( ; !(plugin == ((struct _d3h_plugin_t *)NULL)); plugin = plugin->next)
            if(!(label == ((char *)NULL)))
            {
              unsigned long int main__1__2__27__1__1__1____s1_len;
              unsigned long int main__1__2__27__1__1__1____s2_len;
              signed int return_value___builtin_strcmp_66;
              return_value___builtin_strcmp_66=__builtin_strcmp(dllName, plugin->dll->name);
              tmp_statement_expression_65 = return_value___builtin_strcmp_66;
              if(tmp_statement_expression_65 == 0)
              {
                unsigned long int main__1__2__27__1__1__2____s1_len;
                unsigned long int main__1__2__27__1__1__2____s2_len;
                signed int return_value___builtin_strcmp_64;
                return_value___builtin_strcmp_64=__builtin_strcmp(label, plugin->label);
                tmp_statement_expression_63 = return_value___builtin_strcmp_64;
                if(tmp_statement_expression_63 == 0)
                  break;

              }

            }

            else
            {
              unsigned long int main__1__2__27__1__2__1____s1_len;
              unsigned long int main__1__2__27__1__2__1____s2_len;
              signed int return_value___builtin_strcmp_68;
              return_value___builtin_strcmp_68=__builtin_strcmp(dllName, plugin->dll->name);
              tmp_statement_expression_67 = return_value___builtin_strcmp_68;
              if(tmp_statement_expression_67 == 0)
              {
                if(!(plugin->is_first_in_dll == 0))
                  break;

              }

            }
          if(!(plugin == ((struct _d3h_plugin_t *)NULL)))
          {
            free((void *)dllName);
            free((void *)label);
          }

          else
          {
            void *return_value_calloc_69;
            return_value_calloc_69=calloc((unsigned long int)1, sizeof(struct _d3h_plugin_t) /*72ul*/ );
            plugin = (struct _d3h_plugin_t *)return_value_calloc_69;
            plugin->number = plugin_count;
            plugin->label = label;
            dll = dlls;
            for( ; !(dll == ((struct _d3h_dll_t *)NULL)); dll = dll->next)
            {
              unsigned long int main__1__2__29__1__1__1____s1_len;
              unsigned long int main__1__2__29__1__1__1____s2_len;
              signed int return_value___builtin_strcmp_71;
              return_value___builtin_strcmp_71=__builtin_strcmp(dllName, dll->name);
              tmp_statement_expression_70 = return_value___builtin_strcmp_71;
              if(tmp_statement_expression_70 == 0)
                break;

            }
            if(dll == ((struct _d3h_dll_t *)NULL))
            {
              void *return_value_calloc_72;
              return_value_calloc_72=calloc((unsigned long int)1, sizeof(struct _d3h_dll_t) /*40ul*/ );
              dll = (struct _d3h_dll_t *)return_value_calloc_72;
              dll->name = dllName;
              dll->directory=load(dllName, &pluginObject);
              if(dll->directory == ((char *)NULL) || pluginObject == NULL)
              {
                ghss_debug(1, ": failed to load plugin library %s", dllName);
                return 1;
              }

              void *return_value_dlsym_73;
              return_value_dlsym_73=dlsym(pluginObject, "dssi_descriptor");
              dll->descfn = (const struct _DSSI_Descriptor * (*)(unsigned long int))return_value_dlsym_73;
              if(!(dll->descfn == ((const struct _DSSI_Descriptor * (*)(unsigned long int))NULL)))
                dll->is_DSSI_dll = 1;

              else
              {
                void *return_value_dlsym_74;
                return_value_dlsym_74=dlsym(pluginObject, "ladspa_descriptor");
                dll->descfn = (const struct _DSSI_Descriptor * (*)(unsigned long int))return_value_dlsym_74;
                if(dll->descfn == ((const struct _DSSI_Descriptor * (*)(unsigned long int))NULL))
                {
                  ghss_debug(1, ": %s is not a DSSI or LADSPA plugin library", dllName);
                  return 1;
                }

                dll->is_DSSI_dll = 0;
              }
              dll->next = dlls;
              dlls = dll;
            }

            plugin->dll = dll;
            j = 0;
            if(!(dll->is_DSSI_dll == 0))
            {
              const struct _DSSI_Descriptor *main__1__2__29__3__desc;
              tmp_post_75 = j;
              j = j + 1;
              main__1__2__29__3__desc=dll->descfn((unsigned long int)tmp_post_75);
              if(!(main__1__2__29__3__desc == ((const struct _DSSI_Descriptor *)NULL)))
              {
                if(plugin->label == ((char *)NULL))
                  tmp_if_expr_78 = (_Bool)1;

                else
                {
                  unsigned long int main__1__2__29__3__1__1____s1_len;
                  unsigned long int main__1__2__29__3__1__1____s2_len;
                  signed int return_value___builtin_strcmp_77;
                  return_value___builtin_strcmp_77=__builtin_strcmp(main__1__2__29__3__desc->LADSPA_Plugin->Label, plugin->label);
                  tmp_statement_expression_76 = return_value___builtin_strcmp_77;
                  tmp_if_expr_78 = !(tmp_statement_expression_76 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_78)
                  plugin->descriptor = main__1__2__29__3__desc;

              }

            }

            else
            {
              struct _LADSPA_Descriptor *desc;
              void *return_value_calloc_79;
              return_value_calloc_79=calloc((unsigned long int)1, sizeof(struct _DSSI_Descriptor) /*80ul*/ );
              plugin->descriptor = (const struct _DSSI_Descriptor *)return_value_calloc_79;
              ((struct _DSSI_Descriptor *)plugin->descriptor)->DSSI_API_Version = 1;
              tmp_post_80 = j;
              j = j + 1;
              const struct _DSSI_Descriptor *return_value;
              return_value=dll->descfn((unsigned long int)tmp_post_80);
              desc = (struct _LADSPA_Descriptor *)return_value;
              if(!(desc == ((struct _LADSPA_Descriptor *)NULL)))
              {
                if(plugin->label == ((char *)NULL))
                  tmp_if_expr_83 = (_Bool)1;

                else
                {
                  unsigned long int __s1_len;
                  unsigned long int __s2_len;
                  signed int return_value___builtin_strcmp_82;
                  return_value___builtin_strcmp_82=__builtin_strcmp(desc->Label, plugin->label);
                  tmp_statement_expression_81 = return_value___builtin_strcmp_82;
                  tmp_if_expr_83 = !(tmp_statement_expression_81 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_83)
                  ((struct _DSSI_Descriptor *)plugin->descriptor)->LADSPA_Plugin = desc;

              }

              if(plugin->descriptor->LADSPA_Plugin == ((const struct _LADSPA_Descriptor *)NULL))
              {
                free((void *)plugin->descriptor);
                plugin->descriptor = (const struct _DSSI_Descriptor *)(void *)0;
              }

            }
            if(plugin->descriptor == ((const struct _DSSI_Descriptor *)NULL))
            {
              if(!(plugin->label == ((char *)NULL)))
                tmp_if_expr_84 = plugin->label;

              else
                tmp_if_expr_84 = "(none)";
              ghss_debug(1, ": plugin label '%s' not found in library '%s'", tmp_if_expr_84, dllName);
              return 1;
            }

            j = 1;
            plugin->is_first_in_dll = j;
            if(plugin->label == ((char *)NULL))
            {
              char *return_value___strdup_85;
              return_value___strdup_85=__strdup(plugin->descriptor->LADSPA_Plugin->Label);
              plugin->label = return_value___strdup_85;
            }

            plugin->ins = 0;
            plugin->outs = 0;
            plugin->controlIns = 0;
            plugin->controlOuts = 0;
            j = 0;
            if(!((unsigned long int)j >= plugin->descriptor->LADSPA_Plugin->PortCount))
            {
              signed int pod = plugin->descriptor->LADSPA_Plugin->PortDescriptors[(signed long int)j];
              if(!((0x8 & pod) == 0))
              {
                if(!((0x1 & pod) == 0))
                  plugin->ins = plugin->ins + 1;

                else
                  if(!((0x2 & pod) == 0))
                    plugin->outs = plugin->outs + 1;

              }

              else
                if(!((0x4 & pod) == 0))
                {
                  if(!((0x1 & pod) == 0))
                    plugin->controlIns = plugin->controlIns + 1;

                  else
                    if(!((0x2 & pod) == 0))
                      plugin->controlOuts = plugin->controlOuts + 1;

                }

              j = j + 1;
            }

            plugin->instances = 0;
            plugin->next = plugins;
            plugins = plugin;
            plugin_count = plugin_count + 1;
          }
          j = 0;
          for( ; !(j >= reps); j = j + 1)
            if(!(instance_count >= 32))
            {
              instance = &instances[(signed long int)instance_count];
              instance->plugin = plugin;
              instance->id = instance_count;
              instance->channel = itemplate->channel;
              instance->channel_next_instance = (struct _d3h_instance_t *)(void *)0;
              unsigned long int return_value_strlen_86;
              return_value_strlen_86=strlen(plugin->dll->name);
              unsigned long int return_value_strlen_87;
              return_value_strlen_87=strlen(plugin->label);
              void *return_value_malloc_88;
              return_value_malloc_88=malloc(return_value_strlen_86 + return_value_strlen_87 + (unsigned long int)9);
              tmp = (char *)return_value_malloc_88;
              instance->friendly_name = tmp;
              char *return_value_strrchr_90;
              return_value_strrchr_90=strrchr(plugin->dll->name, 47);
              if(!(return_value_strrchr_90 == ((char *)NULL)))
              {
                char *return_value_strrchr_89;
                return_value_strrchr_89=strrchr(plugin->dll->name, 47);
                strcpy(tmp, return_value_strrchr_89 + (signed long int)1);
              }

              else
                strcpy(tmp, plugin->dll->name);
              unsigned long int return_value_strlen_93;
              return_value_strlen_93=strlen(tmp);
              if(return_value_strlen_93 >= 4ul)
              {
                return_value_strlen_94=strlen(tmp);
                return_value_strcasecmp_95=strcasecmp((tmp + (signed long int)return_value_strlen_94) - (signed long int)3, ".so");
                tmp_if_expr_96 = !(return_value_strcasecmp_95 != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_96 = (_Bool)0;
              if(tmp_if_expr_96)
              {
                unsigned long int return_value_strlen_91;
                return_value_strlen_91=strlen(tmp);
                tmp = (tmp + (signed long int)return_value_strlen_91) - (signed long int)3;
              }

              else
              {
                unsigned long int return_value_strlen_92;
                return_value_strlen_92=strlen(tmp);
                tmp = tmp + (signed long int)return_value_strlen_92;
              }
              sprintf(tmp, "/%s/inst%02d", plugin->label, instance->id);
              instance->configure_items = (struct _configure_item_t *)(void *)0;
              copy_configure_items(itemplate, instance);
              instance->pluginProgramsValid = 0;
              instance->pluginProgramsAlloc = 0;
              instance->pluginProgramCount = 0;
              instance->pluginPrograms = (struct _DSSI_Program_Descriptor *)(void *)0;
              if(!(itemplate->program_set == 0))
              {
                instance->currentBank = (signed long int)itemplate->bank;
                instance->currentProgram = (signed long int)itemplate->program;
                instance->pendingProgramChange = 0;
              }

              else
              {
                instance->currentBank = (signed long int)0;
                instance->currentProgram = (signed long int)0;
                instance->pendingProgramChange = -1;
              }
              instance->pendingBankLSB = -1;
              instance->pendingBankMSB = -1;
              if(!(itemplate->ports.have_settings == 0))
              {
                if(itemplate->ports.highest_set >= plugin->descriptor->LADSPA_Plugin->PortCount)
                {
                  ghss_debug(1, ": out-of-range port number %lu given for %s (instance %d)", itemplate->ports.highest_set, plugin->label, instance_count);
                  return 2;
                }

                copy_initial_port_set(itemplate, instance);
              }

              else
                instance->have_initial_values = 0;
              instance->midi_activity_tick = -2;
              instance->ui_running = 0;
              instance->ui_visible = 0;
              instance->ui_initial_show_sent = 0;
              instance->uiNeedsProgramUpdate = 0;
              instance->ui_osc_address = (void *)0;
              instance->ui_osc_source = (void *)0;
              instance->ui_osc_configure_path = (char *)(void *)0;
              instance->ui_osc_control_path = (char *)(void *)0;
              instance->ui_osc_hide_path = (char *)(void *)0;
              instance->ui_osc_program_path = (char *)(void *)0;
              instance->ui_osc_quit_path = (char *)(void *)0;
              instance->ui_osc_rate_path = (char *)(void *)0;
              instance->ui_osc_show_path = (char *)(void *)0;
              insTotal = insTotal + plugin->ins;
              outsTotal = outsTotal + plugin->outs;
              controlInsTotal = controlInsTotal + plugin->controlIns;
              controlOutsTotal = controlOutsTotal + plugin->controlOuts;
              itemplate->channel = itemplate->channel + 1 & 15;
              plugin->instances = plugin->instances + 1;
              instance_count = instance_count + 1;
            }

            else
            {
              ghss_debug(1, ": too many plugin instances specified");
              return 2;
            }
          reset_instance_template(itemplate);
          reps = 1;
        }
      }
    }
    while((_Bool)1);
    free_instance_template(itemplate);
    if(!(getarg_error == ((char *)NULL)))
    {
      getarg_print_possible_error();
      ghss_debug(1, ": aborting.");
      return 2;
    }

    else
    {
      getarg_cleanup();
      if(instance_count == 0)
      {
        ghss_debug(1, ": no plugin instances specified");
        return 2;
      }

      else
      {
        if(instance_count >= 2)
          qsort((void *)instances, (unsigned long int)instance_count, sizeof(struct _d3h_instance_t) /*1264ul*/ , instance_sort_cmp);

        i = 0;
        for( ; !(i >= 16); i = i + 1)
          channel2instances[(signed long int)i] = (struct _d3h_instance_t *)(void *)0;
        i = 0;
        for( ; !(i >= instance_count); i = i + 1)
        {
          instance = &instances[(signed long int)i];
          instance->number = i;
          if(!(channel2instances[(signed long int)instance->channel] == ((struct _d3h_instance_t *)NULL)))
            instance->channel_next_instance = channel2instances[(signed long int)instance->channel];

          channel2instances[(signed long int)instance->channel] = instance;
          fprintf(stderr, "%s: instance %2d on channel %2d, plugin %2d is '%s'\n", host_name, i, instance->channel, instance->plugin->number, instance->friendly_name);
        }
        jackClient=jack_client_open(host_name, (enum JackOptions)JackSessionID, &status, jack_session_uuid);
        if(jackClient == ((struct _jack_client *)NULL))
        {
          fprintf(stderr, "%s: Error: Failed to connect to JACK server\n", host_name);
          return 1;
        }

        else
        {
          if(!((JackNameNotUnique & (signed int)status) == 0))
          {
            if(!(host_name == host_name_default))
              free((void *)host_name);

            char *return_value_jack_get_client_name_97;
            return_value_jack_get_client_name_97=jack_get_client_name(jackClient);
            char *return_value___strdup_98;
            return_value___strdup_98=__strdup(return_value_jack_get_client_name_97);
            host_name = return_value___strdup_98;
          }

          /* assertion sizeof(jack_default_audio_sample_t) == sizeof(float) */
          assert(sizeof(float) /*4ul*/  == sizeof(float) /*4ul*/ );
          /* assertion sizeof(jack_default_audio_sample_t) == sizeof(LADSPA_Data) */
          assert(sizeof(float) /*4ul*/  == sizeof(float) /*4ul*/ );
          unsigned int return_value_jack_get_sample_rate_99;
          return_value_jack_get_sample_rate_99=jack_get_sample_rate(jackClient);
          sample_rate = (float)return_value_jack_get_sample_rate_99;
          void *return_value_malloc_100;
          return_value_malloc_100=malloc((unsigned long int)insTotal * sizeof(struct _jack_port *) /*8ul*/ );
          inputPorts = (struct _jack_port **)return_value_malloc_100;
          void *return_value_calloc_101;
          return_value_calloc_101=calloc((unsigned long int)insTotal, sizeof(float *) /*8ul*/ );
          pluginInputBuffers = (float **)return_value_calloc_101;
          void *return_value_malloc_102;
          return_value_malloc_102=malloc((unsigned long int)insTotal * sizeof(struct _d3h_instance_t *) /*8ul*/ );
          pluginAudioInInstances = (struct _d3h_instance_t **)return_value_malloc_102;
          void *return_value_malloc_103;
          return_value_malloc_103=malloc((unsigned long int)insTotal * sizeof(unsigned long int) /*8ul*/ );
          pluginAudioInPortNumbers = (unsigned long int *)return_value_malloc_103;
          void *return_value_calloc_104;
          return_value_calloc_104=calloc((unsigned long int)controlInsTotal, sizeof(float) /*4ul*/ );
          pluginControlIns = (float *)return_value_calloc_104;
          void *return_value_malloc_105;
          return_value_malloc_105=malloc((unsigned long int)controlInsTotal * sizeof(struct _d3h_instance_t *) /*8ul*/ );
          pluginControlInInstances = (struct _d3h_instance_t **)return_value_malloc_105;
          void *return_value_malloc_106;
          return_value_malloc_106=malloc((unsigned long int)controlInsTotal * sizeof(unsigned long int) /*8ul*/ );
          pluginControlInPortNumbers = (unsigned long int *)return_value_malloc_106;
          void *return_value_malloc_107;
          return_value_malloc_107=malloc((unsigned long int)controlInsTotal * sizeof(signed int) /*4ul*/ );
          pluginPortUpdated = (signed int *)return_value_malloc_107;
          void *return_value_malloc_108;
          return_value_malloc_108=malloc((unsigned long int)outsTotal * sizeof(struct _jack_port *) /*8ul*/ );
          outputPorts = (struct _jack_port **)return_value_malloc_108;
          void *return_value_malloc_109;
          return_value_malloc_109=malloc((unsigned long int)outsTotal * sizeof(float *) /*8ul*/ );
          pluginOutputBuffers = (float **)return_value_malloc_109;
          void *return_value_calloc_110;
          return_value_calloc_110=calloc((unsigned long int)controlOutsTotal, sizeof(float) /*4ul*/ );
          pluginControlOuts = (float *)return_value_calloc_110;
          void *return_value_malloc_111;
          return_value_malloc_111=malloc((unsigned long int)instance_count * sizeof(void *) /*8ul*/ );
          instanceHandles = (void **)return_value_malloc_111;
          void *return_value_malloc_112;
          return_value_malloc_112=malloc((unsigned long int)instance_count * sizeof(struct snd_seq_event *) /*8ul*/ );
          instanceEventBuffers = (struct snd_seq_event **)return_value_malloc_112;
          void *return_value_malloc_113;
          return_value_malloc_113=malloc((unsigned long int)instance_count * sizeof(unsigned long int) /*8ul*/ );
          instanceEventCounts = (unsigned long int *)return_value_malloc_113;
          i = 0;
          for( ; !(i >= instance_count); i = i + 1)
          {
            void *return_value_malloc_114;
            return_value_malloc_114=malloc((unsigned long int)1024 * sizeof(struct snd_seq_event) /*32ul*/ );
            instanceEventBuffers[(signed long int)i] = (struct snd_seq_event *)return_value_malloc_114;
            void *return_value_malloc_115;
            return_value_malloc_115=malloc(instances[(signed long int)i].plugin->descriptor->LADSPA_Plugin->PortCount * sizeof(signed int) /*4ul*/ );
            instances[(signed long int)i].pluginPortControlInNumbers = (signed int *)return_value_malloc_115;
          }
          in = 0;
          out = 0;
          i = 0;
          for( ; !(i >= instance_count); i = i + 1)
          {
            signed int inst_in = 0;
            signed int inst_out = 0;
            instance = &instances[(signed long int)i];
            plugin = instance->plugin;
            j = 0;
            for( ; !((unsigned long int)j >= plugin->descriptor->LADSPA_Plugin->PortCount); j = j + 1)
            {
              signed int main__1__11__1__1__1__pod = plugin->descriptor->LADSPA_Plugin->PortDescriptors[(signed long int)j];
              if(!((0x1 & main__1__11__1__1__1__pod) == 0) && !((0x8 & main__1__11__1__1__1__pod) == 0))
              {
                char portname[65l];
                snprintf(portname, (unsigned long int)65, "inst%02d %s %s", instance->id, plugin->label, plugin->descriptor->LADSPA_Plugin->PortNames[(signed long int)j]);
                inputPorts[(signed long int)in]=jack_port_register(jackClient, portname, "32 bit float mono audio", (unsigned long int)1, (unsigned long int)0);
                if(inputPorts[(signed long int)in] == ((struct _jack_port *)NULL))
                {
                  snprintf(portname, (unsigned long int)65, "inst%02d %s in %d %s", instance->id, plugin->label, inst_in, plugin->descriptor->LADSPA_Plugin->PortNames[(signed long int)j]);
                  inputPorts[(signed long int)in]=jack_port_register(jackClient, portname, "32 bit float mono audio", (unsigned long int)1, (unsigned long int)0);
                }

                if(inputPorts[(signed long int)in] == ((struct _jack_port *)NULL))
                {
                  fprintf(stderr, "%s: Error: Could not create instance '%s' input port '%s'\n", host_name, instance->friendly_name, (const void *)portname);
                  return 1;
                }

                inst_in = inst_in + 1;
                in = in + 1;
              }

              else
                if(!((0x2 & main__1__11__1__1__1__pod) == 0) && !((0x8 & main__1__11__1__1__1__pod) == 0))
                {
                  char main__1__11__1__1__1__2__portname[65l];
                  snprintf(main__1__11__1__1__1__2__portname, (unsigned long int)65, "inst%02d %s %s", instance->id, plugin->label, plugin->descriptor->LADSPA_Plugin->PortNames[(signed long int)j]);
                  outputPorts[(signed long int)out]=jack_port_register(jackClient, main__1__11__1__1__1__2__portname, "32 bit float mono audio", (unsigned long int)2, (unsigned long int)0);
                  if(outputPorts[(signed long int)out] == ((struct _jack_port *)NULL))
                  {
                    snprintf(main__1__11__1__1__1__2__portname, (unsigned long int)65, "inst%02d %s out %d %s", instance->id, plugin->label, inst_out, plugin->descriptor->LADSPA_Plugin->PortNames[(signed long int)j]);
                    outputPorts[(signed long int)out]=jack_port_register(jackClient, main__1__11__1__1__1__2__portname, "32 bit float mono audio", (unsigned long int)2, (unsigned long int)0);
                  }

                  if(outputPorts[(signed long int)out] == ((struct _jack_port *)NULL))
                  {
                    ghss_debug(1, " error: Could not create instance '%s' output port '%s'", instance->friendly_name, (const void *)main__1__11__1__1__1__2__portname);
                    return 1;
                  }

                  inst_out = inst_out + 1;
                  unsigned int return_value_jack_get_buffer_size_116;
                  return_value_jack_get_buffer_size_116=jack_get_buffer_size(jackClient);
                  void *return_value_calloc_117;
                  return_value_calloc_117=calloc((unsigned long int)return_value_jack_get_buffer_size_116, sizeof(float) /*4ul*/ );
                  pluginOutputBuffers[(signed long int)out] = (float *)return_value_calloc_117;
                  out = out + 1;
                }

            }
          }
          jack_set_process_callback(jackClient, audio_callback, NULL);
          ghss_debug(2, ": setting JACK session callback");
          jack_set_session_callback(jackClient, session_callback, NULL);
          i = 0;
          if(!(i >= instance_count))
          {
            plugin = instances[(signed long int)i].plugin;
            instanceHandles[(signed long int)i]=plugin->descriptor->LADSPA_Plugin->instantiate(plugin->descriptor->LADSPA_Plugin, (unsigned long int)sample_rate);
            if(instanceHandles[(signed long int)i] == NULL)
            {
              ghss_debug(1, " error: Failed to instantiate instance %d, plugin '%s'!", i, plugin->label);
              return 1;
            }

            i = i + 1;
          }

          serverThread=lo_server_thread_new((const char *)(void *)0, osc_error);
          host_osc_url=lo_server_thread_get_url(serverThread);
          ghss_debug(64, ": host OSC URL is %s", host_osc_url);
          lo_server_thread_add_method(serverThread, (const char *)(void *)0, (const char *)(void *)0, osc_message_handler, (void *)0);
          lo_server_thread_start(serverThread);
          create_windows(host_name, instance_count);
          in = 0;
          for( ; !(in >= controlInsTotal); in = in + 1)
            pluginPortUpdated[(signed long int)in] = 0;
          controlOut = 0;
          controlIn = controlOut;
          out = controlIn;
          in = out;
          i = 0;
          for( ; !(i >= instance_count); i = i + 1)
          {
            instance = &instances[(signed long int)i];
            instance->firstControlIn = controlIn;
            j = 0;
            for( ; !(j >= 128); j = j + 1)
              instance->controllerMap[(signed long int)j] = (signed long int)-1;
            plugin = instance->plugin;
            j = 0;
            for( ; !((unsigned long int)j >= plugin->descriptor->LADSPA_Plugin->PortCount); j = j + 1)
            {
              signed int main__1__15__1__2__1__pod = plugin->descriptor->LADSPA_Plugin->PortDescriptors[(signed long int)j];
              instance->pluginPortControlInNumbers[(signed long int)j] = -1;
              if(!((0x8 & main__1__15__1__2__1__pod) == 0))
              {
                if(!(instance->have_initial_values == 0))
                {
                  if(!(instance->initial_value_set[(signed long int)j] == 0))
                  {
                    ghss_debug(1, " %s error: port setting given for audio port %d", instance->friendly_name, j);
                    return 2;
                  }

                }

                if(!((0x1 & main__1__15__1__2__1__pod) == 0))
                {
                  pluginAudioInInstances[(signed long int)in] = instance;
                  tmp_post_118 = in;
                  in = in + 1;
                  pluginAudioInPortNumbers[(signed long int)tmp_post_118] = (unsigned long int)j;
                }

                else
                  if(!((0x2 & main__1__15__1__2__1__pod) == 0))
                  {
                    tmp_post_119 = out;
                    out = out + 1;
                    plugin->descriptor->LADSPA_Plugin->connect_port(instanceHandles[(signed long int)i], (unsigned long int)j, pluginOutputBuffers[(signed long int)tmp_post_119]);
                  }

              }

              else
                if(!((0x4 & main__1__15__1__2__1__pod) == 0))
                {
                  if(!((0x1 & main__1__15__1__2__1__pod) == 0))
                  {
                    if(!(plugin->descriptor->get_midi_controller_for_port == ((signed int (*)(void *, unsigned long int))NULL)))
                    {
                      signed int controller;
                      controller=plugin->descriptor->get_midi_controller_for_port(instanceHandles[(signed long int)i], (unsigned long int)j);
                      if(controller == 0)
                        ghss_debug(1, " error: buggy plugin %s:%s wants mapping for bank MSB", plugin->dll->name, plugin->label);

                      else
                        if(controller == 32)
                          ghss_debug(1, " error: buggy plugin %s:%s wants mapping for bank LSB", plugin->dll->name, plugin->label);

                        else
                          if(!((0x20000000 & controller) == 0))
                            instance->controllerMap[(signed long int)(controller & 0x7f)] = (signed long int)controlIn;

                    }

                    pluginControlInInstances[(signed long int)controlIn] = instance;
                    pluginControlInPortNumbers[(signed long int)controlIn] = (unsigned long int)j;
                    instance->pluginPortControlInNumbers[(signed long int)j] = controlIn;
                    pluginControlIns[(signed long int)controlIn]=get_port_default(plugin->descriptor->LADSPA_Plugin, j);
                    tmp_post_120 = controlIn;
                    controlIn = controlIn + 1;
                    plugin->descriptor->LADSPA_Plugin->connect_port(instanceHandles[(signed long int)i], (unsigned long int)j, &pluginControlIns[(signed long int)tmp_post_120]);
                  }

                  else
                    if(!((0x2 & main__1__15__1__2__1__pod) == 0))
                    {
                      if(!(instance->have_initial_values == 0))
                      {
                        if(!(instance->initial_value_set[(signed long int)j] == 0))
                        {
                          ghss_debug(1, ": port setting given for control out port %d, plugin %s, instance %d", j, plugin->label, instance_count);
                          return 2;
                        }

                      }

                      tmp_post_121 = controlOut;
                      controlOut = controlOut + 1;
                      plugin->descriptor->LADSPA_Plugin->connect_port(instanceHandles[(signed long int)i], (unsigned long int)j, &pluginControlOuts[(signed long int)tmp_post_121]);
                    }

                }

            }
            instance->strip=create_plugin_strip(main_window, instance);
            unsigned long int return_value_gtk_box_get_type_122;
            return_value_gtk_box_get_type_122=gtk_box_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_123;
            return_value_g_type_check_instance_cast_123=g_type_check_instance_cast((struct _GTypeInstance *)plugin_hbox, return_value_gtk_box_get_type_122);
            gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_123, instance->strip->container, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
          }
          /* assertion in == insTotal */
          assert(in == insTotal);
          /* assertion out == outsTotal */
          assert(out == outsTotal);
          /* assertion controlIn == controlInsTotal */
          assert(controlIn == controlInsTotal);
          /* assertion controlOut == controlOutsTotal */
          assert(controlOut == controlOutsTotal);
          signed int return_value_midi_open_124;
          return_value_midi_open_124=midi_open();
          if(return_value_midi_open_124 == 0)
            return 1;

          else
          {
            i = 0;
            for( ; !(i >= instance_count); i = i + 1)
            {
              instance = &instances[(signed long int)i];
              plugin = instance->plugin;
              if(!(plugin->descriptor->configure == ((char * (*)(void *, const char *, const char *))NULL)))
              {
                struct _configure_item_t *item;
                if(!(project_directory == ((char *)NULL)))
                  add_configure_item(&instance->configure_items, "DSSI:PROJECT_DIRECTORY", project_directory);

                item = instance->configure_items;
                if(!(item == ((struct _configure_item_t *)NULL)))
                {
                  tmp=plugin->descriptor->configure(instanceHandles[(signed long int)i], item->key, item->value);
                  if(!(tmp == ((char *)NULL)))
                  {
                    ghss_debug(8, ": on configure '%s' '%s', plugin '%s' returned '%s'", item->key, item->value, instance->friendly_name, tmp);
                    free((void *)tmp);
                  }

                  item = item->next;
                }

              }

              else
                if(!(instance->configure_items == ((struct _configure_item_t *)NULL)))
                  ghss_debug(1, " %s warning: configure items specified for plugin without configure()", instance->friendly_name);

              if(!(plugin->descriptor->select_program == ((void (*)(void *, unsigned long int, unsigned long int))NULL)))
              {
                if(!(instance->pendingProgramChange >= 0))
                {
                  if(!(instance->plugin->descriptor->get_program == ((const struct _DSSI_Program_Descriptor * (*)(void *, unsigned long int))NULL)))
                  {
                    const struct _DSSI_Program_Descriptor *descriptor;
                    descriptor=instance->plugin->descriptor->get_program(instanceHandles[(signed long int)instance->number], (unsigned long int)0);
                    if(!(descriptor == ((const struct _DSSI_Program_Descriptor *)NULL)))
                    {
                      instance->currentBank = (signed long int)descriptor->Bank;
                      instance->currentProgram = (signed long int)descriptor->Program;
                    }

                  }

                }

                plugin->descriptor->select_program(instanceHandles[(signed long int)i], (unsigned long int)instance->currentBank, (unsigned long int)instance->currentProgram);
                instance->uiNeedsProgramUpdate = 1;
              }

              else
                if(instance->pendingProgramChange >= 0)
                  ghss_debug(1, " %s warning: program specified for plugin without select_program()", instance->friendly_name);

              instance->pendingProgramChange = -1;
              if(!(instance->have_initial_values == 0))
              {
                set_initial_port_settings(instance);
                instance->have_initial_values = 0;
              }

              if(!(plugin->descriptor->LADSPA_Plugin->activate == ((void (*)(void *))NULL)))
                plugin->descriptor->LADSPA_Plugin->activate(instanceHandles[(signed long int)i]);

            }
            signed int return_value_jack_activate_125;
            return_value_jack_activate_125=jack_activate(jackClient);
            if(!(return_value_jack_activate_125 == 0))
            {
              ghss_debug(1, ": cannot activate JACK client");
              return 1;
            }

            else
            {
              if(!(autoconnect == 0))
              {
                ports=jack_get_ports(jackClient, (const char *)(void *)0, "^32 bit float mono audio_", (unsigned long int)(4 | 1));
                if(!(ports == ((const char **)NULL)))
                {
                  if(!(*ports == ((const char *)NULL)))
                  {
                    i = 0;
                    j = 0;
                    for( ; !(i >= outsTotal); i = i + 1)
                    {
                      const char *return_value_jack_port_name_126;
                      return_value_jack_port_name_126=jack_port_name(outputPorts[(signed long int)i]);
                      signed int return_value_jack_connect_127;
                      return_value_jack_connect_127=jack_connect(jackClient, return_value_jack_port_name_126, ports[(signed long int)j]);
                      if(!(return_value_jack_connect_127 == 0))
                        fprintf(stderr, "cannot connect output port %d\n", i);

                      j = j + 1;
                      if(ports[(signed long int)j] == ((const char *)NULL))
                        j = 0;

                    }
                    free((void *)ports);
                  }

                }

              }

              signal(2, signalHandler);
              signal(15, signalHandler);
              signal(1, signalHandler);
              signal(3, signalHandler);
              pthread_sigmask(1, &_signals, ((struct anonymous_18 *)NULL));
              signed int return_value_pthread_create_128;
              return_value_pthread_create_128=pthread_create(&midi_thread, (const union pthread_attr_t *)(void *)0, midi_thread_function, (void *)0);
              if(!(return_value_pthread_create_128 == 0))
              {
                ghss_debug(1, ": could not create MIDI thread");
                return 1;
              }

              else
              {
                unsigned int return_value_gtk_timeout_add_129;
                return_value_gtk_timeout_add_129=gtk_timeout_add((unsigned int)50, gtk_timeout_callback, (void *)0);
                gtk_timeout_tag = (signed int)return_value_gtk_timeout_add_129;
                fprintf(stderr, "%s ready\n", host_name);
                gtk_widget_show(main_window);
                host_exiting = 0;
                gtk_main();
                jack_client_close(jackClient);
                gtk_timeout_remove((unsigned int)gtk_timeout_tag);
                i = 0;
                for( ; !(i >= instance_count); i = i + 1)
                {
                  instance = &instances[(signed long int)i];
                  if(!(instance->ui_osc_address == NULL))
                  {
                    instance->ui_running = 0;
                    lo_send_internal(instance->ui_osc_address, "ghostess.c", 2307, instance->ui_osc_quit_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
                    ui_osc_free(instance);
                  }

                  if(!(instance->plugin->descriptor->LADSPA_Plugin->deactivate == ((void (*)(void *))NULL)))
                    instance->plugin->descriptor->LADSPA_Plugin->deactivate(instanceHandles[(signed long int)i]);

                  if(!(instance->plugin->descriptor->LADSPA_Plugin->cleanup == ((void (*)(void *))NULL)))
                    instance->plugin->descriptor->LADSPA_Plugin->cleanup(instanceHandles[(signed long int)i]);

                  free_programs(instance);
                }
                do
                {
                  sleep((unsigned int)1);
                  ghss_debug(2, ": waiting for midi thread to finish");
                }
                while(!(midi_thread_running == 0));
                pthread_join(midi_thread, (void **)(void *)0);
                if(!(host_name == host_name_default))
                  free((void *)host_name);

                if(!(host_osc_url == ((char *)NULL)))
                  free((void *)host_osc_url);

                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// midi_open
// file midi.h line 33
signed int midi_open(void)
{
  signed int return_value_snd_seq_open_1;
  return_value_snd_seq_open_1=snd_seq_open(&alsaClient, "hw", 1 | 2, 0);
  if(!(return_value_snd_seq_open_1 >= 0))
  {
    ghss_debug(1, ": failed to open ALSA sequencer interface");
    return 0;
  }

  else
  {
    snd_seq_set_client_name(alsaClient, host_name);
    alsa_client_id=snd_seq_client_id(alsaClient);
    alsa_port_id=snd_seq_create_simple_port(alsaClient, "input", (unsigned int)(1 << 1 | 1 << 6), (unsigned int)(1 << 20));
    if(!(alsa_port_id >= 0))
    {
      ghss_debug(1, ": failed to create ALSA sequencer port");
      return 0;
    }

    else
    {
      alsaClient_npfd=snd_seq_poll_descriptors_count(alsaClient, (signed short int)0x001);
      void *return_value_calloc_2;
      return_value_calloc_2=calloc((unsigned long int)1, (unsigned long int)alsaClient_npfd * sizeof(struct pollfd) /*8ul*/ );
      alsaClient_pfd = (struct pollfd *)return_value_calloc_2;
      snd_seq_poll_descriptors(alsaClient, alsaClient_pfd, (unsigned int)alsaClient_npfd, (signed short int)0x001);
      ghss_debug(1, ": listening using ALSA MIDI");
      return 1;
    }
  }
}

// midi_thread_function
// file midi.h line 34
void * midi_thread_function(void *arg)
{
  signed int rc;
  struct sched_param rtparam;
  struct snd_seq_event *ev = ((struct snd_seq_event *)NULL);
  memset((void *)&rtparam, 0, sizeof(struct sched_param) /*4ul*/ );
  rtparam.__sched_priority = 1;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  rc=pthread_setschedparam(return_value_pthread_self_1, 1, &rtparam);
  if(!(rc == 0))
  {
    if(rc == 1)
      ghss_debug(4, " midi thread: no permission for SCHED_FIFO, continuing...");

    else
      ghss_debug(4, " midi thread: error getting SCHED_FIFO, continuing...");
  }

  midi_thread_running = 1;
  signed int return_value_snd_seq_event_input_pending_4;
  do
  {
    rc=poll(alsaClient_pfd, (unsigned long int)alsaClient_npfd, 500);
    if(!(rc >= 1))
    {
      if(!(rc == 4) && !(rc >= 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(*return_value___errno_location_2);
        ghss_debug(4, " midi thread: poll error: %s", return_value_strerror_3);
        usleep((unsigned int)500);
      }

    }

    else
    {
      pthread_mutex_lock(&midiEventBufferMutex);
      do
      {
        signed int return_value_snd_seq_event_input_5;
        return_value_snd_seq_event_input_5=snd_seq_event_input(alsaClient, &ev);
        if(return_value_snd_seq_event_input_5 >= 1)
        {
          if(midiEventReadIndex == 1 + midiEventWriteIndex)
          {
            ghss_debug(4, " midi thread: MIDI event buffer overflow!");
            goto __CPROVER_DUMP_L10;
          }

          midiEventBuffer[(signed long int)midiEventWriteIndex] = *ev;
          ev = &midiEventBuffer[(signed long int)midiEventWriteIndex];
          if((signed int)ev->type == 6)
          {
            if((signed int)ev->data.note.velocity == 0)
              ev->type = (unsigned char)7;

          }

          ev->time.tick=jack_frame_time(jackClient);
          ev->dest.client = (unsigned char)0;
          midiEventWriteIndex = (midiEventWriteIndex + 1) % 1024;
        }


      __CPROVER_DUMP_L10:
        ;
        return_value_snd_seq_event_input_pending_4=snd_seq_event_input_pending(alsaClient, 0);
      }
      while(return_value_snd_seq_event_input_pending_4 >= 1);
      pthread_mutex_unlock(&midiEventBufferMutex);
    }
  }
  while(host_exiting == 0);
  midi_thread_running = 0;
  return (void *)0;
}

// new_instance_template
// file ghostess.c line 750
static struct _instance_template_t * new_instance_template(void)
{
  struct _instance_template_t *t;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _instance_template_t) /*80ul*/ );
  t = (struct _instance_template_t *)return_value_calloc_1;
  return t;
}

// on_about_dismiss
// file gui_callbacks.c line 206
void on_about_dismiss(struct _GtkWidget *widget, void *data)
{
  gtk_widget_hide(about_window);
}

// on_delete_event_wrapper
// file gui_callbacks.c line 145
signed int on_delete_event_wrapper(struct _GtkWidget *widget, union _GdkEvent *event, void *data)
{
  void (*handler)(struct _GtkWidget *, void *) = (void (*)(struct _GtkWidget *, void *))data;
  handler(widget, (void *)0);
  return (signed int)!(0 != 0);
}

// on_file_selection_cancel
// file gui_callbacks.c line 164
void on_file_selection_cancel(struct _GtkWidget *widget, void *data)
{
  ghss_debug(256, ": on_save_file_cancel called");
  gtk_widget_hide(file_selection);
}

// on_file_selection_ok
// file gui_callbacks.c line 157
void on_file_selection_ok(struct _GtkWidget *widget, void *data)
{
  gtk_widget_hide(file_selection);
  file_selection_handler(widget, data);
}

// on_menu_about_activate
// file gui_callbacks.c line 103
void on_menu_about_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  char buf[1024l];
  signed int maxlen = 1024;
  signed int len;
  snprintf(buf, (unsigned long int)maxlen, "%s 20120105\nCopyright (C) 2012 by Sean Bolton and others.\n\nThis is sloppy, hurried HACKWARE -- please do not consider this exemplary of the authors' skills or preferences, nor of good DSSI or general programming practices.  (In particular, I don't want anyone attributing my mess to Chris or Steve ;-)\n\n%s comes with ABSOLUTELY NO WARRANTY. It is free software, and you are welcome to redistribute it under certain conditions; see the file COPYING for details.\n\n", host_name_default, host_name_default);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  len = (signed int)return_value_strlen_1;
  snprintf(buf + (signed long int)len, (unsigned long int)(maxlen - len), "Host OSC URL: %s\n", host_osc_url);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(buf);
  len = (signed int)return_value_strlen_2;
  snprintf(buf + (signed long int)len, (unsigned long int)(maxlen - len), "ALSA MIDI input port: %d:%d\n", alsa_client_id, alsa_port_id);
  unsigned long int return_value_gtk_label_get_type_3;
  return_value_gtk_label_get_type_3=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)about_label, return_value_gtk_label_get_type_3);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_4, buf);
  gtk_widget_show(about_window);
}

// on_menu_patchlist_activate
// file gui_callbacks.c line 83
void on_menu_patchlist_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  file_selection_set_path(last_patchlist_filename);
  unsigned long int return_value_gtk_window_get_type_1;
  return_value_gtk_window_get_type_1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_window_get_type_1);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, "ghostess - Export Patchlist for Freewheeling");
  file_selection_handler = on_patchlist_file_ok;
  gtk_widget_show(file_selection);
}

// on_menu_quit_activate
// file gui_callbacks.c line 94
void on_menu_quit_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  gtk_main_quit();
  host_exiting = 1;
}

// on_menu_save_activate
// file gui_callbacks.c line 72
void on_menu_save_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  file_selection_set_path(last_save_filename);
  unsigned long int return_value_gtk_window_get_type_1;
  return_value_gtk_window_get_type_1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_window_get_type_1);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, "ghostess - Save Configuration");
  file_selection_handler = on_save_file_ok;
  gtk_widget_show(file_selection);
}

// on_notice_dismiss
// file gui_callbacks.c line 332
void on_notice_dismiss(struct _GtkWidget *widget, void *data)
{
  gtk_widget_hide(notice_window);
}

// on_patchlist_file_ok
// file gui_callbacks.c line 188
void on_patchlist_file_ok(struct _GtkWidget *widget, void *data)
{
  if(!(last_patchlist_filename == ((char *)NULL)))
    free((void *)last_patchlist_filename);

  unsigned long int return_value_gtk_file_selection_get_type_1;
  return_value_gtk_file_selection_get_type_1=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type_1);
  const char *return_value_gtk_file_selection_get_filename_3;
  return_value_gtk_file_selection_get_filename_3=gtk_file_selection_get_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast_2);
  char *return_value_g_strdup_4;
  return_value_g_strdup_4=g_strdup(return_value_gtk_file_selection_get_filename_3);
  last_patchlist_filename = (char *)return_value_g_strdup_4;
  ghss_debug(256, " on_patchlist_file_ok: file '%s' selected", last_patchlist_filename);
  signed int return_value_write_patchlist_7;
  return_value_write_patchlist_7=write_patchlist(last_patchlist_filename);
  if(return_value_write_patchlist_7 == 0)
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    char *return_value_strerror_6;
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    display_notice("Patchlist export failed:", return_value_strerror_6);
  }

  else
    display_notice("Patchlist exported.", "");
}

// on_save_file_ok
// file gui_callbacks.c line 171
void on_save_file_ok(struct _GtkWidget *widget, void *data)
{
  if(!(last_save_filename == ((char *)NULL)))
    free((void *)last_save_filename);

  unsigned long int return_value_gtk_file_selection_get_type_1;
  return_value_gtk_file_selection_get_type_1=gtk_file_selection_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)file_selection, return_value_gtk_file_selection_get_type_1);
  const char *return_value_gtk_file_selection_get_filename_3;
  return_value_gtk_file_selection_get_filename_3=gtk_file_selection_get_filename((struct _GtkFileSelection *)return_value_g_type_check_instance_cast_2);
  char *return_value_g_strdup_4;
  return_value_g_strdup_4=g_strdup(return_value_gtk_file_selection_get_filename_3);
  last_save_filename = (char *)return_value_g_strdup_4;
  ghss_debug(256, " on_save_file_ok: file '%s' selected", last_save_filename);
  signed int return_value_write_configuration_7;
  return_value_write_configuration_7=write_configuration(last_save_filename, (const char *)(void *)0);
  if(return_value_write_configuration_7 == 0)
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    char *return_value_strerror_6;
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    display_notice("Save Configuration failed:", return_value_strerror_6);
  }

  else
    display_notice("Configuration Saved.", "");
}

// on_strip_ui_button_event
// file gui_callbacks.c line 235
signed int on_strip_ui_button_event(struct _GtkWidget *widget, struct _GdkEventButton *event, void *data)
{
  struct _d3h_instance_t *instance = ((struct _plugin_strip *)data)->instance;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(event->button == 3u))
    return 0;

  else
  {
    ghss_debug(256, " on_strip_ui_button_event: third button click on instance %d", instance->number);
    gtk_widget_set_sensitive(ui_context_menu_launch, (signed int)!(instance->ui_running != 0));
    if(!(instance->ui_running == 0))
      tmp_if_expr_1 = !(instance->ui_visible != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    gtk_widget_set_sensitive(ui_context_menu_show, (signed int)tmp_if_expr_1);
    if(!(instance->ui_running == 0))
      tmp_if_expr_2 = instance->ui_visible != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    gtk_widget_set_sensitive(ui_context_menu_hide, (signed int)tmp_if_expr_2);
    gtk_widget_set_sensitive(ui_context_menu_exit, instance->ui_running);
    ui_context_menu_instance = instance;
    unsigned long int return_value_gtk_menu_get_type_3;
    return_value_gtk_menu_get_type_3=gtk_menu_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)ui_context_menu, return_value_gtk_menu_get_type_3);
    gtk_menu_popup((struct _GtkMenu *)return_value_g_type_check_instance_cast_4, (struct _GtkWidget *)(void *)0, (struct _GtkWidget *)(void *)0, (void (*)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *))(void *)0, (void *)0, event->button, event->time);
    return (signed int)!(0 != 0);
  }
}

// on_strip_ui_button_toggled
// file gui_callbacks.c line 212
void on_strip_ui_button_toggled(struct _GtkWidget *widget, void *data)
{
  struct _d3h_instance_t *instance = ((struct _plugin_strip *)data)->instance;
  signed int state;
  unsigned long int return_value_gtk_toggle_button_get_type_1;
  return_value_gtk_toggle_button_get_type_1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_toggle_button_get_type_1);
  state = (signed int)((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_2)->active;
  ghss_debug(256, " on_strip_ui_button_toggled: instance %d button changed to %s", instance->number, state != 0 ? "on" : "off");
  if(!(instance->ui_osc_address == NULL))
  {
    if(!(state == 0))
    {
      lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 222, instance->ui_osc_show_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
      instance->ui_visible = 1;
    }

    else
    {
      lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 225, instance->ui_osc_hide_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
      instance->ui_visible = 0;
    }
  }

  else
    if(!(state == 0))
    {
      if(instance->ui_running == 0)
      {
        instance->ui_visible = 1;
        start_ui(instance);
      }

    }

}

// on_ui_context_menu_activate
// file gui_callbacks.c line 274
void on_ui_context_menu_activate(struct _GtkWidget *widget, void *data)
{
  signed int mode = (signed int)(signed long int)data;
  struct _d3h_instance_t *instance = ui_context_menu_instance;
  ghss_debug(256, " on_ui_context_menu_activate: menu mode %d selected", mode);
  switch(mode)
  {
    case 0:
    {
      if(instance->ui_osc_address == NULL)
      {
        instance->ui_visible = 1;
        start_ui(instance);
        update_ui_button_internal(instance, (signed int)!(0 != 0));
      }

      break;
    }
    case 1:
    {
      if(!(instance->ui_osc_address == NULL))
      {
        lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 295, instance->ui_osc_show_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
        instance->ui_visible = 1;
        update_ui_button_internal(instance, (signed int)!(0 != 0));
      }

      break;
    }
    case 2:
    {
      if(!(instance->ui_osc_address == NULL))
      {
        lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 303, instance->ui_osc_hide_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
        instance->ui_visible = 0;
        update_ui_button_internal(instance, 0);
      }

      break;
    }
    case 3:
    {
      if(!(instance->ui_osc_address == NULL))
      {
        lo_send_internal(instance->ui_osc_address, "gui_callbacks.c", 311, instance->ui_osc_quit_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
        ui_osc_free(instance);
      }

      instance->ui_running = 0;
      instance->ui_visible = 0;
      update_ui_button_internal(instance, 0);
    }
  }
}

// osc_configure_handler
// file ghostess.c line 2575
signed int osc_configure_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv)
{
  const char *key = (const char *)&argv[(signed long int)0]->s;
  const char *value = (const char *)&argv[(signed long int)1]->s;
  char *message;
  signed int i;
  struct _d3h_instance_t *inst;
  ghss_debug(64, " osc_configure_handler: UI for '%s' sent '%s', '%s'", instance->friendly_name, key, value);
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_1;
  signed int return_value_strncmp_2;
  if(instance->plugin->instances == 1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen("GLOBAL:");
    return_value_strncmp_2=strncmp(key, "GLOBAL:", return_value_strlen_1);
    tmp_if_expr_3 = return_value_strncmp_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    if(!(instance->plugin->descriptor->configure == ((char * (*)(void *, const char *, const char *))NULL)))
    {
      add_configure_item(&instance->configure_items, (char *)key, (char *)value);
      message=instance->plugin->descriptor->configure(instanceHandles[(signed long int)instance->number], key, value);
      if(!(message == ((char *)NULL)))
      {
        ghss_debug(8, ": on configure '%s' '%s', plugin '%s' returned '%s'", key, value, instance->friendly_name, message);
        free((void *)message);
      }

    }

    instance->pluginProgramsValid = 0;
    return 0;
  }

  else
  {
    i = 0;
    for( ; !(instances[(signed long int)i].plugin == instance->plugin); i = i + instances[(signed long int)i].plugin->instances)
      ;
    for( ; instances[(signed long int)i].plugin == instance->plugin; i = i + 1)
    {
      inst = &instances[(signed long int)i];
      if(!(inst->plugin->descriptor->configure == ((char * (*)(void *, const char *, const char *))NULL)))
      {
        add_configure_item(&inst->configure_items, (char *)key, (char *)value);
        message=inst->plugin->descriptor->configure(instanceHandles[(signed long int)i], key, value);
        if(!(message == ((char *)NULL)))
        {
          ghss_debug(8, ": on configure '%s' '%s', plugin '%s' returned '%s'", key, value, inst->friendly_name, message);
          free((void *)message);
        }

      }

      instance->pluginProgramsValid = 0;
      if(!(i == instance->number))
      {
        if(!(inst->ui_osc_address == NULL))
          lo_send_internal(inst->ui_osc_address, "ghostess.c", 2635, inst->ui_osc_configure_path, "ss", key, value, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

      }

    }
    return 0;
  }
}

// osc_control_handler
// file ghostess.c line 2516
signed int osc_control_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv)
{
  signed int port = argv[(signed long int)0]->i;
  float value = argv[(signed long int)1]->f;
  _Bool tmp_if_expr_1;
  if(!(port >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (unsigned long int)port > instance->plugin->descriptor->LADSPA_Plugin->PortCount ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    ghss_debug(64, " OSC control handler: %s port number (%d) is out of range", instance->friendly_name, port);
    return 0;
  }

  else
    if(instance->pluginPortControlInNumbers[(signed long int)port] == -1)
    {
      ghss_debug(64, " OSC control handler: %s port %d is not a control in", instance->friendly_name, port);
      return 0;
    }

    else
    {
      pluginControlIns[(signed long int)instance->pluginPortControlInNumbers[(signed long int)port]] = value;
      ghss_debug(64, " OSC control handler: %s port %d = %f", instance->friendly_name, port, value);
      return 0;
    }
}

// osc_debug_handler
// file ghostess.c line 2734
signed int osc_debug_handler(const char *path, const char *types, union anonymous_7 **argv, signed int argc, void *data, void *user_data)
{
  signed int i;
  ghss_debug(64, ": got unhandled OSC message:");
  ghss_debug(64, ": path: <%s>", path);
  fflush(stderr);
  i = 0;
  for( ; !(i >= argc); i = i + 1)
  {
    printf("%s: arg %d '%c' ", host_name, i, types[(signed long int)i]);
    lo_arg_pp((enum anonymous_15)types[(signed long int)i], (void *)argv[(signed long int)i]);
    printf("\n");
  }
  fflush(stdout);
  ghss_debug(64, ":");
  return 1;
}

// osc_error
// file ghostess.c line 2424
void osc_error(signed int num, const char *msg, const char *path)
{
  ghss_debug(64, ": liblo server error %d in path %s: %s", num, path, msg);
}

// osc_exiting_handler
// file ghostess.c line 2430
signed int osc_exiting_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv)
{
  ghss_debug(64, " OSC: got exiting notification from %s", instance->friendly_name);
  instance->ui_running = 0;
  if(!(instance->ui_osc_address == NULL))
    ui_osc_free(instance);

  update_from_exiting(instance);
  return 0;
}

// osc_message_handler
// file ghostess.c line 2753
signed int osc_message_handler(const char *path, const char *types, union anonymous_7 **argv, signed int argc, void *data, void *user_data)
{
  signed int i;
  struct _d3h_instance_t *instance = (struct _d3h_instance_t *)(void *)0;
  const char *method;
  unsigned int flen = (unsigned int)0;
  void *source;
  signed int send_to_ui = 0;
  signed int return_value_strncmp_2;
  return_value_strncmp_2=strncmp(path, "/dssi/", (unsigned long int)6);
  signed int return_value_osc_debug_handler_1;
  signed int return_value_osc_debug_handler_5;
  _Bool tmp_if_expr_7;
  signed int return_value_osc_debug_handler_6;
  signed int tmp_statement_expression_8;
  _Bool tmp_if_expr_16;
  signed int tmp_statement_expression_12;
  signed int tmp_statement_expression_44;
  _Bool tmp_if_expr_48;
  signed int tmp_statement_expression_46;
  signed int tmp_statement_expression_39;
  _Bool tmp_if_expr_43;
  signed int tmp_statement_expression_41;
  signed int tmp_statement_expression_37;
  signed int tmp_statement_expression_32;
  _Bool tmp_if_expr_36;
  signed int tmp_statement_expression_34;
  signed int tmp_statement_expression_27;
  _Bool tmp_if_expr_31;
  signed int tmp_statement_expression_29;
  signed int tmp_statement_expression_25;
  signed int tmp_statement_expression_23;
  if(!(return_value_strncmp_2 == 0))
  {
    return_value_osc_debug_handler_1=osc_debug_handler(path, types, argv, argc, data, user_data);
    return return_value_osc_debug_handler_1;
  }

  else
  {
    i = 0;
    for( ; !(i >= instance_count); i = i + 1)
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(instances[(signed long int)i].friendly_name);
      flen = (unsigned int)return_value_strlen_3;
      signed int return_value_strncmp_4;
      return_value_strncmp_4=strncmp(path + (signed long int)6, instances[(signed long int)i].friendly_name, (unsigned long int)flen);
      if(return_value_strncmp_4 == 0)
      {
        if((signed int)path[6l + (signed long int)flen] == 47)
        {
          instance = &instances[(signed long int)i];
          break;
        }

      }

    }
    if(instance == ((struct _d3h_instance_t *)NULL))
    {
      return_value_osc_debug_handler_5=osc_debug_handler(path, types, argv, argc, data, user_data);
      return return_value_osc_debug_handler_5;
    }

    else
    {
      method = path + (signed long int)6 + (signed long int)flen;
      if(!((signed int)*method == 47))
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)method[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
      {
        return_value_osc_debug_handler_6=osc_debug_handler(path, types, argv, argc, data, user_data);
        return return_value_osc_debug_handler_6;
      }

      else
      {
        method = method + 1l;
        source=lo_message_get_source((void *)data);
        if(!(instance->ui_osc_source == NULL))
        {
          if(!(instance->ui_osc_address == NULL))
          {
            unsigned long int osc_message_handler__1__3__1____s1_len;
            unsigned long int osc_message_handler__1__3__1____s2_len;
            const char *return_value_lo_address_get_hostname_9;
            return_value_lo_address_get_hostname_9=lo_address_get_hostname(source);
            const char *return_value_lo_address_get_hostname_10;
            return_value_lo_address_get_hostname_10=lo_address_get_hostname(instance->ui_osc_source);
            signed int return_value___builtin_strcmp_11;
            return_value___builtin_strcmp_11=__builtin_strcmp(return_value_lo_address_get_hostname_9, return_value_lo_address_get_hostname_10);
            tmp_statement_expression_8 = return_value___builtin_strcmp_11;
            if(!(tmp_statement_expression_8 == 0))
              tmp_if_expr_16 = (_Bool)1;

            else
            {
              unsigned long int __s1_len;
              unsigned long int __s2_len;
              const char *return_value_lo_address_get_port_13;
              return_value_lo_address_get_port_13=lo_address_get_port(source);
              const char *return_value_lo_address_get_port_14;
              return_value_lo_address_get_port_14=lo_address_get_port(instance->ui_osc_source);
              signed int return_value___builtin_strcmp_15;
              return_value___builtin_strcmp_15=__builtin_strcmp(return_value_lo_address_get_port_13, return_value_lo_address_get_port_14);
              tmp_statement_expression_12 = return_value___builtin_strcmp_15;
              tmp_if_expr_16 = tmp_statement_expression_12 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_16)
              send_to_ui = 1;

          }

        }

        unsigned long int osc_message_handler__1__4____s1_len;
        unsigned long int osc_message_handler__1__4____s2_len;
        signed int return_value___builtin_strcmp_45;
        return_value___builtin_strcmp_45=__builtin_strcmp(method, "configure");
        tmp_statement_expression_44 = return_value___builtin_strcmp_45;
        if(tmp_statement_expression_44 == 0 && argc == 2)
        {
          unsigned long int osc_message_handler__1__5____s1_len;
          unsigned long int osc_message_handler__1__5____s2_len;
          signed int return_value___builtin_strcmp_47;
          return_value___builtin_strcmp_47=__builtin_strcmp(types, "ss");
          tmp_statement_expression_46 = return_value___builtin_strcmp_47;
          tmp_if_expr_48 = !(tmp_statement_expression_46 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_48 = (_Bool)0;
        if(tmp_if_expr_48)
        {
          if(!(send_to_ui == 0))
            lo_send_internal(instance->ui_osc_address, "ghostess.c", 2799, instance->ui_osc_configure_path, "ss", &argv[(signed long int)0]->s, &argv[(signed long int)1]->s, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

          signed int return_value_osc_configure_handler_17;
          return_value_osc_configure_handler_17=osc_configure_handler(instance, argv);
          return return_value_osc_configure_handler_17;
        }

        else
        {
          unsigned long int osc_message_handler__1__7____s1_len;
          unsigned long int osc_message_handler__1__7____s2_len;
          signed int return_value___builtin_strcmp_40;
          return_value___builtin_strcmp_40=__builtin_strcmp(method, "control");
          tmp_statement_expression_39 = return_value___builtin_strcmp_40;
          if(tmp_statement_expression_39 == 0 && argc == 2)
          {
            unsigned long int osc_message_handler__1__8____s1_len;
            unsigned long int osc_message_handler__1__8____s2_len;
            signed int return_value___builtin_strcmp_42;
            return_value___builtin_strcmp_42=__builtin_strcmp(types, "if");
            tmp_statement_expression_41 = return_value___builtin_strcmp_42;
            tmp_if_expr_43 = !(tmp_statement_expression_41 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_43 = (_Bool)0;
          if(tmp_if_expr_43)
          {
            if(!(send_to_ui == 0))
              lo_send_internal(instance->ui_osc_address, "ghostess.c", 2808, instance->ui_osc_control_path, "if", argv[(signed long int)0]->i, argv[(signed long int)1]->f, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

            signed int return_value_osc_control_handler_18;
            return_value_osc_control_handler_18=osc_control_handler(instance, argv);
            return return_value_osc_control_handler_18;
          }

          else
          {
            unsigned long int osc_message_handler__1__10____s1_len;
            unsigned long int osc_message_handler__1__10____s2_len;
            signed int return_value___builtin_strcmp_38;
            return_value___builtin_strcmp_38=__builtin_strcmp(method, "exiting");
            tmp_statement_expression_37 = return_value___builtin_strcmp_38;
            if(tmp_statement_expression_37 == 0 && argc == 0)
            {
              signed int return_value_osc_exiting_handler_19;
              return_value_osc_exiting_handler_19=osc_exiting_handler(instance, argv);
              return return_value_osc_exiting_handler_19;
            }

            else
            {
              unsigned long int osc_message_handler__1__12____s1_len;
              unsigned long int osc_message_handler__1__12____s2_len;
              signed int return_value___builtin_strcmp_33;
              return_value___builtin_strcmp_33=__builtin_strcmp(method, "midi");
              tmp_statement_expression_32 = return_value___builtin_strcmp_33;
              if(tmp_statement_expression_32 == 0 && argc == 1)
              {
                unsigned long int osc_message_handler__1__13____s1_len;
                unsigned long int osc_message_handler__1__13____s2_len;
                signed int return_value___builtin_strcmp_35;
                return_value___builtin_strcmp_35=__builtin_strcmp(types, "m");
                tmp_statement_expression_34 = return_value___builtin_strcmp_35;
                tmp_if_expr_36 = !(tmp_statement_expression_34 != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_36 = (_Bool)0;
              if(tmp_if_expr_36)
              {
                signed int return_value_osc_midi_handler_20;
                return_value_osc_midi_handler_20=osc_midi_handler(instance, argv);
                return return_value_osc_midi_handler_20;
              }

              else
              {
                unsigned long int osc_message_handler__1__15____s1_len;
                unsigned long int osc_message_handler__1__15____s2_len;
                signed int return_value___builtin_strcmp_28;
                return_value___builtin_strcmp_28=__builtin_strcmp(method, "program");
                tmp_statement_expression_27 = return_value___builtin_strcmp_28;
                if(tmp_statement_expression_27 == 0 && argc == 2)
                {
                  unsigned long int osc_message_handler__1__16____s1_len;
                  unsigned long int osc_message_handler__1__16____s2_len;
                  signed int return_value___builtin_strcmp_30;
                  return_value___builtin_strcmp_30=__builtin_strcmp(types, "ii");
                  tmp_statement_expression_29 = return_value___builtin_strcmp_30;
                  tmp_if_expr_31 = !(tmp_statement_expression_29 != 0) ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_31 = (_Bool)0;
                if(tmp_if_expr_31)
                {
                  if(!(send_to_ui == 0))
                    lo_send_internal(instance->ui_osc_address, "ghostess.c", 2825, instance->ui_osc_program_path, "ii", argv[(signed long int)0]->i, argv[(signed long int)1]->i, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);

                  signed int return_value_osc_program_handler_21;
                  return_value_osc_program_handler_21=osc_program_handler(instance, argv);
                  return return_value_osc_program_handler_21;
                }

                else
                {
                  unsigned long int osc_message_handler__1__18____s1_len;
                  unsigned long int osc_message_handler__1__18____s2_len;
                  signed int return_value___builtin_strcmp_26;
                  return_value___builtin_strcmp_26=__builtin_strcmp(method, "update");
                  tmp_statement_expression_25 = return_value___builtin_strcmp_26;
                  if(tmp_statement_expression_25 == 0)
                  {
                    if(argc == 1)
                    {
                      unsigned long int osc_message_handler__1__19____s1_len;
                      unsigned long int osc_message_handler__1__19____s2_len;
                      signed int return_value___builtin_strcmp_24;
                      return_value___builtin_strcmp_24=__builtin_strcmp(types, "s");
                      tmp_statement_expression_23 = return_value___builtin_strcmp_24;
                      if(tmp_statement_expression_23 == 0)
                      {
                        signed int return_value_osc_update_handler_22;
                        return_value_osc_update_handler_22=osc_update_handler(instance, argv, source);
                        return return_value_osc_update_handler_22;
                      }

                    }

                  }

                }
              }
            }
          }
        }
        signed int return_value_osc_debug_handler_49;
        return_value_osc_debug_handler_49=osc_debug_handler(path, types, argv, argc, data, user_data);
        return return_value_osc_debug_handler_49;
      }
    }
  }
}

// osc_midi_handler
// file ghostess.c line 2447
signed int osc_midi_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv)
{
  signed long int count;
  static struct snd_seq_event alsaEncodeBuffer[10l];
  struct snd_seq_event *ev = &alsaEncodeBuffer[(signed long int)0];
  ghss_debug(64, " OSC: got midi request for %s (%02x %02x %02x %02x)", instance->friendly_name, argv[(signed long int)0]->m[(signed long int)0], argv[(signed long int)0]->m[(signed long int)1], argv[(signed long int)0]->m[(signed long int)2], argv[(signed long int)0]->m[(signed long int)3]);
  static struct snd_midi_event *alsaCoder = (struct snd_midi_event *)(void *)0;
  if(alsaCoder == ((struct snd_midi_event *)NULL))
  {
    signed int return_value_snd_midi_event_new_1;
    return_value_snd_midi_event_new_1=snd_midi_event_new((unsigned long int)10, &alsaCoder);
    if(!(return_value_snd_midi_event_new_1 == 0))
    {
      ghss_debug(64, " OSC midi handler: Failed to initialise ALSA MIDI coder!");
      return 0;
    }

  }

  snd_midi_event_reset_encode(alsaCoder);
  count=snd_midi_event_encode(alsaCoder, argv[(signed long int)0]->m + (signed long int)1, (signed long int)3, alsaEncodeBuffer);
  _Bool tmp_if_expr_2;
  if(count == 0l)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !((snd_seq_event_types[(signed long int)ev->type] & (unsigned int)(1 << 1 | 1 << 2)) != 0u) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    ev->dest.client = (unsigned char)1;
    ev->dest.port = (unsigned char)instance->number;
    ev->time.tick = (unsigned int)0;
    if((signed int)ev->type == 6)
    {
      if((signed int)ev->data.note.velocity == 0)
        ev->type = (unsigned char)7;

    }

    pthread_mutex_lock(&midiEventBufferMutex);
    if(midiEventReadIndex == 1 + midiEventWriteIndex)
      ghss_debug(64, " OSC midi handler warning: MIDI event buffer overflow!");

    else
    {
      if((signed int)ev->type == 10)
      {
        if(ev->data.control.param == 0u)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = ev->data.control.param == (unsigned int)32 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        ghss_debug(64, " OSC midi handler warning: %s UI sent bank select controller (should use /program OSC call), ignoring", instance->friendly_name);

      else
        if((signed int)ev->type == 11)
          ghss_debug(64, " OSC midi handler warning: %s UI sent program change (should use /program OSC call), ignoring", instance->friendly_name);

        else
        {
          midiEventBuffer[(signed long int)midiEventWriteIndex] = *ev;
          midiEventWriteIndex = (midiEventWriteIndex + 1) % 1024;
        }
    }
    pthread_mutex_unlock(&midiEventBufferMutex);
    return 0;
  }
}

// osc_program_handler
// file ghostess.c line 2539
signed int osc_program_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv)
{
  signed int bank = argv[(signed long int)0]->i;
  signed int program = argv[(signed long int)1]->i;
  signed int i;
  signed int found = 0;
  if(!((64 & debug_flags) == 0))
  {
    if(instance->pluginProgramsValid == 0)
      query_programs(instance);

    i = 0;
    for( ; !(i >= instance->pluginProgramCount); i = i + 1)
      if((instance->pluginPrograms + (signed long int)i)->Bank == (unsigned long int)bank)
      {
        if((instance->pluginPrograms + (signed long int)i)->Program == (unsigned long int)program)
        {
          ghss_debug(64, " OSC program handler: %s setting bank %d, program %d, name %s", instance->friendly_name, bank, program, (instance->pluginPrograms + (signed long int)i)->Name);
          found = 1;
          break;
        }

      }

    if(found == 0)
      ghss_debug(64, " OSC program handler: %s UI requested unknown program: bank %d, program %d: sending to plugin anyway (plugin should ignore it)", instance->friendly_name, bank, program);

  }

  instance->pendingBankMSB = bank / 128;
  instance->pendingBankLSB = bank % 128;
  instance->pendingProgramChange = program;
  return 0;
}

// osc_update_handler
// file ghostess.c line 2643
signed int osc_update_handler(struct _d3h_instance_t *instance, union anonymous_7 **argv, void *source)
{
  const char *url = (char *)&argv[(signed long int)0]->s;
  const char *path;
  unsigned int i;
  char *host;
  char *port;
  struct _configure_item_t *item;
  printf("%s: OSC: got update request from <%s>\n", host_name, url);
  if(!(instance->ui_osc_address == NULL))
    lo_address_free(instance->ui_osc_address);

  host=lo_url_get_hostname(url);
  port=lo_url_get_port(url);
  instance->ui_osc_address=lo_address_new(host, port);
  free((void *)host);
  free((void *)port);
  if(!(instance->ui_osc_source == NULL))
    lo_address_free(instance->ui_osc_source);

  const char *return_value_lo_address_get_hostname_1;
  return_value_lo_address_get_hostname_1=lo_address_get_hostname(source);
  host = (char *)return_value_lo_address_get_hostname_1;
  const char *return_value_lo_address_get_port_2;
  return_value_lo_address_get_port_2=lo_address_get_port(source);
  port = (char *)return_value_lo_address_get_port_2;
  instance->ui_osc_source=lo_address_new(host, port);
  path=lo_url_get_path(url);
  if(!(instance->ui_osc_configure_path == ((char *)NULL)))
    free((void *)instance->ui_osc_configure_path);

  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(path);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(return_value_strlen_3 + (unsigned long int)11);
  instance->ui_osc_configure_path = (char *)return_value_malloc_4;
  sprintf(instance->ui_osc_configure_path, "%s/configure", path);
  if(!(instance->ui_osc_control_path == ((char *)NULL)))
    free((void *)instance->ui_osc_control_path);

  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(path);
  void *return_value_malloc_6;
  return_value_malloc_6=malloc(return_value_strlen_5 + (unsigned long int)10);
  instance->ui_osc_control_path = (char *)return_value_malloc_6;
  sprintf(instance->ui_osc_control_path, "%s/control", path);
  if(!(instance->ui_osc_hide_path == ((char *)NULL)))
    free((void *)instance->ui_osc_hide_path);

  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(path);
  void *return_value_malloc_8;
  return_value_malloc_8=malloc(return_value_strlen_7 + (unsigned long int)10);
  instance->ui_osc_hide_path = (char *)return_value_malloc_8;
  sprintf(instance->ui_osc_hide_path, "%s/hide", path);
  if(!(instance->ui_osc_program_path == ((char *)NULL)))
    free((void *)instance->ui_osc_program_path);

  unsigned long int return_value_strlen_9;
  return_value_strlen_9=strlen(path);
  void *return_value_malloc_10;
  return_value_malloc_10=malloc(return_value_strlen_9 + (unsigned long int)10);
  instance->ui_osc_program_path = (char *)return_value_malloc_10;
  sprintf(instance->ui_osc_program_path, "%s/program", path);
  if(!(instance->ui_osc_rate_path == ((char *)NULL)))
    free((void *)instance->ui_osc_rate_path);

  unsigned long int return_value_strlen_11;
  return_value_strlen_11=strlen(path);
  void *return_value_malloc_12;
  return_value_malloc_12=malloc(return_value_strlen_11 + (unsigned long int)13);
  instance->ui_osc_rate_path = (char *)return_value_malloc_12;
  sprintf(instance->ui_osc_rate_path, "%s/sample-rate", path);
  if(!(instance->ui_osc_show_path == ((char *)NULL)))
    free((void *)instance->ui_osc_show_path);

  unsigned long int return_value_strlen_13;
  return_value_strlen_13=strlen(path);
  void *return_value_malloc_14;
  return_value_malloc_14=malloc(return_value_strlen_13 + (unsigned long int)10);
  instance->ui_osc_show_path = (char *)return_value_malloc_14;
  sprintf(instance->ui_osc_show_path, "%s/show", path);
  if(!(instance->ui_osc_quit_path == ((char *)NULL)))
    free((void *)instance->ui_osc_quit_path);

  unsigned long int return_value_strlen_15;
  return_value_strlen_15=strlen(path);
  void *return_value_malloc_16;
  return_value_malloc_16=malloc(return_value_strlen_15 + (unsigned long int)10);
  instance->ui_osc_quit_path = (char *)return_value_malloc_16;
  sprintf(instance->ui_osc_quit_path, "%s/quit", path);
  free((void *)(char *)path);
  signed long int return_value_lrintf_17;
  return_value_lrintf_17=lrintf(sample_rate);
  lo_send_internal(instance->ui_osc_address, "ghostess.c", 2698, instance->ui_osc_rate_path, "i", return_value_lrintf_17, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
  item = instance->configure_items;
  for( ; !(item == ((struct _configure_item_t *)NULL)); item = item->next)
    lo_send_internal(instance->ui_osc_address, "ghostess.c", 2703, instance->ui_osc_configure_path, "ss", item->key, item->value, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
  if(!(instance->plugin->descriptor->select_program == ((void (*)(void *, unsigned long int, unsigned long int))NULL)))
  {
    if(!(instance->pendingProgramChange >= 0))
    {
      unsigned long int bank = (unsigned long int)instance->currentBank;
      unsigned long int program = (unsigned long int)instance->currentProgram;
      instance->uiNeedsProgramUpdate = 0;
      lo_send_internal(instance->ui_osc_address, "ghostess.c", 2713, instance->ui_osc_program_path, "ii", bank, program, (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
    }

  }

  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)instance->plugin->controlIns); i = i + 1u)
  {
    signed int in = (signed int)(i + (unsigned int)instance->firstControlIn);
    signed int osc_update_handler__1__3__1__port = (signed int)pluginControlInPortNumbers[(signed long int)in];
    lo_send_internal(instance->ui_osc_address, "ghostess.c", 2721, instance->ui_osc_control_path, "if", osc_update_handler__1__3__1__port, pluginControlIns[(signed long int)in], (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
    if(i % 50u == 49u)
      usleep((unsigned int)300000);

  }
  if(!(instance->ui_visible == 0))
  {
    if(instance->ui_initial_show_sent == 0)
    {
      lo_send_internal(instance->ui_osc_address, "ghostess.c", 2727, instance->ui_osc_show_path, "", (void *)0xdeadbeefdeadbeefL, (void *)0xf00baa23f00baa23L);
      instance->ui_initial_show_sent = 1;
    }

  }

  return 0;
}

// query_programs
// file ghostess.c line 1267
void query_programs(struct _d3h_instance_t *instance)
{
  signed int i;
  const struct _DSSI_Program_Descriptor *descriptor;
  if(instance->pluginProgramsValid == 0)
  {
    if(instance->plugin->descriptor->get_program == ((const struct _DSSI_Program_Descriptor * (*)(void *, unsigned long int))NULL))
    {
      instance->pluginProgramsValid = 1;
      instance->pluginProgramCount = 0;
    }

    else
    {
      i = 0;
      for( ; !(i >= instance->pluginProgramCount); i = i + 1)
        free((void *)(instance->pluginPrograms + (signed long int)i)->Name);
      instance->pluginProgramCount = 0;
      i = 0;
      descriptor=instance->plugin->descriptor->get_program(instanceHandles[(signed long int)instance->number], (unsigned long int)i);
      if(!(descriptor == ((const struct _DSSI_Program_Descriptor *)NULL)))
      {
        if(i >= instance->pluginProgramsAlloc)
        {
          instance->pluginProgramsAlloc = instance->pluginProgramsAlloc + 128;
          void *return_value_realloc_1;
          return_value_realloc_1=realloc((void *)instance->pluginPrograms, (unsigned long int)instance->pluginProgramsAlloc * sizeof(struct _DSSI_Program_Descriptor) /*24ul*/ );
          instance->pluginPrograms = (struct _DSSI_Program_Descriptor *)return_value_realloc_1;
        }

        (instance->pluginPrograms + (signed long int)i)->Bank = descriptor->Bank;
        (instance->pluginPrograms + (signed long int)i)->Program = descriptor->Program;
        char *return_value___strdup_2;
        return_value___strdup_2=__strdup(descriptor->Name);
        (instance->pluginPrograms + (signed long int)i)->Name = return_value___strdup_2;
        ghss_debug(128, " %s: program %d is MIDI bank %lu program %lu, named '%s'", instance->friendly_name, i, (instance->pluginPrograms + (signed long int)i)->Bank, (instance->pluginPrograms + (signed long int)i)->Program, (instance->pluginPrograms + (signed long int)i)->Name);
        instance->pluginProgramCount = instance->pluginProgramCount + 1;
        i = i + 1;
      }

      instance->pluginProgramsValid = 1;
    }
  }

}

// reset_instance_template
// file ghostess.c line 757
static void reset_instance_template(struct _instance_template_t *t)
{
  struct _configure_item_t *c;
  signed int i;
  do
  {
    c = t->configure_items;
    if(c == ((struct _configure_item_t *)NULL))
      break;

    t->configure_items = c->next;
    free((void *)c->key);
    free((void *)c->value);
    free((void *)c);
  }
  while((_Bool)1);
  t->program_set = 0;
  t->bank = (unsigned long int)0;
  t->program = (unsigned long int)0;
  t->ports.have_settings = 0;
  t->ports.highest_set = (unsigned long int)0;
  i = 0;
  for( ; !((unsigned long int)i >= t->ports.allocated); i = i + 1)
    t->ports.set[(signed long int)i] = 0;
}

// session_callback
// file ghostess.c line 657
void session_callback(struct _jack_session_event *event, void *arg)
{
  g_idle_add(session_gui_idle_callback, (void *)event);
}

// session_gui_idle_callback
// file ghostess.c line 627
signed int session_gui_idle_callback(void *arg)
{
  char *filename;
  char *command;
  struct _jack_session_event *session_event = (struct _jack_session_event *)arg;
  filename=g_strdup_printf("%sghostess.cfg", session_event->session_dir);
  command = "/bin/sh _{SESSION_DIR}ghostess.cfg";
  ghss_debug(2 | 256, " session_gui_idle_callback: %s to '%s'", (signed int)session_event->type == JackSessionSaveAndQuit ? "save-and-quit" : "save", filename);
  write_configuration(filename, session_event->client_uuid);
  g_free((void *)filename);
  session_event->command_line=g_strdup(command);
  jack_session_reply(jackClient, session_event);
  if((signed int)session_event->type == JackSessionSaveAndQuit)
    host_exiting = (signed int)!(0 != 0);

  jack_session_event_free(session_event);
  return 0;
}

// setControl
// file ghostess.c line 176
void setControl(struct _d3h_instance_t *instance, signed long int controlIn, struct snd_seq_event *event)
{
  signed long int port = (signed long int)pluginControlInPortNumbers[controlIn];
  const struct _LADSPA_Descriptor *p = instance->plugin->descriptor->LADSPA_Plugin;
  signed int d = (p->PortRangeHints + port)->HintDescriptor;
  float lb = (p->PortRangeHints + port)->LowerBound;
  float ub = (p->PortRangeHints + port)->UpperBound;
  float value = (float)event->data.control.value;
  if(!((0x8 & d) == 0))
  {
    lb = lb * sample_rate;
    ub = ub * sample_rate;
  }

  if((0x1 & d) == 0)
  {
    if((0x2 & d) == 0)
      goto __CPROVER_DUMP_L9;

    else
      value = (ub - 127.0f) + value;
  }

  else
    if((0x2 & d) == 0)
      value = lb + value;

    else
      if(lb > 0.0f && ub > 0.0f && !((0x10 & d) == 0))
      {
        lb=logf(lb);
        ub=logf(ub);
        value = lb + ((ub - lb) * value) / 127.0f;
        value=expf(value);
      }

      else
        value = lb + ((ub - lb) * value) / 127.0f;
  if(!((0x20 & d) == 0))
  {
    signed long int return_value_lrintf_1;
    return_value_lrintf_1=lrintf(value);
    value = (float)return_value_lrintf_1;
  }

  ghss_debug(16, ": %s MIDI controller %d=%d -> control in %ld=%f", instance->friendly_name, event->data.control.param, event->data.control.value, controlIn, value);
  pluginControlIns[controlIn] = value;
  pluginPortUpdated[controlIn] = 1;

__CPROVER_DUMP_L9:
  ;
}

// set_initial_port_settings
// file ghostess.c line 817
void set_initial_port_settings(struct _d3h_instance_t *instance)
{
  signed int i;
  signed int in;
  i = 0;
  for( ; !((unsigned long int)i >= instance->plugin->descriptor->LADSPA_Plugin->PortCount); i = i + 1)
    if(!(instance->initial_value_set[(signed long int)i] == 0))
    {
      in = instance->pluginPortControlInNumbers[(signed long int)i];
      pluginControlIns[(signed long int)in] = instance->initial_value[(signed long int)i];
      pluginPortUpdated[(signed long int)in] = 1;
    }

}

// signalHandler
// file ghostess.c line 168
void signalHandler(signed int sig)
{
  ghss_debug(2, ": signal caught, trying to clean up and exit");
  host_exiting = 1;
}

// start_ui
// file ghostess.c line 1079
void start_ui(struct _d3h_instance_t *instance)
{
  const char *directory = instance->plugin->dll->directory;
  const char *dllName = instance->plugin->dll->name;
  const char *label = instance->plugin->descriptor->LADSPA_Plugin->Label;
  struct dirent *entry;
  char *dllBase;
  char *return_value___strdup_1;
  return_value___strdup_1=__strdup(dllName);
  dllBase = return_value___strdup_1;
  char *subpath;
  char *path;
  char *origPath;
  struct __dirstream *subdir;
  char *filename;
  struct stat buf;
  char *osc_url;
  char tag[12l];
  signed int fuzzy;
  signed int pid;
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(dllBase);
  unsigned long int return_value_strlen_3;
  signed int return_value_strcasecmp_4;
  if(return_value_strlen_5 >= 4ul)
  {
    return_value_strlen_3=strlen(dllBase);
    return_value_strcasecmp_4=strcasecmp((dllBase + (signed long int)return_value_strlen_3) - (signed long int)3, ".so");
    if(return_value_strcasecmp_4 == 0)
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(dllBase);
      dllBase[(signed long int)(return_value_strlen_2 - (unsigned long int)3)] = (char)0;
    }

  }

  if((signed int)*dllBase == 47)
  {
    subpath = dllBase;
    char *return_value_strrchr_6;
    return_value_strrchr_6=strrchr(subpath, 47);
    char *return_value___strdup_7;
    return_value___strdup_7=__strdup(return_value_strrchr_6 + (signed long int)1);
    dllBase = return_value___strdup_7;
  }

  else
  {
    unsigned long int return_value_strlen_8;
    return_value_strlen_8=strlen(directory);
    unsigned long int return_value_strlen_9;
    return_value_strlen_9=strlen(dllBase);
    void *return_value_malloc_10;
    return_value_malloc_10=malloc(return_value_strlen_8 + return_value_strlen_9 + (unsigned long int)2);
    subpath = (char *)return_value_malloc_10;
    sprintf(subpath, "%s/%s", directory, dllBase);
  }
  fuzzy = 0;
  _Bool tmp_if_expr_16;
  unsigned long int return_value_strlen_14;
  signed int return_value_strncmp_15;
  _Bool tmp_if_expr_18;
  unsigned long int return_value_strlen_17;
  _Bool tmp_if_expr_23;
  unsigned long int return_value_strlen_21;
  signed int return_value_strncmp_22;
  _Bool tmp_if_expr_25;
  unsigned long int return_value_strlen_24;
  for( ; !(fuzzy >= 2); fuzzy = fuzzy + 1)
  {
    subdir=opendir(subpath);
    if(subdir == ((struct __dirstream *)NULL))
    {
      ghss_debug(32, " warning: can't open plugin UI directory '%s'", subpath);
      break;
    }

    do
    {
      entry=readdir(subdir);
      if(entry == ((struct dirent *)NULL))
        break;

      if(!((signed int)entry->d_name[0l] == 46))
      {
        char *return_value___builtin_strchr_11;
        return_value___builtin_strchr_11=__builtin_strchr(entry->d_name, 95);
        if(!(return_value___builtin_strchr_11 == ((char *)NULL)))
        {
          if(!(fuzzy == 0))
          {
            ghss_debug(32, ": checking %s against %s", (const void *)entry->d_name, dllBase);
            unsigned long int return_value_strlen_12;
            return_value_strlen_12=strlen(entry->d_name);
            unsigned long int return_value_strlen_13;
            return_value_strlen_13=strlen(dllBase);
            if(return_value_strlen_13 >= return_value_strlen_12)
              tmp_if_expr_16 = (_Bool)1;

            else
            {
              return_value_strlen_14=strlen(dllBase);
              return_value_strncmp_15=strncmp(entry->d_name, dllBase, return_value_strlen_14);
              tmp_if_expr_16 = return_value_strncmp_15 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_16)
              tmp_if_expr_18 = (_Bool)1;

            else
            {
              return_value_strlen_17=strlen(dllBase);
              tmp_if_expr_18 = (signed int)entry->d_name[(signed long int)return_value_strlen_17] != 95 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_18)
              continue;

          }

          else
          {
            ghss_debug(32, ": checking %s against %s", (const void *)entry->d_name, label);
            unsigned long int return_value_strlen_19;
            return_value_strlen_19=strlen(entry->d_name);
            unsigned long int return_value_strlen_20;
            return_value_strlen_20=strlen(label);
            if(return_value_strlen_20 >= return_value_strlen_19)
              tmp_if_expr_23 = (_Bool)1;

            else
            {
              return_value_strlen_21=strlen(label);
              return_value_strncmp_22=strncmp(entry->d_name, label, return_value_strlen_21);
              tmp_if_expr_23 = return_value_strncmp_22 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_23)
              tmp_if_expr_25 = (_Bool)1;

            else
            {
              return_value_strlen_24=strlen(label);
              tmp_if_expr_25 = (signed int)entry->d_name[(signed long int)return_value_strlen_24] != 95 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_25)
              continue;

          }
          unsigned long int return_value_strlen_26;
          return_value_strlen_26=strlen(subpath);
          unsigned long int return_value_strlen_27;
          return_value_strlen_27=strlen(entry->d_name);
          void *return_value_malloc_28;
          return_value_malloc_28=malloc(return_value_strlen_26 + return_value_strlen_27 + (unsigned long int)2);
          filename = (char *)return_value_malloc_28;
          sprintf(filename, "%s/%s", subpath, (const void *)entry->d_name);
          signed int return_value_stat_31;
          return_value_stat_31=stat(filename, &buf);
          if(!(return_value_stat_31 == 0))
          {
            signed int *return_value___errno_location_29;
            return_value___errno_location_29=__errno_location();
            char *return_value_strerror_30;
            return_value_strerror_30=strerror(*return_value___errno_location_29);
            ghss_debug(32, ": stat of UI %s failed: %s", return_value_strerror_30);
            free((void *)filename);
            continue;
          }

          if(!((73u & buf.st_mode) == 0u) && ((61440u & buf.st_mode) == 32768u || (61440u & buf.st_mode) == 40960u))
          {
            unsigned long int return_value_strlen_32;
            return_value_strlen_32=strlen(host_osc_url);
            unsigned long int return_value_strlen_33;
            return_value_strlen_33=strlen(instance->friendly_name);
            void *return_value_malloc_34;
            return_value_malloc_34=malloc(return_value_strlen_32 + return_value_strlen_33 + (unsigned long int)7);
            osc_url = (char *)return_value_malloc_34;
            sprintf(osc_url, "%sdssi/%s", host_osc_url, instance->friendly_name);
            snprintf(tag, (unsigned long int)12, "Inst %d", instance->id);
            ghss_debug(32, ": trying to execute UI '%s', URL to host will be '%s'", filename, osc_url);
            pid=fork();
            if(pid == 0)
            {
              signed int return_value_fork_37;
              return_value_fork_37=fork();
              if(return_value_fork_37 == 0)
              {
                execlp(filename, filename, osc_url, dllName, label, (const void *)tag, (void *)0);
                signed int *return_value___errno_location_35;
                return_value___errno_location_35=__errno_location();
                char *return_value_strerror_36;
                return_value_strerror_36=strerror(*return_value___errno_location_35);
                ghss_debug(1, ": exec of UI failed: %s", return_value_strerror_36);
              }

              _exit(1);
            }

            else
              if(pid >= 1)
                waitpid(pid, (signed int *)(void *)0, 0);

            instance->ui_running = 1;
            instance->ui_initial_show_sent = 0;
            free((void *)osc_url);
            free((void *)filename);
            closedir(subdir);
            free((void *)subpath);
            free((void *)dllBase);
            goto __CPROVER_DUMP_L36;
          }

          free((void *)filename);
        }

      }

    }
    while((_Bool)1);
    closedir(subdir);
  }
  free((void *)subpath);
  free((void *)dllBase);
  origPath=getenv("PATH");
  if(!(origPath == ((char *)NULL)))
  {
    char *return_value___strdup_38;
    return_value___strdup_38=__strdup(origPath);
    path = return_value___strdup_38;
    origPath = path;
    do
    {
      subpath=strtok(path, ":");
      if(subpath == ((char *)NULL))
        break;

      path = ((char *)NULL);
      if(!((signed int)*subpath == 47))
        ghss_debug(32, ": ignoring PATH relative subpath '%s'", subpath);

      else
      {
        unsigned long int return_value_strlen_39;
        return_value_strlen_39=strlen(subpath);
        void *return_value_malloc_40;
        return_value_malloc_40=malloc(return_value_strlen_39 + (unsigned long int)24);
        filename = (char *)return_value_malloc_40;
        sprintf(filename, "%s/ghostess_universal_gui", subpath);
        signed int return_value_stat_41;
        return_value_stat_41=stat(filename, &buf);
        if(!(return_value_stat_41 == 0))
          free((void *)filename);

        else
        {
          if(!((73u & buf.st_mode) == 0u) && ((61440u & buf.st_mode) == 32768u || (61440u & buf.st_mode) == 40960u))
          {
            unsigned long int return_value_strlen_42;
            return_value_strlen_42=strlen(host_osc_url);
            unsigned long int return_value_strlen_43;
            return_value_strlen_43=strlen(instance->friendly_name);
            void *return_value_malloc_44;
            return_value_malloc_44=malloc(return_value_strlen_42 + return_value_strlen_43 + (unsigned long int)7);
            osc_url = (char *)return_value_malloc_44;
            sprintf(osc_url, "%sdssi/%s", host_osc_url, instance->friendly_name);
            snprintf(tag, (unsigned long int)12, "Inst %d", instance->id);
            ghss_debug(32, ": trying to execute universal GUI '%s', URL to host will be '%s'", filename, osc_url);
            pid=fork();
            if(pid == 0)
            {
              signed int return_value_fork_47;
              return_value_fork_47=fork();
              if(return_value_fork_47 == 0)
              {
                execlp(filename, filename, osc_url, dllName, label, (const void *)tag, (void *)0);
                signed int *return_value___errno_location_45;
                return_value___errno_location_45=__errno_location();
                char *return_value_strerror_46;
                return_value_strerror_46=strerror(*return_value___errno_location_45);
                ghss_debug(1, ": exec of universal GUI failed: %s", return_value_strerror_46);
              }

              exit(1);
            }

            else
              if(pid >= 1)
                waitpid(pid, (signed int *)(void *)0, 0);

            instance->ui_running = 1;
            instance->ui_initial_show_sent = 0;
            free((void *)osc_url);
            free((void *)filename);
            goto __CPROVER_DUMP_L36;
          }

          free((void *)filename);
        }
      }
    }
    while((_Bool)1);
    free((void *)origPath);
  }

  ghss_debug(32, ": no UI found for plugin '%s'", label);

__CPROVER_DUMP_L36:
  ;
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat_1;
  return_value___xstat_1=__xstat(1, __path, __statbuf);
  return return_value___xstat_1;
}

// ui_osc_free
// file ghostess.c line 1055
void ui_osc_free(struct _d3h_instance_t *instance)
{
  lo_address_free(instance->ui_osc_address);
  if(!(instance->ui_osc_source == NULL))
    lo_address_free(instance->ui_osc_source);

  free((void *)instance->ui_osc_control_path);
  free((void *)instance->ui_osc_configure_path);
  free((void *)instance->ui_osc_hide_path);
  free((void *)instance->ui_osc_program_path);
  free((void *)instance->ui_osc_quit_path);
  free((void *)instance->ui_osc_rate_path);
  free((void *)instance->ui_osc_show_path);
  instance->ui_osc_address = (void *)0;
  instance->ui_osc_source = (void *)0;
  instance->ui_osc_control_path = (char *)(void *)0;
  instance->ui_osc_configure_path = (char *)(void *)0;
  instance->ui_osc_hide_path = (char *)(void *)0;
  instance->ui_osc_program_path = (char *)(void *)0;
  instance->ui_osc_quit_path = (char *)(void *)0;
  instance->ui_osc_rate_path = (char *)(void *)0;
  instance->ui_osc_show_path = (char *)(void *)0;
}

// update_eyecandy
// file gui_callbacks.h line 47
void update_eyecandy(struct _d3h_instance_t *instance)
{
  signed int state = (signed int)(main_timeout_tick - instance->midi_activity_tick <= 1);
  if(!(instance->strip->previous_midi_state == state))
  {
    unsigned long int return_value_blinky_get_type_1;
    return_value_blinky_get_type_1=blinky_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)instance->strip->midi_status, return_value_blinky_get_type_1);
    blinky_set_state((struct _Blinky *)return_value_g_type_check_instance_cast_2, (unsigned int)state);
    instance->strip->previous_midi_state = state;
  }

}

// update_from_exiting
// file gui_callbacks.h line 46
void update_from_exiting(struct _d3h_instance_t *instance)
{
  update_ui_button_internal(instance, 0);
}

// update_ui_button_internal
// file gui_callbacks.c line 260
void update_ui_button_internal(struct _d3h_instance_t *instance, signed int value)
{
  unsigned long int return_value_gtk_object_get_type_1;
  return_value_gtk_object_get_type_1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)instance->strip->ui_button, return_value_gtk_object_get_type_1);
  gtk_signal_compat_matched((struct _GtkObject *)return_value_g_type_check_instance_cast_2, (void (*)(void))on_strip_ui_button_toggled, (void *)instance->strip, (enum anonymous_9)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)1);
  unsigned long int return_value_gtk_toggle_button_get_type_3;
  return_value_gtk_toggle_button_get_type_3=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)instance->strip->ui_button, return_value_gtk_toggle_button_get_type_3);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_4, value);
  unsigned long int return_value_gtk_object_get_type_5;
  return_value_gtk_object_get_type_5=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)instance->strip->ui_button, return_value_gtk_object_get_type_5);
  gtk_signal_compat_matched((struct _GtkObject *)return_value_g_type_check_instance_cast_6, (void (*)(void))on_strip_ui_button_toggled, (void *)instance->strip, (enum anonymous_9)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)2);
}

// write_configuration
// file ghostess.c line 911
signed int write_configuration(char *filename, const char *uuid)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  signed int rc = 0;
  signed int id;
  signed int instno;
  signed int i;
  signed int in;
  signed int port;
  struct _d3h_instance_t *instance;
  char *arg1 = (char *)(void *)0;
  char *arg2 = (char *)(void *)0;
  struct _configure_item_t *item;
  fp=fopen(filename, "w");
  signed int return_value_fprintf_1;
  signed int return_value_fprintf_3;
  signed int tmp_statement_expression_5;
  signed int tmp_statement_expression_13;
  signed int return_value_fprintf_18;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    return_value_fprintf_1=fprintf(fp, "#!/bin/sh\n");
    if(return_value_fprintf_1 >= 0)
    {
      if(!(dssi_path == ((char *)NULL)))
      {
        escape_for_shell(&arg1, dssi_path);
        signed int return_value_fprintf_2;
        return_value_fprintf_2=fprintf(fp, "DSSI_PATH=%s\nexport DSSI_PATH\n", arg1);
        if(!(return_value_fprintf_2 >= 0))
          goto error;

      }

      return_value_fprintf_3=fprintf(fp, "exec %s \\\n", host_argv0);
      if(return_value_fprintf_3 >= 0)
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_6;
        return_value___builtin_strcmp_6=__builtin_strcmp(host_name, host_name_default);
        tmp_statement_expression_5 = return_value___builtin_strcmp_6;
        if(!(tmp_statement_expression_5 == 0))
        {
          escape_for_shell(&arg1, host_name);
          signed int return_value_fprintf_4;
          return_value_fprintf_4=fprintf(fp, " -hostname %s \\\n", arg1);
          if(!(return_value_fprintf_4 >= 0))
            goto error;

        }

        if(!(project_directory == ((char *)NULL)))
        {
          escape_for_shell(&arg1, project_directory);
          signed int return_value_fprintf_7;
          return_value_fprintf_7=fprintf(fp, " -projdir %s \\\n", arg1);
          if(!(return_value_fprintf_7 >= 0))
            goto error;

        }

        if(!(uuid == ((const char *)NULL)))
        {
          escape_for_shell(&arg1, uuid);
          signed int return_value_fprintf_8;
          return_value_fprintf_8=fprintf(fp, " -uuid %s \\\n", arg1);
          if(!(return_value_fprintf_8 >= 0))
            goto error;

        }

        if(autoconnect == 0 || !(uuid == ((const char *)NULL)))
        {
          signed int return_value_fprintf_9;
          return_value_fprintf_9=fprintf(fp, " -noauto \\\n");
          if(!(return_value_fprintf_9 >= 0))
            goto error;

        }

        id = 0;
        for( ; !(id >= instance_count); id = id + 1)
        {
          instno = 0;
          for( ; !(instances[(signed long int)instno].id == id); instno = instno + 1)
            ;
          instance = &instances[(signed long int)instno];
          escape_for_shell(&arg1, instance->friendly_name);
          signed int return_value_fprintf_10;
          return_value_fprintf_10=fprintf(fp, "-comment %s \\\n", arg1);
          if(!(return_value_fprintf_10 >= 0))
            goto error;

          signed int return_value_fprintf_11;
          return_value_fprintf_11=fprintf(fp, " -chan %d \\\n", instance->channel);
          if(!(return_value_fprintf_11 >= 0))
            goto error;

          item = instance->configure_items;
          for( ; !(item == ((struct _configure_item_t *)NULL)); item = item->next)
          {
            unsigned long int write_configuration__1__7__1__2__1__1____s1_len;
            unsigned long int write_configuration__1__7__1__2__1__1____s2_len;
            signed int return_value___builtin_strcmp_14;
            return_value___builtin_strcmp_14=__builtin_strcmp(item->key, "DSSI:PROJECT_DIRECTORY");
            tmp_statement_expression_13 = return_value___builtin_strcmp_14;
            if(!(tmp_statement_expression_13 == 0))
            {
              escape_for_shell(&arg1, item->key);
              escape_for_shell(&arg2, item->value);
              signed int return_value_fprintf_12;
              return_value_fprintf_12=fprintf(fp, " -conf %s %s \\\n", arg1, arg2);
              if(!(return_value_fprintf_12 >= 0))
                goto error;

            }

          }
          if(!(instance->plugin->descriptor->select_program == ((void (*)(void *, unsigned long int, unsigned long int))NULL)))
          {
            signed int return_value_fprintf_15;
            return_value_fprintf_15=fprintf(fp, " -prog %lu %lu \\\n", instance->currentBank, instance->currentProgram);
            if(!(return_value_fprintf_15 >= 0))
              goto error;

          }

          i = 0;
          for( ; !(i >= instance->plugin->controlIns); i = i + 1)
          {
            char buf[39l];
            in = i + instance->firstControlIn;
            port = (signed int)pluginControlInPortNumbers[(signed long int)in];
            g_ascii_formatd(buf, (signed int)sizeof(char [39l]) /*39ul*/ , "%.6g", (double)pluginControlIns[(signed long int)in]);
            signed int return_value_fprintf_16;
            return_value_fprintf_16=fprintf(fp, " -port %d %s \\\n", port, (const void *)buf);
            if(!(return_value_fprintf_16 >= 0))
              goto error;

          }
          escape_for_shell(&arg1, instance->plugin->dll->name);
          escape_for_shell(&arg2, instance->plugin->label);
          signed int return_value_fprintf_17;
          return_value_fprintf_17=fprintf(fp, " %s:%s \\\n", arg1, arg2);
          if(!(return_value_fprintf_17 >= 0))
            goto error;

        }
        return_value_fprintf_18=fprintf(fp, "\n");
        if(return_value_fprintf_18 >= 0)
          rc = 1;

      }

    }

  }


error:
  ;
  if(!(arg1 == ((char *)NULL)))
    free((void *)arg1);

  if(!(arg2 == ((char *)NULL)))
    free((void *)arg2);

  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  return rc;
}

// write_patchlist
// file ghostess.c line 996
signed int write_patchlist(char *filename)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  signed int rc = 0;
  signed int id;
  signed int instno;
  signed int i;
  signed int j;
  struct _d3h_instance_t *instance;
  char tmp[255l];
  fp=fopen(filename, "w");
  _Bool tmp_if_expr_1;
  signed int return_value_fprintf_2;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    fprintf(fp, "<patchlist>\n");
    id = 0;
    for( ; !(id >= instance_count); id = id + 1)
    {
      instno = 0;
      for( ; !(instances[(signed long int)instno].id == id); instno = instno + 1)
        ;
      instance = &instances[(signed long int)instno];
      if(instance->pluginProgramsValid == 0)
        query_programs(instance);

      i = 0;
      for( ; !(i >= instance->pluginProgramCount); i = i + 1)
      {
        __builtin_strncpy(tmp, (instance->pluginPrograms + (signed long int)i)->Name, (unsigned long int)254);
        tmp[(signed long int)254] = (char)0;
        j = 0;
        for( ; !(tmp[(signed long int)j] == 0); j = j + 1)
        {
          if((signed int)tmp[(signed long int)j] == 60)
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = (signed int)tmp[(signed long int)j] == 62 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
            tmp[(signed long int)j] = (char)32;

          else
            if((signed int)tmp[(signed long int)j] == 34)
              tmp[(signed long int)j] = (char)39;

        }
        fprintf(fp, "<patch channel=\"%d\" name=\"%s\" bank=\"%d\" program=\"%d\"/>\n", instance->channel, (const void *)tmp, (signed int)(instance->pluginPrograms + (signed long int)i)->Bank, (signed int)(instance->pluginPrograms + (signed long int)i)->Program);
      }
    }
    return_value_fprintf_2=fprintf(fp, "</patchlist>\n");
    if(return_value_fprintf_2 >= 0)
      rc = 1;

  }


error:
  ;
  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  return rc;
}

