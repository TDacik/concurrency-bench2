// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$14;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$26;

// tag-#anon#ST[ARR6{U8}$U8$'mac'||U16'$pad0'||U32'ip'||S32'timeout'|]
// file vpcs.h line 36
struct anonymous$4;

// tag-#anon#ST[BF{U8}$U8$'rd'||BF{U8}$U8$'tc'||BF{U8}$U8$'aa'||BF{U8}$U8$'op'||BF{U8}$U8$'qr'||BF{U8}$U8$'rc'||BF{U8}$U8$'z'||BF{U8}$U8$'ra'|]
// file dns.h line 42
struct anonymous$1;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$8;

// tag-#anon#ST[S32'dynip'||U32'ip'||S32'cidr'||ARR6{U8}$U8$'mac'||U48'$pad0'||U64'gw'||ARR6{U8}$U8$'gmac'||U16'$pad1'||SYM#tag-#anon#ST[U32'svr'||ARR6{U8}$U8$'smac'||U16'$pad0'||U32'lease'||U32'ip'||U32'netmask'||U32'gw'||U32'xid'||ARR2{U32}$U32$'dns'||ARR64{S8}$S8$'domain'|]#'dhcp'||U32'lease'||ARR2{U32}$U32$'dns'||ARR64{S8}$S8$'domain'||S32'mtu'|]
// file vpcs.h line 75
struct anonymous$6;

// tag-#anon#ST[S32'id'||ARR7{S8}$S8$'xname'||U40'$pad0'||U64'rpid'||U64'wpid'||S32'dmpflag'||S32'fd'||S32'rfd'||S32'lport'||S32'rport'||U32'rhost'||SYM#tag-pq#'iq'||SYM#tag-pq#'oq'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'locker'||SYM#tag-sesscb#'mscb'||ARR1000{SYM#tag-sesscb#}$SYM#tag-sesscb#$'sesscb'||ARR1000{SYM#tag-tcpcb6#}$SYM#tag-tcpcb6#$'tcpcb6'||ARR10{SYM#tag-#anon#ST[ARR6{U8}$U8$'mac'||U16'$pad0'||U32'ip'||S32'timeout'|]#}$SYM#tag-#anon#ST[ARR6{U8}$U8$'mac'||U16'$pad0'||U32'ip'||S32'timeout'|]#$'ipmac4'||ARR10{SYM#tag-#anon#ST[S32'timeout'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]#'ip'||S32'cidr'||ARR6{U8}$U8$'mac'||U16'$pad0'|]#}$SYM#tag-#anon#ST[S32'timeout'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]#'ip'||S32'cidr'||ARR6{U8}$U8$'mac'||U16'$pad0'|]#$'ipmac6'||SYM#tag-#anon#ST[S32'dynip'||U32'ip'||S32'cidr'||ARR6{U8}$U8$'mac'||U48'$pad0'||U64'gw'||ARR6{U8}$U8$'gmac'||U16'$pad1'||SYM#tag-#anon#ST[U32'svr'||ARR6{U8}$U8$'smac'||U16'$pad0'||U32'lease'||U32'ip'||U32'netmask'||U32'gw'||U32'xid'||ARR2{U32}$U32$'dns'||ARR64{S8}$S8$'domain'|]#'dhcp'||U32'lease'||ARR2{U32}$U32$'dns'||ARR64{S8}$S8$'domain'||S32'mtu'|]#'ip4'||S32'ip6auto'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]#'ip'||S32'cidr'||S32'type'||ARR6{U8}$U8$'gmac'||U16'$pad0'||S32'mtu'|]#'ip6'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]#'ip'||S32'cidr'||S32'type'||ARR6{U8}$U8$'gmac'||U16'$pad0'||S32'mtu'|]#'link6'||U32'$pad1'|]
// file vpcs.h line 91
struct anonymous$0;

// tag-#anon#ST[S32'timeout'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]#'ip'||S32'cidr'||ARR6{U8}$U8$'mac'||U16'$pad0'|]
// file vpcs.h line 57
struct anonymous$5;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]#'ip'||S32'cidr'||S32'type'||ARR6{U8}$U8$'gmac'||U16'$pad0'||S32'mtu'|]
// file vpcs.h line 64
struct anonymous$7;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'type'||U8'code'||U16'cksum'||SYM#tag-#anon#UN[ARR1{U32}$U32$'icmp6_un_data32'||ARR2{U16}$U16$'icmp6_un_data16'||ARR4{U8}$U8$'icmp6_un_data8'|]#'icmp6_dataun'|]#'hdr'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]#'target'|]
// file ip.h line 381
struct anonymous$21;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'type'||U8'code'||U16'cksum'||SYM#tag-#anon#UN[ARR1{U32}$U32$'icmp6_un_data32'||ARR2{U16}$U16$'icmp6_un_data16'||ARR4{U8}$U8$'icmp6_un_data8'|]#'icmp6_dataun'|]#'hdr'||U32'reachable'||U32'retransmit'|]
// file ip.h line 394
struct anonymous$23;

// tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]
// file ip.h line 253
struct anonymous$11;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-ip6_hdrctl#'ip6_un1'||U8'ip6_un2_vfc'|]#'ip6_ctlun'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]#'src'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]#'uaddr'|]#'dst'|]
// file ip.h line 266
struct anonymous$18;

// tag-#anon#ST[U16'id'||U16'flags'||U16'query'||U16'answer'||U16'author'||U16'addition'|]
// file dns.h line 33
struct anonymous;

// tag-#anon#ST[U16'sport'||U16'dport'||U16'len'||U16'cksum'|]
// file ip.h line 151
struct anonymous$24;

// tag-#anon#ST[U32'svr'||ARR6{U8}$U8$'smac'||U16'$pad0'||U32'lease'||U32'ip'||U32'netmask'||U32'gw'||U32'xid'||ARR2{U32}$U32$'dns'||ARR64{S8}$S8$'domain'|]
// file vpcs.h line 45
struct anonymous$13;

// tag-#anon#ST[U8'type'||U8'code'||U16'cksum'||SYM#tag-#anon#UN[ARR1{U32}$U32$'icmp6_un_data32'||ARR2{U16}$U16$'icmp6_un_data16'||ARR4{U8}$U8$'icmp6_un_data8'|]#'icmp6_dataun'|]
// file ip.h line 301
struct anonymous$20;

// tag-#anon#ST[U8'type'||U8'len'||ARR6{U8}$U8$'mac'|]
// file ip.h line 386
struct anonymous$22;

// tag-#anon#UN[ARR16{S8}$S8$'ifrn_name'|]
// file /usr/include/net/if.h line 130
union anonymous$15;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$25;

// tag-#anon#UN[ARR16{U8}$U8$'_a8'||ARR8{U16}$U16$'_a16'||ARR4{U32}$U32$'_a32'|]
// file ip.h line 254
union anonymous$10;

// tag-#anon#UN[ARR1{U32}$U32$'icmp6_un_data32'||ARR2{U16}$U16$'icmp6_un_data16'||ARR4{U8}$U8$'icmp6_un_data8'|]
// file ip.h line 305
union anonymous$19;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$12;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$9;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$3;

// tag-#anon#UN[SYM#tag-ip6_hdrctl#'ip6_un1'||U8'ip6_un2_vfc'|]
// file ip.h line 267
union anonymous$17;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}$S8$'ifru_slave'||ARR16{S8}$S8$'ifru_newname'||*{S8}$S8$'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous$16;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$27;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$2;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-arphdr
// file ip.h line 51
struct arphdr;

// tag-dhcp4_packet
// file dhcp.h line 34
struct dhcp4_packet;

// tag-ethdr
// file ip.h line 40
struct ethdr;

// tag-icmphdr
// file ip.h line 108
struct icmphdr;

// tag-icmprdr
// file ip.h line 118
struct icmprdr;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-ip6_hdrctl
// file ip.h line 268
struct ip6_hdrctl;

// tag-iphdr
// file ip.h line 64
struct iphdr;

// tag-ipovly
// file ip.h line 143
struct ipovly;

// tag-list
// file hv.h line 59
struct list;

// tag-node
// file relay.c line 38
struct node;

// tag-packet
// file queue.h line 40
struct packet;

// tag-peerlist
// file relay.c line 43
struct peerlist;

// tag-pq
// file queue.h line 47
struct pq;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rls
// file readline.h line 33
struct rls;

// tag-sesscb
// file ip.h line 413
struct sesscb;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stub
// file vpcs.c line 103
struct stub$0;

// tag-stub$link1
// file hv.h line 68
struct stub;

// tag-tcpcb6
// file ip.h line 360
struct tcpcb6;

// tag-tcphdr
// file ip.h line 175
struct tcphdr;

// tag-tcpiphdr
// file ip.h line 206
struct tcpiphdr;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-udpiphdr
// file ip.h line 158
struct udpiphdr;

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

#ifndef NULL
#define NULL ((void*)0)
#endif

// VRead
// file dev.h line 35
signed int VRead(struct anonymous$0 *pc, void *buf, signed int len);
// VWrite
// file dev.h line 36
signed int VWrite(struct anonymous$0 *pc, void *buf, signed int len);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _readline
// file readline.c line 185
static signed int _readline(struct rls *rls);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$2, unsigned int *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// arg2int
// file utils.h line 41
signed int arg2int(const char *arg, signed int min, signed int max, signed int defval);
// arp
// file packets.c line 484
static struct packet * arp(struct anonymous$0 *pc, unsigned int dip);
// arpResolve
// file packets.c line 254
signed int arpResolve(struct anonymous$0 *pc, unsigned int ip, unsigned char *dmac);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// autoconf6
// file command6.h line 45
void autoconf6(void);
// bcopy
// file /usr/include/string.h line 454
extern void bcopy(const void *, void *, unsigned long int);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$2, unsigned int);
// bzero
// file /usr/include/string.h line 458
extern void bzero(void *, unsigned long int);
// cksum
// file ip.h line 453
unsigned short int cksum(unsigned short int *buffer, signed int size);
// cksum6
// file ip.h line 455
unsigned short int cksum6(struct anonymous$18 *ip, unsigned char nxt, signed int len);
// cksum_fixup
// file ip.h line 454
unsigned short int cksum_fixup(unsigned short int cksum, unsigned short int old, unsigned short int new, unsigned short int udp);
// clean
// file hv.c line 355
static void clean(void);
// clear_hist
// file vpcs.c line 589
void clear_hist(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// daemon_proc
// file daemon.c line 163
static void daemon_proc(signed int sock, signed int fdtty);
// daemonize
// file daemon.h line 30
signed int daemonize(signed int port, signed int bg);
// del_pkt
// file queue.h line 69
void del_pkt(struct packet *m);
// deq
// file queue.c line 71
struct packet * deq(struct pq *pq);
// deq_impl
// file queue.c line 51
struct packet * deq_impl(struct pq *pq, signed int cond);
// dhcp4_discover
// file dhcp.h line 83
struct packet * dhcp4_discover(struct anonymous$0 *pc, signed int renew);
// dhcp4_release
// file dhcp.h line 86
struct packet * dhcp4_release(struct anonymous$0 *pc);
// dhcp4_request
// file dhcp.h line 84
struct packet * dhcp4_request(struct anonymous$0 *pc);
// digitstring
// file utils.h line 38
signed int digitstring(const char *s);
// dmp_arp
// file dump.c line 121
static void dmp_arp(void *dat);
// dmp_dhcp
// file dhcp.h line 90
signed int dmp_dhcp(struct anonymous$0 *pc, struct packet *m);
// dmp_dns
// file dump.c line 284
static void dmp_dns(void *dat);
// dmp_dns_rname
// file dns.c line 335
signed int dmp_dns_rname(char *s, char *se, char *name);
// dmp_dns_timestr
// file dump.c line 507
static char * dmp_dns_timestr(unsigned int s);
// dmp_ip
// file dump.c line 157
static void dmp_ip(void *dat);
// dmp_ip6
// file dump.c line 224
static void dmp_ip6(void *dat);
// dmp_packet
// file dump.h line 32
signed int dmp_packet(struct packet *m, const signed int flag);
// dnsparse
// file dns.c line 213
static signed int dnsparse(struct packet *m, unsigned short int magicid, char *data, signed int dlen, unsigned int *cip);
// dnsrequest
// file dns.c line 176
static signed int dnsrequest(unsigned short int id, const char *name, char *data, signed int *namelen);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// encap_ehead
// file ip.h line 450
void encap_ehead(char *mbuf, const unsigned char *sea, const unsigned char *dea, const unsigned short int type);
// enq
// file queue.h line 63
struct packet * enq(struct pq *pq, struct packet *m);
// etherIsMulticast
// file ip.h line 458
signed int etherIsMulticast(unsigned char *mac);
// etherIsZero
// file ip.h line 457
signed int etherIsZero(unsigned char *mac);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// findhistory
// file readline.c line 470
static signed int findhistory(struct rls *rls, signed int start);
// fmtstring
// file dns.c line 143
static signed int fmtstring(const char *name, char *buf);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// forkpty
// file /usr/include/pty.h line 39
extern signed int forkpty(signed int *, char *, struct termios *, struct winsize *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getCIDR
// file ip.h line 465
signed int getCIDR(unsigned long int mask);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getkv
// file utils.c line 36
char * getkv(char *str);
// getopt
// file ./getopt.h line 53
signed int getopt(signed int, char **, char *);
// getpath
// file hv.c line 756
static char * getpath(const char *name);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// help_clear
// file help.h line 32
signed int help_clear(signed int argc, char **argv);
// help_echo
// file help.c line 40
signed int help_echo(signed int argc, char **argv);
// help_help
// file help.h line 34
signed int help_help(signed int argc, char **argv);
// help_hist
// file help.c line 45
signed int help_hist(signed int argc, char **argv);
// help_ip
// file help.h line 36
signed int help_ip(signed int argc, char **argv);
// help_load
// file help.h line 37
signed int help_load(signed int argc, char **argv);
// help_neighbor
// file help.c line 139
signed int help_neighbor(signed int argc, char **argv);
// help_ping
// file help.h line 39
signed int help_ping(signed int argc, char **argv);
// help_relay
// file help.h line 41
signed int help_relay(signed int argc, char **argv);
// help_rlogin
// file help.h line 42
signed int help_rlogin(signed int argc, char **argv);
// help_save
// file help.h line 43
signed int help_save(signed int argc, char **argv);
// help_set
// file help.h line 44
signed int help_set(signed int argc, char **argv);
// help_shell
// file help.h line 45
signed int help_shell(signed int argc, char **argv);
// help_show
// file help.h line 46
signed int help_show(signed int argc, char **argv);
// help_shut
// file help.c line 329
signed int help_shut(signed int argc, char **argv);
// help_sleep
// file help.h line 48
signed int help_sleep(signed int argc, char **argv);
// help_trace
// file help.h line 40
signed int help_trace(signed int argc, char **argv);
// help_version
// file help.c line 308
signed int help_version(signed int argc, char **argv);
// hostresolv
// file dns.h line 55
signed int hostresolv(struct anonymous$0 *pc, char *name, unsigned int *ip);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// hypervisor
// file hv.c line 147
static signed int hypervisor(signed int port);
// icmp6Reply
// file packets6.c line 531
static struct packet * icmp6Reply(struct packet *m0);
// icmpReply
// file packets.c line 551
static struct packet * icmpReply(struct packet *m0, char icmptype);
// icmpTypeCode2String
// file ip.h line 467
const char * icmpTypeCode2String(signed int ipv, unsigned char type, unsigned char code);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// inet_ntop4w
// file inet6.c line 52
static const char * inet_ntop4w(const unsigned char *src, char *dst, unsigned int size);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_queue
// file queue.h line 62
void init_queue(struct pq *pq);
// insert_argv
// file utils.h line 34
signed int insert_argv(signed int argc, char **argv, char *str);
// invoke_cmd
// file vpcs.c line 603
static signed int invoke_cmd(const char *cmd);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// ip4Info
// file command.c line 1936
const char * ip4Info(const signed int id);
// ip6Info
// file command6.h line 43
const char * ip6Info(const signed int id);
// ip6tostr
// file ip.c line 303
char * ip6tostr(const unsigned char *ip6);
// ipauto6
// file command6.h line 47
signed int ipauto6(void);
// isDhcp4_Offer
// file dhcp.h line 87
signed int isDhcp4_Offer(struct anonymous$0 *pc, struct packet *m);
// isDhcp4_packer
// file dhcp.h line 88
signed int isDhcp4_packer(struct anonymous$0 *pc, struct packet *m);
// is_there
// file hv.c line 740
static signed int is_there(char *candidate);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// kbhit
// file readline.c line 47
void kbhit(signed int fd);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// loadhistory
// file readline.h line 63
signed int loadhistory(const char *filename, struct rls *rls);
// locallink6
// file command6.h line 49
void locallink6(struct anonymous$0 *pc);
// lock_q
// file queue.c line 120
void lock_q(struct pq *pq);
// loop
// file hv.c line 263
static void loop(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkargv
// file utils.h line 33
signed int mkargv(char *str, char **argv, signed int max);
// nbDiscovery
// file packets6.h line 58
unsigned char * nbDiscovery(struct anonymous$0 *pc, struct anonymous$11 *dst);
// nb_adv
// file packets6.c line 829
static signed int nb_adv(struct anonymous$0 *pc, struct packet *m, struct anonymous$11 *dst);
// nb_sol
// file packets6.c line 753
static struct packet * nb_sol(struct anonymous$0 *pc, struct anonymous$11 *dst);
// nbr_sol
// file packets6.h line 59
struct packet * nbr_sol(struct anonymous$0 *pc);
// new_pkt
// file queue.h line 68
struct packet * new_pkt(signed int len);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_dev
// file dev.h line 32
signed int open_dev(signed int id);
// open_remote
// file remote.h line 30
signed int open_remote(signed int fdio, const char *destip, const unsigned short int destport);
// open_tap
// file dev.c line 164
signed int open_tap(signed int id);
// open_udp
// file dev.h line 33
signed int open_udp(signed int port);
// openpty
// file /usr/include/pty.h line 33
extern signed int openpty(signed int *, signed int *, char *, struct termios *, struct winsize *);
// packet
// file packets.c line 295
struct packet * packet(struct sesscb *sesscb);
// packet6
// file packets6.h line 52
struct packet * packet6(struct sesscb *sesscb);
// parse_cmd
// file vpcs.c line 278
void parse_cmd(char *cmdstr);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pth_reader
// file vpcs.c line 396
static void * pth_reader(void *devid);
// pth_relay
// file relay.h line 34
void * pth_relay(void *dummy);
// pth_timer_tick
// file vpcs.c line 496
static void * pth_timer_tick(void *dummy);
// pth_writer
// file vpcs.c line 473
static void * pth_writer(void *devid);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$9 *, const union anonymous$12 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$9 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$9 *, union anonymous$3 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$3 *, const union anonymous$12 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$3 *);
// pty_master
// file hv.c line 207
static void * pty_master(void *arg);
// pty_slave
// file hv.c line 223
static void * pty_slave(void *arg);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readline
// file readline.h line 51
char * readline(const char *prompt, struct rls *rls);
// readline_free
// file readline.c line 176
void readline_free(struct rls *rls);
// readline_init
// file readline.h line 47
struct rls * readline_init(signed int histnum, signed int buflen);
// readline_tab
// file readline.c line 80
signed int readline_tab(char ** (*cb)(const char *, const char *), struct rls *rls);
// readline_tab::cb$object
//
char ** cb$object(const char *, const char *);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// reset_terminal
// file readline.c line 548
void reset_terminal(signed int fd, struct termios *stored_settings);
// response
// file packets.c line 160
signed int response(struct packet *m, struct sesscb *sesscb);
// response6
// file packets6.h line 54
signed int response6(struct packet *m, struct sesscb *sesscb);
// run_clear
// file command.h line 37
signed int run_clear(signed int argc, char **argv);
// run_dhcp
// file command.c line 593
signed int run_dhcp(signed int argc, char **argv);
// run_dhcp_new
// file command.c line 643
static signed int run_dhcp_new(signed int renew, signed int dump);
// run_dhcp_release
// file command.c line 758
static signed int run_dhcp_release(signed int dump);
// run_disconnect
// file vpcs.c line 577
static signed int run_disconnect(signed int argc, char **argv);
// run_disconnect$link1
// file hv.c line 626
static signed int run_disconnect$link1(signed int ac, char **av);
// run_echo
// file command.h line 38
signed int run_echo(signed int argc, char **argv);
// run_help
// file help.h line 30
signed int run_help(signed int argc, char **argv);
// run_help$link1
// file hv.c line 802
static signed int run_help$link1(signed int ac, char **av);
// run_hist
// file command.h line 40
signed int run_hist(signed int argc, char **argv);
// run_ipconfig
// file command.h line 33
signed int run_ipconfig(signed int argc, char **argv);
// run_ipset6
// file command6.h line 35
signed int run_ipset6(signed int argc, char **argv);
// run_list
// file hv.c line 602
static signed int run_list(signed int ac, char **av);
// run_load
// file command.h line 43
signed int run_load(signed int argc, char **argv);
// run_nb6
// file command6.h line 38
signed int run_nb6(signed int argc, char **argv);
// run_ping
// file command.h line 32
signed int run_ping(signed int argc, char **argv);
// run_ping6
// file command6.h line 33
signed int run_ping6(signed int argc, char **argv);
// run_quit
// file vpcs.c line 562
static signed int run_quit(signed int argc, char **argv);
// run_quit$link1
// file hv.c line 634
static signed int run_quit$link1(signed int ac, char **av);
// run_relay
// file relay.h line 33
signed int run_relay(signed int argc, char **argv);
// run_remote
// file command.h line 41
signed int run_remote(signed int argc, char **argv);
// run_rlogin
// file hv.c line 681
static signed int run_rlogin(signed int argc, char **argv);
// run_save
// file command.h line 44
signed int run_save(signed int argc, char **argv);
// run_set
// file command.h line 35
signed int run_set(signed int argc, char **argv);
// run_show
// file command.h line 31
signed int run_show(signed int argc, char **argv);
// run_show6
// file command6.h line 40
signed int run_show6(struct anonymous$0 *pc);
// run_sleep
// file command.h line 36
signed int run_sleep(signed int argc, char **argv);
// run_stop
// file hv.c line 704
static signed int run_stop(signed int ac, char **av);
// run_tracert
// file command.h line 34
signed int run_tracert(signed int argc, char **argv);
// run_tracert6
// file command6.h line 36
signed int run_tracert6(signed int argc, char **argv);
// run_ver
// file command.h line 39
signed int run_ver(signed int argc, char **argv);
// run_vpcs
// file hv.c line 364
static signed int run_vpcs(signed int ac, char **av);
// sameNet
// file ip.h line 460
signed int sameNet(unsigned long int ip1, unsigned long int ip2, signed int cidr);
// sameNet6
// file ip.h line 461
signed int sameNet6(char *s, char *d, signed int cidr);
// save_eaddr
// file packets.c line 644
static void save_eaddr(struct anonymous$0 *pc, unsigned int addr, unsigned char *mac);
// savehistory
// file readline.h line 62
signed int savehistory(const char *filename, struct rls *rls);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$26 *, struct anonymous$26 *, struct anonymous$26 *, struct timeval *);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// set_dump
// file command.c line 1484
static signed int set_dump(signed int argc, char **argv);
// set_telnet_mode
// file daemon.c line 296
static void set_telnet_mode(signed int s);
// set_telnet_mode$link1
// file hv.c line 819
static void set_telnet_mode$link1(signed int s$link1);
// set_terminal
// file readline.c line 533
void set_terminal(signed int fd, struct termios *stored_settings);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// show_arp
// file command.c line 1536
static signed int show_arp(signed int argc, char **argv);
// show_dump
// file command.c line 1611
static signed int show_dump(signed int argc, char **argv);
// show_echo
// file command.c line 1767
static signed int show_echo(signed int argc, char **argv);
// show_ip
// file command.c line 1660
static signed int show_ip(signed int argc, char **argv);
// show_ipv6
// file command6.h line 41
signed int show_ipv6(signed int argc, char **argv);
// sig_clean
// file vpcs.c line 551
static void sig_clean(signed int sig);
// sig_int
// file vpcs.c line 390
static void sig_int(signed int sig);
// sig_int$link1
// file daemon.c line 289
static void sig_int$link1(signed int sig$link1);
// sig_quit
// file daemon.c line 253
static void sig_quit(signed int sig);
// sig_term
// file daemon.c line 242
static void sig_term(signed int sig);
// sig_usr1
// file daemon.c line 264
static void sig_usr1(signed int sig);
// sig_usr2
// file daemon.c line 275
static void sig_usr2(signed int sig);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// startup
// file vpcs.c line 511
static void startup(void);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strsep
// file /usr/include/string.h line 556
extern char * strsep(char ** restrict , const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// swap_ehead
// file ip.h line 451
void swap_ehead(char *mbuf);
// swap_ip6head
// file ip.h line 463
void swap_ip6head(struct packet *m);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcp
// file tcp.c line 486
signed int tcp(struct anonymous$0 *pc, struct packet *m);
// tcp6
// file tcp.c line 654
signed int tcp6(struct anonymous$0 *pc, struct packet *m);
// tcp6Reply
// file tcp.c line 767
struct packet * tcp6Reply(struct packet *m0, struct sesscb *cb);
// tcpReply
// file tcp.c line 594
struct packet * tcpReply(struct packet *m0, struct sesscb *cb);
// tcpReplyPacket
// file tcp.c line 426
signed int tcpReplyPacket(struct tcphdr *th, struct sesscb *cb, signed int tcplen);
// tcp_ack
// file tcp.c line 62
signed int tcp_ack(signed int ipv);
// tcp_ack::1::fpacket$object
//
struct packet * fpacket$object(struct sesscb *);
// tcp_close
// file tcp.h line 33
signed int tcp_close(signed int ipv);
// tcp_close::1::fpacket$object
//
struct packet * fpacket$object(struct sesscb *);
// tcp_close::1::fresponse$object
//
signed int fresponse$object(struct packet *, struct sesscb *);
// tcp_open
// file tcp.h line 31
signed int tcp_open(signed int ipv);
// tcp_open::1::fpacket$object
//
struct packet * fpacket$object(struct sesscb *);
// tcp_open::1::fresponse$object
//
signed int fresponse$object(struct packet *, struct sesscb *);
// tcp_send
// file tcp.h line 32
signed int tcp_send(signed int ipv);
// tcp_send::1::fpacket$object
//
struct packet * fpacket$object(struct sesscb *);
// tcp_send::1::fresponse$object
//
signed int fresponse$object(struct packet *, struct sesscb *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeout
// file utils.h line 36
signed int timeout(struct timeval tv, signed int mseconds);
// trimspace
// file readline.c line 504
static void trimspace(char *buf);
// ttrim
// file utils.h line 39
char * ttrim(char *s);
// udp6Reply
// file packets6.c line 581
static struct packet * udp6Reply(struct packet *m0);
// udpReply
// file packets.c line 519
static struct packet * udpReply(struct packet *m0);
// ulock_q
// file queue.c line 125
void ulock_q(struct pq *pq);
// upv4
// file packets.h line 34
signed int upv4(struct anonymous$0 *pc, struct packet *m);
// upv6
// file packets6.c line 62
signed int upv6(struct anonymous$0 *pc, struct packet *m);
// usage
// file vpcs.c line 617
void usage();
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vinet_ntop6
// file inet6.h line 44
const char * vinet_ntop6(signed int af, const void * restrict src, char * restrict dst, unsigned int size);
// vinet_ntop6w
// file inet6.c line 68
static const char * vinet_ntop6w(const unsigned char *src, char *dst, unsigned int size);
// vinet_pton6
// file inet6.h line 43
signed int vinet_pton6(signed int af, const char * restrict src, void * restrict dst);
// vinet_pton6w
// file inet6.c line 160
static signed int vinet_pton6w(const char *src, unsigned char *dst);
// vpcs
// file vpcs.c line 140
signed int vpcs(signed int argc, char **argv);
// vprint
// file readline.c line 527
static void vprint(signed int fd, char *s, signed int len);
// waitdeq
// file queue.h line 65
struct packet * waitdeq(struct pq *pq);
// welcome
// file vpcs.c line 594
static void welcome(void);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$14
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$26
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$4
{
  // mac
  unsigned char mac[6l];
  // ip
  unsigned int ip;
  // timeout
  signed int timeout;
};

struct anonymous$1
{
  // rd
  unsigned char rd : 1;
  // tc
  unsigned char tc : 1;
  // aa
  unsigned char aa : 1;
  // op
  unsigned char op : 4;
  // qr
  unsigned char qr : 1;
  // rc
  unsigned char rc : 4;
  // z
  unsigned char z : 3;
  // ra
  unsigned char ra : 1;
};

struct anonymous$8
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$13
{
  // svr
  unsigned int svr;
  // smac
  unsigned char smac[6l];
  // lease
  unsigned int lease;
  // ip
  unsigned int ip;
  // netmask
  unsigned int netmask;
  // gw
  unsigned int gw;
  // xid
  unsigned int xid;
  // dns
  unsigned int dns[2l];
  // domain
  char domain[64l];
};

struct anonymous$6
{
  // dynip
  signed int dynip;
  // ip
  unsigned int ip;
  // cidr
  signed int cidr;
  // mac
  unsigned char mac[6l];
  // gw
  unsigned long int gw;
  // gmac
  unsigned char gmac[6l];
  // dhcp
  struct anonymous$13 dhcp;
  // lease
  unsigned int lease;
  // dns
  unsigned int dns[2l];
  // domain
  char domain[64l];
  // mtu
  signed int mtu;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$9
{
  // __data
  struct anonymous$8 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct pq
{
  // type
  signed int type;
  // ip
  signed int ip;
  // size
  signed int size;
  // locker
  union anonymous$3 locker;
  // cond
  union anonymous$9 cond;
  // q
  struct packet *q;
};

union anonymous$10
{
  // _a8
  unsigned char _a8[16l];
  // _a16
  unsigned short int _a16[8l];
  // _a32
  unsigned int _a32[4l];
};

struct anonymous$11
{
  // uaddr
  union anonymous$10 uaddr;
};

struct sesscb
{
  // sock
  signed int sock;
  // timeout
  unsigned int timeout;
  // sn
  unsigned int sn;
  // waittime
  unsigned int waittime;
  // smac
  unsigned char smac[6l];
  // dmac
  unsigned char dmac[6l];
  // sip
  unsigned int sip;
  // dip
  unsigned int dip;
  // rdip
  unsigned int rdip;
  // sip6
  struct anonymous$11 sip6;
  // dip6
  struct anonymous$11 dip6;
  // rdip6
  struct anonymous$11 rdip6;
  // sport
  unsigned int sport;
  // dport
  unsigned int dport;
  // ipid
  unsigned int ipid;
  // proto
  signed int proto;
  // dsize
  signed int dsize;
  // rdsize
  signed int rdsize;
  // ack
  unsigned int ack;
  // seq
  unsigned int seq;
  // rack
  unsigned int rack;
  // rseq
  unsigned int rseq;
  // winsize
  unsigned short int winsize;
  // flags
  unsigned char flags;
  // rflags
  unsigned char rflags;
  // ttl
  unsigned char ttl;
  // rttl
  unsigned char rttl;
  // rmss
  unsigned short int rmss;
  // aproto
  signed int aproto;
  // icmptype
  unsigned char icmptype;
  // icmpcode
  unsigned char icmpcode;
  // mtu
  signed int mtu;
  // frag
  signed int frag;
  // data
  char *data;
};

struct tcpcb6
{
  // timeout
  unsigned int timeout;
  // sip
  struct anonymous$11 sip;
  // dip
  struct anonymous$11 dip;
  // sport
  unsigned int sport;
  // dport
  unsigned int dport;
  // ack
  unsigned int ack;
  // seq
  unsigned int seq;
  // winsize
  unsigned short int winsize;
  // flags
  unsigned char flags;
  // rflags
  unsigned char rflags;
};

struct anonymous$5
{
  // timeout
  signed int timeout;
  // ip
  struct anonymous$11 ip;
  // cidr
  signed int cidr;
  // mac
  unsigned char mac[6l];
};

struct anonymous$7
{
  // ip
  struct anonymous$11 ip;
  // cidr
  signed int cidr;
  // type
  signed int type;
  // gmac
  unsigned char gmac[6l];
  // mtu
  signed int mtu;
};

struct anonymous$0
{
  // id
  signed int id;
  // xname
  char xname[7l];
  // rpid
  unsigned long int rpid;
  // wpid
  unsigned long int wpid;
  // dmpflag
  signed int dmpflag;
  // fd
  signed int fd;
  // rfd
  signed int rfd;
  // lport
  signed int lport;
  // rport
  signed int rport;
  // rhost
  unsigned int rhost;
  // iq
  struct pq iq;
  // oq
  struct pq oq;
  // locker
  union anonymous$3 locker;
  // mscb
  struct sesscb mscb;
  // sesscb
  struct sesscb sesscb[1000l];
  // tcpcb6
  struct tcpcb6 tcpcb6[1000l];
  // ipmac4
  struct anonymous$4 ipmac4[10l];
  // ipmac6
  struct anonymous$5 ipmac6[10l];
  // ip4
  struct anonymous$6 ip4;
  // ip6auto
  signed int ip6auto;
  // ip6
  struct anonymous$7 ip6;
  // link6
  struct anonymous$7 link6;
};

union anonymous$19
{
  // icmp6_un_data32
  unsigned int icmp6_un_data32[1l];
  // icmp6_un_data16
  unsigned short int icmp6_un_data16[2l];
  // icmp6_un_data8
  unsigned char icmp6_un_data8[4l];
};

struct anonymous$20
{
  // type
  unsigned char type;
  // code
  unsigned char code;
  // cksum
  unsigned short int cksum;
  // icmp6_dataun
  union anonymous$19 icmp6_dataun;
};

struct anonymous$21
{
  // hdr
  struct anonymous$20 hdr;
  // target
  struct anonymous$11 target;
};

struct anonymous$23
{
  // hdr
  struct anonymous$20 hdr;
  // reachable
  unsigned int reachable;
  // retransmit
  unsigned int retransmit;
};

struct ip6_hdrctl
{
  // ip6_un1_flow
  unsigned int ip6_un1_flow;
  // ip6_un1_plen
  unsigned short int ip6_un1_plen;
  // ip6_un1_nxt
  unsigned char ip6_un1_nxt;
  // ip6_un1_hlim
  unsigned char ip6_un1_hlim;
};

union anonymous$17
{
  // ip6_un1
  struct ip6_hdrctl ip6_un1;
  // ip6_un2_vfc
  unsigned char ip6_un2_vfc;
};

struct anonymous$18
{
  // ip6_ctlun
  union anonymous$17 ip6_ctlun;
  // src
  struct anonymous$11 src;
  // dst
  struct anonymous$11 dst;
};

struct anonymous
{
  // id
  unsigned short int id;
  // flags
  unsigned short int flags;
  // query
  unsigned short int query;
  // answer
  unsigned short int answer;
  // author
  unsigned short int author;
  // addition
  unsigned short int addition;
};

struct anonymous$24
{
  // sport
  unsigned short int sport;
  // dport
  unsigned short int dport;
  // len
  unsigned short int len;
  // cksum
  unsigned short int cksum;
};

struct anonymous$22
{
  // type
  unsigned char type;
  // len
  unsigned char len;
  // mac
  unsigned char mac[6l];
};

union anonymous$15
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous$25
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$12
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous$16
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

union anonymous$27
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$2
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct arphdr
{
  // hrd
  unsigned short int hrd;
  // pro
  unsigned short int pro;
  // hln
  unsigned char hln;
  // pln
  unsigned char pln;
  // op
  unsigned short int op;
  // sea
  unsigned char sea[6l];
  // sip
  unsigned char sip[4l];
  // dea
  unsigned char dea[6l];
  // dip
  unsigned char dip[4l];
};

struct dhcp4_packet
{
  // op
  char op;
  // htype
  char htype;
  // hlen
  char hlen;
  // hops
  char hops;
  // xid
  unsigned int xid;
  // secs
  unsigned short int secs;
  // flags
  unsigned short int flags;
  // ciaddr
  unsigned int ciaddr;
  // yiaddr
  unsigned int yiaddr;
  // siaddr
  unsigned int siaddr;
  // giaddr
  unsigned int giaddr;
  // chaddr
  unsigned char chaddr[16l];
  // sname
  char sname[64l];
  // file
  char file[128l];
  // options
  unsigned char options[128l];
};

struct ethdr
{
  // dst
  unsigned char dst[6l];
  // src
  unsigned char src[6l];
  // type
  unsigned short int type;
};

struct icmphdr
{
  // type
  unsigned char type;
  // code
  unsigned char code;
  // cksum
  unsigned short int cksum;
  // id
  unsigned short int id;
  // seq
  unsigned short int seq;
};

struct icmprdr
{
  // type
  unsigned char type;
  // code
  unsigned char code;
  // cksum
  unsigned short int cksum;
  // ip
  unsigned int ip;
  // data
  unsigned char data[0l];
};

struct ifreq
{
  // ifr_ifrn
  union anonymous$15 ifr_ifrn;
  // ifr_ifru
  union anonymous$16 ifr_ifru;
};

struct in6_addr
{
  // __in6_u
  union anonymous$25 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iphdr
{
  // ihl
  unsigned int ihl : 4;
  // ver
  unsigned int ver : 4;
  // tos
  unsigned char tos;
  // len
  unsigned short int len;
  // id
  unsigned short int id;
  // frag
  unsigned short int frag;
  // ttl
  unsigned char ttl;
  // proto
  unsigned char proto;
  // cksum
  unsigned short int cksum;
  // sip
  unsigned int sip;
  // dip
  unsigned int dip;
};

struct ipovly
{
  // ih_x1
  unsigned char ih_x1[9l];
  // ih_pr
  unsigned char ih_pr;
  // ih_len
  unsigned short int ih_len;
  // ih_src
  struct in_addr ih_src;
  // ih_dst
  struct in_addr ih_dst;
};

struct list
{
  // pid
  signed int pid;
  // vport
  signed int vport;
  // vmac
  signed int vmac;
  // vsport
  signed int vsport;
  // vcport
  signed int vcport;
  // cmdline
  char *cmdline;
};

struct node
{
  // ip
  unsigned int ip;
  // port
  unsigned short int port;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct packet
{
  // next
  struct packet *next;
  // len
  signed int len;
  // ts
  struct timeval ts;
  // data
  char data[1l];
};

struct peerlist
{
  // nodea
  struct node nodea;
  // nodeb
  struct node nodeb;
  // next
  struct peerlist *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rls
{
  // kb
  char kb[512l];
  // fdin
  signed int fdin;
  // fdout
  signed int fdout;
  // kbuffer
  char *kbuffer;
  // pos
  signed int pos;
  // history
  char **history;
  // hist_total
  signed int hist_total;
  // prompt
  char *prompt;
  // maxbuflen
  signed int maxbuflen;
  // maxhistnum
  signed int maxhistnum;
  // tab_callback
  char ** (*tab_callback)(const char *, const char *);
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct stub$0
{
  // name
  char *name;
  // grpname
  char *grpname;
  // f
  signed int (*f)(signed int, char **);
  // help
  signed int (*help)(signed int, char **);
};

struct stub
{
  // name
  char *name;
  // f
  signed int (*f)(signed int, char **);
};

struct tcphdr
{
  // th_sport
  unsigned short int th_sport;
  // th_dport
  unsigned short int th_dport;
  // th_seq
  unsigned int th_seq;
  // th_ack
  unsigned int th_ack;
  // th_x2
  unsigned int th_x2 : 4;
  // th_off
  unsigned int th_off : 4;
  // th_flags
  unsigned char th_flags;
  // th_win
  unsigned short int th_win;
  // th_sum
  unsigned short int th_sum;
  // th_urp
  unsigned short int th_urp;
};

struct tcpiphdr
{
  // ti_i
  struct ipovly ti_i;
  // ti_t
  struct tcphdr ti_t;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct udpiphdr
{
  // ui_i
  struct ipovly ui_i;
  // ui_u
  struct anonymous$24 ui_u;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};


// canEcho
// file vpcs.c line 65
signed int canEcho = 0;
// cmd_entry
// file vpcs.c line 113
static struct stub$0 cmd_entry[23l];
// cmd_entry
// file vpcs.c line 113
static struct stub$0 cmd_entry[23l] = { { .name="?", .grpname=(char *)(void *)0, .f=run_help,
    .help=help_help },
    { .name="arp", .grpname="show", .f=run_show, .help=help_show },
    { .name="clear", .grpname=(char *)(void *)0, .f=run_clear,
    .help=help_clear },
    { .name="dhcp", .grpname="ip", .f=run_ipconfig, .help=help_ip },
    { .name="disconnect", .grpname=(char *)(void *)0, .f=run_disconnect,
    .help=(signed int (*)(signed int, char **))(void *)0 },
    { .name="echo", .grpname=(char *)(void *)0, .f=run_echo,
    .help=(signed int (*)(signed int, char **))(void *)0 },
    { .name="help", .grpname=(char *)(void *)0, .f=run_help,
    .help=help_help },
    { .name="history", .grpname=(char *)(void *)0, .f=run_hist,
    .help=(signed int (*)(signed int, char **))(void *)0 },
    { .name="relay", .grpname=(char *)(void *)0, .f=run_relay,
    .help=help_relay },
    { .name="ip", .grpname=(char *)(void *)0, .f=run_ipconfig,
    .help=help_ip },
    { .name="load", .grpname=(char *)(void *)0, .f=run_load,
    .help=help_load },
    { .name="neighbor", .grpname=(char *)(void *)0, .f=run_nb6,
    .help=(signed int (*)(signed int, char **))(void *)0 },
    { .name="ping", .grpname=(char *)(void *)0, .f=run_ping,
    .help=help_ping },
    { .name="quit", .grpname=(char *)(void *)0, .f=run_quit,
    .help=(signed int (*)(signed int, char **))(void *)0 },
    { .name="tracer", .grpname=(char *)(void *)0, .f=run_tracert,
    .help=help_trace },
    { .name="rlogin", .grpname=(char *)(void *)0, .f=run_remote,
    .help=help_rlogin },
    { .name="save", .grpname=(char *)(void *)0, .f=run_save,
    .help=help_save },
    { .name="set", .grpname=(char *)(void *)0, .f=run_set,
    .help=help_set },
    { .name="show", .grpname=(char *)(void *)0, .f=run_show,
    .help=help_show },
    { .name="version", .grpname=(char *)(void *)0, .f=run_ver,
    .help=(signed int (*)(signed int, char **))(void *)0 },
    { .name="sleep", .grpname=(char *)(void *)0, .f=run_sleep,
    .help=help_sleep },
    { .name="zzz", .grpname=(char *)(void *)0, .f=run_sleep,
    .help=help_sleep },
    { .name=(char *)(void *)0, .grpname=(char *)(void *)0, .f=((signed int (*)(signed int, char **))NULL),
    .help=((signed int (*)(signed int, char **))NULL) } };
// cmd_entry$link1
// file hv.c line 107
static struct stub cmd_entry$link1[10l];
// cmd_entry$link1
// file hv.c line 107
static struct stub cmd_entry$link1[10l] = { { .name="?", .f=run_help$link1 }, { .name="disconnect", .f=run_disconnect$link1 },
    { .name="help", .f=run_help$link1 }, { .name="list", .f=run_list }, { .name="quit", .f=run_quit$link1 }, { .name="rlogin", .f=run_rlogin }, { .name="telnet", .f=run_rlogin }, { .name="stop", .f=run_stop }, { .name="vpcs", .f=run_vpcs }, { .name=(char *)(void *)0, .f=(signed int (*)(signed int, char **))(void *)0 } };
// cmd_quit
// file daemon.c line 65
static signed int cmd_quit = 0;
// cmd_quit$link1
// file hv.c line 100
static signed int cmd_quit$link1 = 0;
// ctrl_c
// file vpcs.c line 75
signed int ctrl_c = 0;
// daemon_port
// file vpcs.c line 79
signed int daemon_port = 0;
// daemon_port$link1
// file daemon.c line 67
static signed int daemon_port$link1;
// default_startupfile
// file vpcs.c line 70
const char *default_startupfile = "startup.vpc";
// devtype
// file vpcs.c line 59
signed int devtype = 0;
// fdtty_pid
// file daemon.c line 66
static signed int fdtty_pid;
// fptys
// file hv.c line 97
static struct _IO_FILE *fptys;
// histfile
// file vpcs.c line 71
char *histfile = "vpcs.hist";
// hvport
// file hv.c line 103
static signed int hvport = 2000;
// ident
// file vpcs.c line 56
static const char *ident = "$Id: vpcs.c 89 2014-06-28 16:56:30Z dlintott $";
// ip_masks
// file ip.c line 35
unsigned long int ip_masks[33l] = { (unsigned long int)0x0, (unsigned long int)0x80000000, (unsigned long int)0xC0000000, (unsigned long int)0xE0000000, (unsigned long int)0xF0000000, (unsigned long int)0xF8000000, (unsigned long int)0xFC000000, (unsigned long int)0xFE000000, (unsigned long int)0xFF000000, (unsigned long int)0xFF800000, (unsigned long int)0xFFC00000, (unsigned long int)0xFFE00000, (unsigned long int)0xFFF00000, (unsigned long int)0xFFF80000, (unsigned long int)0xFFFC0000, (unsigned long int)0xFFFE0000, (unsigned long int)0xFFFF0000, (unsigned long int)0xFFFF8000, (unsigned long int)0xFFFFC000, (unsigned long int)0xFFFFE000, (unsigned long int)0xFFFFF000, (unsigned long int)0xFFFFF800, (unsigned long int)0xFFFFFC00, (unsigned long int)0xFFFFFE00, (unsigned long int)0xFFFFFF00, (unsigned long int)0xFFFFFF80, (unsigned long int)0xFFFFFFC0, (unsigned long int)0xFFFFFFE0, (unsigned long int)0xFFFFFFF0, (unsigned long int)0xFFFFFFF8, (unsigned long int)0xFFFFFFFC, (unsigned long int)0xFFFFFFFE, (unsigned long int)0xFFFFFFFF };
// lport
// file vpcs.c line 60
signed int lport = 20000;
// macaddr
// file vpcs.c line 85
signed int macaddr = 0;
// num_pths
// file vpcs.c line 81
signed int num_pths = 9;
// optarg
// file ./getopt.h line 47
extern char *optarg;
// optind
// file ./getopt.h line 48
extern signed int optind;
// pcid
// file vpcs.c line 58
signed int pcid = 0;
// peerlist
// file relay.c line 49
static struct peerlist *peerlist = (struct peerlist *)(void *)0;
// pid_master
// file hv.c line 102
static unsigned long int pid_master;
// pid_salve
// file hv.c line 102
static unsigned long int pid_salve;
// prgname
// file hv.c line 105
static char prgname[4096l];
// ptyfdm
// file hv.c line 96
static signed int ptyfdm;
// ptyfds
// file hv.c line 96
static signed int ptyfds;
// relay_fd
// file relay.c line 50
static signed int relay_fd = 0;
// relay_port
// file relay.c line 51
static signed int relay_port = 0;
// rhost
// file vpcs.c line 63
unsigned int rhost = (unsigned int)0;
// rls
// file vpcs.c line 77
struct rls *rls = (struct rls *)(void *)0;
// rls$link1
// file hv.c line 104
static struct rls *rls$link1 = (struct rls *)(void *)0;
// rport
// file vpcs.c line 61
signed int rport = 30000;
// rport_flag
// file vpcs.c line 62
signed int rport_flag = 0;
// runLoad
// file vpcs.c line 66
signed int runLoad = 0;
// runStartup
// file vpcs.c line 68
signed int runStartup = 0;
// sock
// file hv.c line 98
static signed int sock = -1;
// sock_cli
// file hv.c line 99
static signed int sock_cli = -1;
// startupfile
// file vpcs.c line 69
char *startupfile = (char *)(void *)0;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tapname
// file vpcs.c line 83
char *tapname = "tap0";
// time_tick
// file vpcs.c line 73
unsigned int time_tick = (unsigned int)0;
// ver
// file vpcs.c line 54
const char *ver = "0.5b2";
// vpc
// file vpcs.h line 117
struct anonymous$0 vpc[9l];
// vpcs_list
// file hv.c line 94
static struct list vpcs_list[10l];

// VRead
// file dev.h line 35
signed int VRead(struct anonymous$0 *pc, void *buf, signed int len)
{
  struct sockaddr addr;
  unsigned int size;
  signed int n = 0;
  struct anonymous$14 readSet;
  struct timeval VRead$$1$$timeout = { .tv_sec=(signed long int)1, .tv_usec=(signed long int)0 };
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readSet)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&readSet)->__fds_bits[(signed long int)(pc->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readSet)->__fds_bits[(signed long int)(pc->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << pc->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  signed int return_value_select$1;
  return_value_select$1=select(pc->fd + 1, &readSet, (struct anonymous$14 *)(void *)0, (struct anonymous$14 *)(void *)0, &VRead$$1$$timeout);
  signed long int return_value_read$2;
  signed long int return_value_recvfrom$3;
  if(!(return_value_select$1 >= 1))
    return 0;

  else
  {
    switch(devtype)
    {
      case 1:
      {
        return_value_read$2=read(pc->fd, buf, (unsigned long int)len);
        n = (signed int)return_value_read$2;
        break;
      }
      case 2:
      {
        size = (unsigned int)sizeof(struct sockaddr) /*16ul*/ ;
        return_value_recvfrom$3=recvfrom(pc->fd, buf, (unsigned long int)len, 0, (struct sockaddr *)&addr, &size);
        n = (signed int)return_value_recvfrom$3;
      }
    }
    return n;
  }
}

// VWrite
// file dev.h line 36
signed int VWrite(struct anonymous$0 *pc, void *buf, signed int len)
{
  struct sockaddr_in addr;
  signed int n = 0;
  struct anonymous$14 writeSet;
  struct timeval VWrite$$1$$timeout = { .tv_sec=(signed long int)1, .tv_usec=(signed long int)0 };
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writeSet)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&writeSet)->__fds_bits[(signed long int)(pc->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writeSet)->__fds_bits[(signed long int)(pc->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << pc->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  signed int return_value_select$1;
  return_value_select$1=select(pc->fd + 1, (struct anonymous$14 *)(void *)0, &writeSet, (struct anonymous$14 *)(void *)0, &VWrite$$1$$timeout);
  signed long int return_value_write$2;
  signed long int return_value_sendto$3;
  if(!(return_value_select$1 >= 1))
    return 0;

  else
  {
    switch(devtype)
    {
      case 1:
      {
        return_value_write$2=write(pc->fd, buf, (unsigned long int)len);
        n = (signed int)return_value_write$2;
        break;
      }
      case 2:
      {
        bzero((void *)&addr, sizeof(struct sockaddr_in) /*16ul*/ );
        addr.sin_family = (unsigned short int)2;
        addr.sin_port=htons((unsigned short int)pc->rport);
        addr.sin_addr.s_addr = pc->rhost;
        return_value_sendto$3=sendto(pc->fd, buf, (unsigned long int)len, 0, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
        n = (signed int)return_value_sendto$3;
      }
    }
    return n;
  }
}

// _readline
// file readline.c line 185
static signed int _readline(struct rls *rls)
{
  signed int flags;
  struct termios termios;
  signed int i;
  signed int j;
  signed int fkey;
  char *kb;
  signed int ihist;
  signed int rc;
  char **tab;
  char *p;
  signed int off = 0;
  signed int return_value_isatty$1;
  return_value_isatty$1=isatty(rls->fdin);
  if(!(return_value_isatty$1 == 0))
    set_terminal(rls->fdin, &termios);

  memset((void *)rls->kbuffer, 0, (unsigned long int)rls->maxbuflen);
  rls->pos = 0;
  flags = 0;
  ihist = 0;
  kb = rls->kb;
  rc = 0;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$11;
  signed int tmp_post$12;
  signed int tmp_post$14;
  unsigned long int return_value_strlen$16;
  signed int tmp_post$17;
  _Bool tmp_if_expr$20;
  signed int tmp_post$19;
  _Bool tmp_if_expr$29;
  unsigned long int return_value_strlen$28;
  unsigned long int return_value_strlen$32;
  while((_Bool)1)
  {
    if(off >= rc)
    {
      memset((void *)kb, 0, sizeof(char [512l]) /*512ul*/ );
      signed long int return_value_read$2;
      return_value_read$2=read(rls->fdin, (void *)kb, sizeof(char [512l]) /*512ul*/ );
      rc = (signed int)return_value_read$2;
      if(!(rc >= 1))
        goto __CPROVER_DUMP_L60;

      off = 0;
    }

    else
    {
      memmove((void *)kb, (const void *)(kb + (signed long int)off), (unsigned long int)(rc - off));
      rc = rc - off;
    }
    if((signed int)*kb == 27)
    {
      if((signed int)kb[1l] == 0x5b)
      {
        fkey = (signed int)kb[(signed long int)2] | (signed int)kb[(signed long int)3] << 8;
        if((signed int)kb[2l] == 0x0041)
        {
          off = 3;
          if(flags == 0)
          {
            flags = 1;
            ihist = rls->hist_total;
            if(!(rls->pos == 0))
              strcpy(rls->history[(signed long int)rls->maxhistnum], rls->kbuffer);

            else
              rls->history[(signed long int)rls->maxhistnum][(signed long int)0] = (char)0;
          }

          if(ihist == 0)
            continue;

          i=findhistory(rls, 0 - ihist);
          if(i == -1)
            continue;

          ihist = i;
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(rls->kbuffer);
          i = (signed int)return_value_strlen$3;
          do
          {
            tmp_post$4 = rls->pos;
            rls->pos = rls->pos + 1;
            if(tmp_post$4 >= i)
              break;

            vprint(rls->fdout, " ", 1);
          }
          while((_Bool)1);
          do
          {
            tmp_post$5 = i;
            i = i - 1;
            if(!(tmp_post$5 >= 1))
              break;

            vprint(rls->fdout, "\b \b", 3);
          }
          while((_Bool)1);
          memset((void *)rls->kbuffer, 0, (unsigned long int)rls->maxbuflen);
          strcpy(rls->kbuffer, rls->history[(signed long int)ihist]);
          unsigned long int return_value_strlen$6;
          return_value_strlen$6=strlen(rls->kbuffer);
          rls->pos = (signed int)return_value_strlen$6;
          vprint(rls->fdout, rls->kbuffer, rls->pos);
          continue;
        }

        if((signed int)kb[2l] == 0x0042)
        {
          off = 3;
          if(flags == 0)
            continue;

          if(1 + ihist >= rls->hist_total)
          {
            unsigned long int return_value_strlen$7;
            return_value_strlen$7=strlen(rls->kbuffer);
            i = (signed int)return_value_strlen$7;
            do
            {
              tmp_post$8 = rls->pos;
              rls->pos = rls->pos + 1;
              if(tmp_post$8 >= i)
                break;

              vprint(rls->fdout, " ", 1);
            }
            while((_Bool)1);
            do
            {
              tmp_post$9 = i;
              i = i - 1;
              if(!(tmp_post$9 >= 1))
                break;

              vprint(rls->fdout, "\b \b", 3);
            }
            while((_Bool)1);
            memset((void *)rls->kbuffer, 0, (unsigned long int)rls->maxbuflen);
            rls->pos = 0;
            flags = 0;
            continue;
          }

          i=findhistory(rls, ihist);
          if(i == -1)
            continue;

          ihist = i;
          unsigned long int return_value_strlen$10;
          return_value_strlen$10=strlen(rls->kbuffer);
          i = (signed int)return_value_strlen$10;
          do
          {
            tmp_post$11 = rls->pos;
            rls->pos = rls->pos + 1;
            if(tmp_post$11 >= i)
              break;

            vprint(rls->fdout, " ", 1);
          }
          while((_Bool)1);
          do
          {
            tmp_post$12 = i;
            i = i - 1;
            if(!(tmp_post$12 >= 1))
              break;

            vprint(rls->fdout, "\b \b", 3);
          }
          while((_Bool)1);
          memset((void *)rls->kbuffer, 0, (unsigned long int)rls->maxbuflen);
          strcpy(rls->kbuffer, rls->history[(signed long int)ihist]);
          unsigned long int return_value_strlen$13;
          return_value_strlen$13=strlen(rls->kbuffer);
          rls->pos = (signed int)return_value_strlen$13;
          vprint(rls->fdout, rls->kbuffer, rls->pos);
          continue;
        }

        if((signed int)kb[2l] == 0x0043)
        {
          off = 3;
          unsigned long int return_value_strlen$15;
          return_value_strlen$15=strlen(rls->kbuffer);
          if(!((unsigned long int)rls->pos >= return_value_strlen$15))
          {
            tmp_post$14 = rls->pos;
            rls->pos = rls->pos + 1;
            vprint(rls->fdout, &rls->kbuffer[(signed long int)tmp_post$14], 1);
          }

          continue;
        }

        if((signed int)kb[2l] == 0x0044)
        {
          off = 3;
          if(rls->pos >= 1)
          {
            vprint(rls->fdout, "\b", 1);
            rls->pos = rls->pos - 1;
          }

          continue;
        }

        if(fkey == 0x7e31)
        {
          off = 4;
          for( ; rls->pos >= 1; rls->pos = rls->pos - 1)
            vprint(rls->fdout, "\b", 1);
          continue;
        }

        if(fkey == 0x7e34)
        {
          off = 4;
          do
          {
            return_value_strlen$16=strlen(rls->kbuffer);
            if((unsigned long int)rls->pos >= return_value_strlen$16)
              break;

            tmp_post$17 = rls->pos;
            rls->pos = rls->pos + 1;
            vprint(rls->fdout, &rls->kbuffer[(signed long int)tmp_post$17], 1);
          }
          while((_Bool)1);
          continue;
        }

      }

    }

    flags = 0;
    if((signed int)*kb == 10)
      tmp_if_expr$20 = (_Bool)1;

    else
      tmp_if_expr$20 = (signed int)kb[(signed long int)0] == 13 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$20)
    {
      off = 1;
      trimspace(rls->kbuffer);
      unsigned long int return_value_strlen$18;
      return_value_strlen$18=strlen(rls->kbuffer);
      rls->pos = (signed int)return_value_strlen$18;
      if(rls->pos == 0)
        break;

      if(rls->hist_total == rls->maxhistnum)
      {
        memmove((void *)rls->history[(signed long int)0], (const void *)rls->history[(signed long int)1], (unsigned long int)(rls->maxbuflen * (rls->maxhistnum - 1)));
        rls->hist_total = rls->hist_total - 1;
      }

      tmp_post$19 = rls->hist_total;
      rls->hist_total = rls->hist_total + 1;
      strcpy(rls->history[(signed long int)tmp_post$19], rls->kbuffer);
      break;
    }

    if((signed int)*kb == 3)
    {
      off = 1;
      rls->pos = 0;
      rls->kbuffer[(signed long int)0] = (char)0;
      break;
    }

    if((signed int)*kb == 9)
    {
      off = 1;
      if(rls->tab_callback == ((char ** (*)(const char *, const char *))NULL))
        continue;

      p = (char *)(void *)0;
      if(!(rls->pos == 0))
      {
        p = rls->kbuffer + (signed long int)rls->pos;
        for( ; !(rls->kbuffer >= p); p = p - 1l)
          if((signed int)p[-1l] == 32)
            break;

      }

      tab=rls->tab_callback(rls->kbuffer, p);
      if(tab == ((char **)NULL))
        continue;

      if(!(*tab == ((char *)NULL)))
      {
        if(tab[1l] == ((char *)NULL))
        {
          i = 0;
          unsigned long int return_value_strlen$21;
          return_value_strlen$21=strlen(p);
          if(!((unsigned long int)i >= return_value_strlen$21))
          {
            vprint(rls->fdout, "\b \b", 3);
            i = i + 1;
          }

          unsigned long int return_value_strlen$22;
          return_value_strlen$22=strlen(*tab);
          i = (signed int)return_value_strlen$22;
          vprint(rls->fdout, *tab, i);
          if(!((p - rls->kbuffer) + (signed long int)i >= (signed long int)rls->maxbuflen))
          {
            strcpy(p, *tab);
            unsigned long int return_value_strlen$23;
            return_value_strlen$23=strlen(rls->kbuffer);
            rls->pos = (signed int)return_value_strlen$23;
          }

          free((void *)*tab);
          free((void *)tab);
          continue;
        }

      }

      vprint(rls->fdout, "\n", 1);
      i = 0;
      if(!(tab[(signed long int)i] == ((char *)NULL)))
      {
        unsigned long int return_value_strlen$24;
        return_value_strlen$24=strlen(tab[(signed long int)i]);
        vprint(rls->fdout, tab[(signed long int)i], (signed int)return_value_strlen$24);
        vprint(rls->fdout, " ", 1);
        free((void *)tab[(signed long int)i]);
        i = i + 1;
      }

      vprint(rls->fdout, "\n", 1);
      free((void *)tab);
      unsigned long int return_value_strlen$25;
      return_value_strlen$25=strlen(rls->prompt);
      vprint(rls->fdout, rls->prompt, (signed int)return_value_strlen$25);
      vprint(rls->fdout, rls->kbuffer, rls->pos);
      continue;
    }

    if((signed int)*kb == 8)
      tmp_if_expr$29 = (_Bool)1;

    else
      tmp_if_expr$29 = (signed int)kb[(signed long int)0] == 127 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$29)
    {
      off = 1;
      if(rls->pos >= 1)
      {
        unsigned long int return_value_strlen$26;
        return_value_strlen$26=strlen(rls->kbuffer);
        i = (signed int)return_value_strlen$26;
        j = rls->pos;
        for( ; !(j >= i); j = j + 1)
          rls->kbuffer[(signed long int)(j - 1)] = rls->kbuffer[(signed long int)j];
        rls->kbuffer[(signed long int)(j - 1)] = (char)0;
        rls->pos = rls->pos - 1;
        vprint(rls->fdout, "\b", 1);
        unsigned long int return_value_strlen$27;
        return_value_strlen$27=strlen(&rls->kbuffer[(signed long int)rls->pos]);
        vprint(rls->fdout, &rls->kbuffer[(signed long int)rls->pos], (signed int)return_value_strlen$27);
        vprint(rls->fdout, " \b", 2);
        i = 0;
        do
        {
          return_value_strlen$28=strlen(rls->kbuffer);
          if((unsigned long int)i >= return_value_strlen$28 + -((unsigned long int)rls->pos))
            break;

          vprint(rls->fdout, "\b", 1);
          i = i + 1;
        }
        while((_Bool)1);
      }

    }

    else
    {
      off = 1;
      i = (signed int)kb[(signed long int)0];
      const unsigned short int **return_value___ctype_b_loc$34;
      return_value___ctype_b_loc$34=__ctype_b_loc();
      if(!((16384 & (signed int)(*return_value___ctype_b_loc$34)[(signed long int)i]) == 0))
      {
        unsigned long int return_value_strlen$33;
        return_value_strlen$33=strlen(rls->kbuffer);
        if(!((unsigned long int)rls->pos >= return_value_strlen$33 + 18446744073709551615ul))
        {
          unsigned long int return_value_strlen$30;
          return_value_strlen$30=strlen(rls->kbuffer);
          j = (signed int)return_value_strlen$30;
          if(!(j >= rls->maxbuflen + -1))
          {
            for( ; !(rls->pos >= j); j = j - 1)
              rls->kbuffer[(signed long int)j] = rls->kbuffer[(signed long int)(j - 1)];
            rls->kbuffer[(signed long int)rls->pos] = kb[(signed long int)0];
            unsigned long int return_value_strlen$31;
            return_value_strlen$31=strlen(&rls->kbuffer[(signed long int)rls->pos]);
            vprint(rls->fdout, &rls->kbuffer[(signed long int)rls->pos], (signed int)return_value_strlen$31);
            j = 0;
            do
            {
              return_value_strlen$32=strlen(rls->kbuffer);
              if((unsigned long int)j >= return_value_strlen$32 + -((unsigned long int)rls->pos) + 18446744073709551615ul)
                break;

              vprint(rls->fdout, "\b", 1);
              j = j + 1;
            }
            while((_Bool)1);
          }

        }

        else
        {
          rls->kbuffer[(signed long int)rls->pos] = kb[(signed long int)0];
          rls->kbuffer[(signed long int)(rls->pos + 1)] = (char)0;
          vprint(rls->fdout, &kb[(signed long int)0], 1);
        }
        rls->pos = rls->pos + 1;
      }

    }

  __CPROVER_DUMP_L60:
    ;
    if((signed int)*kb == 16)
      break;

  }
  signed int return_value_isatty$35;
  return_value_isatty$35=isatty(rls->fdin);
  if(!(return_value_isatty$35 == 0))
    reset_terminal(rls->fdin, &termios);

  return rls->pos > 0 ? 1 : 0;
}

// arg2int
// file utils.h line 41
signed int arg2int(const char *arg, signed int min, signed int max, signed int defval)
{
  signed int r;
  _Bool tmp_if_expr$2;
  signed int return_value_sscanf$1;
  if(arg == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_sscanf$1=sscanf(arg, "%d", &r);
    tmp_if_expr$2 = return_value_sscanf$1 != 1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return defval;

  else
    return r;
}

// arp
// file packets.c line 484
static struct packet * arp(struct anonymous$0 *pc, unsigned int dip)
{
  struct ethdr *eh;
  struct arphdr *ah;
  struct packet *m;
  unsigned int *si;
  unsigned int *di;
  unsigned char broadcast[6l] = { (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff };
  m=new_pkt(64);
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    eh = (struct ethdr *)m->data;
    ah = (struct arphdr *)(eh + (signed long int)1);
    ah->hrd=htons((unsigned short int)1);
    ah->pro=htons((unsigned short int)0x0800);
    ah->hln = (unsigned char)6;
    ah->pln = (unsigned char)4;
    ah->op=htons((unsigned short int)1);
    si = (unsigned int *)ah->sip;
    di = (unsigned int *)ah->dip;
    si[(signed long int)0] = pc->ip4.ip;
    di[(signed long int)0] = dip;
    memcpy((void *)ah->dea, (const void *)broadcast, (unsigned long int)6);
    memcpy((void *)ah->sea, (const void *)pc->ip4.mac, (unsigned long int)6);
    encap_ehead(m->data, pc->ip4.mac, broadcast, (const unsigned short int)0x0806);
    return m;
  }
}

// arpResolve
// file packets.c line 254
signed int arpResolve(struct anonymous$0 *pc, unsigned int ip, unsigned char *dmac)
{
  signed int i;
  signed int c;
  struct packet *m;
  signed int waittime = 1000;
  struct timeval tv;
  c = 0;
  i = 0;
  signed int return_value_etherIsZero$1;
  for( ; !(i >= 10); i = i + 1)
    if(pc->ipmac4[(signed long int)i].ip == ip)
    {
      if(!(time_tick + -((unsigned int)pc->ipmac4[(signed long int)i].timeout) >= 121u))
      {
        return_value_etherIsZero$1=etherIsZero(pc->ipmac4[(signed long int)i].mac);
        if(return_value_etherIsZero$1 == 0)
        {
          memcpy((void *)dmac, (const void *)pc->ipmac4[(signed long int)i].mac, (unsigned long int)6);
          return 1;
        }

      }

    }

  signed int tmp_post$2;
  signed int return_value_timeout$3;
  signed int return_value_etherIsZero$4;
  do
  {
    tmp_post$2 = c;
    c = c + 1;
    if(tmp_post$2 >= 3)
      break;

    m=arp(pc, ip);
    if(m == ((struct packet *)NULL))
    {
      printf("out of memory\n");
      return 0;
    }

    enq(&pc->oq, m);
    gettimeofday(&tv, (struct timezone *)(void *)0);
    do
    {
      return_value_timeout$3=timeout(tv, waittime);
      if(!(return_value_timeout$3 == 0))
        break;

      usleep((unsigned int)(1 * 1000));
      i = 0;
      for( ; !(i >= 10); i = i + 1)
        if(pc->ipmac4[(signed long int)i].ip == ip)
        {
          if(!(time_tick + -((unsigned int)pc->ipmac4[(signed long int)i].timeout) >= 121u))
          {
            return_value_etherIsZero$4=etherIsZero(pc->ipmac4[(signed long int)i].mac);
            if(return_value_etherIsZero$4 == 0)
            {
              memcpy((void *)dmac, (const void *)pc->ipmac4[(signed long int)i].mac, (unsigned long int)6);
              return 1;
            }

          }

        }

    }
    while((_Bool)1);
  }
  while((_Bool)1);
  return 0;
}

// autoconf6
// file command6.h line 45
void autoconf6(void)
{
  signed int i;
  struct packet *m = (struct packet *)(void *)0;
  i = 0;
  for( ; !(i >= num_pths); i = i + 1)
  {
    m=nbr_sol(&vpc[(signed long int)pcid]);
    if(!(m == ((struct packet *)NULL)))
      enq(&vpc[(signed long int)pcid].oq, m);

  }
}

// cksum
// file ip.h line 453
unsigned short int cksum(unsigned short int *buffer, signed int size)
{
  unsigned long int cksum$$1$$cksum = (unsigned long int)0;
  unsigned short int *tmp_post$1;
  for( ; size >= 2; size = size - (signed int)sizeof(unsigned short int) /*2ul*/ )
  {
    tmp_post$1 = buffer;
    buffer = buffer + 1l;
    cksum$$1$$cksum = cksum$$1$$cksum + (unsigned long int)*tmp_post$1;
  }
  if(!(size == 0))
    cksum$$1$$cksum = cksum$$1$$cksum + (unsigned long int)*((unsigned char *)buffer);

  cksum$$1$$cksum = (cksum$$1$$cksum >> 16) + (cksum$$1$$cksum & (unsigned long int)0xffff);
  cksum$$1$$cksum = cksum$$1$$cksum + (cksum$$1$$cksum >> 16);
  return (unsigned short int)~cksum$$1$$cksum;
}

// cksum6
// file ip.h line 455
unsigned short int cksum6(struct anonymous$18 *ip, unsigned char nxt, signed int len)
{
  signed int sum = 0;
  unsigned short int *w;
  /* tag-#anon#lST[U32'ph_len'||lARR3{U8}$U8$'ph_zero'||U8'ph_nxt'|] */
struct anonymous$28
{
  // ph_len
  unsigned int ph_len;
  // ph_zero
  unsigned char ph_zero[3l];
  // ph_nxt
  unsigned char ph_nxt;
};

/* */
  ;
  /* tag-#anon#lUN[lARR4{U16}$U16$'phs'||lSYM#tag-#anon#lST[U32'ph_len'||lARR3{U8}$U8$'ph_zero'||U8'ph_nxt'|]#'ph'|] */
union anonymous$29
{
  // phs
  unsigned short int phs[4l];
  // ph
  struct anonymous$28 ph;
};

/* */
  ;
  union anonymous$29 uph;
  memset((void *)&uph, 0, (unsigned long int)8);
  uph.ph.ph_len=htonl((unsigned int)len);
  uph.ph.ph_nxt = nxt;
  sum = sum + (signed int)uph.phs[(signed long int)0];
  sum = sum + (signed int)uph.phs[(signed long int)1];
  sum = sum + (signed int)uph.phs[(signed long int)2];
  sum = sum + (signed int)uph.phs[(signed long int)3];
  w = (unsigned short int *)&ip->src;
  sum = sum + (signed int)w[(signed long int)0];
  sum = sum + (signed int)w[(signed long int)1];
  sum = sum + (signed int)w[(signed long int)2];
  sum = sum + (signed int)w[(signed long int)3];
  sum = sum + (signed int)w[(signed long int)4];
  sum = sum + (signed int)w[(signed long int)5];
  sum = sum + (signed int)w[(signed long int)6];
  sum = sum + (signed int)w[(signed long int)7];
  w = (unsigned short int *)&ip->dst;
  sum = sum + (signed int)w[(signed long int)0];
  sum = sum + (signed int)w[(signed long int)1];
  sum = sum + (signed int)w[(signed long int)2];
  sum = sum + (signed int)w[(signed long int)3];
  sum = sum + (signed int)w[(signed long int)4];
  sum = sum + (signed int)w[(signed long int)5];
  sum = sum + (signed int)w[(signed long int)6];
  sum = sum + (signed int)w[(signed long int)7];
  w = (unsigned short int *)(ip + (signed long int)1);
  unsigned short int *tmp_post$1;
  for( ; len >= 2; len = len - (signed int)sizeof(unsigned short int) /*2ul*/ )
  {
    tmp_post$1 = w;
    w = w + 1l;
    sum = sum + (signed int)*tmp_post$1;
  }
  if(!(len == 0))
    sum = sum + (signed int)*((unsigned char *)w);

  sum = (sum >> 16) + (sum & 0xffff);
  sum = sum + (sum >> 16);
  return (unsigned short int)~sum;
}

// cksum_fixup
// file ip.h line 454
unsigned short int cksum_fixup(unsigned short int cksum, unsigned short int old, unsigned short int new, unsigned short int udp)
{
  unsigned long int l = (unsigned long int)0;
  if(cksum == 0 && !(udp == 0))
    return (unsigned short int)0x0000;

  else
  {
    l = (unsigned long int)(((signed int)cksum + (signed int)old) - (signed int)new);
    l = (l >> 16) + (l & (unsigned long int)0xffff);
    l = l & (unsigned long int)0xffff;
    if(l == 0ul && !(udp == 0))
      return (unsigned short int)0xFFFF;

    else
      return (unsigned short int)l;
  }
}

// clean
// file hv.c line 355
static void clean(void)
{
  close(ptyfdm);
  close(ptyfds);
  close(sock_cli);
  close(sock);
}

// clear_hist
// file vpcs.c line 589
void clear_hist(void)
{
  rls->hist_total = 0;
}

// daemon_proc
// file daemon.c line 163
static void daemon_proc(signed int sock, signed int fdtty)
{
  signed int daemon_proc$$1$$sock_cli;
  struct sockaddr_in cli;
  signed int slen;
  struct anonymous$26 set;
  struct timeval tv;
  unsigned char buf[8192l];
  signed int i;
  slen = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed long int return_value_write$4;
  while((_Bool)1)
  {
    cmd_quit = 0;
    daemon_proc$$1$$sock_cli=accept(sock, (struct sockaddr *)&cli, (unsigned int *)&slen);
    if(daemon_proc$$1$$sock_cli >= 0)
    {
      set_telnet_mode(daemon_proc$$1$$sock_cli);
      while(cmd_quit == 0)
      {
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$26) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&set)->fds_bits[(signed long int)(daemon_proc$$1$$sock_cli / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->fds_bits[(signed long int)(daemon_proc$$1$$sock_cli / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << daemon_proc$$1$$sock_cli % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        (&set)->fds_bits[(signed long int)(fdtty / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->fds_bits[(signed long int)(fdtty / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fdtty % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        tv.tv_sec = (signed long int)0;
        tv.tv_usec = (signed long int)100000;
        i=select(fdtty > daemon_proc$$1$$sock_cli ? fdtty + 1 : daemon_proc$$1$$sock_cli + 1, &set, (struct anonymous$26 *)(void *)0, (struct anonymous$26 *)(void *)0, &tv);
        if(!(i >= 0))
          break;

        if(!(i == 0))
        {
          if(!((set.fds_bits[(signed long int)(fdtty / 8)] & (signed long int)(1UL << fdtty % 8)) == 0l))
          {
            memset((void *)buf, 0, sizeof(unsigned char [8192l]) /*8192ul*/ );
            signed long int return_value_read$1;
            return_value_read$1=read(fdtty, (void *)buf, sizeof(unsigned char [8192l]) /*8192ul*/ );
            i = (signed int)return_value_read$1;
            if(!(i >= 1))
              break;

            signed long int return_value_write$2;
            return_value_write$2=write(daemon_proc$$1$$sock_cli, (const void *)buf, (unsigned long int)i);
            if(!(return_value_write$2 >= 1l))
              break;

          }

          if(!((set.fds_bits[(signed long int)(daemon_proc$$1$$sock_cli / 8)] & (signed long int)(1UL << daemon_proc$$1$$sock_cli % 8)) == 0l))
          {
            memset((void *)buf, 0, sizeof(unsigned char [8192l]) /*8192ul*/ );
            signed long int return_value_read$3;
            return_value_read$3=read(daemon_proc$$1$$sock_cli, (void *)buf, sizeof(unsigned char [8192l]) /*8192ul*/ );
            i = (signed int)return_value_read$3;
            if(!(i >= 1))
              break;

            if(!((signed int)buf[0l] == 0xff))
            {
              return_value_write$4=write(fdtty, (const void *)buf, (unsigned long int)i);
              if(!(return_value_write$4 >= 1l))
                break;

            }

          }

        }

      }
      strcpy((char *)buf, "\r\nGood-bye\r\n");
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen((char *)buf);
      signed long int return_value_write$6;
      return_value_write$6=write(daemon_proc$$1$$sock_cli, (const void *)buf, return_value_strlen$5);
      i = (signed int)return_value_write$6;
      close(daemon_proc$$1$$sock_cli);
    }

  }
}

// daemonize
// file daemon.h line 30
signed int daemonize(signed int port, signed int bg)
{
  signed int daemonize$$1$$sock = 0;
  struct sockaddr_in serv;
  signed int on = 1;
  signed int fdtty;
  signed int pid;
  if(!(bg == 0))
  {
    pid=fork();
    if(!(pid >= 0))
    {
      perror("Daemon fork");
      return -1;
    }

    if(pid >= 1)
      exit(0);

  }

  daemon_port$link1 = port;
  setsid();
  signal(15, sig_term);
  signal(3, sig_quit);
  signal(2, sig_int$link1);
  signal(1, (void (*)(signed int))1);
  signal(10, sig_usr1);
  signal(12, sig_usr2);
  signal(17, (void (*)(signed int))1);
  signal(13, (void (*)(signed int))1);
  fdtty_pid=forkpty(&fdtty, (char *)(void *)0, (struct termios *)(void *)0, (struct winsize *)(void *)0);
  signed int return_value_bind$1;
  signed int return_value_listen$2;
  if(!(fdtty_pid >= 0))
  {
    perror("Daemon fork tty\n");
    return -1;
  }

  else
    if(fdtty_pid == 0)
      return 0;

    else
    {
      daemonize$$1$$sock=socket(2, 1, 6);
      if(!(daemonize$$1$$sock >= 0))
        perror("Daemon socket");

      else
      {
        setsockopt(daemonize$$1$$sock, 1, 2, (const void *)(char *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
        bzero((void *)(char *)&serv, sizeof(struct sockaddr_in) /*16ul*/ );
        serv.sin_family = (unsigned short int)2;
        serv.sin_addr.s_addr=htonl((unsigned int)0x00000000);
        serv.sin_port=htons((unsigned short int)port);
        return_value_bind$1=bind(daemonize$$1$$sock, (struct sockaddr *)&serv, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
        if(!(return_value_bind$1 >= 0))
          perror("Daemon bind port");

        else
        {
          return_value_listen$2=listen(daemonize$$1$$sock, 5);
          if(!(return_value_listen$2 >= 0))
            perror("Daemon listen");

          else
            daemon_proc(daemonize$$1$$sock, fdtty);
        }
      }

    err:
      ;
      if(daemonize$$1$$sock >= 0)
        close(daemonize$$1$$sock);

      close(fdtty);
      kill(fdtty_pid, 9);
      exit(-1);
    }
}

// del_pkt
// file queue.h line 69
void del_pkt(struct packet *m)
{
  free((void *)m);
}

// deq
// file queue.c line 71
struct packet * deq(struct pq *pq)
{
  struct packet *return_value_deq_impl$1;
  return_value_deq_impl$1=deq_impl(pq, 0);
  return return_value_deq_impl$1;
}

// deq_impl
// file queue.c line 51
struct packet * deq_impl(struct pq *pq, signed int cond)
{
  struct packet *m = (struct packet *)(void *)0;
  lock_q(pq);
  if(!(cond == 0))
  {
    if(pq->q == ((struct packet *)NULL))
      pthread_cond_wait(&pq->cond, &pq->locker);

  }

  if(!(pq->q == ((struct packet *)NULL)))
  {
    m = pq->q;
    pq->q = pq->q->next;
    pq->size = pq->size - 1;
  }

  ulock_q(pq);
  return m;
}

// dhcp4_discover
// file dhcp.h line 83
struct packet * dhcp4_discover(struct anonymous$0 *pc, signed int renew)
{
  struct ethdr *eh;
  struct iphdr *ip;
  struct udpiphdr *ui;
  struct dhcp4_packet *dh;
  signed int i;
  signed int k;
  struct packet *m;
  char b[9l];
  unsigned char bcast[6l] = { (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff };
  m=new_pkt(512);
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$12;
  signed int tmp_post$13;
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    eh = (struct ethdr *)m->data;
    ip = (struct iphdr *)(eh + (signed long int)1);
    ui = (struct udpiphdr *)ip;
    dh = (struct dhcp4_packet *)(ui + (signed long int)1);
    dh->op = (char)1;
    dh->htype = (char)1;
    dh->hlen = (char)6;
    dh->hops = (char)0;
    dh->xid = pc->ip4.dhcp.xid;
    dh->secs = (unsigned short int)0;
    dh->flags = (unsigned short int)0;
    dh->ciaddr = (unsigned int)0;
    dh->yiaddr = (unsigned int)0;
    dh->siaddr = (unsigned int)0;
    dh->giaddr = (unsigned int)0;
    memcpy((void *)dh->chaddr, (const void *)pc->ip4.mac, (unsigned long int)6);
    i = 0;
    unsigned int return_value_htonl$1;
    return_value_htonl$1=htonl((unsigned int)0x63825363);
    ((signed int *)&dh->options[(signed long int)i])[(signed long int)0] = (signed int)return_value_htonl$1;
    i = i + (signed int)sizeof(signed int) /*4ul*/ ;
    tmp_post$2 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$2] = (unsigned char)53;
    tmp_post$3 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$3] = (unsigned char)1;
    tmp_post$4 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$4] = (unsigned char)1;
    tmp_post$5 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$5] = (unsigned char)12;
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(pc->xname);
    k = (signed int)return_value_strlen$6;
    tmp_post$7 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$7] = (unsigned char)(k + 1);
    strncpy((char *)(dh->options + (signed long int)i), pc->xname, (unsigned long int)k);
    i = i + k;
    tmp_post$8 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$8] = (unsigned char)(pc->id + 49);
    tmp_post$9 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$9] = (unsigned char)61;
    tmp_post$10 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$10] = (unsigned char)7;
    tmp_post$11 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$11] = (unsigned char)1;
    memcpy((void *)&dh->options[(signed long int)i], (const void *)pc->ip4.mac, (unsigned long int)6);
    i = i + 6;
    if(!(renew == 0))
    {
      if(!(pc->ip4.dhcp.ip == 0u))
      {
        tmp_post$12 = i;
        i = i + 1;
        dh->options[(signed long int)tmp_post$12] = (unsigned char)50;
        tmp_post$13 = i;
        i = i + 1;
        dh->options[(signed long int)tmp_post$13] = (unsigned char)4;
        ((signed int *)&dh->options[(signed long int)i])[(signed long int)0] = (signed int)pc->ip4.dhcp.ip;
        i = i + (signed int)sizeof(signed int) /*4ul*/ ;
      }

    }

    dh->options[(signed long int)i] = (unsigned char)255;
    ui->ui_u.sport=htons((unsigned short int)68);
    ui->ui_u.dport=htons((unsigned short int)67);
    ui->ui_u.len=htons((unsigned short int)(sizeof(struct dhcp4_packet) /*364ul*/  + sizeof(struct anonymous$24) /*8ul*/ ));
    ui->ui_u.cksum = (unsigned short int)0;
    ip->ver = (unsigned int)4;
    ip->ihl = (unsigned int)(sizeof(struct iphdr) /*20ul*/  >> 2);
    ip->tos = (unsigned char)0x10;
    ip->len=htons((unsigned short int)(sizeof(struct udpiphdr) /*28ul*/  + sizeof(struct dhcp4_packet) /*364ul*/ ));
    ip->id = (unsigned short int)0;
    ip->ttl = (unsigned char)16;
    ip->proto = (unsigned char)17;
    ip->cksum = (unsigned short int)0;
    ip->sip = (unsigned int)0;
    ip->dip = 0xffffffff;
    bcopy((const void *)((struct ipovly *)ip)->ih_x1, (void *)b, (unsigned long int)9);
    bzero((void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
    ui->ui_i.ih_len = ui->ui_u.len;
    ui->ui_u.cksum=cksum((unsigned short int *)ui, (signed int)(sizeof(struct udpiphdr) /*28ul*/  + sizeof(struct dhcp4_packet) /*364ul*/ ));
    bcopy((const void *)b, (void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
    ip->cksum = (unsigned short int)0;
    ip->cksum=cksum((unsigned short int *)ip, (signed int)sizeof(struct iphdr) /*20ul*/ );
    encap_ehead(m->data, pc->ip4.mac, bcast, (const unsigned short int)0x0800);
    m->len = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct udpiphdr) /*28ul*/  + sizeof(struct dhcp4_packet) /*364ul*/ );
    return m;
  }
}

// dhcp4_release
// file dhcp.h line 86
struct packet * dhcp4_release(struct anonymous$0 *pc)
{
  struct ethdr *eh;
  struct iphdr *ip;
  struct udpiphdr *ui;
  struct dhcp4_packet *dh;
  signed int i;
  signed int k;
  struct packet *m;
  char b[9l];
  m=new_pkt(512);
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$12;
  signed int tmp_post$13;
  signed int tmp_post$15;
  signed int tmp_post$16;
  signed int tmp_post$17;
  signed int tmp_post$18;
  signed int tmp_post$19;
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    eh = (struct ethdr *)m->data;
    ip = (struct iphdr *)(eh + (signed long int)1);
    ui = (struct udpiphdr *)ip;
    dh = (struct dhcp4_packet *)(ui + (signed long int)1);
    dh->op = (char)1;
    dh->htype = (char)1;
    dh->hlen = (char)6;
    dh->hops = (char)0;
    dh->xid = pc->ip4.dhcp.xid;
    dh->secs = (unsigned short int)pc->ip4.dhcp.lease;
    dh->flags = (unsigned short int)0;
    dh->ciaddr = pc->ip4.dhcp.ip;
    dh->yiaddr = (unsigned int)0;
    dh->siaddr = (unsigned int)0;
    dh->giaddr = (unsigned int)0;
    memcpy((void *)dh->chaddr, (const void *)pc->ip4.mac, (unsigned long int)6);
    i = 0;
    unsigned int return_value_htonl$1;
    return_value_htonl$1=htonl((unsigned int)0x63825363);
    ((signed int *)&dh->options[(signed long int)i])[(signed long int)0] = (signed int)return_value_htonl$1;
    i = i + (signed int)sizeof(signed int) /*4ul*/ ;
    tmp_post$2 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$2] = (unsigned char)53;
    tmp_post$3 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$3] = (unsigned char)1;
    tmp_post$4 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$4] = (unsigned char)7;
    tmp_post$5 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$5] = (unsigned char)55;
    tmp_post$6 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$6] = (unsigned char)2;
    tmp_post$7 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$7] = (unsigned char)1;
    tmp_post$8 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$8] = (unsigned char)3;
    tmp_post$9 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$9] = (unsigned char)54;
    tmp_post$10 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$10] = (unsigned char)4;
    ((signed int *)&dh->options[(signed long int)i])[(signed long int)0] = (signed int)pc->ip4.dhcp.svr;
    i = i + (signed int)sizeof(signed int) /*4ul*/ ;
    tmp_post$11 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$11] = (unsigned char)50;
    tmp_post$12 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$12] = (unsigned char)4;
    ((signed int *)&dh->options[(signed long int)i])[(signed long int)0] = (signed int)pc->ip4.dhcp.ip;
    i = i + (signed int)sizeof(signed int) /*4ul*/ ;
    tmp_post$13 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$13] = (unsigned char)12;
    unsigned long int return_value_strlen$14;
    return_value_strlen$14=strlen(pc->xname);
    k = (signed int)return_value_strlen$14;
    tmp_post$15 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$15] = (unsigned char)(k + 1);
    strncpy((char *)(dh->options + (signed long int)i), pc->xname, (unsigned long int)k);
    i = i + k;
    tmp_post$16 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$16] = (unsigned char)(pc->id + 49);
    tmp_post$17 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$17] = (unsigned char)61;
    tmp_post$18 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$18] = (unsigned char)7;
    tmp_post$19 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$19] = (unsigned char)1;
    memcpy((void *)&dh->options[(signed long int)i], (const void *)pc->ip4.mac, (unsigned long int)6);
    i = i + 6;
    dh->options[(signed long int)i] = (unsigned char)255;
    ui->ui_u.sport=htons((unsigned short int)68);
    ui->ui_u.dport=htons((unsigned short int)67);
    ui->ui_u.len=htons((unsigned short int)(sizeof(struct dhcp4_packet) /*364ul*/  + sizeof(struct anonymous$24) /*8ul*/ ));
    ui->ui_u.cksum = (unsigned short int)0;
    ip->ver = (unsigned int)4;
    ip->ihl = (unsigned int)(sizeof(struct iphdr) /*20ul*/  >> 2);
    ip->tos = (unsigned char)0x10;
    ip->len=htons((unsigned short int)(sizeof(struct udpiphdr) /*28ul*/  + sizeof(struct dhcp4_packet) /*364ul*/ ));
    ip->id = (unsigned short int)0;
    ip->ttl = (unsigned char)16;
    ip->proto = (unsigned char)17;
    ip->cksum = (unsigned short int)0;
    ip->sip = pc->ip4.dhcp.ip;
    ip->dip = pc->ip4.dhcp.svr;
    bcopy((const void *)((struct ipovly *)ip)->ih_x1, (void *)b, (unsigned long int)9);
    bzero((void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
    ui->ui_i.ih_len = ui->ui_u.len;
    ui->ui_u.cksum=cksum((unsigned short int *)ui, (signed int)(sizeof(struct udpiphdr) /*28ul*/  + sizeof(struct dhcp4_packet) /*364ul*/ ));
    bcopy((const void *)b, (void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
    ip->cksum = (unsigned short int)0;
    ip->cksum=cksum((unsigned short int *)ip, (signed int)sizeof(struct iphdr) /*20ul*/ );
    encap_ehead(m->data, pc->ip4.mac, pc->ip4.dhcp.smac, (const unsigned short int)0x0800);
    m->len = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct udpiphdr) /*28ul*/  + sizeof(struct dhcp4_packet) /*364ul*/ );
    return m;
  }
}

// dhcp4_request
// file dhcp.h line 84
struct packet * dhcp4_request(struct anonymous$0 *pc)
{
  struct ethdr *eh;
  struct iphdr *ip;
  struct udpiphdr *ui;
  struct dhcp4_packet *dh;
  signed int i;
  signed int k;
  struct packet *m;
  char b[9l];
  m=new_pkt(512);
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$12;
  signed int tmp_post$14;
  signed int tmp_post$15;
  signed int tmp_post$16;
  signed int tmp_post$17;
  signed int tmp_post$18;
  signed int tmp_post$19;
  signed int tmp_post$20;
  signed int tmp_post$21;
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    eh = (struct ethdr *)m->data;
    ip = (struct iphdr *)(eh + (signed long int)1);
    ui = (struct udpiphdr *)ip;
    dh = (struct dhcp4_packet *)(ui + (signed long int)1);
    dh->op = (char)1;
    dh->htype = (char)1;
    dh->hlen = (char)6;
    dh->hops = (char)0;
    dh->xid = pc->ip4.dhcp.xid;
    dh->secs = (unsigned short int)0;
    dh->flags = (unsigned short int)0;
    dh->ciaddr = pc->ip4.dhcp.ip;
    dh->yiaddr = (unsigned int)0;
    dh->siaddr = (unsigned int)0;
    dh->giaddr = (unsigned int)0;
    memcpy((void *)dh->chaddr, (const void *)pc->ip4.mac, (unsigned long int)6);
    i = 0;
    unsigned int return_value_htonl$1;
    return_value_htonl$1=htonl((unsigned int)0x63825363);
    ((signed int *)&dh->options[(signed long int)i])[(signed long int)0] = (signed int)return_value_htonl$1;
    i = i + (signed int)sizeof(signed int) /*4ul*/ ;
    tmp_post$2 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$2] = (unsigned char)53;
    tmp_post$3 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$3] = (unsigned char)1;
    tmp_post$4 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$4] = (unsigned char)3;
    tmp_post$5 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$5] = (unsigned char)54;
    tmp_post$6 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$6] = (unsigned char)4;
    ((signed int *)&dh->options[(signed long int)i])[(signed long int)0] = (signed int)pc->ip4.dhcp.svr;
    i = i + (signed int)sizeof(signed int) /*4ul*/ ;
    tmp_post$7 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$7] = (unsigned char)50;
    tmp_post$8 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$8] = (unsigned char)4;
    ((signed int *)&dh->options[(signed long int)i])[(signed long int)0] = (signed int)pc->ip4.dhcp.ip;
    i = i + (signed int)sizeof(signed int) /*4ul*/ ;
    tmp_post$9 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$9] = (unsigned char)61;
    tmp_post$10 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$10] = (unsigned char)7;
    tmp_post$11 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$11] = (unsigned char)1;
    memcpy((void *)&dh->options[(signed long int)i], (const void *)pc->ip4.mac, (unsigned long int)6);
    i = i + 6;
    tmp_post$12 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$12] = (unsigned char)12;
    unsigned long int return_value_strlen$13;
    return_value_strlen$13=strlen(pc->xname);
    k = (signed int)return_value_strlen$13;
    tmp_post$14 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$14] = (unsigned char)(k + 1);
    strncpy((char *)(dh->options + (signed long int)i), pc->xname, (unsigned long int)k);
    i = i + k;
    tmp_post$15 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$15] = (unsigned char)(pc->id + 49);
    tmp_post$16 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$16] = (unsigned char)55;
    tmp_post$17 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$17] = (unsigned char)4;
    tmp_post$18 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$18] = (unsigned char)1;
    tmp_post$19 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$19] = (unsigned char)3;
    tmp_post$20 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$20] = (unsigned char)6;
    tmp_post$21 = i;
    i = i + 1;
    dh->options[(signed long int)tmp_post$21] = (unsigned char)15;
    dh->options[(signed long int)i] = (unsigned char)255;
    ui->ui_u.sport=htons((unsigned short int)68);
    ui->ui_u.dport=htons((unsigned short int)67);
    ui->ui_u.len=htons((unsigned short int)(sizeof(struct dhcp4_packet) /*364ul*/  + sizeof(struct anonymous$24) /*8ul*/ ));
    ui->ui_u.cksum = (unsigned short int)0;
    ip->ver = (unsigned int)4;
    ip->ihl = (unsigned int)(sizeof(struct iphdr) /*20ul*/  >> 2);
    ip->tos = (unsigned char)0x10;
    ip->len=htons((unsigned short int)(sizeof(struct udpiphdr) /*28ul*/  + sizeof(struct dhcp4_packet) /*364ul*/ ));
    ip->id = (unsigned short int)0;
    ip->ttl = (unsigned char)16;
    ip->proto = (unsigned char)17;
    ip->cksum = (unsigned short int)0;
    ip->sip = (unsigned int)0;
    ip->dip = 0xffffffff;
    bcopy((const void *)((struct ipovly *)ip)->ih_x1, (void *)b, (unsigned long int)9);
    bzero((void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
    ui->ui_i.ih_len = ui->ui_u.len;
    ui->ui_u.cksum=cksum((unsigned short int *)ui, (signed int)(sizeof(struct udpiphdr) /*28ul*/  + sizeof(struct dhcp4_packet) /*364ul*/ ));
    bcopy((const void *)b, (void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
    ip->cksum = (unsigned short int)0;
    ip->cksum=cksum((unsigned short int *)ip, (signed int)sizeof(struct iphdr) /*20ul*/ );
    encap_ehead(m->data, pc->ip4.mac, pc->ip4.dhcp.smac, (const unsigned short int)0x0800);
    m->len = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct udpiphdr) /*28ul*/  + sizeof(struct dhcp4_packet) /*364ul*/ );
    return m;
  }
}

// digitstring
// file utils.h line 38
signed int digitstring(const char *s)
{
  signed int i = 0;
  if(s == ((const char *)NULL))
    return 0;

  else
  {
    while((signed int)*s >= 48)
    {
      if((signed int)*s >= 58)
        break;

      s = s + 1l;
      i = i + 1;
      if((signed int)*s == 0)
        return i;

    }
    return 0;
  }
}

// dmp_arp
// file dump.c line 121
static void dmp_arp(void *dat)
{
  struct arphdr *ah = (struct arphdr *)dat;
  struct in_addr in;
  unsigned char broadcast[6l] = { (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff };
  unsigned int *si;
  unsigned int *di;
  unsigned short int return_value_ntohs$1;
  return_value_ntohs$1=ntohs(ah->op);
  unsigned short int return_value_ntohs$2;
  return_value_ntohs$2=ntohs(ah->op);
  printf("ARP, OpCode: %d (%s)", return_value_ntohs$1, (signed int)return_value_ntohs$2 == 1 ? "Request" : "Reply");
  si = (unsigned int *)ah->sip;
  di = (unsigned int *)ah->dip;
  if(*si == *di)
  {
    if(!(*di == 0u))
      printf("    Gratuitous ARP");

  }

  printf("\nEther Address: ");
  printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", ah->sea[(signed long int)0], ah->sea[(signed long int)1], ah->sea[(signed long int)2], ah->sea[(signed long int)3], ah->sea[(signed long int)4], ah->sea[(signed long int)5]);
  printf(" -> ");
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)ah->dea, (const void *)broadcast, (unsigned long int)6);
  if(return_value_memcmp$3 == 0)
    printf("Broadcast");

  else
    printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", ah->dea[(signed long int)0], ah->dea[(signed long int)1], ah->dea[(signed long int)2], ah->dea[(signed long int)3], ah->dea[(signed long int)4], ah->dea[(signed long int)5]);
  printf("\n");
  unsigned short int return_value_ntohs$8;
  return_value_ntohs$8=ntohs(ah->op);
  unsigned short int return_value_ntohs$7;
  if((signed int)return_value_ntohs$8 == 1)
  {
    in.s_addr = di[(signed long int)0];
    char *return_value_inet_ntoa$4;
    return_value_inet_ntoa$4=inet_ntoa(in);
    printf("Who has %s? Tell ", return_value_inet_ntoa$4);
    in.s_addr = si[(signed long int)0];
    char *return_value_inet_ntoa$5;
    return_value_inet_ntoa$5=inet_ntoa(in);
    printf("%s", return_value_inet_ntoa$5);
  }

  else
  {
    return_value_ntohs$7=ntohs(ah->op);
    if((signed int)return_value_ntohs$7 == 2)
    {
      in.s_addr = si[(signed long int)0];
      char *return_value_inet_ntoa$6;
      return_value_inet_ntoa$6=inet_ntoa(in);
      printf("%s is at ", return_value_inet_ntoa$6);
      printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", ah->sea[(signed long int)0], ah->sea[(signed long int)1], ah->sea[(signed long int)2], ah->sea[(signed long int)3], ah->sea[(signed long int)4], ah->sea[(signed long int)5]);
    }

  }
  printf("\n");
}

// dmp_dhcp
// file dhcp.h line 90
signed int dmp_dhcp(struct anonymous$0 *pc, struct packet *m)
{
  struct ethdr *eh;
  struct iphdr *ip;
  struct udpiphdr *ui;
  struct dhcp4_packet *dh;
  signed int direct = 0;
  signed int i;
  signed int j;
  signed int k;
  struct in_addr in;
  unsigned char opcode;
  char *msg_type[8l] = { "Discover", "Offer", "Request", "Decline", "Ack", "Nak", "Release", "Inform" };
  eh = (struct ethdr *)m->data;
  ip = (struct iphdr *)(eh + (signed long int)1);
  _Bool tmp_if_expr$4;
  unsigned short int return_value_htons$3;
  _Bool tmp_if_expr$7;
  unsigned short int return_value_htons$6;
  char *return_value_inet_ntoa$12;
  char *return_value_inet_ntoa$13;
  unsigned int return_value_ntohl$14;
  unsigned int return_value_ntohl$15;
  unsigned int return_value_ntohl$16;
  char *return_value_inet_ntoa$17;
  char *return_value_inet_ntoa$19;
  if(!((signed int)ip->proto == 17))
    return 0;

  else
  {
    ui = (struct udpiphdr *)ip;
    dh = (struct dhcp4_packet *)(ui + (signed long int)1);
    signed int return_value_memcmp$1;
    return_value_memcmp$1=memcmp((const void *)eh->dst, (const void *)pc->ip4.mac, (unsigned long int)6);
    if(return_value_memcmp$1 == 0)
      direct = 1;

    if(direct == 0)
    {
      unsigned short int return_value_htons$2;
      return_value_htons$2=htons((unsigned short int)68);
      if(!(ui->ui_u.sport == return_value_htons$2))
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value_htons$3=htons((unsigned short int)67);
        tmp_if_expr$4 = ui->ui_u.dport != return_value_htons$3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
        return 0;

    }

    else
    {
      unsigned short int return_value_htons$5;
      return_value_htons$5=htons((unsigned short int)68);
      if(!(ui->ui_u.dport == return_value_htons$5))
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_htons$6=htons((unsigned short int)67);
        tmp_if_expr$7 = ui->ui_u.sport != return_value_htons$6 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
        return 0;

    }
    printf("Opcode: %d (%s)\n", dh->op, (signed int)dh->op == 1 ? "REQUEST" : "REPLY");
    in.s_addr = dh->ciaddr;
    char *return_value_inet_ntoa$8;
    return_value_inet_ntoa$8=inet_ntoa(in);
    printf("Client IP Address: %s\n", return_value_inet_ntoa$8);
    in.s_addr = dh->yiaddr;
    char *return_value_inet_ntoa$9;
    return_value_inet_ntoa$9=inet_ntoa(in);
    printf("Your IP Address: %s\n", return_value_inet_ntoa$9);
    in.s_addr = dh->siaddr;
    char *return_value_inet_ntoa$10;
    return_value_inet_ntoa$10=inet_ntoa(in);
    printf("Server IP Address: %s\n", return_value_inet_ntoa$10);
    in.s_addr = dh->giaddr;
    char *return_value_inet_ntoa$11;
    return_value_inet_ntoa$11=inet_ntoa(in);
    printf("Gateway IP Address: %s\n", return_value_inet_ntoa$11);
    printf("Client MAC Address: ");
    printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", dh->chaddr[(signed long int)0], dh->chaddr[(signed long int)1], dh->chaddr[(signed long int)2], dh->chaddr[(signed long int)3], dh->chaddr[(signed long int)4], dh->chaddr[(signed long int)5]);
    printf("\n");
    i = (signed int)sizeof(signed int) /*4ul*/ ;
    opcode = dh->options[(signed long int)i];
    for( ; !((signed int)opcode == 255) && !(i >= 128); opcode = dh->options[(signed long int)i])
      switch((signed int)opcode)
      {
        case 53:
        {
          printf("Option %d: Message Type = ", 53);
          k = (signed int)dh->options[(signed long int)(i + 1)];
          j = (signed int)dh->options[(signed long int)(i + 2)];
          if(j >= 1 && !(j >= 9))
            printf("%s\n", msg_type[(signed long int)(j - 1)]);

          else
            printf("Unknown\n");
          i = i + k + 2;
          break;
        }
        case 12:
        {
          printf("Option %d: Host Name = ", 12);
          k = (signed int)dh->options[(signed long int)(i + 1)];
          j = 0;
          for( ; !(j >= k); j = j + 1)
            printf("%c", dh->options[(signed long int)(i + 2 + j)]);
          printf("\n");
          i = i + k + 2;
          break;
        }
        case 61:
        {
          printf("Option %d: Client Identifier = ", 61);
          k = (signed int)dh->options[(signed long int)(i + 1)];
          if((signed int)dh->options[(signed long int)(2 + i)] == 1)
          {
            printf("Hardware Type=Ethernet MAC Address = ");
            printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", (&dh->options[(signed long int)(i + 3)])[(signed long int)0], (&dh->options[(signed long int)(i + 3)])[(signed long int)1], (&dh->options[(signed long int)(i + 3)])[(signed long int)2], (&dh->options[(signed long int)(i + 3)])[(signed long int)3], (&dh->options[(signed long int)(i + 3)])[(signed long int)4], (&dh->options[(signed long int)(i + 3)])[(signed long int)5]);
            printf("\n");
          }

          else
            printf("Unknow type ");
          i = i + k + 2;
          break;
        }
        case 54:
        {
          in.s_addr = (unsigned int)((signed int *)&dh->options[(signed long int)(i + 2)])[(signed long int)0];
          return_value_inet_ntoa$12=inet_ntoa(in);
          printf("Option %d: DHCP Server = %s\n", 54, return_value_inet_ntoa$12);
          i = i + 6;
          break;
        }
        case 50:
        {
          in.s_addr = (unsigned int)((signed int *)&dh->options[(signed long int)(i + 2)])[(signed long int)0];
          return_value_inet_ntoa$13=inet_ntoa(in);
          printf("Option %d: Requested IP Address = %s\n", 50, return_value_inet_ntoa$13);
          i = i + 6;
          break;
        }
        case 51:
        {
          j = ((signed int *)&dh->options[(signed long int)(i + 2)])[(signed long int)0];
          return_value_ntohl$14=ntohl((unsigned int)j);
          printf("Option %d: Lease Time = %d\n", 51, return_value_ntohl$14);
          i = i + 6;
          break;
        }
        case 58:
        {
          j = ((signed int *)&dh->options[(signed long int)(i + 2)])[(signed long int)0];
          return_value_ntohl$15=ntohl((unsigned int)j);
          printf("Option %d: Renewal Time = %d\n", 58, return_value_ntohl$15);
          i = i + 6;
          break;
        }
        case 59:
        {
          j = ((signed int *)&dh->options[(signed long int)(i + 2)])[(signed long int)0];
          return_value_ntohl$16=ntohl((unsigned int)j);
          printf("Option %d: Rebinding Time = %d\n", 59, return_value_ntohl$16);
          i = i + 6;
          break;
        }
        case 1:
        {
          printf("Option %d: Subnet Mask = %d.%d.%d.%d\n", 1, dh->options[(signed long int)(i + 2)], dh->options[(signed long int)(i + 3)], dh->options[(signed long int)(i + 4)], dh->options[(signed long int)(i + 5)]);
          i = i + 6;
          break;
        }
        case 3:
        {
          in.s_addr = (unsigned int)((signed int *)&dh->options[(signed long int)(i + 2)])[(signed long int)0];
          return_value_inet_ntoa$17=inet_ntoa(in);
          printf("Option %d: Router = %s\n", 3, return_value_inet_ntoa$17);
          i = i + 6;
          break;
        }
        case 6:
        {
          k = (signed int)dh->options[(signed long int)(i + 1)];
          printf("Option %d: DNS Server = ", 6);
          j = 0;
          while(k >= (1 + j) * 4)
          {
            in.s_addr = (unsigned int)((signed int *)&dh->options[(signed long int)(i + 2 + j * 4)])[(signed long int)0];
            char *return_value_inet_ntoa$18;
            return_value_inet_ntoa$18=inet_ntoa(in);
            printf("%s ", return_value_inet_ntoa$18);
            j = j + 1;
          }
          printf("\n");
          i = i + k + 2;
          break;
        }
        case 15:
        {
          printf("Option %d: Domain = ", 15);
          k = (signed int)dh->options[(signed long int)(i + 1)];
          j = 0;
          for( ; !(j >= k); j = j + 1)
            printf("%c", dh->options[(signed long int)(i + 2 + j)]);
          printf("\n");
          i = i + k + 2;
          break;
        }
        case 150:
        {
          in.s_addr = (unsigned int)((signed int *)&dh->options[(signed long int)(i + 2)])[(signed long int)0];
          return_value_inet_ntoa$19=inet_ntoa(in);
          printf("Option %d: TFTP Server Address = %s\n", 150, return_value_inet_ntoa$19);
          i = i + 5;
          break;
        }
        default:
        {
          k = (signed int)dh->options[(signed long int)(i + 1)];
          i = i + k + 2;
        }
      }
    printf("\n");
    return 0;
  }
}

// dmp_dns
// file dump.c line 284
static void dmp_dns(void *dat)
{
  struct iphdr *iph = (struct iphdr *)dat;
  struct anonymous$24 *uh = (struct anonymous$24 *)(iph + (signed long int)1);
  signed int iplen;
  char *p;
  char *q;
  struct anonymous *dh;
  unsigned short int *sp;
  char name[256l];
  signed int i;
  signed int j;
  signed int rlen;
  unsigned char c;
  unsigned short int ptr;
  unsigned short int type;
  unsigned short int classt;
  unsigned int ttl;
  struct in_addr in;
  const char *rcode[6l] = { "No error", "Format error", "Server failure", "Name error", "Not implement", "Refused" };
  const char *typestr[16l] = { "A", "NS", "MD", "MF", "CNAME", "SOA", "MB", "MG", "MR", "NULL", "WKS", "PTR", "HINFO", "MINFO", "MX", "TXT" };
  const char *classtr[4l] = { "IN", "CS", "CH", "HS" };
  /* dmp_dns::1::tag-u_dnsflags */
union u_dnsflags
{
  // flags
  unsigned short int flags;
  // dflags
  struct anonymous$1 dflags;
};

/* */
  ;
  union u_dnsflags u_dnsflags;
  struct anonymous$1 *dflags;
  unsigned short int return_value_ntohs$1;
  return_value_ntohs$1=ntohs(iph->len);
  iplen = (signed int)return_value_ntohs$1;
  dh = (struct anonymous *)(uh + (signed long int)1);
  printf("DNS: QueryID = %x", dh->id);
  unsigned short int return_value_ntohs$16;
  return_value_ntohs$16=ntohs(uh->dport);
  unsigned short int return_value_ntohs$15;
  if((signed int)return_value_ntohs$16 == 53)
  {
    printf(", QueryFlags = %x\n", dh->flags);
    p = (char *)(dh + (signed long int)1);
    j = 0;
    i = j;
    name[(signed long int)0] = (char)0;
    while(!((p + (signed long int)j) - (char *)iph >= (signed long int)iplen))
    {
      i = (signed int)p[(signed long int)j];
      strncat(name, (char *)(p + (signed long int)j + (signed long int)1), (unsigned long int)i);
      j = j + i + 1;
      if((signed int)p[(signed long int)j] == 0)
        break;

      strcat(name, ".");
    }
    printf("     Host: %s", (const void *)name);
    p = p + (signed long int)(j + 1);
    type = *((unsigned short int *)p);
    classt = ((unsigned short int *)p)[(signed long int)1];
    if((signed int)type == 0x0100)
      printf(", type = %s", typestr[(signed long int)0]);

    if((signed int)classt == 0x0100)
      printf(", class = IN");

    printf("\n");
  }

  else
  {
    return_value_ntohs$15=ntohs(uh->sport);
    if((signed int)return_value_ntohs$15 == 53)
    {
      printf(", RespFlags = %x, ", dh->flags);
      u_dnsflags.flags = dh->flags;
      dflags = &u_dnsflags.dflags;
      if(!((signed int)dflags->rc == 0))
      {
        if(!(dflags->rc == 0))
          printf("rc: %s", rcode[(signed long int)dflags->rc]);

        else
          printf("rc: %d", dflags->rc);
      }

      printf("\n");
      unsigned short int return_value_ntohs$2;
      return_value_ntohs$2=ntohs(dh->query);
      unsigned short int return_value_ntohs$3;
      return_value_ntohs$3=ntohs(dh->answer);
      unsigned short int return_value_ntohs$4;
      return_value_ntohs$4=ntohs(dh->author);
      unsigned short int return_value_ntohs$5;
      return_value_ntohs$5=ntohs(dh->addition);
      printf("     Query = %d, Answer = %d, Auth = %d, Add = %d\n", return_value_ntohs$2, return_value_ntohs$3, return_value_ntohs$4, return_value_ntohs$5);
      p = (char *)(dh + (signed long int)1);
      j=dmp_dns_rname(p, (char *)iph + (signed long int)iplen, name);
      printf("     QueryHost: %s", (const void *)name);
      p = p + (signed long int)(j + 1);
      type = *((unsigned short int *)p);
      classt = ((unsigned short int *)p)[(signed long int)1];
      if((signed int)type == 0x0100)
        printf(", type = %s", typestr[(signed long int)0]);

      if((signed int)classt == 0x0100)
        printf(", class = IN");

      printf("\n");
      p = p + (signed long int)4;
      while(!(p - (char *)iph >= (signed long int)iplen))
      {
        sp = (unsigned short int *)p;
        ptr=ntohs(*sp);
        if((0xc000 & (signed int)ptr) == 0xc000)
        {
          q = (char *)dh + (signed long int)((signed int)ptr & 0x3fff);
          dmp_dns_rname(q, (char *)iph + (signed long int)iplen, name);
          printf("     RR: name = %s\n", (const void *)name);
        }

        else
        {
          printf("     Only support compression scheme\n");
          goto __CPROVER_DUMP_L38;
        }
        sp = sp + 1l;
        p = p + (signed long int)2;
        type=ntohs(*sp);
        classt=ntohs(sp[(signed long int)1]);
        ttl=ntohl(*((unsigned int *)(sp + (signed long int)4)));
        if((signed int)type >= 17 || !((signed int)type >= 1))
          printf("         Invalid type (%d)", type);

        else
          printf("         type = %s", typestr[(signed long int)((signed int)type - 1)]);
        if((signed int)classt >= 5 || !((signed int)classt >= 1))
          printf(", Invalid class (%d)", classt);

        else
          printf(", class = %s", classtr[(signed long int)((signed int)classt - 1)]);
        printf(", TTL = %d", ttl);
        p = p + (signed long int)(2 + 2 + 4);
        sp = (unsigned short int *)p;
        unsigned short int return_value_ntohs$6;
        return_value_ntohs$6=ntohs(*sp);
        rlen = (signed int)return_value_ntohs$6;
        if(rlen == 4 && (signed int)type == 1)
        {
          in.s_addr = ((unsigned int *)(p + (signed long int)2))[(signed long int)0];
          char *return_value_inet_ntoa$7;
          return_value_inet_ntoa$7=inet_ntoa(in);
          printf(", addr = %s", return_value_inet_ntoa$7);
        }

        else
          if((signed int)type == 2)
          {
            j = 0;
            i = j;
            memset((void *)name, 0, sizeof(char [256l]) /*256ul*/ );
            q = p + (signed long int)2;
            c = (unsigned char)q[(signed long int)j];
            while(!(j >= rlen))
            {
              strncat(name, (char *)(q + (signed long int)j + (signed long int)1), (unsigned long int)c);
              j = j + i + 1;
              c = (unsigned char)q[(signed long int)j];
              if((signed int)q[(signed long int)j] == 0 || (signed int)c >= 65)
                break;

              strcat(name, ".");
            }
            printf("\n         ns = %s", (const void *)name);
          }

          else
            if((signed int)type == 5)
            {
              printf(", data length = %d\n", rlen);
              printf("         Cname: ");
              q = p + (signed long int)2;
              c = (unsigned char)*q;
              i = 0;
              for( ; (_Bool)1; i = i + 1)
              {
                q = q + 1l;
                j = 0;
                for( ; !(j >= (signed int)c); i = i + 1)
                {
                  printf("%c", q[(signed long int)j]);
                  j = j + 1;
                }
                q = q + (signed long int)c;
                c = (unsigned char)*q;
                if((signed int)c == 0 || (signed int)c >= 65)
                  break;

                printf(".");
              }
              if((signed int)c >= 65 && !(1 + i >= rlen))
              {
                sp = (unsigned short int *)q;
                unsigned short int return_value_ntohs$8;
                return_value_ntohs$8=ntohs(*sp);
                dmp_dns_rname((char *)dh + (signed long int)((signed int)return_value_ntohs$8 & 0x3fff), (char *)iph + (signed long int)iplen, name);
                printf(".%s", (const void *)name);
              }

            }

            else
              if((signed int)type == 6)
              {
                printf(", data length = %d\n", rlen);
                printf("         Name server: ");
                q = p + (signed long int)2;
                c = (unsigned char)*q;
                while((_Bool)1)
                {
                  q = q + 1l;
                  j = 0;
                  for( ; !(j >= (signed int)c); j = j + 1)
                    printf("%c", q[(signed long int)j]);
                  q = q + (signed long int)c;
                  c = (unsigned char)*q;
                  if((signed int)c >= 65)
                    break;

                  printf(".");
                }
                dmp_dns_rname((char *)dh + (signed long int)((signed int)ptr & 0x3fff), (char *)iph + (signed long int)iplen, name);
                printf(".%s\n", (const void *)name);
                sp = (unsigned short int *)q;
                printf("         Responsible Mailbox: ");
                q = q + (signed long int)2;
                c = (unsigned char)*q;
                while((_Bool)1)
                {
                  q = q + 1l;
                  j = 0;
                  for( ; !(j >= (signed int)c); j = j + 1)
                    printf("%c", q[(signed long int)j]);
                  q = q + (signed long int)c;
                  c = (unsigned char)*q;
                  if((signed int)c >= 65)
                    break;

                  printf(".");
                }
                unsigned short int return_value_ntohs$9;
                return_value_ntohs$9=ntohs(*sp);
                dmp_dns_rname((char *)dh + (signed long int)((signed int)return_value_ntohs$9 & 0x3fff), (char *)iph + (signed long int)iplen, name);
                printf(".%s\n", (const void *)name);
                q = q + (signed long int)2;
                unsigned int return_value_ntohl$10;
                return_value_ntohl$10=ntohl(((unsigned int *)q)[(signed long int)0]);
                printf("         Serial number: %x\n", return_value_ntohl$10);
                char *return_value_dmp_dns_timestr$11;
                return_value_dmp_dns_timestr$11=dmp_dns_timestr(((unsigned int *)q)[(signed long int)1]);
                printf("         Refresh interval: %s\n", return_value_dmp_dns_timestr$11);
                char *return_value_dmp_dns_timestr$12;
                return_value_dmp_dns_timestr$12=dmp_dns_timestr(((unsigned int *)q)[(signed long int)2]);
                printf("         Retry interval: %s\n", return_value_dmp_dns_timestr$12);
                char *return_value_dmp_dns_timestr$13;
                return_value_dmp_dns_timestr$13=dmp_dns_timestr(((unsigned int *)q)[(signed long int)3]);
                printf("         Expiration time: %s\n", return_value_dmp_dns_timestr$13);
                char *return_value_dmp_dns_timestr$14;
                return_value_dmp_dns_timestr$14=dmp_dns_timestr(((unsigned int *)q)[(signed long int)4]);
                printf("         Minimum TTL: %s", return_value_dmp_dns_timestr$14);
              }

        p = p + (signed long int)(2 + rlen);
        printf("\n");
      }
    }

  }

__CPROVER_DUMP_L38:
  ;
}

// dmp_dns_rname
// file dns.c line 335
signed int dmp_dns_rname(char *s, char *se, char *name)
{
  signed int i;
  unsigned char c;
  name[(signed long int)0] = (char)0;
  c = (unsigned char)*s;
  i = 0;
  while(!(s >= se))
  {
    strncat(name, (char *)(s + (signed long int)i + (signed long int)1), (unsigned long int)c);
    i = i + (signed int)c + 1;
    c = (unsigned char)s[(signed long int)i];
    if((signed int)s[(signed long int)i] == 0 || (signed int)c >= 65)
      break;

    strcat(name, ".");
  }
  return i;
}

// dmp_dns_timestr
// file dump.c line 507
static char * dmp_dns_timestr(unsigned int s)
{
  signed int off = 0;
  static char buf[64l];
  buf[(signed long int)0] = (char)0;
  s=ntohl(s);
  if(!(s / 86400u == 0u))
  {
    signed int return_value_snprintf$1;
    return_value_snprintf$1=snprintf(buf + (signed long int)off, sizeof(char [64l]) /*64ul*/ , "%d days", s / (unsigned int)(3600 * 24));
    off = off + return_value_snprintf$1;
    s = s - (s / (unsigned int)(3600 * 24)) * (unsigned int)(3600 * 24);
  }

  if(!(s / 3600u == 0u))
  {
    signed int return_value_snprintf$2;
    return_value_snprintf$2=snprintf(buf + (signed long int)off, sizeof(char [64l]) /*64ul*/ , "%d hours", s / (unsigned int)3600);
    off = off + return_value_snprintf$2;
    s = s - (s / (unsigned int)3600) * (unsigned int)3600;
  }

  if(!(s / 60u == 0u))
  {
    signed int return_value_snprintf$3;
    return_value_snprintf$3=snprintf(buf + (signed long int)off, sizeof(char [64l]) /*64ul*/ , "%d minutes", s / (unsigned int)60);
    off = off + return_value_snprintf$3;
    s = s - (s / (unsigned int)60) * (unsigned int)60;
  }

  if(!(s == 0u))
  {
    signed int return_value_snprintf$4;
    return_value_snprintf$4=snprintf(buf + (signed long int)off, sizeof(char [64l]) /*64ul*/ , "%d minutes", s / (unsigned int)60);
    off = off + return_value_snprintf$4;
  }

  return buf;
}

// dmp_ip
// file dump.c line 157
static void dmp_ip(void *dat)
{
  struct iphdr *iph = (struct iphdr *)dat;
  struct icmphdr *icmp = (struct icmphdr *)(iph + (signed long int)1);
  struct anonymous$24 *uh = (struct anonymous$24 *)(iph + (signed long int)1);
  struct tcphdr *th = (struct tcphdr *)(iph + (signed long int)1);
  unsigned char *data;
  struct in_addr in;
  unsigned short int return_value_ntohs$1;
  return_value_ntohs$1=ntohs(iph->id);
  unsigned short int return_value_ntohs$2;
  return_value_ntohs$2=ntohs(iph->len);
  unsigned short int return_value_ntohs$3;
  return_value_ntohs$3=ntohs(iph->cksum);
  printf("IPv%d, id: %x, length: %d, ttl: %d, sum: %4.4x", iph->ver, return_value_ntohs$1, return_value_ntohs$2, iph->ttl, return_value_ntohs$3);
  unsigned short int return_value_ntohs$4;
  return_value_ntohs$4=ntohs(iph->frag);
  if((signed int)return_value_ntohs$4 == 0x4000)
    printf(", DF");

  unsigned short int return_value_ntohs$5;
  return_value_ntohs$5=ntohs(iph->frag);
  if((signed int)return_value_ntohs$5 == 0x2000)
    printf(", MF");

  in.s_addr = iph->sip;
  char *return_value_inet_ntoa$6;
  return_value_inet_ntoa$6=inet_ntoa(in);
  printf("\nAddress: %s -> ", return_value_inet_ntoa$6);
  in.s_addr = iph->dip;
  char *return_value_inet_ntoa$7;
  return_value_inet_ntoa$7=inet_ntoa(in);
  printf("%s\n", return_value_inet_ntoa$7);
  _Bool tmp_if_expr$15;
  unsigned short int return_value_ntohs$14;
  unsigned short int return_value_ntohs$16;
  if((signed int)iph->proto == 1)
  {
    printf("Proto: icmp, ");
    printf("type: %d, ", icmp->type);
    printf("code: %d\n", icmp->code);
    const char *return_value_icmpTypeCode2String$8;
    return_value_icmpTypeCode2String$8=icmpTypeCode2String((signed int)iph->ver, icmp->type, icmp->code);
    printf("Desc: %s\n", return_value_icmpTypeCode2String$8);
  }

  else
    if((signed int)iph->proto == 17)
    {
      unsigned short int return_value_ntohs$9;
      return_value_ntohs$9=ntohs(uh->len);
      unsigned short int return_value_ntohs$10;
      return_value_ntohs$10=ntohs(uh->cksum);
      printf("Proto: udp, len: %d, sum: %4.4x\n", return_value_ntohs$9, return_value_ntohs$10);
      unsigned short int return_value_ntohs$11;
      return_value_ntohs$11=ntohs(uh->sport);
      unsigned short int return_value_ntohs$12;
      return_value_ntohs$12=ntohs(uh->dport);
      printf("Port: %d -> %d\n", return_value_ntohs$11, return_value_ntohs$12);
      unsigned short int return_value_ntohs$13;
      return_value_ntohs$13=ntohs(uh->sport);
      if((signed int)return_value_ntohs$13 == 53)
        tmp_if_expr$15 = (_Bool)1;

      else
      {
        return_value_ntohs$14=ntohs(uh->dport);
        tmp_if_expr$15 = (signed int)return_value_ntohs$14 == 53 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$15)
      {
        dmp_dns(dat);
        goto __CPROVER_DUMP_L18;
      }

      unsigned short int return_value_ntohs$17;
      return_value_ntohs$17=ntohs(uh->sport);
      unsigned short int return_value_ntohs$18;
      return_value_ntohs$18=ntohs(uh->dport);
      if(return_value_ntohs$17 == return_value_ntohs$18)
      {
        return_value_ntohs$16=ntohs(uh->sport);
        if((signed int)return_value_ntohs$16 == 520)
        {
          if(iph->dip == 150995168u)
          {
            data = (unsigned char *)(uh + (signed long int)1);
            printf("Desc: RIP%d %s message\n", data[(signed long int)1], (signed int)*data == 1 ? "request" : "response");
          }

        }

      }

    }

    else
      if((signed int)iph->proto == 6)
      {
        unsigned short int return_value_ntohs$19;
        return_value_ntohs$19=ntohs(th->th_sum);
        unsigned int return_value_ntohl$20;
        return_value_ntohl$20=ntohl(th->th_ack);
        unsigned int return_value_ntohl$21;
        return_value_ntohl$21=ntohl(th->th_seq);
        printf("Proto: tcp, sum: %4.4x, ack: %8.8x, seq: %8.8x, ", return_value_ntohs$19, return_value_ntohl$20, return_value_ntohl$21);
        printf("flags: ");
        if(!((0x01 & (signed int)th->th_flags) == 0))
          printf("F");

        if(!((0x02 & (signed int)th->th_flags) == 0))
          printf("S");

        if(!((0x04 & (signed int)th->th_flags) == 0))
          printf("R");

        if(!((0x08 & (signed int)th->th_flags) == 0))
          printf("P");

        if(!((0x10 & (signed int)th->th_flags) == 0))
          printf("A");

        if(!((0x20 & (signed int)th->th_flags) == 0))
          printf("U");

        if(!((0x40 & (signed int)th->th_flags) == 0))
          printf("E");

        if(!((0x80 & (signed int)th->th_flags) == 0))
          printf("C");

        printf("\n");
        unsigned short int return_value_ntohs$22;
        return_value_ntohs$22=ntohs(th->th_sport);
        unsigned short int return_value_ntohs$23;
        return_value_ntohs$23=ntohs(th->th_dport);
        printf("Port: %d -> %d\n", return_value_ntohs$22, return_value_ntohs$23);
      }


__CPROVER_DUMP_L18:
  ;
}

// dmp_ip6
// file dump.c line 224
static void dmp_ip6(void *dat)
{
  struct anonymous$18 *iph = (struct anonymous$18 *)dat;
  struct anonymous$20 *icmp = (struct anonymous$20 *)(iph + (signed long int)1);
  struct anonymous$24 *uh = (struct anonymous$24 *)(iph + (signed long int)1);
  struct tcphdr *th = (struct tcphdr *)(iph + (signed long int)1);
  unsigned char *data;
  char *p;
  unsigned int return_value_ntohl$1;
  return_value_ntohl$1=ntohl(iph->ip6_ctlun.ip6_un1.ip6_un1_flow & 0xffff0f00);
  unsigned short int return_value_ntohs$2;
  return_value_ntohs$2=ntohs(iph->ip6_ctlun.ip6_un1.ip6_un1_plen);
  printf("IPv6, flowid: %x, length: %d, ttl: %d\n", return_value_ntohl$1, return_value_ntohs$2, iph->ip6_ctlun.ip6_un1.ip6_un1_hlim);
  p=ip6tostr(iph->src.uaddr._a8);
  printf("Address: %s -> ", p);
  p=ip6tostr(iph->dst.uaddr._a8);
  printf("%s\n", p);
  unsigned short int return_value_ntohs$8;
  if((signed int)iph->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58)
  {
    printf("Proto: icmp, ");
    printf("type: %d, ", icmp->type);
    printf("code: %d\n", icmp->code);
    const char *return_value_icmpTypeCode2String$3;
    return_value_icmpTypeCode2String$3=icmpTypeCode2String(6, icmp->type, icmp->code);
    printf("Desc: %s\n", return_value_icmpTypeCode2String$3);
  }

  else
    if((signed int)iph->ip6_ctlun.ip6_un1.ip6_un1_nxt == 17)
    {
      unsigned short int return_value_ntohs$4;
      return_value_ntohs$4=ntohs(uh->len);
      unsigned short int return_value_ntohs$5;
      return_value_ntohs$5=ntohs(uh->cksum);
      printf("Proto: udp, len: %d, sum: %4.4x\n", return_value_ntohs$4, return_value_ntohs$5);
      unsigned short int return_value_ntohs$6;
      return_value_ntohs$6=ntohs(uh->sport);
      unsigned short int return_value_ntohs$7;
      return_value_ntohs$7=ntohs(uh->dport);
      printf("Port: %d -> %d\n", return_value_ntohs$6, return_value_ntohs$7);
      unsigned short int return_value_ntohs$9;
      return_value_ntohs$9=ntohs(uh->sport);
      unsigned short int return_value_ntohs$10;
      return_value_ntohs$10=ntohs(uh->dport);
      if(return_value_ntohs$9 == return_value_ntohs$10)
      {
        return_value_ntohs$8=ntohs(uh->sport);
        if((signed int)return_value_ntohs$8 == 521)
        {
          if(iph->dst.uaddr._a32[0l] == 767u)
          {
            if(iph->dst.uaddr._a32[1l] == 0u)
            {
              if(iph->dst.uaddr._a32[2l] == 0u)
              {
                if(iph->dst.uaddr._a32[3l] == 150994944u)
                {
                  data = (unsigned char *)(uh + (signed long int)1);
                  printf("Desc: RIP%d %s message\n", data[(signed long int)1], (signed int)*data == 1 ? "request" : "response");
                }

              }

            }

          }

        }

      }

    }

    else
      if((signed int)iph->ip6_ctlun.ip6_un1.ip6_un1_nxt == 6)
      {
        unsigned short int return_value_ntohs$11;
        return_value_ntohs$11=ntohs(th->th_sum);
        unsigned int return_value_ntohl$12;
        return_value_ntohl$12=ntohl(th->th_ack);
        unsigned int return_value_ntohl$13;
        return_value_ntohl$13=ntohl(th->th_seq);
        printf("Proto: tcp, sum: %4.4x, ack: %8.8x, seq: %8.8x, ", return_value_ntohs$11, return_value_ntohl$12, return_value_ntohl$13);
        printf("flags: ");
        if(!((0x01 & (signed int)th->th_flags) == 0))
          printf("F");

        if(!((0x02 & (signed int)th->th_flags) == 0))
          printf("S");

        if(!((0x04 & (signed int)th->th_flags) == 0))
          printf("R");

        if(!((0x08 & (signed int)th->th_flags) == 0))
          printf("P");

        if(!((0x10 & (signed int)th->th_flags) == 0))
          printf("A");

        if(!((0x20 & (signed int)th->th_flags) == 0))
          printf("U");

        if(!((0x40 & (signed int)th->th_flags) == 0))
          printf("E");

        if(!((0x80 & (signed int)th->th_flags) == 0))
          printf("C");

        printf("\n");
        unsigned short int return_value_ntohs$14;
        return_value_ntohs$14=ntohs(th->th_sport);
        unsigned short int return_value_ntohs$15;
        return_value_ntohs$15=ntohs(th->th_dport);
        printf("Port: %d -> %d\n", return_value_ntohs$14, return_value_ntohs$15);
      }

}

// dmp_packet
// file dump.h line 32
signed int dmp_packet(struct packet *m, const signed int flag)
{
  signed int i;
  signed int j;
  signed int pos0;
  signed int pos1;
  char x0[96l];
  char x1[17l];
  unsigned char *p = (unsigned char *)m->data;
  signed int len = m->len;
  signed int left;
  struct ethdr *eh = (struct ethdr *)m->data;
  signed int cr = 0;
  signed int return_value_sprintf$2;
  signed int return_value_sprintf$3;
  signed int return_value_sprintf$6;
  signed int return_value_sprintf$7;
  signed int return_value_sprintf$9;
  unsigned short int return_value_htons$11;
  unsigned short int return_value_htons$10;
  if(flag == 0)
    return flag;

  else
  {
    if(!((1 & flag) == 0))
    {
      printf("\n");
      printf("\033[33m");
      cr = 1;
      printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", (p + (signed long int)6)[(signed long int)0], (p + (signed long int)6)[(signed long int)1], (p + (signed long int)6)[(signed long int)2], (p + (signed long int)6)[(signed long int)3], (p + (signed long int)6)[(signed long int)4], (p + (signed long int)6)[(signed long int)5]);
      printf(" -> ");
      printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", p[(signed long int)0], p[(signed long int)1], p[(signed long int)2], p[(signed long int)3], p[(signed long int)4], p[(signed long int)5]);
      printf("\n");
    }

    len = len - 14;
    p = p + (signed long int)14;
    if(!((2 & flag) == 0))
    {
      i = 0;
      if(cr == 0)
      {
        printf("\n");
        printf("\033[33m");
        cr = 1;
      }

      for( ; !(i >= len); i = i + (j - i))
      {
        pos1 = 0;
        pos0 = pos1;
        left = 40;
        j = i;
        for( ; !(j >= 16 + i) && !(j >= len); j = j + 2)
        {
          signed int return_value_sprintf$1;
          return_value_sprintf$1=sprintf(x0 + (signed long int)pos0, "%2.2x", p[(signed long int)j]);
          pos0 = pos0 + return_value_sprintf$1;
          left = left - 2;
          const unsigned short int **return_value___ctype_b_loc$4;
          return_value___ctype_b_loc$4=__ctype_b_loc();
          if(!((16384 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)p[(signed long int)j]]) == 0))
          {
            return_value_sprintf$2=sprintf(x1 + (signed long int)pos1, "%c", p[(signed long int)j]);
            pos1 = pos1 + return_value_sprintf$2;
          }

          else
          {
            return_value_sprintf$3=sprintf(x1 + (signed long int)pos1, ".");
            pos1 = pos1 + return_value_sprintf$3;
          }
          signed int return_value_sprintf$5;
          return_value_sprintf$5=sprintf(x0 + (signed long int)pos0, "%2.2x ", (p + (signed long int)j)[(signed long int)1]);
          pos0 = pos0 + return_value_sprintf$5;
          left = left - 3;
          const unsigned short int **return_value___ctype_b_loc$8;
          return_value___ctype_b_loc$8=__ctype_b_loc();
          if(!((16384 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)p[(signed long int)j + 1l]]) == 0))
          {
            return_value_sprintf$6=sprintf(x1 + (signed long int)pos1, "%c", (p + (signed long int)j)[(signed long int)1]);
            pos1 = pos1 + return_value_sprintf$6;
          }

          else
          {
            return_value_sprintf$7=sprintf(x1 + (signed long int)pos1, ".");
            pos1 = pos1 + return_value_sprintf$7;
          }
        }
        pos1 = 0;
        for( ; !(pos1 >= left); pos1 = pos1 + 1)
        {
          return_value_sprintf$9=sprintf(x0 + (signed long int)pos0, " ");
          pos0 = pos0 + return_value_sprintf$9;
        }
        printf("%s   %s\n", (const void *)x0, (const void *)x1);
      }
      printf("\n");
    }

    if(!((4 & flag) == 0))
    {
      if(cr == 0)
      {
        printf("\n");
        printf("\033[33m");
        cr = 1;
      }

      unsigned short int return_value_htons$12;
      return_value_htons$12=htons((unsigned short int)0x0800);
      if(eh->type == return_value_htons$12)
        dmp_ip((void *)(eh + (signed long int)1));

      else
      {
        return_value_htons$11=htons((unsigned short int)0x86DD);
        if(eh->type == return_value_htons$11)
          dmp_ip6((void *)(eh + (signed long int)1));

        else
        {
          return_value_htons$10=htons((unsigned short int)0x0806);
          if(eh->type == return_value_htons$10)
            dmp_arp((void *)(eh + (signed long int)1));

        }
      }
    }

    if(!(cr == 0))
      printf("\033[0m");

    return 1;
  }
}

// dnsparse
// file dns.c line 213
static signed int dnsparse(struct packet *m, unsigned short int magicid, char *data, signed int dlen, unsigned int *cip)
{
  struct ethdr *eh;
  struct iphdr *ip;
  struct udpiphdr *ui;
  unsigned char *p;
  struct anonymous *dh;
  unsigned short int *sp;
  signed int rlen;
  signed int iplen;
  signed int i;
  signed int j;
  unsigned char c;
  const char *rcode[6l] = { "No error", "Format error", "Server failure", "Name error", "Not implement", "Refused" };
  eh = (struct ethdr *)m->data;
  ip = (struct iphdr *)(eh + (signed long int)1);
  ui = (struct udpiphdr *)ip;
  unsigned short int return_value_ntohs$1;
  return_value_ntohs$1=ntohs(ip->len);
  iplen = (signed int)return_value_ntohs$1;
  dh = (struct anonymous *)(ui + (signed long int)1);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$9;
  signed int return_value_sprintf$4;
  if(!(dh->id == magicid))
    return 0;

  else
    if(!((0x8081 & (signed int)dh->flags) == 0x8081))
    {
      c = (unsigned char)((signed int)dh->flags >> 8 & 0xf);
      if((signed int)c == 0)
        return 0;

      printf("DNS server return: ");
      if(!((signed int)c >= 6))
        printf("%s\n", rcode[(signed long int)c]);

      else
        printf("error: %d\n", c);
      return 0;
    }

    else
    {
      if((signed int)dh->query == 0)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)dh->answer == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        return 0;

      else
      {
        p = (unsigned char *)(dh + (signed long int)1);
        c = (unsigned char)0;
        i = 0;
        data[(signed long int)0] = (char)0;
        while(!((p + (signed long int)c) - (unsigned char *)ip >= (signed long int)iplen))
        {
          i = (signed int)p[(signed long int)c];
          strncat(data, (char *)(p + (signed long int)c + (signed long int)1), (unsigned long int)i);
          c = c + (unsigned char)(i + 1);
          if((signed int)p[(signed long int)c] == 0)
            break;

          strcat(data, ".");
        }
        p = p + (signed long int)((signed int)c + 5);
        p = p + (signed long int)2;
        while(!(p - (unsigned char *)ip >= (signed long int)iplen))
        {
          sp = (unsigned short int *)p;
          if((signed int)*sp == 0x0100)
            tmp_if_expr$9 = (signed int)sp[(signed long int)1] == 0x0100 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$9 = (_Bool)0;
          if(tmp_if_expr$9)
          {
            p = p + (signed long int)(2 + 2 + 4);
            sp = (unsigned short int *)p;
            if((signed int)*sp == 0x0400)
            {
              *cip = ((unsigned int *)(p + (signed long int)2))[(signed long int)0];
              return 1;
            }

          }

          else
            if((signed int)*sp == 0x0500)
            {
              p = p + (signed long int)(2 + 2 + 4);
              unsigned short int return_value_ntohs$3;
              return_value_ntohs$3=ntohs(*((unsigned short int *)p));
              rlen = (signed int)return_value_ntohs$3;
              p = p + (signed long int)2;
              c = *p;
              i = 0;
              data[(signed long int)i] = (char)0;
              while((_Bool)1)
              {
                p = p + 1l;
                j = 0;
                for( ; !(j >= (signed int)c); j = j + 1)
                {
                  return_value_sprintf$4=sprintf(data + (signed long int)i, "%c", p[(signed long int)j]);
                  i = i + return_value_sprintf$4;
                }
                p = p + (signed long int)c;
                c = *p;
                if((signed int)c == 0 || (signed int)c >= 65)
                  break;

                signed int return_value_sprintf$5;
                return_value_sprintf$5=sprintf(data + (signed long int)i, ".");
                i = i + return_value_sprintf$5;
              }
              if((signed int)c >= 65)
              {
                sp = (unsigned short int *)p;
                signed int return_value_sprintf$6;
                return_value_sprintf$6=sprintf(data + (signed long int)i, ".");
                i = i + return_value_sprintf$6;
                unsigned short int return_value_ntohs$7;
                return_value_ntohs$7=ntohs(*sp);
                dmp_dns_rname((char *)dh + (signed long int)((signed int)return_value_ntohs$7 & 0x3fff), (char *)ip + (signed long int)iplen, data + (signed long int)i);
              }

              return 2;
            }

            else
            {
              p = p + (signed long int)(2 + 2 + 4);
              sp = (unsigned short int *)p;
              unsigned short int return_value_ntohs$8;
              return_value_ntohs$8=ntohs(*sp);
              rlen = (signed int)return_value_ntohs$8;
              p = p + (signed long int)(rlen + 2);
              p = p + (signed long int)2;
            }
        }
        return 0;
      }
    }
}

// dnsrequest
// file dns.c line 176
static signed int dnsrequest(unsigned short int id, const char *name, char *data, signed int *namelen)
{
  unsigned char buf[256l];
  struct anonymous dh;
  signed int dlen = (signed int)sizeof(struct anonymous) /*12ul*/ ;
  signed int i;
  memset((void *)&dh, 0, sizeof(struct anonymous) /*12ul*/ );
  dh.id = id;
  dh.flags = (unsigned short int)0x0001;
  dh.query=htons((unsigned short int)0x0001);
  memcpy((void *)data, (void *)&dh, sizeof(struct anonymous) /*12ul*/ );
  memset((void *)buf, 0, sizeof(unsigned char [256l]) /*256ul*/ );
  i=fmtstring(name, (char *)buf);
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  if(i == 0)
    return 0;

  else
  {
    *namelen = i;
    memcpy((void *)(data + (signed long int)dlen), (const void *)buf, (unsigned long int)i);
    dlen = dlen + i;
    tmp_post$1 = dlen;
    dlen = dlen + 1;
    data[(signed long int)tmp_post$1] = (char)0x00;
    tmp_post$2 = dlen;
    dlen = dlen + 1;
    data[(signed long int)tmp_post$2] = (char)0x01;
    tmp_post$3 = dlen;
    dlen = dlen + 1;
    data[(signed long int)tmp_post$3] = (char)0x00;
    tmp_post$4 = dlen;
    dlen = dlen + 1;
    data[(signed long int)tmp_post$4] = (char)0x01;
    return dlen;
  }
}

// encap_ehead
// file ip.h line 450
void encap_ehead(char *mbuf, const unsigned char *sea, const unsigned char *dea, const unsigned short int type)
{
  struct ethdr *eh = (struct ethdr *)mbuf;
  memcpy((void *)eh->dst, (const void *)dea, (unsigned long int)6);
  memcpy((void *)eh->src, (const void *)sea, (unsigned long int)6);
  eh->type=htons(type);
}

// enq
// file queue.h line 63
struct packet * enq(struct pq *pq, struct packet *m)
{
  struct packet *q = (struct packet *)(void *)0;
  if(pq->size == 101)
  {
    printf("queue is full \n");
    return (struct packet *)(void *)0;
  }

  else
  {
    lock_q(pq);
    m->next = (struct packet *)(void *)0;
    gettimeofday(&m->ts, (struct timezone *)(void *)0);
    if(pq->q == ((struct packet *)NULL))
      pq->q = m;

    else
    {
      q = pq->q;
      for( ; !(q->next == ((struct packet *)NULL)); q = q->next)
        ;
      q->next = m;
    }
    pq->size = pq->size + 1;
    pthread_cond_signal(&pq->cond);
    ulock_q(pq);
    return q;
  }
}

// etherIsMulticast
// file ip.h line 458
signed int etherIsMulticast(unsigned char *mac)
{
  unsigned char broadcast[6l] = { (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff };
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)(const char *)mac, (const void *)(const char *)broadcast, (unsigned long int)6);
  return (signed int)!(return_value_memcmp$1 != 0);
}

// etherIsZero
// file ip.h line 457
signed int etherIsZero(unsigned char *mac)
{
  unsigned char zero[6l] = { (unsigned char)0x0, (unsigned char)0x0, (unsigned char)0x0, (unsigned char)0x0, (unsigned char)0x0, (unsigned char)0x0 };
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)(const char *)mac, (const void *)(const char *)zero, (unsigned long int)6);
  return (signed int)!(return_value_memcmp$1 != 0);
}

// findhistory
// file readline.c line 470
static signed int findhistory(struct rls *rls, signed int start)
{
  signed int len;
  signed int i;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(rls->history[(signed long int)rls->maxhistnum]);
  len = (signed int)return_value_strlen$1;
  signed int return_value_strncmp$2;
  signed int return_value_strncmp$3;
  if(len == 0)
  {
    if(start >= 0)
    {
      start = start + 1;
      return start < rls->hist_total ? start : -1;
    }

    else
    {
      start = 0 - start;
      start = start - 1;
      return start > -1 ? start : -1;
    }
  }

  else
    if(start >= 0)
    {
      start = start + 1;
      i = start;
      for( ; !(i >= rls->hist_total); i = i + 1)
      {
        return_value_strncmp$2=strncmp(rls->history[(signed long int)rls->maxhistnum], rls->history[(signed long int)i], (unsigned long int)len);
        if(return_value_strncmp$2 == 0)
          return i;

      }
      return -1;
    }

    else
    {
      start = 0 - start;
      start = start - 1;
      i = start;
      for( ; i >= 0; i = i - 1)
      {
        return_value_strncmp$3=strncmp(rls->history[(signed long int)rls->maxhistnum], rls->history[(signed long int)i], (unsigned long int)len);
        if(return_value_strncmp$3 == 0)
          return i;

      }
      return -1;
    }
}

// fmtstring
// file dns.c line 143
static signed int fmtstring(const char *name, char *buf)
{
  char *s;
  char *r;
  signed int len = 0;
  char c;
  _Bool tmp_if_expr$1;
  if(name == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)name[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  char *return_value_strstr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strstr$2=strstr(name, "..");
    tmp_if_expr$3 = return_value_strstr$2 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  char *return_value_strchr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_strchr$4=strchr(name, 46);
    tmp_if_expr$5 = !(return_value_strchr$4 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  unsigned long int return_value_strlen$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_strlen$6=strlen(name);
    tmp_if_expr$7 = return_value_strlen$6 > (unsigned long int)64 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
    return 0;

  else
  {
    memset((void *)buf, 0, (unsigned long int)64);
    strcpy(buf + (signed long int)1, name);
    s = buf + (signed long int)1;
    for( ; !((signed int)*s == 0); s = s + 1l)
      if((signed int)*s == 46)
        *s = (char)0;

    s = buf;
    r = buf + (signed long int)1;
    while(!(*r == 0))
    {
      unsigned long int return_value_strlen$8;
      return_value_strlen$8=strlen(r);
      c = (char)return_value_strlen$8;
      *s = c;
      len = len + (signed int)c + 1;
      s = r + (signed long int)c;
      r = s + (signed long int)1;
    }
    return len + 1;
  }
}

// getCIDR
// file ip.h line 465
signed int getCIDR(unsigned long int mask)
{
  signed int i = 0;
  for( ; !(i >= 33); i = i + 1)
    if(ip_masks[(signed long int)i] == mask)
      return i;

  return 0;
}

// getkv
// file utils.c line 36
char * getkv(char *str)
{
  static char *p;
  if(!(str == ((char *)NULL)))
  {
    static char buf[128l];
    memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    strncpy(buf, str, return_value_strlen$1);
    p=strtok(buf, " \t");
  }

  else
    p=strtok((char *)(void *)0, " \t");
  return p;
}

// getpath
// file hv.c line 756
static char * getpath(const char *name)
{
  char *pathenv = (char *)(void *)0;
  char *env;
  const char *d;
  signed int found;
  char rpath[4096l];
  char *return_value_strchr$2;
  return_value_strchr$2=strchr(name, 47);
  if(!(return_value_strchr$2 == ((char *)NULL)))
  {
    strcpy(rpath, name);
    signed int return_value_is_there$1;
    return_value_is_there$1=is_there(rpath);
    if(!(return_value_is_there$1 == 0))
    {
      found = 1;
      goto ret;
    }

    else
      return (char *)(void *)0;
  }

  char *return_value_getenv$3;
  return_value_getenv$3=getenv("PATH");
  if(return_value_getenv$3 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *return_value_getenv$4;
    return_value_getenv$4=getenv("PATH");
    pathenv=strdup(return_value_getenv$4);
    if(pathenv == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      found = 0;
      env = pathenv;
      do
      {
        d=strsep(&env, ":");
        if(d == ((const char *)NULL))
          break;

        if((signed int)*d == 0)
          d = ".";

        signed int return_value_snprintf$5;
        return_value_snprintf$5=snprintf(rpath, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", d, name);
        if(!(return_value_snprintf$5 >= (signed int)sizeof(char [4096l]) /*4096*/ ))
        {
          signed int return_value_is_there$6;
          return_value_is_there$6=is_there(rpath);
          if(!(return_value_is_there$6 == 0))
          {
            found = 1;
            break;
          }

        }

      }
      while((_Bool)1);
      free((void *)pathenv);

    ret:
      ;
      if(!(found == 0))
      {
        char *return_value_realpath$7;
        return_value_realpath$7=realpath(rpath, prgname);
        return return_value_realpath$7;
      }

      else
        return (char *)(void *)0;
    }
  }
}

// help_clear
// file help.h line 32
signed int help_clear(signed int argc, char **argv)
{
  printf("\n\033[1mclear [ip|ipv6|arp|neighbor|hist]\033[0m\n  Clear ip/ipv6 address, arp/neighbor table, command history\n");
  return 1;
}

// help_echo
// file help.c line 40
signed int help_echo(signed int argc, char **argv)
{
  return 1;
}

// help_help
// file help.h line 34
signed int help_help(signed int argc, char **argv)
{
  printf("\n\033[1m%s\033[0m, Print help. Use command \033[1m?\033[0m for more help\n", argv[(signed long int)0]);
  return 1;
}

// help_hist
// file help.c line 45
signed int help_hist(signed int argc, char **argv)
{
  return 1;
}

// help_ip
// file help.h line 36
signed int help_ip(signed int argc, char **argv)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(argv[(signed long int)0]);
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(argv[(signed long int)0], "dhcp", return_value_strlen$1);
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$3;
  signed int return_value_strncmp$4;
  _Bool tmp_if_expr$10;
  signed int return_value_strcmp$6;
  _Bool tmp_if_expr$9;
  unsigned long int return_value_strlen$7;
  signed int return_value_strncmp$8;
  if(return_value_strncmp$2 == 0)
    tmp_if_expr$11 = (_Bool)1;

  else
  {
    if(argc == 3)
    {
      return_value_strlen$3=strlen(argv[(signed long int)1]);
      return_value_strncmp$4=strncmp(argv[(signed long int)1], "dhcp", return_value_strlen$3);
      tmp_if_expr$5 = !(return_value_strncmp$4 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
    {
      return_value_strcmp$6=strcmp(argv[(signed long int)2], "?");
      if(return_value_strcmp$6 == 0)
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        return_value_strlen$7=strlen(argv[(signed long int)2]);
        return_value_strncmp$8=strncmp(argv[(signed long int)2], "help", return_value_strlen$7);
        tmp_if_expr$9 = !(return_value_strncmp$8 != 0) ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$10 = (_Bool)0;
    tmp_if_expr$11 = tmp_if_expr$10 ? (_Bool)1 : (_Bool)0;
  }
  unsigned long int return_value_strlen$16;
  signed int return_value_strncmp$17;
  signed int return_value_strcmp$12;
  _Bool tmp_if_expr$15;
  unsigned long int return_value_strlen$13;
  signed int return_value_strncmp$14;
  unsigned long int return_value_strlen$22;
  signed int return_value_strncmp$23;
  signed int return_value_strcmp$18;
  _Bool tmp_if_expr$21;
  unsigned long int return_value_strlen$19;
  signed int return_value_strncmp$20;
  unsigned long int return_value_strlen$28;
  signed int return_value_strncmp$29;
  signed int return_value_strcmp$24;
  _Bool tmp_if_expr$27;
  unsigned long int return_value_strlen$25;
  signed int return_value_strncmp$26;
  if(tmp_if_expr$11)
  {
    printf("\n\033[1mip dhcp [-options]\033[0m\n  Attempt to obtain IPv4 address, mask, gateway and DNS via DHCP\n  options:\n    -d         Show DHCP packet decode\n    -r         Renew DHCP lease\n    -x         Release DHCP lease\n");
    return 1;
  }

  else
    if(argc == 3)
    {
      return_value_strlen$16=strlen(argv[(signed long int)1]);
      return_value_strncmp$17=strncmp(argv[(signed long int)1], "mtu", return_value_strlen$16);
      if(!(return_value_strncmp$17 == 0))
        goto __CPROVER_DUMP_L12;

      return_value_strcmp$12=strcmp(argv[(signed long int)2], "?");
      if(return_value_strcmp$12 == 0)
        tmp_if_expr$15 = (_Bool)1;

      else
      {
        return_value_strlen$13=strlen(argv[(signed long int)2]);
        return_value_strncmp$14=strncmp(argv[(signed long int)2], "help", return_value_strlen$13);
        tmp_if_expr$15 = !(return_value_strncmp$14 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$15)
        goto __CPROVER_DUMP_L12;

      printf("\n\033[1mip mtu <value>\033[0m\n  Set IPv4 MTU to <value>, at least 576.\n");
      return 1;
    }

    else
    {

    __CPROVER_DUMP_L12:
      ;
      if(argc == 3)
      {
        return_value_strlen$22=strlen(argv[(signed long int)1]);
        return_value_strncmp$23=strncmp(argv[(signed long int)1], "dns", return_value_strlen$22);
        if(!(return_value_strncmp$23 == 0))
          goto __CPROVER_DUMP_L15;

        return_value_strcmp$18=strcmp(argv[(signed long int)2], "?");
        if(return_value_strcmp$18 == 0)
          tmp_if_expr$21 = (_Bool)1;

        else
        {
          return_value_strlen$19=strlen(argv[(signed long int)2]);
          return_value_strncmp$20=strncmp(argv[(signed long int)2], "help", return_value_strlen$19);
          tmp_if_expr$21 = !(return_value_strncmp$20 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$21)
          goto __CPROVER_DUMP_L15;

        printf("\n\033[1mip dns <ip>\033[0m\n  Set DNS server <ip>, delete if <ip> is '0'\n");
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L15:
        ;
        if(argc == 3)
        {
          return_value_strlen$28=strlen(argv[(signed long int)1]);
          return_value_strncmp$29=strncmp(argv[(signed long int)1], "domain", return_value_strlen$28);
          if(!(return_value_strncmp$29 == 0))
            goto __CPROVER_DUMP_L18;

          return_value_strcmp$24=strcmp(argv[(signed long int)2], "?");
          if(return_value_strcmp$24 == 0)
            tmp_if_expr$27 = (_Bool)1;

          else
          {
            return_value_strlen$25=strlen(argv[(signed long int)2]);
            return_value_strncmp$26=strncmp(argv[(signed long int)2], "help", return_value_strlen$25);
            tmp_if_expr$27 = !(return_value_strncmp$26 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$27)
            goto __CPROVER_DUMP_L18;

          printf("\n\033[1mip domain <name>\033[0m\n  Sets local domain name. \n  If there's no '.' in the host name: the name is assumed within the local domain, \n  it is a short name relative to the local domain. The resolver will append the local\n  domain name to the hostname to resolve it\n");
          return 1;
        }

        else
        {

        __CPROVER_DUMP_L18:
          ;
          printf("\n\033[1mip [arguments]\033[0m\n  Configure the current VPC's IP settings\n  arguments:\n    <address> [/<mask>] [<gateway>]\n    <address> [<gateway>] [/<mask>]\n                   Set the VPC's ip, default gateway ip and network mask\n                   Default IPv4 mask is /24, IPv6 is /64. In the ether mode, \n                   the ip of the tapx is the maximum host ID of the subnet. \n                   \033[1mip 10.1.1.70 /26 10.1.1.65\033[0m set the VPC's ip to 10.1.1.70, \n                   the gateway to 10.1.1.65, the netmask to 255.255.255.192, \n                   the tapx ip to 10.1.1.126 in the ether mode.\n                   </mask> may be written as /26, 26 or 255.255.255.192\n    auto           Attempt to obtain IPv6 address, mask and gateway using SLAAC\n    dhcp -[d|r|x]  Attempt to obtain IPv4 address, mask, gateway, DNS via DHCP\n          -d         Show DHCP packet decode\n          -r         Renew DHCP lease\n          -x         Release DHCP lease\n    dns <ip>       Set DNS server <ip>, delete if <ip> is '0'\n    domain <name>  set local domain name\n    mtu <value>    Set IPv4 MTU to <value>, at least 576. \n");
          return 1;
        }
      }
    }
}

// help_load
// file help.h line 37
signed int help_load(signed int argc, char **argv)
{
  printf("\n\033[1mload [filename]\033[0m\n  Load the configuration/script from the file [filename] (startup.vpc is the default filename).\n  When the file is loaded, commands will be displayed before being executed \n  if the state of the echo flag is on. See \033[1mset echo\033[0m\n  \033[1msleep\033[0m command will ignore \033[1mset echo on\033[0m, ONLY if \033[1msleep\033[0m misses the <text>\n  parameter. \n\n  Note: Press Ctrl+C to interrupt the running script\n");
  return 1;
}

// help_neighbor
// file help.c line 139
signed int help_neighbor(signed int argc, char **argv)
{
  return 1;
}

// help_ping
// file help.h line 39
signed int help_ping(signed int argc, char **argv)
{
  printf("\n\033[1mping <host> [-options]\033[0m\n  Ping the network <host>. <host> can be an ip address or name\n    options:\n     -1             ICMP mode, default\n     -2             UDP mode\n     -3             TCP mode\n     -P <protocol>  Same as above, setting ip protocol\n                    1 - icmp, 17 - udp, 6 - tcp\n     -c <count>     packet count, default 5\n     -l <size>      data size\n     -T <ttl>       set TTL, default 64\n     -s <port>      source port\n     -p <port>      destination port\n     -f <flag>      tcp head flag, |C|E|U|A|P|R|S|F|\n                              bits |7 6 5 4 3 2 1 0|\n     -t             send packet until interrupt by Ctrl+C\n     -i <ms>        wait <ms> milliseconds between sending each packet\n     -w <ms>        wait <ms> milliseconds to receive the response\n\n  Note: 1. Using names requires DNS to be set.\n        2. Use Ctrl+C to stop the command.\n");
  return 1;
}

// help_relay
// file help.h line 41
signed int help_relay(signed int argc, char **argv)
{
  printf("\n\033[1mrelay [arguments]\033[0m\n  arguments:\n    port <port>                  set relay hub port\n    show                         show the relay rules\n    add [ip1:]port1 [ip2:]port2  relay the packets between port1 and port2\n    del [ip1:]port1 [ip2:]port2  delete the relay rule\n    del <id>                     delete the relay rule\n");
  return 1;
}

// help_rlogin
// file help.h line 42
signed int help_rlogin(signed int argc, char **argv)
{
  printf("\n\033[1mrlogin [<ip>] <port>\033[0m\n  Telnet to <port> at <ip> (def 127.0.0.1) relative to HOST PC. \n  To attach to the console of a virtual router running on port 2000 of this\n  host PC, use \033[1mrlogin 2000\033[0m\n  To telnet to the port 2004 of a remote host 10.1.1.1, use\n  \033[1mrlogin 10.1.1.1 2004\033[0m\n");
  return 1;
}

// help_save
// file help.h line 43
signed int help_save(signed int argc, char **argv)
{
  printf("\n\033[1msave [filename]\033[0m\n  Save the configuration to the file [filename] (startup.vpc is the default filename).\n");
  return 1;
}

// help_set
// file help.h line 44
signed int help_set(signed int argc, char **argv)
{
  unsigned long int return_value_strlen$5;
  signed int return_value_strncmp$6;
  signed int return_value_strcmp$1;
  _Bool tmp_if_expr$4;
  unsigned long int return_value_strlen$2;
  signed int return_value_strncmp$3;
  unsigned long int return_value_strlen$11;
  signed int return_value_strncmp$12;
  signed int return_value_strcmp$7;
  _Bool tmp_if_expr$10;
  unsigned long int return_value_strlen$8;
  signed int return_value_strncmp$9;
  if(argc == 3)
  {
    return_value_strlen$5=strlen(argv[(signed long int)1]);
    return_value_strncmp$6=strncmp(argv[(signed long int)1], "dump", return_value_strlen$5);
    if(!(return_value_strncmp$6 == 0))
      goto __CPROVER_DUMP_L3;

    return_value_strcmp$1=strcmp(argv[(signed long int)2], "?");
    if(return_value_strcmp$1 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_strlen$2=strlen(argv[(signed long int)2]);
      return_value_strncmp$3=strncmp(argv[(signed long int)2], "help", return_value_strlen$2);
      tmp_if_expr$4 = !(return_value_strncmp$3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$4)
      goto __CPROVER_DUMP_L3;

    printf("\n\033[1mset dump [detail|mac|raw|all|off]\033[0m\n  Set the packet dump flag for this VPC\n    detail  print protocol\n    mac     print ether address\n    raw     print the first 40 bytes\n    all     all the packets including incoming\n            must use [detail|mac|raw] as well as 'all'\n    off     clear all the flags\n");
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(argc == 3)
    {
      return_value_strlen$11=strlen(argv[(signed long int)1]);
      return_value_strncmp$12=strncmp(argv[(signed long int)1], "echo", return_value_strlen$11);
      if(!(return_value_strncmp$12 == 0))
        goto __CPROVER_DUMP_L6;

      return_value_strcmp$7=strcmp(argv[(signed long int)2], "?");
      if(return_value_strcmp$7 == 0)
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        return_value_strlen$8=strlen(argv[(signed long int)2]);
        return_value_strncmp$9=strncmp(argv[(signed long int)2], "help", return_value_strlen$8);
        tmp_if_expr$10 = !(return_value_strncmp$9 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$10)
        goto __CPROVER_DUMP_L6;

      printf("\n\033[1mset echo [on|off]\033[0m\n  Sets the state of the echo flag used when loading script files.\n  See \033[1mload [filename]\033[0m.\n");
      return 1;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      printf("\n\033[1mset [lport|rport|rhost|pcname|echo|dump|]\033[0m\n  Set hostname, connection port, dump options and echo on or off\n    lport <port>    local port\n    rport <port>    remote peer port\n    rhost <ip>      remote peer host IPv4 address\n    pcname <name>   set the hostname of the current VPC\n    echo [on|off]   set echoing on or off during script execution\n    dump [options]  set the packet dump flag for this VPC. \n                    Options:\n                      detail  print protocol\n                      mac     print ether address\n                      raw     print the first 40 bytes\n                      all     all the packets including incoming.\n                              must use [detail|mac|raw] as well as 'all'\n                      off     clear all the flag\n");
      return 1;
    }
  }
}

// help_shell
// file help.h line 45
signed int help_shell(signed int argc, char **argv)
{
  printf("\n\033[1m! [command [args]]\033[0m\n Invoke an OS command with the 'args' as its arguments\n");
  return 1;
}

// help_show
// file help.h line 46
signed int help_show(signed int argc, char **argv)
{
  unsigned long int return_value_strlen$5;
  signed int return_value_strncmp$6;
  signed int return_value_strcmp$1;
  _Bool tmp_if_expr$4;
  unsigned long int return_value_strlen$2;
  signed int return_value_strncmp$3;
  unsigned long int return_value_strlen$11;
  signed int return_value_strncmp$12;
  signed int return_value_strcmp$7;
  _Bool tmp_if_expr$10;
  unsigned long int return_value_strlen$8;
  signed int return_value_strncmp$9;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$13;
  _Bool tmp_if_expr$16;
  unsigned long int return_value_strlen$14;
  signed int return_value_strncmp$15;
  signed int return_value_strcmp$22;
  signed int return_value_strcmp$18;
  _Bool tmp_if_expr$21;
  unsigned long int return_value_strlen$19;
  signed int return_value_strncmp$20;
  signed int return_value_strcmp$23;
  _Bool tmp_if_expr$26;
  unsigned long int return_value_strlen$24;
  signed int return_value_strncmp$25;
  if(argc == 3)
  {
    return_value_strlen$5=strlen(argv[(signed long int)1]);
    return_value_strncmp$6=strncmp(argv[(signed long int)1], "arp", return_value_strlen$5);
    if(!(return_value_strncmp$6 == 0))
      goto __CPROVER_DUMP_L3;

    return_value_strcmp$1=strcmp(argv[(signed long int)2], "?");
    if(return_value_strcmp$1 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_strlen$2=strlen(argv[(signed long int)2]);
      return_value_strncmp$3=strncmp(argv[(signed long int)2], "help", return_value_strlen$2);
      tmp_if_expr$4 = !(return_value_strncmp$3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$4)
      goto __CPROVER_DUMP_L3;

    printf("\n\033[1mshow arp [<digit>|all]\033[0m\n  Show arp table for VPC <digit> (default this VPC) or all VPCs\n");
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(argc == 3)
    {
      return_value_strlen$11=strlen(argv[(signed long int)1]);
      return_value_strncmp$12=strncmp(argv[(signed long int)1], "dump", return_value_strlen$11);
      if(!(return_value_strncmp$12 == 0))
        goto __CPROVER_DUMP_L6;

      return_value_strcmp$7=strcmp(argv[(signed long int)2], "?");
      if(return_value_strcmp$7 == 0)
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        return_value_strlen$8=strlen(argv[(signed long int)2]);
        return_value_strncmp$9=strncmp(argv[(signed long int)2], "help", return_value_strlen$8);
        tmp_if_expr$10 = !(return_value_strncmp$9 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$10)
        goto __CPROVER_DUMP_L6;

      printf("\n\033[1mshow dump [<digit>|all]\033[0m\n  Show dump flags for VPC <digit> (default this VPC) or all VPCs\n");
      return 1;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      if(argc == 3)
      {
        return_value_strcmp$17=strcmp(argv[(signed long int)1], "ip");
        if(!(return_value_strcmp$17 == 0))
          goto __CPROVER_DUMP_L9;

        return_value_strcmp$13=strcmp(argv[(signed long int)2], "?");
        if(return_value_strcmp$13 == 0)
          tmp_if_expr$16 = (_Bool)1;

        else
        {
          return_value_strlen$14=strlen(argv[(signed long int)2]);
          return_value_strncmp$15=strncmp(argv[(signed long int)2], "help", return_value_strlen$14);
          tmp_if_expr$16 = !(return_value_strncmp$15 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$16)
          goto __CPROVER_DUMP_L9;

        printf("\n\033[1mshow ip [<digit>|all]\033[0m\n  Show IPv4 details for VPC <digit> (default this VPC) or all VPCs, including\n  VPC Name, IP address, mask, gateway, DNS, MAC, lport, rhost:rport and MTU.\n");
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L9:
        ;
        if(argc == 3)
        {
          return_value_strcmp$22=strcmp(argv[(signed long int)1], "ipv6");
          if(!(return_value_strcmp$22 == 0))
            goto __CPROVER_DUMP_L12;

          return_value_strcmp$18=strcmp(argv[(signed long int)2], "?");
          if(return_value_strcmp$18 == 0)
            tmp_if_expr$21 = (_Bool)1;

          else
          {
            return_value_strlen$19=strlen(argv[(signed long int)2]);
            return_value_strncmp$20=strncmp(argv[(signed long int)2], "help", return_value_strlen$19);
            tmp_if_expr$21 = !(return_value_strncmp$20 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$21)
            goto __CPROVER_DUMP_L12;

          printf("\n\033[1mshow ipv6 [<digit>|all]\033[0m\n  Show IPv6 details for VPC <digit> (default this VPC) or all VPCs, including\n  VPC Name, IP address, mask, gateway, DNS, MAC, lport, rhost:rport and MTU\n");
          return 1;
        }

        else
        {

        __CPROVER_DUMP_L12:
          ;
          if(argc >= 2)
          {
            return_value_strcmp$23=strcmp(argv[(signed long int)(argc - 1)], "?");
            if(return_value_strcmp$23 == 0)
              tmp_if_expr$26 = (_Bool)1;

            else
            {
              return_value_strlen$24=strlen(argv[(signed long int)(argc - 1)]);
              return_value_strncmp$25=strncmp(argv[(signed long int)(argc - 1)], "help", return_value_strlen$24);
              tmp_if_expr$26 = !(return_value_strncmp$25 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(!tmp_if_expr$26)
              goto __CPROVER_DUMP_L15;

            printf("\n\033[1mshow [arp [<digit>|all]|dump|echo|history|ip [<digit>|all]|ipv6 [<digit>|all]]\033[0m\n    arp [<digit>|all]   Show arp table for VPC <digit> or all VPCs\n    dump [<digit>|all]  Show dump flags for VPC <digit> or all VPCs\n    echo                Show the status of the echo flag. see \033[1mset echo\033[0m\n    history             List the command history\n    ip [<digit>|all]    Show IPv4 details for VPC <digit> or all VPCs\n                        Shows VPC Name, IP address, mask, gateway, DNS, MAC, \n                        lport, rhost:rport and MTU\n    ipv6 [<digit>|all]  Show IPv6 details for VPC <digit> or all VPCs\n                        Shows VPC Name, IPv6 addresses/mask, gateway, MAC,\n                        lport, rhost:rport and MTU\n    version             Show the version information\n\n  Notes: if <digit> and <all> are missing, \033[1marp\033[0m/\033[1mdump\033[0m/\033[1mip\033[0m/\033[1mipv6\033[0m will display\n         the current VPC.\n");
            return 1;
          }

          else
          {

          __CPROVER_DUMP_L15:
            ;
            return 0;
          }
        }
      }
    }
  }
}

// help_shut
// file help.c line 329
signed int help_shut(signed int argc, char **argv)
{
  printf("\n\033[1m%s\033[0m, shutdown the process (only in daemon mode)\n", argv[(signed long int)0]);
  return 1;
}

// help_sleep
// file help.h line 48
signed int help_sleep(signed int argc, char **argv)
{
  printf("\n\033[1msleep [<seconds>] [text]\033[0m\n  Print <text> and pause execution of script for <seconds>.\n  If <seconds>=0 or missing, pause until a key is pressed. \n  See \033[1mload [filename]\033[0m\n");
  return 1;
}

// help_trace
// file help.h line 40
signed int help_trace(signed int argc, char **argv)
{
  printf("\n\033[1mtrace <host> [-options]\033[0m\n  Print the path packets take to network <host>. <host> can be an ip address or name.\n    options:\n      -P <protocol>  Use IP <protocol> in trace packets\n                     1 - icmp, 17 - udp (default), 6 - tcp  \n      -m <ttl>       maximum TTL, default 8\n      <ttl>          Same as -m option, compatible with the old version\n\n  Note: 1. Using names requires DNS to be set.\n        2. Use Ctrl+C to stop the command.\n");
  return 1;
}

// help_version
// file help.c line 308
signed int help_version(signed int argc, char **argv)
{
  return 1;
}

// hostresolv
// file dns.h line 55
signed int hostresolv(struct anonymous$0 *pc, char *name, unsigned int *ip)
{
  struct sesscb cb;
  struct packet *m;
  char data[512l];
  char *pdn = (char *)(void *)0;
  signed int dlen;
  unsigned int gip;
  struct in_addr in;
  struct timeval tv;
  signed int ok;
  signed int namelen;
  signed int i;
  unsigned char mac[6l];
  char dname[64l];
  unsigned short int magicid;
  signed int reqcnt = 0;
  char *return_value_strchr$1;
  return_value_strchr$1=strchr(name, 46);
  if(return_value_strchr$1 == ((char *)NULL))
  {
    if(!((signed int)pc->ip4.domain[0l] == 0))
      snprintf(dname, sizeof(char [64l]) /*64ul*/ , "%s.%s", name, (const void *)pc->ip4.domain);

    else
      if(!((signed int)pc->ip4.dhcp.domain[0l] == 0))
        snprintf(dname, sizeof(char [64l]) /*64ul*/ , "%s.%s", name, (const void *)pc->ip4.dhcp.domain);

  }

  else
    snprintf(dname, sizeof(char [64l]) /*64ul*/ , "%s", name);

reqry:
  ;
  signed long int return_value_random$2;
  signed int return_value_sameNet$3;
  signed int return_value_arpResolve$5;
  signed long int return_value_time$6;
  signed long int return_value_random$7;
  signed int return_value_timeout$8;
  for( ; (_Bool)1; reqcnt = reqcnt + 1)
  {
    if(reqcnt >= 3)
      return 0;

    return_value_random$2=random();
    magicid = (unsigned short int)return_value_random$2;
    dlen=dnsrequest(magicid, dname, data, &namelen);
    if(dlen == 0)
      return 0;

    return_value_sameNet$3=sameNet((unsigned long int)cb.dip, (unsigned long int)pc->ip4.ip, pc->ip4.cidr);
    if(!(return_value_sameNet$3 == 0))
      gip = cb.dip;

    else
      if(pc->ip4.gw == 0ul)
      {
        printf("No gateway found\n");
        return 0;
      }

      else
        gip = (unsigned int)pc->ip4.gw;
    return_value_arpResolve$5=arpResolve(pc, gip, mac);
    if(return_value_arpResolve$5 == 0)
    {
      in.s_addr = gip;
      char *return_value_inet_ntoa$4;
      return_value_inet_ntoa$4=inet_ntoa(in);
      printf("host (%s) not reachable\n", return_value_inet_ntoa$4);
      return 0;
    }

    pdn = data + (signed long int)sizeof(struct anonymous) /*12ul*/ ;
    i = 0;

  __CPROVER_DUMP_L11:
    ;
    if(i >= 2)
      goto __CPROVER_DUMP_L20;

    if(pc->ip4.dns[(signed long int)i] == 0u)
      goto __CPROVER_DUMP_L19;

    memset((void *)&cb, 0, sizeof(struct sesscb) /*160ul*/ );
    cb.data = data;
    cb.dsize = dlen;
    cb.proto = 17;
    cb.mtu = pc->ip4.mtu;
    return_value_time$6=time(((signed long int *)NULL));
    cb.ipid = (unsigned int)(return_value_time$6 & (signed long int)0xffff);
    cb.ttl = (unsigned char)64;
    cb.sip = pc->ip4.ip;
    cb.dip = pc->ip4.dns[(signed long int)i];
    return_value_random$7=random();
    cb.sport = (unsigned int)(return_value_random$7 % (signed long int)(65000 - 1024) + (signed long int)1024);
    cb.dport = (unsigned int)53;
    memcpy((void *)cb.smac, (const void *)pc->ip4.mac, (unsigned long int)6);
    memcpy((void *)cb.dmac, (const void *)mac, (unsigned long int)6);
    m=packet(&cb);
    if(m == ((struct packet *)NULL))
    {
      printf("out of memory\n");
      return 0;
    }

    gettimeofday(&tv, (struct timezone *)(void *)0);
    enq(&pc->oq, m);

  __CPROVER_DUMP_L13:
    ;
    return_value_timeout$8=timeout(tv, 1000);
    if(!(return_value_timeout$8 == 0))
      goto __CPROVER_DUMP_L18;

    if(!(ctrl_c == 0))
      goto __CPROVER_DUMP_L18;

    usleep((unsigned int)(1 * 1000));
    ok = 0;
    do
    {
      m=deq(&pc->iq);
      if(m == ((struct packet *)NULL))
        break;

      if(!(ok == 0))
        break;

      ok=dnsparse(m, magicid, pdn, namelen, ip);
      free((void *)m);
    }
    while((_Bool)1);
    if(!(ok == 2))
      break;

    printf("%s ->> %s\n", (const void *)dname, pdn);
    strcpy(dname, pdn);
  }
  if(!(ok == 0))
  {
    strcpy(name, pdn);
    return 1;
  }

  else
  {
    goto __CPROVER_DUMP_L13;

  __CPROVER_DUMP_L18:
    ;

  __CPROVER_DUMP_L19:
    ;
    i = i + 1;
    goto __CPROVER_DUMP_L11;

  __CPROVER_DUMP_L20:
    ;
    return 0;
  }
}

// hypervisor
// file hv.c line 147
static signed int hypervisor(signed int port)
{
  struct sockaddr_in serv;
  signed int on = 1;
  setsid();
  signed int return_value_daemon$1;
  return_value_daemon$1=daemon(1, 1);
  signed int return_value_openpty$2;
  if(!(return_value_daemon$1 == 0))
    perror("Daemonize fail");

  else
  {
    memset((void *)vpcs_list, 0, (unsigned long int)10 * sizeof(struct list) /*32ul*/ );
    return_value_openpty$2=openpty(&ptyfdm, &ptyfds, (char *)(void *)0, (struct termios *)(void *)0, (struct winsize *)(void *)0);
    if(!(return_value_openpty$2 == 0))
      perror("Create pseudo-terminal");

    else
    {
      signal(17, (void (*)(signed int))1);
      signal(13, (void (*)(signed int))1);
      fptys=fdopen(ptyfds, "w");
      rls$link1=readline_init(50, 128);
      rls$link1->fdin = ptyfds;
      rls$link1->fdout = ptyfds;
      sock=socket(2, 1, 6);
      if(sock >= 0)
      {
        setsockopt(sock, 1, 2, (const void *)(char *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
        bzero((void *)(char *)&serv, sizeof(struct sockaddr_in) /*16ul*/ );
        serv.sin_family = (unsigned short int)2;
        serv.sin_addr.s_addr=htonl((unsigned int)0x00000000);
        serv.sin_port=htons((unsigned short int)port);
        signed int return_value_bind$3;
        return_value_bind$3=bind(sock, (struct sockaddr *)&serv, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
        if(!(return_value_bind$3 >= 0))
          perror("Daemon bind port");

        else
        {
          signed int return_value_listen$4;
          return_value_listen$4=listen(sock, 5);
          if(!(return_value_listen$4 >= 0))
            perror("Daemon listen");

          else
          {
            loop();
            close(sock);
          }
        }
      }

    }
  }

ret:
  ;
  if(!(rls$link1 == ((struct rls *)NULL)))
    readline_free(rls$link1);

  return 1;
}

// icmp6Reply
// file packets6.c line 531
static struct packet * icmp6Reply(struct packet *m0)
{
  struct ethdr *eh;
  struct ethdr *eh0;
  struct anonymous$18 *ip;
  struct anonymous$18 *ip0;
  struct anonymous$20 *icmp;
  struct packet *m;
  signed int hlen;
  signed int plen = (signed int)((unsigned long int)m0->len - sizeof(struct ethdr) /*14ul*/ );
  hlen = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct anonymous$18) /*40ul*/  + sizeof(struct anonymous$20) /*8ul*/  + (unsigned long int)plen);
  m=new_pkt(hlen);
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    hlen = (signed int)(((unsigned long int)hlen - sizeof(struct ethdr) /*14ul*/ ) - sizeof(struct anonymous$18) /*40ul*/ );
    eh = (struct ethdr *)m->data;
    eh0 = (struct ethdr *)m0->data;
    memcpy((void *)eh->src, (const void *)eh0->dst, (unsigned long int)6);
    memcpy((void *)eh->dst, (const void *)eh0->src, (unsigned long int)6);
    eh->type = eh0->type;
    ip = (struct anonymous$18 *)(eh + (signed long int)1);
    ip0 = (struct anonymous$18 *)(eh0 + (signed long int)1);
    ip->ip6_ctlun.ip6_un1.ip6_un1_flow = (unsigned int)0;
    ip->ip6_ctlun.ip6_un2_vfc = ip->ip6_ctlun.ip6_un2_vfc & (unsigned char)~0xf0;
    ip->ip6_ctlun.ip6_un2_vfc = ip->ip6_ctlun.ip6_un2_vfc | (unsigned char)0x60;
    ip->ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)58;
    ip->ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)64;
    ip->ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)hlen);
    memcpy((void *)ip->src.uaddr._a8, (const void *)ip0->dst.uaddr._a8, (unsigned long int)16);
    memcpy((void *)ip->dst.uaddr._a8, (const void *)ip0->src.uaddr._a8, (unsigned long int)16);
    icmp = (struct anonymous$20 *)(ip + (signed long int)1);
    icmp->type = (unsigned char)1;
    icmp->code = (unsigned char)4;
    signed long int return_value_time$1;
    return_value_time$1=time(((signed long int *)NULL));
    icmp->icmp6_dataun.icmp6_un_data16[(signed long int)0] = (unsigned short int)(return_value_time$1 & (signed long int)0xffff);
    icmp->icmp6_dataun.icmp6_un_data16[(signed long int)1]=htons((unsigned short int)1);
    memcpy((void *)(char *)(icmp + (signed long int)1), (const void *)(m0->data + (signed long int)sizeof(struct ethdr) /*14ul*/ ), (unsigned long int)plen);
    icmp->cksum = (unsigned short int)0;
    icmp->cksum=cksum6(ip, (unsigned char)58, hlen);
    return m;
  }
}

// icmpReply
// file packets.c line 551
static struct packet * icmpReply(struct packet *m0, char icmptype)
{
  struct packet *m = (struct packet *)(void *)0;
  struct ethdr *eh = (struct ethdr *)(void *)0;
  struct iphdr *ip = (struct iphdr *)(void *)0;
  struct icmphdr *icmp = (struct icmphdr *)(void *)0;
  if((signed int)icmptype == 0)
  {
    m = m0;
    eh = (struct ethdr *)m->data;
    ip = (struct iphdr *)(eh + (signed long int)1);
    icmp = (struct icmphdr *)(ip + (signed long int)1);
    unsigned short int old_sum;
    unsigned char old_ttl = ip->ttl;
    old_sum = icmp->cksum;
    icmp->type = (unsigned char)0;
    icmp->cksum=cksum_fixup(icmp->cksum, (unsigned short int)8, (unsigned short int)0, (unsigned short int)0);
    ip->dip = ip->dip ^ ip->sip;
    ip->sip = ip->sip ^ ip->dip;
    ip->dip = ip->dip ^ ip->sip;
    ip->ttl = (unsigned char)64;
    unsigned short int return_value_cksum_fixup$1;
    return_value_cksum_fixup$1=cksum_fixup(ip->cksum, (unsigned short int)old_ttl, (unsigned short int)ip->ttl, (unsigned short int)0);
    unsigned short int return_value_cksum_fixup$2;
    return_value_cksum_fixup$2=cksum_fixup(return_value_cksum_fixup$1, (unsigned short int)8, (unsigned short int)0, (unsigned short int)0);
    ip->cksum=cksum_fixup(return_value_cksum_fixup$2, old_sum, icmp->cksum, (unsigned short int)0);
    swap_ehead(m->data);
    return m;
  }

  if((signed int)icmptype == 3)
  {
    signed int len;
    signed int len0;
    eh = (struct ethdr *)m0->data;
    ip = (struct iphdr *)(eh + (signed long int)1);
    unsigned short int return_value_ntohs$3;
    return_value_ntohs$3=ntohs(ip->len);
    len0 = (signed int)return_value_ntohs$3;
    if(len0 >= 45)
      len0 = 44;

    len = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct iphdr) /*20ul*/  + sizeof(struct icmphdr) /*8ul*/  + (unsigned long int)len0);
    m=new_pkt(len);
    if(m == ((struct packet *)NULL))
      return (struct packet *)(void *)0;

    memcpy((void *)m->data, (const void *)m0->data, sizeof(struct ethdr) /*14ul*/  + sizeof(struct iphdr) /*20ul*/ );
    eh = (struct ethdr *)m->data;
    ip = (struct iphdr *)(eh + (signed long int)1);
    icmp = (struct icmphdr *)(ip + (signed long int)1);
    memcpy((void *)(char *)(icmp + (signed long int)1), (const void *)(char *)(m0->data + (signed long int)sizeof(struct ethdr) /*14ul*/ ), (unsigned long int)len0);
    ip->len=htons((unsigned short int)((unsigned long int)len - sizeof(struct ethdr) /*14ul*/ ));
    signed long int return_value_time$4;
    return_value_time$4=time(((signed long int *)NULL));
    ip->id = (unsigned short int)(return_value_time$4 & (signed long int)0xffff);
    ip->frag=htons((unsigned short int)0x4000);
    ip->ttl = (unsigned char)64;
    ip->proto = (unsigned char)1;
    ip->cksum = (unsigned short int)0;
    ip->dip = ip->dip ^ ip->sip;
    ip->sip = ip->sip ^ ip->dip;
    ip->dip = ip->dip ^ ip->sip;
    icmp->seq=htons((unsigned short int)1);
    icmp->cksum = (unsigned short int)0;
    icmp->type = (unsigned char)3;
    icmp->code = (unsigned char)3;
    signed long int return_value_time$5;
    return_value_time$5=time(((signed long int *)NULL));
    icmp->id = (unsigned short int)(return_value_time$5 & (signed long int)0xffff);
    icmp->cksum=cksum((unsigned short int *)icmp, (signed int)(sizeof(struct icmphdr) /*8ul*/  + (unsigned long int)len0));
    ip->cksum=cksum((unsigned short int *)ip, (signed int)sizeof(struct iphdr) /*20ul*/ );
    swap_ehead(m->data);
    return m;
  }

  return (struct packet *)(void *)0;
}

// icmpTypeCode2String
// file ip.h line 467
const char * icmpTypeCode2String(signed int ipv, unsigned char type, unsigned char code)
{
  const char *DestUnreach[14l] = { "Destination network unreachable", "Destination host unreachable", "Destination protocol unreachable", "Destination port unreachable", "Fragmentation required, and DF flag set",
    "Source route failed", "Destination network unknown", "Destination host unknown", "Source host isolated", "Network administratively prohibited", "Host administratively prohibited", "Network unreachable for TOS", "Host unreachable for TOS", "Communication administratively prohibited" };
  const char *Redirect[4l] = { "Redirect Datagram for the Network", "Redirect Datagram for the Host", "Redirect Datagram for the TOS & network",
    "Redirect Datagram for the TOS & host" };
  const char *TimeExceed[2l] = { "TTL expired in transit", "Fragment reassembly time exceeded" };
  const char *Dest6Unreach[7l] = { "No route to destination", "Communication with destination administratively prohibited",
    "Beyond scope of source address", "Address unreachable", "Port unreachable", "Source address failed ingress/egress policy",
    "Reject route to destination" };
  const char *Time6Exceed[2l] = { "Hop limit exceeded in transit", "Fragment reassembly time exceeded" };
  const char *ND_messesg[5l] = { "ICMPv6 router solicitation", "ICMPv6 router advertisement", "ICMPv6 neighbor solicitation", "ICMPv6 neighbor advertisement", "ICMPv6 redirect" };
  const char *empty = "";
  if(ipv == 4)
    switch((signed int)type)
    {
      case 0:
        return "Echo reply";
      case 8:
        return "Echo";
      case 3:
      {
        if(!((signed int)code >= 14))
          return DestUnreach[(signed long int)code];

        break;
      }
      case 5:
      {
        if(!((signed int)code >= 4))
          return Redirect[(signed long int)code];

        break;
      }
      case 11:
        if(!((signed int)code >= 2))
          return TimeExceed[(signed long int)code];

      default:
        ;
    }

  else
    if(ipv == 6)
      switch((signed int)type)
      {
        case 1:
        {
          if(!((signed int)code >= 7))
            return Dest6Unreach[(signed long int)code];

          break;
        }
        case 3:
        {
          if(!((signed int)code >= 2))
            return Time6Exceed[(signed long int)code];

          break;
        }
        case 128:
          return "ICMPv6 echo request";
        case 129:
          return "ICMPv6 echo reply";
        case 133:

        case 134:

        case 135:

        case 136:

        case 137:
          return ND_messesg[(signed long int)((signed int)type - 133)];
        default:
          ;
      }

  return empty;
}

// inet_ntop4w
// file inet6.c line 52
static const char * inet_ntop4w(const unsigned char *src, char *dst, unsigned int size)
{
  char tmp[(signed long int)sizeof(char [16l]) /*16l*/ ];
  signed int l;
  static const char fmt[12l] = { '%', 'u', '.', '%', 'u', '.', '%', 'u', '.', '%', 'u', 0 };
  l=snprintf(tmp, sizeof(char [16l]) /*16ul*/ , fmt, src[(signed long int)0], src[(signed long int)1], src[(signed long int)2], src[(signed long int)3]);
  if((unsigned int)l >= size || !(l >= 1))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 28;
    return (const char *)(void *)0;
  }

  strncpy(dst, tmp, (unsigned long int)size);
  return dst;
}

// init_queue
// file queue.h line 62
void init_queue(struct pq *pq)
{
  pthread_mutex_init(&pq->locker, (const union anonymous$12 *)(void *)0);
  pthread_cond_init(&pq->cond, (const union anonymous$12 *)(void *)0);
  pq->ip = 0;
  pq->size = 0;
}

// insert_argv
// file utils.h line 34
signed int insert_argv(signed int argc, char **argv, char *str)
{
  char *av[20l];
  signed int i = 0;
  for( ; !(i >= argc); i = i + 1)
    av[(signed long int)i] = argv[(signed long int)i];
  argv[(signed long int)0] = str;
  i = 0;
  for( ; !(i >= argc); i = i + 1)
    argv[(signed long int)(i + 1)] = av[(signed long int)i];
  return argc + 1;
}

// invoke_cmd
// file vpcs.c line 603
static signed int invoke_cmd(const char *cmd)
{
  signed int rc = 0;
  rc=system(cmd);
  return rc;
}

// ip4Info
// file command.c line 1936
const char * ip4Info(const signed int id)
{
  struct in_addr in;
  signed int pos = 0;
  static char buf[128l];
  memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
  if(!(vpc[(signed long int)id].ip4.ip == 0u))
  {
    in.s_addr = vpc[(signed long int)id].ip4.ip;
    char *return_value_inet_ntoa$1;
    return_value_inet_ntoa$1=inet_ntoa(in);
    pos=sprintf(buf, "ip %s", (char *)return_value_inet_ntoa$1);
    in.s_addr = (unsigned int)vpc[(signed long int)id].ip4.gw;
    if(!(vpc[(signed long int)id].ip4.gw == 0ul))
    {
      in.s_addr = (unsigned int)vpc[(signed long int)id].ip4.gw;
      char *return_value_inet_ntoa$2;
      return_value_inet_ntoa$2=inet_ntoa(in);
      signed int return_value_sprintf$3;
      return_value_sprintf$3=sprintf(buf + (signed long int)pos, " %s", return_value_inet_ntoa$2);
      pos = pos + return_value_sprintf$3;
    }

    sprintf(buf + (signed long int)pos, " %d", vpc[(signed long int)id].ip4.cidr);
  }

  else
    return (const char *)(void *)0;
  return buf;
}

// ip6Info
// file command6.h line 43
const char * ip6Info(const signed int id)
{
  struct in6_addr ipaddr;
  char tmp[47l];
  _Bool tmp_if_expr$1;
  if(!(vpc[(signed long int)id].ip6.ip.uaddr._a32[0l] == 0u))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = vpc[(signed long int)id].ip6.ip.uaddr._a32[(signed long int)1] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = vpc[(signed long int)id].ip6.ip.uaddr._a32[(signed long int)2] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = vpc[(signed long int)id].ip6.ip.uaddr._a32[(signed long int)3] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  static char buf[47l];
  if(tmp_if_expr$3)
  {
    memset((void *)buf, 0, (unsigned long int)(46 + 1));
    memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)vpc[(signed long int)id].ip6.ip.uaddr._a8, (unsigned long int)16);
    vinet_ntop6(10, (const void *)&ipaddr, tmp, (unsigned int)(46 + 1));
    sprintf(buf, "ip %s/%d", (const void *)tmp, vpc[(signed long int)id].ip6.cidr);
  }

  else
    return (const char *)(void *)0;
  return buf;
}

// ip6tostr
// file ip.c line 303
char * ip6tostr(const unsigned char *ip6)
{
  struct in6_addr ipaddr;
  static char buf[47l];
  memset((void *)buf, 0, (unsigned long int)(46 + 1));
  memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)ip6, (unsigned long int)16);
  vinet_ntop6(10, (const void *)&ipaddr, buf, (unsigned int)(46 + 1));
  return buf;
}

// ipauto6
// file command6.h line 47
signed int ipauto6(void)
{
  struct packet *m = (struct packet *)(void *)0;
  char buf6[47l];
  struct in6_addr ipaddr;
  signed int n = 100;
  m=nbr_sol(&vpc[(signed long int)pcid]);
  vpc[(signed long int)pcid].ip6auto = 1;
  if(!(m == ((struct packet *)NULL)))
    enq(&vpc[(signed long int)pcid].oq, m);

  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  do
  {
    usleep((unsigned int)10000);
    if(!(vpc[(signed long int)pcid].ip6.ip.uaddr._a32[0l] == 0u))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = vpc[(signed long int)pcid].ip6.ip.uaddr._a32[(signed long int)1] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = vpc[(signed long int)pcid].ip6.ip.uaddr._a32[(signed long int)2] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = vpc[(signed long int)pcid].ip6.ip.uaddr._a32[(signed long int)3] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      memset((void *)buf6, 0, (unsigned long int)(46 + 1));
      memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)vpc[(signed long int)pcid].ip6.ip.uaddr._a8, (unsigned long int)16);
      vinet_ntop6(10, (const void *)&ipaddr, buf6, (unsigned int)(46 + 1));
      printf("GLOBAL SCOPE      : %s/%d\n", (const void *)buf6, vpc[(signed long int)pcid].ip6.cidr);
      printf("ROUTER LINK-LAYER : ");
      printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", vpc[(signed long int)pcid].ip6.gmac[(signed long int)0], vpc[(signed long int)pcid].ip6.gmac[(signed long int)1], vpc[(signed long int)pcid].ip6.gmac[(signed long int)2], vpc[(signed long int)pcid].ip6.gmac[(signed long int)3], vpc[(signed long int)pcid].ip6.gmac[(signed long int)4], vpc[(signed long int)pcid].ip6.gmac[(signed long int)5]);
      printf("\n");
      return 1;
    }

    n = n - 1;
  }
  while(n >= 1);
  printf("No router answered ICMPv6 Router Solicitation\n");
  return 1;
}

// isDhcp4_Offer
// file dhcp.h line 87
signed int isDhcp4_Offer(struct anonymous$0 *pc, struct packet *m)
{
  struct ethdr *eh;
  struct iphdr *ip;
  struct udpiphdr *ui;
  struct dhcp4_packet *dh;
  unsigned char *p;
  unsigned int magic;
  eh = (struct ethdr *)m->data;
  ip = (struct iphdr *)(eh + (signed long int)1);
  ui = (struct udpiphdr *)ip;
  dh = (struct dhcp4_packet *)(ui + (signed long int)1);
  _Bool tmp_if_expr$1;
  if(!(dh->xid == pc->ip4.dhcp.xid))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)dh->op != 2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    p = dh->options;
    magic = (unsigned int)((signed long int *)p)[(signed long int)0];
    unsigned int return_value_htonl$2;
    return_value_htonl$2=htonl((unsigned int)0x63825363);
    if(!(magic == return_value_htonl$2))
      return 0;

    else
    {
      pc->ip4.dhcp.svr = ip->sip;
      pc->ip4.dhcp.ip = dh->yiaddr;
      memcpy((void *)pc->ip4.dhcp.smac, (const void *)eh->src, (unsigned long int)6);
      p = p + (signed long int)4;
      while(!((signed int)*p == 255))
      {
        if(p - dh->options >= 128l)
          break;

        if((signed int)*p == 1)
          tmp_if_expr$5 = (signed int)p[(signed long int)1] == 4 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          pc->ip4.dhcp.netmask = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0];
          p = p + (signed long int)6;
          continue;
        }

        else
        {
          if((signed int)*p == 3)
            tmp_if_expr$4 = (signed int)p[(signed long int)1] == 4 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
          {
            pc->ip4.dhcp.gw = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0];
            p = p + (signed long int)6;
            continue;
          }

          else
            if((signed int)*p == 6)
            {
              if((signed int)p[1l] == 4)
              {
                pc->ip4.dhcp.dns[(signed long int)0] = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0];
                p = p + (signed long int)6;
              }

              else
                if((signed int)p[1l] >= 8)
                {
                  pc->ip4.dhcp.dns[(signed long int)0] = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0];
                  pc->ip4.dhcp.dns[(signed long int)1] = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)1];
                  p = p + (signed long int)((signed int)p[(signed long int)1] + 2);
                }

              continue;
            }

            else
            {
              if((signed int)*p == 54)
                tmp_if_expr$3 = (signed int)p[(signed long int)1] == 4 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              if(tmp_if_expr$3)
              {
                pc->ip4.dhcp.svr = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0];
                p = p + (signed long int)6;
                continue;
              }

              else
              {
                p = p + 1l;
                p = p + (signed long int)((signed int)*p + 1);
              }
            }
        }
      }
      return 1;
      return 0;
    }
  }
}

// isDhcp4_packer
// file dhcp.h line 88
signed int isDhcp4_packer(struct anonymous$0 *pc, struct packet *m)
{
  struct ethdr *eh;
  struct iphdr *ip;
  struct udpiphdr *ui;
  struct dhcp4_packet *dh;
  unsigned char *p;
  unsigned int magic;
  eh = (struct ethdr *)m->data;
  ip = (struct iphdr *)(eh + (signed long int)1);
  ui = (struct udpiphdr *)ip;
  dh = (struct dhcp4_packet *)(ui + (signed long int)1);
  _Bool tmp_if_expr$6;
  if(dh->xid == pc->ip4.dhcp.xid)
    tmp_if_expr$6 = (signed int)dh->op == 2 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$6 = (_Bool)0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$6)
  {
    memset((void *)&pc->ip4.dhcp, 0, sizeof(struct anonymous$13) /*104ul*/ );
    pc->ip4.dhcp.svr = ip->sip;
    memcpy((void *)pc->ip4.dhcp.smac, (const void *)eh->src, (unsigned long int)6);
    pc->ip4.ip = dh->yiaddr;
    pc->ip4.dhcp.ip = pc->ip4.ip;
    p = dh->options;
    magic = (unsigned int)((signed long int *)p)[(signed long int)0];
    unsigned int return_value_htonl$5;
    return_value_htonl$5=htonl((unsigned int)0x63825363);
    if(magic == return_value_htonl$5)
    {
      p = p + (signed long int)4;
      while(!((signed int)*p == 255))
      {
        if(p - dh->options >= 128l)
          break;

        if((signed int)*p == 1)
          tmp_if_expr$4 = (signed int)p[(signed long int)1] == 4 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
        {
          pc->ip4.dhcp.netmask = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0];
          unsigned int return_value_ntohl$1;
          return_value_ntohl$1=ntohl((unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0]);
          pc->ip4.cidr=getCIDR((unsigned long int)return_value_ntohl$1);
          p = p + (signed long int)6;
          continue;
        }

        else
        {
          if((signed int)*p == 3)
            tmp_if_expr$3 = (signed int)p[(signed long int)1] == 4 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
          {
            pc->ip4.gw = (unsigned long int)((signed int *)(p + (signed long int)2))[(signed long int)0];
            pc->ip4.dhcp.gw = (unsigned int)pc->ip4.gw;
            p = p + (signed long int)6;
            continue;
          }

          else
          {
            if((signed int)*p == 51)
              tmp_if_expr$2 = (signed int)p[(signed long int)1] == 4 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$2 = (_Bool)0;
            if(tmp_if_expr$2)
            {
              pc->ip4.lease = pc->ip4.lease + (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0];
              pc->ip4.dhcp.lease = pc->ip4.lease;
              p = p + (signed long int)6;
              continue;
            }

            else
              if((signed int)*p == 6)
              {
                if((signed int)p[1l] == 4)
                {
                  pc->ip4.dhcp.dns[(signed long int)0] = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0];
                  pc->ip4.dns[(signed long int)0] = pc->ip4.dhcp.dns[(signed long int)0];
                  p = p + (signed long int)6;
                }

                else
                  if((signed int)p[1l] >= 8)
                  {
                    pc->ip4.dhcp.dns[(signed long int)0] = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)0];
                    pc->ip4.dhcp.dns[(signed long int)1] = (unsigned int)((signed int *)(p + (signed long int)2))[(signed long int)1];
                    pc->ip4.dns[(signed long int)0] = pc->ip4.dhcp.dns[(signed long int)0];
                    pc->ip4.dns[(signed long int)1] = pc->ip4.dhcp.dns[(signed long int)1];
                    p = p + (signed long int)((signed int)p[(signed long int)1] + 2);
                  }

                continue;
              }

              else
                if((signed int)*p == 15)
                {
                  memset((void *)pc->ip4.dhcp.domain, 0, sizeof(char [64l]) /*64ul*/ );
                  memcpy((void *)pc->ip4.dhcp.domain, (const void *)(p + (signed long int)2), (unsigned long int)p[(signed long int)1]);
                  strcpy(pc->ip4.domain, pc->ip4.dhcp.domain);
                  p = p + (signed long int)((signed int)p[(signed long int)1] + 2);
                }

                else
                {
                  p = p + 1l;
                  p = p + (signed long int)((signed int)*p + 1);
                }
          }
        }
      }
    }

    return 1;
  }

  else
    return 0;
}

// is_there
// file hv.c line 740
static signed int is_there(char *candidate)
{
  struct stat fin;
  signed int return_value_access$3;
  return_value_access$3=access(candidate, 1);
  signed int return_value_stat$2;
  unsigned int return_value_getuid$1;
  if(return_value_access$3 == 0)
  {
    return_value_stat$2=stat(candidate, &fin);
    if(!(return_value_stat$2 == 0))
      goto __CPROVER_DUMP_L1;

    if(!((61440u & fin.st_mode) == 32768u))
      goto __CPROVER_DUMP_L1;

    return_value_getuid$1=getuid();
    if((73u & fin.st_mode) == 0u && return_value_getuid$1 == 0u)
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// kbhit
// file readline.c line 47
void kbhit(signed int fd)
{
  struct termios termios;
  char kb[32l];
  signed int rc;
  set_terminal(fd, &termios);
  do
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)kb, sizeof(char [32l]) /*32ul*/ );
    rc = (signed int)return_value_read$1;
    if(rc >= 1)
      break;

    usleep((unsigned int)100);
  }
  while((_Bool)1);
  reset_terminal(fd, &termios);
}

// loadhistory
// file readline.h line 63
signed int loadhistory(const char *filename, struct rls *rls)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "r");
  signed int len;
  signed int i;
  signed int *return_value___errno_location$1;
  char *return_value_fgets$2;
  signed int tmp_post$4;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  else
  {
    i = 0;
    do
    {
      return_value_fgets$2=fgets(rls->kbuffer, rls->maxbuflen, fp);
      if(return_value_fgets$2 == ((char *)NULL))
        break;

      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(rls->kbuffer);
      len = (signed int)return_value_strlen$3;
      if(!(len == 0))
      {
        if((signed int)rls->kbuffer[(signed long int)(len + -1)] == 10)
          rls->kbuffer[(signed long int)(len - 1)] = (char)0;

        if(i == rls->maxhistnum)
        {
          memmove((void *)rls->history[(signed long int)0], (const void *)rls->history[(signed long int)1], (unsigned long int)(rls->maxhistnum - 1));
          i = i - 1;
        }

        tmp_post$4 = i;
        i = i + 1;
        strcpy(rls->history[(signed long int)tmp_post$4], rls->kbuffer);
      }

    }
    while((_Bool)1);
    rls->hist_total = i;
    fclose(fp);
    return 0;
  }
}

// locallink6
// file command6.h line 49
void locallink6(struct anonymous$0 *pc)
{
  pc->link6.ip.uaddr._a8[(signed long int)15] = pc->ip4.mac[(signed long int)5];
  pc->link6.ip.uaddr._a8[(signed long int)14] = pc->ip4.mac[(signed long int)4];
  pc->link6.ip.uaddr._a8[(signed long int)13] = pc->ip4.mac[(signed long int)3];
  pc->link6.ip.uaddr._a8[(signed long int)12] = (unsigned char)0xfe;
  pc->link6.ip.uaddr._a8[(signed long int)11] = (unsigned char)0xff;
  pc->link6.ip.uaddr._a8[(signed long int)10] = pc->ip4.mac[(signed long int)2];
  pc->link6.ip.uaddr._a8[(signed long int)9] = pc->ip4.mac[(signed long int)1];
  pc->link6.ip.uaddr._a8[(signed long int)8] = (unsigned char)((signed int)pc->ip4.mac[(signed long int)0] ^ 0x2);
  pc->link6.ip.uaddr._a8[(signed long int)1] = (unsigned char)0x80;
  pc->link6.ip.uaddr._a8[(signed long int)0] = (unsigned char)0xfe;
  pc->link6.cidr = 64;
  pc->link6.type = 2;
  struct packet *m;
  m=nbr_sol(pc);
  if(!(m == ((struct packet *)NULL)))
    enq(&pc->oq, m);

}

// lock_q
// file queue.c line 120
void lock_q(struct pq *pq)
{
  pthread_mutex_lock(&pq->locker);
}

// loop
// file hv.c line 263
static void loop(void)
{
  struct sockaddr_in cli;
  signed int slen;
  unsigned char buf[256l];
  unsigned char *p;
  signed int i;
  struct anonymous$14 set;
  struct timeval tv;
  slen = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
  const unsigned short int **return_value___ctype_b_loc$3;
  while(!(cmd_quit$link1 == 2))
  {
    cmd_quit$link1 = 0;
    sock_cli=accept(sock, (struct sockaddr *)&cli, (unsigned int *)&slen);
    if(sock_cli >= 0)
    {
      set_telnet_mode$link1(sock_cli);
      pthread_create(&pid_master, (const union pthread_attr_t *)(void *)0, pty_master, (void *)0);
      pthread_create(&pid_salve, (const union pthread_attr_t *)(void *)0, pty_slave, (void *)0);
      signed int return_value_fcntl$1;
      return_value_fcntl$1=fcntl(sock_cli, 3);
      fcntl(0, 4, return_value_fcntl$1 | 04000);
      while(cmd_quit$link1 == 0)
      {
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&set)->__fds_bits[(signed long int)(sock_cli / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->__fds_bits[(signed long int)(sock_cli / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock_cli % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        tv.tv_sec = (signed long int)1;
        tv.tv_usec = (signed long int)0;
        i=select(sock_cli + 1, &set, (struct anonymous$14 *)(void *)0, (struct anonymous$14 *)(void *)0, &tv);
        if(!(i >= 0))
          break;

        if(!(i == 0))
        {
          if(!((set.__fds_bits[(signed long int)(sock_cli / 8)] & (signed long int)(1UL << sock_cli % 8)) == 0l))
          {
            memset((void *)buf, 0, sizeof(unsigned char [256l]) /*256ul*/ );
            signed long int return_value_read$2;
            return_value_read$2=read(sock_cli, (void *)buf, sizeof(unsigned char [256l]) /*256ul*/ );
            i = (signed int)return_value_read$2;
            if(!(i >= 0))
              break;

            if(!(i == 0))
            {
              p = buf;
              if((signed int)*p == 0xff)
                for( ; !(*p == 0); p = p + 1l)
                {
                  return_value___ctype_b_loc$3=__ctype_b_loc();
                  if(!((16384 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*p]) == 0))
                    break;

                }

              if(!((signed int)*p == 0))
              {
                i = (signed int)((signed long int)i - (p - buf));
                for( ; i >= 1; i = i - 1)
                  if(!((signed int)p[(signed long int)i + -1l] == 0))
                    break;

                if(i >= 1)
                {
                  if((signed int)*p == 4)
                  {
                    p = buf;
                    strcpy((char *)buf, "disconnect\n");
                    unsigned long int return_value_strlen$4;
                    return_value_strlen$4=strlen((char *)buf);
                    i = (signed int)return_value_strlen$4;
                    signed long int return_value_write$5;
                    return_value_write$5=write(ptyfdm, (const void *)p, (unsigned long int)i);
                    i = (signed int)return_value_write$5;
                    usleep((unsigned int)100);
                    strcpy((char *)buf, "\n");
                    unsigned long int return_value_strlen$6;
                    return_value_strlen$6=strlen((char *)buf);
                    i = (signed int)return_value_strlen$6;
                  }

                  signed long int return_value_write$7;
                  return_value_write$7=write(ptyfdm, (const void *)p, (unsigned long int)i);
                }

              }

            }

          }

        }

      }
      pthread_cancel(pid_master);
      pthread_cancel(pid_salve);
      close(sock_cli);
    }

  }
}

// main
// file hv.c line 120
signed int main(signed int argc, char **argv, char **envp)
{
  signed int return_value_strcmp$3;
  if(argc == 3)
  {
    return_value_strcmp$3=strcmp(argv[(signed long int)1], "-H");
    if(return_value_strcmp$3 == 0)
    {
      hvport=atoi(argv[(signed long int)2]);
      if(hvport >= 65001 || !(hvport >= 1024))
      {
        printf("Invalid port\n");
        exit(1);
      }

      char *return_value_getpath$1;
      return_value_getpath$1=getpath(argv[(signed long int)0]);
      if(return_value_getpath$1 == ((char *)NULL))
      {
        printf("Can not get file path\n");
        return 1;
      }

      signed int return_value_hypervisor$2;
      return_value_hypervisor$2=hypervisor(hvport);
      return return_value_hypervisor$2;
    }

  }

  signed int return_value_vpcs$4;
  return_value_vpcs$4=vpcs(argc, argv);
  return return_value_vpcs$4;
}

// mkargv
// file utils.h line 33
signed int mkargv(char *str, char **argv, signed int max)
{
  signed int n = 0;
  char *p;
  char *q;
  char *es;
  char **args = argv;
  char *sep = "=/ \t";
  signed int tmp_post$2;
  signed int tmp_post$3;
  if(str == ((char *)NULL))
    return n;

  else
  {
    static char buf[128l];
    memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
    strncpy(buf, str, sizeof(char [128l]) /*128ul*/  - (unsigned long int)1);
    p = buf;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(buf);
    es = p + (signed long int)return_value_strlen$1;
    while(!(p == ((char *)NULL)) && !(p >= es))
      if((signed int)*p == 34)
      {
        q=strchr(p + (signed long int)1, 34);
        if(q == ((char *)NULL))
          break;

        *q = (char)0;
        if(!(p + 1l >= q))
        {
          tmp_post$2 = n;
          n = n + 1;
          args[(signed long int)tmp_post$2] = p + (signed long int)1;
        }

        q = q + 1l;
        p = q;
      }

      else
      {
        q=strsep(&p, sep);
        if(!(q == ((char *)NULL)))
        {
          if(!((signed int)*q == 0))
          {
            tmp_post$3 = n;
            n = n + 1;
            args[(signed long int)tmp_post$3] = q;
          }

        }

        else
          break;
      }

  ret:
    ;
    args[(signed long int)n] = (char *)(void *)0;
    return n;
  }
}

// nbDiscovery
// file packets6.h line 58
unsigned char * nbDiscovery(struct anonymous$0 *pc, struct anonymous$11 *dst)
{
  signed int i;
  signed int j;
  signed int waittime = 1000;
  struct timeval tv;
  _Bool tmp_if_expr$5;
  signed int return_value_timeout$1;
  signed int tmp_post$6;
  signed int return_value_timeout$7;
  static unsigned char mac[6l] = { (unsigned char)0x0, (unsigned char)0x0, (unsigned char)0x0, (unsigned char)0x0, (unsigned char)0x0, (unsigned char)0x0 };
  if((signed int)dst->uaddr._a16[0l] == 0x80fe)
  {
    mac[(signed long int)0] = (unsigned char)((signed int)dst->uaddr._a8[(signed long int)8] ^ 0x2);
    mac[(signed long int)1] = dst->uaddr._a8[(signed long int)9];
    mac[(signed long int)2] = dst->uaddr._a8[(signed long int)10];
    mac[(signed long int)3] = dst->uaddr._a8[(signed long int)13];
    mac[(signed long int)4] = dst->uaddr._a8[(signed long int)14];
    mac[(signed long int)5] = dst->uaddr._a8[(signed long int)15];
    return mac;
  }

  else
  {
    signed int return_value_sameNet6$4;
    return_value_sameNet6$4=sameNet6((char *)pc->ip6.ip.uaddr._a8, (char *)dst->uaddr._a8, pc->ip6.cidr);
    if(return_value_sameNet6$4 == 0)
      tmp_if_expr$5 = (signed int)dst->uaddr._a16[(signed long int)0] != 0x80fe ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
    {
      gettimeofday(&tv, (struct timezone *)(void *)0);
      do
      {
        return_value_timeout$1=timeout(tv, waittime);
        if(!(return_value_timeout$1 == 0))
          break;

        struct packet *m;
        signed int return_value_memcmp$2;
        return_value_memcmp$2=memcmp((const void *)pc->ip6.gmac, (const void *)(const char *)mac, (unsigned long int)6);
        if(!(return_value_memcmp$2 == 0))
          return pc->ip6.gmac;

        m=nbr_sol(pc);
        if(m == ((struct packet *)NULL))
        {
          printf("out of memory\n");
          return (unsigned char *)(void *)0;
        }

        enq(&pc->oq, m);
        usleep((unsigned int)(10 * 1000));
      }
      while((_Bool)1);
      return (unsigned char *)(void *)0;
    }

    else
    {
      i = 0;
      for( ; !(i >= 10); i = i + 1)
      {
        signed int return_value_sameNet6$3;
        return_value_sameNet6$3=sameNet6((char *)pc->ipmac6[(signed long int)i].ip.uaddr._a8, (char *)dst->uaddr._a8, 128);
        if(!(return_value_sameNet6$3 == 0))
          return pc->ipmac6[(signed long int)i].mac;

      }
    }
    i = 0;
    j = -1;
    do
    {
      tmp_post$6 = i;
      i = i + 1;
      if(tmp_post$6 >= 3)
        break;

      if(!(j == -1))
        break;

      struct packet *p;
      struct packet *nbDiscovery$$1$$4$$m;
      nbDiscovery$$1$$4$$m=nb_sol(pc, dst);
      if(nbDiscovery$$1$$4$$m == ((struct packet *)NULL))
      {
        printf("out of memory\n");
        return (unsigned char *)(void *)0;
      }

      enq(&pc->oq, nbDiscovery$$1$$4$$m);
      gettimeofday(&tv, (struct timezone *)(void *)0);
      do
      {
        return_value_timeout$7=timeout(tv, waittime);
        if(!(return_value_timeout$7 == 0))
          break;

        usleep((unsigned int)(1 * 1000));
        do
        {
          p=deq(&pc->iq);
          if(p == ((struct packet *)NULL))
            break;

          if(!(j == -1))
            break;

          j=nb_adv(pc, p, dst);
          free((void *)p);
        }
        while((_Bool)1);
      }
      while((_Bool)1);
    }
    while((_Bool)1);
    if(i >= 4)
      return (unsigned char *)(void *)0;

    else
      return pc->ipmac6[(signed long int)j].mac;
  }
}

// nb_adv
// file packets6.c line 829
static signed int nb_adv(struct anonymous$0 *pc, struct packet *m, struct anonymous$11 *dst)
{
  struct ethdr *eh;
  struct anonymous$18 *ip;
  struct anonymous$21 *nshdr;
  struct anonymous$22 *nsopt;
  signed int i;
  eh = (struct ethdr *)m->data;
  unsigned short int return_value_htons$1;
  return_value_htons$1=htons((unsigned short int)0x86DD);
  _Bool tmp_if_expr$5;
  signed int return_value_memcmp$4;
  _Bool tmp_if_expr$7;
  signed int return_value_memcmp$6;
  _Bool tmp_if_expr$10;
  if(!(eh->type == return_value_htons$1))
    return -1;

  else
  {
    signed int return_value_memcmp$2;
    return_value_memcmp$2=memcmp((const void *)eh->dst, (const void *)pc->ip4.mac, (unsigned long int)6);
    if(!(return_value_memcmp$2 == 0))
      return -1;

    else
    {
      ip = (struct anonymous$18 *)(eh + (signed long int)1);
      signed int return_value_memcmp$3;
      return_value_memcmp$3=memcmp((const void *)(&pc->ip6.ip)->uaddr._a8, (const void *)(&ip->dst)->uaddr._a8, (unsigned long int)16);
      if(!(return_value_memcmp$3 == 0))
      {
        return_value_memcmp$4=memcmp((const void *)(&pc->link6.ip)->uaddr._a8, (const void *)(&ip->dst)->uaddr._a8, (unsigned long int)16);
        tmp_if_expr$5 = !(!(return_value_memcmp$4 != 0)) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_memcmp$6=memcmp((const void *)dst->uaddr._a8, (const void *)(&ip->src)->uaddr._a8, (unsigned long int)16);
        tmp_if_expr$7 = !(!(return_value_memcmp$6 != 0)) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
        return -1;

      else
      {
        nshdr = (struct anonymous$21 *)(ip + (signed long int)1);
        nsopt = (struct anonymous$22 *)(nshdr + (signed long int)1);
        if(!((signed int)nshdr->hdr.type == 136))
          return -1;

        else
        {
          signed int return_value_memcmp$8;
          return_value_memcmp$8=memcmp((const void *)dst->uaddr._a8, (const void *)(&nshdr->target)->uaddr._a8, (unsigned long int)16);
          if(!(return_value_memcmp$8 == 0))
            return -1;

          else
            if(!((signed int)nsopt->type == 2))
              return -1;

            else
            {
              i = 0;
              while(!(i >= 10))
              {
                signed int return_value_memcmp$9;
                return_value_memcmp$9=memcmp((const void *)pc->ipmac6[(signed long int)i].ip.uaddr._a8, (const void *)ip->src.uaddr._a8, (unsigned long int)16);
                if(return_value_memcmp$9 == 0)
                {
                  if(!(time_tick + -((unsigned int)pc->ipmac6[(signed long int)i].timeout) >= 121u))
                    break;

                }

                if(pc->ipmac6[(signed long int)i].timeout == 0)
                  tmp_if_expr$10 = (_Bool)1;

                else
                  tmp_if_expr$10 = time_tick - (unsigned int)pc->ipmac6[(signed long int)i].timeout > (unsigned int)120 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$10)
                {
                  memcpy((void *)pc->ipmac6[(signed long int)i].mac, (const void *)nsopt->mac, (unsigned long int)6);
                  memcpy((void *)pc->ipmac6[(signed long int)i].ip.uaddr._a8, (const void *)ip->src.uaddr._a8, (unsigned long int)16);
                  pc->ipmac6[(signed long int)i].timeout = (signed int)time_tick;
                  pc->ipmac6[(signed long int)i].cidr = 128;
                  break;
                }

                i = i + 1;
              }
              if(i == 10)
              {
                i = 0;
                memcpy((void *)pc->ipmac6[(signed long int)i].mac, (const void *)nsopt->mac, (unsigned long int)6);
                memcpy((void *)pc->ipmac6[(signed long int)i].ip.uaddr._a8, (const void *)ip->src.uaddr._a8, (unsigned long int)16);
                pc->ipmac6[(signed long int)i].timeout = (signed int)time_tick;
              }

              return i;
            }
        }
      }
    }
  }
}

// nb_sol
// file packets6.c line 753
static struct packet * nb_sol(struct anonymous$0 *pc, struct anonymous$11 *dst)
{
  struct ethdr *eh;
  struct anonymous$18 *ip;
  struct anonymous$21 *nshdr;
  struct anonymous$22 *nsopt;
  struct packet *m;
  signed int len = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct anonymous$18) /*40ul*/  + sizeof(struct anonymous$21) /*24ul*/  + sizeof(struct anonymous$22) /*8ul*/ );
  m=new_pkt(len);
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    len = (signed int)(sizeof(struct anonymous$21) /*24ul*/  + sizeof(struct anonymous$22) /*8ul*/ );
    eh = (struct ethdr *)m->data;
    memcpy((void *)eh->src, (const void *)pc->ip4.mac, (unsigned long int)6);
    eh->type=htons((unsigned short int)0x86DD);
    ip = (struct anonymous$18 *)(eh + (signed long int)1);
    ip->ip6_ctlun.ip6_un1.ip6_un1_flow = (unsigned int)0;
    ip->ip6_ctlun.ip6_un2_vfc = ip->ip6_ctlun.ip6_un2_vfc & (unsigned char)~0xf0;
    ip->ip6_ctlun.ip6_un2_vfc = ip->ip6_ctlun.ip6_un2_vfc | (unsigned char)0x60;
    ip->ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)58;
    ip->ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)255;
    if((signed int)dst->uaddr._a16[0l] == 0x80fe)
      memcpy((void *)ip->src.uaddr._a8, (const void *)pc->link6.ip.uaddr._a8, (unsigned long int)16);

    else
      memcpy((void *)ip->src.uaddr._a8, (const void *)pc->ip6.ip.uaddr._a8, (unsigned long int)16);
    ip->dst.uaddr._a16[(signed long int)0] = (unsigned short int)0x02ff;
    ip->dst.uaddr._a16[(signed long int)1] = (unsigned short int)0;
    ip->dst.uaddr._a32[(signed long int)1] = (unsigned int)0;
    ip->dst.uaddr._a32[(signed long int)2] = (unsigned int)0x01000000;
    ip->dst.uaddr._a32[(signed long int)3] = dst->uaddr._a32[(signed long int)3];
    ip->dst.uaddr._a8[(signed long int)12] = (unsigned char)0xff;
    eh->dst[(signed long int)0] = (unsigned char)0x33;
    eh->dst[(signed long int)1] = (unsigned char)0x33;
    eh->dst[(signed long int)2] = ip->dst.uaddr._a8[(signed long int)12];
    eh->dst[(signed long int)3] = ip->dst.uaddr._a8[(signed long int)13];
    eh->dst[(signed long int)4] = ip->dst.uaddr._a8[(signed long int)14];
    eh->dst[(signed long int)5] = ip->dst.uaddr._a8[(signed long int)15];
    nshdr = (struct anonymous$21 *)(ip + (signed long int)1);
    nshdr->hdr.type = (unsigned char)135;
    nshdr->hdr.code = (unsigned char)0;
    nshdr->hdr.icmp6_dataun.icmp6_un_data32[(signed long int)0] = (unsigned int)0;
    memcpy((void *)nshdr->target.uaddr._a8, (const void *)dst->uaddr._a8, (unsigned long int)16);
    nsopt = (struct anonymous$22 *)(nshdr + (signed long int)1);
    nsopt->type = (unsigned char)1;
    nsopt->len = (unsigned char)1;
    memcpy((void *)nsopt->mac, (const void *)pc->ip4.mac, (unsigned long int)6);
    len = (signed int)(sizeof(struct anonymous$21) /*24ul*/  + sizeof(struct anonymous$22) /*8ul*/ );
    ip->ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)len);
    nshdr->hdr.cksum = (unsigned short int)0;
    nshdr->hdr.cksum=cksum6(ip, (unsigned char)58, len);
    return m;
  }
}

// nbr_sol
// file packets6.h line 59
struct packet * nbr_sol(struct anonymous$0 *pc)
{
  struct ethdr *eh;
  struct anonymous$18 *ip;
  struct anonymous$20 *icmp;
  struct packet *m;
  signed int len = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct anonymous$18) /*40ul*/  + sizeof(struct anonymous$20) /*8ul*/ );
  m=new_pkt(len);
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    len = (signed int)sizeof(struct anonymous$20) /*8ul*/ ;
    eh = (struct ethdr *)m->data;
    memcpy((void *)eh->src, (const void *)pc->ip4.mac, (unsigned long int)6);
    eh->type=htons((unsigned short int)0x86DD);
    ip = (struct anonymous$18 *)(eh + (signed long int)1);
    ip->ip6_ctlun.ip6_un1.ip6_un1_flow = (unsigned int)0;
    ip->ip6_ctlun.ip6_un2_vfc = ip->ip6_ctlun.ip6_un2_vfc & (unsigned char)~0xf0;
    ip->ip6_ctlun.ip6_un2_vfc = ip->ip6_ctlun.ip6_un2_vfc | (unsigned char)0x60;
    ip->ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)58;
    ip->ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)255;
    memcpy((void *)ip->src.uaddr._a8, (const void *)pc->ip6.ip.uaddr._a8, (unsigned long int)16);
    ip->dst.uaddr._a16[(signed long int)0] = (unsigned short int)0x02ff;
    ip->dst.uaddr._a16[(signed long int)1] = (unsigned short int)0;
    ip->dst.uaddr._a32[(signed long int)1] = (unsigned int)0;
    ip->dst.uaddr._a32[(signed long int)2] = (unsigned int)0;
    ip->dst.uaddr._a32[(signed long int)3] = (unsigned int)0x02000000;
    eh->dst[(signed long int)0] = (unsigned char)0x33;
    eh->dst[(signed long int)1] = (unsigned char)0x33;
    eh->dst[(signed long int)5] = (unsigned char)2;
    icmp = (struct anonymous$20 *)(ip + (signed long int)1);
    icmp->type = (unsigned char)133;
    icmp->code = (unsigned char)0;
    len = (signed int)sizeof(struct anonymous$20) /*8ul*/ ;
    ip->ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)len);
    icmp->cksum = (unsigned short int)0;
    icmp->cksum=cksum6(ip, (unsigned char)58, len);
    return m;
  }
}

// new_pkt
// file queue.h line 68
struct packet * new_pkt(signed int len)
{
  struct packet *m = (struct packet *)(void *)0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(((unsigned long int)len + sizeof(struct packet) /*40ul*/ ) - (unsigned long int)1);
  m = (struct packet *)return_value_malloc$1;
  if(!(m == ((struct packet *)NULL)))
  {
    memset((void *)m, 0, ((unsigned long int)len + sizeof(struct packet) /*40ul*/ ) - (unsigned long int)1);
    m->len = len;
    return m;
  }

  else
    return (struct packet *)(void *)0;
}

// open_dev
// file dev.h line 32
signed int open_dev(signed int id)
{
  signed int fd = 0;
  switch(devtype)
  {
    case 1:
    {
      fd=open_tap(id);
      if(!(fd >= 1))
      {
        fd = 0;
        return 0;
      }

      goto __CPROVER_DUMP_L4;
    }
    case 2:
    {
      fd=open_udp(vpc[(signed long int)id].lport);
      if(!(fd >= 1))
      {
        fd = 0;
        return 0;
      }

    }
    default:
    {

    __CPROVER_DUMP_L4:
      ;
      return fd;
    }
  }
}

// open_remote
// file remote.h line 30
signed int open_remote(signed int fdio, const char *destip, const unsigned short int destport)
{
  signed int s;
  struct sockaddr_in addr_in;
  struct termios termios;
  char kb[512l];
  unsigned char outbuf[512l];
  signed int rc;
  signed int i;
  struct timeval tv;
  struct anonymous$14 fset;
  unsigned int return_value_inet_addr$1;
  return_value_inet_addr$1=inet_addr(destip);
  i = (signed int)return_value_inet_addr$1;
  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  if(i == -1)
  {
    printf("Invalid IP address\n");
    return 0;
  }

  else
  {
    s=socket(2, 1, 0);
    if(s == -1)
      return 0;

    else
    {
      bzero((void *)&addr_in, sizeof(struct sockaddr_in) /*16ul*/ );
      addr_in.sin_family = (unsigned short int)2;
      addr_in.sin_addr.s_addr=inet_addr(destip);
      addr_in.sin_port=htons(destport);
      static struct _IO_FILE *fpio;
      fpio=fdopen(fdio, "w");
      rc=connect(s, (struct sockaddr *)&addr_in, (unsigned int)sizeof(struct sockaddr) /*16ul*/ );
      if(!(rc >= 0))
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        if(*return_value___errno_location$8 == 115)
        {
          do
          {
            signed int __d0;
            signed int __d1;
            asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fset)->__fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
          (&fset)->__fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fset)->__fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << s % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
          tv.tv_sec = (signed long int)5;
          tv.tv_usec = (signed long int)0;
          rc=select(s + 1, &fset, (struct anonymous$14 *)(void *)0, (struct anonymous$14 *)(void *)0, &tv);
          if(rc >= 1)
            tmp_if_expr$7 = ((&fset)->__fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << s % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          if(tmp_if_expr$7)
          {
            i = (signed int)sizeof(signed int) /*4ul*/ ;
            getsockopt(s, 1, 4, (void *)&rc, (unsigned int *)&i);
            if(rc == 0)
              goto next;

            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            if(*return_value___errno_location$4 == 115)
              fprintf(fpio, "Connect timeout\n");

            else
            {
              return_value___errno_location$2=__errno_location();
              return_value_strerror$3=strerror(*return_value___errno_location$2);
              fprintf(fpio, "Connect failed: %s\n", return_value_strerror$3);
            }
          }

          else
            if(rc == 0)
              fprintf(fpio, "Connect timeout\n");

            else
            {
              return_value___errno_location$5=__errno_location();
              return_value_strerror$6=strerror(*return_value___errno_location$5);
              fprintf(fpio, "Connect error: %s\n", return_value_strerror$6);
            }
          fflush(fpio);
          close(s);
          return 1;
        }

      }


    next:
      ;
      set_terminal(fdio, &termios);
      fprintf(fpio, "\r\nConnect %s:%d, press Ctrl+X to quit\r\n", destip, destport);
      fprintf(fpio, "NOTES: you will be back to the starting point, NOT THE LAST, \r\n       if using Ctrl+X to quit.\r\n");
      fflush(fpio);
      while((_Bool)1)
      {
        kb[(signed long int)0] = (char)0xff;
        signed long int return_value_write$9;
        return_value_write$9=write(s, (const void *)kb, (unsigned long int)1);
        if(!(return_value_write$9 >= 0l))
          break;

        do
        {
          signed int open_remote$$1$$3$$1$$__d0;
          signed int open_remote$$1$$3$$1$$__d1;
          asm("cld; rep; stosq" : "=c"(open_remote$$1$$3$$1$$__d0), "=D"(open_remote$$1$$3$$1$$__d1) : "a"(0), "0"(sizeof(struct anonymous$14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fset)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&fset)->__fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fset)->__fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << s % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        (&fset)->__fds_bits[(signed long int)(fdio / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fset)->__fds_bits[(signed long int)(fdio / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fdio % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        tv.tv_sec = (signed long int)5;
        tv.tv_usec = (signed long int)0;
        rc=select(fdio > s ? fdio + 1 : s + 1, &fset, (struct anonymous$14 *)(void *)0, (struct anonymous$14 *)(void *)0, &tv);
        if(!(rc >= 0))
          break;

        if(!(rc == 0))
        {
          if(!((fset.__fds_bits[(signed long int)(s / 8)] & (signed long int)(1UL << s % 8)) == 0l))
          {
            signed long int return_value_read$10;
            return_value_read$10=read(s, (void *)outbuf, sizeof(unsigned char [512l]) /*512ul*/ );
            rc = (signed int)return_value_read$10;
            if(!(rc >= 0))
              break;

            if(rc >= 1)
            {
              i = 0;
              for( ; (signed int)outbuf[(signed long int)i] == 0xff; i = i + 3)
                if(i >= rc)
                  break;

              if(!(i >= rc))
              {
                signed long int return_value_write$11;
                return_value_write$11=write(fdio, (const void *)(outbuf + (signed long int)i), (unsigned long int)(rc - i));
                rc = (signed int)return_value_write$11;
                if(!(rc >= 0))
                  break;

              }

            }

          }

          if(!((fset.__fds_bits[(signed long int)(fdio / 8)] & (signed long int)(1UL << fdio % 8)) == 0l))
          {
            signed long int return_value_read$12;
            return_value_read$12=read(fdio, (void *)kb, sizeof(char [512l]) /*512ul*/ );
            rc = (signed int)return_value_read$12;
            if(!(rc >= 0))
              break;

            if((signed int)kb[0l] == 24)
              break;

            if((signed int)kb[0l] == 10)
            {
              signed long int return_value_write$13;
              return_value_write$13=write(s, (const void *)"\r", (unsigned long int)1);
              rc = (signed int)return_value_write$13;
              if(!(rc >= 0))
                break;

              continue;
            }

            if(rc >= 1)
            {
              signed long int return_value_write$14;
              return_value_write$14=write(s, (const void *)kb, (unsigned long int)rc);
              rc = (signed int)return_value_write$14;
              if(!(rc >= 0))
                break;

            }

          }

        }

      }
      close(s);
      fprintf(fpio, "\r\nDisconnected from %s:%d\r\n", destip, destport);
      fflush(fpio);
      reset_terminal(fdio, &termios);
      return 0;
    }
  }
}

// open_tap
// file dev.c line 164
signed int open_tap(signed int id)
{
  struct ifreq ifr;
  signed int fd;
  char dev[12l];
  unsigned long int return_value_strlen$1;
  if(num_pths >= 2)
    sprintf(dev, "tap%d", id);

  else
  {
    return_value_strlen$1=strlen(tapname);
    if(return_value_strlen$1 >= 16ul)
      return -1;

  }
  sprintf(dev, "%s", tapname);
  fd=open("/dev/net/tun", 02);
  if(!(fd >= 0))
    return -1;

  else
  {
    memset((void *)&ifr, 0, sizeof(struct ifreq) /*40ul*/ );
    ifr.ifr_ifru.ifru_flags = (signed short int)(0x0002 | 0x1000);
    strncpy(ifr.ifr_ifrn.ifrn_name, dev, (unsigned long int)12);
    signed int return_value_ioctl$2;
    return_value_ioctl$2=ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(84 << 0 + 8) | (unsigned int)(202 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, (void *)&ifr);
    if(!(return_value_ioctl$2 >= 0))
    {
      close(fd);
      return -1;
    }

    else
      return fd;
  }
}

// open_udp
// file dev.h line 33
signed int open_udp(signed int port)
{
  signed int s;
  struct sockaddr_in addr_in;
  s=socket(2, 2, 0);
  if(s == -1)
    return 0;

  else
  {
    bzero((void *)&addr_in, sizeof(struct sockaddr_in) /*16ul*/ );
    addr_in.sin_family = (unsigned short int)2;
    addr_in.sin_addr.s_addr=htonl((unsigned int)0x00000000);
    addr_in.sin_port=htons((unsigned short int)port);
    signed int return_value_bind$1;
    return_value_bind$1=bind(s, (struct sockaddr *)&addr_in, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(return_value_bind$1 == -1)
    {
      close(s);
      return 0;
    }

    else
      return s;
  }
}

// packet
// file packets.c line 295
struct packet * packet(struct sesscb *sesscb)
{
  struct ethdr *eh;
  struct iphdr *ip;
  signed int i;
  struct packet *m;
  signed int dlen = 0;
  signed int hdr_len = 0;
  signed int frag = 0;
  char b[9l];
  dlen = sesscb->dsize;
  switch(sesscb->proto)
  {
    case 1:
    {
      hdr_len = (signed int)(sizeof(struct iphdr) /*20ul*/  + sizeof(struct icmphdr) /*8ul*/ );
      break;
    }
    case 17:
    {
      hdr_len = (signed int)(sizeof(struct iphdr) /*20ul*/  + sizeof(struct anonymous$24) /*8ul*/ );
      break;
    }
    case 6:
    {
      if(!((signed int)sesscb->flags == 24))
        dlen = 0;

      if((signed int)sesscb->flags == 0x02)
        dlen = 4 + 2 + 2 + 8 + 1 + 3;

      else
        dlen = dlen + 2 + 2 + 8;
      if(!((signed int)sesscb->rmss == 0))
      {
        if(!((signed int)sesscb->rmss >= dlen))
          dlen = (signed int)((((unsigned long int)sesscb->rmss - sizeof(struct ethdr) /*14ul*/ ) - sizeof(struct iphdr) /*20ul*/ ) - sizeof(struct tcphdr) /*20ul*/ );

      }

      hdr_len = (signed int)(sizeof(struct iphdr) /*20ul*/  + sizeof(struct tcphdr) /*20ul*/ );
    }
  }
  if(!(sesscb->mtu + -hdr_len >= dlen))
    dlen = sesscb->mtu - hdr_len;

  m=new_pkt((signed int)(sizeof(struct ethdr) /*14ul*/  + (unsigned long int)hdr_len + (unsigned long int)dlen));
  unsigned int tmp_post$1;
  char *tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  char *tmp_post$8;
  char *tmp_post$9;
  char *tmp_post$10;
  char *tmp_post$11;
  char *tmp_post$12;
  char *tmp_post$13;
  char *tmp_post$14;
  char *tmp_post$15;
  char *tmp_post$16;
  char *tmp_post$17;
  char *tmp_post$18;
  char *tmp_post$19;
  char *tmp_post$20;
  char *tmp_post$21;
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    eh = (struct ethdr *)m->data;
    ip = (struct iphdr *)(eh + (signed long int)1);
    ip->ver = (unsigned int)4;
    ip->ihl = (unsigned int)(sizeof(struct iphdr) /*20ul*/  >> 2);
    ip->len=htons((unsigned short int)(hdr_len + dlen));
    tmp_post$1 = sesscb->ipid;
    sesscb->ipid = sesscb->ipid + 1u;
    ip->id=htons((unsigned short int)tmp_post$1);
    if(frag == 0)
      ip->frag=htons((unsigned short int)0x4000);

    else
      ip->frag=htons((unsigned short int)0x2000);
    ip->ttl = sesscb->ttl;
    ip->proto = (unsigned char)sesscb->proto;
    ip->sip = sesscb->sip;
    ip->dip = sesscb->dip;
    if(sesscb->proto == 1)
    {
      struct icmphdr *icmp = (struct icmphdr *)(ip + (signed long int)1);
      char *packet$$1$$2$$data = (char *)(icmp + (signed long int)1);
      icmp->seq=htons((unsigned short int)sesscb->sn);
      icmp->cksum = (unsigned short int)0;
      icmp->type = (unsigned char)8;
      icmp->code = (unsigned char)0;
      signed long int return_value_time$2;
      return_value_time$2=time(((signed long int *)NULL));
      icmp->id = (unsigned short int)(return_value_time$2 & (signed long int)0xffff);
      i = 0;
      for( ; !(i >= dlen); i = i + 1)
        packet$$1$$2$$data[(signed long int)i] = (char)((unsigned long int)i + sizeof(struct icmphdr) /*8ul*/  & (unsigned long int)0xff);
      icmp->cksum=cksum((unsigned short int *)icmp, (signed int)((unsigned long int)(hdr_len + dlen) - sizeof(struct iphdr) /*20ul*/ ));
    }

    else
      if(sesscb->proto == 17)
      {
        struct udpiphdr *ui = (struct udpiphdr *)ip;
        char *data = (char *)(ui + (signed long int)1);
        ui->ui_u.sport=htons((unsigned short int)sesscb->sport);
        ui->ui_u.dport=htons((unsigned short int)sesscb->dport);
        ui->ui_u.len=htons((unsigned short int)((unsigned long int)(hdr_len + dlen) - sizeof(struct iphdr) /*20ul*/ ));
        ui->ui_u.cksum = (unsigned short int)0;
        if(!(sesscb->data == ((char *)NULL)))
          memcpy((void *)data, (const void *)sesscb->data, (unsigned long int)dlen);

        else
        {
          memcpy((void *)data, (const void *)sesscb->smac, (unsigned long int)6);
          i = 6;
          for( ; !(i >= dlen); i = i + 1)
            data[(signed long int)i] = (char)((unsigned long int)i + sizeof(struct anonymous$24) /*8ul*/  & (unsigned long int)0xff);
        }
        bcopy((const void *)((struct ipovly *)ip)->ih_x1, (void *)b, (unsigned long int)9);
        bzero((void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
        ui->ui_i.ih_len = ui->ui_u.len;
        ui->ui_u.cksum=cksum((unsigned short int *)ui, hdr_len + dlen);
        bcopy((const void *)b, (void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
      }

      else
        if(sesscb->proto == 6)
        {
          struct tcpiphdr *ti = (struct tcpiphdr *)ip;
          char *packet$$1$$4$$data = (char *)(ti + (signed long int)1);
          unsigned int t;
          signed long int return_value_time$3;
          return_value_time$3=time(((signed long int *)NULL));
          t=htonl((unsigned int)return_value_time$3);
          signed int optlen = 0;
          ti->ti_t.th_sport=htons((unsigned short int)sesscb->sport);
          ti->ti_t.th_dport=htons((unsigned short int)sesscb->dport);
          ti->ti_i.ih_len=htons((unsigned short int)((unsigned long int)(hdr_len + dlen) - sizeof(struct iphdr) /*20ul*/ ));
          ti->ti_t.th_ack=htonl(sesscb->ack);
          ti->ti_t.th_seq=htonl(sesscb->seq);
          ti->ti_t.th_win=htons(sesscb->winsize);
          ti->ti_t.th_sum = (unsigned short int)0;
          ti->ti_t.th_flags = sesscb->flags;
          if((signed int)sesscb->flags == 0x02)
          {
            tmp_post$4 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$4 = (char)2;
            tmp_post$5 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$5 = (char)4;
            tmp_post$6 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$6 = (char)0x5;
            tmp_post$7 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$7 = (char)0xb4;
            tmp_post$8 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$8 = (char)0x1;
            tmp_post$9 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$9 = (char)0x1;
            tmp_post$10 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$10 = (char)8;
            tmp_post$11 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$11 = (char)10;
            memcpy((void *)packet$$1$$4$$data, (const void *)(char *)&t, (unsigned long int)4);
            packet$$1$$4$$data = packet$$1$$4$$data + (signed long int)8;
            tmp_post$12 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$12 = (char)0x1;
            tmp_post$13 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$13 = (char)3;
            tmp_post$14 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$14 = (char)3;
            tmp_post$15 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$15 = (char)1;
          }

          else
          {
            tmp_post$16 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$16 = (char)0x1;
            tmp_post$17 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$17 = (char)0x1;
            tmp_post$18 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$18 = (char)8;
            tmp_post$19 = packet$$1$$4$$data;
            packet$$1$$4$$data = packet$$1$$4$$data + 1l;
            *tmp_post$19 = (char)10;
            memcpy((void *)packet$$1$$4$$data, (const void *)(char *)&t, (unsigned long int)4);
            packet$$1$$4$$data = packet$$1$$4$$data + (signed long int)8;
          }
          optlen = (signed int)(packet$$1$$4$$data - (char *)(ti + (signed long int)1));
          ti->ti_t.th_off = (unsigned int)(sizeof(struct tcphdr) /*20ul*/  + (unsigned long int)optlen >> 2);
          i = optlen;
          for( ; !(i >= dlen); i = i + 1)
            if(i % 2 == 0)
            {
              tmp_post$20 = packet$$1$$4$$data;
              packet$$1$$4$$data = packet$$1$$4$$data + 1l;
              *tmp_post$20 = (char)0xd;
            }

            else
            {
              tmp_post$21 = packet$$1$$4$$data;
              packet$$1$$4$$data = packet$$1$$4$$data + 1l;
              *tmp_post$21 = (char)0xa;
            }
          bcopy((const void *)((struct ipovly *)ip)->ih_x1, (void *)b, (unsigned long int)9);
          bzero((void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
          ti->ti_t.th_sum=cksum((unsigned short int *)ti, hdr_len + dlen);
          bcopy((const void *)b, (void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
        }

    ip->cksum = (unsigned short int)0;
    ip->cksum=cksum((unsigned short int *)ip, (signed int)sizeof(struct iphdr) /*20ul*/ );
    encap_ehead(m->data, sesscb->smac, sesscb->dmac, (const unsigned short int)0x0800);
    return m;
  }
}

// packet6
// file packets6.h line 52
struct packet * packet6(struct sesscb *sesscb)
{
  signed int dlen = 0;
  signed int len = 0;
  signed int i;
  struct packet *m = (struct packet *)(void *)0;
  struct ethdr *eh;
  struct anonymous$18 *ip;
  if(!(sesscb->dsize >= 60000))
    dlen = sesscb->dsize;

  len = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct anonymous$18) /*40ul*/ );
  switch(sesscb->proto)
  {
    case 58:
    {
      len = len + (signed int)(sizeof(struct anonymous$20) /*8ul*/  + (unsigned long int)dlen);
      break;
    }
    case 17:
    {
      if(!(dlen >= 6))
        dlen = 6;

      len = len + (signed int)(sizeof(struct anonymous$24) /*8ul*/  + (unsigned long int)dlen);
      break;
    }
    case 6:
    {
      if(!((signed int)sesscb->flags == 24))
        dlen = 0;

      if((signed int)sesscb->flags == 0x02)
        dlen = 4 + 2 + 2 + 8 + 1 + 3;

      else
        dlen = dlen + 2 + 2 + 8;
      if(!((signed int)sesscb->rmss == 0))
      {
        if(!((signed int)sesscb->rmss >= dlen))
          dlen = (signed int)((((unsigned long int)sesscb->rmss - sizeof(struct ethdr) /*14ul*/ ) - sizeof(struct iphdr) /*20ul*/ ) - sizeof(struct tcphdr) /*20ul*/ );

      }

      len = len + (signed int)(sizeof(struct tcphdr) /*20ul*/  + (unsigned long int)dlen);
    }
  }
  m=new_pkt(len);
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  char *tmp_post$8;
  char *tmp_post$9;
  char *tmp_post$10;
  char *tmp_post$11;
  char *tmp_post$12;
  char *tmp_post$13;
  char *tmp_post$14;
  char *tmp_post$15;
  char *tmp_post$16;
  char *tmp_post$17;
  char *tmp_post$18;
  char *tmp_post$19;
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    eh = (struct ethdr *)m->data;
    memcpy((void *)eh->src, (const void *)sesscb->smac, (unsigned long int)6);
    memcpy((void *)eh->dst, (const void *)sesscb->dmac, (unsigned long int)6);
    eh->type=htons((unsigned short int)0x86DD);
    ip = (struct anonymous$18 *)(eh + (signed long int)1);
    ip->ip6_ctlun.ip6_un1.ip6_un1_flow = (unsigned int)0;
    ip->ip6_ctlun.ip6_un2_vfc = ip->ip6_ctlun.ip6_un2_vfc & (unsigned char)~0xf0;
    ip->ip6_ctlun.ip6_un2_vfc = ip->ip6_ctlun.ip6_un2_vfc | (unsigned char)0x60;
    ip->ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)sesscb->proto;
    ip->ip6_ctlun.ip6_un1.ip6_un1_hlim = sesscb->ttl;
    ip->ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)(((unsigned long int)len - sizeof(struct ethdr) /*14ul*/ ) - sizeof(struct anonymous$18) /*40ul*/ ));
    memcpy((void *)ip->src.uaddr._a8, (const void *)sesscb->sip6.uaddr._a8, (unsigned long int)16);
    memcpy((void *)ip->dst.uaddr._a8, (const void *)sesscb->dip6.uaddr._a8, (unsigned long int)16);
    if(sesscb->proto == 58)
    {
      struct anonymous$20 *icmp = (struct anonymous$20 *)(ip + (signed long int)1);
      icmp->type = (unsigned char)128;
      icmp->icmp6_dataun.icmp6_un_data16[(signed long int)0] = (unsigned short int)sesscb->ipid;
      icmp->icmp6_dataun.icmp6_un_data16[(signed long int)1]=htons((unsigned short int)sesscb->sn);
      i = 0;
      for( ; !(i >= dlen); i = i + 1)
        m->data[(signed long int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct anonymous$18) /*40ul*/  + sizeof(struct anonymous$20) /*8ul*/  + (unsigned long int)i)] = (char)i;
      icmp->cksum = (unsigned short int)0;
      icmp->cksum=cksum6(ip, (unsigned char)58, (signed int)(((unsigned long int)len - sizeof(struct ethdr) /*14ul*/ ) - sizeof(struct anonymous$18) /*40ul*/ ));
    }

    else
      if(sesscb->proto == 17)
      {
        struct anonymous$24 *ui = (struct anonymous$24 *)(ip + (signed long int)1);
        char *data = (char *)(ui + (signed long int)1);
        ui->sport=htons((unsigned short int)sesscb->sport);
        ui->dport=htons((unsigned short int)sesscb->dport);
        ui->len=htons((unsigned short int)(((unsigned long int)len - sizeof(struct ethdr) /*14ul*/ ) - sizeof(struct anonymous$18) /*40ul*/ ));
        memcpy((void *)data, (const void *)sesscb->smac, (unsigned long int)6);
        i = 6;
        for( ; !(i >= dlen); i = i + 1)
          data[(signed long int)i] = (char)((unsigned long int)i + sizeof(struct anonymous$24) /*8ul*/ );
        ui->cksum = (unsigned short int)0;
        ui->cksum=cksum6(ip, (unsigned char)17, (signed int)(((unsigned long int)len - sizeof(struct ethdr) /*14ul*/ ) - sizeof(struct anonymous$18) /*40ul*/ ));
      }

      else
        if(sesscb->proto == 6)
        {
          struct tcphdr *th = (struct tcphdr *)(ip + (signed long int)1);
          char *packet6$$1$$4$$data = (char *)(th + (signed long int)1);
          unsigned int t;
          signed long int return_value_time$1;
          return_value_time$1=time(((signed long int *)NULL));
          t=htonl((unsigned int)return_value_time$1);
          signed int optlen = 0;
          th->th_sport=htons((unsigned short int)sesscb->sport);
          th->th_dport=htons((unsigned short int)sesscb->dport);
          th->th_ack=htonl(sesscb->ack);
          th->th_seq=htonl(sesscb->seq);
          th->th_win=htons(sesscb->winsize);
          th->th_flags = sesscb->flags;
          if((signed int)sesscb->flags == 0x02)
          {
            tmp_post$2 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$2 = (char)2;
            tmp_post$3 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$3 = (char)4;
            tmp_post$4 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$4 = (char)0x5;
            tmp_post$5 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$5 = (char)0xb4;
            tmp_post$6 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$6 = (char)0x1;
            tmp_post$7 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$7 = (char)0x1;
            tmp_post$8 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$8 = (char)8;
            tmp_post$9 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$9 = (char)10;
            memcpy((void *)packet6$$1$$4$$data, (const void *)(char *)&t, (unsigned long int)4);
            packet6$$1$$4$$data = packet6$$1$$4$$data + (signed long int)8;
            tmp_post$10 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$10 = (char)0x1;
            tmp_post$11 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$11 = (char)3;
            tmp_post$12 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$12 = (char)3;
            tmp_post$13 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$13 = (char)1;
          }

          else
          {
            tmp_post$14 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$14 = (char)0x1;
            tmp_post$15 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$15 = (char)0x1;
            tmp_post$16 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$16 = (char)8;
            tmp_post$17 = packet6$$1$$4$$data;
            packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
            *tmp_post$17 = (char)10;
            memcpy((void *)packet6$$1$$4$$data, (const void *)(char *)&t, (unsigned long int)4);
            packet6$$1$$4$$data = packet6$$1$$4$$data + (signed long int)8;
          }
          optlen = (signed int)(packet6$$1$$4$$data - (char *)(th + (signed long int)1));
          th->th_off = (unsigned int)(sizeof(struct tcphdr) /*20ul*/  + (unsigned long int)optlen >> 2);
          i = optlen;
          for( ; !(i >= dlen); i = i + 1)
            if(i % 2 == 0)
            {
              tmp_post$18 = packet6$$1$$4$$data;
              packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
              *tmp_post$18 = (char)0xd;
            }

            else
            {
              tmp_post$19 = packet6$$1$$4$$data;
              packet6$$1$$4$$data = packet6$$1$$4$$data + 1l;
              *tmp_post$19 = (char)0xa;
            }
          th->th_sum = (unsigned short int)0;
          th->th_sum=cksum6(ip, (unsigned char)6, (signed int)(((unsigned long int)len - sizeof(struct ethdr) /*14ul*/ ) - sizeof(struct anonymous$18) /*40ul*/ ));
        }

    return m;
  }
}

// parse_cmd
// file vpcs.c line 278
void parse_cmd(char *cmdstr)
{
  struct stub$0 *ep = (struct stub$0 *)(void *)0;
  struct stub$0 *cmd = (struct stub$0 *)(void *)0;
  char *argv[20l];
  signed int argc = 0;
  signed int rc = 0;
  argc=mkargv(cmdstr, (char **)argv, 20);
  unsigned long int return_value_strlen$1;
  signed int return_value_strcmp$5;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$12;
  signed int return_value_digitstring$11;
  signed int return_value_strcmp$15;
  _Bool tmp_if_expr$17;
  signed int return_value_strcmp$16;
  if(!(argc == 0))
  {
    if(argc == 1)
    {
      return_value_strlen$1=strlen(argv[(signed long int)0]);
      if(!(return_value_strlen$1 == 1ul))
        goto __CPROVER_DUMP_L3;

      if(!(num_pths >= 2))
        goto __CPROVER_DUMP_L3;

      if(!((signed int)*argv[0l] + -48 >= 1))
        goto __CPROVER_DUMP_L3;

      if(!(num_pths >= (signed int)*argv[0l] + -48))
        goto __CPROVER_DUMP_L3;

      if(!(canEcho == 0) && !(runLoad == 0))
        printf("%s[%d] %s\n", (const void *)vpc[(signed long int)pcid].xname, pcid + 1, cmdstr);

      pcid = ((signed int)argv[(signed long int)0][(signed long int)0] - 48) - 1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      rc = 0;
      printf("\n");
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(argv[(signed long int)0], "srcid");
      if(return_value_strcmp$2 == 0)
        printf("Source code ID: %s\n", ident);

      else
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(argv[(signed long int)0]);
        signed int return_value_strncmp$4;
        return_value_strncmp$4=strncmp(argv[(signed long int)0], "echo", return_value_strlen$3);
        if(return_value_strncmp$4 == 0)
        {
          char *p = (char *)(void *)0;
          p=strchr(cmdstr, 32);
          if(!(p == ((char *)NULL)))
            printf("%s", p + (signed long int)1);

          else
          {
            p=strchr(cmdstr, 9);
            if(!(p == ((char *)NULL)))
              printf("%s", p + (signed long int)1);

          }
          fflush(stdout);
          goto __CPROVER_DUMP_L38;
        }

        if((signed int)*cmdstr == 33)
        {
          char *parse_cmd$$1$$4$$p = (char *)(void *)0;
          unsigned long int return_value_strlen$6;
          return_value_strlen$6=strlen(cmdstr);
          if(return_value_strlen$6 >= 2ul)
          {
            parse_cmd$$1$$4$$p = cmdstr + (signed long int)1;
            for( ; (_Bool)1; parse_cmd$$1$$4$$p = parse_cmd$$1$$4$$p + 1l)
              if(!((signed int)*parse_cmd$$1$$4$$p == 32))
              {
                if(!((signed int)*parse_cmd$$1$$4$$p == 9))
                  goto __CPROVER_DUMP_L10;

              }


          __CPROVER_DUMP_L10:
            ;
            if(!(*parse_cmd$$1$$4$$p == 0))
            {
              return_value_strcmp$5=strcmp(parse_cmd$$1$$4$$p, "?");
              if(!(return_value_strcmp$5 == 0))
              {
                invoke_cmd(parse_cmd$$1$$4$$p);
                goto __CPROVER_DUMP_L38;
              }

            }

          }

          help_shell(0, (char **)(void *)0);
          goto __CPROVER_DUMP_L38;
        }

        ep = cmd_entry;
        for( ; !(ep->name == ((char *)NULL)); ep = ep + 1l)
        {
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(argv[(signed long int)0]);
          signed int return_value_strncmp$8;
          return_value_strncmp$8=strncmp(argv[(signed long int)0], ep->name, return_value_strlen$7);
          if(return_value_strncmp$8 == 0)
          {
            if(!(cmd == ((struct stub$0 *)NULL)))
              printf("%s\n", cmd->name);

            cmd = ep;
            rc = rc + 1;
          }

        }
        if(rc >= 2)
          printf("%s\n", cmd->name);

        else
        {
          if(!(cmd == ((struct stub$0 *)NULL)))
            tmp_if_expr$18 = cmd->name != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$18 = (_Bool)0;
          if(tmp_if_expr$18)
          {
            if(!(cmd->grpname == ((char *)NULL)))
            {
              argc=insert_argv(argc, argv, cmd->grpname);
              ep = cmd_entry;
              for( ; !(ep->name == ((char *)NULL)); ep = ep + 1l)
              {
                signed int return_value_strcmp$9;
                return_value_strcmp$9=strcmp(argv[(signed long int)0], ep->name);
                if(return_value_strcmp$9 == 0)
                {
                  cmd = ep;
                  break;
                }

              }
            }

            if(!(canEcho == 0) && !(runLoad == 0))
            {
              signed int return_value_strcmp$10;
              return_value_strcmp$10=strcmp(cmd->name, "sleep");
              if(return_value_strcmp$10 == 0)
              {
                if(!(argc == 2))
                  tmp_if_expr$13 = (_Bool)1;

                else
                {
                  if(argc == 2)
                  {
                    return_value_digitstring$11=digitstring(argv[(signed long int)1]);
                    tmp_if_expr$12 = !(return_value_digitstring$11 != 0) ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr$12 = (_Bool)0;
                  tmp_if_expr$13 = tmp_if_expr$12 ? (_Bool)1 : (_Bool)0;
                }
                tmp_if_expr$14 = tmp_if_expr$13 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$14 = (_Bool)0;
              if(!tmp_if_expr$14)
                printf("%s[%d] %s\n", (const void *)vpc[(signed long int)pcid].xname, pcid + 1, cmdstr);

            }

            if(argc >= 2)
            {
              if(!(cmd->help == ((signed int (*)(signed int, char **))NULL)))
              {
                return_value_strcmp$15=strcmp(argv[(signed long int)(argc - 1)], "?");
                if(return_value_strcmp$15 == 0)
                  tmp_if_expr$17 = (_Bool)1;

                else
                {
                  return_value_strcmp$16=strcmp(argv[(signed long int)(argc - 1)], "help");
                  tmp_if_expr$17 = !(return_value_strcmp$16 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$17)
                {
                  argv[(signed long int)0] = cmd->name;
                  cmd->help(argc, argv);
                }

              }

            }

            memset((void *)&vpc[(signed long int)pcid].mscb, 0, sizeof(struct sesscb) /*160ul*/ );
            vpc[(signed long int)pcid].mscb.sock = 1;
            rc=cmd->f(argc, argv);
            memset((void *)&vpc[(signed long int)pcid].mscb, 0, sizeof(struct sesscb) /*160ul*/ );
          }

          else
            printf("Bad command: \"%s\". Use ? for help.\n", cmdstr);
          goto __CPROVER_DUMP_L38;
        }
      }
    }
  }


__CPROVER_DUMP_L38:
  ;
}

// pth_reader
// file vpcs.c line 396
static void * pth_reader(void *devid)
{
  signed int id;
  struct anonymous$0 *pc = (struct anonymous$0 *)(void *)0;
  struct packet *m = (struct packet *)(void *)0;
  unsigned char buf[1520l];
  signed int rc;
  id = *((signed int *)devid);
  pc = &vpc[(signed long int)id];
  pc->id = id;
  pc->rhost = rhost;
  pc->lport = lport + id;
  pc->rport = rport + id;
  pc->ip4.mac[(signed long int)0] = (unsigned char)0x00;
  pc->ip4.mac[(signed long int)1] = (unsigned char)0x50;
  pc->ip4.mac[(signed long int)2] = (unsigned char)0x79;
  pc->ip4.mac[(signed long int)3] = (unsigned char)0x66;
  pc->ip4.mac[(signed long int)4] = (unsigned char)0x68;
  pc->ip4.mac[(signed long int)5] = (unsigned char)(id + macaddr & 0xff);
  if(pc->fd == 0)
    pc->fd=open_dev(id);

  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  if(!(pc->fd >= 1))
  {
    if(devtype == 1)
    {
      if(num_pths >= 2)
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        printf("Create TAP device tap%d error [%s]\n", id, return_value_strerror$2);
      }

      else
      {
        return_value___errno_location$3=__errno_location();
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        printf("Create TAP device %s error [%s]\n", tapname, return_value_strerror$4);
      }
    }

    else
      if(devtype == 2)
      {
        return_value___errno_location$5=__errno_location();
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        printf("Open port %d error [%s]\n", vpc[(signed long int)id].lport, return_value_strerror$6);
      }

    return (void *)0;
  }

  pthread_mutex_init(&pc->locker, (const union anonymous$12 *)(void *)0);
  init_queue(&pc->iq);
  pc->iq.type = 0 + id * 100;
  init_queue(&pc->oq);
  pc->oq.type = 1 + id * 100;
  signed int return_value_pthread_create$7;
  return_value_pthread_create$7=pthread_create(&pc->wpid, (const union pthread_attr_t *)(void *)0, pth_writer, devid);
  if(!(return_value_pthread_create$7 == 0))
  {
    printf("PC%d error\n", id + 1);
    exit(-1);
  }

  _Bool tmp_if_expr$9;
  signed int return_value_memcmp$8;
  while((_Bool)1)
  {
    rc=VRead(pc, (void *)buf, 1520);
    if(rc >= 1)
    {
      m=new_pkt(1520);
      if(m == ((struct packet *)NULL))
      {
        printf("Out of memory.\n");
        exit(-1);
      }

      memcpy((void *)m->data, (const void *)buf, (unsigned long int)rc);
      m->len = rc;
      gettimeofday(&m->ts, (struct timezone *)(void *)0);
      if(!((0x80 & pc->dmpflag) == 0))
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        return_value_memcmp$8=memcmp((const void *)m->data, (const void *)pc->ip4.mac, (unsigned long int)6);
        tmp_if_expr$9 = !(return_value_memcmp$8 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$9)
        dmp_packet(m, pc->dmpflag);

      rc=upv4(pc, m);
      if(rc == 2)
      {
        if(!(pc->mscb.sock == 0))
          enq(&pc->iq, m);

        else
          del_pkt(m);
      }

      else
        if(rc == 0)
          del_pkt(m);

    }

  }
  return (void *)0;
}

// pth_relay
// file relay.h line 34
void * pth_relay(void *dummy)
{
  char buf[1500l];
  signed int len;
  signed int n = 0;
  struct sockaddr_in peeraddr;
  struct sockaddr_in addr;
  unsigned int size;
  struct peerlist *peerhost;
  relay_port = vpc[(signed long int)0].lport + 9;
  relay_fd=open_udp(relay_port);
  if(!(relay_fd >= 1))
    relay_fd = 0;

  while(peerlist == ((struct peerlist *)NULL))
    sleep((unsigned int)1);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  while((_Bool)1)
  {
    len = (signed int)sizeof(char [1500l]) /*1500ul*/ ;
    size = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    signed long int return_value_recvfrom$1;
    return_value_recvfrom$1=recvfrom(relay_fd, (void *)buf, (unsigned long int)len, 0, (struct sockaddr *)&peeraddr, &size);
    n = (signed int)return_value_recvfrom$1;
    bzero((void *)&addr, sizeof(struct sockaddr_in) /*16ul*/ );
    addr.sin_family = (unsigned short int)2;
    peerhost = peerlist;
    for( ; !(peerhost == ((struct peerlist *)NULL)); peerhost = peerhost->next)
    {
      if(peerhost->nodea.port == peeraddr.sin_port)
      {
        unsigned int return_value_htonl$2;
        return_value_htonl$2=htonl((unsigned int)0x00000000);
        if(peerhost->nodea.ip == return_value_htonl$2)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = peerhost->nodea.ip == peeraddr.sin_addr.s_addr ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
        {
          addr.sin_addr.s_addr = peerhost->nodeb.ip;
          addr.sin_port = peerhost->nodeb.port;
          break;
        }

      }

      if(peerhost->nodeb.port == peeraddr.sin_port)
      {
        unsigned int return_value_htonl$4;
        return_value_htonl$4=htonl((unsigned int)0x00000000);
        if(peerhost->nodeb.ip == return_value_htonl$4)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = peerhost->nodeb.ip == peeraddr.sin_addr.s_addr ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
        {
          addr.sin_addr.s_addr = peerhost->nodea.ip;
          addr.sin_port = peerhost->nodea.port;
          break;
        }

      }

    }
    if(!(addr.sin_port == 0))
      sendto(relay_fd, (const void *)buf, (unsigned long int)n, 0, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );

  }
  return (void *)0;
}

// pth_timer_tick
// file vpcs.c line 496
static void * pth_timer_tick(void *dummy)
{
  signed long int t0;
  signed long int t1;
  t0=time(((signed long int *)NULL));
  while((_Bool)1)
  {
    t1=time(((signed long int *)NULL));
    if(t1 + -t0 >= 1l)
    {
      time_tick = time_tick + (unsigned int)(t1 - t0);
      t0 = t1;
    }

    usleep((unsigned int)100);
  }
  return (void *)0;
}

// pth_writer
// file vpcs.c line 473
static void * pth_writer(void *devid)
{
  signed int id;
  struct anonymous$0 *pc = (struct anonymous$0 *)(void *)0;
  id = *((signed int *)devid);
  pc = &vpc[(signed long int)id];
  locallink6(pc);
  while((_Bool)1)
  {
    struct packet *pkt = (struct packet *)(void *)0;
    pkt=waitdeq(&pc->oq);
    dmp_packet(pkt, pc->dmpflag);
    signed int return_value_VWrite$1;
    return_value_VWrite$1=VWrite(pc, (void *)pkt->data, pkt->len);
    if(!(return_value_VWrite$1 == pkt->len))
      printf("Send packet error\n");

    del_pkt(pkt);
  }
  return (void *)0;
}

// pty_master
// file hv.c line 207
static void * pty_master(void *arg)
{
  signed int i;
  unsigned char buf[128l];
  signed long int return_value_write$2;
  while(cmd_quit$link1 == 0)
  {
    memset((void *)buf, 0, sizeof(unsigned char [128l]) /*128ul*/ );
    signed long int return_value_read$1;
    return_value_read$1=read(ptyfdm, (void *)buf, sizeof(unsigned char [128l]) /*128ul*/ );
    i = (signed int)return_value_read$1;
    if(i >= 1)
      return_value_write$2=write(sock_cli, (const void *)buf, (unsigned long int)i);

  }
  return (void *)0;
}

// pty_slave
// file hv.c line 223
static void * pty_slave(void *arg)
{
  char *cmd;
  char *av[20l];
  signed int ac = 0;
  struct stub *ep = (struct stub *)(void *)0;
  signed int matched = 0;
  while(cmd_quit$link1 == 0)
  {
    cmd=readline("HV > ", rls$link1);
    fprintf(fptys, "\r\n");
    fflush(fptys);
    usleep((unsigned int)1);
    if(!(cmd == ((char *)NULL)))
    {
      ttrim(cmd);
      ac=mkargv(cmd, (char **)av, 20);
      if(!(ac == 0))
      {
        ep = cmd_entry$link1;
        matched = 0;
        for( ; !(ep->name == ((char *)NULL)); ep = ep + 1l)
        {
          unsigned long int return_value_strlen$1;
          return_value_strlen$1=strlen(av[(signed long int)0]);
          signed int return_value_strncmp$2;
          return_value_strncmp$2=strncmp(av[(signed long int)0], ep->name, return_value_strlen$1);
          if(return_value_strncmp$2 == 0)
          {
            matched = 1;
            break;
          }

        }
        if(!(matched == 0))
          ep->f(ac, av);

        else
          do
          {
            fprintf(fptys, "200-");
            fprintf(fptys, "Invalid or incomplete command\r\n");
            fflush(fptys);
          }
          while((_Bool)0);
      }

    }

  }
  return (void *)0;
}

// readline
// file readline.h line 51
char * readline(const char *prompt, struct rls *rls)
{
  if(prompt == ((const char *)NULL) || rls == ((struct rls *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(prompt);
    signed long int return_value_write$2;
    return_value_write$2=write(rls->fdout, (const void *)prompt, return_value_strlen$1);
    rls->prompt = (char *)prompt;
    signed int return_value__readline$3;
    return_value__readline$3=_readline(rls);
    if(return_value__readline$3 == 0)
      return (char *)(void *)0;

    else
      return rls->kbuffer;
  }
}

// readline_free
// file readline.c line 176
void readline_free(struct rls *rls)
{
  if(!(rls->history == ((char **)NULL)))
  {
    free((void *)rls->history[(signed long int)0]);
    free((void *)rls->history);
  }

  free((void *)rls);
}

// readline_init
// file readline.h line 47
struct rls * readline_init(signed int histnum, signed int buflen)
{
  struct rls *readline_init$$1$$rls = (struct rls *)(void *)0;
  signed int i;
  char *p = (char *)(void *)0;
  if(!(buflen >= 1) || !(histnum >= 1))
    return (struct rls *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct rls) /*576ul*/ );
    readline_init$$1$$rls = (struct rls *)return_value_malloc$1;
    if(!(readline_init$$1$$rls == ((struct rls *)NULL)))
    {
      memset((void *)readline_init$$1$$rls, 0, sizeof(struct rls) /*576ul*/ );
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)((histnum + 2) * buflen));
      p = (char *)return_value_malloc$2;
      if(!(p == ((char *)NULL)))
      {
        memset((void *)p, 0, (unsigned long int)((histnum + 2) * buflen));
        readline_init$$1$$rls->kbuffer = p;
        void *return_value_malloc$3;
        return_value_malloc$3=malloc((unsigned long int)histnum * sizeof(char *) /*8ul*/ );
        readline_init$$1$$rls->history = (char **)return_value_malloc$3;
        if(!(readline_init$$1$$rls->history == ((char **)NULL)))
        {
          i = 0;
          for( ; histnum >= i; i = i + 1)
            readline_init$$1$$rls->history[(signed long int)i] = p + (signed long int)(buflen * i);
          readline_init$$1$$rls->kbuffer = p + (signed long int)(buflen * (histnum + 1));
          readline_init$$1$$rls->maxbuflen = buflen;
          readline_init$$1$$rls->maxhistnum = histnum;
          readline_init$$1$$rls->fdin = 0;
          readline_init$$1$$rls->fdout = 1;
          return readline_init$$1$$rls;
        }

      }

    }

    if(!(p == ((char *)NULL)))
      free((void *)p);

    if(!(readline_init$$1$$rls == ((struct rls *)NULL)))
      free((void *)readline_init$$1$$rls);

    return (struct rls *)(void *)0;
  }
}

// readline_tab
// file readline.c line 80
signed int readline_tab(char ** (*cb)(const char *, const char *), struct rls *rls)
{
  if(!(cb == ((char ** (*)(const char *, const char *))NULL)))
    rls->tab_callback = cb;

  return 0;
}

// reset_terminal
// file readline.c line 548
void reset_terminal(signed int fd, struct termios *stored_settings)
{
  tcsetattr(fd, 0, stored_settings);
}

// response
// file packets.c line 160
signed int response(struct packet *m, struct sesscb *sesscb)
{
  struct ethdr *eh;
  struct iphdr *ip;
  eh = (struct ethdr *)m->data;
  ip = (struct iphdr *)(eh + (signed long int)1);
  _Bool tmp_if_expr$1;
  if((signed int)ip->proto == 1)
  {
    struct icmphdr *response$$1$$1$$icmp = (struct icmphdr *)(ip + (signed long int)1);
    if((signed int)response$$1$$1$$icmp->type == 5)
    {
      if((signed int)response$$1$$1$$icmp->code == 0)
      {
        struct icmprdr *rdr = (struct icmprdr *)response$$1$$1$$icmp;
        sesscb->icmptype = response$$1$$1$$icmp->type;
        sesscb->icmpcode = response$$1$$1$$icmp->code;
        sesscb->rdip = rdr->ip;
        return 1;
      }

    }

    if((signed int)response$$1$$1$$icmp->type == 3)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)response$$1$$1$$icmp->type == 11 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      sesscb->icmptype = response$$1$$1$$icmp->type;
      sesscb->icmpcode = response$$1$$1$$icmp->code;
      sesscb->rttl = ip->ttl;
      sesscb->rdip = ip->sip;
      return 1;
    }

  }

  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(!(ip->sip == sesscb->dip))
    return 0;

  else
  {
    if((signed int)ip->proto == 1)
    {
      if(sesscb->proto == 1)
      {
        struct icmphdr *icmp = (struct icmphdr *)(ip + (signed long int)1);
        sesscb->icmptype = icmp->type;
        sesscb->icmpcode = icmp->code;
        sesscb->rttl = ip->ttl;
        sesscb->rdip = ip->sip;
        unsigned short int return_value_ntohs$2;
        return_value_ntohs$2=ntohs(icmp->seq);
        if((unsigned int)return_value_ntohs$2 == sesscb->sn)
          return 1;

        return 0;
      }

    }

    if((signed int)ip->proto == 17)
    {
      if(sesscb->proto == 17)
      {
        struct udpiphdr *ui = (struct udpiphdr *)ip;
        char *data = (char *)(ui + (signed long int)1);
        signed int return_value_memcmp$3;
        return_value_memcmp$3=memcmp((const void *)data, (const void *)eh->dst, (unsigned long int)6);
        if(return_value_memcmp$3 == 0)
        {
          sesscb->rttl = ip->ttl;
          return 17;
        }

        return 0;
      }

    }

    if((signed int)ip->proto == 6)
    {
      if(sesscb->proto == 6)
      {
        struct tcpiphdr *ti = (struct tcpiphdr *)ip;
        char *response$$1$$4$$data = (char *)(ti + (signed long int)1);
        sesscb->rseq=ntohl(ti->ti_t.th_seq);
        sesscb->rack=ntohl(ti->ti_t.th_ack);
        sesscb->rflags = ti->ti_t.th_flags;
        sesscb->rttl = ip->ttl;
        unsigned short int return_value_ntohs$4;
        return_value_ntohs$4=ntohs(ip->len);
        sesscb->rdsize = (signed int)(((unsigned long int)return_value_ntohs$4 - sizeof(struct iphdr) /*20ul*/ ) - (unsigned long int)((signed int)ti->ti_t.th_off << 2));
        sesscb->data = (char *)(void *)0;
        if((signed int)sesscb->flags == 0x02)
          tmp_if_expr$5 = (signed int)sesscb->rflags == (0x02 | 0x10) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = sesscb->rdsize > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
        {
          signed int i = 0;
          for( ; (signed int)response$$1$$4$$data[(signed long int)i] == 0x1; i = i + 1)
            if(i >= sesscb->rdsize)
              break;

          for( ; !(i >= sesscb->rdsize); i = i + (signed int)response$$1$$4$$data[(signed long int)(i + 1)])
            if((signed int)response$$1$$4$$data[(signed long int)i] == 2)
            {
              if((signed int)response$$1$$4$$data[(signed long int)(1 + i)] == 4)
              {
                sesscb->rmss = (unsigned short int)(((signed int)response$$1$$4$$data[(signed long int)(i + 2)] << 8) + (signed int)response$$1$$4$$data[(signed long int)(i + 3)]);
                break;
              }

            }

        }

        else
          sesscb->data = (char *)(ip + (signed long int)1) + (signed long int)((signed int)ti->ti_t.th_off << 2);
        return 6;
      }

    }

    return 0;
  }
}

// response6
// file packets6.h line 54
signed int response6(struct packet *m, struct sesscb *sesscb)
{
  struct ethdr *eh;
  struct anonymous$18 *ip;
  eh = (struct ethdr *)m->data;
  ip = (struct anonymous$18 *)(eh + (signed long int)1);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if((signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58)
  {
    struct anonymous$20 *icmp = (struct anonymous$20 *)(ip + (signed long int)1);
    if((signed int)icmp->type == 1)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)icmp->type == 3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)icmp->type == 4 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      sesscb->icmptype = icmp->type;
      sesscb->icmpcode = icmp->code;
      sesscb->rttl = ip->ip6_ctlun.ip6_un1.ip6_un1_hlim;
      memcpy((void *)sesscb->rdip6.uaddr._a8, (const void *)ip->src.uaddr._a8, (unsigned long int)16);
      return 58;
    }

  }

  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)(&sesscb->dip6)->uaddr._a8, (const void *)(&ip->src)->uaddr._a8, (unsigned long int)16);
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if(!(return_value_memcmp$3 == 0))
    return 0;

  else
  {
    if((signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58)
    {
      if(sesscb->proto == 58)
      {
        struct anonymous$20 *response6$$1$$2$$icmp = (struct anonymous$20 *)(ip + (signed long int)1);
        sesscb->icmptype = response6$$1$$2$$icmp->type;
        sesscb->icmpcode = response6$$1$$2$$icmp->code;
        sesscb->rttl = ip->ip6_ctlun.ip6_un1.ip6_un1_hlim;
        memcpy((void *)sesscb->rdip6.uaddr._a8, (const void *)ip->src.uaddr._a8, (unsigned long int)16);
        unsigned short int return_value_ntohs$4;
        return_value_ntohs$4=ntohs(response6$$1$$2$$icmp->icmp6_dataun.icmp6_un_data16[(signed long int)1]);
        if((unsigned int)return_value_ntohs$4 == sesscb->sn)
          return 58;

        return 0;
      }

    }

    if((signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_nxt == 17)
    {
      struct anonymous$24 *ui = (struct anonymous$24 *)(ip + (signed long int)1);
      char *data = (char *)(ui + (signed long int)1);
      signed int return_value_memcmp$5;
      return_value_memcmp$5=memcmp((const void *)data, (const void *)eh->dst, (unsigned long int)6);
      if(return_value_memcmp$5 == 0)
      {
        sesscb->rttl = ip->ip6_ctlun.ip6_un1.ip6_un1_hlim;
        return 17;
      }

      return 0;
    }

    if((signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_nxt == 6)
    {
      struct tcphdr *th = (struct tcphdr *)(ip + (signed long int)1);
      char *response6$$1$$4$$data = (char *)(th + (signed long int)1);
      sesscb->rseq=ntohl(th->th_seq);
      sesscb->rack=ntohl(th->th_ack);
      sesscb->rflags = th->th_flags;
      sesscb->rttl = ip->ip6_ctlun.ip6_un1.ip6_un1_hlim;
      unsigned short int return_value_ntohs$6;
      return_value_ntohs$6=ntohs(ip->ip6_ctlun.ip6_un1.ip6_un1_plen);
      sesscb->rdsize = (signed int)(((unsigned long int)return_value_ntohs$6 - sizeof(struct iphdr) /*20ul*/ ) - (unsigned long int)((signed int)th->th_off << 2));
      sesscb->data = (char *)(void *)0;
      if((signed int)sesscb->flags == 0x02)
        tmp_if_expr$7 = (signed int)sesscb->rflags == (0x02 | 0x10) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = sesscb->rdsize > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
      {
        signed int i = 0;
        for( ; (signed int)response6$$1$$4$$data[(signed long int)i] == 0x1; i = i + 1)
          if(i >= sesscb->rdsize)
            break;

        for( ; !(i >= sesscb->rdsize); i = i + (signed int)response6$$1$$4$$data[(signed long int)(i + 1)])
          if((signed int)response6$$1$$4$$data[(signed long int)i] == 2)
          {
            if((signed int)response6$$1$$4$$data[(signed long int)(1 + i)] == 4)
            {
              sesscb->rmss = (unsigned short int)(((signed int)response6$$1$$4$$data[(signed long int)(i + 2)] << 8) + (signed int)response6$$1$$4$$data[(signed long int)(i + 3)]);
              break;
            }

          }

      }

      else
        sesscb->data = (char *)(ip + (signed long int)1) + (signed long int)((signed int)th->th_off << 2);
      return 6;
    }

    return 0;
  }
}

// run_clear
// file command.h line 37
signed int run_clear(signed int argc, char **argv)
{
  unsigned char mac[6l];
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$2;
  _Bool tmp_if_expr$4;
  if(!(argc >= 2))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(argc == 2)
    {
      return_value_strlen$2=strlen(argv[(signed long int)1]);
      tmp_if_expr$3 = return_value_strlen$2 == (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (signed int)argv[(signed long int)1][(signed long int)0] == 63 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    signed int return_value_help_clear$1;
    return_value_help_clear$1=help_clear(argc, argv);
    return return_value_help_clear$1;
  }

  signed int return_value_strcmp$14;
  return_value_strcmp$14=strcmp("ip", argv[(signed long int)1]);
  unsigned long int return_value_strlen$12;
  signed int return_value_strncmp$13;
  unsigned long int return_value_strlen$10;
  signed int return_value_strncmp$11;
  unsigned long int return_value_strlen$8;
  signed int return_value_strncmp$9;
  unsigned long int return_value_strlen$6;
  signed int return_value_strncmp$7;
  if(return_value_strcmp$14 == 0)
  {
    memcpy((void *)mac, (const void *)vpc[(signed long int)pcid].ip4.mac, (unsigned long int)6);
    memset((void *)&vpc[(signed long int)pcid].ip4, 0, sizeof(struct anonymous$6) /*224ul*/ );
    memcpy((void *)&vpc[(signed long int)pcid].ip4.mac, (const void *)mac, (unsigned long int)6);
    printf("IPv4 address/mask, gateway, DNS, and DHCP cleared\n");
  }

  else
  {
    return_value_strlen$12=strlen(argv[(signed long int)1]);
    return_value_strncmp$13=strncmp("ipv6", argv[(signed long int)1], return_value_strlen$12);
    if(return_value_strncmp$13 == 0)
    {
      memset((void *)&vpc[(signed long int)pcid].ip6, 0, sizeof(struct anonymous$7) /*36ul*/ );
      printf("IPv6 address/mask and router link-layer address cleared\n");
    }

    else
    {
      return_value_strlen$10=strlen(argv[(signed long int)1]);
      return_value_strncmp$11=strncmp("arp", argv[(signed long int)1], return_value_strlen$10);
      if(return_value_strncmp$11 == 0)
        memset((void *)&vpc[(signed long int)pcid].ipmac4, 0, sizeof(struct anonymous$4 [10l]) /*160ul*/ );

      else
      {
        return_value_strlen$8=strlen(argv[(signed long int)1]);
        return_value_strncmp$9=strncmp("neighbor", argv[(signed long int)1], return_value_strlen$8);
        if(return_value_strncmp$9 == 0)
          memset((void *)&vpc[(signed long int)pcid].ipmac6, 0, sizeof(struct anonymous$5 [10l]) /*320ul*/ );

        else
        {
          return_value_strlen$6=strlen(argv[(signed long int)1]);
          return_value_strncmp$7=strncmp("hist", argv[(signed long int)1], return_value_strlen$6);
          if(return_value_strncmp$7 == 0)
            clear_hist();

          else
            printf("Invalid options\n");
        }
      }
    }
  }
  return 1;
}

// run_dhcp
// file command.c line 593
signed int run_dhcp(signed int argc, char **argv)
{
  signed int dump = 0;
  signed int flag = 0;
  signed int i = 0;
  do
  {
    i = i + 1;
    if(i >= argc)
      break;

    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(argv[(signed long int)i], "-d");
    if(return_value_strcmp$1 == 0)
      dump = 1;

    else
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(argv[(signed long int)i], "-r");
      if(return_value_strcmp$2 == 0)
        flag = (flag << 4) + 0x5;

      else
      {
        signed int return_value_strcmp$3;
        return_value_strcmp$3=strcmp(argv[(signed long int)i], "-x");
        if(return_value_strcmp$3 == 0)
          flag = (flag << 4) + 0xa;

        else
        {
          flag = -1;
          break;
        }
      }
    }
  }
  while((_Bool)1);
  signed int return_value_help_ip$4;
  if(flag == -1)
  {
    return_value_help_ip$4=help_ip(argc, argv);
    return return_value_help_ip$4;
  }

  else
  {
    switch(flag)
    {
      case 0:
      {
        run_dhcp_new(0, dump);
        break;
      }
      case 0x5:
      {
        run_dhcp_new(1, dump);
        break;
      }
      case 0xa:
      {
        run_dhcp_release(dump);
        break;
      }
      case 0x5a:
      {
        run_dhcp_new(1, dump);
        run_dhcp_release(dump);
        break;
      }
      case 0xa5:
      {
        run_dhcp_release(dump);
        run_dhcp_new(1, dump);
      }
    }
    return 1;
  }
}

// run_dhcp_new
// file command.c line 643
static signed int run_dhcp_new(signed int renew, signed int dump)
{
  signed int i;
  struct packet *m;
  signed int ok;
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  signed int ts[3l] = { 1, 3, 9 };
  struct packet *p;
  struct in_addr in;
  unsigned char mac[6l];
  signed long int return_value_time$1;
  return_value_time$1=time(((signed long int *)NULL));
  srand((unsigned int)return_value_time$1);
  signed int return_value_rand$2;
  return_value_rand$2=rand();
  pc->ip4.dhcp.xid = (unsigned int)return_value_rand$2;
  i = 0;
  ok = 0;
  for( ; ok == 0 && !(i >= 3); i = i + 1)
  {
    if(dump == 0)
    {
      printf("D");
      fflush(stdout);
    }

    m=dhcp4_discover(pc, renew);
    if(m == ((struct packet *)NULL))
    {
      printf("out of memory\n");
      return 0;
    }

    if(!(dump == 0))
      dmp_dhcp(pc, m);

    enq(&pc->oq, m);
    sleep((unsigned int)ts[(signed long int)i]);
    do
    {
      p=deq(&pc->iq);
      if(p == ((struct packet *)NULL))
        break;

      if(!(ok == 0))
        break;

      ok=isDhcp4_Offer(pc, p);
      if(!(ok == 0))
      {
        if(!(dump == 0))
          dmp_dhcp(pc, p);

        else
        {
          printf("O");
          fflush(stdout);
        }
      }

      free((void *)p);
    }
    while((_Bool)1);
  }
  if(i == 3)
  {
    printf("\nCan't find dhcp server\n");
    return 1;
  }

  else
  {
    i = 0;
    ok = 0;
    for( ; ok == 0 && !(i >= 3); i = i + 1)
    {
      m=dhcp4_request(pc);
      if(m == ((struct packet *)NULL))
      {
        printf("out of memory\n");
        return 0;
      }

      if(!(dump == 0))
        dmp_dhcp(pc, m);

      else
      {
        printf("R");
        fflush(stdout);
      }
      enq(&pc->oq, m);
      sleep((unsigned int)1);
      do
      {
        p=deq(&pc->iq);
        if(p == ((struct packet *)NULL))
          break;

        if(!(ok == 0))
          break;

        ok=isDhcp4_packer(pc, p);
        if(!(ok == 0))
        {
          if(!(dump == 0))
            dmp_dhcp(pc, p);

          else
          {
            printf("A");
            fflush(stdout);
          }
        }

        free((void *)p);
      }
      while((_Bool)1);
    }
    if(i == 3)
    {
      printf("\nCan't get ip address from dhcp server\n");
      return 1;
    }

    else
    {
      signed int return_value_arpResolve$4;
      return_value_arpResolve$4=arpResolve(pc, pc->ip4.ip, mac);
      if(return_value_arpResolve$4 == 1)
      {
        in.s_addr = pc->ip4.ip;
        printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", mac[(signed long int)0], mac[(signed long int)1], mac[(signed long int)2], mac[(signed long int)3], mac[(signed long int)4], mac[(signed long int)5]);
        char *return_value_inet_ntoa$3;
        return_value_inet_ntoa$3=inet_ntoa(in);
        printf(" use my ip %s\n", return_value_inet_ntoa$3);
        memset((void *)pc->ipmac4, 0, sizeof(struct anonymous$4 [10l]) /*160ul*/ );
        pc->ip4.ip = (unsigned int)0;
        pc->ip4.cidr = 0;
        pc->ip4.gw = (unsigned long int)0;
        return 0;
      }

      in.s_addr = pc->ip4.ip;
      char *return_value_inet_ntoa$5;
      return_value_inet_ntoa$5=inet_ntoa(in);
      printf(" IP %s/%d", return_value_inet_ntoa$5, pc->ip4.cidr);
      if(!(pc->ip4.gw == 0ul))
      {
        in.s_addr = (unsigned int)pc->ip4.gw;
        char *return_value_inet_ntoa$6;
        return_value_inet_ntoa$6=inet_ntoa(in);
        printf(" GW %s\n", return_value_inet_ntoa$6);
      }

      pc->ip4.dynip = 1;
      pc->ip4.mtu = 1500;
      return 1;
    }
  }
}

// run_dhcp_release
// file command.c line 758
static signed int run_dhcp_release(signed int dump)
{
  struct packet *m;
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  m=dhcp4_release(pc);
  if(m == ((struct packet *)NULL))
  {
    printf("out of memory\n");
    return 0;
  }

  else
  {
    if(!(dump == 0))
      dmp_dhcp(pc, m);

    enq(&pc->oq, m);
    pc->ip4.ip = (unsigned int)0;
    pc->ip4.cidr = 0;
    pc->ip4.gw = (unsigned long int)0;
    return 0;
  }
}

// run_disconnect
// file vpcs.c line 577
static signed int run_disconnect(signed int argc, char **argv)
{
  signed int pid;
  if(!(daemon_port == 0))
  {
    pid=getppid();
    kill(pid, 3);
  }

  else
    printf("NOT daemon mode\n");
  return 0;
}

// run_disconnect$link1
// file hv.c line 626
static signed int run_disconnect$link1(signed int ac, char **av)
{
  cmd_quit$link1 = 1;
  return 0;
}

// run_echo
// file command.h line 38
signed int run_echo(signed int argc, char **argv)
{
  signed int i = 1;
  for( ; !(i >= argc); i = i + 1)
    printf("%s ", argv[(signed long int)i]);
  return 1;
}

// run_help
// file help.h line 30
signed int run_help(signed int argc, char **argv)
{
  printf("\n?                        Print help\n! [command [args]]       Invoke an OS command with the 'args' as its arguments\n<digit>                  Switch to the VPC<digit>. <digit> range 1 to 9\narp                      Shortcut for: \033[1mshow arp\033[0m. Show arp table\nclear [arguments]        Clear IPv4/IPv6, arp/neighbor cache, command history\ndhcp [-options]          Shortcut for: \033[1mip dhcp\033[0m. Get IPv4 address via DHCP\ndisconnect               Exit the telnet session (daemon mode)\r\necho <text>              Display <text> in output\nhelp                     Print help\nhistory                  Shortcut for: \033[1mshow history\033[0m. List the command history\nip [arguments]           Configure VPC's IP settings\nload [filename]          Load the configuration/script from the file [filename] (startup.vpc is the default filename).\nping <host> [-options]   Ping the network <host> with ICMP (default) or TCP/UDP\nquit                     Quit program\nrelay [arguments]        Relay packets between two UDP ports\nrlogin [<ip>] <port>     Telnet to host relative to HOST PC\nsave [filename]          Save the configuration to the file [filename] (startup.vpc is the default filename).\nset [arguments]          Set VPC name, peer ports, dump options, echo on or off\nshow [arguments]         Print the information of VPCs (default). Try \033[1mshow ?\033[0m\nsleep <seconds> [text]   Print <text> and pause the running script for <seconds>\ntrace <host> [-options]  Print the path packets take to network <host>\nversion                  Shortcut for: \033[1mshow version\033[0m\n\nTo get command syntax help, please enter '?' as an argument of the command.\n");
  return 1;
}

// run_help$link1
// file hv.c line 802
static signed int run_help$link1(signed int ac, char **av)
{
  fprintf(fptys, "help | ?              Print help\r\nvpcs [parameters]     Start vpcs with parameters of vpcs\r\nstop id               Stop vpcs process\r\nlist                  List vpcs process\r\ndisconnect            Exit the telnet session\r\nquit [-f]             Stop vpcs processes and hypervisor\r\n                        -f force quit without prompting\r\ntelnet [<ip>] <port>  Telnet to <port> at <ip> (def 127.0.0.1)\r\nrlogin [<ip>] <port>  Same as telnet\r\n");
  return 0;
}

// run_hist
// file command.h line 40
signed int run_hist(signed int argc, char **argv)
{
  signed int i = 0;
  for( ; !(i >= rls->hist_total); i = i + 1)
    printf("%s\n", rls->history[(signed long int)i]);
  return 1;
}

// run_ipconfig
// file command.h line 33
signed int run_ipconfig(signed int argc, char **argv)
{
  char buf[128l];
  struct in_addr in;
  signed int icidr = 24;
  unsigned int rip;
  unsigned int gip;
  unsigned int tip;
  signed int i;
  signed int j;
  signed int hasgip = 1;
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  unsigned char mac[6l];
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$2;
  _Bool tmp_if_expr$4;
  if(!(argc >= 2))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(argc == 2)
    {
      return_value_strlen$2=strlen(argv[(signed long int)1]);
      tmp_if_expr$3 = return_value_strlen$2 == (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (signed int)argv[(signed long int)1][(signed long int)0] == 63 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    signed int return_value_help_ip$1;
    return_value_help_ip$1=help_ip(argc, argv);
    return return_value_help_ip$1;
  }

  char *return_value_strchr$7;
  return_value_strchr$7=strchr(argv[(signed long int)1], 58);
  signed int return_value_run_ipset6$6;
  signed int return_value_help_ip$11;
  signed int return_value_ipauto6$14;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$19;
  signed int return_value_digitstring$18;
  _Bool tmp_if_expr$25;
  char *return_value_strstr$24;
  unsigned long int return_value_strlen$26;
  signed int return_value_help_ip$30;
  unsigned long int return_value_strlen$37;
  signed int return_value_strncmp$40;
  _Bool tmp_if_expr$44;
  _Bool tmp_if_expr$46;
  if(!(return_value_strchr$7 == ((char *)NULL)))
  {
    return_value_run_ipset6$6=run_ipset6(argc, argv);
    return return_value_run_ipset6$6;
  }

  else
  {
    unsigned long int return_value_strlen$12;
    return_value_strlen$12=strlen(argv[(signed long int)1]);
    signed int return_value_strncmp$13;
    return_value_strncmp$13=strncmp("dhcp", argv[(signed long int)1], return_value_strlen$12);
    if(return_value_strncmp$13 == 0)
    {
      signed int dump = 0;
      signed int flag = 0;
      i = 1;
      do
      {
        i = i + 1;
        if(i >= argc)
          break;

        signed int return_value_strcmp$8;
        return_value_strcmp$8=strcmp(argv[(signed long int)i], "-d");
        if(return_value_strcmp$8 == 0)
          dump = 1;

        else
        {
          signed int return_value_strcmp$9;
          return_value_strcmp$9=strcmp(argv[(signed long int)i], "-r");
          if(return_value_strcmp$9 == 0)
            flag = (flag << 4) + 0x5;

          else
          {
            signed int return_value_strcmp$10;
            return_value_strcmp$10=strcmp(argv[(signed long int)i], "-x");
            if(return_value_strcmp$10 == 0)
              flag = (flag << 4) + 0xa;

            else
            {
              flag = -1;
              break;
            }
          }
        }
      }
      while((_Bool)1);
      if(flag == -1)
      {
        return_value_help_ip$11=help_ip(argc, argv);
        return return_value_help_ip$11;
      }

      switch(flag)
      {
        case 0:
        {
          run_dhcp_new(0, dump);
          break;
        }
        case 0x5:
        {
          run_dhcp_new(1, dump);
          break;
        }
        case 0xa:
        {
          run_dhcp_release(dump);
          break;
        }
        case 0x5a:
        {
          run_dhcp_new(1, dump);
          run_dhcp_release(dump);
          break;
        }
        case 0xa5:
        {
          run_dhcp_release(dump);
          run_dhcp_new(1, dump);
        }
      }
      return 1;
    }

    unsigned long int return_value_strlen$15;
    return_value_strlen$15=strlen(argv[(signed long int)1]);
    signed int return_value_strncmp$16;
    return_value_strncmp$16=strncmp("auto", argv[(signed long int)1], return_value_strlen$15);
    if(return_value_strncmp$16 == 0)
    {
      return_value_ipauto6$14=ipauto6();
      return return_value_ipauto6$14;
    }

    else
    {
      unsigned long int return_value_strlen$21;
      return_value_strlen$21=strlen(argv[(signed long int)1]);
      signed int return_value_strncmp$22;
      return_value_strncmp$22=strncmp("mtu", argv[(signed long int)1], return_value_strlen$21);
      if(return_value_strncmp$22 == 0)
      {
        if(argc == 2 || argc >= 4)
          tmp_if_expr$20 = (_Bool)1;

        else
        {
          if(argc == 3)
          {
            return_value_digitstring$18=digitstring(argv[(signed long int)2]);
            tmp_if_expr$19 = !(return_value_digitstring$18 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$19 = (_Bool)0;
          tmp_if_expr$20 = tmp_if_expr$19 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$20)
        {
          argc = 3;
          argv[(signed long int)2] = "?";
          signed int return_value_help_ip$17;
          return_value_help_ip$17=help_ip(argc, argv);
          return return_value_help_ip$17;
        }

        i=atoi(argv[(signed long int)2]);
        if(!(i >= 576))
          printf("Invalid MTU, should bigger than 576\n");

        else
          pc->ip4.mtu = i;
        return 1;
      }

      unsigned long int return_value_strlen$28;
      return_value_strlen$28=strlen(argv[(signed long int)1]);
      signed int return_value_strncmp$29;
      return_value_strncmp$29=strncmp("domain", argv[(signed long int)1], return_value_strlen$28);
      if(return_value_strncmp$29 == 0)
      {
        if(!(argc == 3))
        {
          printf("Incomplete command.\n");
          return 1;
        }

        unsigned long int return_value_strlen$23;
        return_value_strlen$23=strlen(argv[(signed long int)2]);
        if(return_value_strlen$23 >= 65ul)
          tmp_if_expr$25 = (_Bool)1;

        else
        {
          return_value_strstr$24=strstr(argv[(signed long int)2], "..");
          tmp_if_expr$25 = return_value_strstr$24 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$25)
        {
          printf("Invalid domain name.\n");
          return 1;
        }

        char *p = argv[(signed long int)2];
        while(!(*p == 0))
          if((signed int)*p == 46)
            p = p + 1l;

          else
          {
            strcpy(vpc[(signed long int)pcid].ip4.domain, p);
            p = vpc[(signed long int)pcid].ip4.domain;
            unsigned long int return_value_strlen$27;
            return_value_strlen$27=strlen(p);
            if((signed int)p[-1l + (signed long int)return_value_strlen$27] == 46)
            {
              return_value_strlen$26=strlen(p);
              p[(signed long int)(return_value_strlen$26 - (unsigned long int)1)] = (char)0;
            }

            return 1;
          }
        return 1;
      }

      unsigned long int return_value_strlen$35;
      return_value_strlen$35=strlen(argv[(signed long int)1]);
      signed int return_value_strncmp$36;
      return_value_strncmp$36=strncmp("dns", argv[(signed long int)1], return_value_strlen$35);
      if(return_value_strncmp$36 == 0)
      {
        signed int return_value_strcmp$31;
        return_value_strcmp$31=strcmp(argv[(signed long int)(argc - 1)], "?");
        if(return_value_strcmp$31 == 0)
        {
          return_value_help_ip$30=help_ip(argc, argv);
          return return_value_help_ip$30;
        }

        if(argc == 3)
        {
          signed int return_value_strcmp$32;
          return_value_strcmp$32=strcmp(argv[(signed long int)2], "0");
          if(return_value_strcmp$32 == 0)
          {
            pc->ip4.dns[(signed long int)0] = (unsigned int)0;
            return 1;
          }

          rip=inet_addr(argv[(signed long int)2]);
          if(rip == 0u || rip == 4294967295u)
          {
            printf("Invalid address\n");
            return 0;
          }

          pc->ip4.dns[(signed long int)0] = rip;
        }

        if(argc == 4)
        {
          signed int return_value_strcmp$33;
          return_value_strcmp$33=strcmp(argv[(signed long int)2], "0");
          if(return_value_strcmp$33 == 0)
          {
            pc->ip4.dns[(signed long int)0] = (unsigned int)0;
            return 1;
          }

          rip=inet_addr(argv[(signed long int)2]);
          if(rip == 0u || rip == 4294967295u)
          {
            printf("Invalid address: %s\n", argv[(signed long int)2]);
            return 0;
          }

          pc->ip4.dns[(signed long int)0] = rip;
          signed int return_value_strcmp$34;
          return_value_strcmp$34=strcmp(argv[(signed long int)3], "0");
          if(return_value_strcmp$34 == 0)
          {
            pc->ip4.dns[(signed long int)0] = (unsigned int)0;
            return 1;
          }

          rip=inet_addr(argv[(signed long int)3]);
          if(rip == 0u || rip == 4294967295u)
          {
            printf("Invalid address: %s\n", argv[(signed long int)3]);
            return 0;
          }

          pc->ip4.dns[(signed long int)1] = rip;
        }

        return 1;
      }

      rip=inet_addr(argv[(signed long int)1]);
      gip = (unsigned int)0;
      hasgip = (signed int)gip;
      icidr = 24;
      i = 1;
      do
      {
        i = i + 1;
        if(i >= argc)
          break;

        signed int return_value_digitstring$38;
        return_value_digitstring$38=digitstring(argv[(signed long int)i]);
        if(!(return_value_digitstring$38 == 0))
        {
          return_value_strlen$37=strlen(argv[(signed long int)i]);
          if(return_value_strlen$37 >= 3ul)
            goto __CPROVER_DUMP_L53;

          icidr=atoi(argv[(signed long int)i]);
        }

        else
        {

        __CPROVER_DUMP_L53:
          ;
          unsigned long int return_value_strlen$41;
          return_value_strlen$41=strlen(argv[(signed long int)i]);
          if(return_value_strlen$41 >= 9ul)
          {
            return_value_strncmp$40=strncmp(argv[(signed long int)i], "255.", (unsigned long int)4);
            if(!(return_value_strncmp$40 == 0))
              goto __CPROVER_DUMP_L57;

            gip=inet_addr(argv[(signed long int)i]);
            j = 0;
            for( ; !(i >= 33); j = j + 1)
            {
              unsigned int return_value_ntohl$39;
              return_value_ntohl$39=ntohl(gip);
              if(ip_masks[(signed long int)j] == (unsigned long int)return_value_ntohl$39)
              {
                icidr = j;
                break;
              }

            }
          }

          else
          {

          __CPROVER_DUMP_L57:
            ;
            unsigned long int return_value_strlen$42;
            return_value_strlen$42=strlen(argv[(signed long int)i]);
            j = (signed int)return_value_strlen$42;
            if(j >= 7 && !(j >= 16))
            {
              hasgip = 1;
              gip=inet_addr(argv[(signed long int)i]);
              continue;
            }

            else
            {
              printf("Invalid options\n");
              return 0;
            }
          }
        }
      }
      while((_Bool)1);
      if(icidr >= 31 || !(icidr >= 1))
        icidr = 24;

      if(gip == 4294967295u || rip == 4294967295u || rip == gip)
      {
        printf("Invalid address\n");
        return 0;
      }

      else
      {
        unsigned int return_value_ntohl$43;
        return_value_ntohl$43=ntohl(rip);
        tip = (unsigned int)((unsigned long int)return_value_ntohl$43 & ~ip_masks[(signed long int)icidr]);
        if(tip == 0u)
          tmp_if_expr$44 = (_Bool)1;

        else
          tmp_if_expr$44 = ((unsigned long int)tip | ip_masks[(signed long int)icidr]) == (unsigned long int)0xffffffff ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$44)
        {
          printf("Invalid host address\n");
          return 0;
        }

        else
        {
          if(!(hasgip == 0))
          {
            unsigned int return_value_ntohl$45;
            return_value_ntohl$45=ntohl(gip);
            tip = (unsigned int)((unsigned long int)return_value_ntohl$45 & ~ip_masks[(signed long int)icidr]);
            if(tip == 0u)
              tmp_if_expr$46 = (_Bool)1;

            else
              tmp_if_expr$46 = ((unsigned long int)tip | ip_masks[(signed long int)icidr]) == (unsigned long int)0xffffffff ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$46)
            {
              printf("Invalid gateway address\n");
              return 0;
            }

            unsigned int return_value_ntohl$47;
            return_value_ntohl$47=ntohl(rip);
            unsigned int return_value_ntohl$48;
            return_value_ntohl$48=ntohl(gip);
            if(!((ip_masks[(signed long int)icidr] & (unsigned long int)return_value_ntohl$47) == (ip_masks[(signed long int)icidr] & (unsigned long int)return_value_ntohl$48)))
            {
              printf("not same subnet\n");
              return 0;
            }

          }

          pc->ip4.ip = rip;
          printf("Checking for duplicate address...\n");
          signed int return_value_arpResolve$50;
          return_value_arpResolve$50=arpResolve(pc, rip, mac);
          if(return_value_arpResolve$50 == 1)
          {
            in.s_addr = rip;
            char *return_value_inet_ntoa$49;
            return_value_inet_ntoa$49=inet_ntoa(in);
            printf("%s is being used by MAC ", return_value_inet_ntoa$49);
            printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", mac[(signed long int)0], mac[(signed long int)1], mac[(signed long int)2], mac[(signed long int)3], mac[(signed long int)4], mac[(signed long int)5]);
            printf("\nAddress not changed\n");
            memset((void *)pc->ipmac4, 0, sizeof(struct anonymous$4 [10l]) /*160ul*/ );
            pc->ip4.ip = (unsigned int)0;
            pc->ip4.cidr = 0;
            pc->ip4.gw = (unsigned long int)0;
            return 0;
          }

          pc->ip4.dynip = 0;
          pc->ip4.ip = rip;
          pc->ip4.gw = (unsigned long int)gip;
          pc->ip4.cidr = icidr;
          pc->ip4.mtu = 1500;
          if(devtype == 1)
          {
            unsigned int return_value_ntohl$51;
            return_value_ntohl$51=ntohl(rip);
            tip = (unsigned int)(((unsigned long int)return_value_ntohl$51 | ~ip_masks[(signed long int)icidr]) - (unsigned long int)1);
            in.s_addr=ntohl(tip);
            char *return_value_inet_ntoa$52;
            return_value_inet_ntoa$52=inet_ntoa(in);
            i=sprintf(buf, "ifconfig tap%d %s ", pcid, return_value_inet_ntoa$52);
            in.s_addr=ntohl((unsigned int)ip_masks[(signed long int)icidr]);
            char *return_value_inet_ntoa$53;
            return_value_inet_ntoa$53=inet_ntoa(in);
            sprintf(buf + (signed long int)i, " netmask %s up", return_value_inet_ntoa$53);
            i=system(buf);
          }

          in.s_addr = pc->ip4.ip;
          char *return_value_inet_ntoa$54;
          return_value_inet_ntoa$54=inet_ntoa(in);
          printf("PC%d : %s", pcid + 1, return_value_inet_ntoa$54);
          in.s_addr=ntohl((unsigned int)ip_masks[(signed long int)icidr]);
          char *return_value_inet_ntoa$55;
          return_value_inet_ntoa$55=inet_ntoa(in);
          printf(" %s", return_value_inet_ntoa$55);
          if(!(hasgip == 0))
          {
            in.s_addr = (unsigned int)pc->ip4.gw;
            char *return_value_inet_ntoa$56;
            return_value_inet_ntoa$56=inet_ntoa(in);
            printf(" gateway %s", return_value_inet_ntoa$56);
          }

          printf("\n");
          return 1;
        }
      }
    }
  }
}

// run_ipset6
// file command6.h line 35
signed int run_ipset6(signed int argc, char **argv)
{
  char buf[47l];
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  struct in6_addr ipaddr;
  signed int hasMask = 0;
  struct packet *m;
  signed int eui64 = 0;
  signed int return_value_strcasecmp$1;
  _Bool tmp_if_expr$3;
  signed int return_value_strcasecmp$2;
  signed int return_value_strcasecmp$4;
  _Bool tmp_if_expr$6;
  signed int return_value_strcasecmp$5;
  signed int return_value_vinet_pton6$8;
  signed int tmp_if_expr$7;
  switch(argc)
  {
    case 1:
    {
      run_show6(pc);
      return 1;
    }
    case 4:
    {
      return_value_strcasecmp$1=strcasecmp(argv[(signed long int)3], "eui-64");
      if(return_value_strcasecmp$1 == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_strcasecmp$2=strcasecmp(argv[(signed long int)3], "eui64");
        tmp_if_expr$3 = !(return_value_strcasecmp$2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        eui64 = 1;

    }
    case 3:
    {
      return_value_strcasecmp$4=strcasecmp(argv[(signed long int)2], "eui-64");
      if(return_value_strcasecmp$4 == 0)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_strcasecmp$5=strcasecmp(argv[(signed long int)2], "eui64");
        tmp_if_expr$6 = !(return_value_strcasecmp$5 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        eui64 = 1;

      else
      {
        pc->ip6.cidr=atoi(argv[(signed long int)2]);
        if(pc->ip6.cidr == 0)
          pc->ip6.cidr = 64;

        hasMask = 1;
      }
    }
    case 2:
    {
      if(hasMask == 0)
        pc->ip6.cidr = 64;

      return_value_vinet_pton6$8=vinet_pton6(10, argv[(signed long int)1], (void *)&ipaddr);
      if(return_value_vinet_pton6$8 == 1)
      {
        vinet_ntop6(10, (const void *)&ipaddr, buf, (unsigned int)(46 + 1));
        memcpy((void *)pc->ip6.ip.uaddr._a8, (const void *)ipaddr.__in6_u.__u6_addr8, (unsigned long int)16);
        if(!(eui64 == 0))
        {
          pc->ip6.ip.uaddr._a8[(signed long int)15] = pc->ip4.mac[(signed long int)5];
          pc->ip6.ip.uaddr._a8[(signed long int)14] = pc->ip4.mac[(signed long int)4];
          pc->ip6.ip.uaddr._a8[(signed long int)13] = pc->ip4.mac[(signed long int)3];
          pc->ip6.ip.uaddr._a8[(signed long int)12] = (unsigned char)0xfe;
          pc->ip6.ip.uaddr._a8[(signed long int)11] = (unsigned char)0xff;
          pc->ip6.ip.uaddr._a8[(signed long int)10] = pc->ip4.mac[(signed long int)2];
          pc->ip6.ip.uaddr._a8[(signed long int)9] = pc->ip4.mac[(signed long int)1];
          if(!((0x20 & (signed int)pc->ip4.mac[0l]) == 0))
            tmp_if_expr$7 = (signed int)pc->ip4.mac[(signed long int)0] & 0xef;

          else
            tmp_if_expr$7 = (signed int)pc->ip4.mac[(signed long int)0] | 0x20;
          pc->ip6.ip.uaddr._a8[(signed long int)8] = (unsigned char)tmp_if_expr$7;
          pc->ip6.type = 1;
        }

        else
          pc->ip6.type = 0;
        memset((void *)buf, 0, (unsigned long int)(46 + 1));
        memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)pc->ip6.ip.uaddr._a8, (unsigned long int)16);
        vinet_ntop6(10, (const void *)&ipaddr, buf, (unsigned int)(46 + 1));
        printf("PC%d : %s/%d %s\n", pcid + 1, (const void *)buf, pc->ip6.cidr, pc->ip6.type == 1 ? "eui-64" : "");
        m=nbr_sol(pc);
        if(m == ((struct packet *)NULL))
        {
          printf("out of memory\n");
          return 1;
        }

        enq(&pc->oq, m);
      }

      else
        printf("Invalid ipv6 address.\n");
      break;
    }
    default:
      printf("Invalid.\n");
  }
  return 1;
}

// run_list
// file hv.c line 602
static signed int run_list(signed int ac, char **av)
{
  signed int i;
  signed int k;
  fprintf(fptys, "ID\tPID\tParameters\r\n");
  i = 0;
  k = 1;
  for( ; !(i >= 10); i = i + 1)
    if(!(vpcs_list[(signed long int)i].pid == 0))
    {
      signed int return_value_kill$1;
      return_value_kill$1=kill(vpcs_list[(signed long int)i].pid, 0);
      if(!(return_value_kill$1 == 0))
        vpcs_list[(signed long int)i].pid = 0;

      else
      {
        fprintf(fptys, "%-2d\t%-5d\t%s\r\n", k, vpcs_list[(signed long int)i].pid, vpcs_list[(signed long int)i].cmdline);
        k = k + 1;
      }
    }

  do
  {
    fprintf(fptys, "100-");
    fprintf(fptys, "OK\r\n");
    fflush(fptys);
  }
  while((_Bool)0);
  return 0;
}

// run_load
// file command.h line 43
signed int run_load(signed int argc, char **argv)
{
  struct _IO_FILE *fp;
  char buf[128l];
  char fname[4096l];
  char *filename = "startup.vpc";
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(argc >= 3)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    if(argc == 2)
    {
      return_value_strcmp$2=strcmp(argv[(signed long int)1], "?");
      tmp_if_expr$3 = !(return_value_strcmp$2 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
  {
    signed int return_value_help_load$1;
    return_value_help_load$1=help_load(argc, argv);
    return return_value_help_load$1;
  }

  else
    if(argc == 2)
      filename = argv[(signed long int)1];

  fp=fopen(filename, "r");
  unsigned long int return_value_strlen$5;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    char *return_value_strrchr$6;
    return_value_strrchr$6=strrchr(filename, 46);
    if(return_value_strrchr$6 == ((char *)NULL))
    {
      return_value_strlen$5=strlen(filename);
      if(!(return_value_strlen$5 >= 4091ul))
      {
        memset((void *)fname, 0, (unsigned long int)4096);
        strncpy(fname, filename, (unsigned long int)(4096 - 1));
        strcat(fname, ".vpc");
        fp=fopen(fname, "r");
      }

    }

  }

  signed int return_value_feof$7;
  _Bool tmp_if_expr$9;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    printf("Can't open \"%s\"\n", filename);
    return -1;
  }

  else
  {
    if(!(runStartup == 0))
      printf("\nExecuting the startup file\n");

    else
      printf("\nExecuting the file \"%s\"\n", filename);
    do
    {
      return_value_feof$7=feof(fp);
      if(!(return_value_feof$7 == 0))
        break;

      if(!(ctrl_c == 0))
        break;

      runLoad = 1;
      char *return_value_fgets$8;
      return_value_fgets$8=fgets(buf, 128, fp);
      if(return_value_fgets$8 == ((char *)NULL))
        break;

      ttrim(buf);
      if((signed int)buf[0l] == 35)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = (signed int)buf[(signed long int)0] == 59 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$9)
      {
        unsigned long int return_value_strlen$10;
        return_value_strlen$10=strlen(buf);
        if(return_value_strlen$10 >= 1ul)
          parse_cmd(buf);

      }

    }
    while((_Bool)1);
    runLoad = 0;
    fclose(fp);
    return 1;
  }
}

// run_nb6
// file command6.h line 38
signed int run_nb6(signed int argc, char **argv)
{
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  char buf[47l];
  struct in6_addr ipaddr;
  signed int i;
  signed int j;
  printf("\n");
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(pc->ipmac6[(signed long int)i].timeout >= 1)
    {
      j = 0;
      for( ; !(j >= 6); j = j + 1)
        sprintf(buf + (signed long int)(j * 3), "%2.2x:", pc->ipmac6[(signed long int)i].mac[(signed long int)j]);
      buf[(signed long int)17] = (char)0;
      printf("%s", (const void *)buf);
      memset((void *)buf, 0, (unsigned long int)(46 + 1));
      memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)pc->ipmac6[(signed long int)i].ip.uaddr._a8, (unsigned long int)16);
      vinet_ntop6(10, (const void *)&ipaddr, buf, (unsigned int)(46 + 1));
      printf("   %s/%d\n", (const void *)buf, pc->ipmac6[(signed long int)i].cidr);
    }

  return 1;
}

// run_ping
// file command.h line 32
signed int run_ping(signed int argc, char **argv)
{
  signed int i;
  signed int j;
  signed int gip;
  unsigned int gwip;
  struct in_addr in;
  struct packet *m;
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  char dname[256l];
  unsigned char flags;
  char proto_seq[16l];
  signed int count = 5;
  signed int interval = 1000;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$2;
  _Bool tmp_if_expr$4;
  if(!(argc >= 2))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(argc == 2)
    {
      return_value_strlen$2=strlen(argv[(signed long int)1]);
      tmp_if_expr$3 = return_value_strlen$2 == (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (signed int)argv[(signed long int)1][(signed long int)0] == 63 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    signed int return_value_help_ping$1;
    return_value_help_ping$1=help_ping(argc, argv);
    return return_value_help_ping$1;
  }

  pc->mscb.frag = 0;
  pc->mscb.mtu = pc->ip4.mtu;
  pc->mscb.waittime = (unsigned int)1000;
  signed long int return_value_time$6;
  return_value_time$6=time(((signed long int *)NULL));
  pc->mscb.ipid = (unsigned int)(return_value_time$6 & (signed long int)0xffff);
  signed long int return_value_time$7;
  return_value_time$7=time(((signed long int *)NULL));
  pc->mscb.seq = (unsigned int)return_value_time$7;
  pc->mscb.proto = 1;
  pc->mscb.ttl = (unsigned char)64;
  pc->mscb.dsize = 64;
  signed long int return_value_random$8;
  return_value_random$8=random();
  pc->mscb.sport = (unsigned int)(return_value_random$8 % (signed long int)(65000 - 1024) + (signed long int)1024);
  pc->mscb.dport = (unsigned int)7;
  pc->mscb.sip = pc->ip4.ip;
  memcpy((void *)pc->mscb.smac, (const void *)pc->ip4.mac, (unsigned long int)6);
  strcpy(proto_seq, "icmp_seq");
  i = 2;
  signed int tmp_post$9;
  signed int tmp_post$10;
  _Bool tmp_if_expr$11;
  signed int tmp_post$12;
  signed int tmp_post$13;
  signed int tmp_post$14;
  signed int tmp_post$15;
  signed int return_value_atoi$16;
  signed int tmp_post$17;
  signed int return_value_atoi$18;
  signed int tmp_post$19;
  signed int return_value_atoi$20;
  unsigned long int return_value_strlen$21;
  signed int tmp_post$22;
  signed int tmp_post$23;
  signed int return_value_atoi$24;
  while(!(i >= argc))
  {
    signed int c;
    tmp_post$9 = i;
    i = i + 1;
    if((signed int)*argv[(signed long int)tmp_post$9] == 45)
    {
      c = (signed int)argv[(signed long int)(i - 1)][(signed long int)1];
      switch(c)
      {
        case 68:
        {
          pc->mscb.frag = 1;
          break;
        }
        case 117:
        {
          if(!(i >= argc))
          {
            tmp_post$10 = i;
            i = i + 1;
            pc->mscb.mtu=atoi(argv[(signed long int)tmp_post$10]);
          }

          if(!(pc->mscb.mtu >= 576))
            tmp_if_expr$11 = (_Bool)1;

          else
            tmp_if_expr$11 = pc->mscb.mtu > 65535 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$11)
            pc->mscb.mtu = 1500;

        }
        case 49:
        {
          pc->mscb.proto = 1;
          strcpy(proto_seq, "icmp_seq");
          break;
        }
        case 50:
        {
          pc->mscb.proto = 17;
          strcpy(proto_seq, "udp_seq");
          break;
        }
        case 51:
        {
          pc->mscb.proto = 6;
          strcpy(proto_seq, "tcp_seq");
          break;
        }
        case 80:
        {
          if(!(i >= argc))
          {
            signed int pro;
            tmp_post$12 = i;
            i = i + 1;
            pro=atoi(argv[(signed long int)tmp_post$12]);
            if(pro == 1)
            {
              pc->mscb.proto = 1;
              strcpy(proto_seq, "icmp_seq");
            }

            else
              if(pro == 17)
              {
                pc->mscb.proto = 17;
                strcpy(proto_seq, "udp_seq");
              }

              else
                if(pro == 6)
                {
                  pc->mscb.proto = 6;
                  strcpy(proto_seq, "tcp_seq");
                }

          }

          break;
        }
        case 99:
        {
          if(!(i >= argc))
          {
            tmp_post$13 = i;
            i = i + 1;
            count=atoi(argv[(signed long int)tmp_post$13]);
          }

          break;
        }
        case 108:
        {
          if(!(i >= argc))
          {
            tmp_post$14 = i;
            i = i + 1;
            pc->mscb.dsize=atoi(argv[(signed long int)tmp_post$14]);
          }

          break;
        }
        case 84:
        {
          if(!(i >= argc))
          {
            tmp_post$15 = i;
            i = i + 1;
            return_value_atoi$16=atoi(argv[(signed long int)tmp_post$15]);
            pc->mscb.ttl = (unsigned char)return_value_atoi$16;
          }

          break;
        }
        case 115:
        {
          if(!(i >= argc))
          {
            tmp_post$17 = i;
            i = i + 1;
            return_value_atoi$18=atoi(argv[(signed long int)tmp_post$17]);
            pc->mscb.sport = (unsigned int)return_value_atoi$18;
          }

          break;
        }
        case 112:
        {
          if(!(i >= argc))
          {
            tmp_post$19 = i;
            i = i + 1;
            return_value_atoi$20=atoi(argv[(signed long int)tmp_post$19]);
            pc->mscb.dport = (unsigned int)return_value_atoi$20;
          }

          break;
        }
        case 97:
        {
          if(!(i >= argc))
            pc->mscb.aproto=atoi(argv[(signed long int)i]);

          break;
        }
        case 102:
        {
          if(!(i >= argc))
          {
            j = 0;
            do
            {
              return_value_strlen$21=strlen(argv[(signed long int)i]);
              if((unsigned long int)j >= return_value_strlen$21)
                break;

              switch((signed int)argv[(signed long int)i][(signed long int)j] | 0x20)
              {
                case 99:
                {
                  pc->mscb.flags = pc->mscb.flags | (unsigned char)0x80;
                  break;
                }
                case 101:
                {
                  pc->mscb.flags = pc->mscb.flags | (unsigned char)0x40;
                  break;
                }
                case 117:
                {
                  pc->mscb.flags = pc->mscb.flags | (unsigned char)0x20;
                  break;
                }
                case 97:
                {
                  pc->mscb.flags = pc->mscb.flags | (unsigned char)0x10;
                  break;
                }
                case 112:
                {
                  pc->mscb.flags = pc->mscb.flags | (unsigned char)0x08;
                  break;
                }
                case 114:
                {
                  pc->mscb.flags = pc->mscb.flags | (unsigned char)0x04;
                  break;
                }
                case 115:
                {
                  pc->mscb.flags = pc->mscb.flags | (unsigned char)0x02;
                  break;
                }
                case 102:
                {
                  pc->mscb.flags = pc->mscb.flags | (unsigned char)0x01;
                  break;
                }
                default:
                {
                  printf("Invalid options\n");
                  return 0;
                }
              }
              j = j + 1;
            }
            while((_Bool)1);
            i = i + 1;
          }

          break;
        }
        case 105:
        {
          if(!(i >= argc))
          {
            tmp_post$22 = i;
            i = i + 1;
            interval=atoi(argv[(signed long int)tmp_post$22]);
          }

          if(!(interval >= 1))
            interval = 1000;

          break;
        }
        case 119:
        {
          if(!(i >= argc))
          {
            tmp_post$23 = i;
            i = i + 1;
            return_value_atoi$24=atoi(argv[(signed long int)tmp_post$23]);
            pc->mscb.waittime = (unsigned int)return_value_atoi$24;
          }

          if(!(pc->mscb.waittime >= 1u))
            pc->mscb.waittime = (unsigned int)1000;

          break;
        }
        case 116:
        {
          count = -1;
          break;
        }
        default:
        {
          printf("Invalid options\n");
          return 0;
        }
      }
    }

  }
  if((signed int)pc->mscb.winsize == 0)
    pc->mscb.winsize = (unsigned short int)0xb68;

  char *return_value_strchr$26;
  return_value_strchr$26=strchr(argv[(signed long int)1], 58);
  if(!(return_value_strchr$26 == ((char *)NULL)))
  {
    pc->mscb.mtu = pc->ip6.mtu;
    signed int return_value_run_ping6$25;
    return_value_run_ping6$25=run_ping6(argc, argv);
    return return_value_run_ping6$25;
  }

  pc->mscb.dip=inet_addr(argv[(signed long int)1]);
  _Bool tmp_if_expr$29;
  if(pc->mscb.dip == 4294967295u)
    tmp_if_expr$29 = (_Bool)1;

  else
    tmp_if_expr$29 = pc->mscb.dip == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$29)
  {
    strcpy(dname, argv[(signed long int)1]);
    signed int return_value_hostresolv$28;
    return_value_hostresolv$28=hostresolv(pc, dname, &pc->mscb.dip);
    if(return_value_hostresolv$28 == 0)
    {
      printf("Cannot resolve %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
    {
      in.s_addr = pc->mscb.dip;
      char *return_value_inet_ntoa$27;
      return_value_inet_ntoa$27=inet_ntoa(in);
      printf("%s resolved to %s\n", (const void *)dname, return_value_inet_ntoa$27);
    }
  }

  signed int tmp_post$31;
  signed int return_value_sameNet$32;
  signed int return_value_arpResolve$34;
  _Bool tmp_if_expr$53;
  signed int tmp_post$35;
  signed int tmp_post$39;
  struct packet *p;
  struct timeval tv;
  unsigned int run_ping$$1$$9$$1$$usec;
  signed int respok;
  signed int return_value_timeout$41;
  _Bool tmp_if_expr$44;
  _Bool tmp_if_expr$45;
  _Bool tmp_if_expr$46;
  signed int tmp_post$43;
  struct in_addr run_ping$$1$$9$$1$$2$$1$$2$$din;
  char *return_value_inet_ntoa$47;
  char *return_value_inet_ntoa$48;
  signed int tmp_post$50;
  signed int tmp_post$52;
  if(pc->mscb.dip == pc->ip4.ip)
  {
    i = 1;
    in.s_addr = pc->mscb.dip;
    while(ctrl_c == 0 && (count == -1 || count >= i))
    {
      char *return_value_inet_ntoa$30;
      return_value_inet_ntoa$30=inet_ntoa(in);
      tmp_post$31 = i;
      i = i + 1;
      printf("%s icmp_seq=%d ttl=%d time=0.001 ms\n", return_value_inet_ntoa$30, tmp_post$31, pc->mscb.ttl);
      usleep((unsigned int)(1 * 1000));
    }
    return 1;
  }

  else
  {
    gwip = (unsigned int)pc->ip4.gw;
    flags = pc->mscb.flags;
    do
    {

    redirect:
      ;
      return_value_sameNet$32=sameNet((unsigned long int)pc->mscb.dip, (unsigned long int)pc->ip4.ip, pc->ip4.cidr);
      if(!(return_value_sameNet$32 == 0))
        gip = (signed int)pc->mscb.dip;

      else
        if(gwip == 0u)
        {
          printf("No gateway found\n");
          return 0;
        }

        else
          gip = (signed int)gwip;
      in.s_addr = pc->mscb.dip;
      return_value_arpResolve$34=arpResolve(pc, (unsigned int)gip, pc->mscb.dmac);
      if(return_value_arpResolve$34 == 0)
      {
        in.s_addr = (unsigned int)gip;
        char *return_value_inet_ntoa$33;
        return_value_inet_ntoa$33=inet_ntoa(in);
        printf("host (%s) not reachable\n", return_value_inet_ntoa$33);
        return 0;
      }

      pc->mscb.flags = flags;
      if(pc->mscb.proto == 6)
        tmp_if_expr$53 = (signed int)pc->mscb.flags == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$53 = (_Bool)0;
      if(tmp_if_expr$53)
      {
        i = 0;
        do
        {
          tmp_post$35 = i;
          i = i + 1;
          if(tmp_post$35 >= count)
          {
            if(!(count == -1))
              break;

          }

          if(!(ctrl_c == 0))
            break;

          struct timeval ts0;
          struct timeval ts;
          unsigned int usec;
          signed int k;
          signed int dsize = pc->mscb.dsize;
          signed int traveltime = 1;
          if(i >= 2)
            usleep(pc->mscb.waittime * (unsigned int)1000);

          do
          {
            m=deq(&pc->iq);
            if(m == ((struct packet *)NULL))
              break;

            del_pkt(m);
          }
          while((_Bool)1);
          gettimeofday(&ts, (struct timezone *)(void *)0);
          k=tcp_open(4);
          pc->mscb.dsize = dsize;
          gettimeofday(&ts0, (struct timezone *)(void *)0);
          usec = (unsigned int)(((ts0.tv_sec - ts.tv_sec) * (signed long int)1000000 + ts0.tv_usec) - ts.tv_usec);
          if(k == 0)
          {
            printf("Connect   %d@%s timeout\n", pc->mscb.dport, argv[(signed long int)1]);
            continue;
          }

          else
            if(k == 2)
            {
              struct in_addr din;
              din.s_addr = pc->mscb.rdip;
              if((signed int)pc->mscb.icmptype == 5)
              {
                if((signed int)pc->mscb.icmpcode == 0)
                {
                  din.s_addr = (unsigned int)pc->ip4.gw;
                  char *return_value_inet_ntoa$36;
                  return_value_inet_ntoa$36=inet_ntoa(din);
                  printf("Redirect Network, gateway %s", return_value_inet_ntoa$36);
                  din.s_addr = pc->mscb.rdip;
                  char *return_value_inet_ntoa$37;
                  return_value_inet_ntoa$37=inet_ntoa(din);
                  printf(" -> %s\n", return_value_inet_ntoa$37);
                  gwip = pc->mscb.rdip;
                  usleep((unsigned int)(100 * 1000));
                  goto redirect;
                }

              }

              char *return_value_inet_ntoa$38;
              return_value_inet_ntoa$38=inet_ntoa(din);
              tmp_post$39 = i;
              i = i + 1;
              printf("*%s %s=%d ttl=%d time=%.3f ms", return_value_inet_ntoa$38, (const void *)proto_seq, tmp_post$39, pc->mscb.rttl, (double)usec / 1000.0);
              const char *return_value_icmpTypeCode2String$40;
              return_value_icmpTypeCode2String$40=icmpTypeCode2String(4, pc->mscb.icmptype, pc->mscb.icmpcode);
              printf(" (ICMP type:%d, code:%d, %s)\n", pc->mscb.icmptype, pc->mscb.icmpcode, return_value_icmpTypeCode2String$40);
              continue;
            }

            else
              if(k == 3)
              {
                printf("Connect   %d@%s RST returned\n", pc->mscb.dport, argv[(signed long int)1]);
                continue;
              }

          printf("Connect   %d@%s seq=%d ttl=%d time=%.3f ms\n", pc->mscb.dport, argv[(signed long int)1], i, pc->mscb.rttl, (double)usec / 1000.0);
          traveltime = (signed int)((0.6 * (double)usec) / (double)1000);
          usleep((unsigned int)(traveltime * 1000));
          gettimeofday(&ts, (struct timezone *)(void *)0);
          k=tcp_send(4);
          if(k == 0)
            printf("SendData  %d@%s timeout\n", pc->mscb.dport, argv[(signed long int)1]);

          else
          {
            gettimeofday(&ts0, (struct timezone *)(void *)0);
            usec = (unsigned int)(((ts0.tv_sec - ts.tv_sec) * (signed long int)1000000 + ts0.tv_usec) - ts.tv_usec);
            printf("SendData  %d@%s seq=%d ttl=%d time=%.3f ms\n", pc->mscb.dport, argv[(signed long int)1], i, pc->mscb.rttl, (double)usec / 1000.0);
            if(!(k == 2))
              usleep((unsigned int)(traveltime * 1000));

            gettimeofday(&ts, (struct timezone *)(void *)0);
            k=tcp_close(4);
            if(k == 0)
              printf("Close     %d@%s timeout\n", pc->mscb.dport, argv[(signed long int)1]);

            else
            {
              gettimeofday(&ts0, (struct timezone *)(void *)0);
              usec = (unsigned int)(((ts0.tv_sec - ts.tv_sec) * (signed long int)1000000 + ts0.tv_usec) - ts.tv_usec);
              printf("Close     %d@%s seq=%d ttl=%d time=%.3f ms\n", pc->mscb.dport, argv[(signed long int)1], i, pc->mscb.rttl, (double)usec / 1000.0);
            }
          }
        }
        while((_Bool)1);
        goto __CPROVER_DUMP_L108;
      }

      i = 1;

    __CPROVER_DUMP_L91:
      ;
      if(!(ctrl_c == 0) || !(count == -1) && !(count >= i))
        goto __CPROVER_DUMP_L108;

      p = (struct packet *)(void *)0;
      respok = 0;
      pc->mscb.sn = (unsigned int)i;
      pc->mscb.timeout = time_tick;
      m=packet(&pc->mscb);
      if(m == ((struct packet *)NULL))
      {
        printf("out of memory\n");
        return 0;
      }

      do
      {
        p=deq(&pc->iq);
        if(p == ((struct packet *)NULL))
          break;

        del_pkt(p);
      }
      while((_Bool)1);
      gettimeofday(&tv, (struct timezone *)(void *)0);
      enq(&pc->oq, m);

    __CPROVER_DUMP_L94:
      ;
      return_value_timeout$41=timeout(tv, (signed int)pc->mscb.waittime);
      if(!(return_value_timeout$41 == 0))
        goto __CPROVER_DUMP_L106;

      if(!(respok == 0))
        goto __CPROVER_DUMP_L106;

      if(!(ctrl_c == 0))
        goto __CPROVER_DUMP_L106;

      usleep((unsigned int)(1 * 1000));
      respok = 0;

    __CPROVER_DUMP_L95:
      ;
      p=deq(&pc->iq);
      if(p == ((struct packet *)NULL))
        goto __CPROVER_DUMP_L105;

      if(!(respok == 0))
        goto __CPROVER_DUMP_L105;

      if(!(ctrl_c == 0))
        goto __CPROVER_DUMP_L105;

      pc->mscb.icmpcode = (unsigned char)0;
      pc->mscb.icmptype = pc->mscb.icmpcode;
      respok=response(p, &pc->mscb);
      run_ping$$1$$9$$1$$usec = (unsigned int)(((p->ts.tv_sec - tv.tv_sec) * (signed long int)1000000 + p->ts.tv_usec) - tv.tv_usec);
      del_pkt(p);
      if(respok == 0)
        goto __CPROVER_DUMP_L104;

      if(pc->mscb.proto == 1)
        tmp_if_expr$44 = (signed int)pc->mscb.icmptype == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$44 = (_Bool)0;
      if(tmp_if_expr$44)
        tmp_if_expr$45 = (_Bool)1;

      else
        tmp_if_expr$45 = (pc->mscb.proto == 17 ? (respok == 17 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$45)
        tmp_if_expr$46 = (_Bool)1;

      else
        tmp_if_expr$46 = (pc->mscb.proto == 6 ? (respok == 6 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$46)
      {
        char *return_value_inet_ntoa$42;
        return_value_inet_ntoa$42=inet_ntoa(in);
        tmp_post$43 = i;
        i = i + 1;
        printf("%s %s=%d ttl=%d time=%.3f ms\n", return_value_inet_ntoa$42, (const void *)proto_seq, tmp_post$43, pc->mscb.rttl, (double)run_ping$$1$$9$$1$$usec / 1000.0);
        goto __CPROVER_DUMP_L105;
      }

      if(!(respok == 1))
        goto __CPROVER_DUMP_L104;

      if(!((signed int)pc->mscb.icmptype == 5))
        break;

      if(!((signed int)pc->mscb.icmpcode == 0))
        break;

      run_ping$$1$$9$$1$$2$$1$$2$$din.s_addr = (unsigned int)pc->ip4.gw;
      return_value_inet_ntoa$47=inet_ntoa(run_ping$$1$$9$$1$$2$$1$$2$$din);
      printf("Redirect Network, gateway %s", return_value_inet_ntoa$47);
      run_ping$$1$$9$$1$$2$$1$$2$$din.s_addr = pc->mscb.rdip;
      return_value_inet_ntoa$48=inet_ntoa(run_ping$$1$$9$$1$$2$$1$$2$$din);
      printf(" -> %s\n", return_value_inet_ntoa$48);
      gwip = pc->mscb.rdip;
      usleep((unsigned int)(100 * 1000));
    }
    while((_Bool)1);
    run_ping$$1$$9$$1$$2$$1$$2$$din.s_addr = pc->mscb.rdip;
    char *return_value_inet_ntoa$49;
    return_value_inet_ntoa$49=inet_ntoa(run_ping$$1$$9$$1$$2$$1$$2$$din);
    tmp_post$50 = i;
    i = i + 1;
    printf("*%s %s=%d ttl=%d time=%.3f ms", return_value_inet_ntoa$49, (const void *)proto_seq, tmp_post$50, pc->mscb.rttl, (double)run_ping$$1$$9$$1$$usec / 1000.0);
    const char *return_value_icmpTypeCode2String$51;
    return_value_icmpTypeCode2String$51=icmpTypeCode2String(4, pc->mscb.icmptype, pc->mscb.icmpcode);
    printf(" (ICMP type:%d, code:%d, %s)\n", pc->mscb.icmptype, pc->mscb.icmpcode, return_value_icmpTypeCode2String$51);
    goto __CPROVER_DUMP_L105;

  __CPROVER_DUMP_L104:
    ;
    goto __CPROVER_DUMP_L95;

  __CPROVER_DUMP_L105:
    ;
    goto __CPROVER_DUMP_L94;

  __CPROVER_DUMP_L106:
    ;
    if(ctrl_c == 0 && respok == 0)
    {
      tmp_post$52 = i;
      i = i + 1;
      printf("%s %s=%d timeout\n", argv[(signed long int)1], (const void *)proto_seq, tmp_post$52);
    }

    usleep((unsigned int)(interval * 1000));
    goto __CPROVER_DUMP_L91;

  __CPROVER_DUMP_L108:
    ;
    return 1;
  }
}

// run_ping6
// file command6.h line 33
signed int run_ping6(signed int argc, char **argv)
{
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  struct in6_addr ipaddr;
  struct packet *m = (struct packet *)(void *)0;
  signed int i;
  char *p;
  char proto_seq[16l];
  signed int count = 5;
  printf("\n");
  i = 2;
  i = 2;
  signed int return_value_digitstring$1;
  for( ; !(i >= argc); i = i + 1)
  {
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(argv[(signed long int)i], "-c");
    if(return_value_strcmp$2 == 0)
    {
      if(!(1 + i >= argc))
      {
        return_value_digitstring$1=digitstring(argv[(signed long int)(i + 1)]);
        if(!(return_value_digitstring$1 == 0))
          count=atoi(argv[(signed long int)(i + 1)]);

      }

      break;
    }

  }
  signed int return_value_vinet_pton6$3;
  return_value_vinet_pton6$3=vinet_pton6(10, argv[(signed long int)1], (void *)&ipaddr);
  signed int tmp_post$4;
  _Bool tmp_if_expr$19;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int return_value_timeout$10;
  signed int return_value_timeout$11;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  signed int tmp_post$12;
  signed int tmp_post$16;
  signed int tmp_post$18;
  if(!(return_value_vinet_pton6$3 == 1))
  {
    printf("Invalid address: %s\n", argv[(signed long int)1]);
    return 0;
  }

  else
  {
    memcpy((void *)pc->mscb.dip6.uaddr._a8, (const void *)ipaddr.__in6_u.__u6_addr8, (unsigned long int)16);
    if(!((signed int)pc->mscb.dip6.uaddr._a16[0l] == 0x80fe))
      memcpy((void *)pc->mscb.sip6.uaddr._a8, (const void *)pc->ip6.ip.uaddr._a8, (unsigned long int)16);

    else
      memcpy((void *)pc->mscb.sip6.uaddr._a8, (const void *)pc->link6.ip.uaddr._a8, (unsigned long int)16);
    signed int return_value_memcmp$5;
    return_value_memcmp$5=memcmp((const void *)(&pc->mscb.sip6)->uaddr._a8, (const void *)(&pc->mscb.dip6)->uaddr._a8, (unsigned long int)16);
    if(return_value_memcmp$5 == 0)
    {
      i = 1;
      while(!(i >= 6))
      {
        tmp_post$4 = i;
        i = i + 1;
        printf("%s icmp_seq=%d ttl=%d time=0.001 ms\n", argv[(signed long int)1], tmp_post$4, pc->mscb.ttl);
        usleep((unsigned int)(1 * 1000));
      }
      return 1;
    }

    else
    {
      unsigned char *return_value_nbDiscovery$6;
      return_value_nbDiscovery$6=nbDiscovery(pc, &pc->mscb.dip6);
      p = (char *)return_value_nbDiscovery$6;
      if(p == ((char *)NULL))
      {
        printf("host (%s) not reachable\n", argv[(signed long int)1]);
        return 0;
      }

      else
      {
        memcpy((void *)pc->mscb.dmac, (const void *)p, (unsigned long int)6);
        if(pc->mscb.proto == 1)
        {
          pc->mscb.proto = 58;
          strcpy(proto_seq, "icmp6_seq");
        }

        else
          if(pc->mscb.proto == 6)
            strcpy(proto_seq, "tcp6_seq");

          else
            if(pc->mscb.proto == 17)
              strcpy(proto_seq, "udp6_seq");

        if(pc->mscb.proto == 6)
          tmp_if_expr$19 = (signed int)pc->mscb.flags == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$19 = (_Bool)0;
        if(tmp_if_expr$19)
        {
          i = 0;
          do
          {
            tmp_post$7 = i;
            i = i + 1;
            if(tmp_post$7 >= count)
            {
              if(!(count == -1))
                break;

            }

            if(!(ctrl_c == 0))
              break;

            struct timeval ts0;
            struct timeval ts;
            unsigned int usec;
            signed int k;
            signed int dsize = pc->mscb.dsize;
            signed int traveltime = 1;
            if(i >= 2)
              usleep(pc->mscb.waittime * (unsigned int)1000);

            do
            {
              m=deq(&pc->iq);
              if(m == ((struct packet *)NULL))
                break;

            }
            while((_Bool)1);
            gettimeofday(&ts, (struct timezone *)(void *)0);
            k=tcp_open(0x60);
            pc->mscb.dsize = dsize;
            gettimeofday(&ts0, (struct timezone *)(void *)0);
            usec = (unsigned int)(((ts0.tv_sec - ts.tv_sec) * (signed long int)1000000 + ts0.tv_usec) - ts.tv_usec);
            if(k == 0)
            {
              printf("Connect   %d@%s timeout\n", pc->mscb.dport, argv[(signed long int)1]);
              continue;
            }

            else
              if(k == 2)
              {
                char buf[47l];
                memset((void *)buf, 0, sizeof(char [47l]) /*47ul*/ );
                vinet_ntop6(10, (const void *)&pc->mscb.rdip6, buf, (unsigned int)(46 + 1));
                tmp_post$8 = i;
                i = i + 1;
                printf("*%s %s=%d ttl=%d time=%.3f ms", (const void *)buf, (const void *)proto_seq, tmp_post$8, pc->mscb.rttl, (double)usec / 1000.0);
                const char *return_value_icmpTypeCode2String$9;
                return_value_icmpTypeCode2String$9=icmpTypeCode2String(6, pc->mscb.icmptype, pc->mscb.icmpcode);
                printf(" (ICMP type:%d, code:%d, %s)\n", pc->mscb.icmptype, pc->mscb.icmpcode, return_value_icmpTypeCode2String$9);
                continue;
              }

              else
                if(k == 3)
                {
                  printf("Connect   %d@%s RST returned\n", pc->mscb.dport, argv[(signed long int)1]);
                  continue;
                }

            printf("Connect   %d@%s seq=%d ttl=%d time=%.3f ms\n", pc->mscb.dport, argv[(signed long int)1], i, pc->mscb.rttl, (double)usec / 1000.0);
            traveltime = (signed int)((0.6 * (double)usec) / (double)1000);
            usleep((unsigned int)(traveltime * 1000));
            gettimeofday(&ts, (struct timezone *)(void *)0);
            k=tcp_send(0x60);
            if(k == 0)
              printf("SendData  %d@%s timeout\n", pc->mscb.dport, argv[(signed long int)1]);

            else
            {
              gettimeofday(&ts0, (struct timezone *)(void *)0);
              usec = (unsigned int)(((ts0.tv_sec - ts.tv_sec) * (signed long int)1000000 + ts0.tv_usec) - ts.tv_usec);
              printf("SendData  %d@%s seq=%d ttl=%d time=%.3f ms\n", pc->mscb.dport, argv[(signed long int)1], i, pc->mscb.rttl, (double)usec / 1000.0);
              if(!(k == 2))
                usleep((unsigned int)(traveltime * 1000));

              gettimeofday(&ts, (struct timezone *)(void *)0);
              k=tcp_close(0x60);
              if(k == 0)
                printf("Close     %d@%s timeout\n", pc->mscb.dport, argv[(signed long int)1]);

              else
              {
                gettimeofday(&ts0, (struct timezone *)(void *)0);
                usec = (unsigned int)(((ts0.tv_sec - ts.tv_sec) * (signed long int)1000000 + ts0.tv_usec) - ts.tv_usec);
                printf("Close     %d@%s seq=%d ttl=%d time=%.3f ms\n", pc->mscb.dport, argv[(signed long int)1], i, pc->mscb.rttl, (double)usec / 1000.0);
              }
            }
          }
          while((_Bool)1);
        }

        else
        {
          i = 1;
          while(ctrl_c == 0 && (count == -1 || count >= i))
          {
            struct packet *run_ping6$$1$$9$$1$$p;
            struct timeval tv;
            unsigned int run_ping6$$1$$9$$1$$usec;
            signed int respok = 0;
            pc->mscb.sn = (unsigned int)i;
            pc->mscb.timeout = time_tick;
            m=packet6(&pc->mscb);
            if(m == ((struct packet *)NULL))
            {
              printf("out of memory\n");
              return 0;
            }

            gettimeofday(&tv, (struct timezone *)(void *)0);
            enq(&pc->oq, m);
            do
            {
              return_value_timeout$10=timeout(tv, (signed int)pc->mscb.waittime);
              if(!(return_value_timeout$10 == 0))
                break;

              if(!(ctrl_c == 0))
                break;

              usleep((unsigned int)(1 * 1000));
              respok = 0;
              do
              {
                run_ping6$$1$$9$$1$$p=deq(&pc->iq);
                if(run_ping6$$1$$9$$1$$p == ((struct packet *)NULL))
                  break;

                if(!(respok == 0))
                  break;

                return_value_timeout$11=timeout(tv, (signed int)pc->mscb.waittime);
                if(!(return_value_timeout$11 == 0))
                  break;

                if(!(ctrl_c == 0))
                  break;

                pc->mscb.icmpcode = (unsigned char)0;
                pc->mscb.icmptype = pc->mscb.icmpcode;
                respok=response6(run_ping6$$1$$9$$1$$p, &pc->mscb);
                run_ping6$$1$$9$$1$$usec = (unsigned int)(((run_ping6$$1$$9$$1$$p->ts.tv_sec - tv.tv_sec) * (signed long int)1000000 + run_ping6$$1$$9$$1$$p->ts.tv_usec) - tv.tv_usec);
                del_pkt(run_ping6$$1$$9$$1$$p);
                if(!(respok == 0))
                {
                  tv.tv_sec = (signed long int)0;
                  if(pc->mscb.proto == 58)
                    tmp_if_expr$13 = (signed int)pc->mscb.icmptype == 129 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$13 = (_Bool)0;
                  if(tmp_if_expr$13)
                    tmp_if_expr$14 = (_Bool)1;

                  else
                    tmp_if_expr$14 = (pc->mscb.proto == 17 ? (respok == 17 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$14)
                    tmp_if_expr$15 = (_Bool)1;

                  else
                    tmp_if_expr$15 = (pc->mscb.proto == 6 ? (respok == 6 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$15)
                  {
                    tmp_post$12 = i;
                    i = i + 1;
                    printf("%s %s=%d ttl=%d time=%.3f ms\n", argv[(signed long int)1], (const void *)proto_seq, tmp_post$12, pc->mscb.rttl, (double)run_ping6$$1$$9$$1$$usec / 1000.0);
                    break;
                  }

                  if(respok == 58)
                  {
                    char run_ping6$$1$$9$$1$$2$$1$$2$$buf[47l];
                    memset((void *)run_ping6$$1$$9$$1$$2$$1$$2$$buf, 0, sizeof(char [47l]) /*47ul*/ );
                    vinet_ntop6(10, (const void *)&pc->mscb.rdip6, run_ping6$$1$$9$$1$$2$$1$$2$$buf, (unsigned int)(46 + 1));
                    tmp_post$16 = i;
                    i = i + 1;
                    printf("*%s %s=%d ttl=%d time=%.3f ms", (const void *)run_ping6$$1$$9$$1$$2$$1$$2$$buf, (const void *)proto_seq, tmp_post$16, pc->mscb.rttl, (double)run_ping6$$1$$9$$1$$usec / 1000.0);
                    const char *return_value_icmpTypeCode2String$17;
                    return_value_icmpTypeCode2String$17=icmpTypeCode2String(6, pc->mscb.icmptype, pc->mscb.icmpcode);
                    printf(" (ICMP type:%d, code:%d, %s)\n", pc->mscb.icmptype, pc->mscb.icmpcode, return_value_icmpTypeCode2String$17);
                    break;
                  }

                }

              }
              while((_Bool)1);
            }
            while((_Bool)1);
            if(ctrl_c == 0 && respok == 0)
            {
              tmp_post$18 = i;
              i = i + 1;
              printf("%s %s=%d timeout\n", argv[(signed long int)1], (const void *)proto_seq, tmp_post$18);
            }

          }
        }
        return 1;
      }
    }
  }
}

// run_quit
// file vpcs.c line 562
static signed int run_quit(signed int argc, char **argv)
{
  signed int pid;
  if(!(daemon_port == 0))
  {
    pid=getppid();
    kill(pid, 10);
  }

  sig_clean(0);
  printf("\n");
  exit(0);
}

// run_quit$link1
// file hv.c line 634
static signed int run_quit$link1(signed int ac, char **av)
{
  signed int i;
  char ans[8l];
  char *warning_quit = "Warning: there are active VPCS sessions.\r\nAre you sure you want to quit and terminate these sessions(y/N)? ";
  signed int return_value_strcmp$7;
  _Bool tmp_if_expr$10;
  signed int return_value_strcmp$9;
  if(ac == 1)
  {
    i = 0;
    for( ; !(i >= 10); i = i + 1)
      if(!(vpcs_list[(signed long int)i].pid == 0))
        break;

    if(!(i >= 10))
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(warning_quit);
      signed long int return_value_write$2;
      return_value_write$2=write(sock_cli, (const void *)warning_quit, return_value_strlen$1);
      i = (signed int)return_value_write$2;
      memset((void *)ans, 0, sizeof(char [8l]) /*8ul*/ );
      signed long int return_value_read$3;
      return_value_read$3=read(sock_cli, (void *)ans, sizeof(char [8l]) /*8ul*/ );
      i = (signed int)return_value_read$3;
      if(!(i >= 1))
        return 0;

      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(ans);
      signed long int return_value_write$5;
      return_value_write$5=write(sock_cli, (const void *)ans, return_value_strlen$4);
      i = (signed int)return_value_write$5;
      signed long int return_value_write$6;
      return_value_write$6=write(sock_cli, (const void *)"\r\n", (unsigned long int)2);
      i = (signed int)return_value_write$6;
      signed int return_value_strcmp$8;
      return_value_strcmp$8=strcmp(ans, "y");
      if(!(return_value_strcmp$8 == 0))
      {
        return_value_strcmp$7=strcmp(ans, "Y");
        if(!(return_value_strcmp$7 == 0))
          return 0;

      }

    }

  }

  else
  {
    if(ac == 2)
    {
      return_value_strcmp$9=strcmp(av[(signed long int)1], "-f");
      tmp_if_expr$10 = return_value_strcmp$9 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
      return 1;

    else
      if(ac >= 3)
      {
        do
        {
          fprintf(fptys, "200-");
          fprintf(fptys, "Invalid command\r\n");
          fflush(fptys);
        }
        while((_Bool)0);
        return 1;
      }

  }
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(!(vpcs_list[(signed long int)i].pid == 0))
    {
      kill(vpcs_list[(signed long int)i].pid, 12);
      vpcs_list[(signed long int)i].pid = 0;
      if(!(vpcs_list[(signed long int)i].cmdline == ((char *)NULL)))
        free((void *)vpcs_list[(signed long int)i].cmdline);

    }

  cmd_quit$link1 = 2;
  return 0;
}

// run_relay
// file relay.h line 33
signed int run_relay(signed int argc, char **argv)
{
  signed int port;
  struct peerlist peer;
  struct peerlist *tpeer;
  struct peerlist *peerhost;
  struct in_addr in;
  char tmp[32l];
  char *p;
  signed int i;
  signed int j;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$9;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$19;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$14;
  signed int return_value_strcmp$20;
  signed int return_value_strcmp$25;
  if(argc == 3)
  {
    return_value_strcmp$3=strcmp(argv[(signed long int)1], "port");
    if(!(return_value_strcmp$3 == 0))
      goto __CPROVER_DUMP_L5;

    port=atoi(argv[(signed long int)2]);
    if(port >= 1025 && !(port >= 65534))
      relay_port = port;

    if(!(relay_fd == 0))
    {
      close(relay_fd);
      relay_fd=open_udp(relay_port);
      if(!(relay_fd >= 1))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        printf("Open relay port %d error [%s]\n", relay_port, return_value_strerror$2);
      }

    }

    else
      printf("The port is out of range\n");
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    if(argc == 2)
    {
      return_value_strcmp$9=strcmp(argv[(signed long int)1], "show");
      if(!(return_value_strcmp$9 == 0))
        goto __CPROVER_DUMP_L11;

      printf("Relay port: %d\n", relay_port);
      peerhost = peerlist;
      printf("Relay list");
      if(peerhost == ((struct peerlist *)NULL))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)peerhost->nodea.port == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        printf(": none\n");
        return 0;
      }

      printf(":\n");
      i = 0;
      while(!(peerhost == ((struct peerlist *)NULL)))
      {
        in.s_addr = peerhost->nodea.ip;
        i = i + 1;
        char *return_value_inet_ntoa$5;
        return_value_inet_ntoa$5=inet_ntoa(in);
        unsigned short int return_value_ntohs$6;
        return_value_ntohs$6=ntohs(peerhost->nodea.port);
        printf("  %2d %s:%d", i, return_value_inet_ntoa$5, return_value_ntohs$6);
        in.s_addr = peerhost->nodeb.ip;
        char *return_value_inet_ntoa$7;
        return_value_inet_ntoa$7=inet_ntoa(in);
        unsigned short int return_value_ntohs$8;
        return_value_ntohs$8=ntohs(peerhost->nodeb.port);
        printf(" <-> %s:%d\n", return_value_inet_ntoa$7, return_value_ntohs$8);
        peerhost = peerhost->next;
      }
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L11:
      ;
      if(argc == 4)
      {
        return_value_strcmp$19=strcmp(argv[(signed long int)1], "add");
        if(return_value_strcmp$19 == 0)
        {
          p=strchr(argv[(signed long int)2], 58);
          if(!(p == ((char *)NULL)))
          {
            bzero((void *)tmp, sizeof(char [32l]) /*32ul*/ );
            strncpy(tmp, argv[(signed long int)2], (unsigned long int)(p - argv[(signed long int)2]));
            peer.nodea.ip=inet_addr(tmp);
            i=atoi(p + (signed long int)1);
            if(i >= 65535 || !(i >= 1024))
            {
              printf("port %d is out of range\n", i);
              return 0;
            }

            peer.nodea.port=htons((unsigned short int)i);
          }

          else
          {
            peer.nodea.ip=htonl((unsigned int)0x00000000);
            i=atoi(argv[(signed long int)2]);
            if(i >= 65535 || !(i >= 1024))
            {
              printf("port %d is out of range\n", i);
              return 0;
            }

            peer.nodea.port=htons((unsigned short int)i);
          }
          p=strchr(argv[(signed long int)3], 58);
          if(!(p == ((char *)NULL)))
          {
            bzero((void *)tmp, sizeof(char [32l]) /*32ul*/ );
            strncpy(tmp, argv[(signed long int)3], (unsigned long int)(p - argv[(signed long int)3]));
            peer.nodeb.ip=inet_addr(tmp);
            i=atoi(p + (signed long int)1);
            if(i >= 65535 || !(i >= 1024))
            {
              printf("port %d is out of range\n", i);
              return 0;
            }

            peer.nodeb.port=htons((unsigned short int)i);
          }

          else
          {
            peer.nodeb.ip=htonl((unsigned int)0x00000000);
            i=atoi(argv[(signed long int)3]);
            if(i >= 65535 || !(i >= 1024))
            {
              printf("port %d is out of range\n", i);
              return 0;
            }

            peer.nodeb.port=htons((unsigned short int)i);
          }
          peerhost = peerlist;
          j = 0;
          for( ; !(peerhost == ((struct peerlist *)NULL)); peerhost = peerhost->next)
          {
            if(peerhost->nodea.ip == peer.nodea.ip)
              tmp_if_expr$10 = peerhost->nodea.port == peer.nodea.port ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$10 = (_Bool)0;
            if(tmp_if_expr$10)
              tmp_if_expr$12 = (_Bool)1;

            else
            {
              if(peerhost->nodeb.ip == peer.nodea.ip)
                tmp_if_expr$11 = peerhost->nodeb.port == peer.nodea.port ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$11 = (_Bool)0;
              tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$12)
            {
              in.s_addr = peer.nodea.ip;
              port = (signed int)peer.nodea.port;
              j = 1;
              break;
            }

            if(peerhost->nodea.ip == peer.nodeb.ip)
              tmp_if_expr$13 = peerhost->nodea.port == peer.nodeb.port ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$13 = (_Bool)0;
            if(tmp_if_expr$13)
              tmp_if_expr$15 = (_Bool)1;

            else
            {
              if(peerhost->nodeb.ip == peer.nodeb.ip)
                tmp_if_expr$14 = peerhost->nodeb.port == peer.nodeb.port ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$14 = (_Bool)0;
              tmp_if_expr$15 = tmp_if_expr$14 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$15)
            {
              in.s_addr = peer.nodeb.ip;
              port = (signed int)peer.nodeb.port;
              j = 1;
              break;
            }

          }
          if(j == 1)
          {
            char *return_value_inet_ntoa$16;
            return_value_inet_ntoa$16=inet_ntoa(in);
            unsigned short int return_value_ntohs$17;
            return_value_ntohs$17=ntohs((unsigned short int)port);
            printf("%s:%d is existed\n", return_value_inet_ntoa$16, return_value_ntohs$17);
            return 0;
          }

          void *return_value_malloc$18;
          return_value_malloc$18=malloc(sizeof(struct peerlist) /*24ul*/ );
          tpeer = (struct peerlist *)return_value_malloc$18;
          if(!(tpeer == ((struct peerlist *)NULL)))
          {
            memcpy((void *)tpeer, (const void *)&peer, sizeof(struct peerlist) /*24ul*/ );
            tpeer->next = (struct peerlist *)(void *)0;
          }

          else
            printf("Out of memory\n");
          if(peerlist == ((struct peerlist *)NULL))
            peerlist = tpeer;

          else
          {
            peerhost = peerlist;
            for( ; !(peerhost->next == ((struct peerlist *)NULL)); peerhost = peerhost->next)
              ;
            peerhost->next = tpeer;
          }
          return 0;
        }

      }

      if(argc == 3)
      {
        return_value_strcmp$20=strcmp(argv[(signed long int)1], "del");
        if(!(return_value_strcmp$20 == 0))
          goto __CPROVER_DUMP_L49;

        j=atoi(argv[(signed long int)2]);
        tpeer = peerlist;
        if(j == 1)
        {
          if(!(peerlist == ((struct peerlist *)NULL)))
          {
            peerlist = peerlist->next;
            free((void *)tpeer);
          }

          return 0;
        }

        peerhost = tpeer->next;
        i = 2;
        for( ; !(peerhost == ((struct peerlist *)NULL)); i = i + 1)
        {
          if(i == j)
          {
            tpeer->next = peerhost->next;
            free((void *)peerhost);
            break;
          }

          tpeer = peerhost;
          peerhost = peerhost->next;
        }
        return 0;
      }

      else
      {

      __CPROVER_DUMP_L49:
        ;
        if(argc == 4)
        {
          return_value_strcmp$25=strcmp(argv[(signed long int)1], "del");
          if(!(return_value_strcmp$25 == 0))
            goto __CPROVER_DUMP_L59;

          p=strchr(argv[(signed long int)2], 58);
          if(!(p == ((char *)NULL)))
          {
            bzero((void *)tmp, sizeof(char [32l]) /*32ul*/ );
            strncpy(tmp, argv[(signed long int)2], (unsigned long int)(p - argv[(signed long int)2]));
            peer.nodea.ip=inet_addr(tmp);
            signed int return_value_atoi$21;
            return_value_atoi$21=atoi(p + (signed long int)1);
            peer.nodea.port=htons((unsigned short int)return_value_atoi$21);
          }

          else
          {
            peer.nodea.ip=htonl((unsigned int)0x00000000);
            signed int return_value_atoi$22;
            return_value_atoi$22=atoi(argv[(signed long int)2]);
            peer.nodea.port=htons((unsigned short int)return_value_atoi$22);
          }
          p=strchr(argv[(signed long int)3], 58);
          if(!(p == ((char *)NULL)))
          {
            bzero((void *)tmp, sizeof(char [32l]) /*32ul*/ );
            strncpy(tmp, argv[(signed long int)3], (unsigned long int)(p - argv[(signed long int)3]));
            peer.nodeb.ip=inet_addr(tmp);
            signed int return_value_atoi$23;
            return_value_atoi$23=atoi(p + (signed long int)1);
            peer.nodeb.port=htons((unsigned short int)return_value_atoi$23);
          }

          else
          {
            peer.nodeb.ip=htonl((unsigned int)0x00000000);
            signed int return_value_atoi$24;
            return_value_atoi$24=atoi(argv[(signed long int)3]);
            peer.nodea.port=htons((unsigned short int)return_value_atoi$24);
          }
          tpeer = peerlist;
          peerhost = peerlist;
          for( ; !(peerhost == ((struct peerlist *)NULL)); peerhost = peerhost->next)
          {
            if(peerhost->nodea.ip == peer.nodea.ip)
            {
              if(peerhost->nodea.port == peer.nodea.port)
              {
                if(peerhost->nodeb.ip == peer.nodeb.ip)
                {
                  if(peerhost->nodea.port == peer.nodea.port)
                  {
                    if(tpeer == peerlist)
                      peerlist = peerhost->next;

                    else
                      tpeer->next = peerhost->next;
                    free((void *)peerhost);
                    break;
                  }

                }

              }

            }

            tpeer = peerhost;
          }
          return 0;
        }

        else
        {

        __CPROVER_DUMP_L59:
          ;
          return 0;
        }
      }
    }
  }
}

// run_remote
// file command.h line 41
signed int run_remote(signed int argc, char **argv)
{
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(argv[(signed long int)(argc - 1)], "?");
  signed int return_value_help_rlogin$1;
  if(return_value_strcmp$2 == 0)
  {
    return_value_help_rlogin$1=help_rlogin(argc, argv);
    return return_value_help_rlogin$1;
  }

  else
  {
    if(argc == 2)
    {
      signed int return_value_digitstring$4;
      return_value_digitstring$4=digitstring(argv[(signed long int)1]);
      if(return_value_digitstring$4 == 0)
      {
        printf("Invalid port\n");
        signed int return_value_help_rlogin$3;
        return_value_help_rlogin$3=help_rlogin(argc, argv);
        return return_value_help_rlogin$3;
      }

      signed int return_value_atoi$5;
      return_value_atoi$5=atoi(argv[(signed long int)1]);
      signed int return_value_open_remote$6;
      return_value_open_remote$6=open_remote(0, "127.0.0.1", (const unsigned short int)return_value_atoi$5);
      return return_value_open_remote$6;
    }

    else
      if(argc == 3)
      {
        signed int return_value_digitstring$8;
        return_value_digitstring$8=digitstring(argv[(signed long int)2]);
        if(return_value_digitstring$8 == 0)
        {
          printf("Invalid port\n");
          signed int return_value_help_rlogin$7;
          return_value_help_rlogin$7=help_rlogin(argc, argv);
          return return_value_help_rlogin$7;
        }

        signed int return_value_atoi$9;
        return_value_atoi$9=atoi(argv[(signed long int)2]);
        signed int return_value_open_remote$10;
        return_value_open_remote$10=open_remote(0, argv[(signed long int)1], (const unsigned short int)return_value_atoi$9);
        return return_value_open_remote$10;
      }

    signed int return_value_help_rlogin$11;
    return_value_help_rlogin$11=help_rlogin(argc, argv);
    return return_value_help_rlogin$11;
  }
}

// run_rlogin
// file hv.c line 681
static signed int run_rlogin(signed int argc, char **argv)
{
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(argv[(signed long int)(argc - 1)], "?");
  signed int return_value_help_rlogin$1;
  if(return_value_strcmp$2 == 0)
  {
    return_value_help_rlogin$1=help_rlogin(argc, argv);
    return return_value_help_rlogin$1;
  }

  else
  {
    if(argc == 2)
    {
      signed int return_value_digitstring$4;
      return_value_digitstring$4=digitstring(argv[(signed long int)1]);
      if(return_value_digitstring$4 == 0)
      {
        printf("Invalid port\n");
        signed int return_value_help_rlogin$3;
        return_value_help_rlogin$3=help_rlogin(argc, argv);
        return return_value_help_rlogin$3;
      }

      signed int return_value_atoi$5;
      return_value_atoi$5=atoi(argv[(signed long int)1]);
      signed int return_value_open_remote$6;
      return_value_open_remote$6=open_remote(ptyfds, "127.0.0.1", (const unsigned short int)return_value_atoi$5);
      return return_value_open_remote$6;
    }

    else
      if(argc == 3)
      {
        signed int return_value_digitstring$8;
        return_value_digitstring$8=digitstring(argv[(signed long int)2]);
        if(return_value_digitstring$8 == 0)
        {
          printf("Invalid port\n");
          signed int return_value_help_rlogin$7;
          return_value_help_rlogin$7=help_rlogin(argc, argv);
          return return_value_help_rlogin$7;
        }

        signed int return_value_atoi$9;
        return_value_atoi$9=atoi(argv[(signed long int)2]);
        signed int return_value_open_remote$10;
        return_value_open_remote$10=open_remote(ptyfds, argv[(signed long int)1], (const unsigned short int)return_value_atoi$9);
        return return_value_open_remote$10;
      }

    signed int return_value_help_rlogin$11;
    return_value_help_rlogin$11=help_rlogin(argc, argv);
    return return_value_help_rlogin$11;
  }
}

// run_save
// file command.h line 44
signed int run_save(signed int argc, char **argv)
{
  struct _IO_FILE *fp;
  signed int i;
  char *p;
  char buf[64l];
  unsigned int local_ip;
  struct in_addr in;
  char fname[4096l];
  memset((void *)fname, 0, (unsigned long int)4096);
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$3;
  if(argc >= 3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(argc == 2)
    {
      return_value_strcmp$3=strcmp(argv[(signed long int)1], "?");
      tmp_if_expr$4 = !(return_value_strcmp$3 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    signed int return_value_help_save$1;
    return_value_help_save$1=help_save(argc, argv);
    return return_value_help_save$1;
  }

  else
    if(argc == 1)
      strncpy(fname, default_startupfile, (unsigned long int)(4096 - 1));

    else
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(argv[(signed long int)1]);
      if(return_value_strlen$2 >= 4092ul)
      {
        printf("%s is too long\n", argv[(signed long int)1]);
        return 1;
      }

      else
        strncpy(fname, argv[(signed long int)1], (unsigned long int)(4096 - 1));
    }
  char *return_value_strrchr$6;
  return_value_strrchr$6=strrchr(fname, 46);
  if(return_value_strrchr$6 == ((char *)NULL))
    strcat(fname, ".vpc");

  fp=fopen(fname, "w");
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    local_ip=inet_addr("127.0.0.1");
    i = 0;
    for( ; !(i >= num_pths); i = i + 1)
    {
      if(num_pths >= 2)
        fprintf(fp, "%d\n", i + 1);

      sprintf(buf, "VPCS[%d]", i + 1);
      signed int return_value_strncmp$7;
      return_value_strncmp$7=strncmp(vpc[(signed long int)i].xname, buf, (unsigned long int)3);
      if(!(return_value_strncmp$7 == 0))
        fprintf(fp, "set pcname %s\n", (const void *)vpc[(signed long int)i].xname);

      if(num_pths >= 2)
      {
        if(!(vpc[(signed long int)i].lport == 20000 + i))
          fprintf(fp, "set lport %d\n", vpc[(signed long int)i].lport);

        if(!(vpc[(signed long int)i].rport == 30000 + i))
          fprintf(fp, "set rport %d\n", vpc[(signed long int)i].rport);

        if(!(vpc[(signed long int)i].rhost == local_ip))
        {
          in.s_addr = vpc[(signed long int)i].rhost;
          char *return_value_inet_ntoa$8;
          return_value_inet_ntoa$8=inet_ntoa(in);
          fprintf(fp, "set rhost %s\n", return_value_inet_ntoa$8);
        }

      }

      if(vpc[(signed long int)i].ip4.dynip == 1)
        fputs("dhcp\n", fp);

      else
      {
        const char *return_value_ip4Info$9;
        return_value_ip4Info$9=ip4Info(i);
        p = (char *)return_value_ip4Info$9;
        if(!(p == ((char *)NULL)))
          fprintf(fp, "%s\n", p);

        const char *return_value_ip6Info$10;
        return_value_ip6Info$10=ip6Info(i);
        p = (char *)return_value_ip6Info$10;
        if(!(p == ((char *)NULL)))
          fprintf(fp, "%s\n", p);

      }
      if(vpc[(signed long int)i].ip6auto == 1)
        fputs("ip auto\n", fp);

      printf(".");
    }
    if(num_pths >= 2)
      fprintf(fp, "1\n");

    fclose(fp);
    printf("  done\n");
  }

  else
  {
    return_value___errno_location$11=__errno_location();
    return_value_strerror$12=strerror(*return_value___errno_location$11);
    printf("failed: %s\n", return_value_strerror$12);
  }
  return 1;
}

// run_set
// file command.h line 35
signed int run_set(signed int argc, char **argv)
{
  signed int value;
  signed int fd;
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  unsigned int ip;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$2;
  _Bool tmp_if_expr$4;
  if(!(argc >= 2))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(argc == 2)
    {
      return_value_strlen$2=strlen(argv[(signed long int)1]);
      tmp_if_expr$3 = return_value_strlen$2 == (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (signed int)argv[(signed long int)1][(signed long int)0] == 63 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    signed int return_value_help_set$1;
    return_value_help_set$1=help_set(argc, argv);
    return return_value_help_set$1;
    return 0;
  }

  unsigned long int return_value_strlen$9;
  return_value_strlen$9=strlen(argv[(signed long int)1]);
  signed int return_value_strncmp$10;
  return_value_strncmp$10=strncmp("dump", argv[(signed long int)1], return_value_strlen$9);
  signed int return_value_help_set$6;
  if(return_value_strncmp$10 == 0)
  {
    signed int return_value_strcmp$7;
    return_value_strcmp$7=strcmp(argv[(signed long int)(argc - 1)], "?");
    if(return_value_strcmp$7 == 0)
    {
      return_value_help_set$6=help_set(argc, argv);
      return return_value_help_set$6;
    }

    signed int return_value_set_dump$8;
    return_value_set_dump$8=set_dump(argc, argv);
    return return_value_set_dump$8;
  }

  unsigned long int return_value_strlen$26;
  return_value_strlen$26=strlen(argv[(signed long int)1]);
  signed int return_value_strncmp$27;
  return_value_strncmp$27=strncmp("lport", argv[(signed long int)1], return_value_strlen$26);
  unsigned long int return_value_strlen$24;
  signed int return_value_strncmp$25;
  unsigned long int return_value_strlen$22;
  signed int return_value_strncmp$23;
  unsigned long int return_value_strlen$20;
  signed int return_value_strncmp$21;
  unsigned long int return_value_strlen$18;
  signed int return_value_strncmp$19;
  signed int return_value_help_set$14;
  signed int return_value_strcasecmp$16;
  if(return_value_strncmp$27 == 0)
  {
    if(!(argc == 3))
    {
      printf("Incomplete command.\n");
      return 1;
    }

    value=atoi(argv[(signed long int)2]);
    if(value >= 65001 || !(value >= 1024))
      printf("Invalid port. 1024 > port < 65000.\n");

    else
    {
      fd=open_udp(value);
      if(!(fd >= 1))
      {
        fd = 0;
        signed int *return_value___errno_location$11;
        return_value___errno_location$11=__errno_location();
        char *return_value_strerror$12;
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        printf("Device(%d) open error [%s]\n", pcid, return_value_strerror$12);
        return 0;
      }

      close(pc->fd);
      pc->fd = fd;
      pc->lport = value;
    }
  }

  else
  {
    return_value_strlen$24=strlen(argv[(signed long int)1]);
    return_value_strncmp$25=strncmp("rport", argv[(signed long int)1], return_value_strlen$24);
    if(return_value_strncmp$25 == 0)
    {
      if(!(argc == 3))
      {
        printf("Incomplete command.\n");
        return 1;
      }

      value=atoi(argv[(signed long int)2]);
      if(value >= 65001 || !(value >= 1024))
        printf("Invalid port. 1024 > port < 65000.\n");

      else
        pc->rport = value;
    }

    else
    {
      return_value_strlen$22=strlen(argv[(signed long int)1]);
      return_value_strncmp$23=strncmp("rhost", argv[(signed long int)1], return_value_strlen$22);
      if(return_value_strncmp$23 == 0)
      {
        if(!(argc == 3))
        {
          printf("Incomplete command.\n");
          return 1;
        }

        ip=inet_addr(argv[(signed long int)2]);
        if(ip == 4294967295u)
        {
          printf("Invalid address: %s\n", argv[(signed long int)2]);
          return 0;
        }

        pc->rhost = ip;
      }

      else
      {
        return_value_strlen$20=strlen(argv[(signed long int)1]);
        return_value_strncmp$21=strncmp("pcname", argv[(signed long int)1], return_value_strlen$20);
        if(return_value_strncmp$21 == 0)
        {
          if(!(argc == 3))
          {
            printf("Incomplete command.\n");
            return 1;
          }

          unsigned long int return_value_strlen$13;
          return_value_strlen$13=strlen(argv[(signed long int)2]);
          if(return_value_strlen$13 >= 7ul)
            printf("Hostname is too long. (should be less than %d)\n", 6);

          else
            strcpy(vpc[(signed long int)pcid].xname, argv[(signed long int)2]);
        }

        else
        {
          return_value_strlen$18=strlen(argv[(signed long int)1]);
          return_value_strncmp$19=strncmp("echo", argv[(signed long int)1], return_value_strlen$18);
          if(return_value_strncmp$19 == 0)
          {
            signed int return_value_strcmp$15;
            return_value_strcmp$15=strcmp(argv[(signed long int)(argc - 1)], "?");
            if(return_value_strcmp$15 == 0)
            {
              return_value_help_set$14=help_set(argc, argv);
              return return_value_help_set$14;
            }

            if(!(argc == 3))
            {
              printf("Incomplete command.\n");
              return 1;
            }

            signed int return_value_strcasecmp$17;
            return_value_strcasecmp$17=strcasecmp(argv[(signed long int)2], "on");
            if(return_value_strcasecmp$17 == 0)
              canEcho = 1;

            else
            {
              return_value_strcasecmp$16=strcasecmp(argv[(signed long int)2], "off");
              if(return_value_strcasecmp$16 == 0)
                canEcho = 0;

            }
          }

          else
            printf("Invalid command.\n");
        }
      }
    }
  }
  return 1;
}

// run_show
// file command.h line 31
signed int run_show(signed int argc, char **argv)
{
  signed int i;
  signed int j;
  signed int k;
  struct in_addr in;
  char buf[128l];
  memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
  memset((void *)buf, 32, sizeof(char [128l]) /*128ul*/  - (unsigned long int)1);
  signed int return_value_show_arp$2;
  signed int return_value_show_dump$5;
  signed int return_value_show_ip$8;
  signed int return_value_show_ipv6$10;
  signed int return_value_show_echo$13;
  signed int return_value_run_ver$16;
  signed int return_value_run_hist$19;
  if(argc >= 2)
  {
    signed int return_value_help_show$1;
    return_value_help_show$1=help_show(argc, argv);
    if(!(return_value_help_show$1 == 0))
      return 1;

    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(argv[(signed long int)1]);
    signed int return_value_strncmp$4;
    return_value_strncmp$4=strncmp("arp", argv[(signed long int)1], return_value_strlen$3);
    if(return_value_strncmp$4 == 0)
    {
      return_value_show_arp$2=show_arp(argc, argv);
      return return_value_show_arp$2;
    }

    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(argv[(signed long int)1]);
    signed int return_value_strncmp$7;
    return_value_strncmp$7=strncmp("dump", argv[(signed long int)1], return_value_strlen$6);
    if(return_value_strncmp$7 == 0)
    {
      return_value_show_dump$5=show_dump(argc, argv);
      return return_value_show_dump$5;
    }

    signed int return_value_strcmp$9;
    return_value_strcmp$9=strcmp("ip", argv[(signed long int)1]);
    if(return_value_strcmp$9 == 0)
    {
      return_value_show_ip$8=show_ip(argc, argv);
      return return_value_show_ip$8;
    }

    unsigned long int return_value_strlen$11;
    return_value_strlen$11=strlen(argv[(signed long int)1]);
    signed int return_value_strncmp$12;
    return_value_strncmp$12=strncmp("ipv6", argv[(signed long int)1], return_value_strlen$11);
    if(return_value_strncmp$12 == 0)
    {
      return_value_show_ipv6$10=show_ipv6(argc, argv);
      return return_value_show_ipv6$10;
    }

    unsigned long int return_value_strlen$14;
    return_value_strlen$14=strlen(argv[(signed long int)1]);
    signed int return_value_strncmp$15;
    return_value_strncmp$15=strncmp("echo", argv[(signed long int)1], return_value_strlen$14);
    if(return_value_strncmp$15 == 0)
    {
      return_value_show_echo$13=show_echo(argc, argv);
      return return_value_show_echo$13;
    }

    unsigned long int return_value_strlen$17;
    return_value_strlen$17=strlen(argv[(signed long int)1]);
    signed int return_value_strncmp$18;
    return_value_strncmp$18=strncmp("version", argv[(signed long int)1], return_value_strlen$17);
    if(return_value_strncmp$18 == 0)
    {
      return_value_run_ver$16=run_ver(0, (char **)(void *)0);
      return return_value_run_ver$16;
    }

    unsigned long int return_value_strlen$20;
    return_value_strlen$20=strlen(argv[(signed long int)1]);
    signed int return_value_strncmp$21;
    return_value_strncmp$21=strncmp("history", argv[(signed long int)1], return_value_strlen$20);
    if(return_value_strncmp$21 == 0)
    {
      return_value_run_hist$19=run_hist(0, (char **)(void *)0);
      return return_value_run_hist$19;
    }

    printf("Invalid arguments\n");
    return 1;
  }

  printf("\n");
  switch(devtype)
  {
    case 1:
    {
      j=sprintf(buf, "NAME");
      buf[(signed long int)j] = (char)32;
      j=sprintf(buf + (signed long int)7, "IP/MASK");
      buf[(signed long int)(j + 7)] = (char)32;
      j=sprintf(buf + (signed long int)28, "GATEWAY");
      buf[(signed long int)(j + 28)] = (char)32;
      j=sprintf(buf + (signed long int)64, "GATEWAY");
      printf("%s\n", (const void *)buf);
      i = 0;
      for( ; !(i >= num_pths); i = i + 1)
      {
        memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
        memset((void *)buf, 32, sizeof(char [128l]) /*128ul*/  - (unsigned long int)1);
        signed int return_value_strcmp$22;
        return_value_strcmp$22=strcmp(vpc[(signed long int)i].xname, "VPCS");
        if(return_value_strcmp$22 == 0)
          j=sprintf(buf, "%s%d", (const void *)vpc[(signed long int)i].xname, i + 1);

        else
          j=sprintf(buf, "%s", (const void *)vpc[(signed long int)i].xname);
        buf[(signed long int)j] = (char)32;
        in.s_addr = vpc[(signed long int)i].ip4.ip;
        char *return_value_inet_ntoa$23;
        return_value_inet_ntoa$23=inet_ntoa(in);
        j=sprintf(buf + (signed long int)7, "%s/%d", return_value_inet_ntoa$23, vpc[(signed long int)i].ip4.cidr);
        buf[(signed long int)(j + 7)] = (char)32;
        in.s_addr = (unsigned int)vpc[(signed long int)i].ip4.gw;
        char *return_value_inet_ntoa$24;
        return_value_inet_ntoa$24=inet_ntoa(in);
        sprintf(buf + (signed long int)28, "%s", return_value_inet_ntoa$24);
        k = 0;
        for( ; !(k >= 6); k = k + 1)
          sprintf(buf + (signed long int)46 + (signed long int)(k * 3), "%2.2x:", vpc[(signed long int)i].ip4.mac[(signed long int)k]);
        printf("%s\n", (const void *)buf);
        run_show6(&vpc[(signed long int)i]);
      }
      goto __CPROVER_DUMP_L23;
    }
    case 2:
    {
      j=sprintf(buf, "NAME");
      buf[(signed long int)j] = (char)32;
      j=sprintf(buf + (signed long int)7, "IP/MASK");
      buf[(signed long int)(j + 7)] = (char)32;
      j=sprintf(buf + (signed long int)28, "GATEWAY");
      buf[(signed long int)(j + 28)] = (char)32;
      j=sprintf(buf + (signed long int)46, "MAC");
      buf[(signed long int)(j + 46)] = (char)32;
      j=sprintf(buf + (signed long int)65, "LPORT");
      buf[(signed long int)(j + 65)] = (char)32;
      j=sprintf(buf + (signed long int)72, "RHOST:PORT");
      printf("%s\n", (const void *)buf);
      i = 0;
      for( ; !(i >= num_pths); i = i + 1)
      {
        memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
        memset((void *)buf, 32, sizeof(char [128l]) /*128ul*/  - (unsigned long int)1);
        signed int return_value_strcmp$25;
        return_value_strcmp$25=strcmp(vpc[(signed long int)i].xname, "VPCS");
        if(return_value_strcmp$25 == 0)
          j=sprintf(buf, "%s%d", (const void *)vpc[(signed long int)i].xname, i + 1);

        else
          j=sprintf(buf, "%s", (const void *)vpc[(signed long int)i].xname);
        buf[(signed long int)j] = (char)32;
        in.s_addr = vpc[(signed long int)i].ip4.ip;
        char *return_value_inet_ntoa$26;
        return_value_inet_ntoa$26=inet_ntoa(in);
        j=sprintf(buf + (signed long int)7, "%s/%d", return_value_inet_ntoa$26, vpc[(signed long int)i].ip4.cidr);
        buf[(signed long int)(j + 7)] = (char)32;
        in.s_addr = (unsigned int)vpc[(signed long int)i].ip4.gw;
        char *return_value_inet_ntoa$27;
        return_value_inet_ntoa$27=inet_ntoa(in);
        j=sprintf(buf + (signed long int)28, "%s", return_value_inet_ntoa$27);
        buf[(signed long int)(j + 28)] = (char)32;
        k = 0;
        for( ; !(k >= 6); k = k + 1)
          sprintf(buf + (signed long int)46 + (signed long int)(k * 3), "%2.2x:", vpc[(signed long int)i].ip4.mac[(signed long int)k]);
        buf[(signed long int)63] = (char)32;
        buf[(signed long int)64] = (char)32;
        j=sprintf(buf + (signed long int)65, "%d", vpc[(signed long int)i].lport);
        buf[(signed long int)(j + 65)] = (char)32;
        in.s_addr = vpc[(signed long int)i].rhost;
        char *return_value_inet_ntoa$28;
        return_value_inet_ntoa$28=inet_ntoa(in);
        j=sprintf(buf + (signed long int)72, "%s:%d", return_value_inet_ntoa$28, vpc[(signed long int)i].rport);
        printf("%s\n", (const void *)buf);
        run_show6(&vpc[(signed long int)i]);
      }
    }
    default:
    {

    __CPROVER_DUMP_L23:
      ;
      return 1;
    }
  }
}

// run_show6
// file command6.h line 40
signed int run_show6(struct anonymous$0 *pc)
{
  char buf[47l];
  struct in6_addr ipaddr;
  memset((void *)buf, 0, (unsigned long int)(46 + 1));
  memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)pc->link6.ip.uaddr._a8, (unsigned long int)16);
  vinet_ntop6(10, (const void *)&ipaddr, buf, (unsigned int)(46 + 1));
  printf("       %s/%d\n", (const void *)buf, pc->link6.cidr);
  _Bool tmp_if_expr$1;
  if(!(pc->ip6.ip.uaddr._a32[0l] == 0u))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = pc->ip6.ip.uaddr._a32[(signed long int)1] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = pc->ip6.ip.uaddr._a32[(signed long int)2] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = pc->ip6.ip.uaddr._a32[(signed long int)3] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    memset((void *)buf, 0, (unsigned long int)(46 + 1));
    memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)pc->ip6.ip.uaddr._a8, (unsigned long int)16);
    vinet_ntop6(10, (const void *)&ipaddr, buf, (unsigned int)(46 + 1));
    printf("       %s/%d %s\n", (const void *)buf, pc->ip6.cidr, pc->ip6.type == 1 ? "eui-64" : "");
  }

  return 1;
}

// run_sleep
// file command.h line 36
signed int run_sleep(signed int argc, char **argv)
{
  signed int t;
  signed int ac = argc;
  signed int i;
  t = 0;
  if(argc == 2)
  {
    signed int return_value_digitstring$1;
    return_value_digitstring$1=digitstring(argv[(signed long int)1]);
    if(!(return_value_digitstring$1 == 0))
    {
      t=atoi(argv[(signed long int)1]);
      ac = 2;
    }

    else
      ac = 1;
  }

  else
    if(argc >= 3)
    {
      ac = 1;
      signed int return_value_digitstring$2;
      return_value_digitstring$2=digitstring(argv[(signed long int)1]);
      if(!(return_value_digitstring$2 == 0))
      {
        t=atoi(argv[(signed long int)1]);
        ac = 2;
      }

    }

  if(!(argc == 1))
  {
    i = ac;
    for( ; !(i >= argc); i = i + 1)
      printf("%s ", argv[(signed long int)i]);
    printf("\n");
  }

  if(t == 0)
  {
    if(argc == 1)
      printf("Press any key to continue\n");

    kbhit(0);
  }

  else
    sleep((unsigned int)t);
  return 1;
}

// run_stop
// file hv.c line 704
static signed int run_stop(signed int ac, char **av)
{
  signed int i;
  signed int j;
  signed int k;
  signed int found = 0;
  if(ac == 1)
  {
    do
    {
      fprintf(fptys, "200-");
      fprintf(fptys, "Invalid or incomplete command\r\n");
      fflush(fptys);
    }
    while((_Bool)0);
    return 1;
  }

  else
  {
    j=atoi(av[(signed long int)1]);
    i = 0;
    k = 0;
    i = 0;
    for( ; !(i >= 10); i = i + 1)
      if(!(vpcs_list[(signed long int)i].pid == 0))
      {
        k = k + 1;
        if(k == j)
        {
          do
          {
            fprintf(fptys, "100-");
            fprintf(fptys, "VPCS PID %d is terminated\r\n", vpcs_list[(signed long int)i].pid);
            fflush(fptys);
          }
          while((_Bool)0);
          kill(vpcs_list[(signed long int)i].pid, 12);
          vpcs_list[(signed long int)i].pid = 0;
          if(!(vpcs_list[(signed long int)i].cmdline == ((char *)NULL)))
            free((void *)vpcs_list[(signed long int)i].cmdline);

          found = 1;
          break;
        }

      }

    if(found == 0)
      do
      {
        fprintf(fptys, "200-");
        fprintf(fptys, "VPCS id %s does not exist\r\n", av[(signed long int)1]);
        fflush(fptys);
      }
      while((_Bool)0);

    return 0;
  }
}

// run_tracert
// file command.h line 34
signed int run_tracert(signed int argc, char **argv)
{
  signed int i;
  signed int j;
  unsigned int gip;
  unsigned int gwip;
  struct in_addr in;
  signed int count = 128;
  struct packet *m;
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  signed int ok = 0;
  signed int pktnum = 3;
  signed int prn_ip = 1;
  char outbuf[1024l];
  signed int buf_off = 0;
  char dname[256l];
  signed long int return_value_time$1;
  return_value_time$1=time(((signed long int *)NULL));
  pc->mscb.seq = (unsigned int)return_value_time$1;
  pc->mscb.proto = 17;
  pc->mscb.dsize = 64;
  pc->mscb.mtu = pc->ip4.mtu;
  signed int return_value_rand$2;
  return_value_rand$2=rand();
  pc->mscb.sport = (unsigned int)(return_value_rand$2 & 0xfff1);
  pc->mscb.dport = pc->mscb.sport + (unsigned int)1;
  pc->mscb.sip = pc->ip4.ip;
  pc->mscb.waittime = (unsigned int)1000;
  pc->mscb.timeout = time_tick;
  memcpy((void *)pc->mscb.smac, (const void *)pc->ip4.mac, (unsigned long int)6);
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  if(!(argc >= 2))
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    if(argc == 2)
    {
      return_value_strcmp$4=strcmp(argv[(signed long int)1], "?");
      tmp_if_expr$5 = !(return_value_strcmp$4 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$6)
  {
    signed int return_value_help_trace$3;
    return_value_help_trace$3=help_trace(argc, argv);
    return return_value_help_trace$3;
  }

  char *return_value_strchr$8;
  return_value_strchr$8=strchr(argv[(signed long int)1], 58);
  if(!(return_value_strchr$8 == ((char *)NULL)))
  {
    pc->mscb.mtu = pc->ip6.mtu;
    signed int return_value_run_tracert6$7;
    return_value_run_tracert6$7=run_tracert6(argc, argv);
    return return_value_run_tracert6$7;
  }

  if(argc >= 3)
  {
    i = 2;
    while(!(i >= argc))
    {
      signed int return_value_strcmp$10;
      return_value_strcmp$10=strcmp(argv[(signed long int)i], "-P");
      if(return_value_strcmp$10 == 0)
      {
        if(1 + i >= argc)
        {
          printf("Missing protocol\n");
          return 0;
        }

        i = i + 1;
        signed int return_value_digitstring$9;
        return_value_digitstring$9=digitstring(argv[(signed long int)i]);
        if(return_value_digitstring$9 == 0)
        {
          printf("Invalid protocol\n");
          return 0;
        }

        j=atoi(argv[(signed long int)i]);
        if(j == 1)
          pc->mscb.proto = 1;

        else
          if(j == 17)
            pc->mscb.proto = 17;

          else
            if(j == 6)
            {
              pc->mscb.proto = 6;
              pc->mscb.flags = pc->mscb.flags | (unsigned char)0x02;
            }

            else
            {
              printf("Invalid protocol\n");
              return 0;
            }
        i = i + 1;
        continue;
      }

      signed int return_value_strcmp$12;
      return_value_strcmp$12=strcmp(argv[(signed long int)i], "-m");
      if(return_value_strcmp$12 == 0)
      {
        if(1 + i >= argc)
        {
          printf("Missing TTL\n");
          return 0;
        }

        signed int return_value_digitstring$11;
        return_value_digitstring$11=digitstring(argv[(signed long int)(i + 1)]);
        if(return_value_digitstring$11 == 0)
        {
          printf("Invalid TTL\n");
          return 0;
        }

        i = i + 1;
        j=atoi(argv[(signed long int)i]);
        if(j >= 1 && !(j >= 65))
          count = j;

        else
        {
          printf("Invalid TTL\n");
          return 0;
        }
        i = i + 1;
        continue;
      }

      signed int return_value_digitstring$13;
      return_value_digitstring$13=digitstring(argv[(signed long int)i]);
      if(!(return_value_digitstring$13 == 0))
      {
        if(!(count == 128))
          goto __CPROVER_DUMP_L22;

        j=atoi(argv[(signed long int)i]);
        if(j >= 1 && !(j >= 65))
          count = j;

        else
        {
          printf("Invalid TTL\n");
          return 0;
        }
        i = i + 1;
      }

      else
      {

      __CPROVER_DUMP_L22:
        ;
        signed int return_value_help_trace$14;
        return_value_help_trace$14=help_trace(argc, argv);
        return return_value_help_trace$14;
      }
    }
  }

  if(count == 128)
    count = 8;

  pc->mscb.dip=inet_addr(argv[(signed long int)1]);
  _Bool tmp_if_expr$17;
  if(pc->mscb.dip == 4294967295u)
    tmp_if_expr$17 = (_Bool)1;

  else
    tmp_if_expr$17 = pc->mscb.dip == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$17)
  {
    strcpy(dname, argv[(signed long int)1]);
    signed int return_value_hostresolv$16;
    return_value_hostresolv$16=hostresolv(pc, dname, &pc->mscb.dip);
    if(return_value_hostresolv$16 == 0)
    {
      printf("Cannot resolve %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
    {
      in.s_addr = pc->mscb.dip;
      char *return_value_inet_ntoa$15;
      return_value_inet_ntoa$15=inet_ntoa(in);
      printf("%s resolved to %s\n", (const void *)dname, return_value_inet_ntoa$15);
    }
  }

  if(pc->mscb.dip == pc->ip4.ip)
  {
    i = 1;
    in.s_addr = pc->mscb.dip;
    printf("traceroute to %s, %d hops max\n", argv[(signed long int)1], count);
    char *return_value_inet_ntoa$18;
    return_value_inet_ntoa$18=inet_ntoa(in);
    printf(" 1 %s     0.001 ms\n", return_value_inet_ntoa$18);
    return 1;
  }

  printf("trace to %s, %d hops max", argv[(signed long int)1], count);
  if(pc->mscb.proto == 1)
    printf("%s", (const void *)" (ICMP)");

  else
    if(pc->mscb.proto == 6)
      printf("%s", (const void *)" (TCP)");

  printf(", press Ctrl+C to stop\n");
  gwip = (unsigned int)pc->ip4.gw;
  signed int return_value_sameNet$19;
  signed int return_value_arpResolve$21;
  struct packet *p;
  struct timeval tv;
  unsigned int usec;
  signed int run_tracert$$1$$8$$j;
  signed int return_value_snprintf$22;
  signed int return_value_timeout$23;
  signed int return_value_timeout$24;
  char *return_value_inet_ntoa$25;
  signed int return_value_snprintf$26;
  char *return_value_inet_ntoa$27;
  signed int return_value_snprintf$28;
  do
  {

  redirect:
    ;
    return_value_sameNet$19=sameNet((unsigned long int)pc->mscb.dip, (unsigned long int)pc->ip4.ip, pc->ip4.cidr);
    if(!(return_value_sameNet$19 == 0))
      gip = pc->mscb.dip;

    else
      if(gwip == 0u)
      {
        printf("No gateway found\n");
        return 0;
      }

      else
        gip = gwip;
    return_value_arpResolve$21=arpResolve(pc, gip, pc->mscb.dmac);
    if(return_value_arpResolve$21 == 0)
    {
      in.s_addr = gip;
      char *return_value_inet_ntoa$20;
      return_value_inet_ntoa$20=inet_ntoa(in);
      printf("host (%s) not reachable\n", return_value_inet_ntoa$20);
      return 0;
    }

    i = 1;

  __CPROVER_DUMP_L39:
    ;
    if(!(ctrl_c == 0) || !(count >= i))
      goto __CPROVER_DUMP_L57;

    do
    {
      p=deq(&pc->iq);
      if(p == ((struct packet *)NULL))
        break;

      del_pkt(p);
    }
    while((_Bool)1);
    prn_ip = 1;
    return_value_snprintf$22=snprintf(outbuf + (signed long int)buf_off, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)buf_off, "%2d   ", i);
    buf_off = buf_off + return_value_snprintf$22;
    run_tracert$$1$$8$$j = 0;

  __CPROVER_DUMP_L42:
    ;
    if(!(ctrl_c == 0) || run_tracert$$1$$8$$j >= pktnum)
      goto __CPROVER_DUMP_L56;

    pc->mscb.ttl = (unsigned char)i;
    pc->mscb.icmptype = (unsigned char)0;
    pc->mscb.rdip = pc->mscb.dip;
    m=packet(&pc->mscb);
    if(m == ((struct packet *)NULL))
    {
      printf("out of memory\n");
      return 0;
    }

    gettimeofday(&tv, (struct timezone *)(void *)0);
    enq(&pc->oq, m);

  __CPROVER_DUMP_L44:
    ;
    return_value_timeout$23=timeout(tv, (signed int)pc->mscb.waittime);
    if(!(return_value_timeout$23 == 0))
      goto __CPROVER_DUMP_L54;

    if(!(ctrl_c == 0))
      goto __CPROVER_DUMP_L54;

    usleep((unsigned int)(1 * 1000));
    ok = 0;

  __CPROVER_DUMP_L45:
    ;
    p=deq(&pc->iq);
    if(p == ((struct packet *)NULL))
      goto __CPROVER_DUMP_L53;

    if(!(ok == 0))
      goto __CPROVER_DUMP_L53;

    return_value_timeout$24=timeout(tv, (signed int)pc->mscb.waittime);
    if(!(return_value_timeout$24 == 0))
      goto __CPROVER_DUMP_L53;

    if(!(ctrl_c == 0))
      goto __CPROVER_DUMP_L53;

    ok=response(p, &pc->mscb);
    usec = (unsigned int)(((p->ts.tv_sec - tv.tv_sec) * (signed long int)1000000 + p->ts.tv_usec) - tv.tv_usec);
    del_pkt(p);
    if(!((signed int)pc->mscb.icmptype == 5))
      break;

    if(!((signed int)pc->mscb.icmpcode == 0))
      break;

    in.s_addr = (unsigned int)pc->ip4.gw;
    return_value_inet_ntoa$25=inet_ntoa(in);
    return_value_snprintf$26=snprintf(outbuf + (signed long int)buf_off, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)buf_off, "Redirect Network, gateway %s", return_value_inet_ntoa$25);
    buf_off = buf_off + return_value_snprintf$26;
    in.s_addr = pc->mscb.rdip;
    return_value_inet_ntoa$27=inet_ntoa(in);
    return_value_snprintf$28=snprintf(outbuf + (signed long int)buf_off, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)buf_off, " -> %s\n", return_value_inet_ntoa$27);
    buf_off = buf_off + return_value_snprintf$28;
    gwip = pc->mscb.rdip;
    usleep((unsigned int)(100 * 1000));
  }
  while((_Bool)1);
  if((signed int)pc->mscb.icmptype == 11)
  {
    in.s_addr = pc->mscb.rdip;
    if(!(prn_ip == 0))
    {
      char *return_value_inet_ntoa$29;
      return_value_inet_ntoa$29=inet_ntoa(in);
      signed int return_value_snprintf$30;
      return_value_snprintf$30=snprintf(outbuf + (signed long int)buf_off, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)buf_off, "%s ", return_value_inet_ntoa$29);
      buf_off = buf_off + return_value_snprintf$30;
      prn_ip = 0;
    }

    signed int return_value_snprintf$31;
    return_value_snprintf$31=snprintf(outbuf + (signed long int)buf_off, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)buf_off, "  %.3f ms", (double)usec / 1000.0);
    buf_off = buf_off + return_value_snprintf$31;
    tv.tv_sec = (signed long int)0;
    goto __CPROVER_DUMP_L53;
  }

  else
    if((signed int)pc->mscb.icmptype == 3)
    {
      in.s_addr = pc->mscb.rdip;
      if(!(prn_ip == 0))
      {
        char *return_value_inet_ntoa$32;
        return_value_inet_ntoa$32=inet_ntoa(in);
        const char *return_value_icmpTypeCode2String$33;
        return_value_icmpTypeCode2String$33=icmpTypeCode2String(4, pc->mscb.icmptype, pc->mscb.icmpcode);
        signed int return_value_snprintf$34;
        return_value_snprintf$34=snprintf(outbuf + (signed long int)buf_off, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)buf_off, "*%s   %.3f ms (ICMP type:%d, code:%d, %s)", return_value_inet_ntoa$32, (double)usec / 1000.0, pc->mscb.icmptype, pc->mscb.icmpcode, return_value_icmpTypeCode2String$33);
        buf_off = buf_off + return_value_snprintf$34;
        prn_ip = 0;
      }

      tv.tv_sec = (signed long int)0;
      ok = 99999;
      goto __CPROVER_DUMP_L53;
    }

    else
      if(pc->mscb.dip == pc->mscb.rdip)
      {
        in.s_addr = pc->mscb.rdip;
        if(!(prn_ip == 0))
        {
          char *return_value_inet_ntoa$35;
          return_value_inet_ntoa$35=inet_ntoa(in);
          signed int return_value_snprintf$36;
          return_value_snprintf$36=snprintf(outbuf + (signed long int)buf_off, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)buf_off, "%s ", return_value_inet_ntoa$35);
          buf_off = buf_off + return_value_snprintf$36;
          prn_ip = 0;
        }

        signed int return_value_snprintf$37;
        return_value_snprintf$37=snprintf(outbuf + (signed long int)buf_off, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)buf_off, "  %.3f ms", (double)usec / 1000.0);
        buf_off = buf_off + return_value_snprintf$37;
        tv.tv_sec = (signed long int)0;
        ok = 99999;
        goto __CPROVER_DUMP_L53;
      }

  goto __CPROVER_DUMP_L45;

__CPROVER_DUMP_L53:
  ;
  goto __CPROVER_DUMP_L44;

__CPROVER_DUMP_L54:
  ;
  if(ctrl_c == 0 && ok == 0)
  {
    signed int return_value_snprintf$38;
    return_value_snprintf$38=snprintf(outbuf + (signed long int)buf_off, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)buf_off, "  *");
    buf_off = buf_off + return_value_snprintf$38;
    fflush(stdout);
  }

  run_tracert$$1$$8$$j = run_tracert$$1$$8$$j + 1;
  goto __CPROVER_DUMP_L42;

__CPROVER_DUMP_L56:
  ;
  printf("%s\n", (const void *)outbuf);
  buf_off = 0;
  i = i + 1;
  if(!(ok == 99999))
    goto __CPROVER_DUMP_L39;


__CPROVER_DUMP_L57:
  ;
  return 1;
}

// run_tracert6
// file command6.h line 36
signed int run_tracert6(signed int argc, char **argv)
{
  signed int i;
  signed int j;
  struct packet *m;
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  unsigned char *dmac;
  signed int ok = 0;
  struct in6_addr ipaddr;
  struct anonymous$11 ip;
  signed int pktnum = 3;
  signed int count = 99;
  printf("\n");
  signed int return_value_digitstring$1;
  signed int return_value_digitstring$3;
  signed int return_value_digitstring$4;
  signed int return_value_timeout$6;
  signed int return_value_timeout$7;
  _Bool tmp_if_expr$11;
  signed int return_value_memcmp$10;
  _Bool tmp_if_expr$9;
  if(!(argc >= 2))
  {
    printf("incompleted command.\n");
    return 0;
  }

  else
  {
    i = 2;
    i = 2;
    for( ; !(i >= argc); i = i + 1)
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(argv[(signed long int)i], "-c");
      if(return_value_strcmp$2 == 0)
      {
        if(!(1 + i >= argc))
        {
          return_value_digitstring$1=digitstring(argv[(signed long int)(i + 1)]);
          if(!(return_value_digitstring$1 == 0))
            count=atoi(argv[(signed long int)(i + 1)]);

        }

        break;
      }

    }
    if(count == 99)
    {
      return_value_digitstring$3=digitstring(argv[(signed long int)(argc - 1)]);
      if(!(return_value_digitstring$3 == 0))
        count=atoi(argv[(signed long int)(argc - 1)]);

    }

    if(!(optind >= argc))
    {
      return_value_digitstring$4=digitstring(argv[(signed long int)optind]);
      if(!(return_value_digitstring$4 == 0))
        count=atoi(argv[(signed long int)optind]);

    }

    if(count >= 65 || !(count >= 1))
      count = 64;

    signed int return_value_vinet_pton6$5;
    return_value_vinet_pton6$5=vinet_pton6(10, argv[(signed long int)1], (void *)&ipaddr);
    if(!(return_value_vinet_pton6$5 == 1))
    {
      printf("Invalid address: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
    {
      memcpy((void *)pc->mscb.dip6.uaddr._a8, (const void *)ipaddr.__in6_u.__u6_addr8, (unsigned long int)16);
      if(!((signed int)pc->mscb.dip6.uaddr._a16[0l] == 0x80fe))
        memcpy((void *)pc->mscb.sip6.uaddr._a8, (const void *)pc->ip6.ip.uaddr._a8, (unsigned long int)16);

      else
        memcpy((void *)pc->mscb.sip6.uaddr._a8, (const void *)pc->link6.ip.uaddr._a8, (unsigned long int)16);
      dmac=nbDiscovery(pc, &ip);
      if(dmac == ((unsigned char *)NULL))
      {
        printf("host (%s) not reachable\n", argv[(signed long int)1]);
        return 0;
      }

      else
      {
        memcpy((void *)pc->mscb.dmac, (const void *)dmac, (unsigned long int)6);
        printf("trace to %s, %d hops max\n", argv[(signed long int)1], count);
        i = 1;
        while(ctrl_c == 0 && count >= i)
        {
          struct packet *p;
          struct timeval tv;
          unsigned int usec;
          signed int k;
          printf("%2d ", i);
          j = 0;
          for( ; ctrl_c == 0 && !(j >= pktnum); j = j + 1)
          {
            pc->mscb.ttl = (unsigned char)i;
            m=packet6(&pc->mscb);
            if(m == ((struct packet *)NULL))
            {
              printf("out of memory\n");
              return 0;
            }

            gettimeofday(&tv, (struct timezone *)(void *)0);
            enq(&pc->oq, m);
            k = 0;
            do
            {
              return_value_timeout$6=timeout(tv, (signed int)pc->mscb.waittime);
              if(!(return_value_timeout$6 == 0))
                break;

              if(!(ctrl_c == 0))
                break;

              usleep((unsigned int)(1 * 1000));
              ok = 0;
              do
              {
                p=deq(&pc->iq);
                if(p == ((struct packet *)NULL))
                  break;

                if(!(ok == 0))
                  break;

                return_value_timeout$7=timeout(tv, (signed int)pc->mscb.waittime);
                if(!(return_value_timeout$7 == 0))
                  break;

                if(!(ctrl_c == 0))
                  break;

                ok=response6(p, &pc->mscb);
                usec = (unsigned int)(((p->ts.tv_sec - tv.tv_sec) * (signed long int)1000000 + p->ts.tv_usec) - tv.tv_usec);
                del_pkt(p);
                if((signed int)pc->mscb.icmptype == 3)
                  tmp_if_expr$11 = (_Bool)1;

                else
                {
                  return_value_memcmp$10=memcmp((const void *)(&pc->mscb.dip6)->uaddr._a8, (const void *)(&pc->mscb.rdip6)->uaddr._a8, (unsigned long int)16);
                  tmp_if_expr$11 = !(return_value_memcmp$10 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$11)
                {
                  if(j == 0)
                  {
                    char buf[128l];
                    memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)pc->mscb.rdip6.uaddr._a8, (unsigned long int)16);
                    memset((void *)buf, 0, (unsigned long int)128);
                    vinet_ntop6(10, (const void *)&ipaddr, buf, (unsigned int)(46 + 1));
                    printf("%s ", (const void *)buf);
                  }

                  printf("  %.3f ms", (double)usec / 1000.0);
                  fflush(stdout);
                  tv.tv_sec = (signed long int)0;
                  break;
                }

                else
                {
                  if((signed int)pc->mscb.icmptype == 1)
                    tmp_if_expr$9 = (_Bool)1;

                  else
                    tmp_if_expr$9 = (signed int)pc->mscb.icmptype == 4 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$9)
                  {
                    if(j == 0)
                    {
                      char run_tracert6$$1$$5$$1$$1$$2$$1$$2$$1$$buf[128l];
                      memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)pc->mscb.rdip6.uaddr._a8, (unsigned long int)16);
                      memset((void *)run_tracert6$$1$$5$$1$$1$$2$$1$$2$$1$$buf, 0, (unsigned long int)128);
                      vinet_ntop6(10, (const void *)&ipaddr, run_tracert6$$1$$5$$1$$1$$2$$1$$2$$1$$buf, (unsigned int)(46 + 1));
                      const char *return_value_icmpTypeCode2String$8;
                      return_value_icmpTypeCode2String$8=icmpTypeCode2String(6, pc->mscb.icmptype, pc->mscb.icmpcode);
                      printf("*%s   %.3f ms (ICMP type:%d, code:%d, %s)\n", (const void *)run_tracert6$$1$$5$$1$$1$$2$$1$$2$$1$$buf, (double)usec / 1000.0, pc->mscb.icmptype, pc->mscb.icmpcode, return_value_icmpTypeCode2String$8);
                    }

                    tv.tv_sec = (signed long int)0;
                    return 1;
                  }

                }
              }
              while((_Bool)1);
              k = k + 1;
            }
            while((_Bool)1);
            if(ctrl_c == 0 && ok == 0)
              printf("  *");

          }
          printf("\n");
          i = i + 1;
          if((signed int)pc->mscb.icmptype == 1)
            break;

        }
        return 1;
      }
    }
  }
}

// run_ver
// file command.h line 39
signed int run_ver(signed int argc, char **argv)
{
  printf("\r\nWelcome to Virtual PC Simulator, version %s\r\nDedicated to Daling.\r\nBuild time: %s %s\r\nCopyright (c) 2007-2014, Paul Meng (mirnshi@gmail.com)\r\nAll rights reserved.\r\n\r\nVPCS is free software, distributed under the terms of the \"BSD\" licence.\r\nSource code and license can be found at vpcs.sf.net.\r\nFor more information, please visit wiki.freecode.com.cn.\r\n", ver, (const void *)"Jan 26 2016", (const void *)"17:06:25");
  return 1;
}

// run_vpcs
// file hv.c line 364
static signed int run_vpcs(signed int ac, char **av)
{
  signed int i;
  signed int j;
  signed int c;
  struct list *pv;
  signed int pid;
  char *agv[20l];
  signed int agc = 0;
  char buf[1024l];
  signed int fd1;
  signed int return_value_strcmp$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$10;
  signed int return_value_snprintf$12;
  signed int return_value_snprintf$13;
  signed int return_value_snprintf$14;
  signed int return_value_snprintf$15;
  _Bool tmp_if_expr$18;
  signed int return_value_strcmp$17;
  _Bool tmp_if_expr$20;
  signed int return_value_strcmp$19;
  _Bool tmp_if_expr$22;
  signed int return_value_strcmp$21;
  signed int return_value_execvp$26;
  if(ac == 2)
  {
    return_value_strcmp$1=strcmp(av[(signed long int)1], "?");
    if(!(return_value_strcmp$1 == 0))
      goto __CPROVER_DUMP_L1;

    fd1=dup(1);
    dup2(sock_cli, 1);
    usage();
    fflush(stdout);
    dup2(fd1, 1);
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    i = 0;
    do
    {
      if(!(i >= 10))
        tmp_if_expr$2 = vpcs_list[(signed long int)i].pid != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    if(i == 10)
      return 0;

    else
    {
      pv = &vpcs_list[(signed long int)i];
      memset((void *)pv, 0, sizeof(struct list) /*32ul*/ );
      optind = 1;
      do
      {
        c=getopt(ac, av, "p:m:s:c:");
        if(c == -1)
          break;

        switch(c)
        {
          case 112:
          {
            pv->vport=atoi(optarg);
            if(pv->vport == 0)
            {
              do
              {
                fprintf(fptys, "200-");
                fprintf(fptys, "Invalid daemon port\r\n");
                fflush(fptys);
              }
              while((_Bool)0);
              return 1;
            }

            break;
          }
          case 109:
          {
            pv->vmac=atoi(optarg);
            if(pv->vmac == 0)
            {
              do
              {
                fprintf(fptys, "200-");
                fprintf(fptys, "Invalid ether address\r\n");
                fflush(fptys);
              }
              while((_Bool)0);
              return 1;
            }

            break;
          }
          case 115:
          {
            pv->vsport=atoi(optarg);
            if(pv->vsport == 0)
            {
              do
              {
                fprintf(fptys, "200-");
                fprintf(fptys, "Invalid local port\r\n");
                fflush(fptys);
              }
              while((_Bool)0);
              return 1;
            }

            break;
          }
          case 99:
          {
            pv->vcport=atoi(optarg);
            if(pv->vcport == 0)
            {
              do
              {
                fprintf(fptys, "200-");
                fprintf(fptys, "Invalid remote port\r\n");
                fflush(fptys);
              }
              while((_Bool)0);
              return 1;
            }

          }
          default:
            ;
        }
      }
      while((_Bool)1);
      if(pv->vport == 0)
      {
        j = 0;
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          if(!(vpcs_list[(signed long int)i].pid == 0))
          {
            if(!(j >= vpcs_list[(signed long int)i].vport))
              j = vpcs_list[(signed long int)i].vport;

          }

        if(j == 0)
          pv->vport = hvport + 1;

        else
          pv->vport = j + 1;
      }

      else
      {
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          if(!(vpcs_list[(signed long int)i].pid == 0))
          {
            if(pv->vport == vpcs_list[(signed long int)i].vport)
            {
              do
              {
                fprintf(fptys, "200-");
                fprintf(fptys, "Port %d already in use\r\n", pv->vport);
                fflush(fptys);
              }
              while((_Bool)0);
              return 1;
            }

          }

      }
      if(pv->vmac == 0)
      {
        j = 0;
        c = 0;
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          if(!(vpcs_list[(signed long int)i].pid == 0))
          {
            if(!(j >= vpcs_list[(signed long int)i].vmac))
              j = vpcs_list[(signed long int)i].vmac;

            c = 1;
          }

        if(j == 0)
        {
          if(c == 1)
            pv->vmac = 10;

          else
            pv->vmac = 0;
        }

        else
          pv->vmac = j + 10;
      }

      else
      {
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          if(!(vpcs_list[(signed long int)i].pid == 0))
          {
            if(pv->vmac >= vpcs_list[(signed long int)i].vmac)
              tmp_if_expr$3 = pv->vmac - vpcs_list[(signed long int)i].vmac < 10 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$3 = (_Bool)0;
            if(tmp_if_expr$3)
              tmp_if_expr$5 = (_Bool)1;

            else
            {
              if(!(pv->vmac >= vpcs_list[(signed long int)i].vmac))
                tmp_if_expr$4 = vpcs_list[(signed long int)i].vmac - pv->vmac < 10 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$4 = (_Bool)0;
              tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$5)
            {
              do
              {
                fprintf(fptys, "200-");
                fprintf(fptys, "Ether address overlapped\r\n");
                fflush(fptys);
              }
              while((_Bool)0);
              return 1;
            }

          }

      }
      if(pv->vsport == 0)
      {
        j = 0;
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          if(!(vpcs_list[(signed long int)i].pid == 0))
          {
            if(!(j >= vpcs_list[(signed long int)i].vsport))
              j = vpcs_list[(signed long int)i].vsport;

          }

        if(j == 0)
          pv->vsport = 20000;

        else
          pv->vsport = j + 10;
      }

      else
      {
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          if(!(vpcs_list[(signed long int)i].pid == 0))
          {
            if(pv->vsport >= vpcs_list[(signed long int)i].vsport)
              tmp_if_expr$6 = pv->vsport - vpcs_list[(signed long int)i].vsport < 10 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$6 = (_Bool)0;
            if(tmp_if_expr$6)
              tmp_if_expr$8 = (_Bool)1;

            else
            {
              if(!(pv->vsport >= vpcs_list[(signed long int)i].vsport))
                tmp_if_expr$7 = vpcs_list[(signed long int)i].vsport - pv->vsport < 10 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$7 = (_Bool)0;
              tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$8)
            {
              do
              {
                fprintf(fptys, "200-");
                fprintf(fptys, "Local udp port overlapped\r\n");
                fflush(fptys);
              }
              while((_Bool)0);
              return 1;
            }

          }

      }
      if(pv->vcport == 0)
      {
        j = 0;
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          if(!(vpcs_list[(signed long int)i].pid == 0))
          {
            if(!(j >= vpcs_list[(signed long int)i].vcport))
              j = vpcs_list[(signed long int)i].vcport;

          }

        if(j == 0)
          pv->vcport = 30000;

        else
          pv->vcport = j + 10;
      }

      else
      {
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          if(!(vpcs_list[(signed long int)i].pid == 0))
          {
            if(pv->vcport >= vpcs_list[(signed long int)i].vcport)
              tmp_if_expr$9 = pv->vcport - vpcs_list[(signed long int)i].vcport < 10 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$9 = (_Bool)0;
            if(tmp_if_expr$9)
              tmp_if_expr$11 = (_Bool)1;

            else
            {
              if(!(pv->vcport >= vpcs_list[(signed long int)i].vcport))
                tmp_if_expr$10 = vpcs_list[(signed long int)i].vcport - pv->vcport < 10 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$10 = (_Bool)0;
              tmp_if_expr$11 = tmp_if_expr$10 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$11)
            {
              do
              {
                fprintf(fptys, "200-");
                fprintf(fptys, "Remote udp port overlapped\r\n");
                fflush(fptys);
              }
              while((_Bool)0);
              return 1;
            }

          }

      }
      i = 0;
      if(!(pv->vport == 0))
      {
        return_value_snprintf$12=snprintf(buf + (signed long int)i, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)i, "-p %d ", pv->vport);
        i = i + return_value_snprintf$12;
      }

      if(!(pv->vsport == 0))
      {
        return_value_snprintf$13=snprintf(buf + (signed long int)i, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)i, "-s %d ", pv->vsport);
        i = i + return_value_snprintf$13;
      }

      if(!(pv->vcport == 0))
      {
        return_value_snprintf$14=snprintf(buf + (signed long int)i, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)i, "-c %d ", pv->vcport);
        i = i + return_value_snprintf$14;
      }

      if(!(pv->vmac == 0))
      {
        return_value_snprintf$15=snprintf(buf + (signed long int)i, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)i, "-m %d ", pv->vmac);
        i = i + return_value_snprintf$15;
      }

      j = 1;
      while(!(j >= ac))
      {
        signed int return_value_strcmp$16;
        return_value_strcmp$16=strcmp(av[(signed long int)j], "-p");
        if(return_value_strcmp$16 == 0)
          tmp_if_expr$18 = (_Bool)1;

        else
        {
          return_value_strcmp$17=strcmp(av[(signed long int)j], "-s");
          tmp_if_expr$18 = !(return_value_strcmp$17 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$18)
          tmp_if_expr$20 = (_Bool)1;

        else
        {
          return_value_strcmp$19=strcmp(av[(signed long int)j], "-c");
          tmp_if_expr$20 = !(return_value_strcmp$19 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$20)
          tmp_if_expr$22 = (_Bool)1;

        else
        {
          return_value_strcmp$21=strcmp(av[(signed long int)j], "-m");
          tmp_if_expr$22 = !(return_value_strcmp$21 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$22)
          j = j + 2;

        else
        {
          signed int return_value_snprintf$23;
          return_value_snprintf$23=snprintf(buf + (signed long int)i, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)i, "%s ", av[(signed long int)j]);
          i = i + return_value_snprintf$23;
          j = j + 1;
        }
      }
      pv->cmdline=strdup(buf);
      agv[(signed long int)0] = "vpcs";
      agv[(signed long int)1] = "-F";
      agc=mkargv(buf, (char **)(agv + (signed long int)2), 20);
      agc = agc + 1;
      agc = agc + 1;
      agv[(signed long int)agc] = (char *)(void *)0;
      pid=fork();
      if(!(pid == -1))
      {
        if(pid == 0)
          goto __CPROVER_DUMP_L97;

      }

      else
      {
        return 0;

      __CPROVER_DUMP_L97:
        ;
        clean();
        return_value_execvp$26=execvp(prgname, agv);
        if(return_value_execvp$26 == -1)
        {
          signed int *return_value___errno_location$24;
          return_value___errno_location$24=__errno_location();
          char *return_value_strerror$25;
          return_value_strerror$25=strerror(*return_value___errno_location$24);
          syslog(3, "Execute vpcs failed: %s\n", return_value_strerror$25);
        }

        exit(0);
        goto __CPROVER_DUMP_L101;
      }
      pv->pid = pid;
      do
      {
        fprintf(fptys, "100-");
        fprintf(fptys, "VPCS started with %s\r\n", pv->cmdline);
        fflush(fptys);
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L101;

    __CPROVER_DUMP_L101:
      ;
      return 0;
    }
  }
}

// sameNet
// file ip.h line 460
signed int sameNet(unsigned long int ip1, unsigned long int ip2, signed int cidr)
{
  unsigned int return_value_ntohl$1;
  return_value_ntohl$1=ntohl((unsigned int)ip1);
  unsigned int return_value_ntohl$2;
  return_value_ntohl$2=ntohl((unsigned int)ip2);
  return (signed int)((ip_masks[(signed long int)cidr] & (unsigned long int)return_value_ntohl$1) == (ip_masks[(signed long int)cidr] & (unsigned long int)return_value_ntohl$2));
}

// sameNet6
// file ip.h line 461
signed int sameNet6(char *s, char *d, signed int cidr)
{
  signed int b;
  signed int i;
  b = cidr / 8;
  i = 0;
  for( ; !(i >= b); i = i + 1)
    if(!(s[(signed long int)i] == d[(signed long int)i]))
      return 0;

  b = 8 - cidr % 8;
  if(!((signed int)s[(signed long int)i] >> b == (signed int)d[(signed long int)i] >> b))
    return 0;

  else
    return 1;
}

// save_eaddr
// file packets.c line 644
static void save_eaddr(struct anonymous$0 *pc, unsigned int addr, unsigned char *mac)
{
  signed int i;
  signed int return_value_sameNet$1;
  return_value_sameNet$1=sameNet((unsigned long int)addr, (unsigned long int)pc->ip4.ip, pc->ip4.cidr);
  _Bool tmp_if_expr$2;
  if(!(return_value_sameNet$1 == 0))
  {
    i = 0;
    for( ; !(i >= 10); i = i + 1)
    {
      if(!(time_tick + -((unsigned int)pc->ipmac4[(signed long int)i].timeout) >= 121u))
      {
        if(pc->ipmac4[(signed long int)i].ip == addr)
        {
          pc->ipmac4[(signed long int)i].timeout = (signed int)time_tick;
          break;
        }

      }

      if(pc->ipmac4[(signed long int)i].timeout == 0)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = time_tick - (unsigned int)pc->ipmac4[(signed long int)i].timeout > (unsigned int)120 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        pc->ipmac4[(signed long int)i].ip = addr;
        memcpy((void *)pc->ipmac4[(signed long int)i].mac, (const void *)mac, (unsigned long int)6);
        pc->ipmac4[(signed long int)i].timeout = (signed int)time_tick;
        break;
      }

    }
  }

}

// savehistory
// file readline.h line 62
signed int savehistory(const char *filename, struct rls *rls)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  signed int i;
  signed int *return_value___errno_location$1;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  else
  {
    i = 0;
    for( ; !(i >= rls->hist_total); i = i + 1)
      fprintf(fp, "%s\n", rls->history[(signed long int)i]);
    fclose(fp);
    return 0;
  }
}

// set_dump
// file command.c line 1484
static signed int set_dump(signed int argc, char **argv)
{
  signed int ok = 1;
  signed int i = 2;
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  signed int dmpflag = 0;
  if(argc == 2)
    ok = 0;

  unsigned long int return_value_strlen$7;
  signed int return_value_strncmp$8;
  unsigned long int return_value_strlen$5;
  signed int return_value_strncmp$6;
  unsigned long int return_value_strlen$3;
  signed int return_value_strncmp$4;
  unsigned long int return_value_strlen$1;
  signed int return_value_strncmp$2;
  while(!(i >= argc))
  {
    unsigned long int return_value_strlen$9;
    return_value_strlen$9=strlen(argv[(signed long int)i]);
    signed int return_value_strncmp$10;
    return_value_strncmp$10=strncmp(argv[(signed long int)i], "mac", return_value_strlen$9);
    if(return_value_strncmp$10 == 0)
      dmpflag = dmpflag | 1;

    else
    {
      return_value_strlen$7=strlen(argv[(signed long int)i]);
      return_value_strncmp$8=strncmp(argv[(signed long int)i], "raw", return_value_strlen$7);
      if(return_value_strncmp$8 == 0)
        dmpflag = dmpflag | 2;

      else
      {
        return_value_strlen$5=strlen(argv[(signed long int)i]);
        return_value_strncmp$6=strncmp(argv[(signed long int)i], "detail", return_value_strlen$5);
        if(return_value_strncmp$6 == 0)
          dmpflag = dmpflag | 4;

        else
        {
          return_value_strlen$3=strlen(argv[(signed long int)i]);
          return_value_strncmp$4=strncmp(argv[(signed long int)i], "all", return_value_strlen$3);
          if(return_value_strncmp$4 == 0)
            dmpflag = dmpflag | 0x80;

          else
          {
            return_value_strlen$1=strlen(argv[(signed long int)i]);
            return_value_strncmp$2=strncmp(argv[(signed long int)i], "off", return_value_strlen$1);
            if(return_value_strncmp$2 == 0)
              dmpflag = 0;

            else
            {
              printf("Invalid options\n");
              ok = 0;
              break;
            }
          }
        }
      }
    }
    i = i + 1;
  }
  if(!(ok == 0))
  {
    if(dmpflag == 0)
      pc->dmpflag = 0;

    else
      pc->dmpflag = pc->dmpflag | dmpflag;
    printf("\ndump flags:");
    if(!((1 & pc->dmpflag) == 0))
      printf(" mac");

    if(!((2 & pc->dmpflag) == 0))
      printf(" raw");

    if(!((4 & pc->dmpflag) == 0))
      printf(" detail");

    if(!((0x80 & pc->dmpflag) == 0))
      printf(" all");

    if(pc->dmpflag == 0)
      printf(" (none)");

    printf("\n");
    return 1;
  }

  else
    return 1;
}

// set_telnet_mode
// file daemon.c line 296
static void set_telnet_mode(signed int s)
{
  char *neg = "\001\001\003\003";
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(neg);
  signed long int return_value_write$2;
  return_value_write$2=write(s, (const void *)neg, return_value_strlen$1);
}

// set_telnet_mode$link1
// file hv.c line 819
static void set_telnet_mode$link1(signed int s$link1)
{
  char *neg$link1 = "\001\001\003\003";
  unsigned long int return_value_strlen$1$link1;
  return_value_strlen$1$link1=strlen(neg$link1);
  signed long int return_value_write$2$link1;
  return_value_write$2$link1=write(s$link1, (const void *)neg$link1, return_value_strlen$1$link1);
}

// set_terminal
// file readline.c line 533
void set_terminal(signed int fd, struct termios *stored_settings)
{
  struct termios new_settings;
  tcgetattr(fd, stored_settings);
  new_settings = *stored_settings;
  new_settings.c_lflag = new_settings.c_lflag & (unsigned int)~(0000002 | 0000010 | 0000001);
  new_settings.c_cc[(signed long int)5] = (unsigned char)1;
  new_settings.c_cc[(signed long int)6] = (unsigned char)3;
  tcsetattr(fd, 0, &new_settings);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// show_arp
// file command.c line 1536
static signed int show_arp(signed int argc, char **argv)
{
  struct anonymous$0 *pc;
  signed int i;
  signed int j;
  struct in_addr in;
  char buf[18l];
  unsigned char zero[6l] = { (unsigned char)0, 0, 0, 0, 0, 0 };
  signed int empty = 1;
  signed int si;
  printf("\n");
  unsigned long int return_value_strlen$4;
  _Bool tmp_if_expr$6;
  signed int return_value_digitstring$5;
  if(argc == 3)
  {
    unsigned long int return_value_strlen$7;
    return_value_strlen$7=strlen(argv[(signed long int)2]);
    signed int return_value_strncmp$8;
    return_value_strncmp$8=strncmp(argv[(signed long int)2], "all", return_value_strlen$7);
    if(return_value_strncmp$8 == 0)
    {
      si = 0;
      for( ; !(si >= num_pths); si = si + 1)
      {
        pc = &vpc[(signed long int)si];
        printf("%s[%d]:\n", (const void *)pc->xname, si + 1);
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          if(!(pc->ipmac4[(signed long int)i].ip == 0u))
          {
            signed int return_value_memcmp$1;
            return_value_memcmp$1=memcmp((const void *)pc->ipmac4[(signed long int)i].mac, (const void *)zero, (unsigned long int)6);
            if(!(return_value_memcmp$1 == 0))
            {
              if(!(time_tick + -((unsigned int)pc->ipmac4[(signed long int)i].timeout) >= 121u))
              {
                j = 0;
                for( ; !(j >= 6); j = j + 1)
                  sprintf(buf + (signed long int)(j * 3), "%2.2x:", pc->ipmac4[(signed long int)i].mac[(signed long int)j]);
                buf[(signed long int)17] = (char)0;
                in.s_addr = pc->ipmac4[(signed long int)i].ip;
                char *return_value_inet_ntoa$2;
                return_value_inet_ntoa$2=inet_ntoa(in);
                printf("%s  %s expires in %d seconds \n", (const void *)buf, return_value_inet_ntoa$2, (unsigned int)120 - (time_tick - (unsigned int)pc->ipmac4[(signed long int)i].timeout));
                empty = 0;
              }

            }

          }

        if(!(empty == 0))
          printf("arp table is empty\n");

      }
      return 1;
    }

    else
    {
      return_value_strlen$4=strlen(argv[(signed long int)2]);
      if(return_value_strlen$4 == 1ul)
      {
        return_value_digitstring$5=digitstring(argv[(signed long int)2]);
        tmp_if_expr$6 = return_value_digitstring$5 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
      {
        signed int return_value_atoi$3;
        return_value_atoi$3=atoi(argv[(signed long int)2]);
        si = return_value_atoi$3 - 1;
        if(!(si >= 0))
        {
          printf("Invalid ID\n");
          return 1;
        }

      }

      else
      {
        printf("Invalid ID\n");
        return 1;
      }
    }
  }

  else
    si = pcid;
  if(!(si == pcid))
    printf("%s[%d]:\n", (const void *)vpc[(signed long int)si].xname, si + 1);

  pc = &vpc[(signed long int)si];
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(!(pc->ipmac4[(signed long int)i].ip == 0u))
    {
      signed int return_value_etherIsZero$9;
      return_value_etherIsZero$9=etherIsZero(pc->ipmac4[(signed long int)i].mac);
      if(return_value_etherIsZero$9 == 0)
      {
        if(!(time_tick + -((unsigned int)pc->ipmac4[(signed long int)i].timeout) >= 120u))
        {
          j = 0;
          for( ; !(j >= 6); j = j + 1)
            sprintf(buf + (signed long int)(j * 3), "%2.2x:", pc->ipmac4[(signed long int)i].mac[(signed long int)j]);
          buf[(signed long int)17] = (char)0;
          in.s_addr = pc->ipmac4[(signed long int)i].ip;
          char *return_value_inet_ntoa$10;
          return_value_inet_ntoa$10=inet_ntoa(in);
          printf("%s  %s expires in %d seconds \n", (const void *)buf, return_value_inet_ntoa$10, (unsigned int)120 - (time_tick - (unsigned int)pc->ipmac4[(signed long int)i].timeout));
          empty = 0;
        }

      }

    }

  if(!(empty == 0))
    printf("arp table is empty\n");

  return 1;
}

// show_dump
// file command.c line 1611
static signed int show_dump(signed int argc, char **argv)
{
  signed int i;
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  printf("\n");
  _Bool tmp_if_expr$6;
  signed int return_value_digitstring$5;
  if(argc == 3)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(argv[(signed long int)2]);
    signed int return_value_strncmp$2;
    return_value_strncmp$2=strncmp(argv[(signed long int)2], "all", return_value_strlen$1);
    if(return_value_strncmp$2 == 0)
    {
      i = 0;
      for( ; !(i >= num_pths); i = i + 1)
      {
        printf("%s[%d] dumpflag:", (const void *)vpc[(signed long int)i].xname, i + 1);
        if(!((1 & vpc[(signed long int)i].dmpflag) == 0))
          printf(" mac");

        if(!((2 & vpc[(signed long int)i].dmpflag) == 0))
          printf(" raw");

        if(!((4 & vpc[(signed long int)i].dmpflag) == 0))
          printf(" detail");

        if(!((0x80 & vpc[(signed long int)i].dmpflag) == 0))
          printf(" all");

        if(vpc[(signed long int)i].dmpflag == 0)
          printf(" (none)");

        printf("\n");
      }
      return 1;
    }

    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(argv[(signed long int)2]);
    if(return_value_strlen$4 == 1ul)
    {
      return_value_digitstring$5=digitstring(argv[(signed long int)2]);
      tmp_if_expr$6 = return_value_digitstring$5 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
    {
      signed int return_value_atoi$3;
      return_value_atoi$3=atoi(argv[(signed long int)2]);
      i = return_value_atoi$3 - 1;
      pc = &vpc[(signed long int)i];
    }

    else
      printf("\033[1mshow dump [all]\033[0m\n    all     all vpc's dump flags\n");
    return 1;
  }

  printf("dump flags:");
  if(!((1 & pc->dmpflag) == 0))
    printf(" mac");

  if(!((2 & pc->dmpflag) == 0))
    printf(" raw");

  if(!((4 & pc->dmpflag) == 0))
    printf(" detail");

  if(!((0x80 & pc->dmpflag) == 0))
    printf(" all");

  if(pc->dmpflag == 0)
    printf(" (none)");

  printf("\n");
  return 1;
}

// show_echo
// file command.c line 1767
static signed int show_echo(signed int argc, char **argv)
{
  printf("\n");
  if(!(canEcho == 0))
    printf("Echo On\n");

  else
    printf("Echo Off\n");
  return 1;
}

// show_ip
// file command.c line 1660
static signed int show_ip(signed int argc, char **argv)
{
  signed int i;
  signed int j;
  signed int k;
  struct in_addr in;
  char buf[128l];
  signed int id = -1;
  signed int return_value_digitstring$8;
  if(argc == 3)
  {
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(argv[(signed long int)2]);
    signed int return_value_strncmp$7;
    return_value_strncmp$7=strncmp(argv[(signed long int)2], "all", return_value_strlen$6);
    if(return_value_strncmp$7 == 0)
    {
      memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
      memset((void *)buf, 32, sizeof(char [128l]) /*128ul*/  - (unsigned long int)1);
      j=sprintf(buf, "NAME");
      buf[(signed long int)j] = (char)32;
      j=sprintf(buf + (signed long int)7, "IP/MASK");
      buf[(signed long int)(j + 7)] = (char)32;
      j=sprintf(buf + (signed long int)28, "GATEWAY");
      buf[(signed long int)(j + 28)] = (char)32;
      j=sprintf(buf + (signed long int)46, "MAC");
      buf[(signed long int)(j + 46)] = (char)32;
      j=sprintf(buf + (signed long int)65, "DNS");
      printf("\n%s\n", (const void *)buf);
      i = 0;
      for( ; !(i >= num_pths); i = i + 1)
      {
        memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
        memset((void *)buf, 32, sizeof(char [128l]) /*128ul*/  - (unsigned long int)1);
        signed int return_value_strcmp$1;
        return_value_strcmp$1=strcmp(vpc[(signed long int)i].xname, "VPCS");
        if(return_value_strcmp$1 == 0)
          j=sprintf(buf, "%s%d", (const void *)vpc[(signed long int)i].xname, i + 1);

        else
          j=sprintf(buf, "%s", (const void *)vpc[(signed long int)i].xname);
        buf[(signed long int)j] = (char)32;
        in.s_addr = vpc[(signed long int)i].ip4.ip;
        char *return_value_inet_ntoa$2;
        return_value_inet_ntoa$2=inet_ntoa(in);
        j=sprintf(buf + (signed long int)7, "%s/%d", return_value_inet_ntoa$2, vpc[(signed long int)i].ip4.cidr);
        buf[(signed long int)(j + 7)] = (char)32;
        in.s_addr = (unsigned int)vpc[(signed long int)i].ip4.gw;
        char *return_value_inet_ntoa$3;
        return_value_inet_ntoa$3=inet_ntoa(in);
        j=sprintf(buf + (signed long int)28, "%s", return_value_inet_ntoa$3);
        buf[(signed long int)(j + 28)] = (char)32;
        k = 0;
        for( ; !(k >= 6); k = k + 1)
          sprintf(buf + (signed long int)46 + (signed long int)(k * 3), "%2.2x:", vpc[(signed long int)i].ip4.mac[(signed long int)k]);
        buf[(signed long int)63] = (char)32;
        buf[(signed long int)64] = (char)32;
        buf[(signed long int)65] = (char)0;
        k = 65;
        if(!(vpc[(signed long int)i].ip4.dns[0l] == 0u))
        {
          in.s_addr = vpc[(signed long int)i].ip4.dns[(signed long int)0];
          char *return_value_inet_ntoa$4;
          return_value_inet_ntoa$4=inet_ntoa(in);
          j=sprintf(buf + (signed long int)k, "%s", return_value_inet_ntoa$4);
        }

        if(!(vpc[(signed long int)i].ip4.dns[1l] == 0u))
        {
          in.s_addr = vpc[(signed long int)i].ip4.dns[(signed long int)1];
          buf[(signed long int)(j + 65)] = (char)32;
          k = j + 66;
          char *return_value_inet_ntoa$5;
          return_value_inet_ntoa$5=inet_ntoa(in);
          j=sprintf(buf + (signed long int)k, "%s", return_value_inet_ntoa$5);
        }

        printf("%s\n", (const void *)buf);
      }
      return 1;
    }

    unsigned long int return_value_strlen$9;
    return_value_strlen$9=strlen(argv[(signed long int)2]);
    if(return_value_strlen$9 == 1ul)
    {
      return_value_digitstring$8=digitstring(argv[(signed long int)2]);
      if(!(return_value_digitstring$8 == 0))
        id = (signed int)argv[(signed long int)2][(signed long int)0] - 49;

    }

  }

  else
    if(argc == 2)
      id = pcid;

  if(!(id == -1))
  {
    printf("\n");
    printf("NAME        : %s[%d]\n", (const void *)vpc[(signed long int)id].xname, id + 1);
    in.s_addr = vpc[(signed long int)id].ip4.ip;
    char *return_value_inet_ntoa$10;
    return_value_inet_ntoa$10=inet_ntoa(in);
    printf("IP/MASK     : %s/%d\n", return_value_inet_ntoa$10, vpc[(signed long int)id].ip4.cidr);
    in.s_addr = (unsigned int)vpc[(signed long int)id].ip4.gw;
    char *return_value_inet_ntoa$11;
    return_value_inet_ntoa$11=inet_ntoa(in);
    printf("GATEWAY     : %s\n", return_value_inet_ntoa$11);
    printf("DNS         : ");
    if(!(vpc[(signed long int)id].ip4.dns[0l] == 0u))
    {
      in.s_addr = vpc[(signed long int)id].ip4.dns[(signed long int)0];
      char *return_value_inet_ntoa$12;
      return_value_inet_ntoa$12=inet_ntoa(in);
      printf("%s  ", return_value_inet_ntoa$12);
    }

    if(!(vpc[(signed long int)id].ip4.dns[1l] == 0u))
    {
      in.s_addr = vpc[(signed long int)id].ip4.dns[(signed long int)1];
      char *return_value_inet_ntoa$13;
      return_value_inet_ntoa$13=inet_ntoa(in);
      printf("%s", return_value_inet_ntoa$13);
    }

    printf("\n");
    if(!(vpc[(signed long int)id].ip4.dhcp.svr == 0u))
    {
      in.s_addr = vpc[(signed long int)id].ip4.dhcp.svr;
      char *return_value_inet_ntoa$14;
      return_value_inet_ntoa$14=inet_ntoa(in);
      printf("DHCP SERVER : %s\n", return_value_inet_ntoa$14);
    }

    if(!(vpc[(signed long int)id].ip4.domain[0l] == 0))
      printf("DOMAIN NAME : %s\n", (const void *)vpc[(signed long int)id].ip4.domain);

    else
      if(!(vpc[(signed long int)id].ip4.dhcp.domain[0l] == 0))
        printf("DOMAIN NAME : %s\n", (const void *)vpc[(signed long int)id].ip4.dhcp.domain);

    printf("MAC         : ");
    printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", vpc[(signed long int)id].ip4.mac[(signed long int)0], vpc[(signed long int)id].ip4.mac[(signed long int)1], vpc[(signed long int)id].ip4.mac[(signed long int)2], vpc[(signed long int)id].ip4.mac[(signed long int)3], vpc[(signed long int)id].ip4.mac[(signed long int)4], vpc[(signed long int)id].ip4.mac[(signed long int)5]);
    printf("\n");
    printf("LPORT       : %d\n", vpc[(signed long int)id].lport);
    in.s_addr = vpc[(signed long int)id].rhost;
    char *return_value_inet_ntoa$15;
    return_value_inet_ntoa$15=inet_ntoa(in);
    printf("RHOST:PORT  : %s:%d\n", return_value_inet_ntoa$15, vpc[(signed long int)id].rport);
    printf("MTU:        : %d\n", vpc[(signed long int)id].ip4.mtu);
    return 1;
  }

  argv[(signed long int)(argc - 1)] = "?";
  help_show(argc, argv);
  return 1;
}

// show_ipv6
// file command6.h line 41
signed int show_ipv6(signed int argc, char **argv)
{
  signed int i;
  signed int j;
  signed int k;
  char buf[128l];
  char buf6[47l];
  struct in6_addr ipaddr;
  struct in_addr in;
  signed int off1;
  signed int off2;
  signed int off3;
  signed int max6 = 0;
  signed int id = -1;
  printf("\n");
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  signed int return_value_sprintf$8;
  signed int return_value_sprintf$10;
  signed int return_value_sprintf$11;
  signed int return_value_digitstring$14;
  if(argc == 3)
  {
    unsigned long int return_value_strlen$12;
    return_value_strlen$12=strlen(argv[(signed long int)2]);
    signed int return_value_strncmp$13;
    return_value_strncmp$13=strncmp(argv[(signed long int)2], "all", return_value_strlen$12);
    if(return_value_strncmp$13 == 0)
    {
      i = 0;
      for( ; !(i >= num_pths); i = i + 1)
      {
        if(!(vpc[(signed long int)i].ip6.ip.uaddr._a32[0l] == 0u))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = vpc[(signed long int)i].ip6.ip.uaddr._a32[(signed long int)1] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = vpc[(signed long int)i].ip6.ip.uaddr._a32[(signed long int)2] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = vpc[(signed long int)i].ip6.ip.uaddr._a32[(signed long int)3] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
        {
          memset((void *)buf6, 0, (unsigned long int)(46 + 1));
          memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)vpc[(signed long int)i].ip6.ip.uaddr._a8, (unsigned long int)16);
          vinet_ntop6(10, (const void *)&ipaddr, buf6, (unsigned int)(46 + 1));
          j=sprintf(buf, "%s/%d", (const void *)buf6, vpc[(signed long int)i].ip6.cidr);
          if(!(max6 >= j))
            max6 = j;

        }

      }
      memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
      memset((void *)buf, 32, sizeof(char [128l]) /*128ul*/  - (unsigned long int)1);
      off1 = 7;
      off2 = off1 + max6 + 2;
      off3 = off2 + 17 + 2;
      j=sprintf(buf, "NAME");
      buf[(signed long int)j] = (char)32;
      j=sprintf(buf + (signed long int)off1, "IP/MASK");
      buf[(signed long int)(j + off1)] = (char)32;
      j=sprintf(buf + (signed long int)off2, "ROUTER LINK-LAYER");
      buf[(signed long int)(j + off2)] = (char)32;
      j=sprintf(buf + (signed long int)off3, "MTU");
      printf("%s\n", (const void *)buf);
      i = 0;
      for( ; !(i >= num_pths); i = i + 1)
      {
        memset((void *)buf, 0, sizeof(char [128l]) /*128ul*/ );
        memset((void *)buf, 32, sizeof(char [128l]) /*128ul*/  - (unsigned long int)1);
        signed int return_value_strcmp$4;
        return_value_strcmp$4=strcmp(vpc[(signed long int)i].xname, "VPCS");
        if(return_value_strcmp$4 == 0)
          j=sprintf(buf, "%s%d", (const void *)vpc[(signed long int)i].xname, i + 1);

        else
          j=sprintf(buf, "%s", (const void *)vpc[(signed long int)i].xname);
        buf[(signed long int)j] = (char)32;
        memset((void *)buf6, 0, (unsigned long int)(46 + 1));
        memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)vpc[(signed long int)i].link6.ip.uaddr._a8, (unsigned long int)16);
        vinet_ntop6(10, (const void *)&ipaddr, buf6, (unsigned int)(46 + 1));
        sprintf(buf + (signed long int)7, "%s/%d", (const void *)buf6, vpc[(signed long int)i].link6.cidr);
        j = printf("%s", (const void *)buf);
        if(!(vpc[(signed long int)i].ip6.ip.uaddr._a32[0l] == 0u))
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = vpc[(signed long int)i].ip6.ip.uaddr._a32[(signed long int)1] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = vpc[(signed long int)i].ip6.ip.uaddr._a32[(signed long int)2] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = vpc[(signed long int)i].ip6.ip.uaddr._a32[(signed long int)3] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
        {
          memset((void *)buf6, 0, (unsigned long int)(46 + 1));
          memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)vpc[(signed long int)i].ip6.ip.uaddr._a8, (unsigned long int)16);
          vinet_ntop6(10, (const void *)&ipaddr, buf6, (unsigned int)(46 + 1));
          printf("\n");
          k = 0;
          for( ; !(k >= off1); k = k + 1)
            printf(" ");
          j = printf("%s/%d", (const void *)buf6, vpc[(signed long int)i].ip6.cidr);
          j = j + off1;
        }

        k = j;
        for( ; !(k >= off2); k = k + 1)
          printf(" ");
        signed int return_value_etherIsZero$9;
        return_value_etherIsZero$9=etherIsZero(vpc[(signed long int)i].ip6.gmac);
        if(!(return_value_etherIsZero$9 == 0))
          j=sprintf(buf, "                 ");

        else
        {
          j = 0;
          k = 0;
          for( ; !(k >= 6); k = k + 1)
          {
            return_value_sprintf$8=sprintf(buf + (signed long int)(k * 3), "%2.2x:", vpc[(signed long int)i].ip6.gmac[(signed long int)k]);
            j = j + return_value_sprintf$8;
          }
        }
        buf[(signed long int)(j - 1)] = (char)32;
        if(!(vpc[(signed long int)i].ip6.mtu == 0))
        {
          return_value_sprintf$10=sprintf(buf + (signed long int)j, " %4.4d", vpc[(signed long int)i].ip6.mtu);
          j = j + return_value_sprintf$10;
        }

        else
        {
          return_value_sprintf$11=sprintf(buf + (signed long int)j, "     ");
          j = j + return_value_sprintf$11;
        }
        printf("%s\n", (const void *)buf);
      }
      return 1;
    }

    unsigned long int return_value_strlen$15;
    return_value_strlen$15=strlen(argv[(signed long int)2]);
    if(return_value_strlen$15 == 1ul)
    {
      return_value_digitstring$14=digitstring(argv[(signed long int)2]);
      if(!(return_value_digitstring$14 == 0))
        id = (signed int)argv[(signed long int)2][(signed long int)0] - 49;

    }

  }

  else
    if(argc == 2)
      id = pcid;

  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  if(!(id == -1))
  {
    printf("NAME              : %s[%d]\n", (const void *)vpc[(signed long int)id].xname, id + 1);
    printf("LINK-LOCAL SCOPE  : ");
    memset((void *)buf6, 0, (unsigned long int)(46 + 1));
    memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)vpc[(signed long int)id].link6.ip.uaddr._a8, (unsigned long int)16);
    vinet_ntop6(10, (const void *)&ipaddr, buf6, (unsigned int)(46 + 1));
    printf("%s/%d\n", (const void *)buf6, vpc[(signed long int)id].link6.cidr);
    printf("GLOBAL SCOPE      : ");
    if(!(vpc[(signed long int)id].ip6.ip.uaddr._a32[0l] == 0u))
      tmp_if_expr$16 = (_Bool)1;

    else
      tmp_if_expr$16 = vpc[(signed long int)id].ip6.ip.uaddr._a32[(signed long int)1] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$16)
      tmp_if_expr$17 = (_Bool)1;

    else
      tmp_if_expr$17 = vpc[(signed long int)id].ip6.ip.uaddr._a32[(signed long int)2] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$17)
      tmp_if_expr$18 = (_Bool)1;

    else
      tmp_if_expr$18 = vpc[(signed long int)id].ip6.ip.uaddr._a32[(signed long int)3] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$18)
    {
      memset((void *)buf6, 0, (unsigned long int)(46 + 1));
      memcpy((void *)ipaddr.__in6_u.__u6_addr8, (const void *)vpc[(signed long int)id].ip6.ip.uaddr._a8, (unsigned long int)16);
      vinet_ntop6(10, (const void *)&ipaddr, buf6, (unsigned int)(46 + 1));
      printf("%s/%d", (const void *)buf6, vpc[(signed long int)id].ip6.cidr);
    }

    printf("\n");
    printf("ROUTER LINK-LAYER : ");
    signed int return_value_etherIsZero$19;
    return_value_etherIsZero$19=etherIsZero(vpc[(signed long int)id].ip6.gmac);
    if(return_value_etherIsZero$19 == 0)
      printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", vpc[(signed long int)id].ip6.gmac[(signed long int)0], vpc[(signed long int)id].ip6.gmac[(signed long int)1], vpc[(signed long int)id].ip6.gmac[(signed long int)2], vpc[(signed long int)id].ip6.gmac[(signed long int)3], vpc[(signed long int)id].ip6.gmac[(signed long int)4], vpc[(signed long int)id].ip6.gmac[(signed long int)5]);

    printf("\n");
    printf("MAC               : ");
    printf("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x", vpc[(signed long int)id].ip4.mac[(signed long int)0], vpc[(signed long int)id].ip4.mac[(signed long int)1], vpc[(signed long int)id].ip4.mac[(signed long int)2], vpc[(signed long int)id].ip4.mac[(signed long int)3], vpc[(signed long int)id].ip4.mac[(signed long int)4], vpc[(signed long int)id].ip4.mac[(signed long int)5]);
    printf("\n");
    printf("LPORT             : %d\n", vpc[(signed long int)id].lport);
    in.s_addr = vpc[(signed long int)id].rhost;
    char *return_value_inet_ntoa$20;
    return_value_inet_ntoa$20=inet_ntoa(in);
    printf("RHOST:PORT        : %s:%d\n", return_value_inet_ntoa$20, vpc[(signed long int)id].rport);
    printf("MTU:              : ");
    if(!(vpc[(signed long int)id].ip6.mtu == 0))
      printf("%d", vpc[(signed long int)id].ip6.mtu);

    printf("\n");
    return 1;
  }

  argv[(signed long int)(argc - 1)] = "?";
  help_show(argc, argv);
  return 1;
}

// sig_clean
// file vpcs.c line 551
static void sig_clean(signed int sig)
{
  signed int i = 0;
  for( ; !(i >= num_pths); i = i + 1)
    close(vpc[(signed long int)i].fd);
  if(!(histfile == ((char *)NULL)) && !(rls == ((struct rls *)NULL)))
    savehistory(histfile, rls);

}

// sig_int
// file vpcs.c line 390
static void sig_int(signed int sig)
{
  ctrl_c = 1;
  signal(2, sig_int);
}

// sig_int$link1
// file daemon.c line 289
static void sig_int$link1(signed int sig$link1)
{
  ctrl_c = 1;
  signal(2, sig_int$link1);
}

// sig_quit
// file daemon.c line 253
static void sig_quit(signed int sig)
{
  cmd_quit = 1;
  signal(3, sig_quit);
}

// sig_term
// file daemon.c line 242
static void sig_term(signed int sig)
{
  usleep((unsigned int)100000);
  kill(fdtty_pid, 9);
  exit(0);
}

// sig_usr1
// file daemon.c line 264
static void sig_usr1(signed int sig)
{
  usleep((unsigned int)100000);
  kill(fdtty_pid, 9);
  exit(0);
}

// sig_usr2
// file daemon.c line 275
static void sig_usr2(signed int sig)
{
  kill(fdtty_pid, 10);
  usleep((unsigned int)100000);
  kill(fdtty_pid, 9);
  usleep((unsigned int)100000);
  exit(0);
}

// startup
// file vpcs.c line 511
static void startup(void)
{
  struct _IO_FILE *fp;
  signed int argc;
  char *argv[3l];
  if(startupfile == ((char *)NULL))
  {
    fp=fopen(default_startupfile, "r");
    if(!(fp == ((struct _IO_FILE *)NULL)))
    {
      fclose(fp);
      argv[(signed long int)0] = "load";
      argv[(signed long int)1] = (char *)default_startupfile;
      argv[(signed long int)2] = (char *)(void *)0;
      argc = 2;
      runStartup = 1;
      run_load(argc, argv);
      runStartup = 0;
    }

    goto __CPROVER_DUMP_L6;
  }

  else
  {
    fp=fopen(startupfile, "r");
    if(!(fp == ((struct _IO_FILE *)NULL)))
    {
      fclose(fp);
      runStartup = 1;
      argv[(signed long int)0] = "load";
      argv[(signed long int)1] = (char *)startupfile;
      argv[(signed long int)2] = (char *)(void *)0;
      argc = 2;
      run_load(argc, argv);
      runStartup = 0;
    }

    else
      printf("Can't open %s\n", startupfile);
    goto __CPROVER_DUMP_L6;
  }

__CPROVER_DUMP_L6:
  ;
}

// swap_ehead
// file ip.h line 451
void swap_ehead(char *mbuf)
{
  unsigned char mac[6l];
  struct ethdr *eh = (struct ethdr *)mbuf;
  memcpy((void *)mac, (const void *)eh->dst, (unsigned long int)6);
  memcpy((void *)eh->dst, (const void *)eh->src, (unsigned long int)6);
  memcpy((void *)eh->src, (const void *)mac, (unsigned long int)6);
}

// swap_ip6head
// file ip.h line 463
void swap_ip6head(struct packet *m)
{
  struct anonymous$11 ip0;
  struct anonymous$18 *ip = (struct anonymous$18 *)(m->data + (signed long int)sizeof(struct ethdr) /*14ul*/ );
  memcpy((void *)ip0.uaddr._a8, (const void *)ip->dst.uaddr._a8, (unsigned long int)16);
  memcpy((void *)ip->dst.uaddr._a8, (const void *)ip->src.uaddr._a8, (unsigned long int)16);
  memcpy((void *)ip->src.uaddr._a8, (const void *)ip0.uaddr._a8, (unsigned long int)16);
}

// tcp
// file tcp.c line 486
signed int tcp(struct anonymous$0 *pc, struct packet *m)
{
  struct iphdr *ip = (struct iphdr *)(m->data + (signed long int)sizeof(struct ethdr) /*14ul*/ );
  struct tcpiphdr *ti = (struct tcpiphdr *)ip;
  struct sesscb *cb = (struct sesscb *)(void *)0;
  struct packet *p = (struct packet *)(void *)0;
  signed int i;
  unsigned short int return_value_ntohs$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  if(!(ip->dip == pc->ip4.ip))
    return 0;

  else
  {
    if(!(pc->mscb.sock == 0))
    {
      return_value_ntohs$2=ntohs(ti->ti_t.th_dport);
      if((unsigned int)return_value_ntohs$2 == pc->mscb.sport)
      {
        if(ip->sip == pc->mscb.dip)
        {
          if(pc->mscb.proto == (signed int)ip->proto)
          {
            if(!(time_tick + -pc->mscb.timeout >= 61u))
              return 2;

            struct sesscb rcb;
            signed long int return_value_random$1;
            return_value_random$1=random();
            rcb.seq = (unsigned int)return_value_random$1;
            rcb.sip = ip->sip;
            rcb.dip = ip->dip;
            rcb.sport = (unsigned int)ti->ti_t.th_sport;
            rcb.dport = (unsigned int)ti->ti_t.th_dport;
            rcb.flags = (unsigned char)(0x04 | 0x01 | 0x10);
            p=tcpReply(m, &rcb);
            if(!(p == ((struct packet *)NULL)))
              enq(&pc->oq, p);

            else
              printf("reply error\n");
            return 0;
          }

        }

      }

    }

    i = 0;
    for( ; !(i >= 1000); i = i + 1)
      if((signed int)ti->ti_t.th_flags == 0x02)
      {
        if(pc->sesscb[(signed long int)i].timeout == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = time_tick - pc->sesscb[(signed long int)i].timeout > (unsigned int)60 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          if(ip->sip == pc->sesscb[(signed long int)i].sip)
            tmp_if_expr$5 = ip->dip == pc->sesscb[(signed long int)i].dip ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          if(tmp_if_expr$5)
            tmp_if_expr$6 = (unsigned int)ti->ti_t.th_sport == pc->sesscb[(signed long int)i].sport ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
            tmp_if_expr$7 = (unsigned int)ti->ti_t.th_dport == pc->sesscb[(signed long int)i].dport ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          cb = &pc->sesscb[(signed long int)i];
          cb->timeout = time_tick;
          signed long int return_value_random$3;
          return_value_random$3=random();
          cb->seq = (unsigned int)return_value_random$3;
          cb->sip = ip->sip;
          cb->dip = ip->dip;
          cb->sport = (unsigned int)ti->ti_t.th_sport;
          cb->dport = (unsigned int)ti->ti_t.th_dport;
          break;
        }

      }

      else
        if(!(time_tick + -pc->sesscb[(signed long int)i].timeout >= 61u))
        {
          if(ip->sip == pc->sesscb[(signed long int)i].sip)
          {
            if(ip->dip == pc->sesscb[(signed long int)i].dip)
            {
              if((unsigned int)ti->ti_t.th_sport == pc->sesscb[(signed long int)i].sport)
              {
                if((unsigned int)ti->ti_t.th_dport == pc->sesscb[(signed long int)i].dport)
                {
                  cb = &pc->sesscb[(signed long int)i];
                  break;
                }

              }

            }

          }

        }

    if((signed int)ti->ti_t.th_flags == 0x02)
    {
      if(!(cb == ((struct sesscb *)NULL)))
        goto __CPROVER_DUMP_L21;

      printf("VPCS %d out of session\n", pc->id);
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L21:
      ;
      if(!(cb == ((struct sesscb *)NULL)))
      {
        if((signed int)ti->ti_t.th_flags == 0x10)
          tmp_if_expr$9 = (signed int)cb->flags == 0x01 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        if(tmp_if_expr$9)
          memset((void *)cb, 0, sizeof(struct sesscb) /*160ul*/ );

        else
        {
          cb->timeout = time_tick;
          p=tcpReply(m, cb);
          if(!(p == ((struct packet *)NULL)))
            enq(&pc->oq, p);

          if((0x01 & (signed int)cb->rflags) == 0x01)
          {
            if((signed int)cb->flags == 17)
            {
              p=tcpReply(m, cb);
              if(!(p == ((struct packet *)NULL)))
                enq(&pc->oq, p);

            }

          }

        }
      }

      return 0;
    }
  }
}

// tcp6
// file tcp.c line 654
signed int tcp6(struct anonymous$0 *pc, struct packet *m)
{
  struct anonymous$18 *ip = (struct anonymous$18 *)(m->data + (signed long int)sizeof(struct ethdr) /*14ul*/ );
  struct tcphdr *th = (struct tcphdr *)(ip + (signed long int)1);
  struct sesscb *cb = (struct sesscb *)(void *)0;
  struct packet *p = (struct packet *)(void *)0;
  signed int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  if((signed int)ip->src.uaddr._a16[0l] == 0x80fe)
  {
    signed int return_value_memcmp$1;
    return_value_memcmp$1=memcmp((const void *)(&pc->link6.ip)->uaddr._a8, (const void *)(&ip->dst)->uaddr._a8, (unsigned long int)16);
    if(!(return_value_memcmp$1 == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = th->th_sport != th->th_dport ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return 0;

  }

  else
  {
    signed int return_value_memcmp$3;
    return_value_memcmp$3=memcmp((const void *)(&pc->ip6.ip)->uaddr._a8, (const void *)(&ip->dst)->uaddr._a8, (unsigned long int)16);
    if(!(return_value_memcmp$3 == 0))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = th->th_sport != th->th_dport ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      return 0;

  }
  unsigned short int return_value_ntohs$8;
  signed int return_value_memcmp$7;
  if(!(pc->mscb.sock == 0))
  {
    return_value_ntohs$8=ntohs(th->th_sport);
    if((unsigned int)return_value_ntohs$8 == pc->mscb.sport)
    {
      return_value_memcmp$7=memcmp((const void *)(&pc->mscb.dip6)->uaddr._a8, (const void *)(&ip->src)->uaddr._a8, (unsigned long int)16);
      if(return_value_memcmp$7 == 0)
      {
        if(pc->mscb.proto == (signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_nxt)
        {
          if(!(time_tick + -pc->mscb.timeout >= 61u))
            return 2;

          struct sesscb rcb;
          signed long int return_value_random$5;
          return_value_random$5=random();
          rcb.seq = (unsigned int)return_value_random$5;
          memcpy((void *)rcb.sip6.uaddr._a8, (const void *)ip->src.uaddr._a8, (unsigned long int)16);
          memcpy((void *)rcb.dip6.uaddr._a8, (const void *)ip->dst.uaddr._a8, (unsigned long int)16);
          rcb.sport = (unsigned int)th->th_sport;
          rcb.dport = (unsigned int)th->th_dport;
          rcb.flags = (unsigned char)(0x04 | 0x01 | 0x10);
          signed long int return_value_time$6;
          return_value_time$6=time(((signed long int *)NULL));
          rcb.seq = (unsigned int)return_value_time$6;
          p=tcp6Reply(m, &rcb);
          if(!(p == ((struct packet *)NULL)))
            enq(&pc->oq, p);

          else
            printf("reply error\n");
          return 0;
        }

      }

    }

  }

  i = 0;
  _Bool tmp_if_expr$15;
  signed int return_value_memcmp$10;
  _Bool tmp_if_expr$12;
  signed int return_value_memcmp$11;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  signed int return_value_memcmp$17;
  signed int return_value_memcmp$16;
  for( ; !(i >= 1000); i = i + 1)
    if((signed int)th->th_flags == 0x02)
    {
      if(pc->sesscb[(signed long int)i].timeout == 0u)
        tmp_if_expr$15 = (_Bool)1;

      else
      {
        return_value_memcmp$10=memcmp((const void *)(&pc->sesscb[(signed long int)i].sip6)->uaddr._a8, (const void *)(&ip->src)->uaddr._a8, (unsigned long int)16);
        if(return_value_memcmp$10 == 0)
        {
          return_value_memcmp$11=memcmp((const void *)(&pc->sesscb[(signed long int)i].dip6)->uaddr._a8, (const void *)(&ip->dst)->uaddr._a8, (unsigned long int)16);
          tmp_if_expr$12 = !(return_value_memcmp$11 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$12 = (_Bool)0;
        if(tmp_if_expr$12)
          tmp_if_expr$13 = (unsigned int)th->th_sport == pc->sesscb[(signed long int)i].sport ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$13 = (_Bool)0;
        if(tmp_if_expr$13)
          tmp_if_expr$14 = (unsigned int)th->th_dport == pc->sesscb[(signed long int)i].dport ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$14 = (_Bool)0;
        tmp_if_expr$15 = tmp_if_expr$14 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$15)
      {
        cb = &pc->sesscb[(signed long int)i];
        cb->timeout = time_tick;
        signed long int return_value_random$9;
        return_value_random$9=random();
        cb->seq = (unsigned int)return_value_random$9;
        memcpy((void *)cb->sip6.uaddr._a8, (const void *)ip->src.uaddr._a8, (unsigned long int)16);
        memcpy((void *)cb->dip6.uaddr._a8, (const void *)ip->dst.uaddr._a8, (unsigned long int)16);
        cb->sport = (unsigned int)th->th_sport;
        cb->dport = (unsigned int)th->th_dport;
        break;
      }

    }

    else
      if(!(time_tick + -pc->sesscb[(signed long int)i].timeout >= 61u))
      {
        return_value_memcmp$17=memcmp((const void *)(&pc->sesscb[(signed long int)i].sip6)->uaddr._a8, (const void *)(&ip->src)->uaddr._a8, (unsigned long int)16);
        if(return_value_memcmp$17 == 0)
        {
          return_value_memcmp$16=memcmp((const void *)(&pc->sesscb[(signed long int)i].dip6)->uaddr._a8, (const void *)(&ip->dst)->uaddr._a8, (unsigned long int)16);
          if(return_value_memcmp$16 == 0)
          {
            if((unsigned int)th->th_sport == pc->sesscb[(signed long int)i].sport)
            {
              if((unsigned int)th->th_dport == pc->sesscb[(signed long int)i].dport)
              {
                cb = &pc->sesscb[(signed long int)i];
                break;
              }

            }

          }

        }

      }

  _Bool tmp_if_expr$18;
  if((signed int)th->th_flags == 0x02)
  {
    if(!(cb == ((struct sesscb *)NULL)))
      goto __CPROVER_DUMP_L27;

    printf("VPCS %d out of session\n", pc->id);
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L27:
    ;
    if(!(cb == ((struct sesscb *)NULL)))
    {
      if((signed int)th->th_flags == 0x10)
        tmp_if_expr$18 = (signed int)cb->flags == 0x01 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$18 = (_Bool)0;
      if(tmp_if_expr$18)
        memset((void *)cb, 0, sizeof(struct sesscb) /*160ul*/ );

      else
      {
        cb->timeout = time_tick;
        p=tcp6Reply(m, cb);
        if(!(p == ((struct packet *)NULL)))
          enq(&pc->oq, p);

        if((0x01 & (signed int)cb->rflags) == 0x01)
        {
          if((signed int)cb->flags == 17)
          {
            p=tcp6Reply(m, cb);
            if(!(p == ((struct packet *)NULL)))
              enq(&pc->oq, p);

          }

        }

      }
    }

    return 0;
  }
}

// tcp6Reply
// file tcp.c line 767
struct packet * tcp6Reply(struct packet *m0, struct sesscb *cb)
{
  struct ethdr *eh;
  struct anonymous$18 *ip;
  struct tcphdr *th;
  struct packet *m;
  signed int len;
  signed int tcplen = 0;
  len = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct anonymous$18) /*40ul*/  + sizeof(struct tcphdr) /*20ul*/ );
  m=new_pkt(len);
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    memcpy((void *)m->data, (const void *)m0->data, (unsigned long int)m->len);
    eh = (struct ethdr *)m->data;
    ip = (struct anonymous$18 *)(eh + (signed long int)1);
    th = (struct tcphdr *)(ip + (signed long int)1);
    swap_ehead(m->data);
    swap_ip6head(m);
    ip->ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)64;
    unsigned short int return_value_ntohs$1;
    return_value_ntohs$1=ntohs(ip->ip6_ctlun.ip6_un1.ip6_un1_plen);
    tcplen = (signed int)return_value_ntohs$1;
    ip->ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)sizeof(struct tcphdr) /*20ul*/ );
    signed int rt;
    rt=tcpReplyPacket(th, cb, tcplen);
    if(rt == 0)
    {
      del_pkt(m);
      return (struct packet *)(void *)0;
    }

    else
    {
      th->th_sum = (unsigned short int)0;
      th->th_sum=cksum6(ip, (unsigned char)6, len);
      if(rt == 2)
        cb->flags = (unsigned char)(0x10 | 0x01);

      return m;
    }
  }
}

// tcpReply
// file tcp.c line 594
struct packet * tcpReply(struct packet *m0, struct sesscb *cb)
{
  struct ethdr *eh;
  struct iphdr *ip;
  struct tcpiphdr *ti;
  struct tcphdr *th;
  struct packet *m;
  char b[9l];
  signed int len;
  signed int tcplen = 0;
  len = (signed int)(sizeof(struct ethdr) /*14ul*/  + sizeof(struct iphdr) /*20ul*/  + sizeof(struct tcphdr) /*20ul*/ );
  m=new_pkt(len);
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    memcpy((void *)m->data, (const void *)m0->data, (unsigned long int)m->len);
    eh = (struct ethdr *)m->data;
    ip = (struct iphdr *)(eh + (signed long int)1);
    ti = (struct tcpiphdr *)ip;
    th = (struct tcphdr *)(ip + (signed long int)1);
    unsigned short int return_value_ntohs$1;
    return_value_ntohs$1=ntohs(ip->len);
    tcplen = (signed int)((unsigned long int)return_value_ntohs$1 - sizeof(struct iphdr) /*20ul*/ );
    ip->len=htons((unsigned short int)((unsigned long int)len - sizeof(struct ethdr) /*14ul*/ ));
    ip->dip = ip->dip ^ ip->sip;
    ip->sip = ip->sip ^ ip->dip;
    ip->dip = ip->dip ^ ip->sip;
    ip->ttl = (unsigned char)64;
    signed int rt;
    rt=tcpReplyPacket(th, cb, tcplen);
    if(rt == 0)
    {
      del_pkt(m);
      return (struct packet *)(void *)0;
    }

    else
    {
      ti->ti_i.ih_len=htons((unsigned short int)((unsigned long int)len - sizeof(struct iphdr) /*20ul*/ ));
      bcopy((const void *)((struct ipovly *)ip)->ih_x1, (void *)b, (unsigned long int)9);
      bzero((void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
      ti->ti_t.th_sum = (unsigned short int)0;
      ti->ti_t.th_sum=cksum((unsigned short int *)ti, len);
      bcopy((const void *)b, (void *)((struct ipovly *)ip)->ih_x1, (unsigned long int)9);
      ip->cksum = (unsigned short int)0;
      ip->cksum=cksum((unsigned short int *)ip, (signed int)sizeof(struct iphdr) /*20ul*/ );
      swap_ehead(m->data);
      if(rt == 2)
        cb->flags = (unsigned char)(0x10 | 0x01);

      return m;
    }
  }
}

// tcpReplyPacket
// file tcp.c line 426
signed int tcpReplyPacket(struct tcphdr *th, struct sesscb *cb, signed int tcplen)
{
  signed int clientfinack = 0;
  signed int dsize = 0;
  th->th_sport = th->th_sport ^ th->th_dport;
  th->th_dport = th->th_dport ^ th->th_sport;
  th->th_sport = th->th_sport ^ th->th_dport;
  cb->ack=ntohl(th->th_seq);
  cb->rflags = th->th_flags;
  cb->winsize=ntohs(th->th_win);
  if(!((signed int)cb->flags == 5))
  {
    if(!((signed int)th->th_flags == 0x02))
    {
      if((signed int)th->th_flags == 24)
        goto __CPROVER_DUMP_L2;

      if((signed int)th->th_flags == 17)
        goto __CPROVER_DUMP_L3;

      if((signed int)th->th_flags == 9 || (signed int)th->th_flags == 25)
        goto __CPROVER_DUMP_L4;

      if((signed int)th->th_flags == 0x01)
        goto __CPROVER_DUMP_L5;

    }

    else
    {
      cb->flags = (unsigned char)(0x10 | 0x02);
      cb->ack = cb->ack + 1u;
      goto __CPROVER_DUMP_L10;

    __CPROVER_DUMP_L2:
      ;
      cb->flags = (unsigned char)0x10;
      dsize = tcplen - ((signed int)th->th_off << 2);
      goto __CPROVER_DUMP_L10;

    __CPROVER_DUMP_L3:
      ;
      cb->flags = (unsigned char)(0x10 | 0x01);
      cb->ack = cb->ack + 1u;
      goto __CPROVER_DUMP_L10;

    __CPROVER_DUMP_L4:
      ;
      dsize = tcplen - ((signed int)th->th_off << 2);

    __CPROVER_DUMP_L5:
      ;
      if((signed int)cb->flags == 17)
        cb->flags = (unsigned char)(0x01 | 0x10);

      else
        cb->flags = (unsigned char)0x10;
      if(dsize == 0)
        cb->ack = cb->ack + 1u;

      clientfinack = 1;
      goto __CPROVER_DUMP_L10;
    }
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L10:
    ;
    if(!((signed int)th->th_flags == 0x02))
      cb->seq=ntohl(th->th_ack);

    th->th_ack=htonl(cb->ack + (unsigned int)dsize);
    th->th_seq=htonl(cb->seq);
    th->th_flags = cb->flags;
    if((unsigned long int)((signed int)th->th_off << 2) >= 21ul)
      th->th_off = (unsigned int)(sizeof(struct tcphdr) /*20ul*/  >> 2);

    if(clientfinack == 1)
      return 2;

    else
      return 1;
  }
}

// tcp_ack
// file tcp.c line 62
signed int tcp_ack(signed int ipv)
{
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  struct packet *m = (struct packet *)(void *)0;
  struct packet * (*fpacket)(struct sesscb *);
  if(ipv == 0x60)
    fpacket = packet6;

  else
    fpacket = packet;
  pc->mscb.flags = (unsigned char)0x10;
  m=fpacket(&pc->mscb);
  if(m == ((struct packet *)NULL))
  {
    printf("out of memory\n");
    return 0;
  }

  else
  {
    enq(&pc->oq, m);
    return 1;
  }
}

// tcp_close
// file tcp.h line 33
signed int tcp_close(signed int ipv)
{
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  struct packet *m;
  struct packet *p;
  signed int i = 0;
  signed int ok;
  signed int state = 0;
  signed int rfin = 0;
  struct packet * (*fpacket)(struct sesscb *);
  signed int (*fresponse)(struct packet *, struct sesscb *);
  if(ipv == 0x60)
  {
    fpacket = packet6;
    fresponse = response6;
  }

  else
  {
    fpacket = packet;
    fresponse = response;
  }
  p=deq(&pc->iq);
  if(!(p == ((struct packet *)NULL)))
  {
    ok=fresponse(p, &pc->mscb);
    del_pkt(p);
    if(!(ok == 0))
    {
      if((signed int)pc->mscb.rflags == 24)
      {
        pc->mscb.ack = pc->mscb.rseq + (unsigned int)pc->mscb.rdsize;
        tcp_ack(ipv);
        usleep((unsigned int)(1 * 1000));
      }

      else
      {
        if((signed int)pc->mscb.rflags == 0x10)
        {
          pc->mscb.seq = pc->mscb.rack;
          pc->mscb.ack = pc->mscb.rseq;
        }

        if((17 & (signed int)pc->mscb.rflags) == 17)
        {
          pc->mscb.seq = pc->mscb.rack;
          pc->mscb.ack = pc->mscb.rseq;
          pc->mscb.ack = pc->mscb.ack + 1u;
          tcp_ack(ipv);
          usleep((unsigned int)(1 * 1000));
          rfin = 1;
        }

      }
    }

  }

  signed int tmp_post$1 = i;
  i = i + 1;
  if(!(tmp_post$1 >= 3))
  {
    if(ctrl_c == 0)
    {
      struct timeval tv;
      state = 0;
      pc->mscb.flags = (unsigned char)(0x01 | 0x10 | 0x08);
      m=fpacket(&pc->mscb);
      if(m == ((struct packet *)NULL))
      {
        printf("out of memory\n");
        return 0;
      }

      enq(&pc->oq, m);
      gettimeofday(&tv, (struct timezone *)(void *)0);
      signed int return_value_timeout$2;
      return_value_timeout$2=timeout(tv, (signed int)pc->mscb.waittime);
      if(return_value_timeout$2 == 0)
      {
        if(ctrl_c == 0)
        {
          usleep((unsigned int)(1 * 1000));
          p=deq(&pc->iq);
          if(!(p == ((struct packet *)NULL)))
          {
            ok=fresponse(p, &pc->mscb);
            del_pkt(p);
            if(!(ok == 0))
            {
              if((17 & (signed int)pc->mscb.rflags) == 17)
                state = 1;

              else
                if((signed int)pc->mscb.rflags == 0x10)
                  state = 2;

              tv.tv_sec = (signed long int)0;
            }

          }

        }

      }

      if(!(state == 0))
      {
        if(rfin == 1 && state == 2)
          return 1;

        if(state == 2)
        {
          struct timeval tcp_close$$1$$4$$3$$tv;
          state = 0;
          gettimeofday(&tcp_close$$1$$4$$3$$tv, (struct timezone *)(void *)0);
          signed int return_value_timeout$3;
          return_value_timeout$3=timeout(tcp_close$$1$$4$$3$$tv, (signed int)pc->mscb.waittime);
          if(return_value_timeout$3 == 0)
          {
            if(ctrl_c == 0)
            {
              usleep((unsigned int)(1 * 1000));
              p=deq(&pc->iq);
              if(!(p == ((struct packet *)NULL)))
              {
                ok=fresponse(p, &pc->mscb);
                del_pkt(p);
                if(!(ok == 0))
                {
                  if((0x01 & (signed int)pc->mscb.rflags) == 0x01)
                  {
                    pc->mscb.seq = pc->mscb.rack;
                    state = 1;
                  }

                  tcp_close$$1$$4$$3$$tv.tv_sec = (signed long int)0;
                }

              }

            }

          }

        }

        if(state == 0)
          return 0;

        pc->mscb.ack = pc->mscb.ack + 1u;
        tcp_ack(ipv);
        return 1;
      }

    }

  }

  return 0;
}

// tcp_open
// file tcp.h line 31
signed int tcp_open(signed int ipv)
{
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  struct packet *m;
  struct packet *p;
  signed int i = 0;
  signed int ok;
  signed int state = 0;
  struct packet * (*fpacket)(struct sesscb *);
  signed int (*fresponse)(struct packet *, struct sesscb *);
  if(ipv == 0x60)
  {
    fpacket = packet6;
    fresponse = response6;
  }

  else
  {
    fpacket = packet;
    fresponse = response;
  }
  signed int tmp_post$1 = i;
  i = i + 1;
  signed int return_value_timeout$4;
  _Bool tmp_if_expr$5;
  if(!(tmp_post$1 >= 3))
  {
    if(ctrl_c == 0)
    {
      struct timeval tv;
      pc->mscb.flags = (unsigned char)0x02;
      pc->mscb.timeout = time_tick;
      signed int return_value_rand$2;
      return_value_rand$2=rand();
      pc->mscb.seq = (unsigned int)return_value_rand$2;
      pc->mscb.ack = (unsigned int)0;
      m=fpacket(&pc->mscb);
      if(m == ((struct packet *)NULL))
      {
        printf("out of memory\n");
        return 0;
      }

      enq(&pc->oq, m);
      ok = 0;
      gettimeofday(&tv, (struct timezone *)(void *)0);
      signed int return_value_timeout$3;
      return_value_timeout$3=timeout(tv, (signed int)pc->mscb.waittime);
      if(return_value_timeout$3 == 0)
      {
        if(ctrl_c == 0)
        {
          usleep((unsigned int)(1 * 1000));
          p=deq(&pc->iq);
          if(!(p == ((struct packet *)NULL)))
          {
            return_value_timeout$4=timeout(tv, (signed int)pc->mscb.waittime);
            if(return_value_timeout$4 == 0)
            {
              if(ctrl_c == 0)
              {
                ok=fresponse(p, &pc->mscb);
                del_pkt(p);
                if(!(ok == 0))
                {
                  if(ok == 1)
                    return 2;

                  else
                  {
                    if(pc->mscb.rack == 1u + pc->mscb.seq)
                      tmp_if_expr$5 = (signed int)pc->mscb.rflags == (0x02 | 0x10) ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$5 = (_Bool)0;
                    if(tmp_if_expr$5)
                      state = 1;

                    else
                      if(!((0x04 & (signed int)pc->mscb.rflags) == 0x04))
                      {
                        pc->mscb.flags = (unsigned char)(0x04 | 0x10);
                        pc->mscb.seq = pc->mscb.rack;
                        pc->mscb.ack = pc->mscb.rseq;
                        m=fpacket(&pc->mscb);
                        if(m == ((struct packet *)NULL))
                        {
                          printf("out of memory\n");
                          return 0;
                        }

                        enq(&pc->oq, m);
                        usleep((unsigned int)(1 * 1000));
                      }

                      else
                        if((0x04 & (signed int)pc->mscb.rflags) == 0x04)
                          return 3;

                  }
                  tv.tv_sec = (signed long int)0;
                }

              }

            }

          }

        }

      }

      if(state == 1)
      {
        pc->mscb.seq = pc->mscb.rack;
        pc->mscb.ack = pc->mscb.rseq + (unsigned int)1;
        tcp_ack(ipv);
        return 1;
      }

    }

  }

  return 0;
}

// tcp_send
// file tcp.h line 32
signed int tcp_send(signed int ipv)
{
  struct anonymous$0 *pc = &vpc[(signed long int)pcid];
  struct packet *m;
  struct packet *p;
  signed int i = 0;
  signed int ok;
  signed int state = 0;
  struct packet * (*fpacket)(struct sesscb *);
  signed int (*fresponse)(struct packet *, struct sesscb *);
  if(ipv == 0x60)
  {
    fpacket = packet6;
    fresponse = response6;
  }

  else
  {
    fpacket = packet;
    fresponse = response;
  }
  p=deq(&pc->iq);
  if(!(p == ((struct packet *)NULL)))
  {
    ok=fresponse(p, &pc->mscb);
    del_pkt(p);
    if(!(ok == 0))
    {
      if((signed int)pc->mscb.rflags == 24)
      {
        if(pc->mscb.seq == pc->mscb.rack)
        {
          pc->mscb.ack = pc->mscb.rseq + (unsigned int)pc->mscb.rdsize;
          tcp_ack(ipv);
          usleep((unsigned int)(1 * 1000));
        }

      }

    }

  }

  signed int tmp_post$1 = i;
  i = i + 1;
  if(!(tmp_post$1 >= 3))
  {
    if(ctrl_c == 0)
    {
      struct timeval tv;
      pc->mscb.flags = (unsigned char)(0x10 | 0x08);
      m=fpacket(&pc->mscb);
      if(m == ((struct packet *)NULL))
      {
        printf("out of memory\n");
        return 0;
      }

      enq(&pc->oq, m);
      ok = 0;
      gettimeofday(&tv, (struct timezone *)(void *)0);
      signed int return_value_timeout$2;
      return_value_timeout$2=timeout(tv, (signed int)pc->mscb.waittime);
      if(return_value_timeout$2 == 0)
      {
        if(ctrl_c == 0)
        {
          usleep((unsigned int)(1 * 1000));
          p=deq(&pc->iq);
          if(!(p == ((struct packet *)NULL)))
          {
            ok=fresponse(p, &pc->mscb);
            del_pkt(p);
            if(!(ok == 0))
            {
              if((signed int)pc->mscb.rflags == 0x10)
              {
                if(pc->mscb.rack == pc->mscb.seq + (unsigned int)pc->mscb.dsize)
                {
                  pc->mscb.seq = pc->mscb.rack;
                  pc->mscb.ack = pc->mscb.rseq;
                  state = 1;
                  return 1;
                }

              }

              if((signed int)pc->mscb.rflags == 24)
              {
                unsigned int tseq = pc->mscb.seq;
                pc->mscb.seq = pc->mscb.rack;
                pc->mscb.ack = pc->mscb.rseq + (unsigned int)pc->mscb.rdsize;
                tcp_ack(ipv);
                if(pc->mscb.seq == tseq + (unsigned int)pc->mscb.dsize)
                  return 1;

                else
                  usleep((unsigned int)(1 * 1000));
              }

              if((signed int)pc->mscb.rflags == 25)
              {
                pc->mscb.seq = pc->mscb.rack;
                pc->mscb.ack = pc->mscb.rseq + (unsigned int)pc->mscb.rdsize;
                state = 1;
                return 2;
              }

              tv.tv_sec = (signed long int)0;
            }

          }

        }

      }

      if(state == 1)
        return 1;

    }

  }

  return 0;
}

// timeout
// file utils.h line 36
signed int timeout(struct timeval tv, signed int mseconds)
{
  struct timeval tvx;
  unsigned int usec;
  gettimeofday(&tvx, (struct timezone *)(void *)0);
  usec = (unsigned int)(((tvx.tv_sec - tv.tv_sec) * (signed long int)1000000 + tvx.tv_usec) - tv.tv_usec);
  return (signed int)(usec / (unsigned int)1000 >= (unsigned int)mseconds);
}

// trimspace
// file readline.c line 504
static void trimspace(char *buf)
{
  char *p;
  char *q;
  p = buf;
  char *tmp_post$2;
  char *tmp_post$3;
  if(!(p == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(p);
    q = p + (signed long int)return_value_strlen$1;
    for( ; !(p >= q); q = q - 1l)
      if(!((signed int)*q == 32))
        break;

    q[(signed long int)1] = (char)0;
    for( ; (signed int)*p == 32; p = p + 1l)
      ;
    q = p;
    for( ; !((signed int)*q == 0); *tmp_post$2 = *tmp_post$3)
    {
      tmp_post$2 = p;
      p = p + 1l;
      tmp_post$3 = q;
      q = q + 1l;
    }
    *p = (char)0;
  }

}

// ttrim
// file utils.h line 39
char * ttrim(char *s)
{
  signed int len;
  signed int c;
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(s);
    len = (signed int)return_value_strlen$1;
    len = len - 1;
    while(len >= 0)
    {
      c = (signed int)s[(signed long int)len];
      const unsigned short int **return_value___ctype_b_loc$2;
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)c]) == 0)
        break;

      len = len - 1;
    }
    s[(signed long int)(len + 1)] = (char)0;
    return s;
  }
}

// udp6Reply
// file packets6.c line 581
static struct packet * udp6Reply(struct packet *m0)
{
  struct ethdr *eh;
  struct anonymous$18 *ip;
  struct anonymous$24 *ui;
  struct packet *m;
  m=new_pkt(m0->len);
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    m->len = m0->len;
    memcpy((void *)m->data, (const void *)m0->data, (unsigned long int)m0->len);
    m->ts = m0->ts;
    eh = (struct ethdr *)m->data;
    ip = (struct anonymous$18 *)(eh + (signed long int)1);
    ui = (struct anonymous$24 *)(ip + (signed long int)1);
    swap_ehead(m->data);
    swap_ip6head(m);
    ip->ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)64;
    ui->sport = ui->sport ^ ui->dport;
    ui->dport = ui->dport ^ ui->sport;
    ui->sport = ui->sport ^ ui->dport;
    ui->cksum = (unsigned short int)0;
    unsigned short int return_value_ntohs$1;
    return_value_ntohs$1=ntohs(ui->len);
    ui->cksum=cksum6(ip, (unsigned char)17, (signed int)return_value_ntohs$1);
    return m;
  }
}

// udpReply
// file packets.c line 519
static struct packet * udpReply(struct packet *m0)
{
  struct ethdr *eh;
  struct iphdr *ip;
  struct udpiphdr *ui;
  struct packet *m;
  m=new_pkt(m0->len);
  if(m == ((struct packet *)NULL))
    return (struct packet *)(void *)0;

  else
  {
    m->len = m0->len;
    memcpy((void *)m->data, (const void *)m0->data, (unsigned long int)m0->len);
    m->ts = m0->ts;
    eh = (struct ethdr *)m->data;
    ip = (struct iphdr *)(eh + (signed long int)1);
    ui = (struct udpiphdr *)ip;
    ip->dip = ip->dip ^ ip->sip;
    ip->sip = ip->sip ^ ip->dip;
    ip->dip = ip->dip ^ ip->sip;
    ui->ui_u.sport = ui->ui_u.sport ^ ui->ui_u.dport;
    ui->ui_u.dport = ui->ui_u.dport ^ ui->ui_u.sport;
    ui->ui_u.sport = ui->ui_u.sport ^ ui->ui_u.dport;
    ip->cksum=cksum_fixup(ip->cksum, (unsigned short int)ip->ttl, (unsigned short int)64, (unsigned short int)0);
    ip->ttl = (unsigned char)64;
    swap_ehead(m->data);
    return m;
  }
}

// ulock_q
// file queue.c line 125
void ulock_q(struct pq *pq)
{
  pthread_mutex_unlock(&pq->locker);
}

// upv4
// file packets.h line 34
signed int upv4(struct anonymous$0 *pc, struct packet *m)
{
  struct ethdr *eh = (struct ethdr *)m->data;
  unsigned int *si;
  unsigned int *di;
  unsigned short int return_value_htons$2;
  return_value_htons$2=htons((unsigned short int)0x86DD);
  signed int return_value_upv6$1;
  unsigned short int return_value_htons$3;
  _Bool tmp_if_expr$19;
  unsigned short int return_value_htons$18;
  unsigned short int return_value_htons$6;
  unsigned short int return_value_htons$16;
  _Bool tmp_if_expr$14;
  unsigned short int return_value_htons$12;
  signed int return_value_sameNet$11;
  signed int return_value_strncmp$15;
  if(eh->type == return_value_htons$2)
  {
    return_value_upv6$1=upv6(pc, m);
    return return_value_upv6$1;
  }

  else
  {
    unsigned short int return_value_htons$4;
    return_value_htons$4=htons((unsigned short int)0x0800);
    if(!(eh->type == return_value_htons$4))
    {
      return_value_htons$3=htons((unsigned short int)0x0806);
      if(eh->type == return_value_htons$3)
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed int return_value_etherIsMulticast$5;
      return_value_etherIsMulticast$5=etherIsMulticast(eh->src);
      if(!(return_value_etherIsMulticast$5 == 0))
        return 0;

      else
      {
        signed int return_value_memcmp$17;
        return_value_memcmp$17=memcmp((const void *)eh->dst, (const void *)pc->ip4.mac, (unsigned long int)6);
        if(return_value_memcmp$17 == 0)
        {
          return_value_htons$18=htons((unsigned short int)0x0800);
          tmp_if_expr$19 = ((unsigned short int *)m->data)[(signed long int)6] == return_value_htons$18 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$19 = (_Bool)0;
        if(tmp_if_expr$19)
        {
          struct iphdr *ip = (struct iphdr *)(eh + (signed long int)1);
          if((signed int)ip->proto == 1)
          {
            struct icmphdr *icmp = (struct icmphdr *)(ip + (signed long int)1);
            if((signed int)icmp->type == 8)
            {
              struct packet *upv4$$1$$1$$1$$1$$p;
              upv4$$1$$1$$1$$1$$p=icmpReply(m, (char)0);
              if(!(upv4$$1$$1$$1$$1$$p == ((struct packet *)NULL)))
                enq(&pc->oq, upv4$$1$$1$$1$$1$$p);

              return 1;
            }

          }

          else
            if((signed int)ip->proto == 17)
            {
              struct udpiphdr *ui;
              char *data = (char *)(void *)0;
              ui = (struct udpiphdr *)ip;
              if((0xf0000000 & ip->dip) == 0xe0000000)
                return 0;

              unsigned short int return_value_htons$7;
              return_value_htons$7=htons((unsigned short int)67);
              if(ui->ui_u.sport == return_value_htons$7)
              {
                return_value_htons$6=htons((unsigned short int)68);
                if(ui->ui_u.dport == return_value_htons$6)
                  return 2;

              }

              unsigned short int return_value_htons$8;
              return_value_htons$8=htons((unsigned short int)53);
              if(ui->ui_u.sport == return_value_htons$8)
                return 2;

              data = (char *)(ui + (signed long int)1);
              signed int return_value_memcmp$9;
              return_value_memcmp$9=memcmp((const void *)data, (const void *)eh->dst, (unsigned long int)6);
              if(return_value_memcmp$9 == 0)
                return 2;

              else
              {
                struct packet *p;
                if((signed int)ip->ttl == 1)
                  p=icmpReply(m, (char)3);

                else
                  p=udpReply(m);
                if(!(p == ((struct packet *)NULL)))
                  enq(&pc->oq, p);

              }
              return 0;
            }

            else
              if((signed int)ip->proto == 6)
              {
                signed int return_value_tcp$10;
                return_value_tcp$10=tcp(pc, m);
                return return_value_tcp$10;
              }

        }

        else
        {
          return_value_htons$16=htons((unsigned short int)0x0806);
          if(eh->type == return_value_htons$16)
          {
            struct arphdr *ah = (struct arphdr *)(eh + (signed long int)1);
            si = (unsigned int *)ah->sip;
            di = (unsigned int *)ah->dip;
            unsigned short int return_value_htons$13;
            return_value_htons$13=htons((unsigned short int)1);
            if(ah->op == return_value_htons$13)
              tmp_if_expr$14 = di[(signed long int)0] == pc->ip4.ip ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$14 = (_Bool)0;
            if(tmp_if_expr$14)
            {
              save_eaddr(pc, si[(signed long int)0], ah->sea);
              ah->op=htons((unsigned short int)2);
              memcpy((void *)ah->dea, (const void *)ah->sea, (unsigned long int)6);
              memcpy((void *)ah->sea, (const void *)pc->ip4.mac, (unsigned long int)6);
              di[(signed long int)0] = si[(signed long int)0];
              si[(signed long int)0] = pc->ip4.ip;
              encap_ehead(m->data, pc->ip4.mac, eh->src, (const unsigned short int)0x0806);
              enq(&pc->oq, m);
              return 1;
            }

            else
            {
              return_value_htons$12=htons((unsigned short int)2);
              if(ah->op == return_value_htons$12)
              {
                return_value_sameNet$11=sameNet((unsigned long int)di[(signed long int)0], (unsigned long int)pc->ip4.ip, pc->ip4.cidr);
                if(!(return_value_sameNet$11 == 0))
                  save_eaddr(pc, si[(signed long int)0], ah->sea);

              }

            }
            return 0;
          }

          else
          {
            return_value_strncmp$15=strncmp((const char *)eh->dst, (const char *)pc->ip4.mac, (unsigned long int)6);
            if(!(return_value_strncmp$15 == 0))
              return 0;

          }
        }
        return 2;
      }
    }
  }
}

// upv6
// file packets6.c line 62
signed int upv6(struct anonymous$0 *pc, struct packet *m)
{
  struct ethdr *eh;
  struct anonymous$18 *ip;
  struct anonymous$20 *icmp;
  struct anonymous$11 *tip6 = (struct anonymous$11 *)(void *)0;
  unsigned int mtu = (unsigned int)0;
  eh = (struct ethdr *)m->data;
  signed int return_value_etherIsMulticast$1;
  return_value_etherIsMulticast$1=etherIsMulticast(eh->src);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  signed int tmp_if_expr$19;
  _Bool tmp_if_expr$21;
  if(!(return_value_etherIsMulticast$1 == 0))
    return 0;

  else
  {
    unsigned short int return_value_htons$2;
    return_value_htons$2=htons((unsigned short int)0x86DD);
    if(!(eh->type == return_value_htons$2))
      return 0;

    else
    {
      ip = (struct anonymous$18 *)(eh + (signed long int)1);
      if(!((0xf0 & (signed int)ip->ip6_ctlun.ip6_un2_vfc) == 0x60))
        return 0;

      else
        if((signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58)
        {
          icmp = (struct anonymous$20 *)(ip + (signed long int)1);
          if((signed int)icmp->type == 135)
          {
            struct anonymous$21 *nshdr;
            struct anonymous$22 *nsopt;
            nshdr = (struct anonymous$21 *)(ip + (signed long int)1);
            nsopt = (struct anonymous$22 *)(nshdr + (signed long int)1);
            if(!((signed int)eh->dst[0l] == 0x33))
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = (signed int)eh->dst[(signed long int)1] != 0x33 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
              tmp_if_expr$4 = (_Bool)1;

            else
              tmp_if_expr$4 = (signed int)eh->dst[(signed long int)2] != 0xff ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$4)
              tmp_if_expr$5 = (_Bool)1;

            else
              tmp_if_expr$5 = (signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_hlim != 255 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$5)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = (signed int)ip->dst.uaddr._a16[(signed long int)0] != 0x02ff ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$6)
              tmp_if_expr$7 = (_Bool)1;

            else
              tmp_if_expr$7 = ip->dst.uaddr._a32[(signed long int)1] != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$7)
              tmp_if_expr$8 = (_Bool)1;

            else
              tmp_if_expr$8 = ip->dst.uaddr._a32[(signed long int)2] != (unsigned int)0x01000000 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$8)
              tmp_if_expr$9 = (_Bool)1;

            else
              tmp_if_expr$9 = (signed int)ip->dst.uaddr._a8[(signed long int)12] != 0xff ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$9)
              return 0;

            if(!(eh->dst[3l] == pc->ip6.ip.uaddr._a8[13l]))
              tmp_if_expr$13 = (_Bool)1;

            else
              tmp_if_expr$13 = eh->dst[(signed long int)4] != pc->ip6.ip.uaddr._a8[(signed long int)14] ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$13)
              tmp_if_expr$14 = (_Bool)1;

            else
              tmp_if_expr$14 = eh->dst[(signed long int)5] != pc->ip6.ip.uaddr._a8[(signed long int)15] ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$14)
              tmp_if_expr$15 = (_Bool)1;

            else
              tmp_if_expr$15 = ip->dst.uaddr._a32[(signed long int)3] != (pc->ip6.ip.uaddr._a32[(signed long int)3] | (unsigned int)0xff) ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$15)
            {
              if(!(eh->dst[3l] == pc->link6.ip.uaddr._a8[13l]))
                tmp_if_expr$10 = (_Bool)1;

              else
                tmp_if_expr$10 = eh->dst[(signed long int)4] != pc->link6.ip.uaddr._a8[(signed long int)14] ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$10)
                tmp_if_expr$11 = (_Bool)1;

              else
                tmp_if_expr$11 = eh->dst[(signed long int)5] != pc->link6.ip.uaddr._a8[(signed long int)15] ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$11)
                tmp_if_expr$12 = (_Bool)1;

              else
                tmp_if_expr$12 = ip->dst.uaddr._a32[(signed long int)3] != (pc->link6.ip.uaddr._a32[(signed long int)3] | (unsigned int)0xff) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$12)
                return 0;

              else
                tip6 = &pc->link6.ip;
            }

            else
              tip6 = &pc->ip6.ip;
            memcpy((void *)ip->dst.uaddr._a8, (const void *)ip->src.uaddr._a8, (unsigned long int)16);
            memcpy((void *)ip->src.uaddr._a8, (const void *)tip6->uaddr._a8, (unsigned long int)16);
            nshdr->hdr.type = (unsigned char)136;
            nshdr->hdr.code = (unsigned char)0;
            nshdr->hdr.icmp6_dataun.icmp6_un_data32[(signed long int)0] = (unsigned int)(0x40 | 0x20);
            nsopt->type = (unsigned char)2;
            memcpy((void *)nsopt->mac, (const void *)pc->ip4.mac, (unsigned long int)6);
            nshdr->hdr.cksum = (unsigned short int)0;
            unsigned short int return_value_ntohs$16;
            return_value_ntohs$16=ntohs(ip->ip6_ctlun.ip6_un1.ip6_un1_plen);
            nshdr->hdr.cksum=cksum6(ip, (unsigned char)58, (signed int)return_value_ntohs$16);
            memcpy((void *)eh->dst, (const void *)eh->src, (unsigned long int)6);
            memcpy((void *)eh->src, (const void *)pc->ip4.mac, (unsigned long int)6);
            enq(&pc->oq, m);
            return 1;
          }

          if((signed int)icmp->type == 128)
          {
            swap_ip6head(m);
            icmp = (struct anonymous$20 *)(ip + (signed long int)1);
            icmp->type = (unsigned char)129;
            icmp->cksum=cksum_fixup(icmp->cksum, (unsigned short int)128, (unsigned short int)129, (unsigned short int)0);
            swap_ehead(m->data);
            enq(&pc->oq, m);
            return 1;
          }

          if((signed int)icmp->type == 134)
          {
            char *p = (char *)(void *)0;
            char *mac = (char *)(void *)0;
            struct anonymous$23 *ndr = (struct anonymous$23 *)(ip + (signed long int)1);
            if(!((signed int)ip->src.uaddr._a8[0l] == 0xfe))
              tmp_if_expr$17 = (_Bool)1;

            else
              tmp_if_expr$17 = (signed int)ip->src.uaddr._a8[(signed long int)1] != 0x80 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$17)
              tmp_if_expr$18 = (_Bool)1;

            else
              tmp_if_expr$18 = (signed int)icmp->icmp6_dataun.icmp6_un_data8[(signed long int)0] != 0x40 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$18)
              return 0;

            p = (char *)(ndr + (signed long int)1);
            if((signed int)*p == 1)
            {
              if((signed int)p[1l] == 1)
              {
                mac = p + (signed long int)2;
                p = p + (signed long int)8;
              }

            }

            if((signed int)*p == 5)
            {
              if((signed int)p[1l] == 1)
              {
                mtu=ntohl(*((unsigned int *)(p + (signed long int)4)));
                p = p + (signed long int)8;
              }

            }

            if((signed int)*p == 3)
            {
              if((signed int)p[1l] == 4)
              {
                signed int cidr = (signed int)p[(signed long int)2];
                if(pc->ip6.cidr == 0)
                {
                  memcpy((void *)pc->ip6.ip.uaddr._a8, (const void *)(p + (signed long int)16), (unsigned long int)16);
                  pc->ip6.cidr = cidr;
                  pc->ip6.ip.uaddr._a8[(signed long int)15] = pc->ip4.mac[(signed long int)5];
                  pc->ip6.ip.uaddr._a8[(signed long int)14] = pc->ip4.mac[(signed long int)4];
                  pc->ip6.ip.uaddr._a8[(signed long int)13] = pc->ip4.mac[(signed long int)3];
                  pc->ip6.ip.uaddr._a8[(signed long int)12] = (unsigned char)0xfe;
                  pc->ip6.ip.uaddr._a8[(signed long int)11] = (unsigned char)0xff;
                  pc->ip6.ip.uaddr._a8[(signed long int)10] = pc->ip4.mac[(signed long int)2];
                  pc->ip6.ip.uaddr._a8[(signed long int)9] = pc->ip4.mac[(signed long int)1];
                  if(!((0x20 & (signed int)pc->ip4.mac[0l]) == 0))
                    tmp_if_expr$19 = (signed int)pc->ip4.mac[(signed long int)0] & 0xef;

                  else
                    tmp_if_expr$19 = (signed int)pc->ip4.mac[(signed long int)0] | 0x20;
                  pc->ip6.ip.uaddr._a8[(signed long int)8] = (unsigned char)tmp_if_expr$19;
                  pc->ip6.type = 1;
                  if(!(mtu == 0u))
                    pc->ip6.mtu = (signed int)mtu;

                  mtu = (unsigned int)0;
                }

                signed int return_value_sameNet6$20;
                return_value_sameNet6$20=sameNet6((char *)pc->ip6.ip.uaddr._a8, p + (signed long int)16, pc->ip6.cidr);
                if(!(return_value_sameNet6$20 == 0))
                  memcpy((void *)pc->ip6.gmac, (const void *)mac, (unsigned long int)6);

              }

            }

            return 0;
          }

          if((signed int)icmp->type == 136)
            return 2;

          if((signed int)icmp->type == 129)
            return 2;

          if((signed int)icmp->type == 3)
            tmp_if_expr$21 = (_Bool)1;

          else
            tmp_if_expr$21 = (signed int)icmp->type == 1 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$21)
            goto __CPROVER_DUMP_L55;

          return 2;
        }

        else
        {

        __CPROVER_DUMP_L55:
          ;
          if((signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_nxt == 17)
          {
            struct anonymous$24 *ui = (struct anonymous$24 *)(ip + (signed long int)1);
            if((signed int)ip->dst.uaddr._a8[0l] == 0xff)
              return 0;

            char *data = (char *)(ui + (signed long int)1);
            signed int return_value_memcmp$22;
            return_value_memcmp$22=memcmp((const void *)data, (const void *)eh->dst, (unsigned long int)6);
            if(return_value_memcmp$22 == 0)
              return 2;

            else
            {
              struct packet *upv6$$1$$2$$1$$p;
              if((signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_hlim == 1)
                upv6$$1$$2$$1$$p=icmp6Reply(m);

              else
                upv6$$1$$2$$1$$p=udp6Reply(m);
              if(!(upv6$$1$$2$$1$$p == ((struct packet *)NULL)))
                enq(&pc->oq, upv6$$1$$2$$1$$p);

            }
            return 0;
          }

          else
            if((signed int)ip->ip6_ctlun.ip6_un1.ip6_un1_nxt == 6)
            {
              signed int return_value_tcp6$23;
              return_value_tcp6$23=tcp6(pc, m);
              return return_value_tcp6$23;
            }

            else
              return 0;
          return 2;
        }
    }
  }
}

// usage
// file vpcs.c line 617
void usage()
{
  run_ver(0, (char **)(void *)0);
  printf("\r\nusage: vpcs [options] [scriptfile]\r\nOption:\r\n    -h         print this help then exit\r\n    -v         print version information then exit\r\n\r\n    -i num     number of vpc instances to start (default is 9)\r\n    -p port    run as a daemon listening on the tcp 'port'\r\n    -m num     start byte of ether address, default from 0\r\n    -r file    load and execute script file\r\n               compatible with older versions, DEPRECATED.\r\n\r\n    -e         tap mode, using /dev/tapx by default (linux only)\r\n    -u         udp mode, default\r\n\r\nudp mode options:\r\n    -s port    local udp base port, default from 20000\r\n    -c port    remote udp base port (dynamips udp port), default from 30000\r\n    -t ip      remote host IP, default 127.0.0.1\r\n\r\ntap mode options:\r\n    -d device  device name, works only when -i is set to 1\r\n\r\nhypervisor mode option:\r\n    -H port    run as the hypervisor listening on the tcp 'port'\r\n\r\n  If no 'scriptfile' specified, vpcs will read and execute the file named\r\n  'startup.vpc' if it exsits in the current directory.\r\n\r\n");
}

// vinet_ntop6
// file inet6.h line 44
const char * vinet_ntop6(signed int af, const void * restrict src, char * restrict dst, unsigned int size)
{
  const char *return_value_vinet_ntop6w$1;
  if(af == 10)
  {
    return_value_vinet_ntop6w$1=vinet_ntop6w((const unsigned char *)src, dst, size);
    return return_value_vinet_ntop6w$1;
  }

  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = 97;
  return (const char *)(void *)0;
}

// vinet_ntop6w
// file inet6.c line 68
static const char * vinet_ntop6w(const unsigned char *src, char *dst, unsigned int size)
{
  char tmp[(signed long int)sizeof(char [46l]) /*46l*/ ];
  char *tp;
  /* tag-#anon#lST[S32'base'||S32'len'|] */
struct anonymous$30
{
  // base
  signed int base;
  // len
  signed int len;
};

/* */
  ;
  struct anonymous$30 best;
  struct anonymous$30 cur;
  unsigned int words[8l];
  signed int i;
  memset((void *)words, 0, sizeof(unsigned int [8l]) /*32ul*/ );
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    words[(signed long int)(i / 2)] = words[(signed long int)(i / 2)] | (unsigned int)((signed int)src[(signed long int)i] << (1 - i % 2 << 3));
  best.base = -1;
  best.len = 0;
  cur.base = -1;
  cur.len = 0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    if(words[(signed long int)i] == 0u)
    {
      if(cur.base == -1)
      {
        cur.base = i;
        cur.len = 1;
      }

      else
        cur.len = cur.len + 1;
    }

    else
      if(!(cur.base == -1))
      {
        if(best.base == -1 || !(best.len >= cur.len))
          best = cur;

        cur.base = -1;
      }

  if(!(cur.base == -1))
  {
    if(best.base == -1 || !(best.len >= cur.len))
      best = cur;

  }

  if(!(best.base == -1) && !(best.len >= 2))
    best.base = -1;

  tp = tmp;
  i = 0;
  char *tmp_post$1;
  char *tmp_post$2;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  for( ; !(i >= 8); i = i + 1)
    if(i >= best.base && !(best.base == -1) && !(i >= best.base + best.len))
    {
      if(i == best.base)
      {
        tmp_post$1 = tp;
        tp = tp + 1l;
        *tmp_post$1 = (char)58;
      }

    }

    else
    {
      if(!(i == 0))
      {
        tmp_post$2 = tp;
        tp = tp + 1l;
        *tmp_post$2 = (char)58;
      }

      if(best.base == 0 && i == 6)
      {
        if(best.len == 6)
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          if(best.len == 7)
            tmp_if_expr$5 = words[(signed long int)7] != (unsigned int)0x0001 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          if(best.len == 5)
            tmp_if_expr$7 = words[(signed long int)5] == (unsigned int)0xffff ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          const char *return_value_inet_ntop4w$3;
          return_value_inet_ntop4w$3=inet_ntop4w(src + (signed long int)12, tp, (unsigned int)(sizeof(char [46l]) /*46ul*/  - (unsigned long int)(tp - tmp)));
          if(return_value_inet_ntop4w$3 == ((const char *)NULL))
            return (const char *)(void *)0;

          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(tp);
          tp = tp + (signed long int)return_value_strlen$4;
          break;
        }

      }

      signed int return_value_sprintf$9;
      return_value_sprintf$9=sprintf(tp, "%x", words[(signed long int)i]);
      tp = tp + (signed long int)return_value_sprintf$9;
    }
  char *tmp_post$10;
  if(best.base + best.len == 8 && !(best.base == -1))
  {
    tmp_post$10 = tp;
    tp = tp + 1l;
    *tmp_post$10 = (char)58;
  }

  char *tmp_post$11 = tp;
  tp = tp + 1l;
  *tmp_post$11 = (char)0;
  if(!(size >= (unsigned int)(tp - tmp)))
  {
    signed int *return_value___errno_location$12;
    return_value___errno_location$12=__errno_location();
    *return_value___errno_location$12 = 28;
    return (const char *)(void *)0;
  }

  strcpy(dst, tmp);
  return dst;
}

// vinet_pton6
// file inet6.h line 43
signed int vinet_pton6(signed int af, const char * restrict src, void * restrict dst)
{
  signed int return_value_vinet_pton6w$1;
  if(af == 10)
  {
    return_value_vinet_pton6w$1=vinet_pton6w(src, (unsigned char *)dst);
    return return_value_vinet_pton6w$1;
  }

  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = 97;
  return -1;
}

// vinet_pton6w
// file inet6.c line 160
static signed int vinet_pton6w(const char *src, unsigned char *dst)
{
  unsigned char tmp[16l];
  unsigned char *tp;
  unsigned char *endp;
  unsigned char *colonp;
  const char *xdigits;
  const char *curtok;
  signed int ch;
  signed int seen_xdigits;
  unsigned int val;
  tp = tmp;
  memset((void *)tp, 0, (unsigned long int)16);
  endp = tp + (signed long int)16;
  colonp = (unsigned char *)(void *)0;
  const char *tmp_post$1;
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  signed int return_value_inet_pton$4;
  unsigned char *tmp_post$5;
  unsigned char *tmp_post$6;
  if((signed int)*src == 58)
  {
    src = src + 1l;
    if((signed int)*src == 58)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    curtok = src;
    seen_xdigits = 0;
    val = (unsigned int)0;
    do
    {
      tmp_post$1 = src;
      src = src + 1l;
      ch = (signed int)*tmp_post$1;
      if(ch == 0)
        break;

      const char *pch;
      static const char xdigits_l[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
      xdigits = xdigits_l;
      pch=strchr(xdigits, ch);
      if(pch == ((const char *)NULL))
      {
        static const char xdigits_u[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 0 };
        xdigits = xdigits_u;
        pch=strchr(xdigits, ch);
      }

      if(!(pch == ((const char *)NULL)))
      {
        val = val << 4;
        val = val | (unsigned int)(pch - xdigits);
        seen_xdigits = seen_xdigits + 1;
        if(seen_xdigits >= 5)
          return 0;

      }

      else
        if(ch == 58)
        {
          curtok = src;
          if(seen_xdigits == 0)
          {
            if(!(colonp == ((unsigned char *)NULL)))
              return 0;

            colonp = tp;
            continue;
          }

          else
            if((signed int)*src == 0)
              return 0;

          if(!(endp >= tp + 2l))
            return 0;

          tmp_post$2 = tp;
          tp = tp + 1l;
          *tmp_post$2 = (unsigned char)((signed int)(unsigned char)(val >> 8) & 0xff);
          tmp_post$3 = tp;
          tp = tp + 1l;
          *tmp_post$3 = (unsigned char)((signed int)(unsigned char)val & 0xff);
          seen_xdigits = 0;
          val = (unsigned int)0;
        }

        else
        {
          if(ch == 46 && endp >= tp + 4l)
          {
            return_value_inet_pton$4=inet_pton(2, curtok, (void *)tp);
            if(return_value_inet_pton$4 >= 1)
            {
              tp = tp + (signed long int)4;
              seen_xdigits = 0;
              break;
            }

          }

          return 0;
        }
    }
    while((_Bool)1);
    if(!(seen_xdigits == 0))
    {
      if(!(endp >= tp + 2l))
        return 0;

      tmp_post$5 = tp;
      tp = tp + 1l;
      *tmp_post$5 = (unsigned char)((signed int)(unsigned char)(val >> 8) & 0xff);
      tmp_post$6 = tp;
      tp = tp + 1l;
      *tmp_post$6 = (unsigned char)((signed int)(unsigned char)val & 0xff);
    }

    if(!(colonp == ((unsigned char *)NULL)))
    {
      const signed int n = (const signed int)(tp - colonp);
      signed int i;
      if(tp == endp)
        return 0;

      i = 1;
      for( ; n >= i; i = i + 1)
      {
        endp[(signed long int)-i] = colonp[(signed long int)(n - i)];
        colonp[(signed long int)(n - i)] = (unsigned char)0;
      }
      tp = endp;
    }

    if(!(tp == endp))
      return 0;

    else
    {
      memcpy((void *)dst, (const void *)tmp, (unsigned long int)16);
      return 1;
    }
  }
}

// vpcs
// file vpcs.c line 140
signed int vpcs(signed int argc, char **argv)
{
  signed int i;
  char prompt[128l];
  signed int c;
  unsigned long int timer_pid;
  unsigned long int relay_pid;
  signed int daemon_bg = 1;
  char *cmd;
  rhost=inet_addr("127.0.0.1");
  devtype = 2;
  unsigned int return_value_inet_addr$1;
  do
  {
    c=getopt(argc, argv, "?c:ehm:p:r:s:t:uvFi:d:");
    if(c == -1)
      break;

    switch(c)
    {
      case 99:
      {
        rport_flag = 1;
        rport=arg2int(optarg, 1024, 65000, 30000);
        break;
      }
      case 101:
      {
        devtype = 1;
        break;
      }
      case 109:
      {
        macaddr=arg2int(optarg, 0, 240, 0);
        break;
      }
      case 112:
      {
        daemon_port=arg2int(optarg, 1024, 65000, 5000);
        break;
      }
      case 114:
      {
        startupfile=strdup(optarg);
        break;
      }
      case 115:
      {
        lport=arg2int(optarg, 1024, 65000, 20000);
        break;
      }
      case 116:
      {
        return_value_inet_addr$1=inet_addr(optarg);
        if(!(return_value_inet_addr$1 == 4294967295u))
          rhost=inet_addr(optarg);

        break;
      }
      case 117:
      {
        devtype = 2;
        break;
      }
      case 118:
      {
        run_ver(argc, argv);
        exit(0);
        break;
      }
      case 70:
      {
        daemon_bg = 0;
        break;
      }
      case 105:
      {
        num_pths=arg2int(optarg, 1, 9, 9);
        break;
      }
      case 100:
      {
        if(!(num_pths == 1))
        {
          usage();
          exit(0);
        }

        tapname=strdup(optarg);
        break;
      }
      case 104:

      case 63:
      {
        usage();
        exit(0);
      }
      default:
        ;
    }
  }
  while((_Bool)1);
  if(!(optind == argc))
  {
    if(1 + optind == argc)
      startupfile=strdup(argv[(signed long int)optind]);

    else
    {
      usage();
      exit(0);
    }
  }

  signed int return_value_daemonize$2;
  if(!(daemon_port == 0))
  {
    return_value_daemonize$2=daemonize(daemon_port, daemon_bg);
    if(!(return_value_daemonize$2 == 0))
      exit(0);

  }

  signed int return_value_isatty$3;
  return_value_isatty$3=isatty(0);
  if(return_value_isatty$3 == 0)
  {
    printf("Please run in the tty\n");
    exit(-1);
  }

  signal(2, sig_int);
  signal(10, sig_clean);
  signal(17, (void (*)(signed int))1);
  welcome();
  signed long int return_value_time$4;
  return_value_time$4=time(((signed long int *)NULL));
  srand((unsigned int)return_value_time$4);
  memset((void *)vpc, 0, (unsigned long int)9 * sizeof(struct anonymous$0) /*217264ul*/ );
  i = 0;
  for( ; !(i >= num_pths); i = i + 1)
  {
    signed int return_value_pthread_create$5;
    return_value_pthread_create$5=pthread_create(&vpc[(signed long int)i].rpid, (const union pthread_attr_t *)(void *)0, pth_reader, (void *)&i);
    if(!(return_value_pthread_create$5 == 0))
    {
      printf("PC%d error\n", i + 1);
      fflush(stdout);
      exit(-1);
    }

    strcpy(vpc[(signed long int)i].xname, "VPCS");
    while((signed int)vpc[(signed long int)i].ip4.mac[4l] == 0)
      usleep((unsigned int)(10 * 1000));
    usleep((unsigned int)(100 * 1000));
  }
  pthread_create(&timer_pid, (const union pthread_attr_t *)(void *)0, pth_timer_tick, (void *)0);
  usleep((unsigned int)(100 * 1000));
  pthread_create(&relay_pid, (const union pthread_attr_t *)(void *)0, pth_relay, (void *)0);
  pcid = 0;
  usleep((unsigned int)(50 * 1000));
  autoconf6();
  usleep((unsigned int)(50 * 1000));
  startup();
  rls=readline_init(50, 128);
  if(rls == ((struct rls *)NULL))
  {
    printf("initialize readline error\n");
    return 1;
  }

  else
  {
    if(!(histfile == ((char *)NULL)))
      loadhistory(histfile, rls);

    while((_Bool)1)
    {
      if(num_pths >= 2)
        snprintf(prompt, sizeof(char [128l]) /*128ul*/ , "\n\r%s[%d]> ", (const void *)vpc[(signed long int)pcid].xname, pcid + 1);

      else
        snprintf(prompt, sizeof(char [128l]) /*128ul*/ , "\n\r%s> ", (const void *)vpc[(signed long int)pcid].xname);
      ctrl_c = 0;
      cmd=readline(prompt, rls);
      if(!(cmd == ((char *)NULL)))
      {
        ttrim(cmd);
        parse_cmd(cmd);
      }

    }
    return 0;
  }
}

// vprint
// file readline.c line 527
static void vprint(signed int fd, char *s, signed int len)
{
  signed long int return_value_write$1;
  return_value_write$1=write(fd, (const void *)s, (unsigned long int)len);
}

// waitdeq
// file queue.h line 65
struct packet * waitdeq(struct pq *pq)
{
  struct packet *return_value_deq_impl$1;
  return_value_deq_impl$1=deq_impl(pq, 1);
  return return_value_deq_impl$1;
}

// welcome
// file vpcs.c line 594
static void welcome(void)
{
  run_ver(0, (char **)(void *)0);
  printf("\nPress '?' to get help.\n");
}

