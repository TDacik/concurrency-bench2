// #anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7
// file /usr/include/X11/Xresource.h line 326
enum anonymous_19 { XrmoptionNoArg=0, XrmoptionIsArg=1, XrmoptionStickyArg=2, XrmoptionSepArg=3, XrmoptionResArg=4, XrmoptionSkipArg=5, XrmoptionSkipLine=6, XrmoptionSkipNArgs=7 };

// #anon_enum_XtGeometryYes=0_XtGeometryNo=1_XtGeometryAlmost=2_XtGeometryDone=3
// file /usr/include/X11/Intrinsic.h line 340
enum anonymous_25 { XtGeometryYes=0, XtGeometryNo=1, XtGeometryAlmost=2, XtGeometryDone=3 };

// #anon_enum_XtGrabNone=0_XtGrabNonexclusive=1_XtGrabExclusive=2
// file /usr/include/X11/Intrinsic.h line 347
enum anonymous_26 { XtGrabNone=0, XtGrabNonexclusive=1, XtGrabExclusive=2 };

// #anon_enum_color_scheme_default=0_color_scheme_uniform=1_color_scheme_smooth=2_color_scheme_bright=3
// file ./../xlockmoreI.h line 154
enum anonymous_43 { color_scheme_default=0, color_scheme_uniform=1, color_scheme_smooth=2, color_scheme_bright=3 };

// #anon_enum_t_String=0_t_Float=1_t_Int=2_t_Bool=3
// file ./../xlockmoreI.h line 127
enum anonymous_20 { t_String=0, t_Float=1, t_Int=2, t_Bool=3 };

// tag-#anon#ST[*{*{SYM#tag-__GLXcontextRec#}_SYM#tag-__GLXcontextRec#_}_*{SYM#tag-__GLXcontextRec#}_SYM#tag-__GLXcontextRec#__'glx_context'|*{SYM#tag-rotator#}_SYM#tag-rotator#_'rot'|*{SYM#tag-trackball_state#}_SYM#tag-trackball_state#_'trackball'|S32'button_down_p'|F32'molecule_size'|F32'no_label_threshold'|F32'wireframe_threshold'|S32'which'|S32'nmolecules'|*{SYM#tag-#anon#ST[*{cS8}_cS8_'label'|S32'natoms'|S32'atoms_size'|S32'nbonds'|S32'bonds_size'|*{SYM#tag-#anon#ST[S32'id'|U32'_pad0'|*{cS8}_cS8_'label'|F32'x'|F32'y'|F32'z'|U32'_pad1'|*{cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#}_cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#_'data']#}_SYM#tag-#anon#ST[S32'id'|U32'_pad0'|*{cS8}_cS8_'label'|F32'x'|F32'y'|F32'z'|U32'_pad1'|*{cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#}_cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#_'data']#_'atoms'|*{SYM#tag-#anon#ST[S32'from'|S32'to'|S32'strength']#}_SYM#tag-#anon#ST[S32'from'|S32'to'|S32'strength']#_'bonds']#}_SYM#tag-#anon#ST[*{cS8}_cS8_'label'|S32'natoms'|S32'atoms_size'|S32'nbonds'|S32'bonds_size'|*{SYM#tag-#anon#ST[S32'id'|U32'_pad0'|*{cS8}_cS8_'label'|F32'x'|F32'y'|F32'z'|U32'_pad1'|*{cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#}_cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#_'data']#}_SYM#tag-#anon#ST[S32'id'|U32'_pad0'|*{cS8}_cS8_'label'|F32'x'|F32'y'|F32'z'|U32'_pad1'|*{cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#}_cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#_'data']#_'atoms'|*{SYM#tag-#anon#ST[S32'from'|S32'to'|S32'strength']#}_SYM#tag-#anon#ST[S32'from'|S32'to'|S32'strength']#_'bonds']#_'molecules'|S32'mode'|S32'mode_tick'|S32'next'|U32'molecule_dlist'|U32'shell_dlist'|U32'_pad0'|*{SYM#tag-texture_font_data#}_SYM#tag-texture_font_data#_'atom_font'|*{SYM#tag-texture_font_data#}_SYM#tag-texture_font_data#_'title_font'|S32'polygon_count'|U32'_pad1'|S64'draw_time'|S32'draw_tick'|F32'overall_scale'|S32'low_rez_p'|U32'_pad2']
// file molecule.c line 146
struct anonymous_31;

// tag-#anon#ST[*{S8}_S8_'atom'|S32'count'|U32'_pad0']
// file molecule.c line 927
struct anonymous_37;

// tag-#anon#ST[*{S8}_S8_'name'|S64'value']
// file /usr/include/X11/Intrinsic.h line 316
struct anonymous_23;

// tag-#anon#ST[*{S8}_S8_'opt'|*{S8}_S8_'desc']
// file ./../xlockmoreI.h line 137
struct anonymous_0;

// tag-#anon#ST[*{S8}_S8_'option'|*{S8}_S8_'specifier'|SYM##anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7#'argKind'|U32'_pad0'|*{S8}_S8_'value']
// file /usr/include/X11/Xresource.h line 338
struct anonymous_18;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'visualid'|S32'screen'|S32'depth'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'colormap_size'|S32'bits_per_rgb']
// file /usr/include/X11/Xutil.h line 287
struct anonymous_10;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']
// file /usr/include/X11/Xlib.h line 257
struct anonymous_15;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private1'|S32'fd'|S32'private2'|S32'proto_major_version'|S32'proto_minor_version'|*{S8}_S8_'vendor'|U64'private3'|U64'private4'|U64'private5'|S32'private6'|U32'_pad0'|*{U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64}_U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64_'resource_alloc'|S32'byte_order'|S32'bitmap_unit'|S32'bitmap_pad'|S32'bitmap_bit_order'|S32'nformats'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#_'pixmap_format'|S32'private8'|S32'release'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private9'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private10'|S32'qlen'|U32'_pad2'|U64'last_request_read'|U64'request'|*{S8}_S8_'private11'|*{S8}_S8_'private12'|*{S8}_S8_'private13'|*{S8}_S8_'private14'|U32'max_request_size'|U32'_pad3'|*{SYM#tag-_XrmHashBucketRec#}_SYM#tag-_XrmHashBucketRec#_'db'|*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32_'private15'|*{S8}_S8_'display_name'|S32'default_screen'|S32'nscreens'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screens'|U64'motion_buffer'|U64'private16'|S32'min_keycode'|S32'max_keycode'|*{S8}_S8_'private17'|*{S8}_S8_'private18'|S32'private19'|U32'_pad4'|*{S8}_S8_'xdefaults']
// file /usr/include/X11/Xlib.h line 493
struct anonymous_42;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']
// file /usr/include/X11/Xlib.h line 280
struct anonymous_40;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'fid'|U32'direction'|U32'min_char_or_byte2'|U32'max_char_or_byte2'|U32'min_byte1'|U32'max_byte1'|S32'all_chars_exist'|U32'default_char'|S32'n_properties'|*{SYM#tag-#anon#ST[U64'name'|U64'card32']#}_SYM#tag-#anon#ST[U64'name'|U64'card32']#_'properties'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'min_bounds'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'max_bounds'|*{SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#}_SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#_'per_char'|S32'ascent'|S32'descent']
// file /usr/include/X11/Xlib.h line 1035
struct anonymous_1;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']
// file /usr/include/X11/Xlib.h line 227
struct anonymous_16;

// tag-#anon#ST[*{SYM#tag-texture_font_data#}_SYM#tag-texture_font_data#_'texfont'|S32'line_height'|S32'top_p']
// file fps-gl.c line 38
struct anonymous_22;

// tag-#anon#ST[*{V}_V_'var'|*{S8}_S8_'name'|*{S8}_S8_'classname'|*{S8}_S8_'def'|SYM##anon_enum_t_String=0_t_Float=1_t_Int=2_t_Bool=3#'type'|U32'_pad0']
// file ./../xlockmoreI.h line 129
struct anonymous;

// tag-#anon#ST[*{cS8}_cS8_'label'|S32'natoms'|S32'atoms_size'|S32'nbonds'|S32'bonds_size'|*{SYM#tag-#anon#ST[S32'id'|U32'_pad0'|*{cS8}_cS8_'label'|F32'x'|F32'y'|F32'z'|U32'_pad1'|*{cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#}_cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#_'data']#}_SYM#tag-#anon#ST[S32'id'|U32'_pad0'|*{cS8}_cS8_'label'|F32'x'|F32'y'|F32'z'|U32'_pad1'|*{cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#}_cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#_'data']#_'atoms'|*{SYM#tag-#anon#ST[S32'from'|S32'to'|S32'strength']#}_SYM#tag-#anon#ST[S32'from'|S32'to'|S32'strength']#_'bonds']
// file molecule.c line 137
struct anonymous_30;

// tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']
// file molecule.c line 99
struct anonymous_35;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_36;

// tag-#anon#ST[F32'x'|F32'y'|F32'z']
// file sphere.c line 40
struct anonymous_9;

// tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']
// file /usr/include/X11/Xlib.h line 1017
struct anonymous_38;

// tag-#anon#ST[S16'x'|S16'y']
// file /usr/include/X11/Xlib.h line 426
struct anonymous_14;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_6;

// tag-#anon#ST[S32'depth'|S32'bits_per_pixel'|S32'scanline_pad']
// file /usr/include/X11/Xlib.h line 171
struct anonymous_28;

// tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']
// file /usr/include/X11/Xlib.h line 243
struct anonymous_2;

// tag-#anon#ST[S32'from'|S32'to'|S32'strength']
// file molecule.c line 131
struct anonymous_34;

// tag-#anon#ST[S32'function'|U32'_pad0'|U64'plane_mask'|U64'foreground'|U64'background'|S32'line_width'|S32'line_style'|S32'cap_style'|S32'join_style'|S32'fill_style'|S32'fill_rule'|S32'arc_mode'|U32'_pad1'|U64'tile'|U64'stipple'|S32'ts_x_origin'|S32'ts_y_origin'|U64'font'|S32'subwindow_mode'|S32'graphics_exposures'|S32'clip_x_origin'|S32'clip_y_origin'|U64'clip_mask'|S32'dash_offset'|S8'dashes'|U24'_pad2']
// file /usr/include/X11/Xlib.h line 181
struct anonymous_8;

// tag-#anon#ST[S32'id'|U32'_pad0'|*{cS8}_cS8_'label'|F32'x'|F32'y'|F32'z'|U32'_pad1'|*{cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#}_cSYM#tag-#anon#ST[*{cS8}_cS8_'name'|F32'size'|F32'size2'|*{cS8}_cS8_'color'|*{cS8}_cS8_'text_color'|ARR8{F32}_F32_'gl_color']#_'data']
// file molecule.c line 124
struct anonymous_33;

// tag-#anon#ST[S32'numopts'|U32'_pad0'|*{SYM#tag-#anon#ST[*{S8}_S8_'option'|*{S8}_S8_'specifier'|SYM##anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7#'argKind'|U32'_pad0'|*{S8}_S8_'value']#}_SYM#tag-#anon#ST[*{S8}_S8_'option'|*{S8}_S8_'specifier'|SYM##anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7#'argKind'|U32'_pad0'|*{S8}_S8_'value']#_'opts'|S32'numvarsdesc'|U32'_pad1'|*{SYM#tag-#anon#ST[*{V}_V_'var'|*{S8}_S8_'name'|*{S8}_S8_'classname'|*{S8}_S8_'def'|SYM##anon_enum_t_String=0_t_Float=1_t_Int=2_t_Bool=3#'type'|U32'_pad0']#}_SYM#tag-#anon#ST[*{V}_V_'var'|*{S8}_S8_'name'|*{S8}_S8_'classname'|*{S8}_S8_'def'|SYM##anon_enum_t_String=0_t_Float=1_t_Int=2_t_Bool=3#'type'|U32'_pad0']#_'vars'|*{SYM#tag-#anon#ST[*{S8}_S8_'opt'|*{S8}_S8_'desc']#}_SYM#tag-#anon#ST[*{S8}_S8_'opt'|*{S8}_S8_'desc']#_'desc']
// file ./../xlockmoreI.h line 142
struct anonymous_44;

// tag-#anon#ST[S32'type'|U32'_pad0'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'resourceid'|U64'serial'|U8'error_code'|U8'request_code'|U8'minor_code'|U40'_pad1']
// file /usr/include/X11/Xlib.h line 924
struct anonymous_32;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype']
// file /usr/include/X11/Xlib.h line 948
struct anonymous_75;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype'|U32'cookie'|U32'_pad2'|*{V}_V_'data']
// file /usr/include/X11/Xlib.h line 958
struct anonymous_76;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'major_code'|S32'minor_code']
// file /usr/include/X11/Xlib.h line 686
struct anonymous_53;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|S32'major_code'|S32'minor_code'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 673
struct anonymous_52;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window']
// file /usr/include/X11/Xlib.h line 718
struct anonymous_56;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'from_configure'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 727
struct anonymous_57;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 737
struct anonymous_58;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 816
struct anonymous_65;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y']
// file /usr/include/X11/Xlib.h line 782
struct anonymous_62;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'override_redirect'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 768
struct anonymous_61;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|U64'parent'|S32'x'|S32'y'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 756
struct anonymous_60;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'owner'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 857
struct anonymous_69;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window']
// file /usr/include/X11/Xlib.h line 747
struct anonymous_59;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 826
struct anonymous_66;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'override_redirect']
// file /usr/include/X11/Xlib.h line 705
struct anonymous_55;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'detail'|U32'_pad3'|U64'value_mask']
// file /usr/include/X11/Xlib.h line 801
struct anonymous_64;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 870
struct anonymous_70;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window']
// file /usr/include/X11/Xlib.h line 934
struct anonymous_45;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|ARR32{S8}_S8_'key_vector']
// file /usr/include/X11/Xlib.h line 653
struct anonymous_74;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'mode'|S32'detail']
// file /usr/include/X11/Xlib.h line 634
struct anonymous_50;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'request'|S32'first_keycode'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 912
struct anonymous_73;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 696
struct anonymous_54;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'width'|S32'height']
// file /usr/include/X11/Xlib.h line 792
struct anonymous_63;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 662
struct anonymous_51;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'atom'|U64'time'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 836
struct anonymous_67;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'colormap'|S32'new'|S32'state']
// file /usr/include/X11/Xlib.h line 882
struct anonymous_71;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'message_type'|S32'format'|U32'_pad2'|SYM#tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']#'data']
// file /usr/include/X11/Xlib.h line 897
struct anonymous_72;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|S32'mode'|S32'detail'|S32'same_screen'|S32'focus'|U32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 610
struct anonymous_49;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|S8'is_hint'|U24'_pad2'|S32'same_screen'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 593
struct anonymous_48;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'button'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 575
struct anonymous_47;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'keycode'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 557
struct anonymous_46;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'selection'|U64'time']
// file /usr/include/X11/Xlib.h line 847
struct anonymous_68;

// tag-#anon#ST[S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'depth'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'root'|S32'class'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad0'|U64'colormap'|S32'map_installed'|S32'map_state'|S64'all_event_masks'|S64'your_event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screen']
// file /usr/include/X11/Xlib.h line 308
struct anonymous_17;

// tag-#anon#ST[U16'red'|U16'green'|U16'blue'|U16'alpha']
// file /usr/include/X11/extensions/Xrender.h line 83
struct anonymous_12;

// tag-#anon#ST[U32'request_mode'|S16'x'|S16'y'|U16'width'|U16'height'|U16'border_width'|U16'_pad0'|*{SYM#tag-_WidgetRec#}_SYM#tag-_WidgetRec#_'sibling'|S32'stack_mode'|U32'_pad1']
// file /usr/include/X11/Intrinsic.h line 212
struct anonymous_21;

// tag-#anon#ST[U32'size'|U32'_pad0'|*{S8}_S8_'addr']
// file /usr/include/X11/Xresource.h line 160
struct anonymous_24;

// tag-#anon#ST[U64'background_pixmap'|U64'background_pixel'|U64'border_pixmap'|U64'border_pixel'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U32'_pad0'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad1'|S64'event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad2'|U64'colormap'|U64'cursor']
// file /usr/include/X11/Xlib.h line 290
struct anonymous_39;

// tag-#anon#ST[U64'name'|U64'card32']
// file /usr/include/X11/Xlib.h line 1030
struct anonymous_4;

// tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']
// file /usr/include/X11/Xlib.h line 410
struct anonymous_27;

// tag-#anon#ST[U64'shmseg'|S32'shmid'|U32'_pad0'|*{S8}_S8_'shmaddr'|S32'readOnly'|U32'_pad1']
// file /usr/include/X11/extensions/XShm.h line 50
struct anonymous_29;

// tag-#anon#ST[U8'byte1'|U8'byte2']
// file /usr/include/X11/Xlib.h line 1064
struct anonymous_13;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_41;

// tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']
// file /usr/include/X11/Xlib.h line 905
union anonymous_3;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_5;

// tag-ModeInfo
// file ./../xlockmoreI.h line 27
struct ModeInfo;

// tag-_CoreClassPart
// file /usr/include/X11/CoreP.h line 125
struct _CoreClassPart;

// tag-_CorePart
// file /usr/include/X11/CoreP.h line 72
struct _CorePart;

// tag-_FcCharSet
// file /usr/include/fontconfig/fontconfig.h line 212
struct _FcCharSet;

// tag-_FcPattern
// file /usr/include/fontconfig/fontconfig.h line 230
struct _FcPattern;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-_TranslationData
// file /usr/include/X11/Intrinsic.h line 170
struct _TranslationData;

// tag-_WidgetClassRec
// file /usr/include/X11/Intrinsic.h line 109
struct _WidgetClassRec;

// tag-_WidgetRec
// file /usr/include/X11/Intrinsic.h line 107
struct _WidgetRec;

// tag-_XComposeStatus
// file /usr/include/X11/Xutil.h line 231
struct _XComposeStatus;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XGlyphInfo
// file /usr/include/X11/extensions/Xrender.h line 90
struct _XGlyphInfo;

// tag-_XImage
// file /usr/include/X11/Xlib.h line 360
struct _XImage;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XRegion
// file /usr/include/X11/Xutil.h line 273
struct _XRegion;

// tag-_XftColor
// file /usr/include/X11/Xft/Xft.h line 75
struct _XftColor;

// tag-_XftDraw
// file /usr/include/X11/Xft/Xft.h line 73
struct _XftDraw;

// tag-_XftFont
// file /usr/include/X11/Xft/Xft.h line 64
struct _XftFont;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-_XtActionsRec
// file /usr/include/X11/Intrinsic.h line 111
struct _XtActionsRec;

// tag-_XtAppStruct
// file /usr/include/X11/Intrinsic.h line 114
struct _XtAppStruct;

// tag-_XtCallbackRec
// file /usr/include/X11/Intrinsic.h line 329
struct _XtCallbackRec;

// tag-_XtEventRec
// file /usr/include/X11/Intrinsic.h line 112
struct _XtEventRec;

// tag-_XtResource
// file /usr/include/X11/Intrinsic.h line 354
struct _XtResource;

// tag-_XtStateRec
// file /usr/include/X11/IntrinsicP.h line 187
struct _XtStateRec;

// tag-_XtTMRec
// file /usr/include/X11/IntrinsicP.h line 189
struct _XtTMRec;

// tag-__GLXcontextRec
// file /usr/include/GL/glx.h line 165
struct __GLXcontextRec;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_async_name_from_addr_param
// file async_netdb.h line 90
struct _async_name_from_addr_param;

// tag-_io_thread_status
// file thread_util.h line 360
enum _io_thread_status { _io_thread_working=0, _io_thread_done=1, _io_thread_cancelled=2 };

// tag-_parallel_startup_type
// file thread_util.c line 534
struct _parallel_startup_type;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-async_addr_from_name
// file async_netdb.h line 155
struct async_addr_from_name;

// tag-async_name_from_addr
// file async_netdb.h line 96
struct async_name_from_addr;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-fps_state
// file fps.h line 20
struct fps_state;

// tag-funcs
// file /usr/include/X11/Xlib.h line 376
struct funcs;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-io_thread
// file thread_util.h line 365
struct io_thread;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rotator
// file rotator.h line 15
struct rotator;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 166
struct sockaddr_storage;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-texfont_cache
// file texfont.c line 64
struct texfont_cache;

// tag-texture_font_data
// file texfont.h line 16
struct texture_font_data;

// tag-threadpool
// file thread_util.h line 227
struct threadpool;

// tag-threadpool_class
// file thread_util.h line 277
struct threadpool_class;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-trackball_state
// file gltrackball.h line 16
struct trackball_state;

// tag-xlockmore_function_table
// file ./../xlockmoreI.h line 87
struct xlockmore_function_table;

// tag-xscreensaver_function_table
// file ./../screenhackI.h line 114
struct xscreensaver_function_table;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// BadValue_ehandler
// file xlock-gl-utils.c line 36
static signed int BadValue_ehandler(struct _XDisplay *dpy, struct anonymous_32 *error);
// MapNotify_event_p
// file screenhack.c line 256
static signed int MapNotify_event_p(struct _XDisplay *dpy, union _XEvent *event, char *window);
// VirtualRootWindowOfScreen
// file ./../utils/vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen(struct anonymous_15 *screen);
// XAllocColor
// file /usr/include/X11/Xlib.h line 1958
extern signed int XAllocColor(struct _XDisplay *, unsigned long int, struct anonymous_27 *);
// XAllocColorCells
// file /usr/include/X11/Xlib.h line 1964
extern signed int XAllocColorCells(struct _XDisplay *, unsigned long int, signed int, unsigned long int *, unsigned int, unsigned long int *, unsigned int);
// XBell
// file /usr/include/X11/Xlib.h line 2010
extern signed int XBell(struct _XDisplay *, signed int);
// XChangeProperty
// file /usr/include/X11/Xlib.h line 2068
extern signed int XChangeProperty(struct _XDisplay *, unsigned long int, unsigned long int, unsigned long int, signed int, signed int, const unsigned char *, signed int);
// XChar2b_to_utf8
// file utf8wc.c line 306
extern char * XChar2b_to_utf8(const struct anonymous_13 *in, signed int *length_ret);
// XClearWindow
// file /usr/include/X11/Xlib.h line 2155
extern signed int XClearWindow(struct _XDisplay *, unsigned long int);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous_16 *, signed int);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous_8 *);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XDrawString
// file /usr/include/X11/Xlib.h line 2404
extern signed int XDrawString(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, const char *, signed int);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeColors
// file /usr/include/X11/Xlib.h line 2525
extern signed int XFreeColors(struct _XDisplay *, unsigned long int, unsigned long int *, signed int, unsigned long int);
// XFreeFont
// file /usr/include/X11/Xlib.h line 2542
extern signed int XFreeFont(struct _XDisplay *, struct anonymous_1 *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XGetAtomName
// file /usr/include/X11/Xlib.h line 1500
extern char * XGetAtomName(struct _XDisplay *, unsigned long int);
// XGetImage
// file /usr/include/X11/Xlib.h line 1456
extern struct _XImage * XGetImage(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned long int, signed int);
// XGetVisualInfo
// file /usr/include/X11/Xutil.h line 471
extern struct anonymous_10 * XGetVisualInfo(struct _XDisplay *, signed long int, struct anonymous_10 *, signed int *);
// XGetWindowAttributes
// file /usr/include/X11/Xlib.h line 2691
extern signed int XGetWindowAttributes(struct _XDisplay *, unsigned long int, struct anonymous_17 *);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XIfEvent
// file /usr/include/X11/Xlib.h line 2753
extern signed int XIfEvent(struct _XDisplay *, union _XEvent *, signed int (*)(struct _XDisplay *, union _XEvent *, char *), char *);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XListDepths
// file /usr/include/X11/Xlib.h line 1866
extern signed int * XListDepths(struct _XDisplay *, signed int, signed int *);
// XListPixmapFormats
// file /usr/include/X11/Xlib.h line 1862
extern struct anonymous_28 * XListPixmapFormats(struct _XDisplay *, signed int *);
// XLoadQueryFont
// file /usr/include/X11/Xlib.h line 1394
extern struct anonymous_1 * XLoadQueryFont(struct _XDisplay *, const char *);
// XLookupString
// file /usr/include/X11/Xutil.h line 534
extern signed int XLookupString(struct anonymous_46 *, char *, signed int, unsigned long int *, struct _XComposeStatus *);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XParseColor
// file /usr/include/X11/Xlib.h line 2850
extern signed int XParseColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous_27 *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XQueryTree
// file /usr/include/X11/Xlib.h line 3017
extern signed int XQueryTree(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, unsigned long int **, unsigned int *);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous_32 *)))(struct _XDisplay *, struct anonymous_32 *);
// XSetFont
// file /usr/include/X11/Xlib.h line 3215
extern signed int XSetFont(struct _XDisplay *, struct _XGC *, unsigned long int);
// XSetWindowBackground
// file /usr/include/X11/Xlib.h line 3333
extern signed int XSetWindowBackground(struct _XDisplay *, unsigned long int, unsigned long int);
// XSetWindowColormap
// file /usr/include/X11/Xlib.h line 3363
extern signed int XSetWindowColormap(struct _XDisplay *, unsigned long int, unsigned long int);
// XStoreColors
// file /usr/include/X11/Xlib.h line 3388
extern signed int XStoreColors(struct _XDisplay *, unsigned long int, struct anonymous_27 *, signed int);
// XSync
// file /usr/include/X11/Xlib.h line 3409
extern signed int XSync(struct _XDisplay *, signed int);
// XVisualIDFromVisual
// file /usr/include/X11/Xlib.h line 1728
extern unsigned long int XVisualIDFromVisual(struct anonymous_16 *);
// XftColorAllocValue
// file /usr/include/X11/Xft/Xft.h line 118
signed int XftColorAllocValue(struct _XDisplay *, struct anonymous_16 *, unsigned long int, const struct anonymous_12 *, struct _XftColor *);
// XftColorFree
// file /usr/include/X11/Xft/Xft.h line 125
void XftColorFree(struct _XDisplay *, struct anonymous_16 *, unsigned long int, struct _XftColor *);
// XftDrawCreate
// file /usr/include/X11/Xft/Xft.h line 143
struct _XftDraw * XftDrawCreate(struct _XDisplay *, unsigned long int, struct anonymous_16 *, unsigned long int);
// XftDrawDestroy
// file /usr/include/X11/Xft/Xft.h line 174
void XftDrawDestroy(struct _XftDraw *);
// XftDrawStringUtf8
// file /usr/include/X11/Xft/Xft.h line 219
void XftDrawStringUtf8(struct _XftDraw *, const struct _XftColor *, struct _XftFont *, signed int, signed int, const unsigned char *, signed int);
// XftFontClose
// file /usr/include/X11/Xft/Xft.h line 381
void XftFontClose(struct _XDisplay *, struct _XftFont *);
// XftFontOpenXlfd
// file /usr/include/X11/Xft/Xft.h line 347
struct _XftFont * XftFontOpenXlfd(struct _XDisplay *, signed int, const char *);
// XftTextExtentsUtf8
// file /usr/include/X11/Xft/Xft.h line 319
void XftTextExtentsUtf8(struct _XDisplay *, struct _XftFont *, const unsigned char *, signed int, struct _XGlyphInfo *);
// XmuPrintDefaultErrorMessage
// file ./../utils/xmu.h line 12
signed int XmuPrintDefaultErrorMessage(struct _XDisplay *, struct anonymous_32 *, struct _IO_FILE *);
// XrmGetResource
// file /usr/include/X11/Xresource.h line 223
extern signed int XrmGetResource(struct _XrmHashBucketRec *, const char *, const char *, char **, struct anonymous_24 *);
// XtAppInitialize
// file /usr/include/X11/Intrinsic.h line 1468
extern struct _WidgetRec * XtAppInitialize(struct _XtAppStruct **, const char *, struct anonymous_18 *, unsigned int, signed int *, char **, char **, struct anonymous_23 *, unsigned int);
// XtAppPending
// file /usr/include/X11/Intrinsic.h line 1045
extern unsigned long int XtAppPending(struct _XtAppStruct *);
// XtAppProcessEvent
// file /usr/include/X11/Intrinsic.h line 931
extern void XtAppProcessEvent(struct _XtAppStruct *, unsigned long int);
// XtDatabase
// file resources.c line 27
extern struct _XrmHashBucketRec * XtDatabase(struct _XDisplay *);
// XtDestroyApplicationContext
// file /usr/include/X11/Intrinsic.h line 1520
extern void XtDestroyApplicationContext(struct _XtAppStruct *);
// XtDestroyWidget
// file /usr/include/X11/Intrinsic.h line 1112
extern void XtDestroyWidget(struct _WidgetRec *);
// XtDisplayToApplicationContext
// file /usr/include/X11/Intrinsic.h line 1532
extern struct _XtAppStruct * XtDisplayToApplicationContext(struct _XDisplay *);
// XtGetApplicationNameAndClass
// file /usr/include/X11/Intrinsic.h line 2176
extern void XtGetApplicationNameAndClass(struct _XDisplay *, char **, char **);
// XtPopup
// file /usr/include/X11/Intrinsic.h line 1318
extern void XtPopup(struct _WidgetRec *, enum anonymous_26);
// XtRealizeWidget
// file /usr/include/X11/Intrinsic.h line 1104
extern void XtRealizeWidget(struct _WidgetRec *);
// XtVaAppCreateShell
// file /usr/include/X11/Intrinsic.h line 1408
extern struct _WidgetRec * XtVaAppCreateShell(const char *, const char *, struct _WidgetClassRec *, struct _XDisplay *, ...);
// XtVaSetValues
// file /usr/include/X11/Intrinsic.h line 1592
extern void XtVaSetValues(struct _WidgetRec *, ...);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __atomic_exchange_n
// file thread_util.c line 993 function io_thread_return
signed int __atomic_exchange_n();
// __atomic_load_n
// file thread_util.c line 1006 function io_thread_is_done
signed int __atomic_load_n();
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __h_errno_location
// file /usr/include/netdb.h line 61
extern signed int * __h_errno_location(void);
// __isoc99_sscanf
// file /usr/include/stdio.h line 448
extern signed int __isoc99_sscanf(const char *, const char *, ...);
// _add_next_thread
// file thread_util.c line 551
static void _add_next_thread(struct _parallel_startup_type *self);
// _async_addr_from_name_free
// file async_netdb.c line 283
static void _async_addr_from_name_free(struct async_addr_from_name *self);
// _async_addr_from_name_hostname
// file async_netdb.c line 277
static char * _async_addr_from_name_hostname(struct async_addr_from_name *self);
// _async_addr_from_name_thread
// file async_netdb.c line 295
static void * _async_addr_from_name_thread(void *self_raw);
// _async_name_from_addr_set_param
// file async_netdb.c line 128
static void _async_name_from_addr_set_param(struct _async_name_from_addr_param *self, struct sockaddr *addr, unsigned int addrlen);
// _async_name_from_addr_thread
// file async_netdb.c line 102
static void * _async_name_from_addr_thread(void *self_raw);
// _async_netdb_is_done
// file async_netdb.c line 39
signed int _async_netdb_is_done(struct io_thread *io);
// _get_cache_line_size
// file thread_util.c line 184
static unsigned int _get_cache_line_size(void);
// _hardware_concurrency
// file thread_util.c line 462
static unsigned int _hardware_concurrency(void);
// _parallel_abort
// file thread_util.c line 527
static void _parallel_abort(struct threadpool *self);
// _serial_destroy
// file thread_util.c line 511
static void _serial_destroy(struct threadpool *self);
// _start_routine
// file thread_util.c line 585
static void * _start_routine(void *startup_raw);
// _thread_destroy_and_unlock
// file thread_util.c line 577
static void * _thread_destroy_and_unlock(struct threadpool *self, void *thread);
// _thread_free_and_unlock
// file thread_util.c line 568
static void * _thread_free_and_unlock(struct threadpool *self, void *thread);
// _threadpool_count_parallel
// file thread_util.c line 541
static unsigned int _threadpool_count_parallel(struct threadpool *self);
// _threadpool_count_serial
// file thread_util.c line 501
static unsigned int _threadpool_count_serial(struct threadpool *self);
// _translate_h_errno
// file async_netdb.c line 82
static signed int _translate_h_errno(signed int error);
// _unlock_and_destroy
// file thread_util.c line 685
static void _unlock_and_destroy(struct threadpool *self);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_quats
// file trackball.c line 254
void add_quats(float *q1, float *q2, float *dest);
// adjust_for_device_rotation
// file gltrackball.c line 92
static void adjust_for_device_rotation(struct trackball_state *ts, double *x, double *y, double *w, double *h);
// aligned_free
// file aligned_malloc.h line 35
void aligned_free(void *ptr);
// aligned_malloc
// file aligned_malloc.h line 34
signed int aligned_malloc(void **ptr, unsigned int alignment, unsigned long int size);
// allocate_writable_colors
// file colors.c line 42
extern void allocate_writable_colors(struct anonymous_15 *screen, unsigned long int cmap, unsigned long int *pixels, signed int *ncolorsP);
// asin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 56
extern double asin(double);
// async_addr_from_name_cancel
// file async_netdb.c line 344
void async_addr_from_name_cancel(struct async_addr_from_name *self);
// async_addr_from_name_finish
// file async_netdb.c line 361
signed int async_addr_from_name_finish(struct async_addr_from_name *self, void *addr, unsigned int *addrlen, signed int *errno_error);
// async_addr_from_name_start
// file async_netdb.c line 315
struct async_addr_from_name * async_addr_from_name_start(struct _XDisplay *dpy, const char *hostname);
// async_name_from_addr_cancel
// file async_netdb.c line 182
void async_name_from_addr_cancel(struct async_name_from_addr *self);
// async_name_from_addr_finish
// file async_netdb.c line 197
signed int async_name_from_addr_finish(struct async_name_from_addr *self_raw, char **host, signed int *errno_error);
// async_name_from_addr_start
// file async_netdb.c line 141
struct async_name_from_addr * async_name_from_addr_start(struct _XDisplay *dpy, struct sockaddr *addr, unsigned int addrlen);
// atan2
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 60
extern double atan2(double, double);
// atom_size
// file molecule.c line 361
static float atom_size(const struct anonymous_33 *a);
// axis_to_quat
// file trackball.c line 213
static void axis_to_quat(float *a, float phi, float *q);
// bitmap_to_texture
// file texfont.c line 108
static void bitmap_to_texture(struct _XDisplay *dpy, unsigned long int p, struct anonymous_16 *visual, signed int depth, signed int *wP, signed int *hP);
// build_molecule
// file molecule.c line 541
static void build_molecule(struct ModeInfo *mi, signed int transparent_p);
// build_rotmatrix
// file trackball.c line 309
void build_rotmatrix(float (*m)[4l], float *q);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// ceil
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 178
extern double ceil(double);
// check_gl_error
// file xlock-gl-utils.c line 161
extern void check_gl_error(const char *type);
// clear_gl_error
// file xlock-gl-utils.c line 153
extern void clear_gl_error(void);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// cmp_atoms
// file molecule.c line 935
static signed int cmp_atoms(const void *aa, const void *bb);
// complain
// file colors.c line 79
static void complain(signed int wanted_colors, signed int got_colors, signed int wanted_writable, signed int got_writable);
// cone
// file tube.c line 395
extern signed int cone(float x1, float y1, float z1, float x2, float y2, float z2, float diameter, float cap_size, signed int faces, signed int smooth, signed int cap_p, signed int wire_p);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// describe_gl_visual
// file visual-gl.c line 116
extern void describe_gl_visual(struct _IO_FILE *f, struct anonymous_15 *screen, struct anonymous_16 *visual, signed int private_cmap_p);
// describe_visual
// file visual.c line 445
extern void describe_visual(struct _IO_FILE *f, struct anonymous_15 *screen, struct anonymous_16 *visual, signed int private_cmap_p);
// draw_bounding_box
// file molecule.c line 436
static void draw_bounding_box(struct ModeInfo *mi);
// draw_labels
// file molecule.c line 1361
static void draw_labels(struct ModeInfo *mi);
// draw_molecule
// file molecule.c line 1534
static void draw_molecule(struct ModeInfo *mi);
// enable_texture_string_parameters
// file texfont.c line 576
void enable_texture_string_parameters(void);
// ensure_bounding_box_visible
// file molecule.c line 500
static void ensure_bounding_box_visible(struct ModeInfo *mi);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// find_similar_visual
// file visual.c line 503
extern struct anonymous_16 * find_similar_visual(struct anonymous_15 *screen, struct anonymous_16 *old_visual);
// fix_fds
// file screenhack.c line 403
static void fix_fds(void);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fps_compute
// file fps.h line 25
extern double fps_compute(struct fps_state *st, unsigned long int polys, double depth);
// fps_draw
// file fps.h line 26
extern void fps_draw(struct fps_state *st);
// fps_free
// file fps.h line 23
extern void fps_free(struct fps_state *st);
// fps_init
// file fps.h line 22
extern struct fps_state * fps_init(struct _XDisplay *dpy, unsigned long int window);
// fps_slept
// file fps.h line 24
extern void fps_slept(struct fps_state *st, unsigned long int usecs);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_colors
// file colors.c line 25
extern void free_colors(struct anonymous_15 *screen, unsigned long int cmap, struct anonymous_27 *colors, signed int ncolors);
// free_rotator
// file rotator.c line 196
extern void free_rotator(struct rotator *r);
// free_texture_font
// file texfont.c line 925
extern void free_texture_font(struct texture_font_data *data);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// generate_molecule_formula
// file molecule.c line 951
static void generate_molecule_formula(struct anonymous_30 *m);
// get_atom
// file molecule.c line 371
static struct anonymous_33 * get_atom(struct anonymous_33 *atoms, signed int natoms, signed int id);
// get_atom_data
// file molecule.c line 273
static const struct anonymous_35 * get_atom_data(const char *atom_name);
// get_bits_per_pixel
// file visual.c line 545
extern signed int get_bits_per_pixel(struct _XDisplay *dpy, signed int depth);
// get_boolean_resource
// file ./../utils/resources.h line 16
extern signed int get_boolean_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_cache
// file texfont.c line 458
static struct texfont_cache * get_cache(struct texture_font_data *data, const char *string);
// get_float_resource
// file ./../../utils/resources.h line 18
extern double get_float_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_gl_visual
// file ./../../utils/visual.h line 29
extern struct anonymous_16 * get_gl_visual(struct anonymous_15 *screen);
// get_integer_resource
// file ./../utils/resources.h line 17
extern signed int get_integer_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_minutes_resource
// file resources.c line 261
extern unsigned int get_minutes_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_pixel_resource
// file ./../utils/resources.h line 19
extern unsigned int get_pixel_resource(struct _XDisplay *dpy, unsigned long int cmap, char *res_name, char *res_class);
// get_position
// file rotator.h line 53
extern void get_position(struct rotator *rot, double *x_ret, double *y_ret, double *z_ret, signed int update_p);
// get_rotation
// file rotator.h line 44
extern void get_rotation(struct rotator *rot, double *x_ret, double *y_ret, double *z_ret, signed int update_p);
// get_seconds_resource
// file resources.c line 255
extern unsigned int get_seconds_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_string_resource
// file ./../utils/resources.h line 15
extern char * get_string_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_time_resource
// file resources.c line 244
static unsigned int get_time_resource(struct _XDisplay *dpy, char *res_name, char *res_class, signed int sec_p);
// get_visual
// file visual.c line 50
extern struct anonymous_16 * get_visual(struct anonymous_15 *screen, const char *string, signed int prefer_writable_cells, signed int verbose_p);
// get_visual_resource
// file ./../utils/visual.h line 16
extern struct anonymous_16 * get_visual_resource(struct anonymous_15 *screen, char *name, char *class, signed int prefer_writable_cells);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyaddr
// file /usr/include/netdb.h line 137
extern struct hostent * gethostbyaddr(const void *, unsigned int, signed int);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpid
// file /usr/include/unistd.h line 631
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// glAlphaFunc
// file /usr/include/GL/gl.h line 758
void glAlphaFunc(unsigned int, float);
// glBegin
// file /usr/include/GL/gl.h line 929
void glBegin(unsigned int);
// glBindTexture
// file /usr/include/GL/gl.h line 1311
void glBindTexture(unsigned int, unsigned int);
// glBlendFunc
// file /usr/include/GL/gl.h line 760
void glBlendFunc(unsigned int, unsigned int);
// glCallList
// file /usr/include/GL/gl.h line 917
void glCallList(unsigned int);
// glClear
// file /usr/include/GL/gl.h line 752
void glClear(unsigned int);
// glClearColor
// file /usr/include/GL/gl.h line 750
void glClearColor(float, float, float, float);
// glClearIndex
// file /usr/include/GL/gl.h line 748
void glClearIndex(float);
// glColor3f
// file /usr/include/GL/gl.h line 992
void glColor3f(float, float, float);
// glColor4f
// file /usr/include/GL/gl.h line 1003
void glColor4f(float, float, float, float);
// glColor4fv
// file /usr/include/GL/gl.h line 1028
void glColor4fv(const float *);
// glColorMask
// file /usr/include/GL/gl.h line 756
void glColorMask(unsigned char, unsigned char, unsigned char, unsigned char);
// glDeleteTextures
// file /usr/include/GL/gl.h line 1309
void glDeleteTextures(signed int, const unsigned int *);
// glDepthFunc
// file /usr/include/GL/gl.h line 846
void glDepthFunc(unsigned int);
// glDisable
// file /usr/include/GL/gl.h line 798
void glDisable(unsigned int);
// glDrawArrays
// file /usr/include/GL/gl.h line 1145
void glDrawArrays(unsigned int, signed int, signed int);
// glDrawBuffer
// file /usr/include/GL/gl.h line 792
void glDrawBuffer(unsigned int);
// glEnable
// file /usr/include/GL/gl.h line 796
void glEnable(unsigned int);
// glEnableClientState
// file /usr/include/GL/gl.h line 803
void glEnableClientState(unsigned int);
// glEnd
// file /usr/include/GL/gl.h line 931
void glEnd(void);
// glEndList
// file /usr/include/GL/gl.h line 915
void glEndList(void);
// glFinish
// file /usr/include/GL/gl.h line 833
void glFinish(void);
// glFrontFace
// file /usr/include/GL/gl.h line 766
void glFrontFace(unsigned int);
// glGenLists
// file /usr/include/GL/gl.h line 911
unsigned int glGenLists(signed int);
// glGenTextures
// file /usr/include/GL/gl.h line 1307
void glGenTextures(signed int, unsigned int *);
// glGetBooleanv
// file /usr/include/GL/gl.h line 808
void glGetBooleanv(unsigned int, unsigned char *);
// glGetError
// file /usr/include/GL/gl.h line 829
unsigned int glGetError(void);
// glGetFloatv
// file /usr/include/GL/gl.h line 812
void glGetFloatv(unsigned int, float *);
// glGetIntegerv
// file /usr/include/GL/gl.h line 814
void glGetIntegerv(unsigned int, signed int *);
// glIndexi
// file /usr/include/GL/gl.h line 980
void glIndexi(signed int);
// glIsEnabled
// file /usr/include/GL/gl.h line 800
unsigned char glIsEnabled(unsigned int);
// glLightfv
// file /usr/include/GL/gl.h line 1161
void glLightfv(unsigned int, unsigned int, const float *);
// glLoadIdentity
// file /usr/include/GL/gl.h line 883
void glLoadIdentity(void);
// glMaterialfv
// file /usr/include/GL/gl.h line 1178
void glMaterialfv(unsigned int, unsigned int, const float *);
// glMatrixMode
// file /usr/include/GL/gl.h line 866
void glMatrixMode(unsigned int);
// glMultMatrixf
// file /usr/include/GL/gl.h line 889
void glMultMatrixf(const float *);
// glNewList
// file /usr/include/GL/gl.h line 913
void glNewList(unsigned int, unsigned int);
// glNormal3f
// file /usr/include/GL/gl.h line 967
void glNormal3f(float, float, float);
// glNormalPointer
// file /usr/include/GL/gl.h line 1127
void glNormalPointer(unsigned int, signed int, const void *);
// glOrtho
// file /usr/include/GL/gl.h line 868
void glOrtho(double, double, double, double, double, double);
// glPolygonMode
// file /usr/include/GL/gl.h line 774
void glPolygonMode(unsigned int, unsigned int);
// glPopMatrix
// file /usr/include/GL/gl.h line 881
void glPopMatrix(void);
// glPushMatrix
// file /usr/include/GL/gl.h line 879
void glPushMatrix(void);
// glRotatef
// file /usr/include/GL/gl.h line 893
void glRotatef(float, float, float, float);
// glScalef
// file /usr/include/GL/gl.h line 897
void glScalef(float, float, float);
// glTexCoord2f
// file /usr/include/GL/gl.h line 1042
void glTexCoord2f(float, float);
// glTexCoordPointer
// file /usr/include/GL/gl.h line 1136
void glTexCoordPointer(signed int, unsigned int, signed int, const void *);
// glTexImage2D
// file /usr/include/GL/gl.h line 1294
void glTexImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glTexParameterf
// file /usr/include/GL/gl.h line 1269
void glTexParameterf(unsigned int, unsigned int, float);
// glTexParameteri
// file /usr/include/GL/gl.h line 1270
void glTexParameteri(unsigned int, unsigned int, signed int);
// glTranslatef
// file /usr/include/GL/gl.h line 900
void glTranslatef(float, float, float);
// glVertex3f
// file /usr/include/GL/gl.h line 940
void glVertex3f(float, float, float);
// glVertexPointer
// file /usr/include/GL/gl.h line 1124
void glVertexPointer(signed int, unsigned int, signed int, const void *);
// glViewport
// file /usr/include/GL/gl.h line 876
void glViewport(signed int, signed int, signed int, signed int);
// glXChooseVisual
// file /usr/include/GL/glx.h line 187
extern struct anonymous_10 * glXChooseVisual(struct _XDisplay *, signed int, signed int *);
// glXCreateContext
// file /usr/include/GL/glx.h line 190
extern struct __GLXcontextRec * glXCreateContext(struct _XDisplay *, struct anonymous_10 *, struct __GLXcontextRec *, signed int);
// glXGetConfig
// file /usr/include/GL/glx.h line 214
extern signed int glXGetConfig(struct _XDisplay *, struct anonymous_10 *, signed int, signed int *);
// glXMakeCurrent
// file /usr/include/GL/glx.h line 195
extern signed int glXMakeCurrent(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *);
// glXSwapBuffers
// file /usr/include/GL/glx.h line 201
extern void glXSwapBuffers(struct _XDisplay *, unsigned long int);
// gl_init
// file molecule.c line 1204
static void gl_init(struct ModeInfo *mi);
// gltrackball_dampen
// file gltrackball.c line 193
static void gltrackball_dampen(double *n, double *dn);
// gltrackball_event_handler
// file gltrackball.h line 66
extern signed int gltrackball_event_handler(union _XEvent *event, struct trackball_state *ts, signed int window_width, signed int window_height, signed int *button_down_p);
// gltrackball_get_quaternion
// file gltrackball.c line 273
extern void gltrackball_get_quaternion(struct trackball_state *ts, float *q);
// gltrackball_init
// file gltrackball.h line 21
extern struct trackball_state * gltrackball_init(signed int ignore_device_rotation_p);
// gltrackball_mousewheel
// file gltrackball.c line 237
void gltrackball_mousewheel(struct trackball_state *ts, signed int button, signed int percent, signed int flip_p);
// gltrackball_reset
// file gltrackball.c line 77
extern void gltrackball_reset(struct trackball_state *ts);
// gltrackball_rotate
// file gltrackball.h line 42
extern void gltrackball_rotate(struct trackball_state *ts);
// gltrackball_start
// file gltrackball.c line 128
extern void gltrackball_start(struct trackball_state *ts, signed int x, signed int y, signed int w, signed int h);
// gltrackball_stop
// file gltrackball.c line 140
extern void gltrackball_stop(struct trackball_state *ts);
// gltrackball_track
// file gltrackball.c line 179
extern void gltrackball_track(struct trackball_state *ts, signed int x, signed int y, signed int w, signed int h);
// gltrackball_track_1
// file gltrackball.c line 146
static void gltrackball_track_1(struct trackball_state *ts, double x, double y, signed int w, signed int h);
// gluBuild2DMipmaps
// file /usr/include/GL/glu.h line 296
signed int gluBuild2DMipmaps(unsigned int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// gluLookAt
// file /usr/include/GL/glu.h line 314
void gluLookAt(double, double, double, double, double, double, double, double, double);
// gluPerspective
// file /usr/include/GL/glu.h line 327
void gluPerspective(double, double, double, double);
// hardware_concurrency
// file thread_util.c line 478
unsigned int hardware_concurrency(struct _XDisplay *dpy);
// has_writable_cells
// file ./../utils/visual.h line 25
extern signed int has_writable_cells(struct anonymous_15 *screen, struct anonymous_16 *visual);
// hsv_to_rgb
// file hsv.c line 20
extern void hsv_to_rgb(signed int h, double s, double v, unsigned short int *r, unsigned short int *g, unsigned short int *b);
// id_to_visual
// file visual.c line 340
extern struct anonymous_16 * id_to_visual(struct anonymous_15 *screen, signed int id);
// init_GL
// file ./../xlockmoreI.h line 61
extern struct __GLXcontextRec ** init_GL(struct ModeInfo *mi);
// init_molecule
// file molecule.c line 1274
static void init_molecule(struct ModeInfo *mi);
// init_window
// file screenhack.c line 675
static void init_window(struct _XDisplay *dpy, struct _WidgetRec *toplevel, const char *title);
// insert_vertical_whitespace
// file molecule.c line 1021
static void insert_vertical_whitespace(char *string);
// io_thread_cancel
// file thread_util.h line 406
signed int io_thread_cancel(struct io_thread *self);
// io_thread_create
// file thread_util.h line 380
void * io_thread_create(struct io_thread *self, void *parent, void * (*start_routine)(void *), struct _XDisplay *dpy, unsigned int stacksize);
// io_thread_create::start_routine_object
//
void * start_routine_object(void *);
// io_thread_finish
// file thread_util.h line 411
void io_thread_finish(struct io_thread *self);
// io_thread_is_done
// file thread_util.h line 403
signed int io_thread_is_done(struct io_thread *self);
// io_thread_return
// file thread_util.h line 399
signed int io_thread_return(struct io_thread *self);
// iterate_texture_string
// file texfont.c line 340
static void iterate_texture_string(struct texture_font_data *data, const char *s, signed int draw_x, signed int draw_y, struct _XftDraw *xftdraw, struct _XftColor *xftcolor, struct anonymous_38 *metrics_ret);
// load_fonts
// file molecule.c line 264
static void load_fonts(struct ModeInfo *mi);
// load_molecules
// file molecule.c line 1039
static void load_molecules(struct ModeInfo *mi);
// load_texture_font
// file texfont.h line 21
extern struct texture_font_data * load_texture_font(struct _XDisplay *dpy, char *res);
// make_color_loop
// file colors.c line 451
extern void make_color_loop(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, signed int h0, double s0, double v0, signed int h1, double s1, double v1, signed int h2, double s2, double v2, struct anonymous_27 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP);
// make_color_path
// file colors.c line 224
static void make_color_path(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, signed int npoints, signed int *h, double *s, double *v, struct anonymous_27 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP);
// make_color_ramp
// file colors.c line 99
extern void make_color_ramp(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, signed int h1, double s1, double v1, signed int h2, double s2, double v2, struct anonymous_27 *colors, signed int *ncolorsP, signed int closed_p, signed int allocate_p, signed int *writable_pP);
// make_random_colormap
// file ./../../utils/colors.h line 132
extern void make_random_colormap(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, struct anonymous_27 *colors, signed int *ncolorsP, signed int bright_p, signed int allocate_p, signed int *writable_pP, signed int verbose_p);
// make_rotator
// file rotator.h line 32
extern struct rotator * make_rotator(double spin_x_speed, double spin_y_speed, double spin_z_speed, double spin_accel, double wander_speed, signed int randomize_initial_state_p);
// make_shell
// file screenhack.c line 612
static struct _WidgetRec * make_shell(struct anonymous_15 *screen, struct _WidgetRec *toplevel, signed int width, signed int height);
// make_smooth_colormap
// file ./../../utils/colors.h line 88
extern void make_smooth_colormap(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, struct anonymous_27 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP, signed int verbose_p);
// make_uniform_colormap
// file ./../../utils/colors.h line 110
extern void make_uniform_colormap(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, struct anonymous_27 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP, signed int verbose_p);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// merge_options
// file screenhack.c line 182
static void merge_options(void);
// molecule_bounding_box
// file molecule.c line 396
static void molecule_bounding_box(struct ModeInfo *mi, float *x1, float *y1, float *z1, float *x2, float *y2, float *z2);
// molecule_handle_event
// file molecule.c line 1230
static signed int molecule_handle_event(struct ModeInfo *mi, union _XEvent *event);
// normalize_quat
// file trackball.c line 295
static void normalize_quat(float *q);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);

//

// parse_error
// file molecule.c line 680
static void parse_error(const char *file, signed int lineno, const char *line);
// parse_pdb_data
// file molecule.c line 691
static void parse_pdb_data(struct anonymous_30 *m, const char *data, const char *filename, signed int line);
// parse_pdb_file
// file molecule.c line 879
static signed int parse_pdb_file(struct anonymous_30 *m, const char *name);
// parse_time
// file resources.c line 203
extern signed int parse_time(const char *string, signed int seconds_default_p, signed int silent_p);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pick_best_gl_visual
// file visual.c line 281
static struct anonymous_16 * pick_best_gl_visual(struct anonymous_15 *screen);
// pick_best_visual
// file visual.c line 174
static struct anonymous_16 * pick_best_visual(struct anonymous_15 *screen, signed int prefer_writable_cells, signed int color_only);
// pick_best_visual_of_class
// file visual.c line 242
static struct anonymous_16 * pick_best_visual_of_class(struct anonymous_15 *screen, signed int visual_class);
// pick_mono_visual
// file visual.c line 218
static struct anonymous_16 * pick_mono_visual(struct anonymous_15 *screen);
// pick_new_molecule
// file molecule.c line 1440
static void pick_new_molecule(struct ModeInfo *mi, signed long int last);
// pick_visual
// file screenhack.c line 321
static struct anonymous_16 * pick_visual(struct anonymous_15 *screen);
// print_texture_label
// file texfont.h line 44
void print_texture_label(struct _XDisplay *dpy, struct texture_font_data *data, signed int window_width, signed int window_height, signed int position, const char *string);
// print_texture_string
// file texfont.h line 35
extern void print_texture_string(struct texture_font_data *data, const char *string);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 290
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 375
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 981
extern signed int pthread_cond_broadcast(union anonymous_7 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 973
extern signed int pthread_cond_destroy(union anonymous_7 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous_7 *, union anonymous_5 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 271
extern signed int pthread_detach(unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 250
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous_5 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous_5 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous_5 *);
// push_atom
// file molecule.c line 633
static void push_atom(struct anonymous_30 *m, signed int id, const char *label, float x, float y, float z);
// push_bond
// file molecule.c line 654
static void push_bond(struct anonymous_30 *m, signed int from, signed int to);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reshape_molecule
// file molecule.c line 1183
static void reshape_molecule(struct ModeInfo *mi, signed int width, signed int height);
// rgb_to_hsv
// file hsv.c line 52
extern void rgb_to_hsv(unsigned short int r, unsigned short int g, unsigned short int b, signed int *h, double *s, double *v);
// rotate_1
// file rotator.c line 45
static void rotate_1(double *pos, double *v, double *dv, double speed, double max_v);
// rotate_colors
// file colors.c line 711
extern void rotate_colors(struct anonymous_15 *screen, unsigned long int cmap, struct anonymous_27 *colors, signed int ncolors, signed int distance);
// run_screenhack_table
// file screenhack.c line 536
static void run_screenhack_table(struct _XDisplay *dpy, unsigned long int window, unsigned long int window2, struct xscreensaver_function_table *ft);

//


//

// screen_number
// file ./../../utils/visual.h line 21
extern signed int screen_number(struct anonymous_15 *screen);
// screenhack_do_fps
// file screenhack.c line 528
static void screenhack_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure);
// screenhack_ehandler
// file screenhack.c line 245
static signed int screenhack_ehandler(struct _XDisplay *dpy, struct anonymous_32 *error);
// screenhack_event_helper
// file ./../../utils/resources.h line 39
extern signed int screenhack_event_helper(struct _XDisplay *dpy, unsigned long int window, union _XEvent *event);
// screenhack_handle_event_1
// file screenhack.c line 270
static signed int screenhack_handle_event_1(struct _XDisplay *dpy, union _XEvent *event);
// screenhack_table_handle_events
// file screenhack.c line 433
static char screenhack_table_handle_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, void *closure, unsigned long int window2, void *closure2);
// screenhack_usleep
// file ./../utils/usleep.h line 23
extern void screenhack_usleep(unsigned long int usecs);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_36 *, struct anonymous_36 *, struct anonymous_36 *, struct timeval *);
// set_atom_color
// file molecule.c line 299
static void set_atom_color(struct ModeInfo *mi, const struct anonymous_33 *a, signed int font_p, float alpha);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// special_case_formula
// file molecule.c line 1007
static void special_case_formula(char *f);
// sphere
// file molecule.c line 247
static signed int sphere(struct anonymous_31 *mc, float x, float y, float z, float diameter, signed int wire);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// startup_blurb
// file molecule.c line 1218
static void startup_blurb(struct ModeInfo *mi);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 529
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// string_to_texture
// file texfont.c line 518
void string_to_texture(struct texture_font_data *data, const char *string, struct anonymous_38 *extents_ret, signed int *tex_width_ret, signed int *tex_height_ret);
// string_width
// file fps.c line 175
static signed int string_width(struct anonymous_1 *f, const char *c, signed int *height_ret);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strpbrk
// file /usr/include/string.h line 310
extern char * strpbrk(const char *, const char *);
// strrchr
// file /usr/include/string.h line 258
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// sysconf
// file /usr/include/unistd.h line 622
extern signed long int sysconf(signed int);
// tb_project_to_sphere
// file trackball.c line 226
static float tb_project_to_sphere(float r, float x, float y);
// texture_string_metrics
// file texfont.h line 26
extern void texture_string_metrics(struct texture_font_data *data, const char *s, struct anonymous_38 *metrics_ret, signed int *ascent_ret, signed int *descent_ret);
// thread_memory_alignment
// file thread_util.h line 112
unsigned int thread_memory_alignment(struct _XDisplay *dpy);
// threadpool_create
// file thread_util.c line 713
signed int threadpool_create(struct threadpool *self, struct threadpool_class *cls, struct _XDisplay *dpy, unsigned int count);
// threadpool_destroy
// file thread_util.c line 812
void threadpool_destroy(struct threadpool *self);
// threadpool_run
// file thread_util.c line 826
void threadpool_run(struct threadpool *self, void (*func)(void *));

//

// threadpool_wait
// file thread_util.c line 858
void threadpool_wait(struct threadpool *self);
// threads_available
// file thread_util.h line 93
signed int threads_available(struct _XDisplay *dpy);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// to_pow2
// file texfont.c line 87
static signed int to_pow2(signed int i);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// trackball
// file trackball.c line 167
void trackball(float *q, float p1x, float p1y, float p2x, float p2y);
// tube
// file tube.h line 19
extern signed int tube(float x1, float y1, float z1, float x2, float y2, float z2, float diameter, float cap_size, signed int faces, signed int smooth, signed int caps_p, signed int wire_p);
// tube_1
// file tube.c line 337
static signed int tube_1(float x1, float y1, float z1, float x2, float y2, float z2, float diameter, float cap_size, signed int faces, signed int smooth, signed int caps_p, signed int wire_p, signed int cone_p);
// uc_truncate
// file utf8wc.c line 38
static unsigned long int uc_truncate(unsigned long int uc);
// unit_cone
// file tube.c line 199
static signed int unit_cone(signed int faces, signed int smooth, signed int cap_p, signed int wire_p);
// unit_dome
// file sphere.c line 152
extern signed int unit_dome(signed int stacks, signed int slices, signed int wire_p);
// unit_sphere
// file sphere.h line 21
extern signed int unit_sphere(signed int stacks, signed int slices, signed int wire_p);
// unit_sphere_1
// file sphere.c line 43
static signed int unit_sphere_1(signed int stacks, signed int slices, signed int wire_p, signed int half_p);
// unit_tube
// file tube.c line 38
static signed int unit_tube(signed int faces, signed int smooth, signed int caps_p, signed int wire_p);
// usleep_and_process_events
// file screenhack.c line 481
static char usleep_and_process_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, struct fps_state *fpst, void *closure, unsigned long int delay, unsigned long int window2, struct fps_state *fpst2, void *closure2, unsigned long int delay2);
// utf8_decode
// file utf8wc.c line 56
extern signed long int utf8_decode(const unsigned char *in, signed long int length, unsigned long int *unicode_ret);
// utf8_encode
// file utf8wc.c line 160
extern signed int utf8_encode(unsigned long int uc, char *out, signed long int length);
// utf8_split
// file utf8wc.c line 256
extern char ** utf8_split(const char *string, signed int *length_ret);
// utf8_to_XChar2b
// file utf8wc.c line 215
extern struct anonymous_13 * utf8_to_XChar2b(const char *string, signed int *length_ret);
// utf8_to_latin1
// file utf8wc.c line 347
extern char * utf8_to_latin1(const char *string, signed int ascii_p);
// vadd
// file trackball.c line 147
static void vadd(const float *src1, const float *src2, float *dst);
// validate_gl_visual
// file ./../../utils/visual.h line 31
extern signed int validate_gl_visual(struct _IO_FILE *out, struct anonymous_15 *screen, const char *window_desc, struct anonymous_16 *visual);
// vcopy
// file trackball.c line 102
static void vcopy(const float *v1, float *v2);
// vcross
// file trackball.c line 110
static void vcross(const float *v1, const float *v2, float *cross);
// vdot
// file trackball.c line 141
static float vdot(const float *v1, const float *v2);
// visual_cells
// file visual.c line 487
extern signed int visual_cells(struct anonymous_15 *screen, struct anonymous_16 *visual);
// visual_class
// file visual.c line 409
extern signed int visual_class(struct anonymous_15 *screen, struct anonymous_16 *visual);
// visual_depth
// file ./../utils/visual.h line 17
extern signed int visual_depth(struct anonymous_15 *screen, struct anonymous_16 *visual);
// visual_warning
// file screenhack.c line 341
static void visual_warning(struct anonymous_15 *screen, unsigned long int window, struct anonymous_16 *visual, unsigned long int cmap, signed int window_p);
// vlength
// file trackball.c line 121
static float vlength(const float *v);
// vnormal
// file trackball.c line 135
static void vnormal(float *v);
// vscale
// file trackball.c line 127
static void vscale(float *v, float div);
// vset
// file trackball.c line 86
static void vset(float *v, float x, float y, float z);
// vsub
// file trackball.c line 94
static void vsub(const float *src1, const float *src2, float *dst);
// vzero
// file trackball.c line 78
static void vzero(float *v);
// xlockmore_do_fps
// file ./../xlockmore.c line 533
extern void xlockmore_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure);
// xlockmore_draw
// file ./../xlockmore.c line 495
static unsigned long int xlockmore_draw(struct _XDisplay *dpy, unsigned long int window, void *closure);
// xlockmore_event
// file ./../xlockmore.c line 523
static signed int xlockmore_event(struct _XDisplay *dpy, unsigned long int window, void *closure, union _XEvent *event);
// xlockmore_free
// file ./../xlockmore.c line 542
static void xlockmore_free(struct _XDisplay *dpy, unsigned long int window, void *closure);
// xlockmore_gl_compute_fps
// file ./../xlockmoreI.h line 74
extern void xlockmore_gl_compute_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure);
// xlockmore_gl_draw_fps
// file ./../xlockmoreI.h line 75
extern void xlockmore_gl_draw_fps(struct ModeInfo *mi);
// xlockmore_gl_fps_init
// file fps-gl.c line 46
static void xlockmore_gl_fps_init(struct fps_state *st);
// xlockmore_init
// file ./../xlockmore.c line 278
static void * xlockmore_init(struct _XDisplay *dpy, unsigned long int window, struct xlockmore_function_table *xlmft);
// xlockmore_pick_gl_visual
// file ./../xlockmoreI.h line 66
extern struct anonymous_16 * xlockmore_pick_gl_visual(struct anonymous_15 *screen);
// xlockmore_read_resources
// file ./../xlockmore.c line 239
static void xlockmore_read_resources(struct ModeInfo *mi);
// xlockmore_reshape
// file ./../xlockmore.c line 511
static void xlockmore_reshape(struct _XDisplay *dpy, unsigned long int window, void *closure, unsigned int w, unsigned int h);
// xlockmore_setup
// file ./../xlockmoreI.h line 79
extern void xlockmore_setup(struct xscreensaver_function_table *xsft, void *arg);
// xlockmore_validate_gl_visual
// file ./../xlockmoreI.h line 67
extern signed int xlockmore_validate_gl_visual(struct anonymous_15 *screen, const char *name, struct anonymous_16 *visual);
// ya_rand_init
// file ./../utils/yarandom.h line 37
extern void ya_rand_init(unsigned int seed);
// ya_random
// file ./../../utils/yarandom.h line 36
extern unsigned int ya_random(void);

struct anonymous_31
{
  // glx_context
  struct __GLXcontextRec **glx_context;
  // rot
  struct rotator *rot;
  // trackball
  struct trackball_state *trackball;
  // button_down_p
  signed int button_down_p;
  // molecule_size
  float molecule_size;
  // no_label_threshold
  float no_label_threshold;
  // wireframe_threshold
  float wireframe_threshold;
  // which
  signed int which;
  // nmolecules
  signed int nmolecules;
  // molecules
  struct anonymous_30 *molecules;
  // mode
  signed int mode;
  // mode_tick
  signed int mode_tick;
  // next
  signed int next;
  // molecule_dlist
  unsigned int molecule_dlist;
  // shell_dlist
  unsigned int shell_dlist;
  // atom_font
  struct texture_font_data *atom_font;
  // title_font
  struct texture_font_data *title_font;
  // polygon_count
  signed int polygon_count;
  // draw_time
  signed long int draw_time;
  // draw_tick
  signed int draw_tick;
  // overall_scale
  float overall_scale;
  // low_rez_p
  signed int low_rez_p;
};

struct anonymous_37
{
  // atom
  char *atom;
  // count
  signed int count;
};

struct anonymous_23
{
  // name
  char *name;
  // value
  signed long int value;
};

struct anonymous_0
{
  // opt
  char *opt;
  // desc
  char *desc;
};

struct anonymous_18
{
  // option
  char *option;
  // specifier
  char *specifier;
  // argKind
  enum anonymous_19 argKind;
  // value
  char *value;
};

struct anonymous_10
{
  // visual
  struct anonymous_16 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous_15
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous_2 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous_16 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous_42
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous_40 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous_15 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous_40
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_38
{
  // lbearing
  signed short int lbearing;
  // rbearing
  signed short int rbearing;
  // width
  signed short int width;
  // ascent
  signed short int ascent;
  // descent
  signed short int descent;
  // attributes
  unsigned short int attributes;
};

struct anonymous_1
{
  // ext_data
  struct _XExtData *ext_data;
  // fid
  unsigned long int fid;
  // direction
  unsigned int direction;
  // min_char_or_byte2
  unsigned int min_char_or_byte2;
  // max_char_or_byte2
  unsigned int max_char_or_byte2;
  // min_byte1
  unsigned int min_byte1;
  // max_byte1
  unsigned int max_byte1;
  // all_chars_exist
  signed int all_chars_exist;
  // default_char
  unsigned int default_char;
  // n_properties
  signed int n_properties;
  // properties
  struct anonymous_4 *properties;
  // min_bounds
  struct anonymous_38 min_bounds;
  // max_bounds
  struct anonymous_38 max_bounds;
  // per_char
  struct anonymous_38 *per_char;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct anonymous_16
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous_22
{
  // texfont
  struct texture_font_data *texfont;
  // line_height
  signed int line_height;
  // top_p
  signed int top_p;
};

struct anonymous
{
  // var
  void *var;
  // name
  char *name;
  // classname
  char *classname;
  // def
  char *def;
  // type
  enum anonymous_20 type;
};

struct anonymous_30
{
  // label
  const char *label;
  // natoms
  signed int natoms;
  // atoms_size
  signed int atoms_size;
  // nbonds
  signed int nbonds;
  // bonds_size
  signed int bonds_size;
  // atoms
  struct anonymous_33 *atoms;
  // bonds
  struct anonymous_34 *bonds;
};

struct anonymous_35
{
  // name
  const char *name;
  // size
  float size;
  // size2
  float size2;
  // color
  const char *color;
  // text_color
  const char *text_color;
  // gl_color
  float gl_color[8l];
};

struct anonymous_36
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_9
{
  // x
  float x;
  // y
  float y;
  // z
  float z;
};

struct anonymous_14
{
  // x
  signed short int x;
  // y
  signed short int y;
};

struct anonymous_6
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_28
{
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_2
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous_16 *visuals;
};

struct anonymous_34
{
  // from
  signed int from;
  // to
  signed int to;
  // strength
  signed int strength;
};

struct anonymous_8
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous_33
{
  // id
  signed int id;
  // label
  const char *label;
  // x
  float x;
  // y
  float y;
  // z
  float z;
  // data
  const struct anonymous_35 *data;
};

struct anonymous_44
{
  // numopts
  signed int numopts;
  // opts
  struct anonymous_18 *opts;
  // numvarsdesc
  signed int numvarsdesc;
  // vars
  struct anonymous *vars;
  // desc
  struct anonymous_0 *desc;
};

struct anonymous_32
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous_75
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous_76
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous_53
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_52
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_56
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous_57
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous_58
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_65
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_62
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous_61
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_60
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_69
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_59
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous_66
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_55
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_64
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous_70
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_45
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous_74
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous_50
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous_73
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous_54
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous_63
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous_51
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous_67
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous_71
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous_3
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous_72
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous_3 data;
};

struct anonymous_49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous_48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous_47
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous_46
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous_68
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous_17
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // depth
  signed int depth;
  // visual
  struct anonymous_16 *visual;
  // root
  unsigned long int root;
  // class
  signed int class;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // colormap
  unsigned long int colormap;
  // map_installed
  signed int map_installed;
  // map_state
  signed int map_state;
  // all_event_masks
  signed long int all_event_masks;
  // your_event_mask
  signed long int your_event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // screen
  struct anonymous_15 *screen;
};

struct anonymous_12
{
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // alpha
  unsigned short int alpha;
};

struct anonymous_21
{
  // request_mode
  unsigned int request_mode;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // border_width
  unsigned short int border_width;
  // sibling
  struct _WidgetRec *sibling;
  // stack_mode
  signed int stack_mode;
};

struct anonymous_24
{
  // size
  unsigned int size;
  // addr
  char *addr;
};

struct anonymous_39
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous_4
{
  // name
  unsigned long int name;
  // card32
  unsigned long int card32;
};

struct anonymous_27
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

struct anonymous_29
{
  // shmseg
  unsigned long int shmseg;
  // shmid
  signed int shmid;
  // shmaddr
  char *shmaddr;
  // readOnly
  signed int readOnly;
};

struct anonymous_13
{
  // byte1
  unsigned char byte1;
  // byte2
  unsigned char byte2;
};

union anonymous_41
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_7
{
  // __data
  struct anonymous_6 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_5
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ModeInfo
{
  // xlmft
  struct xlockmore_function_table *xlmft;
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // root_p
  signed int root_p;
  // num_screens
  signed int num_screens;
  // screen_number
  signed int screen_number;
  // npixels
  signed int npixels;
  // pixels
  unsigned long int *pixels;
  // colors
  struct anonymous_27 *colors;
  // writable_p
  signed int writable_p;
  // white
  unsigned long int white;
  // black
  unsigned long int black;
  // xgwa
  struct anonymous_17 xgwa;
  // gc
  struct _XGC *gc;
  // pause
  signed long int pause;
  // fullrandom
  signed int fullrandom;
  // cycles
  signed long int cycles;
  // batchcount
  signed long int batchcount;
  // size
  signed long int size;
  // threed
  signed int threed;
  // threed_left_color
  signed long int threed_left_color;
  // threed_right_color
  signed long int threed_right_color;
  // threed_both_color
  signed long int threed_both_color;
  // threed_none_color
  signed long int threed_none_color;
  // threed_delta
  signed long int threed_delta;
  // wireframe_p
  signed int wireframe_p;
  // is_drawn
  signed int is_drawn;
  // fpst
  struct fps_state *fpst;
  // fps_p
  signed int fps_p;
  // polygon_count
  unsigned long int polygon_count;
  // recursion_depth
  double recursion_depth;
  // use_shm
  signed int use_shm;
  // shm_info
  struct anonymous_29 shm_info;
};

struct _CoreClassPart
{
  // superclass
  struct _WidgetClassRec *superclass;
  // class_name
  char *class_name;
  // widget_size
  unsigned int widget_size;
  // class_initialize
  void (*class_initialize)(void);
  // class_part_initialize
  void (*class_part_initialize)(struct _WidgetClassRec *);
  // class_inited
  unsigned char class_inited;
  // initialize
  void (*initialize)(struct _WidgetRec *, struct _WidgetRec *, struct anonymous_23 *, unsigned int *);
  // initialize_hook
  void (*initialize_hook)(struct _WidgetRec *, struct anonymous_23 *, unsigned int *);
  // realize
  void (*realize)(struct _WidgetRec *, unsigned long int *, struct anonymous_39 *);
  // actions
  struct _XtActionsRec *actions;
  // num_actions
  unsigned int num_actions;
  // resources
  struct _XtResource *resources;
  // num_resources
  unsigned int num_resources;
  // xrm_class
  signed int xrm_class;
  // compress_motion
  char compress_motion;
  // compress_exposure
  unsigned char compress_exposure;
  // compress_enterleave
  char compress_enterleave;
  // visible_interest
  char visible_interest;
  // destroy
  void (*destroy)(struct _WidgetRec *);
  // resize
  void (*resize)(struct _WidgetRec *);
  // expose
  void (*expose)(struct _WidgetRec *, union _XEvent *, struct _XRegion *);
  // set_values
  char (*set_values)(struct _WidgetRec *, struct _WidgetRec *, struct _WidgetRec *, struct anonymous_23 *, unsigned int *);
  // set_values_hook
  char (*set_values_hook)(struct _WidgetRec *, struct anonymous_23 *, unsigned int *);
  // set_values_almost
  void (*set_values_almost)(struct _WidgetRec *, struct _WidgetRec *, struct anonymous_21 *, struct anonymous_21 *);
  // get_values_hook
  void (*get_values_hook)(struct _WidgetRec *, struct anonymous_23 *, unsigned int *);
  // accept_focus
  char (*accept_focus)(struct _WidgetRec *, unsigned long int *);
  // version
  unsigned long int version;
  // callback_private
  void *callback_private;
  // tm_table
  char *tm_table;
  // query_geometry
  enum anonymous_25 (*query_geometry)(struct _WidgetRec *, struct anonymous_21 *, struct anonymous_21 *);
  // display_accelerator
  void (*display_accelerator)(struct _WidgetRec *, char *);
  // extension
  void *extension;
};

struct _XtTMRec
{
  // translations
  struct _TranslationData *translations;
  // proc_table
  void (**proc_table)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
  // current_state
  struct _XtStateRec *current_state;
  // lastEventTime
  unsigned long int lastEventTime;
};

struct _CorePart
{
  // self
  struct _WidgetRec *self;
  // widget_class
  struct _WidgetClassRec *widget_class;
  // parent
  struct _WidgetRec *parent;
  // xrm_name
  signed int xrm_name;
  // being_destroyed
  char being_destroyed;
  // destroy_callbacks
  struct _XtCallbackRec *destroy_callbacks;
  // constraints
  void *constraints;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // border_width
  unsigned short int border_width;
  // managed
  char managed;
  // sensitive
  char sensitive;
  // ancestor_sensitive
  char ancestor_sensitive;
  // event_table
  struct _XtEventRec *event_table;
  // tm
  struct _XtTMRec tm;
  // accelerators
  struct _TranslationData *accelerators;
  // border_pixel
  unsigned long int border_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // popup_list
  struct _WidgetRec **popup_list;
  // num_popups
  unsigned int num_popups;
  // name
  char *name;
  // screen
  struct anonymous_15 *screen;
  // colormap
  unsigned long int colormap;
  // window
  unsigned long int window;
  // depth
  unsigned int depth;
  // background_pixel
  unsigned long int background_pixel;
  // background_pixmap
  unsigned long int background_pixmap;
  // visible
  char visible;
  // mapped_when_managed
  char mapped_when_managed;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _WidgetClassRec
{
  // core_class
  struct _CoreClassPart core_class;
};

struct _WidgetRec
{
  // core
  struct _CorePart core;
};

struct _XComposeStatus
{
  // compose_ptr
  char *compose_ptr;
  // chars_matched
  signed int chars_matched;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous_45 xany;
  // xkey
  struct anonymous_46 xkey;
  // xbutton
  struct anonymous_47 xbutton;
  // xmotion
  struct anonymous_48 xmotion;
  // xcrossing
  struct anonymous_49 xcrossing;
  // xfocus
  struct anonymous_50 xfocus;
  // xexpose
  struct anonymous_51 xexpose;
  // xgraphicsexpose
  struct anonymous_52 xgraphicsexpose;
  // xnoexpose
  struct anonymous_53 xnoexpose;
  // xvisibility
  struct anonymous_54 xvisibility;
  // xcreatewindow
  struct anonymous_55 xcreatewindow;
  // xdestroywindow
  struct anonymous_56 xdestroywindow;
  // xunmap
  struct anonymous_57 xunmap;
  // xmap
  struct anonymous_58 xmap;
  // xmaprequest
  struct anonymous_59 xmaprequest;
  // xreparent
  struct anonymous_60 xreparent;
  // xconfigure
  struct anonymous_61 xconfigure;
  // xgravity
  struct anonymous_62 xgravity;
  // xresizerequest
  struct anonymous_63 xresizerequest;
  // xconfigurerequest
  struct anonymous_64 xconfigurerequest;
  // xcirculate
  struct anonymous_65 xcirculate;
  // xcirculaterequest
  struct anonymous_66 xcirculaterequest;
  // xproperty
  struct anonymous_67 xproperty;
  // xselectionclear
  struct anonymous_68 xselectionclear;
  // xselectionrequest
  struct anonymous_69 xselectionrequest;
  // xselection
  struct anonymous_70 xselection;
  // xcolormap
  struct anonymous_71 xcolormap;
  // xclient
  struct anonymous_72 xclient;
  // xmapping
  struct anonymous_73 xmapping;
  // xerror
  struct anonymous_32 xerror;
  // xkeymap
  struct anonymous_74 xkeymap;
  // xgeneric
  struct anonymous_75 xgeneric;
  // xcookie
  struct anonymous_76 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct _XGlyphInfo
{
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // x
  signed short int x;
  // y
  signed short int y;
  // xOff
  signed short int xOff;
  // yOff
  signed short int yOff;
};

struct funcs
{
  // create_image
  struct _XImage * (*create_image)(struct _XDisplay *, struct anonymous_16 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
  // destroy_image
  signed int (*destroy_image)(struct _XImage *);
  // get_pixel
  unsigned long int (*get_pixel)(struct _XImage *, signed int, signed int);
  // put_pixel
  signed int (*put_pixel)(struct _XImage *, signed int, signed int, unsigned long int);
  // sub_image
  struct _XImage * (*sub_image)(struct _XImage *, signed int, signed int, unsigned int, unsigned int);
  // add_pixel
  signed int (*add_pixel)(struct _XImage *, signed long int);
};

struct _XImage
{
  // width
  signed int width;
  // height
  signed int height;
  // xoffset
  signed int xoffset;
  // format
  signed int format;
  // data
  char *data;
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // bitmap_pad
  signed int bitmap_pad;
  // depth
  signed int depth;
  // bytes_per_line
  signed int bytes_per_line;
  // bits_per_pixel
  signed int bits_per_pixel;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // obdata
  char *obdata;
  // f
  struct funcs f;
};

struct _XftColor
{
  // pixel
  unsigned long int pixel;
  // color
  struct anonymous_12 color;
};

struct _XftFont
{
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // height
  signed int height;
  // max_advance_width
  signed int max_advance_width;
  // charset
  struct _FcCharSet *charset;
  // pattern
  struct _FcPattern *pattern;
};

struct _XtActionsRec
{
  // string
  char *string;
  // proc
  void (*proc)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
};

struct _XtCallbackRec
{
  // callback
  void (*callback)(struct _WidgetRec *, void *, void *);
  // closure
  void *closure;
};

struct _XtResource
{
  // resource_name
  char *resource_name;
  // resource_class
  char *resource_class;
  // resource_type
  char *resource_type;
  // resource_size
  unsigned int resource_size;
  // resource_offset
  unsigned int resource_offset;
  // default_type
  char *default_type;
  // default_addr
  void *default_addr;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct _async_name_from_addr_param
{
  // addrlen
  unsigned int addrlen;
  // addr
  struct sockaddr_storage addr;
};

struct _parallel_startup_type
{
  // parent
  struct threadpool *parent;
  // thread_create
  signed int (*thread_create)(void *, struct threadpool *, unsigned int);
  // last_errno
  signed int last_errno;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct io_thread
{
  // status
  enum _io_thread_status status;
  // thread
  unsigned long int thread;
};

struct async_addr_from_name
{
  // io
  struct io_thread io;
  // gai_error
  signed int gai_error;
  // errno_error
  signed int errno_error;
  // res
  struct addrinfo *res;
};

struct async_name_from_addr
{
  // param
  struct _async_name_from_addr_param param;
  // io
  struct io_thread io;
  // host
  char host[1025l];
  // gai_error
  signed int gai_error;
  // errno_error
  signed int errno_error;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct fps_state
{
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // font
  struct anonymous_1 *font;
  // clear_p
  signed int clear_p;
  // string
  char string[1024l];
  // gl_fps_data
  void *gl_fps_data;
  // draw_gc
  struct _XGC *draw_gc;
  // erase_gc
  struct _XGC *erase_gc;
  // last_ifps
  signed int last_ifps;
  // last_fps
  double last_fps;
  // frame_count
  signed int frame_count;
  // slept
  unsigned long int slept;
  // prev_frame_end
  struct timeval prev_frame_end;
  // this_frame_end
  struct timeval this_frame_end;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous_41 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rotator
{
  // spin_x_speed
  double spin_x_speed;
  // spin_y_speed
  double spin_y_speed;
  // spin_z_speed
  double spin_z_speed;
  // wander_speed
  double wander_speed;
  // rotx
  double rotx;
  // roty
  double roty;
  // rotz
  double rotz;
  // dx
  double dx;
  // dy
  double dy;
  // dz
  double dz;
  // ddx
  double ddx;
  // ddy
  double ddy;
  // ddz
  double ddz;
  // d_max
  double d_max;
  // wander_frame
  signed int wander_frame;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct texfont_cache
{
  // string
  char *string;
  // texid
  unsigned int texid;
  // extents
  struct anonymous_38 extents;
  // tex_width
  signed int tex_width;
  // tex_height
  signed int tex_height;
  // next
  struct texfont_cache *next;
};

struct texture_font_data
{
  // dpy
  struct _XDisplay *dpy;
  // xftfont
  struct _XftFont *xftfont;
  // cache_size
  signed int cache_size;
  // cache
  struct texfont_cache *cache;
};

struct threadpool
{
  // count
  unsigned int count;
  // thread_size
  unsigned long int thread_size;
  // thread_run
  void (*thread_run)(void *);
  // thread_destroy
  void (*thread_destroy)(void *);
  // serial_threads
  void *serial_threads;
  // mutex
  union anonymous_5 mutex;
  // cond
  union anonymous_7 cond;
  // parallel_pending
  unsigned int parallel_pending;
  // parallel_unfinished
  unsigned int parallel_unfinished;
  // parallel_threads
  unsigned long int *parallel_threads;
};

struct threadpool_class
{
  // size
  unsigned long int size;
  // create
  signed int (*create)(void *, struct threadpool *, unsigned int);
  // destroy
  void (*destroy)(void *);
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct trackball_state
{
  // ow
  signed int ow;
  // oh
  signed int oh;
  // x
  double x;
  // y
  double y;
  // dx
  double dx;
  // dy
  double dy;
  // ddx
  double ddx;
  // ddy
  double ddy;
  // q
  float q[4l];
  // button_down_p
  signed int button_down_p;
  // ignore_device_rotation_p
  signed int ignore_device_rotation_p;
};

struct xlockmore_function_table
{
  // progclass
  const char *progclass;
  // defaults
  const char *defaults;
  // want_writable_colors
  signed int want_writable_colors;
  // desired_color_scheme
  enum anonymous_43 desired_color_scheme;
  // hack_init
  void (*hack_init)(struct ModeInfo *);
  // hack_draw
  void (*hack_draw)(struct ModeInfo *);
  // hack_reshape
  void (*hack_reshape)(struct ModeInfo *, signed int, signed int);
  // hack_refresh
  void (*hack_refresh)(struct ModeInfo *);
  // hack_free
  void (*hack_free)(struct ModeInfo *);
  // hack_handle_events
  signed int (*hack_handle_events)(struct ModeInfo *, union _XEvent *);
  // opts
  struct anonymous_44 *opts;
  // screen_count
  unsigned int screen_count;
};

struct xscreensaver_function_table
{
  // progclass
  const char *progclass;
  // defaults
  const char * const *defaults;
  // options
  const struct anonymous_18 *options;
  // setup_cb
  void (*setup_cb)(struct xscreensaver_function_table *, void *);
  // setup_arg
  void *setup_arg;
  // init_cb
  void * (*init_cb)(struct _XDisplay *, unsigned long int);
  // draw_cb
  unsigned long int (*draw_cb)(struct _XDisplay *, unsigned long int, void *);
  // reshape_cb
  void (*reshape_cb)(struct _XDisplay *, unsigned long int, void *, unsigned int, unsigned int);
  // event_cb
  signed int (*event_cb)(struct _XDisplay *, unsigned long int, void *, union _XEvent *);
  // free_cb
  void (*free_cb)(struct _XDisplay *, unsigned long int, void *);
  // fps_cb
  void (*fps_cb)(struct _XDisplay *, unsigned long int, struct fps_state *, void *);
  // pick_visual_hook
  struct anonymous_16 * (*pick_visual_hook)(struct anonymous_15 *);
  // validate_visual_hook
  signed int (*validate_visual_hook)(struct anonymous_15 *, const char *, struct anonymous_16 *);
};


// XA_WM_DELETE_WINDOW
// file screenhack.c line 263
static unsigned long int XA_WM_DELETE_WINDOW;
// XA_WM_PROTOCOLS
// file screenhack.c line 263
static unsigned long int XA_WM_PROTOCOLS;
// XtShellStrings
// file /usr/include/X11/Shell.h line 189
extern const char XtShellStrings[];
// XtStrings
// file /usr/include/X11/StringDefs.h line 316
extern const char XtStrings[];
// _cache_line_size
// file thread_util.c line 288
static signed int _cache_line_size = (signed int)sizeof(void *) /*8ul*/ ;
// _has_pthread
// file thread_util.c line 287
static signed int _has_pthread = 0;
// _has_threads
// file async_netdb.c line 37
static signed int _has_threads;
// a
// file yarandom.c line 73
static unsigned int a[55l] = { 035340171546, (unsigned int)010401501101, 022364657325, 024130436022, (unsigned int)002167303062, 037570375137, 037210607110, (unsigned int)016272055420, 023011770546, (unsigned int)017143426366, (unsigned int)014753657433, 021657231332, 023553406142, (unsigned int)004236526362, (unsigned int)010365611275, (unsigned int)007117336710, (unsigned int)011051276551, (unsigned int)002362132524, (unsigned int)001011540233, (unsigned int)012162531646, (unsigned int)007056762337, (unsigned int)006631245521, (unsigned int)014164542224, 032633236305, 023342700176, (unsigned int)002433062234, (unsigned int)015257225043, 026762051606, (unsigned int)000742573230, (unsigned int)005366042132, (unsigned int)012126416411, (unsigned int)000520471171, (unsigned int)000725646277, 020116577576, 025765742604, (unsigned int)007633473735, (unsigned int)015674255275, (unsigned int)017555634041, (unsigned int)006503154145, 021576344247, (unsigned int)014577627653, (unsigned int)002707523333, 034146376720, 030060227734, (unsigned int)013765414060, 036072251540, (unsigned int)007255221037, 024364674123, (unsigned int)006200353166, (unsigned int)010126373326, (unsigned int)015664104320, (unsigned int)016401041535, (unsigned int)016215305520, 033115351014, (unsigned int)017411670323 };
// all_atom_data
// file molecule.c line 111
static const struct anonymous_35 all_atom_data[9l] = { { .name="H", .size=(float)1.17, .size2=(float)0.40, .color="#FFFFFF",
    .text_color="#000000", .gl_color={ (float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f } },
    { .name="C", .size=(float)1.75, .size2=(float)0.58, .color="#999999",
    .text_color="#FFFFFF", .gl_color={ (float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f } },
    { .name="CA", .size=(float)1.80, .size2=(float)0.60, .color="#0000FF",
    .text_color="#ADD8E6", .gl_color={ (float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f } },
    { .name="N", .size=(float)1.55, .size2=(float)0.52, .color="#A2B5CD",
    .text_color="#EE99FF", .gl_color={ (float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f } },
    { .name="O", .size=(float)1.40, .size2=(float)0.47, .color="#FF0000",
    .text_color="#FFB6C1", .gl_color={ (float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f } },
    { .name="P", .size=(float)1.28, .size2=(float)0.43, .color="#9370DB",
    .text_color="#DB7093", .gl_color={ (float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f } },
    { .name="S", .size=(float)1.80, .size2=(float)0.60, .color="#8B8B00",
    .text_color="#FFFF00", .gl_color={ (float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f } },
    { .name="bond", .size=(float)0, .size2=(float)0, .color="#B3B3B3",
    .text_color="#FFFF00", .gl_color={ (float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f } },
    { .name="*", .size=(float)1.40, .size2=(float)0.47, .color="#008B00",
    .text_color="#90EE90", .gl_color={ (float)0, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f } } };
// builtin_pdb_data
// file molecule.c line 89
static const char * const builtin_pdb_data[38l] = { "HEADER    Adenine: Vitamin B4; Purine base nucleotide\nCOMPND    jb09aden\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Mon Sep 18 15:35:27 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.394   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.084   1.211   0.000  1.00  0.00 \nHETATM    4  N           1       1.337   2.342  -0.002  1.00  0.00 \nHETATM    5  C           1      -0.017   2.313  -0.003  1.00  0.00 \nHETATM    6  N           1      -0.710   1.149  -0.001  1.00  0.00 \nHETATM    7  N           1      -0.391  -1.291   0.006  1.00  0.00 \nHETATM    8  C           1       0.731  -2.049   0.010  1.00  0.00 \nHETATM    9  N           1       1.843  -1.276   0.007  1.00  0.00 \nHETATM   10  N           1       3.485   1.257   0.004  1.00  0.00 \nHETATM   11  H           1      -0.567   3.254  -0.004  1.00  0.00 \nHETATM   12  H           1      -1.347  -1.630   0.010  1.00  0.00 \nHETATM   13  H           1       0.738  -3.139   0.017  1.00  0.00 \nHETATM   14  H           1       3.799   2.220  -0.037  1.00  0.00 \nHETATM   15  H           1       3.839   0.818   0.847  1.00  0.00 \nCONECT    1    2    2    6    7\nCONECT    2    1    1    3    9\nCONECT    3    2    4    4   10\nCONECT    4    3    3    5\nCONECT    5    4    6    6   11\nCONECT    6    1    5    5\nCONECT    7    1    8   12\nCONECT    8    7    9    9   13\nCONECT    9    2    8    8\nCONECT   10    3   14   15\nCONECT   11    5\nCONECT   12    7\nCONECT   13    8\nCONECT   14   10\nCONECT   15   10\nMASTER        0    0    0    0    0    0    0    0   15    0   15    0\nEND\n",
    "HEADER    Adrenochrome: a nerve cell transmission inhibitor, and hallucinogen\nCOMPND    adrenochrome\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Tue Aug 29 08:56:34 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.400   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.056   1.235   0.000  1.00  0.00 \nHETATM    4  C           1       1.351   2.436  -0.011  1.00  0.00 \nHETATM    5  C           1      -0.047   2.437  -0.027  1.00  0.00 \nHETATM    6  C           1      -0.714   1.206  -0.013  1.00  0.00 \nHETATM    7  O           1      -0.597  -1.046  -0.002  1.00  0.00 \nHETATM    8  O           1      -1.918   1.181  -0.023  1.00  0.00 \nHETATM    9  N           1       2.243   3.571  -0.065  1.00  0.00 \nHETATM   10  C           1       1.825   4.648   0.846  1.00  0.00 \nHETATM   11  C           1       3.553   3.011   0.321  1.00  0.00 \nHETATM   12  C           1       3.538   1.506  -0.050  1.00  0.00 \nHETATM   13  H           1       4.088   0.906   0.675  1.00  0.00 \nHETATM   14  O           1       4.023   1.295  -1.381  1.00  0.00 \nHETATM   15  H           1       1.962  -0.934  -0.006  1.00  0.00 \nHETATM   16  H           1      -0.608   3.370  -0.059  1.00  0.00 \nHETATM   17  H           1       1.674   4.250   1.849  1.00  0.00 \nHETATM   18  H           1       0.895   5.089   0.489  1.00  0.00 \nHETATM   19  H           1       2.596   5.418   0.873  1.00  0.00 \nHETATM   20  H           1       3.683   3.101   1.400  1.00  0.00 \nHETATM   21  H           1       4.364   3.531  -0.190  1.00  0.00 \nHETATM   22  H           1       4.963   1.501  -1.423  1.00  0.00 \nCONECT    1    2    6    7\nCONECT    1    7\nCONECT    2    1    3   15\nCONECT    2    3\nCONECT    3    2    4   12\nCONECT    4    3    5    9\nCONECT    4    5\nCONECT    5    4    6   16\nCONECT    6    1    5    8\nCONECT    6    8\nCONECT    7    1\nCONECT    8    6\nCONECT    9    4   10   11\nCONECT   10    9   17   18   19\nCONECT   11    9   12   20   21\nCONECT   12    3   11   13   14\nCONECT   13   12\nCONECT   14   12   22\nCONECT   15    2\nCONECT   16    5\nCONECT   17   10\nCONECT   18   10\nCONECT   19   10\nCONECT   20   11\nCONECT   21   11\nCONECT   22   14\nMASTER        0    0    0    0    0    0    0    0   22    0   22    0\nEND\n",
    "HEADER    Buckminsterfullerine: Bucky Ball\nCOMPND    bucky\nAUTHOR\nGENERATED BY SYMAPPS 1.0\nATOM      1  C                   0.994   0.523  -3.137\nATOM      2  C                   0.418  -0.689  -3.232\nATOM      3  C                   1.239  -1.587  -2.654\nATOM      4  C                   2.172   0.376  -2.500\nATOM      5  C                   2.323  -0.928  -2.202\nATOM      6  C                   1.297  -2.968  -0.779\nATOM      7  C                   0.727  -2.610  -1.946\nATOM      8  C                  -0.608  -2.733  -1.813\nATOM      9  C                  -0.863  -3.172  -0.565\nATOM     10  C                   0.315  -3.321   0.074\nATOM     11  C                  -1.429  -1.836  -2.393\nATOM     12  C                  -0.916  -0.814  -3.106\nATOM     13  C                  -1.675   0.277  -2.878\nATOM     14  C                  -2.657  -0.070  -2.024\nATOM     15  C                  -2.506  -1.376  -1.724\nATOM     16  C                  -1.096   1.488  -2.779\nATOM     17  C                   0.239   1.614  -2.915\nATOM     18  C                   0.658   2.557  -2.049\nATOM     19  C                  -0.417   3.018  -1.381\nATOM     20  C                  -1.503   2.359  -1.834\nATOM     21  C                   1.833   2.405  -1.409\nATOM     22  C                   2.596   1.319  -1.640\nATOM     23  C                   3.167   0.957  -0.474\nATOM     24  C                   2.760   1.823   0.475\nATOM     25  C                   1.935   2.717  -0.104\nATOM     26  C                   3.314  -0.348  -0.175\nATOM     27  C                   2.899  -1.293  -1.041\nATOM     28  C                   2.384  -2.314  -0.328\nATOM     29  C                   2.486  -2.003   0.979\nATOM     30  C                   3.063  -0.788   1.074\nATOM     31  C                  -2.321   0.938   2.198\nATOM     32  C                  -1.237   1.597   2.651\nATOM     33  C                  -0.417   0.699   3.231\nATOM     34  C                  -2.170  -0.366   2.497\nATOM     35  C                  -0.993  -0.514   3.135\nATOM     36  C                   1.671  -0.268   2.871\nATOM     37  C                   0.916   0.824   3.104\nATOM     38  C                   1.430   1.846   2.390\nATOM     39  C                   2.506   1.386   1.722\nATOM     40  C                   2.653   0.079   2.018\nATOM     41  C                   0.609   2.745   1.813\nATOM     42  C                  -0.727   2.622   1.945\nATOM     43  C                  -1.298   2.984   0.779\nATOM     44  C                  -0.315   3.332  -0.075\nATOM     45  C                   0.863   3.183   0.564\nATOM     46  C                  -2.378   2.321   0.325\nATOM     47  C                  -2.896   1.302   1.038\nATOM     48  C                  -3.315   0.358   0.172\nATOM     49  C                  -3.062   0.797  -1.076\nATOM     50  C                  -2.485   2.012  -0.982\nATOM     51  C                  -3.159  -0.945   0.470\nATOM     52  C                  -2.593  -1.310   1.637\nATOM     53  C                  -1.837  -2.402   1.409\nATOM     54  C                  -1.939  -2.714   0.103\nATOM     55  C                  -2.759  -1.815  -0.477\nATOM     56  C                  -0.658  -2.546   2.045\nATOM     57  C                  -0.238  -1.605   2.914\nATOM     58  C                   1.097  -1.482   2.780\nATOM     59  C                   1.503  -2.349   1.832\nATOM     60  C                   0.418  -3.010   1.379\nCONECT   21   25\nCONECT   26   27\nCONECT    2    3\nCONECT    1    4\nCONECT    7    8\nCONECT    8    9\nCONECT    9   10\nCONECT   27   28\nCONECT   28   29\nCONECT   29   30\nCONECT   26   30\nCONECT    6   10\nCONECT   11   12\nCONECT    3    7\nCONECT    8   11\nCONECT    3    5\nCONECT    1   17\nCONECT    5   27\nCONECT   12   13\nCONECT   13   14\nCONECT   14   15\nCONECT   11   15\nCONECT   16   17\nCONECT    6   28\nCONECT    4    5\nCONECT   18   21\nCONECT    1    2\nCONECT    4   22\nCONECT   17   18\nCONECT   18   19\nCONECT   19   20\nCONECT   16   20\nCONECT   21   22\nCONECT   23   26\nCONECT    6    7\nCONECT    2   12\nCONECT   13   16\nCONECT   22   23\nCONECT   23   24\nCONECT   24   25\nCONECT   36   40\nCONECT   41   42\nCONECT   33   37\nCONECT   38   41\nCONECT   33   35\nCONECT   31   47\nCONECT   35   57\nCONECT   42   43\nCONECT   43   44\nCONECT   44   45\nCONECT   41   45\nCONECT   46   47\nCONECT   36   58\nCONECT   34   35\nCONECT   48   51\nCONECT   31   32\nCONECT   34   52\nCONECT   47   48\nCONECT   48   49\nCONECT   49   50\nCONECT   46   50\nCONECT   51   52\nCONECT   53   56\nCONECT   36   37\nCONECT   32   42\nCONECT   43   46\nCONECT   52   53\nCONECT   53   54\nCONECT   54   55\nCONECT   51   55\nCONECT   56   57\nCONECT   32   33\nCONECT   31   34\nCONECT   37   38\nCONECT   38   39\nCONECT   39   40\nCONECT   57   58\nCONECT   58   59\nCONECT   59   60\nCONECT   56   60\nCONECT   10   60\nCONECT   29   59\nCONECT   30   40\nCONECT   24   39\nCONECT    9   54\nCONECT   15   55\nCONECT   14   49\nCONECT   20   50\nCONECT   19   44\nCONECT   25   45\nMASTER        0    0    0    0    0    0    0    0   60    0    0    0\nEND\n",
    "HEADER    Caffeine: Trimethylxanthine; a cardiac stimulant and diuretic\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep 29 14:53:27 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.392   0.000   0.000  1.00  0.00 \nHETATM    3  N           1       2.076   1.164   0.000  1.00  0.00 \nHETATM    4  C           1       1.373   2.321  -0.003  1.00  0.00 \nHETATM    5  O           1       1.978   3.365  -0.017  1.00  0.00 \nHETATM    6  N           1       0.017   2.344   0.003  1.00  0.00 \nHETATM    7  C           1      -0.710   1.202   0.002  1.00  0.00 \nHETATM    8  O           1      -1.915   1.218  -0.006  1.00  0.00 \nHETATM    9  N           1      -0.404  -1.287  -0.019  1.00  0.00 \nHETATM   10  N           1       1.830  -1.279  -0.020  1.00  0.00 \nHETATM   11  C           1       0.715  -2.048  -0.031  1.00  0.00 \nHETATM   12  C           1      -1.795  -1.761  -0.044  1.00  0.00 \nHETATM   13  C           1       3.546   1.178  -0.016  1.00  0.00 \nHETATM   14  C           1      -0.690   3.634  -0.013  1.00  0.00 \nHETATM   15  H           1       0.720  -3.138  -0.055  1.00  0.00 \nHETATM   16  H           1      -1.813  -2.850  -0.090  1.00  0.00 \nHETATM   17  H           1      -2.307  -1.428   0.860  1.00  0.00 \nHETATM   18  H           1      -2.302  -1.352  -0.918  1.00  0.00 \nHETATM   19  H           1       3.894   1.455  -1.011  1.00  0.00 \nHETATM   20  H           1       3.929   0.190   0.239  1.00  0.00 \nHETATM   21  H           1       3.911   1.904   0.710  1.00  0.00 \nHETATM   22  H           1      -1.557   3.583   0.645  1.00  0.00 \nHETATM   23  H           1      -0.027   4.428   0.329  1.00  0.00 \nHETATM   24  H           1      -1.020   3.851  -1.029  1.00  0.00 \nCONECT    1    2    2    7    9\nCONECT    2    1    1    3   10\nCONECT    3    2    4   13\nCONECT    4    3    5    5    6\nCONECT    5    4    4\nCONECT    6    4    7   14\nCONECT    7    1    6    8    8\nCONECT    8    7    7\nCONECT    9    1   11   12\nCONECT   10    2   11   11\nCONECT   11    9   10   10   15\nCONECT   12    9   16   17   18\nCONECT   13    3   19   20   21\nCONECT   14    6   22   23   24\nCONECT   15   11\nCONECT   16   12\nCONECT   17   12\nCONECT   18   12\nCONECT   19   13\nCONECT   20   13\nCONECT   21   13\nCONECT   22   14\nCONECT   23   14\nCONECT   24   14\nMASTER        0    0    0    0    0    0    0    0   24    0   24    0\nEND\n",
    "HEADER    Capsaicin: 8-methyl-N-vanillyl-6-nonenamide; Pepper; a mucous membrane irritant\nAUTHOR    Marvin\nREVDAT   1   05-MAY-09         0                                  \nHETATM    1  C   UNK     0       3.607  -1.127   0.361  0.00  0.00           C+0\nHETATM    2  C   UNK     0       4.334   0.075   0.158  0.00  0.00           C+0\nHETATM    3  C   UNK     0       3.650   1.279  -0.101  0.00  0.00           C+0\nHETATM    4  C   UNK     0       2.246   1.299  -0.172  0.00  0.00           C+0\nHETATM    5  C   UNK     0       1.494   0.118   0.015  0.00  0.00           C+0\nHETATM    6  C   UNK     0       2.190  -1.085   0.285  0.00  0.00           C+0\nHETATM    7  O   UNK     0       4.263  -2.208   0.588  0.00  0.00           O+0\nHETATM    8  O   UNK     0       5.598   0.109   0.186  0.00  0.00           O+0\nHETATM    9  C   UNK     0       3.863  -3.458   0.839  0.00  0.00           C+0\nHETATM   10  C   UNK     0       0.011   0.136  -0.126  0.00  0.00           C+0\nHETATM   11  N   UNK     0      -0.660  -0.367   0.987  0.00  0.00           N+0\nHETATM   12  C   UNK     0      -2.024  -0.105   1.237  0.00  0.00           C+0\nHETATM   13  C   UNK     0      -2.604  -0.886   2.327  0.00  0.00           C+0\nHETATM   14  O   UNK     0      -2.896   0.656   0.691  0.00  0.00           O+0\nHETATM   15  C   UNK     0      -3.159  -0.033   3.504  0.00  0.00           C+0\nHETATM   16  C   UNK     0      -3.849  -0.911   4.584  0.00  0.00           C+0\nHETATM   17  C   UNK     0      -4.419  -0.081   5.764  0.00  0.00           C+0\nHETATM   18  C   UNK     0      -5.132  -0.923   6.711  0.00  0.00           C+0\nHETATM   19  C   UNK     0      -4.516  -1.628   7.675  0.00  0.00           C+0\nHETATM   20  C   UNK     0      -5.206  -2.525   8.600  0.00  0.00           C+0\nHETATM   21  C   UNK     0      -4.662  -3.972   8.454  0.00  0.00           C+0\nHETATM   22  C   UNK     0      -5.081  -2.006  10.057  0.00  0.00           C+0\nCONECT    1    2    6    7                                                  \nCONECT    2    1    3    8                                                  \nCONECT    3    2    4                                                       \nCONECT    4    3    5                                                       \nCONECT    5    4    6   10                                                  \nCONECT    6    5    1                                                       \nCONECT    7    1    9                                                       \nCONECT    8    2                                                            \nCONECT    9    7                                                            \nCONECT   10    5   11                                                       \nCONECT   11   10   12                                                       \nCONECT   12   11   13   14                                                  \nCONECT   13   12   15                                                       \nCONECT   14   12                                                            \nCONECT   15   13   16                                                       \nCONECT   16   15   17                                                       \nCONECT   17   16   18                                                       \nCONECT   18   17   19                                                       \nCONECT   19   18   20                                                       \nCONECT   20   19   21   22                                                  \nCONECT   21   20                                                            \nCONECT   22   20                                                            \nMASTER        0    0    0    0    0    0    0    0   22    0   44    0\nEND\n",
    "HEADER    Chlordecone: Kepone, an insecticide and fungicide\nCOMPND    al1113\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Tue Aug 29 17:54:52 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  O           1       1.206   0.000   0.000  1.00  0.00 \nHETATM    3  C           1      -0.741   1.303   0.000  1.00  0.00 \nHETATM    4  C           1      -0.875   1.738  -1.482  1.00  0.00 \nHETATM    5  C           1      -0.879   0.377  -2.249  1.00  0.00 \nHETATM    6  C           1      -0.745  -0.666  -1.117  1.00  0.00 \nHETATM    7  C           1      -2.247   0.958  -0.112  1.00  0.00 \nHETATM    8  C           1      -2.380   1.999  -1.247  1.00  0.00 \nHETATM    9  C           1      -2.237  -0.385  -0.887  1.00  0.00 \nHETATM   10  C           1      -2.379   0.045  -2.350  1.00  0.00 \nHETATM   11  C           1      -3.162   1.358  -2.394  1.00  0.00 \nHETATM   12 Cl           1       0.142   3.061  -2.080  1.00  0.00 \nHETATM   13 Cl           1      -0.299   2.574   1.159  1.00  0.00 \nHETATM   14 Cl           1      -2.803   3.653  -0.734  1.00  0.00 \nHETATM   15 Cl           1      -3.272   1.132   1.330  1.00  0.00 \nHETATM   16 Cl           1      -3.275  -1.723  -0.285  1.00  0.00 \nHETATM   17 Cl           1      -4.883   1.128  -1.986  1.00  0.00 \nHETATM   18 Cl           1      -2.936   2.229  -3.931  1.00  0.00 \nHETATM   19 Cl           1      -2.805  -1.246  -3.509  1.00  0.00 \nHETATM   20 Cl           1       0.141   0.211  -3.696  1.00  0.00 \nHETATM   21 Cl           1      -0.301  -2.317  -1.612  1.00  0.00 \nCONECT    1    2    2    3    6\nCONECT    2    1    1\nCONECT    3    1    4    7   13\nCONECT    4    3    5    8   12\nCONECT    5    4    6   10   20\nCONECT    6    1    5    9   21\nCONECT    7    3    8    9   15\nCONECT    8    4    7   11   14\nCONECT    9    6    7   10   16\nCONECT   10    5    9   11   19\nCONECT   11    8   10   17   18\nCONECT   12    4\nCONECT   13    3\nCONECT   14    8\nCONECT   15    7\nCONECT   16    9\nCONECT   17   11\nCONECT   18   11\nCONECT   19   10\nCONECT   20    5\nCONECT   21    6\nMASTER        0    0    0    0    0    0    0    0   21    0   21    0\nEND\n",
    "HEADER    Cocaine: Carboxylicacid methyl ester, an anesthetic\nCOMPND    al3078\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Aug 30 12:33:12 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.399   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.099   1.211   0.000  1.00  0.00 \nHETATM    4  C           1       1.400   2.423  -0.002  1.00  0.00 \nHETATM    5  C           1       0.001   2.423  -0.007  1.00  0.00 \nHETATM    6  C           1      -0.700   1.213  -0.005  1.00  0.00 \nHETATM    7  C           1      -2.156   1.218  -0.022  1.00  0.00 \nHETATM    8  O           1      -2.759   0.175  -0.044  1.00  0.00 \nHETATM    9  O           1      -2.806   2.379  -0.075  1.00  0.00 \nHETATM   10  C           1      -4.168   2.239   0.272  1.00  0.00 \nHETATM   11  C           1      -4.872   3.590   0.031  1.00  0.00 \nHETATM   12  C           1      -4.061   4.678   0.674  1.00  0.00 \nHETATM   13  O           1      -4.560   5.346   1.542  1.00  0.00 \nHETATM   14  O           1      -2.741   4.690   0.497  1.00  0.00 \nHETATM   15  C           1      -2.091   5.352   1.560  1.00  0.00 \nHETATM   16  C           1      -6.281   3.587   0.659  1.00  0.00 \nHETATM   17  N           1      -6.101   3.424   2.109  1.00  0.00 \nHETATM   18  C           1      -7.084   2.348   0.212  1.00  0.00 \nHETATM   19  C           1      -6.737   1.277   1.267  1.00  0.00 \nHETATM   20  C           1      -5.765   1.998   2.226  1.00  0.00 \nHETATM   21  C           1      -4.304   1.831   1.755  1.00  0.00 \nHETATM   22  C           1      -7.322   3.768   2.857  1.00  0.00 \nHETATM   23  H           1      -0.544  -0.944  -0.002  1.00  0.00 \nHETATM   24  H           1       1.944  -0.944   0.000  1.00  0.00 \nHETATM   25  H           1       3.189   1.211   0.001  1.00  0.00 \nHETATM   26  H           1       1.945   3.367  -0.004  1.00  0.00 \nHETATM   27  H           1      -0.544   3.368  -0.019  1.00  0.00 \nHETATM   28  H           1      -4.624   1.481  -0.363  1.00  0.00 \nHETATM   29  H           1      -4.942   3.777  -1.041  1.00  0.00 \nHETATM   30  H           1      -2.425   6.389   1.609  1.00  0.00 \nHETATM   31  H           1      -2.320   4.851   2.501  1.00  0.00 \nHETATM   32  H           1      -1.014   5.330   1.395  1.00  0.00 \nHETATM   33  H           1      -6.802   4.513   0.416  1.00  0.00 \nHETATM   34  H           1      -6.806   2.035  -0.795  1.00  0.00 \nHETATM   35  H           1      -8.152   2.564   0.250  1.00  0.00 \nHETATM   36  H           1      -6.275   0.397   0.819  1.00  0.00 \nHETATM   37  H           1      -7.641   0.988   1.803  1.00  0.00 \nHETATM   38  H           1      -5.872   1.638   3.249  1.00  0.00 \nHETATM   39  H           1      -3.995   0.793   1.881  1.00  0.00 \nHETATM   40  H           1      -3.664   2.470   2.364  1.00  0.00 \nHETATM   41  H           1      -8.166   3.167   2.523  1.00  0.00 \nHETATM   42  H           1      -7.551   4.823   2.706  1.00  0.00 \nHETATM   43  H           1      -7.155   3.591   3.920  1.00  0.00 \nCONECT    1    2    2    6   23\nCONECT    2    1    1    3   24\nCONECT    3    2    4    4   25\nCONECT    4    3    3    5   26\nCONECT    5    4    6    6   27\nCONECT    6    1    5    5    7\nCONECT    7    6    8    8    9\nCONECT    8    7    7\nCONECT    9    7   10\nCONECT   10    9   11   21   28\nCONECT   11   10   12   16   29\nCONECT   12   11   13   13   14\nCONECT   13   12   12\nCONECT   14   12   15\nCONECT   15   14   30   31   32\nCONECT   16   11   17   18   33\nCONECT   17   16   20   22\nCONECT   18   16   19   34   35\nCONECT   19   18   20   36   37\nCONECT   20   17   19   21   38\nCONECT   21   10   20   39   40\nCONECT   22   17   41   42   43\nCONECT   23    1\nCONECT   24    2\nCONECT   25    3\nCONECT   26    4\nCONECT   27    5\nCONECT   28   10\nCONECT   29   11\nCONECT   30   15\nCONECT   31   15\nCONECT   32   15\nCONECT   33   16\nCONECT   34   18\nCONECT   35   18\nCONECT   36   19\nCONECT   37   19\nCONECT   38   20\nCONECT   39   21\nCONECT   40   21\nCONECT   41   22\nCONECT   42   22\nCONECT   43   22\nMASTER        0    0    0    0    0    0    0    0   43    0   43    0\nEND\n",
    "HEADER    Methylmorphine: Codeine, a cough reflex inhibitor\nCOMPND    al3083\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Aug 30 12:33:12 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.400   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.107   1.211   0.000  1.00  0.00 \nHETATM    4  C           1       1.445   2.445  -0.038  1.00  0.00 \nHETATM    5  C           1       0.048   2.457   0.012  1.00  0.00 \nHETATM    6  C           1      -0.629   1.242   0.047  1.00  0.00 \nHETATM    7  C           1      -2.076   1.497  -0.256  1.00  0.00 \nHETATM    8  C           1      -2.718   0.335  -1.023  1.00  0.00 \nHETATM    9  C           1      -2.362  -0.955  -0.251  1.00  0.00 \nHETATM   10  C           1      -0.830  -1.234  -0.281  1.00  0.00 \nHETATM   11  C           1      -1.864   2.827  -1.015  1.00  0.00 \nHETATM   12  C           1      -2.785   1.642   1.099  1.00  0.00 \nHETATM   13  C           1      -2.549   0.335   1.888  1.00  0.00 \nHETATM   14  N           1      -2.944  -0.846   1.100  1.00  0.00 \nHETATM   15  C           1      -2.815  -2.080   1.892  1.00  0.00 \nHETATM   16  H           1      -3.800   0.464  -1.011  1.00  0.00 \nHETATM   17  C           1      -2.286   0.268  -2.470  1.00  0.00 \nHETATM   18  C           1      -2.002   1.392  -3.142  1.00  0.00 \nHETATM   19  C           1      -1.354   2.572  -2.453  1.00  0.00 \nHETATM   20  H           1      -2.774   3.428  -1.022  1.00  0.00 \nHETATM   21  O           1      -0.789   3.474  -0.352  1.00  0.00 \nHETATM   22  H           1      -1.514   3.472  -3.047  1.00  0.00 \nHETATM   23  O           1       0.051   2.305  -2.404  1.00  0.00 \nHETATM   24  O           1       2.148   3.606  -0.170  1.00  0.00 \nHETATM   25  H           1       1.942  -0.944  -0.064  1.00  0.00 \nHETATM   26  H           1       3.196   1.191  -0.044  1.00  0.00 \nHETATM   27  H           1      -2.856  -1.789  -0.750  1.00  0.00 \nHETATM   28  H           1      -0.570  -1.581  -1.281  1.00  0.00 \nHETATM   29  H           1      -0.575  -2.018   0.429  1.00  0.00 \nHETATM   30  H           1      -3.852   1.800   0.945  1.00  0.00 \nHETATM   31  H           1      -2.368   2.484   1.653  1.00  0.00 \nHETATM   32  H           1      -3.143   0.370   2.801  1.00  0.00 \nHETATM   33  H           1      -1.498   0.252   2.165  1.00  0.00 \nHETATM   34  H           1      -3.495  -2.034   2.743  1.00  0.00 \nHETATM   35  H           1      -1.796  -2.189   2.261  1.00  0.00 \nHETATM   36  H           1      -3.075  -2.943   1.279  1.00  0.00 \nHETATM   37  H           1      -2.526  -0.630  -3.039  1.00  0.00 \nHETATM   38  H           1      -1.938   1.338  -4.229  1.00  0.00 \nHETATM   39  H           1       0.396   2.184  -3.295  1.00  0.00 \nHETATM   40  C           1       2.068   4.090  -1.493  1.00  0.00 \nHETATM   41  H           1       2.413   3.325  -2.189  1.00  0.00 \nHETATM   42  H           1       1.038   4.360  -1.728  1.00  0.00 \nHETATM   43  H           1       2.699   4.974  -1.590  1.00  0.00 \nCONECT    1    2    2    6   10\nCONECT    2    1    1    3   25\nCONECT    3    2    4    4   26\nCONECT    4    3    3    5   24\nCONECT    5    4    6    6   21\nCONECT    6    1    5    5    7\nCONECT    7    6    8   11   12\nCONECT    8    7    9   16   17\nCONECT    9    8   10   14   27\nCONECT   10    1    9   28   29\nCONECT   11    7   19   20   21\nCONECT   12    7   13   30   31\nCONECT   13   12   14   32   33\nCONECT   14    9   13   15\nCONECT   15   14   34   35   36\nCONECT   16    8\nCONECT   17    8   18   18   37\nCONECT   18   17   17   19   38\nCONECT   19   11   18   22   23\nCONECT   20   11\nCONECT   21    5   11\nCONECT   22   19\nCONECT   23   19   39\nCONECT   24    4   40\nCONECT   25    2\nCONECT   26    3\nCONECT   27    9\nCONECT   28   10\nCONECT   29   10\nCONECT   30   12\nCONECT   31   12\nCONECT   32   13\nCONECT   33   13\nCONECT   34   15\nCONECT   35   15\nCONECT   36   15\nCONECT   37   17\nCONECT   38   18\nCONECT   39   23\nCONECT   40   24   41   42   43\nCONECT   41   40\nCONECT   42   40\nCONECT   43   40\nMASTER        0    0    0    0    0    0    0    0   43    0   43    0\nEND\n",
    "HEADER    Cyclohexane: 1,2,3,4,5,6-hexaisopropylcyclohexane\nCOMPND    al3063\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Sun Sep  3 10:20:00 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.565   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.185   1.436   0.000  1.00  0.00 \nHETATM    4  C           1       1.565   2.409   1.058  1.00  0.00 \nHETATM    5  C           1       0.011   2.333   1.199  1.00  0.00 \nHETATM    6  C           1      -0.636   0.914   1.102  1.00  0.00 \nHETATM    7  C           1       2.238  -0.920   1.062  1.00  0.00 \nHETATM    8  C           1       3.676  -1.279   0.632  1.00  0.00 \nHETATM    9  C           1       1.540  -2.282   1.218  1.00  0.00 \nHETATM   10  C           1       2.217   2.309   2.471  1.00  0.00 \nHETATM   11  C           1       1.987   3.605   3.278  1.00  0.00 \nHETATM   12  C           1       3.745   2.126   2.455  1.00  0.00 \nHETATM   13  C           1      -0.726   0.166   2.473  1.00  0.00 \nHETATM   14  C           1      -1.806  -0.942   2.413  1.00  0.00 \nHETATM   15  C           1      -1.162   1.048   3.662  1.00  0.00 \nHETATM   16  C           1      -0.814   3.472   0.513  1.00  0.00 \nHETATM   17  C           1      -0.477   3.821  -0.947  1.00  0.00 \nHETATM   18  C           1      -0.663   4.782   1.320  1.00  0.00 \nHETATM   19  C           1      -0.573   0.185  -1.439  1.00  0.00 \nHETATM   20  C           1      -2.077   0.514  -1.474  1.00  0.00 \nHETATM   21  C           1      -0.420  -1.124  -2.240  1.00  0.00 \nHETATM   22  C           1       2.365   2.070  -1.423  1.00  0.00 \nHETATM   23  C           1       3.380   3.248  -1.378  1.00  0.00 \nHETATM   24  C           1       2.947   1.067  -2.454  1.00  0.00 \nHETATM   25  H           1      -0.308  -1.011   0.219  1.00  0.00 \nHETATM   26  H           1       1.866  -0.481  -0.919  1.00  0.00 \nHETATM   27  H           1       3.219   1.312   0.276  1.00  0.00 \nHETATM   28  H           1       1.800   3.418   0.741  1.00  0.00 \nHETATM   29  H           1      -0.171   2.602   2.221  1.00  0.00 \nHETATM   30  H           1      -1.683   1.071   0.864  1.00  0.00 \nHETATM   31  H           1       2.274  -0.432   2.031  1.00  0.00 \nHETATM   32  H           1       4.296  -0.395   0.523  1.00  0.00 \nHETATM   33  H           1       3.659  -1.819  -0.314  1.00  0.00 \nHETATM   34  H           1       4.129  -1.913   1.395  1.00  0.00 \nHETATM   35  H           1       1.366  -2.731   0.241  1.00  0.00 \nHETATM   36  H           1       0.598  -2.162   1.743  1.00  0.00 \nHETATM   37  H           1       2.167  -2.946   1.814  1.00  0.00 \nHETATM   38  H           1       1.784   1.476   3.021  1.00  0.00 \nHETATM   39  H           1       0.931   3.795   3.446  1.00  0.00 \nHETATM   40  H           1       2.426   4.454   2.754  1.00  0.00 \nHETATM   41  H           1       2.462   3.505   4.254  1.00  0.00 \nHETATM   42  H           1       4.206   2.819   1.750  1.00  0.00 \nHETATM   43  H           1       3.992   1.100   2.194  1.00  0.00 \nHETATM   44  H           1       4.144   2.311   3.452  1.00  0.00 \nHETATM   45  H           1       0.232  -0.273   2.732  1.00  0.00 \nHETATM   46  H           1      -1.609  -1.663   1.627  1.00  0.00 \nHETATM   47  H           1      -2.784  -0.492   2.238  1.00  0.00 \nHETATM   48  H           1      -1.828  -1.479   3.361  1.00  0.00 \nHETATM   49  H           1      -1.986   1.697   3.365  1.00  0.00 \nHETATM   50  H           1      -0.323   1.642   4.019  1.00  0.00 \nHETATM   51  H           1      -1.487   0.415   4.488  1.00  0.00 \nHETATM   52  H           1      -1.870   3.206   0.555  1.00  0.00 \nHETATM   53  H           1      -0.618   2.957  -1.586  1.00  0.00 \nHETATM   54  H           1       0.544   4.192  -1.014  1.00  0.00 \nHETATM   55  H           1      -1.151   4.606  -1.289  1.00  0.00 \nHETATM   56  H           1       0.380   5.094   1.338  1.00  0.00 \nHETATM   57  H           1      -1.015   4.632   2.341  1.00  0.00 \nHETATM   58  H           1      -1.262   5.567   0.860  1.00  0.00 \nHETATM   59  H           1      -0.035   0.957  -1.972  1.00  0.00 \nHETATM   60  H           1      -2.246   1.523  -1.106  1.00  0.00 \nHETATM   61  H           1      -2.630  -0.201  -0.864  1.00  0.00 \nHETATM   62  H           1      -2.439   0.465  -2.501  1.00  0.00 \nHETATM   63  H           1      -0.991  -1.924  -1.768  1.00  0.00 \nHETATM   64  H           1       0.625  -1.418  -2.300  1.00  0.00 \nHETATM   65  H           1      -0.791  -0.971  -3.254  1.00  0.00 \nHETATM   66  H           1       1.430   2.438  -1.818  1.00  0.00 \nHETATM   67  H           1       4.327   2.902  -0.962  1.00  0.00 \nHETATM   68  H           1       3.011   4.079  -0.782  1.00  0.00 \nHETATM   69  H           1       3.557   3.619  -2.388  1.00  0.00 \nHETATM   70  H           1       2.183   0.367  -2.790  1.00  0.00 \nHETATM   71  H           1       3.780   0.521  -2.010  1.00  0.00 \nHETATM   72  H           1       3.306   1.606  -3.330  1.00  0.00 \nCONECT    1    2    6   19   25\nCONECT    2    1    3    7   26\nCONECT    3    2    4   22   27\nCONECT    4    3    5   10   28\nCONECT    5    4    6   16   29\nCONECT    6    1    5   13   30\nCONECT    7    2    8    9   31\nCONECT    8    7   32   33   34\nCONECT    9    7   35   36   37\nCONECT   10    4   11   12   38\nCONECT   11   10   39   40   41\nCONECT   12   10   42   43   44\nCONECT   13    6   14   15   45\nCONECT   14   13   46   47   48\nCONECT   15   13   49   50   51\nCONECT   16    5   17   18   52\nCONECT   17   16   53   54   55\nCONECT   18   16   56   57   58\nCONECT   19    1   20   21   59\nCONECT   20   19   60   61   62\nCONECT   21   19   63   64   65\nCONECT   22    3   23   24   66\nCONECT   23   22   67   68   69\nCONECT   24   22   70   71   72\nCONECT   25    1\nCONECT   26    2\nCONECT   27    3\nCONECT   28    4\nCONECT   29    5\nCONECT   30    6\nCONECT   31    7\nCONECT   32    8\nCONECT   33    8\nCONECT   34    8\nCONECT   35    9\nCONECT   36    9\nCONECT   37    9\nCONECT   38   10\nCONECT   39   11\nCONECT   40   11\nCONECT   41   11\nCONECT   42   12\nCONECT   43   12\nCONECT   44   12\nCONECT   45   13\nCONECT   46   14\nCONECT   47   14\nCONECT   48   14\nCONECT   49   15\nCONECT   50   15\nCONECT   51   15\nCONECT   52   16\nCONECT   53   17\nCONECT   54   17\nCONECT   55   17\nCONECT   56   18\nCONECT   57   18\nCONECT   58   18\nCONECT   59   19\nCONECT   60   20\nCONECT   61   20\nCONECT   62   20\nCONECT   63   21\nCONECT   64   21\nCONECT   65   21\nCONECT   66   22\nCONECT   67   23\nCONECT   68   23\nCONECT   69   23\nCONECT   70   24\nCONECT   71   24\nCONECT   72   24\nMASTER        0    0    0    0    0    0    0    0   72    0   72    0\nEND\n",
    "HEADER    Cytosine: Pyrimidine base nucleotide\nCOMPND    jb09cyto\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep 29 12:35:29 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.398   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.070   1.227   0.000  1.00  0.00 \nHETATM    4  N           1       1.356   2.375   0.001  1.00  0.00 \nHETATM    5  C           1       0.004   2.350   0.002  1.00  0.00 \nHETATM    6  N           1      -0.667   1.176   0.001  1.00  0.00 \nHETATM    7  O           1      -0.611   3.389   0.004  1.00  0.00 \nHETATM    8  N           1       3.477   1.271   0.003  1.00  0.00 \nHETATM    9  H           1      -0.548  -0.942   0.000  1.00  0.00 \nHETATM   10  H           1       1.954  -0.938   0.001  1.00  0.00 \nHETATM   11  H           1      -1.681   1.178   0.002  1.00  0.00 \nHETATM   12  H           1       3.791   2.109   0.480  1.00  0.00 \nHETATM   13  H           1       3.844   0.453   0.477  1.00  0.00 \nCONECT    1    2    2    6    9\nCONECT    2    1    1    3   10\nCONECT    3    2    4    4    8\nCONECT    4    3    3    5\nCONECT    5    4    6    7    7\nCONECT    6    1    5   11\nCONECT    7    5    5\nCONECT    8    3   12   13\nCONECT    9    1\nCONECT   10    2\nCONECT   11    6\nCONECT   12    8\nCONECT   13    8\nMASTER        0    0    0    0    0    0    0    0   13    0   13    0\nEND\n",
    "HEADER    DNA: Deoxyribonucleic acid\nATOM      1  O   ???     1       4.674  19.391 -10.106\nATOM      2  C   ???     1       4.459  17.981  -9.876\nATOM      3  C   ???     1       5.288  17.571  -8.673\nATOM      4  O   ???     1       4.895  17.956  -7.317\nATOM      5  C   ???     1       5.700  16.166  -8.515\nATOM      6  O   ???     1       6.993  16.174  -7.868\nATOM      7  C   ???     1       4.606  15.591  -7.605\nATOM      8  C   ???     1       4.489  16.741  -6.607\nATOM      9  N   ???     1       3.143  16.925  -5.903\nATOM     10  C   ???     1       3.127  17.319  -4.578\nATOM     11  O   ???     1       4.173  17.497  -3.993\nATOM     12  N   ???     1       1.955  17.554  -3.958\nATOM     13  C   ???     1       0.773  17.466  -4.621\nATOM     14  N   ???     1      -0.393  17.691  -3.955\nATOM     15  C   ???     1       0.722  17.134  -5.985\nATOM     16  C   ???     1       1.945  16.843  -6.625\nATOM     17  P   ???     1       7.833  14.873  -7.879\nATOM     18  O   ???     1       6.913  13.703  -8.299\nATOM     19  O   ???     1       9.116  15.075  -8.639\nATOM     20  O   ???     1       8.137  14.505  -6.390\nATOM     21  C   ???     1       9.093  15.196  -5.586\nATOM     22  C   ???     1       8.913  14.574  -4.231\nATOM     23  O   ???     1       7.518  14.735  -3.865\nATOM     24  C   ???     1       9.081  13.086  -4.262\nATOM     25  O   ???     1      10.078  12.703  -3.397\nATOM     26  C   ???     1       7.686  12.473  -4.029\nATOM     27  C   ???     1       7.063  13.543  -3.201\nATOM     28  N   ???     1       5.563  13.566  -3.134\nATOM     29  C   ???     1       4.657  13.394  -4.141\nATOM     30  N   ???     1       3.380  13.664  -3.752\nATOM     31  C   ???     1       3.485  14.024  -2.465\nATOM     32  C   ???     1       2.474  14.525  -1.574\nATOM     33  O   ???     1       1.309  14.806  -1.867\nATOM     34  N   ???     1       2.958  14.808  -0.289\nATOM     35  C   ???     1       4.279  14.700   0.121\nATOM     36  N   ???     1       4.596  14.961   1.424\nATOM     37  N   ???     1       5.242  14.292  -0.749\nATOM     38  C   ???     1       4.801  13.971  -2.035\nATOM     39  P   ???     1      10.462  11.185  -3.172\nATOM     40  O   ???     1       9.914  10.272  -4.247\nATOM     41  O   ???     1      11.949  11.216  -2.975\nATOM     42  O   ???     1       9.792  10.862  -1.765\nATOM     43  C   ???     1      10.265  11.478  -0.528\nATOM     44  C   ???     1       9.204  11.248   0.526\nATOM     45  O   ???     1       7.918  11.627   0.016\nATOM     46  C   ???     1       9.052   9.838   1.036\nATOM     47  O   ???     1       9.614   9.642   2.306\nATOM     48  C   ???     1       7.597   9.524   0.982\nATOM     49  C   ???     1       6.965  10.887   0.744\nATOM     50  N   ???     1       5.832  10.810  -0.183\nATOM     51  C   ???     1       4.534  11.009   0.257\nATOM     52  O   ???     1       4.306  11.269   1.440\nATOM     53  N   ???     1       3.534  10.905  -0.642\nATOM     54  C   ???     1       3.770  10.552  -1.926\nATOM     55  N   ???     1       2.773  10.591  -2.855\nATOM     56  C   ???     1       5.043  10.250  -2.374\nATOM     57  C   ???     1       6.091  10.396  -1.479\nATOM     58  P   ???     1       9.660   8.226   2.989\nATOM     59  O   ???     1       9.518   7.127   1.928\nATOM     60  O   ???     1      10.794   8.089   3.999\nATOM     61  O   ???     1       8.355   8.291   3.834\nATOM     62  C   ???     1       8.139   9.269   4.865\nATOM     63  C   ???     1       6.937   8.745   5.644\nATOM     64  O   ???     1       5.814   8.819   4.753\nATOM     65  C   ???     1       6.948   7.295   6.225\nATOM     66  O   ???     1       6.417   7.199   7.512\nATOM     67  C   ???     1       6.148   6.464   5.250\nATOM     68  C   ???     1       5.222   7.503   4.599\nATOM     69  N   ???     1       4.918   7.267   3.140\nATOM     70  C   ???     1       5.599   6.623   2.107\nATOM     71  N   ???     1       4.919   6.594   0.951\nATOM     72  C   ???     1       3.772   7.259   1.254\nATOM     73  C   ???     1       2.598   7.558   0.439\nATOM     74  O   ???     1       2.404   7.232  -0.737\nATOM     75  N   ???     1       1.575   8.214   1.141\nATOM     76  C   ???     1       1.613   8.566   2.471\nATOM     77  N   ???     1       0.502   9.125   3.046\nATOM     78  N   ???     1       2.702   8.309   3.210\nATOM     79  C   ???     1       3.753   7.669   2.570\nATOM     80  P   ???     1       6.301   5.803   8.277\nATOM     81  O   ???     1       6.480   4.589   7.476\nATOM     82  O   ???     1       7.156   5.937   9.499\nATOM     83  O   ???     1       4.740   5.694   8.620\nATOM     84  C   ???     1       3.911   6.858   8.929\nATOM     85  C   ???     1       2.515   6.690   8.311\nATOM     86  O   ???     1       2.653   6.561   6.911\nATOM     87  C   ???     1       1.684   5.487   8.712\nATOM     88  O   ???     1       0.539   5.815   9.516\nATOM     89  C   ???     1       1.353   4.792   7.399\nATOM     90  C   ???     1       1.556   5.869   6.393\nATOM     91  N   ???     1       1.967   5.365   5.052\nATOM     92  C   ???     1       3.193   4.822   4.658\nATOM     93  N   ???     1       3.258   4.448   3.362\nATOM     94  C   ???     1       2.043   4.779   2.883\nATOM     95  C   ???     1       1.417   4.673   1.562\nATOM     96  N   ???     1       2.034   4.100   0.514\nATOM     97  N   ???     1       0.156   5.177   1.374\nATOM     98  C   ???     1      -0.498   5.699   2.441\nATOM     99  N   ???     1      -0.077   5.807   3.720\nATOM    100  C   ???     1       1.230   5.336   3.901\nATOM    101  P   ???     1      -0.488   4.701  10.028\nATOM    102  O   ???     1       0.013   3.297  10.287\nATOM    103  O   ???     1      -1.183   5.233  11.229\nATOM    104  O   ???     1      -1.483   4.559   8.784\nATOM    105  C   ???     1      -2.385   5.609   8.332\nATOM    106  C   ???     1      -3.291   4.910   7.309\nATOM    107  O   ???     1      -2.610   4.636   6.060\nATOM    108  C   ???     1      -3.923   3.568   7.700\nATOM    109  O   ???     1      -5.162   3.352   7.126\nATOM    110  C   ???     1      -2.961   2.582   7.123\nATOM    111  C   ???     1      -2.754   3.200   5.763\nATOM    112  N   ???     1      -1.583   2.605   5.066\nATOM    113  C   ???     1      -0.368   2.242   5.588\nATOM    114  N   ???     1       0.486   1.776   4.665\nATOM    115  C   ???     1      -0.189   1.878   3.525\nATOM    116  C   ???     1       0.183   1.571   2.180\nATOM    117  N   ???     1       1.377   0.958   1.920\nATOM    118  N   ???     1      -0.730   1.786   1.174\nATOM    119  C   ???     1      -1.964   2.218   1.475\nATOM    120  N   ???     1      -2.439   2.500   2.716\nATOM    121  C   ???     1      -1.479   2.331   3.718\nATOM    122  P   ???     1      -5.924   1.982   7.353\nATOM    123  O   ???     1      -5.172   0.938   8.012\nATOM    124  O   ???     1      -7.186   2.593   7.897\nATOM    125  O   ???     1      -6.252   1.347   5.938\nATOM    126  C   ???     1      -6.944   2.135   4.921\nATOM    127  C   ???     1      -6.715   1.372   3.651\nATOM    128  O   ???     1      -5.286   1.133   3.458\nATOM    129  C   ???     1      -7.407   0.057   3.644\nATOM    130  O   ???     1      -8.489   0.026   2.771\nATOM    131  C   ???     1      -6.310  -0.990   3.438\nATOM    132  C   ???     1      -5.156  -0.150   2.865\nATOM    133  N   ???     1      -3.757  -0.647   3.037\nATOM    134  C   ???     1      -2.979  -0.923   1.905\nATOM    135  O   ???     1      -3.374  -0.727   0.747\nATOM    136  N   ???     1      -1.687  -1.340   2.116\nATOM    137  C   ???     1      -1.144  -1.494   3.381\nATOM    138  O   ???     1       0.074  -1.754   3.445\nATOM    139  C   ???     1      -1.948  -1.227   4.501\nATOM    140  C   ???     1      -1.422  -1.319   5.892\nATOM    141  C   ???     1      -3.248  -0.795   4.314\nATOM    142  P   ???     1      -9.378  -1.306   2.603\nATOM    143  O   ???     1      -9.127  -2.221   3.726\nATOM    145  O   ???     1      -8.753  -2.007   1.349\nATOM    146  C   ???     1      -8.460  -1.252   0.127\nATOM    147  C   ???     1      -7.623  -2.192  -0.688\nATOM    148  O   ???     1      -6.477  -2.562   0.073\nATOM    149  C   ???     1      -8.255  -3.511  -1.016\nATOM    150  O   ???     1      -8.724  -3.527  -2.285\nATOM    151  C   ???     1      -7.224  -4.587  -0.757\nATOM    152  C   ???     1      -6.004  -3.753  -0.494\nATOM    153  N   ???     1      -4.890  -4.263   0.346\nATOM    154  C   ???     1      -3.627  -4.303  -0.238\nATOM    155  O   ???     1      -3.413  -4.052  -1.439\nATOM    156  N   ???     1      -2.559  -4.547   0.575\nATOM    157  C   ???     1      -2.672  -4.694   1.927\nATOM    158  O   ???     1      -1.603  -4.845   2.510\nATOM    159  C   ???     1      -3.962  -4.607   2.537\nATOM    160  C   ???     1      -4.169  -4.666   4.067\nATOM    161  C   ???     1      -5.072  -4.416   1.690\nATOM    162  P   ???     1      -9.083  -4.896  -2.982\nATOM    163  O   ???     1      -9.692  -5.915  -2.114\nATOM    164  O   ???     1      -9.784  -4.333  -4.195\nATOM    165  O   ???     1      -7.769  -5.544  -3.501\nATOM    166  C   ???     1      -6.988  -4.787  -4.548\nATOM    167  C   ???     1      -5.787  -5.605  -4.680\nATOM    168  O   ???     1      -5.186  -5.816  -3.381\nATOM    169  C   ???     1      -6.160  -6.983  -5.172\nATOM    170  O   ???     1      -5.775  -7.049  -6.554\nATOM    171  C   ???     1      -5.475  -7.989  -4.170\nATOM    172  C   ???     1      -4.470  -7.095  -3.471\nATOM    173  N   ???     1      -4.143  -7.481  -2.064\nATOM    174  C   ???     1      -2.880  -7.900  -1.674\nATOM    175  O   ???     1      -1.981  -8.028  -2.497\nATOM    176  N   ???     1      -2.644  -8.106  -0.357\nATOM    177  C   ???     1      -3.593  -7.906   0.580\nATOM    178  N   ???     1      -3.294  -8.029   1.897\nATOM    179  C   ???     1      -4.887  -7.515   0.234\nATOM    180  C   ???     1      -5.144  -7.290  -1.118\nATOM    181  P   ???     1      -6.271  -8.185  -7.504\nATOM    182  O   ???     1      -7.612  -8.682  -7.077\nATOM    183  O   ???     1      -6.109  -7.701  -8.887\nATOM    184  O   ???     1      -5.255  -9.348  -7.127\nATOM    185  C   ???     1      -3.864  -9.233  -7.443\nATOM    186  C   ???     1      -3.265 -10.503  -6.982\nATOM    187  O   ???     1      -3.388 -10.408  -5.569\nATOM    188  C   ???     1      -3.913 -11.848  -7.400\nATOM    189  O   ???     1      -2.906 -12.861  -7.541\nATOM    190  C   ???     1      -4.865 -12.134  -6.218\nATOM    191  C   ???     1      -3.937 -11.700  -5.115\nATOM    192  N   ???     1      -4.370 -11.653  -3.684\nATOM    193  C   ???     1      -5.572 -11.359  -3.092\nATOM    194  N   ???     1      -5.502 -11.208  -1.750\nATOM    195  C   ???     1      -4.184 -11.405  -1.464\nATOM    196  C   ???     1      -3.484 -11.398  -0.187\nATOM    197  O   ???     1      -3.973 -11.294   0.939\nATOM    198  N   ???     1      -2.117 -11.651  -0.293\nATOM    199  C   ???     1      -1.432 -11.934  -1.458\nATOM    200  N   ???     1      -0.114 -12.247  -1.341\nATOM    201  N   ???     1      -2.059 -11.968  -2.664\nATOM    202  C   ???     1      -3.452 -11.687  -2.620\nATOM    203  P   ???     1      -2.430 -13.413  -8.952\nATOM    204  O   ???     1      -3.259 -14.642  -9.185\nATOM    205  O   ???     1      -2.433 -12.356 -10.046\nATOM    206  O   ???     1      -0.882 -13.756  -8.697\nATOM    207  C   ???     1       0.079 -12.685  -8.383\nATOM    208  C   ???     1       1.266 -13.194  -7.564\nATOM    209  O   ???     1       0.999 -13.349  -6.166\nATOM    210  C   ???     1       1.851 -14.504  -7.958\nATOM    211  O   ???     1       3.274 -14.536  -7.758\nATOM    212  C   ???     1       1.034 -15.479  -7.076\nATOM    213  C   ???     1       1.061 -14.732  -5.783\nATOM    214  N   ???     1       0.018 -15.063  -4.744\nATOM    215  C   ???     1       0.371 -15.193  -3.394\nATOM    216  O   ???     1       1.555 -15.059  -3.043\nATOM    217  N   ???     1      -0.605 -15.422  -2.469\nATOM    218  C   ???     1      -1.903 -15.490  -2.823\nATOM    219  N   ???     1      -2.850 -15.626  -1.852\nATOM    220  C   ???     1      -2.311 -15.339  -4.167\nATOM    221  C   ???     1      -1.315 -15.115  -5.135\nATOM    222  P   ???     1       4.029 -15.922  -7.818\nATOM    223  O   ???     1       3.416 -16.861  -8.809\nATOM    224  O   ???     1       5.487 -15.559  -8.011\nATOM    225  O   ???     1       3.714 -16.639  -6.402\nATOM    226  C   ???     1       4.699 -16.656  -5.290\nATOM    227  C   ???     1       4.464 -17.877  -4.385\nATOM    228  O   ???     1       3.153 -17.818  -3.885\nATOM    229  C   ???     1       4.685 -19.342  -4.849\nATOM    230  O   ???     1       5.420 -20.114  -3.884\nATOM    231  C   ???     1       3.295 -19.890  -5.050\nATOM    232  C   ???     1       2.531 -19.057  -4.020\nATOM    233  N   ???     1       1.056 -18.734  -4.183\nATOM    234  C   ???     1       0.273 -18.422  -5.264\nATOM    235  N   ???     1      -1.031 -18.317  -4.953\nATOM    236  C   ???     1      -1.093 -18.575  -3.620\nATOM    237  C   ???     1      -2.226 -18.671  -2.719\nATOM    238  O   ???     1      -3.418 -18.578  -2.959\nATOM    239  N   ???     1      -1.866 -18.877  -1.414\nATOM    240  C   ???     1      -0.581 -18.991  -0.915\nATOM    241  N   ???     1      -0.396 -19.286   0.409\nATOM    242  N   ???     1       0.472 -18.926  -1.725\nATOM    243  C   ???     1       0.163 -18.734  -3.100\nATOM    244  O   ???     1      -6.680 -19.825   7.699\nATOM    245  C   ???     1      -6.306 -20.194   6.315\nATOM    246  C   ???     1      -5.053 -19.445   5.920\nATOM    247  O   ???     1      -4.418 -19.699   4.659\nATOM    248  C   ???     1      -4.994 -17.972   6.135\nATOM    249  O   ???     1      -3.710 -17.604   6.687\nATOM    250  C   ???     1      -5.163 -17.510   4.681\nATOM    251  C   ???     1      -4.498 -18.548   3.817\nATOM    252  N   ???     1      -5.087 -18.713   2.382\nATOM    253  C   ???     1      -4.235 -18.653   1.283\nATOM    254  O   ???     1      -3.023 -18.634   1.498\nATOM    255  N   ???     1      -4.753 -18.618   0.009\nATOM    256  C   ???     1      -6.087 -18.707  -0.208\nATOM    257  N   ???     1      -6.569 -18.815  -1.491\nATOM    258  C   ???     1      -6.991 -18.809   0.869\nATOM    259  C   ???     1      -6.468 -18.783   2.177\nATOM    260  P   ???     1      -3.519 -16.827   8.069\nATOM    261  O   ???     1      -4.231 -15.537   8.035\nATOM    262  O   ???     1      -3.821 -17.708   9.240\nATOM    263  O   ???     1      -1.956 -16.549   8.073\nATOM    264  C   ???     1      -0.947 -17.650   8.003\nATOM    265  C   ???     1       0.325 -17.111   7.352\nATOM    266  O   ???     1       0.066 -17.132   5.962\nATOM    267  C   ???     1       0.613 -15.669   7.661\nATOM    268  O   ???     1       1.856 -15.388   8.203\nATOM    269  C   ???     1       0.265 -14.853   6.465\nATOM    270  C   ???     1       0.285 -15.854   5.380\nATOM    271  N   ???     1      -0.824 -15.536   4.452\nATOM    272  C   ???     1      -2.113 -15.141   4.752\nATOM    273  N   ???     1      -2.810 -14.728   3.684\nATOM    274  C   ???     1      -1.957 -14.896   2.652\nATOM    275  C   ???     1      -2.142 -14.574   1.260\nATOM    276  O   ???     1      -3.179 -14.132   0.774\nATOM    277  N   ???     1      -1.001 -14.804   0.451\nATOM    278  C   ???     1       0.192 -15.336   0.902\nATOM    279  N   ???     1       1.184 -15.515   0.002\nATOM    280  N   ???     1       0.382 -15.672   2.205\nATOM    281  C   ???     1      -0.729 -15.444   3.059\nATOM    282  P   ???     1       2.293 -13.866   8.376\nATOM    283  O   ???     1       1.086 -13.042   8.626\nATOM    284  O   ???     1       3.396 -13.816   9.377\nATOM    285  O   ???     1       2.922 -13.420   7.025\nATOM    286  C   ???     1       4.007 -14.108   6.407\nATOM    287  C   ???     1       4.054 -13.498   5.013\nATOM    288  O   ???     1       2.780 -13.607   4.393\nATOM    289  C   ???     1       4.326 -12.019   4.962\nATOM    290  O   ???     1       5.715 -11.793   5.178\nATOM    291  C   ???     1       3.795 -11.615   3.565\nATOM    292  C   ???     1       2.647 -12.603   3.423\nATOM    293  N   ???     1       1.244 -12.133   3.536\nATOM    294  C   ???     1       0.427 -12.102   2.410\nATOM    295  O   ???     1       0.835 -12.492   1.323\nATOM    296  N   ???     1      -0.850 -11.713   2.533\nATOM    297  C   ???     1      -1.391 -11.421   3.723\nATOM    298  N   ???     1      -2.628 -10.831   3.762\nATOM    299  C   ???     1      -0.649 -11.574   4.913\nATOM    300  C   ???     1       0.708 -11.938   4.796\nATOM    301  P   ???     1       6.336 -10.366   5.128\nATOM    302  O   ???     1       5.449  -9.428   5.909\nATOM    303  O   ???     1       7.745 -10.482   5.620\nATOM    304  O   ???     1       6.290 -10.020   3.569\nATOM    305  C   ???     1       7.055 -10.811   2.615\nATOM    306  C   ???     1       6.734 -10.308   1.217\nATOM    307  O   ???     1       5.297 -10.192   1.100\nATOM    308  C   ???     1       7.286  -8.975   0.718\nATOM    309  O   ???     1       7.393  -8.945  -0.714\nATOM    310  C   ???     1       6.225  -7.973   1.221\nATOM    311  C   ???     1       4.974  -8.794   0.845\nATOM    312  N   ???     1       3.773  -8.455   1.602\nATOM    313  C   ???     1       3.640  -7.981   2.890\nATOM    314  N   ???     1       2.384  -7.801   3.240\nATOM    315  C   ???     1       1.667  -8.192   2.129\nATOM    316  C   ???     1       0.216  -8.383   1.898\nATOM    317  O   ???     1      -0.692  -8.327   2.724\nATOM    318  N   ???     1      -0.115  -8.589   0.569\nATOM    319  C   ???     1       0.807  -8.696  -0.461\nATOM    320  N   ???     1       0.345  -8.866  -1.749\nATOM    321  N   ???     1       2.149  -8.691  -0.209\nATOM    322  C   ???     1       2.524  -8.455   1.086\nATOM    323  P   ???     1       7.575  -7.564  -1.471\nATOM    324  O   ???     1       7.955  -6.449  -0.479\nATOM    325  O   ???     1       8.741  -7.728  -2.458\nATOM    326  O   ???     1       6.254  -7.373  -2.307\nATOM    327  C   ???     1       6.024  -8.272  -3.442\nATOM    328  C   ???     1       5.019  -7.727  -4.455\nATOM    329  O   ???     1       3.633  -7.467  -4.002\nATOM    330  C   ???     1       5.448  -6.462  -5.147\nATOM    331  O   ???     1       5.043  -6.461  -6.529\nATOM    332  C   ???     1       4.765  -5.380  -4.322\nATOM    333  C   ???     1       3.522  -6.055  -3.759\nATOM    334  N   ???     1       3.349  -5.765  -2.284\nATOM    335  C   ???     1       4.280  -5.485  -1.291\nATOM    336  N   ???     1       3.718  -5.218  -0.101\nATOM    337  C   ???     1       2.389  -5.311  -0.337\nATOM    338  C   ???     1       1.210  -5.068   0.470\nATOM    339  N   ???     1       1.297  -4.554   1.713\nATOM    340  N   ???     1      -0.018  -5.382  -0.038\nATOM    341  C   ???     1      -0.107  -5.816  -1.309\nATOM    342  N   ???     1       0.900  -5.988  -2.198\nATOM    343  C   ???     1       2.136  -5.713  -1.640\nATOM    344  P   ???     1       4.958  -5.104  -7.365\nATOM    345  O   ???     1       5.978  -4.099  -6.859\nATOM    346  O   ???     1       5.021  -5.615  -8.756\nATOM    347  O   ???     1       3.560  -4.533  -7.033\nATOM    348  C   ???     1       2.362  -5.321  -7.154\nATOM    349  C   ???     1       1.273  -4.376  -6.720\nATOM    350  O   ???     1       1.389  -4.141  -5.316\nATOM    351  C   ???     1       1.322  -2.993  -7.366\nATOM    352  O   ???     1       0.329  -2.831  -8.391\nATOM    353  C   ???     1       1.333  -1.991  -6.194\nATOM    354  C   ???     1       0.897  -2.852  -5.006\nATOM    355  N   ???     1       1.537  -2.528  -3.709\nATOM    356  C   ???     1       2.863  -2.388  -3.374\nATOM    357  N   ???     1       3.059  -2.100  -2.081\nATOM    358  C   ???     1       1.825  -2.100  -1.562\nATOM    359  C   ???     1       1.312  -1.785  -0.242\nATOM    360  N   ???     1       2.105  -1.419   0.792\nATOM    361  N   ???     1      -0.035  -1.681  -0.088\nATOM    362  C   ???     1      -0.863  -1.975  -1.112\nATOM    363  N   ???     1      -0.516  -2.341  -2.360\nATOM    364  C   ???     1       0.871  -2.352  -2.537\nATOM    365  P   ???     1       0.096  -1.455  -9.141\nATOM    366  O   ???     1       1.403  -0.827  -9.454\nATOM    367  O   ???     1      -0.784  -1.681 -10.328\nATOM    368  O   ???     1      -0.708  -0.618  -8.042\nATOM    369  C   ???     1      -2.026  -1.063  -7.621\nATOM    370  C   ???     1      -2.460  -0.283  -6.398\nATOM    371  O   ???     1      -1.482  -0.424  -5.323\nATOM    372  C   ???     1      -2.702   1.209  -6.627\nATOM    373  O   ???     1      -4.034   1.463  -6.980\nATOM    374  C   ???     1      -2.262   1.804  -5.316\nATOM    375  C   ???     1      -1.039   0.909  -5.075\nATOM    376  N   ???     1      -0.210   0.993  -3.836\nATOM    377  C   ???     1      -0.736   1.017  -2.546\nATOM    378  O   ???     1      -1.957   0.851  -2.314\nATOM    379  N   ???     1       0.164   1.108  -1.498\nATOM    380  C   ???     1       1.538   1.199  -1.677\nATOM    381  O   ???     1       2.250   1.226  -0.672\nATOM    382  C   ???     1       2.054   1.179  -2.992\nATOM    383  C   ???     1       3.521   1.367  -3.242\nATOM    384  C   ???     1       1.153   1.065  -4.071\nATOM    385  P   ???     1      -4.609   2.928  -7.269\nATOM    386  O   ???     1      -3.623   3.841  -7.848\nATOM    387  O   ???     1      -5.862   2.588  -8.032\nATOM    388  O   ???     1      -4.884   3.503  -5.838\nATOM    389  C   ???     1      -5.822   2.805  -4.954\nATOM    390  C   ???     1      -5.829   3.570  -3.680\nATOM    391  O   ???     1      -4.506   3.511  -3.227\nATOM    392  C   ???     1      -6.172   5.046  -3.735\nATOM    393  O   ???     1      -7.441   5.291  -3.123\nATOM    394  C   ???     1      -5.006   5.747  -3.052\nATOM    395  C   ???     1      -4.274   4.597  -2.370\nATOM    396  N   ???     1      -2.767   4.703  -2.324\nATOM    397  C   ???     1      -2.085   4.842  -1.117\nATOM    398  O   ???     1      -2.678   5.024  -0.043\nATOM    399  N   ???     1      -0.697   4.808  -1.172\nATOM    400  C   ???     1       0.014   4.669  -2.366\nATOM    401  O   ???     1       1.237   4.636  -2.312\nATOM    402  C   ???     1      -0.682   4.595  -3.576\nATOM    403  C   ???     1       0.027   4.511  -4.924\nATOM    404  C   ???     1      -2.079   4.607  -3.526\nATOM    405  P   ???     1      -8.018   6.766  -2.948\nATOM    406  O   ???     1      -7.635   7.566  -4.152\nATOM    407  O   ???     1      -9.476   6.706  -2.680\nATOM    408  O   ???     1      -7.320   7.281  -1.652\nATOM    409  C   ???     1      -7.634   6.745  -0.332\nATOM    410  C   ???     1      -6.740   7.536   0.578\nATOM    411  O   ???     1      -5.356   7.300   0.129\nATOM    412  C   ???     1      -6.992   9.072   0.483\nATOM    413  O   ???     1      -7.500   9.642   1.681\nATOM    414  C   ???     1      -5.648   9.640   0.010\nATOM    415  C   ???     1      -4.683   8.515   0.475\nATOM    416  N   ???     1      -3.379   8.489  -0.149\nATOM    417  C   ???     1      -2.166   8.504   0.541\nATOM    418  O   ???     1      -2.158   8.517   1.779\nATOM    419  N   ???     1      -1.010   8.423  -0.184\nATOM    420  C   ???     1      -1.042   8.316  -1.562\nATOM    421  N   ???     1       0.083   8.179  -2.370\nATOM    422  C   ???     1      -2.249   8.284  -2.244\nATOM    423  C   ???     1      -3.426   8.372  -1.520\nATOM    424  P   ???     1      -8.072  11.149   1.769\nATOM    425  O   ???     1      -8.359  11.946   0.569\nATOM    426  O   ???     1      -9.253  11.131   2.697\nATOM    427  O   ???     1      -6.842  11.901   2.427\nATOM    428  C   ???     1      -6.195  11.442   3.679\nATOM    429  C   ???     1      -4.912  12.282   3.817\nATOM    430  O   ???     1      -3.876  11.994   2.873\nATOM    431  C   ???     1      -5.090  13.728   3.629\nATOM    432  O   ???     1      -4.492  14.502   4.643\nATOM    433  C   ???     1      -4.542  14.026   2.249\nATOM    434  C   ???     1      -3.391  13.126   2.230\nATOM    435  N   ???     1      -2.856  12.707   0.897\nATOM    436  C   ???     1      -3.473  12.442  -0.319\nATOM    437  N   ???     1      -2.637  12.015  -1.293\nATOM    438  C   ???     1      -1.436  12.007  -0.688\nATOM    439  C   ???     1      -0.127  11.608  -1.179\nATOM    440  O   ???     1       0.172  11.212  -2.291\nATOM    441  N   ???     1       0.874  11.683  -0.204\nATOM    442  C   ???     1       0.686  12.119   1.100\nATOM    443  N   ???     1       1.749  12.103   1.939\nATOM    444  N   ???     1      -0.519  12.555   1.528\nATOM    445  C   ???     1      -1.544  12.446   0.633\nATOM    446  P   ???     1      -5.127  15.894   4.858\nATOM    447  O   ???     1      -5.425  16.629   3.561\nATOM    448  O   ???     1      -6.250  15.527   5.754\nATOM    449  O   ???     1      -4.002  16.793   5.584\nATOM    450  C   ???     1      -3.238  16.255   6.678\nATOM    451  C   ???     1      -1.830  16.039   6.216\nATOM    452  O   ???     1      -1.871  15.509   4.883\nATOM    453  C   ???     1      -0.873  17.253   6.173\nATOM    454  O   ???     1      -0.153  17.520   7.416\nATOM    455  C   ???     1       0.090  16.942   5.027\nATOM    456  C   ???     1      -0.595  15.819   4.260\nATOM    457  N   ???     1      -0.730  16.057   2.785\nATOM    458  C   ???     1       0.227  15.578   1.903\nATOM    459  O   ???     1       1.293  15.046   2.291\nATOM    460  N   ???     1      -0.055  15.614   0.600\nATOM    461  C   ???     1      -1.197  16.106   0.107\nATOM    462  N   ???     1      -1.457  15.971  -1.213\nATOM    463  C   ???     1      -2.157  16.670   0.937\nATOM    464  C   ???     1      -1.890  16.634   2.320\nATOM    465  P   ???     1       0.085  19.035   7.891\nATOM    466  O   ???     1      -1.103  19.918   7.465\nATOM    467  O   ???     1       0.455  19.118   9.333\nATOM    468  O   ???     1       1.304  19.503   6.967\nATOM    469  C   ???     1       2.588  19.092   7.215\nATOM    470  C   ???     1       3.346  19.369   5.986\nATOM    471  O   ???     1       2.968  18.509   4.924\nATOM    472  C   ???     1       3.325  20.751   5.383\nATOM    473  O   ???     1       3.907  21.749   6.266\nATOM    474  C   ???     1       4.203  20.393   4.162\nATOM    475  C   ???     1       3.516  19.074   3.711\nATOM    476  N   ???     1       2.407  19.227   2.697\nATOM    477  C   ???     1       1.165  19.783   2.799\nATOM    478  N   ???     1       0.472  19.784   1.639\nATOM    479  C   ???     1       1.290  19.206   0.763\nATOM    480  C   ???     1       1.097  18.852  -0.624\nATOM    481  O   ???     1       0.123  18.893  -1.321\nATOM    482  N   ???     1       2.227  18.334  -1.206\nATOM    483  C   ???     1       3.438  18.092  -0.570\nATOM    484  N   ???     1       4.500  17.628  -1.280\nATOM    485  N   ???     1       3.571  18.322   0.734\nATOM    486  C   ???     1       2.483  18.897   1.373\nCONECT    1    2\nCONECT    2    1    3\nCONECT    3    2    4    5\nCONECT    4    3    8\nCONECT    5    3    6    7\nCONECT    6    5   17\nCONECT    7    5    8\nCONECT    8    4    7    9\nCONECT    9    8   10   16\nCONECT   10    9   11   12\nCONECT   11   10\nCONECT   12   10   13\nCONECT   13   12   14   15\nCONECT   14   13\nCONECT   15   13   16\nCONECT   16    9   15\nCONECT   17    6   18   19   20\nCONECT   18   17\nCONECT   19   17\nCONECT   20   17   21\nCONECT   21   20   22\nCONECT   22   21   23   24\nCONECT   23   22   27\nCONECT   24   22   25   26\nCONECT   25   24   39\nCONECT   26   24   27\nCONECT   27   23   26   28\nCONECT   28   27   29   38\nCONECT   29   28   30\nCONECT   30   29   31\nCONECT   31   30   32   38\nCONECT   32   31   33   34\nCONECT   33   32\nCONECT   34   32   35\nCONECT   35   34   36   37\nCONECT   36   35\nCONECT   37   35   38\nCONECT   38   28   31   37\nCONECT   39   25   40   41   42\nCONECT   40   39\nCONECT   41   39\nCONECT   42   39   43\nCONECT   43   42   44\nCONECT   44   43   45   46\nCONECT   45   44   49\nCONECT   46   44   47   48\nCONECT   47   46   58\nCONECT   48   46   49\nCONECT   49   45   48   50\nCONECT   50   49   51   57\nCONECT   51   50   52   53\nCONECT   52   51\nCONECT   53   51   54\nCONECT   54   53   55   56\nCONECT   55   54\nCONECT   56   54   57\nCONECT   57   50   56\nCONECT   58   47   59   60   61\nCONECT   59   58\nCONECT   60   58\nCONECT   61   58   62\nCONECT   62   61   63\nCONECT   63   62   64   65\nCONECT   64   63   68\nCONECT   65   63   66   67\nCONECT   66   65   80\nCONECT   67   65   68\nCONECT   68   64   67   69\nCONECT   69   68   70   79\nCONECT   70   69   71\nCONECT   71   70   72\nCONECT   72   71   73   79\nCONECT   73   72   74   75\nCONECT   74   73\nCONECT   75   73   76\nCONECT   76   75   77   78\nCONECT   77   76\nCONECT   78   76   79\nCONECT   79   69   72   78\nCONECT   80   66   81   82   83\nCONECT   81   80\nCONECT   82   80\nCONECT   83   80   84\nCONECT   84   83   85\nCONECT   85   84   86   87\nCONECT   86   85   90\nCONECT   87   85   88   89\nCONECT   88   87  101\nCONECT   89   87   90\nCONECT   90   86   89   91\nCONECT   91   90   92  100\nCONECT   92   91   93\nCONECT   93   92   94\nCONECT   94   93   95  100\nCONECT   95   94   96   97\nCONECT   96   95\nCONECT   97   95   98\nCONECT   98   97   99\nCONECT   99   98  100\nCONECT  100   91   94   99\nCONECT  101   88  102  103  104\nCONECT  102  101\nCONECT  103  101\nCONECT  104  101  105\nCONECT  105  104  106\nCONECT  106  105  107  108\nCONECT  107  106  111\nCONECT  108  106  109  110\nCONECT  109  108  122\nCONECT  110  108  111\nCONECT  111  107  110  112\nCONECT  112  111  113  121\nCONECT  113  112  114\nCONECT  114  113  115\nCONECT  115  114  116  121\nCONECT  116  115  117  118\nCONECT  117  116\nCONECT  118  116  119\nCONECT  119  118  120\nCONECT  120  119  121\nCONECT  121  112  115  120\nCONECT  122  109  123  124  125\nCONECT  123  122\nCONECT  124  122\nCONECT  125  122  126\nCONECT  126  125  127\nCONECT  127  126  128  129\nCONECT  128  127  132\nCONECT  129  127  130  131\nCONECT  130  129  142\nCONECT  131  129  132\nCONECT  132  128  131  133\nCONECT  133  132  134  141\nCONECT  134  133  135  136\nCONECT  135  134\nCONECT  136  134  137\nCONECT  137  136  138  139\nCONECT  138  137\nCONECT  139  137  140  141\nCONECT  140  139\nCONECT  141  133  139\nCONECT  142  130  143  145\nCONECT  143  142\nCONECT  145  142  146\nCONECT  146  145  147\nCONECT  147  146  148  149\nCONECT  148  147  152\nCONECT  149  147  150  151\nCONECT  150  149  162\nCONECT  151  149  152\nCONECT  152  148  151  153\nCONECT  153  152  154  161\nCONECT  154  153  155  156\nCONECT  155  154\nCONECT  156  154  157\nCONECT  157  156  158  159\nCONECT  158  157\nCONECT  159  157  160  161\nCONECT  160  159\nCONECT  161  153  159\nCONECT  162  150  163  164  165\nCONECT  163  162\nCONECT  164  162\nCONECT  165  162  166\nCONECT  166  165  167\nCONECT  167  166  168  169\nCONECT  168  167  172\nCONECT  169  167  170  171\nCONECT  170  169  181\nCONECT  171  169  172\nCONECT  172  168  171  173\nCONECT  173  172  174  180\nCONECT  174  173  175  176\nCONECT  175  174\nCONECT  176  174  177\nCONECT  177  176  178  179\nCONECT  178  177\nCONECT  179  177  180\nCONECT  180  173  179\nCONECT  181  170  182  183  184\nCONECT  182  181\nCONECT  183  181\nCONECT  184  181  185\nCONECT  185  184  186\nCONECT  186  185  187  188\nCONECT  187  186  191\nCONECT  188  186  189  190\nCONECT  189  188  203\nCONECT  190  188  191\nCONECT  191  187  190  192\nCONECT  192  191  193  202\nCONECT  193  192  194\nCONECT  194  193  195\nCONECT  195  194  196  202\nCONECT  196  195  197  198\nCONECT  197  196\nCONECT  198  196  199\nCONECT  199  198  200  201\nCONECT  200  199\nCONECT  201  199  202\nCONECT  202  192  195  201\nCONECT  203  189  204  205  206\nCONECT  204  203\nCONECT  205  203\nCONECT  206  203  207\nCONECT  207  206  208\nCONECT  208  207  209  210\nCONECT  209  208  213\nCONECT  210  208  211  212\nCONECT  211  210  222\nCONECT  212  210  213\nCONECT  213  209  212  214\nCONECT  214  213  215  221\nCONECT  215  214  216  217\nCONECT  216  215\nCONECT  217  215  218\nCONECT  218  217  219  220\nCONECT  219  218\nCONECT  220  218  221\nCONECT  221  214  220\nCONECT  222  211  223  224  225\nCONECT  223  222\nCONECT  224  222\nCONECT  225  222  226\nCONECT  226  225  227\nCONECT  227  226  228  229\nCONECT  228  227  232\nCONECT  229  227  230  231\nCONECT  230  229\nCONECT  231  229  232\nCONECT  232  228  231  233\nCONECT  233  232  234  243\nCONECT  234  233  235\nCONECT  235  234  236\nCONECT  236  235  237  243\nCONECT  237  236  238  239\nCONECT  238  237\nCONECT  239  237  240\nCONECT  240  239  241  242\nCONECT  241  240\nCONECT  242  240  243\nCONECT  243  233  236  242\nCONECT  244  245\nCONECT  245  244  246\nCONECT  246  245  247  248\nCONECT  247  246  251\nCONECT  248  246  249  250\nCONECT  249  248  260\nCONECT  250  248  251\nCONECT  251  247  250  252\nCONECT  252  251  253  259\nCONECT  253  252  254  255\nCONECT  254  253\nCONECT  255  253  256\nCONECT  256  255  257  258\nCONECT  257  256\nCONECT  258  256  259\nCONECT  259  252  258\nCONECT  260  249  261  262  263\nCONECT  261  260\nCONECT  262  260\nCONECT  263  260  264\nCONECT  264  263  265\nCONECT  265  264  266  267\nCONECT  266  265  270\nCONECT  267  265  268  269\nCONECT  268  267  282\nCONECT  269  267  270\nCONECT  270  266  269  271\nCONECT  271  270  272  281\nCONECT  272  271  273\nCONECT  273  272  274\nCONECT  274  273  275  281\nCONECT  275  274  276  277\nCONECT  276  275\nCONECT  277  275  278\nCONECT  278  277  279  280\nCONECT  279  278\nCONECT  280  278  281\nCONECT  281  271  274  280\nCONECT  282  268  283  284  285\nCONECT  283  282\nCONECT  284  282\nCONECT  285  282  286\nCONECT  286  285  287\nCONECT  287  286  288  289\nCONECT  288  287  292\nCONECT  289  287  290  291\nCONECT  290  289  301\nCONECT  291  289  292\nCONECT  292  288  291  293\nCONECT  293  292  294  300\nCONECT  294  293  295  296\nCONECT  295  294\nCONECT  296  294  297\nCONECT  297  296  298  299\nCONECT  298  297\nCONECT  299  297  300\nCONECT  300  293  299\nCONECT  301  290  302  303  304\nCONECT  302  301\nCONECT  303  301\nCONECT  304  301  305\nCONECT  305  304  306\nCONECT  306  305  307  308\nCONECT  307  306  311\nCONECT  308  306  309  310\nCONECT  309  308  323\nCONECT  310  308  311\nCONECT  311  307  310  312\nCONECT  312  311  313  322\nCONECT  313  312  314\nCONECT  314  313  315\nCONECT  315  314  316  322\nCONECT  316  315  317  318\nCONECT  317  316\nCONECT  318  316  319\nCONECT  319  318  320  321\nCONECT  320  319\nCONECT  321  319  322\nCONECT  322  312  315  321\nCONECT  323  309  324  325  326\nCONECT  324  323\nCONECT  325  323\nCONECT  326  323  327\nCONECT  327  326  328\nCONECT  328  327  329  330\nCONECT  329  328  333\nCONECT  330  328  331  332\nCONECT  331  330  344\nCONECT  332  330  333\nCONECT  333  329  332  334\nCONECT  334  333  335  343\nCONECT  335  334  336\nCONECT  336  335  337\nCONECT  337  336  338  343\nCONECT  338  337  339  340\nCONECT  339  338\nCONECT  340  338  341\nCONECT  341  340  342\nCONECT  342  341  343\nCONECT  343  334  337  342\nCONECT  344  331  345  346  347\nCONECT  345  344\nCONECT  346  344\nCONECT  347  344  348\nCONECT  348  347  349\nCONECT  349  348  350  351\nCONECT  350  349  354\nCONECT  351  349  352  353\nCONECT  352  351  365\nCONECT  353  351  354\nCONECT  354  350  353  355\nCONECT  355  354  356  364\nCONECT  356  355  357\nCONECT  357  356  358\nCONECT  358  357  359  364\nCONECT  359  358  360  361\nCONECT  360  359\nCONECT  361  359  362\nCONECT  362  361  363\nCONECT  363  362  364\nCONECT  364  355  358  363\nCONECT  365  352  366  367  368\nCONECT  366  365\nCONECT  367  365\nCONECT  368  365  369\nCONECT  369  368  370\nCONECT  370  369  371  372\nCONECT  371  370  375\nCONECT  372  370  373  374\nCONECT  373  372  385\nCONECT  374  372  375\nCONECT  375  371  374  376\nCONECT  376  375  377  384\nCONECT  377  376  378  379\nCONECT  378  377\nCONECT  379  377  380\nCONECT  380  379  381  382\nCONECT  381  380\nCONECT  382  380  383  384\nCONECT  383  382\nCONECT  384  376  382\nCONECT  385  373  386  387  388\nCONECT  386  385\nCONECT  387  385\nCONECT  388  385  389\nCONECT  389  388  390\nCONECT  390  389  391  392\nCONECT  391  390  395\nCONECT  392  390  393  394\nCONECT  393  392  405\nCONECT  394  392  395\nCONECT  395  391  394  396\nCONECT  396  395  397  404\nCONECT  397  396  398  399\nCONECT  398  397\nCONECT  399  397  400\nCONECT  400  399  401  402\nCONECT  401  400\nCONECT  402  400  403  404\nCONECT  403  402\nCONECT  404  396  402\nCONECT  405  393  406  407  408\nCONECT  406  405\nCONECT  407  405\nCONECT  408  405  409\nCONECT  409  408  410\nCONECT  410  409  411  412\nCONECT  411  410  415\nCONECT  412  410  413  414\nCONECT  413  412  424\nCONECT  414  412  415\nCONECT  415  411  414  416\nCONECT  416  415  417  423\nCONECT  417  416  418  419\nCONECT  418  417\nCONECT  419  417  420\nCONECT  420  419  421  422\nCONECT  421  420\nCONECT  422  420  423\nCONECT  423  416  422\nCONECT  424  413  425  426  427\nCONECT  425  424\nCONECT  426  424\nCONECT  427  424  428\nCONECT  428  427  429\nCONECT  429  428  430  431\nCONECT  430  429  434\nCONECT  431  429  432  433\nCONECT  432  431  446\nCONECT  433  431  434\nCONECT  434  430  433  435\nCONECT  435  434  436  445\nCONECT  436  435  437\nCONECT  437  436  438\nCONECT  438  437  439  445\nCONECT  439  438  440  441\nCONECT  440  439\nCONECT  441  439  442\nCONECT  442  441  443  444\nCONECT  443  442\nCONECT  444  442  445\nCONECT  445  435  438  444\nCONECT  446  432  447  448  449\nCONECT  447  446\nCONECT  448  446\nCONECT  449  446  450\nCONECT  450  449  451\nCONECT  451  450  452  453\nCONECT  452  451  456\nCONECT  453  451  454  455\nCONECT  454  453  465\nCONECT  455  453  456\nCONECT  456  452  455  457\nCONECT  457  456  458  464\nCONECT  458  457  459  460\nCONECT  459  458\nCONECT  460  458  461\nCONECT  461  460  462  463\nCONECT  462  461\nCONECT  463  461  464\nCONECT  464  457  463\nCONECT  465  454  466  467  468\nCONECT  466  465\nCONECT  467  465\nCONECT  468  465  469\nCONECT  469  468  470\nCONECT  470  469  471  472\nCONECT  471  470  475\nCONECT  472  470  473  474\nCONECT  473  472\nCONECT  474  472  475\nCONECT  475  471  474  476\nCONECT  476  475  477  486\nCONECT  477  476  478\nCONECT  478  477  479\nCONECT  479  478  480  486\nCONECT  480  479  481  482\nCONECT  481  480\nCONECT  482  480  483\nCONECT  483  482  484  485\nCONECT  484  483\nCONECT  485  483  486\nCONECT  486  476  479  485\nEND\n",
    "HEADER    Dodecahedrane\nCOMPND    al3056\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Sun Sep  3 10:20:00 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.540   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.016   1.465   0.000  1.00  0.00 \nHETATM    4  C           1       0.771   2.369   0.000  1.00  0.00 \nHETATM    5  C           1      -0.476   1.465   0.000  1.00  0.00 \nHETATM    6  C           1      -0.476  -0.655   1.309  1.00  0.00 \nHETATM    7  C           1      -1.246   0.404   2.118  1.00  0.00 \nHETATM    8  C           1      -1.246   1.714   1.309  1.00  0.00 \nHETATM    9  C           1      -0.476   2.774   2.119  1.00  0.00 \nHETATM   10  C           1       0.770   3.179   1.310  1.00  0.00 \nHETATM   11  C           1       2.016   2.774   2.120  1.00  0.00 \nHETATM   12  C           1       2.786   1.715   1.310  1.00  0.00 \nHETATM   13  C           1       2.785   0.405   2.120  1.00  0.00 \nHETATM   14  C           1       2.016  -0.655   1.310  1.00  0.00 \nHETATM   15  C           1       0.769  -1.059   2.118  1.00  0.00 \nHETATM   16  C           1       0.770  -0.250   3.428  1.00  0.00 \nHETATM   17  C           1      -0.476   0.655   3.428  1.00  0.00 \nHETATM   18  C           1       2.015   0.656   3.429  1.00  0.00 \nHETATM   19  C           1       0.000   2.119   3.428  1.00  0.00 \nHETATM   20  C           1       1.539   2.119   3.428  1.00  0.00 \nHETATM   21  H           1      -0.389  -0.536  -0.866  1.00  0.00 \nHETATM   22  H           1       1.929  -0.535  -0.866  1.00  0.00 \nHETATM   23  H           1       2.645   1.669  -0.866  1.00  0.00 \nHETATM   24  H           1       0.771   3.031  -0.867  1.00  0.00 \nHETATM   25  H           1      -1.105   1.670  -0.867  1.00  0.00 \nHETATM   26  H           1      -1.105  -1.521   1.105  1.00  0.00 \nHETATM   27  H           1      -2.264   0.073   2.321  1.00  0.00 \nHETATM   28  H           1      -2.264   2.044   1.104  1.00  0.00 \nHETATM   29  H           1      -1.105   3.639   2.324  1.00  0.00 \nHETATM   30  H           1       0.771   4.249   1.105  1.00  0.00 \nHETATM   31  H           1       2.645   3.640   2.327  1.00  0.00 \nHETATM   32  H           1       3.804   2.046   1.106  1.00  0.00 \nHETATM   33  H           1       3.803   0.073   2.325  1.00  0.00 \nHETATM   34  H           1       2.645  -1.522   1.106  1.00  0.00 \nHETATM   35  H           1       0.769  -2.130   2.322  1.00  0.00 \nHETATM   36  H           1       0.771  -0.912   4.294  1.00  0.00 \nHETATM   37  H           1      -1.106   0.451   4.294  1.00  0.00 \nHETATM   38  H           1       2.644   0.453   4.295  1.00  0.00 \nHETATM   39  H           1      -0.387   2.655   4.295  1.00  0.00 \nHETATM   40  H           1       1.928   2.654   4.295  1.00  0.00 \nCONECT    1    2    5    6   21\nCONECT    2    1    3   14   22\nCONECT    3    2    4   12   23\nCONECT    4    3    5   10   24\nCONECT    5    1    4    8   25\nCONECT    6    1    7   15   26\nCONECT    7    6    8   17   27\nCONECT    8    5    7    9   28\nCONECT    9    8   10   19   29\nCONECT   10    4    9   11   30\nCONECT   11   10   12   20   31\nCONECT   12    3   11   13   32\nCONECT   13   12   14   18   33\nCONECT   14    2   13   15   34\nCONECT   15    6   14   16   35\nCONECT   16   15   17   18   36\nCONECT   17    7   16   19   37\nCONECT   18   13   16   20   38\nCONECT   19    9   17   20   39\nCONECT   20   11   18   19   40\nCONECT   21    1\nCONECT   22    2\nCONECT   23    3\nCONECT   24    4\nCONECT   25    5\nCONECT   26    6\nCONECT   27    7\nCONECT   28    8\nCONECT   29    9\nCONECT   30   10\nCONECT   31   11\nCONECT   32   12\nCONECT   33   13\nCONECT   34   14\nCONECT   35   15\nCONECT   36   16\nCONECT   37   17\nCONECT   38   18\nCONECT   39   19\nCONECT   40   20\nMASTER        0    0    0    0    0    0    0    0   40    0   40    0\nEND\n",
    "HEADER    Tetrahydrocannabinol: Delta 9-THC, an hallucinogen\nATOM      1  O   UNK     0      -1.791  -1.420   0.434\nATOM      2  C   UNK     0      -0.536  -1.012   0.033\nATOM      3  C   UNK     0       0.565  -1.346   0.828\nATOM      4  C   UNK     0       1.855  -0.978   0.446\nATOM      5  C   UNK     0       2.038  -0.295  -0.757\nATOM      6  C   UNK     0       0.940   0.052  -1.556\nATOM      7  C   UNK     0      -0.363  -0.272  -1.148\nATOM      8  C   UNK     0      -1.599   0.113  -1.985\nATOM      9  C   UNK     0      -1.568   1.523  -2.537\nATOM     10  C   UNK     0      -2.681   2.231  -2.781\nATOM     11  C   UNK     0      -4.068   1.708  -2.479\nATOM     12  C   UNK     0      -4.085   0.222  -2.091\nATOM     13  C   UNK     0      -2.892  -0.061  -1.162\nATOM     14  C   UNK     0      -2.908  -1.421  -0.435\nATOM     15  O   UNK     0       1.151   0.702  -2.747\nATOM     16  C   UNK     0      -2.610   3.628  -3.338\nATOM     17  C   UNK     0      -2.824  -2.642  -1.364\nATOM     18  C   UNK     0      -4.125  -1.570   0.485\nATOM     19  C   UNK     0       3.056  -1.332   1.325\nATOM     20  C   UNK     0       3.365  -0.156   2.260\nATOM     21  C   UNK     0       4.569  -0.467   3.158\nATOM     22  C   UNK     0       4.872   0.726   4.074\nATOM     23  C   UNK     0       6.079   0.425   4.969\nATOM     24  H   UNK     0       0.400  -1.896   1.747\nATOM     25  H   UNK     0      -1.626  -0.566  -2.849\nATOM     26  H   UNK     0      -4.720   1.866  -3.352\nATOM     27  H   UNK     0      -4.004  -0.399  -2.997\nATOM     28  H   UNK     0       2.079   0.837  -2.898\nATOM     29  H   UNK     0      -3.163   4.315  -2.681\nATOM     30  H   UNK     0      -2.839  -3.562  -0.762\nATOM     31  H   UNK     0      -3.995  -2.460   1.119\nATOM     32  H   UNK     0      -4.210  -0.687   1.134\nATOM     33  H   UNK     0       2.828  -2.232   1.917\nATOM     34  H   UNK     0       2.480   0.048   2.884\nATOM     35  H   UNK     0       4.349  -1.356   3.772\nATOM     36  H   UNK     0       3.994   0.938   4.706\nATOM     37  H   UNK     0       6.286   1.290   5.618\nATOM     38  H   UNK     0       3.036  -0.022  -1.076\nATOM     39  H   UNK     0      -0.602   1.973  -2.755\nATOM     40  H   UNK     0      -5.037  -0.005  -1.590\nATOM     41  H   UNK     0      -2.881   0.709  -0.374\nATOM     42  H   UNK     0      -1.565   3.966  -3.407\nATOM     43  H   UNK     0      -3.058   3.644  -4.342\nATOM     44  H   UNK     0      -1.884  -2.619  -1.933\nATOM     45  H   UNK     0      -3.674  -2.652  -2.061\nATOM     46  H   UNK     0      -5.048  -1.683  -0.102\nATOM     47  H   UNK     0       3.928  -1.546   0.687\nATOM     48  H   UNK     0       3.578   0.739   1.654\nATOM     49  H   UNK     0       5.449  -0.681   2.531\nATOM     50  H   UNK     0       5.086   1.616   3.462\nATOM     51  H   UNK     0       5.873  -0.453   5.600\nATOM     52  H   UNK     0       6.967   0.224   4.351\nATOM     53  H   UNK     0      -4.467   2.295  -1.638\nCONECT    1    2   14\nCONECT    2    1    3    7\nCONECT    3    2    4   24\nCONECT    4    3    5   19\nCONECT    5    4    6   38\nCONECT    6    5    7   15\nCONECT    7    2    6    8\nCONECT    8    7    9   13   25\nCONECT    9    8   10   39\nCONECT   10    9   11   16\nCONECT   11   10   12   26   53\nCONECT   12   11   27   40   13\nCONECT   13    8   12   41   14\nCONECT   14    1   13   17   18\nCONECT   15    6   28\nCONECT   16   10   29   42   43\nCONECT   17   14   30   44   45\nCONECT   18   14   31   32   46\nCONECT   19    4   20   33   47\nCONECT   20   19   21   34   48\nCONECT   21   20   22   35   49\nCONECT   22   21   23   36   50\nCONECT   23   22   37   51   52\nCONECT   24    3\nCONECT   25    8\nCONECT   26   11\nCONECT   27   12\nCONECT   28   15\nCONECT   29   16\nCONECT   30   17\nCONECT   31   18\nCONECT   32   18\nCONECT   33   19\nCONECT   34   20\nCONECT   35   21\nCONECT   36   22\nCONECT   37   23\nCONECT   38    5\nCONECT   39    9\nCONECT   40   12\nCONECT   41   13\nCONECT   42   16\nCONECT   43   16\nCONECT   44   17\nCONECT   45   17\nCONECT   46   18\nCONECT   47   19\nCONECT   48   20\nCONECT   49   21\nCONECT   50   22\nCONECT   51   23\nCONECT   52   23\nCONECT   53   11\n",
    "HEADER    Trinitroglycerin: Dynamite, an explosive\nCOMPND    jb09trin\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Tue Sep 19 21:46:02 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.540   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.063   1.449   0.000  1.00  0.00 \nHETATM    4  O           1       3.467   1.429   0.127  1.00  0.00 \nHETATM    5  N           1       4.015   2.776  -0.152  1.00  0.00 \nHETATM    6  O           1       4.998   3.268   0.635  1.00  0.00 \nHETATM    7  O           1       3.773   3.351  -1.351  1.00  0.00 \nHETATM    8  O           1       2.004  -0.755   1.098  1.00  0.00 \nHETATM    9  N           1       2.641  -0.291   2.107  1.00  0.00 \nHETATM   10  O           1       3.090  -1.154   3.047  1.00  0.00 \nHETATM   11  O           1       2.879   1.030   2.268  1.00  0.00 \nHETATM   12  O           1      -0.458  -1.330  -0.079  1.00  0.00 \nHETATM   13  N           1      -1.911  -1.339  -0.361  1.00  0.00 \nHETATM   14  O           1      -2.745  -2.029   0.450  1.00  0.00 \nHETATM   15  O           1      -2.357  -0.902  -1.560  1.00  0.00 \nHETATM   16  H           1      -0.365   0.561  -0.860  1.00  0.00 \nHETATM   17  H           1      -0.369   0.458   0.918  1.00  0.00 \nHETATM   18  H           1       1.886  -0.486  -0.912  1.00  0.00 \nHETATM   19  H           1       1.620   2.013   0.821  1.00  0.00 \nHETATM   20  H           1       1.793   1.925  -0.943  1.00  0.00 \nCONECT    1    2   12   16   17\nCONECT    2    1    3    8   18\nCONECT    3    2    4   19   20\nCONECT    4    3    5\nCONECT    5    4    6    7\nCONECT    6    5\nCONECT    7    5\nCONECT    8    2    9\nCONECT    9    8   10   11\nCONECT   10    9\nCONECT   11    9\nCONECT   12    1   13\nCONECT   13   12   14   15\nCONECT   14   13\nCONECT   15   13\nCONECT   16    1\nCONECT   17    1\nCONECT   18    2\nCONECT   19    3\nCONECT   20    3\nMASTER        0    0    0    0    0    0    0    0   20    0   20    0\nEND\n",
    "HEADER    Ethylene Glycol: Ethane-1,2-diol, Anti-freeze\nCOMPND    al2034\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Tue Aug 29 17:54:52 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.542   0.000   0.000  1.00  0.00 \nHETATM    3  O           1       2.027   1.347   0.000  1.00  0.00 \nHETATM    4  O           1      -0.485  -1.347  -0.041  1.00  0.00 \nHETATM    5  H           1      -0.360   0.537  -0.878  1.00  0.00 \nHETATM    6  H           1      -0.367   0.494   0.900  1.00  0.00 \nHETATM    7  H           1       1.902  -0.512  -0.893  1.00  0.00 \nHETATM    8  H           1       1.908  -0.520   0.885  1.00  0.00 \nHETATM    9  H           1       1.743   1.800   0.802  1.00  0.00 \nHETATM   10  H           1      -0.202  -1.823   0.747  1.00  0.00 \nCONECT    1    2    4    5    6\nCONECT    2    1    3    7    8\nCONECT    3    2    9\nCONECT    4    1   10\nCONECT    5    1\nCONECT    6    1\nCONECT    7    2\nCONECT    8    2\nCONECT    9    3\nCONECT   10    4\nMASTER        0    0    0    0    0    0    0    0   10    0   10    0\nEND\n",
    "HEADER    Guanine: Purine base nucleotide\nCOMPND    jb09guan\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Tue Sep 19 21:46:02 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.392   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.082   1.215   0.000  1.00  0.00 \nHETATM    4  N           1       1.339   2.346  -0.001  1.00  0.00 \nHETATM    5  C           1      -0.017   2.313  -0.003  1.00  0.00 \nHETATM    6  N           1      -0.709   1.149  -0.003  1.00  0.00 \nHETATM    7  N           1      -0.392  -1.291  -0.028  1.00  0.00 \nHETATM    8  C           1       0.730  -2.047  -0.044  1.00  0.00 \nHETATM    9  N           1       1.842  -1.275  -0.028  1.00  0.00 \nHETATM   10  O           1       3.285   1.253  -0.010  1.00  0.00 \nHETATM   11  N           1      -0.723   3.523  -0.019  1.00  0.00 \nHETATM   12  H           1       1.811   3.244  -0.007  1.00  0.00 \nHETATM   13  H           1      -1.347  -1.629  -0.048  1.00  0.00 \nHETATM   14  H           1       0.738  -3.137  -0.077  1.00  0.00 \nHETATM   15  H           1      -1.640   3.377  -0.427  1.00  0.00 \nHETATM   16  H           1      -0.213   4.205  -0.570  1.00  0.00 \nCONECT    1    2    2    6    7\nCONECT    2    1    1    3    9\nCONECT    3    2    4   10   10\nCONECT    4    3    5   12\nCONECT    5    4    6    6   11\nCONECT    6    1    5    5\nCONECT    7    1    8   13\nCONECT    8    7    9    9   14\nCONECT    9    2    8    8\nCONECT   10    3    3\nCONECT   11    5   15   16\nCONECT   12    4\nCONECT   13    7\nCONECT   14    8\nCONECT   15   11\nCONECT   16   11\nMASTER        0    0    0    0    0    0    0    0   16    0   16    0\nEND\n",
    "HEADER    Diacetylmorphine: Heroin, an opiate\nCOMPND    al3084\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Aug 30 12:33:12 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.400   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.108   1.210   0.000  1.00  0.00 \nHETATM    4  C           1       1.452   2.447  -0.065  1.00  0.00 \nHETATM    5  C           1       0.055   2.457  -0.018  1.00  0.00 \nHETATM    6  C           1      -0.624   1.244   0.041  1.00  0.00 \nHETATM    7  C           1      -2.081   1.501  -0.201  1.00  0.00 \nHETATM    8  C           1      -2.725   0.343  -0.973  1.00  0.00 \nHETATM    9  C           1      -2.367  -0.953  -0.210  1.00  0.00 \nHETATM   10  C           1      -0.836  -1.236  -0.253  1.00  0.00 \nHETATM   11  C           1      -1.913   2.852  -0.934  1.00  0.00 \nHETATM   12  C           1      -2.752   1.623   1.177  1.00  0.00 \nHETATM   13  C           1      -2.503   0.306   1.943  1.00  0.00 \nHETATM   14  N           1      -2.936  -0.856   1.147  1.00  0.00 \nHETATM   15  C           1      -2.820  -2.103   1.920  1.00  0.00 \nHETATM   16  H           1      -3.807   0.473  -0.972  1.00  0.00 \nHETATM   17  C           1      -2.256   0.283  -2.408  1.00  0.00 \nHETATM   18  C           1      -1.948   1.398  -3.085  1.00  0.00 \nHETATM   19  C           1      -1.494   2.675  -2.413  1.00  0.00 \nHETATM   20  H           1      -2.820   3.452  -0.859  1.00  0.00 \nHETATM   21  O           1      -0.799   3.480  -0.318  1.00  0.00 \nHETATM   22  H           1      -1.885   3.520  -2.982  1.00  0.00 \nHETATM   23  O           1      -0.083   2.674  -2.462  1.00  0.00 \nHETATM   24  O           1       2.142   3.620  -0.142  1.00  0.00 \nHETATM   25  H           1       1.942  -0.945  -0.044  1.00  0.00 \nHETATM   26  H           1       3.198   1.180  -0.006  1.00  0.00 \nHETATM   27  H           1      -2.866  -1.782  -0.712  1.00  0.00 \nHETATM   28  H           1      -0.588  -1.599  -1.250  1.00  0.00 \nHETATM   29  H           1      -0.574  -2.010   0.465  1.00  0.00 \nHETATM   30  H           1      -3.823   1.785   1.052  1.00  0.00 \nHETATM   31  H           1      -2.320   2.456   1.731  1.00  0.00 \nHETATM   32  H           1      -3.068   0.334   2.874  1.00  0.00 \nHETATM   33  H           1      -1.444   0.211   2.184  1.00  0.00 \nHETATM   34  H           1      -3.492  -2.057   2.778  1.00  0.00 \nHETATM   35  H           1      -1.799  -2.234   2.280  1.00  0.00 \nHETATM   36  H           1      -3.099  -2.953   1.298  1.00  0.00 \nHETATM   37  H           1      -2.414  -0.639  -2.967  1.00  0.00 \nHETATM   38  H           1      -1.797   1.313  -4.161  1.00  0.00 \nHETATM   39  C           1       3.076   3.567  -1.091  1.00  0.00 \nHETATM   40  O           1       2.786   3.826  -2.230  1.00  0.00 \nHETATM   41  C           1       4.523   3.509  -0.695  1.00  0.00 \nHETATM   42  H           1       5.012   2.691  -1.224  1.00  0.00 \nHETATM   43  H           1       4.600   3.345   0.380  1.00  0.00 \nHETATM   44  H           1       5.008   4.450  -0.954  1.00  0.00 \nHETATM   45  C           1       0.390   3.733  -3.117  1.00  0.00 \nHETATM   46  O           1       0.845   3.595  -4.223  1.00  0.00 \nHETATM   47  C           1       0.417   5.083  -2.459  1.00  0.00 \nHETATM   48  H           1       1.199   5.692  -2.913  1.00  0.00 \nHETATM   49  H           1       0.619   4.970  -1.395  1.00  0.00 \nHETATM   50  H           1      -0.547   5.574  -2.594  1.00  0.00 \nCONECT    1    2    2    6   10\nCONECT    2    1    1    3   25\nCONECT    3    2    4    4   26\nCONECT    4    3    3    5   24\nCONECT    5    4    6    6   21\nCONECT    6    1    5    5    7\nCONECT    7    6    8   11   12\nCONECT    8    7    9   16   17\nCONECT    9    8   10   14   27\nCONECT   10    1    9   28   29\nCONECT   11    7   19   20   21\nCONECT   12    7   13   30   31\nCONECT   13   12   14   32   33\nCONECT   14    9   13   15\nCONECT   15   14   34   35   36\nCONECT   16    8\nCONECT   17    8   18   18   37\nCONECT   18   17   17   19   38\nCONECT   19   11   18   22   23\nCONECT   20   11\nCONECT   21    5   11\nCONECT   22   19\nCONECT   23   19   45\nCONECT   24    4   39\nCONECT   25    2\nCONECT   26    3\nCONECT   27    9\nCONECT   28   10\nCONECT   29   10\nCONECT   30   12\nCONECT   31   12\nCONECT   32   13\nCONECT   33   13\nCONECT   34   15\nCONECT   35   15\nCONECT   36   15\nCONECT   37   17\nCONECT   38   18\nCONECT   39   24   40   40   41\nCONECT   40   39   39\nCONECT   41   39   42   43   44\nCONECT   42   41\nCONECT   43   41\nCONECT   44   41\nCONECT   45   23   46   46   47\nCONECT   46   45   45\nCONECT   47   45   48   49   50\nCONECT   48   47\nCONECT   49   47\nCONECT   50   47\nMASTER        0    0    0    0    0    0    0    0   50    0   50    0\nEND\n",
    "COMPND    Hexahelicene\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep  1 09:41:05 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.404   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.104   1.206   0.000  1.00  0.00 \nHETATM    4  C           1       1.402   2.413  -0.064  1.00  0.00 \nHETATM    5  C           1       0.002   2.407  -0.063  1.00  0.00 \nHETATM    6  C           1      -0.705   1.209   0.071  1.00  0.00 \nHETATM    7  C           1      -2.102   1.180   0.220  1.00  0.00 \nHETATM    8  C           1      -2.847   2.295   0.643  1.00  0.00 \nHETATM    9  C           1      -4.192   2.360   0.266  1.00  0.00 \nHETATM   10  C           1      -4.858   1.229  -0.190  1.00  0.00 \nHETATM   11  C           1      -4.166   0.012  -0.273  1.00  0.00 \nHETATM   12  C           1      -2.782  -0.001  -0.086  1.00  0.00 \nHETATM   13  C           1      -2.082  -1.204  -0.224  1.00  0.00 \nHETATM   14  C           1      -0.685  -1.210  -0.107  1.00  0.00 \nHETATM   15  C           1      -2.318   3.332   1.420  1.00  0.00 \nHETATM   16  C           1      -1.206   3.177   2.264  1.00  0.00 \nHETATM   17  C           1      -0.519   4.289   2.729  1.00  0.00 \nHETATM   18  C           1      -1.052   5.582   2.503  1.00  0.00 \nHETATM   19  C           1      -2.286   5.716   1.895  1.00  0.00 \nHETATM   20  C           1      -2.936   4.583   1.371  1.00  0.00 \nHETATM   21  C           1      -4.216   4.717   0.815  1.00  0.00 \nHETATM   22  C           1      -4.881   3.585   0.350  1.00  0.00 \nHETATM   23  C           1      -0.789   1.905   2.707  1.00  0.00 \nHETATM   24  C           1       0.400   1.759   3.421  1.00  0.00 \nHETATM   25  C           1       1.155   2.887   3.765  1.00  0.00 \nHETATM   26  C           1       0.669   4.165   3.443  1.00  0.00 \nHETATM   27  H           1       1.945  -0.947  -0.019  1.00  0.00 \nHETATM   28  H           1       3.191   1.206  -0.002  1.00  0.00 \nHETATM   29  H           1       1.942   3.359  -0.131  1.00  0.00 \nHETATM   30  H           1      -0.523   3.350  -0.198  1.00  0.00 \nHETATM   31  H           1      -5.918   1.264  -0.433  1.00  0.00 \nHETATM   32  H           1      -4.698  -0.901  -0.555  1.00  0.00 \nHETATM   33  H           1      -2.617  -2.140  -0.409  1.00  0.00 \nHETATM   34  H           1      -0.142  -2.150  -0.180  1.00  0.00 \nHETATM   35  H           1      -0.520   6.457   2.886  1.00  0.00 \nHETATM   36  H           1      -2.751   6.690   1.806  1.00  0.00 \nHETATM   37  H           1      -4.715   5.680   0.815  1.00  0.00 \nHETATM   38  H           1      -5.917   3.654   0.008  1.00  0.00 \nHETATM   39  H           1      -1.407   1.021   2.524  1.00  0.00 \nHETATM   40  H           1       0.734   0.774   3.725  1.00  0.00 \nHETATM   41  H           1       2.090   2.777   4.328  1.00  0.00 \nHETATM   42  H           1       1.225   5.042   3.772  1.00  0.00 \nCONECT    1    2    2    6   14\nCONECT    2    1    1    3   27\nCONECT    3    2    4    4   28\nCONECT    4    3    3    5   29\nCONECT    5    4    6    6   30\nCONECT    6    1    5    5    7\nCONECT    7    6    8    8   12\nCONECT    8    7    7    9   15\nCONECT    9    8   10   10   22\nCONECT   10    9    9   11   31\nCONECT   11   10   12   12   32\nCONECT   12    7   11   11   13\nCONECT   13   12   14   14   33\nCONECT   14    1   13   13   34\nCONECT   15    8   16   16   20\nCONECT   16   15   15   17   23\nCONECT   17   16   18   18   26\nCONECT   18   17   17   19   35\nCONECT   19   18   20   20   36\nCONECT   20   15   19   19   21\nCONECT   21   20   22   22   37\nCONECT   22    9   21   21   38\nCONECT   23   16   24   24   39\nCONECT   24   23   23   25   40\nCONECT   25   24   26   26   41\nCONECT   26   17   25   25   42\nCONECT   27    2\nCONECT   28    3\nCONECT   29    4\nCONECT   30    5\nCONECT   31   10\nCONECT   32   11\nCONECT   33   13\nCONECT   34   14\nCONECT   35   18\nCONECT   36   19\nCONECT   37   21\nCONECT   38   22\nCONECT   39   23\nCONECT   40   24\nCONECT   41   25\nCONECT   42   26\nMASTER        0    0    0    0    0    0    0    0   42    0   42    0\nEND\n",
    "HEADER    Ibuprofen: Advil/Motrin, an anti-inflammatory\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep  1 09:41:05 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.399   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.098   1.212   0.000  1.00  0.00 \nHETATM    4  C           1       1.391   2.419   0.004  1.00  0.00 \nHETATM    5  C           1      -0.008   2.417   0.005  1.00  0.00 \nHETATM    6  C           1      -0.712   1.206  -0.003  1.00  0.00 \nHETATM    7  C           1      -2.224   1.136  -0.009  1.00  0.00 \nHETATM    8  C           1      -2.900   2.504  -0.232  1.00  0.00 \nHETATM    9  C           1       3.611   1.210  -0.042  1.00  0.00 \nHETATM   10  C           1       4.094   0.909  -1.477  1.00  0.00 \nHETATM   11  C           1       5.635   0.868  -1.503  1.00  0.00 \nHETATM   12  C           1       3.590   1.996  -2.450  1.00  0.00 \nHETATM   13  C           1      -2.686   0.573   1.305  1.00  0.00 \nHETATM   14  O           1      -3.846   0.297   1.466  1.00  0.00 \nHETATM   15  O           1      -1.792   0.321   2.277  1.00  0.00 \nHETATM   16  H           1      -0.539  -0.948  -0.004  1.00  0.00 \nHETATM   17  H           1       1.943  -0.945  -0.009  1.00  0.00 \nHETATM   18  H           1       1.930   3.366  -0.006  1.00  0.00 \nHETATM   19  H           1      -0.533   3.371   0.004  1.00  0.00 \nHETATM   20  H           1      -2.536   0.461  -0.807  1.00  0.00 \nHETATM   21  H           1      -2.546   2.944  -1.165  1.00  0.00 \nHETATM   22  H           1      -2.676   3.171   0.600  1.00  0.00 \nHETATM   23  H           1      -3.980   2.365  -0.292  1.00  0.00 \nHETATM   24  H           1       3.986   0.442   0.635  1.00  0.00 \nHETATM   25  H           1       3.990   2.181   0.277  1.00  0.00 \nHETATM   26  H           1       3.707  -0.061  -1.792  1.00  0.00 \nHETATM   27  H           1       5.991   0.094  -0.823  1.00  0.00 \nHETATM   28  H           1       6.034   1.834  -1.192  1.00  0.00 \nHETATM   29  H           1       5.978   0.645  -2.513  1.00  0.00 \nHETATM   30  H           1       3.941   2.975  -2.122  1.00  0.00 \nHETATM   31  H           1       2.500   1.993  -2.477  1.00  0.00 \nHETATM   32  H           1       3.970   1.793  -3.451  1.00  0.00 \nHETATM   33  H           1      -1.689  -0.648   2.383  1.00  0.00 \nCONECT    1    2    2    6   16\nCONECT    2    1    1    3   17\nCONECT    3    2    4    4    9\nCONECT    4    3    3    5   18\nCONECT    5    4    6    6   19\nCONECT    6    1    5    5    7\nCONECT    7    6    8   13   20\nCONECT    8    7   21   22   23\nCONECT    9    3   10   24   25\nCONECT   10    9   11   12   26\nCONECT   11   10   27   28   29\nCONECT   12   10   30   31   32\nCONECT   13    7   14   14   15\nCONECT   14   13   13\nCONECT   15   13   33\nCONECT   16    1\nCONECT   17    2\nCONECT   18    4\nCONECT   19    5\nCONECT   20    7\nCONECT   21    8\nCONECT   22    8\nCONECT   23    8\nCONECT   24    9\nCONECT   25    9\nCONECT   26   10\nCONECT   27   11\nCONECT   28   11\nCONECT   29   11\nCONECT   30   12\nCONECT   31   12\nCONECT   32   12\nCONECT   33   15\nMASTER        0    0    0    0    0    0    0    0   33    0   33    0\nEND\n",
    "HEADER    Lysergic acid diethylamide, a potent hallucinogen\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep  1 09:41:05 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.397   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.012   1.258   0.000  1.00  0.00 \nHETATM    4  C           1       1.246   2.433  -0.052  1.00  0.00 \nHETATM    5  C           1      -0.155   2.405  -0.125  1.00  0.00 \nHETATM    6  C           1      -0.773   1.155  -0.096  1.00  0.00 \nHETATM    7  N           1      -2.065   0.769  -0.378  1.00  0.00 \nHETATM    8  C           1      -2.092  -0.602  -0.503  1.00  0.00 \nHETATM    9  C           1      -0.810  -1.103  -0.242  1.00  0.00 \nHETATM   10  C           1      -0.159  -2.415  -0.700  1.00  0.00 \nHETATM   11  C           1       1.178  -2.555   0.075  1.00  0.00 \nHETATM   12  C           1       2.056  -1.321  -0.019  1.00  0.00 \nHETATM   13  H           1       0.916  -2.675   1.126  1.00  0.00 \nHETATM   14  N           1       1.899  -3.768  -0.346  1.00  0.00 \nHETATM   15  C           1       3.394  -1.430   0.057  1.00  0.00 \nHETATM   16  C           1       4.101  -2.765   0.134  1.00  0.00 \nHETATM   17  C           1       3.115  -3.899   0.470  1.00  0.00 \nHETATM   18  H           1       4.565  -2.960  -0.830  1.00  0.00 \nHETATM   19  C           1       5.121  -2.704   1.237  1.00  0.00 \nHETATM   20  O           1       4.720  -2.413   2.335  1.00  0.00 \nHETATM   21  N           1       6.434  -3.000   1.089  1.00  0.00 \nHETATM   22  C           1       7.305  -2.925   2.274  1.00  0.00 \nHETATM   23  C           1       7.755  -4.340   2.686  1.00  0.00 \nHETATM   24  C           1       7.047  -3.307  -0.215  1.00  0.00 \nHETATM   25  C           1       6.736  -4.755  -0.646  1.00  0.00 \nHETATM   26  H           1       3.094   1.350   0.014  1.00  0.00 \nHETATM   27  H           1       1.757   3.398  -0.079  1.00  0.00 \nHETATM   28  H           1      -0.732   3.319  -0.249  1.00  0.00 \nHETATM   29  H           1      -2.858   1.432  -0.658  1.00  0.00 \nHETATM   30  H           1      -2.917  -1.177  -0.924  1.00  0.00 \nHETATM   31  H           1       0.025  -2.349  -1.772  1.00  0.00 \nHETATM   32  H           1      -0.811  -3.260  -0.484  1.00  0.00 \nHETATM   33  H           1       4.015  -0.538   0.044  1.00  0.00 \nHETATM   34  H           1       2.844  -3.840   1.524  1.00  0.00 \nHETATM   35  H           1       3.586  -4.865   0.286  1.00  0.00 \nHETATM   36  H           1       6.768  -2.468   3.105  1.00  0.00 \nHETATM   37  H           1       8.181  -2.318   2.047  1.00  0.00 \nHETATM   38  H           1       8.376  -4.772   1.903  1.00  0.00 \nHETATM   39  H           1       6.879  -4.969   2.844  1.00  0.00 \nHETATM   40  H           1       8.332  -4.283   3.609  1.00  0.00 \nHETATM   41  H           1       8.129  -3.199  -0.132  1.00  0.00 \nHETATM   42  H           1       6.693  -2.606  -0.971  1.00  0.00 \nHETATM   43  H           1       5.663  -4.894  -0.765  1.00  0.00 \nHETATM   44  H           1       7.103  -5.451   0.107  1.00  0.00 \nHETATM   45  H           1       7.230  -4.962  -1.595  1.00  0.00 \nHETATM   46  C           1       2.198  -3.813  -1.786  1.00  0.00 \nHETATM   47  H           1       2.586  -2.854  -2.128  1.00  0.00 \nHETATM   48  H           1       1.292  -4.053  -2.342  1.00  0.00 \nHETATM   49  H           1       2.936  -4.591  -1.982  1.00  0.00 \nCONECT    1    2    2    6    9\nCONECT    2    1    1    3   12\nCONECT    3    2    4    4   26\nCONECT    4    3    3    5   27\nCONECT    5    4    6    6   28\nCONECT    6    1    5    5    7\nCONECT    7    6    8   29\nCONECT    8    7    9    9   30\nCONECT    9    1    8    8   10\nCONECT   10    9   11   31   32\nCONECT   11   10   12   13   14\nCONECT   12    2   11   15   15\nCONECT   13   11\nCONECT   14   11   17   46\nCONECT   15   12   12   16   33\nCONECT   16   15   17   18   19\nCONECT   17   14   16   34   35\nCONECT   18   16\nCONECT   19   16   20   20   21\nCONECT   20   19   19\nCONECT   21   19   22   24\nCONECT   22   21   23   36   37\nCONECT   23   22   38   39   40\nCONECT   24   21   25   41   42\nCONECT   25   24   43   44   45\nCONECT   26    3\nCONECT   27    4\nCONECT   28    5\nCONECT   29    7\nCONECT   30    8\nCONECT   31   10\nCONECT   32   10\nCONECT   33   15\nCONECT   34   17\nCONECT   35   17\nCONECT   36   22\nCONECT   37   22\nCONECT   38   23\nCONECT   39   23\nCONECT   40   23\nCONECT   41   24\nCONECT   42   24\nCONECT   43   25\nCONECT   44   25\nCONECT   45   25\nCONECT   46   14   47   48   49\nCONECT   47   46\nCONECT   48   46\nCONECT   49   46\nMASTER        0    0    0    0    0    0    0    0   49    0   49    0\nEND\n",
    "HEADER    Menthol: Mentha arvensis oil\nCOMPND    menthol\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep  1 09:41:05 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  O           1       1.431   0.000   0.000  1.00  0.00 \nHETATM    3  C           1      -0.501   1.458   0.000  1.00  0.00 \nHETATM    4  C           1      -2.042   1.485  -0.004  1.00  0.00 \nHETATM    5  C           1      -2.576   0.746   1.240  1.00  0.00 \nHETATM    6  C           1      -2.072  -0.710   1.236  1.00  0.00 \nHETATM    7  C           1      -0.528  -0.726   1.258  1.00  0.00 \nHETATM    8  C           1      -0.005  -2.181   1.381  1.00  0.00 \nHETATM    9  C           1       1.486  -2.197   1.780  1.00  0.00 \nHETATM   10  C           1      -0.183  -2.997   0.081  1.00  0.00 \nHETATM   11  C           1      -2.539   2.945   0.003  1.00  0.00 \nHETATM   12  H           1      -0.367  -0.497  -0.898  1.00  0.00 \nHETATM   13  H           1       1.761   0.410  -0.806  1.00  0.00 \nHETATM   14  H           1      -0.129   1.968  -0.889  1.00  0.00 \nHETATM   15  H           1      -0.127   1.969   0.888  1.00  0.00 \nHETATM   16  H           1      -2.409   0.987  -0.903  1.00  0.00 \nHETATM   17  H           1      -3.666   0.750   1.224  1.00  0.00 \nHETATM   18  H           1      -2.229   1.249   2.142  1.00  0.00 \nHETATM   19  H           1      -2.440  -1.211   0.342  1.00  0.00 \nHETATM   20  H           1      -2.455  -1.222   2.119  1.00  0.00 \nHETATM   21  H           1      -0.200  -0.175   2.139  1.00  0.00 \nHETATM   22  H           1      -0.565  -2.673   2.176  1.00  0.00 \nHETATM   23  H           1       1.633  -1.600   2.680  1.00  0.00 \nHETATM   24  H           1       2.100  -1.796   0.975  1.00  0.00 \nHETATM   25  H           1       1.794  -3.223   1.980  1.00  0.00 \nHETATM   26  H           1       0.434  -2.578  -0.713  1.00  0.00 \nHETATM   27  H           1      -1.228  -2.993  -0.228  1.00  0.00 \nHETATM   28  H           1       0.127  -4.026   0.261  1.00  0.00 \nHETATM   29  H           1      -2.165   3.462  -0.880  1.00  0.00 \nHETATM   30  H           1      -2.178   3.451   0.898  1.00  0.00 \nHETATM   31  H           1      -3.629   2.960  -0.005  1.00  0.00 \nCONECT    1    2    3    7   12\nCONECT    2    1   13\nCONECT    3    1    4   14   15\nCONECT    4    3    5   11   16\nCONECT    5    4    6   17   18\nCONECT    6    5    7   19   20\nCONECT    7    1    6    8   21\nCONECT    8    7    9   10   22\nCONECT    9    8   23   24   25\nCONECT   10    8   26   27   28\nCONECT   11    4   29   30   31\nCONECT   12    1\nCONECT   13    2\nCONECT   14    3\nCONECT   15    3\nCONECT   16    4\nCONECT   17    5\nCONECT   18    5\nCONECT   19    6\nCONECT   20    6\nCONECT   21    7\nCONECT   22    8\nCONECT   23    9\nCONECT   24    9\nCONECT   25    9\nCONECT   26   10\nCONECT   27   10\nCONECT   28   10\nCONECT   29   11\nCONECT   30   11\nCONECT   31   11\nMASTER        0    0    0    0    0    0    0    0   31    0   31    0\nEND\n",
    "HEADER    Mescaline: Peyote, an hallucinogen\nCOMPND    jb12mesc\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Sep 20 16:26:54 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.398   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.098   1.213   0.000  1.00  0.00 \nHETATM    4  C           1       1.399   2.424  -0.005  1.00  0.00 \nHETATM    5  C           1      -0.001   2.422   0.013  1.00  0.00 \nHETATM    6  C           1      -0.700   1.211   0.014  1.00  0.00 \nHETATM    7  O           1      -2.062   1.209   0.026  1.00  0.00 \nHETATM    8  C           1      -2.564   1.047  -1.282  1.00  0.00 \nHETATM    9  O           1      -0.682  -1.180  -0.024  1.00  0.00 \nHETATM   10  C           1      -0.867  -1.664   1.288  1.00  0.00 \nHETATM   11  O           1       2.078  -1.180  -0.002  1.00  0.00 \nHETATM   12  C           1       2.225  -1.657  -1.321  1.00  0.00 \nHETATM   13  C           1       2.154   3.735  -0.007  1.00  0.00 \nHETATM   14  C           1       2.388   4.190   1.447  1.00  0.00 \nHETATM   15  N           1       3.124   5.464   1.464  1.00  0.00 \nHETATM   16  H           1       3.188   1.207   0.000  1.00  0.00 \nHETATM   17  H           1      -0.549   3.364   0.023  1.00  0.00 \nHETATM   18  H           1      -2.231   0.093  -1.690  1.00  0.00 \nHETATM   19  H           1      -2.208   1.859  -1.916  1.00  0.00 \nHETATM   20  H           1      -3.653   1.064  -1.252  1.00  0.00 \nHETATM   21  H           1      -1.432  -0.938   1.873  1.00  0.00 \nHETATM   22  H           1       0.101  -1.837   1.758  1.00  0.00 \nHETATM   23  H           1      -1.419  -2.603   1.248  1.00  0.00 \nHETATM   24  H           1       2.775  -0.929  -1.917  1.00  0.00 \nHETATM   25  H           1       1.244  -1.825  -1.765  1.00  0.00 \nHETATM   26  H           1       2.777  -2.597  -1.303  1.00  0.00 \nHETATM   27  H           1       1.574   4.490  -0.538  1.00  0.00 \nHETATM   28  H           1       3.114   3.603  -0.507  1.00  0.00 \nHETATM   29  H           1       2.966   3.432   1.976  1.00  0.00 \nHETATM   30  H           1       1.427   4.321   1.944  1.00  0.00 \nHETATM   31  H           1       2.590   6.179   0.982  1.00  0.00 \nHETATM   32  H           1       4.024   5.350   1.012  1.00  0.00 \nCONECT    1    2    2    6    9\nCONECT    2    1    1    3   11\nCONECT    3    2    4    4   16\nCONECT    4    3    3    5   13\nCONECT    5    4    6    6   17\nCONECT    6    1    5    5    7\nCONECT    7    6    8\nCONECT    8    7   18   19   20\nCONECT    9    1   10\nCONECT   10    9   21   22   23\nCONECT   11    2   12\nCONECT   12   11   24   25   26\nCONECT   13    4   14   27   28\nCONECT   14   13   15   29   30\nCONECT   15   14   31   32\nCONECT   16    3\nCONECT   17    5\nCONECT   18    8\nCONECT   19    8\nCONECT   20    8\nCONECT   21   10\nCONECT   22   10\nCONECT   23   10\nCONECT   24   12\nCONECT   25   12\nCONECT   26   12\nCONECT   27   13\nCONECT   28   13\nCONECT   29   14\nCONECT   30   14\nCONECT   31   15\nCONECT   32   15\nMASTER        0    0    0    0    0    0    0    0   32    0   32    0\nEND\n",
    "HEADER    Methamphetamine: D-Desoxyephedrine\nORIGX1      1.000000  0.000000  0.000000        0.00000\nORIGX2      0.000000  1.000000  0.000000        0.00000\nORIGX3      0.000000  0.000000  1.000000        0.00000\nSCALE1      0.100000  0.000000  0.000000        0.00000\nSCALE2      0.000000  0.100000  0.000000        0.00000\nSCALE3      0.000000  0.000000  0.100000        0.00000\nATOM      1  C           1       0.729   4.473  -1.914  1.00  0.00\nATOM      2  C           1      -0.451   3.821  -2.014  1.00  0.00\nATOM      3  C           1      -0.995   3.421  -3.398  1.00  0.00\nATOM      4  C           1      -0.293   3.722  -4.513  1.00  0.00\nATOM      5  C           1       1.052   4.465  -4.399  1.00  0.00\nATOM      6  C           1       1.529   4.816  -3.184  1.00  0.00\nATOM      7  H           1       1.115   4.756  -0.934  1.00  0.00\nATOM      8  C           1      -1.251   3.478  -0.743  1.00  0.00\nATOM      9  H           1      -1.947   2.896  -3.478  1.00  0.00\nATOM     10  H           1      -0.678   3.440  -5.492  1.00  0.00\nATOM     11  H           1       1.618   4.708  -5.298  1.00  0.00\nATOM     12  H           1       2.481   5.342  -3.104  1.00  0.00\nATOM     13  C           1      -0.489   3.986   0.496  1.00  0.00\nATOM     14  N           1      -1.279   3.647   1.750  1.00  0.00\nATOM     15  H           1      -1.378   2.398  -0.674  1.00  0.00\nATOM     19  H           1      -2.229   3.957  -0.790  1.00  0.00\nATOM     20  H           1       0.489   3.507   0.542  1.00  0.00\nATOM     21  C           1      -0.310   5.512   0.398  1.00  0.00\nATOM     22  H           1      -1.403   2.587   1.817  1.00  0.00\nATOM     23  C           1      -0.528   4.148   2.972  1.00  0.00\nATOM     24  H           1      -0.401   5.229   2.903  1.00  0.00\nATOM     25  H           1       0.451   3.670   3.019  1.00  0.00\nATOM     26  H           1      -1.094   3.905   3.871  1.00  0.00\nATOM     27  H           1       0.229   5.871   1.275  1.00  0.00\nATOM     28  H           1      -1.288   5.991   0.352  1.00  0.00\nATOM     29  H           1       0.256   5.755  -0.501  1.00  0.00\nTER      30\nCONECT    1    2                                                                \nCONECT    2    1                                                                \nCONECT    2    3                                                                \nCONECT    3    2                                                                \nCONECT    3    4                                                                \nCONECT    4    3                                                                \nCONECT    4    5                                                                \nCONECT    5    4                                                                \nCONECT    5    6                                                                \nCONECT    6    5                                                                \nCONECT    6    1                                                                \nCONECT    1    6                                                                \nCONECT    1    7                                                                \nCONECT    7    1                                                                \nCONECT    2    8                                                                \nCONECT    8    2                                                                \nCONECT    3    9                                                                \nCONECT    9    3                                                                \nCONECT    4   10                                                                \nCONECT   10    4                                                                \nCONECT    5   11                                                                \nCONECT   11    5                                                                \nCONECT    6   12                                                                \nCONECT   12    6                                                                \nCONECT    8   13                                                                \nCONECT   13    8                                                                \nCONECT   13   14                                                                \nCONECT   14   13                                                                \nCONECT    8   15                                                                \nCONECT   15    8                                                                \nCONECT    8   19                                                                \nCONECT   19    8                                                                \nCONECT   13   20                                                                \nCONECT   20   13                                                                \nCONECT   13   21                                                                \nCONECT   21   13                                                                \nCONECT   14   22                                                                \nCONECT   22   14                                                                \nCONECT   14   23                                                                \nCONECT   23   14                                                                \nCONECT   23   24                                                                \nCONECT   24   23                                                                \nCONECT   23   25                                                                \nCONECT   25   23                                                                \nCONECT   23   26                                                                \nCONECT   26   23                                                                \nCONECT   21   27                                                                \nCONECT   27   21                                                                \nCONECT   21   28                                                                \nCONECT   28   21                                                                \nCONECT   21   29                                                                \nCONECT   29   21                                                                \nMASTER        0    0    0    0    0    0    0    6   26    1   52    0\nEND\n",
    "HEADER    Morphine, an opiate\nCOMPND    al3058\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Aug 30 12:33:12 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.400   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.106   1.211   0.000  1.00  0.00 \nHETATM    4  C           1       1.444   2.446  -0.039  1.00  0.00 \nHETATM    5  C           1       0.047   2.458   0.013  1.00  0.00 \nHETATM    6  C           1      -0.629   1.243   0.051  1.00  0.00 \nHETATM    7  C           1      -2.081   1.500  -0.228  1.00  0.00 \nHETATM    8  C           1      -2.727   0.342  -0.999  1.00  0.00 \nHETATM    9  C           1      -2.363  -0.953  -0.239  1.00  0.00 \nHETATM   10  C           1      -0.832  -1.231  -0.285  1.00  0.00 \nHETATM   11  C           1      -1.885   2.839  -0.975  1.00  0.00 \nHETATM   12  C           1      -2.772   1.631   1.137  1.00  0.00 \nHETATM   13  C           1      -2.525   0.318   1.912  1.00  0.00 \nHETATM   14  N           1      -2.930  -0.855   1.119  1.00  0.00 \nHETATM   15  C           1      -2.790  -2.096   1.899  1.00  0.00 \nHETATM   16  H           1      -3.810   0.470  -0.978  1.00  0.00 \nHETATM   17  C           1      -2.300   0.287  -2.447  1.00  0.00 \nHETATM   18  C           1      -2.022   1.415  -3.116  1.00  0.00 \nHETATM   19  C           1      -1.406   2.612  -2.428  1.00  0.00 \nHETATM   20  H           1      -2.795   3.439  -0.953  1.00  0.00 \nHETATM   21  O           1      -0.796   3.478  -0.328  1.00  0.00 \nHETATM   22  H           1      -1.616   3.510  -3.009  1.00  0.00 \nHETATM   23  O           1       0.011   2.407  -2.414  1.00  0.00 \nHETATM   24  O           1       2.143   3.606  -0.184  1.00  0.00 \nHETATM   25  H           1       1.942  -0.943  -0.066  1.00  0.00 \nHETATM   26  H           1       3.195   1.192  -0.045  1.00  0.00 \nHETATM   27  H           1      -2.861  -1.784  -0.739  1.00  0.00 \nHETATM   28  H           1      -0.580  -1.568  -1.291  1.00  0.00 \nHETATM   29  H           1      -0.568  -2.021   0.414  1.00  0.00 \nHETATM   30  H           1      -3.842   1.788   0.997  1.00  0.00 \nHETATM   31  H           1      -2.350   2.469   1.692  1.00  0.00 \nHETATM   32  H           1      -3.107   0.346   2.833  1.00  0.00 \nHETATM   33  H           1      -1.471   0.235   2.174  1.00  0.00 \nHETATM   34  H           1      -3.461  -2.058   2.757  1.00  0.00 \nHETATM   35  H           1      -1.767  -2.205   2.257  1.00  0.00 \nHETATM   36  H           1      -3.054  -2.955   1.282  1.00  0.00 \nHETATM   37  H           1      -2.529  -0.612  -3.019  1.00  0.00 \nHETATM   38  H           1      -1.956   1.362  -4.203  1.00  0.00 \nHETATM   39  H           1       0.343   2.320  -3.313  1.00  0.00 \nHETATM   40  H           1       2.435   3.917   0.680  1.00  0.00 \nCONECT    1    2    2    6   10\nCONECT    2    1    1    3   25\nCONECT    3    2    4    4   26\nCONECT    4    3    3    5   24\nCONECT    5    4    6    6   21\nCONECT    6    1    5    5    7\nCONECT    7    6    8   11   12\nCONECT    8    7    9   16   17\nCONECT    9    8   10   14   27\nCONECT   10    1    9   28   29\nCONECT   11    7   19   20   21\nCONECT   12    7   13   30   31\nCONECT   13   12   14   32   33\nCONECT   14    9   13   15\nCONECT   15   14   34   35   36\nCONECT   16    8\nCONECT   17    8   18   18   37\nCONECT   18   17   17   19   38\nCONECT   19   11   18   22   23\nCONECT   20   11\nCONECT   21    5   11\nCONECT   22   19\nCONECT   23   19   39\nCONECT   24    4   40\nCONECT   25    2\nCONECT   26    3\nCONECT   27    9\nCONECT   28   10\nCONECT   29   10\nCONECT   30   12\nCONECT   31   12\nCONECT   32   13\nCONECT   33   13\nCONECT   34   15\nCONECT   35   15\nCONECT   36   15\nCONECT   37   17\nCONECT   38   18\nCONECT   39   23\nCONECT   40   24\nMASTER        0    0    0    0    0    0    0    0   40    0   40    0\nEND\n",
    "HEADER    Nicotine, an insecticide\nCOMPND    nicotine\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep  1 09:41:05 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.400   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.082   1.223   0.000  1.00  0.00 \nHETATM    4  C           1       1.361   2.420  -0.060  1.00  0.00 \nHETATM    5  C           1      -0.037   2.388  -0.103  1.00  0.00 \nHETATM    6  N           1      -0.698   1.182  -0.064  1.00  0.00 \nHETATM    7  C           1       2.135  -1.320   0.103  1.00  0.00 \nHETATM    8  H           1      -0.543  -0.944   0.043  1.00  0.00 \nHETATM    9  H           1       3.168   1.256   0.062  1.00  0.00 \nHETATM   10  H           1       1.886   3.375  -0.067  1.00  0.00 \nHETATM   11  H           1      -0.604   3.318  -0.148  1.00  0.00 \nHETATM   12  H           1       2.087  -1.661   1.139  1.00  0.00 \nHETATM   13  N           1       1.561  -2.374  -0.749  1.00  0.00 \nHETATM   14  C           1       3.616  -1.255  -0.318  1.00  0.00 \nHETATM   15  C           1       3.943  -2.708  -0.713  1.00  0.00 \nHETATM   16  C           1       2.580  -3.434  -0.690  1.00  0.00 \nHETATM   17  C           1       1.359  -1.946  -2.144  1.00  0.00 \nHETATM   18  H           1       4.247  -0.910   0.502  1.00  0.00 \nHETATM   19  H           1       3.736  -0.608  -1.187  1.00  0.00 \nHETATM   20  H           1       4.627  -3.166   0.001  1.00  0.00 \nHETATM   21  H           1       4.371  -2.732  -1.715  1.00  0.00 \nHETATM   22  H           1       2.475  -3.968   0.255  1.00  0.00 \nHETATM   23  H           1       2.490  -4.135  -1.520  1.00  0.00 \nHETATM   24  H           1       2.299  -1.632  -2.594  1.00  0.00 \nHETATM   25  H           1       0.648  -1.122  -2.190  1.00  0.00 \nHETATM   26  H           1       0.956  -2.781  -2.717  1.00  0.00 \nCONECT    1    2    2    6    8\nCONECT    2    1    1    3    7\nCONECT    3    2    4    4    9\nCONECT    4    3    3    5   10\nCONECT    5    4    6    6   11\nCONECT    6    1    5    5\nCONECT    7    2   12   13   14\nCONECT    8    1\nCONECT    9    3\nCONECT   10    4\nCONECT   11    5\nCONECT   12    7\nCONECT   13    7   16   17\nCONECT   14    7   15   18   19\nCONECT   15   14   16   20   21\nCONECT   16   13   15   22   23\nCONECT   17   13   24   25   26\nCONECT   18   14\nCONECT   19   14\nCONECT   20   15\nCONECT   21   15\nCONECT   22   16\nCONECT   23   16\nCONECT   24   17\nCONECT   25   17\nCONECT   26   17\nMASTER        0    0    0    0    0    0    0    0   26    0   26    0\nEND\n",
    "HEADER    Procaine: Novocaine, a local anesthetic\nCOMPND    al3080\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Aug 30 12:33:12 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.399   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.099   1.211   0.000  1.00  0.00 \nHETATM    4  C           1       1.398   2.422   0.001  1.00  0.00 \nHETATM    5  C           1      -0.001   2.421   0.002  1.00  0.00 \nHETATM    6  C           1      -0.702   1.211   0.002  1.00  0.00 \nHETATM    7  N           1      -2.104   1.210   0.003  1.00  0.00 \nHETATM    8  C           1       3.511   1.212   0.000  1.00  0.00 \nHETATM    9  O           1       4.107   2.255  -0.002  1.00  0.00 \nHETATM   10  O           1       4.172   0.056   0.011  1.00  0.00 \nHETATM   11  C           1       5.562   0.269   0.112  1.00  0.00 \nHETATM   12  C           1       6.275  -1.096   0.162  1.00  0.00 \nHETATM   13  H           1      -0.542  -0.946   0.000  1.00  0.00 \nHETATM   14  H           1       1.942  -0.945  -0.001  1.00  0.00 \nHETATM   15  H           1       1.940   3.368   0.001  1.00  0.00 \nHETATM   16  H           1      -0.544   3.367   0.004  1.00  0.00 \nHETATM   17  H           1      -2.613   0.334   0.002  1.00  0.00 \nHETATM   18  H           1       5.776   0.831   1.021  1.00  0.00 \nHETATM   19  H           1       5.912   0.827  -0.758  1.00  0.00 \nHETATM   20  H           1       5.949  -1.682  -0.697  1.00  0.00 \nHETATM   21  H           1       5.984  -1.614   1.076  1.00  0.00 \nHETATM   22  N           1       7.741  -0.935   0.107  1.00  0.00 \nHETATM   23  C           1       8.433  -2.206  -0.184  1.00  0.00 \nHETATM   24  C           1       8.171  -3.279   0.896  1.00  0.00 \nHETATM   25  C           1       8.301  -0.239   1.281  1.00  0.00 \nHETATM   26  C           1       8.683   1.204   0.891  1.00  0.00 \nHETATM   27  H           1      -2.613   2.087   0.004  1.00  0.00 \nHETATM   28  H           1       9.505  -2.021  -0.249  1.00  0.00 \nHETATM   29  H           1       8.091  -2.587  -1.146  1.00  0.00 \nHETATM   30  H           1       7.118  -3.559   0.896  1.00  0.00 \nHETATM   31  H           1       8.444  -2.898   1.879  1.00  0.00 \nHETATM   32  H           1       8.770  -4.162   0.675  1.00  0.00 \nHETATM   33  H           1       9.205  -0.743   1.624  1.00  0.00 \nHETATM   34  H           1       7.579  -0.223   2.098  1.00  0.00 \nHETATM   35  H           1       7.804   1.747   0.546  1.00  0.00 \nHETATM   36  H           1       9.424   1.176   0.092  1.00  0.00 \nHETATM   37  H           1       9.105   1.714   1.757  1.00  0.00 \nCONECT    1    2    2    6   13\nCONECT    2    1    1    3   14\nCONECT    3    2    4    4    8\nCONECT    4    3    3    5   15\nCONECT    5    4    6    6   16\nCONECT    6    1    5    5    7\nCONECT    7    6   17   27\nCONECT    8    3    9    9   10\nCONECT    9    8    8\nCONECT   10    8   11\nCONECT   11   10   12   18   19\nCONECT   12   11   20   21   22\nCONECT   13    1\nCONECT   14    2\nCONECT   15    4\nCONECT   16    5\nCONECT   17    7\nCONECT   18   11\nCONECT   19   11\nCONECT   20   12\nCONECT   21   12\nCONECT   22   12   23   25\nCONECT   23   22   24   28   29\nCONECT   24   23   30   31   32\nCONECT   25   22   26   33   34\nCONECT   26   25   35   36   37\nCONECT   27    7\nCONECT   28   23\nCONECT   29   23\nCONECT   30   24\nCONECT   31   24\nCONECT   32   24\nCONECT   33   25\nCONECT   34   25\nCONECT   35   26\nCONECT   36   26\nCONECT   37   26\nMASTER        0    0    0    0    0    0    0    0   37    0   37    0\nEND\n",
    "HEADER    Sucrose octaoleate: Olestra-like non-hydrolyzing fat\nCOMPND    jb15oles\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Sep 20 16:26:54 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.543   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.023   1.465   0.000  1.00  0.00 \nHETATM    4  C           1       1.448   2.115   1.276  1.00  0.00 \nHETATM    5  C           1      -0.094   1.986   1.258  1.00  0.00 \nHETATM    6  O           1      -0.446   0.620   1.189  1.00  0.00 \nHETATM    7  O           1      -0.682   2.630   0.148  1.00  0.00 \nHETATM    8  C           1      -0.713   4.011  -0.142  1.00  0.00 \nHETATM    9  C           1      -1.600   4.135  -1.401  1.00  0.00 \nHETATM   10  C           1      -1.324   4.924   0.946  1.00  0.00 \nHETATM   11  O           1       0.576   4.533  -0.389  1.00  0.00 \nHETATM   12  C           1       0.436   5.938  -0.395  1.00  0.00 \nHETATM   13  C           1      -0.617   6.269   0.681  1.00  0.00 \nHETATM   14  C           1       1.756   6.671  -0.084  1.00  0.00 \nHETATM   15  O           1       2.227   6.278   1.183  1.00  0.00 \nHETATM   16  O           1      -1.499   7.264   0.209  1.00  0.00 \nHETATM   17  O           1      -1.029   4.475   2.250  1.00  0.00 \nHETATM   18  O           1      -1.000   3.465  -2.486  1.00  0.00 \nHETATM   19  C           1      -0.514  -1.457  -0.089  1.00  0.00 \nHETATM   20  O           1      -1.922  -1.490   0.008  1.00  0.00 \nHETATM   21  O           1       2.044  -0.707  -1.115  1.00  0.00 \nHETATM   22  O           1       3.434   1.488  -0.024  1.00  0.00 \nHETATM   23  O           1       1.870   3.459   1.361  1.00  0.00 \nHETATM   24  C           1      -2.482  -2.432  -0.753  1.00  0.00 \nHETATM   25  O           1      -3.315  -2.099  -1.556  1.00  0.00 \nHETATM   26  C           1      -2.336  -3.895  -0.434  1.00  0.00 \nHETATM   27  C           1      -3.583  -4.668  -0.927  1.00  0.00 \nHETATM   28  C           1      -3.416  -6.194  -0.736  1.00  0.00 \nHETATM   29  C           1      -4.686  -6.939  -1.212  1.00  0.00 \nHETATM   30  C           1      -4.492  -8.472  -1.146  1.00  0.00 \nHETATM   31  C           1      -5.779  -9.194  -1.608  1.00  0.00 \nHETATM   32  C           1      -5.580 -10.727  -1.651  1.00  0.00 \nHETATM   33  C           1      -6.868 -11.389  -2.094  1.00  0.00 \nHETATM   34  C           1      -6.933 -12.683  -2.447  1.00  0.00 \nHETATM   35  C           1      -5.725 -13.593  -2.433  1.00  0.00 \nHETATM   36  C           1      -6.164 -15.030  -2.794  1.00  0.00 \nHETATM   37  C           1      -4.957 -15.993  -2.791  1.00  0.00 \nHETATM   38  C           1      -5.423 -17.419  -3.153  1.00  0.00 \nHETATM   39  C           1      -4.225 -18.393  -3.146  1.00  0.00 \nHETATM   40  C           1      -4.700 -19.818  -3.505  1.00  0.00 \nHETATM   41  C           1       3.344  -0.983  -0.999  1.00  0.00 \nHETATM   42  O           1       4.098  -0.665  -1.882  1.00  0.00 \nHETATM   43  C           1       3.844  -1.849   0.124  1.00  0.00 \nHETATM   44  C           1       5.081  -2.680  -0.284  1.00  0.00 \nHETATM   45  C           1       5.532  -3.506   0.946  1.00  0.00 \nHETATM   46  C           1       6.768  -4.378   0.668  1.00  0.00 \nHETATM   47  C           1       7.108  -5.157   1.969  1.00  0.00 \nHETATM   48  C           1       8.283  -6.109   1.808  1.00  0.00 \nHETATM   49  C           1       8.489  -6.845   3.177  1.00  0.00 \nHETATM   50  C           1       9.603  -7.867   3.101  1.00  0.00 \nHETATM   51  C           1       9.838  -8.686   4.139  1.00  0.00 \nHETATM   52  C           1       8.989  -8.622   5.392  1.00  0.00 \nHETATM   53  C           1       9.509  -9.601   6.463  1.00  0.00 \nHETATM   54  C           1       8.612  -9.509   7.718  1.00  0.00 \nHETATM   55  C           1       9.090 -10.491   8.808  1.00  0.00 \nHETATM   56  C           1       8.155 -10.395  10.033  1.00  0.00 \nHETATM   57  C           1       8.599 -11.385  11.130  1.00  0.00 \nHETATM   58  C           1       3.954   2.643   0.391  1.00  0.00 \nHETATM   59  O           1       4.364   2.722   1.520  1.00  0.00 \nHETATM   60  C           1       3.833   3.903  -0.422  1.00  0.00 \nHETATM   61  C           1       5.113   4.138  -1.254  1.00  0.00 \nHETATM   62  C           1       5.001   5.470  -2.030  1.00  0.00 \nHETATM   63  C           1       6.274   5.721  -2.868  1.00  0.00 \nHETATM   64  C           1       6.142   7.042  -3.658  1.00  0.00 \nHETATM   65  C           1       7.424   7.302  -4.480  1.00  0.00 \nHETATM   66  C           1       7.292   8.604  -5.302  1.00  0.00 \nHETATM   67  C           1       8.567   8.842  -6.080  1.00  0.00 \nHETATM   68  C           1       8.673   9.819  -6.994  1.00  0.00 \nHETATM   69  C           1       7.518  10.739  -7.321  1.00  0.00 \nHETATM   70  C           1       7.962  11.764  -8.388  1.00  0.00 \nHETATM   71  C           1       6.793  12.704  -8.749  1.00  0.00 \nHETATM   72  C           1       7.240  13.712  -9.829  1.00  0.00 \nHETATM   73  C           1       6.069  14.649 -10.192  1.00  0.00 \nHETATM   74  C           1       6.510  15.654 -11.277  1.00  0.00 \nHETATM   75  C           1       1.563   4.034   2.524  1.00  0.00 \nHETATM   76  O           1       0.994   5.094   2.507  1.00  0.00 \nHETATM   77  C           1       2.204   3.624   3.820  1.00  0.00 \nHETATM   78  C           1       1.081   3.461   4.864  1.00  0.00 \nHETATM   79  C           1       1.646   2.985   6.219  1.00  0.00 \nHETATM   80  C           1       0.495   2.893   7.242  1.00  0.00 \nHETATM   81  C           1       0.991   2.293   8.574  1.00  0.00 \nHETATM   82  C           1      -0.180   2.239   9.577  1.00  0.00 \nHETATM   83  C           1       0.252   1.529  10.878  1.00  0.00 \nHETATM   84  C           1      -0.909   1.516  11.848  1.00  0.00 \nHETATM   85  C           1      -1.007   0.609  12.832  1.00  0.00 \nHETATM   86  C           1       0.023  -0.485  13.013  1.00  0.00 \nHETATM   87  C           1      -0.255  -1.246  14.326  1.00  0.00 \nHETATM   88  C           1       0.758  -2.396  14.494  1.00  0.00 \nHETATM   89  C           1       0.465  -3.168  15.798  1.00  0.00 \nHETATM   90  C           1       1.443  -4.352  15.937  1.00  0.00 \nHETATM   91  C           1       1.138  -5.136  17.229  1.00  0.00 \nHETATM   92  C           1      -1.640   3.717  -3.628  1.00  0.00 \nHETATM   93  O           1      -1.012   4.078  -4.590  1.00  0.00 \nHETATM   94  C           1      -3.121   3.488  -3.752  1.00  0.00 \nHETATM   95  C           1      -3.553   3.549  -5.232  1.00  0.00 \nHETATM   96  C           1      -5.083   3.368  -5.331  1.00  0.00 \nHETATM   97  C           1      -5.545   3.449  -6.801  1.00  0.00 \nHETATM   98  C           1      -7.080   3.295  -6.870  1.00  0.00 \nHETATM   99  C           1      -7.563   3.372  -8.334  1.00  0.00 \nHETATM  100  C           1      -9.099   3.230  -8.385  1.00  0.00 \nHETATM  101  C           1      -9.579   3.302  -9.818  1.00  0.00 \nHETATM  102  C           1     -10.886   3.239 -10.119  1.00  0.00 \nHETATM  103  C           1     -11.934   3.095  -9.037  1.00  0.00 \nHETATM  104  C           1     -13.340   3.036  -9.669  1.00  0.00 \nHETATM  105  C           1     -14.403   2.883  -8.561  1.00  0.00 \nHETATM  106  C           1     -15.815   2.830  -9.181  1.00  0.00 \nHETATM  107  C           1     -16.867   2.668  -8.064  1.00  0.00 \nHETATM  108  C           1     -18.283   2.619  -8.671  1.00  0.00 \nHETATM  109  C           1      -2.001   7.975   1.218  1.00  0.00 \nHETATM  110  O           1      -3.001   7.595   1.768  1.00  0.00 \nHETATM  111  C           1      -1.156   9.034   1.872  1.00  0.00 \nHETATM  112  C           1      -1.534  10.432   1.344  1.00  0.00 \nHETATM  113  C           1      -0.625  11.493   2.001  1.00  0.00 \nHETATM  114  C           1      -0.976  12.902   1.479  1.00  0.00 \nHETATM  115  C           1      -0.062  13.955   2.143  1.00  0.00 \nHETATM  116  C           1      -0.432  15.365   1.636  1.00  0.00 \nHETATM  117  C           1       0.472  16.432   2.289  1.00  0.00 \nHETATM  118  C           1       0.070  17.801   1.786  1.00  0.00 \nHETATM  119  C           1       0.739  18.910   2.133  1.00  0.00 \nHETATM  120  C           1       1.947  18.864   3.043  1.00  0.00 \nHETATM  121  C           1       2.466  20.301   3.261  1.00  0.00 \nHETATM  122  C           1       3.707  20.302   4.178  1.00  0.00 \nHETATM  123  C           1       4.204  21.750   4.364  1.00  0.00 \nHETATM  124  C           1       5.448  21.780   5.275  1.00  0.00 \nHETATM  125  C           1       5.933  23.236   5.440  1.00  0.00 \nHETATM  126  C           1      -1.676   5.203   3.160  1.00  0.00 \nHETATM  127  O           1      -1.395   6.362   3.326  1.00  0.00 \nHETATM  128  C           1      -2.722   4.564   4.031  1.00  0.00 \nHETATM  129  C           1      -3.529   5.657   4.765  1.00  0.00 \nHETATM  130  C           1      -4.616   5.007   5.648  1.00  0.00 \nHETATM  131  C           1      -5.417   6.088   6.405  1.00  0.00 \nHETATM  132  C           1      -6.505   5.421   7.274  1.00  0.00 \nHETATM  133  C           1      -7.276   6.485   8.085  1.00  0.00 \nHETATM  134  C           1      -8.342   5.803   8.967  1.00  0.00 \nHETATM  135  C           1      -8.999   6.835   9.859  1.00  0.00 \nHETATM  136  C           1     -10.265   7.250   9.698  1.00  0.00 \nHETATM  137  C           1     -11.161   6.729   8.595  1.00  0.00 \nHETATM  138  C           1     -12.519   7.460   8.650  1.00  0.00 \nHETATM  139  C           1     -13.450   6.941   7.534  1.00  0.00 \nHETATM  140  C           1     -14.810   7.665   7.610  1.00  0.00 \nHETATM  141  C           1     -15.745   7.150   6.496  1.00  0.00 \nHETATM  142  C           1     -17.110   7.866   6.583  1.00  0.00 \nHETATM  143  C           1       2.842   7.281   1.802  1.00  0.00 \nHETATM  144  O           1       2.205   8.253   2.118  1.00  0.00 \nHETATM  145  C           1       4.220   7.092   2.370  1.00  0.00 \nHETATM  146  C           1       4.473   8.156   3.459  1.00  0.00 \nHETATM  147  C           1       5.893   8.017   4.051  1.00  0.00 \nHETATM  148  C           1       6.113   9.105   5.125  1.00  0.00 \nHETATM  149  C           1       7.536   9.013   5.717  1.00  0.00 \nHETATM  150  C           1       7.731  10.123   6.772  1.00  0.00 \nHETATM  151  C           1       9.153  10.065   7.368  1.00  0.00 \nHETATM  152  C           1       9.319  11.173   8.385  1.00  0.00 \nHETATM  153  C           1      10.461  11.337   9.067  1.00  0.00 \nHETATM  154  C           1      11.643  10.413   8.868  1.00  0.00 \nHETATM  155  C           1      12.819  10.884   9.749  1.00  0.00 \nHETATM  156  C           1      14.028   9.942   9.572  1.00  0.00 \nHETATM  157  C           1      15.194  10.418  10.464  1.00  0.00 \nHETATM  158  C           1      16.397   9.465  10.312  1.00  0.00 \nHETATM  159  C           1      17.555   9.936  11.217  1.00  0.00 \nHETATM  160  C           1      18.753   8.973  11.081  1.00  0.00 \nHETATM  161  C           1      19.907   9.437  11.992  1.00  0.00 \nHETATM  162  C           1       7.637 -11.294  12.332  1.00  0.00 \nHETATM  163  C           1       8.066 -12.287  13.432  1.00  0.00 \nHETATM  164  C           1      -3.503 -20.792  -3.494  1.00  0.00 \nHETATM  165  C           1      -3.976 -22.215  -3.853  1.00  0.00 \nHETATM  166  C           1       2.094  -6.341  17.349  1.00  0.00 \nHETATM  167  C           1       1.786  -7.131  18.637  1.00  0.00 \nHETATM  168  C           1       5.336  16.589 -11.634  1.00  0.00 \nHETATM  169  C           1       5.771  17.593 -12.721  1.00  0.00 \nHETATM  170  C           1       7.177  23.279   6.350  1.00  0.00 \nHETATM  171  C           1       7.661  24.734   6.509  1.00  0.00 \nHETATM  172  C           1     -19.327   2.450  -7.548  1.00  0.00 \nHETATM  173  C           1     -20.747   2.406  -8.149  1.00  0.00 \nHETATM  174  C           1     -18.044   7.350   5.470  1.00  0.00 \nHETATM  175  C           1     -19.412   8.057   5.560  1.00  0.00 \nHETATM  176  H           1      -0.368   0.553  -0.864  1.00  0.00 \nHETATM  177  H           1       1.874  -0.482   0.920  1.00  0.00 \nHETATM  178  H           1       1.632   1.978  -0.879  1.00  0.00 \nHETATM  179  H           1       1.826   1.557   2.131  1.00  0.00 \nHETATM  180  H           1      -0.503   2.395   2.180  1.00  0.00 \nHETATM  181  H           1      -1.766   5.183  -1.654  1.00  0.00 \nHETATM  182  H           1      -2.562   3.672  -1.182  1.00  0.00 \nHETATM  183  H           1      -2.404   5.015   0.817  1.00  0.00 \nHETATM  184  H           1       0.079   6.263  -1.372  1.00  0.00 \nHETATM  185  H           1      -0.107   6.607   1.580  1.00  0.00 \nHETATM  186  H           1       1.568   7.745  -0.111  1.00  0.00 \nHETATM  187  H           1       2.495   6.425  -0.844  1.00  0.00 \nHETATM  188  H           1      -0.089  -2.043   0.726  1.00  0.00 \nHETATM  189  H           1      -0.191  -1.883  -1.040  1.00  0.00 \nHETATM  190  H           1      -2.226  -4.025   0.643  1.00  0.00 \nHETATM  191  H           1      -1.448  -4.280  -0.936  1.00  0.00 \nHETATM  192  H           1      -3.732  -4.461  -1.987  1.00  0.00 \nHETATM  193  H           1      -4.457  -4.327  -0.372  1.00  0.00 \nHETATM  194  H           1      -3.242  -6.413   0.317  1.00  0.00 \nHETATM  195  H           1      -2.560  -6.535  -1.319  1.00  0.00 \nHETATM  196  H           1      -4.902  -6.654  -2.241  1.00  0.00 \nHETATM  197  H           1      -5.527  -6.653  -0.579  1.00  0.00 \nHETATM  198  H           1      -4.259  -8.767  -0.123  1.00  0.00 \nHETATM  199  H           1      -3.666  -8.756  -1.799  1.00  0.00 \nHETATM  200  H           1      -6.047  -8.844  -2.605  1.00  0.00 \nHETATM  201  H           1      -6.588  -8.955  -0.918  1.00  0.00 \nHETATM  202  H           1      -5.310 -11.089  -0.659  1.00  0.00 \nHETATM  203  H           1      -4.783 -10.967  -2.355  1.00  0.00 \nHETATM  204  H           1      -7.781 -10.795  -2.125  1.00  0.00 \nHETATM  205  H           1      -7.896 -13.091  -2.754  1.00  0.00 \nHETATM  206  H           1      -5.275 -13.588  -1.440  1.00  0.00 \nHETATM  207  H           1      -4.997 -13.243  -3.164  1.00  0.00 \nHETATM  208  H           1      -6.618 -15.028  -3.785  1.00  0.00 \nHETATM  209  H           1      -6.898 -15.374  -2.065  1.00  0.00 \nHETATM  210  H           1      -4.502 -16.000  -1.801  1.00  0.00 \nHETATM  211  H           1      -4.222 -15.655  -3.522  1.00  0.00 \nHETATM  212  H           1      -5.875 -17.411  -4.145  1.00  0.00 \nHETATM  213  H           1      -6.163 -17.753  -2.425  1.00  0.00 \nHETATM  214  H           1      -3.773 -18.402  -2.155  1.00  0.00 \nHETATM  215  H           1      -3.486 -18.063  -3.876  1.00  0.00 \nHETATM  216  H           1      -5.150 -19.810  -4.498  1.00  0.00 \nHETATM  217  H           1      -5.441 -20.147  -2.777  1.00  0.00 \nHETATM  218  H           1       3.046  -2.532   0.416  1.00  0.00 \nHETATM  219  H           1       4.102  -1.216   0.975  1.00  0.00 \nHETATM  220  H           1       5.884  -2.006  -0.580  1.00  0.00 \nHETATM  221  H           1       4.829  -3.337  -1.117  1.00  0.00 \nHETATM  222  H           1       4.717  -4.156   1.264  1.00  0.00 \nHETATM  223  H           1       5.773  -2.820   1.759  1.00  0.00 \nHETATM  224  H           1       7.605  -3.757   0.345  1.00  0.00 \nHETATM  225  H           1       6.511  -5.083  -0.123  1.00  0.00 \nHETATM  226  H           1       6.244  -5.737   2.294  1.00  0.00 \nHETATM  227  H           1       7.378  -4.451   2.755  1.00  0.00 \nHETATM  228  H           1       9.158  -5.517   1.539  1.00  0.00 \nHETATM  229  H           1       8.056  -6.812   1.007  1.00  0.00 \nHETATM  230  H           1       7.572  -7.372   3.439  1.00  0.00 \nHETATM  231  H           1       8.718  -6.129   3.967  1.00  0.00 \nHETATM  232  H           1      10.222  -7.926   2.206  1.00  0.00 \nHETATM  233  H           1      10.647  -9.413   4.074  1.00  0.00 \nHETATM  234  H           1       7.960  -8.886   5.148  1.00  0.00 \nHETATM  235  H           1       9.015  -7.611   5.799  1.00  0.00 \nHETATM  236  H           1      10.534  -9.341   6.725  1.00  0.00 \nHETATM  237  H           1       9.481 -10.616   6.068  1.00  0.00 \nHETATM  238  H           1       7.586  -9.753   7.443  1.00  0.00 \nHETATM  239  H           1       8.644  -8.493   8.111  1.00  0.00 \nHETATM  240  H           1      10.108 -10.239   9.105  1.00  0.00 \nHETATM  241  H           1       9.070 -11.507   8.415  1.00  0.00 \nHETATM  242  H           1       7.136 -10.633   9.726  1.00  0.00 \nHETATM  243  H           1       8.182  -9.380  10.429  1.00  0.00 \nHETATM  244  H           1       9.611 -11.139  11.453  1.00  0.00 \nHETATM  245  H           1       8.585 -12.399  10.730  1.00  0.00 \nHETATM  246  H           1       3.697   4.738   0.262  1.00  0.00 \nHETATM  247  H           1       2.973   3.837  -1.086  1.00  0.00 \nHETATM  248  H           1       5.244   3.316  -1.956  1.00  0.00 \nHETATM  249  H           1       5.973   4.181  -0.585  1.00  0.00 \nHETATM  250  H           1       4.873   6.289  -1.322  1.00  0.00 \nHETATM  251  H           1       4.136   5.428  -2.692  1.00  0.00 \nHETATM  252  H           1       6.415   4.896  -3.567  1.00  0.00 \nHETATM  253  H           1       7.137   5.781  -2.205  1.00  0.00 \nHETATM  254  H           1       5.987   7.867  -2.962  1.00  0.00 \nHETATM  255  H           1       5.288   6.976  -4.332  1.00  0.00 \nHETATM  256  H           1       7.592   6.466  -5.158  1.00  0.00 \nHETATM  257  H           1       8.273   7.389  -3.801  1.00  0.00 \nHETATM  258  H           1       7.117   9.443  -4.629  1.00  0.00 \nHETATM  259  H           1       6.453   8.510  -5.991  1.00  0.00 \nHETATM  260  H           1       9.432   8.207  -5.887  1.00  0.00 \nHETATM  261  H           1       9.620   9.946  -7.519  1.00  0.00 \nHETATM  262  H           1       7.205  11.266  -6.419  1.00  0.00 \nHETATM  263  H           1       6.685  10.153  -7.709  1.00  0.00 \nHETATM  264  H           1       8.285  11.232  -9.283  1.00  0.00 \nHETATM  265  H           1       8.793  12.353  -8.000  1.00  0.00 \nHETATM  266  H           1       6.474  13.244  -7.858  1.00  0.00 \nHETATM  267  H           1       5.958  12.114  -9.129  1.00  0.00 \nHETATM  268  H           1       7.559  13.171 -10.720  1.00  0.00 \nHETATM  269  H           1       8.073  14.304  -9.450  1.00  0.00 \nHETATM  270  H           1       5.753  15.194  -9.302  1.00  0.00 \nHETATM  271  H           1       5.234  14.057 -10.566  1.00  0.00 \nHETATM  272  H           1       6.824  15.110 -12.168  1.00  0.00 \nHETATM  273  H           1       7.346  16.246 -10.905  1.00  0.00 \nHETATM  274  H           1       2.891   4.405   4.144  1.00  0.00 \nHETATM  275  H           1       2.753   2.690   3.706  1.00  0.00 \nHETATM  276  H           1       0.360   2.729   4.502  1.00  0.00 \nHETATM  277  H           1       0.578   4.420   4.999  1.00  0.00 \nHETATM  278  H           1       2.396   3.692   6.575  1.00  0.00 \nHETATM  279  H           1       2.104   2.004   6.094  1.00  0.00 \nHETATM  280  H           1      -0.293   2.257   6.838  1.00  0.00 \nHETATM  281  H           1       0.092   3.890   7.420  1.00  0.00 \nHETATM  282  H           1       1.792   2.910   8.980  1.00  0.00 \nHETATM  283  H           1       1.366   1.285   8.397  1.00  0.00 \nHETATM  284  H           1      -1.010   1.689   9.134  1.00  0.00 \nHETATM  285  H           1      -0.503   3.254   9.807  1.00  0.00 \nHETATM  286  H           1       1.090   2.062  11.326  1.00  0.00 \nHETATM  287  H           1       0.555   0.509  10.641  1.00  0.00 \nHETATM  288  H           1      -1.682   2.279  11.759  1.00  0.00 \nHETATM  289  H           1      -1.860   0.654  13.508  1.00  0.00 \nHETATM  290  H           1       1.020  -0.047  13.053  1.00  0.00 \nHETATM  291  H           1      -0.037  -1.180  12.176  1.00  0.00 \nHETATM  292  H           1      -1.264  -1.658  14.297  1.00  0.00 \nHETATM  293  H           1      -0.170  -0.560  15.169  1.00  0.00 \nHETATM  294  H           1       1.769  -1.990  14.531  1.00  0.00 \nHETATM  295  H           1       0.675  -3.076  13.646  1.00  0.00 \nHETATM  296  H           1      -0.557  -3.546  15.772  1.00  0.00 \nHETATM  297  H           1       0.580  -2.498  16.650  1.00  0.00 \nHETATM  298  H           1       2.466  -3.977  15.971  1.00  0.00 \nHETATM  299  H           1       1.331  -5.015  15.078  1.00  0.00 \nHETATM  300  H           1       0.108  -5.493  17.202  1.00  0.00 \nHETATM  301  H           1       1.269  -4.481  18.090  1.00  0.00 \nHETATM  302  H           1      -3.652   4.262  -3.197  1.00  0.00 \nHETATM  303  H           1      -3.371   2.511  -3.339  1.00  0.00 \nHETATM  304  H           1      -3.052   2.758  -5.791  1.00  0.00 \nHETATM  305  H           1      -3.275   4.517  -5.650  1.00  0.00 \nHETATM  306  H           1      -5.575   4.153  -4.757  1.00  0.00 \nHETATM  307  H           1      -5.358   2.397  -4.919  1.00  0.00 \nHETATM  308  H           1      -5.072   2.653  -7.376  1.00  0.00 \nHETATM  309  H           1      -5.259   4.415  -7.219  1.00  0.00 \nHETATM  310  H           1      -7.548   4.093  -6.294  1.00  0.00 \nHETATM  311  H           1      -7.365   2.332  -6.447  1.00  0.00 \nHETATM  312  H           1      -7.105   2.569  -8.910  1.00  0.00 \nHETATM  313  H           1      -7.275   4.333  -8.761  1.00  0.00 \nHETATM  314  H           1      -9.553   4.035  -7.808  1.00  0.00 \nHETATM  315  H           1      -9.385   2.270  -7.955  1.00  0.00 \nHETATM  316  H           1      -8.852   3.405 -10.623  1.00  0.00 \nHETATM  317  H           1     -11.195   3.293 -11.162  1.00  0.00 \nHETATM  318  H           1     -11.879   3.949  -8.362  1.00  0.00 \nHETATM  319  H           1     -11.753   2.177  -8.477  1.00  0.00 \nHETATM  320  H           1     -13.398   2.184 -10.347  1.00  0.00 \nHETATM  321  H           1     -13.526   3.954 -10.227  1.00  0.00 \nHETATM  322  H           1     -14.340   3.732  -7.880  1.00  0.00 \nHETATM  323  H           1     -14.217   1.964  -8.007  1.00  0.00 \nHETATM  324  H           1     -15.880   1.984  -9.865  1.00  0.00 \nHETATM  325  H           1     -16.006   3.752  -9.729  1.00  0.00 \nHETATM  326  H           1     -16.797   3.511  -7.377  1.00  0.00 \nHETATM  327  H           1     -16.675   1.743  -7.519  1.00  0.00 \nHETATM  328  H           1     -18.353   1.777  -9.361  1.00  0.00 \nHETATM  329  H           1     -18.478   3.545  -9.212  1.00  0.00 \nHETATM  330  H           1      -0.105   8.848   1.652  1.00  0.00 \nHETATM  331  H           1      -1.308   8.997   2.950  1.00  0.00 \nHETATM  332  H           1      -2.576  10.642   1.584  1.00  0.00 \nHETATM  333  H           1      -1.400  10.458   0.262  1.00  0.00 \nHETATM  334  H           1       0.416  11.272   1.765  1.00  0.00 \nHETATM  335  H           1      -0.761  11.465   3.082  1.00  0.00 \nHETATM  336  H           1      -2.016  13.126   1.716  1.00  0.00 \nHETATM  337  H           1      -0.839  12.933   0.398  1.00  0.00 \nHETATM  338  H           1       0.978  13.741   1.894  1.00  0.00 \nHETATM  339  H           1      -0.189  13.915   3.224  1.00  0.00 \nHETATM  340  H           1      -1.473  15.574   1.885  1.00  0.00 \nHETATM  341  H           1      -0.309  15.403   0.553  1.00  0.00 \nHETATM  342  H           1       1.512  16.236   2.027  1.00  0.00 \nHETATM  343  H           1       0.356  16.395   3.372  1.00  0.00 \nHETATM  344  H           1      -0.793  17.892   1.125  1.00  0.00 \nHETATM  345  H           1       0.403  19.871   1.743  1.00  0.00 \nHETATM  346  H           1       2.729  18.261   2.583  1.00  0.00 \nHETATM  347  H           1       1.666  18.429   4.003  1.00  0.00 \nHETATM  348  H           1       1.680  20.901   3.718  1.00  0.00 \nHETATM  349  H           1       2.733  20.734   2.297  1.00  0.00 \nHETATM  350  H           1       4.496  19.701   3.725  1.00  0.00 \nHETATM  351  H           1       3.443  19.879   5.148  1.00  0.00 \nHETATM  352  H           1       3.412  22.349   4.815  1.00  0.00 \nHETATM  353  H           1       4.461  22.170   3.391  1.00  0.00 \nHETATM  354  H           1       6.241  21.182   4.827  1.00  0.00 \nHETATM  355  H           1       5.192  21.369   6.251  1.00  0.00 \nHETATM  356  H           1       5.138  23.834   5.886  1.00  0.00 \nHETATM  357  H           1       6.186  23.646   4.463  1.00  0.00 \nHETATM  358  H           1      -2.234   3.917   4.760  1.00  0.00 \nHETATM  359  H           1      -3.391   3.970   3.410  1.00  0.00 \nHETATM  360  H           1      -3.999   6.312   4.032  1.00  0.00 \nHETATM  361  H           1      -2.855   6.243   5.391  1.00  0.00 \nHETATM  362  H           1      -4.143   4.340   6.369  1.00  0.00 \nHETATM  363  H           1      -5.294   4.431   5.018  1.00  0.00 \nHETATM  364  H           1      -5.887   6.762   5.689  1.00  0.00 \nHETATM  365  H           1      -4.741   6.657   7.044  1.00  0.00 \nHETATM  366  H           1      -6.034   4.719   7.961  1.00  0.00 \nHETATM  367  H           1      -7.201   4.881   6.631  1.00  0.00 \nHETATM  368  H           1      -7.762   7.185   7.405  1.00  0.00 \nHETATM  369  H           1      -6.577   7.027   8.721  1.00  0.00 \nHETATM  370  H           1      -7.858   5.057   9.599  1.00  0.00 \nHETATM  371  H           1      -9.075   5.305   8.334  1.00  0.00 \nHETATM  372  H           1      -8.416   7.259  10.676  1.00  0.00 \nHETATM  373  H           1     -10.661   7.994  10.389  1.00  0.00 \nHETATM  374  H           1     -11.324   5.660   8.731  1.00  0.00 \nHETATM  375  H           1     -10.692   6.909   7.628  1.00  0.00 \nHETATM  376  H           1     -12.360   8.530   8.520  1.00  0.00 \nHETATM  377  H           1     -12.985   7.281   9.620  1.00  0.00 \nHETATM  378  H           1     -13.603   5.869   7.659  1.00  0.00 \nHETATM  379  H           1     -12.992   7.129   6.563  1.00  0.00 \nHETATM  380  H           1     -14.657   8.738   7.488  1.00  0.00 \nHETATM  381  H           1     -15.267   7.476   8.582  1.00  0.00 \nHETATM  382  H           1     -15.891   6.077   6.614  1.00  0.00 \nHETATM  383  H           1     -15.293   7.348   5.524  1.00  0.00 \nHETATM  384  H           1     -16.964   8.939   6.466  1.00  0.00 \nHETATM  385  H           1     -17.561   7.667   7.556  1.00  0.00 \nHETATM  386  H           1       4.947   7.200   1.566  1.00  0.00 \nHETATM  387  H           1       4.294   6.092   2.798  1.00  0.00 \nHETATM  388  H           1       3.737   8.034   4.255  1.00  0.00 \nHETATM  389  H           1       4.363   9.148   3.021  1.00  0.00 \nHETATM  390  H           1       6.629   8.137   3.256  1.00  0.00 \nHETATM  391  H           1       6.005   7.031   4.501  1.00  0.00 \nHETATM  392  H           1       5.382   8.976   5.924  1.00  0.00 \nHETATM  393  H           1       5.977  10.088   4.673  1.00  0.00 \nHETATM  394  H           1       8.269   9.137   4.920  1.00  0.00 \nHETATM  395  H           1       7.673   8.038   6.185  1.00  0.00 \nHETATM  396  H           1       7.001   9.993   7.571  1.00  0.00 \nHETATM  397  H           1       7.579  11.095   6.302  1.00  0.00 \nHETATM  398  H           1       9.884  10.192   6.570  1.00  0.00 \nHETATM  399  H           1       9.304   9.100   7.851  1.00  0.00 \nHETATM  400  H           1       8.493  11.861   8.565  1.00  0.00 \nHETATM  401  H           1      10.536  12.152   9.787  1.00  0.00 \nHETATM  402  H           1      11.947  10.429   7.821  1.00  0.00 \nHETATM  403  H           1      11.362   9.399   9.150  1.00  0.00 \nHETATM  404  H           1      12.509  10.880  10.795  1.00  0.00 \nHETATM  405  H           1      13.103  11.896   9.462  1.00  0.00 \nHETATM  406  H           1      14.343   9.946   8.529  1.00  0.00 \nHETATM  407  H           1      13.743   8.930   9.859  1.00  0.00 \nHETATM  408  H           1      14.872  10.428  11.505  1.00  0.00 \nHETATM  409  H           1      15.489  11.425  10.168  1.00  0.00 \nHETATM  410  H           1      16.727   9.459   9.273  1.00  0.00 \nHETATM  411  H           1      16.099   8.457  10.601  1.00  0.00 \nHETATM  412  H           1      17.219   9.951  12.254  1.00  0.00 \nHETATM  413  H           1      17.860  10.940  10.923  1.00  0.00 \nHETATM  414  H           1      19.093   8.960  10.046  1.00  0.00 \nHETATM  415  H           1      18.446   7.968  11.372  1.00  0.00 \nHETATM  416  H           1      19.573   9.448  13.030  1.00  0.00 \nHETATM  417  H           1      20.221  10.440  11.703  1.00  0.00 \nHETATM  418  H           1      20.748   8.752  11.891  1.00  0.00 \nHETATM  419  H           1       6.625 -11.535  12.006  1.00  0.00 \nHETATM  420  H           1       7.653 -10.282  12.735  1.00  0.00 \nHETATM  421  H           1       9.075 -12.048  13.767  1.00  0.00 \nHETATM  422  H           1       8.046 -13.303  13.036  1.00  0.00 \nHETATM  423  H           1       7.378 -12.215  14.274  1.00  0.00 \nHETATM  424  H           1      -2.762 -20.465  -4.223  1.00  0.00 \nHETATM  425  H           1      -3.052 -20.802  -2.502  1.00  0.00 \nHETATM  426  H           1      -4.423 -22.213  -4.847  1.00  0.00 \nHETATM  427  H           1      -4.714 -22.551  -3.124  1.00  0.00 \nHETATM  428  H           1      -3.123 -22.895  -3.842  1.00  0.00 \nHETATM  429  H           1       3.124  -5.987  17.380  1.00  0.00 \nHETATM  430  H           1       1.964  -6.995  16.486  1.00  0.00 \nHETATM  431  H           1       0.758  -7.491  18.610  1.00  0.00 \nHETATM  432  H           1       1.921  -6.484  19.504  1.00  0.00 \nHETATM  433  H           1       2.464  -7.981  18.713  1.00  0.00 \nHETATM  434  H           1       5.023  17.135 -10.744  1.00  0.00 \nHETATM  435  H           1       4.500  15.996 -12.005  1.00  0.00 \nHETATM  436  H           1       6.079  17.053 -13.616  1.00  0.00 \nHETATM  437  H           1       6.604  18.192 -12.354  1.00  0.00 \nHETATM  438  H           1       4.935  18.248 -12.965  1.00  0.00 \nHETATM  439  H           1       7.973  22.680   5.906  1.00  0.00 \nHETATM  440  H           1       6.926  22.873   7.330  1.00  0.00 \nHETATM  441  H           1       6.871  25.336   6.956  1.00  0.00 \nHETATM  442  H           1       7.919  25.143   5.532  1.00  0.00 \nHETATM  443  H           1       8.540  24.757   7.153  1.00  0.00 \nHETATM  444  H           1     -19.255   3.289  -6.856  1.00  0.00 \nHETATM  445  H           1     -19.135   1.523  -7.009  1.00  0.00 \nHETATM  446  H           1     -20.826   1.565  -8.838  1.00  0.00 \nHETATM  447  H           1     -20.947   3.334  -8.684  1.00  0.00 \nHETATM  448  H           1     -21.476   2.286  -7.348  1.00  0.00 \nHETATM  449  H           1     -18.187   6.275   5.583  1.00  0.00 \nHETATM  450  H           1     -17.597   7.553   4.497  1.00  0.00 \nHETATM  451  H           1     -19.276   9.132   5.443  1.00  0.00 \nHETATM  452  H           1     -19.866   7.853   6.529  1.00  0.00 \nHETATM  453  H           1     -20.065   7.687   4.770  1.00  0.00 \nCONECT    1    2    6   19  176\nCONECT    2    1    3   21  177\nCONECT    3    2    4   22  178\nCONECT    4    3    5   23  179\nCONECT    5    4    6    7  180\nCONECT    6    1    5\nCONECT    7    5    8\nCONECT    8    7    9   10   11\nCONECT    9    8   18  181  182\nCONECT   10    8   13   17  183\nCONECT   11    8   12\nCONECT   12   11   13   14  184\nCONECT   13   10   12   16  185\nCONECT   14   12   15  186  187\nCONECT   15   14  143\nCONECT   16   13  109\nCONECT   17   10  126\nCONECT   18    9   92\nCONECT   19    1   20  188  189\nCONECT   20   19   24\nCONECT   21    2   41\nCONECT   22    3   58\nCONECT   23    4   75\nCONECT   24   20   25   25   26\nCONECT   25   24   24\nCONECT   26   24   27  190  191\nCONECT   27   26   28  192  193\nCONECT   28   27   29  194  195\nCONECT   29   28   30  196  197\nCONECT   30   29   31  198  199\nCONECT   31   30   32  200  201\nCONECT   32   31   33  202  203\nCONECT   33   32   34   34  204\nCONECT   34   33   33   35  205\nCONECT   35   34   36  206  207\nCONECT   36   35   37  208  209\nCONECT   37   36   38  210  211\nCONECT   38   37   39  212  213\nCONECT   39   38   40  214  215\nCONECT   40   39  164  216  217\nCONECT   41   21   42   42   43\nCONECT   42   41   41\nCONECT   43   41   44  218  219\nCONECT   44   43   45  220  221\nCONECT   45   44   46  222  223\nCONECT   46   45   47  224  225\nCONECT   47   46   48  226  227\nCONECT   48   47   49  228  229\nCONECT   49   48   50  230  231\nCONECT   50   49   51   51  232\nCONECT   51   50   50   52  233\nCONECT   52   51   53  234  235\nCONECT   53   52   54  236  237\nCONECT   54   53   55  238  239\nCONECT   55   54   56  240  241\nCONECT   56   55   57  242  243\nCONECT   57   56  162  244  245\nCONECT   58   22   59   59   60\nCONECT   59   58   58\nCONECT   60   58   61  246  247\nCONECT   61   60   62  248  249\nCONECT   62   61   63  250  251\nCONECT   63   62   64  252  253\nCONECT   64   63   65  254  255\nCONECT   65   64   66  256  257\nCONECT   66   65   67  258  259\nCONECT   67   66   68   68  260\nCONECT   68   67   67   69  261\nCONECT   69   68   70  262  263\nCONECT   70   69   71  264  265\nCONECT   71   70   72  266  267\nCONECT   72   71   73  268  269\nCONECT   73   72   74  270  271\nCONECT   74   73  168  272  273\nCONECT   75   23   76   76   77\nCONECT   76   75   75\nCONECT   77   75   78  274  275\nCONECT   78   77   79  276  277\nCONECT   79   78   80  278  279\nCONECT   80   79   81  280  281\nCONECT   81   80   82  282  283\nCONECT   82   81   83  284  285\nCONECT   83   82   84  286  287\nCONECT   84   83   85   85  288\nCONECT   85   84   84   86  289\nCONECT   86   85   87  290  291\nCONECT   87   86   88  292  293\nCONECT   88   87   89  294  295\nCONECT   89   88   90  296  297\nCONECT   90   89   91  298  299\nCONECT   91   90  166  300  301\nCONECT   92   18   93   93   94\nCONECT   93   92   92\nCONECT   94   92   95  302  303\nCONECT   95   94   96  304  305\nCONECT   96   95   97  306  307\nCONECT   97   96   98  308  309\nCONECT   98   97   99  310  311\nCONECT   99   98  100  312  313\nCONECT  100   99  101  314  315\nCONECT  101  100  102  102  316\nCONECT  102  101  101  103  317\nCONECT  103  102  104  318  319\nCONECT  104  103  105  320  321\nCONECT  105  104  106  322  323\nCONECT  106  105  107  324  325\nCONECT  107  106  108  326  327\nCONECT  108  107  172  328  329\nCONECT  109   16  110  110  111\nCONECT  110  109  109\nCONECT  111  109  112  330  331\nCONECT  112  111  113  332  333\nCONECT  113  112  114  334  335\nCONECT  114  113  115  336  337\nCONECT  115  114  116  338  339\nCONECT  116  115  117  340  341\nCONECT  117  116  118  342  343\nCONECT  118  117  119  119  344\nCONECT  119  118  118  120  345\nCONECT  120  119  121  346  347\nCONECT  121  120  122  348  349\nCONECT  122  121  123  350  351\nCONECT  123  122  124  352  353\nCONECT  124  123  125  354  355\nCONECT  125  124  170  356  357\nCONECT  126   17  127  127  128\nCONECT  127  126  126\nCONECT  128  126  129  358  359\nCONECT  129  128  130  360  361\nCONECT  130  129  131  362  363\nCONECT  131  130  132  364  365\nCONECT  132  131  133  366  367\nCONECT  133  132  134  368  369\nCONECT  134  133  135  370  371\nCONECT  135  134  136  136  372\nCONECT  136  135  135  137  373\nCONECT  137  136  138  374  375\nCONECT  138  137  139  376  377\nCONECT  139  138  140  378  379\nCONECT  140  139  141  380  381\nCONECT  141  140  142  382  383\nCONECT  142  141  174  384  385\nCONECT  143   15  144  144  145\nCONECT  144  143  143\nCONECT  145  143  146  386  387\nCONECT  146  145  147  388  389\nCONECT  147  146  148  390  391\nCONECT  148  147  149  392  393\nCONECT  149  148  150  394  395\nCONECT  150  149  151  396  397\nCONECT  151  150  152  398  399\nCONECT  152  151  153  153  400\nCONECT  153  152  152  154  401\nCONECT  154  153  155  402  403\nCONECT  155  154  156  404  405\nCONECT  156  155  157  406  407\nCONECT  157  156  158  408  409\nCONECT  158  157  159  410  411\nCONECT  159  158  160  412  413\nCONECT  160  159  161  414  415\nCONECT  161  160  416  417  418\nCONECT  162   57  163  419  420\nCONECT  163  162  421  422  423\nCONECT  164   40  165  424  425\nCONECT  165  164  426  427  428\nCONECT  166   91  167  429  430\nCONECT  167  166  431  432  433\nCONECT  168   74  169  434  435\nCONECT  169  168  436  437  438\nCONECT  170  125  171  439  440\nCONECT  171  170  441  442  443\nCONECT  172  108  173  444  445\nCONECT  173  172  446  447  448\nCONECT  174  142  175  449  450\nCONECT  175  174  451  452  453\nCONECT  176    1\nCONECT  177    2\nCONECT  178    3\nCONECT  179    4\nCONECT  180    5\nCONECT  181    9\nCONECT  182    9\nCONECT  183   10\nCONECT  184   12\nCONECT  185   13\nCONECT  186   14\nCONECT  187   14\nCONECT  188   19\nCONECT  189   19\nCONECT  190   26\nCONECT  191   26\nCONECT  192   27\nCONECT  193   27\nCONECT  194   28\nCONECT  195   28\nCONECT  196   29\nCONECT  197   29\nCONECT  198   30\nCONECT  199   30\nCONECT  200   31\nCONECT  201   31\nCONECT  202   32\nCONECT  203   32\nCONECT  204   33\nCONECT  205   34\nCONECT  206   35\nCONECT  207   35\nCONECT  208   36\nCONECT  209   36\nCONECT  210   37\nCONECT  211   37\nCONECT  212   38\nCONECT  213   38\nCONECT  214   39\nCONECT  215   39\nCONECT  216   40\nCONECT  217   40\nCONECT  218   43\nCONECT  219   43\nCONECT  220   44\nCONECT  221   44\nCONECT  222   45\nCONECT  223   45\nCONECT  224   46\nCONECT  225   46\nCONECT  226   47\nCONECT  227   47\nCONECT  228   48\nCONECT  229   48\nCONECT  230   49\nCONECT  231   49\nCONECT  232   50\nCONECT  233   51\nCONECT  234   52\nCONECT  235   52\nCONECT  236   53\nCONECT  237   53\nCONECT  238   54\nCONECT  239   54\nCONECT  240   55\nCONECT  241   55\nCONECT  242   56\nCONECT  243   56\nCONECT  244   57\nCONECT  245   57\nCONECT  246   60\nCONECT  247   60\nCONECT  248   61\nCONECT  249   61\nCONECT  250   62\nCONECT  251   62\nCONECT  252   63\nCONECT  253   63\nCONECT  254   64\nCONECT  255   64\nCONECT  256   65\nCONECT  257   65\nCONECT  258   66\nCONECT  259   66\nCONECT  260   67\nCONECT  261   68\nCONECT  262   69\nCONECT  263   69\nCONECT  264   70\nCONECT  265   70\nCONECT  266   71\nCONECT  267   71\nCONECT  268   72\nCONECT  269   72\nCONECT  270   73\nCONECT  271   73\nCONECT  272   74\nCONECT  273   74\nCONECT  274   77\nCONECT  275   77\nCONECT  276   78\nCONECT  277   78\nCONECT  278   79\nCONECT  279   79\nCONECT  280   80\nCONECT  281   80\nCONECT  282   81\nCONECT  283   81\nCONECT  284   82\nCONECT  285   82\nCONECT  286   83\nCONECT  287   83\nCONECT  288   84\nCONECT  289   85\nCONECT  290   86\nCONECT  291   86\nCONECT  292   87\nCONECT  293   87\nCONECT  294   88\nCONECT  295   88\nCONECT  296   89\nCONECT  297   89\nCONECT  298   90\nCONECT  299   90\nCONECT  300   91\nCONECT  301   91\nCONECT  302   94\nCONECT  303   94\nCONECT  304   95\nCONECT  305   95\nCONECT  306   96\nCONECT  307   96\nCONECT  308   97\nCONECT  309   97\nCONECT  310   98\nCONECT  311   98\nCONECT  312   99\nCONECT  313   99\nCONECT  314  100\nCONECT  315  100\nCONECT  316  101\nCONECT  317  102\nCONECT  318  103\nCONECT  319  103\nCONECT  320  104\nCONECT  321  104\nCONECT  322  105\nCONECT  323  105\nCONECT  324  106\nCONECT  325  106\nCONECT  326  107\nCONECT  327  107\nCONECT  328  108\nCONECT  329  108\nCONECT  330  111\nCONECT  331  111\nCONECT  332  112\nCONECT  333  112\nCONECT  334  113\nCONECT  335  113\nCONECT  336  114\nCONECT  337  114\nCONECT  338  115\nCONECT  339  115\nCONECT  340  116\nCONECT  341  116\nCONECT  342  117\nCONECT  343  117\nCONECT  344  118\nCONECT  345  119\nCONECT  346  120\nCONECT  347  120\nCONECT  348  121\nCONECT  349  121\nCONECT  350  122\nCONECT  351  122\nCONECT  352  123\nCONECT  353  123\nCONECT  354  124\nCONECT  355  124\nCONECT  356  125\nCONECT  357  125\nCONECT  358  128\nCONECT  359  128\nCONECT  360  129\nCONECT  361  129\nCONECT  362  130\nCONECT  363  130\nCONECT  364  131\nCONECT  365  131\nCONECT  366  132\nCONECT  367  132\nCONECT  368  133\nCONECT  369  133\nCONECT  370  134\nCONECT  371  134\nCONECT  372  135\nCONECT  373  136\nCONECT  374  137\nCONECT  375  137\nCONECT  376  138\nCONECT  377  138\nCONECT  378  139\nCONECT  379  139\nCONECT  380  140\nCONECT  381  140\nCONECT  382  141\nCONECT  383  141\nCONECT  384  142\nCONECT  385  142\nCONECT  386  145\nCONECT  387  145\nCONECT  388  146\nCONECT  389  146\nCONECT  390  147\nCONECT  391  147\nCONECT  392  148\nCONECT  393  148\nCONECT  394  149\nCONECT  395  149\nCONECT  396  150\nCONECT  397  150\nCONECT  398  151\nCONECT  399  151\nCONECT  400  152\nCONECT  401  153\nCONECT  402  154\nCONECT  403  154\nCONECT  404  155\nCONECT  405  155\nCONECT  406  156\nCONECT  407  156\nCONECT  408  157\nCONECT  409  157\nCONECT  410  158\nCONECT  411  158\nCONECT  412  159\nCONECT  413  159\nCONECT  414  160\nCONECT  415  160\nCONECT  416  161\nCONECT  417  161\nCONECT  418  161\nCONECT  419  162\nCONECT  420  162\nCONECT  421  163\nCONECT  422  163\nCONECT  423  163\nCONECT  424  164\nCONECT  425  164\nCONECT  426  165\nCONECT  427  165\nCONECT  428  165\nCONECT  429  166\nCONECT  430  166\nCONECT  431  167\nCONECT  432  167\nCONECT  433  167\nCONECT  434  168\nCONECT  435  168\nCONECT  436  169\nCONECT  437  169\nCONECT  438  169\nCONECT  439  170\nCONECT  440  170\nCONECT  441  171\nCONECT  442  171\nCONECT  443  171\nCONECT  444  172\nCONECT  445  172\nCONECT  446  173\nCONECT  447  173\nCONECT  448  173\nCONECT  449  174\nCONECT  450  174\nCONECT  451  175\nCONECT  452  175\nCONECT  453  175\nMASTER        0    0    0    0    0    0    0    0  453    0  453    0\nEND\n",
    "HEADER    Penicillin G, an antibiotic\nCOMPND    al3077\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Aug 30 12:33:12 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.542   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       1.415   1.509   0.000  1.00  0.00 \nHETATM    4  O           1       2.209   2.398  -0.083  1.00  0.00 \nHETATM    5  N           1       0.066   1.475   0.061  1.00  0.00 \nHETATM    6  N           1       2.125  -0.528   1.243  1.00  0.00 \nHETATM    7  C           1       2.235  -1.858   1.457  1.00  0.00 \nHETATM    8  O           1       2.669  -2.251   2.509  1.00  0.00 \nHETATM    9  C           1       1.827  -2.860   0.414  1.00  0.00 \nHETATM   10  C           1       1.446  -4.153   1.098  1.00  0.00 \nHETATM   11  C           1       0.143  -4.328   1.578  1.00  0.00 \nHETATM   12  C           1      -0.216  -5.521   2.214  1.00  0.00 \nHETATM   13  C           1       0.729  -6.540   2.373  1.00  0.00 \nHETATM   14  C           1       2.034  -6.363   1.902  1.00  0.00 \nHETATM   15  C           1       2.393  -5.168   1.268  1.00  0.00 \nHETATM   16  S           1      -0.818  -0.450   1.519  1.00  0.00 \nHETATM   17  C           1      -1.605   1.127   1.810  1.00  0.00 \nHETATM   18  C           1      -1.800   1.394   3.317  1.00  0.00 \nHETATM   19  C           1      -2.966   1.138   1.082  1.00  0.00 \nHETATM   20  C           1      -0.629   2.147   1.173  1.00  0.00 \nHETATM   21  C           1      -1.351   3.368   0.682  1.00  0.00 \nHETATM   22  O           1      -1.537   3.505  -0.499  1.00  0.00 \nHETATM   23  O           1      -2.048   4.114   1.557  1.00  0.00 \nHETATM   24  H           1      -0.466  -0.363  -0.916  1.00  0.00 \nHETATM   25  H           1       1.982  -0.387  -0.919  1.00  0.00 \nHETATM   26  H           1       2.409   0.115   1.973  1.00  0.00 \nHETATM   27  H           1       2.660  -3.033  -0.268  1.00  0.00 \nHETATM   28  H           1       0.971  -2.493  -0.151  1.00  0.00 \nHETATM   29  H           1      -0.596  -3.536   1.454  1.00  0.00 \nHETATM   30  H           1      -1.232  -5.657   2.584  1.00  0.00 \nHETATM   31  H           1       0.449  -7.470   2.868  1.00  0.00 \nHETATM   32  H           1       2.772  -7.155   2.030  1.00  0.00 \nHETATM   33  H           1       3.412  -5.032   0.906  1.00  0.00 \nHETATM   34  H           1      -0.839   1.345   3.829  1.00  0.00 \nHETATM   35  H           1      -2.470   0.644   3.739  1.00  0.00 \nHETATM   36  H           1      -2.233   2.384   3.459  1.00  0.00 \nHETATM   37  H           1      -3.586   0.322   1.454  1.00  0.00 \nHETATM   38  H           1      -2.811   1.012   0.010  1.00  0.00 \nHETATM   39  H           1      -3.480   2.082   1.263  1.00  0.00 \nHETATM   40  H           1       0.108   2.446   1.919  1.00  0.00 \nHETATM   41  H           1      -2.798   4.548   1.098  1.00  0.00 \nCONECT    1    2    5   16   24\nCONECT    2    1    3    6   25\nCONECT    3    2    4    4    5\nCONECT    4    3    3\nCONECT    5    1    3   20\nCONECT    6    2    7   26\nCONECT    7    6    8    8    9\nCONECT    8    7    7\nCONECT    9    7   10   27   28\nCONECT   10    9   11   11   15\nCONECT   11   10   10   12   29\nCONECT   12   11   13   13   30\nCONECT   13   12   12   14   31\nCONECT   14   13   15   15   32\nCONECT   15   10   14   14   33\nCONECT   16    1   17\nCONECT   17   16   18   19   20\nCONECT   18   17   34   35   36\nCONECT   19   17   37   38   39\nCONECT   20    5   17   21   40\nCONECT   21   20   22   22   23\nCONECT   22   21   21\nCONECT   23   21   41\nCONECT   24    1\nCONECT   25    2\nCONECT   26    6\nCONECT   27    9\nCONECT   28    9\nCONECT   29   11\nCONECT   30   12\nCONECT   31   13\nCONECT   32   14\nCONECT   33   15\nCONECT   34   18\nCONECT   35   18\nCONECT   36   18\nCONECT   37   19\nCONECT   38   19\nCONECT   39   19\nCONECT   40   20\nCONECT   41   23\nMASTER        0    0    0    0    0    0    0    0   41    0   41    0\nEND\n",
    "HEADER    Salvinorin A: A dissociative hallucinogen, kappa opioid receptor agonist\nATOM      1  O           0      -1.578   3.509   1.054  0.00  0.00           O+0\nATOM      2  O           0      -0.661  -3.341  -1.950  0.00  0.00           O+0\nATOM      3  O           0      -0.961  -0.736  -2.292  0.00  0.00           O+0\nATOM      4  O           0       0.223   4.284   1.789  0.00  0.00           O+0\nATOM      5  O           0       4.133  -2.520   1.067  0.00  0.00           O+0\nATOM      6  O           0       4.305  -2.225  -1.047  0.00  0.00           O+0\nATOM      7  O           0      -5.473   1.972   2.519  0.00  0.00           O+0\nATOM      8  O           0      -1.864  -4.598  -3.067  0.00  0.00           O+0\nATOM      9  C           0       1.875  -0.263  -0.355  0.00  0.00           C+0\nATOM     10  C           0      -0.335   1.379  -0.322  0.00  0.00           C+0\nATOM     11  C           0       0.290  -0.090  -0.402  0.00  0.00           C+0\nATOM     12  C           0       0.295   2.080   0.949  0.00  0.00           C+0\nATOM     13  C           0       2.416   0.613   0.838  0.00  0.00           C+0\nATOM     14  C           0       2.218  -1.798  -0.082  0.00  0.00           C+0\nATOM     15  C           0       1.854   2.057   0.955  0.00  0.00           C+0\nATOM     16  C           0      -1.892   1.349  -0.054  0.00  0.00           C+0\nATOM     17  C           0      -0.312  -1.076  -1.312  0.00  0.00           C+0\nATOM     18  C           0       1.427  -2.783  -1.008  0.00  0.00           C+0\nATOM     19  C           0       2.599   0.182  -1.678  0.00  0.00           C+0\nATOM     20  C           0      -0.152   2.242  -1.623  0.00  0.00           C+0\nATOM     21  C           0      -0.102  -2.502  -1.056  0.00  0.00           C+0\nATOM     22  C           0      -2.483   2.720   0.438  0.00  0.00           C+0\nATOM     23  C           0      -0.364   3.344   1.274  0.00  0.00           C+0\nATOM     24  C           0       3.632  -2.188  -0.023  0.00  0.00           C+0\nATOM     25  C           0      -3.721   2.668   1.259  0.00  0.00           C+0\nATOM     26  C           0      -4.516   3.764   1.594  0.00  0.00           C+0\nATOM     27  C           0      -4.363   1.580   1.857  0.00  0.00           C+0\nATOM     28  C           0      -1.768  -3.894  -2.073  0.00  0.00           C+0\nATOM     29  C           0       5.353  -2.949   1.401  0.00  0.00           C+0\nATOM     30  C           0      -5.577   3.309   2.365  0.00  0.00           C+0\nATOM     31  C           0      -2.903  -3.782  -1.178  0.00  0.00           C+0\nATOM     32  H           0      -0.032  -0.494   0.566  0.00  0.00           H+0\nATOM     33  H           0       0.021   1.488   1.831  0.00  0.00           H+0\nATOM     34  H           0       2.176   0.125   1.788  0.00  0.00           H+0\nATOM     35  H           0       3.509   0.668   0.818  0.00  0.00           H+0\nATOM     36  H           0       1.806  -2.023   0.910  0.00  0.00           H+0\nATOM     37  H           0       2.250   2.682   0.154  0.00  0.00           H+0\nATOM     38  H           0       2.226   2.485   1.891  0.00  0.00           H+0\nATOM     39  H           0      -2.454   1.020  -0.933  0.00  0.00           H+0\nATOM     40  H           0      -2.074   0.590   0.706  0.00  0.00           H+0\nATOM     41  H           0       1.574  -3.811  -0.660  0.00  0.00           H+0\nATOM     42  H           0       1.827  -2.744  -2.026  0.00  0.00           H+0\nATOM     43  H           0       2.260  -0.386  -2.545  0.00  0.00           H+0\nATOM     44  H           0       2.509   1.228  -1.923  0.00  0.00           H+0\nATOM     45  H           0       3.681   0.081  -1.611  0.00  0.00           H+0\nATOM     46  H           0      -0.558   1.749  -2.507  0.00  0.00           H+0\nATOM     47  H           0      -0.638   3.215  -1.562  0.00  0.00           H+0\nATOM     48  H           0       0.868   2.520  -1.836  0.00  0.00           H+0\nATOM     49  H           0      -0.497  -2.735  -0.061  0.00  0.00           H+0\nATOM     50  H           0      -2.764   3.279  -0.460  0.00  0.00           H+0\nATOM     51  H           0      -4.357   4.736   1.321  0.00  0.00           H+0\nATOM     52  H           0      -4.064   0.605   1.821  0.00  0.00           H+0\nATOM     53  H           0       5.360  -3.151   2.472  0.00  0.00           H+0\nATOM     54  H           0       6.112  -2.193   1.186  0.00  0.00           H+0\nATOM     55  H           0       5.605  -3.873   0.875  0.00  0.00           H+0\nATOM     56  H           0      -6.323   3.886   2.756  0.00  0.00           H+0\nATOM     57  H           0      -3.222  -2.742  -1.105  0.00  0.00           H+0\nATOM     58  H           0      -2.636  -4.143  -0.184  0.00  0.00           H+0\nATOM     59  H           0      -3.759  -4.370  -1.521  0.00  0.00           H+0\nCONECT    1   22   23    0    0                                         NONE  65\nCONECT    2   21   28    0    0                                         NONE  66\nCONECT    3   17    0    0    0                                         NONE  67\nCONECT    4   23    0    0    0                                         NONE  68\nCONECT    5   24   29    0    0                                         NONE  69\nCONECT    6   24    0    0    0                                         NONE  70\nCONECT    7   27   30    0    0                                         NONE  71\nCONECT    8   28    0    0    0                                         NONE  72\nCONECT    9   11   13   14   19                                         NONE  73\nCONECT   10   11   12   16   20                                         NONE  74\nCONECT   11    9   10   17   32                                         NONE  75\nCONECT   12   10   15   23   33                                         NONE  76\nCONECT   13    9   15   34   35                                         NONE  77\nCONECT   14    9   18   24   36                                         NONE  78\nCONECT   15   12   13   37   38                                         NONE  79\nCONECT   16   10   22   39   40                                         NONE  80\nCONECT   17    3   11   21    0                                         NONE  81\nCONECT   18   14   21   41   42                                         NONE  82\nCONECT   19    9   43   44   45                                         NONE  83\nCONECT   20   10   46   47   48                                         NONE  84\nCONECT   21    2   17   18   49                                         NONE  85\nCONECT   22    1   16   25   50                                         NONE  86\nCONECT   23    1    4   12    0                                         NONE  87\nCONECT   24    5    6   14    0                                         NONE  88\nCONECT   25   22   26   27    0                                         NONE  89\nCONECT   26   25   30   51    0                                         NONE  90\nCONECT   27    7   25   52    0                                         NONE  91\nCONECT   28    2    8   31    0                                         NONE  92\nCONECT   29    5   53   54   55                                         NONE  93\nCONECT   30    7   26   56    0                                         NONE  94\nCONECT   31   28   57   58   59                                         NONE  95\nEND                                                                     NONE  96\n",
    "HEADER    Sarin: S Enantiomer, a chemical warfare agent\nCOMPND    al3023\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Aug 30 12:33:12 2000  GENERATED BY BABEL 1.6 \nHETATM    1  P           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  F           1       1.779   0.000   0.000  1.00  0.00 \nHETATM    3  C           1      -0.611   1.725   0.000  1.00  0.00 \nHETATM    4  O           1      -0.599  -0.840   1.463  1.00  0.00 \nHETATM    5  O           1      -0.599  -0.841  -1.466  1.00  0.00 \nHETATM    6  C           1      -1.898  -1.369  -1.304  1.00  0.00 \nHETATM    7  C           1      -1.817  -2.772  -0.672  1.00  0.00 \nHETATM    8  C           1      -2.555  -1.476  -2.694  1.00  0.00 \nHETATM    9  H           1      -0.248   2.240  -0.890  1.00  0.00 \nHETATM   10  H           1      -0.248   2.239   0.891  1.00  0.00 \nHETATM   11  H           1      -1.701   1.724   0.000  1.00  0.00 \nHETATM   12  H           1      -2.510  -0.718  -0.679  1.00  0.00 \nHETATM   13  H           1      -1.372  -2.712   0.320  1.00  0.00 \nHETATM   14  H           1      -1.203  -3.414  -1.303  1.00  0.00 \nHETATM   15  H           1      -2.818  -3.194  -0.591  1.00  0.00 \nHETATM   16  H           1      -1.961  -2.124  -3.339  1.00  0.00 \nHETATM   17  H           1      -3.561  -1.885  -2.595  1.00  0.00 \nHETATM   18  H           1      -2.613  -0.482  -3.136  1.00  0.00 \nCONECT    1    2    3    4    4    5\nCONECT    2    1\nCONECT    3    1    9   10   11\nCONECT    4    1    1\nCONECT    5    1    6\nCONECT    6    5    7    8   12\nCONECT    7    6   13   14   15\nCONECT    8    6   16   17   18\nCONECT    9    3\nCONECT   10    3\nCONECT   11    3\nCONECT   12    6\nCONECT   13    7\nCONECT   14    7\nCONECT   15    7\nCONECT   16    8\nCONECT   17    8\nCONECT   18    8\nMASTER        0    0    0    0    0    0    0    0   18    0   18    0\nEND\n",
    "HEADER    Strychnine: Nux Vomica\nCOMPND    al3061\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Wed Aug 30 12:33:12 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.395   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.124   1.193   0.000  1.00  0.00 \nHETATM    4  C           1       1.414   2.398  -0.067  1.00  0.00 \nHETATM    5  C           1       0.014   2.401  -0.115  1.00  0.00 \nHETATM    6  C           1      -0.709   1.203  -0.087  1.00  0.00 \nHETATM    7  C           1       1.911  -1.410   0.160  1.00  0.00 \nHETATM    8  N           1      -0.471  -1.291  -0.057  1.00  0.00 \nHETATM    9  C           1      -1.720  -1.604  -0.472  1.00  0.00 \nHETATM   10  O           1      -2.589  -0.778  -0.359  1.00  0.00 \nHETATM   11  C           1       0.645  -2.239  -0.189  1.00  0.00 \nHETATM   12  C           1      -1.941  -2.698  -1.483  1.00  0.00 \nHETATM   13  C           1      -0.687  -3.549  -1.797  1.00  0.00 \nHETATM   14  H           1       0.525  -3.093   0.477  1.00  0.00 \nHETATM   15  C           1       0.573  -2.674  -1.656  1.00  0.00 \nHETATM   16  H           1      -0.775  -3.908  -2.822  1.00  0.00 \nHETATM   17  O           1      -0.654  -4.641  -0.904  1.00  0.00 \nHETATM   18  C           1       0.221  -5.671  -1.313  1.00  0.00 \nHETATM   19  C           1       1.595  -5.446  -0.726  1.00  0.00 \nHETATM   20  C           1       2.356  -4.403  -1.088  1.00  0.00 \nHETATM   21  C           1       3.723  -4.222  -0.464  1.00  0.00 \nHETATM   22  C           1       1.893  -3.351  -2.072  1.00  0.00 \nHETATM   23  H           1       0.431  -1.791  -2.279  1.00  0.00 \nHETATM   24  H           1       1.803  -3.769  -3.074  1.00  0.00 \nHETATM   25  C           1       2.942  -2.222  -2.062  1.00  0.00 \nHETATM   26  C           1       3.199  -1.816  -0.595  1.00  0.00 \nHETATM   27  C           1       2.322  -1.641   1.618  1.00  0.00 \nHETATM   28  C           1       3.109  -2.956   1.512  1.00  0.00 \nHETATM   29  N           1       3.783  -2.911   0.202  1.00  0.00 \nHETATM   30  H           1       3.212   1.188   0.059  1.00  0.00 \nHETATM   31  H           1       1.957   3.343  -0.078  1.00  0.00 \nHETATM   32  H           1      -0.520   3.349  -0.172  1.00  0.00 \nHETATM   33  H           1      -1.798   1.219  -0.127  1.00  0.00 \nHETATM   34  H           1      -2.263  -2.218  -2.408  1.00  0.00 \nHETATM   35  H           1      -2.740  -3.355  -1.139  1.00  0.00 \nHETATM   36  H           1       0.290  -5.733  -2.400  1.00  0.00 \nHETATM   37  H           1      -0.163  -6.618  -0.935  1.00  0.00 \nHETATM   38  H           1       1.974  -6.159   0.006  1.00  0.00 \nHETATM   39  H           1       4.483  -4.272  -1.243  1.00  0.00 \nHETATM   40  H           1       3.923  -5.012   0.260  1.00  0.00 \nHETATM   41  H           1       2.578  -1.363  -2.625  1.00  0.00 \nHETATM   42  H           1       3.871  -2.566  -2.519  1.00  0.00 \nHETATM   43  H           1       3.898  -0.980  -0.573  1.00  0.00 \nHETATM   44  H           1       1.464  -1.724   2.285  1.00  0.00 \nHETATM   45  H           1       2.987  -0.840   1.943  1.00  0.00 \nHETATM   46  H           1       2.413  -3.794   1.551  1.00  0.00 \nHETATM   47  H           1       3.833  -3.042   2.322  1.00  0.00 \nCONECT    1    2    2    6    8\nCONECT    2    1    1    3    7\nCONECT    3    2    4    4   30\nCONECT    4    3    3    5   31\nCONECT    5    4    6    6   32\nCONECT    6    1    5    5   33\nCONECT    7    2   11   26   27\nCONECT    8    1    9   11\nCONECT    9    8   10   10   12\nCONECT   10    9    9\nCONECT   11    7    8   14   15\nCONECT   12    9   13   34   35\nCONECT   13   12   15   16   17\nCONECT   14   11\nCONECT   15   11   13   22   23\nCONECT   16   13\nCONECT   17   13   18\nCONECT   18   17   19   36   37\nCONECT   19   18   20   20   38\nCONECT   20   19   19   21   22\nCONECT   21   20   29   39   40\nCONECT   22   15   20   24   25\nCONECT   23   15\nCONECT   24   22\nCONECT   25   22   26   41   42\nCONECT   26    7   25   29   43\nCONECT   27    7   28   44   45\nCONECT   28   27   29   46   47\nCONECT   29   21   26   28\nCONECT   30    3\nCONECT   31    4\nCONECT   32    5\nCONECT   33    6\nCONECT   34   12\nCONECT   35   12\nCONECT   36   18\nCONECT   37   18\nCONECT   38   19\nCONECT   39   21\nCONECT   40   21\nCONECT   41   25\nCONECT   42   25\nCONECT   43   26\nCONECT   44   27\nCONECT   45   27\nCONECT   46   28\nCONECT   47   28\nMASTER        0    0    0    0    0    0    0    0   47    0   47    0\nEND\n",
    "HEADER    Sucrose: Sugar\nCOMPND    nat0013\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep  1 09:41:05 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.542   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.041   1.457   0.000  1.00  0.00 \nHETATM    4  C           1       1.414   2.181   1.207  1.00  0.00 \nHETATM    5  C           1      -0.117   2.034   1.128  1.00  0.00 \nHETATM    6  O           1      -0.472   0.668   1.149  1.00  0.00 \nHETATM    7  H           1      -0.566   2.548   1.978  1.00  0.00 \nHETATM    8  O           1      -0.572   2.607  -0.076  1.00  0.00 \nHETATM    9  C           1      -1.867   3.149  -0.193  1.00  0.00 \nHETATM   10  C           1      -1.993   3.815  -1.579  1.00  0.00 \nHETATM   11  C           1      -2.960   2.084  -0.002  1.00  0.00 \nHETATM   12  O           1      -2.117   4.104   0.816  1.00  0.00 \nHETATM   13  C           1      -3.516   4.220   0.978  1.00  0.00 \nHETATM   14  C           1      -4.167   2.959   0.369  1.00  0.00 \nHETATM   15  H           1      -0.368   0.500  -0.896  1.00  0.00 \nHETATM   16  H           1       1.901  -0.501   0.899  1.00  0.00 \nHETATM   17  H           1       1.728   1.949  -0.923  1.00  0.00 \nHETATM   18  H           1       1.774   1.726   2.130  1.00  0.00 \nHETATM   19  H           1      -1.836   3.065  -2.355  1.00  0.00 \nHETATM   20  H           1      -2.981   4.259  -1.698  1.00  0.00 \nHETATM   21  H           1      -3.133   1.511  -0.914  1.00  0.00 \nHETATM   22  H           1      -3.871   5.100   0.441  1.00  0.00 \nHETATM   23  H           1      -4.821   2.452   1.081  1.00  0.00 \nHETATM   24  C           1      -3.859   4.364   2.474  1.00  0.00 \nHETATM   25  O           1      -5.279   4.442   2.639  1.00  0.00 \nHETATM   26  O           1      -4.897   3.325  -0.807  1.00  0.00 \nHETATM   27  O           1      -2.638   1.202   1.079  1.00  0.00 \nHETATM   28  O           1      -0.995   4.834  -1.694  1.00  0.00 \nHETATM   29  C           1      -0.513  -1.453   0.003  1.00  0.00 \nHETATM   30  O           1      -1.944  -1.459  -0.055  1.00  0.00 \nHETATM   31  O           1       2.039  -0.690  -1.152  1.00  0.00 \nHETATM   32  O           1       3.468   1.480   0.101  1.00  0.00 \nHETATM   33  O           1       1.772   3.567   1.189  1.00  0.00 \nHETATM   34  H           1      -3.396   5.270   2.866  1.00  0.00 \nHETATM   35  H           1      -3.480   3.504   3.024  1.00  0.00 \nHETATM   36  H           1      -5.622   5.216   2.180  1.00  0.00 \nHETATM   37  H           1      -5.302   2.544  -1.199  1.00  0.00 \nHETATM   38  H           1      -2.661   1.671   1.919  1.00  0.00 \nHETATM   39  H           1      -1.056   5.255  -2.558  1.00  0.00 \nHETATM   40  H           1      -0.180  -1.958   0.910  1.00  0.00 \nHETATM   41  H           1      -0.118  -1.977  -0.868  1.00  0.00 \nHETATM   42  H           1      -2.305  -1.058   0.741  1.00  0.00 \nHETATM   43  H           1       1.728  -0.261  -1.956  1.00  0.00 \nHETATM   44  H           1       3.781   2.391   0.099  1.00  0.00 \nHETATM   45  H           1       1.428   3.987   0.394  1.00  0.00 \nCONECT    1    2    6   15   29\nCONECT    2    1    3   16   31\nCONECT    3    2    4   17   32\nCONECT    4    3    5   18   33\nCONECT    5    4    6    7    8\nCONECT    6    1    5\nCONECT    7    5\nCONECT    8    5    9\nCONECT    9    8   10   11   12\nCONECT   10    9   19   20   28\nCONECT   11    9   14   21   27\nCONECT   12    9   13\nCONECT   13   12   14   22   24\nCONECT   14   11   13   23   26\nCONECT   15    1\nCONECT   16    2\nCONECT   17    3\nCONECT   18    4\nCONECT   19   10\nCONECT   20   10\nCONECT   21   11\nCONECT   22   13\nCONECT   23   14\nCONECT   24   13   25   34   35\nCONECT   25   24   36\nCONECT   26   14   37\nCONECT   27   11   38\nCONECT   28   10   39\nCONECT   29    1   30   40   41\nCONECT   30   29   42\nCONECT   31    2   43\nCONECT   32    3   44\nCONECT   33    4   45\nCONECT   34   24\nCONECT   35   24\nCONECT   36   25\nCONECT   37   26\nCONECT   38   27\nCONECT   39   28\nCONECT   40   29\nCONECT   41   29\nCONECT   42   30\nCONECT   43   31\nCONECT   44   32\nCONECT   45   33\nMASTER        0    0    0    0    0    0    0    0   45    0   45    0\nEND\n",
    "HEADER    (S)-Thalidomide, a teratogenic enantiomer\nCOMPND    jb03stha\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Mon Sep 18 15:35:27 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.402   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.128   1.197   0.000  1.00  0.00 \nHETATM    4  C           1       1.396   2.389  -0.011  1.00  0.00 \nHETATM    5  C           1       0.003   2.388  -0.010  1.00  0.00 \nHETATM    6  C           1      -0.728   1.196   0.001  1.00  0.00 \nHETATM    7  C           1      -0.415   3.783   0.056  1.00  0.00 \nHETATM    8  O           1      -1.550   4.177   0.150  1.00  0.00 \nHETATM    9  N           1       0.698   4.553   0.096  1.00  0.00 \nHETATM   10  C           1       1.812   3.785   0.053  1.00  0.00 \nHETATM   11  O           1       2.946   4.181   0.146  1.00  0.00 \nHETATM   12  C           1       0.702   6.005   0.319  1.00  0.00 \nHETATM   13  C           1       1.020   6.278   1.801  1.00  0.00 \nHETATM   14  C           1       1.130   7.799   2.000  1.00  0.00 \nHETATM   15  C           1       2.180   8.336   1.068  1.00  0.00 \nHETATM   16  O           1       2.814   9.307   1.391  1.00  0.00 \nHETATM   17  N           1       2.428   7.747  -0.124  1.00  0.00 \nHETATM   18  C           1       1.757   6.647  -0.538  1.00  0.00 \nHETATM   19  O           1       2.022   6.158  -1.607  1.00  0.00 \nHETATM   20  H           1      -0.535  -0.949   0.010  1.00  0.00 \nHETATM   21  H           1       1.938  -0.949   0.010  1.00  0.00 \nHETATM   22  H           1       3.217   1.203   0.020  1.00  0.00 \nHETATM   23  H           1      -1.817   1.201   0.022  1.00  0.00 \nHETATM   24  H           1      -0.272   6.423   0.067  1.00  0.00 \nHETATM   25  H           1       1.968   5.808   2.060  1.00  0.00 \nHETATM   26  H           1       0.228   5.873   2.432  1.00  0.00 \nHETATM   27  H           1       1.408   8.016   3.031  1.00  0.00 \nHETATM   28  H           1       0.173   8.268   1.775  1.00  0.00 \nHETATM   29  H           1       3.142   8.141  -0.727  1.00  0.00 \nCONECT    1    2    2    6   20\nCONECT    2    1    1    3   21\nCONECT    3    2    4    4   22\nCONECT    4    3    3    5   10\nCONECT    5    4    6    6    7\nCONECT    6    1    5    5   23\nCONECT    7    5    8    8    9\nCONECT    8    7    7\nCONECT    9    7   10   12\nCONECT   10    4    9   11   11\nCONECT   11   10   10\nCONECT   12    9   13   18   24\nCONECT   13   12   14   25   26\nCONECT   14   13   15   27   28\nCONECT   15   14   16   16   17\nCONECT   16   15   15\nCONECT   17   15   18   29\nCONECT   18   12   17   19   19\nCONECT   19   18   18\nCONECT   20    1\nCONECT   21    2\nCONECT   22    3\nCONECT   23    6\nCONECT   24   12\nCONECT   25   13\nCONECT   26   13\nCONECT   27   14\nCONECT   28   14\nCONECT   29   17\nMASTER        0    0    0    0    0    0    0    0   29    0   29    0\nEND\n",
    "HEADER    Thymine: Pyrimidine base nucleotide\nCOMPND    jb09thye\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Tue Sep 19 21:46:02 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.399   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.068   1.228   0.000  1.00  0.00 \nHETATM    4  N           1       1.356   2.377  -0.004  1.00  0.00 \nHETATM    5  C           1       0.004   2.350  -0.006  1.00  0.00 \nHETATM    6  N           1      -0.667   1.176  -0.004  1.00  0.00 \nHETATM    7  O           1      -0.611   3.385  -0.006  1.00  0.00 \nHETATM    8  O           1       3.272   1.261   0.006  1.00  0.00 \nHETATM    9  C           1       2.173  -1.300   0.014  1.00  0.00 \nHETATM   10  H           1      -0.549  -0.941   0.006  1.00  0.00 \nHETATM   11  H           1       1.840   3.268  -0.003  1.00  0.00 \nHETATM   12  H           1      -1.681   1.178  -0.004  1.00  0.00 \nHETATM   13  H           1       1.632  -2.055  -0.555  1.00  0.00 \nHETATM   14  H           1       2.293  -1.638   1.044  1.00  0.00 \nHETATM   15  H           1       3.155  -1.146  -0.433  1.00  0.00 \nCONECT    1    2    2    6   10\nCONECT    2    1    1    3    9\nCONECT    3    2    4    8    8\nCONECT    4    3    5   11\nCONECT    5    4    6    7    7\nCONECT    6    1    5   12\nCONECT    7    5    5\nCONECT    8    3    3\nCONECT    9    2   13   14   15\nCONECT   10    1\nCONECT   11    4\nCONECT   12    6\nCONECT   13    9\nCONECT   14    9\nCONECT   15    9\nMASTER        0    0    0    0    0    0    0    0   15    0   15    0\nEND\n",
    "COMPND    Viagra\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nREMARK    from a model provided by Dr Eric Walters\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Mon Oct 16 12:17:54 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.398   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.105   1.207   0.000  1.00  0.00 \nHETATM    4  C           1       1.417   2.427  -0.037  1.00  0.00 \nHETATM    5  C           1       0.017   2.422  -0.014  1.00  0.00 \nHETATM    6  C           1      -0.692   1.216  -0.005  1.00  0.00 \nHETATM    7  H           1      -0.545  -0.944   0.023  1.00  0.00 \nHETATM    8  H           1       1.939  -0.946   0.029  1.00  0.00 \nHETATM    9  H           1      -0.531   3.364  -0.022  1.00  0.00 \nHETATM   10  C           1       2.100   3.733  -0.053  1.00  0.00 \nHETATM   11  N           1       3.453   3.848  -0.302  1.00  0.00 \nHETATM   12  C           1       4.091   5.067  -0.302  1.00  0.00 \nHETATM   13  C           1       3.259   6.246  -0.033  1.00  0.00 \nHETATM   14  C           1       1.897   6.080   0.190  1.00  0.00 \nHETATM   15  N           1       1.310   4.840   0.169  1.00  0.00 \nHETATM   16  O           1       5.271   5.168  -0.544  1.00  0.00 \nHETATM   17  H           1       4.029   2.992  -0.569  1.00  0.00 \nHETATM   18  N           1       3.538   7.572   0.006  1.00  0.00 \nHETATM   19  N           1       2.406   8.264   0.248  1.00  0.00 \nHETATM   20  C           1       1.373   7.363   0.369  1.00  0.00 \nHETATM   21  C           1       4.863   8.163  -0.230  1.00  0.00 \nHETATM   22  H           1       4.799   9.247  -0.133  1.00  0.00 \nHETATM   23  H           1       5.200   7.907  -1.235  1.00  0.00 \nHETATM   24  H           1       5.570   7.774   0.501  1.00  0.00 \nHETATM   25  C           1      -0.079   7.701   0.624  1.00  0.00 \nHETATM   26  C           1      -0.226   9.225   0.805  1.00  0.00 \nHETATM   27  H           1      -0.415   7.190   1.526  1.00  0.00 \nHETATM   28  H           1      -0.680   7.372  -0.224  1.00  0.00 \nHETATM   29  C           1      -1.702   9.584   1.072  1.00  0.00 \nHETATM   30  H           1       0.112   9.732  -0.099  1.00  0.00 \nHETATM   31  H           1       0.383   9.550   1.649  1.00  0.00 \nHETATM   32  H           1      -1.796  10.663   1.198  1.00  0.00 \nHETATM   33  H           1      -2.043   9.083   1.978  1.00  0.00 \nHETATM   34  H           1      -2.315   9.264   0.229  1.00  0.00 \nHETATM   35  O           1       3.461   1.164   0.124  1.00  0.00 \nHETATM   36  C           1       3.859   0.886   1.450  1.00  0.00 \nHETATM   37  C           1       3.396   1.998   2.414  1.00  0.00 \nHETATM   38  H           1       4.947   0.824   1.480  1.00  0.00 \nHETATM   39  H           1       3.443  -0.069   1.771  1.00  0.00 \nHETATM   40  H           1       3.774   1.788   3.414  1.00  0.00 \nHETATM   41  H           1       2.307   2.037   2.446  1.00  0.00 \nHETATM   42  H           1       3.786   2.959   2.077  1.00  0.00 \nHETATM   43  S           1      -2.443   1.230   0.022  1.00  0.00 \nHETATM   44  N           1      -3.045  -0.296  -0.555  1.00  0.00 \nHETATM   45  C           1      -4.498  -0.382  -0.345  1.00  0.00 \nHETATM   46  C           1      -4.996  -1.765  -0.804  1.00  0.00 \nHETATM   47  N           1      -4.674  -1.957  -2.227  1.00  0.00 \nHETATM   48  C           1      -3.222  -1.855  -2.442  1.00  0.00 \nHETATM   49  C           1      -2.728  -0.471  -1.980  1.00  0.00 \nHETATM   50  H           1      -5.005   0.395  -0.919  1.00  0.00 \nHETATM   51  H           1      -4.725  -0.254   0.715  1.00  0.00 \nHETATM   52  H           1      -6.076  -1.822  -0.662  1.00  0.00 \nHETATM   53  H           1      -4.513  -2.539  -0.208  1.00  0.00 \nHETATM   54  H           1      -2.998  -1.979  -3.502  1.00  0.00 \nHETATM   55  H           1      -2.707  -2.629  -1.872  1.00  0.00 \nHETATM   56  H           1      -3.222   0.303  -2.569  1.00  0.00 \nHETATM   57  H           1      -1.651  -0.407  -2.135  1.00  0.00 \nHETATM   58  O           1      -2.929   2.282  -0.818  1.00  0.00 \nHETATM   59  O           1      -2.893   1.442   1.364  1.00  0.00 \nHETATM   60  C           1      -5.177  -3.257  -2.700  1.00  0.00 \nHETATM   61  H           1      -4.954  -3.372  -3.760  1.00  0.00 \nHETATM   62  H           1      -6.257  -3.305  -2.557  1.00  0.00 \nHETATM   63  H           1      -4.703  -4.065  -2.142  1.00  0.00 \nCONECT    1    2    2    6    7\nCONECT    2    1    1    3    8\nCONECT    3    2    4    4   35\nCONECT    4    3    3    5   10\nCONECT    5    4    6    6    9\nCONECT    6    1    5    5   43\nCONECT    7    1\nCONECT    8    2\nCONECT    9    5\nCONECT   10    4   11   15   15\nCONECT   11   10   12   17\nCONECT   12   11   13   16   16\nCONECT   13   12   14   14   18\nCONECT   14   13   13   15   20\nCONECT   15   10   14   14\nCONECT   16   12   12\nCONECT   17   11\nCONECT   18   13   19   21\nCONECT   19   18   20   20\nCONECT   20   14   19   19   25\nCONECT   21   18   22   23   24\nCONECT   22   21\nCONECT   23   21\nCONECT   24   21\nCONECT   25   20   26   27   28\nCONECT   26   25   29   30   31\nCONECT   27   25\nCONECT   28   25\nCONECT   29   26   32   33   34\nCONECT   30   26\nCONECT   31   26\nCONECT   32   29\nCONECT   33   29\nCONECT   34   29\nCONECT   35    3   36\nCONECT   36   35   37   38   39\nCONECT   37   36   40   41   42\nCONECT   38   36\nCONECT   39   36\nCONECT   40   37\nCONECT   41   37\nCONECT   42   37\nCONECT   43    6   44   58   59\nCONECT   44   43   45   49\nCONECT   45   44   46   50   51\nCONECT   46   45   47   52   53\nCONECT   47   46   48   60\nCONECT   48   47   49   54   55\nCONECT   49   44   48   56   57\nCONECT   50   45\nCONECT   51   45\nCONECT   52   46\nCONECT   53   46\nCONECT   54   48\nCONECT   55   48\nCONECT   56   49\nCONECT   57   49\nCONECT   58   43\nCONECT   59   43\nCONECT   60   47   61   62   63\nCONECT   61   60\nCONECT   62   60\nCONECT   63   60\nMASTER        0    0    0    0    0    0    0    0   63    0   63    0\nEND\n",
    "HEADER    Pyridoxine: Vitamin B6\nCOMPND    c8h11no3\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep  1 09:41:05 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.399   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       2.095   1.214   0.000  1.00  0.00 \nHETATM    4  C           1       1.381   2.418   0.018  1.00  0.00 \nHETATM    5  C           1      -0.018   2.390   0.005  1.00  0.00 \nHETATM    6  N           1      -0.688   1.189  -0.006  1.00  0.00 \nHETATM    7  C           1      -0.754  -1.311   0.010  1.00  0.00 \nHETATM    8  O           1       2.079  -1.180   0.011  1.00  0.00 \nHETATM    9  C           1       3.608   1.210   0.001  1.00  0.00 \nHETATM   10  O           1       4.077   1.576   1.303  1.00  0.00 \nHETATM   11  C           1       2.102   3.747   0.058  1.00  0.00 \nHETATM   12  O           1       1.197   4.767   0.493  1.00  0.00 \nHETATM   13  H           1      -0.583   3.322   0.008  1.00  0.00 \nHETATM   14  H           1      -0.438  -1.905   0.867  1.00  0.00 \nHETATM   15  H           1      -0.543  -1.858  -0.909  1.00  0.00 \nHETATM   16  H           1      -1.824  -1.114   0.078  1.00  0.00 \nHETATM   17  H           1       2.145  -1.522  -0.886  1.00  0.00 \nHETATM   18  H           1       3.977   1.922  -0.737  1.00  0.00 \nHETATM   19  H           1       3.973   0.214  -0.250  1.00  0.00 \nHETATM   20  H           1       5.040   1.579   1.315  1.00  0.00 \nHETATM   21  H           1       2.472   3.988  -0.939  1.00  0.00 \nHETATM   22  H           1       2.940   3.690   0.753  1.00  0.00 \nHETATM   23  H           1       1.650   5.617   0.520  1.00  0.00 \nCONECT    1    2    6    7\nCONECT    1    2\nCONECT    2    1    3    8\nCONECT    3    2    4    9\nCONECT    3    4\nCONECT    4    3    5   11\nCONECT    5    4    6   13\nCONECT    5    6\nCONECT    6    1    5\nCONECT    7    1   14   15   16\nCONECT    8    2   17\nCONECT    9    3   10   18   19\nCONECT   10    9   20\nCONECT   11    4   12   21   22\nCONECT   12   11   23\nCONECT   13    5\nCONECT   14    7\nCONECT   15    7\nCONECT   16    7\nCONECT   17    8\nCONECT   18    9\nCONECT   19    9\nCONECT   20   10\nCONECT   21   11\nCONECT   22   11\nCONECT   23   12\nMASTER        0    0    0    0    0    0    0    0   23    0   23    0\nEND\n",
    "HEADER    Ascorbic Acid: Vitamin C\nCOMPND    vit-c\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep  1 09:41:05 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.512   0.000   0.000  1.00  0.00 \nHETATM    3  C           1       1.927   1.264   0.000  1.00  0.00 \nHETATM    4  C           1       0.730   2.091   0.015  1.00  0.00 \nHETATM    5  O           1      -0.382   1.359   0.113  1.00  0.00 \nHETATM    6  O           1       0.759   3.270   0.261  1.00  0.00 \nHETATM    7  O           1       3.197   1.690   0.245  1.00  0.00 \nHETATM    8  O           1       2.283  -1.055   0.386  1.00  0.00 \nHETATM    9  H           1      -0.390  -0.463  -0.907  1.00  0.00 \nHETATM   10  C           1      -0.565  -0.653   1.264  1.00  0.00 \nHETATM   11  H           1       0.050  -1.475   1.629  1.00  0.00 \nHETATM   12  O           1      -0.674   0.397   2.229  1.00  0.00 \nHETATM   13  C           1      -2.028  -1.077   1.106  1.00  0.00 \nHETATM   14  O           1      -2.543  -0.906   2.429  1.00  0.00 \nHETATM   15  H           1       3.383   1.620   1.187  1.00  0.00 \nHETATM   16  H           1       2.156  -1.784  -0.228  1.00  0.00 \nHETATM   17  H           1      -0.774   1.222   1.738  1.00  0.00 \nHETATM   18  H           1      -2.112  -2.110   0.766  1.00  0.00 \nHETATM   19  H           1      -2.545  -0.402   0.425  1.00  0.00 \nHETATM   20  H           1      -2.081  -0.175   2.830  1.00  0.00 \nCONECT    1    2    5    9   10\nCONECT    2    1    3    8\nCONECT    3    2    4    7\nCONECT    4    3    5    6    6\nCONECT    5    1    4\nCONECT    6    4    4\nCONECT    7    3   15\nCONECT    8    2   16\nCONECT    9    1\nCONECT   10    1   11   12   13\nCONECT   11   10\nCONECT   12   10   17\nCONECT   13   10   14   18   19\nCONECT   14   13   20\nCONECT   15    7\nCONECT   16    8\nCONECT   17   12\nCONECT   18   13\nCONECT   19   13\nCONECT   20   14\nMASTER        0    0    0    0    0    0    0    0   20    0   20    0\nEND\n",
    "HEADER    VX: a chemical warfare agent, cholinesterase inhibitor\nCOMPND    VX\nAUTHOR    Created by Dave Woodcock at Okanagan University College\nAUTHOR    email:woodcock@okanagan.bc.ca\nAUTHOR    Date revised: Fri Sep  1 09:41:05 2000  GENERATED BY BABEL 1.6 \nHETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \nHETATM    2  C           1       1.541   0.000   0.000  1.00  0.00 \nHETATM    3  O           1       2.000   1.333   0.000  1.00  0.00 \nHETATM    4  P           1       3.580   1.768  -0.723  1.00  0.00 \nHETATM    5  O           1       3.908   3.507  -0.453  1.00  0.00 \nHETATM    6  C           1       3.536   1.434  -2.522  1.00  0.00 \nHETATM    7  S           1       5.089   0.633   0.149  1.00  0.00 \nHETATM    8  C           1       6.652   1.113  -0.581  1.00  0.00 \nHETATM    9  C           1       7.173   2.394   0.105  1.00  0.00 \nHETATM   10  N           1       8.475   2.827  -0.436  1.00  0.00 \nHETATM   11  C           1       9.247   3.677   0.492  1.00  0.00 \nHETATM   12  C           1       9.948   2.776   1.531  1.00  0.00 \nHETATM   13  C           1       8.388   4.729   1.230  1.00  0.00 \nHETATM   14  C           1       8.465   3.210  -1.863  1.00  0.00 \nHETATM   15  C           1       9.881   3.493  -2.414  1.00  0.00 \nHETATM   16  C           1       7.562   4.422  -2.181  1.00  0.00 \nHETATM   17  H           1      -0.362   0.520   0.887  1.00  0.00 \nHETATM   18  H           1      -0.367  -1.026   0.006  1.00  0.00 \nHETATM   19  H           1      -0.363   0.510  -0.892  1.00  0.00 \nHETATM   20  H           1       1.902  -0.524  -0.885  1.00  0.00 \nHETATM   21  H           1       1.904  -0.507   0.894  1.00  0.00 \nHETATM   22  H           1       2.728   2.007  -2.976  1.00  0.00 \nHETATM   23  H           1       3.367   0.370  -2.691  1.00  0.00 \nHETATM   24  H           1       4.485   1.727  -2.970  1.00  0.00 \nHETATM   25  H           1       6.489   1.278  -1.644  1.00  0.00 \nHETATM   26  H           1       7.377   0.311  -0.444  1.00  0.00 \nHETATM   27  H           1       7.282   2.161   1.162  1.00  0.00 \nHETATM   28  H           1       6.438   3.191   0.006  1.00  0.00 \nHETATM   29  H           1      10.030   4.205  -0.044  1.00  0.00 \nHETATM   30  H           1      10.539   2.021   1.012  1.00  0.00 \nHETATM   31  H           1       9.216   2.282   2.169  1.00  0.00 \nHETATM   32  H           1      10.608   3.383   2.151  1.00  0.00 \nHETATM   33  H           1       9.041   5.368   1.825  1.00  0.00 \nHETATM   34  H           1       7.675   4.243   1.895  1.00  0.00 \nHETATM   35  H           1       7.847   5.345   0.515  1.00  0.00 \nHETATM   36  H           1       8.094   2.362  -2.434  1.00  0.00 \nHETATM   37  H           1      10.574   2.735  -2.048  1.00  0.00 \nHETATM   38  H           1      10.223   4.483  -2.116  1.00  0.00 \nHETATM   39  H           1       9.853   3.454  -3.503  1.00  0.00 \nHETATM   40  H           1       7.928   5.308  -1.665  1.00  0.00 \nHETATM   41  H           1       6.533   4.222  -1.886  1.00  0.00 \nHETATM   42  H           1       7.584   4.609  -3.255  1.00  0.00 \nCONECT    1    2   17   18   19\nCONECT    2    1    3   20   21\nCONECT    3    2    4\nCONECT    4    3    5    6    7\nCONECT    4    5\nCONECT    5    4\nCONECT    6    4   22   23   24\nCONECT    7    4    8\nCONECT    8    7    9   25   26\nCONECT    9    8   10   27   28\nCONECT   10    9   11   14\nCONECT   11   10   12   13   29\nCONECT   12   11   30   31   32\nCONECT   13   11   33   34   35\nCONECT   14   10   15   16   36\nCONECT   15   14   37   38   39\nCONECT   16   14   40   41   42\nCONECT   17    1\nCONECT   18    1\nCONECT   19    1\nCONECT   20    2\nCONECT   21    2\nCONECT   22    6\nCONECT   23    6\nCONECT   24    6\nCONECT   25    8\nCONECT   26    8\nCONECT   27    9\nCONECT   28    9\nCONECT   29   11\nCONECT   30   12\nCONECT   31   12\nCONECT   32   12\nCONECT   33   13\nCONECT   34   13\nCONECT   35   13\nCONECT   36   14\nCONECT   37   15\nCONECT   38   15\nCONECT   39   15\nCONECT   40   16\nCONECT   41   16\nCONECT   42   16\nMASTER        0    0    0    0    0    0    0    0   42    0   42    0\nEND\n" };
// cond_initializer
// file thread_util.c line 285
const union anonymous_7 cond_initializer = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// default_defaults
// file screenhack.c line 163
static char *default_defaults[10l] = { ".root:\t\tfalse", "*geometry:\t\t1280x720", "*mono:\t\tfalse", "*installColormap:\tfalse", "*doFPS:\t\tfalse", "*multiSample:\tfalse", "*visualID:\t\tdefault", "*windowID:\t\t", "*desktopGrabber:\txscreensaver-getimage %s",
    ((char *)NULL) };
// default_options
// file screenhack.c line 141
static struct anonymous_18 default_options[11l] = { { .option="-root", .specifier=".root", .argKind=(enum anonymous_19)XrmoptionNoArg, .value="True" },
    { .option="-window", .specifier=".root", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="False" },
    { .option="-mono", .specifier=".mono", .argKind=(enum anonymous_19)XrmoptionNoArg, .value="True" },
    { .option="-install", .specifier=".installColormap", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="True" },
    { .option="-noinstall", .specifier=".installColormap", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="False" },
    { .option="-visual", .specifier=".visualID", .argKind=(enum anonymous_19)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-window-id", .specifier=".windowID", .argKind=(enum anonymous_19)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-fps", .specifier=".doFPS", .argKind=(enum anonymous_19)XrmoptionNoArg, .value="True" },
    { .option="-no-fps", .specifier=".doFPS", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="False" },
    { .option="-pair", .specifier=".pair", .argKind=(enum anonymous_19)XrmoptionNoArg, .value="True" },
    { .option=((char *)NULL), .specifier=((char *)NULL), .argKind=(enum anonymous_19)0,
    .value=((char *)NULL) } };
// do_atoms
// file molecule.c line 189
static signed int do_atoms;
// do_bbox
// file molecule.c line 192
static signed int do_bbox;
// do_bonds
// file molecule.c line 190
static signed int do_bonds;
// do_labels
// file molecule.c line 188
static signed int do_labels;
// do_shells
// file molecule.c line 191
static signed int do_shells;
// do_spin
// file molecule.c line 185
static char *do_spin;
// do_titles
// file molecule.c line 187
static signed int do_titles;
// do_wander
// file molecule.c line 186
static signed int do_wander;
// got_error
// file xlock-gl-utils.c line 33
static signed int got_error = 0;
// i1
// file yarandom.c line 87
static signed int i1;
// i2
// file yarandom.c line 87
static signed int i2;
// mcs
// file molecule.c line 181
static struct anonymous_31 *mcs = (struct anonymous_31 *)(void *)0;
// merged_defaults
// file screenhack.c line 178
static char **merged_defaults;
// merged_options
// file screenhack.c line 176
static struct anonymous_18 *merged_options;
// merged_options_size
// file screenhack.c line 177
static signed int merged_options_size;
// molecule_opts
// file molecule.c line 239
static struct anonymous_44 molecule_opts;
// opts
// file molecule.c line 201
static struct anonymous_18 opts[20l] = { { .option="-molecule", .specifier=".molecule", .argKind=(enum anonymous_19)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-timeout", .specifier=".timeout", .argKind=(enum anonymous_19)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-spin", .specifier=".spin", .argKind=(enum anonymous_19)XrmoptionSepArg, .value=((char *)NULL) },
    { .option="+spin", .specifier=".spin", .argKind=(enum anonymous_19)XrmoptionNoArg, .value="" },
    { .option="-wander", .specifier=".wander", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="True" },
    { .option="+wander", .specifier=".wander", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="False" },
    { .option="-labels", .specifier=".labels", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="True" },
    { .option="+labels", .specifier=".labels", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="False" },
    { .option="-titles", .specifier=".titles", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="True" },
    { .option="+titles", .specifier=".titles", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="False" },
    { .option="-atoms", .specifier=".atoms", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="True" },
    { .option="+atoms", .specifier=".atoms", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="False" },
    { .option="-bonds", .specifier=".bonds", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="True" },
    { .option="+bonds", .specifier=".bonds", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="False" },
    { .option="-shells", .specifier=".eshells", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="True" },
    { .option="+shells", .specifier=".eshells", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="False" },
    { .option="-shell-alpha", .specifier=".shellAlpha", .argKind=(enum anonymous_19)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-bbox", .specifier=".bbox", .argKind=(enum anonymous_19)XrmoptionNoArg, .value="True" },
    { .option="+bbox", .specifier=".bbox", .argKind=(enum anonymous_19)XrmoptionNoArg, .value="False" },
    { .option="-verbose", .specifier=".verbose", .argKind=(enum anonymous_19)XrmoptionNoArg,
    .value="True" } };
// vars
// file molecule.c line 224
static struct anonymous vars[12l];
// molecule_str
// file molecule.c line 184
static char *molecule_str;
// shell_alpha
// file molecule.c line 194
static float shell_alpha;
// timeout
// file molecule.c line 183
static signed int timeout;
// verbose_p
// file molecule.c line 193
static signed int verbose_p;
// vars
// file molecule.c line 224
static struct anonymous vars[12l] = { { .var=(void *)&molecule_str, .name="molecule", .classname="Molecule",
    .def="(default)", .type=(enum anonymous_20)t_String },
    { .var=(void *)&timeout, .name="timeout", .classname="Seconds",
    .def="20", .type=(enum anonymous_20)t_Int },
    { .var=(void *)&do_spin, .name="spin", .classname="Spin", .def="XYZ",
    .type=(enum anonymous_20)t_String },
    { .var=(void *)&do_wander, .name="wander", .classname="Wander",
    .def="False", .type=(enum anonymous_20)t_Bool },
    { .var=(void *)&do_atoms, .name="atoms", .classname="Atoms",
    .def="True", .type=(enum anonymous_20)t_Bool },
    { .var=(void *)&do_bonds, .name="bonds", .classname="Bonds",
    .def="True", .type=(enum anonymous_20)t_Bool },
    { .var=(void *)&do_shells, .name="eshells", .classname="EShells",
    .def="True", .type=(enum anonymous_20)t_Bool },
    { .var=(void *)&do_labels, .name="labels", .classname="Labels",
    .def="True", .type=(enum anonymous_20)t_Bool },
    { .var=(void *)&do_titles, .name="titles", .classname="Titles",
    .def="True", .type=(enum anonymous_20)t_Bool },
    { .var=(void *)&do_bbox, .name="bbox", .classname="BBox", .def="False",
    .type=(enum anonymous_20)t_Bool },
    { .var=(void *)&shell_alpha, .name="shellAlpha", .classname="ShellAlpha",
    .def="0.3", .type=(enum anonymous_20)t_Float },
    { .var=(void *)&verbose_p, .name="verbose", .classname="Verbose",
    .def="False", .type=(enum anonymous_20)t_Bool } };
// molecule_opts
// file molecule.c line 239
static struct anonymous_44 molecule_opts = { .numopts=(signed int)(sizeof(struct anonymous_18 [20l]) /*640ul*/  / sizeof(struct anonymous_18) /*32ul*/ ), .opts=opts,
    .numvarsdesc=(signed int)(sizeof(struct anonymous [12l]) /*480ul*/  / sizeof(struct anonymous) /*40ul*/ ), .vars=vars,
    .desc=(struct anonymous_0 *)(void *)0 };
// molecule_xlockmore_function_table
// file molecule.c line 1666
static struct xlockmore_function_table molecule_xlockmore_function_table;
// molecule_xlockmore_function_table
// file molecule.c line 1666
static struct xlockmore_function_table molecule_xlockmore_function_table = { .progclass="Molecule", .defaults="*delay:\t10000         \n*showFPS:      False         \n*wireframe:    False         \n*atomFont:   -*-helvetica-medium-r-normal-*-*-240-*-*-*-*-*-*\n*titleFont:  -*-helvetica-medium-r-normal-*-*-180-*-*-*-*-*-*\n*noLabelThreshold:    150    \n*wireframeThreshold:  150    \n", .want_writable_colors=0,
    .desired_color_scheme=(enum anonymous_43)color_scheme_default, .hack_init=init_molecule,
    .hack_draw=draw_molecule, .hack_reshape=reshape_molecule,
    .hack_refresh=((void (*)(struct ModeInfo *))NULL), .hack_free=((void (*)(struct ModeInfo *))NULL),
    .hack_handle_events=molecule_handle_event,
    .opts=&molecule_opts,
    .screen_count=(unsigned int)0 };
// molecule_xscreensaver_function_table
// file molecule.c line 1666
struct xscreensaver_function_table molecule_xscreensaver_function_table;
// molecule_xscreensaver_function_table
// file molecule.c line 1666
struct xscreensaver_function_table molecule_xscreensaver_function_table = { .progclass=((const char *)NULL), .defaults=((const char * const *)NULL), .options=((const struct anonymous_18 *)NULL),
    .setup_cb=xlockmore_setup,
    .setup_arg=(void *)&molecule_xlockmore_function_table, .init_cb=((void * (*)(struct _XDisplay *, unsigned long int))NULL),
    .draw_cb=((unsigned long int (*)(struct _XDisplay *, unsigned long int, void *))NULL),
    .reshape_cb=((void (*)(struct _XDisplay *, unsigned long int, void *, unsigned int, unsigned int))NULL),
    .event_cb=((signed int (*)(struct _XDisplay *, unsigned long int, void *, union _XEvent *))NULL),
    .free_cb=((void (*)(struct _XDisplay *, unsigned long int, void *))NULL),
    .fps_cb=xlockmore_gl_compute_fps,
    .pick_visual_hook=xlockmore_pick_gl_visual, .validate_visual_hook=xlockmore_validate_gl_visual };
// mono_p
// file screenhack.c line 138
signed int mono_p;
// mutex_initializer
// file thread_util.c line 277
const union anonymous_5 mutex_initializer = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// orig_do_atoms
// file molecule.c line 197
static signed int orig_do_atoms;
// orig_do_bonds
// file molecule.c line 197
static signed int orig_do_bonds;
// orig_do_labels
// file molecule.c line 197
static signed int orig_do_labels;
// orig_do_shells
// file molecule.c line 197
static signed int orig_do_shells;
// orig_ehandler
// file xlock-gl-utils.c line 32
static signed int (*orig_ehandler)(struct _XDisplay *, struct anonymous_32 *) = ((signed int (*)(struct _XDisplay *, struct anonymous_32 *))NULL);
// orig_wire
// file molecule.c line 198
static signed int orig_wire;
// progclass
// file screenhack.c line 137
const char *progclass;
// progname
// file screenhack.c line 136
const char *progname;
// screensaver_id
// file ./../utils/version.h line 1
static const char screensaver_id[69l] = { '@', '(', '#', ')', 'x', 's', 'c', 'r', 'e', 'e', 'n', 's', 'a', 'v', 'e', 'r', ' ', '5', '.', '3', '4', ' ', '(', '2', '4', '-', 'O', 'c', 't', '-', '2', '0', '1', '5', ')', ',', ' ', 'b', 'y', ' ', 'J', 'a', 'm', 'i', 'e', ' ', 'Z', 'a', 'w', 'i', 'n', 's', 'k', 'i', ' ', '(', 'j', 'w', 'z', '@', 'j', 'w', 'z', '.', 'o', 'r', 'g', ')', 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// topLevelShellWidgetClass
// file /usr/include/X11/Shell.h line 556
extern struct _WidgetClassRec *topLevelShellWidgetClass;
// xscreensaver_function_table
// file molecule.c line 1666
struct xscreensaver_function_table *xscreensaver_function_table;
// xscreensaver_function_table
// file molecule.c line 1666
struct xscreensaver_function_table *xscreensaver_function_table = &molecule_xscreensaver_function_table;

// BadValue_ehandler
// file xlock-gl-utils.c line 36
static signed int BadValue_ehandler(struct _XDisplay *dpy, struct anonymous_32 *error)
{
  signed int return_value;
  if((signed int)error->error_code == 2)
  {
    got_error = 1;
    return 0;
  }

  else
  {
    return_value=orig_ehandler(dpy, error);
    return return_value;
  }
}

// MapNotify_event_p
// file screenhack.c line 256
static signed int MapNotify_event_p(struct _XDisplay *dpy, union _XEvent *event, char *window)
{
  _Bool tmp_if_expr_1;
  if(event->xany.type == 19)
    tmp_if_expr_1 = event->xvisibility.window == (unsigned long int)window ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// VirtualRootWindowOfScreen
// file ./../utils/vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen(struct anonymous_15 *screen)
{
  signed int return_value___isoc99_sscanf_2;
  static unsigned long int root = (unsigned long int)0;
  static struct anonymous_15 *save_screen = (struct anonymous_15 *)0;
  if(!(screen == save_screen))
  {
    struct _XDisplay *dpy = screen->display;
    unsigned long int __SWM_VROOT = (unsigned long int)0L;
    signed int i;
    unsigned long int rootReturn;
    unsigned long int parentReturn;
    unsigned long int *children;
    unsigned int numChildren;
    const char *xss_id;
    xss_id=getenv("XSCREENSAVER_WINDOW");
    if(!(xss_id == ((const char *)NULL)))
    {
      if(!(*xss_id == 0))
      {
        unsigned long int id = (unsigned long int)0;
        char c;
        signed int return_value___isoc99_sscanf_1;
        return_value___isoc99_sscanf_1=__isoc99_sscanf(xss_id, " 0x%lx %c", &id, &c);
        _Bool tmp_if_expr_3;
        if(return_value___isoc99_sscanf_1 == 1)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value___isoc99_sscanf_2=__isoc99_sscanf(xss_id, " %lu %c", &id, &c);
          tmp_if_expr_3 = 1 == return_value___isoc99_sscanf_2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          root = (unsigned long int)id;
          save_screen = screen;
          return root;
        }

      }

    }

    root = screen->root;
    __SWM_VROOT=XInternAtom(dpy, "__SWM_VROOT", 0);
    signed int return_value_XQueryTree_5;
    return_value_XQueryTree_5=XQueryTree(dpy, root, &rootReturn, &parentReturn, &children, &numChildren);
    if(!(return_value_XQueryTree_5 == 0))
    {
      i = 0;
      for( ; !((unsigned int)i >= numChildren); i = i + 1)
      {
        unsigned long int actual_type;
        signed int actual_format;
        unsigned long int nitems;
        unsigned long int bytesafter;
        unsigned char *newRoot = ((unsigned char *)NULL);
        signed int return_value_XGetWindowProperty_4;
        return_value_XGetWindowProperty_4=XGetWindowProperty(dpy, children[(signed long int)i], __SWM_VROOT, (signed long int)0, (signed long int)1, 0, (unsigned long int)33, &actual_type, &actual_format, &nitems, &bytesafter, &newRoot);
        if(return_value_XGetWindowProperty_4 == 0)
        {
          if(!(newRoot == ((unsigned char *)NULL)))
          {
            root = *((unsigned long int *)newRoot);
            break;
          }

        }

      }
      if(!(children == ((unsigned long int *)NULL)))
        XFree((void *)(char *)children);

    }

    save_screen = screen;
  }

  return root;
}

// XChar2b_to_utf8
// file utf8wc.c line 306
extern char * XChar2b_to_utf8(const struct anonymous_13 *in, signed int *length_ret)
{
  signed int in_len = 0;
  const struct anonymous_13 *in_end;
  signed int out_len;
  char *utf8;
  char *out;
  const char *out_end;
  in_end = in;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(in_end->byte1 == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = in_end->byte2 != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    in_end = in_end + 1l;
    in_len = in_len + 1;
  }
  while((_Bool)1);
  out_len = (in_len + 1) * 3;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(out_len + 1));
  out = (char *)return_value_malloc_2;
  utf8 = out;
  if(out == ((char *)NULL))
    return ((char *)NULL);

  else
  {
    out_end = out + (signed long int)out_len;
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)((signed int)in->byte1 << 8 | (signed int)in->byte2);
      signed int wrote;
      wrote=utf8_encode(uc, out, out_end - out);
      if(wrote >= 4)
        abort();

      out = out + (signed long int)wrote;
      in = in + 1l;
    }
    *out = (char)0;
    out_len = (signed int)((out - utf8) + (signed long int)1);
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)utf8, (unsigned long int)out_len);
    utf8 = (char *)return_value_realloc_3;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = out_len;

    return utf8;
  }
}

// _add_next_thread
// file thread_util.c line 551
static void _add_next_thread(struct _parallel_startup_type *self)
{
  /* assertion !self->last_errno */
  assert(!(self->last_errno != 0));
  unsigned int return_value__threadpool_count_parallel_2;
  return_value__threadpool_count_parallel_2=_threadpool_count_parallel(self->parent);
  if(self->parent->parallel_unfinished == return_value__threadpool_count_parallel_2)
  {
    signed int return_value_pthread_cond_broadcast_1;
    return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->parent->cond);
    /* assertion !(pthread_cond_broadcast(&self->parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_1 != 0));
  }

  else
  {
    unsigned long int *thread = self->parent->parallel_threads + (signed long int)self->parent->parallel_unfinished;
    self->last_errno=pthread_create(thread, (const union pthread_attr_t *)(void *)0, _start_routine, (void *)self);
    if(!(self->last_errno == 0))
      _parallel_abort(self->parent);

  }
}

// _async_addr_from_name_free
// file async_netdb.c line 283
static void _async_addr_from_name_free(struct async_addr_from_name *self)
{
  if(!(self->res == ((struct addrinfo *)NULL)))
    freeaddrinfo(self->res);

  aligned_free((void *)self);
}

// _async_addr_from_name_hostname
// file async_netdb.c line 277
static char * _async_addr_from_name_hostname(struct async_addr_from_name *self)
{
  return (char *)(self + (signed long int)1);
}

// _async_addr_from_name_thread
// file async_netdb.c line 295
static void * _async_addr_from_name_thread(void *self_raw)
{
  struct async_addr_from_name *self = (struct async_addr_from_name *)self_raw;
  char *return_value__async_addr_from_name_hostname_1;
  return_value__async_addr_from_name_hostname_1=_async_addr_from_name_hostname(self);
  self->gai_error=getaddrinfo(return_value__async_addr_from_name_hostname_1, (const char *)(void *)0, (struct addrinfo *)(void *)0, &self->res);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  self->errno_error = *return_value___errno_location_2;
  signed int return_value_io_thread_return_3;
  return_value_io_thread_return_3=io_thread_return(&self->io);
  if(!(return_value_io_thread_return_3 == 0))
    _async_addr_from_name_free(self);

  return (void *)0;
}

// _async_name_from_addr_set_param
// file async_netdb.c line 128
static void _async_name_from_addr_set_param(struct _async_name_from_addr_param *self, struct sockaddr *addr, unsigned int addrlen)
{
  self->addrlen = addrlen;
  memcpy((void *)&self->addr, (const void *)addr, (unsigned long int)addrlen);
}

// _async_name_from_addr_thread
// file async_netdb.c line 102
static void * _async_name_from_addr_thread(void *self_raw)
{
  struct async_name_from_addr *self = (struct async_name_from_addr *)self_raw;
  self->gai_error=getnameinfo((struct sockaddr *)(void *)&self->param.addr, self->param.addrlen, self->host, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , (char *)(void *)0, (unsigned int)0, 8);
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  self->errno_error = *return_value___errno_location_1;
  signed int return_value_io_thread_return_2;
  return_value_io_thread_return_2=io_thread_return(&self->io);
  if(!(return_value_io_thread_return_2 == 0))
    aligned_free((void *)self);

  return (void *)0;
}

// _async_netdb_is_done
// file async_netdb.c line 39
signed int _async_netdb_is_done(struct io_thread *io)
{
  signed int return_value_io_thread_is_done_1;
  if(_has_threads >= 0)
  {
    return_value_io_thread_is_done_1=io_thread_is_done(io);
    return return_value_io_thread_is_done_1;
  }

  return 1;
}

// _get_cache_line_size
// file thread_util.c line 184
static unsigned int _get_cache_line_size(void)
{
  const signed int *name;
  signed long int result = (signed long int)0;
  static const signed int names[4l] = { 190, 193, 196, 199 };
  name = names;
  for( ; !(name == names + 4l); name = name + 1l)
  {
    signed long int sysconf_result;
    sysconf_result=sysconf(*name);
    if(!(result >= sysconf_result))
      result = sysconf_result;

  }
  if(!(result == 0l))
    return (unsigned int)result;

  else
    return (unsigned int)(1 << 7);
}

// _hardware_concurrency
// file thread_util.c line 462
static unsigned int _hardware_concurrency(void)
{
  signed long int count;
  count=sysconf(84);
  return (unsigned int)(count > (signed long int)0 ? count : (signed long int)1);
}

// _parallel_abort
// file thread_util.c line 527
static void _parallel_abort(struct threadpool *self)
{
  /* assertion self->count > 1 */
  assert(self->count > (unsigned int)1);
  self->count = self->parallel_unfinished + (unsigned int)1;
  signed int return_value_pthread_cond_broadcast_1;
  return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->cond);
  /* assertion !(pthread_cond_broadcast(&self->cond)) */
  assert(!(return_value_pthread_cond_broadcast_1 != 0));
}

// _serial_destroy
// file thread_util.c line 511
static void _serial_destroy(struct threadpool *self)
{
  void *thread = self->serial_threads;
  unsigned int i;
  unsigned int count;
  count=_threadpool_count_serial(self);
  i = (unsigned int)0;
  if(!(i == count))
  {
    self->thread_destroy(thread);
    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

  free(self->serial_threads);
}

// _start_routine
// file thread_util.c line 585
static void * _start_routine(void *startup_raw)
{
  struct _parallel_startup_type *startup = (struct _parallel_startup_type *)startup_raw;
  struct threadpool *parent = startup->parent;
  void *thread;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&parent->mutex);
  /* assertion !(pthread_mutex_lock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_lock_1 != 0));
  parent->parallel_unfinished = parent->parallel_unfinished + 1u;
  unsigned int return_value_thread_memory_alignment_2;
  return_value_thread_memory_alignment_2=thread_memory_alignment((struct _XDisplay *)(void *)0);
  startup->last_errno=aligned_malloc(&thread, return_value_thread_memory_alignment_2, parent->thread_size);
  if(!(startup->last_errno == 0))
  {
    _parallel_abort(parent);
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&parent->mutex);
    /* assertion !(pthread_mutex_unlock(&parent->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
    return (void *)0;
  }

  startup->last_errno=startup->thread_create(thread, parent, parent->parallel_unfinished);
  if(!(startup->last_errno == 0))
  {
    _parallel_abort(parent);
    void *return_value__thread_free_and_unlock_4;
    return_value__thread_free_and_unlock_4=_thread_free_and_unlock(parent, thread);
    return return_value__thread_free_and_unlock_4;
  }

  /* assertion !startup->last_errno */
  assert(!(startup->last_errno != 0));
  _add_next_thread(startup);
  void *return_value__thread_destroy_and_unlock_5;
  if(!(startup->last_errno == 0))
  {
    return_value__thread_destroy_and_unlock_5=_thread_destroy_and_unlock(parent, thread);
    return return_value__thread_destroy_and_unlock_5;
  }

  void *return_value__thread_destroy_and_unlock_6;
  if(parent->parallel_pending == 0u)
  {
    if(parent->parallel_threads == ((unsigned long int *)NULL))
    {
      return_value__thread_destroy_and_unlock_6=_thread_destroy_and_unlock(parent, thread);
      return return_value__thread_destroy_and_unlock_6;
    }

    signed int return_value_pthread_cond_wait_7;
    return_value_pthread_cond_wait_7=pthread_cond_wait(&parent->cond, &parent->mutex);
    /* assertion !(pthread_cond_wait(&parent->cond, &parent->mutex)) */
    assert(!(return_value_pthread_cond_wait_7 != 0));
  }

  parent->parallel_pending = parent->parallel_pending - 1u;
  signed int return_value_pthread_cond_broadcast_8;
  if(parent->parallel_pending == 0u)
  {
    return_value_pthread_cond_broadcast_8=pthread_cond_broadcast(&parent->cond);
    /* assertion !(pthread_cond_broadcast(&parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_8 != 0));
  }

  signed int return_value_pthread_mutex_unlock_9;
  return_value_pthread_mutex_unlock_9=pthread_mutex_unlock(&parent->mutex);
  /* assertion !(pthread_mutex_unlock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_9 != 0));
  parent->thread_run(thread);
  signed int return_value_pthread_mutex_lock_10;
  return_value_pthread_mutex_lock_10=pthread_mutex_lock(&parent->mutex);
  /* assertion !(pthread_mutex_lock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_lock_10 != 0));
  signed int return_value_pthread_cond_wait_11;
  if(!(parent->parallel_pending == 0u))
  {
    return_value_pthread_cond_wait_11=pthread_cond_wait(&parent->cond, &parent->mutex);
    /* assertion !(pthread_cond_wait(&parent->cond, &parent->mutex)) */
    assert(!(return_value_pthread_cond_wait_11 != 0));
  }

  parent->parallel_unfinished = parent->parallel_unfinished - 1u;
  signed int return_value_pthread_cond_broadcast_12;
  if(parent->parallel_unfinished == 0u)
  {
    return_value_pthread_cond_broadcast_12=pthread_cond_broadcast(&parent->cond);
    /* assertion !(pthread_cond_broadcast(&parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_12 != 0));
  }

}

// _thread_destroy_and_unlock
// file thread_util.c line 577
static void * _thread_destroy_and_unlock(struct threadpool *self, void *thread)
{
  self->thread_destroy(thread);
  void *return_value__thread_free_and_unlock_1;
  return_value__thread_free_and_unlock_1=_thread_free_and_unlock(self, thread);
  return return_value__thread_free_and_unlock_1;
}

// _thread_free_and_unlock
// file thread_util.c line 568
static void * _thread_free_and_unlock(struct threadpool *self, void *thread)
{
  signed int return_value_pthread_mutex_unlock_1;
  return_value_pthread_mutex_unlock_1=pthread_mutex_unlock(&self->mutex);
  /* assertion !(pthread_mutex_unlock(&self->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_1 != 0));
  aligned_free(thread);
  return (void *)0;
}

// _threadpool_count_parallel
// file thread_util.c line 541
static unsigned int _threadpool_count_parallel(struct threadpool *self)
{
  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  /* assertion self->count >= 1 */
  assert(self->count >= (unsigned int)1);
  return self->count - (unsigned int)1;
}

// _threadpool_count_serial
// file thread_util.c line 501
static unsigned int _threadpool_count_serial(struct threadpool *self)
{
  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  if(_has_pthread >= 0)
    return (unsigned int)(self->count != 0u ? 1 : 0);

  else
    return self->count;
}

// _translate_h_errno
// file async_netdb.c line 82
static signed int _translate_h_errno(signed int error)
{
  switch(error)
  {
    case 1:

    case 4:
      return -2;
    case 2:
      return -3;
    default:
      return -4;
  }
}

// _unlock_and_destroy
// file thread_util.c line 685
static void _unlock_and_destroy(struct threadpool *self)
{
  unsigned long int *threads = self->parallel_threads;
  self->parallel_threads = (unsigned long int *)(void *)0;
  signed int return_value_pthread_cond_broadcast_1;
  if(!(threads == ((unsigned long int *)NULL)))
  {
    return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->cond);
    /* assertion !(pthread_cond_broadcast(&self->cond)) */
    assert(!(return_value_pthread_cond_broadcast_1 != 0));
  }

  signed int return_value_pthread_mutex_unlock_2;
  return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&self->mutex);
  /* assertion !(pthread_mutex_unlock(&self->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_2 != 0));
  signed int return_value_pthread_join_3;
  if(!(threads == ((unsigned long int *)NULL)))
  {
    unsigned int i;
    unsigned int count;
    count=_threadpool_count_parallel(self);
    i = (unsigned int)0;
    for( ; !(i == count); i = i + 1u)
    {
      return_value_pthread_join_3=pthread_join(threads[(signed long int)i], (void **)(void *)0);
      /* assertion !(pthread_join(threads[i], ((void *)0))) */
      assert(!(return_value_pthread_join_3 != 0));
    }
    free((void *)threads);
    signed int return_value_pthread_cond_destroy_4;
    return_value_pthread_cond_destroy_4=pthread_cond_destroy(&self->cond);
    /* assertion !(pthread_cond_destroy(&self->cond)) */
    assert(!(return_value_pthread_cond_destroy_4 != 0));
    signed int return_value_pthread_mutex_destroy_5;
    return_value_pthread_mutex_destroy_5=pthread_mutex_destroy(&self->mutex);
    /* assertion !(pthread_mutex_destroy(&self->mutex)) */
    assert(!(return_value_pthread_mutex_destroy_5 != 0));
  }

  _serial_destroy(self);
}

// add_quats
// file trackball.c line 254
void add_quats(float *q1, float *q2, float *dest)
{
  float t1[4l];
  float t2[4l];
  float t3[4l];
  float tf[4l];
  vcopy(q1, t1);
  vscale(t1, q2[(signed long int)3]);
  vcopy(q2, t2);
  vscale(t2, q1[(signed long int)3]);
  vcross(q2, q1, t3);
  vadd(t1, t2, tf);
  vadd(t3, tf, tf);
  float return_value_vdot_1;
  return_value_vdot_1=vdot(q1, q2);
  tf[(signed long int)3] = q1[(signed long int)3] * q2[(signed long int)3] - return_value_vdot_1;
  dest[(signed long int)0] = tf[(signed long int)0];
  dest[(signed long int)1] = tf[(signed long int)1];
  dest[(signed long int)2] = tf[(signed long int)2];
  dest[(signed long int)3] = tf[(signed long int)3];
  static signed int count = 0;
  count = count + 1;
  if(count >= 98)
  {
    count = 0;
    normalize_quat(dest);
  }

}

// adjust_for_device_rotation
// file gltrackball.c line 92
static void adjust_for_device_rotation(struct trackball_state *ts, double *x, double *y, double *w, double *h)
{
  signed int rot = (signed int)0;
  signed int swap;
  if(ts->ignore_device_rotation_p == 0)
  {
    for( ; !(rot >= -179); rot = rot + 360)
      ;
    for( ; rot >= 181; rot = rot - 360)
      ;
    if(rot >= 136 || !(rot >= -135))
    {
      *x = *w - *x;
      *y = *h - *y;
    }

    else
      if(rot >= 46)
      {
        swap = (signed int)*x;
        *x = *y;
        *y = (double)swap;
        swap = (signed int)*w;
        *w = *h;
        *h = (double)swap;
        *x = *w - *x;
      }

      else
        if(!(rot >= -45))
        {
          swap = (signed int)*x;
          *x = *y;
          *y = (double)swap;
          swap = (signed int)*w;
          *w = *h;
          *h = (double)swap;
          *y = *h - *y;
        }

  }

}

// aligned_free
// file aligned_malloc.h line 35
void aligned_free(void *ptr)
{
  free(((void **)ptr)[(signed long int)-1]);
}

// aligned_malloc
// file aligned_malloc.h line 34
signed int aligned_malloc(void **ptr, unsigned int alignment, unsigned long int size)
{
  void *block_start;
  signed long int align1 = (signed long int)(alignment - (unsigned int)1);
  /* assertion alignment && !(alignment & (alignment - 1)) */
  assert(alignment != 0u && !((alignment & alignment - (unsigned int)1) != 0u));
  size = size + sizeof(void *) /*8ul*/  + (unsigned long int)align1;
  block_start=malloc(size);
  if(block_start == NULL)
    return 12;

  else
  {
    *ptr = (void *)((unsigned long int)(signed long int)block_start + sizeof(void *) /*8ul*/  + (unsigned long int)align1 & (unsigned long int)~align1);
    ((void **)*ptr)[(signed long int)-1] = block_start;
    return 0;
  }
}

// allocate_writable_colors
// file colors.c line 42
extern void allocate_writable_colors(struct anonymous_15 *screen, unsigned long int cmap, unsigned long int *pixels, signed int *ncolorsP)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_15 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int desired = *ncolorsP;
  signed int got = 0;
  signed int requested = desired;
  unsigned long int *new_pixels = pixels;
  *ncolorsP = 0;
  while(requested >= 1 && !(got >= desired))
  {
    if(!(desired + -got >= requested))
      requested = desired - got;

    signed int return_value_XAllocColorCells_2;
    return_value_XAllocColorCells_2=XAllocColorCells(dpy, cmap, 0, ((unsigned long int *)NULL), (unsigned int)0, new_pixels, (unsigned int)requested);
    if(!(return_value_XAllocColorCells_2 == 0))
    {
      new_pixels = new_pixels + (signed long int)requested;
      got = got + requested;
    }

    else
      requested = requested / 2;
  }
  *ncolorsP = *ncolorsP + got;
}

// async_addr_from_name_cancel
// file async_netdb.c line 344
void async_addr_from_name_cancel(struct async_addr_from_name *self)
{
  if(_has_threads >= 0)
  {
    signed int return_value_io_thread_cancel_1;
    return_value_io_thread_cancel_1=io_thread_cancel(&self->io);
    if(!(return_value_io_thread_cancel_1 == 0))
      _async_addr_from_name_free(self);

  }

  else
    aligned_free((void *)self);
}

// async_addr_from_name_finish
// file async_netdb.c line 361
signed int async_addr_from_name_finish(struct async_addr_from_name *self, void *addr, unsigned int *addrlen, signed int *errno_error)
{
  if(_has_threads >= 0)
  {
    signed int gai_error;
    io_thread_finish(&self->io);
    gai_error = self->gai_error;
    if(!(errno_error == ((signed int *)NULL)))
      *errno_error = self->errno_error;

    if(gai_error == 0)
    {
      struct addrinfo *ai = self->res;
      if(ai == ((struct addrinfo *)NULL))
        gai_error = -2;

      else
      {
        /* assertion ai->ai_addrlen <= sizeof (async_netdb_sockaddr_storage_t) */
        assert((unsigned long int)ai->ai_addrlen <= sizeof(struct sockaddr_storage) /*128ul*/ );
        memcpy(addr, (const void *)ai->ai_addr, (unsigned long int)ai->ai_addrlen);
        *addrlen = ai->ai_addrlen;
      }
    }

    _async_addr_from_name_free(self);
    return gai_error;
  }

  struct hostent *he;
  char *return_value__async_addr_from_name_hostname_1;
  return_value__async_addr_from_name_hostname_1=_async_addr_from_name_hostname(self);
  he=gethostbyname(return_value__async_addr_from_name_hostname_1);
  signed int error;
  signed int *return_value___h_errno_location_2;
  return_value___h_errno_location_2=__h_errno_location();
  error = *return_value___h_errno_location_2;
  void *raw_addr;
  struct sockaddr_storage *addr_storage = (struct sockaddr_storage *)addr;
  _async_addr_from_name_free(self);
  signed int return_value__translate_h_errno_3;
  if(he == ((struct hostent *)NULL))
  {
    return_value__translate_h_errno_3=_translate_h_errno(error);
    return return_value__translate_h_errno_3;
  }

  switch(he->h_addrtype)
  {
    case 2:
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
      addr_in->sin_port = (unsigned short int)0;
      raw_addr = (void *)&addr_in->sin_addr;
      *addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      /* assertion he->h_length == 4 */
      assert(he->h_length == 4);
      break;
    }
    case 10:
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      addr_in6->sin6_port = (unsigned short int)0;
      addr_in6->sin6_flowinfo = (unsigned int)0;
      raw_addr = (void *)&addr_in6->sin6_addr;
      *addrlen = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
      /* assertion he->h_length == 16 */
      assert(he->h_length == 16);
      break;
    }
    default:
      return -2;
  }
  addr_storage->ss_family = (unsigned short int)he->h_addrtype;
  memcpy(raw_addr, (const void *)he->h_addr_list[(signed long int)0], (unsigned long int)he->h_length);
  return 0;
}

// async_addr_from_name_start
// file async_netdb.c line 315
struct async_addr_from_name * async_addr_from_name_start(struct _XDisplay *dpy, const char *hostname)
{
  struct async_addr_from_name *self;
  unsigned int return_value_thread_memory_alignment_1;
  return_value_thread_memory_alignment_1=thread_memory_alignment(dpy);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(hostname);
  signed int return_value_aligned_malloc_3;
  return_value_aligned_malloc_3=aligned_malloc((void **)&self, return_value_thread_memory_alignment_1, sizeof(struct async_addr_from_name) /*32ul*/  + return_value_strlen_2 + (unsigned long int)1);
  if(!(return_value_aligned_malloc_3 == 0))
    return (struct async_addr_from_name *)(void *)0;

  else
  {
    char *return_value__async_addr_from_name_hostname_4;
    return_value__async_addr_from_name_hostname_4=_async_addr_from_name_hostname(self);
    strcpy(return_value__async_addr_from_name_hostname_4, hostname);
    _has_threads=threads_available(dpy);
    self->res = (struct addrinfo *)(void *)0;
    if(_has_threads >= 0)
    {
      struct async_addr_from_name *result;
      void *return_value_io_thread_create_5;
      return_value_io_thread_create_5=io_thread_create(&self->io, (void *)self, _async_addr_from_name_thread, dpy, (unsigned int)65536);
      result = (struct async_addr_from_name *)return_value_io_thread_create_5;
      if(result == ((struct async_addr_from_name *)NULL))
        aligned_free((void *)result);

      self = result;
    }

    return self;
  }
}

// async_name_from_addr_cancel
// file async_netdb.c line 182
void async_name_from_addr_cancel(struct async_name_from_addr *self)
{
  if(_has_threads >= 0)
  {
    signed int return_value_io_thread_cancel_1;
    return_value_io_thread_cancel_1=io_thread_cancel(&self->io);
    if(!(return_value_io_thread_cancel_1 == 0))
      aligned_free((void *)self);

  }

  else
    free((void *)self);
}

// async_name_from_addr_finish
// file async_netdb.c line 197
signed int async_name_from_addr_finish(struct async_name_from_addr *self_raw, char **host, signed int *errno_error)
{
  if(_has_threads >= 0)
  {
    struct async_name_from_addr *self = self_raw;
    signed int gai_error;
    io_thread_finish(&self->io);
    gai_error = self->gai_error;
    if(!(gai_error == 0))
    {
      if(!(errno_error == ((signed int *)NULL)))
        *errno_error = self->errno_error;

      *host = (char *)(void *)0;
    }

    else
    {
      *host=strdup(self->host);
      if(*host == ((char *)NULL))
        gai_error = -10;

    }
    aligned_free((void *)self);
    return gai_error;
  }

  struct _async_name_from_addr_param *async_name_from_addr_finish__1__2__self = (struct _async_name_from_addr_param *)self_raw;
  struct hostent *he;
  signed int error;
  const void *raw_addr;
  unsigned int addrlen;
  switch((signed int)(&async_name_from_addr_finish__1__2__self->addr)->ss_family)
  {
    case 2:
    {
      raw_addr = (const void *)&((struct sockaddr_in *)&async_name_from_addr_finish__1__2__self->addr)->sin_addr;
      addrlen = (unsigned int)4;
      break;
    }
    case 10:
    {
      raw_addr = (const void *)&((struct sockaddr_in6 *)&async_name_from_addr_finish__1__2__self->addr)->sin6_addr;
      addrlen = (unsigned int)16;
      break;
    }
    default:
      return -2;
  }
  he=gethostbyaddr(raw_addr, addrlen, (signed int)(&async_name_from_addr_finish__1__2__self->addr)->ss_family);
  signed int *return_value___h_errno_location_1;
  return_value___h_errno_location_1=__h_errno_location();
  error = *return_value___h_errno_location_1;
  free((void *)async_name_from_addr_finish__1__2__self);
  if(he == ((struct hostent *)NULL))
  {
    *host = (char *)(void *)0;
    signed int return_value__translate_h_errno_2;
    return_value__translate_h_errno_2=_translate_h_errno(error);
    return return_value__translate_h_errno_2;
  }

  if(he->h_name == ((char *)NULL))
    return -2;

  else
  {
    *host=strdup(he->h_name);
    if(*host == ((char *)NULL))
      return -10;

    else
      return 0;
  }
}

// async_name_from_addr_start
// file async_netdb.c line 141
struct async_name_from_addr * async_name_from_addr_start(struct _XDisplay *dpy, struct sockaddr *addr, unsigned int addrlen)
{
  /* assertion addrlen */
  assert(addrlen != 0u);
  /* assertion addrlen <= sizeof (async_netdb_sockaddr_storage_t) */
  assert((unsigned long int)addrlen <= sizeof(struct sockaddr_storage) /*128ul*/ );
  _has_threads=threads_available(dpy);
  if(_has_threads >= 0)
  {
    struct async_name_from_addr *self;
    struct async_name_from_addr *result;
    unsigned int return_value_thread_memory_alignment_1;
    return_value_thread_memory_alignment_1=thread_memory_alignment(dpy);
    signed int return_value_aligned_malloc_2;
    return_value_aligned_malloc_2=aligned_malloc((void **)&self, return_value_thread_memory_alignment_1, sizeof(struct async_name_from_addr) /*1192ul*/ );
    if(!(return_value_aligned_malloc_2 == 0))
      return (struct async_name_from_addr *)(void *)0;

    _async_name_from_addr_set_param(&self->param, addr, addrlen);
    void *return_value_io_thread_create_3;
    return_value_io_thread_create_3=io_thread_create(&self->io, (void *)self, _async_name_from_addr_thread, dpy, (unsigned int)65536);
    result = (struct async_name_from_addr *)return_value_io_thread_create_3;
    if(result == ((struct async_name_from_addr *)NULL))
      aligned_free((void *)self);

    return result;
  }

  struct _async_name_from_addr_param *async_name_from_addr_start__1__2__result;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(struct _async_name_from_addr_param) /*136ul*/ );
  async_name_from_addr_start__1__2__result = (struct _async_name_from_addr_param *)return_value_malloc_4;
  if(!(async_name_from_addr_start__1__2__result == ((struct _async_name_from_addr_param *)NULL)))
    _async_name_from_addr_set_param(async_name_from_addr_start__1__2__result, addr, addrlen);

  return (struct async_name_from_addr *)async_name_from_addr_start__1__2__result;
}

// atom_size
// file molecule.c line 361
static float atom_size(const struct anonymous_33 *a)
{
  if(!(do_bonds == 0))
    return a->data->size2;

  else
    return a->data->size;
}

// axis_to_quat
// file trackball.c line 213
static void axis_to_quat(float *a, float phi, float *q)
{
  vnormal(a);
  vcopy(a, q);
  double return_value_sin_1;
  return_value_sin_1=sin((double)phi / 2.0);
  vscale(q, (float)return_value_sin_1);
  double return_value_cos_2;
  return_value_cos_2=cos((double)phi / 2.0);
  q[(signed long int)3] = (float)return_value_cos_2;
}

// bitmap_to_texture
// file texfont.c line 108
static void bitmap_to_texture(struct _XDisplay *dpy, unsigned long int p, struct anonymous_16 *visual, signed int depth, signed int *wP, signed int *hP)
{
  signed int mipmap_p = 1;
  signed int ow = *wP;
  signed int oh = *hP;
  signed int w2;
  w2=to_pow2(ow);
  signed int h2;
  h2=to_pow2(oh);
  signed int x;
  signed int y;
  signed int max;
  signed int scale;
  struct _XImage *image = ((struct _XImage *)NULL);
  unsigned char *data;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(w2 * 2), (unsigned long int)(h2 + 1));
  data = (unsigned char *)return_value_calloc_1;
  unsigned char *out = data;
  glGetIntegerv((unsigned int)0x0D33, &max);
  scale = 1;
  for( ; !(max >= h2) || !(max >= w2); scale = scale * 2)
  {
    w2 = w2 / 2;
    h2 = h2 / 2;
  }
  unsigned int iformat = (unsigned int)0x8049;
  unsigned int format = (unsigned int)0x1909;
  unsigned int type = (unsigned int)0x1401;
  if(image == ((struct _XImage *)NULL))
    image=XGetImage(dpy, p, 0, 0, (unsigned int)ow, (unsigned int)oh, (unsigned long int)~0L, 2);

  y = 0;
  unsigned long int return_value;
  for( ; !(y >= h2); y = y + 1)
  {
    x = 0;
    for( ; !(x >= w2); x = x + 1)
    {
      signed int sx = x * scale;
      signed int sy = y * scale;
      unsigned long int pixel;
      unsigned long int tmp_if_expr_2;
      if(sx >= ow || sy >= oh)
        tmp_if_expr_2 = (unsigned long int)0;

      else
      {
        return_value=image->f.get_pixel(image, sx, sy);
        tmp_if_expr_2 = return_value;
      }
      pixel = tmp_if_expr_2;
      unsigned long int r = pixel & visual->red_mask;
      pixel = (r >> 24 | r >> 16 | r >> 8 | r) & (unsigned long int)0xFF;
      unsigned char *tmp_post_3 = out;
      out = out + 1l;
      *tmp_post_3 = (unsigned char)pixel;
    }
  }
  image->f.destroy_image(image);
  image = ((struct _XImage *)NULL);
  if(!(mipmap_p == 0))
    gluBuild2DMipmaps((unsigned int)0x0DE1, (signed int)iformat, w2, h2, format, type, (const void *)data);

  else
    glTexImage2D((unsigned int)0x0DE1, 0, (signed int)iformat, w2, h2, 0, format, type, (const void *)data);
  char msg[100l];
  sprintf(msg, "texture font %s (%d x %d)", mipmap_p != 0 ? "gluBuild2DMipmaps" : "glTexImage2D", w2, h2);
  check_gl_error(msg);
  free((void *)data);
  *wP = w2 * scale;
  *hP = h2 * scale;
}

// build_molecule
// file molecule.c line 541
static void build_molecule(struct ModeInfo *mi, signed int transparent_p)
{
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  signed int wire = mi->wireframe_p;
  signed int i;
  float alpha = (float)(transparent_p != 0 ? (double)shell_alpha : 1.0);
  signed int polys = 0;
  struct anonymous_30 *m = &mc->molecules[(signed long int)mc->which];
  if(!(wire == 0))
  {
    glDisable((unsigned int)0x0B44);
    glDisable((unsigned int)0x0B50);
    glDisable((unsigned int)0x4000);
    glDisable((unsigned int)0x0B71);
    glDisable((unsigned int)0x0BA1);
    glDisable((unsigned int)0x0B44);
  }

  else
  {
    glEnable((unsigned int)0x0B44);
    glEnable((unsigned int)0x0B50);
    glEnable((unsigned int)0x4000);
    glEnable((unsigned int)0x0B71);
    glEnable((unsigned int)0x0BA1);
    glEnable((unsigned int)0x0B44);
  }
  if(wire == 0)
    set_atom_color(mi, ((const struct anonymous_33 *)NULL), 0, alpha);

  if(!(do_bonds == 0))
  {
    i = 0;
    for( ; !(i >= m->nbonds); i = i + 1)
    {
      const struct anonymous_34 *b = &m->bonds[(signed long int)i];
      const struct anonymous_33 *from;
      from=get_atom(m->atoms, m->natoms, b->from);
      const struct anonymous_33 *to;
      to=get_atom(m->atoms, m->natoms, b->to);
      if(!(wire == 0))
      {
        glBegin((unsigned int)0x0001);
        glVertex3f(from->x, from->y, from->z);
        glVertex3f(to->x, to->y, to->z);
        glEnd();
        polys = polys + 1;
      }

      else
      {
        signed int faces = mc->low_rez_p != 0 ? 6 : 12;
        signed int smooth = 1;
        signed int cap_p = (signed int)(!(do_atoms != 0) || do_shells != 0);
        float base = (float)0.07;
        float thickness = base * (float)b->strength;
        float cap_size = cap_p != 0 ? base / (float)2 : (float)0;
        if((double)thickness > 0.3)
          thickness = (float)0.3;

        signed int return_value_tube_1;
        return_value_tube_1=tube(from->x, from->y, from->z, to->x, to->y, to->z, thickness, cap_size, faces, smooth, cap_p, wire);
        polys = polys + return_value_tube_1;
      }
    }
  }

  if(wire == 0 && !(do_atoms == 0))
  {
    i = 0;
    for( ; !(i >= m->natoms); i = i + 1)
    {
      const struct anonymous_33 *build_molecule__1__4__a = &m->atoms[(signed long int)i];
      float size;
      size=atom_size(build_molecule__1__4__a);
      set_atom_color(mi, build_molecule__1__4__a, 0, alpha);
      signed int return_value_sphere_2;
      return_value_sphere_2=sphere(mc, build_molecule__1__4__a->x, build_molecule__1__4__a->y, build_molecule__1__4__a->z, size, wire);
      polys = polys + return_value_sphere_2;
    }
  }

  if(transparent_p == 0 && !(do_bbox == 0))
  {
    draw_bounding_box(mi);
    polys = polys + 4;
  }

  mc->polygon_count = mc->polygon_count + polys;
}

// build_rotmatrix
// file trackball.c line 309
void build_rotmatrix(float (*m)[4l], float *q)
{
  m[(signed long int)0][(signed long int)0] = (float)(1.0 - 2.0 * (double)(q[(signed long int)1] * q[(signed long int)1] + q[(signed long int)2] * q[(signed long int)2]));
  m[(signed long int)0][(signed long int)1] = (float)(2.0 * (double)(q[(signed long int)0] * q[(signed long int)1] - q[(signed long int)2] * q[(signed long int)3]));
  m[(signed long int)0][(signed long int)2] = (float)(2.0 * (double)(q[(signed long int)2] * q[(signed long int)0] + q[(signed long int)1] * q[(signed long int)3]));
  m[(signed long int)0][(signed long int)3] = (float)0.0;
  m[(signed long int)1][(signed long int)0] = (float)(2.0 * (double)(q[(signed long int)0] * q[(signed long int)1] + q[(signed long int)2] * q[(signed long int)3]));
  m[(signed long int)1][(signed long int)1] = (float)(1.0 - 2.0 * (double)(q[(signed long int)2] * q[(signed long int)2] + q[(signed long int)0] * q[(signed long int)0]));
  m[(signed long int)1][(signed long int)2] = (float)(2.0 * (double)(q[(signed long int)1] * q[(signed long int)2] - q[(signed long int)0] * q[(signed long int)3]));
  m[(signed long int)1][(signed long int)3] = (float)0.0;
  m[(signed long int)2][(signed long int)0] = (float)(2.0 * (double)(q[(signed long int)2] * q[(signed long int)0] - q[(signed long int)1] * q[(signed long int)3]));
  m[(signed long int)2][(signed long int)1] = (float)(2.0 * (double)(q[(signed long int)1] * q[(signed long int)2] + q[(signed long int)0] * q[(signed long int)3]));
  m[(signed long int)2][(signed long int)2] = (float)(1.0 - 2.0 * (double)(q[(signed long int)1] * q[(signed long int)1] + q[(signed long int)0] * q[(signed long int)0]));
  m[(signed long int)2][(signed long int)3] = (float)0.0;
  m[(signed long int)3][(signed long int)0] = (float)0.0;
  m[(signed long int)3][(signed long int)1] = (float)0.0;
  m[(signed long int)3][(signed long int)2] = (float)0.0;
  m[(signed long int)3][(signed long int)3] = (float)1.0;
}

// check_gl_error
// file xlock-gl-utils.c line 161
extern void check_gl_error(const char *type)
{
  char buf[100l];
  unsigned int i;
  const char *e;
  i=glGetError();
  switch(i)
  {
    case (unsigned int)0:
      goto __CPROVER_DUMP_L13;
    case (unsigned int)0x0500:
    {
      e = "invalid enum";
      break;
    }
    case (unsigned int)0x0501:
    {
      e = "invalid value";
      break;
    }
    case (unsigned int)0x0502:
    {
      e = "invalid operation";
      break;
    }
    case (unsigned int)0x0503:
    {
      e = "stack overflow";
      break;
    }
    case (unsigned int)0x0504:
    {
      e = "stack underflow";
      break;
    }
    case (unsigned int)0x0505:
    {
      e = "out of memory";
      break;
    }
    case (unsigned int)0x0506:
    {
      e = "invalid framebuffer operation";
      break;
    }
    case (unsigned int)0x8031:
    {
      e = "table too large";
      break;
    }
    case (unsigned int)0x8065:
    {
      e = "texture too large";
      break;
    }
    default:
    {
      e = buf;
      sprintf(buf, "unknown error %d", (signed int)i);
    }
  }
  fprintf(stderr, "%s: %s error: %s\n", progname, type, e);
  exit(1);

__CPROVER_DUMP_L13:
  ;
}

// clear_gl_error
// file xlock-gl-utils.c line 153
extern void clear_gl_error(void)
{
  unsigned int return_value_glGetError_1;
  do
  {
    return_value_glGetError_1=glGetError();
    if(return_value_glGetError_1 == 0u)
      break;

  }
  while((_Bool)1);
}

// cmp_atoms
// file molecule.c line 935
static signed int cmp_atoms(const void *aa, const void *bb)
{
  const struct anonymous_37 *cmp_atoms__1__a = (struct anonymous_37 *)aa;
  const struct anonymous_37 *b = (struct anonymous_37 *)bb;
  if(cmp_atoms__1__a->atom == ((char *)NULL))
    return 1;

  else
    if(b->atom == ((char *)NULL))
      return -1;

    else
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(cmp_atoms__1__a->atom, "C");
      if(return_value_strcmp_1 == 0)
        return -1;

      else
      {
        signed int return_value_strcmp_2;
        return_value_strcmp_2=strcmp(b->atom, "C");
        if(return_value_strcmp_2 == 0)
          return 1;

        else
        {
          signed int return_value_strcmp_3;
          return_value_strcmp_3=strcmp(cmp_atoms__1__a->atom, "H");
          if(return_value_strcmp_3 == 0)
            return -1;

          else
          {
            signed int return_value_strcmp_4;
            return_value_strcmp_4=strcmp(b->atom, "H");
            if(return_value_strcmp_4 == 0)
              return 1;

            else
            {
              signed int return_value_strcmp_5;
              return_value_strcmp_5=strcmp(cmp_atoms__1__a->atom, b->atom);
              return return_value_strcmp_5;
            }
          }
        }
      }
    }
}

// complain
// file colors.c line 79
static void complain(signed int wanted_colors, signed int got_colors, signed int wanted_writable, signed int got_writable)
{
  if(wanted_colors + -10 >= got_colors)
  {
    if(got_writable == 0 && !(wanted_writable == 0))
      fprintf(stderr, "%s: wanted %d writable colors; got %d read-only colors.\n", progname, wanted_colors, got_colors);

    else
      fprintf(stderr, "%s: wanted %d%s colors; got %d.\n", progname, wanted_colors, got_writable != 0 ? " writable" : "", got_colors);
  }

}

// cone
// file tube.c line 395
extern signed int cone(float x1, float y1, float z1, float x2, float y2, float z2, float diameter, float cap_size, signed int faces, signed int smooth, signed int cap_p, signed int wire_p)
{
  signed int return_value_tube_1_1;
  return_value_tube_1_1=tube_1(x1, y1, z1, x2, y2, z2, diameter, cap_size, faces, smooth, cap_p, wire_p, 1);
  return return_value_tube_1_1;
}

// describe_gl_visual
// file visual-gl.c line 116
extern void describe_gl_visual(struct _IO_FILE *f, struct anonymous_15 *screen, struct anonymous_16 *visual, signed int private_cmap_p)
{
  describe_visual(f, screen, visual, private_cmap_p);
  signed int status;
  signed int value = 0;
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_10 *)NULL))
    abort();

  status=glXGetConfig(dpy, vi_out, 1, &value);
  if(!(status == 3))
  {
    if(!(status == 4) && !(value == 0))
    {
      signed int return_value_glXGetConfig_1;
      return_value_glXGetConfig_1=glXGetConfig(dpy, vi_out, 3, &value);
      if(return_value_glXGetConfig_1 == 0)
      {
        if(!(value == 0))
          printf("    GLX level:         %d\n", value);

      }

      signed int return_value_glXGetConfig_2;
      return_value_glXGetConfig_2=glXGetConfig(dpy, vi_out, 4, &value);
      if(return_value_glXGetConfig_2 == 0 && !(value == 0))
      {
        signed int r = 0;
        signed int g = 0;
        signed int b = 0;
        signed int describe_gl_visual__1__1__1__a = 0;
        glXGetConfig(dpy, vi_out, 8, &r);
        glXGetConfig(dpy, vi_out, 9, &g);
        glXGetConfig(dpy, vi_out, 10, &b);
        glXGetConfig(dpy, vi_out, 11, &describe_gl_visual__1__1__1__a);
        printf("    GLX type:          RGBA (%2d, %2d, %2d, %2d)\n", r, g, b, describe_gl_visual__1__1__1__a);
        r = 0;
        g = 0;
        b = 0;
        describe_gl_visual__1__1__1__a = 0;
        glXGetConfig(dpy, vi_out, 14, &r);
        glXGetConfig(dpy, vi_out, 15, &g);
        glXGetConfig(dpy, vi_out, 16, &b);
        glXGetConfig(dpy, vi_out, 17, &describe_gl_visual__1__1__1__a);
        printf("    GLX accum:         RGBA (%2d, %2d, %2d, %2d)\n", r, g, b, describe_gl_visual__1__1__1__a);
      }

      else
      {
        value = 0;
        glXGetConfig(dpy, vi_out, 2, &value);
        printf("    GLX type:          indexed (%d)\n", value);
      }
      signed int return_value_glXGetConfig_3;
      return_value_glXGetConfig_3=glXGetConfig(dpy, vi_out, 0x20, &value);
      if(return_value_glXGetConfig_3 == 0)
      {
        if(!(value == 0x8000))
          printf("    GLX rating:        %s\n", value == 0x8000 ? "none" : (value == 0x8001 ? "slow" : "???"));

      }

      signed int return_value_glXGetConfig_4;
      return_value_glXGetConfig_4=glXGetConfig(dpy, vi_out, 5, &value);
      if(return_value_glXGetConfig_4 == 0)
        printf("    GLX double-buffer: %s\n", value != 0 ? "yes" : "no");

      signed int return_value_glXGetConfig_5;
      return_value_glXGetConfig_5=glXGetConfig(dpy, vi_out, 6, &value);
      if(return_value_glXGetConfig_5 == 0)
      {
        if(!(value == 0))
          printf("    GLX stereo:        %s\n", value != 0 ? "yes" : "no");

      }

      signed int return_value_glXGetConfig_6;
      return_value_glXGetConfig_6=glXGetConfig(dpy, vi_out, 7, &value);
      if(return_value_glXGetConfig_6 == 0)
      {
        if(!(value == 0))
          printf("    GLX aux buffers:   %d\n", value);

      }

      signed int return_value_glXGetConfig_7;
      return_value_glXGetConfig_7=glXGetConfig(dpy, vi_out, 12, &value);
      if(return_value_glXGetConfig_7 == 0)
        printf("    GLX depth size:    %d\n", value);

      signed int return_value_glXGetConfig_8;
      return_value_glXGetConfig_8=glXGetConfig(dpy, vi_out, 13, &value);
      if(return_value_glXGetConfig_8 == 0)
      {
        if(!(value == 0))
          printf("    GLX stencil size:  %d\n", value);

      }

      signed int return_value_glXGetConfig_10;
      return_value_glXGetConfig_10=glXGetConfig(dpy, vi_out, 0x80A8, &value);
      if(return_value_glXGetConfig_10 == 0)
      {
        if(!(value == 0))
        {
          signed int bufs = value;
          signed int return_value_glXGetConfig_9;
          return_value_glXGetConfig_9=glXGetConfig(dpy, vi_out, 0x80A9, &value);
          if(return_value_glXGetConfig_9 == 0)
            printf("    GLX multisample:   %d, %d\n", bufs, value);

        }

      }

      signed int return_value_glXGetConfig_12;
      return_value_glXGetConfig_12=glXGetConfig(dpy, vi_out, 0x23, &value);
      if(return_value_glXGetConfig_12 == 0)
      {
        if(!(value == 0x8000))
        {
          if(value == 0x8000)
            printf("    GLX transparency:  none\n");

          else
            if(value == 0x8009)
            {
              signed int return_value_glXGetConfig_11;
              return_value_glXGetConfig_11=glXGetConfig(dpy, vi_out, 0x24, &value);
              if(return_value_glXGetConfig_11 == 0)
                printf("    GLX transparency:  indexed (%d)\n", value);

            }

            else
              if(value == 0x8008)
              {
                signed int describe_gl_visual__1__1__4__2__r = 0;
                signed int describe_gl_visual__1__1__4__2__g = 0;
                signed int describe_gl_visual__1__1__4__2__b = 0;
                signed int describe_gl_visual__1__1__4__2__a = 0;
                glXGetConfig(dpy, vi_out, 0x25, &describe_gl_visual__1__1__4__2__r);
                glXGetConfig(dpy, vi_out, 0x26, &describe_gl_visual__1__1__4__2__g);
                glXGetConfig(dpy, vi_out, 0x27, &describe_gl_visual__1__1__4__2__b);
                glXGetConfig(dpy, vi_out, 0x28, &describe_gl_visual__1__1__4__2__a);
                printf("    GLX transparency:  RGBA (%2d, %2d, %2d, %2d)\n", describe_gl_visual__1__1__4__2__r, describe_gl_visual__1__1__4__2__g, describe_gl_visual__1__1__4__2__b, describe_gl_visual__1__1__4__2__a);
              }

        }

      }

    }

  }

}

// describe_visual
// file visual.c line 445
extern void describe_visual(struct _IO_FILE *f, struct anonymous_15 *screen, struct anonymous_16 *visual, signed int private_cmap_p)
{
  char n[10l];
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_10 *)NULL))
    abort();

  if(!(private_cmap_p == 0))
    sprintf(n, "%3d", vi_out->colormap_size);

  else
    strcpy(n, "default");
  char *tmp_if_expr_5;
  char *tmp_if_expr_4;
  char *tmp_if_expr_3;
  char *tmp_if_expr_2;
  char *tmp_if_expr_1;
  if(vi_out->class == 0)
    tmp_if_expr_5 = "StaticGray, ";

  else
  {
    if(vi_out->class == 2)
      tmp_if_expr_4 = "StaticColor,";

    else
    {
      if(vi_out->class == 4)
        tmp_if_expr_3 = "TrueColor,  ";

      else
      {
        if(vi_out->class == 1)
          tmp_if_expr_2 = "GrayScale,  ";

        else
        {
          if(vi_out->class == 3)
            tmp_if_expr_1 = "PseudoColor,";

          else
            tmp_if_expr_1 = vi_out->class == 5 ? "DirectColor," : "UNKNOWN:    ";
          tmp_if_expr_2 = tmp_if_expr_1;
        }
        tmp_if_expr_3 = tmp_if_expr_2;
      }
      tmp_if_expr_4 = tmp_if_expr_3;
    }
    tmp_if_expr_5 = tmp_if_expr_4;
  }
  fprintf(f, "0x%02x (%s depth: %2d, cmap: %s)\n", (unsigned int)vi_out->visualid, tmp_if_expr_5, vi_out->depth, (const void *)n);
  XFree((void *)(char *)vi_out);
}

// draw_bounding_box
// file molecule.c line 436
static void draw_bounding_box(struct ModeInfo *mi)
{
  signed int wire = mi->wireframe_p;
  float x1;
  float y1;
  float z1;
  float x2;
  float y2;
  float z2;
  molecule_bounding_box(mi, &x1, &y1, &z1, &x2, &y2, &z2);
  static const float c1[4l] = { (const float)0.2, (const float)0.2, (const float)0.4, (const float)1.0 };
  glMaterialfv((unsigned int)0x0404, (unsigned int)0x1602, c1);
  glFrontFace((unsigned int)0x0901);
  glBegin((unsigned int)(wire != 0 ? 0x0002 : 0x0007));
  glNormal3f((float)0, (float)1, (float)0);
  glVertex3f(x1, y1, z1);
  glVertex3f(x1, y1, z2);
  glVertex3f(x2, y1, z2);
  glVertex3f(x2, y1, z1);
  glEnd();
  glBegin((unsigned int)(wire != 0 ? 0x0002 : 0x0007));
  glNormal3f((float)0, (float)-1, (float)0);
  glVertex3f(x2, y2, z1);
  glVertex3f(x2, y2, z2);
  glVertex3f(x1, y2, z2);
  glVertex3f(x1, y2, z1);
  glEnd();
  glBegin((unsigned int)(wire != 0 ? 0x0002 : 0x0007));
  glNormal3f((float)0, (float)0, (float)1);
  glVertex3f(x1, y1, z1);
  glVertex3f(x2, y1, z1);
  glVertex3f(x2, y2, z1);
  glVertex3f(x1, y2, z1);
  glEnd();
  glBegin((unsigned int)(wire != 0 ? 0x0002 : 0x0007));
  glNormal3f((float)0, (float)0, (float)-1);
  glVertex3f(x1, y2, z2);
  glVertex3f(x2, y2, z2);
  glVertex3f(x2, y1, z2);
  glVertex3f(x1, y1, z2);
  glEnd();
  glBegin((unsigned int)(wire != 0 ? 0x0002 : 0x0007));
  glNormal3f((float)1, (float)0, (float)0);
  glVertex3f(x1, y2, z1);
  glVertex3f(x1, y2, z2);
  glVertex3f(x1, y1, z2);
  glVertex3f(x1, y1, z1);
  glEnd();
  glBegin((unsigned int)(wire != 0 ? 0x0002 : 0x0007));
  glNormal3f((float)-1, (float)0, (float)0);
  glVertex3f(x2, y1, z1);
  glVertex3f(x2, y1, z2);
  glVertex3f(x2, y2, z2);
  glVertex3f(x2, y2, z1);
  glEnd();
  glDisable((unsigned int)0x0B50);
  static const float c2[4l] = { (const float)1.0, (const float)0.0, (const float)0.0, (const float)1.0 };
  glColor3f(c2[(signed long int)0], c2[(signed long int)1], c2[(signed long int)2]);
  glBegin((unsigned int)0x0001);
  if(x1 > 0.000000f)
    x1 = (float)0;

  if(x2 < 0.000000f)
    x2 = (float)0;

  if(y1 > 0.000000f)
    y1 = (float)0;

  if(y2 < 0.000000f)
    y2 = (float)0;

  if(z1 > 0.000000f)
    z1 = (float)0;

  if(z2 < 0.000000f)
    z2 = (float)0;

  glVertex3f(x1, (float)0, (float)0);
  glVertex3f(x2, (float)0, (float)0);
  glVertex3f((float)0, y1, (float)0);
  glVertex3f((float)0, y2, (float)0);
  glVertex3f((float)0, (float)0, z1);
  glVertex3f((float)0, (float)0, z2);
  glEnd();
  if(wire == 0)
    glEnable((unsigned int)0x0B50);

}

// draw_labels
// file molecule.c line 1361
static void draw_labels(struct ModeInfo *mi)
{
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  signed int wire = mi->wireframe_p;
  struct anonymous_30 *m = &mc->molecules[(signed long int)mc->which];
  signed int i;
  if(!(do_labels == 0))
  {
    i = 0;
    for( ; !(i >= m->natoms); i = i + 1)
    {
      struct anonymous_33 *draw_labels__1__1__a = &m->atoms[(signed long int)i];
      float size;
      size=atom_size(draw_labels__1__1__a);
      float draw_labels__1__1__m[4l][4l];
      glPushMatrix();
      if(wire == 0)
        set_atom_color(mi, draw_labels__1__1__a, 1, (float)1);

      glTranslatef(draw_labels__1__1__a->x, draw_labels__1__1__a->y, draw_labels__1__1__a->z);
      glGetFloatv((unsigned int)0x0BA6, &draw_labels__1__1__m[(signed long int)0][(signed long int)0]);
      draw_labels__1__1__m[(signed long int)0][(signed long int)0] = (float)1;
      draw_labels__1__1__m[(signed long int)1][(signed long int)0] = (float)0;
      draw_labels__1__1__m[(signed long int)2][(signed long int)0] = (float)0;
      draw_labels__1__1__m[(signed long int)0][(signed long int)1] = (float)0;
      draw_labels__1__1__m[(signed long int)1][(signed long int)1] = (float)1;
      draw_labels__1__1__m[(signed long int)2][(signed long int)1] = (float)0;
      draw_labels__1__1__m[(signed long int)0][(signed long int)2] = (float)0;
      draw_labels__1__1__m[(signed long int)1][(signed long int)2] = (float)0;
      draw_labels__1__1__m[(signed long int)2][(signed long int)2] = (float)1;
      glLoadIdentity();
      glMultMatrixf(&draw_labels__1__1__m[(signed long int)0][(signed long int)0]);
      glTranslatef((float)0, (float)0, (float)((double)size * 1.1));
      glRotatef((float)0, (float)0, (float)0, (float)1);
      struct anonymous_38 e;
      signed int w;
      signed int h;
      texture_string_metrics(mc->atom_font, draw_labels__1__1__a->label, &e, ((signed int *)NULL), ((signed int *)NULL));
      w = (signed int)e.width;
      h = (signed int)e.ascent + (signed int)e.descent;
      float s = (float)(1.0 / (double)h);
      s = s * mc->overall_scale;
      s = s * (float)0.8;
      glScalef(s, s, (float)1);
      glTranslatef((float)(-w / 2), (float)(-h / 2), (float)0);
      print_texture_string(mc->atom_font, draw_labels__1__1__a->label);
      glPopMatrix();
    }
  }

}

// draw_molecule
// file molecule.c line 1534
static void draw_molecule(struct ModeInfo *mi)
{
  signed long int draw_molecule__1__now;
  draw_molecule__1__now=time((signed long int *)0);
  float speed = (float)4.0;
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  struct _XDisplay *dpy = mi->dpy;
  unsigned long int window = mi->window;
  if(!(mc->glx_context == ((struct __GLXcontextRec **)NULL)))
  {
    glXMakeCurrent(mi->dpy, mi->window, *mc->glx_context);
    if(mc->draw_time == 0l)
    {
      pick_new_molecule(mi, mc->draw_time);
      mc->draw_time = draw_molecule__1__now;
    }

    else
      if(mc->mode == 0)
      {
        signed int tmp_post_1 = mc->draw_tick;
        mc->draw_tick = mc->draw_tick + 1;
        if(tmp_post_1 >= 11)
        {
          signed long int now;
          now=time((signed long int *)0);
          if(mc->draw_time == 0l)
            mc->draw_time = now;

          mc->draw_tick = 0;
          if(mc->button_down_p == 0)
          {
            if(mc->nmolecules >= 2)
            {
              if(now >= mc->draw_time + (signed long int)timeout)
              {
                mc->mode = 1;
                mc->mode_tick = (signed int)((float)80 / speed);
                mc->draw_time = now;
              }

            }

          }

        }

      }

      else
        if(mc->mode == 1)
        {
          mc->mode_tick = mc->mode_tick - 1;
          if(!(mc->mode_tick >= 1))
          {
            mc->mode_tick = (signed int)((float)80 / speed);
            mc->mode = 2;
            pick_new_molecule(mi, mc->draw_time);
          }

        }

        else
          if(mc->mode == 2)
          {
            mc->mode_tick = mc->mode_tick - 1;
            if(!(mc->mode_tick >= 1))
              mc->mode = 0;

          }

          else
            abort();
    glPushMatrix();
    glScalef((float)1.1, (float)1.1, (float)1.1);
    double x;
    double y;
    double z;
    get_position(mc->rot, &x, &y, &z, (signed int)!(mc->button_down_p != 0));
    glTranslatef((float)((x - 0.5) * (double)9), (float)((y - 0.5) * (double)9), (float)((z - 0.5) * (double)9));
    gltrackball_rotate(mc->trackball);
    get_rotation(mc->rot, &x, &y, &z, (signed int)!(mc->button_down_p != 0));
    glRotatef((float)(x * (double)360), (float)1.0, (float)0.0, (float)0.0);
    glRotatef((float)(y * (double)360), (float)0.0, (float)1.0, (float)0.0);
    glRotatef((float)(z * (double)360), (float)0.0, (float)0.0, (float)1.0);
    glClear((unsigned int)(0x00004000 | 0x00000100));
    if(!(mc->mode == 0))
    {
      float s;
      float tmp_if_expr_2;
      if(mc->mode == 1)
        tmp_if_expr_2 = (float)mc->mode_tick / ((float)80 / speed);

      else
        tmp_if_expr_2 = (((float)80 / speed - (float)mc->mode_tick) + (float)1) / ((float)80 / speed);
      s = tmp_if_expr_2;
      glScalef(s, s, s);
    }

    glPushMatrix();
    glCallList(mc->molecule_dlist);
    if(mc->mode == 0)
    {
      struct anonymous_30 *m = &mc->molecules[(signed long int)mc->which];
      draw_labels(mi);
      if(!(do_titles == 0))
      {
        if(!(m->label == ((const char *)NULL)))
        {
          if(!(*m->label == 0))
          {
            set_atom_color(mi, ((const struct anonymous_33 *)NULL), 1, (float)1);
            print_texture_label(mi->dpy, mc->title_font, mi->xgwa.width, mi->xgwa.height, 1, m->label);
          }

        }

      }

    }

    glPopMatrix();
    if(!(do_shells == 0))
    {
      glColorMask((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0);
      glPushMatrix();
      glCallList(mc->shell_dlist);
      glPopMatrix();
      glColorMask((unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1);
      glDepthFunc((unsigned int)0x0202);
      glEnable((unsigned int)0x0BE2);
      glBlendFunc((unsigned int)0x0302, (unsigned int)0x0303);
      glPushMatrix();
      glCallList(mc->shell_dlist);
      glPopMatrix();
      glDepthFunc((unsigned int)0x0201);
      glDisable((unsigned int)0x0BE2);
    }

    glPopMatrix();
    mi->polygon_count = (unsigned long int)mc->polygon_count;
    if(!(mi->fps_p == 0))
      xlockmore_gl_draw_fps(mi);

    glFinish();
    glXSwapBuffers(dpy, window);
  }

}

// enable_texture_string_parameters
// file texfont.c line 576
void enable_texture_string_parameters(void)
{
  glEnable((unsigned int)0x0DE1);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2703);
  glTexParameterf((unsigned int)0x0DE1, (unsigned int)0x8501, (float)0.25);
  clear_gl_error();
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2802, 0x2901);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2803, 0x2901);
  glAlphaFunc((unsigned int)0x0204, (float)0.01);
  glEnable((unsigned int)0x0BC0);
  glEnable((unsigned int)0x0BE2);
  glDisable((unsigned int)0x0B50);
  glDisable((unsigned int)0x0C60);
  glDisable((unsigned int)0x0C61);
  glBlendFunc((unsigned int)0x0302, (unsigned int)0x0303);
}

// ensure_bounding_box_visible
// file molecule.c line 500
static void ensure_bounding_box_visible(struct ModeInfo *mi)
{
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  float x1;
  float y1;
  float z1;
  float x2;
  float y2;
  float z2;
  float w;
  float h;
  float d;
  float size;
  float max_size = (float)10;
  molecule_bounding_box(mi, &x1, &y1, &z1, &x2, &y2, &z2);
  w = x2 - x1;
  h = y2 - y1;
  d = z2 - z1;
  size = w > h ? w : h;
  size = size > d ? size : d;
  mc->molecule_size = size;
  mc->low_rez_p = 0;
  mc->overall_scale = (float)1;
  if(size > max_size)
  {
    mc->overall_scale = max_size / size;
    glScalef(mc->overall_scale, mc->overall_scale, mc->overall_scale);
    mc->low_rez_p = (signed int)((double)mc->overall_scale < 0.3);
  }

  glTranslatef(-(x1 + w / (float)2), -(y1 + h / (float)2), -(z1 + d / (float)2));
}

// find_similar_visual
// file visual.c line 503
extern struct anonymous_16 * find_similar_visual(struct anonymous_15 *screen, struct anonymous_16 *old_visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  struct anonymous_16 *result = ((struct anonymous_16 *)NULL);
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.class=visual_class(screen, old_visual);
  vi_in.depth=visual_depth(screen, old_visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x8 | 0x4), &vi_in, &out_count);
  if(out_count >= 1 && !(vi_out == ((struct anonymous_10 *)NULL)))
    result = (vi_out + (signed long int)0)->visual;

  if(!(vi_out == ((struct anonymous_10 *)NULL)))
    XFree((void *)vi_out);

  vi_out = ((struct anonymous_10 *)NULL);
  if(result == ((struct anonymous_16 *)NULL))
  {
    vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x8), &vi_in, &out_count);
    if(out_count >= 1 && !(vi_out == ((struct anonymous_10 *)NULL)))
      result = (vi_out + (signed long int)0)->visual;

    if(!(vi_out == ((struct anonymous_10 *)NULL)))
      XFree((void *)vi_out);

    vi_out = ((struct anonymous_10 *)NULL);
  }

  if(result == ((struct anonymous_16 *)NULL))
    result = screen->root_visual;

  return result;
}

// fix_fds
// file screenhack.c line 403
static void fix_fds(void)
{
  signed int fd0;
  fd0=open("/dev/null", 02);
  signed int fd1;
  fd1=open("/dev/null", 02);
  signed int fd2;
  fd2=open("/dev/null", 02);
  if(fd0 >= 3)
    close(fd0);

  if(fd1 >= 3)
    close(fd1);

  if(fd2 >= 3)
    close(fd2);

}

// fps_compute
// file fps.h line 25
extern double fps_compute(struct fps_state *st, unsigned long int polys, double depth)
{
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  if(st == ((struct fps_state *)NULL))
    return (double)0;

  else
  {
    signed int tmp_post_1 = st->frame_count;
    st->frame_count = st->frame_count + 1;
    if(tmp_post_1 >= st->last_ifps)
    {
      struct timezone tzp;
      gettimeofday(&st->this_frame_end, &tzp);
      if(st->prev_frame_end.tv_sec == 0l)
        st->prev_frame_end = st->this_frame_end;

    }

    if(!(st->this_frame_end.tv_sec == st->prev_frame_end.tv_sec))
    {
      double uprev_frame_end = (double)st->prev_frame_end.tv_sec + (double)st->prev_frame_end.tv_usec * 0.000001;
      double uthis_frame_end = (double)st->this_frame_end.tv_sec + (double)st->this_frame_end.tv_usec * 0.000001;
      double fps = (double)st->frame_count / (uthis_frame_end - uprev_frame_end);
      double idle = ((double)st->slept * 0.000001) / (uthis_frame_end - uprev_frame_end);
      double load = (double)100 * ((double)1 - idle);
      if(load < 0.000000)
        load = (double)0;

      st->prev_frame_end = st->this_frame_end;
      st->frame_count = 0;
      st->slept = (unsigned long int)0;
      st->last_ifps = (signed int)fps;
      st->last_fps = fps;
      sprintf(st->string, polys != 0ul ? "FPS:   %.1f \nLoad:  %.1f%% " : "FPS:  %.1f \nLoad: %.1f%% ", fps, load);
      if(polys >= 1ul)
      {
        const char *s = "";
        strcat(st->string, "\nPolys: ");
        if(polys >= 1000000ul)
        {
          return_value_strlen_2=strlen(st->string);
          sprintf(st->string + (signed long int)return_value_strlen_2, "%lu,%03lu,%03lu%s ", polys / (unsigned long int)1000000, (polys / (unsigned long int)1000) % (unsigned long int)1000, polys % (unsigned long int)1000, s);
        }

        else
          if(polys >= 1000ul)
          {
            return_value_strlen_3=strlen(st->string);
            sprintf(st->string + (signed long int)return_value_strlen_3, "%lu,%03lu%s ", polys / (unsigned long int)1000, polys % (unsigned long int)1000, s);
          }

          else
          {
            return_value_strlen_4=strlen(st->string);
            sprintf(st->string + (signed long int)return_value_strlen_4, "%lu%s ", polys, s);
          }
      }

      if(depth >= 0.0)
      {
        unsigned long int L;
        L=strlen(st->string);
        char *fps_compute__1__2__2__s = st->string + (signed long int)L;
        strcat(fps_compute__1__2__2__s, "\nDepth: ");
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(fps_compute__1__2__2__s);
        sprintf(fps_compute__1__2__2__s + (signed long int)return_value_strlen_5, "%.1f", depth);
        L=strlen(fps_compute__1__2__2__s);
        if((signed int)fps_compute__1__2__2__s[-2l + (signed long int)L] == 46)
        {
          if((signed int)fps_compute__1__2__2__s[-1l + (signed long int)L] == 48)
            fps_compute__1__2__2__s[(signed long int)(L - (unsigned long int)2)] = (char)0;

        }

      }

    }

    return st->last_fps;
  }
}

// fps_draw
// file fps.h line 26
extern void fps_draw(struct fps_state *st)
{
  struct anonymous_17 xgwa;
  const char *string = st->string;
  const char *s;
  signed int x = st->x;
  signed int y = st->y;
  signed int lines = 1;
  signed int lh = st->font->ascent + st->font->descent;
  XGetWindowAttributes(st->dpy, st->window, &xgwa);
  s = string;
  for( ; !(*s == 0); s = s + 1l)
    if((signed int)*s == 10)
      lines = lines + 1;

  if(!(y >= 0))
    y = -y + (lines - 1) * lh;

  else
    y = xgwa.height - y;
  y = y - (lh * (lines - 1) + st->font->descent);
  if(!(st->clear_p == 0))
  {
    signed int w;
    signed int h;
    w=string_width(st->font, string, &h);
    XFillRectangle(st->dpy, st->window, st->erase_gc, x - st->font->descent, y - lh, (unsigned int)(w + 2 * st->font->descent), (unsigned int)(h + 2 * st->font->descent));
  }

  unsigned long int return_value_strlen_1;
  while(!(lines == 0))
  {
    s=strchr(string, 10);
    if(s == ((const char *)NULL))
    {
      return_value_strlen_1=strlen(string);
      s = string + (signed long int)return_value_strlen_1;
    }

    XDrawString(st->dpy, st->window, st->draw_gc, x, y, string, (signed int)(s - string));
    string = s;
    string = string + 1l;
    lines = lines - 1;
    y = y + lh;
  }
}

// fps_free
// file fps.h line 23
extern void fps_free(struct fps_state *st)
{
  if(!(st->draw_gc == ((struct _XGC *)NULL)))
    XFreeGC(st->dpy, st->draw_gc);

  if(!(st->erase_gc == ((struct _XGC *)NULL)))
    XFreeGC(st->dpy, st->erase_gc);

  if(!(st->font == ((struct anonymous_1 *)NULL)))
    XFreeFont(st->dpy, st->font);

  free((void *)st);
}

// fps_init
// file fps.h line 22
extern struct fps_state * fps_init(struct _XDisplay *dpy, unsigned long int window)
{
  struct fps_state *st;
  const char *font;
  struct anonymous_1 *f;
  signed int return_value_get_boolean_resource_1;
  return_value_get_boolean_resource_1=get_boolean_resource(dpy, "doFPS", "DoFPS");
  if(return_value_get_boolean_resource_1 == 0)
    return ((struct fps_state *)NULL);

  else
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct fps_state) /*1152ul*/ );
    st = (struct fps_state *)return_value_calloc_2;
    st->dpy = dpy;
    st->window = window;
    st->clear_p=get_boolean_resource(dpy, "fpsSolid", "FPSSolid");
    font=get_string_resource(dpy, "fpsFont", "Font");
    if(font == ((const char *)NULL))
      font = "-*-courier-bold-r-normal-*-180-*";

    f=XLoadQueryFont(dpy, font);
    if(f == ((struct anonymous_1 *)NULL))
      f=XLoadQueryFont(dpy, "fixed");

    struct anonymous_17 xgwa;
    struct anonymous_8 gcv;
    XGetWindowAttributes(dpy, window, &xgwa);
    gcv.font = f->fid;
    unsigned int return_value_get_pixel_resource_3;
    return_value_get_pixel_resource_3=get_pixel_resource(st->dpy, xgwa.colormap, "foreground", "Foreground");
    gcv.foreground = (unsigned long int)return_value_get_pixel_resource_3;
    st->draw_gc=XCreateGC(dpy, window, (unsigned long int)(1L << 14 | 1L << 2), &gcv);
    unsigned int return_value_get_pixel_resource_4;
    return_value_get_pixel_resource_4=get_pixel_resource(st->dpy, xgwa.colormap, "background", "Background");
    gcv.foreground = (unsigned long int)return_value_get_pixel_resource_4;
    st->erase_gc=XCreateGC(dpy, window, (unsigned long int)(1L << 14 | 1L << 2), &gcv);
    st->font = f;
    st->x = 10;
    st->y = 10;
    signed int return_value_get_boolean_resource_5;
    return_value_get_boolean_resource_5=get_boolean_resource(dpy, "fpsTop", "FPSTop");
    if(!(return_value_get_boolean_resource_5 == 0))
      st->y = -(st->font->ascent + st->font->descent + 10);

    strcpy(st->string, "FPS: ... ");
    return st;
  }
}

// fps_slept
// file fps.h line 24
extern void fps_slept(struct fps_state *st, unsigned long int usecs)
{
  st->slept = st->slept + usecs;
}

// free_colors
// file colors.c line 25
extern void free_colors(struct anonymous_15 *screen, unsigned long int cmap, struct anonymous_27 *colors, signed int ncolors)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_15 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int i;
  if(ncolors >= 1)
  {
    unsigned long int *pixels;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)ncolors);
    pixels = (unsigned long int *)return_value_malloc_2;
    i = 0;
    for( ; !(i >= ncolors); i = i + 1)
      pixels[(signed long int)i] = (colors + (signed long int)i)->pixel;
    XFreeColors(dpy, cmap, pixels, ncolors, (unsigned long int)0L);
    free((void *)pixels);
  }

}

// free_rotator
// file rotator.c line 196
extern void free_rotator(struct rotator *r)
{
  free((void *)r);
}

// free_texture_font
// file texfont.c line 925
extern void free_texture_font(struct texture_font_data *data)
{
  while(!(data->cache == ((struct texfont_cache *)NULL)))
  {
    struct texfont_cache *next = data->cache->next;
    glDeleteTextures(1, &data->cache->texid);
    free((void *)data->cache);
    data->cache = next;
  }
  if(!(data->xftfont == ((struct _XftFont *)NULL)))
    XftFontClose(data->dpy, data->xftfont);

  free((void *)data);
}

// generate_molecule_formula
// file molecule.c line 951
static void generate_molecule_formula(struct anonymous_30 *m)
{
  char *buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(m->natoms * 10));
  buf = (char *)return_value_malloc_1;
  char *s = buf;
  signed int i;
  struct anonymous_37 counts[200l];
  memset((void *)counts, 0, sizeof(struct anonymous_37 [200l]) /*3200ul*/ );
  *s = (char)0;
  i = 0;
  const unsigned short int **return_value___ctype_b_loc_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  signed int return_value_strcmp_4;
  for( ; !(i >= m->natoms); i = i + 1)
  {
    signed int j = 0;
    char *generate_molecule_formula__1__1__a = (char *)(m->atoms + (signed long int)i)->label;
    char *e;
    do
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*generate_molecule_formula__1__1__a]) == 0))
        break;

      generate_molecule_formula__1__1__a = generate_molecule_formula__1__1__a + 1l;
    }
    while((_Bool)1);
    generate_molecule_formula__1__1__a=strdup(generate_molecule_formula__1__1__a);
    e = generate_molecule_formula__1__1__a;
    do
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if((1024 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*e]) == 0)
        break;

      e = e + 1l;
    }
    while((_Bool)1);
    *e = (char)0;
    for( ; !(counts[(signed long int)j].atom == ((char *)NULL)); j = j + 1)
    {
      return_value_strcmp_4=strcmp(generate_molecule_formula__1__1__a, counts[(signed long int)j].atom);
      if(return_value_strcmp_4 == 0)
        break;

    }
    if(!(counts[(signed long int)j].atom == ((char *)NULL)))
      free((void *)generate_molecule_formula__1__1__a);

    else
      counts[(signed long int)j].atom = generate_molecule_formula__1__1__a;
    counts[(signed long int)j].count = counts[(signed long int)j].count + 1;
  }
  i = 0;
  for( ; !(counts[(signed long int)i].atom == ((char *)NULL)); i = i + 1)
    ;
  qsort((void *)counts, (unsigned long int)i, sizeof(struct anonymous_37) /*16ul*/ , cmp_atoms);
  i = 0;
  while(!(counts[(signed long int)i].atom == ((char *)NULL)))
  {
    strcat(s, counts[(signed long int)i].atom);
    free((void *)counts[(signed long int)i].atom);
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(s);
    s = s + (signed long int)return_value_strlen_5;
    if(counts[(signed long int)i].count >= 2)
      sprintf(s, "[%d]", counts[(signed long int)i].count);

    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(s);
    s = s + (signed long int)return_value_strlen_6;
    i = i + 1;
  }
  special_case_formula(buf);
  if(m->label == ((const char *)NULL))
    m->label=strdup("");

  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(m->label);
  unsigned long int return_value_strlen_8;
  return_value_strlen_8=strlen(buf);
  void *return_value_malloc_9;
  return_value_malloc_9=malloc(return_value_strlen_7 + return_value_strlen_8 + (unsigned long int)2);
  s = (char *)return_value_malloc_9;
  strcpy(s, m->label);
  strcat(s, "\n");
  strcat(s, buf);
  free((void *)(char *)m->label);
  free((void *)buf);
  m->label = s;
}

// get_atom
// file molecule.c line 371
static struct anonymous_33 * get_atom(struct anonymous_33 *atoms, signed int natoms, signed int id)
{
  signed int i;
  if(!(id >= natoms))
  {
    if((atoms + (signed long int)id)->id == id)
      return &atoms[(signed long int)id];

    if(id >= 1)
    {
      if((atoms + (signed long int)(id + -1))->id == id)
        return &atoms[(signed long int)(id - 1)];

    }

    if(id >= natoms + -1)
      goto __CPROVER_DUMP_L3;

    if(!((atoms + (signed long int)(1 + id))->id == id))
      goto __CPROVER_DUMP_L3;

    return &atoms[(signed long int)(id + 1)];
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    i = 0;
    for( ; !(i >= natoms); i = i + 1)
      if(id == (atoms + (signed long int)i)->id)
        return &atoms[(signed long int)i];

    fprintf(stderr, "%s: no atom %d\n", progname, id);
    abort();
  }
}

// get_atom_data
// file molecule.c line 273
static const struct anonymous_35 * get_atom_data(const char *atom_name)
{
  signed int i;
  const struct anonymous_35 *d = ((const struct anonymous_35 *)NULL);
  char *n;
  n=strdup(atom_name);
  char *n2 = n;
  signed int L;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if(!((1024 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*n]) == 0))
      break;

    n = n + 1l;
  }
  while((_Bool)1);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(n);
  L = (signed int)return_value_strlen_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  for( ; L >= 1; n[(signed long int)L] = (char)0)
  {
    return_value___ctype_b_loc_3=__ctype_b_loc();
    if(!((1024 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)n[(signed long int)(L + -1)]]) == 0))
      break;

    L = L - 1;
  }
  i = 0;
  for( ; !((unsigned long int)i >= 9ul); i = i + 1)
  {
    d = &all_atom_data[(signed long int)i];
    signed int return_value_strcasecmp_4;
    return_value_strcasecmp_4=strcasecmp(n, all_atom_data[(signed long int)i].name);
    if(return_value_strcasecmp_4 == 0)
      break;

  }
  free((void *)n2);
  return d;
}

// get_bits_per_pixel
// file visual.c line 545
extern signed int get_bits_per_pixel(struct _XDisplay *dpy, signed int depth)
{
  unsigned int i = (unsigned int)0;
  signed int count;
  signed int result;
  struct anonymous_28 *formats;
  formats=XListPixmapFormats(dpy, &count);
  if(formats == ((struct anonymous_28 *)NULL))
    return 0;

  else
  {
    for( ; (_Bool)1; i = i + 1u)
    {
      if(i == (unsigned int)count)
      {
        result = 0;
        goto __CPROVER_DUMP_L4;
      }

      if((formats + (signed long int)i)->depth == depth)
      {
        result = (formats + (signed long int)i)->bits_per_pixel;
        break;
      }

    }

  __CPROVER_DUMP_L4:
    ;
    XFree((void *)formats);
    return result;
  }
}

// get_boolean_resource
// file ./../utils/resources.h line 16
extern signed int get_boolean_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  char *tmp;
  char buf[100l];
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *os = s;
  unsigned long int return_value_strlen_4;
  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_6;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_15;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    tmp = buf;
    for( ; !(*s == 0); s = s + 1l)
    {
      char *tmp_post_1 = tmp;
      tmp = tmp + 1l;
      _Bool tmp_if_expr_2;
      if((signed int)*s >= 65)
        tmp_if_expr_2 = (signed int)*s <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      signed int tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = ((signed int)*s - 65) + 97;

      else
        tmp_if_expr_3 = (signed int)*s;
      *tmp_post_1 = (char)tmp_if_expr_3;
    }
    *tmp = (char)0;
    free((void *)os);
    while(!(buf[0l] == 0))
    {
      return_value_strlen_4=strlen(buf);
      if(!((signed int)buf[-1l + (signed long int)return_value_strlen_4] == 32))
      {
        return_value_strlen_5=strlen(buf);
        if(!((signed int)buf[-1l + (signed long int)return_value_strlen_5] == 9))
          break;

      }

      return_value_strlen_6=strlen(buf);
      buf[(signed long int)(return_value_strlen_6 - (unsigned long int)1)] = (char)0;
    }
    signed int return_value_strcmp_7;
    return_value_strcmp_7=strcmp(buf, "on");
    _Bool tmp_if_expr_9;
    if(return_value_strcmp_7 == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strcmp_8=strcmp(buf, "true");
      tmp_if_expr_9 = !(return_value_strcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_11;
    if(tmp_if_expr_9)
      tmp_if_expr_11 = (_Bool)1;

    else
    {
      return_value_strcmp_10=strcmp(buf, "yes");
      tmp_if_expr_11 = !(return_value_strcmp_10 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_11)
      return 1;

    else
    {
      signed int return_value_strcmp_12;
      return_value_strcmp_12=strcmp(buf, "off");
      _Bool tmp_if_expr_14;
      if(return_value_strcmp_12 == 0)
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        return_value_strcmp_13=strcmp(buf, "false");
        tmp_if_expr_14 = !(return_value_strcmp_13 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_16;
      if(tmp_if_expr_14)
        tmp_if_expr_16 = (_Bool)1;

      else
      {
        return_value_strcmp_15=strcmp(buf, "no");
        tmp_if_expr_16 = !(return_value_strcmp_15 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_16)
        return 0;

      else
      {
        fprintf(stderr, "%s: %s must be boolean, not %s.\n", progname, res_name, (const void *)buf);
        return 0;
      }
    }
  }
}

// get_cache
// file texfont.c line 458
static struct texfont_cache * get_cache(struct texture_font_data *data, const char *string)
{
  signed int count = 0;
  struct texfont_cache *prev = ((struct texfont_cache *)NULL);
  struct texfont_cache *prev2 = ((struct texfont_cache *)NULL);
  struct texfont_cache *curr = ((struct texfont_cache *)NULL);
  struct texfont_cache *next = ((struct texfont_cache *)NULL);
  struct texfont_cache *tmp_if_expr_1;
  if(!(data->cache == ((struct texfont_cache *)NULL)))
  {
    prev2 = ((struct texfont_cache *)NULL);
    prev = ((struct texfont_cache *)NULL);
    curr = data->cache;
    next = curr->next;
    for( ; !(curr == ((struct texfont_cache *)NULL)); count = count + 1)
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(string, curr->string);
      if(return_value_strcmp_2 == 0)
      {
        if(!(prev == ((struct texfont_cache *)NULL)))
          prev->next = next;

        if(!(curr == data->cache))
        {
          curr->next = data->cache;
          data->cache = curr;
        }

        return curr;
      }

      prev2 = prev;
      prev = curr;
      curr = next;
      if(!(curr == ((struct texfont_cache *)NULL)))
        tmp_if_expr_1 = curr->next;

      else
        tmp_if_expr_1 = ((struct texfont_cache *)NULL);
      next = tmp_if_expr_1;
    }
  }

  if(!(data->cache_size >= count))
  {
    free((void *)prev->string);
    prev->string = ((char *)NULL);
    prev->tex_width = 0;
    prev->tex_height = 0;
    memset((void *)&prev->extents, 0, sizeof(struct anonymous_38) /*12ul*/ );
    if(!(prev2 == ((struct texfont_cache *)NULL)))
      prev2->next = ((struct texfont_cache *)NULL);

    if(!(prev == data->cache))
      prev->next = data->cache;

    data->cache = prev;
    return prev;
  }

  else
  {
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)1, sizeof(struct texfont_cache) /*40ul*/ );
    curr = (struct texfont_cache *)return_value_calloc_3;
    glGenTextures(1, &curr->texid);
    curr->string = ((char *)NULL);
    curr->next = data->cache;
    data->cache = curr;
    return curr;
  }
}

// get_float_resource
// file ./../../utils/resources.h line 18
extern double get_float_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  double val;
  char c;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  if(s == ((char *)NULL))
    return 0.0;

  else
  {
    signed int return_value___isoc99_sscanf_1;
    return_value___isoc99_sscanf_1=__isoc99_sscanf(s, " %lf %c", &val, &c);
    if(return_value___isoc99_sscanf_1 == 1)
    {
      free((void *)s);
      return val;
    }

    else
    {
      fprintf(stderr, "%s: %s must be a float, not %s.\n", progname, res_name, s);
      free((void *)s);
      return 0.0;
    }
  }
}

// get_gl_visual
// file ./../../utils/visual.h line 29
extern struct anonymous_16 * get_gl_visual(struct anonymous_15 *screen)
{
  struct _XDisplay *dpy = screen->display;
  signed int screen_num;
  screen_num=screen_number(screen);
  signed int attrs[21l][40l] = { { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0x80A8, 1, 0x80A9, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0x80A8, 1, 0x80A9, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0x80A8, 1, 0x80A9, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0x80A8, 1, 0x80A9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 12, 8, 5, 13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 4, 9, 4, 10, 4, 12, 4, 5, 13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 2, 9, 2, 10, 2, 12, 2, 5, 13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 12, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 4, 9, 4, 10, 4, 12, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 2, 9, 2, 10, 2, 12, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 4, 9, 4, 10, 4, 12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 2, 9, 2, 10, 2, 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 2, 8, 12, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 2, 4, 12, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 2, 8, 12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 2, 4, 12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 1, 9, 1, 10, 1, 12, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  signed int i = 0;
  signed int return_value_get_boolean_resource_1;
  return_value_get_boolean_resource_1=get_boolean_resource(dpy, "multiSample", "MultiSample");
  if(return_value_get_boolean_resource_1 == 0)
    i = 4;

  for( ; !((unsigned long int)i >= 21ul); i = i + 1)
  {
    struct anonymous_10 *vi;
    vi=glXChooseVisual(dpy, screen_num, attrs[(signed long int)i]);
    if(!(vi == ((struct anonymous_10 *)NULL)))
    {
      struct anonymous_16 *v = vi->visual;
      XFree((void *)vi);
      return v;
    }

  }
  return ((struct anonymous_16 *)NULL);
}

// get_integer_resource
// file ./../utils/resources.h line 17
extern signed int get_integer_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  signed int val;
  char c;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *ss = s;
  _Bool tmp_if_expr_3;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    for( ; !(*ss == 0); ss = ss + 1l)
      if((signed int)*ss >= 33)
        break;

    _Bool tmp_if_expr_4;
    if((signed int)*ss == 48)
    {
      if((signed int)ss[1l] == 120)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)ss[(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      signed int return_value___isoc99_sscanf_1;
      return_value___isoc99_sscanf_1=__isoc99_sscanf(ss + (signed long int)2, "%x %c", (unsigned int *)&val, &c);
      if(return_value___isoc99_sscanf_1 == 1)
      {
        free((void *)s);
        return val;
      }

    }

    else
    {
      signed int return_value___isoc99_sscanf_2;
      return_value___isoc99_sscanf_2=__isoc99_sscanf(ss, "%d %c", &val, &c);
      if(return_value___isoc99_sscanf_2 == 1)
      {
        free((void *)s);
        return val;
      }

    }
    fprintf(stderr, "%s: %s must be an integer, not %s.\n", progname, res_name, s);
    free((void *)s);
    return 0;
  }
}

// get_minutes_resource
// file resources.c line 261
extern unsigned int get_minutes_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  unsigned int return_value_get_time_resource_1;
  return_value_get_time_resource_1=get_time_resource(dpy, res_name, res_class, 0);
  return return_value_get_time_resource_1;
}

// get_pixel_resource
// file ./../utils/resources.h line 19
extern unsigned int get_pixel_resource(struct _XDisplay *dpy, unsigned long int cmap, char *res_name, char *res_class)
{
  struct anonymous_27 color;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *s2;
  signed int ok = 1;
  unsigned long int return_value_strlen_1;
  signed int return_value_XParseColor_3;
  signed int return_value_XAllocColor_4;
  unsigned long int return_value_strlen_6;
  signed int return_value_strcasecmp_7;
  if(!(s == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(s);
    s2 = (s + (signed long int)return_value_strlen_1) - (signed long int)1;
    for( ; !(s >= s2); s2 = s2 - 1l)
    {
      _Bool tmp_if_expr_2;
      if((signed int)*s2 == 32)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)*s2 == 9 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        *s2 = (char)0;

      else
        break;
    }
    return_value_XParseColor_3=XParseColor(dpy, cmap, s, &color);
    if(return_value_XParseColor_3 == 0)
    {
      fprintf(stderr, "%s: can't parse color %s", progname, s);
      ok = 0;
      goto DEFAULT;
    }

    return_value_XAllocColor_4=XAllocColor(dpy, cmap, &color);
    if(return_value_XAllocColor_4 == 0)
    {
      fprintf(stderr, "%s: couldn't allocate color %s", progname, s);
      ok = 0;
      goto DEFAULT;
    }

    free((void *)s);
    return (unsigned int)color.pixel;
  }

  else
  {

  DEFAULT:
    ;
    if(!(s == ((char *)NULL)))
      free((void *)s);

    signed int black_p;
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(res_class);
    _Bool tmp_if_expr_8;
    if(return_value_strlen_5 >= 10ul)
    {
      return_value_strlen_6=strlen(res_class);
      return_value_strcasecmp_7=strcasecmp("Background", (res_class + (signed long int)return_value_strlen_6) - (signed long int)10);
      tmp_if_expr_8 = !(return_value_strcasecmp_7 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    black_p = (signed int)tmp_if_expr_8;
    if(ok == 0)
      fprintf(stderr, ": using %s.\n", black_p != 0 ? "black" : "white");

    color.flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
    color.blue = (unsigned short int)(black_p != 0 ? 0 : 0xFFFF);
    color.green = color.blue;
    color.red = color.green;
    signed int return_value_XAllocColor_9;
    return_value_XAllocColor_9=XAllocColor(dpy, cmap, &color);
    if(!(return_value_XAllocColor_9 == 0))
      return (unsigned int)color.pixel;

    else
    {
      fprintf(stderr, "%s: couldn't allocate %s either!\n", progname, black_p != 0 ? "black" : "white");
      return (unsigned int)0;
    }
  }
}

// get_position
// file rotator.h line 53
extern void get_position(struct rotator *rot, double *x_ret, double *y_ret, double *z_ret, signed int update_p)
{
  double x = 0.5;
  double y = 0.5;
  double z = 0.5;
  if(IEEE_FLOAT_NOTEQUAL(rot->wander_speed, 0.000000))
  {
    if(!(update_p == 0))
      rot->wander_frame = rot->wander_frame + 1;

    double return_value_sin_1;
    return_value_sin_1=sin((((double)rot->wander_frame * 0.71 * rot->wander_speed) / (double)2) * 3.14159265358979323846);
    x = ((double)1 + return_value_sin_1) / 2.0;
    double return_value_sin_2;
    return_value_sin_2=sin((((double)rot->wander_frame * 0.53 * rot->wander_speed) / (double)2) * 3.14159265358979323846);
    y = ((double)1 + return_value_sin_2) / 2.0;
    double return_value_sin_3;
    return_value_sin_3=sin((((double)rot->wander_frame * 0.37 * rot->wander_speed) / (double)2) * 3.14159265358979323846);
    z = ((double)1 + return_value_sin_3) / 2.0;
  }

  if(!(x_ret == ((double *)NULL)))
    *x_ret = x;

  if(!(y_ret == ((double *)NULL)))
    *y_ret = y;

  if(!(z_ret == ((double *)NULL)))
    *z_ret = z;

}

// get_rotation
// file rotator.h line 44
extern void get_rotation(struct rotator *rot, double *x_ret, double *y_ret, double *z_ret, signed int update_p)
{
  double x;
  double y;
  double z;
  if(!(update_p == 0))
  {
    rotate_1(&rot->rotx, &rot->dx, &rot->ddx, rot->spin_x_speed, rot->d_max);
    rotate_1(&rot->roty, &rot->dy, &rot->ddy, rot->spin_y_speed, rot->d_max);
    rotate_1(&rot->rotz, &rot->dz, &rot->ddz, rot->spin_z_speed, rot->d_max);
  }

  x = rot->rotx;
  y = rot->roty;
  z = rot->rotz;
  if(x < 0.000000)
    x = (double)1 - (x + (double)1);

  if(y < 0.000000)
    y = (double)1 - (y + (double)1);

  if(z < 0.000000)
    z = (double)1 - (z + (double)1);

  if(!(x_ret == ((double *)NULL)))
    *x_ret = x;

  if(!(y_ret == ((double *)NULL)))
    *y_ret = y;

  if(!(z_ret == ((double *)NULL)))
    *z_ret = z;

}

// get_seconds_resource
// file resources.c line 255
extern unsigned int get_seconds_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  unsigned int return_value_get_time_resource_1;
  return_value_get_time_resource_1=get_time_resource(dpy, res_name, res_class, 1);
  return return_value_get_time_resource_1;
}

// get_string_resource
// file ./../utils/resources.h line 15
extern char * get_string_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  struct anonymous_24 value;
  char *type;
  char full_name[1024l];
  char full_class[1024l];
  strcpy(full_name, progname);
  strcat(full_name, ".");
  strcat(full_name, res_name);
  strcpy(full_class, progclass);
  strcat(full_class, ".");
  strcat(full_class, res_class);
  struct _XrmHashBucketRec *return_value_XtDatabase_2;
  return_value_XtDatabase_2=XtDatabase(dpy);
  signed int return_value_XrmGetResource_3;
  return_value_XrmGetResource_3=XrmGetResource(return_value_XtDatabase_2, full_name, full_class, &type, &value);
  if(!(return_value_XrmGetResource_3 == 0))
  {
    char *str;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(value.size + (unsigned int)1));
    str = (char *)return_value_malloc_1;
    strncpy(str, (char *)value.addr, (unsigned long int)value.size);
    str[(signed long int)value.size] = (char)0;
    return str;
  }

  return ((char *)NULL);
}

// get_time_resource
// file resources.c line 244
static unsigned int get_time_resource(struct _XDisplay *dpy, char *res_name, char *res_class, signed int sec_p)
{
  signed int val;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  if(s == ((char *)NULL))
    return (unsigned int)0;

  else
  {
    val=parse_time(s, sec_p, 0);
    free((void *)s);
    return (unsigned int)(val < 0 ? 0 : val);
  }
}

// get_visual
// file visual.c line 50
extern struct anonymous_16 * get_visual(struct anonymous_15 *screen, const char *string, signed int prefer_writable_cells, signed int verbose_p)
{
  char *v;
  char *tmp_if_expr_2;
  char *return_value_strdup_1;
  if(!(string == ((const char *)NULL)))
  {
    return_value_strdup_1=strdup(string);
    tmp_if_expr_2 = return_value_strdup_1;
  }

  else
    tmp_if_expr_2 = ((char *)NULL);
  v = tmp_if_expr_2;
  char c;
  char *tmp;
  signed int vclass;
  unsigned long int id;
  struct anonymous_16 *result = ((struct anonymous_16 *)NULL);
  if(!(v == ((char *)NULL)))
  {
    tmp = v;
    for( ; !(*tmp == 0); tmp = tmp + 1l)
      if((signed int)*tmp >= 65)
      {
        if(!((signed int)*tmp >= 91))
          *tmp = (char)(((signed int)*tmp - 65) + 97);

      }

  }

  _Bool tmp_if_expr_20;
  if(v == ((char *)NULL))
    tmp_if_expr_20 = (_Bool)1;

  else
    tmp_if_expr_20 = !(*v != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcmp_19;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_14;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value___isoc99_sscanf_4;
  signed int return_value___isoc99_sscanf_3;
  if(tmp_if_expr_20)
    vclass = -2;

  else
  {
    return_value_strcmp_19=strcmp(v, "default");
    if(return_value_strcmp_19 == 0)
      vclass = -1;

    else
    {
      return_value_strcmp_18=strcmp(v, "best");
      if(return_value_strcmp_18 == 0)
        vclass = -2;

      else
      {
        return_value_strcmp_17=strcmp(v, "mono");
        if(return_value_strcmp_17 == 0)
          vclass = -3;

        else
        {
          return_value_strcmp_16=strcmp(v, "monochrome");
          if(return_value_strcmp_16 == 0)
            vclass = -3;

          else
          {
            return_value_strcmp_15=strcmp(v, "gray");
            if(return_value_strcmp_15 == 0)
              vclass = -4;

            else
            {
              return_value_strcmp_14=strcmp(v, "grey");
              if(return_value_strcmp_14 == 0)
                vclass = -4;

              else
              {
                return_value_strcmp_13=strcmp(v, "color");
                if(return_value_strcmp_13 == 0)
                  vclass = -5;

                else
                {
                  return_value_strcmp_12=strcmp(v, "gl");
                  if(return_value_strcmp_12 == 0)
                    vclass = -6;

                  else
                  {
                    return_value_strcmp_11=strcmp(v, "staticgray");
                    if(return_value_strcmp_11 == 0)
                      vclass = 0;

                    else
                    {
                      return_value_strcmp_10=strcmp(v, "staticcolor");
                      if(return_value_strcmp_10 == 0)
                        vclass = 2;

                      else
                      {
                        return_value_strcmp_9=strcmp(v, "truecolor");
                        if(return_value_strcmp_9 == 0)
                          vclass = 4;

                        else
                        {
                          return_value_strcmp_8=strcmp(v, "grayscale");
                          if(return_value_strcmp_8 == 0)
                            vclass = 1;

                          else
                          {
                            return_value_strcmp_7=strcmp(v, "greyscale");
                            if(return_value_strcmp_7 == 0)
                              vclass = 1;

                            else
                            {
                              return_value_strcmp_6=strcmp(v, "pseudocolor");
                              if(return_value_strcmp_6 == 0)
                                vclass = 3;

                              else
                              {
                                return_value_strcmp_5=strcmp(v, "directcolor");
                                if(return_value_strcmp_5 == 0)
                                  vclass = 5;

                                else
                                {
                                  return_value___isoc99_sscanf_4=__isoc99_sscanf(v, " %lu %c", &id, &c);
                                  if(return_value___isoc99_sscanf_4 == 1)
                                    vclass = -7;

                                  else
                                  {
                                    return_value___isoc99_sscanf_3=__isoc99_sscanf(v, " 0x%lx %c", &id, &c);
                                    if(return_value___isoc99_sscanf_3 == 1)
                                      vclass = -7;

                                    else
                                    {
                                      fprintf(stderr, "%s: unrecognized visual \"%s\".\n", progname, v);
                                      vclass = -1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  signed int return_value_visual_depth_21;
  if(vclass == -1)
    result = screen->root_visual;

  else
    if(vclass == -2)
      result=pick_best_visual(screen, prefer_writable_cells, 0);

    else
      if(vclass == -3)
      {
        result=pick_mono_visual(screen);
        if(result == ((struct anonymous_16 *)NULL) && !(verbose_p == 0))
          fprintf(stderr, "%s: no monochrome visuals.\n", progname);

      }

      else
        if(vclass == -4)
        {
          if(!(prefer_writable_cells == 0))
            result=pick_best_visual_of_class(screen, 1);

          if(result == ((struct anonymous_16 *)NULL))
            result=pick_best_visual_of_class(screen, 0);

          if(result == ((struct anonymous_16 *)NULL))
            result=pick_best_visual_of_class(screen, 1);

          if(result == ((struct anonymous_16 *)NULL) && !(verbose_p == 0))
            fprintf(stderr, "%s: no GrayScale or StaticGray visuals.\n", progname);

        }

        else
          if(vclass == -5)
          {
            signed int class;
            result = screen->root_visual;
            class=visual_class(screen, result);
            if(!(class == 2) && !(class == 3) && !(class == 4) && !(class == 5))
              result = ((struct anonymous_16 *)NULL);

            if(!(result == ((struct anonymous_16 *)NULL)))
            {
              return_value_visual_depth_21=visual_depth(screen, result);
              if(!(return_value_visual_depth_21 >= 2))
                result = ((struct anonymous_16 *)NULL);

            }

            if(result == ((struct anonymous_16 *)NULL))
              result=pick_best_visual(screen, prefer_writable_cells, 1);

            if(result == ((struct anonymous_16 *)NULL) && !(verbose_p == 0))
              fprintf(stderr, "%s: no color visuals.\n", progname);

          }

          else
            if(vclass == -6)
            {
              struct anonymous_16 *visual;
              visual=pick_best_gl_visual(screen);
              if(!(visual == ((struct anonymous_16 *)NULL)))
                result = visual;

              else
                if(!(verbose_p == 0))
                  fprintf(stderr, "%s: no visual suitable for GL.\n", progname);

            }

            else
              if(vclass == -7)
              {
                result=id_to_visual(screen, (signed int)id);
                if(result == ((struct anonymous_16 *)NULL) && !(verbose_p == 0))
                  fprintf(stderr, "%s: no visual with id 0x%x.\n", progname, (unsigned int)id);

              }

              else
              {
                struct anonymous_16 *get_visual__1__7__visual;
                get_visual__1__7__visual=pick_best_visual_of_class(screen, vclass);
                if(!(get_visual__1__7__visual == ((struct anonymous_16 *)NULL)))
                  result = get_visual__1__7__visual;

                else
                  if(!(verbose_p == 0))
                    fprintf(stderr, "%s: no visual of class %s.\n", progname, v);

              }
  if(!(v == ((char *)NULL)))
    free((void *)v);

  return result;
}

// get_visual_resource
// file ./../utils/visual.h line 16
extern struct anonymous_16 * get_visual_resource(struct anonymous_15 *screen, char *name, char *class, signed int prefer_writable_cells)
{
  char *string;
  string=get_string_resource(screen->display, name, class);
  struct anonymous_16 *v;
  v=get_visual(screen, string, prefer_writable_cells, 1);
  if(!(string == ((char *)NULL)))
    free((void *)string);

  if(!(v == ((struct anonymous_16 *)NULL)))
    return v;

  else
    return screen->root_visual;
}

// gl_init
// file molecule.c line 1204
static void gl_init(struct ModeInfo *mi)
{
  static const float pos[4l] = { (const float)1.0, (const float)0.4, (const float)0.9, (const float)0.0 };
  glLightfv((unsigned int)0x4000, (unsigned int)0x1203, pos);
  static const float amb[4l] = { (const float)0.0, (const float)0.0, (const float)0.0, (const float)1.0 };
  glLightfv((unsigned int)0x4000, (unsigned int)0x1200, amb);
  static const float dif[4l] = { (const float)0.8, (const float)0.8, (const float)0.8, (const float)1.0 };
  glLightfv((unsigned int)0x4000, (unsigned int)0x1201, dif);
  static const float spc[4l] = { (const float)1.0, (const float)1.0, (const float)1.0, (const float)1.0 };
  glLightfv((unsigned int)0x4000, (unsigned int)0x1202, spc);
}

// gltrackball_dampen
// file gltrackball.c line 193
static void gltrackball_dampen(double *n, double *dn)
{
  signed int pos = (signed int)(*n > (double)0);
  *n = *n - *dn;
  if(!(pos == (signed int)(*n > 0.000000)))
  {
    *dn = (double)0;
    *n = *dn;
  }

}

// gltrackball_event_handler
// file gltrackball.h line 66
extern signed int gltrackball_event_handler(union _XEvent *event, struct trackball_state *ts, signed int window_width, signed int window_height, signed int *button_down_p)
{
  _Bool tmp_if_expr_6;
  if(event->xany.type == 4)
    tmp_if_expr_6 = event->xbutton.button == (unsigned int)1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_6 = (_Bool)0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_6)
  {
    *button_down_p = 1;
    gltrackball_start(ts, event->xbutton.x, event->xbutton.y, window_width, window_height);
    return 1;
  }

  else
  {
    _Bool tmp_if_expr_5;
    if(event->xany.type == 5)
      tmp_if_expr_5 = event->xbutton.button == (unsigned int)1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      *button_down_p = 0;
      gltrackball_stop(ts);
      return 1;
    }

    else
    {
      _Bool tmp_if_expr_4;
      if(event->xany.type == 4)
      {
        if(event->xbutton.button == 4u)
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = event->xbutton.button == (unsigned int)5 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = event->xbutton.button == (unsigned int)6 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = event->xbutton.button == (unsigned int)7 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        gltrackball_mousewheel(ts, (signed int)event->xbutton.button, 10, (signed int)!(!(event->xbutton.state != 0u)));
        return 1;
      }

      else
        if(event->xany.type == 6)
        {
          if(!(*button_down_p == 0))
          {
            gltrackball_track(ts, event->xmotion.x, event->xmotion.y, window_width, window_height);
            return 1;
          }

        }

    }
  }
  return 0;
}

// gltrackball_get_quaternion
// file gltrackball.c line 273
extern void gltrackball_get_quaternion(struct trackball_state *ts, float *q)
{
  signed int i = 0;
  for( ; !(i >= 4); i = i + 1)
    q[(signed long int)i] = ts->q[(signed long int)i];
}

// gltrackball_init
// file gltrackball.h line 21
extern struct trackball_state * gltrackball_init(signed int ignore_device_rotation_p)
{
  struct trackball_state *ts;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct trackball_state) /*80ul*/ );
  ts = (struct trackball_state *)return_value_calloc_1;
  if(ts == ((struct trackball_state *)NULL))
    return ((struct trackball_state *)NULL);

  else
  {
    ts->ignore_device_rotation_p = ignore_device_rotation_p;
    trackball(ts->q, (float)0, (float)0, (float)0, (float)0);
    return ts;
  }
}

// gltrackball_mousewheel
// file gltrackball.c line 237
void gltrackball_mousewheel(struct trackball_state *ts, signed int button, signed int percent, signed int flip_p)
{
  signed int up_p;
  signed int horizontal_p;
  signed int mx;
  signed int my;
  signed int move;
  signed int scale;
  switch(button)
  {
    case 4:
    {
      up_p = 1;
      horizontal_p = 0;
      break;
    }
    case 5:
    {
      up_p = 0;
      horizontal_p = 0;
      break;
    }
    case 6:
    {
      up_p = 1;
      horizontal_p = 1;
      break;
    }
    case 7:
    {
      up_p = 0;
      horizontal_p = 1;
      break;
    }
    default:
      abort();
  }
  if(!(flip_p == 0))
  {
    horizontal_p = (signed int)!(horizontal_p != 0);
    up_p = (signed int)!(up_p != 0);
  }

  my = 1000;
  mx = my;
  scale = mx;
  double tmp_if_expr_3;
  double return_value_floor_1;
  double return_value_ceil_2;
  if(!(up_p == 0))
  {
    return_value_floor_1=floor((double)scale * (1.0 - (double)percent / 100.0));
    tmp_if_expr_3 = return_value_floor_1;
  }

  else
  {
    return_value_ceil_2=ceil((double)scale * (1.0 + (double)percent / 100.0));
    tmp_if_expr_3 = return_value_ceil_2;
  }
  move = (signed int)tmp_if_expr_3;
  if(!(horizontal_p == 0))
    mx = move;

  else
    my = move;
  gltrackball_start(ts, scale, scale, scale * 2, scale * 2);
  gltrackball_track(ts, mx, my, scale * 2, scale * 2);
}

// gltrackball_reset
// file gltrackball.c line 77
extern void gltrackball_reset(struct trackball_state *ts)
{
  signed int bd = ts->button_down_p;
  signed int ig = ts->ignore_device_rotation_p;
  memset((void *)ts, 0, sizeof(struct trackball_state) /*80ul*/ );
  ts->button_down_p = bd;
  ts->ignore_device_rotation_p = ig;
  trackball(ts->q, (float)0, (float)0, (float)0, (float)0);
}

// gltrackball_rotate
// file gltrackball.h line 42
extern void gltrackball_rotate(struct trackball_state *ts)
{
  float m[4l][4l];
  if(ts->button_down_p == 0)
  {
    _Bool tmp_if_expr_1;
    if(IEEE_FLOAT_NOTEQUAL(ts->ddx, 0.000000))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = IEEE_FLOAT_NOTEQUAL(ts->ddy, (double)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      gltrackball_track_1(ts, ts->x + ts->dx, ts->y + ts->dy, ts->ow, ts->oh);
      gltrackball_dampen(&ts->dx, &ts->ddx);
      gltrackball_dampen(&ts->dy, &ts->ddy);
    }

  }

  build_rotmatrix(m, ts->q);
  glMultMatrixf(&m[(signed long int)0][(signed long int)0]);
}

// gltrackball_start
// file gltrackball.c line 128
extern void gltrackball_start(struct trackball_state *ts, signed int x, signed int y, signed int w, signed int h)
{
  ts->x = (double)x;
  ts->y = (double)y;
  ts->button_down_p = 1;
  ts->ddx = (double)0;
  ts->dx = ts->ddx;
  ts->ddy = (double)0;
  ts->dy = ts->ddy;
}

// gltrackball_stop
// file gltrackball.c line 140
extern void gltrackball_stop(struct trackball_state *ts)
{
  ts->button_down_p = 0;
}

// gltrackball_track
// file gltrackball.c line 179
extern void gltrackball_track(struct trackball_state *ts, signed int x, signed int y, signed int w, signed int h)
{
  double dampen = 0.01;
  ts->dx = (double)x - ts->x;
  ts->dy = (double)y - ts->y;
  ts->ddx = ts->dx * dampen;
  ts->ddy = ts->dy * dampen;
  ts->ow = w;
  ts->oh = h;
  gltrackball_track_1(ts, (double)x, (double)y, w, h);
}

// gltrackball_track_1
// file gltrackball.c line 146
static void gltrackball_track_1(struct trackball_state *ts, double x, double y, signed int w, signed int h)
{
  double X = x;
  double Y = y;
  double W = (double)w;
  double W2 = (double)w;
  double H = (double)h;
  double H2 = (double)h;
  float q2[4l];
  double ox = ts->x;
  double oy = ts->y;
  ts->x = x;
  ts->y = y;
  adjust_for_device_rotation(ts, &ox, &oy, &W, &H);
  adjust_for_device_rotation(ts, &X, &Y, &W2, &H2);
  trackball(q2, (float)(((double)2 * ox - W) / W), (float)((H - (double)2 * oy) / H), (float)(((double)2 * X - W) / W), (float)((H - (double)2 * Y) / H));
  add_quats(q2, ts->q, ts->q);
}

// hardware_concurrency
// file thread_util.c line 478
unsigned int hardware_concurrency(struct _XDisplay *dpy)
{
  signed int return_value_threads_available_2;
  return_value_threads_available_2=threads_available(dpy);
  unsigned int return_value__hardware_concurrency_1;
  if(return_value_threads_available_2 >= 0)
  {
    return_value__hardware_concurrency_1=_hardware_concurrency();
    return return_value__hardware_concurrency_1;
  }

  return (unsigned int)1;
}

// has_writable_cells
// file ./../utils/visual.h line 25
extern signed int has_writable_cells(struct anonymous_15 *screen, struct anonymous_16 *visual)
{
  signed int return_value_visual_class_1;
  return_value_visual_class_1=visual_class(screen, visual);
  switch(return_value_visual_class_1)
  {
    case 1:

    case 3:

    case 5:
      return 1;
    case 0:

    case 4:

    case 2:
      return 0;
    default:
    {
      abort();
      return 0;
    }
  }
}

// hsv_to_rgb
// file hsv.c line 20
extern void hsv_to_rgb(signed int h, double s, double v, unsigned short int *r, unsigned short int *g, unsigned short int *b)
{
  double H;
  double S;
  double V;
  double R;
  double G;
  double B;
  double p1;
  double p2;
  double p3;
  double f;
  signed int i;
  if(s < 0.000000)
    s = (double)0;

  if(v < 0.000000)
    v = (double)0;

  if(s > 1.000000)
    s = (double)1;

  if(v > 1.000000)
    v = (double)1;

  S = s;
  V = v;
  H = (double)(h % 360) / 60.0;
  i = (signed int)H;
  f = H - (double)i;
  p1 = V * ((double)1 - S);
  p2 = V * ((double)1 - S * f);
  p3 = V * ((double)1 - S * ((double)1 - f));
  if(i == 0)
  {
    R = V;
    G = p3;
    B = p1;
  }

  else
    if(i == 1)
    {
      R = p2;
      G = V;
      B = p1;
    }

    else
      if(i == 2)
      {
        R = p1;
        G = V;
        B = p3;
      }

      else
        if(i == 3)
        {
          R = p1;
          G = p2;
          B = V;
        }

        else
          if(i == 4)
          {
            R = p3;
            G = p1;
            B = V;
          }

          else
          {
            R = V;
            G = p1;
            B = p2;
          }
  *r = (unsigned short int)(R * (double)65535);
  *g = (unsigned short int)(G * (double)65535);
  *b = (unsigned short int)(B * (double)65535);
}

// id_to_visual
// file visual.c line 340
extern struct anonymous_16 * id_to_visual(struct anonymous_15 *screen, signed int id)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid = (unsigned long int)id;
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(!(vi_out == ((struct anonymous_10 *)NULL)))
  {
    struct anonymous_16 *v = (vi_out + (signed long int)0)->visual;
    XFree((void *)(char *)vi_out);
    return v;
  }

  return ((struct anonymous_16 *)NULL);
}

// init_GL
// file ./../xlockmoreI.h line 61
extern struct __GLXcontextRec ** init_GL(struct ModeInfo *mi)
{
  struct _XDisplay *dpy = mi->dpy;
  unsigned long int window = mi->window;
  struct anonymous_15 *screen = mi->xgwa.screen;
  struct anonymous_16 *visual = mi->xgwa.visual;
  struct __GLXcontextRec *glx_context = ((struct __GLXcontextRec *)NULL);
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_10 *)NULL))
    abort();

  XSync(dpy, 0);
  orig_ehandler=XSetErrorHandler(BadValue_ehandler);
  glx_context=glXCreateContext(dpy, vi_out, ((struct __GLXcontextRec *)NULL), 1);
  XSync(dpy, 0);
  XSetErrorHandler(orig_ehandler);
  if(!(got_error == 0))
    glx_context = ((struct __GLXcontextRec *)NULL);

  XFree((void *)(char *)vi_out);
  if(glx_context == ((struct __GLXcontextRec *)NULL))
  {
    unsigned long int return_value_XVisualIDFromVisual_1;
    return_value_XVisualIDFromVisual_1=XVisualIDFromVisual(visual);
    fprintf(stderr, "%s: couldn't create GL context for visual 0x%x.\n", progname, (unsigned int)return_value_XVisualIDFromVisual_1);
    exit(1);
  }

  glXMakeCurrent(dpy, window, glx_context);
  unsigned char rgba_mode = (unsigned char)0;
  glGetBooleanv((unsigned int)0x0C31, &rgba_mode);
  if(rgba_mode == 0)
  {
    glIndexi((signed int)screen->white_pixel);
    glClearIndex((float)screen->black_pixel);
  }

  unsigned char d = (unsigned char)0;
  glGetBooleanv((unsigned int)0x0C32, &d);
  if(!(d == 0))
    glDrawBuffer((unsigned int)0x0405);

  else
    glDrawBuffer((unsigned int)0x0404);
  clear_gl_error();
  char *s;
  s=get_string_resource(mi->dpy, "background", "Background");
  struct anonymous_27 c = { .pixel=(unsigned long int)0, .red=0, .green=0, .blue=0,
    .flags=0, .pad=0 };
  signed int return_value_XParseColor_2;
  return_value_XParseColor_2=XParseColor(dpy, mi->xgwa.colormap, s, &c);
  if(return_value_XParseColor_2 == 0)
    fprintf(stderr, "%s: can't parse color %s; using black.\n", progname, s);

  glClearColor((float)((double)c.red / 65535.0), (float)((double)c.green / 65535.0), (float)((double)c.blue / 65535.0), (float)1.0);
  glClear((unsigned int)(0x00004000 | 0x00000100));
  struct __GLXcontextRec **ptr;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(struct __GLXcontextRec *) /*8ul*/ );
  ptr = (struct __GLXcontextRec **)return_value_malloc_3;
  *ptr = glx_context;
  return ptr;
}

// init_molecule
// file molecule.c line 1274
static void init_molecule(struct ModeInfo *mi)
{
  struct anonymous_31 *mc;
  signed int wire;
  if(mcs == ((struct anonymous_31 *)NULL))
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)mi->num_screens, sizeof(struct anonymous_31) /*128ul*/ );
    mcs = (struct anonymous_31 *)return_value_calloc_1;
    if(mcs == ((struct anonymous_31 *)NULL))
    {
      fprintf(stderr, "%s: out of memory\n", progname);
      exit(1);
    }

  }

  mc = &mcs[(signed long int)mi->screen_number];
  mc->glx_context=init_GL(mi);
  if(!(mc->glx_context == ((struct __GLXcontextRec **)NULL)))
  {
    gl_init(mi);
    reshape_molecule(mi, mi->xgwa.width, mi->xgwa.height);
  }

  load_fonts(mi);
  startup_blurb(mi);
  wire = mi->wireframe_p;
  signed int spinx = 0;
  signed int spiny = 0;
  signed int spinz = 0;
  double spin_speed = 0.5;
  double spin_accel = 0.3;
  double wander_speed = 0.01;
  char *s = do_spin;
  for( ; !(*s == 0); s = s + 1l)
  {
    _Bool tmp_if_expr_4;
    if((signed int)*s == 120)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)*s == 88 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      spinx = 1;

    else
    {
      _Bool tmp_if_expr_3;
      if((signed int)*s == 121)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)*s == 89 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        spiny = 1;

      else
      {
        _Bool tmp_if_expr_2;
        if((signed int)*s == 122)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)*s == 90 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          spinz = 1;

        else
          if(!((signed int)*s == 48))
          {
            fprintf(stderr, "%s: spin must contain only the characters X, Y, or Z (not \"%s\")\n", progname, do_spin);
            exit(1);
          }

      }
    }
  }
  mc->rot=make_rotator(spinx != 0 ? spin_speed : (double)0, spiny != 0 ? spin_speed : (double)0, spinz != 0 ? spin_speed : (double)0, spin_accel, do_wander != 0 ? wander_speed : (double)0, (signed int)(spinx != 0 && spiny != 0 && spinz != 0));
  mc->trackball=gltrackball_init(1);
  orig_do_labels = do_labels;
  orig_do_atoms = do_atoms;
  orig_do_bonds = do_bonds;
  orig_do_shells = do_shells;
  orig_wire = mi->wireframe_p;
  mc->molecule_dlist=glGenLists(1);
  if(!(do_shells == 0))
    mc->shell_dlist=glGenLists(1);

  load_molecules(mi);
  unsigned int return_value_ya_random_5;
  return_value_ya_random_5=ya_random();
  mc->which = (signed int)(return_value_ya_random_5 % (unsigned int)mc->nmolecules);
  double return_value_get_float_resource_6;
  return_value_get_float_resource_6=get_float_resource(mi->dpy, "noLabelThreshold", "NoLabelThreshold");
  mc->no_label_threshold = (float)return_value_get_float_resource_6;
  double return_value_get_float_resource_7;
  return_value_get_float_resource_7=get_float_resource(mi->dpy, "wireframeThreshold", "WireframeThreshold");
  mc->wireframe_threshold = (float)return_value_get_float_resource_7;
  mc->mode = 0;
  if(!(wire == 0))
    do_bonds = 1;

}

// init_window
// file screenhack.c line 675
static void init_window(struct _XDisplay *dpy, struct _WidgetRec *toplevel, const char *title)
{
  unsigned long int window;
  struct anonymous_17 xgwa;
  XtPopup(toplevel, (enum anonymous_26)XtGrabNone);
  XtVaSetValues(toplevel, (char *)&XtShellStrings[(signed long int)356], title, (void *)0);
  window = toplevel->core.window;
  XGetWindowAttributes(dpy, window, &xgwa);
  XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 0 | 1L << 1 | 1L << 2 | 1L << 3);
  XChangeProperty(dpy, window, XA_WM_PROTOCOLS, (unsigned long int)4, 32, 0, (unsigned char *)&XA_WM_DELETE_WINDOW, 1);
}

// insert_vertical_whitespace
// file molecule.c line 1021
static void insert_vertical_whitespace(char *string)
{
  for( ; !(*string == 0); string = string + 1l)
  {
    _Bool tmp_if_expr_1;
    if((signed int)*string == 44)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)string[(signed long int)0] == 59 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_2;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)string[(signed long int)0] == 58 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      if((signed int)string[1l] == 32)
      {
        string[(signed long int)0] = (char)32;
        string[(signed long int)1] = (char)10;
      }

    }

  }
}

// io_thread_cancel
// file thread_util.h line 406
signed int io_thread_cancel(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status old_status;
    signed int return_value___atomic_exchange_n_1;
    return_value___atomic_exchange_n_1=__atomic_exchange_n(&self->status, _io_thread_cancelled, 5);
    old_status = (enum _io_thread_status)return_value___atomic_exchange_n_1;
    /* assertion old_status == _io_thread_working || old_status == _io_thread_done */
    assert((signed int)old_status == _io_thread_working || (signed int)old_status == _io_thread_done);
    signed int return_value_pthread_detach_2;
    return_value_pthread_detach_2=pthread_detach(self->thread);
    /* assertion !(pthread_detach(self->thread)) */
    assert(!(return_value_pthread_detach_2 != 0));
    return (signed int)((signed int)old_status != _io_thread_working);
  }

  return 0;
}

// io_thread_create
// file thread_util.h line 380
void * io_thread_create(struct io_thread *self, void *parent, void * (*start_routine)(void *), struct _XDisplay *dpy, unsigned int stacksize)
{
  signed int return_value_threads_available_4;
  return_value_threads_available_4=threads_available(dpy);
  signed int return_value_pthread_attr_destroy_3;
  if(return_value_threads_available_4 >= 0)
  {
    signed int error;
    union pthread_attr_t attr;
    union pthread_attr_t *attr_ptr = (union pthread_attr_t *)(void *)0;
    if(!(stacksize == 0u))
    {
      attr_ptr = &attr;
      signed int return_value_pthread_attr_init_1;
      return_value_pthread_attr_init_1=pthread_attr_init(&attr);
      if(!(return_value_pthread_attr_init_1 == 0))
        return (void *)0;

      /* assertion stacksize >= 16384 */
      assert(stacksize >= (unsigned int)16384);
      signed int return_value_pthread_attr_setstacksize_2;
      return_value_pthread_attr_setstacksize_2=pthread_attr_setstacksize(&attr, (unsigned long int)stacksize);
      /* assertion !(pthread_attr_setstacksize(&attr, stacksize)) */
      assert(!(return_value_pthread_attr_setstacksize_2 != 0));
    }

    self->status = (enum _io_thread_status)_io_thread_working;
    error=pthread_create(&self->thread, attr_ptr, start_routine, parent);
    /* assertion !error || error == 11 */
    assert(!(error != 0) || error == 11);
    if(!(error == 0))
      parent = (void *)0;

    if(!(attr_ptr == ((union pthread_attr_t *)NULL)))
    {
      return_value_pthread_attr_destroy_3=pthread_attr_destroy(attr_ptr);
      /* assertion !(pthread_attr_destroy(attr_ptr)) */
      assert(!(return_value_pthread_attr_destroy_3 != 0));
    }

    return parent;
  }

  return (void *)0;
}

// io_thread_finish
// file thread_util.h line 411
void io_thread_finish(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status status;
    signed int return_value___atomic_load_n_1;
    return_value___atomic_load_n_1=__atomic_load_n(&self->status, 5);
    status = (enum _io_thread_status)return_value___atomic_load_n_1;
    /* assertion status == _io_thread_working || status == _io_thread_done */
    assert((signed int)status == _io_thread_working || (signed int)status == _io_thread_done);
    signed int return_value_pthread_join_2;
    return_value_pthread_join_2=pthread_join(self->thread, (void **)(void *)0);
    /* assertion !(pthread_join(self->thread, ((void *)0))) */
    assert(!(return_value_pthread_join_2 != 0));
    signed int return_value___atomic_load_n_3;
    return_value___atomic_load_n_3=__atomic_load_n(&self->status, 5);
    /* assertion (__atomic_load_n((&self->status), 5)) == _io_thread_done */
    assert(return_value___atomic_load_n_3 == _io_thread_done);
  }

}

// io_thread_is_done
// file thread_util.h line 403
signed int io_thread_is_done(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    signed int result;
    result=__atomic_load_n(&self->status, 5);
    /* assertion result != _io_thread_cancelled */
    assert(result != _io_thread_cancelled);
    return result;
  }

  return 1;
}

// io_thread_return
// file thread_util.h line 399
signed int io_thread_return(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status old_status;
    signed int return_value___atomic_exchange_n_1;
    return_value___atomic_exchange_n_1=__atomic_exchange_n(&self->status, _io_thread_done, 5);
    old_status = (enum _io_thread_status)return_value___atomic_exchange_n_1;
    /* assertion old_status == _io_thread_working || old_status == _io_thread_cancelled */
    assert((signed int)old_status == _io_thread_working || (signed int)old_status == _io_thread_cancelled);
    return (signed int)((signed int)old_status != _io_thread_working);
  }

  return 0;
}

// iterate_texture_string
// file texfont.c line 340
static void iterate_texture_string(struct texture_font_data *data, const char *s, signed int draw_x, signed int draw_y, struct _XftDraw *xftdraw, struct _XftColor *xftcolor, struct anonymous_38 *metrics_ret)
{
  signed int line_height = data->xftfont->ascent + data->xftfont->descent;
  signed int subscript_offset = (signed int)((double)line_height * 0.3);
  const char *os = s;
  signed int sub_p = 0;
  signed int osub_p = 0;
  signed int cw = 0;
  signed int tabs = 0;
  struct anonymous_38 overall = { .lbearing=(signed short int)0, .rbearing=0, .width=0,
    .ascent=0, .descent=0, .attributes=0 };
  signed int x = 0;
  signed int y = 0;
  signed int ox = x;
  signed int oy = y;
  _Bool tmp_if_expr_6;
  const unsigned short int **return_value___ctype_b_loc_5;
  const unsigned short int **return_value___ctype_b_loc_1;
  while((_Bool)1)
  {
    _Bool tmp_if_expr_3;
    if((signed int)*s == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)*s == 10 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)*s == 9 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_7;
    if(tmp_if_expr_4)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      if((signed int)*s == 91)
      {
        return_value___ctype_b_loc_5=__ctype_b_loc();
        tmp_if_expr_6 = ((signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)s[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_6 = (_Bool)0;
      tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_8;
    if(tmp_if_expr_7)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = ((signed int)*s == 93 ? (sub_p != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
    {
      if(!(s == os))
      {
        struct _XGlyphInfo e;
        struct anonymous_38 c;
        signed int y2 = y;
        if(!(sub_p == 0))
          y2 = y2 + subscript_offset;

        XftTextExtentsUtf8(data->dpy, data->xftfont, (unsigned char *)os, (signed int)(s - os), &e);
        c.lbearing = (signed short int)-((signed int)e.x);
        c.rbearing = (signed short int)((signed int)e.width - (signed int)e.x);
        c.ascent = e.y;
        c.descent = (signed short int)((signed int)e.height - (signed int)e.y);
        c.width = e.xOff;
        overall.ascent = (signed short int)((signed int)overall.ascent > -y2 + (signed int)c.ascent ? (signed int)overall.ascent : -y2 + (signed int)c.ascent);
        overall.descent = (signed short int)((signed int)overall.descent > y2 + (signed int)c.descent ? (signed int)overall.descent : y2 + (signed int)c.descent);
        overall.lbearing = (signed short int)((signed int)overall.lbearing < x + (signed int)c.lbearing ? (signed int)overall.lbearing : x + (signed int)c.lbearing);
        overall.rbearing = (signed short int)((signed int)overall.rbearing > x + (signed int)c.rbearing ? (signed int)overall.rbearing : x + (signed int)c.rbearing);
        overall.width = (signed short int)((signed int)overall.width > x + (signed int)c.width ? (signed int)overall.width : x + (signed int)c.width);
        x = x + (signed int)c.width;
      }

      if((signed int)*s == 10)
      {
        x = 0;
        y = y + line_height;
        sub_p = 0;
      }

      else
        if((signed int)*s == 9)
        {
          if(cw == 0)
          {
            struct _XGlyphInfo iterate_texture_string__1__1__1__3__1__e;
            XftTextExtentsUtf8(data->dpy, data->xftfont, (unsigned char *)"m", 1, &iterate_texture_string__1__1__1__3__1__e);
            cw = (signed int)iterate_texture_string__1__1__1__3__1__e.xOff;
            if(!(cw >= 1))
              cw = 1;

            tabs = cw * 7;
          }

          x = ((x + tabs) / tabs) * tabs;
        }

        else
        {
          _Bool tmp_if_expr_2;
          if((signed int)*s == 91)
          {
            return_value___ctype_b_loc_1=__ctype_b_loc();
            tmp_if_expr_2 = ((signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)s[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
            sub_p = 1;

          else
            if((signed int)*s == 93)
            {
              if(!(sub_p == 0))
                sub_p = 0;

            }

        }
      if(!(s == os) && !(xftdraw == ((struct _XftDraw *)NULL)))
        XftDrawStringUtf8(xftdraw, xftcolor, data->xftfont, draw_x + ox, draw_y + oy + (osub_p != 0 ? subscript_offset : 0), (unsigned char *)os, (signed int)(s - os));

      if(*s == 0)
        break;

      os = s + (signed long int)1;
      ox = x;
      oy = y;
      osub_p = sub_p;
    }

    s = s + 1l;
  }
  if(!(metrics_ret == ((struct anonymous_38 *)NULL)))
    *metrics_ret = overall;

}

// load_fonts
// file molecule.c line 264
static void load_fonts(struct ModeInfo *mi)
{
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  mc->atom_font=load_texture_font(mi->dpy, "atomFont");
  mc->title_font=load_texture_font(mi->dpy, "titleFont");
}

// load_molecules
// file molecule.c line 1039
static void load_molecules(struct ModeInfo *mi)
{
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  signed int i;
  mc->nmolecules = 0;
  signed int return_value_strcmp_13;
  signed int return_value_strcasecmp_8;
  if(!(molecule_str == ((char *)NULL)))
  {
    if(!(*molecule_str == 0))
    {
      return_value_strcmp_13=strcmp(molecule_str, "(default)");
      if(!(return_value_strcmp_13 == 0))
      {
        signed int wire = mi->wireframe_p;
        struct stat st;
        signed int nfiles = 0;
        signed int list_size = 0;
        char **files = ((char **)NULL);
        signed int molecule_ctr;
        signed int return_value_stat_10;
        return_value_stat_10=stat(molecule_str, &st);
        if((61440u & st.st_mode) == 16384u && return_value_stat_10 == 0)
        {
          char buf[255l];
          struct __dirstream *pdb_dir;
          struct dirent *dentry;
          pdb_dir=opendir(molecule_str);
          if(pdb_dir == ((struct __dirstream *)NULL))
          {
            sprintf(buf, "%.100s: %.100s", progname, molecule_str);
            perror(buf);
            exit(1);
          }

          if(!(verbose_p == 0))
            fprintf(stderr, "%s: directory %s\n", progname, molecule_str);

          nfiles = 0;
          list_size = 100;
          void *return_value_calloc_1;
          return_value_calloc_1=calloc(sizeof(char *) /*8ul*/ , (unsigned long int)list_size);
          files = (char **)return_value_calloc_1;
          do
          {
            dentry=readdir(pdb_dir);
            if(dentry == ((struct dirent *)NULL))
              break;

            signed int L;
            unsigned long int return_value_strlen_2;
            return_value_strlen_2=strlen(dentry->d_name);
            L = (signed int)return_value_strlen_2;
            if(L >= 5)
            {
              return_value_strcasecmp_8=strcasecmp((dentry->d_name + (signed long int)L) - (signed long int)4, ".pdb");
              if(return_value_strcasecmp_8 == 0)
              {
                char *fn;
                if(nfiles >= list_size + -1)
                {
                  list_size = (signed int)((double)(list_size + 10) * 1.2);
                  void *return_value_realloc_3;
                  return_value_realloc_3=realloc((void *)files, (unsigned long int)list_size * sizeof(char *) /*8ul*/ );
                  files = (char **)return_value_realloc_3;
                  if(files == ((char **)NULL))
                  {

                  OOM:
                    ;
                    fprintf(stderr, "%s: out of memory (%d files)\n", progname, nfiles);
                    exit(1);
                  }

                }

                unsigned long int return_value_strlen_4;
                return_value_strlen_4=strlen(molecule_str);
                void *return_value_malloc_5;
                return_value_malloc_5=malloc(return_value_strlen_4 + (unsigned long int)L + (unsigned long int)10);
                fn = (char *)return_value_malloc_5;
                if(fn == ((char *)NULL))
                  goto OOM;

                strcpy(fn, molecule_str);
                unsigned long int return_value_strlen_6;
                return_value_strlen_6=strlen(fn);
                if(!((signed int)fn[-1l + (signed long int)return_value_strlen_6] == 47))
                  strcat(fn, "/");

                strcat(fn, dentry->d_name);
                signed int tmp_post_7 = nfiles;
                nfiles = nfiles + 1;
                files[(signed long int)tmp_post_7] = fn;
                if(!(verbose_p == 0))
                  fprintf(stderr, "%s: file %s\n", progname, fn);

              }

            }

          }
          while((_Bool)1);
          closedir(pdb_dir);
          if(nfiles == 0)
            fprintf(stderr, "%s: no .pdb files in directory %s\n", progname, molecule_str);

        }

        else
        {
          void *return_value_malloc_9;
          return_value_malloc_9=malloc(sizeof(char *) /*8ul*/ );
          files = (char **)return_value_malloc_9;
          nfiles = 1;
          files[(signed long int)0]=strdup(molecule_str);
          if(!(verbose_p == 0))
            fprintf(stderr, "%s: file %s\n", progname, molecule_str);

        }
        mc->nmolecules = nfiles;
        void *return_value_calloc_11;
        return_value_calloc_11=calloc(sizeof(struct anonymous_30) /*40ul*/ , (unsigned long int)mc->nmolecules);
        mc->molecules = (struct anonymous_30 *)return_value_calloc_11;
        molecule_ctr = 0;
        i = 0;
        for( ; !(i >= mc->nmolecules); i = i + 1)
        {
          if(!(verbose_p == 0))
            fprintf(stderr, "%s: reading %s\n", progname, files[(signed long int)i]);

          signed int return_value_parse_pdb_file_12;
          return_value_parse_pdb_file_12=parse_pdb_file(&mc->molecules[(signed long int)molecule_ctr], files[(signed long int)i]);
          if(return_value_parse_pdb_file_12 == 0)
          {
            if(do_labels == 0 && (do_atoms == 0 || !(wire == 0)))
            {
              if((mc->molecules + (signed long int)molecule_ctr)->nbonds == 0)
              {
                fprintf(stderr, "%s: %s: no bonds: turning -label on.\n", progname, files[(signed long int)i]);
                do_labels = 1;
              }

            }

            free((void *)files[(signed long int)i]);
            files[(signed long int)i] = ((char *)NULL);
            molecule_ctr = molecule_ctr + 1;
          }

        }
        free((void *)files);
        files = ((char **)NULL);
        mc->nmolecules = molecule_ctr;
      }

    }

  }

  if(mc->nmolecules == 0)
  {
    mc->nmolecules = (signed int)(sizeof(const char * const [38l]) /*304ul*/  / sizeof(const char *) /*8ul*/ );
    void *return_value_calloc_14;
    return_value_calloc_14=calloc(sizeof(struct anonymous_30) /*40ul*/ , (unsigned long int)mc->nmolecules);
    mc->molecules = (struct anonymous_30 *)return_value_calloc_14;
    i = 0;
    for( ; !(i >= mc->nmolecules); i = i + 1)
    {
      char name[100l];
      sprintf(name, "<builtin-%d>", i);
      if(!(verbose_p == 0))
        fprintf(stderr, "%s: reading %s\n", progname, (const void *)name);

      parse_pdb_data(&mc->molecules[(signed long int)i], builtin_pdb_data[(signed long int)i], name, 1);
    }
  }

  i = 0;
  for( ; !(i >= mc->nmolecules); i = i + 1)
  {
    generate_molecule_formula(&mc->molecules[(signed long int)i]);
    insert_vertical_whitespace((char *)(mc->molecules + (signed long int)i)->label);
  }
}

// load_texture_font
// file texfont.h line 21
extern struct texture_font_data * load_texture_font(struct _XDisplay *dpy, char *res)
{
  signed int screen = ((struct anonymous_42 *)dpy)->default_screen;
  char *font;
  font=get_string_resource(dpy, res, "Font");
  const char *def1 = "-*-helvetica-medium-r-normal-*-*-180-*-*-*-*-*-*";
  const char *def2 = "-*-helvetica-medium-r-normal-*-*-140-*-*-*-*-*-*";
  const char *def3 = "fixed";
  struct _XftFont *f = ((struct _XftFont *)NULL);
  struct texture_font_data *data;
  signed int cache_size;
  cache_size=get_integer_resource(dpy, "texFontCacheSize", "Integer");
  if(!(cache_size >= 1))
    cache_size = 30;

  _Bool tmp_if_expr_1;
  if(res == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*res != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    abort();

  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(res, "fpsFont");
  if(return_value_strcmp_2 == 0)
  {
    def1 = "-*-courier-bold-r-normal-*-*-140-*-*-*-*-*-*";
    cache_size = 0;
  }

  if(font == ((char *)NULL))
    font=strdup(def1);

  f=XftFontOpenXlfd(dpy, screen, font);
  signed int return_value_strcmp_3;
  if(f == ((struct _XftFont *)NULL))
  {
    return_value_strcmp_3=strcmp(font, def1);
    if(!(return_value_strcmp_3 == 0))
    {
      fprintf(stderr, "%s: unable to load font \"%s\", using \"%s\"\n", progname, font, def1);
      free((void *)font);
      font=strdup(def1);
      f=XftFontOpenXlfd(dpy, screen, font);
    }

  }

  signed int return_value_strcmp_4;
  if(f == ((struct _XftFont *)NULL))
  {
    return_value_strcmp_4=strcmp(font, def2);
    if(!(return_value_strcmp_4 == 0))
    {
      fprintf(stderr, "%s: unable to load font \"%s\", using \"%s\"\n", progname, font, def2);
      free((void *)font);
      font=strdup(def2);
      f=XftFontOpenXlfd(dpy, screen, font);
    }

  }

  signed int return_value_strcmp_5;
  if(f == ((struct _XftFont *)NULL))
  {
    return_value_strcmp_5=strcmp(font, def3);
    if(!(return_value_strcmp_5 == 0))
    {
      fprintf(stderr, "%s: unable to load font \"%s\", using \"%s\"\n", progname, font, def3);
      free((void *)font);
      font=strdup(def3);
      f=XftFontOpenXlfd(dpy, screen, font);
    }

  }

  if(f == ((struct _XftFont *)NULL))
  {
    fprintf(stderr, "%s: unable to load fallback font \"%s\" either!\n", progname, font);
    abort();
  }

  free((void *)font);
  font = ((char *)NULL);
  void *return_value_calloc_6;
  return_value_calloc_6=calloc((unsigned long int)1, sizeof(struct texture_font_data) /*32ul*/ );
  data = (struct texture_font_data *)return_value_calloc_6;
  data->dpy = dpy;
  data->xftfont = f;
  data->cache_size = cache_size;
  return data;
}

// main
// file screenhack.c line 696
signed int main(signed int argc, char **argv)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  struct anonymous_17 xgwa;
  struct _WidgetRec *toplevel;
  struct _XDisplay *dpy;
  unsigned long int window;
  unsigned long int window2 = (unsigned long int)0;
  struct _WidgetRec *toplevel2 = ((struct _WidgetRec *)NULL);
  struct _XtAppStruct *app;
  signed int root_p;
  unsigned long int on_window = (unsigned long int)0;
  union _XEvent event;
  char dont_clear;
  char version[255l];
  fix_fds();
  progname = argv[(signed long int)0];
  progclass = ft->progclass;
  if(!(ft->setup_cb == ((void (*)(struct xscreensaver_function_table *, void *))NULL)))
    ft->setup_cb(ft, ft->setup_arg);

  merge_options();
  toplevel=XtAppInitialize(&app, progclass, merged_options, (unsigned int)merged_options_size, &argc, argv, merged_defaults, ((struct anonymous_23 *)NULL), (unsigned int)0);
  dpy = toplevel->core.screen->display;
  XtGetApplicationNameAndClass(dpy, (char **)&progname, (char **)&progclass);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(progname);
  if(return_value_strlen_1 >= 100ul)
    ((char *)progname)[(signed long int)100] = (char)0;

  XSetErrorHandler(screenhack_ehandler);
  XA_WM_PROTOCOLS=XInternAtom(dpy, "WM_PROTOCOLS", 0);
  XA_WM_DELETE_WINDOW=XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
  char *v;
  char *return_value_strchr_2;
  return_value_strchr_2=strchr(screensaver_id, 32);
  char *return_value_strdup_3;
  return_value_strdup_3=strdup(return_value_strchr_2);
  v = (char *)return_value_strdup_3;
  char *s1;
  char *s2;
  char *s3;
  char *s4;
  const char *ot;
  ot=get_string_resource(dpy, "title", "Title");
  char *return_value_strchr_4;
  return_value_strchr_4=strchr(v, 32);
  s1 = (char *)return_value_strchr_4;
  s1 = s1 + 1l;
  char *return_value_strchr_5;
  return_value_strchr_5=strchr(s1, 32);
  s2 = (char *)return_value_strchr_5;
  char *return_value_strchr_6;
  return_value_strchr_6=strchr(v, 40);
  s3 = (char *)return_value_strchr_6;
  s3 = s3 + 1l;
  char *return_value_strchr_7;
  return_value_strchr_7=strchr(s3, 41);
  s4 = (char *)return_value_strchr_7;
  *s2 = (char)0;
  *s4 = (char)0;
  if(!(ot == ((const char *)NULL)))
  {
    if(*ot == 0)
      ot = ((const char *)NULL);

  }

  sprintf(version, "%.50s%s%s: from the XScreenSaver %s distribution (%s)", ot != ((const char *)NULL) ? ot : "", ot != ((const char *)NULL) ? ": " : "", progclass, s1, s3);
  free((void *)v);
  signed int return_value_strcmp_9;
  if(argc >= 2)
  {
    const char *main__1__2__s;
    signed int i;
    signed int x = 18;
    signed int end = 78;
    signed int help_p;
    signed int return_value_strcmp_8;
    return_value_strcmp_8=strcmp(argv[(signed long int)1], "-help");
    _Bool tmp_if_expr_10;
    if(return_value_strcmp_8 == 0)
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_strcmp_9=strcmp(argv[(signed long int)1], "--help");
      tmp_if_expr_10 = !(return_value_strcmp_9 != 0) ? (_Bool)1 : (_Bool)0;
    }
    help_p = (signed int)tmp_if_expr_10;
    fprintf(stderr, "%s\n", (const void *)version);
    main__1__2__s = progclass;
    for( ; !(*main__1__2__s == 0); main__1__2__s = main__1__2__s + 1l)
      fprintf(stderr, " ");
    fprintf(stderr, "  http://www.jwz.org/xscreensaver/\n\n");
    if(help_p == 0)
      fprintf(stderr, "Unrecognised option: %s\n", argv[(signed long int)1]);

    fprintf(stderr, "Options include: ");
    i = 0;
    for( ; !(i >= merged_options_size); i = i + 1)
    {
      char *sw = (merged_options + (signed long int)i)->option;
      signed int argp = (signed int)((signed int)(merged_options + (signed long int)i)->argKind == XrmoptionSepArg);
      signed int size;
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(sw);
      size = (signed int)(return_value_strlen_11 + (unsigned long int)(argp != 0 ? 6 : 0) + (unsigned long int)2);
      if(size + x >= end)
      {
        fprintf(stderr, "\n\t\t ");
        x = 18;
      }

      x = x + size;
      fprintf(stderr, "%s", sw);
      if(!(argp == 0))
        fprintf(stderr, " <arg>");

      if(!(i == merged_options_size + -1))
        fprintf(stderr, ", ");

    }
    fprintf(stderr, ".\n");
    exit(help_p != 0 ? 0 : 1);
  }

  char **s = merged_defaults;
  for( ; !(*s == ((char *)NULL)); s = s + 1l)
    free((void *)*s);
  free((void *)merged_options);
  free((void *)merged_defaults);
  merged_options = ((struct anonymous_18 *)NULL);
  merged_defaults = ((char **)NULL);
  signed int return_value_get_boolean_resource_12;
  return_value_get_boolean_resource_12=get_boolean_resource(dpy, "dontClearRoot", "Boolean");
  dont_clear = (char)return_value_get_boolean_resource_12;
  mono_p=get_boolean_resource(dpy, "mono", "Boolean");
  if(!((((struct anonymous_42 *)dpy)->screens + (signed long int)((struct anonymous_42 *)dpy)->default_screen)->root_visual->map_entries >= 3))
    mono_p = 1;

  root_p=get_boolean_resource(dpy, "root", "Boolean");
  char *main__1__4__s;
  main__1__4__s=get_string_resource(dpy, "windowID", "WindowID");
  signed int return_value_get_integer_resource_13;
  if(!(main__1__4__s == ((char *)NULL)))
  {
    if(!(*main__1__4__s == 0))
    {
      return_value_get_integer_resource_13=get_integer_resource(dpy, "windowID", "WindowID");
      on_window = (unsigned long int)return_value_get_integer_resource_13;
    }

  }

  if(!(main__1__4__s == ((char *)NULL)))
    free((void *)main__1__4__s);

  if(!(on_window == 0ul))
  {
    window = (unsigned long int)on_window;
    XtDestroyWidget(toplevel);
    XGetWindowAttributes(dpy, window, &xgwa);
    visual_warning(xgwa.screen, window, xgwa.visual, xgwa.colormap, 1);
    xgwa.your_event_mask = xgwa.your_event_mask | 1L << 0 | 1L << 17;
    XSelectInput(dpy, window, xgwa.your_event_mask);
    if((12l & xgwa.all_event_masks) == 0l)
      XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 2 | 1L << 3);

  }

  else
    if(!(root_p == 0))
    {
      window=VirtualRootWindowOfScreen(toplevel->core.screen);
      XtDestroyWidget(toplevel);
      XGetWindowAttributes(dpy, window, &xgwa);
      XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 17);
      visual_warning(xgwa.screen, window, xgwa.visual, xgwa.colormap, 0);
    }

    else
    {
      struct _WidgetRec *new;
      new=make_shell(toplevel->core.screen, toplevel, (signed int)toplevel->core.width, (signed int)toplevel->core.height);
      if(!(new == toplevel))
      {
        XtDestroyWidget(toplevel);
        toplevel = new;
      }

      init_window(dpy, toplevel, version);
      window = toplevel->core.window;
      XGetWindowAttributes(dpy, window, &xgwa);
      signed int return_value_get_boolean_resource_14;
      return_value_get_boolean_resource_14=get_boolean_resource(dpy, "pair", "Boolean");
      if(!(return_value_get_boolean_resource_14 == 0))
      {
        toplevel2=make_shell(xgwa.screen, ((struct _WidgetRec *)NULL), (signed int)toplevel->core.width, (signed int)toplevel->core.height);
        init_window(dpy, toplevel2, version);
        window2 = toplevel2->core.window;
      }

    }
  if(dont_clear == 0)
  {
    unsigned int bg;
    bg=get_pixel_resource(dpy, xgwa.colormap, "background", "Background");
    XSetWindowBackground(dpy, window, (unsigned long int)bg);
    XClearWindow(dpy, window);
    if(!(window2 == 0ul))
    {
      XSetWindowBackground(dpy, window2, (unsigned long int)bg);
      XClearWindow(dpy, window2);
    }

  }

  if(root_p == 0 && on_window == 0ul)
    XIfEvent(dpy, &event, MapNotify_event_p, (char *)window);

  XSync(dpy, 0);
  ya_rand_init((unsigned int)0);
  run_screenhack_table(dpy, window, window2, ft);
  XtDestroyWidget(toplevel);
  XtDestroyApplicationContext(app);
  return 0;
}

// make_color_loop
// file colors.c line 451
extern void make_color_loop(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, signed int h0, double s0, double v0, signed int h1, double s1, double v1, signed int h2, double s2, double v2, struct anonymous_27 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP)
{
  signed int wanted_writable;
  _Bool tmp_if_expr_1;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_1 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_1;
  signed int h[3l];
  double s[3l];
  double v[3l];
  h[(signed long int)0] = h0;
  h[(signed long int)1] = h1;
  h[(signed long int)2] = h2;
  s[(signed long int)0] = s0;
  s[(signed long int)1] = s1;
  s[(signed long int)2] = s2;
  v[(signed long int)0] = v0;
  v[(signed long int)1] = v1;
  v[(signed long int)2] = v2;
  signed int return_value_has_writable_cells_2;
  if(!(wanted_writable == 0))
  {
    return_value_has_writable_cells_2=has_writable_cells(screen, visual);
    if(return_value_has_writable_cells_2 == 0)
      *writable_pP = 0;

  }

  make_color_path(screen, visual, cmap, 3, h, s, v, colors, ncolorsP, allocate_p, writable_pP);
}

// make_color_path
// file colors.c line 224
static void make_color_path(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, signed int npoints, signed int *h, double *s, double *v, struct anonymous_27 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_15 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int i;
  signed int make_color_path__1__j;
  signed int k;
  signed int total_ncolors = *ncolorsP;
  signed int ncolors[50l];
  double dh[50l];
  double ds[50l];
  double dv[50l];
  if(npoints == 0)
  {
    *ncolorsP = 0;
    goto __CPROVER_DUMP_L40;
  }

  else
    if(npoints == 2)
    {
      make_color_ramp(screen, visual, cmap, h[(signed long int)0], s[(signed long int)0], v[(signed long int)0], h[(signed long int)1], s[(signed long int)1], v[(signed long int)1], colors, ncolorsP, 1, allocate_p, writable_pP);
      goto __CPROVER_DUMP_L40;
    }

    else
      if(npoints >= 50)
        npoints = 50 - 1;

  do
  {

  AGAIN:
    ;
    double DH[50l];
    double edge[50l];
    double ratio[50l];
    double circum = (double)0;
    double one_point_oh = (double)0;
    i = 0;
    for( ; !(i >= npoints); i = i + 1)
    {
      signed int j = (i + 1) % npoints;
      double d = (double)(h[(signed long int)i] - h[(signed long int)j]) / (double)360;
      if(d < 0.000000)
        d = -d;

      if(d > 0.5)
        d = 0.5 - (d - 0.5);

      DH[(signed long int)i] = d;
    }
    i = 0;
    for( ; !(i >= npoints); i = i + 1)
    {
      signed int make_color_path__1__4__2__j = (i + 1) % npoints;
      edge[(signed long int)i]=sqrt(DH[(signed long int)i] * DH[(signed long int)make_color_path__1__4__2__j] + (s[(signed long int)make_color_path__1__4__2__j] - s[(signed long int)i]) * (s[(signed long int)make_color_path__1__4__2__j] - s[(signed long int)i]) + (v[(signed long int)make_color_path__1__4__2__j] - v[(signed long int)i]) * (v[(signed long int)make_color_path__1__4__2__j] - v[(signed long int)i]));
      circum = circum + edge[(signed long int)i];
    }
    if(!(circum < 0.0001))
    {
      i = 0;
      for( ; !(i >= npoints); i = i + 1)
      {
        ratio[(signed long int)i] = edge[(signed long int)i] / circum;
        one_point_oh = one_point_oh + ratio[(signed long int)i];
      }
      if(one_point_oh < 0.99999 || one_point_oh > 1.00001)
        abort();

      i = 0;
      for( ; !(i >= npoints); i = i + 1)
        ncolors[(signed long int)i] = (signed int)((double)total_ncolors * ratio[(signed long int)i]);
      i = 0;
      for( ; !(i >= npoints); i = i + 1)
      {
        signed int make_color_path__1__4__4__j = (i + 1) % npoints;
        if(ncolors[(signed long int)i] >= 1)
        {
          dh[(signed long int)i] = (double)360 * (DH[(signed long int)i] / (double)ncolors[(signed long int)i]);
          ds[(signed long int)i] = (s[(signed long int)make_color_path__1__4__4__j] - s[(signed long int)i]) / (double)ncolors[(signed long int)i];
          dv[(signed long int)i] = (v[(signed long int)make_color_path__1__4__4__j] - v[(signed long int)i]) / (double)ncolors[(signed long int)i];
        }

      }
      memset((void *)colors, 0, (unsigned long int)*ncolorsP * sizeof(struct anonymous_27) /*16ul*/ );
      k = 0;
      i = 0;
      for( ; !(i >= npoints); i = i + 1)
      {
        signed int distance = h[(signed long int)((i + 1) % npoints)] - h[(signed long int)i];
        signed int direction = distance >= 0 ? -1 : 1;
        if(distance >= -180 && !(distance >= 181))
          direction = -direction;

        make_color_path__1__j = 0;
        for( ; !(make_color_path__1__j >= ncolors[(signed long int)i]); k = k + 1)
        {
          double hh = (double)h[(signed long int)i] + (double)make_color_path__1__j * dh[(signed long int)i] * (double)direction;
          if(hh < 0.000000)
            hh = hh + (double)360;

          else
            if(hh > 360.000000)
              hh = hh - (double)0;

          (colors + (signed long int)k)->flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
          hsv_to_rgb((signed int)hh, s[(signed long int)i] + (double)make_color_path__1__j * ds[(signed long int)i], v[(signed long int)i] + (double)make_color_path__1__j * dv[(signed long int)i], &(colors + (signed long int)k)->red, &(colors + (signed long int)k)->green, &(colors + (signed long int)k)->blue);
          make_color_path__1__j = make_color_path__1__j + 1;
        }
      }
      if(!(k >= *ncolorsP))
      {
        *ncolorsP = k;
        if(!(k >= 1))
          goto __CPROVER_DUMP_L40;

      }

      if(allocate_p == 0)
        goto __CPROVER_DUMP_L40;

      _Bool tmp_if_expr_5;
      if(!(writable_pP == ((signed int *)NULL)))
        tmp_if_expr_5 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
      {
        unsigned long int *pixels;
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)(*ncolorsP + 1));
        pixels = (unsigned long int *)return_value_malloc_2;
        signed int return_value_XAllocColorCells_3;
        return_value_XAllocColorCells_3=XAllocColorCells(dpy, cmap, 0, ((unsigned long int *)NULL), (unsigned int)0, pixels, (unsigned int)*ncolorsP);
        if(return_value_XAllocColorCells_3 == 0)
        {
          free((void *)pixels);
          goto FAIL;
        }

        i = 0;
        for( ; !(i >= *ncolorsP); i = i + 1)
          (colors + (signed long int)i)->pixel = pixels[(signed long int)i];
        free((void *)pixels);
        XStoreColors(dpy, cmap, colors, *ncolorsP);
      }

      else
      {
        i = 0;
        for( ; !(i >= *ncolorsP); i = i + 1)
        {
          struct anonymous_27 color = colors[(signed long int)i];
          signed int return_value_XAllocColor_4;
          return_value_XAllocColor_4=XAllocColor(dpy, cmap, &color);
          if(!(return_value_XAllocColor_4 == 0))
            (colors + (signed long int)i)->pixel = color.pixel;

          else
          {
            free_colors(screen, cmap, colors, i);
            goto FAIL;
          }
        }
      }
      goto __CPROVER_DUMP_L40;
    }


  FAIL:
    ;
    total_ncolors = total_ncolors > 170 ? total_ncolors - 20 : (total_ncolors > 100 ? total_ncolors - 10 : (total_ncolors > 75 ? total_ncolors - 5 : (total_ncolors > 25 ? total_ncolors - 3 : (total_ncolors > 10 ? total_ncolors - 2 : (total_ncolors > 2 ? total_ncolors - 1 : 0)))));
    *ncolorsP = total_ncolors;
  }
  while(total_ncolors >= 1);

__CPROVER_DUMP_L40:
  ;
}

// make_color_ramp
// file colors.c line 99
extern void make_color_ramp(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, signed int h1, double s1, double v1, signed int h2, double s2, double v2, struct anonymous_27 *colors, signed int *ncolorsP, signed int closed_p, signed int allocate_p, signed int *writable_pP)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_15 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int make_color_ramp__1__verbose_p = 1;
  signed int i;
  signed int total_ncolors = *ncolorsP;
  signed int ncolors;
  signed int wanted;
  signed int wanted_writable;
  _Bool tmp_if_expr_2;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_2 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_2;
  double dh;
  double ds;
  double dv;
  wanted = total_ncolors;
  if(!(closed_p == 0))
    wanted = wanted / 2 + 1;

  signed int return_value_has_writable_cells_3;
  if(!(wanted_writable == 0))
  {
    return_value_has_writable_cells_3=has_writable_cells(screen, visual);
    if(return_value_has_writable_cells_3 == 0)
      *writable_pP = 0;

  }

  do
  {

  AGAIN:
    ;
    ncolors = total_ncolors;
    memset((void *)colors, 0, (unsigned long int)*ncolorsP * sizeof(struct anonymous_27) /*16ul*/ );
    if(!(closed_p == 0))
      ncolors = ncolors / 2 + 1;

    dh = ((double)h2 - (double)h1) / (double)ncolors;
    ds = (s2 - s1) / (double)ncolors;
    dv = (v2 - v1) / (double)ncolors;
    i = 0;
    for( ; !(i >= ncolors); i = i + 1)
    {
      (colors + (signed long int)i)->flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
      hsv_to_rgb((signed int)((double)h1 + (double)i * dh), s1 + (double)i * ds, v1 + (double)i * dv, &(colors + (signed long int)i)->red, &(colors + (signed long int)i)->green, &(colors + (signed long int)i)->blue);
    }
    if(!(closed_p == 0))
    {
      i = ncolors;
      for( ; !(i >= *ncolorsP); i = i + 1)
        colors[(signed long int)i] = colors[(signed long int)(*ncolorsP - i)];
    }

    if(allocate_p == 0)
      goto __CPROVER_DUMP_L29;

    _Bool tmp_if_expr_7;
    if(!(writable_pP == ((signed int *)NULL)))
      tmp_if_expr_7 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
    {
      unsigned long int *pixels;
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)(*ncolorsP + 1));
      pixels = (unsigned long int *)return_value_malloc_4;
      signed int return_value_XAllocColorCells_5;
      return_value_XAllocColorCells_5=XAllocColorCells(dpy, cmap, 0, ((unsigned long int *)NULL), (unsigned int)0, pixels, (unsigned int)*ncolorsP);
      if(return_value_XAllocColorCells_5 == 0)
      {
        free((void *)pixels);
        goto FAIL;
      }

      i = 0;
      for( ; !(i >= *ncolorsP); i = i + 1)
        (colors + (signed long int)i)->pixel = pixels[(signed long int)i];
      free((void *)pixels);
      XStoreColors(dpy, cmap, colors, *ncolorsP);
    }

    else
    {
      i = 0;
      for( ; !(i >= *ncolorsP); i = i + 1)
      {
        struct anonymous_27 color = colors[(signed long int)i];
        signed int return_value_XAllocColor_6;
        return_value_XAllocColor_6=XAllocColor(dpy, cmap, &color);
        if(!(return_value_XAllocColor_6 == 0))
          (colors + (signed long int)i)->pixel = color.pixel;

        else
        {
          free_colors(screen, cmap, colors, i);
          goto FAIL;
        }
      }
    }
    break;

  FAIL:
    ;
    total_ncolors = total_ncolors > 170 ? total_ncolors - 20 : (total_ncolors > 100 ? total_ncolors - 10 : (total_ncolors > 75 ? total_ncolors - 5 : (total_ncolors > 25 ? total_ncolors - 3 : (total_ncolors > 10 ? total_ncolors - 2 : (total_ncolors > 2 ? total_ncolors - 1 : 0)))));
    *ncolorsP = total_ncolors;
    ncolors = total_ncolors;
  }
  while(total_ncolors >= 1);

WARN:
  ;
  if(!(make_color_ramp__1__verbose_p == 0) && (wanted_writable == 0 || !(ncolors == 0)))
  {
    _Bool tmp_if_expr_8;
    if(!(writable_pP == ((signed int *)NULL)) && !(wanted_writable == 0))
      tmp_if_expr_8 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_8 = (_Bool)0;
    complain(wanted, ncolors, wanted_writable, (signed int)tmp_if_expr_8);
  }


__CPROVER_DUMP_L29:
  ;
}

// make_random_colormap
// file ./../../utils/colors.h line 132
extern void make_random_colormap(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, struct anonymous_27 *colors, signed int *ncolorsP, signed int bright_p, signed int allocate_p, signed int *writable_pP, signed int verbose_p)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_15 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int wanted_writable;
  _Bool tmp_if_expr_2;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_2 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_2;
  signed int ncolors = *ncolorsP;
  signed int i;
  signed int return_value_has_writable_cells_3;
  signed int h0;
  signed int h1;
  double s0;
  double s1;
  double v0;
  double v1;
  double return_value_fabs_10;
  if(*ncolorsP >= 1)
  {
    if(!(wanted_writable == 0))
    {
      return_value_has_writable_cells_3=has_writable_cells(screen, visual);
      if(return_value_has_writable_cells_3 == 0)
        *writable_pP = 0;

    }

    do
    {

    RETRY_ALL:
      ;
      i = 0;
      for( ; !(i >= ncolors); i = i + 1)
      {
        (colors + (signed long int)i)->flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
        if(!(bright_p == 0))
        {
          signed int H;
          unsigned int return_value_ya_random_4;
          return_value_ya_random_4=ya_random();
          H = (signed int)(return_value_ya_random_4 % (unsigned int)360);
          double S;
          unsigned int return_value_ya_random_5;
          return_value_ya_random_5=ya_random();
          S = ((double)(return_value_ya_random_5 % (unsigned int)70) + (double)30) / 100.0;
          double V;
          unsigned int return_value_ya_random_6;
          return_value_ya_random_6=ya_random();
          V = ((double)(return_value_ya_random_6 % (unsigned int)34) + (double)66) / 100.0;
          hsv_to_rgb(H, S, V, &(colors + (signed long int)i)->red, &(colors + (signed long int)i)->green, &(colors + (signed long int)i)->blue);
        }

        else
        {
          unsigned int return_value_ya_random_7;
          return_value_ya_random_7=ya_random();
          (colors + (signed long int)i)->red = (unsigned short int)(return_value_ya_random_7 % (unsigned int)0xFFFF);
          unsigned int return_value_ya_random_8;
          return_value_ya_random_8=ya_random();
          (colors + (signed long int)i)->green = (unsigned short int)(return_value_ya_random_8 % (unsigned int)0xFFFF);
          unsigned int return_value_ya_random_9;
          return_value_ya_random_9=ya_random();
          (colors + (signed long int)i)->blue = (unsigned short int)(return_value_ya_random_9 % (unsigned int)0xFFFF);
        }
      }
      if(!(bright_p == 0) || ncolors >= 5)
        goto __CPROVER_DUMP_L12;

      rgb_to_hsv((colors + (signed long int)0)->red, (colors + (signed long int)0)->green, (colors + (signed long int)0)->blue, &h0, &s0, &v0);
      rgb_to_hsv((colors + (signed long int)1)->red, (colors + (signed long int)1)->green, (colors + (signed long int)1)->blue, &h1, &s1, &v1);
      return_value_fabs_10=fabs(v1 - v0);
    }
    while(return_value_fabs_10 < 0.5);

  __CPROVER_DUMP_L12:
    ;
    if(!(allocate_p == 0))
    {
      do
      {

      RETRY_NON_WRITABLE:
        ;
        _Bool tmp_if_expr_13;
        if(!(writable_pP == ((signed int *)NULL)))
          tmp_if_expr_13 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_13 = (_Bool)0;
        if(tmp_if_expr_13)
        {
          unsigned long int *pixels;
          void *return_value_malloc_11;
          return_value_malloc_11=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)(ncolors + 1));
          pixels = (unsigned long int *)return_value_malloc_11;
          allocate_writable_colors(screen, cmap, pixels, &ncolors);
          if(ncolors >= 1)
          {
            i = 0;
            for( ; !(i >= ncolors); i = i + 1)
              (colors + (signed long int)i)->pixel = pixels[(signed long int)i];
          }

          free((void *)pixels);
          if(ncolors >= 1)
            XStoreColors(dpy, cmap, colors, ncolors);

        }

        else
        {
          i = 0;
          for( ; !(i >= ncolors); i = i + 1)
          {
            struct anonymous_27 color = colors[(signed long int)i];
            signed int return_value_XAllocColor_12;
            return_value_XAllocColor_12=XAllocColor(dpy, cmap, &color);
            if(return_value_XAllocColor_12 == 0)
              break;

            (colors + (signed long int)i)->pixel = color.pixel;
          }
          ncolors = i;
        }
        if(!(ncolors == 0) || writable_pP == ((signed int *)NULL) || allocate_p == 0)
          break;

        if(*writable_pP == 0)
          break;

        ncolors = *ncolorsP;
        *writable_pP = 0;
      }
      while((_Bool)1);
      if(!(verbose_p == 0))
      {
        _Bool tmp_if_expr_14;
        if(!(wanted_writable == 0))
          tmp_if_expr_14 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_14 = (_Bool)0;
        complain(*ncolorsP, ncolors, wanted_writable, (signed int)tmp_if_expr_14);
      }

      *ncolorsP = ncolors;
    }

  }

}

// make_rotator
// file rotator.h line 32
extern struct rotator * make_rotator(double spin_x_speed, double spin_y_speed, double spin_z_speed, double spin_accel, double wander_speed, signed int randomize_initial_state_p)
{
  struct rotator *r;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct rotator) /*120ul*/ );
  r = (struct rotator *)return_value_calloc_1;
  double d;
  double dd;
  if(r == ((struct rotator *)NULL))
    return ((struct rotator *)NULL);

  else
  {
    if(spin_x_speed < 0.000000 || spin_y_speed < 0.000000 || spin_z_speed < 0.000000 || wander_speed < 0.000000)
      abort();

    r->spin_x_speed = spin_x_speed;
    r->spin_y_speed = spin_y_speed;
    r->spin_z_speed = spin_z_speed;
    r->wander_speed = wander_speed;
    if(!(randomize_initial_state_p == 0))
    {
      double tmp_statement_expression_2;
      double make_rotator__1__1__1__tmp;
      unsigned int return_value_ya_random_3;
      return_value_ya_random_3=ya_random();
      make_rotator__1__1__1__tmp = ((double)return_value_ya_random_3 * (double)1.0) / (double)(unsigned int)~0;
      tmp_statement_expression_2 = make_rotator__1__1__1__tmp < (double)0 ? -make_rotator__1__1__1__tmp : make_rotator__1__1__1__tmp;
      unsigned int return_value_ya_random_4;
      return_value_ya_random_4=ya_random();
      r->rotx = tmp_statement_expression_2 * (double)((return_value_ya_random_4 & (unsigned int)1) != 0u ? 1 : -1);
      double tmp_statement_expression_5;
      double make_rotator__1__1__2__tmp;
      unsigned int return_value_ya_random_6;
      return_value_ya_random_6=ya_random();
      make_rotator__1__1__2__tmp = ((double)return_value_ya_random_6 * (double)1.0) / (double)(unsigned int)~0;
      tmp_statement_expression_5 = make_rotator__1__1__2__tmp < (double)0 ? -make_rotator__1__1__2__tmp : make_rotator__1__1__2__tmp;
      unsigned int return_value_ya_random_7;
      return_value_ya_random_7=ya_random();
      r->roty = tmp_statement_expression_5 * (double)((return_value_ya_random_7 & (unsigned int)1) != 0u ? 1 : -1);
      double tmp_statement_expression_8;
      double make_rotator__1__1__3__tmp;
      unsigned int return_value_ya_random_9;
      return_value_ya_random_9=ya_random();
      make_rotator__1__1__3__tmp = ((double)return_value_ya_random_9 * (double)1.0) / (double)(unsigned int)~0;
      tmp_statement_expression_8 = make_rotator__1__1__3__tmp < (double)0 ? -make_rotator__1__1__3__tmp : make_rotator__1__1__3__tmp;
      unsigned int return_value_ya_random_10;
      return_value_ya_random_10=ya_random();
      r->rotz = tmp_statement_expression_8 * (double)((return_value_ya_random_10 & (unsigned int)1) != 0u ? 1 : -1);
      unsigned int return_value_ya_random_11;
      return_value_ya_random_11=ya_random();
      r->wander_frame = (signed int)(return_value_ya_random_11 % (unsigned int)0xFFFF);
    }

    else
    {
      r->rotz = (double)0;
      r->roty = r->rotz;
      r->rotx = r->roty;
      r->wander_frame = 0;
    }
    d = 0.006;
    dd = 0.00006;
    double tmp_statement_expression_12;
    double make_rotator__1__3__tmp;
    unsigned int return_value_ya_random_13;
    return_value_ya_random_13=ya_random();
    make_rotator__1__3__tmp = ((double)return_value_ya_random_13 * (double)(d * r->spin_x_speed)) / (double)(unsigned int)~0;
    tmp_statement_expression_12 = make_rotator__1__3__tmp < (double)0 ? -make_rotator__1__3__tmp : make_rotator__1__3__tmp;
    double tmp_statement_expression_14;
    double make_rotator__1__4__tmp;
    unsigned int return_value_ya_random_15;
    return_value_ya_random_15=ya_random();
    make_rotator__1__4__tmp = ((double)return_value_ya_random_15 * (double)(d * r->spin_x_speed)) / (double)(unsigned int)~0;
    tmp_statement_expression_14 = make_rotator__1__4__tmp < (double)0 ? -make_rotator__1__4__tmp : make_rotator__1__4__tmp;
    double tmp_statement_expression_16;
    double make_rotator__1__5__tmp;
    unsigned int return_value_ya_random_17;
    return_value_ya_random_17=ya_random();
    make_rotator__1__5__tmp = ((double)return_value_ya_random_17 * (double)(d * r->spin_x_speed)) / (double)(unsigned int)~0;
    tmp_statement_expression_16 = make_rotator__1__5__tmp < (double)0 ? -make_rotator__1__5__tmp : make_rotator__1__5__tmp;
    r->dx = (tmp_statement_expression_12 + tmp_statement_expression_14 + tmp_statement_expression_16) / (double)3;
    double tmp_statement_expression_18;
    double make_rotator__1__6__tmp;
    unsigned int return_value_ya_random_19;
    return_value_ya_random_19=ya_random();
    make_rotator__1__6__tmp = ((double)return_value_ya_random_19 * (double)(d * r->spin_y_speed)) / (double)(unsigned int)~0;
    tmp_statement_expression_18 = make_rotator__1__6__tmp < (double)0 ? -make_rotator__1__6__tmp : make_rotator__1__6__tmp;
    double tmp_statement_expression_20;
    double make_rotator__1__7__tmp;
    unsigned int return_value_ya_random_21;
    return_value_ya_random_21=ya_random();
    make_rotator__1__7__tmp = ((double)return_value_ya_random_21 * (double)(d * r->spin_y_speed)) / (double)(unsigned int)~0;
    tmp_statement_expression_20 = make_rotator__1__7__tmp < (double)0 ? -make_rotator__1__7__tmp : make_rotator__1__7__tmp;
    double tmp_statement_expression_22;
    double make_rotator__1__8__tmp;
    unsigned int return_value_ya_random_23;
    return_value_ya_random_23=ya_random();
    make_rotator__1__8__tmp = ((double)return_value_ya_random_23 * (double)(d * r->spin_y_speed)) / (double)(unsigned int)~0;
    tmp_statement_expression_22 = make_rotator__1__8__tmp < (double)0 ? -make_rotator__1__8__tmp : make_rotator__1__8__tmp;
    r->dy = (tmp_statement_expression_18 + tmp_statement_expression_20 + tmp_statement_expression_22) / (double)3;
    double tmp_statement_expression_24;
    double make_rotator__1__9__tmp;
    unsigned int return_value_ya_random_25;
    return_value_ya_random_25=ya_random();
    make_rotator__1__9__tmp = ((double)return_value_ya_random_25 * (double)(d * r->spin_z_speed)) / (double)(unsigned int)~0;
    tmp_statement_expression_24 = make_rotator__1__9__tmp < (double)0 ? -make_rotator__1__9__tmp : make_rotator__1__9__tmp;
    double tmp_statement_expression_26;
    double make_rotator__1__10__tmp;
    unsigned int return_value_ya_random_27;
    return_value_ya_random_27=ya_random();
    make_rotator__1__10__tmp = ((double)return_value_ya_random_27 * (double)(d * r->spin_z_speed)) / (double)(unsigned int)~0;
    tmp_statement_expression_26 = make_rotator__1__10__tmp < (double)0 ? -make_rotator__1__10__tmp : make_rotator__1__10__tmp;
    double tmp_statement_expression_28;
    double make_rotator__1__11__tmp;
    unsigned int return_value_ya_random_29;
    return_value_ya_random_29=ya_random();
    make_rotator__1__11__tmp = ((double)return_value_ya_random_29 * (double)(d * r->spin_z_speed)) / (double)(unsigned int)~0;
    tmp_statement_expression_28 = make_rotator__1__11__tmp < (double)0 ? -make_rotator__1__11__tmp : make_rotator__1__11__tmp;
    r->dz = (tmp_statement_expression_24 + tmp_statement_expression_26 + tmp_statement_expression_28) / (double)3;
    r->d_max = r->dx * (double)2;
    double tmp_statement_expression_30;
    double tmp;
    unsigned int return_value_ya_random_31;
    return_value_ya_random_31=ya_random();
    tmp = ((double)return_value_ya_random_31 * (double)(dd + dd)) / (double)(unsigned int)~0;
    tmp_statement_expression_30 = tmp < (double)0 ? -tmp : tmp;
    r->ddx = (dd + tmp_statement_expression_30) * r->spin_x_speed * spin_accel;
    double tmp_statement_expression_32;
    double make_rotator__1__13__tmp;
    unsigned int return_value_ya_random_33;
    return_value_ya_random_33=ya_random();
    make_rotator__1__13__tmp = ((double)return_value_ya_random_33 * (double)(dd + dd)) / (double)(unsigned int)~0;
    tmp_statement_expression_32 = make_rotator__1__13__tmp < (double)0 ? -make_rotator__1__13__tmp : make_rotator__1__13__tmp;
    r->ddy = (dd + tmp_statement_expression_32) * r->spin_y_speed * spin_accel;
    double tmp_statement_expression_34;
    double make_rotator__1__14__tmp;
    unsigned int return_value_ya_random_35;
    return_value_ya_random_35=ya_random();
    make_rotator__1__14__tmp = ((double)return_value_ya_random_35 * (double)(dd + dd)) / (double)(unsigned int)~0;
    tmp_statement_expression_34 = make_rotator__1__14__tmp < (double)0 ? -make_rotator__1__14__tmp : make_rotator__1__14__tmp;
    r->ddz = (dd + tmp_statement_expression_34) * r->spin_z_speed * spin_accel;
    return r;
  }
}

// make_shell
// file screenhack.c line 612
static struct _WidgetRec * make_shell(struct anonymous_15 *screen, struct _WidgetRec *toplevel, signed int width, signed int height)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_16 *visual;
  visual=pick_visual(screen);
  char def_visual_p;
  _Bool tmp_if_expr_1;
  if(!(toplevel == ((struct _WidgetRec *)NULL)))
    tmp_if_expr_1 = visual == screen->root_visual ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  def_visual_p = (char)tmp_if_expr_1;
  if(!(width >= 1))
    width = 600;

  if(!(height >= 1))
    height = 480;

  if(!(def_visual_p == 0))
  {
    unsigned long int window;
    XtVaSetValues(toplevel, (char *)&XtStrings[(signed long int)453], 0, (char *)&XtStrings[(signed long int)872], width, (char *)&XtStrings[(signed long int)234], height, (char *)&XtShellStrings[(signed long int)417], 1, (void *)0);
    XtRealizeWidget(toplevel);
    window = toplevel->core.window;
    signed int return_value_get_boolean_resource_2;
    return_value_get_boolean_resource_2=get_boolean_resource(dpy, "installColormap", "InstallColormap");
    if(!(return_value_get_boolean_resource_2 == 0))
    {
      unsigned long int cmap;
      cmap=XCreateColormap(dpy, window, screen->root_visual, 0);
      XSetWindowColormap(dpy, window, cmap);
    }

  }

  else
  {
    unsigned int bg;
    unsigned int bd;
    struct _WidgetRec *new;
    unsigned long int make_shell__1__2__cmap;
    unsigned long int return_value_VirtualRootWindowOfScreen_3;
    return_value_VirtualRootWindowOfScreen_3=VirtualRootWindowOfScreen(screen);
    make_shell__1__2__cmap=XCreateColormap(dpy, return_value_VirtualRootWindowOfScreen_3, visual, 0);
    bg=get_pixel_resource(dpy, make_shell__1__2__cmap, "background", "Background");
    bd=get_pixel_resource(dpy, make_shell__1__2__cmap, "borderColor", "Foreground");
    signed int return_value_visual_depth_4;
    return_value_visual_depth_4=visual_depth(screen, visual);
    new=XtVaAppCreateShell(progname, progclass, topLevelShellWidgetClass, dpy, (char *)&XtStrings[(signed long int)453], 0, (char *)&XtShellStrings[(signed long int)104], visual, (char *)&XtStrings[(signed long int)163], return_value_visual_depth_4, (char *)&XtStrings[(signed long int)872], width, (char *)&XtStrings[(signed long int)234], height, (char *)&XtStrings[(signed long int)154], make_shell__1__2__cmap, (char *)&XtStrings[(signed long int)52], (unsigned long int)bg, (char *)&XtStrings[(signed long int)87], (unsigned long int)bd, (char *)&XtShellStrings[(signed long int)417], 1, (void *)0);
    if(toplevel == ((struct _WidgetRec *)NULL))
      XtVaSetValues(new, (char *)&XtStrings[(signed long int)885], 0, (char *)&XtStrings[(signed long int)887], 550, (void *)0);

    XtRealizeWidget(new);
    toplevel = new;
  }
  return toplevel;
}

// make_smooth_colormap
// file ./../../utils/colors.h line 88
extern void make_smooth_colormap(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, struct anonymous_27 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP, signed int verbose_p)
{
  signed int npoints;
  signed int ncolors = *ncolorsP;
  signed int wanted_writable;
  _Bool tmp_if_expr_1;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_1 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_1;
  signed int i;
  signed int h[50l];
  double s[50l];
  double v[50l];
  double total_s = (double)0;
  double total_v = (double)0;
  signed int loop = 0;
  unsigned int return_value_ya_random_3;
  signed int j;
  double hi;
  double hj;
  double dh;
  double distance;
  signed int return_value_has_writable_cells_8;
  if(*ncolorsP >= 1)
  {
    signed int n;
    unsigned int return_value_ya_random_2;
    return_value_ya_random_2=ya_random();
    n = (signed int)(return_value_ya_random_2 % (unsigned int)20);
    if(!(n >= 6))
      npoints = 2;

    else
      if(!(n >= 16))
        npoints = 3;

      else
        if(!(n >= 19))
          npoints = 4;

        else
          npoints = 5;
    do
    {

    REPICK_ALL_COLORS:
      ;
      i = 0;
      for( ; !(i >= npoints); i = i + 1)
      {
        do
        {

        REPICK_THIS_COLOR:
          ;
          loop = loop + 1;
          if(loop >= 10001)
            abort();

          return_value_ya_random_3=ya_random();
          h[(signed long int)i] = (signed int)(return_value_ya_random_3 % (unsigned int)360);
          double tmp_statement_expression_4;
          double tmp;
          unsigned int return_value_ya_random_5;
          return_value_ya_random_5=ya_random();
          tmp = ((double)return_value_ya_random_5 * (double)1.0) / (double)(unsigned int)~0;
          tmp_statement_expression_4 = tmp < (double)0 ? -tmp : tmp;
          s[(signed long int)i] = tmp_statement_expression_4;
          double tmp_statement_expression_6;
          double make_smooth_colormap__1__2__2__tmp;
          unsigned int return_value_ya_random_7;
          return_value_ya_random_7=ya_random();
          make_smooth_colormap__1__2__2__tmp = ((double)return_value_ya_random_7 * (double)0.8) / (double)(unsigned int)~0;
          tmp_statement_expression_6 = make_smooth_colormap__1__2__2__tmp < (double)0 ? -make_smooth_colormap__1__2__2__tmp : make_smooth_colormap__1__2__2__tmp;
          v[(signed long int)i] = tmp_statement_expression_6 + 0.2;
          if(!(i >= 1))
            goto __CPROVER_DUMP_L14;

          j = i + 1 == npoints ? 0 : i - 1;
          hi = (double)h[(signed long int)i] / (double)360;
          hj = (double)h[(signed long int)j] / (double)360;
          dh = hj - hi;
          if(dh < 0.000000)
            dh = -dh;

          if(dh > 0.5)
            dh = 0.5 - (dh - 0.5);

          distance=sqrt(dh * dh + (s[(signed long int)j] - s[(signed long int)i]) * (s[(signed long int)j] - s[(signed long int)i]) + (v[(signed long int)j] - v[(signed long int)i]) * (v[(signed long int)j] - v[(signed long int)i]));
        }
        while(distance < 0.2);

      __CPROVER_DUMP_L14:
        ;
        total_s = total_s + s[(signed long int)i];
        total_v = total_v + v[(signed long int)i];
      }
      if(total_s / (double)npoints < 0.2)
        goto REPICK_ALL_COLORS;

    }
    while(total_v / (double)npoints < 0.3);
    if(!(wanted_writable == 0))
    {
      return_value_has_writable_cells_8=has_writable_cells(screen, visual);
      if(return_value_has_writable_cells_8 == 0)
        *writable_pP = 0;

    }

    do
    {

    RETRY_NON_WRITABLE:
      ;
      make_color_path(screen, visual, cmap, npoints, h, s, v, colors, &ncolors, allocate_p, writable_pP);
      if(allocate_p == 0)
        break;

      if(!(*ncolorsP == 0))
        break;

      if(writable_pP == ((signed int *)NULL))
        break;

      if(*writable_pP == 0)
        break;

      *writable_pP = 0;
    }
    while((_Bool)1);
    if(!(verbose_p == 0))
    {
      _Bool tmp_if_expr_9;
      if(!(wanted_writable == 0))
        tmp_if_expr_9 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_9 = (_Bool)0;
      complain(*ncolorsP, ncolors, wanted_writable, (signed int)tmp_if_expr_9);
    }

    *ncolorsP = ncolors;
  }

}

// make_uniform_colormap
// file ./../../utils/colors.h line 110
extern void make_uniform_colormap(struct anonymous_15 *screen, struct anonymous_16 *visual, unsigned long int cmap, struct anonymous_27 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP, signed int verbose_p)
{
  signed int ncolors = *ncolorsP;
  signed int wanted_writable;
  _Bool tmp_if_expr_1;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_1 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_1;
  double S;
  unsigned int return_value_ya_random_2;
  return_value_ya_random_2=ya_random();
  S = ((double)(return_value_ya_random_2 % (unsigned int)34) + (double)66) / 100.0;
  double V;
  unsigned int return_value_ya_random_3;
  return_value_ya_random_3=ya_random();
  V = ((double)(return_value_ya_random_3 % (unsigned int)34) + (double)66) / 100.0;
  signed int return_value_has_writable_cells_4;
  if(*ncolorsP >= 1)
  {
    if(!(wanted_writable == 0))
    {
      return_value_has_writable_cells_4=has_writable_cells(screen, visual);
      if(return_value_has_writable_cells_4 == 0)
        *writable_pP = 0;

    }

    do
    {

    RETRY_NON_WRITABLE:
      ;
      make_color_ramp(screen, visual, cmap, 0, S, V, 359, S, V, colors, &ncolors, 0, allocate_p, writable_pP);
      if(allocate_p == 0)
        break;

      if(!(*ncolorsP == 0))
        break;

      if(writable_pP == ((signed int *)NULL))
        break;

      if(*writable_pP == 0)
        break;

      ncolors = *ncolorsP;
      *writable_pP = 0;
    }
    while((_Bool)1);
    if(!(verbose_p == 0))
    {
      _Bool tmp_if_expr_5;
      if(!(wanted_writable == 0))
        tmp_if_expr_5 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      complain(*ncolorsP, ncolors, wanted_writable, (signed int)tmp_if_expr_5);
    }

    *ncolorsP = ncolors;
  }

}

// merge_options
// file screenhack.c line 182
static void merge_options(void)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  const struct anonymous_18 *options = ft->options;
  const char * const *defaults = ft->defaults;
  const char *merge_options__1__progclass = ft->progclass;
  signed int def_opts_size;
  signed int opts_size;
  signed int def_defaults_size;
  signed int defaults_size;
  def_opts_size = 0;
  for( ; !(default_options[(signed long int)def_opts_size].option == ((char *)NULL)); def_opts_size = def_opts_size + 1)
    ;
  opts_size = 0;
  for( ; !((options + (signed long int)opts_size)->option == ((char *)NULL)); opts_size = opts_size + 1)
    ;
  merged_options_size = def_opts_size + opts_size;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(merged_options_size + 1) * sizeof(struct anonymous_18) /*32ul*/ );
  merged_options = (struct anonymous_18 *)return_value_malloc_1;
  memcpy((void *)merged_options, (const void *)default_options, (unsigned long int)def_opts_size * sizeof(struct anonymous_18) /*32ul*/ );
  memcpy((void *)(merged_options + (signed long int)def_opts_size), (const void *)options, (unsigned long int)(opts_size + 1) * sizeof(struct anonymous_18) /*32ul*/ );
  def_defaults_size = 0;
  for( ; !(default_defaults[(signed long int)def_defaults_size] == ((char *)NULL)); def_defaults_size = def_defaults_size + 1)
    ;
  defaults_size = 0;
  for( ; !(defaults[(signed long int)defaults_size] == ((const char *)NULL)); defaults_size = defaults_size + 1)
    ;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(def_defaults_size + defaults_size + 1) * sizeof(const char *) /*8ul*/ );
  merged_defaults = (char **)return_value_malloc_2;
  memcpy((void *)merged_defaults, (const void *)default_defaults, (unsigned long int)def_defaults_size * sizeof(const char *) /*8ul*/ );
  memcpy((void *)(merged_defaults + (signed long int)def_defaults_size), (const void *)defaults, (unsigned long int)(defaults_size + 1) * sizeof(const char *) /*8ul*/ );
  char **s = merged_defaults;
  for( ; !(*s == ((char *)NULL)); s = s + 1l)
    if((signed int)*(*s) == 46)
    {
      const char *oldr = *s;
      char *newr;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(oldr);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(merge_options__1__progclass);
      void *return_value_malloc_5;
      return_value_malloc_5=malloc(return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)3);
      newr = (char *)return_value_malloc_5;
      strcpy(newr, merge_options__1__progclass);
      strcat(newr, oldr);
      *s = newr;
    }

    else
      *s=strdup(*s);
}

// molecule_bounding_box
// file molecule.c line 396
static void molecule_bounding_box(struct ModeInfo *mi, float *x1, float *y1, float *z1, float *x2, float *y2, float *z2)
{
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  struct anonymous_30 *m = &mc->molecules[(signed long int)mc->which];
  signed int i;
  if(m->natoms == 0)
  {
    *z2 = (float)0;
    *y2 = *z2;
    *x2 = *y2;
    *z1 = *x2;
    *y1 = *z1;
    *x1 = *y1;
  }

  else
  {
    *x2 = (m->atoms + (signed long int)0)->x;
    *x1 = *x2;
    *y2 = (m->atoms + (signed long int)0)->y;
    *y1 = *y2;
    *z2 = (m->atoms + (signed long int)0)->z;
    *z1 = *z2;
  }
  i = 1;
  for( ; !(i >= m->natoms); i = i + 1)
  {
    if((m->atoms + (signed long int)i)->x < *x1)
      *x1 = (m->atoms + (signed long int)i)->x;

    if((m->atoms + (signed long int)i)->y < *y1)
      *y1 = (m->atoms + (signed long int)i)->y;

    if((m->atoms + (signed long int)i)->z < *z1)
      *z1 = (m->atoms + (signed long int)i)->z;

    if((m->atoms + (signed long int)i)->x > *x2)
      *x2 = (m->atoms + (signed long int)i)->x;

    if((m->atoms + (signed long int)i)->y > *y2)
      *y2 = (m->atoms + (signed long int)i)->y;

    if((m->atoms + (signed long int)i)->z > *z2)
      *z2 = (m->atoms + (signed long int)i)->z;

  }
  *x1 = *x1 - (float)1.5;
  *y1 = *y1 - (float)1.5;
  *z1 = *z1 - (float)1.5;
  *x2 = *x2 + (float)1.5;
  *y2 = *y2 + (float)1.5;
  *z2 = *z2 + (float)1.5;
}

// molecule_handle_event
// file molecule.c line 1230
static signed int molecule_handle_event(struct ModeInfo *mi, union _XEvent *event)
{
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  signed int return_value_gltrackball_event_handler_2;
  return_value_gltrackball_event_handler_2=gltrackball_event_handler(event, mc->trackball, mi->xgwa.width, mi->xgwa.height, &mc->button_down_p);
  if(!(return_value_gltrackball_event_handler_2 == 0))
    return 1;

  else
  {
    if(event->xany.type == 2)
    {
      unsigned long int keysym;
      char c = (char)0;
      XLookupString(&event->xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
      if(keysym == 65361ul || keysym == 65362ul || keysym == 65365ul || (signed int)c == 44 || (signed int)c == 45 || (signed int)c == 60 || (signed int)c == 95)
      {
        mc->next = -1;
        goto SWITCH;
      }

      else
        if(keysym == 65363ul || keysym == 65364ul || keysym == 65366ul || (signed int)c == 43 || (signed int)c == 46 || (signed int)c == 61 || (signed int)c == 62)
        {
          mc->next = 1;
          goto SWITCH;
        }

    }

    signed int return_value_screenhack_event_helper_1;
    return_value_screenhack_event_helper_1=screenhack_event_helper(mi->dpy, mi->window, event);
    if(!(return_value_screenhack_event_helper_1 == 0))
    {

    SWITCH:
      ;
      mc->mode = 1;
      mc->mode_tick = 4;
      return 1;
    }

  }
  return 0;
}

// normalize_quat
// file trackball.c line 295
static void normalize_quat(float *q)
{
  signed int i;
  float mag = q[(signed long int)0] * q[(signed long int)0] + q[(signed long int)1] * q[(signed long int)1] + q[(signed long int)2] * q[(signed long int)2] + q[(signed long int)3] * q[(signed long int)3];
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    q[(signed long int)i] = q[(signed long int)i] / mag;
}

// parse_error
// file molecule.c line 680
static void parse_error(const char *file, signed int lineno, const char *line)
{
  fprintf(stderr, "%s: %s: parse error, line %d: %s\n", progname, file, lineno, line);
  exit(1);
}

// parse_pdb_data
// file molecule.c line 691
static void parse_pdb_data(struct anonymous_30 *m, const char *data, const char *filename, signed int line)
{
  const char *s = data;
  char *ss;
  signed int return_value_strncmp_105;
  _Bool tmp_if_expr_107;
  signed int return_value_strncmp_106;
  const unsigned short int **return_value___ctype_b_loc_3;
  const unsigned short int **return_value___ctype_b_loc_5;
  unsigned long int return_value_strlen_8;
  signed int return_value_strcmp_9;
  unsigned long int return_value_strlen_7;
  signed int return_value_strncmp_31;
  signed int return_value_strncmp_32;
  signed int return_value_strncmp_34;
  signed int return_value_strncmp_36;
  signed int return_value_strncmp_38;
  signed int return_value_strncmp_40;
  signed int return_value_strncmp_42;
  signed int return_value_strncmp_44;
  signed int return_value_strncmp_46;
  signed int return_value_strncmp_48;
  signed int return_value_strncmp_50;
  signed int return_value_strncmp_52;
  signed int return_value_strncmp_54;
  signed int return_value_strncmp_56;
  signed int return_value_strncmp_58;
  signed int return_value_strncmp_60;
  signed int return_value_strncmp_62;
  signed int return_value_strncmp_64;
  signed int return_value_strncmp_66;
  signed int return_value_strncmp_68;
  signed int return_value_strncmp_70;
  signed int return_value_strncmp_72;
  signed int return_value_strncmp_74;
  signed int return_value_strncmp_76;
  signed int return_value_strncmp_78;
  signed int return_value_strncmp_80;
  signed int return_value_strncmp_82;
  signed int return_value_strncmp_84;
  signed int return_value_strncmp_86;
  signed int return_value_strncmp_88;
  signed int return_value_strncmp_90;
  signed int return_value_strncmp_92;
  signed int return_value_strncmp_94;
  signed int return_value_strncmp_96;
  signed int return_value_strncmp_98;
  signed int return_value_strncmp_100;
  signed int return_value_strncmp_102;
  signed int return_value_strncmp_30;
  const unsigned short int **return_value___ctype_b_loc_13;
  const unsigned short int **return_value___ctype_b_loc_14;
  const unsigned short int **return_value___ctype_b_loc_16;
  signed int return_value_strncmp_29;
  const unsigned short int **return_value___ctype_b_loc_22;
  const unsigned short int **return_value___ctype_b_loc_24;
  signed int return_value_strncmp_28;
  _Bool tmp_if_expr_27;
  while(!(*s == 0))
  {
    _Bool tmp_if_expr_104;
    if(m->label == ((const char *)NULL))
      tmp_if_expr_104 = (_Bool)1;

    else
      tmp_if_expr_104 = !(*m->label != 0) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_108;
    if(tmp_if_expr_104)
    {
      return_value_strncmp_105=strncmp(s, "HEADER", (unsigned long int)6);
      if(return_value_strncmp_105 == 0)
        tmp_if_expr_107 = (_Bool)1;

      else
      {
        return_value_strncmp_106=strncmp(s, "COMPND", (unsigned long int)6);
        tmp_if_expr_107 = !(return_value_strncmp_106 != 0) ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_108 = tmp_if_expr_107 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_108 = (_Bool)0;
    if(tmp_if_expr_108)
    {
      char *name;
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)1, (unsigned long int)100);
      name = (char *)return_value_calloc_1;
      char *n2 = name;
      signed int L;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(s);
      L = (signed int)return_value_strlen_2;
      if(L >= 100)
        L = 99;

      strncpy(n2, s, (unsigned long int)L);
      n2 = n2 + (signed long int)7;
      do
      {
        return_value___ctype_b_loc_3=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*n2]) == 0)
          break;

        n2 = n2 + 1l;
      }
      while((_Bool)1);
      ss=strchr(n2, 10);
      if(!(ss == ((char *)NULL)))
        *ss = (char)0;

      ss=strchr(n2, 13);
      if(!(ss == ((char *)NULL)))
        *ss = (char)0;

      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(n2);
      ss = (n2 + (signed long int)return_value_strlen_4) - (signed long int)1;
      do
      {
        return_value___ctype_b_loc_5=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)*ss]) == 0)
          break;

        if(n2 >= ss)
          break;

        char *tmp_post_6 = ss;
        ss = ss - 1l;
        *tmp_post_6 = (char)0;
      }
      while((_Bool)1);
      unsigned long int return_value_strlen_10;
      return_value_strlen_10=strlen(n2);
      if(return_value_strlen_10 >= 5ul)
      {
        return_value_strlen_8=strlen(n2);
        return_value_strcmp_9=strcmp((n2 + (signed long int)return_value_strlen_8) - (signed long int)4, ".pdb");
        if(return_value_strcmp_9 == 0)
        {
          return_value_strlen_7=strlen(n2);
          n2[(signed long int)(return_value_strlen_7 - (unsigned long int)4)] = (char)0;
        }

      }

      if(!(m->label == ((const char *)NULL)))
        free((void *)(char *)m->label);

      m->label=strdup(n2);
      free((void *)name);
    }

    else
    {
      return_value_strncmp_31=strncmp(s, "TITLE ", (unsigned long int)6);
      _Bool tmp_if_expr_33;
      if(return_value_strncmp_31 == 0)
        tmp_if_expr_33 = (_Bool)1;

      else
      {
        return_value_strncmp_32=strncmp(s, "HEADER", (unsigned long int)6);
        tmp_if_expr_33 = !(return_value_strncmp_32 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_35;
      if(tmp_if_expr_33)
        tmp_if_expr_35 = (_Bool)1;

      else
      {
        return_value_strncmp_34=strncmp(s, "COMPND", (unsigned long int)6);
        tmp_if_expr_35 = !(return_value_strncmp_34 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_37;
      if(tmp_if_expr_35)
        tmp_if_expr_37 = (_Bool)1;

      else
      {
        return_value_strncmp_36=strncmp(s, "AUTHOR", (unsigned long int)6);
        tmp_if_expr_37 = !(return_value_strncmp_36 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_39;
      if(tmp_if_expr_37)
        tmp_if_expr_39 = (_Bool)1;

      else
      {
        return_value_strncmp_38=strncmp(s, "REVDAT", (unsigned long int)6);
        tmp_if_expr_39 = !(return_value_strncmp_38 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_41;
      if(tmp_if_expr_39)
        tmp_if_expr_41 = (_Bool)1;

      else
      {
        return_value_strncmp_40=strncmp(s, "SOURCE", (unsigned long int)6);
        tmp_if_expr_41 = !(return_value_strncmp_40 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_43;
      if(tmp_if_expr_41)
        tmp_if_expr_43 = (_Bool)1;

      else
      {
        return_value_strncmp_42=strncmp(s, "EXPDTA", (unsigned long int)6);
        tmp_if_expr_43 = !(return_value_strncmp_42 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_45;
      if(tmp_if_expr_43)
        tmp_if_expr_45 = (_Bool)1;

      else
      {
        return_value_strncmp_44=strncmp(s, "JRNL  ", (unsigned long int)6);
        tmp_if_expr_45 = !(return_value_strncmp_44 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_47;
      if(tmp_if_expr_45)
        tmp_if_expr_47 = (_Bool)1;

      else
      {
        return_value_strncmp_46=strncmp(s, "REMARK", (unsigned long int)6);
        tmp_if_expr_47 = !(return_value_strncmp_46 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_49;
      if(tmp_if_expr_47)
        tmp_if_expr_49 = (_Bool)1;

      else
      {
        return_value_strncmp_48=strncmp(s, "SEQRES", (unsigned long int)6);
        tmp_if_expr_49 = !(return_value_strncmp_48 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_51;
      if(tmp_if_expr_49)
        tmp_if_expr_51 = (_Bool)1;

      else
      {
        return_value_strncmp_50=strncmp(s, "HET   ", (unsigned long int)6);
        tmp_if_expr_51 = !(return_value_strncmp_50 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_53;
      if(tmp_if_expr_51)
        tmp_if_expr_53 = (_Bool)1;

      else
      {
        return_value_strncmp_52=strncmp(s, "FORMUL", (unsigned long int)6);
        tmp_if_expr_53 = !(return_value_strncmp_52 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_55;
      if(tmp_if_expr_53)
        tmp_if_expr_55 = (_Bool)1;

      else
      {
        return_value_strncmp_54=strncmp(s, "CRYST1", (unsigned long int)6);
        tmp_if_expr_55 = !(return_value_strncmp_54 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_57;
      if(tmp_if_expr_55)
        tmp_if_expr_57 = (_Bool)1;

      else
      {
        return_value_strncmp_56=strncmp(s, "ORIGX1", (unsigned long int)6);
        tmp_if_expr_57 = !(return_value_strncmp_56 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_59;
      if(tmp_if_expr_57)
        tmp_if_expr_59 = (_Bool)1;

      else
      {
        return_value_strncmp_58=strncmp(s, "ORIGX2", (unsigned long int)6);
        tmp_if_expr_59 = !(return_value_strncmp_58 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_61;
      if(tmp_if_expr_59)
        tmp_if_expr_61 = (_Bool)1;

      else
      {
        return_value_strncmp_60=strncmp(s, "ORIGX3", (unsigned long int)6);
        tmp_if_expr_61 = !(return_value_strncmp_60 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_63;
      if(tmp_if_expr_61)
        tmp_if_expr_63 = (_Bool)1;

      else
      {
        return_value_strncmp_62=strncmp(s, "SCALE1", (unsigned long int)6);
        tmp_if_expr_63 = !(return_value_strncmp_62 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_65;
      if(tmp_if_expr_63)
        tmp_if_expr_65 = (_Bool)1;

      else
      {
        return_value_strncmp_64=strncmp(s, "SCALE2", (unsigned long int)6);
        tmp_if_expr_65 = !(return_value_strncmp_64 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_67;
      if(tmp_if_expr_65)
        tmp_if_expr_67 = (_Bool)1;

      else
      {
        return_value_strncmp_66=strncmp(s, "SCALE3", (unsigned long int)6);
        tmp_if_expr_67 = !(return_value_strncmp_66 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_69;
      if(tmp_if_expr_67)
        tmp_if_expr_69 = (_Bool)1;

      else
      {
        return_value_strncmp_68=strncmp(s, "MASTER", (unsigned long int)6);
        tmp_if_expr_69 = !(return_value_strncmp_68 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_71;
      if(tmp_if_expr_69)
        tmp_if_expr_71 = (_Bool)1;

      else
      {
        return_value_strncmp_70=strncmp(s, "KEYWDS", (unsigned long int)6);
        tmp_if_expr_71 = !(return_value_strncmp_70 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_73;
      if(tmp_if_expr_71)
        tmp_if_expr_73 = (_Bool)1;

      else
      {
        return_value_strncmp_72=strncmp(s, "DBREF ", (unsigned long int)6);
        tmp_if_expr_73 = !(return_value_strncmp_72 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_75;
      if(tmp_if_expr_73)
        tmp_if_expr_75 = (_Bool)1;

      else
      {
        return_value_strncmp_74=strncmp(s, "HETNAM", (unsigned long int)6);
        tmp_if_expr_75 = !(return_value_strncmp_74 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_77;
      if(tmp_if_expr_75)
        tmp_if_expr_77 = (_Bool)1;

      else
      {
        return_value_strncmp_76=strncmp(s, "HETSYN", (unsigned long int)6);
        tmp_if_expr_77 = !(return_value_strncmp_76 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_79;
      if(tmp_if_expr_77)
        tmp_if_expr_79 = (_Bool)1;

      else
      {
        return_value_strncmp_78=strncmp(s, "HELIX ", (unsigned long int)6);
        tmp_if_expr_79 = !(return_value_strncmp_78 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_81;
      if(tmp_if_expr_79)
        tmp_if_expr_81 = (_Bool)1;

      else
      {
        return_value_strncmp_80=strncmp(s, "LINK  ", (unsigned long int)6);
        tmp_if_expr_81 = !(return_value_strncmp_80 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_83;
      if(tmp_if_expr_81)
        tmp_if_expr_83 = (_Bool)1;

      else
      {
        return_value_strncmp_82=strncmp(s, "MTRIX1", (unsigned long int)6);
        tmp_if_expr_83 = !(return_value_strncmp_82 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_85;
      if(tmp_if_expr_83)
        tmp_if_expr_85 = (_Bool)1;

      else
      {
        return_value_strncmp_84=strncmp(s, "MTRIX2", (unsigned long int)6);
        tmp_if_expr_85 = !(return_value_strncmp_84 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_87;
      if(tmp_if_expr_85)
        tmp_if_expr_87 = (_Bool)1;

      else
      {
        return_value_strncmp_86=strncmp(s, "MTRIX3", (unsigned long int)6);
        tmp_if_expr_87 = !(return_value_strncmp_86 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_89;
      if(tmp_if_expr_87)
        tmp_if_expr_89 = (_Bool)1;

      else
      {
        return_value_strncmp_88=strncmp(s, "SHEET ", (unsigned long int)6);
        tmp_if_expr_89 = !(return_value_strncmp_88 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_91;
      if(tmp_if_expr_89)
        tmp_if_expr_91 = (_Bool)1;

      else
      {
        return_value_strncmp_90=strncmp(s, "CISPEP", (unsigned long int)6);
        tmp_if_expr_91 = !(return_value_strncmp_90 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_93;
      if(tmp_if_expr_91)
        tmp_if_expr_93 = (_Bool)1;

      else
      {
        return_value_strncmp_92=strncmp(s, "GENERATED BY", (unsigned long int)12);
        tmp_if_expr_93 = !(return_value_strncmp_92 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_95;
      if(tmp_if_expr_93)
        tmp_if_expr_95 = (_Bool)1;

      else
      {
        return_value_strncmp_94=strncmp(s, "TER ", (unsigned long int)4);
        tmp_if_expr_95 = !(return_value_strncmp_94 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_97;
      if(tmp_if_expr_95)
        tmp_if_expr_97 = (_Bool)1;

      else
      {
        return_value_strncmp_96=strncmp(s, "END ", (unsigned long int)4);
        tmp_if_expr_97 = !(return_value_strncmp_96 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_99;
      if(tmp_if_expr_97)
        tmp_if_expr_99 = (_Bool)1;

      else
      {
        return_value_strncmp_98=strncmp(s, "TER\n", (unsigned long int)4);
        tmp_if_expr_99 = !(return_value_strncmp_98 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_101;
      if(tmp_if_expr_99)
        tmp_if_expr_101 = (_Bool)1;

      else
      {
        return_value_strncmp_100=strncmp(s, "END\n", (unsigned long int)4);
        tmp_if_expr_101 = !(return_value_strncmp_100 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_103;
      if(tmp_if_expr_101)
        tmp_if_expr_103 = (_Bool)1;

      else
      {
        return_value_strncmp_102=strncmp(s, "\n", (unsigned long int)1);
        tmp_if_expr_103 = !(return_value_strncmp_102 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_103)
      {
        return_value_strncmp_30=strncmp(s, "ATOM   ", (unsigned long int)7);
        if(return_value_strncmp_30 == 0)
        {
          signed int id;
          const char *end;
          end=strchr(s, 10);
          signed int parse_pdb_data__1__1__2__L = (signed int)(end - s);
          char *parse_pdb_data__1__1__2__name;
          void *return_value_calloc_11;
          return_value_calloc_11=calloc((unsigned long int)1, (unsigned long int)4);
          parse_pdb_data__1__1__2__name = (char *)return_value_calloc_11;
          float x = (float)-999;
          float y = (float)-999;
          float z = (float)-999;
          signed int return_value___isoc99_sscanf_12;
          return_value___isoc99_sscanf_12=__isoc99_sscanf(s + (signed long int)7, " %d ", &id);
          if(!(return_value___isoc99_sscanf_12 == 1))
            parse_error(filename, line, s);

          strncpy(parse_pdb_data__1__1__2__name, s + (signed long int)12, (unsigned long int)3);
          if(parse_pdb_data__1__1__2__L >= 78)
          {
            return_value___ctype_b_loc_13=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc_13)[(signed long int)(signed int)s[77l]]) == 0)
            {
              parse_pdb_data__1__1__2__name[(signed long int)0] = s[(signed long int)76];
              parse_pdb_data__1__1__2__name[(signed long int)1] = s[(signed long int)77];
              parse_pdb_data__1__1__2__name[(signed long int)2] = (char)0;
            }

          }

          do
          {
            return_value___ctype_b_loc_14=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc_14)[(signed long int)(signed int)*parse_pdb_data__1__1__2__name]) == 0)
              break;

            parse_pdb_data__1__1__2__name = parse_pdb_data__1__1__2__name + 1l;
          }
          while((_Bool)1);
          unsigned long int return_value_strlen_15;
          return_value_strlen_15=strlen(parse_pdb_data__1__1__2__name);
          ss = (parse_pdb_data__1__1__2__name + (signed long int)return_value_strlen_15) - (signed long int)1;
          do
          {
            return_value___ctype_b_loc_16=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc_16)[(signed long int)(signed int)*ss]) == 0)
              break;

            if(parse_pdb_data__1__1__2__name >= ss)
              break;

            char *tmp_post_17 = ss;
            ss = ss - 1l;
            *tmp_post_17 = (char)0;
          }
          while((_Bool)1);
          ss = parse_pdb_data__1__1__2__name + (signed long int)1;
          while(!(*ss == 0))
          {
            signed int return_value_tolower_18;
            return_value_tolower_18=tolower((signed int)*ss);
            *ss = (char)return_value_tolower_18;
            ss = ss + 1l;
          }
          signed int return_value___isoc99_sscanf_19;
          return_value___isoc99_sscanf_19=__isoc99_sscanf(s + (signed long int)32, " %f %f %f ", &x, &y, &z);
          if(!(return_value___isoc99_sscanf_19 == 3))
            parse_error(filename, line, s);

          push_atom(m, id, parse_pdb_data__1__1__2__name, x, y, z);
        }

        else
        {
          return_value_strncmp_29=strncmp(s, "HETATM ", (unsigned long int)7);
          if(return_value_strncmp_29 == 0)
          {
            signed int parse_pdb_data__1__1__3__id;
            char *parse_pdb_data__1__1__3__name;
            void *return_value_calloc_20;
            return_value_calloc_20=calloc((unsigned long int)1, (unsigned long int)4);
            parse_pdb_data__1__1__3__name = (char *)return_value_calloc_20;
            float parse_pdb_data__1__1__3__x = (float)-999;
            float parse_pdb_data__1__1__3__y = (float)-999;
            float parse_pdb_data__1__1__3__z = (float)-999;
            signed int return_value___isoc99_sscanf_21;
            return_value___isoc99_sscanf_21=__isoc99_sscanf(s + (signed long int)7, " %d ", &parse_pdb_data__1__1__3__id);
            if(!(return_value___isoc99_sscanf_21 == 1))
              parse_error(filename, line, s);

            strncpy(parse_pdb_data__1__1__3__name, s + (signed long int)12, (unsigned long int)3);
            do
            {
              return_value___ctype_b_loc_22=__ctype_b_loc();
              if((8192 & (signed int)(*return_value___ctype_b_loc_22)[(signed long int)(signed int)*parse_pdb_data__1__1__3__name]) == 0)
                break;

              parse_pdb_data__1__1__3__name = parse_pdb_data__1__1__3__name + 1l;
            }
            while((_Bool)1);
            unsigned long int return_value_strlen_23;
            return_value_strlen_23=strlen(parse_pdb_data__1__1__3__name);
            ss = (parse_pdb_data__1__1__3__name + (signed long int)return_value_strlen_23) - (signed long int)1;
            do
            {
              return_value___ctype_b_loc_24=__ctype_b_loc();
              if((8192 & (signed int)(*return_value___ctype_b_loc_24)[(signed long int)(signed int)*ss]) == 0)
                break;

              if(parse_pdb_data__1__1__3__name >= ss)
                break;

              char *tmp_post_25 = ss;
              ss = ss - 1l;
              *tmp_post_25 = (char)0;
            }
            while((_Bool)1);
            signed int return_value___isoc99_sscanf_26;
            return_value___isoc99_sscanf_26=__isoc99_sscanf(s + (signed long int)30, " %f %f %f ", &parse_pdb_data__1__1__3__x, &parse_pdb_data__1__1__3__y, &parse_pdb_data__1__1__3__z);
            if(!(return_value___isoc99_sscanf_26 == 3))
              parse_error(filename, line, s);

            push_atom(m, parse_pdb_data__1__1__3__id, parse_pdb_data__1__1__3__name, parse_pdb_data__1__1__3__x, parse_pdb_data__1__1__3__y, parse_pdb_data__1__1__3__z);
          }

          else
          {
            return_value_strncmp_28=strncmp(s, "CONECT ", (unsigned long int)7);
            if(return_value_strncmp_28 == 0)
            {
              signed int atoms[11l];
              signed int i;
              i=__isoc99_sscanf(s + (signed long int)8, " %d %d %d %d %d %d %d %d %d %d %d %d ", &atoms[(signed long int)0], &atoms[(signed long int)1], &atoms[(signed long int)2], &atoms[(signed long int)3], &atoms[(signed long int)4], &atoms[(signed long int)5], &atoms[(signed long int)6], &atoms[(signed long int)7], &atoms[(signed long int)8], &atoms[(signed long int)9], &atoms[(signed long int)10], &atoms[(signed long int)11]);
              signed int j = 1;
              for( ; !(j >= i); j = j + 1)
                if(atoms[(signed long int)j] >= 1)
                  push_bond(m, atoms[(signed long int)0], atoms[(signed long int)j]);

            }

            else
            {
              char *s1;
              s1=strdup(s);
              ss = s1;
              do
              {
                if(!(*ss == 0))
                  tmp_if_expr_27 = (signed int)*ss != 10 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_27 = (_Bool)0;
                if(!tmp_if_expr_27)
                  break;

                ss = ss + 1l;
              }
              while((_Bool)1);
              *ss = (char)0;
              fprintf(stderr, "%s: %s: %d: unrecognised line: %s\n", progname, filename, line, s1);
            }
          }
        }
      }

    }
    for( ; !(*s == 0); s = s + 1l)
      if((signed int)*s == 10)
        break;

    if((signed int)*s == 10)
      s = s + 1l;

    line = line + 1;
  }
}

// parse_pdb_file
// file molecule.c line 879
static signed int parse_pdb_file(struct anonymous_30 *m, const char *name)
{
  struct _IO_FILE *in;
  signed int buf_size = 40960;
  char *buf;
  signed int line = 1;
  in=fopen(name, "r");
  if(in == ((struct _IO_FILE *)NULL))
  {
    char *parse_pdb_file__1__1__buf;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(name);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)1024 + return_value_strlen_1);
    parse_pdb_file__1__1__buf = (char *)return_value_malloc_2;
    sprintf(parse_pdb_file__1__1__buf, "%s: error reading \"%s\"", progname, name);
    perror(parse_pdb_file__1__1__buf);
    return -1;
  }

  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)buf_size);
  buf = (char *)return_value_malloc_3;
  char *return_value_fgets_4;
  do
  {
    return_value_fgets_4=fgets(buf, buf_size - 1, in);
    if(return_value_fgets_4 == ((char *)NULL))
      break;

    char *s = buf;
    for( ; !(*s == 0); s = s + 1l)
      if((signed int)*s == 13)
        *s = (char)10;

    signed int tmp_post_5 = line;
    line = line + 1;
    parse_pdb_data(m, buf, name, tmp_post_5);
  }
  while((_Bool)1);
  free((void *)buf);
  fclose(in);
  if(m->natoms == 0)
  {
    fprintf(stderr, "%s: file %s contains no atomic coordinates!\n", progname, name);
    return -1;
  }

  else
  {
    if(m->nbonds == 0)
    {
      if(!(do_bonds == 0))
      {
        fprintf(stderr, "%s: warning: file %s contains no atomic bond info.\n", progname, name);
        do_bonds = 0;
      }

    }

    return 0;
  }
}

// parse_time
// file resources.c line 203
extern signed int parse_time(const char *string, signed int seconds_default_p, signed int silent_p)
{
  unsigned int h;
  unsigned int m;
  unsigned int s;
  char c;
  signed int return_value___isoc99_sscanf_6;
  return_value___isoc99_sscanf_6=__isoc99_sscanf(string, " %u : %2u : %2u %c", &h, &m, &s, &c);
  signed int return_value___isoc99_sscanf_3;
  signed int return_value___isoc99_sscanf_4;
  signed int return_value___isoc99_sscanf_2;
  signed int return_value___isoc99_sscanf_1;
  if(!(return_value___isoc99_sscanf_6 == 3))
  {
    return_value___isoc99_sscanf_3=__isoc99_sscanf(string, " : %2u : %2u %c", &m, &s, &c);
    _Bool tmp_if_expr_5;
    if(return_value___isoc99_sscanf_3 == 2)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___isoc99_sscanf_4=__isoc99_sscanf(string, " %u : %2u %c", &m, &s, &c);
      tmp_if_expr_5 = 2 == return_value___isoc99_sscanf_4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      h = (unsigned int)0;

    else
    {
      return_value___isoc99_sscanf_2=__isoc99_sscanf(string, " : %2u %c", &s, &c);
      if(return_value___isoc99_sscanf_2 == 1)
      {
        m = (unsigned int)0;
        h = m;
      }

      else
      {
        return_value___isoc99_sscanf_1=__isoc99_sscanf(string, " %u %c", seconds_default_p != 0 ? &s : &m, &c);
        if(return_value___isoc99_sscanf_1 == 1)
        {
          h = (unsigned int)0;
          if(!(seconds_default_p == 0))
            m = (unsigned int)0;

          else
            s = (unsigned int)0;
        }

        else
        {
          if(silent_p == 0)
            fprintf(stderr, "%s: invalid time interval specification \"%s\".\n", progname, string);

          return -1;
        }
      }
    }
  }

  if(s >= 60u && (!(h == 0u) || !(m == 0u)))
  {
    if(silent_p == 0)
      fprintf(stderr, "%s: seconds > 59 in \"%s\".\n", progname, string);

    return -1;
  }

  else
    if(h >= 1u && m >= 60u)
    {
      if(silent_p == 0)
        fprintf(stderr, "%s: minutes > 59 in \"%s\".\n", progname, string);

      return -1;
    }

    else
      return (signed int)(h * (unsigned int)60 * (unsigned int)60 + m * (unsigned int)60 + s);
}

// pick_best_gl_visual
// file visual.c line 281
static struct anonymous_16 * pick_best_gl_visual(struct anonymous_15 *screen)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  struct anonymous_16 *result = ((struct anonymous_16 *)NULL);
  signed int ndepths = 0;
  signed int *depths;
  signed int return_value_screen_number_1;
  return_value_screen_number_1=screen_number(screen);
  depths=XListDepths(dpy, return_value_screen_number_1, &ndepths);
  signed int screen_depth;
  signed int tmp_if_expr_2;
  if(!(depths == ((signed int *)NULL)) && !(ndepths == 0))
    tmp_if_expr_2 = depths[(signed long int)(ndepths - 1)];

  else
    tmp_if_expr_2 = 0;
  screen_depth = tmp_if_expr_2;
  XFree((void *)depths);
  vi_in.class = 4;
  vi_in.screen=screen_number(screen);
  vi_in.depth = screen_depth / 2;
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2 | 0x4), &vi_in, &out_count);
  if(out_count >= 1)
    result = (vi_out + (signed long int)0)->visual;

  if(!(vi_out == ((struct anonymous_10 *)NULL)))
    XFree((void *)(char *)vi_out);

  if(result == ((struct anonymous_16 *)NULL) && screen_depth >= 25)
  {
    vi_in.class = 4;
    vi_in.screen=screen_number(screen);
    vi_in.depth = 12;
    vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2 | 0x4), &vi_in, &out_count);
    if(out_count >= 1)
      result = (vi_out + (signed long int)0)->visual;

  }

  if(result == ((struct anonymous_16 *)NULL))
    result=pick_best_visual_of_class(screen, 4);

  if(result == ((struct anonymous_16 *)NULL))
    result=pick_best_visual(screen, 0, 0);

  return result;
}

// pick_best_visual
// file visual.c line 174
static struct anonymous_16 * pick_best_visual(struct anonymous_15 *screen, signed int prefer_writable_cells, signed int color_only)
{
  struct anonymous_16 *visual;
  signed int return_value_visual_depth_1;
  if(prefer_writable_cells == 0)
  {
    visual=pick_best_visual_of_class(screen, 4);
    if(!(visual == ((struct anonymous_16 *)NULL)))
    {
      return_value_visual_depth_1=visual_depth(screen, visual);
      if(return_value_visual_depth_1 >= 16)
        return visual;

    }

  }

  visual=pick_best_visual_of_class(screen, 3);
  signed int return_value_visual_depth_2;
  if(!(visual == ((struct anonymous_16 *)NULL)))
  {
    _Bool tmp_if_expr_3;
    if(color_only == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_visual_depth_2=visual_depth(screen, visual);
      tmp_if_expr_3 = return_value_visual_depth_2 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 4);
  signed int return_value_visual_depth_4;
  if(!(visual == ((struct anonymous_16 *)NULL)))
  {
    _Bool tmp_if_expr_5;
    if(color_only == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_visual_depth_4=visual_depth(screen, visual);
      tmp_if_expr_5 = return_value_visual_depth_4 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 5);
  signed int return_value_visual_depth_6;
  if(!(visual == ((struct anonymous_16 *)NULL)))
  {
    _Bool tmp_if_expr_7;
    if(color_only == 0)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_visual_depth_6=visual_depth(screen, visual);
      tmp_if_expr_7 = return_value_visual_depth_6 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 2);
  signed int return_value_visual_depth_8;
  if(!(visual == ((struct anonymous_16 *)NULL)))
  {
    _Bool tmp_if_expr_9;
    if(color_only == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_visual_depth_8=visual_depth(screen, visual);
      tmp_if_expr_9 = return_value_visual_depth_8 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      return visual;

  }

  signed int return_value_visual_depth_10;
  signed int return_value_visual_depth_12;
  if(color_only == 0)
  {
    visual=pick_best_visual_of_class(screen, 1);
    if(!(visual == ((struct anonymous_16 *)NULL)))
    {
      _Bool tmp_if_expr_11;
      if(color_only == 0)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_visual_depth_10=visual_depth(screen, visual);
        tmp_if_expr_11 = return_value_visual_depth_10 > 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
        return visual;

    }

    visual=pick_best_visual_of_class(screen, 0);
    if(!(visual == ((struct anonymous_16 *)NULL)))
    {
      _Bool tmp_if_expr_13;
      if(color_only == 0)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        return_value_visual_depth_12=visual_depth(screen, visual);
        tmp_if_expr_13 = return_value_visual_depth_12 > 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_13)
        return visual;

    }

  }

  visual = screen->root_visual;
  _Bool tmp_if_expr_15;
  signed int return_value_visual_depth_14;
  if(color_only == 0)
    tmp_if_expr_15 = (_Bool)1;

  else
  {
    return_value_visual_depth_14=visual_depth(screen, visual);
    tmp_if_expr_15 = return_value_visual_depth_14 > 1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_15)
    return visual;

  else
    return ((struct anonymous_16 *)NULL);
}

// pick_best_visual_of_class
// file visual.c line 242
static struct anonymous_16 * pick_best_visual_of_class(struct anonymous_15 *screen, signed int visual_class)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  vi_in.class = visual_class;
  vi_in.screen=screen_number(screen);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2), &vi_in, &out_count);
  _Bool tmp_if_expr_1;
  if(!(vi_out == ((struct anonymous_10 *)NULL)))
  {
    signed int i;
    signed int best;
    struct anonymous_16 *visual;
    i = out_count - 1;
    best = i;
    for( ; i >= 0; i = i - 1)
    {
      _Bool tmp_if_expr_2;
      if(!((vi_out + (signed long int)best)->depth >= (vi_out + (signed long int)i)->depth))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        if((vi_out + (signed long int)i)->depth == (vi_out + (signed long int)best)->depth)
          tmp_if_expr_1 = (vi_out + (signed long int)i)->colormap_size > (vi_out + (signed long int)best)->colormap_size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        best = i;

    }
    struct anonymous_16 *tmp_if_expr_3;
    if(!(best >= out_count))
      tmp_if_expr_3 = (vi_out + (signed long int)best)->visual;

    else
      tmp_if_expr_3 = ((struct anonymous_16 *)NULL);
    visual = tmp_if_expr_3;
    XFree((void *)(char *)vi_out);
    return visual;
  }

  else
    return ((struct anonymous_16 *)NULL);
}

// pick_mono_visual
// file visual.c line 218
static struct anonymous_16 * pick_mono_visual(struct anonymous_15 *screen)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  vi_in.depth = 1;
  vi_in.screen=screen_number(screen);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x4 | 0x2), &vi_in, &out_count);
  if(!(vi_out == ((struct anonymous_10 *)NULL)))
  {
    struct anonymous_16 *v;
    struct anonymous_16 *tmp_if_expr_1;
    if(out_count >= 1)
      tmp_if_expr_1 = (vi_out + (signed long int)0)->visual;

    else
      tmp_if_expr_1 = ((struct anonymous_16 *)NULL);
    v = tmp_if_expr_1;
    if(!(v == ((struct anonymous_16 *)NULL)))
    {
      if(!(vi_out->depth == 1))
        v = ((struct anonymous_16 *)NULL);

    }

    XFree((void *)(char *)vi_out);
    return v;
  }

  else
    return ((struct anonymous_16 *)NULL);
}

// pick_new_molecule
// file molecule.c line 1440
static void pick_new_molecule(struct ModeInfo *mi, signed long int last)
{
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  unsigned int return_value_ya_random_2;
  if(mc->nmolecules == 1)
  {
    if(!(last == 0l))
      goto __CPROVER_DUMP_L19;

    mc->which = 0;
  }

  else
    if(last == 0l)
    {
      unsigned int return_value_ya_random_1;
      return_value_ya_random_1=ya_random();
      mc->which = (signed int)(return_value_ya_random_1 % (unsigned int)mc->nmolecules);
    }

    else
      if(!(mc->next >= 0))
      {
        mc->which = mc->which - 1;
        if(!(mc->which >= 0))
          mc->which = mc->nmolecules - 1;

        mc->next = 0;
      }

      else
        if(mc->next >= 1)
        {
          mc->which = mc->which + 1;
          if(mc->which >= mc->nmolecules)
            mc->which = 0;

          mc->next = 0;
        }

        else
        {
          signed int n = mc->which;
          while(n == mc->which)
          {
            return_value_ya_random_2=ya_random();
            n = (signed int)(return_value_ya_random_2 % (unsigned int)mc->nmolecules);
          }
          mc->which = n;
        }
  if(!(verbose_p == 0))
  {
    char *name;
    name=strdup((mc->molecules + (signed long int)mc->which)->label);
    char *s;
    s=strpbrk(name, "\r\n");
    if(!(s == ((char *)NULL)))
      *s = (char)0;

    fprintf(stderr, "%s: drawing %s (%d)\n", progname, name, mc->which);
    free((void *)name);
  }

  mc->polygon_count = 0;
  glNewList(mc->molecule_dlist, (unsigned int)0x1300);
  ensure_bounding_box_visible(mi);
  do_labels = orig_do_labels;
  do_atoms = orig_do_atoms;
  do_bonds = orig_do_bonds;
  do_shells = orig_do_shells;
  mi->wireframe_p = orig_wire;
  if(mc->molecule_size > mc->no_label_threshold)
    do_labels = 0;

  if(mc->molecule_size > mc->wireframe_threshold)
    mi->wireframe_p = 1;

  if(!(mi->wireframe_p == 0))
  {
    do_bonds = 1;
    do_shells = 0;
  }

  if(do_bonds == 0)
    do_shells = 0;

  if(do_atoms == 0 && do_bonds == 0 && do_labels == 0)
  {
    mi->wireframe_p = 1;
    do_bonds = 1;
  }

  build_molecule(mi, 0);
  glEndList();
  if(!(do_shells == 0))
  {
    glNewList(mc->shell_dlist, (unsigned int)0x1300);
    ensure_bounding_box_visible(mi);
    do_labels = 0;
    do_atoms = 1;
    do_bonds = 0;
    build_molecule(mi, 1);
    glEndList();
    do_bonds = orig_do_bonds;
    do_atoms = orig_do_atoms;
    do_labels = orig_do_labels;
  }


__CPROVER_DUMP_L19:
  ;
}

// pick_visual
// file screenhack.c line 321
static struct anonymous_16 * pick_visual(struct anonymous_15 *screen)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  if(!(ft->pick_visual_hook == ((struct anonymous_16 * (*)(struct anonymous_15 *))NULL)))
  {
    struct anonymous_16 *v;
    v=ft->pick_visual_hook(screen);
    if(!(v == ((struct anonymous_16 *)NULL)))
      return v;

  }

  struct anonymous_16 *return_value_get_visual_resource_1;
  return_value_get_visual_resource_1=get_visual_resource(screen, "visualID", "VisualID", 0);
  return return_value_get_visual_resource_1;
}

// print_texture_label
// file texfont.h line 44
void print_texture_label(struct _XDisplay *dpy, struct texture_font_data *data, signed int window_width, signed int window_height, signed int position, const char *string)
{
  float color[4l];
  signed int tex_p;
  unsigned char return_value_glIsEnabled_1;
  return_value_glIsEnabled_1=glIsEnabled((unsigned int)0x0DE1);
  tex_p = (signed int)return_value_glIsEnabled_1;
  signed int texs_p;
  unsigned char return_value_glIsEnabled_2;
  return_value_glIsEnabled_2=glIsEnabled((unsigned int)0x0C60);
  texs_p = (signed int)return_value_glIsEnabled_2;
  signed int text_p;
  unsigned char return_value_glIsEnabled_3;
  return_value_glIsEnabled_3=glIsEnabled((unsigned int)0x0C61);
  text_p = (signed int)return_value_glIsEnabled_3;
  signed int depth_p;
  unsigned char return_value_glIsEnabled_4;
  return_value_glIsEnabled_4=glIsEnabled((unsigned int)0x0B71);
  depth_p = (signed int)return_value_glIsEnabled_4;
  signed int cull_p;
  unsigned char return_value_glIsEnabled_5;
  return_value_glIsEnabled_5=glIsEnabled((unsigned int)0x0B44);
  cull_p = (signed int)return_value_glIsEnabled_5;
  signed int fog_p;
  unsigned char return_value_glIsEnabled_6;
  return_value_glIsEnabled_6=glIsEnabled((unsigned int)0x0B60);
  fog_p = (signed int)return_value_glIsEnabled_6;
  signed int ovp[4l];
  signed int opoly[2l];
  glGetIntegerv((unsigned int)0x0B40, opoly);
  glGetIntegerv((unsigned int)0x0BA2, ovp);
  glGetFloatv((unsigned int)0x0B00, color);
  glEnable((unsigned int)0x0DE1);
  glBlendFunc((unsigned int)0x0302, (unsigned int)0x0303);
  glPolygonMode((unsigned int)0x0404, (unsigned int)0x1B02);
  glDisable((unsigned int)0x0C60);
  glDisable((unsigned int)0x0C61);
  glDisable((unsigned int)0x0B44);
  glDisable((unsigned int)0x0B60);
  glDisable((unsigned int)0x0B71);
  glMatrixMode((unsigned int)0x1701);
  glPushMatrix();
  glLoadIdentity();
  glMatrixMode((unsigned int)0x1700);
  glPushMatrix();
  struct anonymous_38 cs;
  signed int ascent;
  signed int descent;
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int swap;
  signed int rot = (signed int)0;
  glLoadIdentity();
  glViewport(0, 0, window_width, window_height);
  glOrtho((double)0, (double)window_width, (double)0, (double)window_height, (double)-1, (double)1);
  for( ; !(rot >= -179); rot = rot + 360)
    ;
  for( ; rot >= 181; rot = rot - 360)
    ;
  texture_string_metrics(data, string, &cs, &ascent, &descent);
  h = (signed int)cs.ascent + (signed int)cs.descent;
  w = (signed int)cs.width;
  if(rot >= 136 || !(rot >= -135))
  {
    glTranslatef((float)window_width, (float)window_height, (float)0);
    glRotatef((float)180, (float)0, (float)0, (float)1);
  }

  else
    if(rot >= 46)
    {
      glTranslatef((float)window_width, (float)0, (float)0);
      glRotatef((float)90, (float)0, (float)0, (float)1);
      swap = window_width;
      window_width = window_height;
      window_height = swap;
    }

    else
      if(!(rot >= -45))
      {
        glTranslatef((float)0, (float)window_height, (float)0);
        glRotatef((float)-90, (float)0, (float)0, (float)1);
        swap = window_width;
        window_width = window_height;
        window_height = swap;
      }

  switch(position)
  {
    case 0:
    {
      x = (window_width - w) / 2;
      y = (window_height + h) / 2 - ascent;
      break;
    }
    case 1:
    {
      x = ascent;
      y = window_height - ascent * 2;
      break;
    }
    case 2:
    {
      x = ascent;
      y = h;
      break;
    }
    default:
      abort();
  }
  glTranslatef((float)x, (float)y, (float)0);
  const struct anonymous_14 offsets[5l] = { { .x=(signed short int)-1, .y=(signed short int)-1 },
    { .x=(signed short int)-1, .y=(signed short int)1 },
    { .x=(signed short int)1, .y=(signed short int)1 },
    { .x=(signed short int)1, .y=(signed short int)-1 },
    { .x=(signed short int)0, .y=(signed short int)0 } };
  signed int i;
  glColor3f((float)0, (float)0, (float)0);
  i = 0;
  for( ; !((unsigned long int)i >= 5ul); i = i + 1)
  {
    if((signed int)offsets[(signed long int)i].x == 0)
      glColor4fv(color);

    glPushMatrix();
    glTranslatef((float)offsets[(signed long int)i].x, (float)offsets[(signed long int)i].y, (float)0);
    print_texture_string(data, string);
    glPopMatrix();
  }
  glPopMatrix();
  glMatrixMode((unsigned int)0x1701);
  glPopMatrix();
  if(!(tex_p == 0))
    glEnable((unsigned int)0x0DE1);

  else
    glDisable((unsigned int)0x0DE1);
  if(!(texs_p == 0))
    glEnable((unsigned int)0x0C60);

  if(!(text_p == 0))
    glEnable((unsigned int)0x0C61);

  if(!(depth_p == 0))
    glEnable((unsigned int)0x0B71);

  else
    glDisable((unsigned int)0x0B71);
  if(!(cull_p == 0))
    glEnable((unsigned int)0x0B44);

  if(!(fog_p == 0))
    glEnable((unsigned int)0x0B60);

  glViewport(ovp[(signed long int)0], ovp[(signed long int)1], ovp[(signed long int)2], ovp[(signed long int)3]);
  glPolygonMode((unsigned int)0x0404, (unsigned int)opoly[(signed long int)0]);
  glMatrixMode((unsigned int)0x1700);
}

// print_texture_string
// file texfont.h line 35
extern void print_texture_string(struct texture_font_data *data, const char *string)
{
  struct anonymous_38 overall;
  signed int tex_width;
  signed int tex_height;
  struct texfont_cache *cache;
  signed int old_texture;
  if(!(*string == 0))
  {
    clear_gl_error();
    glGetIntegerv((unsigned int)0x8069, &old_texture);
    cache=get_cache(data, string);
    glBindTexture((unsigned int)0x0DE1, cache->texid);
    check_gl_error("texture font binding");
    if(!(cache->string == ((char *)NULL)))
    {
      overall = data->cache->extents;
      tex_width = data->cache->tex_width;
      tex_height = data->cache->tex_height;
    }

    else
      string_to_texture(data, string, &overall, &tex_width, &tex_height);
    signed int ofront;
    signed int oblend;
    signed int alpha_p;
    signed int blend_p;
    signed int light_p;
    signed int gen_s_p;
    signed int gen_t_p;
    float omatrix[16l];
    float qx0;
    float qy0;
    float qx1;
    float qy1;
    float tx0;
    float ty0;
    float tx1;
    float ty1;
    signed int draw_back_face_p;
    unsigned char return_value_glIsEnabled_1;
    return_value_glIsEnabled_1=glIsEnabled((unsigned int)0x0B44);
    draw_back_face_p = (signed int)!(return_value_glIsEnabled_1 != 0);
    glGetIntegerv((unsigned int)0x0B46, &ofront);
    glGetIntegerv((unsigned int)0x0BE0, &oblend);
    glGetFloatv((unsigned int)0x0BA8, omatrix);
    unsigned char return_value_glIsEnabled_2;
    return_value_glIsEnabled_2=glIsEnabled((unsigned int)0x0BE2);
    blend_p = (signed int)return_value_glIsEnabled_2;
    unsigned char return_value_glIsEnabled_3;
    return_value_glIsEnabled_3=glIsEnabled((unsigned int)0x0BC0);
    alpha_p = (signed int)return_value_glIsEnabled_3;
    unsigned char return_value_glIsEnabled_4;
    return_value_glIsEnabled_4=glIsEnabled((unsigned int)0x0B50);
    light_p = (signed int)return_value_glIsEnabled_4;
    unsigned char return_value_glIsEnabled_5;
    return_value_glIsEnabled_5=glIsEnabled((unsigned int)0x0C60);
    gen_s_p = (signed int)return_value_glIsEnabled_5;
    unsigned char return_value_glIsEnabled_6;
    return_value_glIsEnabled_6=glIsEnabled((unsigned int)0x0C61);
    gen_t_p = (signed int)return_value_glIsEnabled_6;
    glPushMatrix();
    glNormal3f((float)0, (float)0, (float)1);
    glFrontFace((unsigned int)0x0900);
    glMatrixMode((unsigned int)0x1702);
    glLoadIdentity();
    glMatrixMode((unsigned int)0x1700);
    enable_texture_string_parameters();
    qx0 = (float)overall.lbearing;
    qy0 = (float)-((signed int)overall.descent);
    qx1 = (float)overall.rbearing;
    qy1 = (float)overall.ascent;
    tx0 = (float)0;
    ty1 = (float)0;
    tx1 = (float)((signed int)overall.rbearing - (signed int)overall.lbearing) / (float)tex_width;
    ty0 = (float)((signed int)overall.ascent + (signed int)overall.descent) / (float)tex_height;
    glEnable((unsigned int)0x0B44);
    glFrontFace((unsigned int)0x0901);
    glBegin((unsigned int)0x0007);
    glTexCoord2f(tx0, ty0);
    glVertex3f(qx0, qy0, (float)0);
    glTexCoord2f(tx1, ty0);
    glVertex3f(qx1, qy0, (float)0);
    glTexCoord2f(tx1, ty1);
    glVertex3f(qx1, qy1, (float)0);
    glTexCoord2f(tx0, ty1);
    glVertex3f(qx0, qy1, (float)0);
    glEnd();
    if(!(draw_back_face_p == 0))
    {
      glFrontFace((unsigned int)0x0900);
      glBegin((unsigned int)0x0007);
      glTexCoord2f(tx0, ty0);
      glVertex3f(qx0, qy0, (float)0);
      glTexCoord2f(tx1, ty0);
      glVertex3f(qx1, qy0, (float)0);
      glTexCoord2f(tx1, ty1);
      glVertex3f(qx1, qy1, (float)0);
      glTexCoord2f(tx0, ty1);
      glVertex3f(qx0, qy1, (float)0);
      glEnd();
      glDisable((unsigned int)0x0B44);
    }

    glPopMatrix();
    glBindTexture((unsigned int)0x0DE1, (unsigned int)old_texture);
    glFrontFace((unsigned int)ofront);
    if(alpha_p == 0)
      glDisable((unsigned int)0x0BC0);

    if(blend_p == 0)
      glDisable((unsigned int)0x0BE2);

    if(!(light_p == 0))
      glEnable((unsigned int)0x0B50);

    if(!(gen_s_p == 0))
      glEnable((unsigned int)0x0C60);

    if(!(gen_t_p == 0))
      glEnable((unsigned int)0x0C61);

    glBlendFunc((unsigned int)0x0302, (unsigned int)oblend);
    glMatrixMode((unsigned int)0x1702);
    glMultMatrixf(omatrix);
    glMatrixMode((unsigned int)0x1700);
    check_gl_error("texture font print");
    if(cache->string == ((char *)NULL))
    {
      cache->string=strdup(string);
      cache->extents = overall;
      cache->tex_width = tex_width;
      cache->tex_height = tex_height;
    }

  }

}

// push_atom
// file molecule.c line 633
static void push_atom(struct anonymous_30 *m, signed int id, const char *label, float x, float y, float z)
{
  m->natoms = m->natoms + 1;
  if(!(m->atoms_size >= m->natoms))
  {
    m->atoms_size = m->atoms_size + 20;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)m->atoms, (unsigned long int)m->atoms_size * sizeof(struct anonymous_33) /*40ul*/ );
    m->atoms = (struct anonymous_33 *)return_value_realloc_1;
  }

  (m->atoms + (signed long int)(m->natoms - 1))->id = id;
  (m->atoms + (signed long int)(m->natoms - 1))->label = label;
  (m->atoms + (signed long int)(m->natoms - 1))->x = x;
  (m->atoms + (signed long int)(m->natoms - 1))->y = y;
  (m->atoms + (signed long int)(m->natoms - 1))->z = z;
  (m->atoms + (signed long int)(m->natoms - 1))->data=get_atom_data(label);
}

// push_bond
// file molecule.c line 654
static void push_bond(struct anonymous_30 *m, signed int from, signed int to)
{
  signed int i = 0;
  _Bool tmp_if_expr_2;
  for( ; !(i >= m->nbonds); i = i + 1)
  {
    _Bool tmp_if_expr_1;
    if((m->bonds + (signed long int)i)->from == from)
      tmp_if_expr_1 = (m->bonds + (signed long int)i)->to == to ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      if((m->bonds + (signed long int)i)->to == from)
        tmp_if_expr_2 = (m->bonds + (signed long int)i)->from == to ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
    {
      (m->bonds + (signed long int)i)->strength = (m->bonds + (signed long int)i)->strength + 1;
      goto __CPROVER_DUMP_L11;
    }

  }
  m->nbonds = m->nbonds + 1;
  if(!(m->bonds_size >= m->nbonds))
  {
    m->bonds_size = m->bonds_size + 20;
    void *return_value_realloc_4;
    return_value_realloc_4=realloc((void *)m->bonds, (unsigned long int)m->bonds_size * sizeof(struct anonymous_34) /*12ul*/ );
    m->bonds = (struct anonymous_34 *)return_value_realloc_4;
  }

  (m->bonds + (signed long int)(m->nbonds - 1))->from = from;
  (m->bonds + (signed long int)(m->nbonds - 1))->to = to;
  (m->bonds + (signed long int)(m->nbonds - 1))->strength = 1;

__CPROVER_DUMP_L11:
  ;
}

// reshape_molecule
// file molecule.c line 1183
static void reshape_molecule(struct ModeInfo *mi, signed int width, signed int height)
{
  float h = (float)height / (float)width;
  glViewport(0, 0, (signed int)width, (signed int)height);
  glMatrixMode((unsigned int)0x1701);
  glLoadIdentity();
  gluPerspective(30.0, (double)((float)1 / h), 20.0, 100.0);
  glMatrixMode((unsigned int)0x1700);
  glLoadIdentity();
  gluLookAt(0.0, 0.0, 30.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
  glClear((unsigned int)0x00004000);
}

// rgb_to_hsv
// file hsv.c line 52
extern void rgb_to_hsv(unsigned short int r, unsigned short int g, unsigned short int b, signed int *h, double *s, double *v)
{
  double R;
  double G;
  double B;
  double H;
  double S;
  double V;
  double cmax;
  double cmin;
  double cmm;
  signed int imax;
  R = (double)r / 65535.0;
  G = (double)g / 65535.0;
  B = (double)b / 65535.0;
  cmax = R;
  cmin = G;
  imax = 1;
  if(cmax < G)
  {
    cmax = G;
    cmin = R;
    imax = 2;
  }

  if(cmax < B)
  {
    cmax = B;
    imax = 3;
  }

  if(cmin > B)
    cmin = B;

  cmm = cmax - cmin;
  V = cmax;
  if(IEEE_FLOAT_EQUAL(cmm, 0.000000))
  {
    H = (double)0;
    S = H;
  }

  else
  {
    S = cmm / cmax;
    if(imax == 1)
      H = (G - B) / cmm;

    else
      if(imax == 2)
        H = 2.0 + (B - R) / cmm;

      else
        H = 4.0 + (R - G) / cmm;
    if(H < 0.000000)
      H = H + 6.0;

  }
  *h = (signed int)(H * 60.0);
  *s = S;
  *v = V;
}

// rotate_1
// file rotator.c line 45
static void rotate_1(double *pos, double *v, double *dv, double speed, double max_v)
{
  double ppos = *pos;
  unsigned int return_value_ya_random_5;
  if(!IEEE_FLOAT_EQUAL(speed, 0.000000))
  {
    if(ppos < 0.000000)
      ppos = -(ppos + *v);

    else
      ppos = ppos + *v;
    if(ppos > 1.0)
      ppos = ppos - 1.0;

    else
      if(ppos < 0.000000)
        ppos = ppos + 1.0;

    if(ppos < 0.000000)
      abort();

    if(ppos > 1.0)
      abort();

    *pos = *pos > (double)0 ? ppos : -ppos;
    *v = *v + *dv;
    _Bool tmp_if_expr_3;
    if(*v > max_v)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = *v < -max_v ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      *dv = -(*dv);

    else
      if(*v < 0.000000)
      {
        unsigned int return_value_ya_random_2;
        return_value_ya_random_2=ya_random();
        if(!(return_value_ya_random_2 % 4u == 0u))
        {
          *v = (double)0;
          unsigned int return_value_ya_random_1;
          return_value_ya_random_1=ya_random();
          if(!(return_value_ya_random_1 % 2u == 0u))
            *dv = (double)0;

          else
            if(*dv < 0.000000)
              *dv = -(*dv);

        }

        else
        {
          *v = -(*v);
          *dv = -(*dv);
          *pos = -(*pos);
        }
      }

    unsigned int return_value_ya_random_4;
    return_value_ya_random_4=ya_random();
    if(return_value_ya_random_4 % 120u == 0u)
      *dv = -(*dv);

    unsigned int return_value_ya_random_6;
    return_value_ya_random_6=ya_random();
    if(return_value_ya_random_6 % 200u == 0u)
    {
      if(IEEE_FLOAT_EQUAL(*dv, 0.000000))
        *dv = 0.00001;

      else
      {
        return_value_ya_random_5=ya_random();
        if(!((1u & return_value_ya_random_5) == 0u))
          *dv = *dv * 1.2;

        else
          *dv = *dv * 0.8;
      }
    }

  }

}

// rotate_colors
// file colors.c line 711
extern void rotate_colors(struct anonymous_15 *screen, unsigned long int cmap, struct anonymous_27 *colors, signed int ncolors, signed int distance)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_15 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int i;
  struct anonymous_27 *colors2;
  if(ncolors >= 2)
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct anonymous_27) /*16ul*/  * (unsigned long int)ncolors);
    colors2 = (struct anonymous_27 *)return_value_malloc_2;
    distance = distance % ncolors;
    i = 0;
    for( ; !(i >= ncolors); i = i + 1)
    {
      signed int j = i - distance;
      if(j >= ncolors)
        j = j - ncolors;

      if(!(j >= 0))
        j = j + ncolors;

      colors2[(signed long int)i] = colors[(signed long int)j];
      (colors2 + (signed long int)i)->pixel = (colors + (signed long int)i)->pixel;
    }
    XStoreColors(dpy, cmap, colors2, ncolors);
    XFlush(dpy);
    memcpy((void *)colors, (const void *)colors2, sizeof(struct anonymous_27) /*16ul*/  * (unsigned long int)ncolors);
    free((void *)colors2);
  }

}

// run_screenhack_table
// file screenhack.c line 536
static void run_screenhack_table(struct _XDisplay *dpy, unsigned long int window, unsigned long int window2, struct xscreensaver_function_table *ft)
{
  void * (*init_cb)(struct _XDisplay *, unsigned long int, void *) = (void * (*)(struct _XDisplay *, unsigned long int, void *))ft->init_cb;
  void (*fps_cb)(struct _XDisplay *, unsigned long int, struct fps_state *, void *) = ft->fps_cb;
  void *closure;
  closure=init_cb(dpy, window, ft->setup_arg);
  struct fps_state *fpst;
  fpst=fps_init(dpy, window);
  void *closure2 = NULL;
  struct fps_state *fpst2 = ((struct fps_state *)NULL);
  if(!(window2 == 0ul))
    closure2=init_cb(dpy, window2, ft->setup_arg);

  if(!(window2 == 0ul))
    fpst2=fps_init(dpy, window2);

  if(closure == NULL)
    abort();

  if(fps_cb == ((void (*)(struct _XDisplay *, unsigned long int, struct fps_state *, void *))NULL))
    fps_cb = screenhack_do_fps;

  {
    unsigned long int delay;
    delay=ft->draw_cb(dpy, window, closure);
    unsigned long int delay2 = (unsigned long int)0;
    if(!(window2 == 0ul))
      delay2=ft->draw_cb(dpy, window2, closure2);

    if(!(fpst == ((struct fps_state *)NULL)))
      fps_cb(dpy, window, fpst, closure);

    if(!(fpst2 == ((struct fps_state *)NULL)))
      fps_cb(dpy, window, fpst2, closure);

    char return_value_usleep_and_process_events_1;
    return_value_usleep_and_process_events_1=usleep_and_process_events(dpy, ft, window, fpst, closure, delay, window2, fpst2, closure2, delay2);
  }
  ft->free_cb(dpy, window, closure);
  if(!(fpst == ((struct fps_state *)NULL)))
    fps_free(fpst);

  if(!(window2 == 0ul))
    ft->free_cb(dpy, window2, closure2);

  if(!(fpst2 == ((struct fps_state *)NULL)))
    fps_free(fpst2);

}

// screen_number
// file ./../../utils/visual.h line 21
extern signed int screen_number(struct anonymous_15 *screen)
{
  struct _XDisplay *dpy = screen->display;
  signed int i = 0;
  for( ; !(i >= ((struct anonymous_42 *)dpy)->nscreens); i = i + 1)
    if(((struct anonymous_42 *)dpy)->screens + (signed long int)i == screen)
      return i;

  abort();
  return 0;
}

// screenhack_do_fps
// file screenhack.c line 528
static void screenhack_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure)
{
  fps_compute(fpst, (unsigned long int)0, (double)-1);
  fps_draw(fpst);
}

// screenhack_ehandler
// file screenhack.c line 245
static signed int screenhack_ehandler(struct _XDisplay *dpy, struct anonymous_32 *error)
{
  fprintf(stderr, "\nX error in %s:\n", progname);
  signed int return_value_XmuPrintDefaultErrorMessage_1;
  return_value_XmuPrintDefaultErrorMessage_1=XmuPrintDefaultErrorMessage(dpy, error, stderr);
  if(!(return_value_XmuPrintDefaultErrorMessage_1 == 0))
    exit(-1);

  else
    fprintf(stderr, " (nonfatal.)\n");
  return 0;
}

// screenhack_event_helper
// file ./../../utils/resources.h line 39
extern signed int screenhack_event_helper(struct _XDisplay *dpy, unsigned long int window, union _XEvent *event)
{
  if(event->xany.type == 2)
  {
    unsigned long int keysym;
    char c = (char)0;
    XLookupString(&event->xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
    if(keysym == 65361ul || keysym == 65362ul || keysym == 65363ul || keysym == 65364ul || keysym == 65365ul || keysym == 65366ul || (signed int)c == 9 || (signed int)c == 10 || (signed int)c == 13 || (signed int)c == 32)
      return 1;

  }

  else
    if(event->xany.type == 4)
    {
      if(event->xbutton.button == 1u)
        return 1;

    }

  return 0;
}

// screenhack_handle_event_1
// file screenhack.c line 270
static signed int screenhack_handle_event_1(struct _XDisplay *dpy, union _XEvent *event)
{
  switch(event->xany.type)
  {
    case 2:
    {
      unsigned long int keysym;
      char c = (char)0;
      XLookupString(&event->xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
      if((signed int)c == 3 || (signed int)c == 27 || (signed int)c == 81 || (signed int)c == 113)
        return 0;

      else
        if(!(keysym >= 65505ul) || keysym >= 65519ul)
          XBell(dpy, 0);

      goto __CPROVER_DUMP_L11;
    }
    case 4:
    {
      XBell(dpy, 0);
      goto __CPROVER_DUMP_L11;
    }
    case 33:
      if(!(event->xclient.message_type == XA_WM_PROTOCOLS))
      {
        char *s;
        s=XGetAtomName(dpy, event->xclient.message_type);
        if(s == ((char *)NULL))
          s = "(null)";

        fprintf(stderr, "%s: unknown ClientMessage %s received!\n", progname, s);
      }

      else
        if(!((unsigned long int)event->xclient.data.l[0l] == XA_WM_DELETE_WINDOW))
        {
          char *s1;
          s1=XGetAtomName(dpy, event->xclient.message_type);
          char *s2;
          s2=XGetAtomName(dpy, (unsigned long int)event->xclient.data.l[(signed long int)0]);
          if(s1 == ((char *)NULL))
            s1 = "(null)";

          if(s2 == ((char *)NULL))
            s2 = "(null)";

          fprintf(stderr, "%s: unknown ClientMessage %s[%s] received!\n", progname, s1, s2);
        }

        else
          return 0;
    default:
    {

    __CPROVER_DUMP_L11:
      ;
      return 1;
    }
  }
}

// screenhack_table_handle_events
// file screenhack.c line 433
static char screenhack_table_handle_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, void *closure, unsigned long int window2, void *closure2)
{
  struct _XtAppStruct *app;
  app=XtDisplayToApplicationContext(dpy);
  unsigned long int return_value_XtAppPending_1;
  return_value_XtAppPending_1=XtAppPending(app);
  if(!((6ul & return_value_XtAppPending_1) == 0ul))
    XtAppProcessEvent(app, (unsigned long int)(2 | 4));

  signed int return_value_XPending_2;
  signed int tmp_if_expr_5;
  signed int return_value;
  signed int tmp_if_expr_4;
  signed int return_value_1;
  signed int return_value_screenhack_handle_event_1_3;
  do
  {
    return_value_XPending_2=XPending(dpy);
    if(return_value_XPending_2 == 0)
      break;

    union _XEvent event;
    XNextEvent(dpy, &event);
    if(event.xany.type == 22)
    {
      if(event.xany.window == window)
        ft->reshape_cb(dpy, window, closure, (unsigned int)event.xconfigure.width, (unsigned int)event.xconfigure.height);

      if(event.xany.window == window2 && !(window2 == 0ul))
        ft->reshape_cb(dpy, window2, closure2, (unsigned int)event.xconfigure.width, (unsigned int)event.xconfigure.height);

    }

    else
    {
      _Bool tmp_if_expr_6;
      if(event.xany.type == 33)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        if(event.xany.window == window)
        {
          return_value=ft->event_cb(dpy, window, closure, &event);
          tmp_if_expr_5 = return_value;
        }

        else
        {
          if(event.xany.window == window2 && !(window2 == 0ul))
          {
            return_value_1=ft->event_cb(dpy, window2, closure2, &event);
            tmp_if_expr_4 = return_value_1;
          }

          else
            tmp_if_expr_4 = 0;
          tmp_if_expr_5 = tmp_if_expr_4;
        }
        tmp_if_expr_6 = !(tmp_if_expr_5 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
      {
        return_value_screenhack_handle_event_1_3=screenhack_handle_event_1(dpy, &event);
        if(return_value_screenhack_handle_event_1_3 == 0)
          return (char)0;

      }

    }
    unsigned long int return_value_XtAppPending_7;
    return_value_XtAppPending_7=XtAppPending(app);
    if(!((6ul & return_value_XtAppPending_7) == 0ul))
      XtAppProcessEvent(app, (unsigned long int)(2 | 4));

  }
  while((_Bool)1);
  return (char)1;
}

// screenhack_usleep
// file ./../utils/usleep.h line 23
extern void screenhack_usleep(unsigned long int usecs)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)(usecs / (unsigned long int)1000000L);
  tv.tv_usec = (signed long int)(usecs % (unsigned long int)1000000L);
  select(0, ((struct anonymous_36 *)NULL), ((struct anonymous_36 *)NULL), ((struct anonymous_36 *)NULL), &tv);
}

// set_atom_color
// file molecule.c line 299
static void set_atom_color(struct ModeInfo *mi, const struct anonymous_33 *a, signed int font_p, float alpha)
{
  const struct anonymous_35 *d;
  float gl_color[4l];
  if(!(a == ((const struct anonymous_33 *)NULL)))
    d = a->data;

  else
    d=get_atom_data("bond");
  if(!(font_p == 0))
  {
    gl_color[(signed long int)0] = d->gl_color[(signed long int)4];
    gl_color[(signed long int)1] = d->gl_color[(signed long int)5];
    gl_color[(signed long int)2] = d->gl_color[(signed long int)6];
    gl_color[(signed long int)3] = d->gl_color[(signed long int)7];
  }

  else
  {
    gl_color[(signed long int)0] = d->gl_color[(signed long int)0];
    gl_color[(signed long int)1] = d->gl_color[(signed long int)1];
    gl_color[(signed long int)2] = d->gl_color[(signed long int)2];
    gl_color[(signed long int)3] = d->gl_color[(signed long int)3];
  }
  if(IEEE_FLOAT_EQUAL(gl_color[3l], 0.000000f))
  {
    const char *string;
    const char *tmp_if_expr_1;
    if(font_p == 0)
      tmp_if_expr_1 = d->color;

    else
      tmp_if_expr_1 = d->text_color;
    string = tmp_if_expr_1;
    struct anonymous_27 xcolor;
    signed int return_value_XParseColor_3;
    return_value_XParseColor_3=XParseColor(mi->dpy, mi->xgwa.colormap, string, &xcolor);
    if(return_value_XParseColor_3 == 0)
    {
      const char *tmp_if_expr_2;
      if(!(a == ((const struct anonymous_33 *)NULL)))
        tmp_if_expr_2 = a->label;

      else
        tmp_if_expr_2 = d->name;
      fprintf(stderr, "%s: unparsable color in %s: %s\n", progname, tmp_if_expr_2, string);
      exit(1);
    }

    gl_color[(signed long int)0] = (float)((double)xcolor.red / 65536.0);
    gl_color[(signed long int)1] = (float)((double)xcolor.green / 65536.0);
    gl_color[(signed long int)2] = (float)((double)xcolor.blue / 65536.0);
  }

  gl_color[(signed long int)3] = alpha;
  if(do_atoms == 0 && !(font_p == 0))
  {
    if(IEEE_FLOAT_EQUAL(gl_color[0l], 0.000000f))
    {
      if(IEEE_FLOAT_EQUAL(gl_color[1l], 0.000000f))
      {
        if(IEEE_FLOAT_EQUAL(gl_color[2l], 0.000000f))
        {
          gl_color[(signed long int)2] = (float)1;
          gl_color[(signed long int)1] = gl_color[(signed long int)2];
          gl_color[(signed long int)0] = gl_color[(signed long int)1];
        }

      }

    }

  }

  if(!(font_p == 0))
    glColor4f(gl_color[(signed long int)0], gl_color[(signed long int)1], gl_color[(signed long int)2], gl_color[(signed long int)3]);

  else
    glMaterialfv((unsigned int)0x0404, (unsigned int)0x1602, gl_color);
}

// special_case_formula
// file molecule.c line 1007
static void special_case_formula(char *f)
{
  signed int return_value_strcmp_8;
  return_value_strcmp_8=strcmp(f, "H[2]Be");
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(return_value_strcmp_8 == 0)
    strcpy(f, "BeH[2]");

  else
  {
    return_value_strcmp_7=strcmp(f, "H[3]B");
    if(return_value_strcmp_7 == 0)
      strcpy(f, "BH[3]");

    else
    {
      return_value_strcmp_6=strcmp(f, "H[3]N");
      if(return_value_strcmp_6 == 0)
        strcpy(f, "NH[3]");

      else
      {
        return_value_strcmp_5=strcmp(f, "CHN");
        if(return_value_strcmp_5 == 0)
          strcpy(f, "HCN");

        else
        {
          return_value_strcmp_4=strcmp(f, "CKN");
          if(return_value_strcmp_4 == 0)
            strcpy(f, "KCN");

          else
          {
            return_value_strcmp_3=strcmp(f, "H[4]N[2]");
            if(return_value_strcmp_3 == 0)
              strcpy(f, "N[2]H[4]");

            else
            {
              return_value_strcmp_2=strcmp(f, "Cl[3]P");
              if(return_value_strcmp_2 == 0)
                strcpy(f, "PCl[3]");

              else
              {
                return_value_strcmp_1=strcmp(f, "Cl[5]P");
                if(return_value_strcmp_1 == 0)
                  strcpy(f, "PCl[5]");

              }
            }
          }
        }
      }
    }
  }
}

// sphere
// file molecule.c line 247
static signed int sphere(struct anonymous_31 *mc, float x, float y, float z, float diameter, signed int wire)
{
  signed int stacks = mc->low_rez_p != 0 ? 8 : 24;
  signed int slices = mc->low_rez_p != 0 ? 14 : 48;
  glPushMatrix();
  glTranslatef(x, y, z);
  glScalef(diameter, diameter, diameter);
  unit_sphere(stacks, slices, wire);
  glPopMatrix();
  return stacks * slices;
}

// startup_blurb
// file molecule.c line 1218
static void startup_blurb(struct ModeInfo *mi)
{
  struct anonymous_31 *mc = &mcs[(signed long int)mi->screen_number];
  const char *s = "Constructing molecules...";
  print_texture_label(mi->dpy, mc->title_font, mi->xgwa.width, mi->xgwa.height, 0, s);
  glFinish();
  glXSwapBuffers(mi->dpy, mi->window);
}

// string_to_texture
// file texfont.c line 518
void string_to_texture(struct texture_font_data *data, const char *string, struct anonymous_38 *extents_ret, signed int *tex_width_ret, signed int *tex_height_ret)
{
  unsigned long int window = (&((struct anonymous_42 *)data->dpy)->screens[(signed long int)0])->root;
  unsigned long int p;
  struct anonymous_8 gcv;
  struct _XGC *gc;
  struct anonymous_17 xgwa;
  struct anonymous_12 rcolor;
  struct _XftColor xftcolor;
  struct _XftDraw *xftdraw;
  signed int width;
  signed int height;
  struct anonymous_38 overall;
  XGetWindowAttributes(data->dpy, window, &xgwa);
  iterate_texture_string(data, string, 0, 0, ((struct _XftDraw *)NULL), ((struct _XftColor *)NULL), &overall);
  width = (signed int)overall.rbearing - (signed int)overall.lbearing;
  height = (signed int)overall.ascent + (signed int)overall.descent;
  if(!(width >= 1))
    width = 1;

  if(!(height >= 1))
    height = 1;

  p=XCreatePixmap(data->dpy, window, (unsigned int)width, (unsigned int)height, (unsigned int)xgwa.depth);
  gcv.foreground = xgwa.screen->black_pixel;
  gc=XCreateGC(data->dpy, p, (unsigned long int)(1L << 2), &gcv);
  XFillRectangle(data->dpy, p, gc, 0, 0, (unsigned int)width, (unsigned int)height);
  XFreeGC(data->dpy, gc);
  rcolor.alpha = (unsigned short int)0xFFFF;
  rcolor.blue = rcolor.alpha;
  rcolor.green = rcolor.blue;
  rcolor.red = rcolor.green;
  XftColorAllocValue(data->dpy, xgwa.visual, xgwa.colormap, &rcolor, &xftcolor);
  xftdraw=XftDrawCreate(data->dpy, p, xgwa.visual, xgwa.colormap);
  iterate_texture_string(data, string, -((signed int)overall.lbearing), (signed int)overall.ascent, xftdraw, &xftcolor, ((struct anonymous_38 *)NULL));
  XftDrawDestroy(xftdraw);
  XftColorFree(data->dpy, xgwa.visual, xgwa.colormap, &xftcolor);
  bitmap_to_texture(data->dpy, p, xgwa.visual, xgwa.depth, &width, &height);
  XFreePixmap(data->dpy, p);
  if(!(extents_ret == ((struct anonymous_38 *)NULL)))
    *extents_ret = overall;

  if(!(tex_width_ret == ((signed int *)NULL)))
    *tex_width_ret = width;

  if(!(tex_height_ret == ((signed int *)NULL)))
    *tex_height_ret = height;

}

// string_width
// file fps.c line 175
static signed int string_width(struct anonymous_1 *f, const char *c, signed int *height_ret)
{
  signed int x = 0;
  signed int max_w = 0;
  signed int h = f->ascent + f->descent;
  while(!(*c == 0))
  {
    signed int cc = (signed int)*((unsigned char *)c);
    if((signed int)*c == 10)
    {
      if(!(max_w >= x))
        max_w = x;

      x = 0;
      h = h + f->ascent + f->descent;
    }

    else
    {
      signed int tmp_if_expr_1;
      if(!(f->per_char == ((struct anonymous_38 *)NULL)))
        tmp_if_expr_1 = (signed int)(f->per_char + (signed long int)((unsigned int)cc - f->min_char_or_byte2))->width;

      else
        tmp_if_expr_1 = (signed int)f->min_bounds.rbearing;
      x = x + tmp_if_expr_1;
    }
    c = c + 1l;
  }
  if(!(max_w >= x))
    max_w = x;

  if(!(height_ret == ((signed int *)NULL)))
    *height_ret = h;

  return max_w;
}

// tb_project_to_sphere
// file trackball.c line 226
static float tb_project_to_sphere(float r, float x, float y)
{
  float d;
  float t;
  float z;
  double return_value_sqrt_1;
  return_value_sqrt_1=sqrt((double)(x * x + y * y));
  d = (float)return_value_sqrt_1;
  if((double)d < (double)r * 0.70710678118654752440)
  {
    double return_value_sqrt_2;
    return_value_sqrt_2=sqrt((double)(r * r - d * d));
    z = (float)return_value_sqrt_2;
  }

  else
  {
    t = (float)((double)r / 1.41421356237309504880);
    z = (t * t) / d;
  }
  return z;
}

// texture_string_metrics
// file texfont.h line 26
extern void texture_string_metrics(struct texture_font_data *data, const char *s, struct anonymous_38 *metrics_ret, signed int *ascent_ret, signed int *descent_ret)
{
  if(!(metrics_ret == ((struct anonymous_38 *)NULL)))
    iterate_texture_string(data, s, 0, 0, ((struct _XftDraw *)NULL), ((struct _XftColor *)NULL), metrics_ret);

  if(!(ascent_ret == ((signed int *)NULL)))
    *ascent_ret = data->xftfont->ascent;

  if(!(descent_ret == ((signed int *)NULL)))
    *descent_ret = data->xftfont->descent;

}

// thread_memory_alignment
// file thread_util.h line 112
unsigned int thread_memory_alignment(struct _XDisplay *dpy)
{
  threads_available(dpy);
  return (unsigned int)_cache_line_size;
}

// threadpool_create
// file thread_util.c line 713
signed int threadpool_create(struct threadpool *self, struct threadpool_class *cls, struct _XDisplay *dpy, unsigned int count)
{
  threads_available(dpy);
  self->count = count;
  /* assertion cls */
  assert(cls != ((struct threadpool_class *)NULL));
  self->thread_size = cls->size;
  self->thread_destroy = cls->destroy;
  void *thread;
  unsigned int i;
  unsigned int count_serial;
  count_serial=_threadpool_count_serial(self);
  if(!(count_serial == 0u))
  {
    thread=malloc(cls->size * (unsigned long int)count_serial);
    if(thread == NULL)
      return 12;

  }

  else
    thread = (void *)0;
  self->serial_threads = thread;
  i = (unsigned int)0;
  if(!(i == count_serial))
  {
    signed int error;
    error=cls->create(thread, self, i);
    if(!(error == 0))
    {
      self->count = i;
      _serial_destroy(self);
      return error;
    }

    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  signed int return_value_pthread_cond_wait_3;
  if(_has_pthread >= 0)
  {
    unsigned int count_parallel;
    count_parallel=_threadpool_count_parallel(self);
    self->mutex = mutex_initializer;
    self->cond = cond_initializer;
    self->parallel_pending = (unsigned int)0;
    self->parallel_unfinished = (unsigned int)0;
    if(count_parallel == 0u)
    {
      self->parallel_threads = (unsigned long int *)(void *)0;
      return 0;
    }

    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)count_parallel);
    self->parallel_threads = (unsigned long int *)return_value_malloc_1;
    if(self->parallel_threads == ((unsigned long int *)NULL))
      return 12;

    struct _parallel_startup_type startup;
    startup.parent = self;
    startup.thread_create = cls->create;
    startup.last_errno = 0;
    signed int return_value_pthread_mutex_lock_2;
    return_value_pthread_mutex_lock_2=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_2 != 0));
    _add_next_thread(&startup);
    if(startup.last_errno == 0)
      while(!(self->parallel_unfinished == count_parallel))
      {
        if(self->parallel_threads == ((unsigned long int *)NULL))
          break;

        return_value_pthread_cond_wait_3=pthread_cond_wait(&self->cond, &self->mutex);
        /* assertion !(pthread_cond_wait(&self->cond, &self->mutex)) */
        assert(!(return_value_pthread_cond_wait_3 != 0));
      }

    if(!(startup.last_errno == 0))
      _unlock_and_destroy(self);

    else
    {
      self->parallel_unfinished = (unsigned int)0;
      signed int return_value_pthread_mutex_unlock_4;
      return_value_pthread_mutex_unlock_4=pthread_mutex_unlock(&self->mutex);
      /* assertion !(pthread_mutex_unlock(&self->mutex)) */
      assert(!(return_value_pthread_mutex_unlock_4 != 0));
    }
    return startup.last_errno;
  }

  return 0;
}

// threadpool_destroy
// file thread_util.c line 812
void threadpool_destroy(struct threadpool *self)
{
  if(_has_pthread >= 0)
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    _unlock_and_destroy(self);
    goto __CPROVER_DUMP_L2;
  }

  _serial_destroy(self);

__CPROVER_DUMP_L2:
  ;
}

// threadpool_run
// file thread_util.c line 826
void threadpool_run(struct threadpool *self, void (*func)(void *))
{
  if(_has_pthread >= 0)
  {
    unsigned int threadpool_run__1__1__count;
    threadpool_run__1__1__count=_threadpool_count_parallel(self);
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    /* assertion !self->parallel_pending */
    assert(!(self->parallel_pending != 0u));
    /* assertion !self->parallel_unfinished */
    assert(!(self->parallel_unfinished != 0u));
    self->parallel_pending = threadpool_run__1__1__count;
    self->parallel_unfinished = threadpool_run__1__1__count;
    self->thread_run = func;
    signed int return_value_pthread_cond_broadcast_2;
    return_value_pthread_cond_broadcast_2=pthread_cond_broadcast(&self->cond);
    /* assertion !(pthread_cond_broadcast(&self->cond)) */
    assert(!(return_value_pthread_cond_broadcast_2 != 0));
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&self->mutex);
    /* assertion !(pthread_mutex_unlock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
  }

  void *thread = self->serial_threads;
  unsigned int i;
  unsigned int count;
  count=_threadpool_count_serial(self);
  i = (unsigned int)0;
  if(!(i == count))
  {
    func(thread);
    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

}

// threadpool_wait
// file thread_util.c line 858
void threadpool_wait(struct threadpool *self)
{
  signed int return_value_pthread_cond_wait_2;
  if(_has_pthread >= 0)
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    while(!(self->parallel_unfinished == 0u))
    {
      return_value_pthread_cond_wait_2=pthread_cond_wait(&self->cond, &self->mutex);
      /* assertion !(pthread_cond_wait(&self->cond, &self->mutex)) */
      assert(!(return_value_pthread_cond_wait_2 != 0));
    }
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&self->mutex);
    /* assertion !(pthread_mutex_unlock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
  }

}

// threads_available
// file thread_util.h line 93
signed int threads_available(struct _XDisplay *dpy)
{
  if(_has_pthread == 0)
  {
    _has_pthread = (signed int)200809L;
    if(_has_pthread >= 0)
    {
      signed int return_value_get_boolean_resource_2;
      return_value_get_boolean_resource_2=get_boolean_resource(dpy, "useThreads", "Boolean");
      if(!(return_value_get_boolean_resource_2 == 0))
      {
        unsigned int return_value__get_cache_line_size_1;
        return_value__get_cache_line_size_1=_get_cache_line_size();
        _cache_line_size = (signed int)return_value__get_cache_line_size_1;
        /* assertion _cache_line_size >= sizeof(void *) */
        assert((unsigned long int)_cache_line_size >= sizeof(void *) /*8ul*/ );
        /* assertion ((_cache_line_size) > 0 && !((_cache_line_size) & ((_cache_line_size) - 1))) */
        assert(_cache_line_size > 0 && !((_cache_line_size & _cache_line_size - 1) != 0));
      }

      else
        _has_pthread = -1;
    }

  }

  return _has_pthread;
}

// to_pow2
// file texfont.c line 87
static signed int to_pow2(signed int i)
{
  signed int j = 0;
  static const unsigned int pow2[17l] = { (const unsigned int)1, (const unsigned int)2, (const unsigned int)4, (const unsigned int)8, (const unsigned int)16, (const unsigned int)32, (const unsigned int)64, (const unsigned int)128, (const unsigned int)256, (const unsigned int)512, (const unsigned int)1024, (const unsigned int)2048, (const unsigned int)4096, (const unsigned int)8192, (const unsigned int)16384, (const unsigned int)32768, (const unsigned int)65536 };
  for( ; !((unsigned long int)j >= 17ul); j = j + 1)
    if(pow2[(signed long int)j] >= (unsigned int)i)
      return (signed int)pow2[(signed long int)j];

  abort();
}

// trackball
// file trackball.c line 167
void trackball(float *q, float p1x, float p1y, float p2x, float p2y)
{
  float trackball__1__a[3l];
  float phi;
  float p1[3l];
  float p2[3l];
  float d[3l];
  float t;
  if(IEEE_FLOAT_EQUAL(p1x, p2x) && IEEE_FLOAT_EQUAL(p1y, p2y))
  {
    vzero(q);
    q[(signed long int)3] = (float)1.0;
  }

  else
  {
    float return_value_tb_project_to_sphere_1;
    return_value_tb_project_to_sphere_1=tb_project_to_sphere((float)0.8, p1x, p1y);
    vset(p1, p1x, p1y, return_value_tb_project_to_sphere_1);
    float return_value_tb_project_to_sphere_2;
    return_value_tb_project_to_sphere_2=tb_project_to_sphere((float)0.8, p2x, p2y);
    vset(p2, p2x, p2y, return_value_tb_project_to_sphere_2);
    vcross(p2, p1, trackball__1__a);
    vsub(p1, p2, d);
    float return_value_vlength_3;
    return_value_vlength_3=vlength(d);
    t = (float)((double)return_value_vlength_3 / (2.0 * 0.8));
    if(t > 1.000000f)
      t = (float)1.0;

    if(t < -1.000000f)
      t = (float)-1.0;

    double return_value_asin_4;
    return_value_asin_4=asin((double)t);
    phi = (float)(2.0 * return_value_asin_4);
    axis_to_quat(trackball__1__a, phi, q);
  }
}

// tube
// file tube.h line 19
extern signed int tube(float x1, float y1, float z1, float x2, float y2, float z2, float diameter, float cap_size, signed int faces, signed int smooth, signed int caps_p, signed int wire_p)
{
  signed int return_value_tube_1_1;
  return_value_tube_1_1=tube_1(x1, y1, z1, x2, y2, z2, diameter, cap_size, faces, smooth, caps_p, wire_p, 0);
  return return_value_tube_1_1;
}

// tube_1
// file tube.c line 337
static signed int tube_1(float x1, float y1, float z1, float x2, float y2, float z2, float diameter, float cap_size, signed int faces, signed int smooth, signed int caps_p, signed int wire_p, signed int cone_p)
{
  float length;
  float X;
  float Y;
  float Z;
  signed int polys = 0;
  if(diameter <= 0.000000f)
    abort();

  X = x2 - x1;
  Y = y2 - y1;
  Z = z2 - z1;
  if(IEEE_FLOAT_EQUAL(X, 0.000000f) && IEEE_FLOAT_EQUAL(Y, 0.000000f) && IEEE_FLOAT_EQUAL(Z, 0.000000f))
    return 0;

  else
  {
    double return_value_sqrt_1;
    return_value_sqrt_1=sqrt((double)(X * X + Y * Y + Z * Z));
    length = (float)return_value_sqrt_1;
    glPushMatrix();
    glTranslatef(x1, y1, z1);
    double return_value_atan2_2;
    return_value_atan2_2=atan2((double)X, (double)Y);
    glRotatef((float)(-return_value_atan2_2 * ((double)180 / 3.14159265358979323846)), (float)0, (float)0, (float)1);
    double return_value_sqrt_3;
    return_value_sqrt_3=sqrt((double)(X * X + Y * Y));
    double return_value_atan2_4;
    return_value_atan2_4=atan2((double)Z, return_value_sqrt_3);
    glRotatef((float)(return_value_atan2_4 * ((double)180 / 3.14159265358979323846)), (float)1, (float)0, (float)0);
    glScalef(diameter, length, diameter);
    if(IEEE_FLOAT_NOTEQUAL(cap_size, 0.000000f))
    {
      float c = cap_size / length;
      glTranslatef((float)0, -c, (float)0);
      glScalef((float)1, (float)1 + c + c, (float)1);
    }

    if(!(cone_p == 0))
      polys=unit_cone(faces, smooth, caps_p, wire_p);

    else
      polys=unit_tube(faces, smooth, caps_p, wire_p);
    glPopMatrix();
    return polys;
  }
}

// uc_truncate
// file utf8wc.c line 38
static unsigned long int uc_truncate(unsigned long int uc)
{
  uc = uc & (unsigned long int)0x7FFFFFFFL;
  if(uc >= 1114112ul)
    uc = (unsigned long int)0xFFFD;

  if(uc == 0ul)
    uc = (unsigned long int)0xFFFD;

  if(uc >= 55296ul && !(uc >= 57344ul))
    uc = (unsigned long int)0xFFFD;

  return uc;
}

// unit_cone
// file tube.c line 199
static signed int unit_cone(signed int faces, signed int smooth, signed int cap_p, signed int wire_p)
{
  signed int i;
  signed int polys = 0;
  float step = (float)((3.14159265358979323846 * (double)2) / (double)faces);
  float s2 = step / (float)2;
  float th;
  float x;
  float unit_cone__1__y;
  float x0;
  float y0;
  signed int arraysize;
  signed int out;
  /* tag-#anon#lST[SYM#tag-#anon#ST[F32'x'|F32'y'|F32'z']#'p'|SYM#tag-#anon#ST[F32'x'|F32'y'|F32'z']#'n'|F32's'|F32't'] */
struct anonymous_11
{
  // p
  struct anonymous_9 p;
  // n
  struct anonymous_9 n;
  // s
  float s;
  // t
  float t;
};

/* */
  ;
  struct anonymous_11 *array;
  arraysize = (faces + 1) * 3;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)arraysize, sizeof(struct anonymous_11) /*32ul*/ );
  array = (struct anonymous_11 *)(void *)return_value_calloc_1;
  if(array == ((struct anonymous_11 *)NULL))
    abort();

  out = 0;
  th = (float)0;
  x = (float)1;
  unit_cone__1__y = (float)0;
  double return_value_cos_2;
  return_value_cos_2=cos((double)s2);
  x0 = (float)return_value_cos_2;
  double return_value_sin_3;
  return_value_sin_3=sin((double)s2);
  y0 = (float)return_value_sin_3;
  i = 0;
  for( ; !(i >= faces); i = i + 1)
  {
    (array + (signed long int)out)->p.x = x;
    (array + (signed long int)out)->p.y = (float)0;
    (array + (signed long int)out)->p.z = unit_cone__1__y;
    if(!(smooth == 0))
      (array + (signed long int)out)->n = (array + (signed long int)out)->p;

    else
    {
      (array + (signed long int)out)->n.x = x0;
      (array + (signed long int)out)->n.y = (float)0;
      (array + (signed long int)out)->n.z = y0;
    }
    out = out + 1;
    (array + (signed long int)out)->p.x = (float)0;
    (array + (signed long int)out)->p.y = (float)1;
    (array + (signed long int)out)->p.z = (float)0;
    (array + (signed long int)out)->n.x = x0;
    (array + (signed long int)out)->n.y = (float)0;
    (array + (signed long int)out)->n.z = y0;
    out = out + 1;
    th = th + step;
    double return_value_cos_4;
    return_value_cos_4=cos((double)(th + s2));
    x0 = (float)return_value_cos_4;
    double return_value_sin_5;
    return_value_sin_5=sin((double)(th + s2));
    y0 = (float)return_value_sin_5;
    double return_value_cos_6;
    return_value_cos_6=cos((double)th);
    x = (float)return_value_cos_6;
    double return_value_sin_7;
    return_value_sin_7=sin((double)th);
    unit_cone__1__y = (float)return_value_sin_7;
    (array + (signed long int)out)->p.x = x;
    (array + (signed long int)out)->p.y = (float)0;
    (array + (signed long int)out)->p.z = unit_cone__1__y;
    if(!(smooth == 0))
      (array + (signed long int)out)->n = (array + (signed long int)out)->p;

    else
      (array + (signed long int)out)->n = (array + (signed long int)(out - 1))->n;
    out = out + 1;
    if(out >= arraysize)
      abort();

    polys = polys + 1;
  }
  glEnableClientState((unsigned int)0x8074);
  glEnableClientState((unsigned int)0x8075);
  glEnableClientState((unsigned int)0x8078);
  glVertexPointer(3, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->p);
  glNormalPointer((unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->n);
  glTexCoordPointer(2, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->s);
  glFrontFace((unsigned int)0x0901);
  glDrawArrays((unsigned int)(wire_p != 0 ? 0x0001 : 0x0004), 0, out);
  if(!(cap_p == 0))
  {
    out = 0;
    if(wire_p == 0)
    {
      (array + (signed long int)out)->p.x = (float)0;
      (array + (signed long int)out)->p.y = (float)0;
      (array + (signed long int)out)->p.z = (float)0;
      (array + (signed long int)out)->n.x = (float)0;
      (array + (signed long int)out)->n.y = (float)-1;
      (array + (signed long int)out)->n.z = (float)0;
      out = out + 1;
    }

    i = 0;
    th = (float)0;
    for( ; faces >= i; i = i + 1)
    {
      float unit_cone__1__2__2__x;
      double return_value_cos_8;
      return_value_cos_8=cos((double)th);
      unit_cone__1__2__2__x = (float)return_value_cos_8;
      float y;
      double return_value_sin_9;
      return_value_sin_9=sin((double)th);
      y = (float)return_value_sin_9;
      array[(signed long int)out] = array[(signed long int)0];
      (array + (signed long int)out)->p.x = unit_cone__1__2__2__x;
      (array + (signed long int)out)->p.y = (float)0;
      (array + (signed long int)out)->p.z = y;
      out = out + 1;
      th = th + step;
      polys = polys + 1;
      if(out >= arraysize)
        abort();

    }
    glVertexPointer(3, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->p);
    glNormalPointer((unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->n);
    glTexCoordPointer(2, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->s);
    glFrontFace((unsigned int)0x0901);
    glDrawArrays((unsigned int)(wire_p != 0 ? 0x0002 : 0x0006), 0, out);
  }

  free((void *)array);
  return polys;
}

// unit_dome
// file sphere.c line 152
extern signed int unit_dome(signed int stacks, signed int slices, signed int wire_p)
{
  signed int return_value_unit_sphere_1_1;
  return_value_unit_sphere_1_1=unit_sphere_1(stacks, slices, wire_p, 1);
  return return_value_unit_sphere_1_1;
}

// unit_sphere
// file sphere.h line 21
extern signed int unit_sphere(signed int stacks, signed int slices, signed int wire_p)
{
  signed int return_value_unit_sphere_1_1;
  return_value_unit_sphere_1_1=unit_sphere_1(stacks, slices, wire_p, 0);
  return return_value_unit_sphere_1_1;
}

// unit_sphere_1
// file sphere.c line 43
static signed int unit_sphere_1(signed int stacks, signed int slices, signed int wire_p, signed int half_p)
{
  signed int polys = 0;
  signed int i;
  signed int j;
  double theta1;
  double theta2;
  double theta3;
  struct anonymous_9 p;
  struct anonymous_9 n;
  struct anonymous_9 la = { .x=(float)0, .y=(float)-1, .z=(float)0 };
  struct anonymous_9 lb = { .x=(float)0, .y=(float)-1, .z=(float)0 };
  struct anonymous_9 c = { .x=(float)0, .y=(float)0, .z=(float)0 };
  double r = 1.0;
  signed int stacks2 = stacks * 2;
  signed int end = half_p != 0 ? stacks / 2 : stacks;
  signed int mode = wire_p != 0 ? 0x0003 : 0x0005;
  signed int arraysize;
  signed int out;
  /* tag-#anon#lST[SYM#tag-#anon#ST[F32'x'|F32'y'|F32'z']#'p'|SYM#tag-#anon#ST[F32'x'|F32'y'|F32'z']#'n'|F32's'|F32't'] */
struct anonymous_11
{
  // p
  struct anonymous_9 p;
  // n
  struct anonymous_9 n;
  // s
  float s;
  // t
  float t;
};

/* */
  ;
  struct anonymous_11 *array;
  if(r < 0.000000)
    r = -r;

  if(!(slices >= 0))
    slices = -slices;

  arraysize = (stacks + 1) * (slices + 1) * (wire_p != 0 ? 4 : 2);
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)arraysize, sizeof(struct anonymous_11) /*32ul*/ );
  array = (struct anonymous_11 *)(void *)return_value_calloc_1;
  if(array == ((struct anonymous_11 *)NULL))
    abort();

  out = 0;
  if(r <= 0.000000 || !(slices >= 4) || !(stacks >= 2))
  {
    mode = 0x0000;
    signed int tmp_post_2 = out;
    out = out + 1;
    (array + (signed long int)tmp_post_2)->p = c;
  }

  else
  {
    j = 0;
    for( ; !(j >= end); j = j + 1)
    {
      theta1 = ((double)j * (3.14159265358979323846 + 3.14159265358979323846)) / (double)stacks2 - 1.57079632679489661923;
      theta2 = ((double)(j + 1) * (3.14159265358979323846 + 3.14159265358979323846)) / (double)stacks2 - 1.57079632679489661923;
      i = slices;
      for( ; i >= 0; i = i - 1)
      {
        theta3 = ((double)i * (3.14159265358979323846 + 3.14159265358979323846)) / (double)slices;
        if(!(wire_p == 0))
        {
          signed int tmp_post_3 = out;
          out = out + 1;
          (array + (signed long int)tmp_post_3)->p = lb;
          signed int tmp_post_4 = out;
          out = out + 1;
          (array + (signed long int)tmp_post_4)->p = la;
        }

        double return_value_cos_5;
        return_value_cos_5=cos(theta2);
        double return_value_cos_6;
        return_value_cos_6=cos(theta3);
        n.x = (float)(return_value_cos_5 * return_value_cos_6);
        double return_value_sin_7;
        return_value_sin_7=sin(theta2);
        n.y = (float)return_value_sin_7;
        double return_value_cos_8;
        return_value_cos_8=cos(theta2);
        double return_value_sin_9;
        return_value_sin_9=sin(theta3);
        n.z = (float)(return_value_cos_8 * return_value_sin_9);
        p.x = (float)((double)c.x + r * (double)n.x);
        p.y = (float)((double)c.y + r * (double)n.y);
        p.z = (float)((double)c.z + r * (double)n.z);
        (array + (signed long int)out)->p = p;
        (array + (signed long int)out)->n = n;
        (array + (signed long int)out)->s = (float)i / (float)slices;
        (array + (signed long int)out)->t = (float)(2 * (j + 1)) / (float)stacks2;
        out = out + 1;
        if(!(wire_p == 0))
          la = p;

        double return_value_cos_10;
        return_value_cos_10=cos(theta1);
        double return_value_cos_11;
        return_value_cos_11=cos(theta3);
        n.x = (float)(return_value_cos_10 * return_value_cos_11);
        double return_value_sin_12;
        return_value_sin_12=sin(theta1);
        n.y = (float)return_value_sin_12;
        double return_value_cos_13;
        return_value_cos_13=cos(theta1);
        double return_value_sin_14;
        return_value_sin_14=sin(theta3);
        n.z = (float)(return_value_cos_13 * return_value_sin_14);
        p.x = (float)((double)c.x + r * (double)n.x);
        p.y = (float)((double)c.y + r * (double)n.y);
        p.z = (float)((double)c.z + r * (double)n.z);
        (array + (signed long int)out)->p = p;
        (array + (signed long int)out)->n = n;
        (array + (signed long int)out)->s = (float)i / (float)slices;
        (array + (signed long int)out)->t = (float)(2 * j) / (float)stacks2;
        out = out + 1;
        if(out >= arraysize)
          abort();

        if(!(wire_p == 0))
          lb = p;

        polys = polys + 1;
      }
    }
  }

END:
  ;
  glEnableClientState((unsigned int)0x8074);
  glEnableClientState((unsigned int)0x8075);
  glEnableClientState((unsigned int)0x8078);
  glVertexPointer(3, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->p);
  glNormalPointer((unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->n);
  glTexCoordPointer(2, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->s);
  glDrawArrays((unsigned int)mode, 0, out);
  free((void *)array);
  return polys;
}

// unit_tube
// file tube.c line 38
static signed int unit_tube(signed int faces, signed int smooth, signed int caps_p, signed int wire_p)
{
  signed int i;
  signed int polys = 0;
  float step = (float)((3.14159265358979323846 * (double)2) / (double)faces);
  float s2 = step / (float)2;
  float th;
  float x;
  float y;
  float x0 = (float)0;
  float y0 = (float)0;
  signed int z = 0;
  signed int arraysize;
  signed int out;
  /* tag-#anon#lST[SYM#tag-#anon#ST[F32'x'|F32'y'|F32'z']#'p'|SYM#tag-#anon#ST[F32'x'|F32'y'|F32'z']#'n'|F32's'|F32't'] */
struct anonymous_11
{
  // p
  struct anonymous_9 p;
  // n
  struct anonymous_9 n;
  // s
  float s;
  // t
  float t;
};

/* */
  ;
  struct anonymous_11 *array;
  arraysize = (faces + 1) * 6;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)arraysize, sizeof(struct anonymous_11) /*32ul*/ );
  array = (struct anonymous_11 *)(void *)return_value_calloc_1;
  if(array == ((struct anonymous_11 *)NULL))
    abort();

  out = 0;
  th = (float)0;
  x = (float)1;
  y = (float)0;
  if(smooth == 0)
  {
    double return_value_cos_2;
    return_value_cos_2=cos((double)s2);
    x0 = (float)return_value_cos_2;
    double return_value_sin_3;
    return_value_sin_3=sin((double)s2);
    y0 = (float)return_value_sin_3;
  }

  if(!(smooth == 0))
    faces = faces + 1;

  i = 0;
  for( ; !(i >= faces); i = i + 1)
  {
    (array + (signed long int)out)->p.x = x;
    (array + (signed long int)out)->p.y = (float)0;
    (array + (signed long int)out)->p.z = y;
    if(!(smooth == 0))
      (array + (signed long int)out)->n = (array + (signed long int)out)->p;

    else
    {
      (array + (signed long int)out)->n.x = x0;
      (array + (signed long int)out)->n.y = (float)0;
      (array + (signed long int)out)->n.z = y0;
    }
    out = out + 1;
    (array + (signed long int)out)->p.x = x;
    (array + (signed long int)out)->p.y = (float)1;
    (array + (signed long int)out)->p.z = y;
    (array + (signed long int)out)->n = (array + (signed long int)(out - 1))->n;
    out = out + 1;
    th = th + step;
    double return_value_cos_4;
    return_value_cos_4=cos((double)th);
    x = (float)return_value_cos_4;
    double return_value_sin_5;
    return_value_sin_5=sin((double)th);
    y = (float)return_value_sin_5;
    if(smooth == 0)
    {
      double return_value_cos_6;
      return_value_cos_6=cos((double)(th + s2));
      x0 = (float)return_value_cos_6;
      double return_value_sin_7;
      return_value_sin_7=sin((double)(th + s2));
      y0 = (float)return_value_sin_7;
      (array + (signed long int)out)->p.x = x;
      (array + (signed long int)out)->p.y = (float)1;
      (array + (signed long int)out)->p.z = y;
      (array + (signed long int)out)->n = (array + (signed long int)(out - 1))->n;
      out = out + 1;
      array[(signed long int)out] = array[(signed long int)(out - 3)];
      out = out + 1;
      array[(signed long int)out] = array[(signed long int)(out - 2)];
      out = out + 1;
      (array + (signed long int)out)->p.x = x;
      (array + (signed long int)out)->p.y = (float)0;
      (array + (signed long int)out)->p.z = y;
      (array + (signed long int)out)->n = (array + (signed long int)(out - 1))->n;
      out = out + 1;
      polys = polys + 1;
    }

    polys = polys + 1;
    if(out >= arraysize)
      abort();

  }
  glEnableClientState((unsigned int)0x8074);
  glEnableClientState((unsigned int)0x8075);
  glEnableClientState((unsigned int)0x8078);
  glVertexPointer(3, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->p);
  glNormalPointer((unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->n);
  glTexCoordPointer(2, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->s);
  glFrontFace((unsigned int)0x0901);
  glDrawArrays((unsigned int)(wire_p != 0 ? 0x0001 : (smooth != 0 ? 0x0005 : 0x0004)), 0, out);
  if(!(caps_p == 0))
  {
    z = 0;
    for( ; !(z >= 2); z = z + 1)
    {
      out = 0;
      if(wire_p == 0)
      {
        (array + (signed long int)out)->p.x = (float)0;
        (array + (signed long int)out)->p.y = (float)z;
        (array + (signed long int)out)->p.z = (float)0;
        (array + (signed long int)out)->n.x = (float)0;
        (array + (signed long int)out)->n.y = (float)(z == 0 ? -1 : 1);
        (array + (signed long int)out)->n.z = (float)0;
        out = out + 1;
      }

      th = (float)0;
      i = z == 0 ? 0 : faces;
      for( ; z == 0 ? faces >= i : i >= 0; i = i + (z == 0 ? 1 : -1))
      {
        float unit_tube__1__3__2__x;
        double return_value_cos_8;
        return_value_cos_8=cos((double)th);
        unit_tube__1__3__2__x = (float)return_value_cos_8;
        float unit_tube__1__3__2__y;
        double return_value_sin_9;
        return_value_sin_9=sin((double)th);
        unit_tube__1__3__2__y = (float)return_value_sin_9;
        array[(signed long int)out] = array[(signed long int)0];
        (array + (signed long int)out)->p.x = unit_tube__1__3__2__x;
        (array + (signed long int)out)->p.y = (float)z;
        (array + (signed long int)out)->p.z = unit_tube__1__3__2__y;
        out = out + 1;
        th = th + (z == 0 ? step : -step);
        polys = polys + 1;
        if(out >= arraysize)
          abort();

      }
      glVertexPointer(3, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->p);
      glNormalPointer((unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->n);
      glTexCoordPointer(2, (unsigned int)0x1406, (signed int)sizeof(struct anonymous_11) /*32ul*/ , (const void *)&(array + (signed long int)0)->s);
      glFrontFace((unsigned int)0x0901);
      glDrawArrays((unsigned int)(wire_p != 0 ? 0x0002 : 0x0006), 0, out);
    }
  }

  free((void *)array);
  return polys;
}

// usleep_and_process_events
// file screenhack.c line 481
static char usleep_and_process_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, struct fps_state *fpst, void *closure, unsigned long int delay, unsigned long int window2, struct fps_state *fpst2, void *closure2, unsigned long int delay2)
{
  do
  {
    unsigned long int quantum = (unsigned long int)33333;
    if(!(delay >= quantum))
      quantum = delay;

    delay = delay - quantum;
    XSync(dpy, 0);
    if(quantum >= 1ul)
    {
      screenhack_usleep(quantum);
      if(!(fpst == ((struct fps_state *)NULL)))
        fps_slept(fpst, quantum);

      if(!(fpst2 == ((struct fps_state *)NULL)))
        fps_slept(fpst2, quantum);

    }

    char return_value_screenhack_table_handle_events_1;
    return_value_screenhack_table_handle_events_1=screenhack_table_handle_events(dpy, ft, window, closure, window2, closure2);
    if(return_value_screenhack_table_handle_events_1 == 0)
      return (char)0;

  }
  while(delay >= 1ul);
  return (char)1;
}

// utf8_decode
// file utf8wc.c line 56
extern signed long int utf8_decode(const unsigned char *in, signed long int length, unsigned long int *unicode_ret)
{
  const unsigned char *start = in;
  const unsigned char *end = in + length;
  unsigned long int uc = (unsigned long int)0xFFFD;
  unsigned long int min = (unsigned long int)0;
  unsigned char c;
  if(length >= 1l)
  {
    const unsigned char *tmp_post_1 = in;
    in = in + 1l;
    c = *tmp_post_1;
    if((0xC0 & (signed int)c) == 0x80)
      uc = (unsigned long int)0xFFFD;

    else
      if((0x80 & (signed int)c) == 0)
        uc = (unsigned long int)((signed int)c & 0x7F);

      else
        if((0xE0 & (signed int)c) == 0xC0)
        {
          if(!(end >= in + 1l))
          {
            in = end;
            goto DONE;
          }

          min = (unsigned long int)(1 << 7);
          uc = (unsigned long int)(((signed int)c & 0x1F) << 6 | (signed int)in[(signed long int)0] & 0x3F);
          in = in + (signed long int)1;
        }

        else
          if((0xF0 & (signed int)c) == 0xE0)
          {
            if(!(end >= in + 2l))
            {
              in = end;
              goto DONE;
            }

            min = (unsigned long int)(1 << 11);
            uc = (unsigned long int)(((signed int)c & 0x0F) << 12 | ((signed int)in[(signed long int)0] & 0x3F) << 6 | (signed int)in[(signed long int)1] & 0x3F);
            in = in + (signed long int)2;
          }

          else
            if((0xF8 & (signed int)c) == 0xF0)
            {
              if(!(end >= in + 3l))
              {
                in = end;
                goto DONE;
              }

              min = (unsigned long int)(1 << 16);
              uc = (unsigned long int)(((signed int)c & 0x07) << 18 | ((signed int)in[(signed long int)0] & 0x3F) << 12 | ((signed int)in[(signed long int)1] & 0x3F) << 6 | (signed int)in[(signed long int)2] & 0x3F);
              in = in + (signed long int)3;
            }

            else
              if((0xFC & (signed int)c) == 0xF8)
              {
                if(!(end >= in + 4l))
                {
                  in = end;
                  goto DONE;
                }

                min = (unsigned long int)(1 << 21);
                uc = (unsigned long int)(((signed int)c & 0x03) << 24 | ((signed int)in[(signed long int)0] & 0x3F) << 18 | ((signed int)in[(signed long int)1] & 0x3F) << 12 | ((signed int)in[(signed long int)2] & 0x3F) << 6 | (signed int)in[(signed long int)3] & 0x3F);
                in = in + (signed long int)4;
              }

              else
                if((0xFE & (signed int)c) == 0xFC)
                {
                  if(!(end >= in + 5l))
                  {
                    in = end;
                    goto DONE;
                  }

                  min = (unsigned long int)(1 << 26);
                  uc = (unsigned long int)(((signed int)c & 0x01) << 30 | ((signed int)in[(signed long int)0] & 0x3F) << 24 | ((signed int)in[(signed long int)1] & 0x3F) << 18 | ((signed int)in[(signed long int)2] & 0x3F) << 12 | ((signed int)in[(signed long int)3] & 0x3F) << 6 | (signed int)in[(signed long int)4] & 0x3F);
                  in = in + (signed long int)5;
                }

                else
                  uc = (unsigned long int)0xFFFD;
  }


DONE:
  ;
  length = in - start;
  signed int i = 1;
  for( ; !((signed long int)i >= length); i = i + 1)
    if(!((0xC0 & (signed int)start[(signed long int)i]) == 0x80))
    {
      uc = (unsigned long int)0xFFFD;
      length = (signed long int)(i + 1);
      break;
    }

  if(!(uc >= min))
    uc = (unsigned long int)0xFFFD;

  uc=uc_truncate(uc);
  if(!(unicode_ret == ((unsigned long int *)NULL)))
    *unicode_ret = uc;

  return length;
}

// utf8_encode
// file utf8wc.c line 160
extern signed int utf8_encode(unsigned long int uc, char *out, signed long int length)
{
  const char *old = out;
  uc=uc_truncate(uc);
  if(length >= 1l && !(uc >= 128ul))
  {
    char *tmp_post_1 = out;
    out = out + 1l;
    *tmp_post_1 = (char)uc;
  }

  else
    if(length >= 2l && !(uc >= 2048ul))
    {
      char *tmp_post_2 = out;
      out = out + 1l;
      *tmp_post_2 = (char)((unsigned long int)0xC0 | uc >> 6 & (unsigned long int)0x1F);
      char *tmp_post_3 = out;
      out = out + 1l;
      *tmp_post_3 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
    }

    else
      if(length >= 3l && !(uc >= 65536ul))
      {
        char *tmp_post_4 = out;
        out = out + 1l;
        *tmp_post_4 = (char)((unsigned long int)0xE0 | uc >> 12 & (unsigned long int)0x0F);
        char *tmp_post_5 = out;
        out = out + 1l;
        *tmp_post_5 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
        char *tmp_post_6 = out;
        out = out + 1l;
        *tmp_post_6 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
      }

      else
        if(length >= 4l && !(uc >= 2097152ul))
        {
          char *tmp_post_7 = out;
          out = out + 1l;
          *tmp_post_7 = (char)((unsigned long int)0xF0 | uc >> 18 & (unsigned long int)0x07);
          char *tmp_post_8 = out;
          out = out + 1l;
          *tmp_post_8 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
          char *tmp_post_9 = out;
          out = out + 1l;
          *tmp_post_9 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
          char *tmp_post_10 = out;
          out = out + 1l;
          *tmp_post_10 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
        }

        else
          if(length >= 5l && !(uc >= 67108864ul))
          {
            char *tmp_post_11 = out;
            out = out + 1l;
            *tmp_post_11 = (char)((unsigned long int)0xF8 | uc >> 24 & (unsigned long int)0x03);
            char *tmp_post_12 = out;
            out = out + 1l;
            *tmp_post_12 = (char)((unsigned long int)0x80 | uc >> 18 & (unsigned long int)0x3F);
            char *tmp_post_13 = out;
            out = out + 1l;
            *tmp_post_13 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
            char *tmp_post_14 = out;
            out = out + 1l;
            *tmp_post_14 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
            char *tmp_post_15 = out;
            out = out + 1l;
            *tmp_post_15 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
          }

          else
            if(length >= 6l)
            {
              char *tmp_post_16 = out;
              out = out + 1l;
              *tmp_post_16 = (char)((unsigned long int)0xFC | uc >> 30 & (unsigned long int)0x01);
              char *tmp_post_17 = out;
              out = out + 1l;
              *tmp_post_17 = (char)((unsigned long int)0x80 | uc >> 24 & (unsigned long int)0x3F);
              char *tmp_post_18 = out;
              out = out + 1l;
              *tmp_post_18 = (char)((unsigned long int)0x80 | uc >> 18 & (unsigned long int)0x3F);
              char *tmp_post_19 = out;
              out = out + 1l;
              *tmp_post_19 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
              char *tmp_post_20 = out;
              out = out + 1l;
              *tmp_post_20 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
              char *tmp_post_21 = out;
              out = out + 1l;
              *tmp_post_21 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
            }

  return (signed int)(out - old);
}

// utf8_split
// file utf8wc.c line 256
extern char ** utf8_split(const char *string, signed int *length_ret)
{
  const unsigned char *in = (const unsigned char *)string;
  signed long int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  len = (signed long int)return_value_strlen_1;
  const unsigned char *end = in + len;
  char **ret;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(len + (signed long int)1) * sizeof(char *) /*8ul*/ );
  ret = (char **)return_value_malloc_2;
  signed int i = 0;
  if(ret == ((char **)NULL))
    return ((char **)NULL);

  else
  {
    while(!(in >= end))
    {
      unsigned long int uc;
      signed long int len2;
      len2=utf8_decode(in, len, &uc);
      char tmp[10l];
      strncpy(tmp, (char *)in, (unsigned long int)len2);
      tmp[len2] = (char)0;
      signed int tmp_post_3 = i;
      i = i + 1;
      ret[(signed long int)tmp_post_3]=strdup(tmp);
      in = in + len2;
      if(i >= 2 && uc >= 768ul && !(uc >= 880ul))
      {
        signed long int L1;
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(ret[(signed long int)(i - 2)]);
        L1 = (signed long int)return_value_strlen_4;
        signed long int L2;
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(ret[(signed long int)(i - 1)]);
        L2 = (signed long int)return_value_strlen_5;
        char *s2;
        void *return_value_malloc_6;
        return_value_malloc_6=malloc((unsigned long int)(L1 + L2 + (signed long int)1));
        s2 = (char *)return_value_malloc_6;
        strncpy(s2, ret[(signed long int)(i - 2)], (unsigned long int)L1);
        strncpy(s2 + L1, ret[(signed long int)(i - 1)], (unsigned long int)L2);
        s2[L1 + L2] = (char)0;
        free((void *)ret[(signed long int)(i - 2)]);
        ret[(signed long int)(i - 2)] = s2;
        i = i - 1;
      }

    }
    ret[(signed long int)i] = ((char *)NULL);
    void *return_value_realloc_7;
    return_value_realloc_7=realloc((void *)ret, (unsigned long int)(i + 1) * sizeof(char *) /*8ul*/ );
    ret = (char **)return_value_realloc_7;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = i;

    return ret;
  }
}

// utf8_to_XChar2b
// file utf8wc.c line 215
extern struct anonymous_13 * utf8_to_XChar2b(const char *string, signed int *length_ret)
{
  signed long int in_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  in_len = (signed long int)return_value_strlen_1;
  const unsigned char *in = (const unsigned char *)string;
  const unsigned char *in_end = in + in_len;
  struct anonymous_13 *c2b;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(in_len + (signed long int)1) * sizeof(struct anonymous_13) /*2ul*/ );
  c2b = (struct anonymous_13 *)return_value_malloc_2;
  struct anonymous_13 *out = c2b;
  if(out == ((struct anonymous_13 *)NULL))
    return ((struct anonymous_13 *)NULL);

  else
  {
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)0;
      signed long int L;
      L=utf8_decode(in, in_end - in, &uc);
      in = in + L;
      if(uc >= 65536ul)
        uc = (unsigned long int)0xFFFD;

      out->byte1 = (unsigned char)(uc >> 8 & (unsigned long int)0xFF);
      out->byte2 = (unsigned char)(uc & (unsigned long int)0xFF);
      out = out + 1l;
    }
    out->byte1 = (unsigned char)0;
    out->byte2 = (unsigned char)0;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)c2b, (unsigned long int)((out - c2b) + (signed long int)1) * sizeof(struct anonymous_13) /*2ul*/ );
    c2b = (struct anonymous_13 *)return_value_realloc_3;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = (signed int)(out - c2b);

    return c2b;
  }
}

// utf8_to_latin1
// file utf8wc.c line 347
extern char * utf8_to_latin1(const char *string, signed int ascii_p)
{
  signed long int in_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  in_len = (signed long int)return_value_strlen_1;
  const unsigned char *in = (const unsigned char *)string;
  const unsigned char *in_end = in + in_len;
  unsigned char *ret;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(in_len + (signed long int)1));
  ret = (unsigned char *)return_value_malloc_2;
  unsigned char *out = ret;
  if(ret == ((unsigned char *)NULL))
    return ((char *)NULL);

  else
  {
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)0;
      signed long int len2;
      len2=utf8_decode(in, in_end - in, &uc);
      in = in + len2;
      if(uc == 18446744073709551520ul)
        uc = (unsigned long int)32;

      else
        if(uc >= 768ul && !(uc >= 880ul))
          uc = (unsigned long int)0;

        else
          if(uc >= 256ul)
            switch(uc)
            {
              case (unsigned long int)0x2000:

              case (unsigned long int)0x2001:

              case (unsigned long int)0x2002:

              case (unsigned long int)0x2003:

              case (unsigned long int)0x2004:

              case (unsigned long int)0x2005:

              case (unsigned long int)0x2006:

              case (unsigned long int)0x2007:

              case (unsigned long int)0x2008:

              case (unsigned long int)0x2009:

              case (unsigned long int)0x200A:
              {
                uc = (unsigned long int)32;
                break;
              }
              case (unsigned long int)0x2010:

              case (unsigned long int)0x2011:

              case (unsigned long int)0x2012:

              case (unsigned long int)0x2013:

              case (unsigned long int)0x2014:

              case (unsigned long int)0x2015:
              {
                uc = (unsigned long int)45;
                break;
              }
              case (unsigned long int)0x2018:

              case (unsigned long int)0x2019:

              case (unsigned long int)0x201A:

              case (unsigned long int)0x201B:
              {
                uc = (unsigned long int)39;
                break;
              }
              case (unsigned long int)0x201C:

              case (unsigned long int)0x201D:

              case (unsigned long int)0x201E:

              case (unsigned long int)0x201F:
              {
                uc = (unsigned long int)34;
                break;
              }
              case (unsigned long int)0x2022:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x2023:
              {
                uc = (unsigned long int)-69;
                break;
              }
              case (unsigned long int)0x2027:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x202F:
              {
                uc = (unsigned long int)32;
                break;
              }
              case (unsigned long int)0x2038:
              {
                uc = (unsigned long int)94;
                break;
              }
              case (unsigned long int)0x2039:
              {
                uc = (unsigned long int)-85;
                break;
              }
              case (unsigned long int)0x203A:
              {
                uc = (unsigned long int)-69;
                break;
              }
              case (unsigned long int)0x2041:
              {
                uc = (unsigned long int)94;
                break;
              }
              case (unsigned long int)0x2042:
              {
                uc = (unsigned long int)42;
                break;
              }
              case (unsigned long int)0x2043:
              {
                uc = (unsigned long int)61;
                break;
              }
              case (unsigned long int)0x2044:
              {
                uc = (unsigned long int)47;
                break;
              }
              case (unsigned long int)0x204B:
              {
                uc = (unsigned long int)-74;
                break;
              }
              case (unsigned long int)0x204C:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x204D:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x204E:
              {
                uc = (unsigned long int)42;
                break;
              }
              case (unsigned long int)0x204F:
                uc = (unsigned long int)59;
            }

      if(uc >= 256ul)
        uc = (unsigned long int)(ascii_p != 0 ? 35 : -65);

      if(!(ascii_p == 0))
      {
        const unsigned char latin1_to_ascii[96l] = { ' ', '!', 'C', '#', '#', 'Y', '|', 'S', '_', 'C', '#', '<', '=', '-', 'R', '_', '#', '#', '2', '3', '\'', 'u', 'P', '.', ',', '1', 'o', '>', '#', '#', '#', '?', 'A', 'A', 'A', 'A', 'A', 'A', 'E', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I', 'D', 'N', 'O', 'O', 'O', 'O', 'O', 'x', '0', 'U', 'U', 'U', 'U', 'Y', 'p', 'S', 'a', 'a', 'a', 'a', 'a', 'a', 'e', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i', 'o', 'n', 'o', 'o', 'o', 'o', 'o', '/', 'o', 'u', 'u', 'u', 'u', 'y', 'p', 'y' };
        if(uc >= 160ul)
          uc = (unsigned long int)latin1_to_ascii[(signed long int)(uc - (unsigned long int)0xA0)];

      }

      if(uc >= 1ul)
      {
        unsigned char *tmp_post_3 = out;
        out = out + 1l;
        *tmp_post_3 = (unsigned char)uc;
      }

    }
    *out = (unsigned char)0;
    void *return_value_realloc_4;
    return_value_realloc_4=realloc((void *)ret, (unsigned long int)((out - ret) + (signed long int)1) * sizeof(unsigned char) /*1ul*/ );
    ret = (unsigned char *)return_value_realloc_4;
    return (char *)ret;
  }
}

// vadd
// file trackball.c line 147
static void vadd(const float *src1, const float *src2, float *dst)
{
  dst[(signed long int)0] = src1[(signed long int)0] + src2[(signed long int)0];
  dst[(signed long int)1] = src1[(signed long int)1] + src2[(signed long int)1];
  dst[(signed long int)2] = src1[(signed long int)2] + src2[(signed long int)2];
}

// validate_gl_visual
// file ./../../utils/visual.h line 31
extern signed int validate_gl_visual(struct _IO_FILE *out, struct anonymous_15 *screen, const char *window_desc, struct anonymous_16 *visual)
{
  signed int status;
  signed int value = 0;
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  unsigned int id;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_10 *)NULL))
    abort();

  status=glXGetConfig(dpy, vi_out, 1, &value);
  id = (unsigned int)vi_out->visualid;
  XFree((void *)(char *)vi_out);
  if(status == 3)
  {
    fprintf(out, "%s: display \"%s\" does not support the GLX extension.\n", progname, ((struct anonymous_42 *)dpy)->display_name);
    return 0;
  }

  else
    if(status == 4 || value == 0)
    {
      fprintf(out, "%s: %s's visual 0x%x does not support the GLX extension.\n", progname, window_desc, id);
      return 0;
    }

    else
      return 1;
}

// vcopy
// file trackball.c line 102
static void vcopy(const float *v1, float *v2)
{
  signed int i = 0;
  for( ; !(i >= 3); i = i + 1)
    v2[(signed long int)i] = v1[(signed long int)i];
}

// vcross
// file trackball.c line 110
static void vcross(const float *v1, const float *v2, float *cross)
{
  float temp[3l];
  temp[(signed long int)0] = v1[(signed long int)1] * v2[(signed long int)2] - v1[(signed long int)2] * v2[(signed long int)1];
  temp[(signed long int)1] = v1[(signed long int)2] * v2[(signed long int)0] - v1[(signed long int)0] * v2[(signed long int)2];
  temp[(signed long int)2] = v1[(signed long int)0] * v2[(signed long int)1] - v1[(signed long int)1] * v2[(signed long int)0];
  vcopy(temp, cross);
}

// vdot
// file trackball.c line 141
static float vdot(const float *v1, const float *v2)
{
  return v1[(signed long int)0] * v2[(signed long int)0] + v1[(signed long int)1] * v2[(signed long int)1] + v1[(signed long int)2] * v2[(signed long int)2];
}

// visual_cells
// file visual.c line 487
extern signed int visual_cells(struct anonymous_15 *screen, struct anonymous_16 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  signed int c;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_10 *)NULL))
    abort();

  c = (vi_out + (signed long int)0)->colormap_size;
  XFree((void *)(char *)vi_out);
  return c;
}

// visual_class
// file visual.c line 409
extern signed int visual_class(struct anonymous_15 *screen, struct anonymous_16 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  signed int c;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_10 *)NULL))
    abort();

  c = (vi_out + (signed long int)0)->class;
  XFree((void *)(char *)vi_out);
  return c;
}

// visual_depth
// file ./../utils/visual.h line 17
extern signed int visual_depth(struct anonymous_15 *screen, struct anonymous_16 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_10 vi_in;
  struct anonymous_10 *vi_out;
  signed int out_count;
  signed int d;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_10 *)NULL))
    abort();

  d = (vi_out + (signed long int)0)->depth;
  XFree((void *)(char *)vi_out);
  return d;
}

// visual_warning
// file screenhack.c line 341
static void visual_warning(struct anonymous_15 *screen, unsigned long int window, struct anonymous_16 *visual, unsigned long int cmap, signed int window_p)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  char *visual_string;
  visual_string=get_string_resource(screen->display, "visualID", "VisualID");
  struct anonymous_16 *desired_visual;
  desired_visual=pick_visual(screen);
  char win[100l];
  char why[100l];
  unsigned long int return_value_VirtualRootWindowOfScreen_1;
  return_value_VirtualRootWindowOfScreen_1=VirtualRootWindowOfScreen(screen);
  if(window == return_value_VirtualRootWindowOfScreen_1)
    strcpy(win, "root window");

  else
    sprintf(win, "window 0x%lx", (unsigned long int)window);
  if(!(window_p == 0))
    sprintf(why, "-window-id 0x%lx", (unsigned long int)window);

  else
    strcpy(why, "-root");
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_6;
  if(!(visual_string == ((char *)NULL)))
  {
    if(!(*visual_string == 0))
    {
      char *s = visual_string;
      for( ; !(*s == 0); s = s + 1l)
        if((signed int)*s >= 65)
        {
          if(!((signed int)*s >= 91))
            *s = (char)(((signed int)*s - 65) + 97);

        }

      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(visual_string, "default");
      _Bool tmp_if_expr_5;
      if(return_value_strcmp_3 == 0)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_strcmp_4=strcmp(visual_string, "default");
        tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_7;
      if(tmp_if_expr_5)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_strcmp_6=strcmp(visual_string, "best");
        tmp_if_expr_7 = !(return_value_strcmp_6 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_7)
      {
        if(!(visual == desired_visual))
        {
          fprintf(stderr, "%s: ignoring `-visual %s' because of `%s'.\n", progname, visual_string, (const void *)why);
          unsigned long int return_value_XVisualIDFromVisual_2;
          return_value_XVisualIDFromVisual_2=XVisualIDFromVisual(visual);
          fprintf(stderr, "%s: using %s's visual 0x%lx.\n", progname, (const void *)win, return_value_XVisualIDFromVisual_2);
        }

      }

      free((void *)visual_string);
    }

  }

  signed int return_value_has_writable_cells_9;
  signed int return_value_get_boolean_resource_8;
  if(visual == screen->root_visual)
  {
    return_value_has_writable_cells_9=has_writable_cells(screen, visual);
    if(!(return_value_has_writable_cells_9 == 0))
    {
      return_value_get_boolean_resource_8=get_boolean_resource(screen->display, "installColormap", "InstallColormap");
      if(!(return_value_get_boolean_resource_8 == 0))
      {
        fprintf(stderr, "%s: ignoring `-install' because of `%s'.\n", progname, (const void *)why);
        fprintf(stderr, "%s: using %s's colormap 0x%lx.\n", progname, (const void *)win, (unsigned long int)cmap);
      }

    }

  }

  if(!(ft->validate_visual_hook == ((signed int (*)(struct anonymous_15 *, const char *, struct anonymous_16 *))NULL)))
  {
    signed int return_value;
    return_value=ft->validate_visual_hook(screen, win, visual);
    if(return_value == 0)
      exit(1);

  }

}

// vlength
// file trackball.c line 121
static float vlength(const float *v)
{
  double return_value_sqrt_1;
  return_value_sqrt_1=sqrt((double)(v[(signed long int)0] * v[(signed long int)0] + v[(signed long int)1] * v[(signed long int)1] + v[(signed long int)2] * v[(signed long int)2]));
  return (float)return_value_sqrt_1;
}

// vnormal
// file trackball.c line 135
static void vnormal(float *v)
{
  float return_value_vlength_1;
  return_value_vlength_1=vlength(v);
  vscale(v, (float)(1.0 / (double)return_value_vlength_1));
}

// vscale
// file trackball.c line 127
static void vscale(float *v, float div)
{
  v[(signed long int)0] = v[(signed long int)0] * div;
  v[(signed long int)1] = v[(signed long int)1] * div;
  v[(signed long int)2] = v[(signed long int)2] * div;
}

// vset
// file trackball.c line 86
static void vset(float *v, float x, float y, float z)
{
  v[(signed long int)0] = x;
  v[(signed long int)1] = y;
  v[(signed long int)2] = z;
}

// vsub
// file trackball.c line 94
static void vsub(const float *src1, const float *src2, float *dst)
{
  dst[(signed long int)0] = src1[(signed long int)0] - src2[(signed long int)0];
  dst[(signed long int)1] = src1[(signed long int)1] - src2[(signed long int)1];
  dst[(signed long int)2] = src1[(signed long int)2] - src2[(signed long int)2];
}

// vzero
// file trackball.c line 78
static void vzero(float *v)
{
  v[(signed long int)0] = (float)0.0;
  v[(signed long int)1] = (float)0.0;
  v[(signed long int)2] = (float)0.0;
}

// xlockmore_do_fps
// file ./../xlockmore.c line 533
extern void xlockmore_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  double tmp_if_expr_1;
  if(!(mi == ((struct ModeInfo *)NULL)))
    tmp_if_expr_1 = mi->recursion_depth;

  else
    tmp_if_expr_1 = (double)-1;
  fps_compute(fpst, (unsigned long int)0, tmp_if_expr_1);
  fps_draw(fpst);
}

// xlockmore_draw
// file ./../xlockmore.c line 495
static unsigned long int xlockmore_draw(struct _XDisplay *dpy, unsigned long int window, void *closure)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  unsigned long int orig_pause = (unsigned long int)mi->pause;
  unsigned long int this_pause;
  mi->xlmft->hack_draw(mi);
  this_pause = (unsigned long int)mi->pause;
  mi->pause = (signed long int)orig_pause;
  return this_pause;
}

// xlockmore_event
// file ./../xlockmore.c line 523
static signed int xlockmore_event(struct _XDisplay *dpy, unsigned long int window, void *closure, union _XEvent *event)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  _Bool tmp_if_expr_1;
  if(!(mi == ((struct ModeInfo *)NULL)))
    tmp_if_expr_1 = mi->xlmft->hack_handle_events != ((signed int (*)(struct ModeInfo *, union _XEvent *))NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  signed int return_value;
  if(tmp_if_expr_1)
  {
    return_value=mi->xlmft->hack_handle_events(mi, event);
    return return_value;
  }

  else
    return 0;
}

// xlockmore_free
// file ./../xlockmore.c line 542
static void xlockmore_free(struct _XDisplay *dpy, unsigned long int window, void *closure)
{
  ;
}

// xlockmore_gl_compute_fps
// file ./../xlockmoreI.h line 74
extern void xlockmore_gl_compute_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  if(mi->fpst == ((struct fps_state *)NULL))
  {
    mi->fpst = fpst;
    xlockmore_gl_fps_init(fpst);
  }

  fps_compute(fpst, mi->polygon_count, mi->recursion_depth);
}

// xlockmore_gl_draw_fps
// file ./../xlockmoreI.h line 75
extern void xlockmore_gl_draw_fps(struct ModeInfo *mi)
{
  struct fps_state *st = mi->fpst;
  if(!(st == ((struct fps_state *)NULL)))
  {
    struct anonymous_22 *data = (struct anonymous_22 *)st->gl_fps_data;
    struct anonymous_17 xgwa;
    signed int lines = 1;
    const char *s;
    signed int y = st->y;
    XGetWindowAttributes(st->dpy, st->window, &xgwa);
    s = st->string;
    for( ; !(*s == 0); s = s + 1l)
      if((signed int)*s == 10)
        lines = lines + 1;

    if(!(y >= 0))
      y = (xgwa.height + y) - lines * data->line_height;

    y = y + lines * data->line_height;
    glColor3f((float)1, (float)1, (float)1);
    print_texture_label(st->dpy, data->texfont, xgwa.width, xgwa.height, data->top_p != 0 ? 1 : 2, st->string);
  }

}

// xlockmore_gl_fps_init
// file fps-gl.c line 46
static void xlockmore_gl_fps_init(struct fps_state *st)
{
  struct anonymous_22 *data;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_22) /*16ul*/ );
  data = (struct anonymous_22 *)return_value_calloc_1;
  signed int ascent;
  signed int descent;
  data->top_p=get_boolean_resource(st->dpy, "fpsTop", "FPSTop");
  data->texfont=load_texture_font(st->dpy, "fpsFont");
  texture_string_metrics(data->texfont, "M", ((struct anonymous_38 *)NULL), &ascent, &descent);
  data->line_height = ascent + descent;
  st->gl_fps_data = (void *)data;
}

// xlockmore_init
// file ./../xlockmore.c line 278
static void * xlockmore_init(struct _XDisplay *dpy, unsigned long int window, struct xlockmore_function_table *xlmft)
{
  struct ModeInfo *mi;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ModeInfo) /*392ul*/ );
  mi = (struct ModeInfo *)return_value_calloc_1;
  struct anonymous_8 gcv;
  struct anonymous_27 color;
  signed int i;
  signed int root_p;
  if(xlmft == ((struct xlockmore_function_table *)NULL))
    abort();

  mi->xlmft = xlmft;
  mi->dpy = dpy;
  mi->window = window;
  XGetWindowAttributes(dpy, window, &mi->xgwa);
  mi->num_screens = 1;
  mi->screen_number = 0;
  mi->num_screens = mi->num_screens + 1;
  static signed int screen_tick = 0;
  if(!(screen_tick == 0))
    mi->screen_number = mi->screen_number + 1;

  screen_tick = screen_tick + 1;
  root_p = (signed int)(window == mi->xgwa.screen->root);
  XSelectInput(dpy, window, mi->xgwa.your_event_mask | 1L << 6);
  color.flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
  color.blue = (unsigned short int)0;
  color.green = color.blue;
  color.red = color.green;
  signed int return_value_XAllocColor_2;
  return_value_XAllocColor_2=XAllocColor(dpy, mi->xgwa.colormap, &color);
  if(return_value_XAllocColor_2 == 0)
    abort();

  mi->black = color.pixel;
  color.blue = (unsigned short int)0xFFFF;
  color.green = color.blue;
  color.red = color.green;
  signed int return_value_XAllocColor_3;
  return_value_XAllocColor_3=XAllocColor(dpy, mi->xgwa.colormap, &color);
  if(return_value_XAllocColor_3 == 0)
    abort();

  mi->white = color.pixel;
  void *return_value_calloc_4;
  void *return_value_calloc_5;
  if(!(mono_p == 0))
  {

  MONO:
    ;
    mi->npixels = 2;
    if(mi->pixels == ((unsigned long int *)NULL))
    {
      return_value_calloc_4=calloc((unsigned long int)mi->npixels, sizeof(unsigned long int) /*8ul*/ );
      mi->pixels = (unsigned long int *)return_value_calloc_4;
    }

    if(mi->colors == ((struct anonymous_27 *)NULL))
    {
      return_value_calloc_5=calloc((unsigned long int)mi->npixels, sizeof(struct anonymous_27) /*16ul*/ );
      mi->colors = (struct anonymous_27 *)return_value_calloc_5;
    }

    static unsigned long int pixels[2l];
    pixels[(signed long int)0] = mi->black;
    pixels[(signed long int)1] = mi->white;
    static struct anonymous_27 colors[2l];
    colors[(signed long int)0].flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
    colors[(signed long int)1].flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
    colors[(signed long int)0].blue = (unsigned short int)0;
    colors[(signed long int)0].green = colors[(signed long int)0].blue;
    colors[(signed long int)0].red = colors[(signed long int)0].green;
    colors[(signed long int)1].blue = (unsigned short int)0xFFFF;
    colors[(signed long int)1].green = colors[(signed long int)1].blue;
    colors[(signed long int)1].red = colors[(signed long int)1].green;
    mi->writable_p = 0;
  }

  else
  {
    mi->npixels=get_integer_resource(dpy, "ncolors", "Integer");
    if(!(mi->npixels >= 1))
      mi->npixels = 64;

    else
      if((signed long int)mi->npixels >= 8193l)
        mi->npixels = (signed int)(1L << 13);

    void *return_value_calloc_6;
    return_value_calloc_6=calloc((unsigned long int)mi->npixels, sizeof(struct anonymous_27) /*16ul*/ );
    mi->colors = (struct anonymous_27 *)return_value_calloc_6;
    mi->writable_p = mi->xlmft->want_writable_colors;
    switch((signed int)mi->xlmft->desired_color_scheme)
    {
      case color_scheme_uniform:
      {
        make_uniform_colormap(mi->xgwa.screen, mi->xgwa.visual, mi->xgwa.colormap, mi->colors, &mi->npixels, 1, &mi->writable_p, 1);
        break;
      }
      case color_scheme_smooth:
      {
        make_smooth_colormap(mi->xgwa.screen, mi->xgwa.visual, mi->xgwa.colormap, mi->colors, &mi->npixels, 1, &mi->writable_p, 1);
        break;
      }
      case color_scheme_bright:

      case color_scheme_default:
      {
        make_random_colormap(mi->xgwa.screen, mi->xgwa.visual, mi->xgwa.colormap, mi->colors, &mi->npixels, (signed int)((signed int)mi->xlmft->desired_color_scheme == color_scheme_bright), 1, &mi->writable_p, 1);
        break;
      }
      default:
        abort();
    }
    if(!(mi->npixels >= 3))
      goto MONO;

    else
    {
      void *return_value_calloc_7;
      return_value_calloc_7=calloc((unsigned long int)mi->npixels, sizeof(unsigned long int) /*8ul*/ );
      mi->pixels = (unsigned long int *)return_value_calloc_7;
      i = 0;
      for( ; !(i >= mi->npixels); i = i + 1)
        mi->pixels[(signed long int)i] = (mi->colors + (signed long int)i)->pixel;
    }
  }
  gcv.foreground = mi->white;
  gcv.background = mi->black;
  mi->gc=XCreateGC(dpy, window, (unsigned long int)(1L << 2 | 1L << 3), &gcv);
  mi->fullrandom = 1;
  signed int return_value_get_integer_resource_8;
  return_value_get_integer_resource_8=get_integer_resource(dpy, "delay", "Usecs");
  mi->pause = (signed long int)return_value_get_integer_resource_8;
  signed int return_value_get_integer_resource_9;
  return_value_get_integer_resource_9=get_integer_resource(dpy, "cycles", "Int");
  mi->cycles = (signed long int)return_value_get_integer_resource_9;
  signed int return_value_get_integer_resource_10;
  return_value_get_integer_resource_10=get_integer_resource(dpy, "count", "Int");
  mi->batchcount = (signed long int)return_value_get_integer_resource_10;
  signed int return_value_get_integer_resource_11;
  return_value_get_integer_resource_11=get_integer_resource(dpy, "size", "Int");
  mi->size = (signed long int)return_value_get_integer_resource_11;
  mi->threed=get_boolean_resource(dpy, "use3d", "Boolean");
  double return_value_get_float_resource_12;
  return_value_get_float_resource_12=get_float_resource(dpy, "delta3d", "Float");
  mi->threed_delta = (signed long int)return_value_get_float_resource_12;
  unsigned int return_value_get_pixel_resource_13;
  return_value_get_pixel_resource_13=get_pixel_resource(dpy, mi->xgwa.colormap, "right3d", "Color");
  mi->threed_right_color = (signed long int)return_value_get_pixel_resource_13;
  unsigned int return_value_get_pixel_resource_14;
  return_value_get_pixel_resource_14=get_pixel_resource(dpy, mi->xgwa.colormap, "left3d", "Color");
  mi->threed_left_color = (signed long int)return_value_get_pixel_resource_14;
  unsigned int return_value_get_pixel_resource_15;
  return_value_get_pixel_resource_15=get_pixel_resource(dpy, mi->xgwa.colormap, "both3d", "Color");
  mi->threed_both_color = (signed long int)return_value_get_pixel_resource_15;
  unsigned int return_value_get_pixel_resource_16;
  return_value_get_pixel_resource_16=get_pixel_resource(dpy, mi->xgwa.colormap, "none3d", "Color");
  mi->threed_none_color = (signed long int)return_value_get_pixel_resource_16;
  mi->wireframe_p=get_boolean_resource(dpy, "wireframe", "Boolean");
  mi->root_p = root_p;
  mi->use_shm=get_boolean_resource(dpy, "useSHM", "Boolean");
  mi->fps_p=get_boolean_resource(dpy, "doFPS", "DoFPS");
  mi->recursion_depth = (double)-1;
  if(!(mi->pause >= 0l))
    mi->pause = (signed long int)0;

  else
    if(mi->pause >= 100000001l)
      mi->pause = (signed long int)100000000;

  char *name;
  name=get_string_resource(dpy, "font", "Font");
  if(!(name == ((char *)NULL)))
  {
    struct anonymous_1 *f;
    f=XLoadQueryFont(dpy, name);
    const char *def1 = "-*-helvetica-bold-r-normal-*-180-*";
    const char *def2 = "fixed";
    if(f == ((struct anonymous_1 *)NULL))
    {
      fprintf(stderr, "%s: font %s does not exist, using %s\n", progname, name, def1);
      f=XLoadQueryFont(dpy, def1);
    }

    if(f == ((struct anonymous_1 *)NULL))
    {
      fprintf(stderr, "%s: font %s does not exist, using %s\n", progname, def1, def2);
      f=XLoadQueryFont(dpy, def2);
    }

    if(!(f == ((struct anonymous_1 *)NULL)))
      XSetFont(dpy, mi->gc, f->fid);

    if(!(f == ((struct anonymous_1 *)NULL)))
      XFreeFont(dpy, f);

    free((void *)name);
  }

  xlockmore_read_resources(mi);
  XClearWindow(dpy, window);
  mi->xlmft->hack_init(mi);
  return (void *)mi;
}

// xlockmore_pick_gl_visual
// file ./../xlockmoreI.h line 66
extern struct anonymous_16 * xlockmore_pick_gl_visual(struct anonymous_15 *screen)
{
  struct anonymous_16 *v = ((struct anonymous_16 *)NULL);
  struct _XDisplay *dpy = screen->display;
  char *string;
  string=get_string_resource(dpy, "visualID", "VisualID");
  char *s;
  if(!(string == ((char *)NULL)))
  {
    s = string;
    for( ; !(*s == 0); s = s + 1l)
      if((signed int)*s >= 65)
      {
        if(!((signed int)*s >= 91))
          *s = (char)(((signed int)*s - 65) + 97);

      }

  }

  _Bool tmp_if_expr_1;
  if(string == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*string != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(tmp_if_expr_1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strcmp_2=strcmp(string, "gl");
    tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strcmp_4=strcmp(string, "best");
    tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_strcmp_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_strcmp_6=strcmp(string, "color");
    tmp_if_expr_7 = !(return_value_strcmp_6 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  signed int return_value_strcmp_8;
  if(tmp_if_expr_7)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_strcmp_8=strcmp(string, "default");
    tmp_if_expr_9 = !(return_value_strcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_9)
    v=get_gl_visual(screen);

  if(!(string == ((char *)NULL)))
    free((void *)string);

  return v;
}

// xlockmore_read_resources
// file ./../xlockmore.c line 239
static void xlockmore_read_resources(struct ModeInfo *mi)
{
  struct _XDisplay *dpy = mi->dpy;
  struct anonymous_44 *xlockmore_opts = mi->xlmft->opts;
  signed int i = 0;
  double return_value_get_float_resource_1;
  for( ; !(i >= xlockmore_opts->numvarsdesc); i = i + 1)
  {
    void *var = (xlockmore_opts->vars + (signed long int)i)->var;
    signed int *var_b = (signed int *)var;
    char **var_c = (char **)var;
    signed int *var_i = (signed int *)var;
    float *var_f = (float *)var;
    switch((signed int)(xlockmore_opts->vars + (signed long int)i)->type)
    {
      case t_String:
      {
        *var_c=get_string_resource(dpy, (xlockmore_opts->vars + (signed long int)i)->name, (xlockmore_opts->vars + (signed long int)i)->classname);
        break;
      }
      case t_Float:
      {
        return_value_get_float_resource_1=get_float_resource(dpy, (xlockmore_opts->vars + (signed long int)i)->name, (xlockmore_opts->vars + (signed long int)i)->classname);
        *var_f = (float)return_value_get_float_resource_1;
        break;
      }
      case t_Int:
      {
        *var_i=get_integer_resource(dpy, (xlockmore_opts->vars + (signed long int)i)->name, (xlockmore_opts->vars + (signed long int)i)->classname);
        break;
      }
      case t_Bool:
      {
        *var_b=get_boolean_resource(dpy, (xlockmore_opts->vars + (signed long int)i)->name, (xlockmore_opts->vars + (signed long int)i)->classname);
        break;
      }
      default:
        abort();
    }
  }
}

// xlockmore_reshape
// file ./../xlockmore.c line 511
static void xlockmore_reshape(struct _XDisplay *dpy, unsigned long int window, void *closure, unsigned int w, unsigned int h)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  if(!(mi == ((struct ModeInfo *)NULL)))
  {
    if(!(mi->xlmft->hack_reshape == ((void (*)(struct ModeInfo *, signed int, signed int))NULL)))
    {
      XGetWindowAttributes(dpy, window, &mi->xgwa);
      mi->xlmft->hack_reshape(mi, mi->xgwa.width, mi->xgwa.height);
    }

  }

}

// xlockmore_setup
// file ./../xlockmoreI.h line 79
extern void xlockmore_setup(struct xscreensaver_function_table *xsft, void *arg)
{
  struct xlockmore_function_table *xlmft = (struct xlockmore_function_table *)arg;
  signed int i;
  signed int j;
  char *s;
  struct anonymous_18 *new_options;
  char **new_defaults;
  const char *xlockmore_defaults;
  struct anonymous_44 *xlockmore_opts = xlmft->opts;
  ya_rand_init((unsigned int)0);
  xsft->init_cb = (void * (*)(struct _XDisplay *, unsigned long int))xlockmore_init;
  xsft->draw_cb = xlockmore_draw;
  xsft->reshape_cb = xlockmore_reshape;
  xsft->event_cb = xlockmore_event;
  xsft->free_cb = xlockmore_free;
  progclass = xlmft->progclass;
  xlockmore_defaults = xlmft->defaults;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(xlockmore_opts->numopts * 3 + 100), sizeof(struct anonymous_18) /*32ul*/ );
  new_options = (struct anonymous_18 *)return_value_calloc_1;
  i = 0;
  for( ; !(i >= xlockmore_opts->numopts); i = i + 1)
  {
    struct anonymous_18 *xlockmore_setup__1__1__old = &xlockmore_opts->opts[(signed long int)i];
    struct anonymous_18 *xlockmore_setup__1__1__new = &new_options[(signed long int)i];
    if((signed int)*xlockmore_setup__1__1__old->option == 45)
      xlockmore_setup__1__1__new->option = xlockmore_setup__1__1__old->option;

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(xlockmore_setup__1__1__old->option);
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(return_value_strlen_2 + (unsigned long int)5);
      xlockmore_setup__1__1__new->option = (char *)return_value_malloc_3;
      strcpy(xlockmore_setup__1__1__new->option, "-no-");
      strcat(xlockmore_setup__1__1__new->option, xlockmore_setup__1__1__old->option + (signed long int)1);
    }
    xlockmore_setup__1__1__new->specifier=strrchr(xlockmore_setup__1__1__old->specifier, 46);
    if(xlockmore_setup__1__1__new->specifier == ((char *)NULL))
      abort();

    xlockmore_setup__1__1__new->argKind = xlockmore_setup__1__1__old->argKind;
    xlockmore_setup__1__1__new->value = xlockmore_setup__1__1__old->value;
  }
  char *args[9l] = { "-count", "-cycles", "-delay", "-ncolors", "-size", "-font", "-wireframe", "-use3d", "-useSHM" };
  j = 0;
  char *return_value_strstr_11;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  for( ; !((unsigned long int)j >= 9ul); j = j + 1)
  {
    return_value_strstr_11=strstr(xlockmore_defaults, args[(signed long int)j] + (signed long int)1);
    if(!(return_value_strstr_11 == ((char *)NULL)))
    {
      struct anonymous_18 *xlockmore_setup__1__2__1__new;
      signed int tmp_post_4 = i;
      i = i + 1;
      xlockmore_setup__1__2__1__new = &new_options[(signed long int)tmp_post_4];
      xlockmore_setup__1__2__1__new->option = args[(signed long int)j];
      xlockmore_setup__1__2__1__new->specifier=strdup(args[(signed long int)j]);
      xlockmore_setup__1__2__1__new->specifier[(signed long int)0] = (char)46;
      signed int return_value_strcmp_10;
      return_value_strcmp_10=strcmp(xlockmore_setup__1__2__1__new->option, "-wireframe");
      if(return_value_strcmp_10 == 0)
      {
        xlockmore_setup__1__2__1__new->argKind = (enum anonymous_19)XrmoptionNoArg;
        xlockmore_setup__1__2__1__new->value = "True";
        signed int tmp_post_5 = i;
        i = i + 1;
        xlockmore_setup__1__2__1__new = &new_options[(signed long int)tmp_post_5];
        xlockmore_setup__1__2__1__new->option = "-no-wireframe";
        xlockmore_setup__1__2__1__new->specifier = (new_options + (signed long int)(i - 2))->specifier;
        xlockmore_setup__1__2__1__new->argKind = (enum anonymous_19)XrmoptionNoArg;
        xlockmore_setup__1__2__1__new->value = "False";
      }

      else
      {
        return_value_strcmp_9=strcmp(xlockmore_setup__1__2__1__new->option, "-use3d");
        if(return_value_strcmp_9 == 0)
        {
          xlockmore_setup__1__2__1__new->option = "-3d";
          xlockmore_setup__1__2__1__new->argKind = (enum anonymous_19)XrmoptionNoArg;
          xlockmore_setup__1__2__1__new->value = "True";
          signed int tmp_post_6 = i;
          i = i + 1;
          xlockmore_setup__1__2__1__new = &new_options[(signed long int)tmp_post_6];
          xlockmore_setup__1__2__1__new->option = "-no-3d";
          xlockmore_setup__1__2__1__new->specifier = (new_options + (signed long int)(i - 2))->specifier;
          xlockmore_setup__1__2__1__new->argKind = (enum anonymous_19)XrmoptionNoArg;
          xlockmore_setup__1__2__1__new->value = "False";
        }

        else
        {
          return_value_strcmp_8=strcmp(xlockmore_setup__1__2__1__new->option, "-useSHM");
          if(return_value_strcmp_8 == 0)
          {
            xlockmore_setup__1__2__1__new->option = "-shm";
            xlockmore_setup__1__2__1__new->argKind = (enum anonymous_19)XrmoptionNoArg;
            xlockmore_setup__1__2__1__new->value = "True";
            signed int tmp_post_7 = i;
            i = i + 1;
            xlockmore_setup__1__2__1__new = &new_options[(signed long int)tmp_post_7];
            xlockmore_setup__1__2__1__new->option = "-no-shm";
            xlockmore_setup__1__2__1__new->specifier = (new_options + (signed long int)(i - 2))->specifier;
            xlockmore_setup__1__2__1__new->argKind = (enum anonymous_19)XrmoptionNoArg;
            xlockmore_setup__1__2__1__new->value = "False";
          }

          else
          {
            xlockmore_setup__1__2__1__new->argKind = (enum anonymous_19)XrmoptionSepArg;
            xlockmore_setup__1__2__1__new->value = ((char *)NULL);
          }
        }
      }
    }

  }
  i = 0;
  void *return_value_calloc_12;
  return_value_calloc_12=calloc((unsigned long int)1, (unsigned long int)(xlockmore_opts->numvarsdesc * 10 + 1000));
  new_defaults = (char **)return_value_calloc_12;
  void *return_value_malloc_13;
  return_value_malloc_13=malloc((unsigned long int)50);
  s = (char *)return_value_malloc_13;
  *s = (char)0;
  strcpy(s, progclass);
  strcat(s, ".background: black");
  signed int tmp_post_14 = i;
  i = i + 1;
  new_defaults[(signed long int)tmp_post_14] = s;
  void *return_value_malloc_15;
  return_value_malloc_15=malloc((unsigned long int)50);
  s = (char *)return_value_malloc_15;
  *s = (char)0;
  strcpy(s, progclass);
  strcat(s, ".foreground: white");
  signed int tmp_post_16 = i;
  i = i + 1;
  new_defaults[(signed long int)tmp_post_16] = s;
  s=strdup(xlockmore_defaults);
  while(!(s == ((char *)NULL)))
  {
    if(*s == 0)
      break;

    signed int tmp_post_17 = i;
    i = i + 1;
    new_defaults[(signed long int)tmp_post_17] = s;
    s=strchr(s, 10);
    if(!(s == ((char *)NULL)))
    {
      char *tmp_post_18 = s;
      s = s + 1l;
      *tmp_post_18 = (char)0;
    }

  }
  j = 0;
  for( ; !(j >= xlockmore_opts->numvarsdesc); j = j + 1)
  {
    const char *def = (xlockmore_opts->vars + (signed long int)j)->def;
    if(def == ((const char *)NULL))
      abort();

    if(*def == 0)
      abort();

    unsigned long int return_value_strlen_19;
    return_value_strlen_19=strlen(def);
    if(return_value_strlen_19 >= 1001ul)
      abort();

    unsigned long int return_value_strlen_20;
    return_value_strlen_20=strlen((xlockmore_opts->vars + (signed long int)j)->name);
    unsigned long int return_value_strlen_21;
    return_value_strlen_21=strlen(def);
    void *return_value_malloc_22;
    return_value_malloc_22=malloc(return_value_strlen_20 + return_value_strlen_21 + (unsigned long int)10);
    s = (char *)return_value_malloc_22;
    strcpy(s, "*");
    strcat(s, (xlockmore_opts->vars + (signed long int)j)->name);
    strcat(s, ": ");
    strcat(s, def);
    signed int tmp_post_23 = i;
    i = i + 1;
    new_defaults[(signed long int)tmp_post_23] = s;
    char *onew;
    onew=strdup((xlockmore_opts->vars + (signed long int)j)->name);
    const char *new = onew;
    signed int k;
    s=strrchr(new, 46);
    if(!(s == ((char *)NULL)))
      new = s + (signed long int)1;

    s=strrchr(new, 42);
    if(!(s == ((char *)NULL)))
      new = s + (signed long int)1;

    k = 0;
    for( ; !(k >= i + -1); k = k + 1)
    {
      char *oold;
      oold=strdup(new_defaults[(signed long int)k]);
      const char *old = oold;
      s=strchr(oold, 58);
      if(!(s == ((char *)NULL)))
        *s = (char)0;

      s=strrchr(old, 46);
      if(!(s == ((char *)NULL)))
        old = s + (signed long int)1;

      s=strrchr(old, 42);
      if(!(s == ((char *)NULL)))
        old = s + (signed long int)1;

      signed int return_value_strcasecmp_24;
      return_value_strcasecmp_24=strcasecmp(old, new);
      if(return_value_strcasecmp_24 == 0)
        fprintf(stderr, "%s: duplicate resource \"%s\": set in both DEFAULTS and vars[]\n", progname, old);

      free((void *)oold);
    }
    free((void *)onew);
  }
  new_defaults[(signed long int)i] = ((char *)NULL);
  xsft->progclass = progclass;
  xsft->options = new_options;
  xsft->defaults = (const char * const *)new_defaults;
}

// xlockmore_validate_gl_visual
// file ./../xlockmoreI.h line 67
extern signed int xlockmore_validate_gl_visual(struct anonymous_15 *screen, const char *name, struct anonymous_16 *visual)
{
  signed int return_value_validate_gl_visual_1;
  return_value_validate_gl_visual_1=validate_gl_visual(stderr, screen, name, visual);
  return return_value_validate_gl_visual_1;
}

// ya_rand_init
// file ./../utils/yarandom.h line 37
extern void ya_rand_init(unsigned int seed)
{
  signed int i;
  if(seed == 0u)
  {
    struct timeval tp;
    struct timezone tzp;
    gettimeofday(&tp, &tzp);
    seed = 999U * (unsigned int)tp.tv_sec;
    seed = seed << 11 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)11;
    seed = seed + (unsigned int)((signed long int)1001 * tp.tv_usec);
    seed = seed << 7 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)7;
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    seed = seed + (unsigned int)(1003 * return_value_getpid_1);
    seed = seed << 13 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)13;
  }

  a[(signed long int)0] = a[(signed long int)0] + seed;
  i = 1;
  for( ; !(i >= 55); i = i + 1)
  {
    seed = seed * (unsigned int)999;
    seed = seed << 9 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)9;
    seed = seed + a[(signed long int)(i - 1)] * (unsigned int)1001;
    seed = seed << 15 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)15;
    a[(signed long int)i] = a[(signed long int)i] + seed;
  }
  i1 = (signed int)(a[(signed long int)0] % (unsigned int)55);
  i2 = (i1 + 24) % 55;
}

// ya_random
// file ./../../utils/yarandom.h line 36
extern unsigned int ya_random(void)
{
  signed int ret = (signed int)(a[(signed long int)i1] + a[(signed long int)i2]);
  a[(signed long int)i1] = (unsigned int)ret;
  i1 = i1 + 1;
  if(i1 >= 55)
    i1 = 0;

  i2 = i2 + 1;
  if(i2 >= 55)
    i2 = 0;

  return (unsigned int)ret;
}

