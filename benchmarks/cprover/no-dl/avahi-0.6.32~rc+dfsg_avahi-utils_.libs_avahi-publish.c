// #anon_enum$AVAHI_BROWSER_NEW=0$AVAHI_BROWSER_REMOVE=1$AVAHI_BROWSER_CACHE_EXHAUSTED=2$AVAHI_BROWSER_ALL_FOR_NOW=3$AVAHI_BROWSER_FAILURE=4
// file ../avahi-common/defs.h line 284
enum anonymous$3 { AVAHI_BROWSER_NEW=0, AVAHI_BROWSER_REMOVE=1, AVAHI_BROWSER_CACHE_EXHAUSTED=2, AVAHI_BROWSER_ALL_FOR_NOW=3, AVAHI_BROWSER_FAILURE=4 };

// #anon_enum$AVAHI_CLIENT_IGNORE_USER_CONFIG=1$AVAHI_CLIENT_NO_FAIL=2
// file ../avahi-client/client.h line 48
enum anonymous$11 { AVAHI_CLIENT_IGNORE_USER_CONFIG=1, AVAHI_CLIENT_NO_FAIL=2 };

// #anon_enum$AVAHI_CLIENT_S_REGISTERING=1$AVAHI_CLIENT_S_RUNNING=2$AVAHI_CLIENT_S_COLLISION=3$AVAHI_CLIENT_FAILURE=100$AVAHI_CLIENT_CONNECTING=101
// file ../avahi-client/client.h line 40
enum anonymous$5 { AVAHI_CLIENT_S_REGISTERING=1, AVAHI_CLIENT_S_RUNNING=2, AVAHI_CLIENT_S_COLLISION=3, AVAHI_CLIENT_FAILURE=100, AVAHI_CLIENT_CONNECTING=101 };

// #anon_enum$AVAHI_DOMAIN_BROWSER_BROWSE=0$AVAHI_DOMAIN_BROWSER_BROWSE_DEFAULT=1$AVAHI_DOMAIN_BROWSER_REGISTER=2$AVAHI_DOMAIN_BROWSER_REGISTER_DEFAULT=3$AVAHI_DOMAIN_BROWSER_BROWSE_LEGACY=4$AVAHI_DOMAIN_BROWSER_MAX=5
// file ../avahi-common/defs.h line 303
enum anonymous$1 { AVAHI_DOMAIN_BROWSER_BROWSE=0, AVAHI_DOMAIN_BROWSER_BROWSE_DEFAULT=1, AVAHI_DOMAIN_BROWSER_REGISTER=2, AVAHI_DOMAIN_BROWSER_REGISTER_DEFAULT=3, AVAHI_DOMAIN_BROWSER_BROWSE_LEGACY=4, AVAHI_DOMAIN_BROWSER_MAX=5 };

// #anon_enum$AVAHI_ENTRY_GROUP_UNCOMMITED=0$AVAHI_ENTRY_GROUP_REGISTERING=1$AVAHI_ENTRY_GROUP_ESTABLISHED=2$AVAHI_ENTRY_GROUP_COLLISION=3$AVAHI_ENTRY_GROUP_FAILURE=4
// file ../avahi-common/defs.h line 230
enum anonymous { AVAHI_ENTRY_GROUP_UNCOMMITED=0, AVAHI_ENTRY_GROUP_REGISTERING=1, AVAHI_ENTRY_GROUP_ESTABLISHED=2, AVAHI_ENTRY_GROUP_COLLISION=3, AVAHI_ENTRY_GROUP_FAILURE=4 };

// #anon_enum$AVAHI_LOOKUP_RESULT_CACHED=1$AVAHI_LOOKUP_RESULT_WIDE_AREA=2$AVAHI_LOOKUP_RESULT_MULTICAST=4$AVAHI_LOOKUP_RESULT_LOCAL=8$AVAHI_LOOKUP_RESULT_OUR_OWN=16$AVAHI_LOOKUP_RESULT_STATIC=32
// file ../avahi-common/defs.h line 270
enum anonymous$4 { AVAHI_LOOKUP_RESULT_CACHED=1, AVAHI_LOOKUP_RESULT_WIDE_AREA=2, AVAHI_LOOKUP_RESULT_MULTICAST=4, AVAHI_LOOKUP_RESULT_LOCAL=8, AVAHI_LOOKUP_RESULT_OUR_OWN=16, AVAHI_LOOKUP_RESULT_STATIC=32 };

// #anon_enum$AVAHI_LOOKUP_USE_WIDE_AREA=1$AVAHI_LOOKUP_USE_MULTICAST=2$AVAHI_LOOKUP_NO_TXT=4$AVAHI_LOOKUP_NO_ADDRESS=8
// file ../avahi-common/defs.h line 260
enum anonymous$2 { AVAHI_LOOKUP_USE_WIDE_AREA=1, AVAHI_LOOKUP_USE_MULTICAST=2, AVAHI_LOOKUP_NO_TXT=4, AVAHI_LOOKUP_NO_ADDRESS=8 };

// #anon_enum$AVAHI_PUBLISH_UNIQUE=1$AVAHI_PUBLISH_NO_PROBE=2$AVAHI_PUBLISH_NO_ANNOUNCE=4$AVAHI_PUBLISH_ALLOW_MULTIPLE=8$AVAHI_PUBLISH_NO_REVERSE=16$AVAHI_PUBLISH_NO_COOKIE=32$AVAHI_PUBLISH_UPDATE=64$AVAHI_PUBLISH_USE_WIDE_AREA=128$AVAHI_PUBLISH_USE_MULTICAST=256
// file ../avahi-common/defs.h line 243
enum anonymous$0 { AVAHI_PUBLISH_UNIQUE=1, AVAHI_PUBLISH_NO_PROBE=2, AVAHI_PUBLISH_NO_ANNOUNCE=4, AVAHI_PUBLISH_ALLOW_MULTIPLE=8, AVAHI_PUBLISH_NO_REVERSE=16, AVAHI_PUBLISH_NO_COOKIE=32, AVAHI_PUBLISH_UPDATE=64, AVAHI_PUBLISH_USE_WIDE_AREA=128, AVAHI_PUBLISH_USE_MULTICAST=256 };

// #anon_enum$AVAHI_RESOLVER_FOUND=0$AVAHI_RESOLVER_FAILURE=1
// file ../avahi-common/defs.h line 293
enum anonymous$9 { AVAHI_RESOLVER_FOUND=0, AVAHI_RESOLVER_FAILURE=1 };

// #anon_enum$AVAHI_WATCH_IN=1$AVAHI_WATCH_OUT=4$AVAHI_WATCH_ERR=8$AVAHI_WATCH_HUP=16
// file ../avahi-common/watch.h line 42
enum anonymous$6 { AVAHI_WATCH_IN=1, AVAHI_WATCH_OUT=4, AVAHI_WATCH_ERR=8, AVAHI_WATCH_HUP=16 };

// #anon_enum$COMMAND_UNSPEC=0$COMMAND_HELP=1$COMMAND_VERSION=2$COMMAND_PUBLISH_SERVICE=3$COMMAND_PUBLISH_ADDRESS=4
// file avahi-publish.c line 43
enum anonymous$7 { COMMAND_UNSPEC=0, COMMAND_HELP=1, COMMAND_VERSION=2, COMMAND_PUBLISH_SERVICE=3, COMMAND_PUBLISH_ADDRESS=4 };

// #anon_enum$DBUS_BUS_SESSION=0$DBUS_BUS_SYSTEM=1$DBUS_BUS_STARTER=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 56
enum anonymous$29 { DBUS_BUS_SESSION=0, DBUS_BUS_SYSTEM=1, DBUS_BUS_STARTER=2 };

// #anon_enum$DBUS_DISPATCH_DATA_REMAINS=0$DBUS_DISPATCH_COMPLETE=1$DBUS_DISPATCH_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 79
enum anonymous$12 { DBUS_DISPATCH_DATA_REMAINS=0, DBUS_DISPATCH_COMPLETE=1, DBUS_DISPATCH_NEED_MEMORY=2 };

// #anon_enum$DBUS_HANDLER_RESULT_HANDLED=0$DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1$DBUS_HANDLER_RESULT_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 66
enum anonymous$28 { DBUS_HANDLER_RESULT_HANDLED=0, DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1, DBUS_HANDLER_RESULT_NEED_MEMORY=2 };

// #anon_enum$STATE_INIT=0$STATE_PREPARING=1$STATE_PREPARED=2$STATE_RUNNING=3$STATE_RAN=4$STATE_DISPATCHING=5$STATE_DISPATCHED=6$STATE_QUIT=7$STATE_FAILURE=8
// file simple-watch.c line 84
enum anonymous$10 { STATE_INIT=0, STATE_PREPARING=1, STATE_PREPARED=2, STATE_RUNNING=3, STATE_RAN=4, STATE_DISPATCHING=5, STATE_DISPATCHED=6, STATE_QUIT=7, STATE_FAILURE=8 };

// tag-#anon#ST[*{SYM#tag-DBusConnection#}$SYM#tag-DBusConnection#$'connection'||*{cSYM#tag-AvahiPoll#}$cSYM#tag-AvahiPoll#$'poll_api'||*{SYM#tag-AvahiTimeout#}$SYM#tag-AvahiTimeout#$'dispatch_timeout'||S32'ref'||U32'$pad0'|]
// file ../avahi-common/dbus-watch-glue.c line 61
struct anonymous$13;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$24;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$22;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$17;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$18;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$21;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$20;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$15;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$19;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$23;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$16;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$14;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$27;

// tag-#anon#UN[SYM#tag-AvahiIPv6Address#'ipv6'||SYM#tag-AvahiIPv4Address#'ipv4'||ARR1{U8}$U8$'data'|]
// file ../avahi-common/address.h line 73
union anonymous$8;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$25;

// tag-AvahiAddress
// file ../avahi-common/address.h line 70
struct AvahiAddress;

// tag-AvahiAddressResolver
// file lookup.h line 242
struct AvahiAddressResolver;

// tag-AvahiAllocator
// file malloc.h line 75
struct AvahiAllocator;

// tag-AvahiClient
// file client.h line 37
struct AvahiClient;

// tag-AvahiDomainBrowser
// file lookup.h line 44
struct AvahiDomainBrowser;

// tag-AvahiEntryGroup
// file publish.h line 43
struct AvahiEntryGroup;

// tag-AvahiHostNameResolver
// file lookup.h line 211
struct AvahiHostNameResolver;

// tag-AvahiIPv4Address
// file ../avahi-common/address.h line 60
struct AvahiIPv4Address;

// tag-AvahiIPv6Address
// file ../avahi-common/address.h line 65
struct AvahiIPv6Address;

// tag-AvahiPoll
// file ../avahi-common/watch.h line 39
struct AvahiPoll;

// tag-AvahiRList
// file rlist.h line 30
struct AvahiRList;

// tag-AvahiRecordBrowser
// file lookup.h line 276
struct AvahiRecordBrowser;

// tag-AvahiServiceBrowser
// file lookup.h line 78
struct AvahiServiceBrowser;

// tag-AvahiServiceResolver
// file lookup.h line 157
struct AvahiServiceResolver;

// tag-AvahiServiceTypeBrowser
// file lookup.h line 123
struct AvahiServiceTypeBrowser;

// tag-AvahiSimplePoll
// file simple-watch.h line 34
struct AvahiSimplePoll;

// tag-AvahiStringList
// file ../avahi-common/strlst.h line 40
struct AvahiStringList;

// tag-AvahiThreadedPoll
// file thread-watch.h line 32
struct AvahiThreadedPoll;

// tag-AvahiTimeout
// file ../avahi-common/watch.h line 36
struct AvahiTimeout;

// tag-AvahiWatch
// file ../avahi-common/watch.h line 33
struct AvahiWatch;

// tag-Config
// file avahi-publish.c line 51
struct Config;

// tag-DBusConnection
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 51
struct DBusConnection;

// tag-DBusError
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 43
struct DBusError;

// tag-DBusMessage
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 44
struct DBusMessage;

// tag-DBusMessageIter
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 46
struct DBusMessageIter;

// tag-DBusTimeout
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 45
struct DBusTimeout;

// tag-DBusWatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 43
struct DBusWatch;

// tag-TimeoutData
// file ../avahi-common/dbus-watch-glue.c line 196
struct TimeoutData;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-error_map
// file ../avahi-common/dbus.c line 93
struct error_map;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_timeout
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout(struct DBusTimeout *dbus_timeout, void *userdata);
// add_watch
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch(struct DBusWatch *dbus_watch, void *userdata);
// address_get_size
// file address.c line 35
static unsigned long int address_get_size(const struct AvahiAddress *a);
// address_get_size$link1
// file address.c line 35
static unsigned long int address_get_size$link1(const struct AvahiAddress *a$link1);
// append_rdata
// file entrygroup.c line 348
static signed int append_rdata(struct DBusMessage *message, const void *rdata, unsigned long int size);
// append_string_list
// file entrygroup.c line 363
static signed int append_string_list(struct DBusMessage *message, struct AvahiStringList *txt);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// avahi_address_cmp
// file address.c line 46
signed int avahi_address_cmp(const struct AvahiAddress *a, const struct AvahiAddress *b);
// avahi_address_parse
// file ../avahi-common/address.h line 95
struct AvahiAddress * avahi_address_parse(const char *s, signed int proto, struct AvahiAddress *ret_addr);
// avahi_address_resolver_event
// file internal.h line 166
enum anonymous$28 avahi_address_resolver_event(struct AvahiClient *client, enum anonymous$9 event, struct DBusMessage *message);
// avahi_address_resolver_free
// file lookup.h line 269
signed int avahi_address_resolver_free(struct AvahiAddressResolver *r);
// avahi_address_resolver_get_client
// file resolver.c line 755
struct AvahiClient * avahi_address_resolver_get_client(struct AvahiAddressResolver *r);
// avahi_address_resolver_new
// file resolver.c line 642
struct AvahiAddressResolver * avahi_address_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const struct AvahiAddress *a, enum anonymous$2 flags, void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous$9, const struct AvahiAddress *, const char *, enum anonymous$4, void *), void *userdata);
// avahi_address_resolver_new::callback$object
//
void callback$object(struct AvahiAddressResolver *, signed int, signed int, enum anonymous$9, const struct AvahiAddress *, const char *, enum anonymous$4, void *);
// avahi_address_snprint
// file ../avahi-common/address.h line 90
char * avahi_address_snprint(char *s, unsigned long int length, const struct AvahiAddress *a);
// avahi_af_to_proto
// file address.c line 137
signed int avahi_af_to_proto(signed int af);
// avahi_age
// file timeval.c line 76
signed long int avahi_age(struct timeval *a);
// avahi_alternative_host_name
// file ../avahi-common/alternative.h line 33
char * avahi_alternative_host_name(const char *s);
// avahi_alternative_service_name
// file ../avahi-common/alternative.h line 39
char * avahi_alternative_service_name(const char *s);
// avahi_client_errno
// file ../avahi-client/client.h line 99
signed int avahi_client_errno(struct AvahiClient *client);
// avahi_client_free
// file ../avahi-client/client.h line 72
void avahi_client_free(struct AvahiClient *client);
// avahi_client_get_domain_name
// file client.c line 742
const char * avahi_client_get_domain_name(struct AvahiClient *client);
// avahi_client_get_host_name
// file client.c line 756
const char * avahi_client_get_host_name(struct AvahiClient *client);
// avahi_client_get_host_name_fqdn
// file ../avahi-client/client.h line 91
const char * avahi_client_get_host_name_fqdn(struct AvahiClient *client);
// avahi_client_get_local_service_cookie
// file client.c line 846
unsigned int avahi_client_get_local_service_cookie(struct AvahiClient *client);
// avahi_client_get_state
// file ../avahi-client/client.h line 94
enum anonymous$5 avahi_client_get_state(struct AvahiClient *client);
// avahi_client_get_string_reply_and_block
// file client.c line 672
static char * avahi_client_get_string_reply_and_block(struct AvahiClient *client, const char *method, const char *param);
// avahi_client_get_version_string
// file ../avahi-client/client.h line 79
const char * avahi_client_get_version_string(struct AvahiClient *client);
// avahi_client_is_connected
// file client.c line 896
signed int avahi_client_is_connected(struct AvahiClient *client);
// avahi_client_new
// file ../avahi-client/client.h line 62
struct AvahiClient * avahi_client_new(const struct AvahiPoll *poll_api, enum anonymous$11 flags, void (*callback)(struct AvahiClient *, enum anonymous$5, void *), void *userdata, signed int *ret_error);
// avahi_client_new::callback$object
//
void callback$object(struct AvahiClient *, enum anonymous$5, void *);
// avahi_client_set_dbus_error
// file client.c line 51
signed int avahi_client_set_dbus_error(struct AvahiClient *client, struct DBusError *error);
// avahi_client_set_errno
// file client.c line 45
signed int avahi_client_set_errno(struct AvahiClient *client, signed int error);
// avahi_client_set_host_name
// file client.c line 905
signed int avahi_client_set_host_name(struct AvahiClient *client, const char *name);
// avahi_client_simple_method_call
// file client.c line 797
signed int avahi_client_simple_method_call(struct AvahiClient *client, const char *path, const char *interface, const char *method);
// avahi_dbus_bus_get
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get(struct DBusError *error);
// avahi_dbus_connection_glue
// file ../avahi-common/dbus-watch-glue.h line 29
signed int avahi_dbus_connection_glue(struct DBusConnection *c, const struct AvahiPoll *poll_api);
// avahi_domain_browser_event
// file internal.h line 159
enum anonymous$28 avahi_domain_browser_event(struct AvahiClient *client, enum anonymous$3 event, struct DBusMessage *message);
// avahi_domain_browser_free
// file lookup.h line 71
signed int avahi_domain_browser_free(struct AvahiDomainBrowser *b);
// avahi_domain_browser_get_client
// file browser.c line 234
struct AvahiClient * avahi_domain_browser_get_client(struct AvahiDomainBrowser *b);
// avahi_domain_browser_new
// file browser.c line 104
struct AvahiDomainBrowser * avahi_domain_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous$1 btype, enum anonymous$2 flags, void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$3, const char *, enum anonymous$4, void *), void *userdata);
// avahi_domain_browser_new::callback$object
//
void callback$object(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$3, const char *, enum anonymous$4, void *);
// avahi_domain_equal
// file ../avahi-common/domain.h line 62
signed int avahi_domain_equal(const char *a, const char *b);
// avahi_domain_hash
// file domain.c line 424
unsigned int avahi_domain_hash(const char *s);
// avahi_elapse_time
// file ../avahi-common/timeval.h line 50
struct timeval * avahi_elapse_time(struct timeval *tv, unsigned int msec, unsigned int jitter);
// avahi_entry_group_add_address
// file ../avahi-client/publish.h line 146
signed int avahi_entry_group_add_address(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const struct AvahiAddress *a);
// avahi_entry_group_add_record
// file entrygroup.c line 808
signed int avahi_entry_group_add_record(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, unsigned short int clazz, unsigned short int type, unsigned int ttl, const void *rdata, unsigned long int size);
// avahi_entry_group_add_service
// file entrygroup.c line 496
signed int avahi_entry_group_add_service(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, ...);
// avahi_entry_group_add_service_strlst
// file ../avahi-client/publish.h line 99
signed int avahi_entry_group_add_service_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, struct AvahiStringList *txt);
// avahi_entry_group_add_service_subtype
// file ../avahi-client/publish.h line 112
signed int avahi_entry_group_add_service_subtype(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, const char *subtype);
// avahi_entry_group_commit
// file ../avahi-client/publish.h line 67
signed int avahi_entry_group_commit(struct AvahiEntryGroup *group);
// avahi_entry_group_free
// file ../avahi-client/publish.h line 60
signed int avahi_entry_group_free(struct AvahiEntryGroup *group);
// avahi_entry_group_get_client
// file entrygroup.c line 290
struct AvahiClient * avahi_entry_group_get_client(struct AvahiEntryGroup *group);
// avahi_entry_group_get_state
// file entrygroup.c line 281
signed int avahi_entry_group_get_state(struct AvahiEntryGroup *group);
// avahi_entry_group_is_empty
// file ../avahi-client/publish.h line 76
signed int avahi_entry_group_is_empty(struct AvahiEntryGroup *group);
// avahi_entry_group_new
// file ../avahi-client/publish.h line 54
struct AvahiEntryGroup * avahi_entry_group_new(struct AvahiClient *client, void (*callback)(struct AvahiEntryGroup *, enum anonymous, void *), void *userdata);
// avahi_entry_group_new::callback$object
//
void callback$object(struct AvahiEntryGroup *, enum anonymous, void *);
// avahi_entry_group_reset
// file entrygroup.c line 267
signed int avahi_entry_group_reset(struct AvahiEntryGroup *group);
// avahi_entry_group_set_state
// file internal.h line 157
void avahi_entry_group_set_state(struct AvahiEntryGroup *group, enum anonymous state);
// avahi_entry_group_update_service_txt
// file entrygroup.c line 611
signed int avahi_entry_group_update_service_txt(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, ...);
// avahi_entry_group_update_service_txt_strlst
// file entrygroup.c line 633
signed int avahi_entry_group_update_service_txt_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, struct AvahiStringList *txt);
// avahi_error_dbus_to_number
// file ../avahi-common/dbus.h line 112
signed int avahi_error_dbus_to_number(const char *s);
// avahi_error_number_to_dbus
// file ../avahi-common/dbus.c line 133
const char * avahi_error_number_to_dbus(signed int error);
// avahi_escape_label
// file domain.c line 116
char * avahi_escape_label(const char *src, unsigned long int src_length, char **ret_name, unsigned long int *ret_size);
// avahi_free
// file ../avahi-common/malloc.h line 42
void avahi_free(void *p);
// avahi_get_type_from_subtype
// file domain.c line 306
const char * avahi_get_type_from_subtype(const char *t);
// avahi_host_name_resolver_event
// file internal.h line 165
enum anonymous$28 avahi_host_name_resolver_event(struct AvahiClient *client, enum anonymous$9 event, struct DBusMessage *message);
// avahi_host_name_resolver_free
// file lookup.h line 239
signed int avahi_host_name_resolver_free(struct AvahiHostNameResolver *r);
// avahi_host_name_resolver_get_client
// file resolver.c line 558
struct AvahiClient * avahi_host_name_resolver_get_client(struct AvahiHostNameResolver *r);
// avahi_host_name_resolver_new
// file resolver.c line 424
struct AvahiHostNameResolver * avahi_host_name_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, signed int aprotocol, enum anonymous$2 flags, void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous$9, const char *, const struct AvahiAddress *, enum anonymous$4, void *), void *userdata);
// avahi_host_name_resolver_new::callback$object
//
void callback$object(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous$9, const char *, const struct AvahiAddress *, enum anonymous$4, void *);
// avahi_init_i18n
// file ../avahi-common/i18n.h line 51
void avahi_init_i18n(void);
// avahi_is_valid_domain_name
// file domain.c line 369
signed int avahi_is_valid_domain_name(const char *t);
// avahi_is_valid_fqdn
// file domain.c line 575
signed int avahi_is_valid_fqdn(const char *t);
// avahi_is_valid_host_name
// file domain.h line 103
signed int avahi_is_valid_host_name(const char *t);
// avahi_is_valid_service_name
// file domain.h line 100
signed int avahi_is_valid_service_name(const char *t);
// avahi_is_valid_service_subtype
// file domain.c line 363
signed int avahi_is_valid_service_subtype(const char *t);
// avahi_is_valid_service_type_generic
// file domain.c line 254
signed int avahi_is_valid_service_type_generic(const char *t);
// avahi_is_valid_service_type_strict
// file domain.c line 274
signed int avahi_is_valid_service_type_strict(const char *t);
// avahi_malloc
// file ../avahi-common/malloc.h line 36
void * avahi_malloc(unsigned long int size);
// avahi_malloc0
// file malloc.c line 113
void * avahi_malloc0(unsigned long int size);
// avahi_memdup
// file malloc.c line 248
void * avahi_memdup(const void *s, unsigned long int l);
// avahi_new_internal
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal(unsigned int n, unsigned long int k);
// avahi_new_internal$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link1(unsigned int n$link1, unsigned long int k$link1);
// avahi_new_internal$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link1(unsigned int n$link1$link1, unsigned long int k$link1$link1);
// avahi_new_internal$link1$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link2(unsigned int n$link1$link2, unsigned long int k$link1$link2);
// avahi_new_internal$link2
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link2(unsigned int n$link2, unsigned long int k$link2);
// avahi_new_internal$link2$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link1(unsigned int n$link2$link1, unsigned long int k$link2$link1);
// avahi_new_internal$link2$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link2(unsigned int n$link2$link2, unsigned long int k$link2$link2);
// avahi_new_internal$link3
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link3(unsigned int n$link3, unsigned long int k$link3);
// avahi_new_internal$link3$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link1(unsigned int n$link3$link1, unsigned long int k$link3$link1);
// avahi_new_internal$link3$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link2(unsigned int n$link3$link2, unsigned long int k$link3$link2);
// avahi_new_internal$link4
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link4(unsigned int n$link4, unsigned long int k$link4);
// avahi_new_internal$link4$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link1(unsigned int n$link4$link1, unsigned long int k$link4$link1);
// avahi_new_internal$link4$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link2(unsigned int n$link4$link2, unsigned long int k$link4$link2);
// avahi_new_internal$link5
// file malloc.h line 48
static inline void * avahi_new_internal$link5(unsigned int n$link5, unsigned long int k$link5);
// avahi_new_internal$link6
// file malloc.h line 48
static inline void * avahi_new_internal$link6(unsigned int n$link6, unsigned long int k$link6);
// avahi_normalize_name
// file ../avahi-common/domain.h line 50
char * avahi_normalize_name(const char *s, char *ret_s, unsigned long int size);
// avahi_normalize_name_strdup
// file domain.c line 219
char * avahi_normalize_name_strdup(const char *s);
// avahi_nss_support
// file check-nss.c line 31
signed int avahi_nss_support(void);
// avahi_proto_to_af
// file address.c line 127
signed int avahi_proto_to_af(signed int proto);
// avahi_proto_to_string
// file address.c line 147
const char * avahi_proto_to_string(signed int proto);
// avahi_realloc
// file malloc.c line 146
void * avahi_realloc(void *p, unsigned long int size);
// avahi_record_browser_event
// file internal.h line 162
enum anonymous$28 avahi_record_browser_event(struct AvahiClient *client, enum anonymous$3 event, struct DBusMessage *message);
// avahi_record_browser_free
// file lookup.h line 308
signed int avahi_record_browser_free(struct AvahiRecordBrowser *b);
// avahi_record_browser_get_client
// file browser.c line 903
struct AvahiClient * avahi_record_browser_get_client(struct AvahiRecordBrowser *b);
// avahi_record_browser_new
// file browser.c line 786
struct AvahiRecordBrowser * avahi_record_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, unsigned short int clazz, unsigned short int type, enum anonymous$2 flags, void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$3, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$4, void *), void *userdata);
// avahi_record_browser_new::callback$object
//
void callback$object(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$3, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$4, void *);
// avahi_reverse_lookup_name
// file address.c line 67
char * avahi_reverse_lookup_name(const struct AvahiAddress *a, char *ret_s, unsigned long int length);
// avahi_rlist_prepend
// file rlist.c line 29
struct AvahiRList * avahi_rlist_prepend(struct AvahiRList *r, void *data);
// avahi_rlist_remove
// file rlist.c line 41
struct AvahiRList * avahi_rlist_remove(struct AvahiRList *r, void *data);
// avahi_rlist_remove_by_link
// file rlist.c line 55
struct AvahiRList * avahi_rlist_remove_by_link(struct AvahiRList *r, struct AvahiRList *n);
// avahi_service_browser_event
// file internal.h line 161
enum anonymous$28 avahi_service_browser_event(struct AvahiClient *client, enum anonymous$3 event, struct DBusMessage *message);
// avahi_service_browser_free
// file lookup.h line 117
signed int avahi_service_browser_free(struct AvahiServiceBrowser *b);
// avahi_service_browser_get_client
// file browser.c line 686
struct AvahiClient * avahi_service_browser_get_client(struct AvahiServiceBrowser *b);
// avahi_service_browser_new
// file browser.c line 564
struct AvahiServiceBrowser * avahi_service_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *type, const char *domain, enum anonymous$2 flags, void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, const char *, enum anonymous$4, void *), void *userdata);
// avahi_service_browser_new::callback$object
//
void callback$object(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, const char *, enum anonymous$4, void *);
// avahi_service_name_join
// file domain.c line 440
signed int avahi_service_name_join(char *p, unsigned long int size, const char *name, const char *type, const char *domain);
// avahi_service_name_split
// file domain.c line 496
signed int avahi_service_name_split(const char *p, char *name, unsigned long int name_size, char *type, unsigned long int type_size, char *domain, unsigned long int domain_size);
// avahi_service_resolver_event
// file internal.h line 164
enum anonymous$28 avahi_service_resolver_event(struct AvahiClient *client, enum anonymous$9 event, struct DBusMessage *message);
// avahi_service_resolver_free
// file lookup.h line 205
signed int avahi_service_resolver_free(struct AvahiServiceResolver *r);
// avahi_service_resolver_get_client
// file resolver.c line 318
struct AvahiClient * avahi_service_resolver_get_client(struct AvahiServiceResolver *r);
// avahi_service_resolver_new
// file resolver.c line 179
struct AvahiServiceResolver * avahi_service_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, const char *type, const char *domain, signed int aprotocol, enum anonymous$2 flags, void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous$9, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous$4, void *), void *userdata);
// avahi_service_resolver_new::callback$object
//
void callback$object(struct AvahiServiceResolver *, signed int, signed int, enum anonymous$9, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous$4, void *);
// avahi_service_type_browser_event
// file internal.h line 160
enum anonymous$28 avahi_service_type_browser_event(struct AvahiClient *client, enum anonymous$3 event, struct DBusMessage *message);
// avahi_service_type_browser_free
// file lookup.h line 150
signed int avahi_service_type_browser_free(struct AvahiServiceTypeBrowser *b);
// avahi_service_type_browser_get_client
// file browser.c line 465
struct AvahiClient * avahi_service_type_browser_get_client(struct AvahiServiceTypeBrowser *b);
// avahi_service_type_browser_new
// file browser.c line 350
struct AvahiServiceTypeBrowser * avahi_service_type_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous$2 flags, void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, enum anonymous$4, void *), void *userdata);
// avahi_service_type_browser_new::callback$object
//
void callback$object(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, enum anonymous$4, void *);
// avahi_set_allocator
// file malloc.c line 196
void avahi_set_allocator(const struct AvahiAllocator *a);
// avahi_simple_poll_dispatch
// file simple-watch.c line 547
signed int avahi_simple_poll_dispatch(struct AvahiSimplePoll *s);
// avahi_simple_poll_free
// file ../avahi-common/simple-watch.h line 40
void avahi_simple_poll_free(struct AvahiSimplePoll *s);
// avahi_simple_poll_get
// file ../avahi-common/simple-watch.h line 45
const struct AvahiPoll * avahi_simple_poll_get(struct AvahiSimplePoll *s);
// avahi_simple_poll_iterate
// file simple-watch.c line 596
signed int avahi_simple_poll_iterate(struct AvahiSimplePoll *s, signed int timeout);
// avahi_simple_poll_loop
// file ../avahi-common/simple-watch.h line 78
signed int avahi_simple_poll_loop(struct AvahiSimplePoll *s);
// avahi_simple_poll_new
// file ../avahi-common/simple-watch.h line 37
struct AvahiSimplePoll * avahi_simple_poll_new(void);
// avahi_simple_poll_prepare
// file simple-watch.c line 450
signed int avahi_simple_poll_prepare(struct AvahiSimplePoll *s, signed int timeout);
// avahi_simple_poll_quit
// file ../avahi-common/simple-watch.h line 60
void avahi_simple_poll_quit(struct AvahiSimplePoll *s);
// avahi_simple_poll_run
// file simple-watch.c line 518
signed int avahi_simple_poll_run(struct AvahiSimplePoll *s);
// avahi_simple_poll_set_func
// file simple-watch.c line 630
void avahi_simple_poll_set_func(struct AvahiSimplePoll *s, signed int (*func)(struct pollfd *, unsigned int, signed int, void *), void *userdata);
// avahi_simple_poll_set_func::func$link1$object
//
signed int func$link1$object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func$object
//
signed int func$object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_wakeup
// file simple-watch.c line 97
void avahi_simple_poll_wakeup(struct AvahiSimplePoll *s);
// avahi_strdup
// file ../avahi-common/malloc.h line 66
char * avahi_strdup(const char *s);
// avahi_strdup_printf
// file malloc.c line 235
char * avahi_strdup_printf(const char *fmt, ...);
// avahi_strdup_vprintf
// file malloc.c line 200
char * avahi_strdup_vprintf(const char *fmt, void **ap);
// avahi_strerror
// file ../avahi-common/error.h line 103
const char * avahi_strerror(signed int error);
// avahi_string_list_add
// file ../avahi-common/strlst.h line 73
struct AvahiStringList * avahi_string_list_add(struct AvahiStringList *l, const char *text);
// avahi_string_list_add_anonymous
// file strlst.c line 34
struct AvahiStringList * avahi_string_list_add_anonymous(struct AvahiStringList *l, unsigned long int size);
// avahi_string_list_add_arbitrary
// file ../avahi-common/strlst.h line 85
struct AvahiStringList * avahi_string_list_add_arbitrary(struct AvahiStringList *l, const unsigned char *text, unsigned long int size);
// avahi_string_list_add_many
// file strlst.c line 255
struct AvahiStringList * avahi_string_list_add_many(struct AvahiStringList *r, ...);
// avahi_string_list_add_many_va
// file strlst.c line 265
struct AvahiStringList * avahi_string_list_add_many_va(struct AvahiStringList *r, __builtin_va_list va);
// avahi_string_list_add_pair
// file strlst.c line 395
struct AvahiStringList * avahi_string_list_add_pair(struct AvahiStringList *l, const char *key, const char *value);
// avahi_string_list_add_pair_arbitrary
// file strlst.c line 404
struct AvahiStringList * avahi_string_list_add_pair_arbitrary(struct AvahiStringList *l, const char *key, const unsigned char *value, unsigned long int size);
// avahi_string_list_add_printf
// file strlst.c line 366
struct AvahiStringList * avahi_string_list_add_printf(struct AvahiStringList *l, const char *format, ...);
// avahi_string_list_add_vprintf
// file strlst.c line 326
struct AvahiStringList * avahi_string_list_add_vprintf(struct AvahiStringList *l, const char *format, void **va);
// avahi_string_list_copy
// file strlst.c line 293
struct AvahiStringList * avahi_string_list_copy(const struct AvahiStringList *l);
// avahi_string_list_equal
// file strlst.c line 235
signed int avahi_string_list_equal(const struct AvahiStringList *a, const struct AvahiStringList *b);
// avahi_string_list_find
// file strlst.c line 378
struct AvahiStringList * avahi_string_list_find(struct AvahiStringList *l, const char *key);
// avahi_string_list_free
// file ../avahi-common/strlst.h line 64
void avahi_string_list_free(struct AvahiStringList *l);
// avahi_string_list_get_next
// file strlst.c line 469
struct AvahiStringList * avahi_string_list_get_next(struct AvahiStringList *l);
// avahi_string_list_get_pair
// file strlst.c line 423
signed int avahi_string_list_get_pair(struct AvahiStringList *l, char **key, char **value, unsigned long int *size);
// avahi_string_list_get_service_cookie
// file strlst.c line 484
unsigned int avahi_string_list_get_service_cookie(struct AvahiStringList *l);
// avahi_string_list_get_size
// file strlst.c line 479
unsigned long int avahi_string_list_get_size(struct AvahiStringList *l);
// avahi_string_list_get_text
// file strlst.c line 474
unsigned char * avahi_string_list_get_text(struct AvahiStringList *l);
// avahi_string_list_length
// file strlst.c line 317
unsigned int avahi_string_list_length(const struct AvahiStringList *l);
// avahi_string_list_new
// file strlst.c line 274
struct AvahiStringList * avahi_string_list_new(const char *txt, ...);
// avahi_string_list_new_from_array
// file strlst.c line 305
struct AvahiStringList * avahi_string_list_new_from_array(const char **array, signed int length);
// avahi_string_list_new_va
// file ../avahi-common/strlst.h line 55
struct AvahiStringList * avahi_string_list_new_va(void **va);
// avahi_string_list_parse
// file strlst.c line 69
signed int avahi_string_list_parse(const void *data, unsigned long int size, struct AvahiStringList **ret);
// avahi_string_list_reverse
// file ../avahi-common/strlst.h line 130
struct AvahiStringList * avahi_string_list_reverse(struct AvahiStringList *l);
// avahi_string_list_serialize
// file strlst.c line 168
unsigned long int avahi_string_list_serialize(struct AvahiStringList *l, void *data, unsigned long int size);
// avahi_string_list_to_string
// file strlst.c line 131
char * avahi_string_list_to_string(struct AvahiStringList *l);
// avahi_strndup
// file malloc.c line 175
char * avahi_strndup(const char *s, unsigned long int max);
// avahi_threaded_poll_free
// file thread-watch.c line 107
void avahi_threaded_poll_free(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_get
// file thread-watch.c line 123
const struct AvahiPoll * avahi_threaded_poll_get(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_lock
// file thread-watch.c line 170
void avahi_threaded_poll_lock(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_new
// file thread-watch.c line 77
struct AvahiThreadedPoll * avahi_threaded_poll_new(void);
// avahi_threaded_poll_quit
// file thread-watch.c line 161
void avahi_threaded_poll_quit(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_start
// file thread-watch.c line 129
signed int avahi_threaded_poll_start(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_stop
// file thread-watch.c line 142
signed int avahi_threaded_poll_stop(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_unlock
// file thread-watch.c line 179
void avahi_threaded_poll_unlock(struct AvahiThreadedPoll *p);
// avahi_timeval_add
// file timeval.c line 59
struct timeval * avahi_timeval_add(struct timeval *a, signed long int usec);
// avahi_timeval_compare
// file timeval.c line 30
signed int avahi_timeval_compare(struct timeval *a, struct timeval *b);
// avahi_timeval_diff
// file timeval.c line 49
signed long int avahi_timeval_diff(struct timeval *a, struct timeval *b);
// avahi_unescape_label
// file domain.c line 41
char * avahi_unescape_label(const char **name, char *dest, unsigned long int size);
// avahi_utf8_valid
// file utf8.h line 29
const char * avahi_utf8_valid(const char *str);
// avahi_xdg_config_open
// file xdg-config.h line 25
struct _IO_FILE * avahi_xdg_config_open(const char *filename);
// bind_textdomain_codeset
// file /usr/include/libintl.h line 91
extern char * bind_textdomain_codeset(const char *, const char *);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_version
// file client.c line 351
static signed int check_version(struct AvahiClient *client, signed int *ret_error);
// cleanup_timeouts
// file simple-watch.c line 304
static void cleanup_timeouts(struct AvahiSimplePoll *s, signed int all);
// cleanup_timeouts$link1
// file simple-watch.c line 304
static void cleanup_timeouts$link1(struct AvahiSimplePoll *s$link1, signed int all$link1);
// cleanup_watches
// file simple-watch.c line 230
static void cleanup_watches(struct AvahiSimplePoll *s, signed int all);
// cleanup_watches$link1
// file simple-watch.c line 230
static void cleanup_watches$link1(struct AvahiSimplePoll *s$link1, signed int all$link1);
// clear_wakeup
// file simple-watch.c line 105
static void clear_wakeup(struct AvahiSimplePoll *s);
// clear_wakeup$link1
// file simple-watch.c line 105
static void clear_wakeup$link1(struct AvahiSimplePoll *s$link1);
// client_callback
// file avahi-publish.c line 150
static void client_callback(struct AvahiClient *c, enum anonymous$5 state, void *userdata);
// client_set_state
// file client.c line 58
static void client_set_state(struct AvahiClient *client, enum anonymous$5 state);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_pipe_fds
// file sigint.c line 58
static void close_pipe_fds(void);
// connection_data_ref
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous$13 * connection_data_ref(struct anonymous$13 *d);
// connection_data_unref
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref(struct anonymous$13 *d);
// dbus_bus_add_match
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 83
void dbus_bus_add_match(struct DBusConnection *, const char *, struct DBusError *);
// dbus_bus_get_private
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 43
struct DBusConnection * dbus_bus_get_private(enum anonymous$29, struct DBusError *);
// dbus_connection_add_filter
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 295
unsigned int dbus_connection_add_filter(struct DBusConnection *, enum anonymous$28 (*)(struct DBusConnection *, struct DBusMessage *, void *), void *, void (*)(void *));
// dbus_connection_close
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 183
void dbus_connection_close(struct DBusConnection *);
// dbus_connection_dispatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 220
enum anonymous$12 dbus_connection_dispatch(struct DBusConnection *);
// dbus_connection_get_dispatch_status
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 218
enum anonymous$12 dbus_connection_get_dispatch_status(struct DBusConnection *);
// dbus_connection_get_is_connected
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 185
unsigned int dbus_connection_get_is_connected(struct DBusConnection *);
// dbus_connection_ref
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 179
struct DBusConnection * dbus_connection_ref(struct DBusConnection *);
// dbus_connection_send_with_reply_and_block
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 233
struct DBusMessage * dbus_connection_send_with_reply_and_block(struct DBusConnection *, struct DBusMessage *, signed int, struct DBusError *);
// dbus_connection_set_dispatch_status_function
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 257
void dbus_connection_set_dispatch_status_function(struct DBusConnection *, void (*)(struct DBusConnection *, enum anonymous$12, void *), void *, void (*)(void *));
// dbus_connection_set_exit_on_disconnect
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 197
void dbus_connection_set_exit_on_disconnect(struct DBusConnection *, unsigned int);
// dbus_connection_set_timeout_functions
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 245
unsigned int dbus_connection_set_timeout_functions(struct DBusConnection *, unsigned int (*)(struct DBusTimeout *, void *), void (*)(struct DBusTimeout *, void *), void (*)(struct DBusTimeout *, void *), void *, void (*)(void *));
// dbus_connection_set_watch_functions
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 238
unsigned int dbus_connection_set_watch_functions(struct DBusConnection *, unsigned int (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void *, void (*)(void *));
// dbus_connection_unref
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 181
void dbus_connection_unref(struct DBusConnection *);
// dbus_error_free
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 67
void dbus_error_free(struct DBusError *);
// dbus_error_init
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 65
void dbus_error_init(struct DBusError *);
// dbus_error_is_set
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 84
unsigned int dbus_error_is_set(const struct DBusError *);
// dbus_message_append_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 189
unsigned int dbus_message_append_args(struct DBusMessage *, signed int, ...);
// dbus_message_get_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 197
unsigned int dbus_message_get_args(struct DBusMessage *, struct DBusError *, signed int, ...);
// dbus_message_get_interface
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 113
const char * dbus_message_get_interface(struct DBusMessage *);
// dbus_message_get_member
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 121
const char * dbus_message_get_member(struct DBusMessage *);
// dbus_message_get_path
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 105
const char * dbus_message_get_path(struct DBusMessage *);
// dbus_message_is_signal
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 152
unsigned int dbus_message_is_signal(struct DBusMessage *, const char *, const char *);
// dbus_message_iter_append_fixed_array
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 253
unsigned int dbus_message_iter_append_fixed_array(struct DBusMessageIter *, signed int, const void *, signed int);
// dbus_message_iter_close_container
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 263
unsigned int dbus_message_iter_close_container(struct DBusMessageIter *, struct DBusMessageIter *);
// dbus_message_iter_get_arg_type
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 220
signed int dbus_message_iter_get_arg_type(struct DBusMessageIter *);
// dbus_message_iter_get_basic
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 227
void dbus_message_iter_get_basic(struct DBusMessageIter *, void *);
// dbus_message_iter_get_element_type
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 222
signed int dbus_message_iter_get_element_type(struct DBusMessageIter *);
// dbus_message_iter_get_fixed_array
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 240
void dbus_message_iter_get_fixed_array(struct DBusMessageIter *, void *, signed int *);
// dbus_message_iter_init
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 211
unsigned int dbus_message_iter_init(struct DBusMessage *, struct DBusMessageIter *);
// dbus_message_iter_init_append
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 246
void dbus_message_iter_init_append(struct DBusMessage *, struct DBusMessageIter *);
// dbus_message_iter_next
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 216
unsigned int dbus_message_iter_next(struct DBusMessageIter *);
// dbus_message_iter_open_container
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 258
unsigned int dbus_message_iter_open_container(struct DBusMessageIter *, signed int, const char *, struct DBusMessageIter *);
// dbus_message_iter_recurse
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 224
void dbus_message_iter_recurse(struct DBusMessageIter *, struct DBusMessageIter *);
// dbus_message_new_method_call
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 72
struct DBusMessage * dbus_message_new_method_call(const char *, const char *, const char *, const char *);
// dbus_message_unref
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 98
void dbus_message_unref(struct DBusMessage *);
// dbus_timeout_get_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 482
void * dbus_timeout_get_data(struct DBusTimeout *);
// dbus_timeout_get_enabled
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 490
unsigned int dbus_timeout_get_enabled(struct DBusTimeout *);
// dbus_timeout_get_interval
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 480
signed int dbus_timeout_get_interval(struct DBusTimeout *);
// dbus_timeout_handle
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 488
unsigned int dbus_timeout_handle(struct DBusTimeout *);
// dbus_timeout_set_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 484
void dbus_timeout_set_data(struct DBusTimeout *, void *, void (*)(void *));
// dbus_watch_get_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 461
void * dbus_watch_get_data(struct DBusWatch *);
// dbus_watch_get_enabled
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 470
unsigned int dbus_watch_get_enabled(struct DBusWatch *);
// dbus_watch_get_flags
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 459
unsigned int dbus_watch_get_flags(struct DBusWatch *);
// dbus_watch_get_unix_fd
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 455
signed int dbus_watch_get_unix_fd(struct DBusWatch *);
// dbus_watch_handle
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 467
unsigned int dbus_watch_handle(struct DBusWatch *, unsigned int);
// dbus_watch_set_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 463
void dbus_watch_set_data(struct DBusWatch *, void *, void (*)(void *));
// defer_timeout_callback
// file browser.c line 83
static void defer_timeout_callback(struct AvahiTimeout *t, void *userdata);
// destroy_timeout
// file simple-watch.c line 296
static void destroy_timeout(struct AvahiTimeout *t);
// destroy_timeout$link1
// file simple-watch.c line 296
static void destroy_timeout$link1(struct AvahiTimeout *t$link1);
// destroy_watch
// file simple-watch.c line 218
static void destroy_watch(struct AvahiWatch *w);
// destroy_watch$link1
// file simple-watch.c line 218
static void destroy_watch$link1(struct AvahiWatch *w$link1);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// dispatch_status
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status(struct DBusConnection *connection, enum anonymous$12 new_status, void *userdata);
// dispatch_timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback(struct AvahiTimeout *t, void *userdata);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// domain_browser_ref
// file browser.c line 77
static void domain_browser_ref(struct AvahiDomainBrowser *db);
// drop_incomplete_utf8
// file alternative.c line 34
static void drop_incomplete_utf8(char *c);
// drop_incomplete_utf8$link1
// file alternative.c line 34
static void drop_incomplete_utf8$link1(char *c$link1);
// entry_group_callback
// file avahi-publish.c line 66
static void entry_group_callback(struct AvahiEntryGroup *g, enum anonymous state, void *userdata);
// entry_group_simple_method_call
// file entrygroup.c line 188
static signed int entry_group_simple_method_call(struct AvahiEntryGroup *group, const char *method);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// filter_func
// file client.c line 103
static enum anonymous$28 filter_func(struct DBusConnection *bus, struct DBusMessage *message, void *userdata);
// find_next_timeout
// file simple-watch.c line 425
static struct AvahiTimeout * find_next_timeout(struct AvahiSimplePoll *s);
// find_next_timeout$link1
// file simple-watch.c line 425
static struct AvahiTimeout * find_next_timeout$link1(struct AvahiSimplePoll *s$link1);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_server_state
// file client.c line 305
static signed int get_server_state(struct AvahiClient *client, signed int *ret_error);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// handler
// file sigint.c line 54
static void handler(signed int s);
// help
// file avahi-publish.c line 214
static void help(struct _IO_FILE *f, const char *argv0);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_server
// file client.c line 431
static signed int init_server(struct AvahiClient *client, signed int *ret_error);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// oom
// file malloc.c line 44
static void oom(void);
// oom$link1
// file malloc.c line 44
static void oom$link1(void);
// parse_command_line
// file avahi-publish.c line 232
static signed int parse_command_line(struct Config *c, const char *argv0, signed int argc, char **argv);
// parse_domain_file
// file browser.c line 58
static void parse_domain_file(struct AvahiDomainBrowser *b);
// parse_environment
// file browser.c line 41
static void parse_environment(struct AvahiDomainBrowser *b);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// poll_func
// file thread-watch.c line 48
static signed int poll_func(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata);
// poll_func$link1
// file thread-watch.c line 48
static signed int poll_func$link1(struct pollfd *ufds$link1, unsigned int nfds$link1, signed int timeout$link1, void *userdata$link1);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 280
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$25 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$25 *, const union anonymous$27 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$25 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$25 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$17 *, struct anonymous$17 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// rebuild
// file simple-watch.c line 385
static signed int rebuild(struct AvahiSimplePoll *s);
// rebuild$link1
// file simple-watch.c line 385
static signed int rebuild$link1(struct AvahiSimplePoll *s$link1);
// register_stuff
// file avahi-publish.c line 109
static signed int register_stuff(struct Config *config);
// remove_pollfd
// file simple-watch.c line 194
static void remove_pollfd(struct AvahiWatch *w);
// remove_pollfd$link1
// file simple-watch.c line 194
static void remove_pollfd$link1(struct AvahiWatch *w$link1);
// remove_timeout
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout(struct DBusTimeout *dbus_timeout, void *userdata);
// remove_watch
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch(struct DBusWatch *dbus_watch, void *userdata);
// request_dispatch
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch(struct anonymous$13 *d, signed int enable);
// retrieve_state
// file entrygroup.c line 52
static signed int retrieve_state(struct AvahiEntryGroup *group);
// set_nonblock
// file sigint.c line 40
static signed int set_nonblock(signed int fd);
// set_nonblock$link1
// file simple-watch.c line 118
static signed int set_nonblock$link1(signed int fd$link1);
// set_nonblock$link2
// file simple-watch.c line 118
static signed int set_nonblock$link2(signed int fd$link2);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$17 *);
// sigint_install
// file sigint.h line 25
signed int sigint_install(struct AvahiSimplePoll *spoll);
// sigint_uninstall
// file sigint.h line 26
void sigint_uninstall(void);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlcpy
// file domain.c line 482
static unsigned long int strlcpy(char *dest, const char *src, unsigned long int n);
// strlcpy$link1
// file domain.c line 482
static unsigned long int strlcpy$link1(char *dest$link1, const char *src$link1, unsigned long int n$link1);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// system_poll
// file simple-watch.c line 626
static signed int system_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata);
// system_poll$link1
// file simple-watch.c line 626
static signed int system_poll$link1(struct pollfd *ufds$link1, unsigned int nfds$link1, signed int timeout$link1, void *userdata$link1);
// thread
// file thread-watch.c line 62
static void * thread(void *userdata);
// thread$link1
// file thread-watch.c line 62
static void * thread$link1(void *userdata$link1);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback(struct AvahiTimeout *avahi_timeout, void *userdata);
// timeout_callback$link1
// file simple-watch.c line 441
static void timeout_callback$link1(struct AvahiTimeout *t);
// timeout_callback$link2
// file simple-watch.c line 441
static void timeout_callback$link2(struct AvahiTimeout *t$link1);
// timeout_data_ref
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref(struct TimeoutData *t);
// timeout_data_unref
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref(struct TimeoutData *t);
// timeout_free
// file simple-watch.c line 284
static void timeout_free(struct AvahiTimeout *t);
// timeout_free$link1
// file simple-watch.c line 284
static void timeout_free$link1(struct AvahiTimeout *t$link1);
// timeout_new
// file simple-watch.c line 244
static struct AvahiTimeout * timeout_new(const struct AvahiPoll *api, struct timeval *tv, void (*callback)(struct AvahiTimeout *, void *), void *userdata);
// timeout_new$link1
// file simple-watch.c line 244
static struct AvahiTimeout * timeout_new$link1(const struct AvahiPoll *api$link1, struct timeval *tv$link1, void (*callback$link1)(struct AvahiTimeout *, void *), void *userdata$link1);
// timeout_new::callback$link1$object
//
void callback$link1$object(struct AvahiTimeout *, void *);
// timeout_new::callback$object
//
void callback$object(struct AvahiTimeout *, void *);
// timeout_toggled
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled(struct DBusTimeout *dbus_timeout, void *userdata);
// timeout_update
// file simple-watch.c line 273
static void timeout_update(struct AvahiTimeout *t, struct timeval *tv);
// timeout_update$link1
// file simple-watch.c line 273
static void timeout_update$link1(struct AvahiTimeout *t$link1, struct timeval *tv$link1);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// translate_avahi_to_dbus
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus(enum anonymous$6 e);
// translate_dbus_to_avahi
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous$6 translate_dbus_to_avahi(unsigned int f);
// update_timeout
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout(struct TimeoutData *timeout);
// update_watch
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch(const struct AvahiPoll *poll_api, struct DBusWatch *dbus_watch);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// watch_callback
// file sigint.c line 67
static void watch_callback(struct AvahiWatch *w, signed int fd, enum anonymous$6 event, void *userdata);
// watch_callback$link1
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback$link1(struct AvahiWatch *avahi_watch, signed int fd$link1, enum anonymous$6 events, void *userdata$link1);
// watch_free
// file simple-watch.c line 203
static void watch_free(struct AvahiWatch *w);
// watch_free$link1
// file simple-watch.c line 203
static void watch_free$link1(struct AvahiWatch *w$link1);
// watch_get_events
// file simple-watch.c line 184
static enum anonymous$6 watch_get_events(struct AvahiWatch *w);
// watch_get_events$link1
// file simple-watch.c line 184
static enum anonymous$6 watch_get_events$link1(struct AvahiWatch *w$link1);
// watch_new
// file simple-watch.c line 132
static struct AvahiWatch * watch_new(const struct AvahiPoll *api, signed int fd, enum anonymous$6 event, void (*callback)(struct AvahiWatch *, signed int, enum anonymous$6, void *), void *userdata);
// watch_new$link1
// file simple-watch.c line 132
static struct AvahiWatch * watch_new$link1(const struct AvahiPoll *api$link1, signed int fd$link1, enum anonymous$6 event$link1, void (*callback$link1)(struct AvahiWatch *, signed int, enum anonymous$6, void *), void *userdata$link1);
// watch_new::callback$link1$object
//
void callback$link1$object(struct AvahiWatch *, signed int, enum anonymous$6, void *);
// watch_new::callback$object
//
void callback$object(struct AvahiWatch *, signed int, enum anonymous$6, void *);
// watch_toggled
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled(struct DBusWatch *dbus_watch, void *userdata);
// watch_update
// file simple-watch.c line 168
static void watch_update(struct AvahiWatch *w, enum anonymous$6 events);
// watch_update$link1
// file simple-watch.c line 168
static void watch_update$link1(struct AvahiWatch *w$link1, enum anonymous$6 events$link1);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xcalloc
// file malloc.c line 89
static void * xcalloc(unsigned long int nmemb, unsigned long int size);
// xcalloc$link1
// file malloc.c line 89
static void * xcalloc$link1(unsigned long int nmemb$link1, unsigned long int size$link1);
// xmalloc
// file malloc.c line 62
static void * xmalloc(unsigned long int size);
// xmalloc$link1
// file malloc.c line 62
static void * xmalloc$link1(unsigned long int size$link1);
// xrealloc
// file malloc.c line 75
static void * xrealloc(void *p, unsigned long int size);
// xrealloc$link1
// file malloc.c line 75
static void * xrealloc$link1(void *p$link1, unsigned long int size$link1);

struct anonymous$13
{
  // connection
  struct DBusConnection *connection;
  // poll_api
  const struct AvahiPoll *poll_api;
  // dispatch_timeout
  struct AvahiTimeout *dispatch_timeout;
  // ref
  signed int ref;
};

struct anonymous$24
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$22
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$17
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$18
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$21
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$20
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$19
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$23
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$14
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$18 _kill;
  // _timer
  struct anonymous$19 _timer;
  // _rt
  struct anonymous$20 _rt;
  // _sigchld
  struct anonymous$21 _sigchld;
  // _sigfault
  struct anonymous$22 _sigfault;
  // _sigpoll
  struct anonymous$23 _sigpoll;
  // _sigsys
  struct anonymous$24 _sigsys;
};

struct anonymous$15
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$14 _sifields;
};

union anonymous$16
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$15 *, void *);
};

union anonymous$27
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct AvahiIPv6Address
{
  // address
  unsigned char address[16l];
};

struct AvahiIPv4Address
{
  // address
  unsigned int address;
};

union anonymous$8
{
  // ipv6
  struct AvahiIPv6Address ipv6;
  // ipv4
  struct AvahiIPv4Address ipv4;
  // data
  unsigned char data[1l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$25
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct AvahiAddress
{
  // proto
  signed int proto;
  // data
  union anonymous$8 data;
};

struct AvahiAddressResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous$9, const struct AvahiAddress *, const char *, enum anonymous$4, void *);
  // userdata
  void *userdata;
  // address_resolvers_next
  struct AvahiAddressResolver *address_resolvers_next;
  // address_resolvers_prev
  struct AvahiAddressResolver *address_resolvers_prev;
  // address
  struct AvahiAddress address;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiAllocator
{
  // malloc
  void * (*malloc)(unsigned long int);
  // free
  void (*free)(void *);
  // realloc
  void * (*realloc)(void *, unsigned long int);
  // calloc
  void * (*calloc)(unsigned long int, unsigned long int);
};

struct AvahiClient
{
  // poll_api
  const struct AvahiPoll *poll_api;
  // bus
  struct DBusConnection *bus;
  // error
  signed int error;
  // state
  enum anonymous$5 state;
  // flags
  enum anonymous$11 flags;
  // version_string
  char *version_string;
  // host_name
  char *host_name;
  // host_name_fqdn
  char *host_name_fqdn;
  // domain_name
  char *domain_name;
  // local_service_cookie
  unsigned int local_service_cookie;
  // local_service_cookie_valid
  signed int local_service_cookie_valid;
  // callback
  void (*callback)(struct AvahiClient *, enum anonymous$5, void *);
  // userdata
  void *userdata;
  // groups
  struct AvahiEntryGroup *groups;
  // domain_browsers
  struct AvahiDomainBrowser *domain_browsers;
  // service_browsers
  struct AvahiServiceBrowser *service_browsers;
  // service_type_browsers
  struct AvahiServiceTypeBrowser *service_type_browsers;
  // service_resolvers
  struct AvahiServiceResolver *service_resolvers;
  // host_name_resolvers
  struct AvahiHostNameResolver *host_name_resolvers;
  // address_resolvers
  struct AvahiAddressResolver *address_resolvers;
  // record_browsers
  struct AvahiRecordBrowser *record_browsers;
};

struct AvahiDomainBrowser
{
  // ref
  signed int ref;
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$3, const char *, enum anonymous$4, void *);
  // userdata
  void *userdata;
  // domain_browsers_next
  struct AvahiDomainBrowser *domain_browsers_next;
  // domain_browsers_prev
  struct AvahiDomainBrowser *domain_browsers_prev;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
  // defer_timeout
  struct AvahiTimeout *defer_timeout;
  // static_browse_domains
  struct AvahiStringList *static_browse_domains;
};

struct AvahiEntryGroup
{
  // path
  char *path;
  // state
  enum anonymous state;
  // state_valid
  signed int state_valid;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiEntryGroup *, enum anonymous, void *);
  // userdata
  void *userdata;
  // groups_next
  struct AvahiEntryGroup *groups_next;
  // groups_prev
  struct AvahiEntryGroup *groups_prev;
};

struct AvahiHostNameResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous$9, const char *, const struct AvahiAddress *, enum anonymous$4, void *);
  // userdata
  void *userdata;
  // host_name_resolvers_next
  struct AvahiHostNameResolver *host_name_resolvers_next;
  // host_name_resolvers_prev
  struct AvahiHostNameResolver *host_name_resolvers_prev;
  // host_name
  char *host_name;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiPoll
{
  // userdata
  void *userdata;
  // watch_new
  struct AvahiWatch * (*watch_new)(const struct AvahiPoll *, signed int, enum anonymous$6, void (*)(struct AvahiWatch *, signed int, enum anonymous$6, void *), void *);
  // watch_update
  void (*watch_update)(struct AvahiWatch *, enum anonymous$6);
  // watch_get_events
  enum anonymous$6 (*watch_get_events)(struct AvahiWatch *);
  // watch_free
  void (*watch_free)(struct AvahiWatch *);
  // timeout_new
  struct AvahiTimeout * (*timeout_new)(const struct AvahiPoll *, struct timeval *, void (*)(struct AvahiTimeout *, void *), void *);
  // timeout_update
  void (*timeout_update)(struct AvahiTimeout *, struct timeval *);
  // timeout_free
  void (*timeout_free)(struct AvahiTimeout *);
};

struct AvahiRList
{
  // rlist_next
  struct AvahiRList *rlist_next;
  // rlist_prev
  struct AvahiRList *rlist_prev;
  // data
  void *data;
};

struct AvahiRecordBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$3, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$4, void *);
  // userdata
  void *userdata;
  // record_browsers_next
  struct AvahiRecordBrowser *record_browsers_next;
  // record_browsers_prev
  struct AvahiRecordBrowser *record_browsers_prev;
  // name
  char *name;
  // clazz
  unsigned short int clazz;
  // type
  unsigned short int type;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, const char *, enum anonymous$4, void *);
  // userdata
  void *userdata;
  // service_browsers_next
  struct AvahiServiceBrowser *service_browsers_next;
  // service_browsers_prev
  struct AvahiServiceBrowser *service_browsers_prev;
  // type
  char *type;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous$9, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous$4, void *);
  // userdata
  void *userdata;
  // service_resolvers_next
  struct AvahiServiceResolver *service_resolvers_next;
  // service_resolvers_prev
  struct AvahiServiceResolver *service_resolvers_prev;
  // name
  char *name;
  // type
  char *type;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceTypeBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, enum anonymous$4, void *);
  // userdata
  void *userdata;
  // service_type_browsers_next
  struct AvahiServiceTypeBrowser *service_type_browsers_next;
  // service_type_browsers_prev
  struct AvahiServiceTypeBrowser *service_type_browsers_prev;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiSimplePoll
{
  // api
  struct AvahiPoll api;
  // poll_func
  signed int (*poll_func)(struct pollfd *, unsigned int, signed int, void *);
  // poll_func_userdata
  void *poll_func_userdata;
  // pollfds
  struct pollfd *pollfds;
  // n_pollfds
  signed int n_pollfds;
  // max_pollfds
  signed int max_pollfds;
  // rebuild_pollfds
  signed int rebuild_pollfds;
  // watch_req_cleanup
  signed int watch_req_cleanup;
  // timeout_req_cleanup
  signed int timeout_req_cleanup;
  // quit
  signed int quit;
  // events_valid
  signed int events_valid;
  // n_watches
  signed int n_watches;
  // watches
  struct AvahiWatch *watches;
  // timeouts
  struct AvahiTimeout *timeouts;
  // wakeup_pipe
  signed int wakeup_pipe[2l];
  // wakeup_issued
  signed int wakeup_issued;
  // prepared_timeout
  signed int prepared_timeout;
  // state
  enum anonymous$10 state;
};

struct AvahiStringList
{
  // next
  struct AvahiStringList *next;
  // size
  unsigned long int size;
  // text
  unsigned char text[1l];
};

struct AvahiThreadedPoll
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // thread_id
  unsigned long int thread_id;
  // mutex
  union anonymous$25 mutex;
  // thread_running
  signed int thread_running;
  // retval
  signed int retval;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct AvahiTimeout
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // dead
  signed int dead;
  // enabled
  signed int enabled;
  // expiry
  struct timeval expiry;
  // callback
  void (*callback)(struct AvahiTimeout *, void *);
  // userdata
  void *userdata;
  // timeouts_next
  struct AvahiTimeout *timeouts_next;
  // timeouts_prev
  struct AvahiTimeout *timeouts_prev;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct AvahiWatch
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // dead
  signed int dead;
  // idx
  signed int idx;
  // pollfd
  struct pollfd pollfd;
  // callback
  void (*callback)(struct AvahiWatch *, signed int, enum anonymous$6, void *);
  // userdata
  void *userdata;
  // watches_next
  struct AvahiWatch *watches_next;
  // watches_prev
  struct AvahiWatch *watches_prev;
};

struct Config
{
  // verbose
  signed int verbose;
  // no_fail
  signed int no_fail;
  // no_reverse
  signed int no_reverse;
  // command
  enum anonymous$7 command;
  // name
  char *name;
  // stype
  char *stype;
  // domain
  char *domain;
  // host
  char *host;
  // port
  unsigned short int port;
  // txt
  struct AvahiStringList *txt;
  // subtypes
  struct AvahiStringList *subtypes;
  // address
  struct AvahiAddress address;
};

struct DBusError
{
  // name
  const char *name;
  // message
  const char *message;
  // dummy1
  unsigned int dummy1 : 1;
  // dummy2
  unsigned int dummy2 : 1;
  // dummy3
  unsigned int dummy3 : 1;
  // dummy4
  unsigned int dummy4 : 1;
  // dummy5
  unsigned int dummy5 : 1;
  // padding1
  void *padding1;
};

struct DBusMessageIter
{
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  unsigned int dummy3;
  // dummy4
  signed int dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // dummy7
  signed int dummy7;
  // dummy8
  signed int dummy8;
  // dummy9
  signed int dummy9;
  // dummy10
  signed int dummy10;
  // dummy11
  signed int dummy11;
  // pad1
  signed int pad1;
  // pad2
  signed int pad2;
  // pad3
  void *pad3;
};

struct TimeoutData
{
  // poll_api
  const struct AvahiPoll *poll_api;
  // avahi_timeout
  struct AvahiTimeout *avahi_timeout;
  // dbus_timeout
  struct DBusTimeout *dbus_timeout;
  // ref
  signed int ref;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct error_map
{
  // dbus_error
  const char *dbus_error;
  // avahi_error
  signed int avahi_error;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$16 __sigaction_handler;
  // sa_mask
  struct anonymous$17 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// allocator
// file malloc.c line 40
static const struct AvahiAllocator *allocator = (const struct AvahiAllocator *)(void *)0;
// allocator$link1
// file malloc.c line 40
static const struct AvahiAllocator *allocator$link1 = (const struct AvahiAllocator *)(void *)0;
// client
// file avahi-publish.c line 61
static struct AvahiClient *client = (struct AvahiClient *)(void *)0;
// entry_group
// file avahi-publish.c line 62
static struct AvahiEntryGroup *entry_group = (struct AvahiEntryGroup *)(void *)0;
// error_map
// file ../avahi-common/dbus.c line 98
static struct error_map error_map[15l] = { { .dbus_error="org.freedesktop.DBus.Error.Failed", .avahi_error=-1 },
    { .dbus_error="org.freedesktop.DBus.Error.NoMemory", .avahi_error=-24 },
    { .dbus_error="org.freedesktop.DBus.Error.ServiceUnknown", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.BadAddress", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.NotSupported", .avahi_error=-49 },
    { .dbus_error="org.freedesktop.DBus.Error.LimitsExceeded", .avahi_error=-17 },
    { .dbus_error="org.freedesktop.DBus.Error.AccessDenied", .avahi_error=-20 },
    { .dbus_error="org.freedesktop.DBus.Error.AuthFailed", .avahi_error=-20 },
    { .dbus_error="org.freedesktop.DBus.Error.NoServer", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.Timeout", .avahi_error=-15 },
    { .dbus_error="org.freedesktop.DBus.Error.NoNetwork", .avahi_error=-5 },
    { .dbus_error="org.freedesktop.DBus.Error.Disconnected", .avahi_error=-23 },
    { .dbus_error="org.freedesktop.DBus.Error.InvalidArgs", .avahi_error=-51 },
    { .dbus_error="org.freedesktop.DBus.Error.TimedOut", .avahi_error=-15 },
    { .dbus_error=(const char *)(void *)0, .avahi_error=0 } };
// old_sigint_sa
// file sigint.c line 36
static struct sigaction old_sigint_sa;
// old_sigterm_sa
// file sigint.c line 36
static struct sigaction old_sigterm_sa;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// pipe_fds
// file sigint.c line 37
static signed int pipe_fds[2l] = { -1, -1 };
// simple_poll
// file avahi-publish.c line 60
static struct AvahiSimplePoll *simple_poll = (struct AvahiSimplePoll *)(void *)0;
// simple_poll$link1
// file sigint.c line 35
static struct AvahiSimplePoll *simple_poll$link1 = (struct AvahiSimplePoll *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// table
// file ../avahi-common/dbus.c line 31
static const char * const table[54l] = { "org.freedesktop.Avahi.Success", "org.freedesktop.Avahi.Failure", "org.freedesktop.Avahi.BadStateError", "org.freedesktop.Avahi.InvalidHostNameError",
    "org.freedesktop.Avahi.InvalidDomainNameError",
    "org.freedesktop.Avahi.NoNetworkError", "org.freedesktop.Avahi.InvalidTTLError",
    "org.freedesktop.Avahi.IsPatternError", "org.freedesktop.Avahi.CollisionError", "org.freedesktop.Avahi.InvalidRecordError",
    "org.freedesktop.Avahi.InvalidServiceNameError",
    "org.freedesktop.Avahi.InvalidServiceTypeError",
    "org.freedesktop.Avahi.InvalidPortError",
    "org.freedesktop.Avahi.InvalidKeyError",
    "org.freedesktop.Avahi.InvalidAddressError",
    "org.freedesktop.Avahi.TimeoutError", "org.freedesktop.Avahi.TooManyClientsError",
    "org.freedesktop.Avahi.TooManyObjectsError",
    "org.freedesktop.Avahi.TooManyEntriesError",
    "org.freedesktop.Avahi.OSError", "org.freedesktop.DBus.Error.AccessDenied",
    "org.freedesktop.Avahi.InvalidOperationError",
    "org.freedesktop.Avahi.DBusError", "org.freedesktop.Avahi.DisconnectedError",
    "org.freedesktop.Avahi.NoMemoryError", "org.freedesktop.Avahi.InvalidObjectError",
    "org.freedesktop.Avahi.NoDaemonError", "org.freedesktop.Avahi.InvalidInterfaceError",
    "org.freedesktop.Avahi.InvalidInterfaceProtocolError",
    "org.freedesktop.Avahi.InvalidFlagsError",
    "org.freedesktop.Avahi.NotFoundError", "org.freedesktop.Avahi.InvalidConfigurationError",
    "org.freedesktop.Avahi.VersionMismatchError",
    "org.freedesktop.Avahi.InvalidServiceSubtypeError",
    "org.freedesktop.Avahi.InvalidPacketError",
    "org.freedesktop.Avahi.InvalidDNSErrorError",
    "org.freedesktop.Avahi.DNSFORMERR", "org.freedesktop.Avahi.DNSSERVFAIL", "org.freedesktop.Avahi.DNSNXDOMAIN", "org.freedesktop.Avahi.DNSNOTIMP", "org.freedesktop.Avahi.DNSREFUSED", "org.freedesktop.Avahi.DNSYXDOMAIN", "org.freedesktop.Avahi.DNSYXRRSET", "org.freedesktop.Avahi.DNSNXRRSET", "org.freedesktop.Avahi.DNSNOTAUTH", "org.freedesktop.Avahi.DNSNOTZONE", "org.freedesktop.Avahi.InvalidRDataError",
    "org.freedesktop.Avahi.InvalidDNSClassError",
    "org.freedesktop.Avahi.InvalidDNSTypeError",
    "org.freedesktop.Avahi.NotSupportedError",
    "org.freedesktop.Avahi.NotPermittedError",
    "org.freedesktop.Avahi.InvalidArgumentError",
    "org.freedesktop.Avahi.IsEmptyError", "org.freedesktop.Avahi.NoChangeError" };
// watch
// file sigint.c line 38
static struct AvahiWatch *watch = (struct AvahiWatch *)(void *)0;

// add_timeout
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct TimeoutData *timeout;
  struct anonymous$13 *d = (struct anonymous$13 *)userdata;
  struct timeval tv;
  unsigned int b;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$13 *)NULL));
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link4((unsigned int)1, sizeof(struct TimeoutData) /*32ul*/ );
  timeout = (struct TimeoutData *)return_value_avahi_new_internal$1;
  signed int return_value_dbus_timeout_get_interval$2;
  if(timeout == ((struct TimeoutData *)NULL))
    return (unsigned int)0;

  else
  {
    timeout->dbus_timeout = dbus_timeout;
    timeout->poll_api = d->poll_api;
    timeout->ref = 1;
    b=dbus_timeout_get_enabled(dbus_timeout);
    if(!(b == 0u))
    {
      return_value_dbus_timeout_get_interval$2=dbus_timeout_get_interval(dbus_timeout);
      avahi_elapse_time(&tv, (unsigned int)return_value_dbus_timeout_get_interval$2, (unsigned int)0);
    }

    timeout->avahi_timeout=d->poll_api->timeout_new(d->poll_api, b != 0u ? &tv : (struct timeval *)(void *)0, timeout_callback, (void *)timeout);
    if(timeout->avahi_timeout == ((struct AvahiTimeout *)NULL))
    {
      avahi_free((void *)timeout);
      return (unsigned int)0;
    }

    else
    {
      dbus_timeout_set_data(dbus_timeout, (void *)timeout, (void (*)(void *))timeout_data_unref);
      return (unsigned int)1;
    }
  }
}

// add_watch
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous$13 *d = (struct anonymous$13 *)userdata;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$13 *)NULL));
  unsigned int return_value_update_watch$1;
  return_value_update_watch$1=update_watch(d->poll_api, dbus_watch);
  return return_value_update_watch$1;
}

// address_get_size
// file address.c line 35
static unsigned long int address_get_size(const struct AvahiAddress *a)
{
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  if(a->proto == 0)
    return (unsigned long int)4;

  else
    if(a->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size$link1
// file address.c line 35
static unsigned long int address_get_size$link1(const struct AvahiAddress *a$link1)
{
  /* assertion a */
  assert(a$link1 != ((const struct AvahiAddress *)NULL));
  if(a$link1->proto == 0)
    return (unsigned long int)4;

  else
    if(a$link1->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// append_rdata
// file entrygroup.c line 348
static signed int append_rdata(struct DBusMessage *message, const void *rdata, unsigned long int size)
{
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message, &iter);
  unsigned int return_value_dbus_message_iter_open_container$1;
  return_value_dbus_message_iter_open_container$1=dbus_message_iter_open_container(&iter, (signed int)97, "y", &sub);
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_message_iter_append_fixed_array$2;
  if(return_value_dbus_message_iter_open_container$1 == 0u)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_append_fixed_array$2=dbus_message_iter_append_fixed_array(&sub, (signed int)121, (const void *)&rdata, (signed int)size);
    tmp_if_expr$3 = !(return_value_dbus_message_iter_append_fixed_array$2 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_message_iter_close_container$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_close_container$4=dbus_message_iter_close_container(&iter, &sub);
    tmp_if_expr$5 = !(return_value_dbus_message_iter_close_container$4 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
    return -1;

  else
    return 0;
}

// append_string_list
// file entrygroup.c line 363
static signed int append_string_list(struct DBusMessage *message, struct AvahiStringList *txt)
{
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  signed int r = -1;
  struct AvahiStringList *p;
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message, &iter);
  txt=avahi_string_list_reverse(txt);
  unsigned int return_value_dbus_message_iter_open_container$1;
  return_value_dbus_message_iter_open_container$1=dbus_message_iter_open_container(&iter, (signed int)97, "ay", &sub);
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_message_iter_append_fixed_array$3;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_message_iter_close_container$5;
  unsigned int return_value_dbus_message_iter_close_container$7;
  if(!(return_value_dbus_message_iter_open_container$1 == 0u))
  {
    p = txt;
    for( ; !(p == ((struct AvahiStringList *)NULL)); p = p->next)
    {
      struct DBusMessageIter sub2;
      const unsigned char *data = p->text;
      unsigned int return_value_dbus_message_iter_open_container$2;
      return_value_dbus_message_iter_open_container$2=dbus_message_iter_open_container(&sub, (signed int)97, "y", &sub2);
      if(return_value_dbus_message_iter_open_container$2 == 0u)
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_append_fixed_array$3=dbus_message_iter_append_fixed_array(&sub2, (signed int)121, (const void *)&data, (signed int)p->size);
        tmp_if_expr$4 = !(return_value_dbus_message_iter_append_fixed_array$3 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_close_container$5=dbus_message_iter_close_container(&sub, &sub2);
        tmp_if_expr$6 = !(return_value_dbus_message_iter_close_container$5 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        goto fail;

    }
    return_value_dbus_message_iter_close_container$7=dbus_message_iter_close_container(&iter, &sub);
    if(!(return_value_dbus_message_iter_close_container$7 == 0u))
      r = 0;

  }


fail:
  ;
  txt=avahi_string_list_reverse(txt);
  return r;
}

// avahi_address_cmp
// file address.c line 46
signed int avahi_address_cmp(const struct AvahiAddress *a, const struct AvahiAddress *b)
{
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  /* assertion b */
  assert(b != ((const struct AvahiAddress *)NULL));
  if(!(a->proto == b->proto))
    return -1;

  else
  {
    unsigned long int return_value_address_get_size$1;
    return_value_address_get_size$1=address_get_size(a);
    signed int return_value_memcmp$2;
    return_value_memcmp$2=memcmp((const void *)a->data.data, (const void *)b->data.data, return_value_address_get_size$1);
    return return_value_memcmp$2;
  }
}

// avahi_address_parse
// file ../avahi-common/address.h line 95
struct AvahiAddress * avahi_address_parse(const char *s, signed int proto, struct AvahiAddress *ret_addr)
{
  /* assertion ret_addr */
  assert(ret_addr != ((struct AvahiAddress *)NULL));
  /* assertion s */
  assert(s != ((const char *)NULL));
  if(proto == -1)
  {
    signed int return_value_inet_pton$2;
    return_value_inet_pton$2=inet_pton(2, s, (void *)ret_addr->data.data);
    if(!(return_value_inet_pton$2 >= 1))
    {
      signed int return_value_inet_pton$1;
      return_value_inet_pton$1=inet_pton(10, s, (void *)ret_addr->data.data);
      if(!(return_value_inet_pton$1 >= 1))
        return (struct AvahiAddress *)(void *)0;

      else
        ret_addr->proto = 1;
    }

    else
      ret_addr->proto = 0;
  }

  else
  {
    signed int return_value_avahi_proto_to_af$3;
    return_value_avahi_proto_to_af$3=avahi_proto_to_af(proto);
    signed int return_value_inet_pton$4;
    return_value_inet_pton$4=inet_pton(return_value_avahi_proto_to_af$3, s, (void *)ret_addr->data.data);
    if(!(return_value_inet_pton$4 >= 1))
      return (struct AvahiAddress *)(void *)0;

    ret_addr->proto = proto;
  }
  return ret_addr;
}

// avahi_address_resolver_event
// file internal.h line 166
enum anonymous$28 avahi_address_resolver_event(struct AvahiClient *client, enum anonymous$9 event, struct DBusMessage *message)
{
  struct AvahiAddressResolver *r = (struct AvahiAddressResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *address;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  struct AvahiAddress *return_value_avahi_address_parse$5;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  signed int return_value_avahi_error_dbus_to_number$9;
  if(!(path == ((const char *)NULL)))
  {
    r = client->address_resolvers;
    for( ; !(r == ((struct AvahiAddressResolver *)NULL)); r = r->address_resolvers_next)
    {
      return_value_strcmp$1=strcmp(r->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(r == ((struct AvahiAddressResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)115, &name, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        /* assertion address */
        assert(address != ((char *)NULL));
        return_value_avahi_address_parse$5=avahi_address_parse(address, (signed int)aprotocol, &a);
        if(return_value_avahi_address_parse$5 == ((struct AvahiAddress *)NULL))
        {
          fprintf(stderr, "Failed to parse address\n");
          goto fail;
        }

        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous$9)AVAHI_RESOLVER_FOUND, &a, name, (enum anonymous$4)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args$6=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$6 == 0u)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$9=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number$9);
        r->callback(r, r->interface, r->protocol, event, &r->address, (const char *)(void *)0, (enum anonymous$4)0, r->userdata);
      }
    }
    return (enum anonymous$28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_address_resolver_free
// file lookup.h line 269
signed int avahi_address_resolver_free(struct AvahiAddressResolver *r)
{
  struct AvahiClient *avahi_address_resolver_free$$1$$client;
  signed int ret = 0;
  /* assertion r */
  assert(r != ((struct AvahiAddressResolver *)NULL));
  avahi_address_resolver_free$$1$$client = r->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(avahi_address_resolver_free$$1$$client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      ret=avahi_client_simple_method_call(avahi_address_resolver_free$$1$$client, r->path, "org.freedesktop.Avahi.AddressResolver", "Free");

  }

  do
  {
    struct AvahiAddressResolver **_head = &avahi_address_resolver_free$$1$$client->address_resolvers;
    struct AvahiAddressResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiAddressResolver *)NULL));
    if(!(_item->address_resolvers_next == ((struct AvahiAddressResolver *)NULL)))
      _item->address_resolvers_next->address_resolvers_prev = _item->address_resolvers_prev;

    if(!(_item->address_resolvers_prev == ((struct AvahiAddressResolver *)NULL)))
      _item->address_resolvers_prev->address_resolvers_next = _item->address_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->address_resolvers_next;
    }
    _item->address_resolvers_prev = (struct AvahiAddressResolver *)(void *)0;
    _item->address_resolvers_next = _item->address_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r);
  return ret;
}

// avahi_address_resolver_get_client
// file resolver.c line 755
struct AvahiClient * avahi_address_resolver_get_client(struct AvahiAddressResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiAddressResolver *)NULL));
  return r->client;
}

// avahi_address_resolver_new
// file resolver.c line 642
struct AvahiAddressResolver * avahi_address_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const struct AvahiAddress *a, enum anonymous$2 flags, void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous$9, const struct AvahiAddress *, const char *, enum anonymous$4, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiAddressResolver *r = (struct AvahiAddressResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  char *path;
  char addr[40l];
  char *address = addr;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  dbus_error_init(&error);
  char *return_value_avahi_address_snprint$1;
  return_value_avahi_address_snprint$1=avahi_address_snprint(addr, sizeof(char [40l]) /*40ul*/ , a);
  void *return_value_avahi_new_internal$3;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_error_is_set$5;
  unsigned int return_value_dbus_message_get_args$7;
  _Bool tmp_if_expr$9;
  unsigned int return_value_dbus_error_is_set$8;
  if(return_value_avahi_address_snprint$1 == ((char *)NULL))
  {
    avahi_client_set_errno(client, -14);
    return (struct AvahiAddressResolver *)(void *)0;
  }

  else
  {
    signed int return_value_avahi_client_is_connected$2;
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(client);
    if(return_value_avahi_client_is_connected$2 == 0)
      avahi_client_set_errno(client, -2);

    else
    {
      return_value_avahi_new_internal$3=avahi_new_internal$link3((unsigned int)1, sizeof(struct AvahiAddressResolver) /*80ul*/ );
      r = (struct AvahiAddressResolver *)return_value_avahi_new_internal$3;
      if(r == ((struct AvahiAddressResolver *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        r->client = client;
        r->callback = callback;
        r->userdata = userdata;
        r->path = (char *)(void *)0;
        r->interface = interface;
        r->protocol = protocol;
        r->address = *a;
        do
        {
          struct AvahiAddressResolver **_head = &client->address_resolvers;
          struct AvahiAddressResolver *_item = r;
          /* assertion _item */
          assert(_item != ((struct AvahiAddressResolver *)NULL));
          _item->address_resolvers_next = *_head;
          if(!(_item->address_resolvers_next == ((struct AvahiAddressResolver *)NULL)))
            _item->address_resolvers_next->address_resolvers_prev = _item;

          _item->address_resolvers_prev = (struct AvahiAddressResolver *)(void *)0;
          *_head = _item;
        }
        while((_Bool)0);
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "AddressResolverNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &address, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args$4 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr$6 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$5=dbus_error_is_set(&error);
              tmp_if_expr$6 = return_value_dbus_error_is_set$5 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$6)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args$7=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args$7 == 0u)
                tmp_if_expr$9 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$8=dbus_error_is_set(&error);
                tmp_if_expr$9 = return_value_dbus_error_is_set$8 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr$9)
                avahi_client_set_errno(client, -22);

              else
              {
                r->path=avahi_strdup(path);
                if(r->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return r;
                }
              }
            }
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$10;
    return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$10 == 0u))
    {
      avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(r == ((struct AvahiAddressResolver *)NULL)))
      avahi_address_resolver_free(r);

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return (struct AvahiAddressResolver *)(void *)0;
  }
}

// avahi_address_snprint
// file ../avahi-common/address.h line 90
char * avahi_address_snprint(char *s, unsigned long int length, const struct AvahiAddress *a)
{
  /* assertion s */
  assert(s != ((char *)NULL));
  /* assertion length */
  assert(length != 0ul);
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  signed int return_value_avahi_proto_to_af$1;
  return_value_avahi_proto_to_af$1=avahi_proto_to_af(a->proto);
  const char *return_value_inet_ntop$2;
  return_value_inet_ntop$2=inet_ntop(return_value_avahi_proto_to_af$1, (const void *)a->data.data, s, (unsigned int)length);
  if(return_value_inet_ntop$2 == ((const char *)NULL))
    return (char *)(void *)0;

  else
    return s;
}

// avahi_af_to_proto
// file address.c line 137
signed int avahi_af_to_proto(signed int af)
{
  if(af == 2)
    return 0;

  else
    if(af == 10)
      return 1;

    else
    {
      /* assertion af == 0 */
      assert(af == 0);
      return -1;
    }
}

// avahi_age
// file timeval.c line 76
signed long int avahi_age(struct timeval *a)
{
  struct timeval now;
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  gettimeofday(&now, (struct timezone *)(void *)0);
  signed long int return_value_avahi_timeval_diff$1;
  return_value_avahi_timeval_diff$1=avahi_timeval_diff(&now, a);
  return return_value_avahi_timeval_diff$1;
}

// avahi_alternative_host_name
// file ../avahi-common/alternative.h line 33
char * avahi_alternative_host_name(const char *s)
{
  const char *e;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  signed int return_value_avahi_is_valid_host_name$1;
  return_value_avahi_is_valid_host_name$1=avahi_is_valid_host_name(s);
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$5;
  if(return_value_avahi_is_valid_host_name$1 == 0)
    return (char *)(void *)0;

  else
  {
    e=strrchr(s, 45);
    if(!(e == ((const char *)NULL)))
    {
      const char *p;
      e = e + 1l;
      p = e;
      for( ; !(*p == 0); p = p + 1l)
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*p]) == 0)
        {
          e = (const char *)(void *)0;
          break;
        }

      }
      if(!(e == ((const char *)NULL)))
      {
        if((signed int)*e == 48)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (signed int)*e == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
          e = (const char *)(void *)0;

      }

    }

    if(!(e == ((const char *)NULL)))
    {
      char *c;
      char *m;
      unsigned long int l;
      signed int n;
      signed int return_value_atoi$4;
      return_value_atoi$4=atoi(e);
      n = return_value_atoi$4 + 1;
      m=avahi_strdup_printf("%i", n);
      if(m == ((char *)NULL))
        return (char *)(void *)0;

      l = (unsigned long int)((e - s) - (signed long int)1);
      unsigned long int return_value_strlen$6;
      return_value_strlen$6=strlen(m);
      if(l >= 63ul + -return_value_strlen$6 + 18446744073709551615ul)
      {
        return_value_strlen$5=strlen(m);
        l = ((unsigned long int)(64 - 1) - return_value_strlen$5) - (unsigned long int)1;
      }

      c=avahi_strndup(s, l);
      if(c == ((char *)NULL))
      {
        avahi_free((void *)m);
        return (char *)(void *)0;
      }

      drop_incomplete_utf8(c);
      r=avahi_strdup_printf("%s-%s", c, m);
      avahi_free((void *)c);
      avahi_free((void *)m);
    }

    else
    {
      char *avahi_alternative_host_name$$1$$3$$c;
      avahi_alternative_host_name$$1$$3$$c=avahi_strndup(s, (unsigned long int)((64 - 1) - 2));
      if(avahi_alternative_host_name$$1$$3$$c == ((char *)NULL))
        return (char *)(void *)0;

      drop_incomplete_utf8(avahi_alternative_host_name$$1$$3$$c);
      r=avahi_strdup_printf("%s-2", avahi_alternative_host_name$$1$$3$$c);
      avahi_free((void *)avahi_alternative_host_name$$1$$3$$c);
    }
    signed int return_value_avahi_is_valid_host_name$7;
    return_value_avahi_is_valid_host_name$7=avahi_is_valid_host_name(r);
    /* assertion avahi_is_valid_host_name(r) */
    assert(return_value_avahi_is_valid_host_name$7 != 0);
    return r;
  }
}

// avahi_alternative_service_name
// file ../avahi-common/alternative.h line 39
char * avahi_alternative_service_name(const char *s)
{
  const char *e;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  signed int return_value_avahi_is_valid_service_name$1;
  return_value_avahi_is_valid_service_name$1=avahi_is_valid_service_name(s);
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$5;
  if(return_value_avahi_is_valid_service_name$1 == 0)
    return (char *)(void *)0;

  else
  {
    e=strstr(s, " #");
    if(!(e == ((const char *)NULL)))
    {
      const char *avahi_alternative_service_name$$1$$1$$n;
      const char *p;
      e = e + (signed long int)2;
      do
      {
        avahi_alternative_service_name$$1$$1$$n=strstr(e, " #");
        if(avahi_alternative_service_name$$1$$1$$n == ((const char *)NULL))
          break;

        e = avahi_alternative_service_name$$1$$1$$n + (signed long int)2;
      }
      while((_Bool)1);
      p = e;
      for( ; !(*p == 0); p = p + 1l)
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*p]) == 0)
        {
          e = (const char *)(void *)0;
          break;
        }

      }
      if(!(e == ((const char *)NULL)))
      {
        if((signed int)*e == 48)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (signed int)*e == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
          e = (const char *)(void *)0;

      }

    }

    if(!(e == ((const char *)NULL)))
    {
      char *avahi_alternative_service_name$$1$$2$$c;
      char *m;
      unsigned long int l;
      signed int n;
      signed int return_value_atoi$4;
      return_value_atoi$4=atoi(e);
      n = return_value_atoi$4 + 1;
      m=avahi_strdup_printf("%i", n);
      if(m == ((char *)NULL))
        return (char *)(void *)0;

      l = (unsigned long int)((e - s) - (signed long int)2);
      unsigned long int return_value_strlen$6;
      return_value_strlen$6=strlen(m);
      if(l >= 63ul + -return_value_strlen$6 + 18446744073709551614ul)
      {
        return_value_strlen$5=strlen(m);
        l = ((unsigned long int)(64 - 1) - return_value_strlen$5) - (unsigned long int)2;
      }

      avahi_alternative_service_name$$1$$2$$c=avahi_strndup(s, l);
      if(avahi_alternative_service_name$$1$$2$$c == ((char *)NULL))
      {
        avahi_free((void *)m);
        return (char *)(void *)0;
      }

      drop_incomplete_utf8(avahi_alternative_service_name$$1$$2$$c);
      r=avahi_strdup_printf("%s #%s", avahi_alternative_service_name$$1$$2$$c, m);
      avahi_free((void *)avahi_alternative_service_name$$1$$2$$c);
      avahi_free((void *)m);
    }

    else
    {
      char *c;
      c=avahi_strndup(s, (unsigned long int)((64 - 1) - 3));
      if(c == ((char *)NULL))
        return (char *)(void *)0;

      drop_incomplete_utf8(c);
      r=avahi_strdup_printf("%s #2", c);
      avahi_free((void *)c);
    }
    signed int return_value_avahi_is_valid_service_name$7;
    return_value_avahi_is_valid_service_name$7=avahi_is_valid_service_name(r);
    /* assertion avahi_is_valid_service_name(r) */
    assert(return_value_avahi_is_valid_service_name$7 != 0);
    return r;
  }
}

// avahi_client_errno
// file ../avahi-client/client.h line 99
signed int avahi_client_errno(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  return client->error;
}

// avahi_client_free
// file ../avahi-client/client.h line 72
void avahi_client_free(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  if(!(client->bus == ((struct DBusConnection *)NULL)))
    dbus_connection_close(client->bus);

  while(!(client->groups == ((struct AvahiEntryGroup *)NULL)))
    avahi_entry_group_free(client->groups);
  while(!(client->domain_browsers == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(client->domain_browsers);
  while(!(client->service_browsers == ((struct AvahiServiceBrowser *)NULL)))
    avahi_service_browser_free(client->service_browsers);
  while(!(client->service_type_browsers == ((struct AvahiServiceTypeBrowser *)NULL)))
    avahi_service_type_browser_free(client->service_type_browsers);
  while(!(client->service_resolvers == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(client->service_resolvers);
  while(!(client->host_name_resolvers == ((struct AvahiHostNameResolver *)NULL)))
    avahi_host_name_resolver_free(client->host_name_resolvers);
  while(!(client->address_resolvers == ((struct AvahiAddressResolver *)NULL)))
    avahi_address_resolver_free(client->address_resolvers);
  while(!(client->record_browsers == ((struct AvahiRecordBrowser *)NULL)))
    avahi_record_browser_free(client->record_browsers);
  if(!(client->bus == ((struct DBusConnection *)NULL)))
    dbus_connection_unref(client->bus);

  avahi_free((void *)client->version_string);
  avahi_free((void *)client->host_name);
  avahi_free((void *)client->host_name_fqdn);
  avahi_free((void *)client->domain_name);
  avahi_free((void *)client);
}

// avahi_client_get_domain_name
// file client.c line 742
const char * avahi_client_get_domain_name(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->domain_name == ((char *)NULL))
      client->domain_name=avahi_client_get_string_reply_and_block(client, "GetDomainName", (const char *)(void *)0);

    return client->domain_name;
  }
}

// avahi_client_get_host_name
// file client.c line 756
const char * avahi_client_get_host_name(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->host_name == ((char *)NULL))
      client->host_name=avahi_client_get_string_reply_and_block(client, "GetHostName", (const char *)(void *)0);

    return client->host_name;
  }
}

// avahi_client_get_host_name_fqdn
// file ../avahi-client/client.h line 91
const char * avahi_client_get_host_name_fqdn(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->host_name_fqdn == ((char *)NULL))
      client->host_name_fqdn=avahi_client_get_string_reply_and_block(client, "GetHostNameFqdn", (const char *)(void *)0);

    return client->host_name_fqdn;
  }
}

// avahi_client_get_local_service_cookie
// file client.c line 846
unsigned int avahi_client_get_local_service_cookie(struct AvahiClient *client)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_error_is_set$2;
  unsigned int return_value_dbus_message_get_args$4;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_error_is_set$5;
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (unsigned int)0;
  }

  else
    if(!(client->local_service_cookie_valid == 0))
      return client->local_service_cookie;

    else
    {
      dbus_error_init(&error);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetLocalServiceCookie");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$2=dbus_error_is_set(&error);
          tmp_if_expr$3 = return_value_dbus_error_is_set$2 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$3)
        {
          return_value_dbus_message_get_args$4=dbus_message_get_args(reply, &error, (signed int)117, &client->local_service_cookie, (signed int)0);
          if(return_value_dbus_message_get_args$4 == 0u)
            tmp_if_expr$6 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$5=dbus_error_is_set(&error);
            tmp_if_expr$6 = return_value_dbus_error_is_set$5 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$6)
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            client->local_service_cookie_valid = 1;
            return client->local_service_cookie;
          }

        }

      }

    fail:
      ;
      if(!(message == ((struct DBusMessage *)NULL)))
        dbus_message_unref(message);

      if(!(reply == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply);

      unsigned int return_value_dbus_error_is_set$7;
      return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
      if(!(return_value_dbus_error_is_set$7 == 0u))
      {
        avahi_client_set_dbus_error(client, &error);
        dbus_error_free(&error);
      }

      return (unsigned int)0;
    }
}

// avahi_client_get_state
// file ../avahi-client/client.h line 94
enum anonymous$5 avahi_client_get_state(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  return client->state;
}

// avahi_client_get_string_reply_and_block
// file client.c line 672
static char * avahi_client_get_string_reply_and_block(struct AvahiClient *client, const char *method, const char *param)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *ret;
  char *n;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion method */
  assert(method != ((const char *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", method);
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_error_is_set$2;
  unsigned int return_value_dbus_message_get_args$4;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_error_is_set$5;
  if(message == ((struct DBusMessage *)NULL))
    avahi_client_set_errno(client, -24);

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      unsigned int return_value_dbus_message_append_args$1;
      return_value_dbus_message_append_args$1=dbus_message_append_args(message, (signed int)115, &param, (signed int)0);
      if(return_value_dbus_message_append_args$1 == 0u)
      {
        avahi_client_set_errno(client, -24);
        goto fail;
      }

    }

    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$2=dbus_error_is_set(&error);
      tmp_if_expr$3 = return_value_dbus_error_is_set$2 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$3)
    {
      return_value_dbus_message_get_args$4=dbus_message_get_args(reply, &error, (signed int)115, &ret, (signed int)0);
      if(return_value_dbus_message_get_args$4 == 0u)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$5=dbus_error_is_set(&error);
        tmp_if_expr$6 = return_value_dbus_error_is_set$5 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$6)
      {
        n=avahi_strdup(ret);
        if(n == ((char *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          dbus_message_unref(message);
          dbus_message_unref(reply);
          return n;
        }
      }

    }

  }

fail:
  ;
  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  unsigned int return_value_dbus_error_is_set$7;
  return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$7 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  return (char *)(void *)0;
}

// avahi_client_get_version_string
// file ../avahi-client/client.h line 79
const char * avahi_client_get_version_string(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->version_string == ((char *)NULL))
      client->version_string=avahi_client_get_string_reply_and_block(client, "GetVersionString", (const char *)(void *)0);

    return client->version_string;
  }
}

// avahi_client_is_connected
// file client.c line 896
signed int avahi_client_is_connected(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_connection_get_is_connected$1;
  if(!(client->bus == ((struct DBusConnection *)NULL)))
  {
    return_value_dbus_connection_get_is_connected$1=dbus_connection_get_is_connected(client->bus);
    tmp_if_expr$2 = return_value_dbus_connection_get_is_connected$1 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$2)
  {
    if((signed int)client->state == AVAHI_CLIENT_S_RUNNING)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)client->state == AVAHI_CLIENT_S_REGISTERING ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)client->state == AVAHI_CLIENT_S_COLLISION ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$5 = (_Bool)0;
  return (signed int)tmp_if_expr$5;
}

// avahi_client_new
// file ../avahi-client/client.h line 62
struct AvahiClient * avahi_client_new(const struct AvahiPoll *poll_api, enum anonymous$11 flags, void (*callback)(struct AvahiClient *, enum anonymous$5, void *), void *userdata, signed int *ret_error)
{
  struct AvahiClient *avahi_client_new$$1$$client = (struct AvahiClient *)(void *)0;
  struct DBusError error;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  avahi_init_i18n();
  dbus_error_init(&error);
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal((unsigned int)1, sizeof(struct AvahiClient) /*152ul*/ );
  avahi_client_new$$1$$client = (struct AvahiClient *)return_value_avahi_new_internal$1;
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_error_is_set$2;
  signed int return_value_avahi_dbus_connection_glue$4;
  unsigned int return_value_dbus_connection_add_filter$5;
  unsigned int return_value_dbus_error_is_set$6;
  unsigned int return_value_dbus_error_is_set$7;
  unsigned int return_value_dbus_error_is_set$8;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  if(avahi_client_new$$1$$client == ((struct AvahiClient *)NULL))
  {
    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = -24;

  }

  else
  {
    avahi_client_new$$1$$client->poll_api = poll_api;
    avahi_client_new$$1$$client->error = 0;
    avahi_client_new$$1$$client->callback = callback;
    avahi_client_new$$1$$client->userdata = userdata;
    avahi_client_new$$1$$client->state = (enum anonymous$5)-1;
    avahi_client_new$$1$$client->flags = flags;
    avahi_client_new$$1$$client->host_name = (char *)(void *)0;
    avahi_client_new$$1$$client->host_name_fqdn = (char *)(void *)0;
    avahi_client_new$$1$$client->domain_name = (char *)(void *)0;
    avahi_client_new$$1$$client->version_string = (char *)(void *)0;
    avahi_client_new$$1$$client->local_service_cookie_valid = 0;
    do
      avahi_client_new$$1$$client->groups = (struct AvahiEntryGroup *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new$$1$$client->domain_browsers = (struct AvahiDomainBrowser *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new$$1$$client->service_browsers = (struct AvahiServiceBrowser *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new$$1$$client->service_type_browsers = (struct AvahiServiceTypeBrowser *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new$$1$$client->service_resolvers = (struct AvahiServiceResolver *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new$$1$$client->host_name_resolvers = (struct AvahiHostNameResolver *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new$$1$$client->address_resolvers = (struct AvahiAddressResolver *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new$$1$$client->record_browsers = (struct AvahiRecordBrowser *)(void *)0;
    while((_Bool)0);
    avahi_client_new$$1$$client->bus=avahi_dbus_bus_get(&error);
    if(avahi_client_new$$1$$client->bus == ((struct DBusConnection *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$2=dbus_error_is_set(&error);
      tmp_if_expr$3 = return_value_dbus_error_is_set$2 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      if(!(ret_error == ((signed int *)NULL)))
        *ret_error = -22;

    }

    else
    {
      return_value_avahi_dbus_connection_glue$4=avahi_dbus_connection_glue(avahi_client_new$$1$$client->bus, poll_api);
      if(!(return_value_avahi_dbus_connection_glue$4 >= 0))
      {
        if(!(ret_error == ((signed int *)NULL)))
          *ret_error = -24;

      }

      else
      {
        return_value_dbus_connection_add_filter$5=dbus_connection_add_filter(avahi_client_new$$1$$client->bus, filter_func, (void *)avahi_client_new$$1$$client, (void (*)(void *))(void *)0);
        if(return_value_dbus_connection_add_filter$5 == 0u)
        {
          if(!(ret_error == ((signed int *)NULL)))
            *ret_error = -24;

        }

        else
        {
          dbus_bus_add_match(avahi_client_new$$1$$client->bus, "type='signal', interface='org.freedesktop.Avahi.Server', sender='org.freedesktop.Avahi', path='/'", &error);
          return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
          if(return_value_dbus_error_is_set$6 == 0u)
          {
            dbus_bus_add_match(avahi_client_new$$1$$client->bus, "type='signal', interface='org.freedesktop.DBus', sender='org.freedesktop.DBus', path='/org/freedesktop/DBus'", &error);
            return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
            if(return_value_dbus_error_is_set$7 == 0u)
            {
              dbus_bus_add_match(avahi_client_new$$1$$client->bus, "type='signal', interface='org.freedesktop.DBus.Local'", &error);
              return_value_dbus_error_is_set$8=dbus_error_is_set(&error);
              if(return_value_dbus_error_is_set$8 == 0u)
              {
                message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.DBus.Peer", "Ping");
                if(!(message == ((struct DBusMessage *)NULL)))
                {
                  reply=dbus_connection_send_with_reply_and_block(avahi_client_new$$1$$client->bus, message, -1, &error);
                  if(reply == ((struct DBusMessage *)NULL))
                    tmp_if_expr$11 = (_Bool)1;

                  else
                  {
                    return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
                    tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$11)
                  {
                    dbus_error_free(&error);
                    if((AVAHI_CLIENT_NO_FAIL & (signed int)flags) == 0)
                    {
                      if(!(ret_error == ((signed int *)NULL)))
                        *ret_error = -26;

                      goto fail;
                    }

                    client_set_state(avahi_client_new$$1$$client, (enum anonymous$5)AVAHI_CLIENT_CONNECTING);
                  }

                  else
                  {
                    signed int return_value_init_server$9;
                    return_value_init_server$9=init_server(avahi_client_new$$1$$client, ret_error);
                    if(!(return_value_init_server$9 >= 0))
                      goto fail;

                  }
                  dbus_message_unref(message);
                  if(!(reply == ((struct DBusMessage *)NULL)))
                    dbus_message_unref(reply);

                  return avahi_client_new$$1$$client;
                }

              }

            }

          }

        }
      }
    }
  }

fail:
  ;
  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  if(!(avahi_client_new$$1$$client == ((struct AvahiClient *)NULL)))
    avahi_client_free(avahi_client_new$$1$$client);

  unsigned int return_value_dbus_error_is_set$13;
  return_value_dbus_error_is_set$13=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$13 == 0u))
  {
    if(!(ret_error == ((signed int *)NULL)))
    {
      signed int return_value_strcmp$12;
      return_value_strcmp$12=strcmp(error.name, "org.freedesktop.DBus.Error.FileNotFound");
      if(return_value_strcmp$12 == 0)
        *ret_error = -26;

      else
        *ret_error=avahi_error_dbus_to_number(error.name);
    }

    dbus_error_free(&error);
  }

  return (struct AvahiClient *)(void *)0;
}

// avahi_client_set_dbus_error
// file client.c line 51
signed int avahi_client_set_dbus_error(struct AvahiClient *client, struct DBusError *error)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion error */
  assert(error != ((struct DBusError *)NULL));
  signed int return_value_avahi_error_dbus_to_number$1;
  return_value_avahi_error_dbus_to_number$1=avahi_error_dbus_to_number(error->name);
  signed int return_value_avahi_client_set_errno$2;
  return_value_avahi_client_set_errno$2=avahi_client_set_errno(client, return_value_avahi_error_dbus_to_number$1);
  return return_value_avahi_client_set_errno$2;
}

// avahi_client_set_errno
// file client.c line 45
signed int avahi_client_set_errno(struct AvahiClient *client, signed int error)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  client->error = error;
  return client->error;
}

// avahi_client_set_host_name
// file client.c line 905
signed int avahi_client_set_host_name(struct AvahiClient *client, const char *name)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$2;
  return_value_avahi_client_is_connected$2=avahi_client_is_connected(client);
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$2 == 0)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "SetHostName");
    if(message == ((struct DBusMessage *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)115, &name, (signed int)0);
      if(return_value_dbus_message_append_args$3 == 0u)
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
          tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$5)
        {
          return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$6 == 0u)
            tmp_if_expr$8 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
            tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$8)
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            avahi_free((void *)client->host_name);
            client->host_name = (char *)(void *)0;
            avahi_free((void *)client->host_name_fqdn);
            client->host_name_fqdn = (char *)(void *)0;
            return 0;
          }

        }

      }
    }

  fail:
    ;
    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    unsigned int return_value_dbus_error_is_set$9;
    return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$9 == 0u))
    {
      avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    return client->error;
  }
}

// avahi_client_simple_method_call
// file client.c line 797
signed int avahi_client_simple_method_call(struct AvahiClient *client, const char *path, const char *interface, const char *method)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  dbus_error_init(&error);
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion path */
  assert(path != ((const char *)NULL));
  /* assertion interface */
  assert(interface != ((const char *)NULL));
  /* assertion method */
  assert(method != ((const char *)NULL));
  message=dbus_message_new_method_call("org.freedesktop.Avahi", path, interface, method);
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_error_is_set$1;
  unsigned int return_value_dbus_message_get_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      tmp_if_expr$2 = return_value_dbus_error_is_set$1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      r=avahi_client_set_errno(client, -22);

    else
    {
      return_value_dbus_message_get_args$3=dbus_message_get_args(reply, &error, (signed int)0);
      if(return_value_dbus_message_get_args$3 == 0u)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$6;
  return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$6 == 0u))
  {
    r=avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// avahi_dbus_bus_get
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get(struct DBusError *error)
{
  struct DBusConnection *c;
  c=dbus_bus_get_private((enum anonymous$29)DBUS_BUS_SYSTEM, error);
  if(c == ((struct DBusConnection *)NULL))
    return (struct DBusConnection *)(void *)0;

  else
  {
    dbus_connection_set_exit_on_disconnect(c, (unsigned int)0);
    return c;
  }
}

// avahi_dbus_connection_glue
// file ../avahi-common/dbus-watch-glue.h line 29
signed int avahi_dbus_connection_glue(struct DBusConnection *c, const struct AvahiPoll *poll_api)
{
  struct anonymous$13 *d = (struct anonymous$13 *)(void *)0;
  /* assertion c */
  assert(c != ((struct DBusConnection *)NULL));
  /* assertion poll_api */
  assert(poll_api != ((const struct AvahiPoll *)NULL));
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link4((unsigned int)1, sizeof(struct anonymous$13) /*32ul*/ );
  d = (struct anonymous$13 *)return_value_avahi_new_internal$1;
  struct anonymous$13 *return_value_connection_data_ref$2;
  unsigned int return_value_dbus_connection_set_watch_functions$3;
  struct anonymous$13 *return_value_connection_data_ref$4;
  unsigned int return_value_dbus_connection_set_timeout_functions$5;
  struct anonymous$13 *return_value_connection_data_ref$6;
  enum anonymous$12 return_value_dbus_connection_get_dispatch_status$7;
  if(!(d == ((struct anonymous$13 *)NULL)))
  {
    d->poll_api = poll_api;
    d->connection = c;
    d->ref = 1;
    d->dispatch_timeout=poll_api->timeout_new(poll_api, (struct timeval *)(void *)0, dispatch_timeout_callback, (void *)d);
    return_value_connection_data_ref$2=connection_data_ref(d);
    return_value_dbus_connection_set_watch_functions$3=dbus_connection_set_watch_functions(c, add_watch, remove_watch, watch_toggled, (void *)return_value_connection_data_ref$2, (void (*)(void *))connection_data_unref);
    return_value_connection_data_ref$4=connection_data_ref(d);
    return_value_dbus_connection_set_timeout_functions$5=dbus_connection_set_timeout_functions(c, add_timeout, remove_timeout, timeout_toggled, (void *)return_value_connection_data_ref$4, (void (*)(void *))connection_data_unref);
    return_value_connection_data_ref$6=connection_data_ref(d);
    dbus_connection_set_dispatch_status_function(c, dispatch_status, (void *)return_value_connection_data_ref$6, (void (*)(void *))connection_data_unref);
    return_value_dbus_connection_get_dispatch_status$7=dbus_connection_get_dispatch_status(c);
    if((signed int)return_value_dbus_connection_get_dispatch_status$7 == DBUS_DISPATCH_DATA_REMAINS)
      request_dispatch(d, 1);

    connection_data_unref(d);
    return 0;
  }

  else
  {

  fail:
    ;
    if(!(d == ((struct anonymous$13 *)NULL)))
    {
      d->poll_api->timeout_free(d->dispatch_timeout);
      avahi_free((void *)d);
    }

    return -1;
  }
}

// avahi_domain_browser_event
// file internal.h line 159
enum anonymous$28 avahi_domain_browser_event(struct AvahiClient *client, enum anonymous$3 event, struct DBusMessage *message)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *domain = (char *)(void *)0;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  struct AvahiStringList *l;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  signed int return_value_avahi_error_dbus_to_number$8;
  signed int return_value_avahi_domain_equal$9;
  if(!(path == ((const char *)NULL)))
  {
    db = client->domain_browsers;
    for( ; !(db == ((struct AvahiDomainBrowser *)NULL)); db = db->domain_browsers_next)
    {
      return_value_strcmp$1=strcmp(db->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(db == ((struct AvahiDomainBrowser *)NULL))
      goto fail;

    interface = db->interface;
    protocol = db->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args$5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$5 == 0u)
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
          tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(db->client, return_value_avahi_error_dbus_to_number$8);
      }
    }
    if(!(domain == ((char *)NULL)))
    {
      l = db->static_browse_domains;
      for( ; !(l == ((struct AvahiStringList *)NULL)); l = l->next)
      {
        return_value_avahi_domain_equal$9=avahi_domain_equal((char *)l->text, domain);
        if(!(return_value_avahi_domain_equal$9 == 0))
          return (enum anonymous$28)DBUS_HANDLER_RESULT_HANDLED;

      }
    }

    db->callback(db, (signed int)interface, (signed int)protocol, event, domain, (enum anonymous$4)flags, db->userdata);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_domain_browser_free
// file lookup.h line 71
signed int avahi_domain_browser_free(struct AvahiDomainBrowser *b)
{
  struct AvahiClient *avahi_domain_browser_free$$1$$client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  /* assertion b->ref >= 1 */
  assert(b->ref >= 1);
  b->ref = b->ref - 1;
  signed int return_value_avahi_client_is_connected$1;
  if(b->ref >= 1)
    return 0;

  else
  {
    avahi_domain_browser_free$$1$$client = b->client;
    if(!(b->path == ((char *)NULL)))
    {
      return_value_avahi_client_is_connected$1=avahi_client_is_connected(b->client);
      if(!(return_value_avahi_client_is_connected$1 == 0))
        r=avahi_client_simple_method_call(avahi_domain_browser_free$$1$$client, b->path, "org.freedesktop.Avahi.DomainBrowser", "Free");

    }

    do
    {
      struct AvahiDomainBrowser **_head = &avahi_domain_browser_free$$1$$client->domain_browsers;
      struct AvahiDomainBrowser *_item = b;
      /* assertion _item */
      assert(_item != ((struct AvahiDomainBrowser *)NULL));
      if(!(_item->domain_browsers_next == ((struct AvahiDomainBrowser *)NULL)))
        _item->domain_browsers_next->domain_browsers_prev = _item->domain_browsers_prev;

      if(!(_item->domain_browsers_prev == ((struct AvahiDomainBrowser *)NULL)))
        _item->domain_browsers_prev->domain_browsers_next = _item->domain_browsers_next;

      else
      {
        /* assertion *_head == _item */
        assert(*_head == _item);
        *_head = _item->domain_browsers_next;
      }
      _item->domain_browsers_prev = (struct AvahiDomainBrowser *)(void *)0;
      _item->domain_browsers_next = _item->domain_browsers_prev;
    }
    while((_Bool)0);
    if(!(b->defer_timeout == ((struct AvahiTimeout *)NULL)))
      b->client->poll_api->timeout_free(b->defer_timeout);

    avahi_string_list_free(b->static_browse_domains);
    avahi_free((void *)b->path);
    avahi_free((void *)b);
    return r;
  }
}

// avahi_domain_browser_get_client
// file browser.c line 234
struct AvahiClient * avahi_domain_browser_get_client(struct AvahiDomainBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  return b->client;
}

// avahi_domain_browser_new
// file browser.c line 104
struct AvahiDomainBrowser * avahi_domain_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous$1 btype, enum anonymous$2 flags, void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$3, const char *, enum anonymous$4, void *), void *userdata)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_interface;
  signed int i_protocol;
  signed int bt;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$3, const char *, enum anonymous$4, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal$2=avahi_new_internal$link2((unsigned int)1, sizeof(struct AvahiDomainBrowser) /*80ul*/ );
    db = (struct AvahiDomainBrowser *)return_value_avahi_new_internal$2;
    if(db == ((struct AvahiDomainBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      db->ref = 1;
      db->client = client;
      db->callback = callback;
      db->userdata = userdata;
      db->path = (char *)(void *)0;
      db->interface = interface;
      db->protocol = protocol;
      db->static_browse_domains = (struct AvahiStringList *)(void *)0;
      db->defer_timeout = (struct AvahiTimeout *)(void *)0;
      do
      {
        struct AvahiDomainBrowser **_head = &client->domain_browsers;
        struct AvahiDomainBrowser *_item = db;
        /* assertion _item */
        assert(_item != ((struct AvahiDomainBrowser *)NULL));
        _item->domain_browsers_next = *_head;
        if(!(_item->domain_browsers_next == ((struct AvahiDomainBrowser *)NULL)))
          _item->domain_browsers_next->domain_browsers_prev = _item;

        _item->domain_browsers_prev = (struct AvahiDomainBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if((AVAHI_CLIENT_IGNORE_USER_CONFIG & (signed int)client->flags) == 0)
      {
        parse_environment(db);
        parse_domain_file(db);
      }

      db->static_browse_domains=avahi_string_list_reverse(db->static_browse_domains);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "DomainBrowserNew");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        i_interface = (signed int)interface;
        i_protocol = (signed int)protocol;
        u_flags = (unsigned int)flags;
        bt = (signed int)btype;
        return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &domain, (signed int)105, &bt, (signed int)117, &u_flags, (signed int)0);
        if(return_value_dbus_message_append_args$3 == 0u)
          avahi_client_set_errno(client, -24);

        else
        {
          reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
          if(reply == ((struct DBusMessage *)NULL))
            tmp_if_expr$5 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
            tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$5)
            avahi_client_set_errno(client, -22);

          else
          {
            return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
            if(return_value_dbus_message_get_args$6 == 0u)
              tmp_if_expr$8 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
              tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(path == ((char *)NULL) || tmp_if_expr$8)
              avahi_client_set_errno(client, -22);

            else
            {
              db->path=avahi_strdup(path);
              if(db->path == ((char *)NULL))
                avahi_client_set_errno(client, -24);

              else
              {
                if(!(db->static_browse_domains == ((struct AvahiStringList *)NULL)))
                {
                  if((signed int)btype == AVAHI_DOMAIN_BROWSER_BROWSE)
                  {
                    struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
                    db->defer_timeout=client->poll_api->timeout_new(client->poll_api, &tv, defer_timeout_callback, (void *)db);
                    if(db->defer_timeout == ((struct AvahiTimeout *)NULL))
                      avahi_client_set_errno(client, -24);

                  }

                }

                dbus_message_unref(message);
                dbus_message_unref(reply);
                return db;
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(db == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(db);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiDomainBrowser *)(void *)0;
}

// avahi_domain_equal
// file ../avahi-common/domain.h line 62
signed int avahi_domain_equal(const char *a, const char *b)
{
  /* assertion a */
  assert(a != ((const char *)NULL));
  /* assertion b */
  assert(b != ((const char *)NULL));
  if(a == b)
    return 1;

  else
  {
    do
    {
      char ca[64l];
      char cb[64l];
      char *r;
      r=avahi_unescape_label(&a, ca, sizeof(char [64l]) /*64ul*/ );
      /* assertion r */
      assert(r != ((char *)NULL));
      r=avahi_unescape_label(&b, cb, sizeof(char [64l]) /*64ul*/ );
      /* assertion r */
      assert(r != ((char *)NULL));
      signed int return_value_strcasecmp$1;
      return_value_strcasecmp$1=strcasecmp(ca, cb);
      if(!(return_value_strcasecmp$1 == 0))
        return 0;

      if(*a == 0)
      {
        if(*b == 0)
          return 1;

      }

    }
    while((_Bool)1);
    return 1;
  }
}

// avahi_domain_hash
// file domain.c line 424
unsigned int avahi_domain_hash(const char *s)
{
  unsigned int hash = (unsigned int)0;
  signed int return_value_tolower$1;
  while(!(*s == 0))
  {
    char c[64l];
    char *p;
    char *r;
    r=avahi_unescape_label(&s, c, sizeof(char [64l]) /*64ul*/ );
    /* assertion r */
    assert(r != ((char *)NULL));
    p = c;
    for( ; !(*p == 0); p = p + 1l)
    {
      return_value_tolower$1=tolower((signed int)*p);
      hash = (unsigned int)31 * hash + (unsigned int)return_value_tolower$1;
    }
  }
  return hash;
}

// avahi_elapse_time
// file ../avahi-common/timeval.h line 50
struct timeval * avahi_elapse_time(struct timeval *tv, unsigned int msec, unsigned int jitter)
{
  /* assertion tv */
  assert(tv != ((struct timeval *)NULL));
  gettimeofday(tv, (struct timezone *)(void *)0);
  if(!(msec == 0u))
    avahi_timeval_add(tv, (signed long int)msec * (signed long int)1000);

  if(!(jitter == 0u))
  {
    signed long int now;
    signed int r;
    now=time((signed long int *)(void *)0);
    static union anonymous$25 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
    pthread_mutex_lock(&mutex);
    static signed int last_rand;
    static signed long int timestamp = (signed long int)0;
    if(now >= 10l + timestamp)
    {
      timestamp = now;
      last_rand=rand();
    }

    r = last_rand;
    pthread_mutex_unlock(&mutex);
    avahi_timeval_add(tv, (signed long int)(((double)jitter * 1000.0 * (double)r) / ((double)2147483647 + 1.0)));
  }

  return tv;
}

// avahi_entry_group_add_address
// file ../avahi-client/publish.h line 146
signed int avahi_entry_group_add_address(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const struct AvahiAddress *a)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_add_address$$1$$client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  char s_address[40l];
  char *p_address = s_address;
  /* assertion name */
  assert(name != ((const char *)NULL));
  avahi_entry_group_add_address$$1$$client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  char *return_value_avahi_address_snprint$4;
  unsigned int return_value_dbus_message_append_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  unsigned int return_value_dbus_message_get_args$8;
  _Bool tmp_if_expr$10;
  unsigned int return_value_dbus_error_is_set$9;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddAddress");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_add_address$$1$$client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_avahi_address_snprint$4=avahi_address_snprint(s_address, sizeof(char [40l]) /*40ul*/ , a);
      if(return_value_avahi_address_snprint$4 == ((char *)NULL))
        r=avahi_client_set_errno(avahi_entry_group_add_address$$1$$client, -14);

      else
      {
        return_value_dbus_message_append_args$5=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &p_address, (signed int)0);
        if(return_value_dbus_message_append_args$5 == 0u)
          r=avahi_client_set_errno(group->client, -24);

        else
        {
          reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_add_address$$1$$client->bus, message, -1, &error);
          if(reply == ((struct DBusMessage *)NULL))
            tmp_if_expr$7 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
            tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$7)
            r=avahi_client_set_errno(avahi_entry_group_add_address$$1$$client, -22);

          else
          {
            return_value_dbus_message_get_args$8=dbus_message_get_args(reply, &error, (signed int)0);
            if(return_value_dbus_message_get_args$8 == 0u)
              tmp_if_expr$10 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
              tmp_if_expr$10 = return_value_dbus_error_is_set$9 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$10)
              r=avahi_client_set_errno(avahi_entry_group_add_address$$1$$client, -22);

            else
            {
              dbus_message_unref(message);
              dbus_message_unref(reply);
              return 0;
            }
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$11;
    return_value_dbus_error_is_set$11=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$11 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_add_address$$1$$client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_record
// file entrygroup.c line 808
signed int avahi_entry_group_add_record(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, unsigned short int clazz, unsigned short int type, unsigned int ttl, const void *rdata, unsigned long int size)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_add_record$$1$$client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion name */
  assert(name != ((const char *)NULL));
  avahi_entry_group_add_record$$1$$client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  signed int return_value_append_rdata$5;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  unsigned int return_value_dbus_message_get_args$9;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddRecord");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_add_record$$1$$client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)117, &ttl, (signed int)0);
      if(return_value_dbus_message_append_args$4 == 0u)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_append_rdata$5=append_rdata(message, rdata, size);
        tmp_if_expr$6 = return_value_append_rdata$5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_add_record$$1$$client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          r=avahi_client_set_errno(avahi_entry_group_add_record$$1$$client, -22);

        else
        {
          return_value_dbus_message_get_args$9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$9 == 0u)
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
            tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            r=avahi_client_set_errno(avahi_entry_group_add_record$$1$$client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$12;
    return_value_dbus_error_is_set$12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$12 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_add_record$$1$$client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_service
// file entrygroup.c line 496
signed int avahi_entry_group_add_service(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, ...)
{
  void **va;
  signed int r;
  struct AvahiStringList *txt;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  va = (void **)&port;
  txt=avahi_string_list_new_va(va);
  r=avahi_entry_group_add_service_strlst(group, interface, protocol, flags, name, type, domain, host, port, txt);
  avahi_string_list_free(txt);
  va = ((void **)NULL);
  return r;
}

// avahi_entry_group_add_service_strlst
// file ../avahi-client/publish.h line 99
signed int avahi_entry_group_add_service_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, struct AvahiStringList *txt)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_add_service_strlst$$1$$client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  avahi_entry_group_add_service_strlst$$1$$client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  signed int return_value_append_string_list$5;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  unsigned int return_value_dbus_message_get_args$9;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    if(host == ((const char *)NULL))
      host = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddService");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_add_service_strlst$$1$$client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &host, (signed int)113, &port, (signed int)0);
      if(return_value_dbus_message_append_args$4 == 0u)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_append_string_list$5=append_string_list(message, txt);
        tmp_if_expr$6 = return_value_append_string_list$5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_add_service_strlst$$1$$client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          r=avahi_client_set_errno(avahi_entry_group_add_service_strlst$$1$$client, -22);

        else
        {
          return_value_dbus_message_get_args$9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$9 == 0u)
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
            tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            r=avahi_client_set_errno(avahi_entry_group_add_service_strlst$$1$$client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$12;
    return_value_dbus_error_is_set$12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$12 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_add_service_strlst$$1$$client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_service_subtype
// file ../avahi-client/publish.h line 112
signed int avahi_entry_group_add_service_subtype(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, const char *subtype)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_add_service_subtype$$1$$client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  /* assertion subtype */
  assert(subtype != ((const char *)NULL));
  avahi_entry_group_add_service_subtype$$1$$client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_error_is_set$5;
  unsigned int return_value_dbus_message_get_args$7;
  _Bool tmp_if_expr$9;
  unsigned int return_value_dbus_error_is_set$8;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddServiceSubtype");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_add_service_subtype$$1$$client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &subtype, (signed int)0);
      if(return_value_dbus_message_append_args$4 == 0u)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_add_service_subtype$$1$$client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$5=dbus_error_is_set(&error);
          tmp_if_expr$6 = return_value_dbus_error_is_set$5 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
          r=avahi_client_set_errno(avahi_entry_group_add_service_subtype$$1$$client, -22);

        else
        {
          return_value_dbus_message_get_args$7=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$7 == 0u)
            tmp_if_expr$9 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$8=dbus_error_is_set(&error);
            tmp_if_expr$9 = return_value_dbus_error_is_set$8 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$9)
            r=avahi_client_set_errno(avahi_entry_group_add_service_subtype$$1$$client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$10;
    return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$10 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_add_service_subtype$$1$$client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_commit
// file ../avahi-client/publish.h line 67
signed int avahi_entry_group_commit(struct AvahiEntryGroup *group)
{
  signed int ret;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    ret=entry_group_simple_method_call(group, "Commit");
    if(!(ret >= 0))
      return ret;

    else
    {
      group->state_valid = 0;
      return ret;
    }
  }
}

// avahi_entry_group_free
// file ../avahi-client/publish.h line 60
signed int avahi_entry_group_free(struct AvahiEntryGroup *group)
{
  struct AvahiClient *avahi_entry_group_free$$1$$client = group->client;
  signed int r = 0;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  if(!(group->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(avahi_entry_group_free$$1$$client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      r=entry_group_simple_method_call(group, "Free");

  }

  do
  {
    struct AvahiEntryGroup **_head = &avahi_entry_group_free$$1$$client->groups;
    struct AvahiEntryGroup *_item = group;
    /* assertion _item */
    assert(_item != ((struct AvahiEntryGroup *)NULL));
    if(!(_item->groups_next == ((struct AvahiEntryGroup *)NULL)))
      _item->groups_next->groups_prev = _item->groups_prev;

    if(!(_item->groups_prev == ((struct AvahiEntryGroup *)NULL)))
      _item->groups_prev->groups_next = _item->groups_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->groups_next;
    }
    _item->groups_prev = (struct AvahiEntryGroup *)(void *)0;
    _item->groups_next = _item->groups_prev;
  }
  while((_Bool)0);
  avahi_free((void *)group->path);
  avahi_free((void *)group);
  return r;
}

// avahi_entry_group_get_client
// file entrygroup.c line 290
struct AvahiClient * avahi_entry_group_get_client(struct AvahiEntryGroup *group)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  return group->client;
}

// avahi_entry_group_get_state
// file entrygroup.c line 281
signed int avahi_entry_group_get_state(struct AvahiEntryGroup *group)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  if(!(group->state_valid == 0))
    return (signed int)group->state;

  else
  {
    signed int return_value_retrieve_state$1;
    return_value_retrieve_state$1=retrieve_state(group);
    return return_value_retrieve_state$1;
  }
}

// avahi_entry_group_is_empty
// file ../avahi-client/publish.h line 76
signed int avahi_entry_group_is_empty(struct AvahiEntryGroup *group)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  signed int b;
  struct AvahiClient *avahi_entry_group_is_empty$$1$$client;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  avahi_entry_group_is_empty$$1$$client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "IsEmpty");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_is_empty$$1$$client, -24);

    else
    {
      reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_is_empty$$1$$client->bus, message, -1, &error);
      if(reply == ((struct DBusMessage *)NULL))
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        r=avahi_client_set_errno(avahi_entry_group_is_empty$$1$$client, -22);

      else
      {
        return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)98, &b, (signed int)0);
        if(return_value_dbus_message_get_args$6 == 0u)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          r=avahi_client_set_errno(avahi_entry_group_is_empty$$1$$client, -22);

        else
        {
          dbus_message_unref(message);
          dbus_message_unref(reply);
          return (signed int)!(!(b != 0));
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$9;
    return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$9 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_is_empty$$1$$client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_new
// file ../avahi-client/publish.h line 54
struct AvahiEntryGroup * avahi_entry_group_new(struct AvahiClient *client, void (*callback)(struct AvahiEntryGroup *, enum anonymous, void *), void *userdata)
{
  struct AvahiEntryGroup *group = (struct AvahiEntryGroup *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int state;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  unsigned int return_value_dbus_message_get_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal$2=avahi_new_internal$link1((unsigned int)1, sizeof(struct AvahiEntryGroup) /*56ul*/ );
    group = (struct AvahiEntryGroup *)return_value_avahi_new_internal$2;
    if(group == ((struct AvahiEntryGroup *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      group->client = client;
      group->callback = callback;
      group->userdata = userdata;
      group->state_valid = 0;
      group->path = (char *)(void *)0;
      do
      {
        struct AvahiEntryGroup **_head = &client->groups;
        struct AvahiEntryGroup *_item = group;
        /* assertion _item */
        assert(_item != ((struct AvahiEntryGroup *)NULL));
        _item->groups_next = *_head;
        if(!(_item->groups_next == ((struct AvahiEntryGroup *)NULL)))
          _item->groups_next->groups_prev = _item;

        _item->groups_prev = (struct AvahiEntryGroup *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "EntryGroupNew");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
          avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args$5=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
          if(return_value_dbus_message_get_args$5 == 0u)
            tmp_if_expr$7 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
            tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$7)
            avahi_client_set_errno(client, -22);

          else
          {
            group->path=avahi_strdup(path);
            if(group->path == ((char *)NULL))
              avahi_client_set_errno(client, -24);

            else
            {
              state=retrieve_state(group);
              if(!(state >= 0))
                avahi_client_set_errno(client, state);

              else
              {
                avahi_entry_group_set_state(group, (enum anonymous)state);
                dbus_message_unref(message);
                dbus_message_unref(reply);
                return group;
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$8;
  return_value_dbus_error_is_set$8=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$8 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(group == ((struct AvahiEntryGroup *)NULL)))
    avahi_entry_group_free(group);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiEntryGroup *)(void *)0;
}

// avahi_entry_group_reset
// file entrygroup.c line 267
signed int avahi_entry_group_reset(struct AvahiEntryGroup *group)
{
  signed int ret;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    ret=entry_group_simple_method_call(group, "Reset");
    if(!(ret >= 0))
      return ret;

    else
    {
      group->state_valid = 0;
      return ret;
    }
  }
}

// avahi_entry_group_set_state
// file internal.h line 157
void avahi_entry_group_set_state(struct AvahiEntryGroup *group, enum anonymous state)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  if(!(group->state_valid == 0))
  {
    if(group->state == state)
      goto __CPROVER_DUMP_L2;

  }

  group->state = state;
  group->state_valid = 1;
  if(!(group->callback == ((void (*)(struct AvahiEntryGroup *, enum anonymous, void *))NULL)))
    group->callback(group, state, group->userdata);


__CPROVER_DUMP_L2:
  ;
}

// avahi_entry_group_update_service_txt
// file entrygroup.c line 611
signed int avahi_entry_group_update_service_txt(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, ...)
{
  void **va;
  signed int r;
  struct AvahiStringList *txt;
  va = (void **)&domain;
  txt=avahi_string_list_new_va(va);
  r=avahi_entry_group_update_service_txt_strlst(group, interface, protocol, flags, name, type, domain, txt);
  avahi_string_list_free(txt);
  va = ((void **)NULL);
  return r;
}

// avahi_entry_group_update_service_txt_strlst
// file entrygroup.c line 633
signed int avahi_entry_group_update_service_txt_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$0 flags, const char *name, const char *type, const char *domain, struct AvahiStringList *txt)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_update_service_txt_strlst$$1$$client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  avahi_entry_group_update_service_txt_strlst$$1$$client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  signed int return_value_append_string_list$5;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  unsigned int return_value_dbus_message_get_args$9;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "UpdateServiceTxt");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_update_service_txt_strlst$$1$$client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)0);
      if(return_value_dbus_message_append_args$4 == 0u)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_append_string_list$5=append_string_list(message, txt);
        tmp_if_expr$6 = return_value_append_string_list$5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_update_service_txt_strlst$$1$$client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          r=avahi_client_set_errno(avahi_entry_group_update_service_txt_strlst$$1$$client, -22);

        else
        {
          return_value_dbus_message_get_args$9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$9 == 0u)
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
            tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            r=avahi_client_set_errno(avahi_entry_group_update_service_txt_strlst$$1$$client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$12;
    return_value_dbus_error_is_set$12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$12 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_update_service_txt_strlst$$1$$client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_error_dbus_to_number
// file ../avahi-common/dbus.h line 112
signed int avahi_error_dbus_to_number(const char *s)
{
  signed int e;
  struct error_map *m;
  /* assertion s */
  assert(s != ((const char *)NULL));
  e = -1;
  signed int return_value_strcmp$1;
  for( ; e >= -53; e = e - 1)
  {
    return_value_strcmp$1=strcmp(s, table[(signed long int)-e]);
    if(return_value_strcmp$1 == 0)
      return e;

  }
  m = error_map;
  signed int return_value_strcmp$2;
  for( ; !(m->dbus_error == ((const char *)NULL)); m = m + 1l)
  {
    return_value_strcmp$2=strcmp(m->dbus_error, s);
    if(return_value_strcmp$2 == 0)
      return m->avahi_error;

  }
  return -22;
}

// avahi_error_number_to_dbus
// file ../avahi-common/dbus.c line 133
const char * avahi_error_number_to_dbus(signed int error)
{
  /* assertion error > AVAHI_ERR_MAX */
  assert(error > -54);
  /* assertion error < 1 */
  assert(error < 1);
  return table[(signed long int)-error];
}

// avahi_escape_label
// file domain.c line 116
char * avahi_escape_label(const char *src, unsigned long int src_length, char **ret_name, unsigned long int *ret_size)
{
  char *r;
  /* assertion src */
  assert(src != ((const char *)NULL));
  /* assertion ret_name */
  assert(ret_name != ((char **)NULL));
  /* assertion *ret_name */
  assert(*ret_name != ((char *)NULL));
  /* assertion ret_size */
  assert(ret_size != ((unsigned long int *)NULL));
  /* assertion *ret_size > 0 */
  assert(*ret_size > (unsigned long int)0);
  r = *ret_name;
  _Bool tmp_if_expr$15;
  char *tmp_post$1;
  char *tmp_post$2;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$13;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  for( ; src_length >= 1ul; src = src + 1l)
  {
    if((signed int)*src == 46)
      tmp_if_expr$15 = (_Bool)1;

    else
      tmp_if_expr$15 = (signed int)*src == 92 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$15)
    {
      if(!(*ret_size >= 3ul))
        return (char *)(void *)0;

      tmp_post$1 = *ret_name;
      *ret_name = *ret_name + 1l;
      *tmp_post$1 = (char)92;
      tmp_post$2 = *ret_name;
      *ret_name = *ret_name + 1l;
      *tmp_post$2 = *src;
      *ret_size = *ret_size - (unsigned long int)2;
    }

    else
    {
      if((signed int)*src == 95)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)*src == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        if((signed int)*src >= 48)
          tmp_if_expr$9 = (signed int)*src <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$10)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        if((signed int)*src >= 97)
          tmp_if_expr$11 = (signed int)*src <= 122 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
        tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
        tmp_if_expr$14 = (_Bool)1;

      else
      {
        if((signed int)*src >= 65)
          tmp_if_expr$13 = (signed int)*src <= 90 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$13 = (_Bool)0;
        tmp_if_expr$14 = tmp_if_expr$13 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$14)
      {
        if(!(*ret_size >= 2ul))
          return (char *)(void *)0;

        tmp_post$3 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$3 = *src;
        *ret_size = *ret_size - 1ul;
      }

      else
      {
        if(!(*ret_size >= 5ul))
          return (char *)(void *)0;

        tmp_post$4 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$4 = (char)92;
        tmp_post$5 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$5 = (char)(48 + (signed int)(char)((signed int)(unsigned char)*src / 100));
        tmp_post$6 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$6 = (char)(48 + (signed int)(char)(((signed int)(unsigned char)*src / 10) % 10));
        tmp_post$7 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$7 = (char)(48 + (signed int)(char)((signed int)(unsigned char)*src % 10));
        *ret_size = *ret_size - (unsigned long int)4;
      }
    }
    src_length = src_length - 1ul;
  }
  *(*ret_name) = (char)0;
  return r;
}

// avahi_free
// file ../avahi-common/malloc.h line 42
void avahi_free(void *p)
{
  if(!(p == NULL))
  {
    if(allocator == ((const struct AvahiAllocator *)NULL))
      free(p);

    else
    {
      /* assertion allocator->free */
      assert(allocator->free != ((void (*)(void *))NULL));
      allocator->free(p);
    }
  }

}

// avahi_get_type_from_subtype
// file domain.c line 306
const char * avahi_get_type_from_subtype(const char *t)
{
  char label[64l];
  const char *ret;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 1014ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$10;
  signed int return_value_strcasecmp$12;
  if(tmp_if_expr$2)
    return (const char *)(void *)0;

  else
  {
    char *return_value_avahi_unescape_label$3;
    return_value_avahi_unescape_label$3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$3 == ((char *)NULL))
      return (const char *)(void *)0;

    else
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(label);
      if(!(return_value_strlen$4 >= 3ul))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        return (const char *)(void *)0;

      else
        if(*t == 0)
          return (const char *)(void *)0;

        else
        {
          char *return_value_avahi_unescape_label$6;
          return_value_avahi_unescape_label$6=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label$6 == ((char *)NULL))
            return (const char *)(void *)0;

          else
          {
            signed int return_value_strcasecmp$7;
            return_value_strcasecmp$7=strcasecmp(label, "_sub");
            if(!(return_value_strcasecmp$7 == 0))
              return (const char *)(void *)0;

            else
              if(*t == 0)
                return (const char *)(void *)0;

              else
              {
                ret = t;
                char *return_value_avahi_unescape_label$8;
                return_value_avahi_unescape_label$8=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
                if(return_value_avahi_unescape_label$8 == ((char *)NULL))
                  return (const char *)(void *)0;

                else
                {
                  unsigned long int return_value_strlen$9;
                  return_value_strlen$9=strlen(label);
                  if(!(return_value_strlen$9 >= 3ul))
                    tmp_if_expr$10 = (_Bool)1;

                  else
                    tmp_if_expr$10 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$10)
                    return (const char *)(void *)0;

                  else
                    if(*t == 0)
                      return (const char *)(void *)0;

                    else
                    {
                      char *return_value_avahi_unescape_label$11;
                      return_value_avahi_unescape_label$11=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
                      if(return_value_avahi_unescape_label$11 == ((char *)NULL))
                        return (const char *)(void *)0;

                      else
                      {
                        signed int return_value_strcasecmp$13;
                        return_value_strcasecmp$13=strcasecmp(label, "_tcp");
                        if(!(return_value_strcasecmp$13 == 0))
                        {
                          return_value_strcasecmp$12=strcasecmp(label, "_udp");
                          if(return_value_strcasecmp$12 == 0)
                            goto __CPROVER_DUMP_L18;

                          return (const char *)(void *)0;
                        }

                        else
                        {

                        __CPROVER_DUMP_L18:
                          ;
                          if(!(*t == 0))
                            return (const char *)(void *)0;

                          else
                            return ret;
                        }
                      }
                    }
                }
              }
          }
        }
    }
  }
}

// avahi_host_name_resolver_event
// file internal.h line 165
enum anonymous$28 avahi_host_name_resolver_event(struct AvahiClient *client, enum anonymous$9 event, struct DBusMessage *message)
{
  struct AvahiHostNameResolver *r = (struct AvahiHostNameResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *address;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  struct AvahiAddress *return_value_avahi_address_parse$5;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  signed int return_value_avahi_error_dbus_to_number$9;
  if(!(path == ((const char *)NULL)))
  {
    r = client->host_name_resolvers;
    for( ; !(r == ((struct AvahiHostNameResolver *)NULL)); r = r->host_name_resolvers_next)
    {
      return_value_strcmp$1=strcmp(r->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(r == ((struct AvahiHostNameResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        /* assertion address */
        assert(address != ((char *)NULL));
        return_value_avahi_address_parse$5=avahi_address_parse(address, (signed int)aprotocol, &a);
        if(return_value_avahi_address_parse$5 == ((struct AvahiAddress *)NULL))
        {
          fprintf(stderr, "Failed to parse address\n");
          goto fail;
        }

        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous$9)AVAHI_RESOLVER_FOUND, name, &a, (enum anonymous$4)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args$6=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$6 == 0u)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$9=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number$9);
        r->callback(r, r->interface, r->protocol, event, r->host_name, (const struct AvahiAddress *)(void *)0, (enum anonymous$4)0, r->userdata);
      }
    }
    return (enum anonymous$28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_host_name_resolver_free
// file lookup.h line 239
signed int avahi_host_name_resolver_free(struct AvahiHostNameResolver *r)
{
  signed int ret = 0;
  struct AvahiClient *avahi_host_name_resolver_free$$1$$client;
  /* assertion r */
  assert(r != ((struct AvahiHostNameResolver *)NULL));
  avahi_host_name_resolver_free$$1$$client = r->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(avahi_host_name_resolver_free$$1$$client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      ret=avahi_client_simple_method_call(avahi_host_name_resolver_free$$1$$client, r->path, "org.freedesktop.Avahi.HostNameResolver", "Free");

  }

  do
  {
    struct AvahiHostNameResolver **_head = &avahi_host_name_resolver_free$$1$$client->host_name_resolvers;
    struct AvahiHostNameResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiHostNameResolver *)NULL));
    if(!(_item->host_name_resolvers_next == ((struct AvahiHostNameResolver *)NULL)))
      _item->host_name_resolvers_next->host_name_resolvers_prev = _item->host_name_resolvers_prev;

    if(!(_item->host_name_resolvers_prev == ((struct AvahiHostNameResolver *)NULL)))
      _item->host_name_resolvers_prev->host_name_resolvers_next = _item->host_name_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->host_name_resolvers_next;
    }
    _item->host_name_resolvers_prev = (struct AvahiHostNameResolver *)(void *)0;
    _item->host_name_resolvers_next = _item->host_name_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r->host_name);
  avahi_free((void *)r);
  return ret;
}

// avahi_host_name_resolver_get_client
// file resolver.c line 558
struct AvahiClient * avahi_host_name_resolver_get_client(struct AvahiHostNameResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiHostNameResolver *)NULL));
  return r->client;
}

// avahi_host_name_resolver_new
// file resolver.c line 424
struct AvahiHostNameResolver * avahi_host_name_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, signed int aprotocol, enum anonymous$2 flags, void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous$9, const char *, const struct AvahiAddress *, enum anonymous$4, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiHostNameResolver *r = (struct AvahiHostNameResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  signed int i_aprotocol;
  unsigned int u_flags;
  char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal$2=avahi_new_internal$link3((unsigned int)1, sizeof(struct AvahiHostNameResolver) /*64ul*/ );
    r = (struct AvahiHostNameResolver *)return_value_avahi_new_internal$2;
    if(r == ((struct AvahiHostNameResolver *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      r->client = client;
      r->callback = callback;
      r->userdata = userdata;
      r->path = (char *)(void *)0;
      r->interface = interface;
      r->protocol = protocol;
      r->host_name = (char *)(void *)0;
      do
      {
        struct AvahiHostNameResolver **_head = &client->host_name_resolvers;
        struct AvahiHostNameResolver *_item = r;
        /* assertion _item */
        assert(_item != ((struct AvahiHostNameResolver *)NULL));
        _item->host_name_resolvers_next = *_head;
        if(!(_item->host_name_resolvers_next == ((struct AvahiHostNameResolver *)NULL)))
          _item->host_name_resolvers_next->host_name_resolvers_prev = _item;

        _item->host_name_resolvers_prev = (struct AvahiHostNameResolver *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      r->host_name=avahi_strdup(name);
      if(r->host_name == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "HostNameResolverNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          i_aprotocol = (signed int)aprotocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)105, &i_aprotocol, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args$3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr$5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
              tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args$6 == 0u)
                tmp_if_expr$8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr$8)
                avahi_client_set_errno(client, -22);

              else
              {
                r->path=avahi_strdup(path);
                if(r->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return r;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(r == ((struct AvahiHostNameResolver *)NULL)))
    avahi_host_name_resolver_free(r);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiHostNameResolver *)(void *)0;
}

// avahi_init_i18n
// file ../avahi-common/i18n.h line 51
void avahi_init_i18n(void)
{
  static signed int done = 0;
  if(done == 0)
  {
    bindtextdomain("avahi", "/usr/share/locale");
    bind_textdomain_codeset("avahi", "UTF-8");
    done = 1;
  }

}

// avahi_is_valid_domain_name
// file domain.c line 369
signed int avahi_is_valid_domain_name(const char *t)
{
  signed int is_first = 1;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  if(return_value_strlen$1 >= 1014ul)
    return 0;

  else
  {
    do
    {
      char label[64l];
      char *return_value_avahi_unescape_label$2;
      return_value_avahi_unescape_label$2=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label$2 == ((char *)NULL))
        return 0;

      if(!(is_first == 0))
      {
        if((signed int)label[0l] == 0)
        {
          if((signed int)*t == 0)
            return 1;

        }

      }

      is_first = 0;
      if((signed int)label[0l] == 0)
        return 0;

    }
    while(!(*t == 0));
    return 1;
  }
}

// avahi_is_valid_fqdn
// file domain.c line 575
signed int avahi_is_valid_fqdn(const char *t)
{
  char label[64l];
  char normalized[1014l];
  const char *k = t;
  struct AvahiAddress a;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  if(return_value_strlen$1 >= 1014ul)
    return 0;

  else
  {
    signed int return_value_avahi_is_valid_domain_name$2;
    return_value_avahi_is_valid_domain_name$2=avahi_is_valid_domain_name(t);
    if(return_value_avahi_is_valid_domain_name$2 == 0)
      return 0;

    else
    {
      char *return_value_avahi_unescape_label$3;
      return_value_avahi_unescape_label$3=avahi_unescape_label(&k, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label$3 == ((char *)NULL))
        return 0;

      else
        if(k == ((const char *)NULL) || (signed int)label[0l] == 0)
          return 0;

        else
        {
          char *return_value_avahi_unescape_label$4;
          return_value_avahi_unescape_label$4=avahi_unescape_label(&k, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label$4 == ((char *)NULL))
            return 0;

          else
            if(k == ((const char *)NULL) || (signed int)label[0l] == 0)
              return 0;

            else
            {
              char *return_value_avahi_normalize_name$5;
              return_value_avahi_normalize_name$5=avahi_normalize_name(t, normalized, sizeof(char [1014l]) /*1014ul*/ );
              if(return_value_avahi_normalize_name$5 == ((char *)NULL))
                return 0;

              else
              {
                struct AvahiAddress *return_value_avahi_address_parse$6;
                return_value_avahi_address_parse$6=avahi_address_parse(normalized, -1, &a);
                if(!(return_value_avahi_address_parse$6 == ((struct AvahiAddress *)NULL)))
                  return 0;

                else
                  return 1;
              }
            }
        }
    }
  }
}

// avahi_is_valid_host_name
// file domain.h line 103
signed int avahi_is_valid_host_name(const char *t)
{
  char label[64l];
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 1014ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label$3;
    return_value_avahi_unescape_label$3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$3 == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(label);
      if(!(return_value_strlen$4 >= 1ul))
        return 0;

      else
        if(!(*t == 0))
          return 0;

        else
          return 1;
    }
  }
}

// avahi_is_valid_service_name
// file domain.h line 100
signed int avahi_is_valid_service_name(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 64ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return 0;

  else
    return 1;
}

// avahi_is_valid_service_subtype
// file domain.c line 363
signed int avahi_is_valid_service_subtype(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  const char *return_value_avahi_get_type_from_subtype$1;
  return_value_avahi_get_type_from_subtype$1=avahi_get_type_from_subtype(t);
  return (signed int)!(!(return_value_avahi_get_type_from_subtype$1 != ((const char *)NULL)));
}

// avahi_is_valid_service_type_generic
// file domain.c line 254
signed int avahi_is_valid_service_type_generic(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 1014ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    do
    {
      char label[64l];
      char *return_value_avahi_unescape_label$3;
      return_value_avahi_unescape_label$3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label$3 == ((char *)NULL))
        return 0;

      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(label);
      if(!(return_value_strlen$4 >= 3ul))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        return 0;

    }
    while(!(*t == 0));
    return 1;
  }
}

// avahi_is_valid_service_type_strict
// file domain.c line 274
signed int avahi_is_valid_service_type_strict(const char *t)
{
  char label[64l];
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 1014ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  signed int return_value_strcasecmp$7;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label$3;
    return_value_avahi_unescape_label$3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$3 == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(label);
      if(!(return_value_strlen$4 >= 3ul))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        return 0;

      else
        if(*t == 0)
          return 0;

        else
        {
          char *return_value_avahi_unescape_label$6;
          return_value_avahi_unescape_label$6=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label$6 == ((char *)NULL))
            return 0;

          else
          {
            signed int return_value_strcasecmp$8;
            return_value_strcasecmp$8=strcasecmp(label, "_tcp");
            if(!(return_value_strcasecmp$8 == 0))
            {
              return_value_strcasecmp$7=strcasecmp(label, "_udp");
              if(return_value_strcasecmp$7 == 0)
                goto __CPROVER_DUMP_L10;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L10:
              ;
              if(!(*t == 0))
                return 0;

              else
                return 1;
            }
          }
        }
    }
  }
}

// avahi_malloc
// file ../avahi-common/malloc.h line 36
void * avahi_malloc(unsigned long int size)
{
  void *return_value_xmalloc$1;
  if(!(size >= 1ul))
    return (void *)0;

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xmalloc$1=xmalloc(size);
      return return_value_xmalloc$1;
    }

    else
    {
      /* assertion allocator->malloc */
      assert(allocator->malloc != ((void * (*)(unsigned long int))NULL));
      void *return_value;
      return_value=allocator->malloc(size);
      return return_value;
    }
}

// avahi_malloc0
// file malloc.c line 113
void * avahi_malloc0(unsigned long int size)
{
  void *p;
  void *return_value_xcalloc$1;
  void *return_value;
  if(!(size >= 1ul))
    return (void *)0;

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xcalloc$1=xcalloc((unsigned long int)1, size);
      return return_value_xcalloc$1;
    }

    else
      if(!(allocator->calloc == ((void * (*)(unsigned long int, unsigned long int))NULL)))
      {
        return_value=allocator->calloc((unsigned long int)1, size);
        return return_value;
      }

      else
      {
        /* assertion allocator->malloc */
        assert(allocator->malloc != ((void * (*)(unsigned long int))NULL));
        p=allocator->malloc(size);
        if(!(p == NULL))
          memset(p, 0, size);

        return p;
      }
}

// avahi_memdup
// file malloc.c line 248
void * avahi_memdup(const void *s, unsigned long int l)
{
  void *p;
  /* assertion s */
  assert(s != NULL);
  p=avahi_malloc(l);
  if(p == NULL)
    return (void *)0;

  else
  {
    memcpy(p, s, l);
    return p;
  }
}

// avahi_new_internal
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal(unsigned int n, unsigned long int k)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n < (unsigned long int)0x7fffffff / k);
  void *return_value_avahi_malloc$1;
  return_value_avahi_malloc$1=avahi_malloc((unsigned long int)n * k);
  return return_value_avahi_malloc$1;
}

// avahi_new_internal$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link1(unsigned int n$link1, unsigned long int k$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1 < (unsigned long int)0x7fffffff / k$link1);
  void *return_value_avahi_malloc$1$link1;
  return_value_avahi_malloc$1$link1=avahi_malloc((unsigned long int)n$link1 * k$link1);
  return return_value_avahi_malloc$1$link1;
}

// avahi_new_internal$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link1(unsigned int n$link1$link1, unsigned long int k$link1$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1$link1 < (unsigned long int)0x7fffffff / k$link1$link1);
  void *return_value_avahi_malloc$1$link1$link1;
  return_value_avahi_malloc$1$link1$link1=avahi_malloc((unsigned long int)n$link1$link1 * k$link1$link1);
  return return_value_avahi_malloc$1$link1$link1;
}

// avahi_new_internal$link1$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link2(unsigned int n$link1$link2, unsigned long int k$link1$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1$link2 < (unsigned long int)0x7fffffff / k$link1$link2);
  void *return_value_avahi_malloc$1$link1$link2;
  return_value_avahi_malloc$1$link1$link2=avahi_malloc((unsigned long int)n$link1$link2 * k$link1$link2);
  return return_value_avahi_malloc$1$link1$link2;
}

// avahi_new_internal$link2
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link2(unsigned int n$link2, unsigned long int k$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2 < (unsigned long int)0x7fffffff / k$link2);
  void *return_value_avahi_malloc$1$link2;
  return_value_avahi_malloc$1$link2=avahi_malloc((unsigned long int)n$link2 * k$link2);
  return return_value_avahi_malloc$1$link2;
}

// avahi_new_internal$link2$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link1(unsigned int n$link2$link1, unsigned long int k$link2$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2$link1 < (unsigned long int)0x7fffffff / k$link2$link1);
  void *return_value_avahi_malloc$1$link2$link1;
  return_value_avahi_malloc$1$link2$link1=avahi_malloc((unsigned long int)n$link2$link1 * k$link2$link1);
  return return_value_avahi_malloc$1$link2$link1;
}

// avahi_new_internal$link2$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link2(unsigned int n$link2$link2, unsigned long int k$link2$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2$link2 < (unsigned long int)0x7fffffff / k$link2$link2);
  void *return_value_avahi_malloc$1$link2$link2;
  return_value_avahi_malloc$1$link2$link2=avahi_malloc((unsigned long int)n$link2$link2 * k$link2$link2);
  return return_value_avahi_malloc$1$link2$link2;
}

// avahi_new_internal$link3
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link3(unsigned int n$link3, unsigned long int k$link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3 < (unsigned long int)0x7fffffff / k$link3);
  void *return_value_avahi_malloc$1$link3;
  return_value_avahi_malloc$1$link3=avahi_malloc((unsigned long int)n$link3 * k$link3);
  return return_value_avahi_malloc$1$link3;
}

// avahi_new_internal$link3$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link1(unsigned int n$link3$link1, unsigned long int k$link3$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3$link1 < (unsigned long int)0x7fffffff / k$link3$link1);
  void *return_value_avahi_malloc$1$link3$link1;
  return_value_avahi_malloc$1$link3$link1=avahi_malloc((unsigned long int)n$link3$link1 * k$link3$link1);
  return return_value_avahi_malloc$1$link3$link1;
}

// avahi_new_internal$link3$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link2(unsigned int n$link3$link2, unsigned long int k$link3$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3$link2 < (unsigned long int)0x7fffffff / k$link3$link2);
  void *return_value_avahi_malloc$1$link3$link2;
  return_value_avahi_malloc$1$link3$link2=avahi_malloc((unsigned long int)n$link3$link2 * k$link3$link2);
  return return_value_avahi_malloc$1$link3$link2;
}

// avahi_new_internal$link4
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link4(unsigned int n$link4, unsigned long int k$link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4 < (unsigned long int)0x7fffffff / k$link4);
  void *return_value_avahi_malloc$1$link4;
  return_value_avahi_malloc$1$link4=avahi_malloc((unsigned long int)n$link4 * k$link4);
  return return_value_avahi_malloc$1$link4;
}

// avahi_new_internal$link4$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link1(unsigned int n$link4$link1, unsigned long int k$link4$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4$link1 < (unsigned long int)0x7fffffff / k$link4$link1);
  void *return_value_avahi_malloc$1$link4$link1;
  return_value_avahi_malloc$1$link4$link1=avahi_malloc((unsigned long int)n$link4$link1 * k$link4$link1);
  return return_value_avahi_malloc$1$link4$link1;
}

// avahi_new_internal$link4$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link2(unsigned int n$link4$link2, unsigned long int k$link4$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4$link2 < (unsigned long int)0x7fffffff / k$link4$link2);
  void *return_value_avahi_malloc$1$link4$link2;
  return_value_avahi_malloc$1$link4$link2=avahi_malloc((unsigned long int)n$link4$link2 * k$link4$link2);
  return return_value_avahi_malloc$1$link4$link2;
}

// avahi_new_internal$link5
// file malloc.h line 48
static inline void * avahi_new_internal$link5(unsigned int n$link5, unsigned long int k$link5)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link5 < (unsigned long int)0x7fffffff / k$link5);
  void *return_value_avahi_malloc$1$link5;
  return_value_avahi_malloc$1$link5=avahi_malloc((unsigned long int)n$link5 * k$link5);
  return return_value_avahi_malloc$1$link5;
}

// avahi_new_internal$link6
// file malloc.h line 48
static inline void * avahi_new_internal$link6(unsigned int n$link6, unsigned long int k$link6)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link6 < (unsigned long int)0x7fffffff / k$link6);
  void *return_value_avahi_malloc$1$link6;
  return_value_avahi_malloc$1$link6=avahi_malloc((unsigned long int)n$link6 * k$link6);
  return return_value_avahi_malloc$1$link6;
}

// avahi_normalize_name
// file ../avahi-common/domain.h line 50
char * avahi_normalize_name(const char *s, char *ret_s, unsigned long int size)
{
  signed int empty = 1;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  /* assertion ret_s */
  assert(ret_s != ((char *)NULL));
  /* assertion size > 0 */
  assert(size > (unsigned long int)0);
  r = ret_s;
  *ret_s = (char)0;
  char *tmp_post$2;
  while(!(*s == 0))
  {
    char label[64l];
    char *return_value_avahi_unescape_label$1;
    return_value_avahi_unescape_label$1=avahi_unescape_label(&s, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$1 == ((char *)NULL))
      return (char *)(void *)0;

    if((signed int)label[0l] == 0)
    {
      if((signed int)*s == 0)
      {
        if(!(empty == 0))
          return ret_s;

      }

      return (char *)(void *)0;
    }

    if(empty == 0)
    {
      if(!(size >= 1ul))
        return (char *)(void *)0;

      tmp_post$2 = r;
      r = r + 1l;
      *tmp_post$2 = (char)46;
      size = size - 1ul;
    }

    else
      empty = 0;
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(label);
    avahi_escape_label(label, return_value_strlen$3, &r, &size);
  }
  return ret_s;
}

// avahi_normalize_name_strdup
// file domain.c line 219
char * avahi_normalize_name_strdup(const char *s)
{
  char t[1014l];
  /* assertion s */
  assert(s != ((const char *)NULL));
  char *return_value_avahi_normalize_name$1;
  return_value_avahi_normalize_name$1=avahi_normalize_name(s, t, sizeof(char [1014l]) /*1014ul*/ );
  if(return_value_avahi_normalize_name$1 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *return_value_avahi_strdup$2;
    return_value_avahi_strdup$2=avahi_strdup(t);
    return return_value_avahi_strdup$2;
  }
}

// avahi_nss_support
// file check-nss.c line 31
signed int avahi_nss_support(void)
{
  signed int b = 0;
  static const char * const libs[4l] = { "libnss_mdns.so.2", "libnss_mdns4.so.2", "libnss_mdns6.so.2", (const char *)(void *)0 };
  const char * const *l = libs;
  for( ; !(*l == ((const char *)NULL)); l = l + 1l)
  {
    void *dl;
    dl=dlopen(*l, 0x00001);
    if(!(dl == NULL))
    {
      b = 1;
      dlclose(dl);
      break;
    }

  }
  return b;
}

// avahi_proto_to_af
// file address.c line 127
signed int avahi_proto_to_af(signed int proto)
{
  if(proto == 0)
    return 2;

  else
    if(proto == 1)
      return 10;

    else
    {
      /* assertion proto == AVAHI_PROTO_UNSPEC */
      assert(proto == -1);
      return 0;
    }
}

// avahi_proto_to_string
// file address.c line 147
const char * avahi_proto_to_string(signed int proto)
{
  if(proto == 0)
    return "IPv4";

  else
    if(proto == 1)
      return "IPv6";

    else
    {
      /* assertion proto == AVAHI_PROTO_UNSPEC */
      assert(proto == -1);
      return "UNSPEC";
    }
}

// avahi_realloc
// file malloc.c line 146
void * avahi_realloc(void *p, unsigned long int size)
{
  void *return_value_xrealloc$1;
  if(size == 0ul)
  {
    avahi_free(p);
    return (void *)0;
  }

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xrealloc$1=xrealloc(p, size);
      return return_value_xrealloc$1;
    }

    else
    {
      /* assertion allocator->realloc */
      assert(allocator->realloc != ((void * (*)(void *, unsigned long int))NULL));
      void *return_value;
      return_value=allocator->realloc(p, size);
      return return_value;
    }
}

// avahi_record_browser_event
// file internal.h line 162
enum anonymous$28 avahi_record_browser_event(struct AvahiClient *client, enum anonymous$3 event, struct DBusMessage *message)
{
  struct AvahiRecordBrowser *b = (struct AvahiRecordBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *name;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  unsigned short int clazz;
  unsigned short int type;
  void *rdata = (void *)0;
  signed int rdata_size = 0;
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  signed int j;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  signed int return_value_dbus_message_iter_get_arg_type$5;
  _Bool tmp_if_expr$7;
  signed int return_value_dbus_message_iter_get_element_type$6;
  signed int return_value_dbus_message_iter_get_arg_type$8;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$9;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  signed int return_value_avahi_error_dbus_to_number$12;
  if(!(path == ((const char *)NULL)))
  {
    b = client->record_browsers;
    for( ; !(b == ((struct AvahiRecordBrowser *)NULL)); b = b->record_browsers_next)
    {
      return_value_strcmp$1=strcmp(b->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(b == ((struct AvahiRecordBrowser *)NULL))
      goto fail;

    interface = b->interface;
    protocol = b->protocol;
    clazz = b->clazz;
    type = b->type;
    name = b->name;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        dbus_message_iter_init(message, &iter);
        j = 0;
        for( ; !(j >= 5); j = j + 1)
          dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type$5=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type$5 == 97))
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_message_iter_get_element_type$6=dbus_message_iter_get_element_type(&iter);
          tmp_if_expr$7 = return_value_dbus_message_iter_get_element_type$6 != (signed int)121 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
          goto fail;

        dbus_message_iter_recurse(&iter, &sub);
        dbus_message_iter_get_fixed_array(&sub, (void *)&rdata, &rdata_size);
        dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type$8=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type$8 == 117))
          goto fail;

        dbus_message_iter_get_basic(&iter, (void *)&flags);
        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args$9=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$9 == 0u)
          tmp_if_expr$11 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
          tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$11)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$12=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number$12);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, name, clazz, type, rdata, (unsigned long int)rdata_size, (enum anonymous$4)flags, b->userdata);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_record_browser_free
// file lookup.h line 308
signed int avahi_record_browser_free(struct AvahiRecordBrowser *b)
{
  struct AvahiClient *avahi_record_browser_free$$1$$client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiRecordBrowser *)NULL));
  avahi_record_browser_free$$1$$client = b->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      r=avahi_client_simple_method_call(avahi_record_browser_free$$1$$client, b->path, "org.freedesktop.Avahi.RecordBrowser", "Free");

  }

  do
  {
    struct AvahiRecordBrowser **_head = &b->client->record_browsers;
    struct AvahiRecordBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiRecordBrowser *)NULL));
    if(!(_item->record_browsers_next == ((struct AvahiRecordBrowser *)NULL)))
      _item->record_browsers_next->record_browsers_prev = _item->record_browsers_prev;

    if(!(_item->record_browsers_prev == ((struct AvahiRecordBrowser *)NULL)))
      _item->record_browsers_prev->record_browsers_next = _item->record_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->record_browsers_next;
    }
    _item->record_browsers_prev = (struct AvahiRecordBrowser *)(void *)0;
    _item->record_browsers_next = _item->record_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->name);
  avahi_free((void *)b);
  return r;
}

// avahi_record_browser_get_client
// file browser.c line 903
struct AvahiClient * avahi_record_browser_get_client(struct AvahiRecordBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiRecordBrowser *)NULL));
  return b->client;
}

// avahi_record_browser_new
// file browser.c line 786
struct AvahiRecordBrowser * avahi_record_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, unsigned short int clazz, unsigned short int type, enum anonymous$2 flags, void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$3, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$4, void *), void *userdata)
{
  struct AvahiRecordBrowser *b = (struct AvahiRecordBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_protocol;
  signed int i_interface;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$3, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$4, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal$2=avahi_new_internal$link2((unsigned int)1, sizeof(struct AvahiRecordBrowser) /*72ul*/ );
    b = (struct AvahiRecordBrowser *)return_value_avahi_new_internal$2;
    if(b == ((struct AvahiRecordBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->name = (char *)(void *)0;
      b->clazz = clazz;
      b->type = type;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiRecordBrowser **_head = &client->record_browsers;
        struct AvahiRecordBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiRecordBrowser *)NULL));
        _item->record_browsers_next = *_head;
        if(!(_item->record_browsers_next == ((struct AvahiRecordBrowser *)NULL)))
          _item->record_browsers_next->record_browsers_prev = _item;

        _item->record_browsers_prev = (struct AvahiRecordBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      b->name=avahi_strdup(name);
      if(b->name == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "RecordBrowserNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args$3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr$5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
              tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args$6 == 0u)
                tmp_if_expr$8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr$8)
                avahi_client_set_errno(client, -22);

              else
              {
                b->path=avahi_strdup(path);
                if(b->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return b;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiRecordBrowser *)NULL)))
    avahi_record_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiRecordBrowser *)(void *)0;
}

// avahi_reverse_lookup_name
// file address.c line 67
char * avahi_reverse_lookup_name(const struct AvahiAddress *a, char *ret_s, unsigned long int length)
{
  /* assertion ret_s */
  assert(ret_s != ((char *)NULL));
  /* assertion length > 0 */
  assert(length > (unsigned long int)0);
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  if(a->proto == 0)
  {
    unsigned int n;
    n=ntohl(a->data.ipv4.address);
    snprintf(ret_s, length, "%u.%u.%u.%u.in-addr.arpa", n & (unsigned int)0xFF, n >> 8 & (unsigned int)0xFF, n >> 16 & (unsigned int)0xFF, n >> 24);
  }

  else
  {
    /* assertion a->proto == AVAHI_PROTO_INET6 */
    assert(a->proto == 1);
    snprintf(ret_s, length, "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.arpa", (signed int)a->data.ipv6.address[(signed long int)15] & 0xF, (signed int)a->data.ipv6.address[(signed long int)15] >> 4, (signed int)a->data.ipv6.address[(signed long int)14] & 0xF, (signed int)a->data.ipv6.address[(signed long int)14] >> 4, (signed int)a->data.ipv6.address[(signed long int)13] & 0xF, (signed int)a->data.ipv6.address[(signed long int)13] >> 4, (signed int)a->data.ipv6.address[(signed long int)12] & 0xF, (signed int)a->data.ipv6.address[(signed long int)12] >> 4, (signed int)a->data.ipv6.address[(signed long int)11] & 0xF, (signed int)a->data.ipv6.address[(signed long int)11] >> 4, (signed int)a->data.ipv6.address[(signed long int)10] & 0xF, (signed int)a->data.ipv6.address[(signed long int)10] >> 4, (signed int)a->data.ipv6.address[(signed long int)9] & 0xF, (signed int)a->data.ipv6.address[(signed long int)9] >> 4, (signed int)a->data.ipv6.address[(signed long int)8] & 0xF, (signed int)a->data.ipv6.address[(signed long int)8] >> 4, (signed int)a->data.ipv6.address[(signed long int)7] & 0xF, (signed int)a->data.ipv6.address[(signed long int)7] >> 4, (signed int)a->data.ipv6.address[(signed long int)6] & 0xF, (signed int)a->data.ipv6.address[(signed long int)6] >> 4, (signed int)a->data.ipv6.address[(signed long int)5] & 0xF, (signed int)a->data.ipv6.address[(signed long int)5] >> 4, (signed int)a->data.ipv6.address[(signed long int)4] & 0xF, (signed int)a->data.ipv6.address[(signed long int)4] >> 4, (signed int)a->data.ipv6.address[(signed long int)3] & 0xF, (signed int)a->data.ipv6.address[(signed long int)3] >> 4, (signed int)a->data.ipv6.address[(signed long int)2] & 0xF, (signed int)a->data.ipv6.address[(signed long int)2] >> 4, (signed int)a->data.ipv6.address[(signed long int)1] & 0xF, (signed int)a->data.ipv6.address[(signed long int)1] >> 4, (signed int)a->data.ipv6.address[(signed long int)0] & 0xF, (signed int)a->data.ipv6.address[(signed long int)0] >> 4);
  }
  return ret_s;
}

// avahi_rlist_prepend
// file rlist.c line 29
struct AvahiRList * avahi_rlist_prepend(struct AvahiRList *r, void *data)
{
  struct AvahiRList *n;
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link4$link1((unsigned int)1, sizeof(struct AvahiRList) /*24ul*/ );
  n = (struct AvahiRList *)return_value_avahi_new_internal$1;
  if(n == ((struct AvahiRList *)NULL))
    return (struct AvahiRList *)(void *)0;

  else
  {
    n->data = data;
    do
    {
      struct AvahiRList **_head = &r;
      struct AvahiRList *_item = n;
      /* assertion _item */
      assert(_item != ((struct AvahiRList *)NULL));
      _item->rlist_next = *_head;
      if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
        _item->rlist_next->rlist_prev = _item;

      _item->rlist_prev = (struct AvahiRList *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    return r;
  }
}

// avahi_rlist_remove
// file rlist.c line 41
struct AvahiRList * avahi_rlist_remove(struct AvahiRList *r, void *data)
{
  struct AvahiRList *n = r;
  for( ; !(n == ((struct AvahiRList *)NULL)); n = n->rlist_next)
    if(n->data == data)
    {
      do
      {
        struct AvahiRList **_head = &r;
        struct AvahiRList *_item = n;
        /* assertion _item */
        assert(_item != ((struct AvahiRList *)NULL));
        if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
          _item->rlist_next->rlist_prev = _item->rlist_prev;

        if(!(_item->rlist_prev == ((struct AvahiRList *)NULL)))
          _item->rlist_prev->rlist_next = _item->rlist_next;

        else
        {
          /* assertion *_head == _item */
          assert(*_head == _item);
          *_head = _item->rlist_next;
        }
        _item->rlist_prev = (struct AvahiRList *)(void *)0;
        _item->rlist_next = _item->rlist_prev;
      }
      while((_Bool)0);
      avahi_free((void *)n);
      break;
    }

  return r;
}

// avahi_rlist_remove_by_link
// file rlist.c line 55
struct AvahiRList * avahi_rlist_remove_by_link(struct AvahiRList *r, struct AvahiRList *n)
{
  /* assertion n */
  assert(n != ((struct AvahiRList *)NULL));
  do
  {
    struct AvahiRList **_head = &r;
    struct AvahiRList *_item = n;
    /* assertion _item */
    assert(_item != ((struct AvahiRList *)NULL));
    if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
      _item->rlist_next->rlist_prev = _item->rlist_prev;

    if(!(_item->rlist_prev == ((struct AvahiRList *)NULL)))
      _item->rlist_prev->rlist_next = _item->rlist_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->rlist_next;
    }
    _item->rlist_prev = (struct AvahiRList *)(void *)0;
    _item->rlist_next = _item->rlist_prev;
  }
  while((_Bool)0);
  avahi_free((void *)n);
  return r;
}

// avahi_service_browser_event
// file internal.h line 161
enum anonymous$28 avahi_service_browser_event(struct AvahiClient *client, enum anonymous$3 event, struct DBusMessage *message)
{
  struct AvahiServiceBrowser *b = (struct AvahiServiceBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *name = (char *)(void *)0;
  char *type;
  char *domain;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  signed int return_value_avahi_error_dbus_to_number$8;
  if(!(path == ((const char *)NULL)))
  {
    b = client->service_browsers;
    for( ; !(b == ((struct AvahiServiceBrowser *)NULL)); b = b->service_browsers_next)
    {
      return_value_strcmp$1=strcmp(b->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(b == ((struct AvahiServiceBrowser *)NULL))
      goto fail;

    type = b->type;
    domain = b->domain;
    interface = b->interface;
    protocol = b->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args$5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$5 == 0u)
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
          tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number$8);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, name, type, domain, (enum anonymous$4)flags, b->userdata);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_browser_free
// file lookup.h line 117
signed int avahi_service_browser_free(struct AvahiServiceBrowser *b)
{
  struct AvahiClient *avahi_service_browser_free$$1$$client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiServiceBrowser *)NULL));
  avahi_service_browser_free$$1$$client = b->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      r=avahi_client_simple_method_call(avahi_service_browser_free$$1$$client, b->path, "org.freedesktop.Avahi.ServiceBrowser", "Free");

  }

  do
  {
    struct AvahiServiceBrowser **_head = &b->client->service_browsers;
    struct AvahiServiceBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceBrowser *)NULL));
    if(!(_item->service_browsers_next == ((struct AvahiServiceBrowser *)NULL)))
      _item->service_browsers_next->service_browsers_prev = _item->service_browsers_prev;

    if(!(_item->service_browsers_prev == ((struct AvahiServiceBrowser *)NULL)))
      _item->service_browsers_prev->service_browsers_next = _item->service_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_browsers_next;
    }
    _item->service_browsers_prev = (struct AvahiServiceBrowser *)(void *)0;
    _item->service_browsers_next = _item->service_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->type);
  avahi_free((void *)b->domain);
  avahi_free((void *)b);
  return r;
}

// avahi_service_browser_get_client
// file browser.c line 686
struct AvahiClient * avahi_service_browser_get_client(struct AvahiServiceBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiServiceBrowser *)NULL));
  return b->client;
}

// avahi_service_browser_new
// file browser.c line 564
struct AvahiServiceBrowser * avahi_service_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *type, const char *domain, enum anonymous$2 flags, void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, const char *, enum anonymous$4, void *), void *userdata)
{
  struct AvahiServiceBrowser *b = (struct AvahiServiceBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_protocol;
  signed int i_interface;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, const char *, enum anonymous$4, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal$2=avahi_new_internal$link2((unsigned int)1, sizeof(struct AvahiServiceBrowser) /*72ul*/ );
    b = (struct AvahiServiceBrowser *)return_value_avahi_new_internal$2;
    if(b == ((struct AvahiServiceBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->domain = (char *)(void *)0;
      b->type = b->domain;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiServiceBrowser **_head = &client->service_browsers;
        struct AvahiServiceBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceBrowser *)NULL));
        _item->service_browsers_next = *_head;
        if(!(_item->service_browsers_next == ((struct AvahiServiceBrowser *)NULL)))
          _item->service_browsers_next->service_browsers_prev = _item;

        _item->service_browsers_prev = (struct AvahiServiceBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      b->type=avahi_strdup(type);
      if(b->type == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
        if(!(domain == ((const char *)NULL)))
        {
          if(*domain == 0)
            goto __CPROVER_DUMP_L7;

          b->domain=avahi_strdup(domain);
          if(!(b->domain == ((char *)NULL)))
            goto __CPROVER_DUMP_L7;

          avahi_client_set_errno(client, -24);
        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceBrowserNew");
          if(message == ((struct DBusMessage *)NULL))
            avahi_client_set_errno(client, -24);

          else
          {
            i_interface = (signed int)interface;
            i_protocol = (signed int)protocol;
            u_flags = (unsigned int)flags;
            return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &u_flags, (signed int)0);
            if(return_value_dbus_message_append_args$3 == 0u)
              avahi_client_set_errno(client, -24);

            else
            {
              reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
              if(reply == ((struct DBusMessage *)NULL))
                tmp_if_expr$5 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
                tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$5)
                avahi_client_set_errno(client, -22);

              else
              {
                return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
                if(return_value_dbus_message_get_args$6 == 0u)
                  tmp_if_expr$8 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                  tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(path == ((char *)NULL) || tmp_if_expr$8)
                  avahi_client_set_errno(client, -22);

                else
                {
                  b->path=avahi_strdup(path);
                  if(b->path == ((char *)NULL))
                    avahi_client_set_errno(client, -24);

                  else
                  {
                    dbus_message_unref(message);
                    dbus_message_unref(reply);
                    return b;
                  }
                }
              }
            }
          }
        }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiServiceBrowser *)NULL)))
    avahi_service_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceBrowser *)(void *)0;
}

// avahi_service_name_join
// file domain.c line 440
signed int avahi_service_name_join(char *p, unsigned long int size, const char *name, const char *type, const char *domain)
{
  char escaped_name[256l];
  char normalized_type[1014l];
  char normalized_domain[1014l];
  /* assertion p */
  assert(p != ((char *)NULL));
  signed int return_value_avahi_is_valid_service_name$1;
  char *tmp_if_expr$7;
  if(!(name == ((const char *)NULL)))
  {
    return_value_avahi_is_valid_service_name$1=avahi_is_valid_service_name(name);
    if(!(return_value_avahi_is_valid_service_name$1 == 0))
      goto __CPROVER_DUMP_L1;

    return -10;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    signed int return_value_avahi_is_valid_service_type_generic$2;
    return_value_avahi_is_valid_service_type_generic$2=avahi_is_valid_service_type_generic(type);
    if(return_value_avahi_is_valid_service_type_generic$2 == 0)
      return -11;

    else
    {
      signed int return_value_avahi_is_valid_domain_name$3;
      return_value_avahi_is_valid_domain_name$3=avahi_is_valid_domain_name(domain);
      if(return_value_avahi_is_valid_domain_name$3 == 0)
        return -4;

      else
      {
        if(!(name == ((const char *)NULL)))
        {
          unsigned long int l = sizeof(char [256l]) /*256ul*/ ;
          char *e = escaped_name;
          char *r;
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(name);
          r=avahi_escape_label(name, return_value_strlen$4, &e, &l);
          /* assertion r */
          assert(r != ((char *)NULL));
        }

        char *return_value_avahi_normalize_name$5;
        return_value_avahi_normalize_name$5=avahi_normalize_name(type, normalized_type, sizeof(char [1014l]) /*1014ul*/ );
        if(return_value_avahi_normalize_name$5 == ((char *)NULL))
          return -11;

        else
        {
          char *return_value_avahi_normalize_name$6;
          return_value_avahi_normalize_name$6=avahi_normalize_name(domain, normalized_domain, sizeof(char [1014l]) /*1014ul*/ );
          if(return_value_avahi_normalize_name$6 == ((char *)NULL))
            return -4;

          else
          {
            if(!(name == ((const char *)NULL)))
              tmp_if_expr$7 = escaped_name;

            else
              tmp_if_expr$7 = "";
            snprintf(p, size, "%s%s%s.%s", tmp_if_expr$7, name != ((const char *)NULL) ? "." : "", (const void *)normalized_type, (const void *)normalized_domain);
            return 0;
          }
        }
      }
    }
  }
}

// avahi_service_name_split
// file domain.c line 496
signed int avahi_service_name_split(const char *p, char *name, unsigned long int name_size, char *type, unsigned long int type_size, char *domain, unsigned long int domain_size)
{
  /* #anon_enum$NAME=0$TYPE=1$DOMAIN=2 */
enum anonymous$26 { NAME=0, TYPE=1, DOMAIN=2 };

/* */
  ;
  enum anonymous$26 state;
  signed int type_empty = 1;
  signed int domain_empty = 1;
  /* assertion p */
  assert(p != ((const char *)NULL));
  /* assertion type */
  assert(type != ((char *)NULL));
  /* assertion type_size > 0 */
  assert(type_size > (unsigned long int)0);
  /* assertion domain */
  assert(domain != ((char *)NULL));
  /* assertion domain_size > 0 */
  assert(domain_size > (unsigned long int)0);
  if(!(name == ((char *)NULL)))
  {
    /* assertion name_size > 0 */
    assert(name_size > (unsigned long int)0);
    *name = (char)0;
    state = (enum anonymous$26)NAME;
  }

  else
    state = (enum anonymous$26)TYPE;
  *domain = (char)0;
  *type = *domain;
  char *tmp_post$2;
  char *tmp_post$5;
  unsigned long int return_value_strlen$6;
  char *return_value_avahi_escape_label$7;
  while(!(*p == 0))
  {
    char buf[64l];
    char *return_value_avahi_unescape_label$1;
    return_value_avahi_unescape_label$1=avahi_unescape_label(&p, buf, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$1 == ((char *)NULL))
      return -1;

    switch((signed int)state)
    {
      case NAME:
      {
        strlcpy(name, buf, name_size);
        state = (enum anonymous$26)TYPE;
        break;
      }
      case TYPE:
      {
        if((signed int)buf[0l] == 95)
        {
          if(type_empty == 0)
          {
            if(type_size == 0ul)
              return -24;

            tmp_post$2 = type;
            type = type + 1l;
            *tmp_post$2 = (char)46;
            type_size = type_size - 1ul;
          }

          else
            type_empty = 0;
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(buf);
          char *return_value_avahi_escape_label$4;
          return_value_avahi_escape_label$4=avahi_escape_label(buf, return_value_strlen$3, &type, &type_size);
          if(return_value_avahi_escape_label$4 == ((char *)NULL))
            return -24;

          break;
        }

        state = (enum anonymous$26)DOMAIN;
      }
      case DOMAIN:
      {
        if(domain_empty == 0)
        {
          if(domain_size == 0ul)
            return -24;

          tmp_post$5 = domain;
          domain = domain + 1l;
          *tmp_post$5 = (char)46;
          domain_size = domain_size - 1ul;
        }

        else
          domain_empty = 0;
        return_value_strlen$6=strlen(buf);
        return_value_avahi_escape_label$7=avahi_escape_label(buf, return_value_strlen$6, &domain, &domain_size);
        if(return_value_avahi_escape_label$7 == ((char *)NULL))
          return -24;

      }
    }
  }
  return 0;
}

// avahi_service_resolver_event
// file internal.h line 164
enum anonymous$28 avahi_service_resolver_event(struct AvahiClient *client, enum anonymous$9 event, struct DBusMessage *message)
{
  struct AvahiServiceResolver *r = (struct AvahiServiceResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  struct AvahiStringList *strlst = (struct AvahiStringList *)(void *)0;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  signed int j;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *type;
  char *domain;
  char *host;
  char *address;
  unsigned short int port;
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  signed int return_value_dbus_message_iter_get_arg_type$5;
  _Bool tmp_if_expr$7;
  signed int return_value_dbus_message_iter_get_element_type$6;
  signed int return_value_dbus_message_iter_get_arg_type$9;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$10;
  _Bool tmp_if_expr$12;
  unsigned int return_value_dbus_error_is_set$11;
  signed int return_value_avahi_error_dbus_to_number$13;
  if(!(path == ((const char *)NULL)))
  {
    r = client->service_resolvers;
    for( ; !(r == ((struct AvahiServiceResolver *)NULL)); r = r->service_resolvers_next)
    {
      return_value_strcmp$1=strcmp(r->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(r == ((struct AvahiServiceResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &host, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)113, &port, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        dbus_message_iter_init(message, &iter);
        j = 0;
        for( ; !(j >= 9); j = j + 1)
          dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type$5=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type$5 == 97))
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_message_iter_get_element_type$6=dbus_message_iter_get_element_type(&iter);
          tmp_if_expr$7 = return_value_dbus_message_iter_get_element_type$6 != (signed int)97 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          fprintf(stderr, "Error parsing service resolving message\n");
          goto fail;
        }

        strlst = (struct AvahiStringList *)(void *)0;
        dbus_message_iter_recurse(&iter, &sub);
        do
        {
          struct DBusMessageIter sub2;
          signed int at;
          const unsigned char *k;
          signed int n;
          at=dbus_message_iter_get_arg_type(&sub);
          if(at == 0)
            break;

          /* assertion at == ((int) 'a') */
          assert(at == (signed int)97);
          signed int return_value_dbus_message_iter_get_element_type$8;
          return_value_dbus_message_iter_get_element_type$8=dbus_message_iter_get_element_type(&sub);
          if(!(return_value_dbus_message_iter_get_element_type$8 == 121))
          {
            fprintf(stderr, "Error parsing service resolving message\n");
            goto fail;
          }

          dbus_message_iter_recurse(&sub, &sub2);
          k = (const unsigned char *)(void *)0;
          n = 0;
          dbus_message_iter_get_fixed_array(&sub2, (void *)&k, &n);
          if(n >= 1 && !(k == ((const unsigned char *)NULL)))
            strlst=avahi_string_list_add_arbitrary(strlst, k, (unsigned long int)n);

          dbus_message_iter_next(&sub);
        }
        while((_Bool)1);
        dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type$9=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type$9 == 117))
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        dbus_message_iter_get_basic(&iter, (void *)&flags);
        /* assertion address */
        assert(address != ((char *)NULL));
        if((signed int)*address == 0)
          address = (char *)(void *)0;

        else
          avahi_address_parse(address, (signed int)aprotocol, &a);
        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous$9)AVAHI_RESOLVER_FOUND, name, type, domain, host, address != ((char *)NULL) ? &a : (struct AvahiAddress *)(void *)0, port, strlst, (enum anonymous$4)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args$10=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$10 == 0u)
          tmp_if_expr$12 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$11=dbus_error_is_set(&error);
          tmp_if_expr$12 = return_value_dbus_error_is_set$11 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$12)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$13=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number$13);
        r->callback(r, r->interface, r->protocol, event, r->name, r->type, r->domain, (const char *)(void *)0, (const struct AvahiAddress *)(void *)0, (unsigned short int)0, (struct AvahiStringList *)(void *)0, (enum anonymous$4)0, r->userdata);
      }
    }
    return (enum anonymous$28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    avahi_string_list_free(strlst);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_resolver_free
// file lookup.h line 205
signed int avahi_service_resolver_free(struct AvahiServiceResolver *r)
{
  struct AvahiClient *avahi_service_resolver_free$$1$$client;
  signed int ret = 0;
  /* assertion r */
  assert(r != ((struct AvahiServiceResolver *)NULL));
  avahi_service_resolver_free$$1$$client = r->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(avahi_service_resolver_free$$1$$client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      ret=avahi_client_simple_method_call(avahi_service_resolver_free$$1$$client, r->path, "org.freedesktop.Avahi.ServiceResolver", "Free");

  }

  do
  {
    struct AvahiServiceResolver **_head = &avahi_service_resolver_free$$1$$client->service_resolvers;
    struct AvahiServiceResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceResolver *)NULL));
    if(!(_item->service_resolvers_next == ((struct AvahiServiceResolver *)NULL)))
      _item->service_resolvers_next->service_resolvers_prev = _item->service_resolvers_prev;

    if(!(_item->service_resolvers_prev == ((struct AvahiServiceResolver *)NULL)))
      _item->service_resolvers_prev->service_resolvers_next = _item->service_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_resolvers_next;
    }
    _item->service_resolvers_prev = (struct AvahiServiceResolver *)(void *)0;
    _item->service_resolvers_next = _item->service_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r->name);
  avahi_free((void *)r->type);
  avahi_free((void *)r->domain);
  avahi_free((void *)r);
  return ret;
}

// avahi_service_resolver_get_client
// file resolver.c line 318
struct AvahiClient * avahi_service_resolver_get_client(struct AvahiServiceResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiServiceResolver *)NULL));
  return r->client;
}

// avahi_service_resolver_new
// file resolver.c line 179
struct AvahiServiceResolver * avahi_service_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, const char *type, const char *domain, signed int aprotocol, enum anonymous$2 flags, void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous$9, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous$4, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiServiceResolver *r = (struct AvahiServiceResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  signed int i_aprotocol;
  unsigned int u_flags;
  char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  if(domain == ((const char *)NULL))
    domain = "";

  if(name == ((const char *)NULL))
    name = "";

  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal$2=avahi_new_internal$link3((unsigned int)1, sizeof(struct AvahiServiceResolver) /*80ul*/ );
    r = (struct AvahiServiceResolver *)return_value_avahi_new_internal$2;
    if(r == ((struct AvahiServiceResolver *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      r->client = client;
      r->callback = callback;
      r->userdata = userdata;
      r->path = (char *)(void *)0;
      r->domain = (char *)(void *)0;
      r->type = r->domain;
      r->name = r->type;
      r->interface = interface;
      r->protocol = protocol;
      do
      {
        struct AvahiServiceResolver **_head = &client->service_resolvers;
        struct AvahiServiceResolver *_item = r;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceResolver *)NULL));
        _item->service_resolvers_next = *_head;
        if(!(_item->service_resolvers_next == ((struct AvahiServiceResolver *)NULL)))
          _item->service_resolvers_next->service_resolvers_prev = _item;

        _item->service_resolvers_prev = (struct AvahiServiceResolver *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if(!(name == ((const char *)NULL)))
      {
        if(*name == 0)
          goto __CPROVER_DUMP_L7;

        r->name=avahi_strdup(name);
        if(!(r->name == ((char *)NULL)))
          goto __CPROVER_DUMP_L7;

        avahi_client_set_errno(client, -24);
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        r->type=avahi_strdup(type);
        if(r->type == ((char *)NULL))
          avahi_client_set_errno(client, -24);

        else
          if(!(domain == ((const char *)NULL)))
          {
            if(*domain == 0)
              goto __CPROVER_DUMP_L9;

            r->domain=avahi_strdup(domain);
            if(!(r->domain == ((char *)NULL)))
              goto __CPROVER_DUMP_L9;

            avahi_client_set_errno(client, -24);
          }

          else
          {

          __CPROVER_DUMP_L9:
            ;
            message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceResolverNew");
            if(message == ((struct DBusMessage *)NULL))
              avahi_client_set_errno(client, -24);

            else
            {
              i_interface = (signed int)interface;
              i_protocol = (signed int)protocol;
              i_aprotocol = (signed int)aprotocol;
              u_flags = (unsigned int)flags;
              return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)105, &i_aprotocol, (signed int)117, &u_flags, (signed int)0);
              if(return_value_dbus_message_append_args$3 == 0u)
                avahi_client_set_errno(client, -24);

              else
              {
                reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
                if(reply == ((struct DBusMessage *)NULL))
                  tmp_if_expr$5 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
                  tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$5)
                  avahi_client_set_errno(client, -22);

                else
                {
                  return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
                  if(return_value_dbus_message_get_args$6 == 0u)
                    tmp_if_expr$8 = (_Bool)1;

                  else
                  {
                    return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                    tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
                  }
                  if(path == ((char *)NULL) || tmp_if_expr$8)
                    avahi_client_set_errno(client, -22);

                  else
                  {
                    r->path=avahi_strdup(path);
                    if(r->path == ((char *)NULL))
                      avahi_client_set_errno(client, -24);

                    else
                    {
                      dbus_message_unref(message);
                      dbus_message_unref(reply);
                      return r;
                    }
                  }
                }
              }
            }
          }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(r == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(r);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceResolver *)(void *)0;
}

// avahi_service_type_browser_event
// file internal.h line 160
enum anonymous$28 avahi_service_type_browser_event(struct AvahiClient *client, enum anonymous$3 event, struct DBusMessage *message)
{
  struct AvahiServiceTypeBrowser *b = (struct AvahiServiceTypeBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *domain;
  char *type = (char *)(void *)0;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  signed int return_value_avahi_error_dbus_to_number$8;
  if(!(path == ((const char *)NULL)))
  {
    b = client->service_type_browsers;
    for( ; !(b == ((struct AvahiServiceTypeBrowser *)NULL)); b = b->service_type_browsers_next)
    {
      return_value_strcmp$1=strcmp(b->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(b == ((struct AvahiServiceTypeBrowser *)NULL))
      goto fail;

    domain = b->domain;
    interface = b->interface;
    protocol = b->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args$5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$5 == 0u)
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
          tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number$8);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, type, domain, (enum anonymous$4)flags, b->userdata);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_type_browser_free
// file lookup.h line 150
signed int avahi_service_type_browser_free(struct AvahiServiceTypeBrowser *b)
{
  struct AvahiClient *avahi_service_type_browser_free$$1$$client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiServiceTypeBrowser *)NULL));
  avahi_service_type_browser_free$$1$$client = b->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      r=avahi_client_simple_method_call(avahi_service_type_browser_free$$1$$client, b->path, "org.freedesktop.Avahi.ServiceTypeBrowser", "Free");

  }

  do
  {
    struct AvahiServiceTypeBrowser **_head = &b->client->service_type_browsers;
    struct AvahiServiceTypeBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceTypeBrowser *)NULL));
    if(!(_item->service_type_browsers_next == ((struct AvahiServiceTypeBrowser *)NULL)))
      _item->service_type_browsers_next->service_type_browsers_prev = _item->service_type_browsers_prev;

    if(!(_item->service_type_browsers_prev == ((struct AvahiServiceTypeBrowser *)NULL)))
      _item->service_type_browsers_prev->service_type_browsers_next = _item->service_type_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_type_browsers_next;
    }
    _item->service_type_browsers_prev = (struct AvahiServiceTypeBrowser *)(void *)0;
    _item->service_type_browsers_next = _item->service_type_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->domain);
  avahi_free((void *)b);
  return r;
}

// avahi_service_type_browser_get_client
// file browser.c line 465
struct AvahiClient * avahi_service_type_browser_get_client(struct AvahiServiceTypeBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiServiceTypeBrowser *)NULL));
  return b->client;
}

// avahi_service_type_browser_new
// file browser.c line 350
struct AvahiServiceTypeBrowser * avahi_service_type_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous$2 flags, void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, enum anonymous$4, void *), void *userdata)
{
  struct AvahiServiceTypeBrowser *b = (struct AvahiServiceTypeBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$3, const char *, const char *, enum anonymous$4, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal$2=avahi_new_internal$link2((unsigned int)1, sizeof(struct AvahiServiceTypeBrowser) /*64ul*/ );
    b = (struct AvahiServiceTypeBrowser *)return_value_avahi_new_internal$2;
    if(b == ((struct AvahiServiceTypeBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->domain = (char *)(void *)0;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiServiceTypeBrowser **_head = &client->service_type_browsers;
        struct AvahiServiceTypeBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceTypeBrowser *)NULL));
        _item->service_type_browsers_next = *_head;
        if(!(_item->service_type_browsers_next == ((struct AvahiServiceTypeBrowser *)NULL)))
          _item->service_type_browsers_next->service_type_browsers_prev = _item;

        _item->service_type_browsers_prev = (struct AvahiServiceTypeBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if(!(*domain == 0))
      {
        b->domain=avahi_strdup(domain);
        if(!(b->domain == ((char *)NULL)))
          goto __CPROVER_DUMP_L6;

        avahi_client_set_errno(client, -24);
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceTypeBrowserNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &domain, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args$3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr$5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
              tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args$6 == 0u)
                tmp_if_expr$8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr$8)
                avahi_client_set_errno(client, -22);

              else
              {
                b->path=avahi_strdup(path);
                if(b->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return b;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiServiceTypeBrowser *)NULL)))
    avahi_service_type_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceTypeBrowser *)(void *)0;
}

// avahi_set_allocator
// file malloc.c line 196
void avahi_set_allocator(const struct AvahiAllocator *a)
{
  allocator = a;
}

// avahi_simple_poll_dispatch
// file simple-watch.c line 547
signed int avahi_simple_poll_dispatch(struct AvahiSimplePoll *s)
{
  struct AvahiTimeout *next_timeout;
  struct AvahiWatch *w;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  /* assertion s->state == STATE_RAN */
  assert((signed int)s->state == STATE_RAN);
  s->state = (enum anonymous$10)STATE_DISPATCHING;
  next_timeout=find_next_timeout(s);
  if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
  {
    if(next_timeout->expiry.tv_sec == 0l)
    {
      if(next_timeout->expiry.tv_usec == 0l)
      {
        timeout_callback$link1(next_timeout);
        goto finish;
      }

    }

    signed long int return_value_avahi_age$1;
    return_value_avahi_age$1=avahi_age(&next_timeout->expiry);
    if(return_value_avahi_age$1 >= 0l)
    {
      timeout_callback$link1(next_timeout);
      goto finish;
    }

  }

  w = s->watches;
  for( ; !(w == ((struct AvahiWatch *)NULL)); w = w->watches_next)
    if(w->dead == 0)
    {
      /* assertion w->idx >= 0 */
      assert(w->idx >= 0);
      /* assertion w->idx < s->n_pollfds */
      assert(w->idx < s->n_pollfds);
      if(!((signed int)(s->pollfds + (signed long int)w->idx)->revents == 0))
      {
        w->callback(w, w->pollfd.fd, (enum anonymous$6)(s->pollfds + (signed long int)w->idx)->revents, w->userdata);
        break;
      }

    }


finish:
  ;
  s->state = (enum anonymous$10)STATE_DISPATCHED;
  return 0;
}

// avahi_simple_poll_free
// file ../avahi-common/simple-watch.h line 40
void avahi_simple_poll_free(struct AvahiSimplePoll *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  cleanup_timeouts(s, 1);
  cleanup_watches(s, 1);
  /* assertion s->n_watches == 0 */
  assert(s->n_watches == 0);
  avahi_free((void *)s->pollfds);
  if(s->wakeup_pipe[0l] >= 0)
    close(s->wakeup_pipe[(signed long int)0]);

  if(s->wakeup_pipe[1l] >= 0)
    close(s->wakeup_pipe[(signed long int)1]);

  avahi_free((void *)s);
}

// avahi_simple_poll_get
// file ../avahi-common/simple-watch.h line 45
const struct AvahiPoll * avahi_simple_poll_get(struct AvahiSimplePoll *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  return &s->api;
}

// avahi_simple_poll_iterate
// file simple-watch.c line 596
signed int avahi_simple_poll_iterate(struct AvahiSimplePoll *s, signed int timeout)
{
  signed int r;
  r=avahi_simple_poll_prepare(s, timeout);
  if(!(r == 0))
    return r;

  else
  {
    r=avahi_simple_poll_run(s);
    if(!(r == 0))
      return r;

    else
    {
      r=avahi_simple_poll_dispatch(s);
      if(!(r == 0))
        return r;

      else
        return 0;
    }
  }
}

// avahi_simple_poll_loop
// file ../avahi-common/simple-watch.h line 78
signed int avahi_simple_poll_loop(struct AvahiSimplePoll *s)
{
  signed int r;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    r=avahi_simple_poll_iterate(s, -1);
    if(!(r == 0))
    {
      if(r >= 0)
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value___errno_location$1=__errno_location();
        tmp_if_expr$2 = *return_value___errno_location$1 != 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
        return r;

    }

  }
  while((_Bool)1);
}

// avahi_simple_poll_new
// file ../avahi-common/simple-watch.h line 37
struct AvahiSimplePoll * avahi_simple_poll_new(void)
{
  struct AvahiSimplePoll *s;
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link2$link1((unsigned int)1, sizeof(struct AvahiSimplePoll) /*160ul*/ );
  s = (struct AvahiSimplePoll *)return_value_avahi_new_internal$1;
  if(s == ((struct AvahiSimplePoll *)NULL))
    return (struct AvahiSimplePoll *)(void *)0;

  else
  {
    signed int return_value_pipe$2;
    return_value_pipe$2=pipe(s->wakeup_pipe);
    if(!(return_value_pipe$2 >= 0))
    {
      avahi_free((void *)s);
      return (struct AvahiSimplePoll *)(void *)0;
    }

    else
    {
      set_nonblock$link1(s->wakeup_pipe[(signed long int)0]);
      set_nonblock$link1(s->wakeup_pipe[(signed long int)1]);
      s->api.userdata = (void *)s;
      s->api.watch_new = watch_new;
      s->api.watch_free = watch_free;
      s->api.watch_update = watch_update;
      s->api.watch_get_events = watch_get_events;
      s->api.timeout_new = timeout_new;
      s->api.timeout_free = timeout_free;
      s->api.timeout_update = timeout_update;
      s->pollfds = (struct pollfd *)(void *)0;
      s->n_pollfds = 0;
      s->max_pollfds = s->n_pollfds;
      s->rebuild_pollfds = 1;
      s->quit = 0;
      s->n_watches = 0;
      s->events_valid = 0;
      s->watch_req_cleanup = 0;
      s->timeout_req_cleanup = 0;
      s->prepared_timeout = 0;
      s->state = (enum anonymous$10)STATE_INIT;
      s->wakeup_issued = 0;
      avahi_simple_poll_set_func(s, (signed int (*)(struct pollfd *, unsigned int, signed int, void *))(void *)0, (void *)0);
      do
        s->watches = (struct AvahiWatch *)(void *)0;
      while((_Bool)0);
      do
        s->timeouts = (struct AvahiTimeout *)(void *)0;
      while((_Bool)0);
      return s;
    }
  }
}

// avahi_simple_poll_prepare
// file simple-watch.c line 450
signed int avahi_simple_poll_prepare(struct AvahiSimplePoll *s, signed int timeout)
{
  struct AvahiTimeout *next_timeout;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  _Bool tmp_if_expr$1;
  if((signed int)s->state == STATE_INIT)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)s->state == STATE_DISPATCHED ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)s->state == STATE_FAILURE ? (_Bool)1 : (_Bool)0;
  /* assertion s->state == STATE_INIT || s->state == STATE_DISPATCHED || s->state == STATE_FAILURE */
  assert(tmp_if_expr$2);
  s->state = (enum anonymous$10)STATE_PREPARING;
  clear_wakeup(s);
  if(!(s->watch_req_cleanup == 0))
    cleanup_watches(s, 0);

  if(!(s->timeout_req_cleanup == 0))
    cleanup_timeouts(s, 0);

  signed int return_value_rebuild$3;
  if(!(s->quit == 0))
  {
    s->state = (enum anonymous$10)STATE_QUIT;
    return 1;
  }

  else
    if(!(s->rebuild_pollfds == 0))
    {
      return_value_rebuild$3=rebuild(s);
      if(return_value_rebuild$3 >= 0)
        goto __CPROVER_DUMP_L8;

      s->state = (enum anonymous$10)STATE_FAILURE;
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      next_timeout=find_next_timeout(s);
      if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
      {
        struct timeval now;
        signed int t;
        signed long int usec;
        if(next_timeout->expiry.tv_sec == 0l)
        {
          if(!(next_timeout->expiry.tv_usec == 0l))
            goto __CPROVER_DUMP_L9;

          timeout = 0;
        }

        else
        {

        __CPROVER_DUMP_L9:
          ;
          gettimeofday(&now, (struct timezone *)(void *)0);
          usec=avahi_timeval_diff(&next_timeout->expiry, &now);
          if(!(usec >= 1l))
            timeout = 0;

          else
          {
            t = (signed int)(usec / (signed long int)1000) + 1;
            if(!(t >= timeout) || !(timeout >= 0))
              timeout = t;

          }
        }
      }


    finish:
      ;
      s->prepared_timeout = timeout;
      s->state = (enum anonymous$10)STATE_PREPARED;
      return 0;
    }
}

// avahi_simple_poll_quit
// file ../avahi-common/simple-watch.h line 60
void avahi_simple_poll_quit(struct AvahiSimplePoll *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  s->quit = 1;
  avahi_simple_poll_wakeup(s);
}

// avahi_simple_poll_run
// file simple-watch.c line 518
signed int avahi_simple_poll_run(struct AvahiSimplePoll *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  _Bool tmp_if_expr$1;
  if((signed int)s->state == STATE_PREPARED)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)s->state == STATE_FAILURE ? (_Bool)1 : (_Bool)0;
  /* assertion s->state == STATE_PREPARED || s->state == STATE_FAILURE */
  assert(tmp_if_expr$1);
  s->state = (enum anonymous$10)STATE_RUNNING;
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = 0;
  signed int return_value;
  return_value=s->poll_func(s->pollfds, (unsigned int)s->n_pollfds, s->prepared_timeout, s->poll_func_userdata);
  if(!(return_value >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    s->state = (enum anonymous$10)STATE_FAILURE;
    return -1;
  }

  s->events_valid = 1;
  s->state = (enum anonymous$10)STATE_RAN;
  return 0;
}

// avahi_simple_poll_set_func
// file simple-watch.c line 630
void avahi_simple_poll_set_func(struct AvahiSimplePoll *s, signed int (*func)(struct pollfd *, unsigned int, signed int, void *), void *userdata)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  s->poll_func = func != ((signed int (*)(struct pollfd *, unsigned int, signed int, void *))NULL) ? func : system_poll;
  s->poll_func_userdata = func != ((signed int (*)(struct pollfd *, unsigned int, signed int, void *))NULL) ? userdata : (void *)0;
  avahi_simple_poll_wakeup(s);
}

// avahi_simple_poll_wakeup
// file simple-watch.c line 97
void avahi_simple_poll_wakeup(struct AvahiSimplePoll *s)
{
  char c = (char)87;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  write(s->wakeup_pipe[(signed long int)1], (const void *)&c, sizeof(char) /*1ul*/ );
  s->wakeup_issued = 1;
}

// avahi_strdup
// file ../avahi-common/malloc.h line 66
char * avahi_strdup(const char *s)
{
  char *r;
  unsigned long int size;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    size=strlen(s);
    void *return_value_avahi_malloc$1;
    return_value_avahi_malloc$1=avahi_malloc(size + (unsigned long int)1);
    r = (char *)return_value_avahi_malloc$1;
    if(r == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)r, (const void *)s, size + (unsigned long int)1);
      return r;
    }
  }
}

// avahi_strdup_printf
// file malloc.c line 235
char * avahi_strdup_printf(const char *fmt, ...)
{
  char *s;
  void **ap;
  /* assertion fmt */
  assert(fmt != ((const char *)NULL));
  ap = (void **)&fmt;
  s=avahi_strdup_vprintf(fmt, ap);
  ap = ((void **)NULL);
  return s;
}

// avahi_strdup_vprintf
// file malloc.c line 200
char * avahi_strdup_vprintf(const char *fmt, void **ap)
{
  unsigned long int len = (unsigned long int)80;
  char *buf;
  /* assertion fmt */
  assert(fmt != ((const char *)NULL));
  void *return_value_avahi_malloc$1;
  return_value_avahi_malloc$1=avahi_malloc(len);
  buf = (char *)return_value_avahi_malloc$1;
  if(buf == ((char *)NULL))
    return (char *)(void *)0;

  else
    do
    {
      signed int n;
      char *nbuf;
      void **ap2 = (void **)ap;
      n=vsnprintf(buf, len, fmt, ap2);
      ap2 = ((void **)NULL);
      if(n >= 0 && !(n >= (signed int)len))
        return buf;

      if(n >= 0)
        len = (unsigned long int)(n + 1);

      else
        len = len * (unsigned long int)2;
      void *return_value_avahi_realloc$2;
      return_value_avahi_realloc$2=avahi_realloc((void *)buf, len);
      nbuf = (char *)return_value_avahi_realloc$2;
      if(nbuf == ((char *)NULL))
      {
        avahi_free((void *)buf);
        return (char *)(void *)0;
      }

      buf = nbuf;
    }
    while((_Bool)1);
}

// avahi_strerror
// file ../avahi-common/error.h line 103
const char * avahi_strerror(signed int error)
{
  const char * const msg[54l] = { "OK", "Operation failed", "Bad state", "Invalid host name", "Invalid domain name", "No suitable network protocol available",
    "Invalid DNS TTL", "Resource record key is pattern", "Local name collision", "Invalid record", "Invalid service name", "Invalid service type", "Invalid port number", "Invalid record key", "Invalid address", "Timeout reached", "Too many clients", "Too many objects", "Too many entries", "OS Error", "Access denied", "Invalid operation", "An unexpected D-Bus error occurred", "Daemon connection failed", "Memory exhausted", "The object passed in was not valid", "Daemon not running", "Invalid interface index", "Invalid protocol specification", "Invalid flags", "Not found", "Invalid configuration", "Version mismatch", "Invalid service subtype", "Invalid packet", "Invalid DNS return code", "DNS failure: FORMERR", "DNS failure: SERVFAIL", "DNS failure: NXDOMAIN", "DNS failure: NOTIMP", "DNS failure: REFUSED", "DNS failure: YXDOMAIN", "DNS failure: YXRRSET", "DNS failure: NXRRSET", "DNS failure: NOTAUTH", "DNS failure: NOTZONE", "Invalid RDATA", "Invalid DNS type", "Invalid DNS class", "Not supported", "Not permitted", "Invalid argument", "Is empty", "The requested operation is invalid because redundant" };
  avahi_init_i18n();
  char *return_value_dgettext$1;
  if(-error >= 54 || !(-error >= 0))
  {
    return_value_dgettext$1=dgettext("avahi", "Invalid Error Code");
    return return_value_dgettext$1;
  }

  else
  {
    char *return_value_dgettext$2;
    return_value_dgettext$2=dgettext("avahi", msg[(signed long int)-error]);
    return return_value_dgettext$2;
  }
}

// avahi_string_list_add
// file ../avahi-common/strlst.h line 73
struct AvahiStringList * avahi_string_list_add(struct AvahiStringList *l, const char *text)
{
  /* assertion text */
  assert(text != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(text);
  struct AvahiStringList *return_value_avahi_string_list_add_arbitrary$2;
  return_value_avahi_string_list_add_arbitrary$2=avahi_string_list_add_arbitrary(l, (const unsigned char *)text, return_value_strlen$1);
  return return_value_avahi_string_list_add_arbitrary$2;
}

// avahi_string_list_add_anonymous
// file strlst.c line 34
struct AvahiStringList * avahi_string_list_add_anonymous(struct AvahiStringList *l, unsigned long int size)
{
  struct AvahiStringList *n;
  void *return_value_avahi_malloc$1;
  return_value_avahi_malloc$1=avahi_malloc(sizeof(struct AvahiStringList) /*24ul*/  + size);
  n = (struct AvahiStringList *)return_value_avahi_malloc$1;
  if(n == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    n->next = l;
    n->size = size;
    n->text[(signed long int)size] = (unsigned char)0;
    return n;
  }
}

// avahi_string_list_add_arbitrary
// file ../avahi-common/strlst.h line 85
struct AvahiStringList * avahi_string_list_add_arbitrary(struct AvahiStringList *l, const unsigned char *text, unsigned long int size)
{
  struct AvahiStringList *n;
  /* assertion size == 0 || text */
  assert(size == (unsigned long int)0 || text != ((const unsigned char *)NULL));
  n=avahi_string_list_add_anonymous(l, size);
  if(n == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    if(size >= 1ul)
      memcpy((void *)n->text, (const void *)text, size);

    return n;
  }
}

// avahi_string_list_add_many
// file strlst.c line 255
struct AvahiStringList * avahi_string_list_add_many(struct AvahiStringList *r, ...)
{
  void **va = (void **)&r;
  r=avahi_string_list_add_many_va(r, va);
  va = ((void **)NULL);
  return r;
}

// avahi_string_list_add_many_va
// file strlst.c line 265
struct AvahiStringList * avahi_string_list_add_many_va(struct AvahiStringList *r, __builtin_va_list va)
{
  const char *txt;
  do
  {
    txt=va_arg(va, __typeof__(txt));
    if(txt == ((const char *)NULL))
      break;

    r=avahi_string_list_add(r, txt);
  }
  while((_Bool)1);
  return r;
}

// avahi_string_list_add_pair
// file strlst.c line 395
struct AvahiStringList * avahi_string_list_add_pair(struct AvahiStringList *l, const char *key, const char *value)
{
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct AvahiStringList *return_value_avahi_string_list_add_printf$1;
  struct AvahiStringList *return_value_avahi_string_list_add$2;
  if(!(value == ((const char *)NULL)))
  {
    return_value_avahi_string_list_add_printf$1=avahi_string_list_add_printf(l, "%s=%s", key, value);
    return return_value_avahi_string_list_add_printf$1;
  }

  else
  {
    return_value_avahi_string_list_add$2=avahi_string_list_add(l, key);
    return return_value_avahi_string_list_add$2;
  }
}

// avahi_string_list_add_pair_arbitrary
// file strlst.c line 404
struct AvahiStringList * avahi_string_list_add_pair_arbitrary(struct AvahiStringList *l, const char *key, const unsigned char *value, unsigned long int size)
{
  unsigned long int n;
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct AvahiStringList *return_value_avahi_string_list_add$1;
  if(value == ((const unsigned char *)NULL))
  {
    return_value_avahi_string_list_add$1=avahi_string_list_add(l, key);
    return return_value_avahi_string_list_add$1;
  }

  else
  {
    n=strlen(key);
    l=avahi_string_list_add_anonymous(l, n + (unsigned long int)1 + size);
    if(l == ((struct AvahiStringList *)NULL))
      return (struct AvahiStringList *)(void *)0;

    else
    {
      memcpy((void *)l->text, (const void *)key, n);
      l->text[(signed long int)n] = (unsigned char)61;
      memcpy((void *)(l->text + (signed long int)n + (signed long int)1), (const void *)value, size);
      return l;
    }
  }
}

// avahi_string_list_add_printf
// file strlst.c line 366
struct AvahiStringList * avahi_string_list_add_printf(struct AvahiStringList *l, const char *format, ...)
{
  void **va;
  /* assertion format */
  assert(format != ((const char *)NULL));
  va = (void **)&format;
  l=avahi_string_list_add_vprintf(l, format, va);
  va = ((void **)NULL);
  return l;
}

// avahi_string_list_add_vprintf
// file strlst.c line 326
struct AvahiStringList * avahi_string_list_add_vprintf(struct AvahiStringList *l, const char *format, void **va)
{
  unsigned long int len = (unsigned long int)80;
  struct AvahiStringList *r;
  /* assertion format */
  assert(format != ((const char *)NULL));
  void *return_value_avahi_malloc$1;
  return_value_avahi_malloc$1=avahi_malloc(sizeof(struct AvahiStringList) /*24ul*/  + len);
  r = (struct AvahiStringList *)return_value_avahi_malloc$1;
  if(r == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    do
    {
      signed int n;
      struct AvahiStringList *nr;
      void **va2 = (void **)va;
      n=vsnprintf((char *)r->text, len, format, va2);
      va2 = ((void **)NULL);
      if(n >= 0 && !(n >= (signed int)len))
        break;

      if(n >= 0)
        len = (unsigned long int)(n + 1);

      else
        len = len * (unsigned long int)2;
      void *return_value_avahi_realloc$2;
      return_value_avahi_realloc$2=avahi_realloc((void *)r, sizeof(struct AvahiStringList) /*24ul*/  + len);
      nr = (struct AvahiStringList *)return_value_avahi_realloc$2;
      if(nr == ((struct AvahiStringList *)NULL))
      {
        avahi_free((void *)r);
        return (struct AvahiStringList *)(void *)0;
      }

      r = nr;
    }
    while((_Bool)1);
    r->next = l;
    r->size=strlen((char *)r->text);
    return r;
  }
}

// avahi_string_list_copy
// file strlst.c line 293
struct AvahiStringList * avahi_string_list_copy(const struct AvahiStringList *l)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  for( ; !(l == ((const struct AvahiStringList *)NULL)); l = l->next)
  {
    r=avahi_string_list_add_arbitrary(r, l->text, l->size);
    if(r == ((struct AvahiStringList *)NULL))
    {
      avahi_string_list_free(r);
      return (struct AvahiStringList *)(void *)0;
    }

  }
  struct AvahiStringList *return_value_avahi_string_list_reverse$1;
  return_value_avahi_string_list_reverse$1=avahi_string_list_reverse(r);
  return return_value_avahi_string_list_reverse$1;
}

// avahi_string_list_equal
// file strlst.c line 235
signed int avahi_string_list_equal(const struct AvahiStringList *a, const struct AvahiStringList *b)
{
  signed int return_value_memcmp$1;
  while((_Bool)1)
  {
    if(a == ((const struct AvahiStringList *)NULL) && b == ((const struct AvahiStringList *)NULL))
      return 1;

    if(a == ((const struct AvahiStringList *)NULL) || b == ((const struct AvahiStringList *)NULL))
      return 0;

    if(!(a->size == b->size))
      return 0;

    if(!(a->size == 0ul))
    {
      return_value_memcmp$1=memcmp((const void *)a->text, (const void *)b->text, a->size);
      if(!(return_value_memcmp$1 == 0))
        return 0;

    }

    a = a->next;
    b = b->next;
  }
}

// avahi_string_list_find
// file strlst.c line 378
struct AvahiStringList * avahi_string_list_find(struct AvahiStringList *l, const char *key)
{
  unsigned long int n;
  /* assertion key */
  assert(key != ((const char *)NULL));
  n=strlen(key);
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = l->next)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp((char *)l->text, key);
    if(return_value_strcasecmp$1 == 0)
      return l;

    signed int return_value_strncasecmp$2;
    return_value_strncasecmp$2=strncasecmp((char *)l->text, key, n);
    if(return_value_strncasecmp$2 == 0)
    {
      if((signed int)l->text[(signed long int)n] == 61)
        return l;

    }

  }
  return (struct AvahiStringList *)(void *)0;
}

// avahi_string_list_free
// file ../avahi-common/strlst.h line 64
void avahi_string_list_free(struct AvahiStringList *l)
{
  struct AvahiStringList *n;
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = n)
  {
    n = l->next;
    avahi_free((void *)l);
  }
}

// avahi_string_list_get_next
// file strlst.c line 469
struct AvahiStringList * avahi_string_list_get_next(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->next;
}

// avahi_string_list_get_pair
// file strlst.c line 423
signed int avahi_string_list_get_pair(struct AvahiStringList *l, char **key, char **value, unsigned long int *size)
{
  char *e;
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  void *return_value_memchr$2;
  return_value_memchr$2=memchr((const void *)l->text, 61, l->size);
  e = (char *)return_value_memchr$2;
  if(e == ((char *)NULL))
  {
    if(!(key == ((char **)NULL)))
    {
      *key=avahi_strdup((char *)l->text);
      if(*key == ((char *)NULL))
        return -1;

    }

    if(!(value == ((char **)NULL)))
      *value = (char *)(void *)0;

    if(!(size == ((unsigned long int *)NULL)))
      *size = (unsigned long int)0;

  }

  else
  {
    unsigned long int n;
    if(!(key == ((char **)NULL)))
    {
      *key=avahi_strndup((char *)l->text, (unsigned long int)(e - (char *)l->text));
      if(*key == ((char *)NULL))
        return -1;

    }

    e = e + 1l;
    n = l->size - (unsigned long int)(e - (char *)l->text);
    if(!(value == ((char **)NULL)))
    {
      void *return_value_avahi_memdup$1;
      return_value_avahi_memdup$1=avahi_memdup((const void *)e, n + (unsigned long int)1);
      *value = (char *)return_value_avahi_memdup$1;
      if(*value == ((char *)NULL))
      {
        if(!(key == ((char **)NULL)))
          avahi_free((void *)*key);

        return -1;
      }

      (*value)[(signed long int)n] = (char)0;
    }

    if(!(size == ((unsigned long int *)NULL)))
      *size = n;

  }
  return 0;
}

// avahi_string_list_get_service_cookie
// file strlst.c line 484
unsigned int avahi_string_list_get_service_cookie(struct AvahiStringList *l)
{
  struct AvahiStringList *f;
  char *value = (char *)(void *)0;
  char *end = (char *)(void *)0;
  unsigned int ret;
  f=avahi_string_list_find(l, "org.freedesktop.Avahi.cookie");
  if(f == ((struct AvahiStringList *)NULL))
    return (unsigned int)0;

  else
  {
    signed int return_value_avahi_string_list_get_pair$1;
    return_value_avahi_string_list_get_pair$1=avahi_string_list_get_pair(f, (char **)(void *)0, &value, (unsigned long int *)(void *)0);
    if(value == ((char *)NULL) || !(return_value_avahi_string_list_get_pair$1 >= 0))
      return (unsigned int)0;

    else
    {
      signed long long int return_value_strtoll$2;
      return_value_strtoll$2=strtoll(value, &end, 0);
      ret = (unsigned int)return_value_strtoll$2;
      if(!(*value == 0))
      {
        if(end == ((char *)NULL))
          goto __CPROVER_DUMP_L3;

        if((signed int)*end == 0)
          goto __CPROVER_DUMP_L3;

        avahi_free((void *)value);
        return (unsigned int)0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        avahi_free((void *)value);
        return ret;
      }
    }
  }
}

// avahi_string_list_get_size
// file strlst.c line 479
unsigned long int avahi_string_list_get_size(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->size;
}

// avahi_string_list_get_text
// file strlst.c line 474
unsigned char * avahi_string_list_get_text(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->text;
}

// avahi_string_list_length
// file strlst.c line 317
unsigned int avahi_string_list_length(const struct AvahiStringList *l)
{
  unsigned int n = (unsigned int)0;
  for( ; !(l == ((const struct AvahiStringList *)NULL)); l = l->next)
    n = n + 1u;
  return n;
}

// avahi_string_list_new
// file strlst.c line 274
struct AvahiStringList * avahi_string_list_new(const char *txt, ...)
{
  void **va;
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  if(!(txt == ((const char *)NULL)))
  {
    r=avahi_string_list_add(r, txt);
    va = (void **)&txt;
    r=avahi_string_list_add_many_va(r, va);
    va = ((void **)NULL);
  }

  return r;
}

// avahi_string_list_new_from_array
// file strlst.c line 305
struct AvahiStringList * avahi_string_list_new_from_array(const char **array, signed int length)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  signed int i;
  /* assertion array */
  assert(array != ((const char **)NULL));
  i = 0;
  signed int tmp_if_expr$1;
  do
  {
    if(length >= 0)
      tmp_if_expr$1 = (signed int)(i < length);

    else
      tmp_if_expr$1 = (signed int)!(!(array[(signed long int)i] != ((const char *)NULL)));
    if(tmp_if_expr$1 == 0)
      break;

    r=avahi_string_list_add(r, array[(signed long int)i]);
    i = i + 1;
  }
  while((_Bool)1);
  return r;
}

// avahi_string_list_new_va
// file ../avahi-common/strlst.h line 55
struct AvahiStringList * avahi_string_list_new_va(void **va)
{
  struct AvahiStringList *return_value_avahi_string_list_add_many_va$1;
  return_value_avahi_string_list_add_many_va$1=avahi_string_list_add_many_va((struct AvahiStringList *)(void *)0, va);
  return return_value_avahi_string_list_add_many_va$1;
}

// avahi_string_list_parse
// file strlst.c line 69
signed int avahi_string_list_parse(const void *data, unsigned long int size, struct AvahiStringList **ret)
{
  const unsigned char *c;
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  /* assertion data */
  assert(data != NULL);
  /* assertion ret */
  assert(ret != ((struct AvahiStringList **)NULL));
  c = (const unsigned char *)data;
  const unsigned char *tmp_post$1;
  while(size >= 1ul)
  {
    unsigned long int k;
    tmp_post$1 = c;
    c = c + 1l;
    k = (unsigned long int)*tmp_post$1;
    size = size - 1ul;
    if(!(size >= k))
      goto fail;

    if(k >= 1ul)
    {
      struct AvahiStringList *n;
      n=avahi_string_list_add_arbitrary(r, c, k);
      if(n == ((struct AvahiStringList *)NULL))
        goto fail;

      r = n;
    }

    c = c + (signed long int)k;
    size = size - k;
  }
  *ret = r;
  return 0;

fail:
  ;
  avahi_string_list_free(r);
  return -1;
}

// avahi_string_list_reverse
// file ../avahi-common/strlst.h line 130
struct AvahiStringList * avahi_string_list_reverse(struct AvahiStringList *l)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  struct AvahiStringList *n;
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = n)
  {
    n = l->next;
    l->next = r;
    r = l;
  }
  return r;
}

// avahi_string_list_serialize
// file strlst.c line 168
unsigned long int avahi_string_list_serialize(struct AvahiStringList *l, void *data, unsigned long int size)
{
  unsigned long int used = (unsigned long int)0;
  unsigned char *tmp_post$1;
  if(!(data == NULL))
  {
    struct AvahiStringList *n;
    unsigned char *c;
    l=avahi_string_list_reverse(l);
    c = (unsigned char *)data;
    n = l;
    for( ; size >= 2ul && !(n == ((struct AvahiStringList *)NULL)); n = n->next)
    {
      unsigned long int avahi_string_list_serialize$$1$$1$$1$$1$$k = n->size;
      if(!(avahi_string_list_serialize$$1$$1$$1$$1$$k == 0ul))
      {
        if(avahi_string_list_serialize$$1$$1$$1$$1$$k >= 256ul)
          avahi_string_list_serialize$$1$$1$$1$$1$$k = (unsigned long int)255;

        if(!(size + 18446744073709551615ul >= avahi_string_list_serialize$$1$$1$$1$$1$$k))
          avahi_string_list_serialize$$1$$1$$1$$1$$k = size - (unsigned long int)1;

        tmp_post$1 = c;
        c = c + 1l;
        *tmp_post$1 = (unsigned char)avahi_string_list_serialize$$1$$1$$1$$1$$k;
        memcpy((void *)c, (const void *)n->text, avahi_string_list_serialize$$1$$1$$1$$1$$k);
        c = c + (signed long int)avahi_string_list_serialize$$1$$1$$1$$1$$k;
        used = used + (unsigned long int)1 + avahi_string_list_serialize$$1$$1$$1$$1$$k;
        size = size - ((unsigned long int)1 + avahi_string_list_serialize$$1$$1$$1$$1$$k);
      }

    }
    l=avahi_string_list_reverse(l);
    if(used == 0ul && size >= 1ul)
    {
      *((unsigned char *)data) = (unsigned char)0;
      used = (unsigned long int)1;
    }

  }

  else
  {
    struct AvahiStringList *avahi_string_list_serialize$$1$$2$$n = l;
    for( ; !(avahi_string_list_serialize$$1$$2$$n == ((struct AvahiStringList *)NULL)); avahi_string_list_serialize$$1$$2$$n = avahi_string_list_serialize$$1$$2$$n->next)
    {
      unsigned long int k = avahi_string_list_serialize$$1$$2$$n->size;
      if(!(k == 0ul))
      {
        if(k >= 256ul)
          k = (unsigned long int)255;

        used = used + (unsigned long int)1 + k;
      }

    }
    if(used == 0ul)
      used = (unsigned long int)1;

  }
  return used;
}

// avahi_string_list_to_string
// file strlst.c line 131
char * avahi_string_list_to_string(struct AvahiStringList *l)
{
  struct AvahiStringList *n;
  unsigned long int s = (unsigned long int)0;
  char *t;
  char *e;
  n = l;
  for( ; !(n == ((struct AvahiStringList *)NULL)); n = n->next)
  {
    if(!(n == l))
      s = s + 1ul;

    s = s + n->size + (unsigned long int)2;
  }
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link1$link1((unsigned int)(s + (unsigned long int)1), sizeof(char) /*1ul*/ );
  e = (char *)return_value_avahi_new_internal$1;
  t = e;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  if(t == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    l=avahi_string_list_reverse(l);
    n = l;
    for( ; !(n == ((struct AvahiStringList *)NULL)); n = n->next)
    {
      if(!(n == l))
      {
        tmp_post$2 = e;
        e = e + 1l;
        *tmp_post$2 = (char)32;
      }

      tmp_post$3 = e;
      e = e + 1l;
      *tmp_post$3 = (char)34;
      strncpy(e, (char *)n->text, n->size);
      e[(signed long int)n->size] = (char)0;
      e=strchr(e, 0);
      tmp_post$4 = e;
      e = e + 1l;
      *tmp_post$4 = (char)34;
      /* assertion e */
      assert(e != ((char *)NULL));
    }
    l=avahi_string_list_reverse(l);
    *e = (char)0;
    return t;
  }
}

// avahi_strndup
// file malloc.c line 175
char * avahi_strndup(const char *s, unsigned long int max)
{
  char *r;
  unsigned long int size;
  const char *p;
  _Bool tmp_if_expr$1;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = s;
    size = (unsigned long int)0;
    do
    {
      if(!(size >= max))
        tmp_if_expr$1 = *p != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      p = p + 1l;
      size = size + 1ul;
    }
    while((_Bool)1);
    void *return_value_avahi_new_internal$2;
    return_value_avahi_new_internal$2=avahi_new_internal$link5((unsigned int)(size + (unsigned long int)1), sizeof(char) /*1ul*/ );
    r = (char *)return_value_avahi_new_internal$2;
    if(r == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)r, (const void *)s, size);
      r[(signed long int)size] = (char)0;
      return r;
    }
  }
}

// avahi_threaded_poll_free
// file thread-watch.c line 107
void avahi_threaded_poll_free(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  _Bool tmp_if_expr$3;
  unsigned long int return_value_pthread_self$1;
  signed int return_value_pthread_equal$2;
  if(p->thread_running == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_pthread_self$1=pthread_self();
    return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
    tmp_if_expr$3 = !(return_value_pthread_equal$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr$3);
  if(!(p->thread_running == 0))
    avahi_threaded_poll_stop(p);

  if(!(p->simple_poll == ((struct AvahiSimplePoll *)NULL)))
    avahi_simple_poll_free(p->simple_poll);

  pthread_mutex_destroy(&p->mutex);
  avahi_free((void *)p);
}

// avahi_threaded_poll_get
// file thread-watch.c line 123
const struct AvahiPoll * avahi_threaded_poll_get(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  const struct AvahiPoll *return_value_avahi_simple_poll_get$1;
  return_value_avahi_simple_poll_get$1=avahi_simple_poll_get(p->simple_poll);
  return return_value_avahi_simple_poll_get$1;
}

// avahi_threaded_poll_lock
// file thread-watch.c line 170
void avahi_threaded_poll_lock(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  _Bool tmp_if_expr$3;
  unsigned long int return_value_pthread_self$1;
  signed int return_value_pthread_equal$2;
  if(p->thread_running == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_pthread_self$1=pthread_self();
    return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
    tmp_if_expr$3 = !(return_value_pthread_equal$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr$3);
  pthread_mutex_lock(&p->mutex);
}

// avahi_threaded_poll_new
// file thread-watch.c line 77
struct AvahiThreadedPoll * avahi_threaded_poll_new(void)
{
  struct AvahiThreadedPoll *p;
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link3$link1((unsigned int)1, sizeof(struct AvahiThreadedPoll) /*64ul*/ );
  p = (struct AvahiThreadedPoll *)return_value_avahi_new_internal$1;
  if(!(p == ((struct AvahiThreadedPoll *)NULL)))
  {
    p->simple_poll=avahi_simple_poll_new();
    if(p->simple_poll == ((struct AvahiSimplePoll *)NULL))
      goto fail;

    pthread_mutex_init(&p->mutex, (const union anonymous$27 *)(void *)0);
    avahi_simple_poll_set_func(p->simple_poll, poll_func, (void *)&p->mutex);
    p->thread_running = 0;
    return p;
  }

  else
  {

  fail:
    ;
    if(!(p == ((struct AvahiThreadedPoll *)NULL)))
    {
      if(!(p->simple_poll == ((struct AvahiSimplePoll *)NULL)))
      {
        avahi_simple_poll_free(p->simple_poll);
        pthread_mutex_destroy(&p->mutex);
      }

      avahi_free((void *)p);
    }

    return (struct AvahiThreadedPoll *)(void *)0;
  }
}

// avahi_threaded_poll_quit
// file thread-watch.c line 161
void avahi_threaded_poll_quit(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  signed int return_value_pthread_equal$2;
  return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
  /* assertion pthread_equal(pthread_self(), p->thread_id) */
  assert(return_value_pthread_equal$2 != 0);
  avahi_simple_poll_quit(p->simple_poll);
}

// avahi_threaded_poll_start
// file thread-watch.c line 129
signed int avahi_threaded_poll_start(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  /* assertion !p->thread_running */
  assert(!(p->thread_running != 0));
  signed int return_value_pthread_create$1;
  return_value_pthread_create$1=pthread_create(&p->thread_id, (const union pthread_attr_t *)(void *)0, thread, (void *)p);
  if(!(return_value_pthread_create$1 >= 0))
    return -1;

  else
  {
    p->thread_running = 1;
    return 0;
  }
}

// avahi_threaded_poll_stop
// file thread-watch.c line 142
signed int avahi_threaded_poll_stop(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  if(p->thread_running == 0)
    return -1;

  else
  {
    unsigned long int return_value_pthread_self$1;
    return_value_pthread_self$1=pthread_self();
    signed int return_value_pthread_equal$2;
    return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
    /* assertion !pthread_equal(pthread_self(), p->thread_id) */
    assert(!(return_value_pthread_equal$2 != 0));
    pthread_mutex_lock(&p->mutex);
    avahi_simple_poll_quit(p->simple_poll);
    pthread_mutex_unlock(&p->mutex);
    pthread_join(p->thread_id, (void **)(void *)0);
    p->thread_running = 0;
    return p->retval;
  }
}

// avahi_threaded_poll_unlock
// file thread-watch.c line 179
void avahi_threaded_poll_unlock(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  _Bool tmp_if_expr$3;
  unsigned long int return_value_pthread_self$1;
  signed int return_value_pthread_equal$2;
  if(p->thread_running == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_pthread_self$1=pthread_self();
    return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
    tmp_if_expr$3 = !(return_value_pthread_equal$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr$3);
  pthread_mutex_unlock(&p->mutex);
}

// avahi_timeval_add
// file timeval.c line 59
struct timeval * avahi_timeval_add(struct timeval *a, signed long int usec)
{
  signed long int u;
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  u = usec + a->tv_usec;
  if(!(u >= 0l))
  {
    a->tv_usec = (signed long int)((signed long int)1000000 + u % (signed long int)1000000);
    a->tv_sec = a->tv_sec + (signed long int)((signed long int)-1 + u / (signed long int)1000000);
  }

  else
  {
    a->tv_usec = (signed long int)(u % (signed long int)1000000);
    a->tv_sec = a->tv_sec + (signed long int)(u / (signed long int)1000000);
  }
  return a;
}

// avahi_timeval_compare
// file timeval.c line 30
signed int avahi_timeval_compare(struct timeval *a, struct timeval *b)
{
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  /* assertion b */
  assert(b != ((struct timeval *)NULL));
  if(!(a->tv_sec >= b->tv_sec))
    return -1;

  else
    if(!(b->tv_sec >= a->tv_sec))
      return 1;

    else
      if(!(a->tv_usec >= b->tv_usec))
        return -1;

      else
        if(!(b->tv_usec >= a->tv_usec))
          return 1;

        else
          return 0;
}

// avahi_timeval_diff
// file timeval.c line 49
signed long int avahi_timeval_diff(struct timeval *a, struct timeval *b)
{
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  /* assertion b */
  assert(b != ((struct timeval *)NULL));
  signed int return_value_avahi_timeval_compare$2;
  return_value_avahi_timeval_compare$2=avahi_timeval_compare(a, b);
  signed long int return_value_avahi_timeval_diff$1;
  if(!(return_value_avahi_timeval_compare$2 >= 0))
  {
    return_value_avahi_timeval_diff$1=avahi_timeval_diff(b, a);
    return -return_value_avahi_timeval_diff$1;
  }

  else
    return (((signed long int)a->tv_sec - b->tv_sec) * (signed long int)1000000 + a->tv_usec) - b->tv_usec;
}

// avahi_unescape_label
// file domain.c line 41
char * avahi_unescape_label(const char **name, char *dest, unsigned long int size)
{
  unsigned int i = (unsigned int)0;
  char *d;
  /* assertion dest */
  assert(dest != ((char *)NULL));
  /* assertion size > 0 */
  assert(size > (unsigned long int)0);
  /* assertion name */
  assert(name != ((const char **)NULL));
  d = dest;
  _Bool tmp_if_expr$8;
  char *tmp_post$1;
  const char *tmp_post$2;
  const unsigned short int **return_value___ctype_b_loc$7;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  char *tmp_post$6;
  char *tmp_post$9;
  const char *tmp_post$10;
  while((_Bool)1)
  {
    if((unsigned long int)i >= size)
      return (char *)(void *)0;

    if((signed int)*(*name) == 46)
    {
      *name = *name + 1l;
      break;
    }

    if((signed int)*(*name) == 0)
      break;

    if((signed int)*(*name) == 92)
    {
      *name = *name + 1l;
      if((signed int)*(*name) == 0)
        return (char *)(void *)0;

      else
      {
        if((signed int)*(*name) == 92)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)*(*name) == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
        {
          tmp_post$1 = d;
          d = d + 1l;
          tmp_post$2 = *name;
          *name = *name + 1l;
          *tmp_post$1 = *tmp_post$2;
          i = i + 1u;
        }

        else
        {
          return_value___ctype_b_loc$7=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*(*name)]) == 0))
          {
            signed int n;
            const unsigned short int **return_value___ctype_b_loc$3;
            return_value___ctype_b_loc$3=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)(*name)[1l]]) == 0)
              tmp_if_expr$5 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc$4=__ctype_b_loc();
              tmp_if_expr$5 = !(((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(*name)[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$5)
              return (char *)(void *)0;

            n = (signed int)(unsigned char)((signed int)*(*name) - 48) * 100 + (signed int)(unsigned char)((signed int)(*name)[(signed long int)1] - 48) * 10 + (signed int)(unsigned char)((signed int)(*name)[(signed long int)2] - 48);
            if(n == 0 || n >= 256)
              return (char *)(void *)0;

            tmp_post$6 = d;
            d = d + 1l;
            *tmp_post$6 = (char)n;
            i = i + 1u;
            *name = *name + (signed long int)3;
          }

          else
            return (char *)(void *)0;
        }
      }
    }

    else
    {
      tmp_post$9 = d;
      d = d + 1l;
      tmp_post$10 = *name;
      *name = *name + 1l;
      *tmp_post$9 = *tmp_post$10;
      i = i + 1u;
    }
  }
  /* assertion i < size */
  assert((unsigned long int)i < size);
  *d = (char)0;
  const char *return_value_avahi_utf8_valid$11;
  return_value_avahi_utf8_valid$11=avahi_utf8_valid(dest);
  if(return_value_avahi_utf8_valid$11 == ((const char *)NULL))
    return (char *)(void *)0;

  else
    return dest;
}

// avahi_utf8_valid
// file utf8.h line 29
const char * avahi_utf8_valid(const char *str)
{
  unsigned int val = (unsigned int)0;
  unsigned int min = (unsigned int)0;
  const char *p = str;
  for( ; !(*p == 0); p = p + 1l)
  {
    if((signed int)*((const unsigned char *)p) >= 128)
    {
      if((0xe0 & (signed int)*((const unsigned char *)p)) == 0xc0)
      {
        if((0x1e & (signed int)*((const unsigned char *)p)) == 0)
          goto error;

        p = p + 1l;
        if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
          goto error;

      }

      else
      {
        if((0xf0 & (signed int)*((const unsigned char *)p)) == 0xe0)
        {
          min = (unsigned int)(1 << 11);
          val = (unsigned int)((signed int)*((const unsigned char *)p) & 0x0f);
          goto TWO_REMAINING;
        }

        else
          if((0xf8 & (signed int)*((const unsigned char *)p)) == 0xf0)
          {
            min = (unsigned int)(1 << 16);
            val = (unsigned int)((signed int)*((const unsigned char *)p) & 0x07);
          }

          else
            goto error;
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);

      TWO_REMAINING:
        ;
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);
        if(!(val >= min))
          goto error;

        if((65534u & val) == 65534u || (0xFFFFF800 & val) == 55296u || val >= 1114112u || !(val >= 65008u) && val >= 64976u)
          goto error;

      }
      goto __CPROVER_DUMP_L13;

    error:
      ;
      return (const char *)(void *)0;
    }


  __CPROVER_DUMP_L13:
    ;
  }
  return str;
}

// avahi_xdg_config_open
// file xdg-config.h line 25
struct _IO_FILE * avahi_xdg_config_open(const char *filename)
{
  struct _IO_FILE *f;
  const char *e;
  const char *d;
  char fn[4096l];
  char *p = (char *)(void *)0;
  char buf[2048l];
  char *s = (char *)(void *)0;
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  e=getenv("XDG_CONFIG_HOME");
  _Bool tmp_if_expr$1;
  if(!(e == ((const char *)NULL)))
    tmp_if_expr$1 = *e != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    p = fn;
    snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", e, filename);
  }

  else
  {
    e=getenv("HOME");
    if(!(e == ((const char *)NULL)))
    {
      if(!(*e == 0))
      {
        p = fn;
        snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/.config/%s", e, filename);
      }

    }

  }
  signed int *return_value___errno_location$2;
  if(!(p == ((char *)NULL)))
  {
    f=fopen(p, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
      return f;

    else
    {
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 2))
        return (struct _IO_FILE *)(void *)0;

    }
  }

  d=getenv("XDG_CONFIG_DIRS");
  _Bool tmp_if_expr$3;
  if(d == ((const char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = !(*d != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    d = "/etc/xdg";

  snprintf(buf, sizeof(char [2048l]) /*2048ul*/ , "%s", d);
  e=strtok_r(buf, ":", &s);
  while(!(e == ((const char *)NULL)))
  {
    snprintf(fn, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", e, filename);
    f=fopen(fn, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
      return f;

    e=strtok_r((char *)(void *)0, ":", &s);
  }
  return (struct _IO_FILE *)(void *)0;
}

// check_version
// file client.c line 351
static signed int check_version(struct AvahiClient *client, signed int *ret_error)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  unsigned int version;
  signed int e = -24;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetAPIVersion");
  _Bool tmp_if_expr$14;
  unsigned int return_value_dbus_error_is_set$13;
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  _Bool tmp_if_expr$12;
  unsigned int return_value_dbus_error_is_set$11;
  if(!(message == ((struct DBusMessage *)NULL)))
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$14 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$13=dbus_error_is_set(&error);
      tmp_if_expr$14 = return_value_dbus_error_is_set$13 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$14)
    {
      char *version_str;
      unsigned int return_value_dbus_error_is_set$1;
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      if(return_value_dbus_error_is_set$1 == 0u)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_strcmp$2=strcmp(error.name, "org.freedesktop.DBus.Error.UnknownMethod");
        tmp_if_expr$3 = return_value_strcmp$2 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        goto fail;

      dbus_message_unref(message);
      if(!(reply == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply);

      dbus_error_free(&error);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetVersionString");
      if(message == ((struct DBusMessage *)NULL))
        goto fail;

      reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
      if(reply == ((struct DBusMessage *)NULL))
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        goto fail;

      unsigned int return_value_dbus_message_get_args$6;
      return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)115, &version_str, (signed int)0);
      if(return_value_dbus_message_get_args$6 == 0u)
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
        tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8)
        goto fail;

      signed int return_value_strcmp$9;
      return_value_strcmp$9=strcmp(version_str, "avahi 0.6");
      version = (unsigned int)(return_value_strcmp$9 == 0 ? 0x0201 : 0x0000);
    }

    else
    {
      unsigned int return_value_dbus_message_get_args$10;
      return_value_dbus_message_get_args$10=dbus_message_get_args(reply, &error, (signed int)117, &version, (signed int)0);
      if(return_value_dbus_message_get_args$10 == 0u)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$11=dbus_error_is_set(&error);
        tmp_if_expr$12 = return_value_dbus_error_is_set$11 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
        goto fail;

    }
    if(!((65280u & version) == 512u) || !((255u & version) >= 1u))
    {
      e = -32;
      goto fail;
    }

    dbus_message_unref(message);
    dbus_message_unref(reply);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$15;
    return_value_dbus_error_is_set$15=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$15 == 0u))
    {
      e=avahi_error_dbus_to_number(error.name);
      dbus_error_free(&error);
    }

    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = e;

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return e;
  }
}

// cleanup_timeouts
// file simple-watch.c line 304
static void cleanup_timeouts(struct AvahiSimplePoll *s, signed int all)
{
  struct AvahiTimeout *t;
  struct AvahiTimeout *next;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  t = s->timeouts;
  _Bool tmp_if_expr$1;
  for( ; !(t == ((struct AvahiTimeout *)NULL)); t = next)
  {
    next = t->timeouts_next;
    if(!(all == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = t->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      destroy_timeout(t);

  }
  s->timeout_req_cleanup = 0;
}

// cleanup_timeouts$link1
// file simple-watch.c line 304
static void cleanup_timeouts$link1(struct AvahiSimplePoll *s$link1, signed int all$link1)
{
  struct AvahiTimeout *t$link1;
  struct AvahiTimeout *next$link1;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll *)NULL));
  t$link1 = s$link1->timeouts;
  _Bool tmp_if_expr$1$link1;
  for( ; !(t$link1 == ((struct AvahiTimeout *)NULL)); t$link1 = next$link1)
  {
    next$link1 = t$link1->timeouts_next;
    if(!(all$link1 == 0))
      tmp_if_expr$1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1 = t$link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1)
      destroy_timeout$link1(t$link1);

  }
  s$link1->timeout_req_cleanup = 0;
}

// cleanup_watches
// file simple-watch.c line 230
static void cleanup_watches(struct AvahiSimplePoll *s, signed int all)
{
  struct AvahiWatch *w;
  struct AvahiWatch *next;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  w = s->watches;
  _Bool tmp_if_expr$1;
  for( ; !(w == ((struct AvahiWatch *)NULL)); w = next)
  {
    next = w->watches_next;
    if(!(all == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = w->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      destroy_watch(w);

  }
  s->timeout_req_cleanup = 0;
}

// cleanup_watches$link1
// file simple-watch.c line 230
static void cleanup_watches$link1(struct AvahiSimplePoll *s$link1, signed int all$link1)
{
  struct AvahiWatch *w$link1;
  struct AvahiWatch *next$link1;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll *)NULL));
  w$link1 = s$link1->watches;
  _Bool tmp_if_expr$1$link1;
  for( ; !(w$link1 == ((struct AvahiWatch *)NULL)); w$link1 = next$link1)
  {
    next$link1 = w$link1->watches_next;
    if(!(all$link1 == 0))
      tmp_if_expr$1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1 = w$link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1)
      destroy_watch$link1(w$link1);

  }
  s$link1->timeout_req_cleanup = 0;
}

// clear_wakeup
// file simple-watch.c line 105
static void clear_wakeup(struct AvahiSimplePoll *s)
{
  char c[10l];
  signed long int return_value_read$1;
  if(!(s->wakeup_issued == 0))
  {
    s->wakeup_issued = 0;
    do
    {
      return_value_read$1=read(s->wakeup_pipe[(signed long int)0], (void *)&c, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read$1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup$link1
// file simple-watch.c line 105
static void clear_wakeup$link1(struct AvahiSimplePoll *s$link1)
{
  char c$link1[10l];
  signed long int return_value_read$1$link1;
  if(!(s$link1->wakeup_issued == 0))
  {
    s$link1->wakeup_issued = 0;
    do
    {
      return_value_read$1$link1=read(s$link1->wakeup_pipe[(signed long int)0], (void *)&c$link1, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read$1$link1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// client_callback
// file avahi-publish.c line 150
static void client_callback(struct AvahiClient *c, enum anonymous$5 state, void *userdata)
{
  struct Config *config = (struct Config *)userdata;
  client = c;
  _Bool tmp_if_expr$9;
  signed int return_value_avahi_client_errno$8;
  signed int return_value_register_stuff$10;
  char *return_value_dgettext$11;
  char *return_value_dgettext$12;
  switch((signed int)state)
  {
    case AVAHI_CLIENT_FAILURE:
    {
      if(!(config->no_fail == 0))
      {
        return_value_avahi_client_errno$8=avahi_client_errno(c);
        tmp_if_expr$9 = return_value_avahi_client_errno$8 == -23 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        signed int error;
        char *return_value_dgettext$1;
        return_value_dgettext$1=dgettext("avahi", "Disconnected, reconnecting ...\n");
        fprintf(stderr, return_value_dgettext$1);
        avahi_client_free(client);
        client = (struct AvahiClient *)(void *)0;
        entry_group = (struct AvahiEntryGroup *)(void *)0;
        const struct AvahiPoll *return_value_avahi_simple_poll_get$4;
        return_value_avahi_simple_poll_get$4=avahi_simple_poll_get(simple_poll);
        client=avahi_client_new(return_value_avahi_simple_poll_get$4, (enum anonymous$11)AVAHI_CLIENT_NO_FAIL, client_callback, (void *)config, &error);
        if(client == ((struct AvahiClient *)NULL))
        {
          char *return_value_dgettext$2;
          return_value_dgettext$2=dgettext("avahi", "Failed to create client object: %s\n");
          const char *return_value_avahi_strerror$3;
          return_value_avahi_strerror$3=avahi_strerror(error);
          fprintf(stderr, return_value_dgettext$2, return_value_avahi_strerror$3);
          avahi_simple_poll_quit(simple_poll);
        }

      }

      else
      {
        char *return_value_dgettext$5;
        return_value_dgettext$5=dgettext("avahi", "Client failure, exiting: %s\n");
        signed int return_value_avahi_client_errno$6;
        return_value_avahi_client_errno$6=avahi_client_errno(c);
        const char *return_value_avahi_strerror$7;
        return_value_avahi_strerror$7=avahi_strerror(return_value_avahi_client_errno$6);
        fprintf(stderr, return_value_dgettext$5, return_value_avahi_strerror$7);
        avahi_simple_poll_quit(simple_poll);
      }
      break;
    }
    case AVAHI_CLIENT_S_RUNNING:
    {
      return_value_register_stuff$10=register_stuff(config);
      if(!(return_value_register_stuff$10 >= 0))
        avahi_simple_poll_quit(simple_poll);

      break;
    }
    case AVAHI_CLIENT_S_COLLISION:
      if(!(config->verbose == 0))
      {
        return_value_dgettext$11=dgettext("avahi", "Host name conflict\n");
        fprintf(stderr, return_value_dgettext$11);
      }

    case AVAHI_CLIENT_S_REGISTERING:
    {
      if(!(entry_group == ((struct AvahiEntryGroup *)NULL)))
      {
        avahi_entry_group_free(entry_group);
        entry_group = (struct AvahiEntryGroup *)(void *)0;
      }

      break;
    }
    case AVAHI_CLIENT_CONNECTING:
      if(!(config->verbose == 0))
      {
        return_value_dgettext$12=dgettext("avahi", "Waiting for daemon ...\n");
        fprintf(stderr, return_value_dgettext$12);
      }

  }
}

// client_set_state
// file client.c line 58
static void client_set_state(struct AvahiClient *client, enum anonymous$5 state)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  if(!(client->state == state))
  {
    client->state = state;
    switch((signed int)client->state)
    {
      case AVAHI_CLIENT_FAILURE:
        if(!(client->bus == ((struct DBusConnection *)NULL)))
        {
          dbus_connection_close(client->bus);
          dbus_connection_unref(client->bus);
          client->bus = (struct DBusConnection *)(void *)0;
        }

      case AVAHI_CLIENT_S_COLLISION:

      case AVAHI_CLIENT_S_REGISTERING:
      {
        avahi_free((void *)client->host_name);
        avahi_free((void *)client->host_name_fqdn);
        avahi_free((void *)client->domain_name);
        client->host_name = (char *)(void *)0;
        client->host_name_fqdn = (char *)(void *)0;
        client->domain_name = (char *)(void *)0;
      }
      case AVAHI_CLIENT_S_RUNNING:

      case AVAHI_CLIENT_CONNECTING:

      default:
        if(!(client->callback == ((void (*)(struct AvahiClient *, enum anonymous$5, void *))NULL)))
          client->callback(client, state, client->userdata);

    }
  }

}

// close_pipe_fds
// file sigint.c line 58
static void close_pipe_fds(void)
{
  if(pipe_fds[0l] >= 0)
    close(pipe_fds[(signed long int)0]);

  if(pipe_fds[1l] >= 0)
    close(pipe_fds[(signed long int)1]);

  pipe_fds[(signed long int)1] = -1;
  pipe_fds[(signed long int)0] = pipe_fds[(signed long int)1];
}

// connection_data_ref
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous$13 * connection_data_ref(struct anonymous$13 *d)
{
  /* assertion d */
  assert(d != ((struct anonymous$13 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d->ref >= 1);
  d->ref = d->ref + 1;
  return d;
}

// connection_data_unref
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref(struct anonymous$13 *d)
{
  /* assertion d */
  assert(d != ((struct anonymous$13 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d->ref >= 1);
  d->ref = d->ref - 1;
  if(!(d->ref >= 1))
  {
    d->poll_api->timeout_free(d->dispatch_timeout);
    avahi_free((void *)d);
  }

}

// defer_timeout_callback
// file browser.c line 83
static void defer_timeout_callback(struct AvahiTimeout *t, void *userdata)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)userdata;
  struct AvahiStringList *l;
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  db->client->poll_api->timeout_free(db->defer_timeout);
  db->defer_timeout = (struct AvahiTimeout *)(void *)0;
  domain_browser_ref(db);
  l = db->static_browse_domains;
  if(!(l == ((struct AvahiStringList *)NULL)))
  {
    if(db->ref >= 2)
    {
      db->callback(db, -1, -1, (enum anonymous$3)AVAHI_BROWSER_NEW, (char *)l->text, (enum anonymous$4)AVAHI_LOOKUP_RESULT_STATIC, db->userdata);
      l = l->next;
    }

  }

  avahi_domain_browser_free(db);
}

// destroy_timeout
// file simple-watch.c line 296
static void destroy_timeout(struct AvahiTimeout *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  do
  {
    struct AvahiTimeout **_head = &t->simple_poll->timeouts;
    struct AvahiTimeout *_item = t;
    /* assertion _item */
    assert(_item != ((struct AvahiTimeout *)NULL));
    if(!(_item->timeouts_next == ((struct AvahiTimeout *)NULL)))
      _item->timeouts_next->timeouts_prev = _item->timeouts_prev;

    if(!(_item->timeouts_prev == ((struct AvahiTimeout *)NULL)))
      _item->timeouts_prev->timeouts_next = _item->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->timeouts_next;
    }
    _item->timeouts_prev = (struct AvahiTimeout *)(void *)0;
    _item->timeouts_next = _item->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t);
}

// destroy_timeout$link1
// file simple-watch.c line 296
static void destroy_timeout$link1(struct AvahiTimeout *t$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout *)NULL));
  do
  {
    struct AvahiTimeout **_head$link1 = &t$link1->simple_poll->timeouts;
    struct AvahiTimeout *_item$link1 = t$link1;
    /* assertion _item */
    assert(_item$link1 != ((struct AvahiTimeout *)NULL));
    if(!(_item$link1->timeouts_next == ((struct AvahiTimeout *)NULL)))
      _item$link1->timeouts_next->timeouts_prev = _item$link1->timeouts_prev;

    if(!(_item$link1->timeouts_prev == ((struct AvahiTimeout *)NULL)))
      _item$link1->timeouts_prev->timeouts_next = _item$link1->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link1 == _item$link1);
      *_head$link1 = _item$link1->timeouts_next;
    }
    _item$link1->timeouts_prev = (struct AvahiTimeout *)(void *)0;
    _item$link1->timeouts_next = _item$link1->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t$link1);
}

// destroy_watch
// file simple-watch.c line 218
static void destroy_watch(struct AvahiWatch *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  remove_pollfd(w);
  do
  {
    struct AvahiWatch **_head = &w->simple_poll->watches;
    struct AvahiWatch *_item = w;
    /* assertion _item */
    assert(_item != ((struct AvahiWatch *)NULL));
    if(!(_item->watches_next == ((struct AvahiWatch *)NULL)))
      _item->watches_next->watches_prev = _item->watches_prev;

    if(!(_item->watches_prev == ((struct AvahiWatch *)NULL)))
      _item->watches_prev->watches_next = _item->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->watches_next;
    }
    _item->watches_prev = (struct AvahiWatch *)(void *)0;
    _item->watches_next = _item->watches_prev;
  }
  while((_Bool)0);
  if(w->dead == 0)
    w->simple_poll->n_watches = w->simple_poll->n_watches - 1;

  avahi_free((void *)w);
}

// destroy_watch$link1
// file simple-watch.c line 218
static void destroy_watch$link1(struct AvahiWatch *w$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch *)NULL));
  remove_pollfd$link1(w$link1);
  do
  {
    struct AvahiWatch **_head$link1 = &w$link1->simple_poll->watches;
    struct AvahiWatch *_item$link1 = w$link1;
    /* assertion _item */
    assert(_item$link1 != ((struct AvahiWatch *)NULL));
    if(!(_item$link1->watches_next == ((struct AvahiWatch *)NULL)))
      _item$link1->watches_next->watches_prev = _item$link1->watches_prev;

    if(!(_item$link1->watches_prev == ((struct AvahiWatch *)NULL)))
      _item$link1->watches_prev->watches_next = _item$link1->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link1 == _item$link1);
      *_head$link1 = _item$link1->watches_next;
    }
    _item$link1->watches_prev = (struct AvahiWatch *)(void *)0;
    _item$link1->watches_next = _item$link1->watches_prev;
  }
  while((_Bool)0);
  if(w$link1->dead == 0)
    w$link1->simple_poll->n_watches = w$link1->simple_poll->n_watches - 1;

  avahi_free((void *)w$link1);
}

// dispatch_status
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status(struct DBusConnection *connection, enum anonymous$12 new_status, void *userdata)
{
  struct anonymous$13 *d = (struct anonymous$13 *)userdata;
  if((signed int)new_status == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch(d, 1);

}

// dispatch_timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback(struct AvahiTimeout *t, void *userdata)
{
  struct anonymous$13 *d = (struct anonymous$13 *)userdata;
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$13 *)NULL));
  connection_data_ref(d);
  dbus_connection_ref(d->connection);
  enum anonymous$12 return_value_dbus_connection_dispatch$1;
  return_value_dbus_connection_dispatch$1=dbus_connection_dispatch(d->connection);
  if((signed int)return_value_dbus_connection_dispatch$1 == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch(d, 1);

  else
    request_dispatch(d, 0);
  dbus_connection_unref(d->connection);
  connection_data_unref(d);
}

// domain_browser_ref
// file browser.c line 77
static void domain_browser_ref(struct AvahiDomainBrowser *db)
{
  /* assertion db */
  assert(db != ((struct AvahiDomainBrowser *)NULL));
  /* assertion db->ref >= 1 */
  assert(db->ref >= 1);
  db->ref = db->ref + 1;
}

// drop_incomplete_utf8
// file alternative.c line 34
static void drop_incomplete_utf8(char *c)
{
  char *e;
  char *return_value_strchr$1;
  return_value_strchr$1=strchr(c, 0);
  e = return_value_strchr$1 - (signed long int)1;
  while(e >= c)
  {
    const char *return_value_avahi_utf8_valid$2;
    return_value_avahi_utf8_valid$2=avahi_utf8_valid(c);
    if(!(return_value_avahi_utf8_valid$2 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e & 128) != 0);
    *e = (char)0;
    e = e - 1l;
  }
}

// drop_incomplete_utf8$link1
// file alternative.c line 34
static void drop_incomplete_utf8$link1(char *c$link1)
{
  char *e$link1;
  char *return_value_strchr$1$link1;
  return_value_strchr$1$link1=strchr(c$link1, 0);
  e$link1 = return_value_strchr$1$link1 - (signed long int)1;
  while(e$link1 >= c$link1)
  {
    const char *return_value_avahi_utf8_valid$2$link1;
    return_value_avahi_utf8_valid$2$link1=avahi_utf8_valid(c$link1);
    if(!(return_value_avahi_utf8_valid$2$link1 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e$link1 & 128) != 0);
    *e$link1 = (char)0;
    e$link1 = e$link1 - 1l;
  }
}

// entry_group_callback
// file avahi-publish.c line 66
static void entry_group_callback(struct AvahiEntryGroup *g, enum anonymous state, void *userdata)
{
  struct Config *config = (struct Config *)userdata;
  /* assertion g */
  assert(g != ((struct AvahiEntryGroup *)NULL));
  /* assertion config */
  assert(config != ((struct Config *)NULL));
  char *return_value_dgettext$1;
  char *return_value_dgettext$2;
  signed int return_value_avahi_client_errno$3;
  const char *return_value_avahi_strerror$4;
  char *n;
  char *return_value_dgettext$5;
  switch((signed int)state)
  {
    case AVAHI_ENTRY_GROUP_ESTABLISHED:
    {
      return_value_dgettext$1=dgettext("avahi", "Established under name '%s'\n");
      fprintf(stderr, return_value_dgettext$1, config->name);
      goto __CPROVER_DUMP_L7;
    }
    case AVAHI_ENTRY_GROUP_FAILURE:
    {
      return_value_dgettext$2=dgettext("avahi", "Failed to register: %s\n");
      return_value_avahi_client_errno$3=avahi_client_errno(client);
      return_value_avahi_strerror$4=avahi_strerror(return_value_avahi_client_errno$3);
      fprintf(stderr, return_value_dgettext$2, return_value_avahi_strerror$4);
      goto __CPROVER_DUMP_L7;
    }
    case AVAHI_ENTRY_GROUP_COLLISION:
    {
      if((signed int)config->command == COMMAND_PUBLISH_SERVICE)
        n=avahi_alternative_service_name(config->name);

      else
      {
        /* assertion config->command == COMMAND_PUBLISH_ADDRESS */
        assert((signed int)config->command == COMMAND_PUBLISH_ADDRESS);
        n=avahi_alternative_host_name(config->name);
      }
      return_value_dgettext$5=dgettext("avahi", "Name collision, picking new name '%s'.\n");
      fprintf(stderr, return_value_dgettext$5, n);
      avahi_free((void *)config->name);
      config->name = n;
      register_stuff(config);
      goto __CPROVER_DUMP_L7;
    }
    case AVAHI_ENTRY_GROUP_UNCOMMITED:

    case AVAHI_ENTRY_GROUP_REGISTERING:
      ;
    default:

      __CPROVER_DUMP_L7:
        ;
  }
}

// entry_group_simple_method_call
// file entrygroup.c line 188
static signed int entry_group_simple_method_call(struct AvahiEntryGroup *group, const char *method)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  struct AvahiClient *entry_group_simple_method_call$$1$$client;
  dbus_error_init(&error);
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  entry_group_simple_method_call$$1$$client = group->client;
  message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", method);
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_error_is_set$1;
  unsigned int return_value_dbus_message_get_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(entry_group_simple_method_call$$1$$client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(entry_group_simple_method_call$$1$$client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      tmp_if_expr$2 = return_value_dbus_error_is_set$1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      r=avahi_client_set_errno(entry_group_simple_method_call$$1$$client, -22);

    else
    {
      return_value_dbus_message_get_args$3=dbus_message_get_args(reply, &error, (signed int)0);
      if(return_value_dbus_message_get_args$3 == 0u)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        r=avahi_client_set_errno(entry_group_simple_method_call$$1$$client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$6;
  return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$6 == 0u))
  {
    r=avahi_client_set_dbus_error(entry_group_simple_method_call$$1$$client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// filter_func
// file client.c line 103
static enum anonymous$28 filter_func(struct DBusConnection *bus, struct DBusMessage *message, void *userdata)
{
  struct AvahiClient *filter_func$$1$$client = (struct AvahiClient *)userdata;
  struct DBusError error;
  /* assertion bus */
  assert(bus != ((struct DBusConnection *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  unsigned int return_value_dbus_message_is_signal$75;
  return_value_dbus_message_is_signal$75=dbus_message_is_signal(message, "org.freedesktop.DBus.Local", "Disconnected");
  unsigned int return_value_dbus_message_is_signal$74;
  unsigned int return_value_dbus_message_is_signal$73;
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_error_is_set$2;
  _Bool tmp_if_expr$6;
  signed int return_value_avahi_client_is_connected$5;
  _Bool tmp_if_expr$4;
  signed int return_value_avahi_client_is_connected$72;
  unsigned int return_value_dbus_message_is_signal$71;
  _Bool tmp_if_expr$10;
  unsigned int return_value_dbus_error_is_set$9;
  unsigned int return_value_dbus_message_is_signal$70;
  signed int return_value_strcmp$11;
  _Bool tmp_if_expr$14;
  unsigned int return_value_dbus_error_is_set$13;
  unsigned int return_value_dbus_message_is_signal$69;
  enum anonymous$28 return_value_avahi_domain_browser_event$15;
  unsigned int return_value_dbus_message_is_signal$68;
  enum anonymous$28 return_value_avahi_domain_browser_event$16;
  unsigned int return_value_dbus_message_is_signal$67;
  enum anonymous$28 return_value_avahi_domain_browser_event$17;
  unsigned int return_value_dbus_message_is_signal$66;
  enum anonymous$28 return_value_avahi_domain_browser_event$18;
  unsigned int return_value_dbus_message_is_signal$65;
  enum anonymous$28 return_value_avahi_domain_browser_event$19;
  unsigned int return_value_dbus_message_is_signal$64;
  enum anonymous$28 return_value_avahi_service_type_browser_event$20;
  unsigned int return_value_dbus_message_is_signal$63;
  enum anonymous$28 return_value_avahi_service_type_browser_event$21;
  unsigned int return_value_dbus_message_is_signal$62;
  enum anonymous$28 return_value_avahi_service_type_browser_event$22;
  unsigned int return_value_dbus_message_is_signal$61;
  enum anonymous$28 return_value_avahi_service_type_browser_event$23;
  unsigned int return_value_dbus_message_is_signal$60;
  enum anonymous$28 return_value_avahi_service_type_browser_event$24;
  unsigned int return_value_dbus_message_is_signal$59;
  enum anonymous$28 return_value_avahi_service_browser_event$25;
  unsigned int return_value_dbus_message_is_signal$58;
  enum anonymous$28 return_value_avahi_service_browser_event$26;
  unsigned int return_value_dbus_message_is_signal$57;
  enum anonymous$28 return_value_avahi_service_browser_event$27;
  unsigned int return_value_dbus_message_is_signal$56;
  enum anonymous$28 return_value_avahi_service_browser_event$28;
  unsigned int return_value_dbus_message_is_signal$55;
  enum anonymous$28 return_value_avahi_service_browser_event$29;
  unsigned int return_value_dbus_message_is_signal$54;
  enum anonymous$28 return_value_avahi_service_resolver_event$30;
  unsigned int return_value_dbus_message_is_signal$53;
  enum anonymous$28 return_value_avahi_service_resolver_event$31;
  unsigned int return_value_dbus_message_is_signal$52;
  enum anonymous$28 return_value_avahi_host_name_resolver_event$32;
  unsigned int return_value_dbus_message_is_signal$51;
  enum anonymous$28 return_value_avahi_host_name_resolver_event$33;
  unsigned int return_value_dbus_message_is_signal$50;
  enum anonymous$28 return_value_avahi_address_resolver_event$34;
  unsigned int return_value_dbus_message_is_signal$49;
  enum anonymous$28 return_value_avahi_address_resolver_event$35;
  unsigned int return_value_dbus_message_is_signal$48;
  enum anonymous$28 return_value_avahi_record_browser_event$36;
  unsigned int return_value_dbus_message_is_signal$47;
  enum anonymous$28 return_value_avahi_record_browser_event$37;
  unsigned int return_value_dbus_message_is_signal$46;
  enum anonymous$28 return_value_avahi_record_browser_event$38;
  unsigned int return_value_dbus_message_is_signal$45;
  enum anonymous$28 return_value_avahi_record_browser_event$39;
  unsigned int return_value_dbus_message_is_signal$44;
  enum anonymous$28 return_value_avahi_record_browser_event$40;
  if(!(return_value_dbus_message_is_signal$75 == 0u))
  {
    avahi_client_set_errno(filter_func$$1$$client, -23);
    goto fail;
  }

  else
  {
    return_value_dbus_message_is_signal$74=dbus_message_is_signal(message, "org.freedesktop.DBus", "NameAcquired");
    if(return_value_dbus_message_is_signal$74 == 0u)
    {
      return_value_dbus_message_is_signal$73=dbus_message_is_signal(message, "org.freedesktop.DBus", "NameOwnerChanged");
      if(!(return_value_dbus_message_is_signal$73 == 0u))
      {
        char *name;
        char *old;
        char *new;
        unsigned int return_value_dbus_message_get_args$1;
        return_value_dbus_message_get_args$1=dbus_message_get_args(message, &error, (signed int)115, &name, (signed int)115, &old, (signed int)115, &new, (signed int)0);
        if(return_value_dbus_message_get_args$1 == 0u)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$2=dbus_error_is_set(&error);
          tmp_if_expr$3 = return_value_dbus_error_is_set$2 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
        {
          fprintf(stderr, "WARNING: Failed to parse NameOwnerChanged signal: %s\n", error.message);
          avahi_client_set_errno(filter_func$$1$$client, -22);
          goto fail;
        }

        signed int return_value_strcmp$7;
        return_value_strcmp$7=strcmp(name, "org.freedesktop.Avahi");
        if(return_value_strcmp$7 == 0)
        {
          if(!(*old == 0))
          {
            return_value_avahi_client_is_connected$5=avahi_client_is_connected(filter_func$$1$$client);
            tmp_if_expr$6 = return_value_avahi_client_is_connected$5 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
          {
            avahi_client_set_errno(filter_func$$1$$client, -23);
            goto fail;
          }

          else
            if((signed int)filter_func$$1$$client->state == AVAHI_CLIENT_CONNECTING)
            {
              if(old == ((char *)NULL))
                tmp_if_expr$4 = (_Bool)1;

              else
                tmp_if_expr$4 = (signed int)*old == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$4)
              {
                signed int ret;
                ret=init_server(filter_func$$1$$client, (signed int *)(void *)0);
                if(!(ret >= 0))
                {
                  avahi_client_set_errno(filter_func$$1$$client, ret);
                  goto fail;
                }

              }

            }

        }

      }

      else
      {
        return_value_avahi_client_is_connected$72=avahi_client_is_connected(filter_func$$1$$client);
        if(!(return_value_avahi_client_is_connected$72 == 0))
        {
          return_value_dbus_message_is_signal$71=dbus_message_is_signal(message, "org.freedesktop.Avahi.Server", "StateChanged");
          if(!(return_value_dbus_message_is_signal$71 == 0u))
          {
            signed int state;
            char *e = (char *)(void *)0;
            signed int c;
            unsigned int return_value_dbus_message_get_args$8;
            return_value_dbus_message_get_args$8=dbus_message_get_args(message, &error, (signed int)105, &state, (signed int)115, &e, (signed int)0);
            if(return_value_dbus_message_get_args$8 == 0u)
              tmp_if_expr$10 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
              tmp_if_expr$10 = return_value_dbus_error_is_set$9 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$10)
            {
              fprintf(stderr, "WARNING: Failed to parse Server.StateChanged signal: %s\n", error.message);
              avahi_client_set_errno(filter_func$$1$$client, -22);
              goto fail;
            }

            c=avahi_error_dbus_to_number(e);
            if(!(c == 0))
              avahi_client_set_errno(filter_func$$1$$client, c);

            client_set_state(filter_func$$1$$client, (enum anonymous$5)state);
          }

          else
          {
            return_value_dbus_message_is_signal$70=dbus_message_is_signal(message, "org.freedesktop.Avahi.EntryGroup", "StateChanged");
            if(!(return_value_dbus_message_is_signal$70 == 0u))
            {
              const char *path;
              struct AvahiEntryGroup *g;
              path=dbus_message_get_path(message);
              g = filter_func$$1$$client->groups;
              for( ; !(g == ((struct AvahiEntryGroup *)NULL)); g = g->groups_next)
              {
                return_value_strcmp$11=strcmp(g->path, path);
                if(return_value_strcmp$11 == 0)
                  break;

              }
              if(!(g == ((struct AvahiEntryGroup *)NULL)))
              {
                signed int filter_func$$1$$6$$2$$state;
                char *filter_func$$1$$6$$2$$e;
                signed int filter_func$$1$$6$$2$$c;
                unsigned int return_value_dbus_message_get_args$12;
                return_value_dbus_message_get_args$12=dbus_message_get_args(message, &error, (signed int)105, &filter_func$$1$$6$$2$$state, (signed int)115, &filter_func$$1$$6$$2$$e, (signed int)0);
                if(return_value_dbus_message_get_args$12 == 0u)
                  tmp_if_expr$14 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set$13=dbus_error_is_set(&error);
                  tmp_if_expr$14 = return_value_dbus_error_is_set$13 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$14)
                {
                  fprintf(stderr, "WARNING: Failed to parse EntryGroup.StateChanged signal: %s\n", error.message);
                  avahi_client_set_errno(filter_func$$1$$client, -22);
                  goto fail;
                }

                filter_func$$1$$6$$2$$c=avahi_error_dbus_to_number(filter_func$$1$$6$$2$$e);
                if(!(filter_func$$1$$6$$2$$c == 0))
                  avahi_client_set_errno(filter_func$$1$$client, filter_func$$1$$6$$2$$c);

                avahi_entry_group_set_state(g, (enum anonymous)filter_func$$1$$6$$2$$state);
              }

            }

            else
            {
              return_value_dbus_message_is_signal$69=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "ItemNew");
              if(!(return_value_dbus_message_is_signal$69 == 0u))
              {
                return_value_avahi_domain_browser_event$15=avahi_domain_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_NEW, message);
                return return_value_avahi_domain_browser_event$15;
              }

              else
              {
                return_value_dbus_message_is_signal$68=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "ItemRemove");
                if(!(return_value_dbus_message_is_signal$68 == 0u))
                {
                  return_value_avahi_domain_browser_event$16=avahi_domain_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_REMOVE, message);
                  return return_value_avahi_domain_browser_event$16;
                }

                else
                {
                  return_value_dbus_message_is_signal$67=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "CacheExhausted");
                  if(!(return_value_dbus_message_is_signal$67 == 0u))
                  {
                    return_value_avahi_domain_browser_event$17=avahi_domain_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                    return return_value_avahi_domain_browser_event$17;
                  }

                  else
                  {
                    return_value_dbus_message_is_signal$66=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "AllForNow");
                    if(!(return_value_dbus_message_is_signal$66 == 0u))
                    {
                      return_value_avahi_domain_browser_event$18=avahi_domain_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_ALL_FOR_NOW, message);
                      return return_value_avahi_domain_browser_event$18;
                    }

                    else
                    {
                      return_value_dbus_message_is_signal$65=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "Failure");
                      if(!(return_value_dbus_message_is_signal$65 == 0u))
                      {
                        return_value_avahi_domain_browser_event$19=avahi_domain_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_FAILURE, message);
                        return return_value_avahi_domain_browser_event$19;
                      }

                      else
                      {
                        return_value_dbus_message_is_signal$64=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemNew");
                        if(!(return_value_dbus_message_is_signal$64 == 0u))
                        {
                          return_value_avahi_service_type_browser_event$20=avahi_service_type_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_NEW, message);
                          return return_value_avahi_service_type_browser_event$20;
                        }

                        else
                        {
                          return_value_dbus_message_is_signal$63=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemRemove");
                          if(!(return_value_dbus_message_is_signal$63 == 0u))
                          {
                            return_value_avahi_service_type_browser_event$21=avahi_service_type_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_REMOVE, message);
                            return return_value_avahi_service_type_browser_event$21;
                          }

                          else
                          {
                            return_value_dbus_message_is_signal$62=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "CacheExhausted");
                            if(!(return_value_dbus_message_is_signal$62 == 0u))
                            {
                              return_value_avahi_service_type_browser_event$22=avahi_service_type_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                              return return_value_avahi_service_type_browser_event$22;
                            }

                            else
                            {
                              return_value_dbus_message_is_signal$61=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "AllForNow");
                              if(!(return_value_dbus_message_is_signal$61 == 0u))
                              {
                                return_value_avahi_service_type_browser_event$23=avahi_service_type_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                return return_value_avahi_service_type_browser_event$23;
                              }

                              else
                              {
                                return_value_dbus_message_is_signal$60=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "Failure");
                                if(!(return_value_dbus_message_is_signal$60 == 0u))
                                {
                                  return_value_avahi_service_type_browser_event$24=avahi_service_type_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_FAILURE, message);
                                  return return_value_avahi_service_type_browser_event$24;
                                }

                                else
                                {
                                  return_value_dbus_message_is_signal$59=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "ItemNew");
                                  if(!(return_value_dbus_message_is_signal$59 == 0u))
                                  {
                                    return_value_avahi_service_browser_event$25=avahi_service_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_NEW, message);
                                    return return_value_avahi_service_browser_event$25;
                                  }

                                  else
                                  {
                                    return_value_dbus_message_is_signal$58=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "ItemRemove");
                                    if(!(return_value_dbus_message_is_signal$58 == 0u))
                                    {
                                      return_value_avahi_service_browser_event$26=avahi_service_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_REMOVE, message);
                                      return return_value_avahi_service_browser_event$26;
                                    }

                                    else
                                    {
                                      return_value_dbus_message_is_signal$57=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "CacheExhausted");
                                      if(!(return_value_dbus_message_is_signal$57 == 0u))
                                      {
                                        return_value_avahi_service_browser_event$27=avahi_service_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                                        return return_value_avahi_service_browser_event$27;
                                      }

                                      else
                                      {
                                        return_value_dbus_message_is_signal$56=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "AllForNow");
                                        if(!(return_value_dbus_message_is_signal$56 == 0u))
                                        {
                                          return_value_avahi_service_browser_event$28=avahi_service_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                          return return_value_avahi_service_browser_event$28;
                                        }

                                        else
                                        {
                                          return_value_dbus_message_is_signal$55=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "Failure");
                                          if(!(return_value_dbus_message_is_signal$55 == 0u))
                                          {
                                            return_value_avahi_service_browser_event$29=avahi_service_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_FAILURE, message);
                                            return return_value_avahi_service_browser_event$29;
                                          }

                                          else
                                          {
                                            return_value_dbus_message_is_signal$54=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceResolver", "Found");
                                            if(!(return_value_dbus_message_is_signal$54 == 0u))
                                            {
                                              return_value_avahi_service_resolver_event$30=avahi_service_resolver_event(filter_func$$1$$client, (enum anonymous$9)AVAHI_RESOLVER_FOUND, message);
                                              return return_value_avahi_service_resolver_event$30;
                                            }

                                            else
                                            {
                                              return_value_dbus_message_is_signal$53=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceResolver", "Failure");
                                              if(!(return_value_dbus_message_is_signal$53 == 0u))
                                              {
                                                return_value_avahi_service_resolver_event$31=avahi_service_resolver_event(filter_func$$1$$client, (enum anonymous$9)AVAHI_RESOLVER_FAILURE, message);
                                                return return_value_avahi_service_resolver_event$31;
                                              }

                                              else
                                              {
                                                return_value_dbus_message_is_signal$52=dbus_message_is_signal(message, "org.freedesktop.Avahi.HostNameResolver", "Found");
                                                if(!(return_value_dbus_message_is_signal$52 == 0u))
                                                {
                                                  return_value_avahi_host_name_resolver_event$32=avahi_host_name_resolver_event(filter_func$$1$$client, (enum anonymous$9)AVAHI_RESOLVER_FOUND, message);
                                                  return return_value_avahi_host_name_resolver_event$32;
                                                }

                                                else
                                                {
                                                  return_value_dbus_message_is_signal$51=dbus_message_is_signal(message, "org.freedesktop.Avahi.HostNameResolver", "Failure");
                                                  if(!(return_value_dbus_message_is_signal$51 == 0u))
                                                  {
                                                    return_value_avahi_host_name_resolver_event$33=avahi_host_name_resolver_event(filter_func$$1$$client, (enum anonymous$9)AVAHI_RESOLVER_FAILURE, message);
                                                    return return_value_avahi_host_name_resolver_event$33;
                                                  }

                                                  else
                                                  {
                                                    return_value_dbus_message_is_signal$50=dbus_message_is_signal(message, "org.freedesktop.Avahi.AddressResolver", "Found");
                                                    if(!(return_value_dbus_message_is_signal$50 == 0u))
                                                    {
                                                      return_value_avahi_address_resolver_event$34=avahi_address_resolver_event(filter_func$$1$$client, (enum anonymous$9)AVAHI_RESOLVER_FOUND, message);
                                                      return return_value_avahi_address_resolver_event$34;
                                                    }

                                                    else
                                                    {
                                                      return_value_dbus_message_is_signal$49=dbus_message_is_signal(message, "org.freedesktop.Avahi.AddressResolver", "Failure");
                                                      if(!(return_value_dbus_message_is_signal$49 == 0u))
                                                      {
                                                        return_value_avahi_address_resolver_event$35=avahi_address_resolver_event(filter_func$$1$$client, (enum anonymous$9)AVAHI_RESOLVER_FAILURE, message);
                                                        return return_value_avahi_address_resolver_event$35;
                                                      }

                                                      else
                                                      {
                                                        return_value_dbus_message_is_signal$48=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "ItemNew");
                                                        if(!(return_value_dbus_message_is_signal$48 == 0u))
                                                        {
                                                          return_value_avahi_record_browser_event$36=avahi_record_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_NEW, message);
                                                          return return_value_avahi_record_browser_event$36;
                                                        }

                                                        else
                                                        {
                                                          return_value_dbus_message_is_signal$47=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "ItemRemove");
                                                          if(!(return_value_dbus_message_is_signal$47 == 0u))
                                                          {
                                                            return_value_avahi_record_browser_event$37=avahi_record_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_REMOVE, message);
                                                            return return_value_avahi_record_browser_event$37;
                                                          }

                                                          else
                                                          {
                                                            return_value_dbus_message_is_signal$46=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "CacheExhausted");
                                                            if(!(return_value_dbus_message_is_signal$46 == 0u))
                                                            {
                                                              return_value_avahi_record_browser_event$38=avahi_record_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                                                              return return_value_avahi_record_browser_event$38;
                                                            }

                                                            else
                                                            {
                                                              return_value_dbus_message_is_signal$45=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "AllForNow");
                                                              if(!(return_value_dbus_message_is_signal$45 == 0u))
                                                              {
                                                                return_value_avahi_record_browser_event$39=avahi_record_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                                                return return_value_avahi_record_browser_event$39;
                                                              }

                                                              else
                                                              {
                                                                return_value_dbus_message_is_signal$44=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "Failure");
                                                                if(!(return_value_dbus_message_is_signal$44 == 0u))
                                                                {
                                                                  return_value_avahi_record_browser_event$40=avahi_record_browser_event(filter_func$$1$$client, (enum anonymous$3)AVAHI_BROWSER_FAILURE, message);
                                                                  return return_value_avahi_record_browser_event$40;
                                                                }

                                                                else
                                                                {
                                                                  const char *return_value_dbus_message_get_interface$41;
                                                                  return_value_dbus_message_get_interface$41=dbus_message_get_interface(message);
                                                                  const char *return_value_dbus_message_get_path$42;
                                                                  return_value_dbus_message_get_path$42=dbus_message_get_path(message);
                                                                  const char *return_value_dbus_message_get_member$43;
                                                                  return_value_dbus_message_get_member$43=dbus_message_get_member(message);
                                                                  fprintf(stderr, "WARNING: Unhandled message: interface=%s, path=%s, member=%s\n", return_value_dbus_message_get_interface$41, return_value_dbus_message_get_path$42, return_value_dbus_message_get_member$43);
                                                                  return (enum anonymous$28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

      }
    }

  }
  return (enum anonymous$28)DBUS_HANDLER_RESULT_HANDLED;

fail:
  ;
  unsigned int return_value_dbus_error_is_set$77;
  return_value_dbus_error_is_set$77=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$77 == 0u))
  {
    signed int return_value_avahi_error_dbus_to_number$76;
    return_value_avahi_error_dbus_to_number$76=avahi_error_dbus_to_number(error.name);
    avahi_client_set_errno(filter_func$$1$$client, return_value_avahi_error_dbus_to_number$76);
    dbus_error_free(&error);
  }

  client_set_state(filter_func$$1$$client, (enum anonymous$5)AVAHI_CLIENT_FAILURE);
  return (enum anonymous$28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}

// find_next_timeout
// file simple-watch.c line 425
static struct AvahiTimeout * find_next_timeout(struct AvahiSimplePoll *s)
{
  struct AvahiTimeout *t;
  struct AvahiTimeout *n = (struct AvahiTimeout *)(void *)0;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  t = s->timeouts;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_timeval_compare$2;
  for( ; !(t == ((struct AvahiTimeout *)NULL)); t = t->timeouts_next)
  {
    if(!(t->dead == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !(t->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      if(n == ((struct AvahiTimeout *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare$2=avahi_timeval_compare(&t->expiry, &n->expiry);
        tmp_if_expr$3 = return_value_avahi_timeval_compare$2 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        n = t;

    }

  }
  return n;
}

// find_next_timeout$link1
// file simple-watch.c line 425
static struct AvahiTimeout * find_next_timeout$link1(struct AvahiSimplePoll *s$link1)
{
  struct AvahiTimeout *t$link1;
  struct AvahiTimeout *n$link1 = (struct AvahiTimeout *)(void *)0;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll *)NULL));
  t$link1 = s$link1->timeouts;
  _Bool tmp_if_expr$1$link1;
  _Bool tmp_if_expr$3$link1;
  signed int return_value_avahi_timeval_compare$2$link1;
  for( ; !(t$link1 == ((struct AvahiTimeout *)NULL)); t$link1 = t$link1->timeouts_next)
  {
    if(!(t$link1->dead == 0))
      tmp_if_expr$1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1 = !(t$link1->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1$link1)
    {
      if(n$link1 == ((struct AvahiTimeout *)NULL))
        tmp_if_expr$3$link1 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare$2$link1=avahi_timeval_compare(&t$link1->expiry, &n$link1->expiry);
        tmp_if_expr$3$link1 = return_value_avahi_timeval_compare$2$link1 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3$link1)
        n$link1 = t$link1;

    }

  }
  return n$link1;
}

// get_server_state
// file client.c line 305
static signed int get_server_state(struct AvahiClient *client, signed int *ret_error)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int state;
  signed int e = -24;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetState");
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_error_is_set$1;
  unsigned int return_value_dbus_message_get_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  if(!(message == ((struct DBusMessage *)NULL)))
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      tmp_if_expr$2 = return_value_dbus_error_is_set$1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      goto fail;

    return_value_dbus_message_get_args$3=dbus_message_get_args(reply, &error, (signed int)105, &state, (signed int)0);
    if(return_value_dbus_message_get_args$3 == 0u)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
      tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      goto fail;

    client_set_state(client, (enum anonymous$5)state);
    dbus_message_unref(message);
    dbus_message_unref(reply);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$6;
    return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$6 == 0u))
    {
      e=avahi_error_dbus_to_number(error.name);
      dbus_error_free(&error);
    }

    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = e;

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return e;
  }
}

// handler
// file sigint.c line 54
static void handler(signed int s)
{
  write(pipe_fds[(signed long int)1], (const void *)&s, sizeof(signed int) /*4ul*/ );
}

// help
// file avahi-publish.c line 214
static void help(struct _IO_FILE *f, const char *argv0)
{
  char *return_value_dgettext$1;
  return_value_dgettext$1=dgettext("avahi", "%s [options] %s <name> <type> <port> [<txt ...>]\n%s [options] %s <host-name> <address>\n\n    -h --help            Show this help\n    -V --version         Show version\n    -s --service         Publish service\n    -a --address         Publish address\n    -v --verbose         Enable verbose mode\n    -d --domain=DOMAIN   Domain to publish service in\n    -H --host=DOMAIN     Host where service resides\n       --subtype=SUBTYPE An additional subtype to register this service with\n    -R --no-reverse      Do not publish reverse entry with address\n    -f --no-fail         Don't fail if the daemon is not available\n");
  char *return_value_strstr$2;
  return_value_strstr$2=strstr(argv0, "service");
  char *return_value_strstr$3;
  return_value_strstr$3=strstr(argv0, "address");
  fprintf(f, return_value_dgettext$1, argv0, return_value_strstr$2 != ((char *)NULL) ? "[-s]" : "-s", argv0, return_value_strstr$3 != ((char *)NULL) ? "[-a]" : "-a");
}

// init_server
// file client.c line 431
static signed int init_server(struct AvahiClient *client, signed int *ret_error)
{
  signed int r;
  r=check_version(client, ret_error);
  if(!(r >= 0))
    return r;

  else
  {
    r=get_server_state(client, ret_error);
    if(!(r >= 0))
      return r;

    else
      return 0;
  }
}

// main
// file avahi-publish.c line 342
signed int main(signed int argc, char **argv)
{
  signed int ret = 1;
  signed int error;
  struct Config config;
  const char *argv0;
  avahi_init_i18n();
  setlocale(6, "");
  argv0=strrchr(argv[(signed long int)0], 47);
  if(!(argv0 == ((const char *)NULL)))
    argv0 = argv0 + 1l;

  else
    argv0 = argv[(signed long int)0];
  signed int return_value_parse_command_line$1;
  return_value_parse_command_line$1=parse_command_line(&config, argv0, argc, argv);
  char *return_value_dgettext$2;
  signed int return_value_sigint_install$4;
  const struct AvahiPoll *return_value_avahi_simple_poll_get$7;
  enum anonymous$5 return_value_avahi_client_get_state$15;
  if(return_value_parse_command_line$1 >= 0)
    switch((signed int)config.command)
    {
      case COMMAND_UNSPEC:
      {
        ret = 1;
        return_value_dgettext$2=dgettext("avahi", "No command specified.\n");
        fprintf(stderr, return_value_dgettext$2);
        break;
      }
      case COMMAND_HELP:
      {
        help(stdout, argv0);
        ret = 0;
        break;
      }
      case COMMAND_VERSION:
      {
        printf("%s 0.6.32-rc\n", argv0);
        ret = 0;
        break;
      }
      case COMMAND_PUBLISH_SERVICE:

      case COMMAND_PUBLISH_ADDRESS:
      {
        simple_poll=avahi_simple_poll_new();
        if(simple_poll == ((struct AvahiSimplePoll *)NULL))
        {
          char *return_value_dgettext$3;
          return_value_dgettext$3=dgettext("avahi", "Failed to create simple poll object.\n");
          fprintf(stderr, return_value_dgettext$3);
          break;
        }

        return_value_sigint_install$4=sigint_install(simple_poll);
        if(!(return_value_sigint_install$4 >= 0))
          break;

        return_value_avahi_simple_poll_get$7=avahi_simple_poll_get(simple_poll);
        client=avahi_client_new(return_value_avahi_simple_poll_get$7, (enum anonymous$11)(config.no_fail != 0 ? AVAHI_CLIENT_NO_FAIL : 0), client_callback, (void *)&config, &error);
        if(client == ((struct AvahiClient *)NULL))
        {
          char *return_value_dgettext$5;
          return_value_dgettext$5=dgettext("avahi", "Failed to create client object: %s\n");
          const char *return_value_avahi_strerror$6;
          return_value_avahi_strerror$6=avahi_strerror(error);
          fprintf(stderr, return_value_dgettext$5, return_value_avahi_strerror$6);
          break;
        }

        return_value_avahi_client_get_state$15=avahi_client_get_state(client);
        if(!((signed int)return_value_avahi_client_get_state$15 == AVAHI_CLIENT_CONNECTING))
        {
          if(!(config.verbose == 0))
          {
            const char *version;
            const char *hn;
            version=avahi_client_get_version_string(client);
            if(version == ((const char *)NULL))
            {
              char *return_value_dgettext$8;
              return_value_dgettext$8=dgettext("avahi", "Failed to query version string: %s\n");
              signed int return_value_avahi_client_errno$9;
              return_value_avahi_client_errno$9=avahi_client_errno(client);
              const char *return_value_avahi_strerror$10;
              return_value_avahi_strerror$10=avahi_strerror(return_value_avahi_client_errno$9);
              fprintf(stderr, return_value_dgettext$8, return_value_avahi_strerror$10);
              break;
            }

            hn=avahi_client_get_host_name_fqdn(client);
            if(hn == ((const char *)NULL))
            {
              char *return_value_dgettext$11;
              return_value_dgettext$11=dgettext("avahi", "Failed to query host name: %s\n");
              signed int return_value_avahi_client_errno$12;
              return_value_avahi_client_errno$12=avahi_client_errno(client);
              const char *return_value_avahi_strerror$13;
              return_value_avahi_strerror$13=avahi_strerror(return_value_avahi_client_errno$12);
              fprintf(stderr, return_value_dgettext$11, return_value_avahi_strerror$13);
              break;
            }

            char *return_value_dgettext$14;
            return_value_dgettext$14=dgettext("avahi", "Server version: %s; Host name: %s\n");
            fprintf(stderr, return_value_dgettext$14, version, hn);
          }

        }

        avahi_simple_poll_loop(simple_poll);
        ret = 0;
      }
      default:
        ;
    }


fail:
  ;
  if(!(client == ((struct AvahiClient *)NULL)))
    avahi_client_free(client);

  sigint_uninstall();
  if(!(simple_poll == ((struct AvahiSimplePoll *)NULL)))
    avahi_simple_poll_free(simple_poll);

  avahi_free((void *)config.host);
  avahi_free((void *)config.name);
  avahi_free((void *)config.stype);
  avahi_free((void *)config.domain);
  avahi_string_list_free(config.subtypes);
  avahi_string_list_free(config.txt);
  return ret;
}

// oom
// file malloc.c line 44
static void oom(void)
{
  static const char msg[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n = msg;
  unsigned long int return_value_strlen$1;
  do
  {
    return_value_strlen$1=strlen(n);
    if(!(return_value_strlen$1 >= 1ul))
      break;

    signed long int r;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(n);
    r=write(2, (const void *)n, return_value_strlen$2);
    if(!(r >= 0l))
      break;

    n = n + r;
  }
  while((_Bool)1);
  abort();
}

// oom$link1
// file malloc.c line 44
static void oom$link1(void)
{
  static const char msg$link1[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n$link1 = msg$link1;
  unsigned long int return_value_strlen$1$link1;
  do
  {
    return_value_strlen$1$link1=strlen(n$link1);
    if(!(return_value_strlen$1$link1 >= 1ul))
      break;

    signed long int r$link1;
    unsigned long int return_value_strlen$2$link1;
    return_value_strlen$2$link1=strlen(n$link1);
    r$link1=write(2, (const void *)n$link1, return_value_strlen$2$link1);
    if(!(r$link1 >= 0l))
      break;

    n$link1 = n$link1 + r$link1;
  }
  while((_Bool)1);
  abort();
}

// parse_command_line
// file avahi-publish.c line 232
static signed int parse_command_line(struct Config *c, const char *argv0, signed int argc, char **argv)
{
  signed int o;
  /* assertion c */
  assert(c != ((struct Config *)NULL));
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(argv0, "address");
  signed int tmp_if_expr$3;
  char *return_value_strstr$2;
  if(!(return_value_strstr$1 == ((char *)NULL)))
    tmp_if_expr$3 = COMMAND_PUBLISH_ADDRESS;

  else
  {
    return_value_strstr$2=strstr(argv0, "service");
    tmp_if_expr$3 = return_value_strstr$2 != ((char *)NULL) ? COMMAND_PUBLISH_SERVICE : COMMAND_UNSPEC;
  }
  c->command = (enum anonymous$7)tmp_if_expr$3;
  c->no_reverse = 0;
  c->no_fail = c->no_reverse;
  c->verbose = c->no_fail;
  c->stype = (char *)(void *)0;
  c->domain = c->stype;
  c->name = c->domain;
  c->host = c->name;
  c->port = (unsigned short int)0;
  c->subtypes = (struct AvahiStringList *)(void *)0;
  c->txt = c->subtypes;
  do
  {
    static struct option long_options[11l] = { { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=86 },
    { .name="service", .has_arg=0, .flag=(signed int *)(void *)0, .val=115 },
    { .name="address", .has_arg=0, .flag=(signed int *)(void *)0, .val=97 },
    { .name="verbose", .has_arg=0, .flag=(signed int *)(void *)0, .val=118 },
    { .name="domain", .has_arg=1, .flag=(signed int *)(void *)0, .val=100 },
    { .name="host", .has_arg=1, .flag=(signed int *)(void *)0, .val=72 },
    { .name="subtype", .has_arg=1, .flag=(signed int *)(void *)0, .val=256 },
    { .name="no-reverse", .has_arg=0, .flag=(signed int *)(void *)0, .val=82 },
    { .name="no-fail", .has_arg=0, .flag=(signed int *)(void *)0, .val=102 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
    o=getopt_long(argc, argv, "hVsavRd:H:f", long_options, (signed int *)(void *)0);
    if(!(o >= 0))
      break;

    switch(o)
    {
      case 104:
      {
        c->command = (enum anonymous$7)COMMAND_HELP;
        break;
      }
      case 86:
      {
        c->command = (enum anonymous$7)COMMAND_VERSION;
        break;
      }
      case 115:
      {
        c->command = (enum anonymous$7)COMMAND_PUBLISH_SERVICE;
        break;
      }
      case 97:
      {
        c->command = (enum anonymous$7)COMMAND_PUBLISH_ADDRESS;
        break;
      }
      case 118:
      {
        c->verbose = 1;
        break;
      }
      case 82:
      {
        c->no_reverse = 1;
        break;
      }
      case 100:
      {
        avahi_free((void *)c->domain);
        c->domain=avahi_strdup(optarg);
        break;
      }
      case 72:
      {
        avahi_free((void *)c->host);
        c->host=avahi_strdup(optarg);
        break;
      }
      case 102:
      {
        c->no_fail = 1;
        break;
      }
      case 256:
      {
        c->subtypes=avahi_string_list_add(c->subtypes, optarg);
        break;
      }
      default:
        return -1;
    }
  }
  while((_Bool)1);
  _Bool tmp_if_expr$9;
  if((signed int)c->command == COMMAND_PUBLISH_ADDRESS)
  {
    if(!(2 + optind == argc))
    {
      char *return_value_dgettext$4;
      return_value_dgettext$4=dgettext("avahi", "Bad number of arguments\n");
      fprintf(stderr, return_value_dgettext$4);
      return -1;
    }

    avahi_free((void *)c->name);
    c->name=avahi_strdup(argv[(signed long int)optind]);
    avahi_address_parse(argv[(signed long int)(optind + 1)], -1, &c->address);
  }

  else
    if((signed int)c->command == COMMAND_PUBLISH_SERVICE)
    {
      char *e;
      signed long int p;
      signed int i;
      if(!(argc >= 3 + optind))
      {
        char *return_value_dgettext$5;
        return_value_dgettext$5=dgettext("avahi", "Bad number of arguments\n");
        fprintf(stderr, return_value_dgettext$5);
        return -1;
      }

      c->name=avahi_strdup(argv[(signed long int)optind]);
      c->stype=avahi_strdup(argv[(signed long int)(optind + 1)]);
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      *return_value___errno_location$6 = 0;
      p=strtol(argv[(signed long int)(optind + 2)], &e, 0);
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      if(!(*return_value___errno_location$8 == 0))
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = *e != 0 ? (_Bool)1 : (_Bool)0;
      if(p >= 65536l || !(p >= 0l) || tmp_if_expr$9)
      {
        char *return_value_dgettext$7;
        return_value_dgettext$7=dgettext("avahi", "Failed to parse port number: %s\n");
        fprintf(stderr, return_value_dgettext$7, argv[(signed long int)(optind + 2)]);
        return -1;
      }

      c->port = (unsigned short int)p;
      i = optind + 3;
      for( ; !(i >= argc); i = i + 1)
        c->txt=avahi_string_list_add(c->txt, argv[(signed long int)i]);
    }

  return 0;
}

// parse_domain_file
// file browser.c line 58
static void parse_domain_file(struct AvahiDomainBrowser *b)
{
  struct _IO_FILE *f;
  char buf[1014l];
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  f=avahi_xdg_config_open("avahi/browse-domains");
  char *return_value_fgets$1;
  if(!(f == ((struct _IO_FILE *)NULL)))
    do
    {
      return_value_fgets$1=fgets(buf, (signed int)(sizeof(char [1014l]) /*1014ul*/  - (unsigned long int)1), f);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      char domain[1014l];
      unsigned long int return_value_strcspn$2;
      return_value_strcspn$2=strcspn(buf, "\n\r");
      buf[(signed long int)return_value_strcspn$2] = (char)0;
      char *return_value_avahi_normalize_name$3;
      return_value_avahi_normalize_name$3=avahi_normalize_name(buf, domain, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name$3 == ((char *)NULL)))
        b->static_browse_domains=avahi_string_list_add(b->static_browse_domains, domain);

    }
    while((_Bool)1);

}

// parse_environment
// file browser.c line 41
static void parse_environment(struct AvahiDomainBrowser *b)
{
  char buf[3042l];
  char *e;
  char *t;
  char *p;
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  e=getenv("AVAHI_BROWSE_DOMAINS");
  if(!(e == ((char *)NULL)))
  {
    snprintf(buf, sizeof(char [3042l]) /*3042ul*/ , "%s", e);
    t=strtok_r(buf, ":", &p);
    while(!(t == ((char *)NULL)))
    {
      char domain[1014l];
      char *return_value_avahi_normalize_name$1;
      return_value_avahi_normalize_name$1=avahi_normalize_name(t, domain, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name$1 == ((char *)NULL)))
        b->static_browse_domains=avahi_string_list_add(b->static_browse_domains, domain);

      t=strtok_r((char *)(void *)0, ":", &p);
    }
  }

}

// poll_func
// file thread-watch.c line 48
static signed int poll_func(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata)
{
  union anonymous$25 *mutex = (union anonymous$25 *)userdata;
  signed int r;
  pthread_mutex_unlock(mutex);
  r=poll(ufds, (unsigned long int)nfds, timeout);
  pthread_mutex_lock(mutex);
  return r;
}

// poll_func$link1
// file thread-watch.c line 48
static signed int poll_func$link1(struct pollfd *ufds$link1, unsigned int nfds$link1, signed int timeout$link1, void *userdata$link1)
{
  union anonymous$25 *mutex$link1 = (union anonymous$25 *)userdata$link1;
  signed int r$link1;
  pthread_mutex_unlock(mutex$link1);
  r$link1=poll(ufds$link1, (unsigned long int)nfds$link1, timeout$link1);
  pthread_mutex_lock(mutex$link1);
  return r$link1;
}

// rebuild
// file simple-watch.c line 385
static signed int rebuild(struct AvahiSimplePoll *s)
{
  struct AvahiWatch *w;
  signed int idx;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  if(!(s->max_pollfds >= 1 + s->n_watches))
  {
    struct pollfd *n;
    s->max_pollfds = s->n_watches + 10;
    void *return_value_avahi_realloc$1;
    return_value_avahi_realloc$1=avahi_realloc((void *)s->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s->max_pollfds);
    n = (struct pollfd *)return_value_avahi_realloc$1;
    if(n == ((struct pollfd *)NULL))
      return -1;

    s->pollfds = n;
  }

  (s->pollfds + (signed long int)0)->fd = s->wakeup_pipe[(signed long int)0];
  (s->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx = 1;
  w = s->watches;
  signed int tmp_post$2;
  for( ; !(w == ((struct AvahiWatch *)NULL)); w = w->watches_next)
    if(w->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w->idx < s->max_pollfds);
      tmp_post$2 = idx;
      idx = idx + 1;
      w->idx = tmp_post$2;
      s->pollfds[(signed long int)w->idx] = w->pollfd;
    }

  s->n_pollfds = idx;
  s->events_valid = 0;
  s->rebuild_pollfds = 0;
  return 0;
}

// rebuild$link1
// file simple-watch.c line 385
static signed int rebuild$link1(struct AvahiSimplePoll *s$link1)
{
  struct AvahiWatch *w$link1;
  signed int idx$link1;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll *)NULL));
  if(!(s$link1->max_pollfds >= 1 + s$link1->n_watches))
  {
    struct pollfd *n$link1;
    s$link1->max_pollfds = s$link1->n_watches + 10;
    void *return_value_avahi_realloc$1$link1;
    return_value_avahi_realloc$1$link1=avahi_realloc((void *)s$link1->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s$link1->max_pollfds);
    n$link1 = (struct pollfd *)return_value_avahi_realloc$1$link1;
    if(n$link1 == ((struct pollfd *)NULL))
      return -1;

    s$link1->pollfds = n$link1;
  }

  (s$link1->pollfds + (signed long int)0)->fd = s$link1->wakeup_pipe[(signed long int)0];
  (s$link1->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s$link1->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx$link1 = 1;
  w$link1 = s$link1->watches;
  signed int tmp_post$2$link1;
  for( ; !(w$link1 == ((struct AvahiWatch *)NULL)); w$link1 = w$link1->watches_next)
    if(w$link1->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w$link1->idx < s$link1->max_pollfds);
      tmp_post$2$link1 = idx$link1;
      idx$link1 = idx$link1 + 1;
      w$link1->idx = tmp_post$2$link1;
      s$link1->pollfds[(signed long int)w$link1->idx] = w$link1->pollfd;
    }

  s$link1->n_pollfds = idx$link1;
  s$link1->events_valid = 0;
  s$link1->rebuild_pollfds = 0;
  return 0;
}

// register_stuff
// file avahi-publish.c line 109
static signed int register_stuff(struct Config *config)
{
  /* assertion config */
  assert(config != ((struct Config *)NULL));
  if(entry_group == ((struct AvahiEntryGroup *)NULL))
  {
    entry_group=avahi_entry_group_new(client, entry_group_callback, (void *)config);
    if(entry_group == ((struct AvahiEntryGroup *)NULL))
    {
      char *return_value_dgettext$1;
      return_value_dgettext$1=dgettext("avahi", "Failed to create entry group: %s\n");
      signed int return_value_avahi_client_errno$2;
      return_value_avahi_client_errno$2=avahi_client_errno(client);
      const char *return_value_avahi_strerror$3;
      return_value_avahi_strerror$3=avahi_strerror(return_value_avahi_client_errno$2);
      fprintf(stderr, return_value_dgettext$1, return_value_avahi_strerror$3);
      return -1;
    }

  }

  signed int return_value_avahi_entry_group_is_empty$4;
  return_value_avahi_entry_group_is_empty$4=avahi_entry_group_is_empty(entry_group);
  /* assertion avahi_entry_group_is_empty(entry_group) */
  assert(return_value_avahi_entry_group_is_empty$4 != 0);
  signed int return_value_avahi_entry_group_add_service_subtype$16;
  if((signed int)config->command == COMMAND_PUBLISH_ADDRESS)
  {
    signed int return_value_avahi_entry_group_add_address$8;
    return_value_avahi_entry_group_add_address$8=avahi_entry_group_add_address(entry_group, -1, -1, (enum anonymous$0)(config->no_reverse != 0 ? AVAHI_PUBLISH_NO_REVERSE : 0), config->name, &config->address);
    if(!(return_value_avahi_entry_group_add_address$8 >= 0))
    {
      char *return_value_dgettext$5;
      return_value_dgettext$5=dgettext("avahi", "Failed to add address: %s\n");
      signed int return_value_avahi_client_errno$6;
      return_value_avahi_client_errno$6=avahi_client_errno(client);
      const char *return_value_avahi_strerror$7;
      return_value_avahi_strerror$7=avahi_strerror(return_value_avahi_client_errno$6);
      fprintf(stderr, return_value_dgettext$5, return_value_avahi_strerror$7);
      return -1;
    }

  }

  else
  {
    struct AvahiStringList *i;
    /* assertion config->command == COMMAND_PUBLISH_SERVICE */
    assert((signed int)config->command == COMMAND_PUBLISH_SERVICE);
    signed int return_value_avahi_entry_group_add_service_strlst$12;
    return_value_avahi_entry_group_add_service_strlst$12=avahi_entry_group_add_service_strlst(entry_group, -1, -1, (enum anonymous$0)0, config->name, config->stype, config->domain, config->host, config->port, config->txt);
    if(!(return_value_avahi_entry_group_add_service_strlst$12 >= 0))
    {
      char *return_value_dgettext$9;
      return_value_dgettext$9=dgettext("avahi", "Failed to add service: %s\n");
      signed int return_value_avahi_client_errno$10;
      return_value_avahi_client_errno$10=avahi_client_errno(client);
      const char *return_value_avahi_strerror$11;
      return_value_avahi_strerror$11=avahi_strerror(return_value_avahi_client_errno$10);
      fprintf(stderr, return_value_dgettext$9, return_value_avahi_strerror$11);
      return -1;
    }

    i = config->subtypes;
    for( ; !(i == ((struct AvahiStringList *)NULL)); i = i->next)
    {
      return_value_avahi_entry_group_add_service_subtype$16=avahi_entry_group_add_service_subtype(entry_group, -1, -1, (enum anonymous$0)0, config->name, config->stype, config->domain, (char *)i->text);
      if(!(return_value_avahi_entry_group_add_service_subtype$16 >= 0))
      {
        char *return_value_dgettext$13;
        return_value_dgettext$13=dgettext("avahi", "Failed to add subtype '%s': %s\n");
        signed int return_value_avahi_client_errno$14;
        return_value_avahi_client_errno$14=avahi_client_errno(client);
        const char *return_value_avahi_strerror$15;
        return_value_avahi_strerror$15=avahi_strerror(return_value_avahi_client_errno$14);
        fprintf(stderr, return_value_dgettext$13, (const void *)i->text, return_value_avahi_strerror$15);
        return -1;
      }

    }
  }
  avahi_entry_group_commit(entry_group);
  return 0;
}

// remove_pollfd
// file simple-watch.c line 194
static void remove_pollfd(struct AvahiWatch *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  if(!(w->idx == -1))
    w->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd$link1
// file simple-watch.c line 194
static void remove_pollfd$link1(struct AvahiWatch *w$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch *)NULL));
  if(!(w$link1->idx == -1))
    w$link1->simple_poll->rebuild_pollfds = 1;

}

// remove_timeout
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct anonymous$13 *d = (struct anonymous$13 *)userdata;
  struct TimeoutData *timeout;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$13 *)NULL));
  void *return_value_dbus_timeout_get_data$1;
  return_value_dbus_timeout_get_data$1=dbus_timeout_get_data(dbus_timeout);
  timeout = (struct TimeoutData *)return_value_dbus_timeout_get_data$1;
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  d->poll_api->timeout_free(timeout->avahi_timeout);
  timeout->avahi_timeout = (struct AvahiTimeout *)(void *)0;
}

// remove_watch
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous$13 *d = (struct anonymous$13 *)userdata;
  struct AvahiWatch *avahi_watch;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$13 *)NULL));
  void *return_value_dbus_watch_get_data$1;
  return_value_dbus_watch_get_data$1=dbus_watch_get_data(dbus_watch);
  avahi_watch = (struct AvahiWatch *)return_value_dbus_watch_get_data$1;
  if(!(avahi_watch == ((struct AvahiWatch *)NULL)))
  {
    d->poll_api->watch_free(avahi_watch);
    dbus_watch_set_data(dbus_watch, (void *)0, (void (*)(void *))(void *)0);
  }

}

// request_dispatch
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch(struct anonymous$13 *d, signed int enable)
{
  /* assertion d */
  assert(d != ((struct anonymous$13 *)NULL));
  if(!(enable == 0))
  {
    enum anonymous$12 return_value_dbus_connection_get_dispatch_status$1;
    return_value_dbus_connection_get_dispatch_status$1=dbus_connection_get_dispatch_status(d->connection);
    /* assertion dbus_connection_get_dispatch_status(d->connection) == DBUS_DISPATCH_DATA_REMAINS */
    assert((signed int)return_value_dbus_connection_get_dispatch_status$1 == DBUS_DISPATCH_DATA_REMAINS);
    static struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
    d->poll_api->timeout_update(d->dispatch_timeout, &tv);
  }

  else
    d->poll_api->timeout_update(d->dispatch_timeout, (struct timeval *)(void *)0);
}

// retrieve_state
// file entrygroup.c line 52
static signed int retrieve_state(struct AvahiEntryGroup *group)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  signed int state;
  struct AvahiClient *retrieve_state$$1$$client;
  dbus_error_init(&error);
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  retrieve_state$$1$$client = group->client;
  message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "GetState");
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_error_is_set$1;
  unsigned int return_value_dbus_message_get_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(retrieve_state$$1$$client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(retrieve_state$$1$$client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      tmp_if_expr$2 = return_value_dbus_error_is_set$1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      r=avahi_client_set_errno(retrieve_state$$1$$client, -22);

    else
    {
      return_value_dbus_message_get_args$3=dbus_message_get_args(reply, &error, (signed int)105, &state, (signed int)0);
      if(return_value_dbus_message_get_args$3 == 0u)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        r=avahi_client_set_errno(retrieve_state$$1$$client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return state;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$6;
  return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$6 == 0u))
  {
    r=avahi_client_set_dbus_error(retrieve_state$$1$$client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// set_nonblock
// file sigint.c line 40
static signed int set_nonblock(signed int fd)
{
  signed int n;
  /* assertion fd >= 0 */
  assert(fd >= 0);
  n=fcntl(fd, 3);
  if(!(n >= 0))
    return -1;

  else
    if(!((04000 & n) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl$1;
      return_value_fcntl$1=fcntl(fd, 4, n | 04000);
      return return_value_fcntl$1;
    }
}

// set_nonblock$link1
// file simple-watch.c line 118
static signed int set_nonblock$link1(signed int fd$link1)
{
  signed int n$link1;
  /* assertion fd >= 0 */
  assert(fd$link1 >= 0);
  n$link1=fcntl(fd$link1, 3);
  if(!(n$link1 >= 0))
    return -1;

  else
    if(!((04000 & n$link1) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl$1$link1;
      return_value_fcntl$1$link1=fcntl(fd$link1, 4, n$link1 | 04000);
      return return_value_fcntl$1$link1;
    }
}

// set_nonblock$link2
// file simple-watch.c line 118
static signed int set_nonblock$link2(signed int fd$link2)
{
  signed int n$link2;
  /* assertion fd >= 0 */
  assert(fd$link2 >= 0);
  n$link2=fcntl(fd$link2, 3);
  if(!(n$link2 >= 0))
    return -1;

  else
    if(!((04000 & n$link2) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl$1$link2;
      return_value_fcntl$1$link2=fcntl(fd$link2, 4, n$link2 | 04000);
      return return_value_fcntl$1$link2;
    }
}

// sigint_install
// file sigint.h line 25
signed int sigint_install(struct AvahiSimplePoll *spoll)
{
  struct sigaction sa;
  const struct AvahiPoll *p;
  /* assertion spoll */
  assert(spoll != ((struct AvahiSimplePoll *)NULL));
  /* assertion !simple_poll */
  assert(!(simple_poll$link1 != ((struct AvahiSimplePoll *)NULL)));
  _Bool tmp_if_expr$1;
  if(pipe_fds[0l] == -1)
    tmp_if_expr$1 = pipe_fds[(signed long int)1] == -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion pipe_fds[0] == -1 && pipe_fds[1] == -1 */
  assert(tmp_if_expr$1);
  signed int return_value_pipe$4;
  return_value_pipe$4=pipe(pipe_fds);
  if(!(return_value_pipe$4 >= 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    fprintf(stderr, "pipe() failed: %s\n", return_value_strerror$3);
    return -1;
  }

  set_nonblock(pipe_fds[(signed long int)0]);
  set_nonblock(pipe_fds[(signed long int)1]);
  memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
  sa.__sigaction_handler.sa_handler = handler;
  sa.sa_flags = 0x10000000;
  signed int return_value_sigaction$7;
  return_value_sigaction$7=sigaction(2, &sa, &old_sigint_sa);
  if(!(return_value_sigaction$7 >= 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    fprintf(stderr, "sigaction() failed: %s\n", return_value_strerror$6);
    close_pipe_fds();
    return -1;
  }

  signed int return_value_sigaction$10;
  return_value_sigaction$10=sigaction(15, &sa, &old_sigterm_sa);
  if(!(return_value_sigaction$10 >= 0))
  {
    sigaction(2, &old_sigint_sa, (struct sigaction *)(void *)0);
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    char *return_value_strerror$9;
    return_value_strerror$9=strerror(*return_value___errno_location$8);
    fprintf(stderr, "sigaction() failed: %s\n", return_value_strerror$9);
    close_pipe_fds();
    return -1;
  }

  p=avahi_simple_poll_get(spoll);
  watch=p->watch_new(p, pipe_fds[(signed long int)0], (enum anonymous$6)AVAHI_WATCH_IN, watch_callback, (void *)0);
  /* assertion watch */
  assert(watch != ((struct AvahiWatch *)NULL));
  simple_poll$link1 = spoll;
  return 0;
}

// sigint_uninstall
// file sigint.h line 26
void sigint_uninstall(void)
{
  if(!(simple_poll$link1 == ((struct AvahiSimplePoll *)NULL)))
  {
    sigaction(15, &old_sigterm_sa, (struct sigaction *)(void *)0);
    sigaction(2, &old_sigint_sa, (struct sigaction *)(void *)0);
    close_pipe_fds();
    if(!(watch == ((struct AvahiWatch *)NULL)))
    {
      const struct AvahiPoll *p;
      /* assertion simple_poll */
      assert(simple_poll$link1 != ((struct AvahiSimplePoll *)NULL));
      p=avahi_simple_poll_get(simple_poll$link1);
      p->watch_free(watch);
      watch = (struct AvahiWatch *)(void *)0;
    }

    simple_poll$link1 = (struct AvahiSimplePoll *)(void *)0;
  }

}

// strlcpy
// file domain.c line 482
static unsigned long int strlcpy(char *dest, const char *src, unsigned long int n)
{
  /* assertion dest */
  assert(dest != ((char *)NULL));
  /* assertion src */
  assert(src != ((const char *)NULL));
  if(n >= 1ul)
  {
    strncpy(dest, src, n - (unsigned long int)1);
    dest[(signed long int)(n - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(src);
  return return_value_strlen$1;
}

// strlcpy$link1
// file domain.c line 482
static unsigned long int strlcpy$link1(char *dest$link1, const char *src$link1, unsigned long int n$link1)
{
  /* assertion dest */
  assert(dest$link1 != ((char *)NULL));
  /* assertion src */
  assert(src$link1 != ((const char *)NULL));
  if(n$link1 >= 1ul)
  {
    strncpy(dest$link1, src$link1, n$link1 - (unsigned long int)1);
    dest$link1[(signed long int)(n$link1 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen$1$link1;
  return_value_strlen$1$link1=strlen(src$link1);
  return return_value_strlen$1$link1;
}

// system_poll
// file simple-watch.c line 626
static signed int system_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata)
{
  signed int return_value_poll$1;
  return_value_poll$1=poll(ufds, (unsigned long int)nfds, timeout);
  return return_value_poll$1;
}

// system_poll$link1
// file simple-watch.c line 626
static signed int system_poll$link1(struct pollfd *ufds$link1, unsigned int nfds$link1, signed int timeout$link1, void *userdata$link1)
{
  signed int return_value_poll$1$link1;
  return_value_poll$1$link1=poll(ufds$link1, (unsigned long int)nfds$link1, timeout$link1);
  return return_value_poll$1$link1;
}

// thread
// file thread-watch.c line 62
static void * thread(void *userdata)
{
  struct AvahiThreadedPoll *p = (struct AvahiThreadedPoll *)userdata;
  struct anonymous$17 mask;
  sigfillset(&mask);
  pthread_sigmask(0, &mask, (struct anonymous$17 *)(void *)0);
  pthread_mutex_lock(&p->mutex);
  p->retval=avahi_simple_poll_loop(p->simple_poll);
  pthread_mutex_unlock(&p->mutex);
  return (void *)0;
}

// thread$link1
// file thread-watch.c line 62
static void * thread$link1(void *userdata$link1)
{
  struct AvahiThreadedPoll *p$link1 = (struct AvahiThreadedPoll *)userdata$link1;
  struct anonymous$17 mask$link1;
  sigfillset(&mask$link1);
  pthread_sigmask(0, &mask$link1, (struct anonymous$17 *)(void *)0);
  pthread_mutex_lock(&p$link1->mutex);
  p$link1->retval=avahi_simple_poll_loop(p$link1->simple_poll);
  pthread_mutex_unlock(&p$link1->mutex);
  return (void *)0;
}

// timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback(struct AvahiTimeout *avahi_timeout, void *userdata)
{
  struct TimeoutData *timeout = (struct TimeoutData *)userdata;
  /* assertion avahi_timeout */
  assert(avahi_timeout != ((struct AvahiTimeout *)NULL));
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  timeout_data_ref(timeout);
  dbus_timeout_handle(timeout->dbus_timeout);
  if(!(timeout->avahi_timeout == ((struct AvahiTimeout *)NULL)))
    update_timeout(timeout);

  timeout_data_unref(timeout);
}

// timeout_callback$link1
// file simple-watch.c line 441
static void timeout_callback$link1(struct AvahiTimeout *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  /* assertion t->enabled */
  assert(t->enabled != 0);
  t->enabled = 0;
  t->callback(t, t->userdata);
}

// timeout_callback$link2
// file simple-watch.c line 441
static void timeout_callback$link2(struct AvahiTimeout *t$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1->dead != 0));
  /* assertion t->enabled */
  assert(t$link1->enabled != 0);
  t$link1->enabled = 0;
  t$link1->callback(t$link1, t$link1->userdata);
}

// timeout_data_ref
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref(struct TimeoutData *t)
{
  /* assertion t */
  assert(t != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t->ref >= 1);
  t->ref = t->ref + 1;
  return t;
}

// timeout_data_unref
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref(struct TimeoutData *t)
{
  /* assertion t */
  assert(t != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t->ref >= 1);
  t->ref = t->ref - 1;
  if(!(t->ref >= 1))
  {
    if(!(t->avahi_timeout == ((struct AvahiTimeout *)NULL)))
      t->poll_api->timeout_free(t->avahi_timeout);

    avahi_free((void *)t);
  }

}

// timeout_free
// file simple-watch.c line 284
static void timeout_free(struct AvahiTimeout *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  avahi_simple_poll_wakeup(t->simple_poll);
  t->dead = 1;
  t->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free$link1
// file simple-watch.c line 284
static void timeout_free$link1(struct AvahiTimeout *t$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1->dead != 0));
  avahi_simple_poll_wakeup(t$link1->simple_poll);
  t$link1->dead = 1;
  t$link1->simple_poll->timeout_req_cleanup = 1;
}

// timeout_new
// file simple-watch.c line 244
static struct AvahiTimeout * timeout_new(const struct AvahiPoll *api, struct timeval *tv, void (*callback)(struct AvahiTimeout *, void *), void *userdata)
{
  struct AvahiTimeout *t;
  struct AvahiSimplePoll *s;
  /* assertion api */
  assert(api != ((const struct AvahiPoll *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiTimeout *, void *))NULL));
  s = (struct AvahiSimplePoll *)api->userdata;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link2$link1((unsigned int)1, sizeof(struct AvahiTimeout) /*64ul*/ );
  t = (struct AvahiTimeout *)return_value_avahi_new_internal$1;
  if(t == ((struct AvahiTimeout *)NULL))
    return (struct AvahiTimeout *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s);
    t->simple_poll = s;
    t->dead = 0;
    t->enabled = (signed int)!(!(tv != ((struct timeval *)NULL)));
    if(!(t->enabled == 0))
      t->expiry = *tv;

    t->callback = callback;
    t->userdata = userdata;
    do
    {
      struct AvahiTimeout **_head = &s->timeouts;
      struct AvahiTimeout *_item = t;
      /* assertion _item */
      assert(_item != ((struct AvahiTimeout *)NULL));
      _item->timeouts_next = *_head;
      if(!(_item->timeouts_next == ((struct AvahiTimeout *)NULL)))
        _item->timeouts_next->timeouts_prev = _item;

      _item->timeouts_prev = (struct AvahiTimeout *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    return t;
  }
}

// timeout_new$link1
// file simple-watch.c line 244
static struct AvahiTimeout * timeout_new$link1(const struct AvahiPoll *api$link1, struct timeval *tv$link1, void (*callback$link1)(struct AvahiTimeout *, void *), void *userdata$link1)
{
  struct AvahiTimeout *t$link1;
  struct AvahiSimplePoll *s$link1;
  /* assertion api */
  assert(api$link1 != ((const struct AvahiPoll *)NULL));
  /* assertion callback */
  assert(callback$link1 != ((void (*)(struct AvahiTimeout *, void *))NULL));
  s$link1 = (struct AvahiSimplePoll *)api$link1->userdata;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal$1$link1;
  return_value_avahi_new_internal$1$link1=avahi_new_internal$link2$link2((unsigned int)1, sizeof(struct AvahiTimeout) /*64ul*/ );
  t$link1 = (struct AvahiTimeout *)return_value_avahi_new_internal$1$link1;
  if(t$link1 == ((struct AvahiTimeout *)NULL))
    return (struct AvahiTimeout *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link1);
    t$link1->simple_poll = s$link1;
    t$link1->dead = 0;
    t$link1->enabled = (signed int)!(!(tv$link1 != ((struct timeval *)NULL)));
    if(!(t$link1->enabled == 0))
      t$link1->expiry = *tv$link1;

    t$link1->callback = callback$link1;
    t$link1->userdata = userdata$link1;
    do
    {
      struct AvahiTimeout **_head$link1 = &s$link1->timeouts;
      struct AvahiTimeout *_item$link1 = t$link1;
      /* assertion _item */
      assert(_item$link1 != ((struct AvahiTimeout *)NULL));
      _item$link1->timeouts_next = *_head$link1;
      if(!(_item$link1->timeouts_next == ((struct AvahiTimeout *)NULL)))
        _item$link1->timeouts_next->timeouts_prev = _item$link1;

      _item$link1->timeouts_prev = (struct AvahiTimeout *)(void *)0;
      *_head$link1 = _item$link1;
    }
    while((_Bool)0);
    return t$link1;
  }
}

// timeout_toggled
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct TimeoutData *timeout;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  void *return_value_dbus_timeout_get_data$1;
  return_value_dbus_timeout_get_data$1=dbus_timeout_get_data(dbus_timeout);
  timeout = (struct TimeoutData *)return_value_dbus_timeout_get_data$1;
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  update_timeout(timeout);
}

// timeout_update
// file simple-watch.c line 273
static void timeout_update(struct AvahiTimeout *t, struct timeval *tv)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  avahi_simple_poll_wakeup(t->simple_poll);
  t->enabled = (signed int)!(!(tv != ((struct timeval *)NULL)));
  if(!(t->enabled == 0))
    t->expiry = *tv;

}

// timeout_update$link1
// file simple-watch.c line 273
static void timeout_update$link1(struct AvahiTimeout *t$link1, struct timeval *tv$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1->dead != 0));
  avahi_simple_poll_wakeup(t$link1->simple_poll);
  t$link1->enabled = (signed int)!(!(tv$link1 != ((struct timeval *)NULL)));
  if(!(t$link1->enabled == 0))
    t$link1->expiry = *tv$link1;

}

// translate_avahi_to_dbus
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus(enum anonymous$6 e)
{
  unsigned int f = (unsigned int)0;
  if(!((AVAHI_WATCH_IN & (signed int)e) == 0))
    f = f | (unsigned int)1;

  if(!((AVAHI_WATCH_OUT & (signed int)e) == 0))
    f = f | (unsigned int)2;

  if(!((AVAHI_WATCH_ERR & (signed int)e) == 0))
    f = f | (unsigned int)4;

  if(!((AVAHI_WATCH_HUP & (signed int)e) == 0))
    f = f | (unsigned int)8;

  return f;
}

// translate_dbus_to_avahi
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous$6 translate_dbus_to_avahi(unsigned int f)
{
  enum anonymous$6 e = (enum anonymous$6)0;
  if(!((1u & f) == 0u))
    e = e | (enum anonymous$6)AVAHI_WATCH_IN;

  if(!((2u & f) == 0u))
    e = e | (enum anonymous$6)AVAHI_WATCH_OUT;

  if(!((4u & f) == 0u))
    e = e | (enum anonymous$6)AVAHI_WATCH_ERR;

  if(!((8u & f) == 0u))
    e = e | (enum anonymous$6)AVAHI_WATCH_HUP;

  return e;
}

// update_timeout
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout(struct TimeoutData *timeout)
{
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  /* assertion timeout->ref >= 1 */
  assert(timeout->ref >= 1);
  unsigned int return_value_dbus_timeout_get_enabled$2;
  return_value_dbus_timeout_get_enabled$2=dbus_timeout_get_enabled(timeout->dbus_timeout);
  if(!(return_value_dbus_timeout_get_enabled$2 == 0u))
  {
    struct timeval tv;
    signed int return_value_dbus_timeout_get_interval$1;
    return_value_dbus_timeout_get_interval$1=dbus_timeout_get_interval(timeout->dbus_timeout);
    avahi_elapse_time(&tv, (unsigned int)return_value_dbus_timeout_get_interval$1, (unsigned int)0);
    timeout->poll_api->timeout_update(timeout->avahi_timeout, &tv);
  }

  else
    timeout->poll_api->timeout_update(timeout->avahi_timeout, (struct timeval *)(void *)0);
}

// update_watch
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch(const struct AvahiPoll *poll_api, struct DBusWatch *dbus_watch)
{
  struct AvahiWatch *avahi_watch;
  unsigned int b;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  void *return_value_dbus_watch_get_data$1;
  return_value_dbus_watch_get_data$1=dbus_watch_get_data(dbus_watch);
  avahi_watch = (struct AvahiWatch *)return_value_dbus_watch_get_data$1;
  b=dbus_watch_get_enabled(dbus_watch);
  if(avahi_watch == ((struct AvahiWatch *)NULL) && !(b == 0u))
  {
    signed int return_value_dbus_watch_get_unix_fd$2;
    return_value_dbus_watch_get_unix_fd$2=dbus_watch_get_unix_fd(dbus_watch);
    unsigned int return_value_dbus_watch_get_flags$3;
    return_value_dbus_watch_get_flags$3=dbus_watch_get_flags(dbus_watch);
    enum anonymous$6 return_value_translate_dbus_to_avahi$4;
    return_value_translate_dbus_to_avahi$4=translate_dbus_to_avahi(return_value_dbus_watch_get_flags$3);
    avahi_watch=poll_api->watch_new(poll_api, return_value_dbus_watch_get_unix_fd$2, return_value_translate_dbus_to_avahi$4, watch_callback$link1, (void *)dbus_watch);
    if(avahi_watch == ((struct AvahiWatch *)NULL))
      return (unsigned int)0;

    dbus_watch_set_data(dbus_watch, (void *)avahi_watch, (void (*)(void *))(void *)0);
  }

  else
    if(b == 0u && !(avahi_watch == ((struct AvahiWatch *)NULL)))
    {
      poll_api->watch_free(avahi_watch);
      dbus_watch_set_data(dbus_watch, (void *)0, (void (*)(void *))(void *)0);
    }

    else
      if(!(avahi_watch == ((struct AvahiWatch *)NULL)))
      {
        unsigned int return_value_dbus_watch_get_flags$5;
        return_value_dbus_watch_get_flags$5=dbus_watch_get_flags(dbus_watch);
        poll_api->watch_update(avahi_watch, (enum anonymous$6)return_value_dbus_watch_get_flags$5);
      }

  return (unsigned int)1;
}

// watch_callback
// file sigint.c line 67
static void watch_callback(struct AvahiWatch *w, signed int fd, enum anonymous$6 event, void *userdata)
{
  signed int s;
  signed long int l;
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  /* assertion fd == pipe_fds[0] */
  assert(fd == pipe_fds[(signed long int)0]);
  /* assertion event == AVAHI_WATCH_IN */
  assert((signed int)event == AVAHI_WATCH_IN);
  l=read(fd, (void *)&s, sizeof(signed int) /*4ul*/ );
  /* assertion l == sizeof(s) */
  assert((unsigned long int)l == sizeof(signed int) /*4ul*/ );
  fprintf(stderr, "Got %s, quitting.\n", s == 2 ? "SIGINT" : "SIGTERM");
  avahi_simple_poll_quit(simple_poll$link1);
}

// watch_callback$link1
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback$link1(struct AvahiWatch *avahi_watch, signed int fd$link1, enum anonymous$6 events, void *userdata$link1)
{
  struct DBusWatch *dbus_watch = (struct DBusWatch *)userdata$link1;
  /* assertion avahi_watch */
  assert(avahi_watch != ((struct AvahiWatch *)NULL));
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  unsigned int return_value_translate_avahi_to_dbus$1;
  return_value_translate_avahi_to_dbus$1=translate_avahi_to_dbus(events);
  dbus_watch_handle(dbus_watch, return_value_translate_avahi_to_dbus$1);
}

// watch_free
// file simple-watch.c line 203
static void watch_free(struct AvahiWatch *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  avahi_simple_poll_wakeup(w->simple_poll);
  remove_pollfd(w);
  w->dead = 1;
  w->simple_poll->n_watches = w->simple_poll->n_watches - 1;
  w->simple_poll->watch_req_cleanup = 1;
}

// watch_free$link1
// file simple-watch.c line 203
static void watch_free$link1(struct AvahiWatch *w$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1->dead != 0));
  avahi_simple_poll_wakeup(w$link1->simple_poll);
  remove_pollfd$link1(w$link1);
  w$link1->dead = 1;
  w$link1->simple_poll->n_watches = w$link1->simple_poll->n_watches - 1;
  w$link1->simple_poll->watch_req_cleanup = 1;
}

// watch_get_events
// file simple-watch.c line 184
static enum anonymous$6 watch_get_events(struct AvahiWatch *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  if(!(w->idx == -1))
  {
    if(w->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous$6)(w->simple_poll->pollfds + (signed long int)w->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous$6)0;
  }
}

// watch_get_events$link1
// file simple-watch.c line 184
static enum anonymous$6 watch_get_events$link1(struct AvahiWatch *w$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1->dead != 0));
  if(!(w$link1->idx == -1))
  {
    if(w$link1->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous$6)(w$link1->simple_poll->pollfds + (signed long int)w$link1->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous$6)0;
  }
}

// watch_new
// file simple-watch.c line 132
static struct AvahiWatch * watch_new(const struct AvahiPoll *api, signed int fd, enum anonymous$6 event, void (*callback)(struct AvahiWatch *, signed int, enum anonymous$6, void *), void *userdata)
{
  struct AvahiWatch *w;
  struct AvahiSimplePoll *s;
  /* assertion api */
  assert(api != ((const struct AvahiPoll *)NULL));
  /* assertion fd >= 0 */
  assert(fd >= 0);
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiWatch *, signed int, enum anonymous$6, void *))NULL));
  s = (struct AvahiSimplePoll *)api->userdata;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link2$link1((unsigned int)1, sizeof(struct AvahiWatch) /*56ul*/ );
  w = (struct AvahiWatch *)return_value_avahi_new_internal$1;
  if(w == ((struct AvahiWatch *)NULL))
    return (struct AvahiWatch *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s);
    w->simple_poll = s;
    w->dead = 0;
    w->pollfd.fd = fd;
    w->pollfd.events = (signed short int)event;
    w->pollfd.revents = (signed short int)0;
    w->callback = callback;
    w->userdata = userdata;
    w->idx = -1;
    s->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch **_head = &s->watches;
      struct AvahiWatch *_item = w;
      /* assertion _item */
      assert(_item != ((struct AvahiWatch *)NULL));
      _item->watches_next = *_head;
      if(!(_item->watches_next == ((struct AvahiWatch *)NULL)))
        _item->watches_next->watches_prev = _item;

      _item->watches_prev = (struct AvahiWatch *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    s->n_watches = s->n_watches + 1;
    return w;
  }
}

// watch_new$link1
// file simple-watch.c line 132
static struct AvahiWatch * watch_new$link1(const struct AvahiPoll *api$link1, signed int fd$link1, enum anonymous$6 event$link1, void (*callback$link1)(struct AvahiWatch *, signed int, enum anonymous$6, void *), void *userdata$link1)
{
  struct AvahiWatch *w$link1;
  struct AvahiSimplePoll *s$link1;
  /* assertion api */
  assert(api$link1 != ((const struct AvahiPoll *)NULL));
  /* assertion fd >= 0 */
  assert(fd$link1 >= 0);
  /* assertion callback */
  assert(callback$link1 != ((void (*)(struct AvahiWatch *, signed int, enum anonymous$6, void *))NULL));
  s$link1 = (struct AvahiSimplePoll *)api$link1->userdata;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal$1$link1;
  return_value_avahi_new_internal$1$link1=avahi_new_internal$link2$link2((unsigned int)1, sizeof(struct AvahiWatch) /*56ul*/ );
  w$link1 = (struct AvahiWatch *)return_value_avahi_new_internal$1$link1;
  if(w$link1 == ((struct AvahiWatch *)NULL))
    return (struct AvahiWatch *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link1);
    w$link1->simple_poll = s$link1;
    w$link1->dead = 0;
    w$link1->pollfd.fd = fd$link1;
    w$link1->pollfd.events = (signed short int)event$link1;
    w$link1->pollfd.revents = (signed short int)0;
    w$link1->callback = callback$link1;
    w$link1->userdata = userdata$link1;
    w$link1->idx = -1;
    s$link1->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch **_head$link1 = &s$link1->watches;
      struct AvahiWatch *_item$link1 = w$link1;
      /* assertion _item */
      assert(_item$link1 != ((struct AvahiWatch *)NULL));
      _item$link1->watches_next = *_head$link1;
      if(!(_item$link1->watches_next == ((struct AvahiWatch *)NULL)))
        _item$link1->watches_next->watches_prev = _item$link1;

      _item$link1->watches_prev = (struct AvahiWatch *)(void *)0;
      *_head$link1 = _item$link1;
    }
    while((_Bool)0);
    s$link1->n_watches = s$link1->n_watches + 1;
    return w$link1;
  }
}

// watch_toggled
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous$13 *d = (struct anonymous$13 *)userdata;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$13 *)NULL));
  update_watch(d->poll_api, dbus_watch);
}

// watch_update
// file simple-watch.c line 168
static void watch_update(struct AvahiWatch *w, enum anonymous$6 events)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  avahi_simple_poll_wakeup(w->simple_poll);
  w->pollfd.events = (signed short int)events;
  if(!(w->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w->simple_poll != ((struct AvahiSimplePoll *)NULL));
    w->simple_poll->pollfds[(signed long int)w->idx] = w->pollfd;
  }

  else
    w->simple_poll->rebuild_pollfds = 1;
}

// watch_update$link1
// file simple-watch.c line 168
static void watch_update$link1(struct AvahiWatch *w$link1, enum anonymous$6 events$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1->dead != 0));
  avahi_simple_poll_wakeup(w$link1->simple_poll);
  w$link1->pollfd.events = (signed short int)events$link1;
  if(!(w$link1->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w$link1->simple_poll != ((struct AvahiSimplePoll *)NULL));
    w$link1->simple_poll->pollfds[(signed long int)w$link1->idx] = w$link1->pollfd;
  }

  else
    w$link1->simple_poll->rebuild_pollfds = 1;
}

// xcalloc
// file malloc.c line 89
static void * xcalloc(unsigned long int nmemb, unsigned long int size)
{
  void *p;
  if(nmemb == 0ul || size == 0ul)
    return (void *)0;

  else
  {
    p=calloc(nmemb, size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xcalloc$link1
// file malloc.c line 89
static void * xcalloc$link1(unsigned long int nmemb$link1, unsigned long int size$link1)
{
  void *p$link1;
  if(nmemb$link1 == 0ul || size$link1 == 0ul)
    return (void *)0;

  else
  {
    p$link1=calloc(nmemb$link1, size$link1);
    if(p$link1 == NULL)
      oom$link1();

    return p$link1;
  }
}

// xmalloc
// file malloc.c line 62
static void * xmalloc(unsigned long int size)
{
  void *p;
  if(size == 0ul)
    return (void *)0;

  else
  {
    p=malloc(size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xmalloc$link1
// file malloc.c line 62
static void * xmalloc$link1(unsigned long int size$link1)
{
  void *p$link1;
  if(size$link1 == 0ul)
    return (void *)0;

  else
  {
    p$link1=malloc(size$link1);
    if(p$link1 == NULL)
      oom$link1();

    return p$link1;
  }
}

// xrealloc
// file malloc.c line 75
static void * xrealloc(void *p, unsigned long int size)
{
  if(size == 0ul)
  {
    free(p);
    return (void *)0;
  }

  else
  {
    p=realloc(p, size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xrealloc$link1
// file malloc.c line 75
static void * xrealloc$link1(void *p$link1, unsigned long int size$link1)
{
  if(size$link1 == 0ul)
  {
    free(p$link1);
    return (void *)0;
  }

  else
  {
    p$link1=realloc(p$link1, size$link1);
    if(p$link1 == NULL)
      oom$link1();

    return p$link1;
  }
}

