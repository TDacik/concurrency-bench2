// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$5;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$6;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$0;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$4;

// tag-#anon#ST[ARR2{S32}$S32$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/types.h line 134
struct anonymous$2;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous$1;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$3;

// tag-XDR
// file /usr/include/rpc/xdr.h line 109
struct XDR;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-fuse
// file /usr/include/fuse/fuse.h line 45
struct fuse;

// tag-fuse_context
// file /usr/include/fuse/fuse.h line 601
struct fuse_context;

// tag-fuse_dirhandle
// file /usr/include/fuse/fuse.h line 62
struct fuse_dirhandle;

// tag-fuse_file_info_compat
// file /usr/include/fuse/fuse_common_compat.h line 12
struct fuse_file_info_compat;

// tag-fuse_operations_compat22
// file /usr/include/fuse/fuse_compat.h line 71
struct fuse_operations_compat22;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statfs
// file /usr/include/x86_64-linux-gnu/bits/statfs.h line 24
struct statfs;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-utimbuf
// file /usr/include/utime.h line 37
struct utimbuf;

// tag-xdr_op
// file /usr/include/rpc/xdr.h line 81
enum xdr_op { XDR_ENCODE=0, XDR_DECODE=1, XDR_FREE=2 };

// tag-xdr_ops
// file /usr/include/rpc/xdr.h line 113
struct xdr_ops;

#ifndef NULL
#define NULL ((void*)0)
#endif

// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _readn
// file common.c line 132
signed int _readn(signed int fd, char *ptr, signed int nbytes, signed int timeout_secs, void (*timeout_function)(), signed int doselect);
// _readn::timeout_function$object
//
void timeout_function$object();
// _writen
// file common.c line 177
signed int _writen(signed int fd, char *ptr, signed int nbytes, signed int timeout_secs, void (*timeout_function)(), signed int doselect);
// _writen::timeout_function$object
//
void timeout_function$object();
// bcopy
// file /usr/include/string.h line 454
extern void bcopy(const void *, void *, unsigned long int);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bindsocket
// file common.c line 51
signed int bindsocket(signed int port);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// error_die
// file common.c line 343
void error_die(char *err);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fuse_get_context
// file /usr/include/fuse/fuse.h line 722
struct fuse_context * fuse_get_context(void);
// fuse_main_real_compat22
// file /usr/include/fuse/fuse_compat.h line 117
signed int fuse_main_real_compat22(signed int, char **, struct fuse_operations_compat22 *, unsigned long int);
// fuse_unmount_compat22
// file /usr/include/fuse/fuse_common_compat.h line 26
void fuse_unmount_compat22(const char *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// handle_mount
// file ltspfs.c line 983
void handle_mount(char *mp);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// info
// file common.c line 356
void info(const char *format, ...);
// init_pkt
// file ltspfs.c line 63
void init_pkt(struct XDR *in, struct XDR *out, char *inbuf, char *outbuf);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// ltspfs_chmod
// file ltspfs.c line 647
static signed int ltspfs_chmod(const char *path, unsigned int mode);
// ltspfs_chown
// file ltspfs.c line 672
static signed int ltspfs_chown(const char *path, unsigned int uid, unsigned int gid);
// ltspfs_fsync
// file ltspfs.c line 945
static signed int ltspfs_fsync(const char *path, signed int isdatasync, struct fuse_file_info_compat *fi);
// ltspfs_getattr
// file ltspfs.c line 291
static signed int ltspfs_getattr(const char *path, struct stat *stbuf);
// ltspfs_init
// file ltspfs.c line 964
static void * ltspfs_init(void);
// ltspfs_link
// file ltspfs.c line 636
static signed int ltspfs_link(const char *from, const char *to);
// ltspfs_mkdir
// file ltspfs.c line 518
static signed int ltspfs_mkdir(const char *path, unsigned int mode);
// ltspfs_mknod
// file ltspfs.c line 492
static signed int ltspfs_mknod(const char *path, unsigned int mode, unsigned long int rdev);
// ltspfs_onepath
// file ltspfs.c line 543
static signed int ltspfs_onepath(signed int opcode, const char *path);
// ltspfs_open
// file ltspfs.c line 749
static signed int ltspfs_open(const char *path, struct fuse_file_info_compat *fi);
// ltspfs_read
// file ltspfs.c line 775
static signed int ltspfs_read(const char *path, char *buf, unsigned long int size, signed long int offset, struct fuse_file_info_compat *fi);
// ltspfs_readdir
// file ltspfs.c line 433
static signed int ltspfs_readdir(const char *path, void *buf, signed int (*filler)(void *, const char *, struct stat *, signed long int), signed long int offset, struct fuse_file_info_compat *fi);
// ltspfs_readdir::filler$object
//
signed int filler$object(void *, const char *, struct stat *, signed long int);
// ltspfs_readlink
// file ltspfs.c line 379
static signed int ltspfs_readlink(const char *path, char *buf, unsigned long int size);
// ltspfs_release
// file ltspfs.c line 930
static signed int ltspfs_release(const char *path, struct fuse_file_info_compat *fi);
// ltspfs_rename
// file ltspfs.c line 625
static signed int ltspfs_rename(const char *from, const char *to);
// ltspfs_rmdir
// file ltspfs.c line 577
static signed int ltspfs_rmdir(const char *path);
// ltspfs_sendauth
// file ltspfs.c line 225
signed int ltspfs_sendauth(void);
// ltspfs_statfs
// file ltspfs.c line 881
static signed int ltspfs_statfs(const char *path, struct statfs *stbuf);
// ltspfs_symlink
// file ltspfs.c line 614
static signed int ltspfs_symlink(const char *from, const char *to);
// ltspfs_truncate
// file ltspfs.c line 698
static signed int ltspfs_truncate(const char *path, signed long int size);
// ltspfs_twopath
// file ltspfs.c line 588
static signed int ltspfs_twopath(signed int opcode, const char *from, const char *to);
// ltspfs_unlink
// file ltspfs.c line 566
static signed int ltspfs_unlink(const char *path);
// ltspfs_utime
// file ltspfs.c line 723
static signed int ltspfs_utime(const char *path, struct utimbuf *buf);
// ltspfs_write
// file ltspfs.c line 832
static signed int ltspfs_write(const char *path, const char *buf, unsigned long int size, signed long int offset, struct fuse_file_info_compat *fi);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// opensocket
// file common.h line 25
signed int opensocket(char *hostname, signed int port);
// parse_return
// file ltspfs.c line 196
static signed int parse_return(struct XDR *xdr);
// ping_timeout
// file ltspfs.c line 161
void ping_timeout(void *nothing);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$3 *, const union anonymous$7 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$3 *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readn
// file common.h line 26
signed int readn(signed int fd, char *ptr, signed int maxlen);
// readpacket
// file ltspfs.c line 92
signed int readpacket(struct XDR *in, char *packetbuffer);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$4 *, struct anonymous$4 *, struct anonymous$4 *, struct timeval *);
// send_recv
// file ltspfs.c line 145
void send_recv(struct XDR *in, struct XDR *out, char *inbuf, char *outbuf);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// status_return
// file common.c line 307
signed int status_return(signed int sockfd, signed int result);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// timeout
// file ltspfs.c line 79
void timeout(void);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writen
// file common.h line 27
signed int writen(signed int fd, char *ptr, signed int nbytes);
// writepacket
// file ltspfs.c line 114
signed int writepacket(struct XDR *out, char *packetbuffer);
// xdr_int
// file /usr/include/rpc/xdr.h line 288
extern signed int xdr_int(struct XDR *, signed int *);
// xdr_long
// file /usr/include/rpc/xdr.h line 290
extern signed int xdr_long(struct XDR *, signed long int *);
// xdr_longlong_t
// file /usr/include/rpc/xdr.h line 294
extern signed int xdr_longlong_t(struct XDR *, signed long int *);
// xdr_string
// file /usr/include/rpc/xdr.h line 314
extern signed int xdr_string(struct XDR *, char **, unsigned int);
// xdr_u_char
// file /usr/include/rpc/xdr.h line 319
extern signed int xdr_u_char(struct XDR *, unsigned char *);
// xdr_u_int
// file /usr/include/rpc/xdr.h line 289
extern signed int xdr_u_int(struct XDR *, unsigned int *);
// xdr_u_longlong_t
// file /usr/include/rpc/xdr.h line 295
extern signed int xdr_u_longlong_t(struct XDR *, unsigned long int *);
// xdrmem_create
// file /usr/include/rpc/xdr.h line 350
extern void xdrmem_create(struct XDR *, char *, unsigned int, enum xdr_op);

struct anonymous$5
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$1 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$0 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$6 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$5 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$6
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$0
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$4
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$2
{
  // __val
  signed int __val[2l];
};

struct anonymous$1
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$0 *visuals;
};

union anonymous$7
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct XDR
{
  // x_op
  enum xdr_op x_op;
  // x_ops
  struct xdr_ops *x_ops;
  // x_public
  char *x_public;
  // x_private
  char *x_private;
  // x_base
  char *x_base;
  // x_handy
  unsigned int x_handy;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct fuse_context
{
  // fuse
  struct fuse *fuse;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // pid
  signed int pid;
  // private_data
  void *private_data;
  // umask
  unsigned int umask;
};

struct fuse_file_info_compat
{
  // flags
  signed int flags;
  // fh
  unsigned long int fh;
  // writepage
  signed int writepage;
  // direct_io
  unsigned int direct_io : 1;
  // keep_cache
  unsigned int keep_cache : 1;
};

struct fuse_operations_compat22
{
  // getattr
  signed int (*getattr)(const char *, struct stat *);
  // readlink
  signed int (*readlink)(const char *, char *, unsigned long int);
  // getdir
  signed int (*getdir)(const char *, struct fuse_dirhandle *, signed int (*)(struct fuse_dirhandle *, const char *, signed int, unsigned long int));
  // mknod
  signed int (*mknod)(const char *, unsigned int, unsigned long int);
  // mkdir
  signed int (*mkdir)(const char *, unsigned int);
  // unlink
  signed int (*unlink)(const char *);
  // rmdir
  signed int (*rmdir)(const char *);
  // symlink
  signed int (*symlink)(const char *, const char *);
  // rename
  signed int (*rename)(const char *, const char *);
  // link
  signed int (*link)(const char *, const char *);
  // chmod
  signed int (*chmod)(const char *, unsigned int);
  // chown
  signed int (*chown)(const char *, unsigned int, unsigned int);
  // truncate
  signed int (*truncate)(const char *, signed long int);
  // utime
  signed int (*utime)(const char *, struct utimbuf *);
  // open
  signed int (*open)(const char *, struct fuse_file_info_compat *);
  // read
  signed int (*read)(const char *, char *, unsigned long int, signed long int, struct fuse_file_info_compat *);
  // write
  signed int (*write)(const char *, const char *, unsigned long int, signed long int, struct fuse_file_info_compat *);
  // statfs
  signed int (*statfs)(const char *, struct statfs *);
  // flush
  signed int (*flush)(const char *, struct fuse_file_info_compat *);
  // release
  signed int (*release)(const char *, struct fuse_file_info_compat *);
  // fsync
  signed int (*fsync)(const char *, signed int, struct fuse_file_info_compat *);
  // setxattr
  signed int (*setxattr)(const char *, const char *, const char *, unsigned long int, signed int);
  // getxattr
  signed int (*getxattr)(const char *, const char *, char *, unsigned long int);
  // listxattr
  signed int (*listxattr)(const char *, char *, unsigned long int);
  // removexattr
  signed int (*removexattr)(const char *, const char *);
  // opendir
  signed int (*opendir)(const char *, struct fuse_file_info_compat *);
  // readdir
  signed int (*readdir)(const char *, void *, signed int (*)(void *, const char *, struct stat *, signed long int), signed long int, struct fuse_file_info_compat *);
  // releasedir
  signed int (*releasedir)(const char *, struct fuse_file_info_compat *);
  // fsyncdir
  signed int (*fsyncdir)(const char *, signed int, struct fuse_file_info_compat *);
  // init
  void * (*init)(void);
  // destroy
  void (*destroy)(void *);
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct statfs
{
  // f_type
  signed long int f_type;
  // f_bsize
  signed long int f_bsize;
  // f_blocks
  unsigned long int f_blocks;
  // f_bfree
  unsigned long int f_bfree;
  // f_bavail
  unsigned long int f_bavail;
  // f_files
  unsigned long int f_files;
  // f_ffree
  unsigned long int f_ffree;
  // f_fsid
  struct anonymous$2 f_fsid;
  // f_namelen
  signed long int f_namelen;
  // f_frsize
  signed long int f_frsize;
  // f_flags
  signed long int f_flags;
  // f_spare
  signed long int f_spare[4l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct utimbuf
{
  // actime
  signed long int actime;
  // modtime
  signed long int modtime;
};

struct xdr_ops
{
  // x_getlong
  signed int (*x_getlong)(struct XDR *, signed long int *);
  // x_putlong
  signed int (*x_putlong)(struct XDR *, const signed long int *);
  // x_getbytes
  signed int (*x_getbytes)(struct XDR *, char *, unsigned int);
  // x_putbytes
  signed int (*x_putbytes)(struct XDR *, const char *, unsigned int);
  // x_getpostn
  unsigned int (*x_getpostn)(const struct XDR *);
  // x_setpostn
  signed int (*x_setpostn)(struct XDR *, unsigned int);
  // x_inline
  signed int * (*x_inline)(struct XDR *, unsigned int);
  // x_destroy
  void (*x_destroy)(struct XDR *);
  // x_getint32
  signed int (*x_getint32)(struct XDR *, signed int *);
  // x_putint32
  signed int (*x_putint32)(struct XDR *, const signed int *);
};


// debug
// file ltspfs.c line 54
signed int debug = 0;
// fc
// file ltspfs.c line 53
static struct fuse_context *fc = (struct fuse_context *)(void *)0;
// fuse_mount_point
// file ltspfs.c line 52
static char *fuse_mount_point;
// lock
// file ltspfs.c line 50
static union anonymous$3 lock;
// ltspfs_oper
// file ltspfs.c line 1012
static struct fuse_operations_compat22 ltspfs_oper;
// ltspfs_oper
// file ltspfs.c line 1012
static struct fuse_operations_compat22 ltspfs_oper = { .getattr=ltspfs_getattr, .readlink=ltspfs_readlink, .getdir=((signed int (*)(const char *, struct fuse_dirhandle *, signed int (*)(struct fuse_dirhandle *, const char *, signed int, unsigned long int)))NULL),
    .mknod=ltspfs_mknod,
    .mkdir=ltspfs_mkdir, .unlink=ltspfs_unlink,
    .rmdir=ltspfs_rmdir, .symlink=ltspfs_symlink,
    .rename=ltspfs_rename, .link=ltspfs_link,
    .chmod=ltspfs_chmod, .chown=ltspfs_chown,
    .truncate=ltspfs_truncate, .utime=ltspfs_utime,
    .open=ltspfs_open, .read=ltspfs_read,
    .write=ltspfs_write, .statfs=ltspfs_statfs,
    .flush=((signed int (*)(const char *, struct fuse_file_info_compat *))NULL), .release=ltspfs_release,
    .fsync=ltspfs_fsync, .setxattr=((signed int (*)(const char *, const char *, const char *, unsigned long int, signed int))NULL),
    .getxattr=((signed int (*)(const char *, const char *, char *, unsigned long int))NULL),
    .listxattr=((signed int (*)(const char *, char *, unsigned long int))NULL),
    .removexattr=((signed int (*)(const char *, const char *))NULL),
    .opendir=((signed int (*)(const char *, struct fuse_file_info_compat *))NULL),
    .readdir=ltspfs_readdir,
    .releasedir=((signed int (*)(const char *, struct fuse_file_info_compat *))NULL), .fsyncdir=((signed int (*)(const char *, signed int, struct fuse_file_info_compat *))NULL),
    .init=ltspfs_init,
    .destroy=((void (*)(void *))NULL) };
// sockfd
// file ltspfs.c line 51
static signed int sockfd;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// syslogopen
// file ltspfs.c line 55
signed int syslogopen = 0;

// _readn
// file common.c line 132
signed int _readn(signed int fd, char *ptr, signed int nbytes, signed int timeout_secs, void (*timeout_function)(), signed int doselect)
{
  signed int nleft;
  signed int nread;
  signed int r;
  struct anonymous$4 set;
  struct timeval ltspfs_timeout;
  struct timeval *timeout_ptr = &ltspfs_timeout;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$4) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&set)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  if(doselect == 0)
    timeout_ptr = (struct timeval *)(void *)0;

  nleft = nbytes;
  while(nleft >= 1)
  {
    ltspfs_timeout.tv_sec = (signed long int)timeout_secs;
    ltspfs_timeout.tv_usec = (signed long int)0;
    r=select(1024, &set, (struct anonymous$4 *)(void *)0, (struct anonymous$4 *)(void *)0, timeout_ptr);
    if(!(r >= 0))
      return r;

    else
      if(r == 0)
        timeout_function();

      else
      {
        signed long int return_value_read$1;
        return_value_read$1=read(fd, (void *)ptr, (unsigned long int)nleft);
        nread = (signed int)return_value_read$1;
        if(!(nread >= 0))
          return nread;

        else
          if(nread == 0)
            break;

        nleft = nleft - nread;
        ptr = ptr + (signed long int)nread;
      }
  }
  return nbytes - nleft;
}

// _writen
// file common.c line 177
signed int _writen(signed int fd, char *ptr, signed int nbytes, signed int timeout_secs, void (*timeout_function)(), signed int doselect)
{
  signed int nleft;
  signed int nwritten;
  signed int r;
  struct anonymous$4 set;
  struct timeval ltspfs_timeout;
  struct timeval *timeout_ptr = &ltspfs_timeout;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$4) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&set)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  if(doselect == 0)
    timeout_ptr = (struct timeval *)(void *)0;

  nleft = nbytes;
  while(nleft >= 1)
  {
    ltspfs_timeout.tv_sec = (signed long int)timeout_secs;
    ltspfs_timeout.tv_usec = (signed long int)0;
    r=select(1024, (struct anonymous$4 *)(void *)0, &set, (struct anonymous$4 *)(void *)0, timeout_ptr);
    if(!(r >= 0))
      return r;

    else
      if(r == 0)
        timeout_function();

      else
      {
        signed long int return_value_write$1;
        return_value_write$1=write(fd, (const void *)ptr, (unsigned long int)nleft);
        nwritten = (signed int)return_value_write$1;
        if(!(nwritten >= 1))
          return nwritten;

        nleft = nleft - nwritten;
        ptr = ptr + (signed long int)nwritten;
      }
  }
  return nbytes - nleft;
}

// bindsocket
// file common.c line 51
signed int bindsocket(signed int port)
{
  struct sockaddr_in serv_addr;
  signed int s;
  s=socket(2, 1, 0);
  if(!(s >= 0))
    error_die("Can't open socket");

  memset((void *)(char *)&serv_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  serv_addr.sin_family = (unsigned short int)2;
  serv_addr.sin_addr.s_addr=htonl((unsigned int)0x00000000);
  serv_addr.sin_port=htons((unsigned short int)port);
  signed int return_value_bind$1;
  return_value_bind$1=bind(s, (struct sockaddr *)&serv_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_bind$1 >= 0))
    error_die("Can't bind port");

  signed int return_value_listen$2;
  return_value_listen$2=listen(s, 5);
  if(!(return_value_listen$2 >= 0))
    error_die("Listen failed");

  return s;
}

// error_die
// file common.c line 343
void error_die(char *err)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  char *return_value_strerror$3;
  return_value_strerror$3=strerror(*return_value___errno_location$2);
  info("%s (errno = %d : %s): Shutting down\n", err, *return_value___errno_location$1, return_value_strerror$3);
  exit(1);
}

// handle_mount
// file ltspfs.c line 983
void handle_mount(char *mp)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 25;
  char *ptr = mp;
  signed int res;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_string(&out, &ptr, (unsigned int)4096);
  writepacket(&out, outbuf);
  readpacket(&in, inbuf);
  xdr_int(&in, &res);
  if(!(res == 0))
  {
    fprintf(stderr, "Couldn't mount %s\n", mp);
    close(sockfd);
    exit(1);
  }

}

// info
// file common.c line 356
void info(const char *format, ...)
{
  void **ap = (void **)&format;
  if(!(syslogopen == 0))
    vsyslog(6, format, ap);

  if(!(debug == 0))
    vfprintf(stderr, format, ap);

  ap = ((void **)NULL);
}

// init_pkt
// file ltspfs.c line 63
void init_pkt(struct XDR *in, struct XDR *out, char *inbuf, char *outbuf)
{
  signed int i = 0;
  xdrmem_create(in, inbuf, (unsigned int)(4 * 4 + 2 * 4096), (enum xdr_op)XDR_DECODE);
  xdrmem_create(out, outbuf, (unsigned int)(4 * 4 + 2 * 4096), (enum xdr_op)XDR_ENCODE);
  xdr_int(out, &i);
}

// ltspfs_chmod
// file ltspfs.c line 647
static signed int ltspfs_chmod(const char *path, unsigned int mode)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 10;
  char *ptr = (char *)path;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_u_int(&out, &mode);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_parse_return$1;
  return_value_parse_return$1=parse_return(&in);
  return return_value_parse_return$1;
}

// ltspfs_chown
// file ltspfs.c line 672
static signed int ltspfs_chown(const char *path, unsigned int uid, unsigned int gid)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 11;
  char *ptr = (char *)path;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_u_int(&out, &uid);
  xdr_u_int(&out, &gid);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_parse_return$1;
  return_value_parse_return$1=parse_return(&in);
  return return_value_parse_return$1;
}

// ltspfs_fsync
// file ltspfs.c line 945
static signed int ltspfs_fsync(const char *path, signed int isdatasync, struct fuse_file_info_compat *fi)
{
  (void)path;
  (void)isdatasync;
  (void)fi;
  return 0;
}

// ltspfs_getattr
// file ltspfs.c line 291
static signed int ltspfs_getattr(const char *path, struct stat *stbuf)
{
  struct XDR out;
  struct XDR in;
  char outbuf[8208l];
  char inbuf[8208l];
  char *ptr = (char *)path;
  signed int opcode = 0;
  unsigned int nlink = (unsigned int)stbuf->st_nlink;
  signed int res;
  unsigned int uid;
  unsigned int gid;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_xdr_int$1;
  return_value_xdr_int$1=xdr_int(&in, &res);
  signed int return_value_parse_return$2;
  if(return_value_xdr_int$1 == 0)
    return -13;

  else
    if(!(res == 0))
    {
      return_value_parse_return$2=parse_return(&in);
      return return_value_parse_return$2;
    }

    else
    {
      if(fc == ((struct fuse_context *)NULL))
        fc=fuse_get_context();

      signed int return_value_xdr_u_longlong_t$3;
      return_value_xdr_u_longlong_t$3=xdr_u_longlong_t(&in, &stbuf->st_dev);
      if(return_value_xdr_u_longlong_t$3 == 0)
        return -13;

      else
      {
        signed int return_value_xdr_u_longlong_t$4;
        return_value_xdr_u_longlong_t$4=xdr_u_longlong_t(&in, &stbuf->st_ino);
        if(return_value_xdr_u_longlong_t$4 == 0)
          return -13;

        else
        {
          signed int return_value_xdr_u_int$5;
          return_value_xdr_u_int$5=xdr_u_int(&in, &stbuf->st_mode);
          if(return_value_xdr_u_int$5 == 0)
            return -13;

          else
          {
            signed int return_value_xdr_u_int$6;
            return_value_xdr_u_int$6=xdr_u_int(&in, &nlink);
            if(return_value_xdr_u_int$6 == 0)
              return -13;

            else
            {
              signed int return_value_xdr_u_int$7;
              return_value_xdr_u_int$7=xdr_u_int(&in, &uid);
              if(return_value_xdr_u_int$7 == 0)
                return -13;

              else
              {
                signed int return_value_xdr_u_int$8;
                return_value_xdr_u_int$8=xdr_u_int(&in, &gid);
                if(return_value_xdr_u_int$8 == 0)
                  return -13;

                else
                {
                  stbuf->st_uid = fc->uid;
                  stbuf->st_gid = fc->gid;
                  stbuf->st_mode = stbuf->st_mode & (unsigned int)(0040000 | 0100000 | 0700);
                  signed int return_value_xdr_u_longlong_t$9;
                  return_value_xdr_u_longlong_t$9=xdr_u_longlong_t(&in, &stbuf->st_rdev);
                  if(return_value_xdr_u_longlong_t$9 == 0)
                    return -13;

                  else
                  {
                    signed int return_value_xdr_longlong_t$10;
                    return_value_xdr_longlong_t$10=xdr_longlong_t(&in, &stbuf->st_size);
                    if(return_value_xdr_longlong_t$10 == 0)
                      return -13;

                    else
                    {
                      signed int return_value_xdr_long$11;
                      return_value_xdr_long$11=xdr_long(&in, &stbuf->st_blksize);
                      if(return_value_xdr_long$11 == 0)
                        return -13;

                      else
                      {
                        signed int return_value_xdr_longlong_t$12;
                        return_value_xdr_longlong_t$12=xdr_longlong_t(&in, &stbuf->st_blocks);
                        if(return_value_xdr_longlong_t$12 == 0)
                          return -13;

                        else
                        {
                          signed int return_value_xdr_long$13;
                          return_value_xdr_long$13=xdr_long(&in, &stbuf->st_atim.tv_sec);
                          if(return_value_xdr_long$13 == 0)
                            return -13;

                          else
                          {
                            signed int return_value_xdr_long$14;
                            return_value_xdr_long$14=xdr_long(&in, &stbuf->st_mtim.tv_sec);
                            if(return_value_xdr_long$14 == 0)
                              return -13;

                            else
                            {
                              signed int return_value_xdr_long$15;
                              return_value_xdr_long$15=xdr_long(&in, &stbuf->st_ctim.tv_sec);
                              if(return_value_xdr_long$15 == 0)
                                return -13;

                              else
                              {
                                do
                                  if(!(in.x_ops->x_destroy == ((void (*)(struct XDR *))NULL)))
                                    (&in)->x_ops->x_destroy(&in);

                                while((_Bool)0);
                                return 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
}

// ltspfs_init
// file ltspfs.c line 964
static void * ltspfs_init(void)
{
  unsigned long int ping_thread;
  signed int return_value_pthread_create$1;
  return_value_pthread_create$1=pthread_create(&ping_thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)ping_timeout, (void *)0);
  if(!(return_value_pthread_create$1 >= 0))
  {
    close(sockfd);
    exit(1);
  }

  pthread_detach(ping_thread);
  return (void *)0;
}

// ltspfs_link
// file ltspfs.c line 636
static signed int ltspfs_link(const char *from, const char *to)
{
  signed int return_value_ltspfs_twopath$1;
  return_value_ltspfs_twopath$1=ltspfs_twopath(9, from, to);
  return return_value_ltspfs_twopath$1;
}

// ltspfs_mkdir
// file ltspfs.c line 518
static signed int ltspfs_mkdir(const char *path, unsigned int mode)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 4;
  char *ptr = (char *)path;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_u_int(&out, &mode);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_parse_return$1;
  return_value_parse_return$1=parse_return(&in);
  return return_value_parse_return$1;
}

// ltspfs_mknod
// file ltspfs.c line 492
static signed int ltspfs_mknod(const char *path, unsigned int mode, unsigned long int rdev)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 3;
  char *ptr = (char *)path;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_u_int(&out, &mode);
  xdr_u_longlong_t(&out, &rdev);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_parse_return$1;
  return_value_parse_return$1=parse_return(&in);
  return return_value_parse_return$1;
}

// ltspfs_onepath
// file ltspfs.c line 543
static signed int ltspfs_onepath(signed int opcode, const char *path)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  char *ptr = (char *)path;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_parse_return$1;
  return_value_parse_return$1=parse_return(&in);
  return return_value_parse_return$1;
}

// ltspfs_open
// file ltspfs.c line 749
static signed int ltspfs_open(const char *path, struct fuse_file_info_compat *fi)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 14;
  char *ptr = (char *)path;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_int(&out, &fi->flags);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_parse_return$1;
  return_value_parse_return$1=parse_return(&in);
  return return_value_parse_return$1;
}

// ltspfs_read
// file ltspfs.c line 775
static signed int ltspfs_read(const char *path, char *buf, unsigned long int size, signed long int offset, struct fuse_file_info_compat *fi)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 15;
  char *ptr = (char *)path;
  signed int res;
  signed int returned;
  unsigned int usize = (unsigned int)size;
  (void)fi;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_u_int(&out, &usize);
  xdr_longlong_t(&out, &offset);
  xdr_string(&out, &ptr, (unsigned int)4096);
  pthread_mutex_lock(&lock);
  writepacket(&out, outbuf);
  readpacket(&in, inbuf);
  signed int return_value_xdr_int$1;
  return_value_xdr_int$1=xdr_int(&in, &res);
  if(return_value_xdr_int$1 == 0)
  {
    pthread_mutex_unlock(&lock);
    return -13;
  }

  else
  {
    signed int return_value_xdr_int$2;
    return_value_xdr_int$2=xdr_int(&in, &returned);
    if(return_value_xdr_int$2 == 0)
    {
      pthread_mutex_unlock(&lock);
      return -13;
    }

    else
    {
      do
        if(!(in.x_ops->x_destroy == ((void (*)(struct XDR *))NULL)))
          (&in)->x_ops->x_destroy(&in);

      while((_Bool)0);
      if(!(res == 0))
      {
        pthread_mutex_unlock(&lock);
        return -returned;
      }

      else
      {
        readn(sockfd, buf, returned);
        pthread_mutex_unlock(&lock);
        return returned;
      }
    }
  }
}

// ltspfs_readdir
// file ltspfs.c line 433
static signed int ltspfs_readdir(const char *path, void *buf, signed int (*filler)(void *, const char *, struct stat *, signed long int), signed long int offset, struct fuse_file_info_compat *fi)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 2;
  signed int r = 0;
  signed int statcode;
  char *ptr = (char *)path;
  (void)offset;
  (void)fi;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_string(&out, &ptr, (unsigned int)4096);
  pthread_mutex_lock(&lock);
  writepacket(&out, outbuf);
  readpacket(&in, inbuf);
  xdr_int(&in, &statcode);
  if(statcode == 2)
  {
    if(r == 0)
    {
      struct stat st;
      unsigned char type;
      char dirpath[4096l];
      ptr = dirpath;
      memset((void *)&st, 0, sizeof(struct stat) /*144ul*/ );
      xdr_u_longlong_t(&in, &st.st_ino);
      xdr_u_char(&in, &type);
      xdr_string(&in, &ptr, (unsigned int)4096);
      st.st_mode = (unsigned int)((signed int)type << 12);
      r=filler(buf, dirpath, &st, (signed long int)0);
    }

    (&in)->x_ops->x_setpostn(&in, (unsigned int)0);
    readpacket(&in, inbuf);
    xdr_int(&in, &statcode);
  }

  pthread_mutex_unlock(&lock);
  signed int return_value_parse_return$1;
  if(!(r == 0))
    return r;

  else
  {
    return_value_parse_return$1=parse_return(&in);
    return return_value_parse_return$1;
  }
}

// ltspfs_readlink
// file ltspfs.c line 379
static signed int ltspfs_readlink(const char *path, char *buf, unsigned long int size)
{
  struct XDR out;
  struct XDR in;
  char outbuf[8208l];
  char inbuf[8208l];
  signed int opcode = 1;
  signed int ret;
  signed int retcode;
  char *ptr = (char *)path;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_xdr_int$1;
  return_value_xdr_int$1=xdr_int(&in, &ret);
  if(return_value_xdr_int$1 == 0)
    return -13;

  else
  {
    if(!(ret == 0))
    {
      signed int return_value_xdr_int$2;
      return_value_xdr_int$2=xdr_int(&in, &retcode);
      if(return_value_xdr_int$2 == 0)
        retcode = 13;

      do
        if(!(in.x_ops->x_destroy == ((void (*)(struct XDR *))NULL)))
          (&in)->x_ops->x_destroy(&in);

      while((_Bool)0);
      return -retcode;
    }

    ptr = buf;
    signed int return_value_xdr_string$3;
    return_value_xdr_string$3=xdr_string(&in, &ptr, (unsigned int)size);
    if(return_value_xdr_string$3 == 0)
      return -13;

    else
    {
      do
        if(!(in.x_ops->x_destroy == ((void (*)(struct XDR *))NULL)))
          (&in)->x_ops->x_destroy(&in);

      while((_Bool)0);
      return 0;
    }
  }
}

// ltspfs_release
// file ltspfs.c line 930
static signed int ltspfs_release(const char *path, struct fuse_file_info_compat *fi)
{
  (void)path;
  (void)fi;
  return 0;
}

// ltspfs_rename
// file ltspfs.c line 625
static signed int ltspfs_rename(const char *from, const char *to)
{
  signed int return_value_ltspfs_twopath$1;
  return_value_ltspfs_twopath$1=ltspfs_twopath(8, from, to);
  return return_value_ltspfs_twopath$1;
}

// ltspfs_rmdir
// file ltspfs.c line 577
static signed int ltspfs_rmdir(const char *path)
{
  signed int return_value_ltspfs_onepath$1;
  return_value_ltspfs_onepath$1=ltspfs_onepath(7, path);
  return return_value_ltspfs_onepath$1;
}

// ltspfs_sendauth
// file ltspfs.c line 225
signed int ltspfs_sendauth(void)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int size;
  signed int opcode = 24;
  unsigned long int comm_atom;
  struct _XDisplay *dpy;
  unsigned long int root;
  char *buf;
  unsigned long int type;
  signed int format;
  signed int res;
  unsigned long int nitems;
  unsigned long int nleft;
  dpy=XOpenDisplay((const char *)(void *)0);
  if(dpy == ((struct _XDisplay *)NULL))
  {
    fprintf(stderr, "Cannot open X display.\n");
    exit(1);
  }

  root = (&((struct anonymous *)dpy)->screens[(signed long int)((struct anonymous *)dpy)->default_screen])->root;
  comm_atom=XInternAtom(dpy, "LTSPFS_TOKEN", 0);
  if(comm_atom == 0ul)
  {
    printf("Couldn't allocate atom\n");
    exit(1);
  }

  res=XGetWindowProperty(dpy, root, comm_atom, (signed long int)0, (signed long int)512, 0, (unsigned long int)31, &type, &format, &nitems, &nleft, (unsigned char **)&buf);
  if(!(res == 0) || !(type == 31ul))
  {
    fprintf(stderr, "Couldn't read LTSPFS_TOKEN atom.\n");
    exit(1);
  }

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  size = (signed int)return_value_strlen$1;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_int(&out, &size);
  writepacket(&out, outbuf);
  writen(sockfd, buf, size);
  fprintf(stderr, "Wrote %s size %d, waiting\n", buf, size);
  readpacket(&in, inbuf);
  XFree((void *)buf);
  XCloseDisplay(dpy);
  signed int return_value_parse_return$2;
  return_value_parse_return$2=parse_return(&in);
  return return_value_parse_return$2;
}

// ltspfs_statfs
// file ltspfs.c line 881
static signed int ltspfs_statfs(const char *path, struct statfs *stbuf)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 17;
  char *ptr = (char *)path;
  signed int ret;
  signed int f_type;
  signed int f_bsize;
  signed int f_namelen;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_xdr_int$1;
  return_value_xdr_int$1=xdr_int(&in, &ret);
  signed int return_value_parse_return$2;
  if(return_value_xdr_int$1 == 0)
    return -13;

  else
    if(!(ret == 0))
    {
      return_value_parse_return$2=parse_return(&in);
      return return_value_parse_return$2;
    }

    else
    {
      xdr_int(&in, &f_type);
      stbuf->f_type = (signed long int)f_type;
      xdr_int(&in, &f_bsize);
      stbuf->f_bsize = (signed long int)f_bsize;
      xdr_u_longlong_t(&in, &stbuf->f_blocks);
      xdr_u_longlong_t(&in, &stbuf->f_bfree);
      xdr_u_longlong_t(&in, &stbuf->f_bavail);
      xdr_u_longlong_t(&in, &stbuf->f_files);
      xdr_u_longlong_t(&in, &stbuf->f_ffree);
      xdr_int(&in, &f_namelen);
      stbuf->f_namelen = (signed long int)f_namelen;
      return 0;
    }
}

// ltspfs_symlink
// file ltspfs.c line 614
static signed int ltspfs_symlink(const char *from, const char *to)
{
  signed int return_value_ltspfs_twopath$1;
  return_value_ltspfs_twopath$1=ltspfs_twopath(5, from, to);
  return return_value_ltspfs_twopath$1;
}

// ltspfs_truncate
// file ltspfs.c line 698
static signed int ltspfs_truncate(const char *path, signed long int size)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 12;
  char *ptr = (char *)path;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_longlong_t(&out, &size);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_parse_return$1;
  return_value_parse_return$1=parse_return(&in);
  return return_value_parse_return$1;
}

// ltspfs_twopath
// file ltspfs.c line 588
static signed int ltspfs_twopath(signed int opcode, const char *from, const char *to)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  char *ptr;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  ptr = (char *)from;
  xdr_string(&out, &ptr, (unsigned int)4096);
  ptr = (char *)to;
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_parse_return$1;
  return_value_parse_return$1=parse_return(&in);
  return return_value_parse_return$1;
}

// ltspfs_unlink
// file ltspfs.c line 566
static signed int ltspfs_unlink(const char *path)
{
  signed int return_value_ltspfs_onepath$1;
  return_value_ltspfs_onepath$1=ltspfs_onepath(6, path);
  return return_value_ltspfs_onepath$1;
}

// ltspfs_utime
// file ltspfs.c line 723
static signed int ltspfs_utime(const char *path, struct utimbuf *buf)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 13;
  char *ptr = (char *)path;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_long(&out, &buf->actime);
  xdr_long(&out, &buf->modtime);
  xdr_string(&out, &ptr, (unsigned int)4096);
  send_recv(&in, &out, inbuf, outbuf);
  signed int return_value_parse_return$1;
  return_value_parse_return$1=parse_return(&in);
  return return_value_parse_return$1;
}

// ltspfs_write
// file ltspfs.c line 832
static signed int ltspfs_write(const char *path, const char *buf, unsigned long int size, signed long int offset, struct fuse_file_info_compat *fi)
{
  struct XDR in;
  struct XDR out;
  char inbuf[8208l];
  char outbuf[8208l];
  signed int opcode = 16;
  char *ptr = (char *)path;
  signed int res;
  signed int returned;
  unsigned int usize = (unsigned int)size;
  (void)fi;
  init_pkt(&in, &out, inbuf, outbuf);
  xdr_int(&out, &opcode);
  xdr_u_int(&out, &usize);
  xdr_longlong_t(&out, &offset);
  xdr_string(&out, &ptr, (unsigned int)4096);
  pthread_mutex_lock(&lock);
  writepacket(&out, outbuf);
  writen(sockfd, (char *)buf, (signed int)size);
  readpacket(&in, inbuf);
  pthread_mutex_unlock(&lock);
  signed int return_value_xdr_int$1;
  return_value_xdr_int$1=xdr_int(&in, &res);
  if(return_value_xdr_int$1 == 0)
    return -13;

  else
  {
    signed int return_value_xdr_int$2;
    return_value_xdr_int$2=xdr_int(&in, &returned);
    if(return_value_xdr_int$2 == 0)
      return -13;

    else
    {
      do
        if(!(in.x_ops->x_destroy == ((void (*)(struct XDR *))NULL)))
          (&in)->x_ops->x_destroy(&in);

      while((_Bool)0);
      if(!(res == 0))
        return -returned;

      else
        return returned;
    }
  }
}

// main
// file ltspfs.c line 1040
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int myargc = 0;
  char *host = (char *)(void *)0;
  char *mountpoint = (char *)(void *)0;
  char *hostmount = (char *)(void *)0;
  char **myargv;
  setbuf(stderr, (char *)(void *)0);
  if(!(argc >= 3))
  {
    fprintf(stderr, "Usage: %s host:/dir/to/mount /mountpoint <fuse options>\n", argv[(signed long int)0]);
    exit(1);
  }

  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)argc, sizeof(char *) /*8ul*/ );
  myargv = (char **)return_value_calloc$1;
  if(myargv == ((char **)NULL))
  {
    fprintf(stderr, "calloc() failed to allocate memory\n");
    exit(1);
  }

  signed int tmp_post$2 = myargc;
  myargc = myargc + 1;
  myargv[(signed long int)tmp_post$2] = argv[(signed long int)0];
  i = 1;
  char *return_value_strchr$4;
  signed int tmp_post$3;
  for( ; !(i >= argc); i = i + 1)
  {
    return_value_strchr$4=strchr(argv[(signed long int)i], 58);
    if(!(return_value_strchr$4 == ((char *)NULL)))
      hostmount=strdup(argv[(signed long int)i]);

    else
    {
      if((signed int)*argv[(signed long int)i] == 47)
        fuse_mount_point = argv[(signed long int)i];

      tmp_post$3 = myargc;
      myargc = myargc + 1;
      myargv[(signed long int)tmp_post$3] = argv[(signed long int)i];
    }
  }
  if(hostmount == ((char *)NULL))
  {
    fprintf(stderr, "Remote dir must be specified as host:/dir.\n");
    exit(0);
  }

  host = hostmount;
  mountpoint=strchr(hostmount, 58);
  *mountpoint = (char)0;
  mountpoint = mountpoint + 1l;
  if(host == ((char *)NULL))
  {
    fprintf(stderr, "No host specified!\n");
    exit(0);
  }

  if(!((signed int)*mountpoint == 47))
  {
    fprintf(stderr, "No mountpoint specified!\n");
    exit(0);
  }

  sockfd=opensocket(host, 9220);
  pthread_mutex_init(&lock, (const union anonymous$7 *)(void *)0);
  char *return_value_getenv$6;
  return_value_getenv$6=getenv("LTSPFS_NOAUTH");
  if(return_value_getenv$6 == ((char *)NULL))
  {
    signed int return_value_ltspfs_sendauth$5;
    return_value_ltspfs_sendauth$5=ltspfs_sendauth();
    if(!(return_value_ltspfs_sendauth$5 == 0))
    {
      fprintf(stderr, "Authentication failed.\n");
      exit(1);
    }

  }

  handle_mount(mountpoint);
  signed int return_value_fuse_main_real_compat22$7;
  return_value_fuse_main_real_compat22$7=fuse_main_real_compat22(myargc, myargv, &ltspfs_oper, sizeof(struct fuse_operations_compat22) /*248ul*/ );
  return return_value_fuse_main_real_compat22$7;
}

// opensocket
// file common.h line 25
signed int opensocket(char *hostname, signed int port)
{
  struct sockaddr_in serv_addr;
  struct hostent *server;
  signed int s;
  s=socket(2, 1, 0);
  if(!(s >= 0))
  {
    fprintf(stderr, "ERROR opening socket\n");
    exit(1);
  }

  server=gethostbyname(hostname);
  if(server == ((struct hostent *)NULL))
  {
    fprintf(stderr, "ERROR, no such host\n");
    exit(1);
  }

  memset((void *)(char *)&serv_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  serv_addr.sin_family = (unsigned short int)2;
  bcopy((const void *)(char *)server->h_addr_list[(signed long int)0], (void *)(char *)&serv_addr.sin_addr.s_addr, (unsigned long int)server->h_length);
  serv_addr.sin_port=htons((unsigned short int)port);
  signed int return_value_connect$1;
  return_value_connect$1=connect(s, (struct sockaddr *)&serv_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_connect$1 >= 0))
  {
    fprintf(stderr, "ERROR connecting\n");
    exit(1);
  }

  return s;
}

// parse_return
// file ltspfs.c line 196
static signed int parse_return(struct XDR *xdr)
{
  signed int res;
  signed int retcode;
  xdr->x_ops->x_setpostn(xdr, (unsigned int)0);
  xdr_int(xdr, &res);
  signed int return_value_xdr_int$2;
  return_value_xdr_int$2=xdr_int(xdr, &res);
  signed int return_value_xdr_int$1;
  if(return_value_xdr_int$2 == 0)
    retcode = 13;

  else
    if(res == 0)
      retcode = 0;

    else
    {
      return_value_xdr_int$1=xdr_int(xdr, &retcode);
      if(return_value_xdr_int$1 == 0)
        retcode = 13;

    }
  if(!(xdr->x_ops->x_destroy == ((void (*)(struct XDR *))NULL)))
    xdr->x_ops->x_destroy(xdr);

  return -retcode;
}

// ping_timeout
// file ltspfs.c line 161
void ping_timeout(void *nothing)
{
  struct XDR in;
  struct XDR out;
  signed int i;
  char pingin[8208l];
  char pingout[8208l];
  struct timespec ping_interval;
  (void)nothing;
  init_pkt(&in, &out, pingin, pingout);
  i = 26;
  xdr_int(&out, &i);
  unsigned int return_value;
  return_value=(&out)->x_ops->x_getpostn(&out);
  i = (signed int)return_value;
  (&out)->x_ops->x_setpostn(&out, (unsigned int)0);
  xdr_int(&out, &i);
  ping_interval.tv_sec = (signed long int)30;
  ping_interval.tv_nsec = (signed long int)0;
  nanosleep(&ping_interval, (struct timespec *)(void *)0);
  pthread_mutex_lock(&lock);
  writen(sockfd, pingout, i);
  readpacket(&in, pingin);
  (&in)->x_ops->x_setpostn(&in, (unsigned int)0);
  pthread_mutex_unlock(&lock);
}

// readn
// file common.h line 26
signed int readn(signed int fd, char *ptr, signed int maxlen)
{
  signed int return_value__readn$1;
  return_value__readn$1=_readn(fd, ptr, maxlen, 120, timeout, 1);
  return return_value__readn$1;
}

// readpacket
// file ltspfs.c line 92
signed int readpacket(struct XDR *in, char *packetbuffer)
{
  char *pktptr = packetbuffer;
  signed int len;
  readn(sockfd, pktptr, 4);
  xdr_int(in, &len);
  len = len - 4;
  pktptr = pktptr + (signed long int)4;
  signed int return_value_readn$1;
  return_value_readn$1=readn(sockfd, pktptr, len);
  return return_value_readn$1;
}

// send_recv
// file ltspfs.c line 145
void send_recv(struct XDR *in, struct XDR *out, char *inbuf, char *outbuf)
{
  pthread_mutex_lock(&lock);
  writepacket(out, outbuf);
  readpacket(in, inbuf);
  pthread_mutex_unlock(&lock);
}

// status_return
// file common.c line 307
signed int status_return(signed int sockfd, signed int result)
{
  struct XDR out;
  char output[8192l];
  signed int i = 0;
  xdrmem_create(&out, output, (unsigned int)8192, (enum xdr_op)XDR_ENCODE);
  xdr_int(&out, &i);
  if(result == -1)
  {
    i = 1;
    xdr_int(&out, &i);
    if(!(debug == 0))
      info("status_return STATUS_FAIL\n");

    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    xdr_int(&out, &(*return_value___errno_location$1));
  }

  else
  {
    i = 0;
    if(!(debug == 0))
      info("status_return STATUS_OK\n");

    xdr_int(&out, &i);
  }
  unsigned int return_value;
  return_value=(&out)->x_ops->x_getpostn(&out);
  i = (signed int)return_value;
  (&out)->x_ops->x_setpostn(&out, (unsigned int)0);
  xdr_int(&out, &i);
  writen(sockfd, output, i);
  return 0;
}

// timeout
// file ltspfs.c line 79
void timeout(void)
{
  close(sockfd);
  fuse_unmount_compat22(fuse_mount_point);
  exit(0);
}

// writen
// file common.h line 27
signed int writen(signed int fd, char *ptr, signed int nbytes)
{
  signed int return_value__writen$1;
  return_value__writen$1=_writen(fd, ptr, nbytes, 120, timeout, 1);
  return return_value__writen$1;
}

// writepacket
// file ltspfs.c line 114
signed int writepacket(struct XDR *out, char *packetbuffer)
{
  signed int i;
  unsigned int return_value;
  return_value=out->x_ops->x_getpostn(out);
  i = (signed int)return_value;
  out->x_ops->x_setpostn(out, (unsigned int)0);
  xdr_int(out, &i);
  i=writen(sockfd, packetbuffer, i);
  if(!(out->x_ops->x_destroy == ((void (*)(struct XDR *))NULL)))
    out->x_ops->x_destroy(out);

  return i;
}

