// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_3;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_1;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_2;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_locale_t
// file client.c line 41
struct _locale_t;

// tag-_lscp_buffer_fill_t
// file ../lscp/client.h line 84
struct _lscp_buffer_fill_t;

// tag-_lscp_channel_info_t
// file ../lscp/client.h line 62
struct _lscp_channel_info_t;

// tag-_lscp_client_t
// file ../lscp/client.h line 161
struct _lscp_client_t;

// tag-_lscp_connect_list_t
// file server.h line 71
struct _lscp_connect_list_t;

// tag-_lscp_connect_t
// file server.h line 60
struct _lscp_connect_t;

// tag-_lscp_device_info_t
// file ../lscp/device.h line 85
struct _lscp_device_info_t;

// tag-_lscp_device_port_info_t
// file ../lscp/device.h line 94
struct _lscp_device_port_info_t;

// tag-_lscp_driver_info_t
// file ../lscp/device.h line 75
struct _lscp_driver_info_t;

// tag-_lscp_engine_info_t
// file ../lscp/client.h line 53
struct _lscp_engine_info_t;

// tag-_lscp_event_t
// file ../lscp/event.h line 34
enum _lscp_event_t { LSCP_EVENT_NONE=0, LSCP_EVENT_CHANNEL_COUNT=1, LSCP_EVENT_VOICE_COUNT=2, LSCP_EVENT_STREAM_COUNT=4, LSCP_EVENT_BUFFER_FILL=8, LSCP_EVENT_CHANNEL_INFO=16, LSCP_EVENT_TOTAL_VOICE_COUNT=32, LSCP_EVENT_AUDIO_OUTPUT_DEVICE_COUNT=64, LSCP_EVENT_AUDIO_OUTPUT_DEVICE_INFO=128, LSCP_EVENT_MIDI_INPUT_DEVICE_COUNT=256, LSCP_EVENT_MIDI_INPUT_DEVICE_INFO=512, LSCP_EVENT_MIDI_INSTRUMENT_MAP_COUNT=1024, LSCP_EVENT_MIDI_INSTRUMENT_MAP_INFO=4096, LSCP_EVENT_MIDI_INSTRUMENT_COUNT=8192, LSCP_EVENT_MIDI_INSTRUMENT_INFO=16384, LSCP_EVENT_MISCELLANEOUS=32768, LSCP_EVENT_CHANNEL_MIDI=65536, LSCP_EVENT_DEVICE_MIDI=131072 };

// tag-_lscp_fxsend_info_t
// file ../lscp/client.h line 102
struct _lscp_fxsend_info_t;

// tag-_lscp_load_mode_t
// file ../lscp/client.h line 123
enum _lscp_load_mode_t { LSCP_LOAD_DEFAULT=0, LSCP_LOAD_ON_DEMAND=1, LSCP_LOAD_ON_DEMAND_HOLD=2, LSCP_LOAD_PERSISTENT=3 };

// tag-_lscp_midi_instrument_info_t
// file ../lscp/client.h line 134
struct _lscp_midi_instrument_info_t;

// tag-_lscp_midi_instrument_t
// file ../lscp/client.h line 113
struct _lscp_midi_instrument_t;

// tag-_lscp_param_info_t
// file ../lscp/device.h line 58
struct _lscp_param_info_t;

// tag-_lscp_param_t
// file ../lscp/device.h line 49
struct _lscp_param_t;

// tag-_lscp_parser_t
// file parser.h line 43
struct _lscp_parser_t;

// tag-_lscp_server_info_t
// file ../lscp/client.h line 43
struct _lscp_server_info_t;

// tag-_lscp_server_mode_t
// file server.h line 37
enum _lscp_server_mode_t { LSCP_SERVER_THREAD=0, LSCP_SERVER_SELECT=1 };

// tag-_lscp_server_t
// file server.h line 57
struct _lscp_server_t;

// tag-_lscp_socket_agent_t
// file ../lscp/socket.h line 68
struct _lscp_socket_agent_t;

// tag-_lscp_status_t
// file ../lscp/thread.h line 51
enum _lscp_status_t { LSCP_OK=0, LSCP_FAILED=-1, LSCP_ERROR=-2, LSCP_WARNING=-3, LSCP_TIMEOUT=-4, LSCP_QUIT=-5 };

// tag-_lscp_thread_t
// file ../lscp/thread.h line 99
struct _lscp_thread_t;

// tag-_lscp_type_t
// file ../lscp/device.h line 37
enum _lscp_type_t { LSCP_TYPE_NONE=0, LSCP_TYPE_BOOL=1, LSCP_TYPE_INT=2, LSCP_TYPE_FLOAT=3, LSCP_TYPE_STRING=4 };

// tag-_lscp_usage_t
// file ../lscp/client.h line 93
enum _lscp_usage_t { LSCP_USAGE_BYTES=0, LSCP_USAGE_PERCENTAGE=1 };

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// _atof
// file client.c line 66
static float _atof(const char *txt);
// _lscp_client_evt_connect
// file client.c line 171
static enum _lscp_status_t _lscp_client_evt_connect(struct _lscp_client_t *pClient);
// _lscp_client_evt_proc
// file client.c line 76
static void _lscp_client_evt_proc(void *pvClient);
// _lscp_client_evt_request
// file client.c line 216
static enum _lscp_status_t _lscp_client_evt_request(struct _lscp_client_t *pClient, signed int iSubscribe, enum _lscp_event_t event);
// _lscp_connect_create
// file server.c line 175
static struct _lscp_connect_t * _lscp_connect_create(struct _lscp_server_t *pServer, signed int sock, struct sockaddr_in *pAddr, signed int cAddr);
// _lscp_connect_destroy
// file server.c line 213
static enum _lscp_status_t _lscp_connect_destroy(struct _lscp_connect_t *pConnect);
// _lscp_connect_list_append
// file server.c line 61
static void _lscp_connect_list_append(struct _lscp_connect_list_t *pList, struct _lscp_connect_t *pItem);
// _lscp_connect_list_find_sock
// file server.c line 143
static struct _lscp_connect_t * _lscp_connect_list_find_sock(struct _lscp_connect_list_t *pList, signed int sock);
// _lscp_connect_list_free
// file server.c line 123
static void _lscp_connect_list_free(struct _lscp_connect_list_t *pList);
// _lscp_connect_list_init
// file server.c line 49
static void _lscp_connect_list_init(struct _lscp_connect_list_t *pList);
// _lscp_connect_list_remove
// file server.c line 83
static void _lscp_connect_list_remove(struct _lscp_connect_list_t *pList, struct _lscp_connect_t *pItem);
// _lscp_connect_list_remove_safe
// file server.c line 104
static void _lscp_connect_list_remove_safe(struct _lscp_connect_list_t *pList, struct _lscp_connect_t *pItem);
// _lscp_connect_proc
// file server.c line 160
static void _lscp_connect_proc(void *pvConnect);
// _lscp_connect_recv
// file server.c line 232
static enum _lscp_status_t _lscp_connect_recv(struct _lscp_connect_t *pConnect);
// _lscp_device_info_query
// file device.c line 86
static struct _lscp_device_info_t * _lscp_device_info_query(struct _lscp_client_t *pClient, struct _lscp_device_info_t *pDeviceInfo, char *pszQuery);
// _lscp_device_port_info_query
// file device.c line 127
static struct _lscp_device_port_info_t * _lscp_device_port_info_query(struct _lscp_client_t *pClient, struct _lscp_device_port_info_t *pDevicePortInfo, char *pszQuery);
// _lscp_driver_info_query
// file device.c line 39
static struct _lscp_driver_info_t * _lscp_driver_info_query(struct _lscp_client_t *pClient, struct _lscp_driver_info_t *pDriverInfo, char *pszQuery);
// _lscp_param_info_query
// file device.c line 172
static struct _lscp_param_info_t * _lscp_param_info_query(struct _lscp_client_t *pClient, struct _lscp_param_info_t *pParamInfo, char *pszQuery, signed int cchMaxQuery, struct _lscp_param_t *pDepList);
// _lscp_server_agent_proc
// file server.c line 388
static void _lscp_server_agent_proc(void *pvServer);
// _lscp_server_select_proc
// file server.c line 291
static void _lscp_server_select_proc(struct _lscp_server_t *pServer);
// _lscp_server_thread_proc
// file server.c line 259
static void _lscp_server_thread_proc(struct _lscp_server_t *pServer);
// _lscp_socket_getopt_bool
// file socket.c line 127
static void _lscp_socket_getopt_bool(signed int sock, const char *pszOptName, signed int iOptName);
// _lscp_socket_getopt_int
// file socket.c line 140
static void _lscp_socket_getopt_int(signed int sock, const char *pszOptName, signed int iOptName);
// _lscp_thread_start
// file thread.c line 45
static void * _lscp_thread_start(void *pvThread);
// _restore_locale
// file client.c line 58
static void _restore_locale(struct _locale_t *locale);
// _save_and_set_c_locale
// file client.c line 49
static void _save_and_set_c_locale(struct _locale_t *locale);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// herror
// file /usr/include/netdb.h line 92
extern void herror(const char *);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lscp_add_channel
// file client.c line 969
signed int lscp_add_channel(struct _lscp_client_t *pClient);
// lscp_add_midi_instrument_map
// file client.c line 2404
signed int lscp_add_midi_instrument_map(struct _lscp_client_t *pClient, const char *pszMapName);
// lscp_channel_info_free
// file common.h line 160
void lscp_channel_info_free(struct _lscp_channel_info_t *pChannelInfo);
// lscp_channel_info_init
// file common.h line 159
void lscp_channel_info_init(struct _lscp_channel_info_t *pChannelInfo);
// lscp_channel_info_reset
// file common.h line 161
void lscp_channel_info_reset(struct _lscp_channel_info_t *pChannelInfo);
// lscp_clear_midi_instruments
// file client.c line 2890
enum _lscp_status_t lscp_clear_midi_instruments(struct _lscp_client_t *pClient, signed int iMidiMap);
// lscp_client_build
// file client.c line 262
const char * lscp_client_build(void);
// lscp_client_call
// file common.h line 94
enum _lscp_status_t lscp_client_call(struct _lscp_client_t *pClient, const char *pszQuery, signed int iResult);
// lscp_client_create
// file client.c line 282
struct _lscp_client_t * lscp_client_create(const char *pszHost, signed int iPort, enum _lscp_status_t (*pfnCallback)(struct _lscp_client_t *, enum _lscp_event_t, const char *, signed int, void *), void *pvData);
// lscp_client_create::pfnCallback_object
//
enum _lscp_status_t pfnCallback_object(struct _lscp_client_t *, enum _lscp_event_t, const char *, signed int, void *);
// lscp_client_destroy
// file client.c line 435
enum _lscp_status_t lscp_client_destroy(struct _lscp_client_t *pClient);
// lscp_client_get_errno
// file client.c line 607
signed int lscp_client_get_errno(struct _lscp_client_t *pClient);
// lscp_client_get_events
// file client.c line 817
enum _lscp_event_t lscp_client_get_events(struct _lscp_client_t *pClient);
// lscp_client_get_result
// file client.c line 590
const char * lscp_client_get_result(struct _lscp_client_t *pClient);
// lscp_client_get_timeout
// file client.c line 537
signed int lscp_client_get_timeout(struct _lscp_client_t *pClient);
// lscp_client_join
// file client.c line 412
enum _lscp_status_t lscp_client_join(struct _lscp_client_t *pClient);
// lscp_client_package
// file client.c line 256
const char * lscp_client_package(void);
// lscp_client_query
// file client.c line 562
enum _lscp_status_t lscp_client_query(struct _lscp_client_t *pClient, const char *pszQuery);
// lscp_client_recv
// file common.c line 54
enum _lscp_status_t lscp_client_recv(struct _lscp_client_t *pClient, char *pchBuffer, signed int *pcchBuffer, signed int iTimeout);
// lscp_client_set_result
// file common.h line 95
void lscp_client_set_result(struct _lscp_client_t *pClient, char *pszResult, signed int iErrno);
// lscp_client_set_timeout
// file client.c line 518
enum _lscp_status_t lscp_client_set_timeout(struct _lscp_client_t *pClient, signed int iTimeout);
// lscp_client_subscribe
// file client.c line 647
enum _lscp_status_t lscp_client_subscribe(struct _lscp_client_t *pClient, enum _lscp_event_t events);
// lscp_client_unsubscribe
// file client.c line 743
enum _lscp_status_t lscp_client_unsubscribe(struct _lscp_client_t *pClient, enum _lscp_event_t events);
// lscp_client_version
// file client.c line 259
const char * lscp_client_version(void);
// lscp_create_audio_device
// file device.c line 396
signed int lscp_create_audio_device(struct _lscp_client_t *pClient, const char *pszAudioDriver, struct _lscp_param_t *pParams);
// lscp_create_fxsend
// file client.c line 2092
signed int lscp_create_fxsend(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiController, const char *pszFxName);
// lscp_create_midi_device
// file device.c line 776
signed int lscp_create_midi_device(struct _lscp_client_t *pClient, const char *pszMidiDriver, struct _lscp_param_t *pParams);
// lscp_destroy_audio_device
// file device.c line 430
enum _lscp_status_t lscp_destroy_audio_device(struct _lscp_client_t *pClient, signed int iAudioDevice);
// lscp_destroy_fxsend
// file client.c line 2132
enum _lscp_status_t lscp_destroy_fxsend(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend);
// lscp_destroy_midi_device
// file device.c line 810
enum _lscp_status_t lscp_destroy_midi_device(struct _lscp_client_t *pClient, signed int iMidiDevice);
// lscp_device_info_free
// file common.h line 174
void lscp_device_info_free(struct _lscp_device_info_t *pDeviceInfo);
// lscp_device_info_init
// file common.h line 173
void lscp_device_info_init(struct _lscp_device_info_t *pDeviceInfo);
// lscp_device_info_reset
// file common.h line 175
void lscp_device_info_reset(struct _lscp_device_info_t *pDeviceInfo);
// lscp_device_port_info_free
// file common.h line 181
void lscp_device_port_info_free(struct _lscp_device_port_info_t *pDevicePortInfo);
// lscp_device_port_info_init
// file common.h line 180
void lscp_device_port_info_init(struct _lscp_device_port_info_t *pDevicePortInfo);
// lscp_device_port_info_reset
// file common.h line 182
void lscp_device_port_info_reset(struct _lscp_device_port_info_t *pDevicePortInfo);
// lscp_driver_info_free
// file common.h line 167
void lscp_driver_info_free(struct _lscp_driver_info_t *pDriverInfo);
// lscp_driver_info_init
// file common.h line 166
void lscp_driver_info_init(struct _lscp_driver_info_t *pDriverInfo);
// lscp_driver_info_reset
// file common.h line 168
void lscp_driver_info_reset(struct _lscp_driver_info_t *pDriverInfo);
// lscp_edit_channel_instrument
// file client.c line 2916
enum _lscp_status_t lscp_edit_channel_instrument(struct _lscp_client_t *pClient, signed int iSamplerChannel);
// lscp_engine_info_free
// file common.h line 153
void lscp_engine_info_free(struct _lscp_engine_info_t *pEngineInfo);
// lscp_engine_info_init
// file common.h line 152
void lscp_engine_info_init(struct _lscp_engine_info_t *pEngineInfo);
// lscp_engine_info_reset
// file common.h line 154
void lscp_engine_info_reset(struct _lscp_engine_info_t *pEngineInfo);
// lscp_event_from_text
// file ../lscp/event.h line 63
enum _lscp_event_t lscp_event_from_text(const char *pszText);
// lscp_event_to_text
// file ../lscp/event.h line 62
const char * lscp_event_to_text(enum _lscp_event_t event);
// lscp_fxsend_info_free
// file common.h line 200
void lscp_fxsend_info_free(struct _lscp_fxsend_info_t *pFxSendInfo);
// lscp_fxsend_info_init
// file common.h line 199
void lscp_fxsend_info_init(struct _lscp_fxsend_info_t *pFxSendInfo);
// lscp_fxsend_info_reset
// file common.h line 201
void lscp_fxsend_info_reset(struct _lscp_fxsend_info_t *pFxSendInfo);
// lscp_get_audio_channel_info
// file device.c line 569
struct _lscp_device_port_info_t * lscp_get_audio_channel_info(struct _lscp_client_t *pClient, signed int iAudioDevice, signed int iAudioChannel);
// lscp_get_audio_channel_param_info
// file device.c line 597
struct _lscp_param_info_t * lscp_get_audio_channel_param_info(struct _lscp_client_t *pClient, signed int iAudioDevice, signed int iAudioChannel, const char *pszParam);
// lscp_get_audio_device_info
// file device.c line 518
struct _lscp_device_info_t * lscp_get_audio_device_info(struct _lscp_client_t *pClient, signed int iAudioDevice);
// lscp_get_audio_devices
// file device.c line 454
signed int lscp_get_audio_devices(struct _lscp_client_t *pClient);
// lscp_get_audio_driver_info
// file device.c line 342
struct _lscp_driver_info_t * lscp_get_audio_driver_info(struct _lscp_client_t *pClient, const char *pszAudioDriver);
// lscp_get_audio_driver_param_info
// file device.c line 366
struct _lscp_param_info_t * lscp_get_audio_driver_param_info(struct _lscp_client_t *pClient, const char *pszAudioDriver, const char *pszParam, struct _lscp_param_t *pDepList);
// lscp_get_available_audio_drivers
// file device.c line 278
signed int lscp_get_available_audio_drivers(struct _lscp_client_t *pClient);
// lscp_get_available_engines
// file client.c line 1019
signed int lscp_get_available_engines(struct _lscp_client_t *pClient);
// lscp_get_available_midi_drivers
// file device.c line 656
signed int lscp_get_available_midi_drivers(struct _lscp_client_t *pClient);
// lscp_get_channel_buffer_fill
// file client.c line 1411
struct _lscp_buffer_fill_t * lscp_get_channel_buffer_fill(struct _lscp_client_t *pClient, enum _lscp_usage_t usage_type, signed int iSamplerChannel);
// lscp_get_channel_info
// file client.c line 1141
struct _lscp_channel_info_t * lscp_get_channel_info(struct _lscp_client_t *pClient, signed int iSamplerChannel);
// lscp_get_channel_stream_count
// file client.c line 1317
signed int lscp_get_channel_stream_count(struct _lscp_client_t *pClient, signed int iSamplerChannel);
// lscp_get_channel_stream_usage
// file client.c line 1350
signed int lscp_get_channel_stream_usage(struct _lscp_client_t *pClient, signed int iSamplerChannel);
// lscp_get_channel_voice_count
// file client.c line 1284
signed int lscp_get_channel_voice_count(struct _lscp_client_t *pClient, signed int iSamplerChannel);
// lscp_get_channels
// file client.c line 906
signed int lscp_get_channels(struct _lscp_client_t *pClient);
// lscp_get_engine_info
// file client.c line 1083
struct _lscp_engine_info_t * lscp_get_engine_info(struct _lscp_client_t *pClient, const char *pszEngineName);
// lscp_get_fxsend_info
// file client.c line 2229
struct _lscp_fxsend_info_t * lscp_get_fxsend_info(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend);
// lscp_get_fxsends
// file client.c line 2155
signed int lscp_get_fxsends(struct _lscp_client_t *pClient, signed int iSamplerChannel);
// lscp_get_midi_device_info
// file device.c line 898
struct _lscp_device_info_t * lscp_get_midi_device_info(struct _lscp_client_t *pClient, signed int iMidiDevice);
// lscp_get_midi_devices
// file device.c line 834
signed int lscp_get_midi_devices(struct _lscp_client_t *pClient);
// lscp_get_midi_driver_info
// file device.c line 720
struct _lscp_driver_info_t * lscp_get_midi_driver_info(struct _lscp_client_t *pClient, const char *pszMidiDriver);
// lscp_get_midi_driver_param_info
// file device.c line 746
struct _lscp_param_info_t * lscp_get_midi_driver_param_info(struct _lscp_client_t *pClient, const char *pszMidiDriver, const char *pszParam, struct _lscp_param_t *pDepList);
// lscp_get_midi_instrument_info
// file client.c line 2787
struct _lscp_midi_instrument_info_t * lscp_get_midi_instrument_info(struct _lscp_client_t *pClient, struct _lscp_midi_instrument_t *pMidiInstr);
// lscp_get_midi_instrument_map_name
// file client.c line 2526
const char * lscp_get_midi_instrument_map_name(struct _lscp_client_t *pClient, signed int iMidiMap);
// lscp_get_midi_instrument_maps
// file client.c line 2463
signed int lscp_get_midi_instrument_maps(struct _lscp_client_t *pClient);
// lscp_get_midi_instruments
// file client.c line 2702
signed int lscp_get_midi_instruments(struct _lscp_client_t *pClient, signed int iMidiMap);
// lscp_get_midi_port_info
// file device.c line 949
struct _lscp_device_port_info_t * lscp_get_midi_port_info(struct _lscp_client_t *pClient, signed int iMidiDevice, signed int iMidiPort);
// lscp_get_midi_port_param_info
// file device.c line 977
struct _lscp_param_info_t * lscp_get_midi_port_param_info(struct _lscp_client_t *pClient, signed int iMidiDevice, signed int iMidiPort, const char *pszParam);
// lscp_get_param_value
// file device.c line 1027
const char * lscp_get_param_value(struct _lscp_param_t *pParams, const char *pszParam);
// lscp_get_server_info
// file client.c line 1788
struct _lscp_server_info_t * lscp_get_server_info(struct _lscp_client_t *pClient);
// lscp_get_streams
// file client.c line 2031
signed int lscp_get_streams(struct _lscp_client_t *pClient);
// lscp_get_total_voice_count
// file client.c line 1846
signed int lscp_get_total_voice_count(struct _lscp_client_t *pClient);
// lscp_get_total_voice_count_max
// file client.c line 1875
signed int lscp_get_total_voice_count_max(struct _lscp_client_t *pClient);
// lscp_get_voices
// file client.c line 1969
signed int lscp_get_voices(struct _lscp_client_t *pClient);
// lscp_get_volume
// file client.c line 1904
float lscp_get_volume(struct _lscp_client_t *pClient);
// lscp_isplit_create
// file common.h line 112
signed int * lscp_isplit_create(const char *pszCsv, const char *pszSeps);
// lscp_isplit_destroy
// file common.h line 113
void lscp_isplit_destroy(signed int *piSplit);
// lscp_list_audio_devices
// file device.c line 483
signed int * lscp_list_audio_devices(struct _lscp_client_t *pClient);
// lscp_list_available_audio_drivers
// file device.c line 307
const char ** lscp_list_available_audio_drivers(struct _lscp_client_t *pClient);
// lscp_list_available_engines
// file client.c line 1048
const char ** lscp_list_available_engines(struct _lscp_client_t *pClient);
// lscp_list_available_midi_drivers
// file device.c line 685
const char ** lscp_list_available_midi_drivers(struct _lscp_client_t *pClient);
// lscp_list_channels
// file client.c line 935
signed int * lscp_list_channels(struct _lscp_client_t *pClient);
// lscp_list_fxsends
// file client.c line 2190
signed int * lscp_list_fxsends(struct _lscp_client_t *pClient, signed int iSamplerChannel);
// lscp_list_midi_devices
// file device.c line 863
signed int * lscp_list_midi_devices(struct _lscp_client_t *pClient);
// lscp_list_midi_instrument_maps
// file client.c line 2492
signed int * lscp_list_midi_instrument_maps(struct _lscp_client_t *pClient);
// lscp_list_midi_instruments
// file client.c line 2742
struct _lscp_midi_instrument_t * lscp_list_midi_instruments(struct _lscp_client_t *pClient, signed int iMidiMap);
// lscp_load_engine
// file client.c line 885
enum _lscp_status_t lscp_load_engine(struct _lscp_client_t *pClient, const char *pszEngineName, signed int iSamplerChannel);
// lscp_load_instrument
// file client.c line 840
enum _lscp_status_t lscp_load_instrument(struct _lscp_client_t *pClient, const char *pszFileName, signed int iInstrIndex, signed int iSamplerChannel);
// lscp_load_instrument_non_modal
// file client.c line 863
enum _lscp_status_t lscp_load_instrument_non_modal(struct _lscp_client_t *pClient, const char *pszFileName, signed int iInstrIndex, signed int iSamplerChannel);
// lscp_ltrim
// file common.h line 101
char * lscp_ltrim(char *psz);
// lscp_map_midi_instrument
// file client.c line 2618
enum _lscp_status_t lscp_map_midi_instrument(struct _lscp_client_t *pClient, struct _lscp_midi_instrument_t *pMidiInstr, const char *pszEngineName, const char *pszFileName, signed int iInstrIndex, float fVolume, enum _lscp_load_mode_t load_mode, const char *pszName);
// lscp_midi_instrument_info_free
// file common.h line 207
void lscp_midi_instrument_info_free(struct _lscp_midi_instrument_info_t *pInstrInfo);
// lscp_midi_instrument_info_init
// file common.h line 206
void lscp_midi_instrument_info_init(struct _lscp_midi_instrument_info_t *pInstrInfo);
// lscp_midi_instrument_info_reset
// file common.h line 208
void lscp_midi_instrument_info_reset(struct _lscp_midi_instrument_info_t *pInstrInfo);
// lscp_midi_instruments_create
// file common.h line 134
struct _lscp_midi_instrument_t * lscp_midi_instruments_create(const char *pszCsv);
// lscp_midi_instruments_destroy
// file common.h line 135
void lscp_midi_instruments_destroy(struct _lscp_midi_instrument_t *pInstrs);
// lscp_param_concat
// file common.h line 194
signed int lscp_param_concat(char *pszBuffer, signed int cchMaxBuffer, struct _lscp_param_t *pParams);
// lscp_param_info_free
// file common.h line 188
void lscp_param_info_free(struct _lscp_param_info_t *pParamInfo);
// lscp_param_info_init
// file common.h line 187
void lscp_param_info_init(struct _lscp_param_info_t *pParamInfo);
// lscp_param_info_reset
// file common.h line 189
void lscp_param_info_reset(struct _lscp_param_info_t *pParamInfo);
// lscp_parser_free
// file parser.h line 60
void lscp_parser_free(struct _lscp_parser_t *pParser);
// lscp_parser_init
// file parser.h line 54
void lscp_parser_init(struct _lscp_parser_t *pParser, const char *pchBuffer, signed int cchBuffer);
// lscp_parser_next
// file parser.h line 55
const char * lscp_parser_next(struct _lscp_parser_t *pParser);
// lscp_parser_nextint
// file parser.h line 56
signed int lscp_parser_nextint(struct _lscp_parser_t *pParser);
// lscp_parser_nextnum
// file parser.h line 57
float lscp_parser_nextnum(struct _lscp_parser_t *pParser);
// lscp_parser_strtok
// file parser.c line 34
const char * lscp_parser_strtok(char *pchBuffer, const char *pszDelim, char **ppch);
// lscp_parser_test
// file parser.h line 58
signed int lscp_parser_test(struct _lscp_parser_t *pParser, const char *pszToken);
// lscp_parser_test2
// file parser.h line 59
signed int lscp_parser_test2(struct _lscp_parser_t *pParser, const char *pszToken, const char *pszToken2);
// lscp_plist_alloc
// file common.c line 625
void lscp_plist_alloc(struct _lscp_param_t **ppList);
// lscp_plist_append
// file common.h line 128
void lscp_plist_append(struct _lscp_param_t **ppList, const char *pszKey, const char *pszValue);
// lscp_plist_free
// file common.c line 645
void lscp_plist_free(struct _lscp_param_t **ppList);
// lscp_psplit_create
// file common.c line 538
struct _lscp_param_t * lscp_psplit_create(const char *pszCsv, const char *pszSeps1, const char *pszSeps2);
// lscp_psplit_destroy
// file common.c line 595
void lscp_psplit_destroy(struct _lscp_param_t *ppSplit);
// lscp_remove_channel
// file client.c line 998
enum _lscp_status_t lscp_remove_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel);
// lscp_remove_midi_instrument_map
// file client.c line 2441
enum _lscp_status_t lscp_remove_midi_instrument_map(struct _lscp_client_t *pClient, signed int iMidiMap);
// lscp_reset_channel
// file client.c line 1752
enum _lscp_status_t lscp_reset_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel);
// lscp_reset_sampler
// file client.c line 1772
enum _lscp_status_t lscp_reset_sampler(struct _lscp_client_t *pClient);
// lscp_server_broadcast
// file server.h line 117
enum _lscp_status_t lscp_server_broadcast(struct _lscp_server_t *pServer, enum _lscp_event_t event, const char *pchData, signed int cchData);
// lscp_server_build
// file server.h line 106
const char * lscp_server_build(void);
// lscp_server_create
// file server.h line 112
struct _lscp_server_t * lscp_server_create(signed int iPort, enum _lscp_status_t (*pfnCallback)(struct _lscp_connect_t *, const char *, signed int, void *), void *pvData);
// lscp_server_create::pfnCallback_object
//
enum _lscp_status_t pfnCallback_object(struct _lscp_connect_t *, const char *, signed int, void *);
// lscp_server_create_ex
// file server.c line 453
struct _lscp_server_t * lscp_server_create_ex(signed int iPort, enum _lscp_status_t (*pfnCallback)(struct _lscp_connect_t *, const char *, signed int, void *), void *pvData, enum _lscp_server_mode_t mode);
// lscp_server_create_ex::pfnCallback_object
//
enum _lscp_status_t pfnCallback_object(struct _lscp_connect_t *, const char *, signed int, void *);
// lscp_server_destroy
// file server.h line 115
enum _lscp_status_t lscp_server_destroy(struct _lscp_server_t *pServer);
// lscp_server_info_free
// file common.h line 146
void lscp_server_info_free(struct _lscp_server_info_t *pServerInfo);
// lscp_server_info_init
// file common.h line 145
void lscp_server_info_init(struct _lscp_server_info_t *pServerInfo);
// lscp_server_info_reset
// file common.h line 147
void lscp_server_info_reset(struct _lscp_server_info_t *pServerInfo);
// lscp_server_join
// file server.c line 558
enum _lscp_status_t lscp_server_join(struct _lscp_server_t *pServer);
// lscp_server_package
// file server.h line 104
const char * lscp_server_package(void);
// lscp_server_result
// file server.h line 119
enum _lscp_status_t lscp_server_result(struct _lscp_connect_t *pConnect, const char *pchBuffer, signed int cchBuffer);
// lscp_server_subscribe
// file server.h line 121
enum _lscp_status_t lscp_server_subscribe(struct _lscp_connect_t *pConnect, enum _lscp_event_t event);
// lscp_server_unsubscribe
// file server.h line 122
enum _lscp_status_t lscp_server_unsubscribe(struct _lscp_connect_t *pConnect, enum _lscp_event_t event);
// lscp_server_version
// file server.h line 105
const char * lscp_server_version(void);
// lscp_set_audio_channel_param
// file device.c line 626
enum _lscp_status_t lscp_set_audio_channel_param(struct _lscp_client_t *pClient, signed int iAudioDevice, signed int iAudioChannel, struct _lscp_param_t *pParam);
// lscp_set_audio_device_param
// file device.c line 542
enum _lscp_status_t lscp_set_audio_device_param(struct _lscp_client_t *pClient, signed int iAudioDevice, struct _lscp_param_t *pParam);
// lscp_set_channel_audio_channel
// file client.c line 1529
enum _lscp_status_t lscp_set_channel_audio_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iAudioOut, signed int iAudioIn);
// lscp_set_channel_audio_device
// file client.c line 1506
enum _lscp_status_t lscp_set_channel_audio_device(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iAudioDevice);
// lscp_set_channel_audio_type
// file client.c line 1484
enum _lscp_status_t lscp_set_channel_audio_type(struct _lscp_client_t *pClient, signed int iSamplerChannel, const char *pszAudioDriver);
// lscp_set_channel_midi_channel
// file client.c line 1618
enum _lscp_status_t lscp_set_channel_midi_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiChannel);
// lscp_set_channel_midi_device
// file client.c line 1573
enum _lscp_status_t lscp_set_channel_midi_device(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiDevice);
// lscp_set_channel_midi_map
// file client.c line 1645
enum _lscp_status_t lscp_set_channel_midi_map(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiMap);
// lscp_set_channel_midi_port
// file client.c line 1595
enum _lscp_status_t lscp_set_channel_midi_port(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiPort);
// lscp_set_channel_midi_type
// file client.c line 1551
enum _lscp_status_t lscp_set_channel_midi_type(struct _lscp_client_t *pClient, signed int iSamplerChannel, const char *pszMidiDriver);
// lscp_set_channel_mute
// file client.c line 1707
enum _lscp_status_t lscp_set_channel_mute(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMute);
// lscp_set_channel_solo
// file client.c line 1731
enum _lscp_status_t lscp_set_channel_solo(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iSolo);
// lscp_set_channel_volume
// file client.c line 1679
enum _lscp_status_t lscp_set_channel_volume(struct _lscp_client_t *pClient, signed int iSamplerChannel, float fVolume);
// lscp_set_fxsend_audio_channel
// file client.c line 2331
enum _lscp_status_t lscp_set_fxsend_audio_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend, signed int iAudioSrc, signed int iAudioDst);
// lscp_set_fxsend_level
// file client.c line 2378
enum _lscp_status_t lscp_set_fxsend_level(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend, float fLevel);
// lscp_set_fxsend_midi_controller
// file client.c line 2355
enum _lscp_status_t lscp_set_fxsend_midi_controller(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend, signed int iMidiController);
// lscp_set_fxsend_name
// file client.c line 2307
enum _lscp_status_t lscp_set_fxsend_name(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend, const char *pszFxName);
// lscp_set_midi_device_param
// file device.c line 922
enum _lscp_status_t lscp_set_midi_device_param(struct _lscp_client_t *pClient, signed int iMidiDevice, struct _lscp_param_t *pParam);
// lscp_set_midi_instrument_map_name
// file client.c line 2579
enum _lscp_status_t lscp_set_midi_instrument_map_name(struct _lscp_client_t *pClient, signed int iMidiMap, const char *pszMapName);
// lscp_set_midi_port_param
// file device.c line 1006
enum _lscp_status_t lscp_set_midi_port_param(struct _lscp_client_t *pClient, signed int iMidiDevice, signed int iMidiPort, struct _lscp_param_t *pParam);
// lscp_set_streams
// file client.c line 2068
enum _lscp_status_t lscp_set_streams(struct _lscp_client_t *pClient, signed int iMaxStreams);
// lscp_set_voices
// file client.c line 2006
enum _lscp_status_t lscp_set_voices(struct _lscp_client_t *pClient, signed int iMaxVoices);
// lscp_set_volume
// file client.c line 1940
enum _lscp_status_t lscp_set_volume(struct _lscp_client_t *pClient, float fVolume);
// lscp_socket_agent_free
// file ../lscp/socket.h line 80
enum _lscp_status_t lscp_socket_agent_free(struct _lscp_socket_agent_t *pAgent);
// lscp_socket_agent_init
// file ../lscp/socket.h line 77
void lscp_socket_agent_init(struct _lscp_socket_agent_t *pAgent, signed int sock, struct sockaddr_in *pAddr, signed int cAddr);
// lscp_socket_agent_join
// file ../lscp/socket.h line 79
enum _lscp_status_t lscp_socket_agent_join(struct _lscp_socket_agent_t *pAgent);
// lscp_socket_agent_start
// file ../lscp/socket.h line 78
enum _lscp_status_t lscp_socket_agent_start(struct _lscp_socket_agent_t *pAgent, void (*pfnProc)(void *), void *pvData, signed int iDetach);
// lscp_socket_agent_start::pfnProc_object
//
void pfnProc_object(void *);
// lscp_socket_getopts
// file socket.c line 153
void lscp_socket_getopts(const char *pszPrefix, signed int sock);
// lscp_socket_herror
// file socket.c line 119
void lscp_socket_herror(const char *pszPrefix);
// lscp_socket_perror
// file ../lscp/socket.h line 58
void lscp_socket_perror(const char *pszPrefix);
// lscp_socket_trace
// file ../lscp/socket.h line 62
void lscp_socket_trace(const char *pszPrefix, struct sockaddr_in *pAddr, const char *pchBuffer, signed int cchBuffer);
// lscp_strtok
// file common.h line 100
char * lscp_strtok(char *pchBuffer, const char *pszSeps, char **ppch);
// lscp_szsplit_create
// file common.h line 105
char ** lscp_szsplit_create(const char *pszCsv, const char *pszSeps);
// lscp_szsplit_destroy
// file common.h line 106
void lscp_szsplit_destroy(char **ppszSplit);
// lscp_thread_cancel
// file thread.c line 135
enum _lscp_status_t lscp_thread_cancel(struct _lscp_thread_t *pThread);
// lscp_thread_create
// file thread.c line 63
struct _lscp_thread_t * lscp_thread_create(void (*pfnProc)(void *), void *pvData, signed int iDetach);
// lscp_thread_create::pfnProc_object
//
void pfnProc_object(void *);
// lscp_thread_destroy
// file thread.c line 160
enum _lscp_status_t lscp_thread_destroy(struct _lscp_thread_t *pThread);
// lscp_thread_join
// file thread.c line 110
enum _lscp_status_t lscp_thread_join(struct _lscp_thread_t *pThread);
// lscp_unmap_midi_instrument
// file client.c line 2674
enum _lscp_status_t lscp_unmap_midi_instrument(struct _lscp_client_t *pClient, struct _lscp_midi_instrument_t *pMidiInstr);
// lscp_unquote
// file common.h line 102
char * lscp_unquote(char **ppsz, signed int dup);
// lscp_unquote_dup
// file common.h line 103
void lscp_unquote_dup(char **ppszDst, char **ppszSrc);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_0 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_0 *, const union anonymous_1 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_0 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_0 *, union anonymous_2 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_2 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_2 *, const union anonymous_1 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_2 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_3 *, struct anonymous_3 *, struct anonymous_3 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// server_callback
// file example_server.c line 37
enum _lscp_status_t server_callback(struct _lscp_connect_t *pConnect, const char *pchBuffer, signed int cchBuffer, void *pvData);
// server_prompt
// file example_server.c line 835
void server_prompt(void);
// server_usage
// file example_server.c line 827
void server_usage(void);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strpbrk
// file /usr/include/string.h line 314
extern char * strpbrk(const char *, const char *);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);

struct anonymous_3
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous_1
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_0
{
  // __data
  struct anonymous __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _locale_t
{
  // numeric
  char numeric[32l];
  // ctype
  char ctype[32l];
};

struct _lscp_buffer_fill_t
{
  // stream_id
  unsigned int stream_id;
  // stream_usage
  unsigned long int stream_usage;
};

struct _lscp_channel_info_t
{
  // engine_name
  char *engine_name;
  // audio_device
  signed int audio_device;
  // audio_channels
  signed int audio_channels;
  // audio_routing
  signed int *audio_routing;
  // instrument_file
  char *instrument_file;
  // instrument_nr
  signed int instrument_nr;
  // instrument_name
  char *instrument_name;
  // instrument_status
  signed int instrument_status;
  // midi_device
  signed int midi_device;
  // midi_port
  signed int midi_port;
  // midi_channel
  signed int midi_channel;
  // midi_map
  signed int midi_map;
  // volume
  float volume;
  // mute
  signed int mute;
  // solo
  signed int solo;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct _lscp_socket_agent_t
{
  // sock
  signed int sock;
  // addr
  struct sockaddr_in addr;
  // pThread
  struct _lscp_thread_t *pThread;
  // iState
  signed int iState;
};

struct _lscp_driver_info_t
{
  // description
  char *description;
  // version
  char *version;
  // parameters
  char **parameters;
};

struct _lscp_device_info_t
{
  // driver
  char *driver;
  // params
  struct _lscp_param_t *params;
};

struct _lscp_param_info_t
{
  // type
  enum _lscp_type_t type;
  // description
  char *description;
  // mandatory
  signed int mandatory;
  // fix
  signed int fix;
  // multiplicity
  signed int multiplicity;
  // depends
  char **depends;
  // defaultv
  char *defaultv;
  // range_min
  char *range_min;
  // range_max
  char *range_max;
  // possibilities
  char **possibilities;
};

struct _lscp_device_port_info_t
{
  // name
  char *name;
  // params
  struct _lscp_param_t *params;
};

struct _lscp_server_info_t
{
  // description
  char *description;
  // version
  char *version;
  // protocol_version
  char *protocol_version;
};

struct _lscp_engine_info_t
{
  // description
  char *description;
  // version
  char *version;
};

struct _lscp_fxsend_info_t
{
  // name
  char *name;
  // midi_controller
  signed int midi_controller;
  // audio_routing
  signed int *audio_routing;
  // level
  float level;
};

struct _lscp_midi_instrument_info_t
{
  // name
  char *name;
  // engine_name
  char *engine_name;
  // instrument_file
  char *instrument_file;
  // instrument_nr
  signed int instrument_nr;
  // instrument_name
  char *instrument_name;
  // load_mode
  enum _lscp_load_mode_t load_mode;
  // volume
  float volume;
};

struct _lscp_client_t
{
  // pfnCallback
  enum _lscp_status_t (*pfnCallback)(struct _lscp_client_t *, enum _lscp_event_t, const char *, signed int, void *);
  // pvData
  void *pvData;
  // cmd
  struct _lscp_socket_agent_t cmd;
  // evt
  struct _lscp_socket_agent_t evt;
  // events
  enum _lscp_event_t events;
  // audio_drivers
  char **audio_drivers;
  // midi_drivers
  char **midi_drivers;
  // audio_devices
  signed int *audio_devices;
  // midi_devices
  signed int *midi_devices;
  // engines
  char **engines;
  // channels
  signed int *channels;
  // fxsends
  signed int *fxsends;
  // midi_instruments
  struct _lscp_midi_instrument_t *midi_instruments;
  // midi_maps
  signed int *midi_maps;
  // midi_map_name
  char *midi_map_name;
  // audio_driver_info
  struct _lscp_driver_info_t audio_driver_info;
  // midi_driver_info
  struct _lscp_driver_info_t midi_driver_info;
  // audio_device_info
  struct _lscp_device_info_t audio_device_info;
  // midi_device_info
  struct _lscp_device_info_t midi_device_info;
  // audio_param_info
  struct _lscp_param_info_t audio_param_info;
  // midi_param_info
  struct _lscp_param_info_t midi_param_info;
  // audio_channel_info
  struct _lscp_device_port_info_t audio_channel_info;
  // midi_port_info
  struct _lscp_device_port_info_t midi_port_info;
  // audio_channel_param_info
  struct _lscp_param_info_t audio_channel_param_info;
  // midi_port_param_info
  struct _lscp_param_info_t midi_port_param_info;
  // server_info
  struct _lscp_server_info_t server_info;
  // engine_info
  struct _lscp_engine_info_t engine_info;
  // channel_info
  struct _lscp_channel_info_t channel_info;
  // fxsend_info
  struct _lscp_fxsend_info_t fxsend_info;
  // midi_instrument_info
  struct _lscp_midi_instrument_info_t midi_instrument_info;
  // pszResult
  char *pszResult;
  // iErrno
  signed int iErrno;
  // buffer_fill
  struct _lscp_buffer_fill_t *buffer_fill;
  // iStreamCount
  signed int iStreamCount;
  // iTimeout
  signed int iTimeout;
  // mutex
  union anonymous_2 mutex;
  // cond
  union anonymous_0 cond;
  // iTimeoutCount
  signed int iTimeoutCount;
};

struct _lscp_connect_list_t
{
  // first
  struct _lscp_connect_t *first;
  // last
  struct _lscp_connect_t *last;
  // count
  unsigned int count;
  // mutex
  union anonymous_2 mutex;
};

struct _lscp_connect_t
{
  // server
  struct _lscp_server_t *server;
  // client
  struct _lscp_socket_agent_t client;
  // events
  enum _lscp_event_t events;
  // prev
  struct _lscp_connect_t *prev;
  // next
  struct _lscp_connect_t *next;
};

struct _lscp_midi_instrument_t
{
  // map
  signed int map;
  // bank
  signed int bank;
  // prog
  signed int prog;
};

struct _lscp_param_t
{
  // key
  char *key;
  // value
  char *value;
};

struct _lscp_parser_t
{
  // pchBuffer
  char *pchBuffer;
  // cchBuffer
  signed int cchBuffer;
  // pszToken
  const char *pszToken;
  // pch
  char *pch;
};

struct _lscp_server_t
{
  // mode
  enum _lscp_server_mode_t mode;
  // connects
  struct _lscp_connect_list_t connects;
  // pfnCallback
  enum _lscp_status_t (*pfnCallback)(struct _lscp_connect_t *, const char *, signed int, void *);
  // pvData
  void *pvData;
  // agent
  struct _lscp_socket_agent_t agent;
};

struct _lscp_thread_t
{
  // pthread
  unsigned long int pthread;
  // pfnProc
  void (*pfnProc)(void *);
  // pvData
  void *pvData;
  // iDetach
  signed int iDetach;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// _atof
// file client.c line 66
static float _atof(const char *txt)
{
  float f;
  sscanf(txt, "%f", &f);
  return f;
}

// _lscp_client_evt_connect
// file client.c line 171
static enum _lscp_status_t _lscp_client_evt_connect(struct _lscp_client_t *pClient)
{
  signed int sock;
  struct sockaddr_in addr;
  signed int cAddr;
  sock=socket(2, 1, 0);
  if(sock == -1)
  {
    lscp_socket_perror("_lscp_client_evt_connect: socket");
    return (enum _lscp_status_t)LSCP_FAILED;
  }

  else
  {
    cAddr = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
    memmove((void *)(char *)&addr, (const void *)&pClient->cmd.addr, (unsigned long int)cAddr);
    signed int return_value_connect_1;
    return_value_connect_1=connect(sock, (struct sockaddr *)&addr, (unsigned int)cAddr);
    if(return_value_connect_1 == -1)
    {
      lscp_socket_perror("_lscp_client_evt_connect: connect");
      close(sock);
      return (enum _lscp_status_t)LSCP_FAILED;
    }

    else
    {
      lscp_socket_agent_init(&pClient->evt, sock, &addr, cAddr);
      enum _lscp_status_t return_value_lscp_socket_agent_start_2;
      return_value_lscp_socket_agent_start_2=lscp_socket_agent_start(&pClient->evt, _lscp_client_evt_proc, (void *)pClient, 0);
      return return_value_lscp_socket_agent_start_2;
    }
  }
}

// _lscp_client_evt_proc
// file client.c line 76
static void _lscp_client_evt_proc(void *pvClient)
{
  struct _lscp_client_t *pClient = (struct _lscp_client_t *)pvClient;
  struct anonymous_3 fds;
  signed int fd;
  signed int fdmax;
  struct timeval tv;
  signed int iSelect;
  signed int iTimeout;
  char achBuffer[1024l];
  signed int cchBuffer;
  const char *pszSeps = ":\r\n";
  char *pszToken;
  char *pch;
  signed int cchToken;
  enum _lscp_event_t event;
  _Bool tmp_if_expr_5;
  unsigned long int tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  while(!(pClient->evt.iState == 0))
  {
    fd = (signed int)pClient->evt.sock;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&fds)->__fds_bits[(signed long int)((unsigned int)fd / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)((unsigned int)fd / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << (unsigned int)fd % (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    fdmax = fd;
    iTimeout = 10 * pClient->iTimeout;
    if(iTimeout >= 1000)
    {
      tv.tv_sec = (signed long int)(iTimeout / 1000);
      iTimeout = iTimeout - (signed int)(tv.tv_sec * (signed long int)1000);
    }

    else
      tv.tv_sec = (signed long int)0;
    tv.tv_usec = (signed long int)(iTimeout * 1000);
    iSelect=select(fdmax + 1, &fds, (struct anonymous_3 *)(void *)0, (struct anonymous_3 *)(void *)0, &tv);
    if(iSelect >= 1)
      tmp_if_expr_5 = ((&fds)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      signed long int return_value_recv_1;
      return_value_recv_1=recv(pClient->evt.sock, (void *)achBuffer, sizeof(char [1024l]) /*1024ul*/ , 0);
      cchBuffer = (signed int)return_value_recv_1;
      if(cchBuffer >= 1)
      {
        achBuffer[(signed long int)cchBuffer] = (char)0;
        pch = achBuffer;
        do
        {
          pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
          signed int return_value_strcasecmp_4;
          return_value_strcasecmp_4=strcasecmp(pszToken, "NOTIFY");
          if(return_value_strcasecmp_4 == 0)
          {
            pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
            event=lscp_event_from_text(pszToken);
            pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
            if(pszToken == ((char *)NULL))
              tmp_if_expr_3 = (unsigned long int)0;

            else
            {
              return_value_strlen_2=strlen(pszToken);
              tmp_if_expr_3 = return_value_strlen_2;
            }
            cchToken = (signed int)tmp_if_expr_3;
            if(!(((signed int)pClient->events & (signed int)event) == 0))
            {
              enum _lscp_status_t return_value;
              return_value=pClient->pfnCallback(pClient, event, pszToken, cchToken, pClient->pvData);
              if(!((signed int)return_value == LSCP_OK))
                pClient->evt.iState = 0;

            }

          }

        }
        while(!(*pch == 0));
      }

      else
      {
        lscp_socket_perror("_lscp_client_evt_proc: recv");
        pClient->evt.iState = 0;
      }
    }

    else
      if(!(iSelect >= 0))
      {
        lscp_socket_perror("_lscp_client_evt_proc: select");
        pClient->evt.iState = 0;
      }

    pthread_cond_signal(&pClient->cond);
  }
}

// _lscp_client_evt_request
// file client.c line 216
static enum _lscp_status_t _lscp_client_evt_request(struct _lscp_client_t *pClient, signed int iSubscribe, enum _lscp_event_t event)
{
  const char *pszEvent;
  char szQuery[1024l];
  signed int cchQuery;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    pszEvent=lscp_event_to_text(event);
    if(pszEvent == ((const char *)NULL))
      return (enum _lscp_status_t)LSCP_FAILED;

    else
    {
      cchQuery=sprintf(szQuery, "%sSUBSCRIBE %s\n\n", iSubscribe == 0 ? "UN" : "", pszEvent);
      signed long int return_value_send_1;
      return_value_send_1=send(pClient->evt.sock, (const void *)szQuery, (unsigned long int)cchQuery, 0);
      if(!(return_value_send_1 >= (signed long int)cchQuery))
      {
        lscp_socket_perror("_lscp_client_evt_request: send");
        return (enum _lscp_status_t)LSCP_FAILED;
      }

      else
      {
        pthread_cond_wait(&pClient->cond, &pClient->mutex);
        if(!(iSubscribe == 0))
          pClient->events = pClient->events | event;

        else
          pClient->events = pClient->events & (enum _lscp_event_t)~((signed int)event);
        return (enum _lscp_status_t)LSCP_OK;
      }
    }
  }
}

// _lscp_connect_create
// file server.c line 175
static struct _lscp_connect_t * _lscp_connect_create(struct _lscp_server_t *pServer, signed int sock, struct sockaddr_in *pAddr, signed int cAddr)
{
  struct _lscp_connect_t *pConnect;
  if(pServer == ((struct _lscp_server_t *)NULL) || pAddr == ((struct sockaddr_in *)NULL) || sock == -1)
  {
    fprintf(stderr, "_lscp_connect_create: Invalid connection arguments.\n");
    return (struct _lscp_connect_t *)(void *)0;
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct _lscp_connect_t) /*72ul*/ );
    pConnect = (struct _lscp_connect_t *)return_value_malloc_1;
    if(pConnect == ((struct _lscp_connect_t *)NULL))
    {
      fprintf(stderr, "_lscp_connect_create: Out of memory.\n");
      close(sock);
      return (struct _lscp_connect_t *)(void *)0;
    }

    else
    {
      memset((void *)pConnect, 0, sizeof(struct _lscp_connect_t) /*72ul*/ );
      pConnect->server = pServer;
      pConnect->events = (enum _lscp_event_t)LSCP_EVENT_NONE;
      lscp_socket_agent_init(&pConnect->client, sock, pAddr, cAddr);
      if((signed int)pServer->mode == LSCP_SERVER_THREAD)
      {
        enum _lscp_status_t return_value_lscp_socket_agent_start_2;
        return_value_lscp_socket_agent_start_2=lscp_socket_agent_start(&pConnect->client, _lscp_connect_proc, (void *)pConnect, 0);
        if(!((signed int)return_value_lscp_socket_agent_start_2 == LSCP_OK))
        {
          close(sock);
          free((void *)pConnect);
          return (struct _lscp_connect_t *)(void *)0;
        }

      }

      return pConnect;
    }
  }
}

// _lscp_connect_destroy
// file server.c line 213
static enum _lscp_status_t _lscp_connect_destroy(struct _lscp_connect_t *pConnect)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  if(pConnect == ((struct _lscp_connect_t *)NULL))
    return ret;

  else
  {
    lscp_socket_agent_free(&pConnect->client);
    free((void *)pConnect);
    return ret;
  }
}

// _lscp_connect_list_append
// file server.c line 61
static void _lscp_connect_list_append(struct _lscp_connect_list_t *pList, struct _lscp_connect_t *pItem)
{
  pthread_mutex_lock(&pList->mutex);
  pItem->prev = pList->last;
  pItem->next = (struct _lscp_connect_t *)(void *)0;
  if(!(pList->last == ((struct _lscp_connect_t *)NULL)))
    pList->last->next = pItem;

  else
    pList->first = pItem;
  pList->last = pItem;
  pList->count = pList->count + 1u;
  pthread_mutex_unlock(&pList->mutex);
}

// _lscp_connect_list_find_sock
// file server.c line 143
static struct _lscp_connect_t * _lscp_connect_list_find_sock(struct _lscp_connect_list_t *pList, signed int sock)
{
  struct _lscp_connect_t *p = pList->first;
  for( ; !(p == ((struct _lscp_connect_t *)NULL)); p = p->next)
    if(sock == p->client.sock)
      return p;

  return (struct _lscp_connect_t *)(void *)0;
}

// _lscp_connect_list_free
// file server.c line 123
static void _lscp_connect_list_free(struct _lscp_connect_list_t *pList)
{
  struct _lscp_connect_t *p;
  struct _lscp_connect_t *pNext;
  pthread_mutex_lock(&pList->mutex);
  p = pList->first;
  for( ; !(p == ((struct _lscp_connect_t *)NULL)); p = pNext)
  {
    pNext = p->next;
    _lscp_connect_list_remove(pList, p);
    _lscp_connect_destroy(p);
  }
  pthread_mutex_unlock(&pList->mutex);
  pthread_mutex_destroy(&pList->mutex);
}

// _lscp_connect_list_init
// file server.c line 49
static void _lscp_connect_list_init(struct _lscp_connect_list_t *pList)
{
  pList->first = (struct _lscp_connect_t *)(void *)0;
  pList->last = (struct _lscp_connect_t *)(void *)0;
  pList->count = (unsigned int)0;
  pthread_mutex_init(&pList->mutex, (const union anonymous_1 *)(void *)0);
}

// _lscp_connect_list_remove
// file server.c line 83
static void _lscp_connect_list_remove(struct _lscp_connect_list_t *pList, struct _lscp_connect_t *pItem)
{
  if(!(pItem->next == ((struct _lscp_connect_t *)NULL)))
    pItem->next->prev = pItem->prev;

  else
    pList->last = pItem->prev;
  if(!(pItem->prev == ((struct _lscp_connect_t *)NULL)))
    pItem->prev->next = pItem->next;

  else
    pList->first = pItem->next;
  pItem->next = (struct _lscp_connect_t *)(void *)0;
  pItem->prev = (struct _lscp_connect_t *)(void *)0;
  pList->count = pList->count - 1u;
}

// _lscp_connect_list_remove_safe
// file server.c line 104
static void _lscp_connect_list_remove_safe(struct _lscp_connect_list_t *pList, struct _lscp_connect_t *pItem)
{
  struct _lscp_connect_t *p;
  pthread_mutex_lock(&pList->mutex);
  p = pList->first;
  for( ; !(p == ((struct _lscp_connect_t *)NULL)); p = p->next)
    if(p == pItem)
    {
      _lscp_connect_list_remove(pList, pItem);
      break;
    }

  pthread_mutex_unlock(&pList->mutex);
}

// _lscp_connect_proc
// file server.c line 160
static void _lscp_connect_proc(void *pvConnect)
{
  struct _lscp_connect_t *pConnect = (struct _lscp_connect_t *)pvConnect;
  struct _lscp_server_t *pServer = pConnect->server;
  while(!(pServer->agent.iState == 0))
  {
    if(pConnect->client.iState == 0)
      break;

    enum _lscp_status_t return_value__lscp_connect_recv_1;
    return_value__lscp_connect_recv_1=_lscp_connect_recv(pConnect);
    if(!((signed int)return_value__lscp_connect_recv_1 == LSCP_OK))
      pConnect->client.iState = 0;

  }
  pServer->pfnCallback(pConnect, (const char *)(void *)0, 1, pServer->pvData);
  _lscp_connect_list_remove_safe(&pServer->connects, pConnect);
  close(pConnect->client.sock);
}

// _lscp_connect_recv
// file server.c line 232
static enum _lscp_status_t _lscp_connect_recv(struct _lscp_connect_t *pConnect)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  struct _lscp_server_t *pServer;
  char achBuffer[1024l];
  signed int cchBuffer;
  if(pConnect == ((struct _lscp_connect_t *)NULL))
    return ret;

  else
  {
    pServer = pConnect->server;
    if(pServer == ((struct _lscp_server_t *)NULL))
      return ret;

    else
    {
      signed long int return_value_recv_1;
      return_value_recv_1=recv(pConnect->client.sock, (void *)achBuffer, sizeof(char [1024l]) /*1024ul*/ , 0);
      cchBuffer = (signed int)return_value_recv_1;
      if(cchBuffer >= 1)
        ret=pServer->pfnCallback(pConnect, achBuffer, cchBuffer, pServer->pvData);

      else
        if(!(cchBuffer >= 0))
          lscp_socket_perror("_lscp_connect_recv: recv");

      return ret;
    }
  }
}

// _lscp_device_info_query
// file device.c line 86
static struct _lscp_device_info_t * _lscp_device_info_query(struct _lscp_client_t *pClient, struct _lscp_device_info_t *pDeviceInfo, char *pszQuery)
{
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  char *pszKey;
  pthread_mutex_lock(&pClient->mutex);
  lscp_device_info_reset(pDeviceInfo);
  enum _lscp_status_t return_value_lscp_client_call_3;
  return_value_lscp_client_call_3=lscp_client_call(pClient, pszQuery, 1);
  char *return_value_lscp_unquote_1;
  if((signed int)return_value_lscp_client_call_3 == LSCP_OK)
  {
    pszResult=lscp_client_get_result(pClient);
    pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
    while(!(pszToken == ((char *)NULL)))
    {
      signed int return_value_strcasecmp_2;
      return_value_strcasecmp_2=strcasecmp(pszToken, "DRIVER");
      if(return_value_strcasecmp_2 == 0)
      {
        pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
        if(!(pszToken == ((char *)NULL)))
          lscp_unquote_dup(&pDeviceInfo->driver, &pszToken);

      }

      else
      {
        pszKey = pszToken;
        pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
        if(!(pszToken == ((char *)NULL)))
        {
          return_value_lscp_unquote_1=lscp_unquote(&pszToken, 0);
          lscp_plist_append(&pDeviceInfo->params, pszKey, return_value_lscp_unquote_1);
        }

      }
      pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
    }
  }

  else
    pDeviceInfo = (struct _lscp_device_info_t *)(void *)0;
  pthread_mutex_unlock(&pClient->mutex);
  return pDeviceInfo;
}

// _lscp_device_port_info_query
// file device.c line 127
static struct _lscp_device_port_info_t * _lscp_device_port_info_query(struct _lscp_client_t *pClient, struct _lscp_device_port_info_t *pDevicePortInfo, char *pszQuery)
{
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  char *pszKey;
  char *pszVal;
  pthread_mutex_lock(&pClient->mutex);
  lscp_device_port_info_reset(pDevicePortInfo);
  enum _lscp_status_t return_value_lscp_client_call_2;
  return_value_lscp_client_call_2=lscp_client_call(pClient, pszQuery, 1);
  if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
  {
    pszResult=lscp_client_get_result(pClient);
    pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
    while(!(pszToken == ((char *)NULL)))
    {
      pszKey = pszToken;
      pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
      if(!(pszKey == ((char *)NULL)) && !(pszToken == ((char *)NULL)))
      {
        pszVal=lscp_unquote(&pszToken, 0);
        lscp_plist_append(&pDevicePortInfo->params, pszKey, pszVal);
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp(pszKey, "NAME");
        if(return_value_strcasecmp_1 == 0)
        {
          if(!(pDevicePortInfo->name == ((char *)NULL)))
            free((void *)pDevicePortInfo->name);

          pDevicePortInfo->name = (char *)(void *)0;
          if(!(pszVal == ((char *)NULL)))
            pDevicePortInfo->name=strdup(pszVal);

        }

      }

      pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
    }
  }

  else
    pDevicePortInfo = (struct _lscp_device_port_info_t *)(void *)0;
  pthread_mutex_unlock(&pClient->mutex);
  return pDevicePortInfo;
}

// _lscp_driver_info_query
// file device.c line 39
static struct _lscp_driver_info_t * _lscp_driver_info_query(struct _lscp_client_t *pClient, struct _lscp_driver_info_t *pDriverInfo, char *pszQuery)
{
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  pthread_mutex_lock(&pClient->mutex);
  lscp_driver_info_reset(pDriverInfo);
  enum _lscp_status_t return_value_lscp_client_call_4;
  return_value_lscp_client_call_4=lscp_client_call(pClient, pszQuery, 1);
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if((signed int)return_value_lscp_client_call_4 == LSCP_OK)
  {
    pszResult=lscp_client_get_result(pClient);
    pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
    while(!(pszToken == ((char *)NULL)))
    {
      signed int return_value_strcasecmp_3;
      return_value_strcasecmp_3=strcasecmp(pszToken, "DESCRIPTION");
      if(return_value_strcasecmp_3 == 0)
      {
        pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
        if(!(pszToken == ((char *)NULL)))
          lscp_unquote_dup(&pDriverInfo->description, &pszToken);

      }

      else
      {
        return_value_strcasecmp_2=strcasecmp(pszToken, "VERSION");
        if(return_value_strcasecmp_2 == 0)
        {
          pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
          if(!(pszToken == ((char *)NULL)))
            lscp_unquote_dup(&pDriverInfo->version, &pszToken);

        }

        else
        {
          return_value_strcasecmp_1=strcasecmp(pszToken, "PARAMETERS");
          if(return_value_strcasecmp_1 == 0)
          {
            pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
            if(!(pszToken == ((char *)NULL)))
            {
              if(!(pDriverInfo->parameters == ((char **)NULL)))
                lscp_szsplit_destroy(pDriverInfo->parameters);

              pDriverInfo->parameters=lscp_szsplit_create(pszToken, ",");
            }

          }

        }
      }
      pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
    }
  }

  else
    pDriverInfo = (struct _lscp_driver_info_t *)(void *)0;
  pthread_mutex_unlock(&pClient->mutex);
  return pDriverInfo;
}

// _lscp_param_info_query
// file device.c line 172
static struct _lscp_param_info_t * _lscp_param_info_query(struct _lscp_client_t *pClient, struct _lscp_param_info_t *pParamInfo, char *pszQuery, signed int cchMaxQuery, struct _lscp_param_t *pDepList)
{
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  pthread_mutex_lock(&pClient->mutex);
  lscp_param_info_reset(pParamInfo);
  lscp_param_concat(pszQuery, cchMaxQuery, pDepList);
  enum _lscp_status_t return_value_lscp_client_call_21;
  return_value_lscp_client_call_21=lscp_client_call(pClient, pszQuery, 1);
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  signed int return_value_strcasecmp_19;
  signed int return_value_strcasecmp_18;
  char *return_value_lscp_unquote_5;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_17;
  char *return_value_lscp_unquote_7;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_16;
  char *return_value_lscp_unquote_9;
  signed int return_value_strcasecmp_10;
  signed int return_value_strcasecmp_15;
  signed int return_value_strcasecmp_14;
  signed int return_value_strcasecmp_13;
  signed int return_value_strcasecmp_12;
  signed int return_value_strcasecmp_11;
  if((signed int)return_value_lscp_client_call_21 == LSCP_OK)
  {
    pszResult=lscp_client_get_result(pClient);
    pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
    while(!(pszToken == ((char *)NULL)))
    {
      signed int return_value_strcasecmp_20;
      return_value_strcasecmp_20=strcasecmp(pszToken, "TYPE");
      if(return_value_strcasecmp_20 == 0)
      {
        pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
        if(!(pszToken == ((char *)NULL)))
        {
          pszToken=lscp_unquote(&pszToken, 0);
          signed int return_value_strcasecmp_4;
          return_value_strcasecmp_4=strcasecmp(pszToken, "BOOL");
          if(return_value_strcasecmp_4 == 0)
            pParamInfo->type = (enum _lscp_type_t)LSCP_TYPE_BOOL;

          else
          {
            return_value_strcasecmp_3=strcasecmp(pszToken, "INT");
            if(return_value_strcasecmp_3 == 0)
              pParamInfo->type = (enum _lscp_type_t)LSCP_TYPE_INT;

            else
            {
              return_value_strcasecmp_2=strcasecmp(pszToken, "FLOAT");
              if(return_value_strcasecmp_2 == 0)
                pParamInfo->type = (enum _lscp_type_t)LSCP_TYPE_FLOAT;

              else
              {
                return_value_strcasecmp_1=strcasecmp(pszToken, "STRING");
                if(return_value_strcasecmp_1 == 0)
                  pParamInfo->type = (enum _lscp_type_t)LSCP_TYPE_STRING;

              }
            }
          }
        }

      }

      else
      {
        return_value_strcasecmp_19=strcasecmp(pszToken, "DESCRIPTION");
        if(return_value_strcasecmp_19 == 0)
        {
          pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
          if(!(pszToken == ((char *)NULL)))
            lscp_unquote_dup(&pParamInfo->description, &pszToken);

        }

        else
        {
          return_value_strcasecmp_18=strcasecmp(pszToken, "MANDATORY");
          if(return_value_strcasecmp_18 == 0)
          {
            pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
            if(!(pszToken == ((char *)NULL)))
            {
              return_value_lscp_unquote_5=lscp_unquote(&pszToken, 0);
              return_value_strcasecmp_6=strcasecmp(return_value_lscp_unquote_5, "TRUE");
              pParamInfo->mandatory = (signed int)(return_value_strcasecmp_6 == 0);
            }

          }

          else
          {
            return_value_strcasecmp_17=strcasecmp(pszToken, "FIX");
            if(return_value_strcasecmp_17 == 0)
            {
              pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
              if(!(pszToken == ((char *)NULL)))
              {
                return_value_lscp_unquote_7=lscp_unquote(&pszToken, 0);
                return_value_strcasecmp_8=strcasecmp(return_value_lscp_unquote_7, "TRUE");
                pParamInfo->fix = (signed int)(return_value_strcasecmp_8 == 0);
              }

            }

            else
            {
              return_value_strcasecmp_16=strcasecmp(pszToken, "MULTIPLICITY");
              if(return_value_strcasecmp_16 == 0)
              {
                pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                if(!(pszToken == ((char *)NULL)))
                {
                  return_value_lscp_unquote_9=lscp_unquote(&pszToken, 0);
                  return_value_strcasecmp_10=strcasecmp(return_value_lscp_unquote_9, "TRUE");
                  pParamInfo->multiplicity = (signed int)(return_value_strcasecmp_10 == 0);
                }

              }

              else
              {
                return_value_strcasecmp_15=strcasecmp(pszToken, "DEPENDS");
                if(return_value_strcasecmp_15 == 0)
                {
                  pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                  if(!(pszToken == ((char *)NULL)))
                  {
                    if(!(pParamInfo->depends == ((char **)NULL)))
                      lscp_szsplit_destroy(pParamInfo->depends);

                    pParamInfo->depends=lscp_szsplit_create(pszToken, ",");
                  }

                }

                else
                {
                  return_value_strcasecmp_14=strcasecmp(pszToken, "DEFAULT");
                  if(return_value_strcasecmp_14 == 0)
                  {
                    pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                    if(!(pszToken == ((char *)NULL)))
                      lscp_unquote_dup(&pParamInfo->defaultv, &pszToken);

                  }

                  else
                  {
                    return_value_strcasecmp_13=strcasecmp(pszToken, "RANGE_MIN");
                    if(return_value_strcasecmp_13 == 0)
                    {
                      pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                      if(!(pszToken == ((char *)NULL)))
                        lscp_unquote_dup(&pParamInfo->range_min, &pszToken);

                    }

                    else
                    {
                      return_value_strcasecmp_12=strcasecmp(pszToken, "RANGE_MAX");
                      if(return_value_strcasecmp_12 == 0)
                      {
                        pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                        if(!(pszToken == ((char *)NULL)))
                          lscp_unquote_dup(&pParamInfo->range_max, &pszToken);

                      }

                      else
                      {
                        return_value_strcasecmp_11=strcasecmp(pszToken, "POSSIBILITIES");
                        if(return_value_strcasecmp_11 == 0)
                        {
                          pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                          if(!(pszToken == ((char *)NULL)))
                          {
                            if(!(pParamInfo->possibilities == ((char **)NULL)))
                              lscp_szsplit_destroy(pParamInfo->possibilities);

                            pParamInfo->possibilities=lscp_szsplit_create(pszToken, ",");
                          }

                        }

                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
    }
  }

  else
    pParamInfo = (struct _lscp_param_info_t *)(void *)0;
  pthread_mutex_unlock(&pClient->mutex);
  return pParamInfo;
}

// _lscp_server_agent_proc
// file server.c line 388
static void _lscp_server_agent_proc(void *pvServer)
{
  struct _lscp_server_t *pServer = (struct _lscp_server_t *)pvServer;
  if((signed int)pServer->mode == LSCP_SERVER_THREAD)
    _lscp_server_thread_proc(pServer);

  else
    _lscp_server_select_proc(pServer);
}

// _lscp_server_select_proc
// file server.c line 291
static void _lscp_server_select_proc(struct _lscp_server_t *pServer)
{
  struct anonymous_3 master_fds;
  struct anonymous_3 select_fds;
  signed int fd;
  signed int fdmax;
  struct timeval tv;
  signed int iSelect;
  signed int sock;
  struct sockaddr_in addr;
  unsigned int cAddr;
  struct _lscp_connect_t *pConnect;
  do
  {
    signed int _lscp_server_select_proc__1__1____d0;
    signed int _lscp_server_select_proc__1__1____d1;
    asm("cld; rep; stosq" : "=c"(_lscp_server_select_proc__1__1____d0), "=D"(_lscp_server_select_proc__1__1____d1) : "a"(0), "0"(sizeof(struct anonymous_3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&master_fds)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&select_fds)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&master_fds)->__fds_bits[(signed long int)((unsigned int)pServer->agent.sock / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&master_fds)->__fds_bits[(signed long int)((unsigned int)pServer->agent.sock / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << (unsigned int)pServer->agent.sock % (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  fdmax = (signed int)pServer->agent.sock;
  while(!(pServer->agent.iState == 0))
  {
    select_fds = master_fds;
    tv.tv_sec = (signed long int)30;
    tv.tv_usec = (signed long int)0;
    iSelect=select(fdmax + 1, &select_fds, (struct anonymous_3 *)(void *)0, (struct anonymous_3 *)(void *)0, &tv);
    if(!(iSelect >= 0))
    {
      lscp_socket_perror("_lscp_server_select_proc: select");
      pServer->agent.iState = 0;
    }

    else
      if(iSelect >= 1)
      {
        fd = 0;
        for( ; !(fd >= 1 + fdmax); fd = fd + 1)
          if(!((select_fds.__fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
          {
            if(fd == pServer->agent.sock)
            {
              cAddr = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
              sock=accept(pServer->agent.sock, (struct sockaddr *)&addr, &cAddr);
              if(sock == -1)
              {
                lscp_socket_perror("_lscp_server_select_proc: accept");
                pServer->agent.iState = 0;
              }

              else
              {
                (&master_fds)->__fds_bits[(signed long int)((unsigned int)sock / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&master_fds)->__fds_bits[(signed long int)((unsigned int)sock / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << (unsigned int)sock % (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                if(!(fdmax >= sock))
                  fdmax = (signed int)sock;

                pConnect=_lscp_connect_create(pServer, sock, &addr, (signed int)cAddr);
                if(!(pConnect == ((struct _lscp_connect_t *)NULL)))
                {
                  _lscp_connect_list_append(&pServer->connects, pConnect);
                  pServer->pfnCallback(pConnect, (const char *)(void *)0, 0, pServer->pvData);
                }

              }
            }

            else
            {
              pthread_mutex_lock(&pServer->connects.mutex);
              pConnect=_lscp_connect_list_find_sock(&pServer->connects, (signed int)fd);
              enum _lscp_status_t return_value__lscp_connect_recv_1;
              return_value__lscp_connect_recv_1=_lscp_connect_recv(pConnect);
              if(!((signed int)return_value__lscp_connect_recv_1 == LSCP_OK))
              {
                if(!(pConnect == ((struct _lscp_connect_t *)NULL)))
                {
                  pServer->pfnCallback(pConnect, (const char *)(void *)0, 1, pServer->pvData);
                  _lscp_connect_list_remove(&pServer->connects, pConnect);
                  _lscp_connect_destroy(pConnect);
                }

                (&master_fds)->__fds_bits[(signed long int)((unsigned int)fd / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&master_fds)->__fds_bits[(signed long int)((unsigned int)fd / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << (unsigned int)fd % (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ )));
              }

              pthread_mutex_unlock(&pServer->connects.mutex);
            }
          }

      }

  }
}

// _lscp_server_thread_proc
// file server.c line 259
static void _lscp_server_thread_proc(struct _lscp_server_t *pServer)
{
  signed int sock;
  struct sockaddr_in addr;
  unsigned int cAddr;
  struct _lscp_connect_t *pConnect;
  while(!(pServer->agent.iState == 0))
  {
    cAddr = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    sock=accept(pServer->agent.sock, (struct sockaddr *)&addr, &cAddr);
    if(sock == -1)
    {
      lscp_socket_perror("_lscp_server_thread_proc: accept");
      pServer->agent.iState = 0;
    }

    else
    {
      pConnect=_lscp_connect_create(pServer, sock, &addr, (signed int)cAddr);
      if(!(pConnect == ((struct _lscp_connect_t *)NULL)))
      {
        _lscp_connect_list_append(&pServer->connects, pConnect);
        pServer->pfnCallback(pConnect, (const char *)(void *)0, 0, pServer->pvData);
      }

    }
  }
}

// _lscp_socket_getopt_bool
// file socket.c line 127
static void _lscp_socket_getopt_bool(signed int sock, const char *pszOptName, signed int iOptName)
{
  signed int iSockOpt;
  unsigned int cSockLen = (unsigned int)sizeof(signed int) /*4ul*/ ;
  char szPrefix[33l];
  sprintf(szPrefix, "  %s\t", pszOptName);
  signed int return_value_getsockopt_1;
  return_value_getsockopt_1=getsockopt(sock, 1, iOptName, (void *)(char *)&iSockOpt, &cSockLen);
  if(return_value_getsockopt_1 == -1)
    lscp_socket_perror(szPrefix);

  else
    fprintf(stderr, "%s: %s\n", (const void *)szPrefix, iSockOpt != 0 ? "ON" : "OFF");
}

// _lscp_socket_getopt_int
// file socket.c line 140
static void _lscp_socket_getopt_int(signed int sock, const char *pszOptName, signed int iOptName)
{
  signed int iSockOpt;
  unsigned int cSockLen = (unsigned int)sizeof(signed int) /*4ul*/ ;
  char szPrefix[33l];
  sprintf(szPrefix, "  %s\t", pszOptName);
  signed int return_value_getsockopt_1;
  return_value_getsockopt_1=getsockopt(sock, 1, iOptName, (void *)(char *)&iSockOpt, &cSockLen);
  if(return_value_getsockopt_1 == -1)
    lscp_socket_perror(szPrefix);

  else
    fprintf(stderr, "%s: %d\n", (const void *)szPrefix, iSockOpt);
}

// _lscp_thread_start
// file thread.c line 45
static void * _lscp_thread_start(void *pvThread)
{
  struct _lscp_thread_t *pThread = (struct _lscp_thread_t *)pvThread;
  if(!(pThread == ((struct _lscp_thread_t *)NULL)))
  {
    pThread->pfnProc(pThread->pvData);
    if(!(pThread->iDetach == 0))
      free((void *)pThread);

  }

  return (void *)0;
}

// _restore_locale
// file client.c line 58
static void _restore_locale(struct _locale_t *locale)
{
  setlocale(1, locale->numeric);
  setlocale(0, locale->ctype);
}

// _save_and_set_c_locale
// file client.c line 49
static void _save_and_set_c_locale(struct _locale_t *locale)
{
  char *return_value_setlocale_1;
  return_value_setlocale_1=setlocale(1, (const char *)(void *)0);
  strncpy(locale->numeric, return_value_setlocale_1, (unsigned long int)32);
  char *return_value_setlocale_2;
  return_value_setlocale_2=setlocale(0, (const char *)(void *)0);
  strncpy(locale->ctype, return_value_setlocale_2, (unsigned long int)32);
  setlocale(1, "C");
  setlocale(0, "C");
}

// lscp_add_channel
// file client.c line 969
signed int lscp_add_channel(struct _lscp_client_t *pClient)
{
  signed int iSamplerChannel = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "ADD CHANNEL\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iSamplerChannel=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iSamplerChannel;
  }
}

// lscp_add_midi_instrument_map
// file client.c line 2404
signed int lscp_add_midi_instrument_map(struct _lscp_client_t *pClient, const char *pszMapName)
{
  signed int iMidiMap = -1;
  char szQuery[1024l];
  unsigned long int return_value_strlen_1;
  const char *return_value_lscp_client_get_result_2;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    strcpy(szQuery, "ADD MIDI_INSTRUMENT_MAP");
    if(!(pszMapName == ((const char *)NULL)))
    {
      return_value_strlen_1=strlen(szQuery);
      sprintf(szQuery + (signed long int)return_value_strlen_1, " '%s'", pszMapName);
    }

    strcat(szQuery, "\r\n");
    enum _lscp_status_t return_value_lscp_client_call_3;
    return_value_lscp_client_call_3=lscp_client_call(pClient, szQuery, 0);
    if((signed int)return_value_lscp_client_call_3 == LSCP_OK)
    {
      return_value_lscp_client_get_result_2=lscp_client_get_result(pClient);
      iMidiMap=atoi(return_value_lscp_client_get_result_2);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iMidiMap;
  }
}

// lscp_channel_info_free
// file common.h line 160
void lscp_channel_info_free(struct _lscp_channel_info_t *pChannelInfo)
{
  if(!(pChannelInfo->engine_name == ((char *)NULL)))
    free((void *)pChannelInfo->engine_name);

  if(!(pChannelInfo->audio_routing == ((signed int *)NULL)))
    lscp_isplit_destroy(pChannelInfo->audio_routing);

  if(!(pChannelInfo->instrument_file == ((char *)NULL)))
    free((void *)pChannelInfo->instrument_file);

  if(!(pChannelInfo->instrument_name == ((char *)NULL)))
    free((void *)pChannelInfo->instrument_name);

}

// lscp_channel_info_init
// file common.h line 159
void lscp_channel_info_init(struct _lscp_channel_info_t *pChannelInfo)
{
  pChannelInfo->engine_name = (char *)(void *)0;
  pChannelInfo->audio_device = 0;
  pChannelInfo->audio_channels = 0;
  pChannelInfo->audio_routing = (signed int *)(void *)0;
  pChannelInfo->instrument_file = (char *)(void *)0;
  pChannelInfo->instrument_nr = 0;
  pChannelInfo->instrument_name = (char *)(void *)0;
  pChannelInfo->instrument_status = 0;
  pChannelInfo->midi_device = 0;
  pChannelInfo->midi_port = 0;
  pChannelInfo->midi_channel = 0;
  pChannelInfo->midi_map = 0;
  pChannelInfo->volume = (float)0.0;
  pChannelInfo->mute = 0;
  pChannelInfo->solo = 0;
}

// lscp_channel_info_reset
// file common.h line 161
void lscp_channel_info_reset(struct _lscp_channel_info_t *pChannelInfo)
{
  lscp_channel_info_free(pChannelInfo);
  lscp_channel_info_init(pChannelInfo);
}

// lscp_clear_midi_instruments
// file client.c line 2890
enum _lscp_status_t lscp_clear_midi_instruments(struct _lscp_client_t *pClient, signed int iMidiMap)
{
  char szQuery[1024l];
  strcpy(szQuery, "CLEAR MIDI_INSTRUMENTS ");
  unsigned long int return_value_strlen_1;
  if(!(iMidiMap >= 0))
    strcat(szQuery, "ALL");

  else
  {
    return_value_strlen_1=strlen(szQuery);
    sprintf(szQuery + (signed long int)return_value_strlen_1, "%d", iMidiMap);
  }
  strcat(szQuery, "\r\n");
  enum _lscp_status_t return_value_lscp_client_query_2;
  return_value_lscp_client_query_2=lscp_client_query(pClient, szQuery);
  return return_value_lscp_client_query_2;
}

// lscp_client_build
// file client.c line 262
const char * lscp_client_build(void)
{
  return "Jan 25 2016 01:29:40";
}

// lscp_client_call
// file common.h line 94
enum _lscp_status_t lscp_client_call(struct _lscp_client_t *pClient, const char *pszQuery, signed int iResult)
{
  signed int cchQuery;
  char achBuffer[1024l];
  signed int cchBuffer;
  const char *pszSeps = ":[]";
  char *pszBuffer;
  char *pszToken;
  char *pch;
  signed int iErrno;
  char *pszResult;
  signed int cchResult;
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  signed int return_value_strncasecmp_4;
  signed int return_value_strncasecmp_3;
  _Bool tmp_if_expr_10;
  signed int return_value_strncasecmp_9;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return ret;

  else
  {
    iErrno = -1;
    cchResult = 0;
    pszResult = (char *)(void *)0;
    pszBuffer = (char *)(void *)0;
    if(pClient->cmd.sock == -1)
    {
      pszResult = "Connection closed or no longer valid";
      lscp_client_set_result(pClient, pszResult, iErrno);
      return ret;
    }

    else
      if(pClient->iTimeoutCount >= 1)
      {
        pClient->iTimeoutCount = 0;
        cchBuffer = (signed int)sizeof(char [1024l]) /*1024ul*/ ;
        ret=lscp_client_recv(pClient, achBuffer, &cchBuffer, pClient->iTimeout);
        if((signed int)ret == LSCP_OK)
          goto __CPROVER_DUMP_L3;

        iErrno = (signed int)ret;
        pszResult = "Failure during flush timeout operation";
        lscp_client_set_result(pClient, pszResult, iErrno);
        return ret;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(pszQuery);
        cchQuery = (signed int)return_value_strlen_1;
        signed long int return_value_send_2;
        return_value_send_2=send(pClient->cmd.sock, (const void *)pszQuery, (unsigned long int)cchQuery, 0);
        if(!(return_value_send_2 >= (signed long int)cchQuery))
        {
          lscp_socket_perror("lscp_client_call: send");
          pszResult = "Failure during send operation";
          lscp_client_set_result(pClient, pszResult, iErrno);
          return ret;
        }

        else
        {
          while(pszResult == ((char *)NULL))
          {
            cchBuffer = (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
            ret=lscp_client_recv(pClient, achBuffer, &cchBuffer, pClient->iTimeout);
            switch((signed int)ret)
            {
              case LSCP_OK:
              {
                achBuffer[(signed long int)cchBuffer] = (char)0;
                return_value_strncasecmp_4=strncasecmp(achBuffer, "WRN:", (unsigned long int)4);
                if(return_value_strncasecmp_4 == 0)
                  ret = (enum _lscp_status_t)LSCP_WARNING;

                else
                {
                  return_value_strncasecmp_3=strncasecmp(achBuffer, "ERR:", (unsigned long int)4);
                  if(return_value_strncasecmp_3 == 0)
                    ret = (enum _lscp_status_t)LSCP_ERROR;

                }
                if((signed int)ret == LSCP_OK)
                {
                  iErrno = 0;
                  if(!(iResult >= 1))
                  {
                    return_value_strncasecmp_9=strncasecmp(achBuffer, "OK[", (unsigned long int)3);
                    tmp_if_expr_10 = return_value_strncasecmp_9 == 0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_10 = (_Bool)0;
                  if(tmp_if_expr_10)
                  {
                    pszToken=lscp_strtok(achBuffer, pszSeps, &pch);
                    if(!(pszToken == ((char *)NULL)))
                      pszResult=lscp_strtok((char *)(void *)0, pszSeps, &pch);

                  }

                  else
                  {
                    cchResult = cchResult + (signed int)sizeof(char [1024l]) /*1024ul*/ ;
                    void *return_value_malloc_5;
                    return_value_malloc_5=malloc((unsigned long int)(cchResult + 1));
                    pszResult = (char *)return_value_malloc_5;
                    pszResult[(signed long int)0] = (char)0;
                    if(!(pszBuffer == ((char *)NULL)))
                    {
                      strcat(pszResult, pszBuffer);
                      free((void *)pszBuffer);
                    }

                    strcat(pszResult, achBuffer);
                    pszBuffer = pszResult;
                    pszResult = (char *)(void *)0;
                    unsigned long int return_value_strlen_6;
                    return_value_strlen_6=strlen(pszBuffer);
                    cchBuffer = (signed int)return_value_strlen_6;
                    if(cchBuffer >= 2)
                    {
                      if((signed int)pszBuffer[(signed long int)(cchBuffer + -1)] == 10)
                      {
                        if((signed int)pszBuffer[(signed long int)(cchBuffer + -2)] == 13)
                        {
                          if(!(iResult >= 1))
                            tmp_if_expr_8 = (_Bool)1;

                          else
                          {
                            if(cchBuffer >= 3)
                              tmp_if_expr_7 = (signed int)pszBuffer[(signed long int)(cchBuffer - 3)] == 46 ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr_7 = (_Bool)0;
                            tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr_8)
                          {
                            for( ; cchBuffer >= 1; cchBuffer = cchBuffer - 1)
                              if(!((signed int)pszBuffer[(signed long int)(cchBuffer + -1)] == 13))
                              {
                                if(!((signed int)pszBuffer[(signed long int)(cchBuffer + -1)] == 10))
                                {
                                  if(!((signed int)pszBuffer[(signed long int)(cchBuffer + -1)] == 46))
                                    break;

                                }

                              }

                            pszBuffer[(signed long int)cchBuffer] = (char)0;
                            pszResult = pszBuffer;
                          }

                        }

                      }

                    }

                  }
                }

                else
                {
                  for( ; cchBuffer >= 1; achBuffer[(signed long int)cchBuffer] = (char)0)
                  {
                    if(!((signed int)achBuffer[(signed long int)(cchBuffer + -1)] == 13))
                    {
                      if(!((signed int)achBuffer[(signed long int)(cchBuffer + -1)] == 10))
                        break;

                    }

                    cchBuffer = cchBuffer - 1;
                  }
                  pszToken=lscp_strtok(achBuffer, pszSeps, &pch);
                  if(!(pszToken == ((char *)NULL)))
                  {
                    pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
                    if(!(pszToken == ((char *)NULL)))
                    {
                      signed int return_value_atoi_11;
                      return_value_atoi_11=atoi(pszToken);
                      iErrno = return_value_atoi_11 + 100;
                      pszResult=lscp_strtok((char *)(void *)0, pszSeps, &pch);
                    }

                  }

                }
                break;
              }
              case LSCP_TIMEOUT:
              {
                pClient->iTimeoutCount = pClient->iTimeoutCount + 1;
                pszResult = "Timeout during receive operation";
                iErrno = (signed int)ret;
                break;
              }
              case LSCP_QUIT:
              {
                pszResult = "Server terminated the connection";
                iErrno = (signed int)ret;
                break;
              }
              case LSCP_FAILED:

              default:
                pszResult = "Failure during receive operation";
            }
          }
          lscp_client_set_result(pClient, pszResult, iErrno);
          if(!(pszBuffer == ((char *)NULL)))
            free((void *)pszBuffer);

          return ret;
        }
      }
  }
}

// lscp_client_create
// file client.c line 282
struct _lscp_client_t * lscp_client_create(const char *pszHost, signed int iPort, enum _lscp_status_t (*pfnCallback)(struct _lscp_client_t *, enum _lscp_event_t, const char *, signed int, void *), void *pvData)
{
  struct _lscp_client_t *pClient;
  struct hostent *pHost;
  signed int sock;
  struct sockaddr_in addr;
  signed int cAddr;
  if(pfnCallback == ((enum _lscp_status_t (*)(struct _lscp_client_t *, enum _lscp_event_t, const char *, signed int, void *))NULL))
  {
    fprintf(stderr, "lscp_client_create: Invalid client callback function.\n");
    return (struct _lscp_client_t *)(void *)0;
  }

  else
  {
    pHost=gethostbyname(pszHost);
    if(pHost == ((struct hostent *)NULL))
    {
      lscp_socket_herror("lscp_client_create: gethostbyname");
      return (struct _lscp_client_t *)(void *)0;
    }

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct _lscp_client_t) /*912ul*/ );
      pClient = (struct _lscp_client_t *)return_value_malloc_1;
      if(pClient == ((struct _lscp_client_t *)NULL))
      {
        fprintf(stderr, "lscp_client_create: Out of memory.\n");
        return (struct _lscp_client_t *)(void *)0;
      }

      else
      {
        memset((void *)pClient, 0, sizeof(struct _lscp_client_t) /*912ul*/ );
        pClient->pfnCallback = pfnCallback;
        pClient->pvData = pvData;
        sock=socket(2, 1, 0);
        if(sock == -1)
        {
          lscp_socket_perror("lscp_client_create: cmd: socket");
          free((void *)pClient);
          return (struct _lscp_client_t *)(void *)0;
        }

        else
        {
          cAddr = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
          memset((void *)(char *)&addr, 0, (unsigned long int)cAddr);
          addr.sin_family = (unsigned short int)pHost->h_addrtype;
          memmove((void *)(char *)&addr.sin_addr, (const void *)pHost->h_addr_list[(signed long int)0], (unsigned long int)pHost->h_length);
          addr.sin_port=htons((unsigned short int)(signed short int)iPort);
          signed int return_value_connect_2;
          return_value_connect_2=connect(sock, (struct sockaddr *)&addr, (unsigned int)cAddr);
          if(return_value_connect_2 == -1)
          {
            lscp_socket_perror("lscp_client_create: cmd: connect");
            close(sock);
            free((void *)pClient);
            return (struct _lscp_client_t *)(void *)0;
          }

          else
          {
            lscp_socket_agent_init(&pClient->cmd, sock, &addr, cAddr);
            lscp_socket_agent_init(&pClient->evt, -1, (struct sockaddr_in *)(void *)0, 0);
            pClient->events = (enum _lscp_event_t)LSCP_EVENT_NONE;
            pClient->audio_drivers = (char **)(void *)0;
            pClient->midi_drivers = (char **)(void *)0;
            pClient->audio_devices = (signed int *)(void *)0;
            pClient->midi_devices = (signed int *)(void *)0;
            pClient->engines = (char **)(void *)0;
            pClient->channels = (signed int *)(void *)0;
            pClient->fxsends = (signed int *)(void *)0;
            pClient->midi_instruments = (struct _lscp_midi_instrument_t *)(void *)0;
            pClient->midi_maps = (signed int *)(void *)0;
            pClient->midi_map_name = (char *)(void *)0;
            lscp_driver_info_init(&pClient->audio_driver_info);
            lscp_driver_info_init(&pClient->midi_driver_info);
            lscp_device_info_init(&pClient->audio_device_info);
            lscp_device_info_init(&pClient->midi_device_info);
            lscp_param_info_init(&pClient->audio_param_info);
            lscp_param_info_init(&pClient->midi_param_info);
            lscp_device_port_info_init(&pClient->audio_channel_info);
            lscp_device_port_info_init(&pClient->midi_port_info);
            lscp_param_info_init(&pClient->audio_channel_param_info);
            lscp_param_info_init(&pClient->midi_port_param_info);
            lscp_server_info_init(&pClient->server_info);
            lscp_engine_info_init(&pClient->engine_info);
            lscp_channel_info_init(&pClient->channel_info);
            lscp_fxsend_info_init(&pClient->fxsend_info);
            lscp_midi_instrument_info_init(&pClient->midi_instrument_info);
            pClient->pszResult = (char *)(void *)0;
            pClient->iErrno = -1;
            pClient->buffer_fill = (struct _lscp_buffer_fill_t *)(void *)0;
            pClient->iStreamCount = 0;
            pClient->iTimeout = 500;
            pClient->iTimeoutCount = 0;
            pthread_mutex_init(&pClient->mutex, (const union anonymous_1 *)(void *)0);
            pthread_cond_init(&pClient->cond, (const union anonymous_1 *)(void *)0);
            return pClient;
          }
        }
      }
    }
  }
}

// lscp_client_destroy
// file client.c line 435
enum _lscp_status_t lscp_client_destroy(struct _lscp_client_t *pClient)
{
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    lscp_midi_instrument_info_free(&pClient->midi_instrument_info);
    lscp_fxsend_info_free(&pClient->fxsend_info);
    lscp_channel_info_free(&pClient->channel_info);
    lscp_engine_info_free(&pClient->engine_info);
    lscp_server_info_free(&pClient->server_info);
    lscp_param_info_free(&pClient->midi_port_param_info);
    lscp_param_info_free(&pClient->audio_channel_param_info);
    lscp_device_port_info_free(&pClient->midi_port_info);
    lscp_device_port_info_free(&pClient->audio_channel_info);
    lscp_param_info_free(&pClient->midi_param_info);
    lscp_param_info_free(&pClient->audio_param_info);
    lscp_device_info_free(&pClient->midi_device_info);
    lscp_device_info_free(&pClient->audio_device_info);
    lscp_driver_info_free(&pClient->midi_driver_info);
    lscp_driver_info_free(&pClient->audio_driver_info);
    lscp_szsplit_destroy(pClient->audio_drivers);
    lscp_szsplit_destroy(pClient->midi_drivers);
    lscp_isplit_destroy(pClient->audio_devices);
    lscp_isplit_destroy(pClient->midi_devices);
    lscp_szsplit_destroy(pClient->engines);
    lscp_isplit_destroy(pClient->channels);
    lscp_isplit_destroy(pClient->fxsends);
    lscp_midi_instruments_destroy(pClient->midi_instruments);
    lscp_isplit_destroy(pClient->midi_maps);
    if(!(pClient->midi_map_name == ((char *)NULL)))
      free((void *)pClient->midi_map_name);

    pClient->audio_drivers = (char **)(void *)0;
    pClient->midi_drivers = (char **)(void *)0;
    pClient->audio_devices = (signed int *)(void *)0;
    pClient->midi_devices = (signed int *)(void *)0;
    pClient->engines = (char **)(void *)0;
    pClient->channels = (signed int *)(void *)0;
    pClient->fxsends = (signed int *)(void *)0;
    pClient->midi_instruments = (struct _lscp_midi_instrument_t *)(void *)0;
    pClient->midi_maps = (signed int *)(void *)0;
    pClient->midi_map_name = (char *)(void *)0;
    lscp_client_set_result(pClient, (char *)(void *)0, 0);
    if(!(pClient->buffer_fill == ((struct _lscp_buffer_fill_t *)NULL)))
      free((void *)pClient->buffer_fill);

    pClient->buffer_fill = (struct _lscp_buffer_fill_t *)(void *)0;
    pClient->iStreamCount = 0;
    pClient->iTimeout = 0;
    lscp_socket_agent_free(&pClient->evt);
    lscp_socket_agent_free(&pClient->cmd);
    pthread_mutex_unlock(&pClient->mutex);
    pthread_mutex_destroy(&pClient->mutex);
    pthread_cond_destroy(&pClient->cond);
    free((void *)pClient);
    return (enum _lscp_status_t)LSCP_OK;
  }
}

// lscp_client_get_errno
// file client.c line 607
signed int lscp_client_get_errno(struct _lscp_client_t *pClient)
{
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
    return pClient->iErrno;
}

// lscp_client_get_events
// file client.c line 817
enum _lscp_event_t lscp_client_get_events(struct _lscp_client_t *pClient)
{
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_event_t)LSCP_EVENT_NONE;

  else
    return pClient->events;
}

// lscp_client_get_result
// file client.c line 590
const char * lscp_client_get_result(struct _lscp_client_t *pClient)
{
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (const char *)(void *)0;

  else
    return pClient->pszResult;
}

// lscp_client_get_timeout
// file client.c line 537
signed int lscp_client_get_timeout(struct _lscp_client_t *pClient)
{
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
    return pClient->iTimeout;
}

// lscp_client_join
// file client.c line 412
enum _lscp_status_t lscp_client_join(struct _lscp_client_t *pClient)
{
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    lscp_socket_agent_join(&pClient->cmd);
    return (enum _lscp_status_t)LSCP_OK;
  }
}

// lscp_client_package
// file client.c line 256
const char * lscp_client_package(void)
{
  return "liblscp";
}

// lscp_client_query
// file client.c line 562
enum _lscp_status_t lscp_client_query(struct _lscp_client_t *pClient, const char *pszQuery)
{
  enum _lscp_status_t ret;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    ret=lscp_client_call(pClient, pszQuery, 0);
    pthread_mutex_unlock(&pClient->mutex);
    return ret;
  }
}

// lscp_client_recv
// file common.c line 54
enum _lscp_status_t lscp_client_recv(struct _lscp_client_t *pClient, char *pchBuffer, signed int *pcchBuffer, signed int iTimeout)
{
  struct anonymous_3 fds;
  signed int fd;
  signed int fdmax;
  struct timeval tv;
  signed int iSelect;
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  _Bool tmp_if_expr_2;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return ret;

  else
  {
    fd = (signed int)pClient->cmd.sock;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&fds)->__fds_bits[(signed long int)((unsigned int)fd / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)((unsigned int)fd / (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << (unsigned int)fd % (unsigned int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    fdmax = fd;
    if(!(iTimeout >= 1))
      iTimeout = pClient->iTimeout;

    if(iTimeout >= 1000)
    {
      tv.tv_sec = (signed long int)(iTimeout / 1000);
      iTimeout = iTimeout - (signed int)(tv.tv_sec * (signed long int)1000);
    }

    else
      tv.tv_sec = (signed long int)0;
    tv.tv_usec = (signed long int)(iTimeout * 1000);
    iSelect=select(fdmax + 1, &fds, (struct anonymous_3 *)(void *)0, (struct anonymous_3 *)(void *)0, &tv);
    if(iSelect >= 1)
      tmp_if_expr_2 = ((&fds)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      signed long int return_value_recv_1;
      return_value_recv_1=recv(pClient->cmd.sock, (void *)pchBuffer, (unsigned long int)*pcchBuffer, 0);
      *pcchBuffer = (signed int)return_value_recv_1;
      if(*pcchBuffer >= 1)
        ret = (enum _lscp_status_t)LSCP_OK;

      else
        if(!(*pcchBuffer >= 0))
          lscp_socket_perror("lscp_client_recv: recv");

        else
          if(*pcchBuffer == 0)
          {
            lscp_socket_agent_free(&pClient->evt);
            lscp_socket_agent_free(&pClient->cmd);
            ret = (enum _lscp_status_t)LSCP_QUIT;
          }

    }

    else
      if(iSelect == 0)
        ret = (enum _lscp_status_t)LSCP_TIMEOUT;

      else
        lscp_socket_perror("lscp_client_recv: select");
    return ret;
  }
}

// lscp_client_set_result
// file common.h line 95
void lscp_client_set_result(struct _lscp_client_t *pClient, char *pszResult, signed int iErrno)
{
  if(!(pClient->pszResult == ((char *)NULL)))
    free((void *)pClient->pszResult);

  pClient->pszResult = (char *)(void *)0;
  pClient->iErrno = iErrno;
  char *return_value_lscp_ltrim_1;
  if(!(pszResult == ((char *)NULL)))
  {
    return_value_lscp_ltrim_1=lscp_ltrim(pszResult);
    pClient->pszResult=strdup(return_value_lscp_ltrim_1);
  }

}

// lscp_client_set_timeout
// file client.c line 518
enum _lscp_status_t lscp_client_set_timeout(struct _lscp_client_t *pClient, signed int iTimeout)
{
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
    if(!(iTimeout >= 0))
      return (enum _lscp_status_t)LSCP_FAILED;

    else
    {
      pClient->iTimeout = iTimeout;
      return (enum _lscp_status_t)LSCP_OK;
    }
}

// lscp_client_subscribe
// file client.c line 647
enum _lscp_status_t lscp_client_subscribe(struct _lscp_client_t *pClient, enum _lscp_event_t events)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_OK;
  enum _lscp_event_t currentEvent;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if((signed int)pClient->events == LSCP_EVENT_NONE)
      ret=_lscp_client_evt_connect(pClient);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_CHANNEL_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_CHANNEL_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_VOICE_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_VOICE_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_STREAM_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_STREAM_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_BUFFER_FILL & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_BUFFER_FILL);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_CHANNEL_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_CHANNEL_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_TOTAL_VOICE_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_TOTAL_VOICE_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_AUDIO_OUTPUT_DEVICE_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_AUDIO_OUTPUT_DEVICE_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_AUDIO_OUTPUT_DEVICE_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_AUDIO_OUTPUT_DEVICE_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INPUT_DEVICE_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_MIDI_INPUT_DEVICE_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INPUT_DEVICE_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_MIDI_INPUT_DEVICE_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INSTRUMENT_MAP_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_MAP_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INSTRUMENT_MAP_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_MAP_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INSTRUMENT_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INSTRUMENT_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MISCELLANEOUS & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 1, (enum _lscp_event_t)LSCP_EVENT_MISCELLANEOUS);

    currentEvent = (enum _lscp_event_t)((unsigned int)events & 0xffff0000);
    if((signed int)ret == LSCP_OK && !(currentEvent == /*enum*/LSCP_EVENT_NONE))
    {
      if((signed int)currentEvent == LSCP_EVENT_CHANNEL_MIDI || (signed int)currentEvent == LSCP_EVENT_DEVICE_MIDI)
      {
        ret=_lscp_client_evt_request(pClient, 1, currentEvent);
        goto __CPROVER_DUMP_L20;
      }

      ret = (enum _lscp_status_t)LSCP_FAILED;
    }


  __CPROVER_DUMP_L20:
    ;
    pthread_mutex_unlock(&pClient->mutex);
    return ret;
  }
}

// lscp_client_unsubscribe
// file client.c line 743
enum _lscp_status_t lscp_client_unsubscribe(struct _lscp_client_t *pClient, enum _lscp_event_t events)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_OK;
  enum _lscp_event_t currentEvent;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_CHANNEL_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_CHANNEL_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_VOICE_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_VOICE_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_STREAM_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_STREAM_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_BUFFER_FILL & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_BUFFER_FILL);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_CHANNEL_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_CHANNEL_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_TOTAL_VOICE_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_TOTAL_VOICE_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_AUDIO_OUTPUT_DEVICE_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_AUDIO_OUTPUT_DEVICE_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_AUDIO_OUTPUT_DEVICE_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_AUDIO_OUTPUT_DEVICE_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INPUT_DEVICE_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_MIDI_INPUT_DEVICE_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INPUT_DEVICE_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_MIDI_INPUT_DEVICE_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INSTRUMENT_MAP_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_MAP_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INSTRUMENT_MAP_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_MAP_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INSTRUMENT_COUNT & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_COUNT);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MIDI_INSTRUMENT_INFO & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_INFO);

    if((signed int)ret == LSCP_OK && !((LSCP_EVENT_MISCELLANEOUS & (signed int)events) == 0))
      ret=_lscp_client_evt_request(pClient, 0, (enum _lscp_event_t)LSCP_EVENT_MISCELLANEOUS);

    currentEvent = (enum _lscp_event_t)((unsigned int)events & 0xffff0000);
    if((signed int)ret == LSCP_OK && !(currentEvent == /*enum*/LSCP_EVENT_NONE))
    {
      if((signed int)currentEvent == LSCP_EVENT_CHANNEL_MIDI || (signed int)currentEvent == LSCP_EVENT_DEVICE_MIDI)
      {
        ret=_lscp_client_evt_request(pClient, 0, currentEvent);
        goto __CPROVER_DUMP_L19;
      }

      ret = (enum _lscp_status_t)LSCP_FAILED;
    }


  __CPROVER_DUMP_L19:
    ;
    if((signed int)pClient->events == LSCP_EVENT_NONE)
      lscp_socket_agent_free(&pClient->evt);

    pthread_mutex_unlock(&pClient->mutex);
    return ret;
  }
}

// lscp_client_version
// file client.c line 259
const char * lscp_client_version(void)
{
  return "0.5.6";
}

// lscp_create_audio_device
// file device.c line 396
signed int lscp_create_audio_device(struct _lscp_client_t *pClient, const char *pszAudioDriver, struct _lscp_param_t *pParams)
{
  char szQuery[1024l];
  signed int iAudioDevice = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
    if(pszAudioDriver == ((const char *)NULL))
      return -1;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      sprintf(szQuery, "CREATE AUDIO_OUTPUT_DEVICE %s", pszAudioDriver);
      lscp_param_concat(szQuery, (signed int)sizeof(char [1024l]) /*1024ul*/ , pParams);
      enum _lscp_status_t return_value_lscp_client_call_2;
      return_value_lscp_client_call_2=lscp_client_call(pClient, szQuery, 0);
      if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
      {
        return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
        iAudioDevice=atoi(return_value_lscp_client_get_result_1);
      }

      pthread_mutex_unlock(&pClient->mutex);
      return iAudioDevice;
    }
}

// lscp_create_fxsend
// file client.c line 2092
signed int lscp_create_fxsend(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiController, const char *pszFxName)
{
  signed int iFxSend = -1;
  char szQuery[1024l];
  unsigned long int return_value_strlen_1;
  const char *return_value_lscp_client_get_result_2;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
    if(iMidiController >= 128 || !(iMidiController >= 0) || !(iSamplerChannel >= 0))
      return -1;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      sprintf(szQuery, "CREATE FX_SEND %d %d", iSamplerChannel, iMidiController);
      if(!(pszFxName == ((const char *)NULL)))
      {
        return_value_strlen_1=strlen(szQuery);
        sprintf(szQuery + (signed long int)return_value_strlen_1, " '%s'", pszFxName);
      }

      strcat(szQuery, "\r\n");
      enum _lscp_status_t return_value_lscp_client_call_3;
      return_value_lscp_client_call_3=lscp_client_call(pClient, szQuery, 0);
      if((signed int)return_value_lscp_client_call_3 == LSCP_OK)
      {
        return_value_lscp_client_get_result_2=lscp_client_get_result(pClient);
        iFxSend=atoi(return_value_lscp_client_get_result_2);
      }

      pthread_mutex_unlock(&pClient->mutex);
      return iFxSend;
    }
}

// lscp_create_midi_device
// file device.c line 776
signed int lscp_create_midi_device(struct _lscp_client_t *pClient, const char *pszMidiDriver, struct _lscp_param_t *pParams)
{
  char szQuery[1024l];
  signed int iMidiDevice = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
    if(pszMidiDriver == ((const char *)NULL))
      return -1;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      sprintf(szQuery, "CREATE MIDI_INPUT_DEVICE %s", pszMidiDriver);
      lscp_param_concat(szQuery, (signed int)sizeof(char [1024l]) /*1024ul*/ , pParams);
      enum _lscp_status_t return_value_lscp_client_call_2;
      return_value_lscp_client_call_2=lscp_client_call(pClient, szQuery, 0);
      if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
      {
        return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
        iMidiDevice=atoi(return_value_lscp_client_get_result_1);
      }

      pthread_mutex_unlock(&pClient->mutex);
      return iMidiDevice;
    }
}

// lscp_destroy_audio_device
// file device.c line 430
enum _lscp_status_t lscp_destroy_audio_device(struct _lscp_client_t *pClient, signed int iAudioDevice)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return ret;

  else
    if(!(iAudioDevice >= 0))
      return ret;

    else
    {
      sprintf(szQuery, "DESTROY AUDIO_OUTPUT_DEVICE %d\r\n", iAudioDevice);
      enum _lscp_status_t return_value_lscp_client_query_1;
      return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
      return return_value_lscp_client_query_1;
    }
}

// lscp_destroy_fxsend
// file client.c line 2132
enum _lscp_status_t lscp_destroy_fxsend(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend)
{
  char szQuery[1024l];
  if(!(iFxSend >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "DESTROY FX_SEND %d %d\r\n", iSamplerChannel, iFxSend);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_destroy_midi_device
// file device.c line 810
enum _lscp_status_t lscp_destroy_midi_device(struct _lscp_client_t *pClient, signed int iMidiDevice)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return ret;

  else
    if(!(iMidiDevice >= 0))
      return ret;

    else
    {
      sprintf(szQuery, "DESTROY MIDI_INPUT_DEVICE %d\r\n", iMidiDevice);
      enum _lscp_status_t return_value_lscp_client_query_1;
      return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
      return return_value_lscp_client_query_1;
    }
}

// lscp_device_info_free
// file common.h line 174
void lscp_device_info_free(struct _lscp_device_info_t *pDeviceInfo)
{
  if(!(pDeviceInfo->driver == ((char *)NULL)))
    free((void *)pDeviceInfo->driver);

  lscp_plist_free(&pDeviceInfo->params);
}

// lscp_device_info_init
// file common.h line 173
void lscp_device_info_init(struct _lscp_device_info_t *pDeviceInfo)
{
  pDeviceInfo->driver = (char *)(void *)0;
  lscp_plist_alloc(&pDeviceInfo->params);
}

// lscp_device_info_reset
// file common.h line 175
void lscp_device_info_reset(struct _lscp_device_info_t *pDeviceInfo)
{
  lscp_device_info_free(pDeviceInfo);
  lscp_device_info_init(pDeviceInfo);
}

// lscp_device_port_info_free
// file common.h line 181
void lscp_device_port_info_free(struct _lscp_device_port_info_t *pDevicePortInfo)
{
  if(!(pDevicePortInfo->name == ((char *)NULL)))
    free((void *)pDevicePortInfo->name);

  lscp_plist_free(&pDevicePortInfo->params);
}

// lscp_device_port_info_init
// file common.h line 180
void lscp_device_port_info_init(struct _lscp_device_port_info_t *pDevicePortInfo)
{
  pDevicePortInfo->name = (char *)(void *)0;
  lscp_plist_alloc(&pDevicePortInfo->params);
}

// lscp_device_port_info_reset
// file common.h line 182
void lscp_device_port_info_reset(struct _lscp_device_port_info_t *pDevicePortInfo)
{
  lscp_device_port_info_free(pDevicePortInfo);
  lscp_device_port_info_init(pDevicePortInfo);
}

// lscp_driver_info_free
// file common.h line 167
void lscp_driver_info_free(struct _lscp_driver_info_t *pDriverInfo)
{
  if(!(pDriverInfo->description == ((char *)NULL)))
    free((void *)pDriverInfo->description);

  if(!(pDriverInfo->version == ((char *)NULL)))
    free((void *)pDriverInfo->version);

  lscp_szsplit_destroy(pDriverInfo->parameters);
}

// lscp_driver_info_init
// file common.h line 166
void lscp_driver_info_init(struct _lscp_driver_info_t *pDriverInfo)
{
  pDriverInfo->description = (char *)(void *)0;
  pDriverInfo->version = (char *)(void *)0;
  pDriverInfo->parameters = (char **)(void *)0;
}

// lscp_driver_info_reset
// file common.h line 168
void lscp_driver_info_reset(struct _lscp_driver_info_t *pDriverInfo)
{
  lscp_driver_info_free(pDriverInfo);
  lscp_driver_info_init(pDriverInfo);
}

// lscp_edit_channel_instrument
// file client.c line 2916
enum _lscp_status_t lscp_edit_channel_instrument(struct _lscp_client_t *pClient, signed int iSamplerChannel)
{
  char szQuery[1024l];
  if(!(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "EDIT CHANNEL INSTRUMENT %d\r\n", iSamplerChannel);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_engine_info_free
// file common.h line 153
void lscp_engine_info_free(struct _lscp_engine_info_t *pEngineInfo)
{
  if(!(pEngineInfo->description == ((char *)NULL)))
    free((void *)pEngineInfo->description);

  if(!(pEngineInfo->version == ((char *)NULL)))
    free((void *)pEngineInfo->version);

}

// lscp_engine_info_init
// file common.h line 152
void lscp_engine_info_init(struct _lscp_engine_info_t *pEngineInfo)
{
  pEngineInfo->description = (char *)(void *)0;
  pEngineInfo->version = (char *)(void *)0;
}

// lscp_engine_info_reset
// file common.h line 154
void lscp_engine_info_reset(struct _lscp_engine_info_t *pEngineInfo)
{
  lscp_engine_info_free(pEngineInfo);
  lscp_engine_info_init(pEngineInfo);
}

// lscp_event_from_text
// file ../lscp/event.h line 63
enum _lscp_event_t lscp_event_from_text(const char *pszText)
{
  enum _lscp_event_t event = (enum _lscp_event_t)LSCP_EVENT_NONE;
  signed int return_value_strcasecmp_16;
  signed int return_value_strcasecmp_15;
  signed int return_value_strcasecmp_14;
  signed int return_value_strcasecmp_13;
  signed int return_value_strcasecmp_12;
  signed int return_value_strcasecmp_11;
  signed int return_value_strcasecmp_10;
  signed int return_value_strcasecmp_9;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if(!(pszText == ((const char *)NULL)))
  {
    signed int return_value_strcasecmp_17;
    return_value_strcasecmp_17=strcasecmp(pszText, "CHANNEL_COUNT");
    if(return_value_strcasecmp_17 == 0)
      event = (enum _lscp_event_t)LSCP_EVENT_CHANNEL_COUNT;

    else
    {
      return_value_strcasecmp_16=strcasecmp(pszText, "VOICE_COUNT");
      if(return_value_strcasecmp_16 == 0)
        event = (enum _lscp_event_t)LSCP_EVENT_VOICE_COUNT;

      else
      {
        return_value_strcasecmp_15=strcasecmp(pszText, "STREAM_COUNT");
        if(return_value_strcasecmp_15 == 0)
          event = (enum _lscp_event_t)LSCP_EVENT_STREAM_COUNT;

        else
        {
          return_value_strcasecmp_14=strcasecmp(pszText, "BUFFER_FILL");
          if(return_value_strcasecmp_14 == 0)
            event = (enum _lscp_event_t)LSCP_EVENT_BUFFER_FILL;

          else
          {
            return_value_strcasecmp_13=strcasecmp(pszText, "CHANNEL_INFO");
            if(return_value_strcasecmp_13 == 0)
              event = (enum _lscp_event_t)LSCP_EVENT_CHANNEL_INFO;

            else
            {
              return_value_strcasecmp_12=strcasecmp(pszText, "TOTAL_VOICE_COUNT");
              if(return_value_strcasecmp_12 == 0)
                event = (enum _lscp_event_t)LSCP_EVENT_TOTAL_VOICE_COUNT;

              else
              {
                return_value_strcasecmp_11=strcasecmp(pszText, "AUDIO_OUTPUT_DEVICE_COUNT");
                if(return_value_strcasecmp_11 == 0)
                  event = (enum _lscp_event_t)LSCP_EVENT_AUDIO_OUTPUT_DEVICE_COUNT;

                else
                {
                  return_value_strcasecmp_10=strcasecmp(pszText, "AUDIO_OUTPUT_DEVICE_INFO");
                  if(return_value_strcasecmp_10 == 0)
                    event = (enum _lscp_event_t)LSCP_EVENT_AUDIO_OUTPUT_DEVICE_INFO;

                  else
                  {
                    return_value_strcasecmp_9=strcasecmp(pszText, "MIDI_INPUT_DEVICE_COUNT");
                    if(return_value_strcasecmp_9 == 0)
                      event = (enum _lscp_event_t)LSCP_EVENT_MIDI_INPUT_DEVICE_COUNT;

                    else
                    {
                      return_value_strcasecmp_8=strcasecmp(pszText, "MIDI_INPUT_DEVICE_INFO");
                      if(return_value_strcasecmp_8 == 0)
                        event = (enum _lscp_event_t)LSCP_EVENT_MIDI_INPUT_DEVICE_INFO;

                      else
                      {
                        return_value_strcasecmp_7=strcasecmp(pszText, "MIDI_INSTRUMENT_MAP_COUNT");
                        if(return_value_strcasecmp_7 == 0)
                          event = (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_MAP_COUNT;

                        else
                        {
                          return_value_strcasecmp_6=strcasecmp(pszText, "MIDI_INSTRUMENT_MAP_INFO");
                          if(return_value_strcasecmp_6 == 0)
                            event = (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_MAP_INFO;

                          else
                          {
                            return_value_strcasecmp_5=strcasecmp(pszText, "MIDI_INSTRUMENT_COUNT");
                            if(return_value_strcasecmp_5 == 0)
                              event = (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_COUNT;

                            else
                            {
                              return_value_strcasecmp_4=strcasecmp(pszText, "MIDI_INSTRUMENT_INFO");
                              if(return_value_strcasecmp_4 == 0)
                                event = (enum _lscp_event_t)LSCP_EVENT_MIDI_INSTRUMENT_INFO;

                              else
                              {
                                return_value_strcasecmp_3=strcasecmp(pszText, "MISCELLANEOUS");
                                if(return_value_strcasecmp_3 == 0)
                                  event = (enum _lscp_event_t)LSCP_EVENT_MISCELLANEOUS;

                                else
                                {
                                  return_value_strcasecmp_2=strcasecmp(pszText, "CHANNEL_MIDI");
                                  if(return_value_strcasecmp_2 == 0)
                                    event = (enum _lscp_event_t)LSCP_EVENT_CHANNEL_MIDI;

                                  else
                                  {
                                    return_value_strcasecmp_1=strcasecmp(pszText, "DEVICE_MIDI");
                                    if(return_value_strcasecmp_1 == 0)
                                      event = (enum _lscp_event_t)LSCP_EVENT_DEVICE_MIDI;

                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return event;
}

// lscp_event_to_text
// file ../lscp/event.h line 62
const char * lscp_event_to_text(enum _lscp_event_t event)
{
  const char *pszText = (const char *)(void *)0;
  switch((signed int)event)
  {
    case LSCP_EVENT_CHANNEL_COUNT:
    {
      pszText = "CHANNEL_COUNT";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_VOICE_COUNT:
    {
      pszText = "VOICE_COUNT";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_STREAM_COUNT:
    {
      pszText = "STREAM_COUNT";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_BUFFER_FILL:
    {
      pszText = "BUFFER_FILL";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_CHANNEL_INFO:
    {
      pszText = "CHANNEL_INFO";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_TOTAL_VOICE_COUNT:
    {
      pszText = "TOTAL_VOICE_COUNT";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_AUDIO_OUTPUT_DEVICE_COUNT:
    {
      pszText = "AUDIO_OUTPUT_DEVICE_COUNT";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_AUDIO_OUTPUT_DEVICE_INFO:
    {
      pszText = "AUDIO_OUTPUT_DEVICE_INFO";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_MIDI_INPUT_DEVICE_COUNT:
    {
      pszText = "MIDI_INPUT_DEVICE_COUNT";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_MIDI_INPUT_DEVICE_INFO:
    {
      pszText = "MIDI_INPUT_DEVICE_INFO";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_MIDI_INSTRUMENT_MAP_COUNT:
    {
      pszText = "MIDI_INSTRUMENT_MAP_COUNT";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_MIDI_INSTRUMENT_MAP_INFO:
    {
      pszText = "MIDI_INSTRUMENT_MAP_INFO";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_MIDI_INSTRUMENT_COUNT:
    {
      pszText = "MIDI_INSTRUMENT_COUNT";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_MIDI_INSTRUMENT_INFO:
    {
      pszText = "MIDI_INSTRUMENT_INFO";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_MISCELLANEOUS:
    {
      pszText = "MISCELLANEOUS";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_CHANNEL_MIDI:
    {
      pszText = "CHANNEL_MIDI";
      goto __CPROVER_DUMP_L18;
    }
    case LSCP_EVENT_DEVICE_MIDI:
      pszText = "DEVICE_MIDI";
    case LSCP_EVENT_NONE:

    default:
    {

    __CPROVER_DUMP_L18:
      ;
      return pszText;
    }
  }
}

// lscp_fxsend_info_free
// file common.h line 200
void lscp_fxsend_info_free(struct _lscp_fxsend_info_t *pFxSendInfo)
{
  if(!(pFxSendInfo->name == ((char *)NULL)))
    free((void *)pFxSendInfo->name);

  if(!(pFxSendInfo->audio_routing == ((signed int *)NULL)))
    lscp_isplit_destroy(pFxSendInfo->audio_routing);

}

// lscp_fxsend_info_init
// file common.h line 199
void lscp_fxsend_info_init(struct _lscp_fxsend_info_t *pFxSendInfo)
{
  pFxSendInfo->name = (char *)(void *)0;
  pFxSendInfo->midi_controller = 0;
  pFxSendInfo->audio_routing = (signed int *)(void *)0;
  pFxSendInfo->level = 0.0f;
}

// lscp_fxsend_info_reset
// file common.h line 201
void lscp_fxsend_info_reset(struct _lscp_fxsend_info_t *pFxSendInfo)
{
  lscp_fxsend_info_free(pFxSendInfo);
  lscp_fxsend_info_init(pFxSendInfo);
}

// lscp_get_audio_channel_info
// file device.c line 569
struct _lscp_device_port_info_t * lscp_get_audio_channel_info(struct _lscp_client_t *pClient, signed int iAudioDevice, signed int iAudioChannel)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_device_port_info_t *)(void *)0;

  else
    if(!(iAudioDevice >= 0))
      return (struct _lscp_device_port_info_t *)(void *)0;

    else
      if(!(iAudioChannel >= 0))
        return (struct _lscp_device_port_info_t *)(void *)0;

      else
      {
        sprintf(szQuery, "GET AUDIO_OUTPUT_CHANNEL INFO %d %d\r\n", iAudioDevice, iAudioChannel);
        struct _lscp_device_port_info_t *return_value__lscp_device_port_info_query_1;
        return_value__lscp_device_port_info_query_1=_lscp_device_port_info_query(pClient, &pClient->audio_channel_info, szQuery);
        return return_value__lscp_device_port_info_query_1;
      }
}

// lscp_get_audio_channel_param_info
// file device.c line 597
struct _lscp_param_info_t * lscp_get_audio_channel_param_info(struct _lscp_client_t *pClient, signed int iAudioDevice, signed int iAudioChannel, const char *pszParam)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_param_info_t *)(void *)0;

  else
    if(!(iAudioDevice >= 0))
      return (struct _lscp_param_info_t *)(void *)0;

    else
      if(!(iAudioChannel >= 0))
        return (struct _lscp_param_info_t *)(void *)0;

      else
        if(pszParam == ((const char *)NULL))
          return (struct _lscp_param_info_t *)(void *)0;

        else
        {
          sprintf(szQuery, "GET AUDIO_OUTPUT_CHANNEL_PARAMETER INFO %d %d %s", iAudioDevice, iAudioChannel, pszParam);
          struct _lscp_param_info_t *return_value__lscp_param_info_query_1;
          return_value__lscp_param_info_query_1=_lscp_param_info_query(pClient, &pClient->audio_channel_param_info, szQuery, (signed int)sizeof(char [1024l]) /*1024ul*/ , (struct _lscp_param_t *)(void *)0);
          return return_value__lscp_param_info_query_1;
        }
}

// lscp_get_audio_device_info
// file device.c line 518
struct _lscp_device_info_t * lscp_get_audio_device_info(struct _lscp_client_t *pClient, signed int iAudioDevice)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_device_info_t *)(void *)0;

  else
    if(!(iAudioDevice >= 0))
      return (struct _lscp_device_info_t *)(void *)0;

    else
    {
      sprintf(szQuery, "GET AUDIO_OUTPUT_DEVICE INFO %d\r\n", iAudioDevice);
      struct _lscp_device_info_t *return_value__lscp_device_info_query_1;
      return_value__lscp_device_info_query_1=_lscp_device_info_query(pClient, &pClient->audio_device_info, szQuery);
      return return_value__lscp_device_info_query_1;
    }
}

// lscp_get_audio_devices
// file device.c line 454
signed int lscp_get_audio_devices(struct _lscp_client_t *pClient)
{
  signed int iAudioDevices = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET AUDIO_OUTPUT_DEVICES\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iAudioDevices=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iAudioDevices;
  }
}

// lscp_get_audio_driver_info
// file device.c line 342
struct _lscp_driver_info_t * lscp_get_audio_driver_info(struct _lscp_client_t *pClient, const char *pszAudioDriver)
{
  char szQuery[1024l];
  if(pszAudioDriver == ((const char *)NULL))
    return (struct _lscp_driver_info_t *)(void *)0;

  else
  {
    sprintf(szQuery, "GET AUDIO_OUTPUT_DRIVER INFO %s\r\n", pszAudioDriver);
    struct _lscp_driver_info_t *return_value__lscp_driver_info_query_1;
    return_value__lscp_driver_info_query_1=_lscp_driver_info_query(pClient, &pClient->audio_driver_info, szQuery);
    return return_value__lscp_driver_info_query_1;
  }
}

// lscp_get_audio_driver_param_info
// file device.c line 366
struct _lscp_param_info_t * lscp_get_audio_driver_param_info(struct _lscp_client_t *pClient, const char *pszAudioDriver, const char *pszParam, struct _lscp_param_t *pDepList)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_param_info_t *)(void *)0;

  else
    if(pszAudioDriver == ((const char *)NULL))
      return (struct _lscp_param_info_t *)(void *)0;

    else
      if(pszParam == ((const char *)NULL))
        return (struct _lscp_param_info_t *)(void *)0;

      else
      {
        sprintf(szQuery, "GET AUDIO_OUTPUT_DRIVER_PARAMETER INFO %s %s", pszAudioDriver, pszParam);
        struct _lscp_param_info_t *return_value__lscp_param_info_query_1;
        return_value__lscp_param_info_query_1=_lscp_param_info_query(pClient, &pClient->audio_param_info, szQuery, (signed int)sizeof(char [1024l]) /*1024ul*/ , pDepList);
        return return_value__lscp_param_info_query_1;
      }
}

// lscp_get_available_audio_drivers
// file device.c line 278
signed int lscp_get_available_audio_drivers(struct _lscp_client_t *pClient)
{
  signed int iAudioDrivers = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET AVAILABLE_AUDIO_OUTPUT_DRIVERS\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iAudioDrivers=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iAudioDrivers;
  }
}

// lscp_get_available_engines
// file client.c line 1019
signed int lscp_get_available_engines(struct _lscp_client_t *pClient)
{
  signed int iAvailableEngines = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET AVAILABLE_ENGINES\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iAvailableEngines=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iAvailableEngines;
  }
}

// lscp_get_available_midi_drivers
// file device.c line 656
signed int lscp_get_available_midi_drivers(struct _lscp_client_t *pClient)
{
  signed int iMidiDrivers = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET AVAILABLE_MIDI_INPUT_DRIVERS\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iMidiDrivers=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iMidiDrivers;
  }
}

// lscp_get_channel_buffer_fill
// file client.c line 1411
struct _lscp_buffer_fill_t * lscp_get_channel_buffer_fill(struct _lscp_client_t *pClient, enum _lscp_usage_t usage_type, signed int iSamplerChannel)
{
  struct _lscp_buffer_fill_t *pBufferFill;
  char szQuery[1024l];
  signed int iStreamCount;
  const char *pszUsageType = (signed int)usage_type == LSCP_USAGE_BYTES ? "BYTES" : "PERCENTAGE";
  const char *pszResult;
  const char *pszSeps = "[]%,";
  char *pszToken;
  char *pch;
  signed int iStream;
  iStreamCount=lscp_get_channel_stream_count(pClient, iSamplerChannel);
  void *return_value_malloc_1;
  signed int tmp_post_4;
  if(!(iStreamCount >= 0))
    return (struct _lscp_buffer_fill_t *)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->iStreamCount == iStreamCount))
    {
      if(!(pClient->buffer_fill == ((struct _lscp_buffer_fill_t *)NULL)))
        free((void *)pClient->buffer_fill);

      if(iStreamCount >= 1)
      {
        return_value_malloc_1=malloc((unsigned long int)iStreamCount * sizeof(struct _lscp_buffer_fill_t) /*16ul*/ );
        pClient->buffer_fill = (struct _lscp_buffer_fill_t *)return_value_malloc_1;
      }

      else
        pClient->buffer_fill = (struct _lscp_buffer_fill_t *)(void *)0;
      pClient->iStreamCount = iStreamCount;
    }

    pBufferFill = pClient->buffer_fill;
    if(iStreamCount >= 1 && !(pBufferFill == ((struct _lscp_buffer_fill_t *)NULL)))
    {
      iStream = 0;
      pBufferFill = pClient->buffer_fill;
      sprintf(szQuery, "GET CHANNEL BUFFER_FILL %s %d\r\n", pszUsageType, iSamplerChannel);
      enum _lscp_status_t return_value_lscp_client_call_5;
      return_value_lscp_client_call_5=lscp_client_call(pClient, szQuery, 0);
      if((signed int)return_value_lscp_client_call_5 == LSCP_OK)
      {
        pszResult=lscp_client_get_result(pClient);
        pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
        while(!(pszToken == ((char *)NULL)))
        {
          if(iStream >= pClient->iStreamCount)
            break;

          if(!(*pszToken == 0))
          {
            signed long int return_value_atol_2;
            return_value_atol_2=atol(pszToken);
            (pBufferFill + (signed long int)iStream)->stream_id = (unsigned int)return_value_atol_2;
            pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
            if(pszToken == ((char *)NULL))
              break;

            signed long int return_value_atol_3;
            return_value_atol_3=atol(pszToken);
            (pBufferFill + (signed long int)iStream)->stream_usage = (unsigned long int)return_value_atol_3;
            iStream = iStream + 1;
          }

          pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
        }
      }

      else
        for( ; !(iStream >= pClient->iStreamCount); (pBufferFill + (signed long int)tmp_post_4)->stream_usage = (unsigned long int)0)
        {
          tmp_post_4 = iStream;
          iStream = iStream + 1;
        }
    }

    pthread_mutex_unlock(&pClient->mutex);
    return pBufferFill;
  }
}

// lscp_get_channel_info
// file client.c line 1141
struct _lscp_channel_info_t * lscp_get_channel_info(struct _lscp_client_t *pClient, signed int iSamplerChannel)
{
  struct _lscp_channel_info_t *pChannelInfo;
  char szQuery[1024l];
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  struct _locale_t locale;
  signed int return_value_strcasecmp_28;
  char *return_value_lscp_ltrim_1;
  signed int return_value_strcasecmp_27;
  char *return_value_lscp_ltrim_2;
  signed int return_value_strcasecmp_26;
  signed int return_value_strcasecmp_25;
  signed int return_value_strcasecmp_24;
  char *return_value_lscp_ltrim_3;
  signed int return_value_strcasecmp_23;
  signed int return_value_strcasecmp_22;
  char *return_value_lscp_ltrim_4;
  signed int return_value_strcasecmp_21;
  char *return_value_lscp_ltrim_5;
  signed int return_value_strcasecmp_20;
  char *return_value_lscp_ltrim_6;
  signed int return_value_strcasecmp_19;
  signed int return_value_strcasecmp_18;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_17;
  char *return_value_lscp_ltrim_10;
  signed int return_value_strcasecmp_16;
  char *return_value_lscp_unquote_11;
  signed int return_value_strcasecmp_12;
  signed int return_value_strcasecmp_15;
  char *return_value_lscp_unquote_13;
  signed int return_value_strcasecmp_14;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_channel_info_t *)(void *)0;

  else
    if(!(iSamplerChannel >= 0))
      return (struct _lscp_channel_info_t *)(void *)0;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      pChannelInfo = &pClient->channel_info;
      lscp_channel_info_reset(pChannelInfo);
      _save_and_set_c_locale(&locale);
      sprintf(szQuery, "GET CHANNEL INFO %d\r\n", iSamplerChannel);
      enum _lscp_status_t return_value_lscp_client_call_30;
      return_value_lscp_client_call_30=lscp_client_call(pClient, szQuery, 1);
      if((signed int)return_value_lscp_client_call_30 == LSCP_OK)
      {
        pszResult=lscp_client_get_result(pClient);
        pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
        while(!(pszToken == ((char *)NULL)))
        {
          signed int return_value_strcasecmp_29;
          return_value_strcasecmp_29=strcasecmp(pszToken, "ENGINE_NAME");
          if(return_value_strcasecmp_29 == 0)
          {
            pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
            if(!(pszToken == ((char *)NULL)))
              lscp_unquote_dup(&pChannelInfo->engine_name, &pszToken);

          }

          else
          {
            return_value_strcasecmp_28=strcasecmp(pszToken, "AUDIO_OUTPUT_DEVICE");
            if(return_value_strcasecmp_28 == 0)
            {
              pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
              if(!(pszToken == ((char *)NULL)))
              {
                return_value_lscp_ltrim_1=lscp_ltrim(pszToken);
                pChannelInfo->audio_device=atoi(return_value_lscp_ltrim_1);
              }

            }

            else
            {
              return_value_strcasecmp_27=strcasecmp(pszToken, "AUDIO_OUTPUT_CHANNELS");
              if(return_value_strcasecmp_27 == 0)
              {
                pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                if(!(pszToken == ((char *)NULL)))
                {
                  return_value_lscp_ltrim_2=lscp_ltrim(pszToken);
                  pChannelInfo->audio_channels=atoi(return_value_lscp_ltrim_2);
                }

              }

              else
              {
                return_value_strcasecmp_26=strcasecmp(pszToken, "AUDIO_OUTPUT_ROUTING");
                if(return_value_strcasecmp_26 == 0)
                {
                  pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                  if(!(pszToken == ((char *)NULL)))
                  {
                    if(!(pChannelInfo->audio_routing == ((signed int *)NULL)))
                      lscp_isplit_destroy(pChannelInfo->audio_routing);

                    pChannelInfo->audio_routing=lscp_isplit_create(pszToken, ",");
                  }

                }

                else
                {
                  return_value_strcasecmp_25=strcasecmp(pszToken, "INSTRUMENT_FILE");
                  if(return_value_strcasecmp_25 == 0)
                  {
                    pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                    if(!(pszToken == ((char *)NULL)))
                      lscp_unquote_dup(&pChannelInfo->instrument_file, &pszToken);

                  }

                  else
                  {
                    return_value_strcasecmp_24=strcasecmp(pszToken, "INSTRUMENT_NR");
                    if(return_value_strcasecmp_24 == 0)
                    {
                      pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                      if(!(pszToken == ((char *)NULL)))
                      {
                        return_value_lscp_ltrim_3=lscp_ltrim(pszToken);
                        pChannelInfo->instrument_nr=atoi(return_value_lscp_ltrim_3);
                      }

                    }

                    else
                    {
                      return_value_strcasecmp_23=strcasecmp(pszToken, "INSTRUMENT_NAME");
                      if(return_value_strcasecmp_23 == 0)
                      {
                        pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                        if(!(pszToken == ((char *)NULL)))
                          lscp_unquote_dup(&pChannelInfo->instrument_name, &pszToken);

                      }

                      else
                      {
                        return_value_strcasecmp_22=strcasecmp(pszToken, "INSTRUMENT_STATUS");
                        if(return_value_strcasecmp_22 == 0)
                        {
                          pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                          if(!(pszToken == ((char *)NULL)))
                          {
                            return_value_lscp_ltrim_4=lscp_ltrim(pszToken);
                            pChannelInfo->instrument_status=atoi(return_value_lscp_ltrim_4);
                          }

                        }

                        else
                        {
                          return_value_strcasecmp_21=strcasecmp(pszToken, "MIDI_INPUT_DEVICE");
                          if(return_value_strcasecmp_21 == 0)
                          {
                            pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                            if(!(pszToken == ((char *)NULL)))
                            {
                              return_value_lscp_ltrim_5=lscp_ltrim(pszToken);
                              pChannelInfo->midi_device=atoi(return_value_lscp_ltrim_5);
                            }

                          }

                          else
                          {
                            return_value_strcasecmp_20=strcasecmp(pszToken, "MIDI_INPUT_PORT");
                            if(return_value_strcasecmp_20 == 0)
                            {
                              pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                              if(!(pszToken == ((char *)NULL)))
                              {
                                return_value_lscp_ltrim_6=lscp_ltrim(pszToken);
                                pChannelInfo->midi_port=atoi(return_value_lscp_ltrim_6);
                              }

                            }

                            else
                            {
                              return_value_strcasecmp_19=strcasecmp(pszToken, "MIDI_INPUT_CHANNEL");
                              if(return_value_strcasecmp_19 == 0)
                              {
                                pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                                if(!(pszToken == ((char *)NULL)))
                                {
                                  pszToken=lscp_ltrim(pszToken);
                                  signed int return_value_strcasecmp_7;
                                  return_value_strcasecmp_7=strcasecmp(pszToken, "ALL");
                                  if(return_value_strcasecmp_7 == 0)
                                    pChannelInfo->midi_channel = 16;

                                  else
                                    pChannelInfo->midi_channel=atoi(pszToken);
                                }

                              }

                              else
                              {
                                return_value_strcasecmp_18=strcasecmp(pszToken, "MIDI_INSTRUMENT_MAP");
                                if(return_value_strcasecmp_18 == 0)
                                {
                                  pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                                  if(!(pszToken == ((char *)NULL)))
                                  {
                                    pszToken=lscp_ltrim(pszToken);
                                    signed int return_value_strcasecmp_9;
                                    return_value_strcasecmp_9=strcasecmp(pszToken, "NONE");
                                    if(return_value_strcasecmp_9 == 0)
                                      pChannelInfo->midi_map = -1;

                                    else
                                    {
                                      return_value_strcasecmp_8=strcasecmp(pszToken, "DEFAULT");
                                      if(return_value_strcasecmp_8 == 0)
                                        pChannelInfo->midi_map = -2;

                                      else
                                        pChannelInfo->midi_map=atoi(pszToken);
                                    }
                                  }

                                }

                                else
                                {
                                  return_value_strcasecmp_17=strcasecmp(pszToken, "VOLUME");
                                  if(return_value_strcasecmp_17 == 0)
                                  {
                                    pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                                    if(!(pszToken == ((char *)NULL)))
                                    {
                                      return_value_lscp_ltrim_10=lscp_ltrim(pszToken);
                                      pChannelInfo->volume=_atof(return_value_lscp_ltrim_10);
                                    }

                                  }

                                  else
                                  {
                                    return_value_strcasecmp_16=strcasecmp(pszToken, "MUTE");
                                    if(return_value_strcasecmp_16 == 0)
                                    {
                                      pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                                      if(!(pszToken == ((char *)NULL)))
                                      {
                                        return_value_lscp_unquote_11=lscp_unquote(&pszToken, 0);
                                        return_value_strcasecmp_12=strcasecmp(return_value_lscp_unquote_11, "TRUE");
                                        pChannelInfo->mute = (signed int)(return_value_strcasecmp_12 == 0);
                                      }

                                    }

                                    else
                                    {
                                      return_value_strcasecmp_15=strcasecmp(pszToken, "SOLO");
                                      if(return_value_strcasecmp_15 == 0)
                                      {
                                        pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                                        if(!(pszToken == ((char *)NULL)))
                                        {
                                          return_value_lscp_unquote_13=lscp_unquote(&pszToken, 0);
                                          return_value_strcasecmp_14=strcasecmp(return_value_lscp_unquote_13, "TRUE");
                                          pChannelInfo->solo = (signed int)(return_value_strcasecmp_14 == 0);
                                        }

                                      }

                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
        }
      }

      else
        pChannelInfo = (struct _lscp_channel_info_t *)(void *)0;
      _restore_locale(&locale);
      pthread_mutex_unlock(&pClient->mutex);
      return pChannelInfo;
    }
}

// lscp_get_channel_stream_count
// file client.c line 1317
signed int lscp_get_channel_stream_count(struct _lscp_client_t *pClient, signed int iSamplerChannel)
{
  char szQuery[1024l];
  signed int iStreamCount = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
    if(!(iSamplerChannel >= 0))
      return -1;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      sprintf(szQuery, "GET CHANNEL STREAM_COUNT %d\r\n", iSamplerChannel);
      enum _lscp_status_t return_value_lscp_client_call_2;
      return_value_lscp_client_call_2=lscp_client_call(pClient, szQuery, 0);
      if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
      {
        return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
        iStreamCount=atoi(return_value_lscp_client_get_result_1);
      }

      pthread_mutex_unlock(&pClient->mutex);
      return iStreamCount;
    }
}

// lscp_get_channel_stream_usage
// file client.c line 1350
signed int lscp_get_channel_stream_usage(struct _lscp_client_t *pClient, signed int iSamplerChannel)
{
  char szQuery[1024l];
  signed int iStreamUsage = -1;
  const char *pszResult;
  const char *pszSeps = "[]%,";
  char *pszToken;
  char *pch;
  signed int iStream;
  signed int iPercent;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
    if(!(iSamplerChannel >= 0))
      return -1;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      iStream = 0;
      sprintf(szQuery, "GET CHANNEL BUFFER_FILL PERCENTAGE %d\r\n", iSamplerChannel);
      enum _lscp_status_t return_value_lscp_client_call_2;
      return_value_lscp_client_call_2=lscp_client_call(pClient, szQuery, 0);
      if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
      {
        pszResult=lscp_client_get_result(pClient);
        pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
        while(!(pszToken == ((char *)NULL)))
        {
          if(!(*pszToken == 0))
          {
            pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
            if(pszToken == ((char *)NULL))
              break;

            signed long int return_value_atol_1;
            return_value_atol_1=atol(pszToken);
            iPercent = (signed int)return_value_atol_1;
            if(iStream == 0 || !(iPercent >= iStreamUsage))
              iStreamUsage = iPercent;

            iStream = iStream + 1;
          }

          pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
        }
      }

      pthread_mutex_unlock(&pClient->mutex);
      return iStreamUsage;
    }
}

// lscp_get_channel_voice_count
// file client.c line 1284
signed int lscp_get_channel_voice_count(struct _lscp_client_t *pClient, signed int iSamplerChannel)
{
  char szQuery[1024l];
  signed int iVoiceCount = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
    if(!(iSamplerChannel >= 0))
      return -1;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      sprintf(szQuery, "GET CHANNEL VOICE_COUNT %d\r\n", iSamplerChannel);
      enum _lscp_status_t return_value_lscp_client_call_2;
      return_value_lscp_client_call_2=lscp_client_call(pClient, szQuery, 0);
      if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
      {
        return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
        iVoiceCount=atoi(return_value_lscp_client_get_result_1);
      }

      pthread_mutex_unlock(&pClient->mutex);
      return iVoiceCount;
    }
}

// lscp_get_channels
// file client.c line 906
signed int lscp_get_channels(struct _lscp_client_t *pClient)
{
  signed int iChannels = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET CHANNELS\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iChannels=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iChannels;
  }
}

// lscp_get_engine_info
// file client.c line 1083
struct _lscp_engine_info_t * lscp_get_engine_info(struct _lscp_client_t *pClient, const char *pszEngineName)
{
  struct _lscp_engine_info_t *pEngineInfo;
  char szQuery[1024l];
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  signed int return_value_strcasecmp_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_engine_info_t *)(void *)0;

  else
    if(pszEngineName == ((const char *)NULL))
      return (struct _lscp_engine_info_t *)(void *)0;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      pEngineInfo = &pClient->engine_info;
      lscp_engine_info_reset(pEngineInfo);
      sprintf(szQuery, "GET ENGINE INFO %s\r\n", pszEngineName);
      enum _lscp_status_t return_value_lscp_client_call_3;
      return_value_lscp_client_call_3=lscp_client_call(pClient, szQuery, 1);
      if((signed int)return_value_lscp_client_call_3 == LSCP_OK)
      {
        pszResult=lscp_client_get_result(pClient);
        pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
        while(!(pszToken == ((char *)NULL)))
        {
          signed int return_value_strcasecmp_2;
          return_value_strcasecmp_2=strcasecmp(pszToken, "DESCRIPTION");
          if(return_value_strcasecmp_2 == 0)
          {
            pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
            if(!(pszToken == ((char *)NULL)))
              lscp_unquote_dup(&pEngineInfo->description, &pszToken);

          }

          else
          {
            return_value_strcasecmp_1=strcasecmp(pszToken, "VERSION");
            if(return_value_strcasecmp_1 == 0)
            {
              pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
              if(!(pszToken == ((char *)NULL)))
                lscp_unquote_dup(&pEngineInfo->version, &pszToken);

            }

          }
          pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
        }
      }

      else
        pEngineInfo = (struct _lscp_engine_info_t *)(void *)0;
      pthread_mutex_unlock(&pClient->mutex);
      return pEngineInfo;
    }
}

// lscp_get_fxsend_info
// file client.c line 2229
struct _lscp_fxsend_info_t * lscp_get_fxsend_info(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend)
{
  struct _lscp_fxsend_info_t *pFxSendInfo;
  char szQuery[1024l];
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  struct _locale_t locale;
  signed int return_value_strcasecmp_5;
  char *return_value_lscp_ltrim_1;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  char *return_value_lscp_ltrim_2;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_fxsend_info_t *)(void *)0;

  else
    if(!(iFxSend >= 0) || !(iSamplerChannel >= 0))
      return (struct _lscp_fxsend_info_t *)(void *)0;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      _save_and_set_c_locale(&locale);
      pFxSendInfo = &pClient->fxsend_info;
      lscp_fxsend_info_reset(pFxSendInfo);
      sprintf(szQuery, "GET FX_SEND INFO %d %d\r\n", iSamplerChannel, iFxSend);
      enum _lscp_status_t return_value_lscp_client_call_7;
      return_value_lscp_client_call_7=lscp_client_call(pClient, szQuery, 1);
      if((signed int)return_value_lscp_client_call_7 == LSCP_OK)
      {
        pszResult=lscp_client_get_result(pClient);
        pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
        while(!(pszToken == ((char *)NULL)))
        {
          signed int return_value_strcasecmp_6;
          return_value_strcasecmp_6=strcasecmp(pszToken, "NAME");
          if(return_value_strcasecmp_6 == 0)
          {
            pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
            if(!(pszToken == ((char *)NULL)))
              lscp_unquote_dup(&pFxSendInfo->name, &pszToken);

          }

          else
          {
            return_value_strcasecmp_5=strcasecmp(pszToken, "MIDI_CONTROLLER");
            if(return_value_strcasecmp_5 == 0)
            {
              pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
              if(!(pszToken == ((char *)NULL)))
              {
                return_value_lscp_ltrim_1=lscp_ltrim(pszToken);
                pFxSendInfo->midi_controller=atoi(return_value_lscp_ltrim_1);
              }

            }

            else
            {
              return_value_strcasecmp_4=strcasecmp(pszToken, "AUDIO_OUTPUT_ROUTING");
              if(return_value_strcasecmp_4 == 0)
              {
                pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                if(!(pszToken == ((char *)NULL)))
                {
                  if(!(pFxSendInfo->audio_routing == ((signed int *)NULL)))
                    lscp_isplit_destroy(pFxSendInfo->audio_routing);

                  pFxSendInfo->audio_routing=lscp_isplit_create(pszToken, ",");
                }

              }

              else
              {
                return_value_strcasecmp_3=strcasecmp(pszToken, "LEVEL");
                if(return_value_strcasecmp_3 == 0)
                {
                  pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                  if(!(pszToken == ((char *)NULL)))
                  {
                    return_value_lscp_ltrim_2=lscp_ltrim(pszToken);
                    pFxSendInfo->level=_atof(return_value_lscp_ltrim_2);
                  }

                }

              }
            }
          }
          pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
        }
      }

      else
        pFxSendInfo = (struct _lscp_fxsend_info_t *)(void *)0;
      _restore_locale(&locale);
      pthread_mutex_unlock(&pClient->mutex);
      return pFxSendInfo;
    }
}

// lscp_get_fxsends
// file client.c line 2155
signed int lscp_get_fxsends(struct _lscp_client_t *pClient, signed int iSamplerChannel)
{
  signed int iFxSends = -1;
  char szQuery[1024l];
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
    if(!(iSamplerChannel >= 0))
      return -1;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      sprintf(szQuery, "GET FX_SENDS %d\r\n", iSamplerChannel);
      enum _lscp_status_t return_value_lscp_client_call_2;
      return_value_lscp_client_call_2=lscp_client_call(pClient, szQuery, 0);
      if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
      {
        return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
        iFxSends=atoi(return_value_lscp_client_get_result_1);
      }

      pthread_mutex_unlock(&pClient->mutex);
      return iFxSends;
    }
}

// lscp_get_midi_device_info
// file device.c line 898
struct _lscp_device_info_t * lscp_get_midi_device_info(struct _lscp_client_t *pClient, signed int iMidiDevice)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_device_info_t *)(void *)0;

  else
    if(!(iMidiDevice >= 0))
      return (struct _lscp_device_info_t *)(void *)0;

    else
    {
      sprintf(szQuery, "GET MIDI_INPUT_DEVICE INFO %d\r\n", iMidiDevice);
      struct _lscp_device_info_t *return_value__lscp_device_info_query_1;
      return_value__lscp_device_info_query_1=_lscp_device_info_query(pClient, &pClient->midi_device_info, szQuery);
      return return_value__lscp_device_info_query_1;
    }
}

// lscp_get_midi_devices
// file device.c line 834
signed int lscp_get_midi_devices(struct _lscp_client_t *pClient)
{
  signed int iMidiDevices = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET MIDI_INPUT_DEVICES\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iMidiDevices=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iMidiDevices;
  }
}

// lscp_get_midi_driver_info
// file device.c line 720
struct _lscp_driver_info_t * lscp_get_midi_driver_info(struct _lscp_client_t *pClient, const char *pszMidiDriver)
{
  char szQuery[1024l];
  if(pszMidiDriver == ((const char *)NULL))
    return (struct _lscp_driver_info_t *)(void *)0;

  else
  {
    sprintf(szQuery, "GET MIDI_INPUT_DRIVER INFO %s\r\n", pszMidiDriver);
    struct _lscp_driver_info_t *return_value__lscp_driver_info_query_1;
    return_value__lscp_driver_info_query_1=_lscp_driver_info_query(pClient, &pClient->midi_driver_info, szQuery);
    return return_value__lscp_driver_info_query_1;
  }
}

// lscp_get_midi_driver_param_info
// file device.c line 746
struct _lscp_param_info_t * lscp_get_midi_driver_param_info(struct _lscp_client_t *pClient, const char *pszMidiDriver, const char *pszParam, struct _lscp_param_t *pDepList)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_param_info_t *)(void *)0;

  else
    if(pszMidiDriver == ((const char *)NULL))
      return (struct _lscp_param_info_t *)(void *)0;

    else
      if(pszParam == ((const char *)NULL))
        return (struct _lscp_param_info_t *)(void *)0;

      else
      {
        sprintf(szQuery, "GET MIDI_INPUT_DRIVER_PARAMETER INFO %s %s", pszMidiDriver, pszParam);
        struct _lscp_param_info_t *return_value__lscp_param_info_query_1;
        return_value__lscp_param_info_query_1=_lscp_param_info_query(pClient, &pClient->midi_param_info, szQuery, (signed int)sizeof(char [1024l]) /*1024ul*/ , pDepList);
        return return_value__lscp_param_info_query_1;
      }
}

// lscp_get_midi_instrument_info
// file client.c line 2787
struct _lscp_midi_instrument_info_t * lscp_get_midi_instrument_info(struct _lscp_client_t *pClient, struct _lscp_midi_instrument_t *pMidiInstr)
{
  struct _lscp_midi_instrument_info_t *pInstrInfo;
  char szQuery[1024l];
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  struct _locale_t locale;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  signed int return_value_strcasecmp_13;
  signed int return_value_strcasecmp_12;
  signed int return_value_strcasecmp_11;
  char *return_value_lscp_ltrim_3;
  signed int return_value_strcasecmp_10;
  signed int return_value_strcasecmp_9;
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_8;
  char *return_value_lscp_ltrim_7;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_midi_instrument_info_t *)(void *)0;

  else
    if(!(pMidiInstr->map >= 0))
      return (struct _lscp_midi_instrument_info_t *)(void *)0;

    else
    {
      if(!(pMidiInstr->bank >= 0))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = pMidiInstr->bank > 16383 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        return (struct _lscp_midi_instrument_info_t *)(void *)0;

      else
      {
        if(!(pMidiInstr->prog >= 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = pMidiInstr->prog > 127 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          return (struct _lscp_midi_instrument_info_t *)(void *)0;

        else
        {
          pthread_mutex_lock(&pClient->mutex);
          _save_and_set_c_locale(&locale);
          pInstrInfo = &pClient->midi_instrument_info;
          lscp_midi_instrument_info_reset(pInstrInfo);
          sprintf(szQuery, "GET MIDI_INSTRUMENT INFO %d %d %d\r\n", pMidiInstr->map, pMidiInstr->bank, pMidiInstr->prog);
          enum _lscp_status_t return_value_lscp_client_call_15;
          return_value_lscp_client_call_15=lscp_client_call(pClient, szQuery, 1);
          if((signed int)return_value_lscp_client_call_15 == LSCP_OK)
          {
            pszResult=lscp_client_get_result(pClient);
            pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
            while(!(pszToken == ((char *)NULL)))
            {
              signed int return_value_strcasecmp_14;
              return_value_strcasecmp_14=strcasecmp(pszToken, "NAME");
              if(return_value_strcasecmp_14 == 0)
              {
                pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                if(!(pszToken == ((char *)NULL)))
                  lscp_unquote_dup(&pInstrInfo->name, &pszToken);

              }

              else
              {
                return_value_strcasecmp_13=strcasecmp(pszToken, "ENGINE_NAME");
                if(return_value_strcasecmp_13 == 0)
                {
                  pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                  if(!(pszToken == ((char *)NULL)))
                    lscp_unquote_dup(&pInstrInfo->engine_name, &pszToken);

                }

                else
                {
                  return_value_strcasecmp_12=strcasecmp(pszToken, "INSTRUMENT_FILE");
                  if(return_value_strcasecmp_12 == 0)
                  {
                    pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                    if(!(pszToken == ((char *)NULL)))
                      lscp_unquote_dup(&pInstrInfo->instrument_file, &pszToken);

                  }

                  else
                  {
                    return_value_strcasecmp_11=strcasecmp(pszToken, "INSTRUMENT_NR");
                    if(return_value_strcasecmp_11 == 0)
                    {
                      pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                      if(!(pszToken == ((char *)NULL)))
                      {
                        return_value_lscp_ltrim_3=lscp_ltrim(pszToken);
                        pInstrInfo->instrument_nr=atoi(return_value_lscp_ltrim_3);
                      }

                    }

                    else
                    {
                      return_value_strcasecmp_10=strcasecmp(pszToken, "INSTRUMENT_NAME");
                      if(return_value_strcasecmp_10 == 0)
                      {
                        pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                        if(!(pszToken == ((char *)NULL)))
                          lscp_unquote_dup(&pInstrInfo->instrument_name, &pszToken);

                      }

                      else
                      {
                        return_value_strcasecmp_9=strcasecmp(pszToken, "LOAD_MODE");
                        if(return_value_strcasecmp_9 == 0)
                        {
                          pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                          if(!(pszToken == ((char *)NULL)))
                          {
                            pszToken=lscp_ltrim(pszToken);
                            signed int return_value_strcasecmp_6;
                            return_value_strcasecmp_6=strcasecmp(pszToken, "ON_DEMAND");
                            if(return_value_strcasecmp_6 == 0)
                              pInstrInfo->load_mode = (enum _lscp_load_mode_t)LSCP_LOAD_ON_DEMAND;

                            else
                            {
                              return_value_strcasecmp_5=strcasecmp(pszToken, "ON_DEMAND_HOLD");
                              if(return_value_strcasecmp_5 == 0)
                                pInstrInfo->load_mode = (enum _lscp_load_mode_t)LSCP_LOAD_ON_DEMAND_HOLD;

                              else
                              {
                                return_value_strcasecmp_4=strcasecmp(pszToken, "PERSISTENT");
                                if(return_value_strcasecmp_4 == 0)
                                  pInstrInfo->load_mode = (enum _lscp_load_mode_t)LSCP_LOAD_PERSISTENT;

                                else
                                  pInstrInfo->load_mode = (enum _lscp_load_mode_t)LSCP_LOAD_DEFAULT;
                              }
                            }
                          }

                        }

                        else
                        {
                          return_value_strcasecmp_8=strcasecmp(pszToken, "VOLUME");
                          if(return_value_strcasecmp_8 == 0)
                          {
                            pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
                            if(!(pszToken == ((char *)NULL)))
                            {
                              return_value_lscp_ltrim_7=lscp_ltrim(pszToken);
                              pInstrInfo->volume=_atof(return_value_lscp_ltrim_7);
                            }

                          }

                        }
                      }
                    }
                  }
                }
              }
              pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
            }
          }

          else
            pInstrInfo = (struct _lscp_midi_instrument_info_t *)(void *)0;
          _restore_locale(&locale);
          pthread_mutex_unlock(&pClient->mutex);
          return pInstrInfo;
        }
      }
    }
}

// lscp_get_midi_instrument_map_name
// file client.c line 2526
const char * lscp_get_midi_instrument_map_name(struct _lscp_client_t *pClient, signed int iMidiMap)
{
  char szQuery[1024l];
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (const char *)(void *)0;

  else
    if(!(iMidiMap >= 0))
      return (const char *)(void *)0;

    else
    {
      pthread_mutex_lock(&pClient->mutex);
      if(!(pClient->midi_map_name == ((char *)NULL)))
      {
        free((void *)pClient->midi_map_name);
        pClient->midi_map_name = (char *)(void *)0;
      }

      sprintf(szQuery, "GET MIDI_INSTRUMENT_MAP INFO %d\r\n", iMidiMap);
      enum _lscp_status_t return_value_lscp_client_call_2;
      return_value_lscp_client_call_2=lscp_client_call(pClient, szQuery, 1);
      if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
      {
        pszResult=lscp_client_get_result(pClient);
        pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
        while(!(pszToken == ((char *)NULL)))
        {
          signed int return_value_strcasecmp_1;
          return_value_strcasecmp_1=strcasecmp(pszToken, "NAME");
          if(return_value_strcasecmp_1 == 0)
          {
            pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
            if(!(pszToken == ((char *)NULL)))
              lscp_unquote_dup(&pClient->midi_map_name, &pszToken);

          }

          pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
        }
      }

      pthread_mutex_unlock(&pClient->mutex);
      return pClient->midi_map_name;
    }
}

// lscp_get_midi_instrument_maps
// file client.c line 2463
signed int lscp_get_midi_instrument_maps(struct _lscp_client_t *pClient)
{
  signed int iMidiMaps = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET MIDI_INSTRUMENT_MAPS\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iMidiMaps=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iMidiMaps;
  }
}

// lscp_get_midi_instruments
// file client.c line 2702
signed int lscp_get_midi_instruments(struct _lscp_client_t *pClient, signed int iMidiMap)
{
  signed int iInstruments = -1;
  char szQuery[1024l];
  unsigned long int return_value_strlen_1;
  const char *return_value_lscp_client_get_result_2;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    strcpy(szQuery, "GET MIDI_INSTRUMENTS ");
    if(!(iMidiMap >= 0))
      strcat(szQuery, "ALL");

    else
    {
      return_value_strlen_1=strlen(szQuery);
      sprintf(szQuery + (signed long int)return_value_strlen_1, "%d", iMidiMap);
    }
    strcat(szQuery, "\r\n");
    enum _lscp_status_t return_value_lscp_client_call_3;
    return_value_lscp_client_call_3=lscp_client_call(pClient, szQuery, 0);
    if((signed int)return_value_lscp_client_call_3 == LSCP_OK)
    {
      return_value_lscp_client_get_result_2=lscp_client_get_result(pClient);
      iInstruments=atoi(return_value_lscp_client_get_result_2);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iInstruments;
  }
}

// lscp_get_midi_port_info
// file device.c line 949
struct _lscp_device_port_info_t * lscp_get_midi_port_info(struct _lscp_client_t *pClient, signed int iMidiDevice, signed int iMidiPort)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_device_port_info_t *)(void *)0;

  else
    if(!(iMidiDevice >= 0))
      return (struct _lscp_device_port_info_t *)(void *)0;

    else
      if(!(iMidiPort >= 0))
        return (struct _lscp_device_port_info_t *)(void *)0;

      else
      {
        sprintf(szQuery, "GET MIDI_INPUT_PORT INFO %d %d\r\n", iMidiDevice, iMidiPort);
        struct _lscp_device_port_info_t *return_value__lscp_device_port_info_query_1;
        return_value__lscp_device_port_info_query_1=_lscp_device_port_info_query(pClient, &pClient->midi_port_info, szQuery);
        return return_value__lscp_device_port_info_query_1;
      }
}

// lscp_get_midi_port_param_info
// file device.c line 977
struct _lscp_param_info_t * lscp_get_midi_port_param_info(struct _lscp_client_t *pClient, signed int iMidiDevice, signed int iMidiPort, const char *pszParam)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_param_info_t *)(void *)0;

  else
    if(!(iMidiDevice >= 0))
      return (struct _lscp_param_info_t *)(void *)0;

    else
      if(!(iMidiPort >= 0))
        return (struct _lscp_param_info_t *)(void *)0;

      else
        if(pszParam == ((const char *)NULL))
          return (struct _lscp_param_info_t *)(void *)0;

        else
        {
          sprintf(szQuery, "GET MIDI_INPUT_PORT_PARAMETER INFO %d %d %s", iMidiDevice, iMidiPort, pszParam);
          struct _lscp_param_info_t *return_value__lscp_param_info_query_1;
          return_value__lscp_param_info_query_1=_lscp_param_info_query(pClient, &pClient->midi_port_param_info, szQuery, (signed int)sizeof(char [1024l]) /*1024ul*/ , (struct _lscp_param_t *)(void *)0);
          return return_value__lscp_param_info_query_1;
        }
}

// lscp_get_param_value
// file device.c line 1027
const char * lscp_get_param_value(struct _lscp_param_t *pParams, const char *pszParam)
{
  signed int i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(pParams == ((struct _lscp_param_t *)NULL)))
      tmp_if_expr_1 = (pParams + (signed long int)i)->key != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    signed int return_value_strcasecmp_2;
    return_value_strcasecmp_2=strcasecmp((pParams + (signed long int)i)->key, pszParam);
    if(return_value_strcasecmp_2 == 0)
      return (const char *)(pParams + (signed long int)i)->value;

    i = i + 1;
  }
  while((_Bool)1);
  return (const char *)(void *)0;
}

// lscp_get_server_info
// file client.c line 1788
struct _lscp_server_info_t * lscp_get_server_info(struct _lscp_client_t *pClient)
{
  struct _lscp_server_info_t *pServerInfo;
  const char *pszResult;
  const char *pszSeps = ":";
  const char *pszCrlf = "\r\n";
  char *pszToken;
  char *pch;
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_server_info_t *)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    pServerInfo = &pClient->server_info;
    lscp_server_info_reset(pServerInfo);
    enum _lscp_status_t return_value_lscp_client_call_4;
    return_value_lscp_client_call_4=lscp_client_call(pClient, "GET SERVER INFO\r\n", 1);
    if((signed int)return_value_lscp_client_call_4 == LSCP_OK)
    {
      pszResult=lscp_client_get_result(pClient);
      pszToken=lscp_strtok((char *)pszResult, pszSeps, &pch);
      while(!(pszToken == ((char *)NULL)))
      {
        signed int return_value_strcasecmp_3;
        return_value_strcasecmp_3=strcasecmp(pszToken, "DESCRIPTION");
        if(return_value_strcasecmp_3 == 0)
        {
          pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
          if(!(pszToken == ((char *)NULL)))
            lscp_unquote_dup(&pServerInfo->description, &pszToken);

        }

        else
        {
          return_value_strcasecmp_2=strcasecmp(pszToken, "VERSION");
          if(return_value_strcasecmp_2 == 0)
          {
            pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
            if(!(pszToken == ((char *)NULL)))
              lscp_unquote_dup(&pServerInfo->version, &pszToken);

          }

          else
          {
            return_value_strcasecmp_1=strcasecmp(pszToken, "PROTOCOL_VERSION");
            if(return_value_strcasecmp_1 == 0)
            {
              pszToken=lscp_strtok((char *)(void *)0, pszCrlf, &pch);
              if(!(pszToken == ((char *)NULL)))
                lscp_unquote_dup(&pServerInfo->protocol_version, &pszToken);

            }

          }
        }
        pszToken=lscp_strtok((char *)(void *)0, pszSeps, &pch);
      }
    }

    else
      pServerInfo = (struct _lscp_server_info_t *)(void *)0;
    pthread_mutex_unlock(&pClient->mutex);
    return pServerInfo;
  }
}

// lscp_get_streams
// file client.c line 2031
signed int lscp_get_streams(struct _lscp_client_t *pClient)
{
  signed int iStreams = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET STREAMS\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iStreams=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iStreams;
  }
}

// lscp_get_total_voice_count
// file client.c line 1846
signed int lscp_get_total_voice_count(struct _lscp_client_t *pClient)
{
  signed int iVoiceCount = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET TOTAL_VOICE_COUNT\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iVoiceCount=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iVoiceCount;
  }
}

// lscp_get_total_voice_count_max
// file client.c line 1875
signed int lscp_get_total_voice_count_max(struct _lscp_client_t *pClient)
{
  signed int iVoiceCount = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET TOTAL_VOICE_COUNT_MAX\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iVoiceCount=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iVoiceCount;
  }
}

// lscp_get_voices
// file client.c line 1969
signed int lscp_get_voices(struct _lscp_client_t *pClient)
{
  signed int iVoices = -1;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return -1;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET VOICES\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      iVoices=atoi(return_value_lscp_client_get_result_1);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return iVoices;
  }
}

// lscp_get_volume
// file client.c line 1904
float lscp_get_volume(struct _lscp_client_t *pClient)
{
  float fVolume = 0.0f;
  struct _locale_t locale;
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return 0.0f;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    _save_and_set_c_locale(&locale);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "GET VOLUME\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      fVolume=_atof(return_value_lscp_client_get_result_1);
    }

    _restore_locale(&locale);
    pthread_mutex_unlock(&pClient->mutex);
    return fVolume;
  }
}

// lscp_isplit_create
// file common.h line 112
signed int * lscp_isplit_create(const char *pszCsv, const char *pszSeps)
{
  char *pchHead;
  char *pch;
  signed int iSize;
  signed int i;
  signed int j;
  signed int cchSeps;
  signed int *piSplit;
  signed int *piNewSplit;
  pchHead=lscp_ltrim((char *)pszCsv);
  signed int tmp_post_2;
  if(*pchHead == 0)
    return (signed int *)(void *)0;

  else
  {
    iSize = 4;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)iSize * sizeof(signed int) /*4ul*/ );
    piSplit = (signed int *)return_value_malloc_1;
    if(piSplit == ((signed int *)NULL))
      return (signed int *)(void *)0;

    else
    {
      i = 0;
      tmp_post_2 = i;
      i = i + 1;
      piSplit[(signed long int)tmp_post_2]=atoi(pchHead);
      if(!(piSplit[(signed long int)tmp_post_2] >= 0))
      {
        free((void *)piSplit);
        return (signed int *)(void *)0;
      }

      else
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(pszSeps);
        cchSeps = (signed int)return_value_strlen_3;
        do
        {
          pch=strpbrk(pchHead, pszSeps);
          if(pch == ((char *)NULL))
            break;

          pchHead = pch + (signed long int)cchSeps;
          piSplit[(signed long int)i]=atoi(pchHead);
          i = i + 1;
          if(i >= iSize)
          {
            iSize = iSize + 4;
            void *return_value_malloc_4;
            return_value_malloc_4=malloc((unsigned long int)iSize * sizeof(signed int) /*4ul*/ );
            piNewSplit = (signed int *)return_value_malloc_4;
            if(!(piNewSplit == ((signed int *)NULL)))
            {
              j = 0;
              for( ; !(j >= i); j = j + 1)
                piNewSplit[(signed long int)j] = piSplit[(signed long int)j];
              free((void *)piSplit);
              piSplit = piNewSplit;
            }

          }

        }
        while((_Bool)1);
        for( ; !(i >= iSize); i = i + 1)
          piSplit[(signed long int)i] = -1;
        return piSplit;
      }
    }
  }
}

// lscp_isplit_destroy
// file common.h line 113
void lscp_isplit_destroy(signed int *piSplit)
{
  if(!(piSplit == ((signed int *)NULL)))
    free((void *)piSplit);

}

// lscp_list_audio_devices
// file device.c line 483
signed int * lscp_list_audio_devices(struct _lscp_client_t *pClient)
{
  const char *pszSeps = ",";
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (signed int *)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->audio_devices == ((signed int *)NULL)))
    {
      lscp_isplit_destroy(pClient->audio_devices);
      pClient->audio_devices = (signed int *)(void *)0;
    }

    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "LIST AUDIO_OUTPUT_DEVICES\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      pClient->audio_devices=lscp_isplit_create(return_value_lscp_client_get_result_1, pszSeps);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return pClient->audio_devices;
  }
}

// lscp_list_available_audio_drivers
// file device.c line 307
const char ** lscp_list_available_audio_drivers(struct _lscp_client_t *pClient)
{
  const char *pszSeps = ",";
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (const char **)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->audio_drivers == ((char **)NULL)))
    {
      lscp_szsplit_destroy(pClient->audio_drivers);
      pClient->audio_drivers = (char **)(void *)0;
    }

    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "LIST AVAILABLE_AUDIO_OUTPUT_DRIVERS\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      pClient->audio_drivers=lscp_szsplit_create(return_value_lscp_client_get_result_1, pszSeps);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return (const char **)pClient->audio_drivers;
  }
}

// lscp_list_available_engines
// file client.c line 1048
const char ** lscp_list_available_engines(struct _lscp_client_t *pClient)
{
  const char *pszSeps = ",";
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (const char **)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->engines == ((char **)NULL)))
    {
      lscp_szsplit_destroy(pClient->engines);
      pClient->engines = (char **)(void *)0;
    }

    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "LIST AVAILABLE_ENGINES\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      pClient->engines=lscp_szsplit_create(return_value_lscp_client_get_result_1, pszSeps);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return (const char **)pClient->engines;
  }
}

// lscp_list_available_midi_drivers
// file device.c line 685
const char ** lscp_list_available_midi_drivers(struct _lscp_client_t *pClient)
{
  const char *pszSeps = ",";
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (const char **)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->midi_drivers == ((char **)NULL)))
    {
      lscp_szsplit_destroy(pClient->midi_drivers);
      pClient->midi_drivers = (char **)(void *)0;
    }

    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "LIST AVAILABLE_MIDI_INPUT_DRIVERS\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      pClient->midi_drivers=lscp_szsplit_create(return_value_lscp_client_get_result_1, pszSeps);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return (const char **)pClient->midi_drivers;
  }
}

// lscp_list_channels
// file client.c line 935
signed int * lscp_list_channels(struct _lscp_client_t *pClient)
{
  const char *pszSeps = ",";
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (signed int *)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->channels == ((signed int *)NULL)))
    {
      lscp_isplit_destroy(pClient->channels);
      pClient->channels = (signed int *)(void *)0;
    }

    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "LIST CHANNELS\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      pClient->channels=lscp_isplit_create(return_value_lscp_client_get_result_1, pszSeps);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return pClient->channels;
  }
}

// lscp_list_fxsends
// file client.c line 2190
signed int * lscp_list_fxsends(struct _lscp_client_t *pClient, signed int iSamplerChannel)
{
  const char *pszSeps = ",";
  char szQuery[1024l];
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (signed int *)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->fxsends == ((signed int *)NULL)))
    {
      lscp_isplit_destroy(pClient->fxsends);
      pClient->fxsends = (signed int *)(void *)0;
    }

    sprintf(szQuery, "LIST FX_SENDS %d\r\n", iSamplerChannel);
    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, szQuery, 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      pClient->fxsends=lscp_isplit_create(return_value_lscp_client_get_result_1, pszSeps);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return pClient->fxsends;
  }
}

// lscp_list_midi_devices
// file device.c line 863
signed int * lscp_list_midi_devices(struct _lscp_client_t *pClient)
{
  const char *pszSeps = ",";
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (signed int *)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->midi_devices == ((signed int *)NULL)))
    {
      lscp_isplit_destroy(pClient->midi_devices);
      pClient->midi_devices = (signed int *)(void *)0;
    }

    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "LIST MIDI_INPUT_DEVICES\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      pClient->midi_devices=lscp_isplit_create(return_value_lscp_client_get_result_1, pszSeps);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return pClient->midi_devices;
  }
}

// lscp_list_midi_instrument_maps
// file client.c line 2492
signed int * lscp_list_midi_instrument_maps(struct _lscp_client_t *pClient)
{
  const char *pszSeps = ",";
  const char *return_value_lscp_client_get_result_1;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (signed int *)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->midi_maps == ((signed int *)NULL)))
    {
      lscp_isplit_destroy(pClient->midi_maps);
      pClient->midi_maps = (signed int *)(void *)0;
    }

    enum _lscp_status_t return_value_lscp_client_call_2;
    return_value_lscp_client_call_2=lscp_client_call(pClient, "LIST MIDI_INSTRUMENT_MAPS\r\n", 0);
    if((signed int)return_value_lscp_client_call_2 == LSCP_OK)
    {
      return_value_lscp_client_get_result_1=lscp_client_get_result(pClient);
      pClient->midi_maps=lscp_isplit_create(return_value_lscp_client_get_result_1, pszSeps);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return pClient->midi_maps;
  }
}

// lscp_list_midi_instruments
// file client.c line 2742
struct _lscp_midi_instrument_t * lscp_list_midi_instruments(struct _lscp_client_t *pClient, signed int iMidiMap)
{
  char szQuery[1024l];
  unsigned long int return_value_strlen_1;
  const char *return_value_lscp_client_get_result_2;
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (struct _lscp_midi_instrument_t *)(void *)0;

  else
  {
    pthread_mutex_lock(&pClient->mutex);
    if(!(pClient->midi_instruments == ((struct _lscp_midi_instrument_t *)NULL)))
    {
      lscp_midi_instruments_destroy(pClient->midi_instruments);
      pClient->midi_instruments = (struct _lscp_midi_instrument_t *)(void *)0;
    }

    strcpy(szQuery, "LIST MIDI_INSTRUMENTS ");
    if(!(iMidiMap >= 0))
      strcat(szQuery, "ALL");

    else
    {
      return_value_strlen_1=strlen(szQuery);
      sprintf(szQuery + (signed long int)return_value_strlen_1, "%d", iMidiMap);
    }
    strcat(szQuery, "\r\n");
    enum _lscp_status_t return_value_lscp_client_call_3;
    return_value_lscp_client_call_3=lscp_client_call(pClient, szQuery, 0);
    if((signed int)return_value_lscp_client_call_3 == LSCP_OK)
    {
      return_value_lscp_client_get_result_2=lscp_client_get_result(pClient);
      pClient->midi_instruments=lscp_midi_instruments_create(return_value_lscp_client_get_result_2);
    }

    pthread_mutex_unlock(&pClient->mutex);
    return pClient->midi_instruments;
  }
}

// lscp_load_engine
// file client.c line 885
enum _lscp_status_t lscp_load_engine(struct _lscp_client_t *pClient, const char *pszEngineName, signed int iSamplerChannel)
{
  char szQuery[1024l];
  if(pszEngineName == ((const char *)NULL) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "LOAD ENGINE %s %d\r\n", pszEngineName, iSamplerChannel);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_load_instrument
// file client.c line 840
enum _lscp_status_t lscp_load_instrument(struct _lscp_client_t *pClient, const char *pszFileName, signed int iInstrIndex, signed int iSamplerChannel)
{
  char szQuery[1024l];
  if(pszFileName == ((const char *)NULL) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "LOAD INSTRUMENT '%s' %d %d\r\n", pszFileName, iInstrIndex, iSamplerChannel);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_load_instrument_non_modal
// file client.c line 863
enum _lscp_status_t lscp_load_instrument_non_modal(struct _lscp_client_t *pClient, const char *pszFileName, signed int iInstrIndex, signed int iSamplerChannel)
{
  char szQuery[1024l];
  if(pszFileName == ((const char *)NULL) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "LOAD INSTRUMENT NON_MODAL '%s' %d %d\r\n", pszFileName, iInstrIndex, iSamplerChannel);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_ltrim
// file common.h line 101
char * lscp_ltrim(char *psz)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*psz]) == 0)
      break;

    psz = psz + 1l;
  }
  while((_Bool)1);
  return psz;
}

// lscp_map_midi_instrument
// file client.c line 2618
enum _lscp_status_t lscp_map_midi_instrument(struct _lscp_client_t *pClient, struct _lscp_midi_instrument_t *pMidiInstr, const char *pszEngineName, const char *pszFileName, signed int iInstrIndex, float fVolume, enum _lscp_load_mode_t load_mode, const char *pszName)
{
  char szQuery[1024l];
  struct _locale_t locale;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_3;
  enum _lscp_status_t return_value_lscp_client_query_4;
  if(!(pMidiInstr->map >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    if(!(pMidiInstr->bank >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = pMidiInstr->bank > 16383 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return (enum _lscp_status_t)LSCP_FAILED;

    else
    {
      if(!(pMidiInstr->prog >= 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = pMidiInstr->prog > 127 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        return (enum _lscp_status_t)LSCP_FAILED;

      else
        if(pszEngineName == ((const char *)NULL) || pszFileName == ((const char *)NULL))
          return (enum _lscp_status_t)LSCP_FAILED;

        else
        {
          if(fVolume < 0.0f)
            fVolume = 1.0f;

          _save_and_set_c_locale(&locale);
          sprintf(szQuery, "MAP MIDI_INSTRUMENT %d %d %d %s '%s' %d %g", pMidiInstr->map, pMidiInstr->bank, pMidiInstr->prog, pszEngineName, pszFileName, iInstrIndex, fVolume);
          _restore_locale(&locale);
          switch((signed int)load_mode)
          {
            case LSCP_LOAD_PERSISTENT:
            {
              strcat(szQuery, " PERSISTENT");
              goto __CPROVER_DUMP_L13;
            }
            case LSCP_LOAD_ON_DEMAND_HOLD:
            {
              strcat(szQuery, " ON_DEMAND_HOLD");
              goto __CPROVER_DUMP_L13;
            }
            case LSCP_LOAD_ON_DEMAND:
              strcat(szQuery, " ON_DEMAND");
            case LSCP_LOAD_DEFAULT:

            default:
            {

            __CPROVER_DUMP_L13:
              ;
              if(!(pszName == ((const char *)NULL)))
              {
                return_value_strlen_3=strlen(szQuery);
                sprintf(szQuery + (signed long int)return_value_strlen_3, " '%s'", pszName);
              }

              strcat(szQuery, "\r\n");
              return_value_lscp_client_query_4=lscp_client_query(pClient, szQuery);
              return return_value_lscp_client_query_4;
            }
          }
        }
    }
  }
}

// lscp_midi_instrument_info_free
// file common.h line 207
void lscp_midi_instrument_info_free(struct _lscp_midi_instrument_info_t *pInstrInfo)
{
  if(!(pInstrInfo->name == ((char *)NULL)))
    free((void *)pInstrInfo->name);

  if(!(pInstrInfo->engine_name == ((char *)NULL)))
    free((void *)pInstrInfo->engine_name);

  if(!(pInstrInfo->instrument_file == ((char *)NULL)))
    free((void *)pInstrInfo->instrument_file);

  if(!(pInstrInfo->instrument_name == ((char *)NULL)))
    free((void *)pInstrInfo->instrument_name);

}

// lscp_midi_instrument_info_init
// file common.h line 206
void lscp_midi_instrument_info_init(struct _lscp_midi_instrument_info_t *pInstrInfo)
{
  pInstrInfo->name = (char *)(void *)0;
  pInstrInfo->engine_name = (char *)(void *)0;
  pInstrInfo->instrument_file = (char *)(void *)0;
  pInstrInfo->instrument_nr = 0;
  pInstrInfo->instrument_name = (char *)(void *)0;
  pInstrInfo->load_mode = (enum _lscp_load_mode_t)LSCP_LOAD_DEFAULT;
  pInstrInfo->volume = (float)0.0;
}

// lscp_midi_instrument_info_reset
// file common.h line 208
void lscp_midi_instrument_info_reset(struct _lscp_midi_instrument_info_t *pInstrInfo)
{
  lscp_midi_instrument_info_free(pInstrInfo);
  lscp_midi_instrument_info_init(pInstrInfo);
}

// lscp_midi_instruments_create
// file common.h line 134
struct _lscp_midi_instrument_t * lscp_midi_instruments_create(const char *pszCsv)
{
  char *pchHead;
  char *pch;
  signed int iSize;
  signed int i;
  signed int j;
  signed int k;
  struct _lscp_midi_instrument_t *pInstrs;
  struct _lscp_midi_instrument_t *pNewInstrs;
  pchHead=lscp_ltrim((char *)pszCsv);
  if(*pchHead == 0)
    return (struct _lscp_midi_instrument_t *)(void *)0;

  else
  {
    iSize = 4;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)iSize * sizeof(struct _lscp_midi_instrument_t) /*12ul*/ );
    pInstrs = (struct _lscp_midi_instrument_t *)return_value_malloc_1;
    if(pInstrs == ((struct _lscp_midi_instrument_t *)NULL))
      return (struct _lscp_midi_instrument_t *)(void *)0;

    else
    {
      i = 0;
      k = 0;
      do
      {
        pch=strpbrk(pchHead, "{,}");
        if(pch == ((char *)NULL))
          break;

        switch((signed int)*pch)
        {
          case 123:
          {
            pchHead = pch + (signed long int)1;
            if(k == 0)
            {
              (pInstrs + (signed long int)i)->map=atoi(pchHead);
              k = k + 1;
            }

            break;
          }
          case 44:
          {
            pchHead = pch + (signed long int)1;
            if(k == 1)
            {
              (pInstrs + (signed long int)i)->bank=atoi(pchHead);
              k = k + 1;
            }

            else
              if(k == 2)
              {
                (pInstrs + (signed long int)i)->prog=atoi(pchHead);
                k = k + 1;
              }

            break;
          }
          case 125:
          {
            pchHead = pch + (signed long int)1;
            k = 0;
          }
        }
        if(k == 3)
        {
          i = i + 1;
          if(i >= iSize)
          {
            iSize = iSize + 4;
            void *return_value_malloc_2;
            return_value_malloc_2=malloc((unsigned long int)iSize * sizeof(struct _lscp_midi_instrument_t) /*12ul*/ );
            pNewInstrs = (struct _lscp_midi_instrument_t *)return_value_malloc_2;
            if(!(pNewInstrs == ((struct _lscp_midi_instrument_t *)NULL)))
            {
              j = 0;
              for( ; !(j >= i); j = j + 1)
              {
                (pNewInstrs + (signed long int)j)->map = (pInstrs + (signed long int)j)->map;
                (pNewInstrs + (signed long int)j)->bank = (pInstrs + (signed long int)j)->bank;
                (pNewInstrs + (signed long int)j)->prog = (pInstrs + (signed long int)j)->prog;
              }
              free((void *)pInstrs);
              pInstrs = pNewInstrs;
            }

          }

        }

      }
      while((_Bool)1);
      for( ; !(i >= iSize); i = i + 1)
      {
        (pInstrs + (signed long int)i)->map = -1;
        (pInstrs + (signed long int)i)->bank = -1;
        (pInstrs + (signed long int)i)->prog = -1;
      }
      return pInstrs;
    }
  }
}

// lscp_midi_instruments_destroy
// file common.h line 135
void lscp_midi_instruments_destroy(struct _lscp_midi_instrument_t *pInstrs)
{
  if(!(pInstrs == ((struct _lscp_midi_instrument_t *)NULL)))
    free((void *)pInstrs);

}

// lscp_param_concat
// file common.h line 194
signed int lscp_param_concat(char *pszBuffer, signed int cchMaxBuffer, struct _lscp_param_t *pParams)
{
  signed int cchBuffer;
  signed int cchParam;
  signed int i;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  signed int tmp_post_6;
  signed int tmp_post_7;
  if(pszBuffer == ((char *)NULL))
    return 0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(pszBuffer);
    cchBuffer = (signed int)return_value_strlen_1;
    i = 0;
    do
    {
      if(!(pParams == ((struct _lscp_param_t *)NULL)))
        tmp_if_expr_2 = (pParams + (signed long int)i)->key != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (pParams + (signed long int)i)->value != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen((pParams + (signed long int)i)->key);
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen((pParams + (signed long int)i)->value);
      cchParam = (signed int)(return_value_strlen_4 + return_value_strlen_5 + (unsigned long int)4);
      if(!(2 + cchBuffer + cchParam >= cchMaxBuffer))
      {
        sprintf(pszBuffer + (signed long int)cchBuffer, " %s='%s'", (pParams + (signed long int)i)->key, (pParams + (signed long int)i)->value);
        cchBuffer = cchBuffer + cchParam;
      }

      i = i + 1;
    }
    while((_Bool)1);
    if(!(2 + cchBuffer >= cchMaxBuffer))
    {
      tmp_post_6 = cchBuffer;
      cchBuffer = cchBuffer + 1;
      pszBuffer[(signed long int)tmp_post_6] = (char)13;
      tmp_post_7 = cchBuffer;
      cchBuffer = cchBuffer + 1;
      pszBuffer[(signed long int)tmp_post_7] = (char)10;
      pszBuffer[(signed long int)cchBuffer] = (char)0;
    }

    return cchBuffer;
  }
}

// lscp_param_info_free
// file common.h line 188
void lscp_param_info_free(struct _lscp_param_info_t *pParamInfo)
{
  if(!(pParamInfo->description == ((char *)NULL)))
    free((void *)pParamInfo->description);

  lscp_szsplit_destroy(pParamInfo->depends);
  if(!(pParamInfo->defaultv == ((char *)NULL)))
    free((void *)pParamInfo->defaultv);

  if(!(pParamInfo->range_min == ((char *)NULL)))
    free((void *)pParamInfo->range_min);

  if(!(pParamInfo->range_max == ((char *)NULL)))
    free((void *)pParamInfo->range_max);

  lscp_szsplit_destroy(pParamInfo->possibilities);
}

// lscp_param_info_init
// file common.h line 187
void lscp_param_info_init(struct _lscp_param_info_t *pParamInfo)
{
  pParamInfo->type = (enum _lscp_type_t)LSCP_TYPE_NONE;
  pParamInfo->description = (char *)(void *)0;
  pParamInfo->mandatory = 0;
  pParamInfo->fix = 0;
  pParamInfo->multiplicity = 0;
  pParamInfo->depends = (char **)(void *)0;
  pParamInfo->defaultv = (char *)(void *)0;
  pParamInfo->range_min = (char *)(void *)0;
  pParamInfo->range_max = (char *)(void *)0;
  pParamInfo->possibilities = (char **)(void *)0;
}

// lscp_param_info_reset
// file common.h line 189
void lscp_param_info_reset(struct _lscp_param_info_t *pParamInfo)
{
  lscp_param_info_free(pParamInfo);
  lscp_param_info_init(pParamInfo);
}

// lscp_parser_free
// file parser.h line 60
void lscp_parser_free(struct _lscp_parser_t *pParser)
{
  if(!(pParser->pchBuffer == ((char *)NULL)))
    free((void *)pParser->pchBuffer);

  pParser->pchBuffer = (char *)(void *)0;
}

// lscp_parser_init
// file parser.h line 54
void lscp_parser_init(struct _lscp_parser_t *pParser, const char *pchBuffer, signed int cchBuffer)
{
  memset((void *)pParser, 0, sizeof(struct _lscp_parser_t) /*32ul*/ );
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(cchBuffer + 1));
  pParser->pchBuffer = (char *)return_value_malloc_1;
  if(!(pParser->pchBuffer == ((char *)NULL)))
  {
    memcpy((void *)pParser->pchBuffer, (const void *)pchBuffer, (unsigned long int)cchBuffer);
    pParser->pchBuffer[(signed long int)cchBuffer] = (char)0;
    pParser->pszToken=lscp_parser_strtok(pParser->pchBuffer, " \t\r\n", &pParser->pch);
  }

}

// lscp_parser_next
// file parser.h line 55
const char * lscp_parser_next(struct _lscp_parser_t *pParser)
{
  const char *pszToken = pParser->pszToken;
  if(!(pParser->pszToken == ((const char *)NULL)))
    pParser->pszToken=lscp_parser_strtok((char *)(void *)0, " \t\r\n", &pParser->pch);

  return pszToken;
}

// lscp_parser_nextint
// file parser.h line 56
signed int lscp_parser_nextint(struct _lscp_parser_t *pParser)
{
  signed int ret = 0;
  if(!(pParser->pszToken == ((const char *)NULL)))
  {
    ret=atoi(pParser->pszToken);
    lscp_parser_next(pParser);
  }

  return ret;
}

// lscp_parser_nextnum
// file parser.h line 57
float lscp_parser_nextnum(struct _lscp_parser_t *pParser)
{
  float ret = 0.0f;
  if(!(pParser->pszToken == ((const char *)NULL)))
  {
    double return_value_atof_1;
    return_value_atof_1=atof(pParser->pszToken);
    ret = (float)return_value_atof_1;
    lscp_parser_next(pParser);
  }

  return ret;
}

// lscp_parser_strtok
// file parser.c line 34
const char * lscp_parser_strtok(char *pchBuffer, const char *pszDelim, char **ppch)
{
  const char *pszToken;
  if(pchBuffer == ((char *)NULL))
    pchBuffer = *ppch;

  unsigned long int return_value_strspn_1;
  return_value_strspn_1=strspn(pchBuffer, pszDelim);
  pchBuffer = pchBuffer + (signed long int)return_value_strspn_1;
  char *return_value_strchr_2;
  if((signed int)*pchBuffer == 0)
    return (const char *)(void *)0;

  else
  {
    pszToken = pchBuffer;
    pchBuffer=strpbrk(pszToken, pszDelim);
    if(pchBuffer == ((char *)NULL))
      *ppch=strchr(pszToken, 0);

    else
    {
      *pchBuffer = (char)0;
      *ppch = pchBuffer + (signed long int)1;
      do
      {
        return_value_strchr_2=strchr(pszDelim, (signed int)*(*ppch));
        if(return_value_strchr_2 == ((char *)NULL))
          break;

        *ppch = *ppch + 1l;
      }
      while((_Bool)1);
    }
    return pszToken;
  }
}

// lscp_parser_test
// file parser.h line 58
signed int lscp_parser_test(struct _lscp_parser_t *pParser, const char *pszToken)
{
  signed int ret = (signed int)(pParser->pszToken != (const char *)(void *)0);
  signed int return_value_strcasecmp_1;
  if(!(ret == 0))
  {
    return_value_strcasecmp_1=strcasecmp(pParser->pszToken, pszToken);
    ret = (signed int)(return_value_strcasecmp_1 == 0);
  }

  if(!(ret == 0))
    lscp_parser_next(pParser);

  return ret;
}

// lscp_parser_test2
// file parser.h line 59
signed int lscp_parser_test2(struct _lscp_parser_t *pParser, const char *pszToken, const char *pszToken2)
{
  signed int ret;
  ret=lscp_parser_test(pParser, pszToken);
  if(!(ret == 0))
    ret=lscp_parser_test(pParser, pszToken2);

  return ret;
}

// lscp_plist_alloc
// file common.c line 625
void lscp_plist_alloc(struct _lscp_param_t **ppList)
{
  struct _lscp_param_t *pParams;
  signed int iSize;
  signed int i;
  if(!(ppList == ((struct _lscp_param_t **)NULL)))
  {
    iSize = 4;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)iSize * sizeof(struct _lscp_param_t) /*16ul*/ );
    pParams = (struct _lscp_param_t *)return_value_malloc_1;
    if(!(pParams == ((struct _lscp_param_t *)NULL)))
    {
      i = 0;
      for( ; !(i >= iSize); i = i + 1)
      {
        (pParams + (signed long int)i)->key = (char *)(void *)0;
        (pParams + (signed long int)i)->value = (char *)(void *)0;
      }
    }

    *ppList = pParams;
  }

}

// lscp_plist_append
// file common.h line 128
void lscp_plist_append(struct _lscp_param_t **ppList, const char *pszKey, const char *pszValue)
{
  struct _lscp_param_t *pParams;
  struct _lscp_param_t *pNewParams;
  signed int iSize;
  signed int iNewSize;
  signed int i = 0;
  if(!(ppList == ((struct _lscp_param_t **)NULL)))
  {
    if(!(*ppList == ((struct _lscp_param_t *)NULL)))
    {
      pParams = *ppList;
      while(!((pParams + (signed long int)i)->key == ((char *)NULL)))
      {
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp((pParams + (signed long int)i)->key, pszKey);
        if(return_value_strcasecmp_1 == 0)
        {
          if(!((pParams + (signed long int)i)->value == ((char *)NULL)))
            free((void *)(pParams + (signed long int)i)->value);

          (pParams + (signed long int)i)->value=strdup(pszValue);
          goto __CPROVER_DUMP_L9;
        }

        i = i + 1;
      }
      iSize = (i >> 2) + 1 << 2;
      (pParams + (signed long int)i)->key=strdup(pszKey);
      (pParams + (signed long int)i)->value=strdup(pszValue);
      i = i + 1;
      if(i >= iSize)
      {
        iNewSize = iSize + 4;
        void *return_value_malloc_2;
        return_value_malloc_2=malloc((unsigned long int)iNewSize * sizeof(struct _lscp_param_t) /*16ul*/ );
        pNewParams = (struct _lscp_param_t *)return_value_malloc_2;
        i = 0;
        for( ; !(i >= iSize); i = i + 1)
        {
          (pNewParams + (signed long int)i)->key = (pParams + (signed long int)i)->key;
          (pNewParams + (signed long int)i)->value = (pParams + (signed long int)i)->value;
        }
        for( ; !(i >= iNewSize); i = i + 1)
        {
          (pNewParams + (signed long int)i)->key = (char *)(void *)0;
          (pNewParams + (signed long int)i)->value = (char *)(void *)0;
        }
        free((void *)pParams);
        *ppList = pNewParams;
      }

    }

  }


__CPROVER_DUMP_L9:
  ;
}

// lscp_plist_free
// file common.c line 645
void lscp_plist_free(struct _lscp_param_t **ppList)
{
  struct _lscp_param_t *pParams;
  signed int i;
  _Bool tmp_if_expr_1;
  if(!(ppList == ((struct _lscp_param_t **)NULL)))
  {
    if(!(*ppList == ((struct _lscp_param_t *)NULL)))
    {
      pParams = *ppList;
      i = 0;
      do
      {
        if(!(pParams == ((struct _lscp_param_t *)NULL)))
          tmp_if_expr_1 = (pParams + (signed long int)i)->key != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        free((void *)(pParams + (signed long int)i)->key);
        free((void *)(pParams + (signed long int)i)->value);
        i = i + 1;
      }
      while((_Bool)1);
      free((void *)pParams);
    }

    *ppList = (struct _lscp_param_t *)(void *)0;
  }

}

// lscp_psplit_create
// file common.c line 538
struct _lscp_param_t * lscp_psplit_create(const char *pszCsv, const char *pszSeps1, const char *pszSeps2)
{
  char *pszHead;
  char *pch;
  signed int iSize;
  signed int i;
  signed int j;
  signed int cchSeps1;
  signed int cchSeps2;
  struct _lscp_param_t *ppSplit;
  struct _lscp_param_t *ppNewSplit;
  pszHead=strdup(pszCsv);
  if(pszHead == ((char *)NULL))
    return (struct _lscp_param_t *)(void *)0;

  else
  {
    iSize = 4;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)iSize * sizeof(struct _lscp_param_t) /*16ul*/ );
    ppSplit = (struct _lscp_param_t *)return_value_malloc_1;
    if(ppSplit == ((struct _lscp_param_t *)NULL))
    {
      free((void *)pszHead);
      return (struct _lscp_param_t *)(void *)0;
    }

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(pszSeps1);
      cchSeps1 = (signed int)return_value_strlen_2;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(pszSeps2);
      cchSeps2 = (signed int)return_value_strlen_3;
      i = 0;
      do
      {
        pch=strpbrk(pszHead, pszSeps1);
        if(pch == ((char *)NULL))
          break;

        (ppSplit + (signed long int)i)->key = pszHead;
        pszHead = pch + (signed long int)cchSeps1;
        *pch = (char)0;
        (ppSplit + (signed long int)i)->value=lscp_unquote(&pszHead, 0);
        pch=strpbrk(pszHead, pszSeps2);
        if(!(pch == ((char *)NULL)))
        {
          pszHead = pch + (signed long int)cchSeps2;
          *pch = (char)0;
        }

        i = i + 1;
        if(i >= iSize)
        {
          iSize = iSize + 4;
          void *return_value_malloc_4;
          return_value_malloc_4=malloc((unsigned long int)iSize * sizeof(struct _lscp_param_t) /*16ul*/ );
          ppNewSplit = (struct _lscp_param_t *)return_value_malloc_4;
          if(!(ppNewSplit == ((struct _lscp_param_t *)NULL)))
          {
            j = 0;
            for( ; !(j >= i); j = j + 1)
            {
              (ppNewSplit + (signed long int)j)->key = (ppSplit + (signed long int)j)->key;
              (ppNewSplit + (signed long int)j)->value = (ppSplit + (signed long int)j)->value;
            }
            free((void *)ppSplit);
            ppSplit = ppNewSplit;
          }

        }

      }
      while((_Bool)1);
      if(!(i >= 1))
        free((void *)pszHead);

      for( ; !(i >= iSize); i = i + 1)
      {
        (ppSplit + (signed long int)i)->key = (char *)(void *)0;
        (ppSplit + (signed long int)i)->value = (char *)(void *)0;
      }
      return ppSplit;
    }
  }
}

// lscp_psplit_destroy
// file common.c line 595
void lscp_psplit_destroy(struct _lscp_param_t *ppSplit)
{
  if(!(ppSplit == ((struct _lscp_param_t *)NULL)))
  {
    if(!(ppSplit->key == ((char *)NULL)))
      free((void *)(ppSplit + (signed long int)0)->key);

  }

  if(!(ppSplit == ((struct _lscp_param_t *)NULL)))
    free((void *)ppSplit);

}

// lscp_remove_channel
// file client.c line 998
enum _lscp_status_t lscp_remove_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel)
{
  char szQuery[1024l];
  if(!(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "REMOVE CHANNEL %d\r\n", iSamplerChannel);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_remove_midi_instrument_map
// file client.c line 2441
enum _lscp_status_t lscp_remove_midi_instrument_map(struct _lscp_client_t *pClient, signed int iMidiMap)
{
  char szQuery[1024l];
  if(!(iMidiMap >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "REMOVE MIDI_INSTRUMENT_MAP %d\r\n", iMidiMap);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_reset_channel
// file client.c line 1752
enum _lscp_status_t lscp_reset_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel)
{
  char szQuery[1024l];
  if(!(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "RESET CHANNEL %d\r\n", iSamplerChannel);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_reset_sampler
// file client.c line 1772
enum _lscp_status_t lscp_reset_sampler(struct _lscp_client_t *pClient)
{
  enum _lscp_status_t return_value_lscp_client_query_1;
  return_value_lscp_client_query_1=lscp_client_query(pClient, "RESET\r\n");
  return return_value_lscp_client_query_1;
}

// lscp_server_broadcast
// file server.h line 117
enum _lscp_status_t lscp_server_broadcast(struct _lscp_server_t *pServer, enum _lscp_event_t event, const char *pchData, signed int cchData)
{
  struct _lscp_connect_t *p;
  const char *pszEvent;
  char achBuffer[1024l];
  signed int cchBuffer;
  signed int tmp_post_1;
  signed int tmp_post_2;
  if(pServer == ((struct _lscp_server_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
    if(pchData == ((const char *)NULL) || !(cchData >= 1))
      return (enum _lscp_status_t)LSCP_FAILED;

    else
    {
      pszEvent=lscp_event_to_text(event);
      if(pszEvent == ((const char *)NULL))
        return (enum _lscp_status_t)LSCP_FAILED;

      else
      {
        cchBuffer=sprintf(achBuffer, "NOTIFY:%s:", pszEvent);
        if(!(pchData == ((const char *)NULL)))
        {
          if(!(1024 + -cchBuffer + -2 >= cchData))
            cchData = (1024 - cchBuffer) - 2;

          strncpy(&achBuffer[(signed long int)cchBuffer], pchData, (unsigned long int)cchData);
          cchBuffer = cchBuffer + cchData;
        }

        tmp_post_1 = cchBuffer;
        cchBuffer = cchBuffer + 1;
        achBuffer[(signed long int)tmp_post_1] = (char)13;
        tmp_post_2 = cchBuffer;
        cchBuffer = cchBuffer + 1;
        achBuffer[(signed long int)tmp_post_2] = (char)10;
        pthread_mutex_lock(&pServer->connects.mutex);
        p = pServer->connects.first;
        for( ; !(p == ((struct _lscp_connect_t *)NULL)); p = p->next)
          if(!(((signed int)p->events & (signed int)event) == 0))
            send(p->client.sock, (const void *)achBuffer, (unsigned long int)cchBuffer, 0);

        pthread_mutex_unlock(&pServer->connects.mutex);
        return (enum _lscp_status_t)LSCP_OK;
      }
    }
}

// lscp_server_build
// file server.h line 106
const char * lscp_server_build(void)
{
  return "Jan 25 2016 01:29:52";
}

// lscp_server_create
// file server.h line 112
struct _lscp_server_t * lscp_server_create(signed int iPort, enum _lscp_status_t (*pfnCallback)(struct _lscp_connect_t *, const char *, signed int, void *), void *pvData)
{
  struct _lscp_server_t *return_value_lscp_server_create_ex_1;
  return_value_lscp_server_create_ex_1=lscp_server_create_ex(iPort, pfnCallback, pvData, (enum _lscp_server_mode_t)LSCP_SERVER_SELECT);
  return return_value_lscp_server_create_ex_1;
}

// lscp_server_create_ex
// file server.c line 453
struct _lscp_server_t * lscp_server_create_ex(signed int iPort, enum _lscp_status_t (*pfnCallback)(struct _lscp_connect_t *, const char *, signed int, void *), void *pvData, enum _lscp_server_mode_t mode)
{
  struct _lscp_server_t *pServer;
  signed int sock;
  struct sockaddr_in addr;
  unsigned int cAddr;
  signed int iSockOpt = -1;
  if(pfnCallback == ((enum _lscp_status_t (*)(struct _lscp_connect_t *, const char *, signed int, void *))NULL))
  {
    fprintf(stderr, "lscp_server_create: Invalid server callback function.\n");
    return (struct _lscp_server_t *)(void *)0;
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct _lscp_server_t) /*128ul*/ );
    pServer = (struct _lscp_server_t *)return_value_malloc_1;
    if(pServer == ((struct _lscp_server_t *)NULL))
    {
      fprintf(stderr, "lscp_server_create: Out of memory.\n");
      return (struct _lscp_server_t *)(void *)0;
    }

    else
    {
      memset((void *)pServer, 0, sizeof(struct _lscp_server_t) /*128ul*/ );
      _lscp_connect_list_init(&pServer->connects);
      pServer->mode = mode;
      pServer->pfnCallback = pfnCallback;
      pServer->pvData = pvData;
      sock=socket(2, 1, 0);
      if(sock == -1)
      {
        lscp_socket_perror("lscp_server_create: socket");
        free((void *)pServer);
        return (struct _lscp_server_t *)(void *)0;
      }

      else
      {
        signed int return_value_setsockopt_2;
        return_value_setsockopt_2=setsockopt(sock, 1, 2, (const void *)(char *)&iSockOpt, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(return_value_setsockopt_2 == -1)
          lscp_socket_perror("lscp_server_create: setsockopt(SO_REUSEADDR)");

        cAddr = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        memset((void *)(char *)&addr, 0, (unsigned long int)cAddr);
        addr.sin_family = (unsigned short int)2;
        addr.sin_addr.s_addr=htonl((unsigned int)0x00000000);
        addr.sin_port=htons((unsigned short int)(signed short int)iPort);
        signed int return_value_bind_3;
        return_value_bind_3=bind(sock, (struct sockaddr *)&addr, cAddr);
        if(return_value_bind_3 == -1)
        {
          lscp_socket_perror("lscp_server_create: bind");
          close(sock);
          free((void *)pServer);
          return (struct _lscp_server_t *)(void *)0;
        }

        else
        {
          signed int return_value_listen_4;
          return_value_listen_4=listen(sock, 10);
          if(return_value_listen_4 == -1)
          {
            lscp_socket_perror("lscp_server_create: listen");
            close(sock);
            free((void *)pServer);
            return (struct _lscp_server_t *)(void *)0;
          }

          else
          {
            if(iPort == 0)
            {
              signed int return_value_getsockname_5;
              return_value_getsockname_5=getsockname(sock, (struct sockaddr *)&addr, &cAddr);
              if(return_value_getsockname_5 == -1)
              {
                lscp_socket_perror("lscp_server_create: getsockname");
                close(sock);
                free((void *)pServer);
              }

            }

            lscp_socket_agent_init(&pServer->agent, sock, &addr, (signed int)cAddr);
            enum _lscp_status_t return_value_lscp_socket_agent_start_6;
            return_value_lscp_socket_agent_start_6=lscp_socket_agent_start(&pServer->agent, _lscp_server_agent_proc, (void *)pServer, 0);
            if(!((signed int)return_value_lscp_socket_agent_start_6 == LSCP_OK))
            {
              lscp_socket_agent_free(&pServer->agent);
              free((void *)pServer);
              return (struct _lscp_server_t *)(void *)0;
            }

            else
              return pServer;
          }
        }
      }
    }
  }
}

// lscp_server_destroy
// file server.h line 115
enum _lscp_status_t lscp_server_destroy(struct _lscp_server_t *pServer)
{
  if(pServer == ((struct _lscp_server_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    _lscp_connect_list_free(&pServer->connects);
    lscp_socket_agent_free(&pServer->agent);
    free((void *)pServer);
    return (enum _lscp_status_t)LSCP_OK;
  }
}

// lscp_server_info_free
// file common.h line 146
void lscp_server_info_free(struct _lscp_server_info_t *pServerInfo)
{
  if(!(pServerInfo->description == ((char *)NULL)))
    free((void *)pServerInfo->description);

  if(!(pServerInfo->version == ((char *)NULL)))
    free((void *)pServerInfo->version);

  if(!(pServerInfo->protocol_version == ((char *)NULL)))
    free((void *)pServerInfo->protocol_version);

}

// lscp_server_info_init
// file common.h line 145
void lscp_server_info_init(struct _lscp_server_info_t *pServerInfo)
{
  pServerInfo->description = (char *)(void *)0;
  pServerInfo->version = (char *)(void *)0;
  pServerInfo->protocol_version = (char *)(void *)0;
}

// lscp_server_info_reset
// file common.h line 147
void lscp_server_info_reset(struct _lscp_server_info_t *pServerInfo)
{
  lscp_server_info_free(pServerInfo);
  lscp_server_info_init(pServerInfo);
}

// lscp_server_join
// file server.c line 558
enum _lscp_status_t lscp_server_join(struct _lscp_server_t *pServer)
{
  if(pServer == ((struct _lscp_server_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    lscp_socket_agent_join(&pServer->agent);
    return (enum _lscp_status_t)LSCP_OK;
  }
}

// lscp_server_package
// file server.h line 104
const char * lscp_server_package(void)
{
  return "liblscp";
}

// lscp_server_result
// file server.h line 119
enum _lscp_status_t lscp_server_result(struct _lscp_connect_t *pConnect, const char *pchBuffer, signed int cchBuffer)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  if(pConnect == ((struct _lscp_connect_t *)NULL))
    return ret;

  else
    if(pchBuffer == ((const char *)NULL) || !(cchBuffer >= 1))
      return ret;

    else
    {
      signed long int return_value_send_1;
      return_value_send_1=send(pConnect->client.sock, (const void *)pchBuffer, (unsigned long int)cchBuffer, 0);
      if(!(return_value_send_1 == (signed long int)cchBuffer))
        lscp_socket_perror("lscp_server_result");

      else
        ret = (enum _lscp_status_t)LSCP_OK;
      return ret;
    }
}

// lscp_server_subscribe
// file server.h line 121
enum _lscp_status_t lscp_server_subscribe(struct _lscp_connect_t *pConnect, enum _lscp_event_t event)
{
  if(pConnect == ((struct _lscp_connect_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
    if((signed int)event == LSCP_EVENT_NONE)
      return (enum _lscp_status_t)LSCP_FAILED;

    else
    {
      pConnect->events = pConnect->events | event;
      return (enum _lscp_status_t)LSCP_OK;
    }
}

// lscp_server_unsubscribe
// file server.h line 122
enum _lscp_status_t lscp_server_unsubscribe(struct _lscp_connect_t *pConnect, enum _lscp_event_t event)
{
  if(pConnect == ((struct _lscp_connect_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
    if((signed int)event == LSCP_EVENT_NONE)
      return (enum _lscp_status_t)LSCP_FAILED;

    else
    {
      pConnect->events = pConnect->events & (enum _lscp_event_t)~((signed int)event);
      return (enum _lscp_status_t)LSCP_OK;
    }
}

// lscp_server_version
// file server.h line 105
const char * lscp_server_version(void)
{
  return "0.5.6";
}

// lscp_set_audio_channel_param
// file device.c line 626
enum _lscp_status_t lscp_set_audio_channel_param(struct _lscp_client_t *pClient, signed int iAudioDevice, signed int iAudioChannel, struct _lscp_param_t *pParam)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
    if(!(iAudioDevice >= 0))
      return (enum _lscp_status_t)LSCP_FAILED;

    else
      if(!(iAudioChannel >= 0))
        return (enum _lscp_status_t)LSCP_FAILED;

      else
        if(pParam == ((struct _lscp_param_t *)NULL))
          return (enum _lscp_status_t)LSCP_FAILED;

        else
        {
          sprintf(szQuery, "SET AUDIO_OUTPUT_CHANNEL_PARAMETER %d %d %s='%s'\r\n", iAudioDevice, iAudioChannel, pParam->key, pParam->value);
          enum _lscp_status_t return_value_lscp_client_query_1;
          return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
          return return_value_lscp_client_query_1;
        }
}

// lscp_set_audio_device_param
// file device.c line 542
enum _lscp_status_t lscp_set_audio_device_param(struct _lscp_client_t *pClient, signed int iAudioDevice, struct _lscp_param_t *pParam)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
    if(!(iAudioDevice >= 0))
      return (enum _lscp_status_t)LSCP_FAILED;

    else
      if(pParam == ((struct _lscp_param_t *)NULL))
        return (enum _lscp_status_t)LSCP_FAILED;

      else
      {
        sprintf(szQuery, "SET AUDIO_OUTPUT_DEVICE_PARAMETER %d %s='%s'\r\n", iAudioDevice, pParam->key, pParam->value);
        enum _lscp_status_t return_value_lscp_client_query_1;
        return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
        return return_value_lscp_client_query_1;
      }
}

// lscp_set_channel_audio_channel
// file client.c line 1529
enum _lscp_status_t lscp_set_channel_audio_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iAudioOut, signed int iAudioIn)
{
  char szQuery[1024l];
  if(!(iAudioIn >= 0) || !(iAudioOut >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET CHANNEL AUDIO_OUTPUT_CHANNEL %d %d %d\r\n", iSamplerChannel, iAudioOut, iAudioIn);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_channel_audio_device
// file client.c line 1506
enum _lscp_status_t lscp_set_channel_audio_device(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iAudioDevice)
{
  char szQuery[1024l];
  if(!(iAudioDevice >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET CHANNEL AUDIO_OUTPUT_DEVICE %d %d\r\n", iSamplerChannel, iAudioDevice);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_channel_audio_type
// file client.c line 1484
enum _lscp_status_t lscp_set_channel_audio_type(struct _lscp_client_t *pClient, signed int iSamplerChannel, const char *pszAudioDriver)
{
  char szQuery[1024l];
  if(pszAudioDriver == ((const char *)NULL) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET CHANNEL AUDIO_OUTPUT_TYPE %d %s\r\n", iSamplerChannel, pszAudioDriver);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_channel_midi_channel
// file client.c line 1618
enum _lscp_status_t lscp_set_channel_midi_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiChannel)
{
  char szQuery[1024l];
  if(iMidiChannel >= 17 || !(iMidiChannel >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    if(iMidiChannel == 16)
      sprintf(szQuery, "SET CHANNEL MIDI_INPUT_CHANNEL %d ALL\r\n", iSamplerChannel);

    else
      sprintf(szQuery, "SET CHANNEL MIDI_INPUT_CHANNEL %d %d\r\n", iSamplerChannel, iMidiChannel);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_channel_midi_device
// file client.c line 1573
enum _lscp_status_t lscp_set_channel_midi_device(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiDevice)
{
  char szQuery[1024l];
  if(!(iMidiDevice >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET CHANNEL MIDI_INPUT_DEVICE %d %d\r\n", iSamplerChannel, iMidiDevice);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_channel_midi_map
// file client.c line 1645
enum _lscp_status_t lscp_set_channel_midi_map(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiMap)
{
  char szQuery[1024l];
  unsigned long int return_value_strlen_1;
  if(!(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET CHANNEL MIDI_INSTRUMENT_MAP %d ", iSamplerChannel);
    if(iMidiMap == -1)
      strcat(szQuery, "NONE");

    else
      if(iMidiMap == -2)
        strcat(szQuery, "DEFAULT");

      else
      {
        return_value_strlen_1=strlen(szQuery);
        sprintf(szQuery + (signed long int)return_value_strlen_1, "%d", iMidiMap);
      }
    strcat(szQuery, "\r\n");
    enum _lscp_status_t return_value_lscp_client_query_2;
    return_value_lscp_client_query_2=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_2;
  }
}

// lscp_set_channel_midi_port
// file client.c line 1595
enum _lscp_status_t lscp_set_channel_midi_port(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMidiPort)
{
  char szQuery[1024l];
  if(!(iMidiPort >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET CHANNEL MIDI_INPUT_PORT %d %d\r\n", iSamplerChannel, iMidiPort);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_channel_midi_type
// file client.c line 1551
enum _lscp_status_t lscp_set_channel_midi_type(struct _lscp_client_t *pClient, signed int iSamplerChannel, const char *pszMidiDriver)
{
  char szQuery[1024l];
  if(pszMidiDriver == ((const char *)NULL) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET CHANNEL MIDI_INPUT_TYPE %d %s\r\n", iSamplerChannel, pszMidiDriver);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_channel_mute
// file client.c line 1707
enum _lscp_status_t lscp_set_channel_mute(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iMute)
{
  char szQuery[1024l];
  if(iMute >= 2 || !(iMute >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET CHANNEL MUTE %d %d\r\n", iSamplerChannel, iMute);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_channel_solo
// file client.c line 1731
enum _lscp_status_t lscp_set_channel_solo(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iSolo)
{
  char szQuery[1024l];
  if(iSolo >= 2 || !(iSamplerChannel >= 0) || !(iSolo >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET CHANNEL SOLO %d %d\r\n", iSamplerChannel, iSolo);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_channel_volume
// file client.c line 1679
enum _lscp_status_t lscp_set_channel_volume(struct _lscp_client_t *pClient, signed int iSamplerChannel, float fVolume)
{
  char szQuery[1024l];
  struct _locale_t locale;
  if(fVolume < 0.0f || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    _save_and_set_c_locale(&locale);
    sprintf(szQuery, "SET CHANNEL VOLUME %d %g\r\n", iSamplerChannel, fVolume);
    _restore_locale(&locale);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_fxsend_audio_channel
// file client.c line 2331
enum _lscp_status_t lscp_set_fxsend_audio_channel(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend, signed int iAudioSrc, signed int iAudioDst)
{
  char szQuery[1024l];
  if(!(iAudioDst >= 0) || !(iAudioSrc >= 0) || !(iFxSend >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET FX_SEND AUDIO_OUTPUT_CHANNEL %d %d %d %d\r\n", iSamplerChannel, iFxSend, iAudioSrc, iAudioDst);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_fxsend_level
// file client.c line 2378
enum _lscp_status_t lscp_set_fxsend_level(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend, float fLevel)
{
  char szQuery[1024l];
  struct _locale_t locale;
  if(fLevel < 0.0f || !(iFxSend >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    _save_and_set_c_locale(&locale);
    sprintf(szQuery, "SET FX_SEND LEVEL %d %d %f\r\n", iSamplerChannel, iFxSend, fLevel);
    _restore_locale(&locale);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_fxsend_midi_controller
// file client.c line 2355
enum _lscp_status_t lscp_set_fxsend_midi_controller(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend, signed int iMidiController)
{
  char szQuery[1024l];
  if(iMidiController >= 128 || !(iFxSend >= 0) || !(iMidiController >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET FX_SEND MIDI_CONTROLLER %d %d %d\r\n", iSamplerChannel, iFxSend, iMidiController);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_fxsend_name
// file client.c line 2307
enum _lscp_status_t lscp_set_fxsend_name(struct _lscp_client_t *pClient, signed int iSamplerChannel, signed int iFxSend, const char *pszFxName)
{
  char szQuery[1024l];
  if(pszFxName == ((const char *)NULL) || pClient == ((struct _lscp_client_t *)NULL) || !(iFxSend >= 0) || !(iSamplerChannel >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    snprintf(szQuery, (unsigned long int)1024, "SET FX_SEND NAME %d %d '%s'\r\n", iSamplerChannel, iFxSend, pszFxName);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_midi_device_param
// file device.c line 922
enum _lscp_status_t lscp_set_midi_device_param(struct _lscp_client_t *pClient, signed int iMidiDevice, struct _lscp_param_t *pParam)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
    if(!(iMidiDevice >= 0))
      return (enum _lscp_status_t)LSCP_FAILED;

    else
      if(pParam == ((struct _lscp_param_t *)NULL))
        return (enum _lscp_status_t)LSCP_FAILED;

      else
      {
        sprintf(szQuery, "SET MIDI_INPUT_DEVICE_PARAMETER %d %s='%s'\r\n", iMidiDevice, pParam->key, pParam->value);
        enum _lscp_status_t return_value_lscp_client_query_1;
        return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
        return return_value_lscp_client_query_1;
      }
}

// lscp_set_midi_instrument_map_name
// file client.c line 2579
enum _lscp_status_t lscp_set_midi_instrument_map_name(struct _lscp_client_t *pClient, signed int iMidiMap, const char *pszMapName)
{
  char szQuery[1024l];
  if(!(iMidiMap >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
    if(pszMapName == ((const char *)NULL))
      return (enum _lscp_status_t)LSCP_FAILED;

    else
    {
      sprintf(szQuery, "SET MIDI_INSTRUMENT_MAP NAME %d '%s'\r\n", iMidiMap, pszMapName);
      enum _lscp_status_t return_value_lscp_client_query_1;
      return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
      return return_value_lscp_client_query_1;
    }
}

// lscp_set_midi_port_param
// file device.c line 1006
enum _lscp_status_t lscp_set_midi_port_param(struct _lscp_client_t *pClient, signed int iMidiDevice, signed int iMidiPort, struct _lscp_param_t *pParam)
{
  char szQuery[1024l];
  if(pClient == ((struct _lscp_client_t *)NULL))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
    if(!(iMidiDevice >= 0))
      return (enum _lscp_status_t)LSCP_FAILED;

    else
      if(!(iMidiPort >= 0))
        return (enum _lscp_status_t)LSCP_FAILED;

      else
        if(pParam == ((struct _lscp_param_t *)NULL))
          return (enum _lscp_status_t)LSCP_FAILED;

        else
        {
          sprintf(szQuery, "SET MIDI_INPUT_PORT_PARAMETER %d %d %s='%s'\r\n", iMidiDevice, iMidiPort, pParam->key, pParam->value);
          enum _lscp_status_t return_value_lscp_client_query_1;
          return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
          return return_value_lscp_client_query_1;
        }
}

// lscp_set_streams
// file client.c line 2068
enum _lscp_status_t lscp_set_streams(struct _lscp_client_t *pClient, signed int iMaxStreams)
{
  char szQuery[1024l];
  if(!(iMaxStreams >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET STREAMS %d\r\n", iMaxStreams);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_voices
// file client.c line 2006
enum _lscp_status_t lscp_set_voices(struct _lscp_client_t *pClient, signed int iMaxVoices)
{
  char szQuery[1024l];
  if(!(iMaxVoices >= 1))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    sprintf(szQuery, "SET VOICES %d\r\n", iMaxVoices);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_set_volume
// file client.c line 1940
enum _lscp_status_t lscp_set_volume(struct _lscp_client_t *pClient, float fVolume)
{
  char szQuery[1024l];
  struct _locale_t locale;
  if(fVolume < 0.0f)
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    _save_and_set_c_locale(&locale);
    sprintf(szQuery, "SET VOLUME %g\r\n", fVolume);
    _restore_locale(&locale);
    enum _lscp_status_t return_value_lscp_client_query_1;
    return_value_lscp_client_query_1=lscp_client_query(pClient, szQuery);
    return return_value_lscp_client_query_1;
  }
}

// lscp_socket_agent_free
// file ../lscp/socket.h line 80
enum _lscp_status_t lscp_socket_agent_free(struct _lscp_socket_agent_t *pAgent)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  if(!(pAgent->iState == 0))
    pAgent->iState = 0;

  if(!(pAgent->sock == -1))
    close(pAgent->sock);

  pAgent->sock = -1;
  if(!(pAgent->pThread == ((struct _lscp_thread_t *)NULL)))
    ret=lscp_thread_destroy(pAgent->pThread);

  pAgent->pThread = (struct _lscp_thread_t *)(void *)0;
  return ret;
}

// lscp_socket_agent_init
// file ../lscp/socket.h line 77
void lscp_socket_agent_init(struct _lscp_socket_agent_t *pAgent, signed int sock, struct sockaddr_in *pAddr, signed int cAddr)
{
  memset((void *)pAgent, 0, sizeof(struct _lscp_socket_agent_t) /*40ul*/ );
  pAgent->sock = sock;
  pAgent->pThread = (struct _lscp_thread_t *)(void *)0;
  pAgent->iState = 0;
  if(!(pAddr == ((struct sockaddr_in *)NULL)))
    memmove((void *)(char *)&pAgent->addr, (const void *)pAddr, (unsigned long int)cAddr);

}

// lscp_socket_agent_join
// file ../lscp/socket.h line 79
enum _lscp_status_t lscp_socket_agent_join(struct _lscp_socket_agent_t *pAgent)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  if(!(pAgent->pThread == ((struct _lscp_thread_t *)NULL)))
    ret=lscp_thread_join(pAgent->pThread);

  return ret;
}

// lscp_socket_agent_start
// file ../lscp/socket.h line 78
enum _lscp_status_t lscp_socket_agent_start(struct _lscp_socket_agent_t *pAgent, void (*pfnProc)(void *), void *pvData, signed int iDetach)
{
  if(!(pAgent->iState == 0))
    pAgent->iState = 0;

  if(!(pAgent->pThread == ((struct _lscp_thread_t *)NULL)))
    lscp_thread_destroy(pAgent->pThread);

  pAgent->iState = 1;
  pAgent->pThread=lscp_thread_create(pfnProc, pvData, iDetach);
  return (enum _lscp_status_t)(pAgent->pThread == (struct _lscp_thread_t *)(void *)0 ? LSCP_FAILED : LSCP_OK);
}

// lscp_socket_getopts
// file socket.c line 153
void lscp_socket_getopts(const char *pszPrefix, signed int sock)
{
  fprintf(stderr, "%s: sock=%d:\n", pszPrefix, sock);
  _lscp_socket_getopt_bool(sock, "SO_BROADCAST", 6);
  _lscp_socket_getopt_bool(sock, "SO_DEBUG", 1);
  _lscp_socket_getopt_bool(sock, "SO_DONTROUTE", 5);
  _lscp_socket_getopt_bool(sock, "SO_KEEPALIVE", 9);
  _lscp_socket_getopt_bool(sock, "SO_OOBINLINE", 10);
  _lscp_socket_getopt_int(sock, "SO_RCVBUF", 8);
  _lscp_socket_getopt_bool(sock, "SO_REUSEADDR", 2);
  _lscp_socket_getopt_int(sock, "SO_SNDBUF", 7);
}

// lscp_socket_herror
// file socket.c line 119
void lscp_socket_herror(const char *pszPrefix)
{
  herror(pszPrefix);
}

// lscp_socket_perror
// file ../lscp/socket.h line 58
void lscp_socket_perror(const char *pszPrefix)
{
  perror(pszPrefix);
}

// lscp_socket_trace
// file ../lscp/socket.h line 62
void lscp_socket_trace(const char *pszPrefix, struct sockaddr_in *pAddr, const char *pchBuffer, signed int cchBuffer)
{
  char *pszBuffer;
  char *return_value_inet_ntoa_1;
  return_value_inet_ntoa_1=inet_ntoa(pAddr->sin_addr);
  unsigned short int return_value_htons_2;
  return_value_htons_2=htons(pAddr->sin_port);
  fprintf(stderr, "%s: addr=%s port=%d:\n", pszPrefix, return_value_inet_ntoa_1, return_value_htons_2);
  if(cchBuffer >= 1 && !(pchBuffer == ((const char *)NULL)))
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)(cchBuffer + 1));
    pszBuffer = (char *)return_value_malloc_3;
    if(!(pszBuffer == ((char *)NULL)))
    {
      memcpy((void *)pszBuffer, (const void *)pchBuffer, (unsigned long int)cchBuffer);
      for( ; cchBuffer >= 1; cchBuffer = cchBuffer - 1)
        if(!((signed int)pszBuffer[(signed long int)(cchBuffer + -1)] == 10))
        {
          if(!((signed int)pszBuffer[(signed long int)(cchBuffer + -1)] == 13))
            break;

        }

      pszBuffer[(signed long int)cchBuffer] = (char)0;
      fprintf(stderr, "< %s\n", pszBuffer);
      free((void *)pszBuffer);
    }

  }

  else
    fprintf(stderr, "< (null)\n");
}

// lscp_strtok
// file common.h line 100
char * lscp_strtok(char *pchBuffer, const char *pszSeps, char **ppch)
{
  char *pszToken;
  if(pchBuffer == ((char *)NULL))
    pchBuffer = *ppch;

  unsigned long int return_value_strspn_1;
  return_value_strspn_1=strspn(pchBuffer, pszSeps);
  pchBuffer = pchBuffer + (signed long int)return_value_strspn_1;
  char *return_value_strchr_2;
  if((signed int)*pchBuffer == 0)
    return (char *)(void *)0;

  else
  {
    pszToken = pchBuffer;
    pchBuffer=strpbrk(pszToken, pszSeps);
    if(pchBuffer == ((char *)NULL))
      *ppch=strchr(pszToken, 0);

    else
    {
      *pchBuffer = (char)0;
      *ppch = pchBuffer + (signed long int)1;
      for( ; !(*(*ppch) == 0); *ppch = *ppch + 1l)
      {
        return_value_strchr_2=strchr(pszSeps, (signed int)*(*ppch));
        if(return_value_strchr_2 == ((char *)NULL))
          break;

      }
    }
    return pszToken;
  }
}

// lscp_szsplit_create
// file common.h line 105
char ** lscp_szsplit_create(const char *pszCsv, const char *pszSeps)
{
  char *pszHead;
  char *pch;
  signed int iSize;
  signed int i;
  signed int j;
  signed int cchSeps;
  char **ppszSplit;
  char **ppszNewSplit;
  iSize = 4;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)iSize * sizeof(char *) /*8ul*/ );
  ppszSplit = (char **)return_value_malloc_1;
  signed int tmp_post_2;
  const unsigned short int **return_value___ctype_b_loc_4;
  if(ppszSplit == ((char **)NULL))
    return (char **)(void *)0;

  else
  {
    i = 0;
    pszHead = (char *)pszCsv;
    tmp_post_2 = i;
    i = i + 1;
    ppszSplit[(signed long int)tmp_post_2]=lscp_unquote(&pszHead, 1);
    if(ppszSplit[(signed long int)tmp_post_2] == ((char *)NULL))
    {
      free((void *)ppszSplit);
      return (char **)(void *)0;
    }

    else
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(pszSeps);
      cchSeps = (signed int)return_value_strlen_3;
      do
      {
        pch=strpbrk(pszHead, pszSeps);
        if(pch == ((char *)NULL))
          break;

        pszHead = pch + (signed long int)cchSeps;
        do
        {
          return_value___ctype_b_loc_4=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)pch[-1l]]) == 0)
            break;

          if(*ppszSplit >= pch)
            break;

          pch = pch - 1l;
        }
        while((_Bool)1);
        *pch = (char)0;
        ppszSplit[(signed long int)i]=lscp_unquote(&pszHead, 0);
        i = i + 1;
        if(i >= iSize)
        {
          iSize = iSize + 4;
          void *return_value_malloc_5;
          return_value_malloc_5=malloc((unsigned long int)iSize * sizeof(char *) /*8ul*/ );
          ppszNewSplit = (char **)return_value_malloc_5;
          if(!(ppszNewSplit == ((char **)NULL)))
          {
            j = 0;
            for( ; !(j >= i); j = j + 1)
              ppszNewSplit[(signed long int)j] = ppszSplit[(signed long int)j];
            free((void *)ppszSplit);
            ppszSplit = ppszNewSplit;
          }

        }

      }
      while((_Bool)1);
      for( ; !(i >= iSize); i = i + 1)
        ppszSplit[(signed long int)i] = (char *)(void *)0;
      return ppszSplit;
    }
  }
}

// lscp_szsplit_destroy
// file common.h line 106
void lscp_szsplit_destroy(char **ppszSplit)
{
  if(!(ppszSplit == ((char **)NULL)))
  {
    if(!(*ppszSplit == ((char *)NULL)))
      free((void *)ppszSplit[(signed long int)0]);

  }

  if(!(ppszSplit == ((char **)NULL)))
    free((void *)ppszSplit);

}

// lscp_thread_cancel
// file thread.c line 135
enum _lscp_status_t lscp_thread_cancel(struct _lscp_thread_t *pThread)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  signed int return_value_pthread_cancel_1;
  if(pThread == ((struct _lscp_thread_t *)NULL))
    return ret;

  else
  {
    if(!(pThread->pthread == 0ul))
    {
      return_value_pthread_cancel_1=pthread_cancel(pThread->pthread);
      if(return_value_pthread_cancel_1 == 0)
      {
        pThread->pthread = (unsigned long int)0;
        ret = (enum _lscp_status_t)LSCP_OK;
      }

    }

    return ret;
  }
}

// lscp_thread_create
// file thread.c line 63
struct _lscp_thread_t * lscp_thread_create(void (*pfnProc)(void *), void *pvData, signed int iDetach)
{
  struct _lscp_thread_t *pThread;
  union pthread_attr_t attr;
  if(pfnProc == ((void (*)(void *))NULL))
  {
    fprintf(stderr, "lcsp_thread_create: Invalid thread function.\n");
    return (struct _lscp_thread_t *)(void *)0;
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct _lscp_thread_t) /*32ul*/ );
    pThread = (struct _lscp_thread_t *)return_value_malloc_1;
    if(pThread == ((struct _lscp_thread_t *)NULL))
    {
      fprintf(stderr, "lcsp_thread_create: Out of memory.\n");
      return (struct _lscp_thread_t *)(void *)0;
    }

    else
    {
      memset((void *)pThread, 0, sizeof(struct _lscp_thread_t) /*32ul*/ );
      pThread->pvData = pvData;
      pThread->pfnProc = pfnProc;
      pThread->iDetach = iDetach;
      pthread_attr_init(&attr);
      if(!(iDetach == 0))
        pthread_attr_setdetachstate(&attr, 1);

      signed int return_value_pthread_create_2;
      return_value_pthread_create_2=pthread_create(&pThread->pthread, &attr, _lscp_thread_start, (void *)pThread);
      if(!(return_value_pthread_create_2 == 0))
      {
        fprintf(stderr, "lcsp_thread_create: Failed to create thread.\n");
        free((void *)pThread);
        return (struct _lscp_thread_t *)(void *)0;
      }

      else
        return pThread;
    }
  }
}

// lscp_thread_destroy
// file thread.c line 160
enum _lscp_status_t lscp_thread_destroy(struct _lscp_thread_t *pThread)
{
  enum _lscp_status_t ret;
  ret=lscp_thread_cancel(pThread);
  if((signed int)ret == LSCP_OK)
    ret=lscp_thread_join(pThread);

  if((signed int)ret == LSCP_OK)
    free((void *)pThread);

  return ret;
}

// lscp_thread_join
// file thread.c line 110
enum _lscp_status_t lscp_thread_join(struct _lscp_thread_t *pThread)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_FAILED;
  signed int return_value_pthread_join_1;
  if(pThread == ((struct _lscp_thread_t *)NULL))
    return ret;

  else
  {
    if(!(pThread->pthread == 0ul))
    {
      return_value_pthread_join_1=pthread_join(pThread->pthread, (void **)(void *)0);
      if(return_value_pthread_join_1 == 0)
      {
        pThread->pthread = (unsigned long int)0;
        ret = (enum _lscp_status_t)LSCP_OK;
      }

    }

    return ret;
  }
}

// lscp_unmap_midi_instrument
// file client.c line 2674
enum _lscp_status_t lscp_unmap_midi_instrument(struct _lscp_client_t *pClient, struct _lscp_midi_instrument_t *pMidiInstr)
{
  char szQuery[1024l];
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(pMidiInstr->map >= 0))
    return (enum _lscp_status_t)LSCP_FAILED;

  else
  {
    if(!(pMidiInstr->bank >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = pMidiInstr->bank > 16383 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return (enum _lscp_status_t)LSCP_FAILED;

    else
    {
      if(!(pMidiInstr->prog >= 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = pMidiInstr->prog > 127 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        return (enum _lscp_status_t)LSCP_FAILED;

      else
      {
        sprintf(szQuery, "UNMAP MIDI_INSTRUMENT %d %d %d\r\n", pMidiInstr->map, pMidiInstr->bank, pMidiInstr->prog);
        enum _lscp_status_t return_value_lscp_client_query_3;
        return_value_lscp_client_query_3=lscp_client_query(pClient, szQuery);
        return return_value_lscp_client_query_3;
      }
    }
  }
}

// lscp_unquote
// file common.h line 102
char * lscp_unquote(char **ppsz, signed int dup)
{
  char chQuote;
  char *psz = *ppsz;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*psz]) == 0)
      break;

    psz = psz + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr_6;
  if((signed int)*psz == 34)
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = (signed int)*psz == 39 ? (_Bool)1 : (_Bool)0;
  char *tmp_post_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  const unsigned short int **return_value___ctype_b_loc_4;
  char *tmp_post_5;
  if(tmp_if_expr_6)
  {
    tmp_post_2 = psz;
    psz = psz + 1l;
    chQuote = *tmp_post_2;
    do
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*psz]) == 0)
        break;

      psz = psz + 1l;
    }
    while((_Bool)1);
    if(!(dup == 0))
      psz=strdup(psz);

    *ppsz = psz;
    if(!(*ppsz == ((char *)NULL)))
    {
      for( ; !(*(*ppsz) == 0); *ppsz = *ppsz + 1l)
        if(*(*ppsz) == chQuote)
          break;

      if(!(*(*ppsz) == 0))
      {
        do
        {
          return_value___ctype_b_loc_4=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(*ppsz)[-1l]]) == 0)
            break;

          if(psz >= *ppsz)
            break;

          *ppsz = *ppsz - 1l;
        }
        while((_Bool)1);
        tmp_post_5 = *ppsz;
        *ppsz = *ppsz + 1l;
        *tmp_post_5 = (char)0;
      }

    }

  }

  else
    if(!(dup == 0))
    {
      psz=strdup(psz);
      *ppsz = psz;
    }

  return psz;
}

// lscp_unquote_dup
// file common.h line 103
void lscp_unquote_dup(char **ppszDst, char **ppszSrc)
{
  if(!(*ppszDst == ((char *)NULL)))
    free((void *)*ppszDst);

  *ppszDst = (char *)(void *)0;
  if(!(*ppszSrc == ((char *)NULL)))
    *ppszDst=lscp_unquote(ppszSrc, 1);

}

// main
// file example_server.c line 840
signed int main(signed int argc, char **argv)
{
  struct _lscp_server_t *pServer;
  char szLine[200l];
  signed int cchLine;
  struct _lscp_connect_t *p;
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  srand((unsigned int)return_value_time_1);
  pServer=lscp_server_create(8888, server_callback, (void *)0);
  char *return_value_fgets_2;
  _Bool tmp_if_expr_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_9;
  _Bool tmp_if_expr_8;
  signed int return_value_strcmp_7;
  unsigned long int return_value_strlen_6;
  if(pServer == ((struct _lscp_server_t *)NULL))
    return -1;

  else
  {
    server_usage();
    server_prompt();
    do
    {
      return_value_fgets_2=fgets(szLine, (signed int)sizeof(char [200l]) /*200ul*/ , stdin);
      if(return_value_fgets_2 == ((char *)NULL))
        break;

      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(szLine);
      cchLine = (signed int)return_value_strlen_3;
      for( ; cchLine >= 1; cchLine = cchLine - 1)
        if(!((signed int)szLine[(signed long int)(cchLine + -1)] == 10))
        {
          if(!((signed int)szLine[(signed long int)(cchLine + -1)] == 13))
            break;

        }

      szLine[(signed long int)cchLine] = (char)0;
      signed int return_value_strcmp_10;
      return_value_strcmp_10=strcmp(szLine, "exit");
      if(return_value_strcmp_10 == 0)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_strcmp_11=strcmp(szLine, "quit");
        tmp_if_expr_12 = return_value_strcmp_11 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        break;

      else
      {
        return_value_strcmp_9=strcmp(szLine, "list");
        if(return_value_strcmp_9 == 0)
        {
          p = pServer->connects.first;
          for( ; !(p == ((struct _lscp_connect_t *)NULL)); p = p->next)
          {
            char *return_value_inet_ntoa_4;
            return_value_inet_ntoa_4=inet_ntoa(p->client.addr.sin_addr);
            unsigned short int return_value_ntohs_5;
            return_value_ntohs_5=ntohs(p->client.addr.sin_port);
            printf("client: sock=%d addr=%s port=%d events=0x%04x.\n", p->client.sock, return_value_inet_ntoa_4, return_value_ntohs_5, (signed int)p->events);
          }
        }

        else
        {
          if(cchLine >= 1)
          {
            return_value_strcmp_7=strcmp(szLine, "help");
            tmp_if_expr_8 = return_value_strcmp_7 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_8 = (_Bool)0;
          if(tmp_if_expr_8)
          {
            return_value_strlen_6=strlen(szLine);
            lscp_server_broadcast(pServer, (enum _lscp_event_t)LSCP_EVENT_MISCELLANEOUS, szLine, (signed int)return_value_strlen_6);
          }

          else
            server_usage();
        }
      }
      server_prompt();
    }
    while((_Bool)1);
    lscp_server_destroy(pServer);
    return 0;
  }
}

// server_callback
// file example_server.c line 37
enum _lscp_status_t server_callback(struct _lscp_connect_t *pConnect, const char *pchBuffer, signed int cchBuffer, void *pvData)
{
  enum _lscp_status_t ret = (enum _lscp_status_t)LSCP_OK;
  struct _lscp_parser_t tok;
  const char *pszResult = (const char *)(void *)0;
  char szTemp[4096l];
  signed int i;
  if(pchBuffer == ((const char *)NULL))
  {
    char *return_value_inet_ntoa_1;
    return_value_inet_ntoa_1=inet_ntoa(pConnect->client.addr.sin_addr);
    unsigned short int return_value_htons_2;
    return_value_htons_2=htons(pConnect->client.addr.sin_port);
    fprintf(stderr, "server_callback: addr=%s port=%d: ", return_value_inet_ntoa_1, return_value_htons_2);
    switch(cchBuffer)
    {
      case 0:
      {
        fprintf(stderr, "New client connection.\n");
        break;
      }
      case 1:
        fprintf(stderr, "Connection closed.\n");
    }
    return ret;
  }

  lscp_socket_trace("server_callback", &pConnect->client.addr, pchBuffer, cchBuffer);
  lscp_parser_init(&tok, pchBuffer, cchBuffer);
  signed int return_value_lscp_parser_test_163;
  return_value_lscp_parser_test_163=lscp_parser_test(&tok, "GET");
  signed int return_value_lscp_parser_test_14;
  signed int return_value_lscp_parser_test_13;
  signed int return_value_lscp_parser_test_12;
  signed int return_value_lscp_parser_test_10;
  signed int return_value_lscp_parser_test_74;
  signed int return_value_lscp_parser_test_73;
  signed int return_value_lscp_parser_test_72;
  signed int return_value_lscp_parser_test2_71;
  signed int return_value_lscp_parser_test_16;
  signed int return_value_lscp_parser_test2_70;
  signed int return_value_lscp_parser_test2_69;
  signed int return_value_lscp_parser_test_20;
  signed int return_value_lscp_parser_test_19;
  signed int return_value_lscp_parser_test_25;
  signed int return_value_lscp_parser_test_23;
  signed int return_value_lscp_parser_test_22;
  signed int return_value_lscp_parser_test2_68;
  signed int return_value_lscp_parser_test_27;
  signed int return_value_lscp_parser_test2_67;
  signed int return_value_lscp_parser_test2_66;
  signed int return_value_lscp_parser_test2_65;
  signed int return_value_lscp_parser_test2_64;
  signed int return_value_lscp_parser_test2_63;
  signed int return_value_lscp_parser_test_34;
  signed int return_value_lscp_parser_test2_62;
  signed int return_value_lscp_parser_test_61;
  signed int return_value_lscp_parser_test_60;
  signed int return_value_lscp_parser_test_59;
  signed int return_value_lscp_parser_test2_58;
  signed int return_value_lscp_parser_test2_57;
  signed int return_value_lscp_parser_test_43;
  signed int return_value_lscp_parser_test_42;
  signed int return_value_lscp_parser_test_56;
  signed int return_value_lscp_parser_test_55;
  signed int return_value_lscp_parser_test_54;
  signed int return_value_lscp_parser_test2_53;
  signed int return_value_lscp_parser_test_52;
  signed int return_value_lscp_parser_test_51;
  signed int return_value_lscp_parser_test_50;
  signed int return_value_lscp_parser_test2_49;
  signed int return_value_lscp_parser_test2_48;
  signed int return_value_lscp_parser_test_162;
  _Bool tmp_if_expr_77;
  unsigned long int return_value_strlen_76;
  signed int return_value_lscp_parser_test_101;
  signed int return_value_lscp_parser_test_100;
  signed int return_value_lscp_parser_test_99;
  signed int return_value_lscp_parser_test_98;
  _Bool tmp_if_expr_80;
  unsigned long int return_value_strlen_79;
  signed int return_value_lscp_parser_test_97;
  _Bool tmp_if_expr_83;
  unsigned long int return_value_strlen_82;
  signed int return_value_lscp_parser_test_96;
  _Bool tmp_if_expr_86;
  unsigned long int return_value_strlen_85;
  signed int return_value_lscp_parser_test_95;
  _Bool tmp_if_expr_89;
  unsigned long int return_value_strlen_88;
  signed int return_value_lscp_parser_test_94;
  _Bool tmp_if_expr_92;
  unsigned long int return_value_strlen_91;
  signed int return_value_lscp_parser_test_161;
  signed int return_value_lscp_parser_test_112;
  signed int return_value_lscp_parser_test_111;
  signed int return_value_lscp_parser_test_110;
  signed int return_value_lscp_parser_test_109;
  signed int return_value_lscp_parser_test_108;
  signed int return_value_lscp_parser_test_107;
  signed int return_value_lscp_parser_test_106;
  signed int return_value_lscp_parser_test_105;
  signed int return_value_lscp_parser_test_104;
  signed int return_value_lscp_parser_test_103;
  signed int return_value_lscp_parser_test_119;
  signed int return_value_lscp_parser_test_118;
  signed int return_value_lscp_parser_test_115;
  signed int return_value_lscp_parser_test_114;
  signed int return_value_lscp_parser_test2_117;
  signed int return_value_lscp_parser_test_160;
  signed int return_value_lscp_parser_test_121;
  signed int return_value_lscp_parser_test_159;
  signed int tmp_post_123;
  signed int return_value_lscp_parser_test_125;
  signed int tmp_post_124;
  signed int return_value_lscp_parser_test_158;
  signed int return_value_lscp_parser_test_129;
  signed int return_value_lscp_parser_test_157;
  signed int return_value_lscp_parser_test_156;
  signed int tmp_post_133;
  signed int return_value_lscp_parser_test_137;
  signed int tmp_post_134;
  signed int return_value_lscp_parser_test_136;
  signed int tmp_post_135;
  signed int return_value_lscp_parser_test_155;
  signed int return_value_lscp_parser_test_143;
  signed int return_value_lscp_parser_test_142;
  signed int return_value_lscp_parser_test2_154;
  signed int return_value_lscp_parser_test2_153;
  signed int return_value_lscp_parser_test2_152;
  signed int return_value_lscp_parser_test_151;
  signed int return_value_lscp_parser_test_150;
  signed int return_value_lscp_parser_test_149;
  static signed int iMidiMaps = 0;
  static signed int iMidiInstruments = 0;
  static signed int iFxSend = 0;
  static float fVolume = 1.0f;
  static signed int iMidiDevice = 0;
  static signed int iAudioDevice = 0;
  static signed int iSamplerChannel = 0;
  if(!(return_value_lscp_parser_test_163 == 0))
  {
    signed int return_value_lscp_parser_test_75;
    return_value_lscp_parser_test_75=lscp_parser_test(&tok, "CHANNEL");
    if(!(return_value_lscp_parser_test_75 == 0))
    {
      signed int return_value_lscp_parser_test_15;
      return_value_lscp_parser_test_15=lscp_parser_test(&tok, "INFO");
      if(!(return_value_lscp_parser_test_15 == 0))
        pszResult = "ENGINE_NAME: DummyEngine\r\nINSTRUMENT_FILE: DummyInstrument.gig\r\nINSTRUMENT_NR: 0\r\nINSTRUMENT_NAME: Dummy Instrument\r\nINSTRUMENT_STATUS: 100\r\nAUDIO_OUTPUT_DEVICE: 0\r\nAUDIO_OUTPUT_CHANNELS: 2\r\nAUDIO_OUTPUT_ROUTING: 0,1\r\nMIDI_INPUT_DEVICE: 0\r\nMIDI_INPUT_PORT: 0\r\nMIDI_INPUT_CHANNEL: ALL\r\nVOLUME: 0.5\r\nMUTE: FALSE\r\nSOLO: TRUE\r\n.\r\n";

      else
      {
        return_value_lscp_parser_test_14=lscp_parser_test(&tok, "VOICE_COUNT");
        if(!(return_value_lscp_parser_test_14 == 0))
        {
          signed int return_value_rand_3;
          return_value_rand_3=rand();
          sprintf(szTemp, "%d\r\n", return_value_rand_3 % 100);
          pszResult = szTemp;
        }

        else
        {
          return_value_lscp_parser_test_13=lscp_parser_test(&tok, "STREAM_COUNT");
          if(!(return_value_lscp_parser_test_13 == 0))
            pszResult = "3\r\n";

          else
          {
            return_value_lscp_parser_test_12=lscp_parser_test(&tok, "BUFFER_FILL");
            if(!(return_value_lscp_parser_test_12 == 0))
            {
              signed int return_value_lscp_parser_test_11;
              return_value_lscp_parser_test_11=lscp_parser_test(&tok, "BYTES");
              if(!(return_value_lscp_parser_test_11 == 0))
              {
                signed int return_value_rand_4;
                return_value_rand_4=rand();
                signed int return_value_rand_5;
                return_value_rand_5=rand();
                signed int return_value_rand_6;
                return_value_rand_6=rand();
                sprintf(szTemp, "[1]%d,[2]%d,[3]%d\r\n", return_value_rand_4, return_value_rand_5, return_value_rand_6);
                pszResult = szTemp;
              }

              else
              {
                return_value_lscp_parser_test_10=lscp_parser_test(&tok, "PERCENTAGE");
                if(!(return_value_lscp_parser_test_10 == 0))
                {
                  signed int return_value_rand_7;
                  return_value_rand_7=rand();
                  signed int return_value_rand_8;
                  return_value_rand_8=rand();
                  signed int return_value_rand_9;
                  return_value_rand_9=rand();
                  sprintf(szTemp, "[1]%d%%,[2]%d%%,[3]%d%%\r\n", return_value_rand_7 % 100, return_value_rand_8 % 100, return_value_rand_9 % 100);
                  pszResult = szTemp;
                }

                else
                  ret = (enum _lscp_status_t)LSCP_FAILED;
              }
            }

            else
              ret = (enum _lscp_status_t)LSCP_FAILED;
          }
        }
      }
    }

    else
    {
      return_value_lscp_parser_test_74=lscp_parser_test(&tok, "CHANNELS");
      if(!(return_value_lscp_parser_test_74 == 0))
      {
        sprintf(szTemp, "%d\r\n", iSamplerChannel);
        pszResult = szTemp;
      }

      else
      {
        return_value_lscp_parser_test_73=lscp_parser_test(&tok, "AVAILABLE_AUDIO_OUTPUT_DRIVERS");
        if(!(return_value_lscp_parser_test_73 == 0))
          pszResult = "2\r\n";

        else
        {
          return_value_lscp_parser_test_72=lscp_parser_test(&tok, "AVAILABLE_MIDI_INPUT_DRIVERS");
          if(!(return_value_lscp_parser_test_72 == 0))
            pszResult = "1\r\n";

          else
          {
            return_value_lscp_parser_test2_71=lscp_parser_test2(&tok, "AUDIO_OUTPUT_DRIVER", "INFO");
            if(!(return_value_lscp_parser_test2_71 == 0))
            {
              signed int return_value_lscp_parser_test_17;
              return_value_lscp_parser_test_17=lscp_parser_test(&tok, "Alsa");
              if(!(return_value_lscp_parser_test_17 == 0))
                pszResult = "DESCRIPTION: 'ALSA PCM'\r\nVERSION: '1.0'\r\nPARAMETERS: channels,samplerate,active\r\n.\r\n";

              else
              {
                return_value_lscp_parser_test_16=lscp_parser_test(&tok, "Jack");
                if(!(return_value_lscp_parser_test_16 == 0))
                  pszResult = "DESCRIPTION: JACK Audio Connection Kit\r\nVERSION: 0.98.1\r\nPARAMETERS: channels,samplerate,active\r\n.\r\n";

                else
                  ret = (enum _lscp_status_t)LSCP_FAILED;
              }
            }

            else
            {
              return_value_lscp_parser_test2_70=lscp_parser_test2(&tok, "MIDI_INPUT_DRIVER", "INFO");
              if(!(return_value_lscp_parser_test2_70 == 0))
              {
                signed int return_value_lscp_parser_test_18;
                return_value_lscp_parser_test_18=lscp_parser_test(&tok, "Alsa");
                if(!(return_value_lscp_parser_test_18 == 0))
                  pszResult = "DESCRIPTION: ALSA Sequencer\r\nVERSION: 1.0\r\nPARAMETERS: ports,active\r\n.\r\n";

                else
                  ret = (enum _lscp_status_t)LSCP_FAILED;
              }

              else
              {
                return_value_lscp_parser_test2_69=lscp_parser_test2(&tok, "AUDIO_OUTPUT_DRIVER_PARAMETER", "INFO");
                if(!(return_value_lscp_parser_test2_69 == 0))
                {
                  signed int return_value_lscp_parser_test_26;
                  return_value_lscp_parser_test_26=lscp_parser_test(&tok, "Alsa");
                  if(!(return_value_lscp_parser_test_26 == 0))
                  {
                    signed int return_value_lscp_parser_test_21;
                    return_value_lscp_parser_test_21=lscp_parser_test(&tok, "active");
                    if(!(return_value_lscp_parser_test_21 == 0))
                      pszResult = "DESCRIPTION: 'ALSA PCM active state'\r\nTYPE: BOOL\r\nMANDATORY: TRUE\r\nFIX: TRUE\r\nMULTIPLICITY: FALSE\r\nDEPENDS: channels,samplerate,card\r\nDEFAULT: TRUE\r\nRANGE_MIN: FALSE\r\nRANGE_MAX: TRUE\r\nPOSSIBILITIES: FALSE,TRUE\r\n.\r\n";

                    else
                    {
                      return_value_lscp_parser_test_20=lscp_parser_test(&tok, "channels");
                      if(!(return_value_lscp_parser_test_20 == 0))
                        pszResult = "DESCRIPTION: 'Number of ALSA PCM channels'\r\nTYPE: INT\r\nMANDATORY: TRUE\r\nFIX: TRUE\r\nMULTIPLICITY: FALSE\r\nDEFAULT: 2\r\n.\r\n";

                      else
                      {
                        return_value_lscp_parser_test_19=lscp_parser_test(&tok, "samplerate");
                        if(!(return_value_lscp_parser_test_19 == 0))
                          pszResult = "DESCRIPTION: 'ALSA PCM sample rate'\r\nTYPE: INT\r\nMANDATORY: TRUE\r\nFIX: TRUE\r\nMULTIPLICITY: TRUE\r\nDEFAULT: 44100\r\nPOSSIBILITIES: 44100,48000,96000\r\n.\r\n";

                        else
                          ret = (enum _lscp_status_t)LSCP_FAILED;
                      }
                    }
                  }

                  else
                  {
                    return_value_lscp_parser_test_25=lscp_parser_test(&tok, "Jack");
                    if(!(return_value_lscp_parser_test_25 == 0))
                    {
                      signed int return_value_lscp_parser_test_24;
                      return_value_lscp_parser_test_24=lscp_parser_test(&tok, "active");
                      if(!(return_value_lscp_parser_test_24 == 0))
                        pszResult = "DESCRIPTION: 'JACK active state'\r\nTYPE: BOOL\r\nMANDATORY: TRUE\r\nFIX: TRUE\r\nMULTIPLICITY: FALSE\r\nDEPENDS: channels,samplerate\r\nDEFAULT: TRUE\r\nRANGE_MIN: FALSE\r\nRANGE_MAX: TRUE\r\nPOSSIBILITIES: FALSE,TRUE\r\n.\r\n";

                      else
                      {
                        return_value_lscp_parser_test_23=lscp_parser_test(&tok, "channels");
                        if(!(return_value_lscp_parser_test_23 == 0))
                          pszResult = "DESCRIPTION: 'Number of JACK audio channels'\r\nTYPE: INT\r\nMANDATORY: TRUE\r\nFIX: TRUE\r\nMULTIPLICITY: FALSE\r\nDEFAULT: 2\r\n.\r\n";

                        else
                        {
                          return_value_lscp_parser_test_22=lscp_parser_test(&tok, "samplerate");
                          if(!(return_value_lscp_parser_test_22 == 0))
                            pszResult = "DESCRIPTION: 'JACK sample rate'\r\nTYPE: INT\r\nMANDATORY: TRUE\r\nFIX: TRUE\r\nMULTIPLICITY: TRUE\r\nDEFAULT: 44100\r\nPOSSIBILITIES: 44100,48000,96000\r\n.\r\n";

                          else
                            ret = (enum _lscp_status_t)LSCP_FAILED;
                        }
                      }
                    }

                    else
                      ret = (enum _lscp_status_t)LSCP_FAILED;
                  }
                }

                else
                {
                  return_value_lscp_parser_test2_68=lscp_parser_test2(&tok, "MIDI_INPUT_DRIVER_PARAMETER", "INFO");
                  if(!(return_value_lscp_parser_test2_68 == 0))
                  {
                    signed int return_value_lscp_parser_test_29;
                    return_value_lscp_parser_test_29=lscp_parser_test(&tok, "Alsa");
                    if(!(return_value_lscp_parser_test_29 == 0))
                    {
                      signed int return_value_lscp_parser_test_28;
                      return_value_lscp_parser_test_28=lscp_parser_test(&tok, "active");
                      if(!(return_value_lscp_parser_test_28 == 0))
                        pszResult = "DESCRIPTION: 'ALSA Sequencer device active state'\r\nTYPE: BOOL\r\nMANDATORY: TRUE\r\nFIX: TRUE\r\nMULTIPLICITY: FALSE\r\nDEPENDS: channels,ports\r\nDEFAULT: TRUE\r\nRANGE_MIN: FALSE\r\nRANGE_MAX: TRUE\r\nPOSSIBILITIES: FALSE,TRUE\r\n.\r\n";

                      else
                      {
                        return_value_lscp_parser_test_27=lscp_parser_test(&tok, "ports");
                        if(!(return_value_lscp_parser_test_27 == 0))
                          pszResult = "DESCRIPTION: 'Number of ALSA Sequencer ports'\r\nTYPE: INT\r\nMANDATORY: FALSE\r\nFIX: FALSE\r\nMULTIPLICITY: FALSE\r\nDEFAULT: 1\r\nRANGE_MIN: 1\r\nRANGE_MAX: 4\r\n.\r\n";

                        else
                          ret = (enum _lscp_status_t)LSCP_FAILED;
                      }
                    }

                    else
                      ret = (enum _lscp_status_t)LSCP_FAILED;
                  }

                  else
                  {
                    return_value_lscp_parser_test2_67=lscp_parser_test2(&tok, "AUDIO_OUTPUT_DEVICE", "INFO");
                    if(!(return_value_lscp_parser_test2_67 == 0))
                    {
                      signed int return_value_lscp_parser_nextint_30;
                      return_value_lscp_parser_nextint_30=lscp_parser_nextint(&tok);
                      if(!(return_value_lscp_parser_nextint_30 >= iAudioDevice))
                        pszResult = "driver: Alsa\r\nactive: TRUE\r\nchannels: 2\r\nsamplerate: 44100\r\n.\r\n";

                      else
                        ret = (enum _lscp_status_t)LSCP_FAILED;
                    }

                    else
                    {
                      return_value_lscp_parser_test2_66=lscp_parser_test2(&tok, "MIDI_INPUT_DEVICE", "INFO");
                      if(!(return_value_lscp_parser_test2_66 == 0))
                      {
                        signed int return_value_lscp_parser_nextint_31;
                        return_value_lscp_parser_nextint_31=lscp_parser_nextint(&tok);
                        if(!(return_value_lscp_parser_nextint_31 >= iMidiDevice))
                          pszResult = "driver: Alsa\r\nactive: TRUE\r\nchannels: 16\r\nports: 1\r\n.\r\n";

                        else
                          ret = (enum _lscp_status_t)LSCP_FAILED;
                      }

                      else
                      {
                        return_value_lscp_parser_test2_65=lscp_parser_test2(&tok, "AUDIO_OUTPUT_CHANNEL", "INFO");
                        if(!(return_value_lscp_parser_test2_65 == 0))
                        {
                          signed int return_value_lscp_parser_nextint_32;
                          return_value_lscp_parser_nextint_32=lscp_parser_nextint(&tok);
                          if(!(return_value_lscp_parser_nextint_32 >= iAudioDevice))
                            pszResult = "name: DummyMonitor\r\nis_mix_channel: FALSE\r\nmix_channel_destination: 0\r\n.\r\n";

                          else
                            ret = (enum _lscp_status_t)LSCP_FAILED;
                        }

                        else
                        {
                          return_value_lscp_parser_test2_64=lscp_parser_test2(&tok, "MIDI_INPUT_PORT", "INFO");
                          if(!(return_value_lscp_parser_test2_64 == 0))
                          {
                            signed int return_value_lscp_parser_nextint_33;
                            return_value_lscp_parser_nextint_33=lscp_parser_nextint(&tok);
                            if(!(return_value_lscp_parser_nextint_33 >= iMidiDevice))
                              pszResult = "name: DummyKeyboard\r\nalsa_seq_bindings: '64:0'\r\n.\r\n";

                            else
                              ret = (enum _lscp_status_t)LSCP_FAILED;
                          }

                          else
                          {
                            return_value_lscp_parser_test2_63=lscp_parser_test2(&tok, "AUDIO_OUTPUT_CHANNEL_PARAMETER", "INFO");
                            if(!(return_value_lscp_parser_test2_63 == 0))
                            {
                              signed int return_value_lscp_parser_nextint_36;
                              return_value_lscp_parser_nextint_36=lscp_parser_nextint(&tok);
                              if(!(return_value_lscp_parser_nextint_36 >= iAudioDevice))
                              {
                                lscp_parser_nextint(&tok);
                                signed int return_value_lscp_parser_test_35;
                                return_value_lscp_parser_test_35=lscp_parser_test(&tok, "is_mix_channel");
                                if(!(return_value_lscp_parser_test_35 == 0))
                                  pszResult = "DESCRIPTION: 'Whether this is an audio mix channel'\r\nTYPE: BOOL\r\nMANDATORY: TRUE\r\nFIX: FALSE\r\nMULTIPLICITY: FALSE\r\nPOSSIBILITIES: FALSE,TRUE\r\n.\r\n";

                                else
                                {
                                  return_value_lscp_parser_test_34=lscp_parser_test(&tok, "mix_channel_destination");
                                  if(!(return_value_lscp_parser_test_34 == 0))
                                    pszResult = "DESCRIPTION: 'Audio mix channel destination'\r\nTYPE: INT\r\nMANDATORY: TRUE\r\nFIX: FALSE\r\nMULTIPLICITY: TRUE\r\nPOSSIBILITIES: 0,1\r\n.\r\n";

                                  else
                                    ret = (enum _lscp_status_t)LSCP_FAILED;
                                }
                              }

                              else
                                ret = (enum _lscp_status_t)LSCP_FAILED;
                            }

                            else
                            {
                              return_value_lscp_parser_test2_62=lscp_parser_test2(&tok, "MIDI_INPUT_PORT_PARAMETER", "INFO");
                              if(!(return_value_lscp_parser_test2_62 == 0))
                              {
                                signed int return_value_lscp_parser_nextint_38;
                                return_value_lscp_parser_nextint_38=lscp_parser_nextint(&tok);
                                if(!(return_value_lscp_parser_nextint_38 >= iMidiDevice))
                                {
                                  lscp_parser_nextint(&tok);
                                  signed int return_value_lscp_parser_test_37;
                                  return_value_lscp_parser_test_37=lscp_parser_test(&tok, "alsa_seq_bindings");
                                  if(!(return_value_lscp_parser_test_37 == 0))
                                    pszResult = "DESCRIPTION: 'Alsa sequencer port bindings'\r\nTYPE: STRING\r\nMANDATORY: TRUE\r\nFIX: FALSE\r\nMULTIPLICITY: TRUE\r\nPOSSIBILITIES: '64:0','68:0','68:1'\r\n.\r\n";

                                  else
                                    ret = (enum _lscp_status_t)LSCP_FAILED;
                                }

                                else
                                  ret = (enum _lscp_status_t)LSCP_FAILED;
                              }

                              else
                              {
                                return_value_lscp_parser_test_61=lscp_parser_test(&tok, "AUDIO_OUTPUT_DEVICES");
                                if(!(return_value_lscp_parser_test_61 == 0))
                                {
                                  sprintf(szTemp, "%d\r\n", iAudioDevice);
                                  pszResult = szTemp;
                                }

                                else
                                {
                                  return_value_lscp_parser_test_60=lscp_parser_test(&tok, "MIDI_INPUT_DEVICES");
                                  if(!(return_value_lscp_parser_test_60 == 0))
                                  {
                                    sprintf(szTemp, "%d\r\n", iMidiDevice);
                                    pszResult = szTemp;
                                  }

                                  else
                                  {
                                    return_value_lscp_parser_test_59=lscp_parser_test(&tok, "AVAILABLE_ENGINES");
                                    if(!(return_value_lscp_parser_test_59 == 0))
                                      pszResult = "3\r\n";

                                    else
                                    {
                                      return_value_lscp_parser_test2_58=lscp_parser_test2(&tok, "SERVER", "INFO");
                                      if(!(return_value_lscp_parser_test2_58 == 0))
                                      {
                                        const char *return_value_lscp_server_package_39;
                                        return_value_lscp_server_package_39=lscp_server_package();
                                        const char *return_value_lscp_server_build_40;
                                        return_value_lscp_server_build_40=lscp_server_build();
                                        const char *return_value_lscp_server_version_41;
                                        return_value_lscp_server_version_41=lscp_server_version();
                                        sprintf(szTemp, "DESCRIPTION: example_server (%s) %s\r\nVERSION: %s\r\n.\r\n", return_value_lscp_server_package_39, return_value_lscp_server_build_40, return_value_lscp_server_version_41);
                                        pszResult = szTemp;
                                      }

                                      else
                                      {
                                        return_value_lscp_parser_test2_57=lscp_parser_test2(&tok, "ENGINE", "INFO");
                                        if(!(return_value_lscp_parser_test2_57 == 0))
                                        {
                                          signed int return_value_lscp_parser_test_44;
                                          return_value_lscp_parser_test_44=lscp_parser_test(&tok, "GigEngine");
                                          if(!(return_value_lscp_parser_test_44 == 0))
                                            pszResult = "DESCRIPTION: GigaSampler Engine\r\nVERSION: 0.3\r\n.\r\n";

                                          else
                                          {
                                            return_value_lscp_parser_test_43=lscp_parser_test(&tok, "DLSEngine");
                                            if(!(return_value_lscp_parser_test_43 == 0))
                                              pszResult = "DESCRIPTION: 'DLS Generic Engine'\r\nVERSION: 0.2\r\n.\r\n";

                                            else
                                            {
                                              return_value_lscp_parser_test_42=lscp_parser_test(&tok, "AkaiEngine");
                                              if(!(return_value_lscp_parser_test_42 == 0))
                                                pszResult = "DESCRIPTION: Akai Sampler Engine\r\nVERSION: 0.1\r\n.\r\n";

                                              else
                                                ret = (enum _lscp_status_t)LSCP_FAILED;
                                            }
                                          }
                                        }

                                        else
                                        {
                                          return_value_lscp_parser_test_56=lscp_parser_test(&tok, "TOTAL_VOICE_COUNT");
                                          if(!(return_value_lscp_parser_test_56 == 0))
                                          {
                                            signed int return_value_rand_45;
                                            return_value_rand_45=rand();
                                            sprintf(szTemp, "%d\r\n", return_value_rand_45 % 100);
                                            pszResult = szTemp;
                                          }

                                          else
                                          {
                                            return_value_lscp_parser_test_55=lscp_parser_test(&tok, "TOTAL_VOICE_COUNT_MAX");
                                            if(!(return_value_lscp_parser_test_55 == 0))
                                            {
                                              signed int return_value_rand_46;
                                              return_value_rand_46=rand();
                                              sprintf(szTemp, "%d\r\n", return_value_rand_46 % 100);
                                              pszResult = szTemp;
                                            }

                                            else
                                            {
                                              return_value_lscp_parser_test_54=lscp_parser_test(&tok, "VOLUME");
                                              if(!(return_value_lscp_parser_test_54 == 0))
                                              {
                                                sprintf(szTemp, "%g\r\n", fVolume);
                                                pszResult = szTemp;
                                              }

                                              else
                                              {
                                                return_value_lscp_parser_test2_53=lscp_parser_test2(&tok, "FX_SEND", "INFO");
                                                if(!(return_value_lscp_parser_test2_53 == 0))
                                                  pszResult = "NAME: DummyFxSend\r\nMIDI_CONTROLLER: 99\r\nAUDIO_OUTPUT_ROUTING: 0,1\r\nLEVEL: 0.15\r\n.\r\n";

                                                else
                                                {
                                                  return_value_lscp_parser_test_52=lscp_parser_test(&tok, "FX_SENDS");
                                                  if(!(return_value_lscp_parser_test_52 == 0))
                                                  {
                                                    sprintf(szTemp, "%d\r\n", iFxSend);
                                                    pszResult = szTemp;
                                                  }

                                                  else
                                                  {
                                                    return_value_lscp_parser_test_51=lscp_parser_test(&tok, "MIDI_INSTRUMENTS");
                                                    if(!(return_value_lscp_parser_test_51 == 0))
                                                    {
                                                      sprintf(szTemp, "%d\r\n", iMidiInstruments);
                                                      pszResult = szTemp;
                                                    }

                                                    else
                                                    {
                                                      return_value_lscp_parser_test_50=lscp_parser_test(&tok, "MIDI_INSTRUMENT_MAPS");
                                                      if(!(return_value_lscp_parser_test_50 == 0))
                                                      {
                                                        sprintf(szTemp, "%d\r\n", iMidiMaps);
                                                        pszResult = szTemp;
                                                      }

                                                      else
                                                      {
                                                        return_value_lscp_parser_test2_49=lscp_parser_test2(&tok, "MIDI_INSTRUMENT_MAP", "INFO");
                                                        if(!(return_value_lscp_parser_test2_49 == 0))
                                                        {
                                                          strcpy(szTemp, "NAME: ");
                                                          signed int return_value_lscp_parser_nextint_47;
                                                          return_value_lscp_parser_nextint_47=lscp_parser_nextint(&tok);
                                                          switch(return_value_lscp_parser_nextint_47)
                                                          {
                                                            case 0:
                                                            {
                                                              strcat(szTemp, "Chromatic\r\n");
                                                              break;
                                                            }
                                                            case 1:
                                                              strcat(szTemp, "Drum Kits\r\n");
                                                          }
                                                          strcat(szTemp, ".\r\n");
                                                          pszResult = szTemp;
                                                        }

                                                        else
                                                        {
                                                          return_value_lscp_parser_test2_48=lscp_parser_test2(&tok, "MIDI_INSTRUMENT", "INFO");
                                                          if(!(return_value_lscp_parser_test2_48 == 0))
                                                            pszResult = "NAME: DummyName\r\nENGINE_NAME: DummyEngine\r\nINSTRUMENT_FILE: DummyInstrument.gig\r\nINSTRUMENT_NR: 0\r\nINSTRUMENT_NAME: Dummy Instrument\r\nLOAD_MODE: ON_DEMAND\r\nVOLUME: 0.5\r\n.\r\n";

                                                          else
                                                            ret = (enum _lscp_status_t)LSCP_FAILED;
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  else
  {
    return_value_lscp_parser_test_162=lscp_parser_test(&tok, "LIST");
    if(!(return_value_lscp_parser_test_162 == 0))
    {
      signed int return_value_lscp_parser_test_102;
      return_value_lscp_parser_test_102=lscp_parser_test(&tok, "CHANNELS");
      if(!(return_value_lscp_parser_test_102 == 0))
      {
        szTemp[(signed long int)0] = (char)0;
        i = 0;
        do
        {
          if(!(i >= iSamplerChannel))
          {
            return_value_strlen_76=strlen(szTemp);
            tmp_if_expr_77 = return_value_strlen_76 < sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)8 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_77 = (_Bool)0;
          if(!tmp_if_expr_77)
            break;

          if(i >= 1)
            strcat(szTemp, ",");

          unsigned long int return_value_strlen_78;
          return_value_strlen_78=strlen(szTemp);
          sprintf(szTemp + (signed long int)return_value_strlen_78, "%d", i);
          i = i + 1;
        }
        while((_Bool)1);
        strcat(szTemp, "\r\n");
        pszResult = szTemp;
      }

      else
      {
        return_value_lscp_parser_test_101=lscp_parser_test(&tok, "AVAILABLE_ENGINES");
        if(!(return_value_lscp_parser_test_101 == 0))
          pszResult = "GigEngine,DLSEngine,AkaiEngine\r\n";

        else
        {
          return_value_lscp_parser_test_100=lscp_parser_test(&tok, "AVAILABLE_AUDIO_OUTPUT_DRIVERS");
          if(!(return_value_lscp_parser_test_100 == 0))
            pszResult = "ALSA,JACK\r\n";

          else
          {
            return_value_lscp_parser_test_99=lscp_parser_test(&tok, "AVAILABLE_MIDI_INPUT_DRIVERS");
            if(!(return_value_lscp_parser_test_99 == 0))
              pszResult = "ALSA\r\n";

            else
            {
              return_value_lscp_parser_test_98=lscp_parser_test(&tok, "AUDIO_OUTPUT_DEVICES");
              if(!(return_value_lscp_parser_test_98 == 0))
              {
                szTemp[(signed long int)0] = (char)0;
                i = 0;
                do
                {
                  if(!(i >= iAudioDevice))
                  {
                    return_value_strlen_79=strlen(szTemp);
                    tmp_if_expr_80 = return_value_strlen_79 < sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)8 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_80 = (_Bool)0;
                  if(!tmp_if_expr_80)
                    break;

                  if(i >= 1)
                    strcat(szTemp, ",");

                  unsigned long int return_value_strlen_81;
                  return_value_strlen_81=strlen(szTemp);
                  sprintf(szTemp + (signed long int)return_value_strlen_81, "%d", i);
                  i = i + 1;
                }
                while((_Bool)1);
                strcat(szTemp, "\r\n");
                pszResult = szTemp;
              }

              else
              {
                return_value_lscp_parser_test_97=lscp_parser_test(&tok, "MIDI_INPUT_DEVICES");
                if(!(return_value_lscp_parser_test_97 == 0))
                {
                  szTemp[(signed long int)0] = (char)0;
                  i = 0;
                  do
                  {
                    if(!(i >= iMidiDevice))
                    {
                      return_value_strlen_82=strlen(szTemp);
                      tmp_if_expr_83 = return_value_strlen_82 < sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)8 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_83 = (_Bool)0;
                    if(!tmp_if_expr_83)
                      break;

                    if(i >= 1)
                      strcat(szTemp, ",");

                    unsigned long int return_value_strlen_84;
                    return_value_strlen_84=strlen(szTemp);
                    sprintf(szTemp + (signed long int)return_value_strlen_84, "%d", i);
                    i = i + 1;
                  }
                  while((_Bool)1);
                  strcat(szTemp, "\r\n");
                  pszResult = szTemp;
                }

                else
                {
                  return_value_lscp_parser_test_96=lscp_parser_test(&tok, "FX_SENDS");
                  if(!(return_value_lscp_parser_test_96 == 0))
                  {
                    szTemp[(signed long int)0] = (char)0;
                    i = 0;
                    do
                    {
                      if(!(i >= iFxSend))
                      {
                        return_value_strlen_85=strlen(szTemp);
                        tmp_if_expr_86 = return_value_strlen_85 < sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)8 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_86 = (_Bool)0;
                      if(!tmp_if_expr_86)
                        break;

                      if(i >= 1)
                        strcat(szTemp, ",");

                      unsigned long int return_value_strlen_87;
                      return_value_strlen_87=strlen(szTemp);
                      sprintf(szTemp + (signed long int)return_value_strlen_87, "%d", i);
                      i = i + 1;
                    }
                    while((_Bool)1);
                    strcat(szTemp, "\r\n");
                    pszResult = szTemp;
                  }

                  else
                  {
                    return_value_lscp_parser_test_95=lscp_parser_test(&tok, "MIDI_INSTRUMENTS");
                    if(!(return_value_lscp_parser_test_95 == 0))
                    {
                      szTemp[(signed long int)0] = (char)0;
                      i = 0;
                      do
                      {
                        if(!(i >= iMidiInstruments))
                        {
                          return_value_strlen_88=strlen(szTemp);
                          tmp_if_expr_89 = return_value_strlen_88 < sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)16 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr_89 = (_Bool)0;
                        if(!tmp_if_expr_89)
                          break;

                        if(i >= 1)
                          strcat(szTemp, ",");

                        unsigned long int return_value_strlen_90;
                        return_value_strlen_90=strlen(szTemp);
                        sprintf(szTemp + (signed long int)return_value_strlen_90, "{0,%d,%d}", i / 128, i % 128);
                        i = i + 1;
                      }
                      while((_Bool)1);
                      strcat(szTemp, "\r\n");
                      pszResult = szTemp;
                    }

                    else
                    {
                      return_value_lscp_parser_test_94=lscp_parser_test(&tok, "MIDI_INSTRUMENT_MAPS");
                      if(!(return_value_lscp_parser_test_94 == 0))
                      {
                        szTemp[(signed long int)0] = (char)0;
                        i = 0;
                        do
                        {
                          if(!(i >= iMidiMaps))
                          {
                            return_value_strlen_91=strlen(szTemp);
                            tmp_if_expr_92 = return_value_strlen_91 < sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)8 ? (_Bool)1 : (_Bool)0;
                          }

                          else
                            tmp_if_expr_92 = (_Bool)0;
                          if(!tmp_if_expr_92)
                            break;

                          if(i >= 1)
                            strcat(szTemp, ",");

                          unsigned long int return_value_strlen_93;
                          return_value_strlen_93=strlen(szTemp);
                          sprintf(szTemp + (signed long int)return_value_strlen_93, "%d", i);
                          i = i + 1;
                        }
                        while((_Bool)1);
                        strcat(szTemp, "\r\n");
                        pszResult = szTemp;
                      }

                      else
                        ret = (enum _lscp_status_t)LSCP_FAILED;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    else
    {
      return_value_lscp_parser_test_161=lscp_parser_test(&tok, "SET");
      if(!(return_value_lscp_parser_test_161 == 0))
      {
        signed int return_value_lscp_parser_test_120;
        return_value_lscp_parser_test_120=lscp_parser_test(&tok, "CHANNEL");
        if(!(return_value_lscp_parser_test_120 == 0))
        {
          signed int return_value_lscp_parser_test_113;
          return_value_lscp_parser_test_113=lscp_parser_test(&tok, "VOLUME");
          if(return_value_lscp_parser_test_113 == 0)
          {
            return_value_lscp_parser_test_112=lscp_parser_test(&tok, "MUTE");
            if(return_value_lscp_parser_test_112 == 0)
            {
              return_value_lscp_parser_test_111=lscp_parser_test(&tok, "SOLO");
              if(return_value_lscp_parser_test_111 == 0)
              {
                return_value_lscp_parser_test_110=lscp_parser_test(&tok, "AUDIO_OUTPUT_TYPE");
                if(return_value_lscp_parser_test_110 == 0)
                {
                  return_value_lscp_parser_test_109=lscp_parser_test(&tok, "AUDIO_OUTPUT_DEVICE");
                  if(return_value_lscp_parser_test_109 == 0)
                  {
                    return_value_lscp_parser_test_108=lscp_parser_test(&tok, "AUDIO_OUTPUT_CHANNEL");
                    if(return_value_lscp_parser_test_108 == 0)
                    {
                      return_value_lscp_parser_test_107=lscp_parser_test(&tok, "MIDI_INPUT_TYPE");
                      if(return_value_lscp_parser_test_107 == 0)
                      {
                        return_value_lscp_parser_test_106=lscp_parser_test(&tok, "MIDI_INPUT_DEVICE");
                        if(return_value_lscp_parser_test_106 == 0)
                        {
                          return_value_lscp_parser_test_105=lscp_parser_test(&tok, "MIDI_INPUT_PORT");
                          if(return_value_lscp_parser_test_105 == 0)
                          {
                            return_value_lscp_parser_test_104=lscp_parser_test(&tok, "MIDI_INPUT_CHANNEL");
                            if(return_value_lscp_parser_test_104 == 0)
                            {
                              return_value_lscp_parser_test_103=lscp_parser_test(&tok, "MIDI_INSTRUMENT_MAP");
                              if(return_value_lscp_parser_test_103 == 0)
                                ret = (enum _lscp_status_t)LSCP_FAILED;

                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

        else
        {
          return_value_lscp_parser_test_119=lscp_parser_test(&tok, "VOLUME");
          if(!(return_value_lscp_parser_test_119 == 0))
            fVolume=lscp_parser_nextnum(&tok);

          else
          {
            return_value_lscp_parser_test_118=lscp_parser_test(&tok, "FX_SEND");
            if(!(return_value_lscp_parser_test_118 == 0))
            {
              signed int return_value_lscp_parser_test_116;
              return_value_lscp_parser_test_116=lscp_parser_test(&tok, "MIDI_CONTROLLER");
              if(return_value_lscp_parser_test_116 == 0)
              {
                return_value_lscp_parser_test_115=lscp_parser_test(&tok, "AUDIO_OUTPUT_CHANNEL");
                if(return_value_lscp_parser_test_115 == 0)
                {
                  return_value_lscp_parser_test_114=lscp_parser_test(&tok, "LEVEL");
                  if(return_value_lscp_parser_test_114 == 0)
                    ret = (enum _lscp_status_t)LSCP_FAILED;

                }

              }

            }

            else
            {
              return_value_lscp_parser_test2_117=lscp_parser_test2(&tok, "MIDI_INSTRUMENT_MAP", "NAME");
              if(return_value_lscp_parser_test2_117 == 0)
                ret = (enum _lscp_status_t)LSCP_FAILED;

            }
          }
        }
      }

      else
      {
        return_value_lscp_parser_test_160=lscp_parser_test(&tok, "LOAD");
        if(!(return_value_lscp_parser_test_160 == 0))
        {
          signed int return_value_lscp_parser_test_122;
          return_value_lscp_parser_test_122=lscp_parser_test(&tok, "ENGINE");
          if(return_value_lscp_parser_test_122 == 0)
          {
            return_value_lscp_parser_test_121=lscp_parser_test(&tok, "INSTRUMENT");
            if(return_value_lscp_parser_test_121 == 0)
              ret = (enum _lscp_status_t)LSCP_FAILED;

          }

        }

        else
        {
          return_value_lscp_parser_test_159=lscp_parser_test(&tok, "ADD");
          if(!(return_value_lscp_parser_test_159 == 0))
          {
            signed int return_value_lscp_parser_test_126;
            return_value_lscp_parser_test_126=lscp_parser_test(&tok, "CHANNEL");
            if(!(return_value_lscp_parser_test_126 == 0))
            {
              if(!(iSamplerChannel >= 16))
              {
                tmp_post_123 = iSamplerChannel;
                iSamplerChannel = iSamplerChannel + 1;
                sprintf(szTemp, "OK[%d]\r\n", tmp_post_123);
                pszResult = szTemp;
              }

              else
              {
                iSamplerChannel = 0;
                ret = (enum _lscp_status_t)LSCP_FAILED;
              }
            }

            else
            {
              return_value_lscp_parser_test_125=lscp_parser_test(&tok, "MIDI_INSTRUMENT_MAP");
              if(!(return_value_lscp_parser_test_125 == 0))
              {
                if(!(iMidiMaps >= 2))
                {
                  tmp_post_124 = iMidiMaps;
                  iMidiMaps = iMidiMaps + 1;
                  sprintf(szTemp, "OK[%d]\r\n", tmp_post_124);
                  pszResult = szTemp;
                }

                else
                {
                  iMidiMaps = 0;
                  ret = (enum _lscp_status_t)LSCP_FAILED;
                }
              }

            }
          }

          else
          {
            return_value_lscp_parser_test_158=lscp_parser_test(&tok, "REMOVE");
            if(!(return_value_lscp_parser_test_158 == 0))
            {
              signed int return_value_lscp_parser_test_130;
              return_value_lscp_parser_test_130=lscp_parser_test(&tok, "CHANNEL");
              if(!(return_value_lscp_parser_test_130 == 0))
              {
                signed int return_value_lscp_parser_nextint_127;
                return_value_lscp_parser_nextint_127=lscp_parser_nextint(&tok);
                if(return_value_lscp_parser_nextint_127 >= 0)
                  iSamplerChannel = iSamplerChannel - 1;

                else
                  ret = (enum _lscp_status_t)LSCP_FAILED;
              }

              else
              {
                return_value_lscp_parser_test_129=lscp_parser_test(&tok, "MIDI_INSTRUMENT_MAP");
                if(!(return_value_lscp_parser_test_129 == 0))
                {
                  signed int return_value_lscp_parser_nextint_128;
                  return_value_lscp_parser_nextint_128=lscp_parser_nextint(&tok);
                  if(return_value_lscp_parser_nextint_128 >= 0)
                    iMidiMaps = iMidiMaps - 1;

                  else
                    ret = (enum _lscp_status_t)LSCP_FAILED;
                }

              }
            }

            else
            {
              return_value_lscp_parser_test_157=lscp_parser_test(&tok, "RESET");
              if(!(return_value_lscp_parser_test_157 == 0))
              {
                signed int return_value_lscp_parser_test_132;
                return_value_lscp_parser_test_132=lscp_parser_test(&tok, "CHANNEL");
                if(!(return_value_lscp_parser_test_132 == 0))
                {
                  signed int return_value_lscp_parser_nextint_131;
                  return_value_lscp_parser_nextint_131=lscp_parser_nextint(&tok);
                  if(!(iSamplerChannel >= return_value_lscp_parser_nextint_131))
                    ret = (enum _lscp_status_t)LSCP_FAILED;

                }

                else
                {
                  iSamplerChannel = 0;
                  iAudioDevice = 0;
                  iMidiDevice = 0;
                  iMidiMaps = 0;
                  iMidiInstruments = 0;
                }
              }

              else
              {
                return_value_lscp_parser_test_156=lscp_parser_test(&tok, "CREATE");
                if(!(return_value_lscp_parser_test_156 == 0))
                {
                  signed int return_value_lscp_parser_test_138;
                  return_value_lscp_parser_test_138=lscp_parser_test(&tok, "AUDIO_OUTPUT_DEVICE");
                  if(!(return_value_lscp_parser_test_138 == 0))
                  {
                    if(!(iAudioDevice >= 8))
                    {
                      tmp_post_133 = iAudioDevice;
                      iAudioDevice = iAudioDevice + 1;
                      sprintf(szTemp, "OK[%d]\r\n", tmp_post_133);
                      pszResult = szTemp;
                    }

                    else
                    {
                      iAudioDevice = 0;
                      ret = (enum _lscp_status_t)LSCP_FAILED;
                    }
                  }

                  else
                  {
                    return_value_lscp_parser_test_137=lscp_parser_test(&tok, "MIDI_INPUT_DEVICE");
                    if(!(return_value_lscp_parser_test_137 == 0))
                    {
                      if(!(iMidiDevice >= 8))
                      {
                        tmp_post_134 = iMidiDevice;
                        iMidiDevice = iMidiDevice + 1;
                        sprintf(szTemp, "OK[%d]\r\n", tmp_post_134);
                        pszResult = szTemp;
                      }

                      else
                      {
                        iMidiDevice = 0;
                        ret = (enum _lscp_status_t)LSCP_FAILED;
                      }
                    }

                    else
                    {
                      return_value_lscp_parser_test_136=lscp_parser_test(&tok, "FX_SEND");
                      if(!(return_value_lscp_parser_test_136 == 0))
                      {
                        if(!(iFxSend >= 8))
                        {
                          tmp_post_135 = iFxSend;
                          iFxSend = iFxSend + 1;
                          sprintf(szTemp, "OK[%d]\r\n", tmp_post_135);
                          pszResult = szTemp;
                        }

                        else
                        {
                          iFxSend = 0;
                          ret = (enum _lscp_status_t)LSCP_FAILED;
                        }
                      }

                      else
                        ret = (enum _lscp_status_t)LSCP_FAILED;
                    }
                  }
                }

                else
                {
                  return_value_lscp_parser_test_155=lscp_parser_test(&tok, "DESTROY");
                  if(!(return_value_lscp_parser_test_155 == 0))
                  {
                    signed int return_value_lscp_parser_test_144;
                    return_value_lscp_parser_test_144=lscp_parser_test(&tok, "AUDIO_OUTPUT_DEVICE");
                    if(!(return_value_lscp_parser_test_144 == 0))
                    {
                      signed int return_value_lscp_parser_nextint_139;
                      return_value_lscp_parser_nextint_139=lscp_parser_nextint(&tok);
                      if(return_value_lscp_parser_nextint_139 >= 0 && iAudioDevice >= 1)
                        iAudioDevice = iAudioDevice - 1;

                      else
                        ret = (enum _lscp_status_t)LSCP_FAILED;
                    }

                    else
                    {
                      return_value_lscp_parser_test_143=lscp_parser_test(&tok, "MIDI_INPUT_DEVICE");
                      if(!(return_value_lscp_parser_test_143 == 0))
                      {
                        signed int return_value_lscp_parser_nextint_140;
                        return_value_lscp_parser_nextint_140=lscp_parser_nextint(&tok);
                        if(return_value_lscp_parser_nextint_140 >= 0 && iMidiDevice >= 1)
                          iMidiDevice = iMidiDevice - 1;

                        else
                          ret = (enum _lscp_status_t)LSCP_FAILED;
                      }

                      else
                      {
                        return_value_lscp_parser_test_142=lscp_parser_test(&tok, "FX_SEND");
                        if(!(return_value_lscp_parser_test_142 == 0))
                        {
                          signed int return_value_lscp_parser_nextint_141;
                          return_value_lscp_parser_nextint_141=lscp_parser_nextint(&tok);
                          if(return_value_lscp_parser_nextint_141 >= 0 && iFxSend >= 1)
                            iFxSend = iFxSend - 1;

                          else
                            ret = (enum _lscp_status_t)LSCP_FAILED;
                        }

                        else
                          ret = (enum _lscp_status_t)LSCP_FAILED;
                      }
                    }
                  }

                  else
                  {
                    return_value_lscp_parser_test2_154=lscp_parser_test2(&tok, "MAP", "MIDI_INSTRUMENT");
                    if(!(return_value_lscp_parser_test2_154 == 0))
                      iMidiInstruments = iMidiInstruments + 1;

                    else
                    {
                      return_value_lscp_parser_test2_153=lscp_parser_test2(&tok, "UNMAP", "MIDI_INSTRUMENT");
                      if(!(return_value_lscp_parser_test2_153 == 0))
                      {
                        if(iMidiInstruments >= 1)
                          iMidiInstruments = iMidiInstruments - 1;

                        else
                          ret = (enum _lscp_status_t)LSCP_FAILED;
                      }

                      else
                      {
                        return_value_lscp_parser_test2_152=lscp_parser_test2(&tok, "CLEAR", "MIDI_INSTRUMENTS");
                        if(!(return_value_lscp_parser_test2_152 == 0))
                          iMidiInstruments = 0;

                        else
                        {
                          return_value_lscp_parser_test_151=lscp_parser_test(&tok, "SUBSCRIBE");
                          if(!(return_value_lscp_parser_test_151 == 0))
                          {
                            const char *return_value_lscp_parser_next_145;
                            return_value_lscp_parser_next_145=lscp_parser_next(&tok);
                            enum _lscp_event_t return_value_lscp_event_from_text_146;
                            return_value_lscp_event_from_text_146=lscp_event_from_text(return_value_lscp_parser_next_145);
                            ret=lscp_server_subscribe(pConnect, return_value_lscp_event_from_text_146);
                          }

                          else
                          {
                            return_value_lscp_parser_test_150=lscp_parser_test(&tok, "UNSUBSCRIBE");
                            if(!(return_value_lscp_parser_test_150 == 0))
                            {
                              const char *return_value_lscp_parser_next_147;
                              return_value_lscp_parser_next_147=lscp_parser_next(&tok);
                              enum _lscp_event_t return_value_lscp_event_from_text_148;
                              return_value_lscp_event_from_text_148=lscp_event_from_text(return_value_lscp_parser_next_147);
                              ret=lscp_server_unsubscribe(pConnect, return_value_lscp_event_from_text_148);
                            }

                            else
                            {
                              return_value_lscp_parser_test_149=lscp_parser_test(&tok, "QUIT");
                              if(!(return_value_lscp_parser_test_149 == 0))
                              {
                                lscp_parser_free(&tok);
                                return (enum _lscp_status_t)LSCP_FAILED;
                              }

                              else
                                ret = (enum _lscp_status_t)LSCP_FAILED;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  lscp_parser_free(&tok);
  if(pszResult == ((const char *)NULL))
    pszResult = (signed int)ret == LSCP_OK ? "OK\r\n" : "ERR:1:Failed\r\n";

  fprintf(stderr, "> %s", pszResult);
  unsigned long int return_value_strlen_164;
  return_value_strlen_164=strlen(pszResult);
  enum _lscp_status_t return_value_lscp_server_result_165;
  return_value_lscp_server_result_165=lscp_server_result(pConnect, pszResult, (signed int)return_value_strlen_164);
  return return_value_lscp_server_result_165;
}

// server_prompt
// file example_server.c line 835
void server_prompt(void)
{
  fputs("lscp_server> ", stdout);
}

// server_usage
// file example_server.c line 827
void server_usage(void)
{
  const char *return_value_lscp_server_package_1;
  return_value_lscp_server_package_1=lscp_server_package();
  const char *return_value_lscp_server_version_2;
  return_value_lscp_server_version_2=lscp_server_version();
  const char *return_value_lscp_server_build_3;
  return_value_lscp_server_build_3=lscp_server_build();
  printf("\n  %s %s (Build: %s)\n", return_value_lscp_server_package_1, return_value_lscp_server_version_2, return_value_lscp_server_build_3);
  fputs("\n  Available server commands: help, exit, quit, list", stdout);
  fputs("\n  (all else are broadcast verbatim to subscribers)\n\n", stdout);
}

