// #anon_enum_AO_BYTE_TS_clear=0_AO_BYTE_TS_set=255
// file /usr/include/atomic_ops/sysdeps/test_and_set_t_is_char.h line 30
enum anonymous_1 { AO_BYTE_TS_clear=0, AO_BYTE_TS_set=255 };

// #anon_enum_RT_CONSISTENT=0_RT_ADD=1_RT_DELETE=2
// file /usr/include/link.h line 54
enum anonymous_23 { RT_CONSISTENT=0, RT_ADD=1, RT_DELETE=2 };

// tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 126
struct anonymous_8;

// tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 111
struct anonymous_13;

// tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_6;

// tag-#anon#ST[*{cS8}_cS8_'oh_string'|U64'oh_int'|U64'oh_sz'|U64'oh_sf']
// file ./include/private/dbg_mlc.h line 57
struct anonymous_16;

// tag-#anon#ST[ARR16{U64}_U64_'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_0;

// tag-#anon#ST[ARR16{U8}_U8_'e_ident'|U16'e_type'|U16'e_machine'|U32'e_version'|U64'e_entry'|U64'e_phoff'|U64'e_shoff'|U32'e_flags'|U16'e_ehsize'|U16'e_phentsize'|U16'e_phnum'|U16'e_shentsize'|U16'e_shnum'|U16'e_shstrndx']
// file /usr/include/elf.h line 85
struct anonymous_24;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'_pad0']#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'_pad0']#_'__cancel_jmp_buf'|ARR4{*{V}_V_}_*{V}_V__'__pad']
// file /usr/include/pthread.h line 523
struct anonymous_26;

// tag-#anon#ST[ARR23{S64}_S64_'gregs'|*{SYM#tag-_libc_fpstate#}_SYM#tag-_libc_fpstate#_'fpregs'|ARR8{U64}_U64_'__reserved1']
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 124
struct anonymous_18;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'_pad0']
// file /usr/include/pthread.h line 525
struct anonymous_25;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_14;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_2;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_5;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_4;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_10;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_3;

// tag-#anon#ST[S64'd_tag'|SYM#tag-#anon#UN[U64'd_val'|U64'd_ptr']#'d_un']
// file /usr/include/elf.h line 688
struct anonymous_22;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 119
struct anonymous_7;

// tag-#anon#ST[U32'p_type'|U32'p_flags'|U64'p_offset'|U64'p_vaddr'|U64'p_paddr'|U64'p_filesz'|U64'p_memsz'|U64'p_align']
// file /usr/include/elf.h line 579
struct anonymous_20;

// tag-#anon#ST[U64'ed_bitmap'|S32'ed_continued'|U32'_pad0']
// file typd_mlc.c line 57
struct anonymous_19;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V_'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_11;

// tag-#anon#UN[ARR257{S8}_S8_'_hb_marks'|U64'dummy'|U2112'_pad']
// file ./include/private/gc_priv.h line 959
union anonymous_17;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_9;

// tag-#anon#UN[ARR32{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous_12;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_15;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-#anon#UN[U64'd_val'|U64'd_ptr']
// file /usr/include/elf.h line 691
union anonymous_21;

// tag-ComplexArrayDescriptor
// file typd_mlc.c line 76
struct ComplexArrayDescriptor;

// tag-ComplexDescriptor
// file typd_mlc.c line 66
union ComplexDescriptor;

// tag-GC_Thread_Rep
// file ./include/private/pthread_support.h line 42
struct GC_Thread_Rep;

// tag-GC_finalizer_closure
// file ./include/gc_disclaim.h line 42
struct GC_finalizer_closure;

// tag-GC_ms_entry
// file ./include/private/../gc_mark.h line 61
struct GC_ms_entry;

// tag-GC_prof_stats_s
// file ./include/private/../gc.h line 629
struct GC_prof_stats_s;

// tag-GC_stack_base
// file ./include/private/../gc.h line 1214
struct GC_stack_base;

// tag-GC_traced_stack_sect_s
// file ./include/private/gc_priv.h line 1454
struct GC_traced_stack_sect_s;

// tag-HeapSect
// file ./include/private/gc_priv.h line 1238
struct HeapSect;

// tag-LeafDescriptor
// file typd_mlc.c line 67
struct LeafDescriptor;

// tag-Print_stats
// file reclaim.c line 464
struct Print_stats;

// tag-SequenceDescriptor
// file typd_mlc.c line 82
struct SequenceDescriptor;

// tag-_GC_arrays
// file ./include/private/gc_priv.h line 1092
struct _GC_arrays;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 742
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_libc_fpstate
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 104
struct _libc_fpstate;

// tag-_libc_fpxreg
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 92
struct _libc_fpxreg;

// tag-_libc_xmmreg
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 99
struct _libc_xmmreg;

// tag-bi
// file ./include/private/gc_hdrs.h line 118
struct bi;

// tag-blocking_data
// file ./include/private/gc_priv.h line 1448
struct blocking_data;

// tag-closure
// file dbg_mlc.c line 1042
struct closure;

// tag-disappearing_link
// file finalize.c line 36
struct disappearing_link;

// tag-dl_hashtbl_s
// file finalize.c line 46
struct dl_hashtbl_s;

// tag-dl_phdr_info
// file /usr/include/link.h line 138
struct dl_phdr_info;

// tag-exclusion
// file ./include/private/gc_priv.h line 1021
struct exclusion;

// tag-finalizable_object
// file finalize.c line 58
struct finalizable_object;

// tag-hash_chain_entry
// file finalize.c line 31
struct hash_chain_entry;

// tag-hblk
// file ./include/private/gcconfig.h line 2922
struct hblk;

// tag-hblkhdr
// file ./include/private/gc_hdrs.h line 18
struct hblkhdr;

// tag-hce
// file ./include/private/gc_hdrs.h line 71
struct hce;

// tag-link_map
// file /usr/include/link.h line 46
struct link_map;

// tag-load_segment
// file dyn_load.c line 457
struct load_segment;

// tag-obj_kind
// file ./include/private/gc_priv.h line 1321
struct obj_kind;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-r_debug
// file /usr/include/link.h line 42
struct r_debug;

// tag-roots
// file ./include/private/gc_priv.h line 1030
struct roots;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigaltstack
// file /usr/include/x86_64-linux-gnu/bits/sigstack.h line 49
struct sigaltstack;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-start_info
// file pthread_support.c line 1592
struct start_info;

// tag-thread_local_freelists
// file ./include/private/thread_local_alloc.h line 79
struct thread_local_freelists;

// tag-thread_stop_info
// file ./include/private/pthread_stop_world.h line 21
struct thread_stop_info;

// tag-ucontext
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 133
struct ucontext;

// tag-word_ptr_ao_u
// file ./include/private/gc_priv.h line 865
union word_ptr_ao_u;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef FENCE
#define FENCE(x) ((void)0)
#endif

// AO_char_store
// file /usr/include/atomic_ops/sysdeps/loadstore/char_atomic_store.h line 28
static inline void AO_char_store(volatile unsigned char *addr, unsigned char new_val);
// AO_compare_and_swap_full
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full(volatile unsigned long int *addr, unsigned long int old, unsigned long int new_val);
// AO_compare_and_swap_full_link1
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full_link1(volatile unsigned long int *addr_link1, unsigned long int old_link1, unsigned long int new_val_link1);
// AO_fetch_and_add
// file /usr/include/atomic_ops/generalize-arithm.h line 2726
static inline unsigned long int AO_fetch_and_add(volatile unsigned long int *addr, unsigned long int incr);
// AO_load
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load(const volatile unsigned long int *addr);
// AO_load_link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load_link1(const volatile unsigned long int *addr_link1);
// AO_load_link2
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load_link2(const volatile unsigned long int *addr_link2);
// AO_load_link3
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load_link3(const volatile unsigned long int *addr_link3);
// AO_load_read
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read(const volatile unsigned long int *addr);
// AO_load_read_link1
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read_link1(const volatile unsigned long int *addr_link1);
// AO_nop_read
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read(void);
// AO_nop_read_link1
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read_link1(void);
// AO_nop_write
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write(void);
// AO_nop_write_link1
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write_link1(void);
// AO_nop_write_link2
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write_link2(void);
// AO_store
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store(volatile unsigned long int *addr, unsigned long int new_val);
// AO_store_link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store_link1(volatile unsigned long int *addr_link1, unsigned long int new_val_link1);
// AO_store_link2
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store_link2(volatile unsigned long int *addr_link2, unsigned long int new_val_link2);
// AO_test_and_set_full
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 124
static inline enum anonymous_1 AO_test_and_set_full(volatile unsigned char *addr);
// GC_FirstDLOpenedLinkMap
// file dyn_load.c line 678
struct link_map * GC_FirstDLOpenedLinkMap(void);
// GC_acquire_mark_lock
// file ./include/private/gc_priv.h line 2371
void GC_acquire_mark_lock(void);
// GC_add_ext_descriptor
// file typd_mlc.c line 113
signed long int GC_add_ext_descriptor(const unsigned long int *bm, unsigned long int nbits);
// GC_add_leaked
// file reclaim.c line 52
static inline void GC_add_leaked(char *leaked);
// GC_add_map_entry
// file ./include/private/gc_priv.h line 1734
signed int GC_add_map_entry(unsigned long int granules);
// GC_add_roots
// file mark_rts.c line 151
extern void GC_add_roots(void *b, void *e);
// GC_add_roots_inner
// file ./include/private/gc_priv.h line 1660
void GC_add_roots_inner(char *b, char *e, signed int tmp);
// GC_add_smashed
// file dbg_mlc.c line 945
void GC_add_smashed(char *smashed);
// GC_add_to_black_list_normal
// file blacklst.c line 183
void GC_add_to_black_list_normal(unsigned long int p);
// GC_add_to_black_list_stack
// file blacklst.c line 205
void GC_add_to_black_list_stack(unsigned long int p);
// GC_add_to_fl
// file allchblk.c line 352
void GC_add_to_fl(struct hblk *h, struct hblkhdr *hhdr);
// GC_add_to_heap
// file alloc.c line 1045
void GC_add_to_heap(struct hblk *p, unsigned long int bytes);
// GC_adj_bytes_allocd
// file alloc.c line 244
unsigned long int GC_adj_bytes_allocd(void);
// GC_alloc_large
// file malloc.c line 42
char * GC_alloc_large(unsigned long int lb, signed int k, unsigned int flags);
// GC_alloc_large_and_clear
// file malloc.c line 85
char * GC_alloc_large_and_clear(unsigned long int lb, signed int k, unsigned int flags);
// GC_alloc_reclaim_list
// file malloc.c line 23
signed int GC_alloc_reclaim_list(struct obj_kind *kind);
// GC_allochblk
// file allchblk.c line 576
struct hblk * GC_allochblk(unsigned long int sz, signed int kind, unsigned int flags);
// GC_allochblk_nth
// file allchblk.c line 640
struct hblk * GC_allochblk_nth(unsigned long int sz, signed int kind, unsigned int flags, signed int n, signed int may_split);
// GC_allocobj
// file alloc.c line 1330
char * GC_allocobj(unsigned long int gran, signed int kind);
// GC_allow_register_threads
// file pthread_support.c line 1542
extern void GC_allow_register_threads(void);
// GC_apply_to_all_blocks
// file ./include/private/gc_priv.h line 1542
void GC_apply_to_all_blocks(void (*fn)(struct hblk *, unsigned long int), unsigned long int client_data);
// GC_apply_to_all_blocks::fn_object
//
void fn_object(struct hblk *, unsigned long int);
// GC_approx_sp
// file ./include/private/gc_priv.h line 1538
char * GC_approx_sp(void);
// GC_array_mark_proc
// file typd_mlc.c line 495
struct GC_ms_entry * GC_array_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env);
// GC_atfork_child
// file pthread_support.c line 1019
extern void GC_atfork_child(void);
// GC_atfork_parent
// file pthread_support.c line 1013
extern void GC_atfork_parent(void);
// GC_atfork_prepare
// file pthread_support.c line 1001
extern void GC_atfork_prepare(void);
// GC_base
// file ./include/private/../gc.h line 464
extern void * GC_base(void *p);
// GC_bl_init
// file blacklst.c line 107
void GC_bl_init(void);
// GC_bl_init_no_interiors
// file blacklst.c line 92
void GC_bl_init_no_interiors(void);
// GC_block_empty
// file ./include/private/gc_priv.h line 1801
signed int GC_block_empty(struct hblkhdr *hhdr);
// GC_block_nearly_full
// file reclaim.c line 133
signed int GC_block_nearly_full(struct hblkhdr *hhdr);
// GC_block_was_dirty
// file mark.c line 1816
signed int GC_block_was_dirty(struct hblk *h, struct hblkhdr *hhdr);
// GC_build_fl
// file ./include/private/gc_priv.h line 1747
char * GC_build_fl(struct hblk *h, unsigned long int sz, signed int clear, char *list);
// GC_build_fl2
// file new_hblk.c line 70
char * GC_build_fl2(struct hblk *h, char *ofl);
// GC_build_fl4
// file new_hblk.c line 86
char * GC_build_fl4(struct hblk *h, char *ofl);
// GC_build_fl_clear2
// file new_hblk.c line 30
char * GC_build_fl_clear2(struct hblk *h, char *ofl);
// GC_build_fl_clear4
// file new_hblk.c line 50
char * GC_build_fl_clear4(struct hblk *h, char *ofl);
// GC_call_with_alloc_lock
// file misc.c line 1814
extern void * GC_call_with_alloc_lock(void * (*fn)(void *), void *client_data);
// GC_call_with_alloc_lock::fn_object
//
void * fn_object(void *);
// GC_call_with_gc_active
// file pthread_support.c line 1244
extern void * GC_call_with_gc_active(void * (*fn)(void *), void *client_data);
// GC_call_with_gc_active::fn_object
//
void * fn_object(void *);
// GC_call_with_stack_base
// file misc.c line 1829
extern void * GC_call_with_stack_base(void * (*fn)(struct GC_stack_base *, void *), void *arg);
// GC_call_with_stack_base::fn_object
//
void * fn_object(struct GC_stack_base *, void *);
// GC_calloc_explicitly_typed
// file typd_mlc.c line 658
extern void * GC_calloc_explicitly_typed(unsigned long int n, unsigned long int lb, unsigned long int d);
// GC_change_stubborn
// file stubborn.c line 52
extern void GC_change_stubborn(const void *p);
// GC_check_annotated_obj
// file dbg_mlc.c line 295
char * GC_check_annotated_obj(struct anonymous_16 *ohdr);
// GC_check_finalizer_nested
// file ./include/private/gc_priv.h line 2270
unsigned char * GC_check_finalizer_nested(void);
// GC_check_heap_object
//
void GC_check_heap_object(void);
// GC_check_heap_block
// file dbg_mlc.c line 979
void GC_check_heap_block(struct hblk *hbp, unsigned long int dummy);
// GC_check_heap_proc
// file dbg_mlc.c line 1005
void GC_check_heap_proc(void);
// GC_check_leaked
// file dbg_mlc.c line 1012
signed int GC_check_leaked(char *base);
// GC_clear_a_few_frames
// file alloc.c line 285
void GC_clear_a_few_frames(void);
// GC_clear_bl
// file blacklst.c line 122
void GC_clear_bl(unsigned long int *doomed);
// GC_clear_fl_links
// file reclaim.c line 591
void GC_clear_fl_links(void **flp);
// GC_clear_fl_marks
// file alloc.c line 765
void GC_clear_fl_marks(char *q);
// GC_clear_hdr_marks
// file ./include/private/gc_priv.h line 1647
void GC_clear_hdr_marks(struct hblkhdr *hhdr);
// GC_clear_mark_bit
// file ./include/private/../gc_mark.h line 246
extern void GC_clear_mark_bit(const void *p);
// GC_clear_marks
// file ./include/private/gc_priv.h line 1553
void GC_clear_marks(void);
// GC_clear_roots
// file mark_rts.c line 265
extern void GC_clear_roots(void);
// GC_clear_stack
// file ./include/private/../gc_mark.h line 229
extern void * GC_clear_stack(void *arg);
// GC_clear_stack_inner
// file misc.c line 328
void * GC_clear_stack_inner(void *arg, char *limit);
// GC_collect_a_little
// file alloc.c line 546
extern signed int GC_collect_a_little(void);
// GC_collect_a_little_inner
// file alloc.c line 499
void GC_collect_a_little_inner(signed int n);
// GC_collect_or_expand
// file alloc.c line 1249
signed int GC_collect_or_expand(unsigned long int needed_blocks, signed int ignore_off_page, signed int retry);
// GC_collection_in_progress
// file ./include/private/gc_priv.h line 1571
signed int GC_collection_in_progress(void);
// GC_compute_heap_usage_percent
// file alloc.c line 815
static inline signed int GC_compute_heap_usage_percent(void);
// GC_compute_large_free_bytes
// file allchblk.c line 104
unsigned long int GC_compute_large_free_bytes(void);
// GC_compute_root_size
// file mark_rts.c line 44
unsigned long int GC_compute_root_size(void);
// GC_cond_register_dynamic_libraries
// file ./include/private/gc_priv.h line 1667
void GC_cond_register_dynamic_libraries(void);
// GC_continue_reclaim
// file ./include/private/gc_priv.h line 1784
void GC_continue_reclaim(unsigned long int sz, signed int kind);
// GC_copy_bl
// file blacklst.c line 127
void GC_copy_bl(unsigned long int *old, unsigned long int *new);
// GC_core_finalized_malloc
// file fnlz_mlc.c line 85
void * GC_core_finalized_malloc(unsigned long int lb, struct GC_finalizer_closure *fclos);
// GC_core_gcj_malloc
// file gcj_mlc.c line 159
void * GC_core_gcj_malloc(unsigned long int lb, void *ptr_to_struct_containing_descr);
// GC_core_gcj_malloc::1::1::2::1::oom_fn_object
//
void * oom_fn_object(unsigned long int);
// GC_core_gcj_malloc::1::2::2::oom_fn_object
//
void * oom_fn_object(unsigned long int);
// GC_core_malloc
// file malloc.c line 257
void * GC_core_malloc(unsigned long int lb);
// GC_core_malloc_atomic
// file malloc.c line 227
void * GC_core_malloc_atomic(unsigned long int lb);
// GC_current_warn_proc_object
//
void GC_current_warn_proc_object(char *, unsigned long int);
// GC_debug_change_stubborn
// file dbg_mlc.c line 667
extern void GC_debug_change_stubborn(const void *p);
// GC_debug_end_stubborn_change
// file dbg_mlc.c line 670
extern void GC_debug_end_stubborn_change(const void *p);
// GC_debug_free
// file dbg_mlc.c line 797
extern void GC_debug_free(void *p);
// GC_debug_gcj_malloc
// file gcj_mlc.c line 209
extern void * GC_debug_gcj_malloc(unsigned long int lb, void *ptr_to_struct_containing_descr, const char *s, signed int i);
// GC_debug_gcj_malloc::1::2::oom_fn_object
//
void * oom_fn_object(unsigned long int);
// GC_debug_invoke_finalizer
// file dbg_mlc.c line 1065
void GC_debug_invoke_finalizer(void *obj, void *data);
// GC_debug_malloc
// file dbg_mlc.c line 509
extern void * GC_debug_malloc(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_atomic
// file dbg_mlc.c line 674
extern void * GC_debug_malloc_atomic(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_atomic_ignore_off_page
// file dbg_mlc.c line 553
extern void * GC_debug_malloc_atomic_ignore_off_page(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_atomic_uncollectable
// file dbg_mlc.c line 771
extern void * GC_debug_malloc_atomic_uncollectable(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_ignore_off_page
// file dbg_mlc.c line 536
extern void * GC_debug_malloc_ignore_off_page(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_replacement
// file dbg_mlc.c line 1216
extern void * GC_debug_malloc_replacement(unsigned long int lb);
// GC_debug_malloc_stubborn
// file dbg_mlc.c line 661
extern void * GC_debug_malloc_stubborn(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_uncollectable
// file dbg_mlc.c line 752
extern void * GC_debug_malloc_uncollectable(unsigned long int lb, const char *s, signed int i);
// GC_debug_print_heap_obj_proc
// file dbg_mlc.c line 404
void GC_debug_print_heap_obj_proc(char *p);
// GC_debug_realloc
// file dbg_mlc.c line 871
extern void * GC_debug_realloc(void *p, unsigned long int lb, const char *s, signed int i);
// GC_debug_realloc_replacement
// file dbg_mlc.c line 1221
extern void * GC_debug_realloc_replacement(void *p, unsigned long int lb);
// GC_debug_register_displacement
// file dbg_mlc.c line 478
extern void GC_debug_register_displacement(unsigned long int offset);
// GC_debug_register_finalizer
// file dbg_mlc.c line 1098
extern void GC_debug_register_finalizer(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_debug_register_finalizer::1::my_old_fn_object
//
void my_old_fn_object(void *, void *);
// GC_debug_register_finalizer::fn_object
//
void fn_object(void *, void *);
// GC_debug_register_finalizer::ofn_object_object
//
void ofn_object_object(void *, void *);
// GC_debug_register_finalizer_ignore_self
// file dbg_mlc.c line 1185
extern void GC_debug_register_finalizer_ignore_self(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_debug_register_finalizer_ignore_self::1::my_old_fn_object
//
void my_old_fn_object(void *, void *);
// GC_debug_register_finalizer_ignore_self::fn_object
//
void fn_object(void *, void *);
// GC_debug_register_finalizer_ignore_self::ofn_object_object
//
void ofn_object_object(void *, void *);
// GC_debug_register_finalizer_no_order
// file dbg_mlc.c line 1127
extern void GC_debug_register_finalizer_no_order(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_debug_register_finalizer_no_order::1::my_old_fn_object
//
void my_old_fn_object(void *, void *);
// GC_debug_register_finalizer_no_order::fn_object
//
void fn_object(void *, void *);
// GC_debug_register_finalizer_no_order::ofn_object_object
//
void ofn_object_object(void *, void *);
// GC_debug_register_finalizer_unreachable
// file dbg_mlc.c line 1156
extern void GC_debug_register_finalizer_unreachable(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_debug_register_finalizer_unreachable::1::my_old_fn_object
//
void my_old_fn_object(void *, void *);
// GC_debug_register_finalizer_unreachable::fn_object
//
void fn_object(void *, void *);
// GC_debug_register_finalizer_unreachable::ofn_object_object
//
void ofn_object_object(void *, void *);
// GC_debug_strdup
// file dbg_mlc.c line 691
extern char * GC_debug_strdup(const char *str, const char *s, signed int i);
// GC_debug_strndup
// file dbg_mlc.c line 714
extern char * GC_debug_strndup(const char *str, unsigned long int size, const char *s, signed int i);
// GC_default_is_valid_displacement_print_proc
// file ptr_chck.c line 103
void GC_default_is_valid_displacement_print_proc(void *p);
// GC_default_is_visible_print_proc
// file ptr_chck.c line 152
void GC_default_is_visible_print_proc(void *p);
// GC_default_on_abort
// file misc.c line 1638
void GC_default_on_abort(const char *msg);
// GC_default_oom_fn
// file misc.c line 164
void * GC_default_oom_fn(unsigned long int bytes_requested);
// GC_default_print_heap_obj_proc
// file blacklst.c line 57
void GC_default_print_heap_obj_proc(char *p);
// GC_default_push_other_roots
// file os_dep.c line 2589
void GC_default_push_other_roots(void);
// GC_default_same_obj_print_proc
// file ptr_chck.c line 21
void GC_default_same_obj_print_proc(void *p, void *q);
// GC_default_stop_func_object
//
signed int GC_default_stop_func_object(void);
// GC_default_warn_proc
// file misc.c line 1590
void GC_default_warn_proc(char *msg, unsigned long int arg);
// GC_delete_gc_thread
// file pthread_support.c line 562
void GC_delete_gc_thread(struct GC_Thread_Rep *t);
// GC_delete_thread
// file pthread_support.c line 524
void GC_delete_thread(unsigned long int id);
// GC_descr_obj_size
// file typd_mlc.c line 421
unsigned long int GC_descr_obj_size(union ComplexDescriptor *d);
// GC_destroy_thread_local
// file thread_local_alloc.c line 127
void GC_destroy_thread_local(struct thread_local_freelists *p);
// GC_dirty_init
// file ./include/private/gc_priv.h line 2039
void GC_dirty_init(void);
// GC_disable
// file misc.c line 1725
extern void GC_disable(void);
// GC_disclaim_and_reclaim
// file reclaim.c line 222
char * GC_disclaim_and_reclaim(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count);
// GC_disclaim_and_reclaim::1::disclaim_object
//
signed int disclaim_object(void *);
// GC_disclaim_and_reclaim_or_free_small_block
// file reclaim.c line 346
void GC_disclaim_and_reclaim_or_free_small_block(struct hblk *hbp);
// GC_dlopen
// file gc_dlopen.c line 70
extern void * GC_dlopen(const char *path, signed int mode);
// GC_do_blocking
// file misc.c line 1940
extern void * GC_do_blocking(void * (*fn)(void *), void *client_data);
// GC_do_blocking::fn_object
//
void * fn_object(void *);
// GC_do_blocking_inner
// file ./include/private/gc_priv.h line 2271
void GC_do_blocking_inner(char *data, void *context);
// GC_do_local_mark
// file mark.c line 964
void GC_do_local_mark(struct GC_ms_entry *local_mark_stack, struct GC_ms_entry *local_top);
// GC_do_parallel_mark
// file mark.c line 1119
void GC_do_parallel_mark(void);
// GC_double_descr
// file typd_mlc.c line 175
unsigned long int GC_double_descr(unsigned long int descriptor, unsigned long int nwords);
// GC_dump
// file ./include/private/../gc.h line 1395
extern void GC_dump(void);
// GC_dump_finalization
// file finalize.c line 612
void GC_dump_finalization(void);
// GC_dump_finalization_links
// file finalize.c line 593
void GC_dump_finalization_links(struct dl_hashtbl_s *dl_hashtbl);
// GC_dump_regions
// file allchblk.c line 170
void GC_dump_regions(void);
// GC_enable
// file ./include/private/../gc.h line 693
extern void GC_enable(void);
// GC_enable_incremental
// file misc.c line 1228
extern void GC_enable_incremental(void);
// GC_end_stubborn_change
// file stubborn.c line 48
extern void GC_end_stubborn_change(const void *p);
// GC_enough_large_bytes_left
// file allchblk.c line 70
static inline signed int GC_enough_large_bytes_left(void);
// GC_enqueue_all_finalizers
// file finalize.c line 881
void GC_enqueue_all_finalizers(void);
// GC_err_printf
// file ./include/private/gc_priv.h line 2096
extern void GC_err_printf(const char *format, ...);
// GC_err_puts
// file misc.c line 1585
void GC_err_puts(const char *s);
// GC_exclude_static_roots
// file mark_rts.c line 474
extern void GC_exclude_static_roots(void *b, void *e);
// GC_exclude_static_roots_inner
// file ./include/private/gc_priv.h line 1661
void GC_exclude_static_roots_inner(void *start, void *finish);
// GC_exit_check
// file misc.c line 744
void GC_exit_check(void);
// GC_expand_hp
// file alloc.c line 1223
extern signed int GC_expand_hp(unsigned long int bytes);
// GC_expand_hp_inner
// file alloc.c line 1155
signed int GC_expand_hp_inner(unsigned long int n);
// GC_extend_size_map
// file ./include/private/gc_priv.h line 2220
void GC_extend_size_map(unsigned long int i);
// GC_fault_handler
// file os_dep.c line 922
void GC_fault_handler(signed int sig);
// GC_finalize
// file ./include/private/gc_priv.h line 262
void GC_finalize(void);
// GC_finalize_all
// file finalize.c line 936
extern void GC_finalize_all(void);
// GC_finalized_disclaim
// file fnlz_mlc.c line 29
signed int GC_finalized_disclaim(void *obj);
// GC_finalized_malloc
// file fnlz_mlc.c line 130
extern void * GC_finalized_malloc(unsigned long int client_lb, struct GC_finalizer_closure *fclos);
// GC_finalized_malloc::_tmp::return_value_GC_get_oom_fn_3_object
//
void * return_value_GC_get_oom_fn_3_object(unsigned long int);
// GC_finalizer_notifier_object
//
void GC_finalizer_notifier_object(void);
// GC_find_header
// file ./include/private/gc_priv.h line 1895
struct hblkhdr * GC_find_header(char *h);
// GC_find_limit
// file os_dep.c line 998
char * GC_find_limit(char *p, signed int up);
// GC_find_limit_with_bound
// file os_dep.c line 956
char * GC_find_limit_with_bound(char *p, signed int up, char *bound);
// GC_finish_collection
// file alloc.c line 825
void GC_finish_collection(void);
// GC_free
// file ./include/private/../gc.h line 435
extern void GC_free(void *p);
// GC_free_block_ending_at
// file allchblk.c line 323
struct hblk * GC_free_block_ending_at(struct hblk *h);
// GC_free_inner
// file malloc.c line 542
void GC_free_inner(void *p);
// GC_freehblk
// file allchblk.c line 825
void GC_freehblk(struct hblk *hbp);
// GC_gcj_fake_mark_proc
// file gcj_mlc.c line 59
struct GC_ms_entry * GC_gcj_fake_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env);
// GC_gcj_malloc
// file thread_local_alloc.c line 240
extern void * GC_gcj_malloc(unsigned long int bytes, void *ptr_to_struct_containing_descr);
// GC_gcj_malloc::_tmp::return_value_GC_get_oom_fn_2_object
//
void * return_value_GC_get_oom_fn_2_object(unsigned long int);
// GC_gcj_malloc_ignore_off_page
// file gcj_mlc.c line 237
extern void * GC_gcj_malloc_ignore_off_page(unsigned long int lb, void *ptr_to_struct_containing_descr);
// GC_gcj_malloc_ignore_off_page::1::1::2::1::oom_fn_object
//
void * oom_fn_object(unsigned long int);
// GC_gcj_malloc_ignore_off_page::1::2::2::oom_fn_object
//
void * oom_fn_object(unsigned long int);
// GC_gcollect
// file alloc.c line 1006
extern void GC_gcollect(void);
// GC_gcollect_and_unmap
// file alloc.c line 1014
extern void GC_gcollect_and_unmap(void);
// GC_general_register_disappearing_link
// file finalize.c line 211
extern signed int GC_general_register_disappearing_link(void **link, const void *obj);
// GC_generic_lock
// file pthread_support.c line 1826
void GC_generic_lock(union anonymous *lock);
// GC_generic_malloc
// file malloc.c line 171
extern void * GC_generic_malloc(unsigned long int lb, signed int k);
// GC_generic_malloc::_tmp::return_value_GC_get_oom_fn_2_object
//
void * return_value_GC_get_oom_fn_2_object(unsigned long int);
// GC_generic_malloc::_tmp::return_value_GC_get_oom_fn_5_object
//
void * return_value_GC_get_oom_fn_5_object(unsigned long int);
// GC_generic_malloc_ignore_off_page
// file mallocx.c line 170
extern void * GC_generic_malloc_ignore_off_page(unsigned long int lb, signed int k);
// GC_generic_malloc_ignore_off_page::_tmp::return_value_GC_get_oom_fn_2_object
//
void * return_value_GC_get_oom_fn_2_object(unsigned long int);
// GC_generic_malloc_ignore_off_page::1::3::oom_fn_object
//
void * oom_fn_object(unsigned long int);
// GC_generic_malloc_inner
// file ./include/private/gc_priv.h line 1828
void * GC_generic_malloc_inner(unsigned long int lb, signed int k);
// GC_generic_malloc_inner_ignore_off_page
// file ./include/private/gc_priv.h line 1831
void * GC_generic_malloc_inner_ignore_off_page(unsigned long int lb, signed int k);
// GC_generic_malloc_many
// file mallocx.c line 272
extern void GC_generic_malloc_many(unsigned long int lb, signed int k, void **result);
// GC_generic_or_special_malloc
// file mallocx.c line 50
void * GC_generic_or_special_malloc(unsigned long int lb, signed int knd);
// GC_get_abort_func
// file misc.c line 1704
extern void (*GC_get_abort_func(void))(const char *);
// GC_get_abort_func::1::fn_object
//
void fn_object(const char *);
// GC_get_all_interior_pointers
// file misc.c line 2078
extern signed int GC_get_all_interior_pointers(void);
// GC_get_bytes_since_gc
// file misc.c line 503
extern unsigned long int GC_get_bytes_since_gc(void);
// GC_get_dont_expand
// file misc.c line 2114
extern signed int GC_get_dont_expand(void);
// GC_get_dont_precollect
// file misc.c line 2170
extern signed int GC_get_dont_precollect(void);
// GC_get_file_len
// file os_dep.c line 164
unsigned long int GC_get_file_len(signed int f);
// GC_get_finalize_on_demand
// file misc.c line 2090
extern signed int GC_get_finalize_on_demand(void);
// GC_get_finalizer_notifier
// file misc.c line 2033
extern void (*GC_get_finalizer_notifier(void))(void);
// GC_get_finalizer_notifier::1::fn_object
//
void fn_object(void);
// GC_get_find_leak
// file misc.c line 2056
extern signed int GC_get_find_leak(void);
// GC_get_first_part
// file allchblk.c line 489
struct hblk * GC_get_first_part(struct hblk *h, struct hblkhdr *hhdr, unsigned long int bytes, signed int index);
// GC_get_force_unmap_on_gcollect
// file misc.c line 2202
extern signed int GC_get_force_unmap_on_gcollect(void);
// GC_get_free_bytes
// file misc.c line 492
extern unsigned long int GC_get_free_bytes(void);
// GC_get_free_space_divisor
// file misc.c line 2147
extern unsigned long int GC_get_free_space_divisor(void);
// GC_get_full_freq
// file misc.c line 2181
extern signed int GC_get_full_freq(void);
// GC_get_gc_no
// file misc.c line 1969
extern unsigned long int GC_get_gc_no(void);
// GC_get_heap_size
// file ./include/gc.h line 589
extern unsigned long int GC_get_heap_size(void);
// GC_get_heap_usage_safe
// file misc.c line 518
extern void GC_get_heap_usage_safe(unsigned long int *pheap_size, unsigned long int *pfree_bytes, unsigned long int *punmapped_bytes, unsigned long int *pbytes_since_gc, unsigned long int *ptotal_bytes);
// GC_get_java_finalization
// file misc.c line 2102
extern signed int GC_get_java_finalization(void);
// GC_get_main_stack_base
// file ./include/private/gc_priv.h line 1672
char * GC_get_main_stack_base(void);
// GC_get_maps
// file os_dep.c line 194
char * GC_get_maps(void);
// GC_get_maps_len
// file os_dep.c line 179
unsigned long int GC_get_maps_len(void);
// GC_get_max_retries
// file misc.c line 2158
extern unsigned long int GC_get_max_retries(void);
// GC_get_no_dls
// file misc.c line 2126
extern signed int GC_get_no_dls(void);
// GC_get_non_gc_bytes
// file misc.c line 2136
extern unsigned long int GC_get_non_gc_bytes(void);
// GC_get_nprocs
// file pthread_support.c line 804
signed int GC_get_nprocs(void);
// GC_get_on_heap_resize
// file misc.c line 2014
extern void (*GC_get_on_heap_resize(void))(unsigned long int);
// GC_get_on_heap_resize::1::fn_object
//
void fn_object(unsigned long int);
// GC_get_oom_fn
// file ./include/private/../gc.h line 120
extern void * (*GC_get_oom_fn(void))(unsigned long int);
// GC_get_oom_fn::1::fn_object
//
void * fn_object(unsigned long int);
// GC_get_pages_executable
// file os_dep.c line 4446
extern signed int GC_get_pages_executable(void);
// GC_get_parallel
// file misc.c line 1975
extern signed int GC_get_parallel(void);
// GC_get_prof_stats
// file misc.c line 562
extern unsigned long int GC_get_prof_stats(struct GC_prof_stats_s *pstats, unsigned long int stats_sz);
// GC_get_prof_stats_unsafe
// file misc.c line 586
extern unsigned long int GC_get_prof_stats_unsafe(struct GC_prof_stats_s *pstats, unsigned long int stats_sz);
// GC_get_push_other_roots
// file os_dep.c line 2615
extern void (*GC_get_push_other_roots(void))(void);
// GC_get_stack_base
// file os_dep.c line 1273
extern signed int GC_get_stack_base(struct GC_stack_base *b);
// GC_get_start_callback
// file alloc.c line 324
extern void (*GC_get_start_callback(void))(void);
// GC_get_start_callback::1::fn_object
//
void fn_object(void);
// GC_get_stop_func
// file alloc.c line 158
extern signed int (*GC_get_stop_func(void))(void);
// GC_get_stop_func::1::stop_func_object
//
signed int stop_func_object(void);
// GC_get_suspend_signal
// file ./include/private/../gc.h line 1259
extern signed int GC_get_suspend_signal(void);
// GC_get_thr_restart_signal
// file pthread_stop_world.c line 172
extern signed int GC_get_thr_restart_signal(void);
// GC_get_time_limit
// file misc.c line 2192
extern unsigned long int GC_get_time_limit(void);
// GC_get_total_bytes
// file misc.c line 508
extern unsigned long int GC_get_total_bytes(void);
// GC_get_unmapped_bytes
// file misc.c line 498
extern unsigned long int GC_get_unmapped_bytes(void);
// GC_get_version
// file alloc.c line 105
extern unsigned int GC_get_version(void);
// GC_get_warn_proc
// file misc.c line 1624
extern void (*GC_get_warn_proc(void))(char *, unsigned long int);
// GC_get_warn_proc::1::result_object
//
void result_object(char *, unsigned long int);
// GC_grow_table
// file finalize.c line 100
void GC_grow_table(struct hash_chain_entry ***table, signed long int *log_size_ptr);
// GC_has_other_debug_info
// file dbg_mlc.c line 36
signed int GC_has_other_debug_info(char *p);
// GC_has_static_roots_object
//
signed int GC_has_static_roots_object(const char *, void *, unsigned long int);
// GC_hblk_fl_from_blocks
// file allchblk.c line 84
signed int GC_hblk_fl_from_blocks(unsigned long int blocks_needed);
// GC_header_cache_miss
// file headers.c line 58
struct hblkhdr * GC_header_cache_miss(char *p, struct hce *hce);
// GC_help_marker
// file mark.c line 1157
void GC_help_marker(unsigned long int my_mark_no);
// GC_ignore_self_finalize_mark_proc
// file finalize.c line 391
void GC_ignore_self_finalize_mark_proc(char *p);
// GC_ignore_warn_proc
// file misc.c line 1599
extern void GC_ignore_warn_proc(char *msg, unsigned long int arg);
// GC_incr_bytes_allocd
// file mallocx.c line 234
extern void GC_incr_bytes_allocd(unsigned long int n);
// GC_incr_bytes_freed
// file mallocx.c line 240
extern void GC_incr_bytes_freed(unsigned long int n);
// GC_incremental_protection_needs
// file os_dep.c line 3379
extern signed int GC_incremental_protection_needs(void);
// GC_init
// file ./include/gc.h line 396
extern void GC_init(void);
// GC_init_explicit_typing
// file typd_mlc.c line 348
void GC_init_explicit_typing(void);
// GC_init_finalized_malloc
// file fnlz_mlc.c line 50
extern void GC_init_finalized_malloc(void);
// GC_init_gcj_malloc
// file gcj_mlc.c line 69
extern void GC_init_gcj_malloc(signed int mp_index, void *mp);
// GC_init_headers
// file headers.c line 189
void GC_init_headers(void);
// GC_init_linux_data_start
// file ./include/private/gc_priv.h line 2289
void GC_init_linux_data_start(void);
// GC_init_parallel
// file ./include/private/gc_priv.h line 1681
void GC_init_parallel(void);
// GC_init_size_map
// file misc.c line 227
void GC_init_size_map(void);
// GC_init_thread_local
// file thread_local_alloc.c line 87
void GC_init_thread_local(struct thread_local_freelists *p);
// GC_initialize_offsets
// file ./include/private/gc_priv.h line 2224
void GC_initialize_offsets(void);
// GC_initiate_gc
// file ./include/private/gc_priv.h line 1565
void GC_initiate_gc(void);
// GC_inner_start_routine
// file pthread_start.c line 45
void * GC_inner_start_routine(struct GC_stack_base *sb, void *arg);
// GC_inner_start_routine::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// GC_inner_start_routine::1::start_object
//
void * start_object(void *);
// GC_install_counts
// file ./include/private/gc_priv.h line 1887
signed int GC_install_counts(struct hblk *h, unsigned long int sz);
// GC_install_header
// file ./include/private/gc_priv.h line 1883
struct hblkhdr * GC_install_header(struct hblk *h);
// GC_invalidate_mark_state
// file ./include/private/gc_priv.h line 1555
void GC_invalidate_mark_state(void);
// GC_invoke_finalizers
// file finalize.c line 966
extern signed int GC_invoke_finalizers(void);
// GC_is_black_listed
// file ./include/private/gc_priv.h line 1713
struct hblk * GC_is_black_listed(struct hblk *h, unsigned long int len);
// GC_is_disabled
// file misc.c line 1733
extern signed int GC_is_disabled(void);
// GC_is_heap_ptr
// file misc.c line 462
extern signed int GC_is_heap_ptr(const void *p);
// GC_is_marked
// file ./include/private/../gc_mark.h line 245
extern signed int GC_is_marked(const void *p);
// GC_is_valid_displacement
// file ptr_chck.c line 117
extern void * GC_is_valid_displacement(void *p);
// GC_is_valid_displacement_print_proc_object
//
void GC_is_valid_displacement_print_proc_object(void *);
// GC_is_visible
// file ptr_chck.c line 187
extern void * GC_is_visible(void *p);
// GC_is_visible_print_proc_object
//
void GC_is_visible_print_proc_object(void *);
// GC_linux_main_stack_base
// file os_dep.c line 1071
char * GC_linux_main_stack_base(void);
// GC_lock
// file ./include/private/gc_locks.h line 182
void GC_lock(void);
// GC_log_printf
// file ./include/private/gc_priv.h line 2104
extern void GC_log_printf(const char *format, ...);
// GC_lookup_thread
// file pthread_support.c line 596
struct GC_Thread_Rep * GC_lookup_thread(unsigned long int id);
// GC_make_array_descriptor
// file typd_mlc.c line 207
signed int GC_make_array_descriptor(unsigned long int nelements, unsigned long int size, unsigned long int descriptor, unsigned long int *simple_d, union ComplexDescriptor **complex_d, struct LeafDescriptor *leaf);
// GC_make_closure
// file dbg_mlc.c line 1047
void * GC_make_closure(void (*fn)(void *, void *), void *data);
// GC_make_closure::fn_object
//
void fn_object(void *, void *);
// GC_make_descriptor
// file typd_mlc.c line 534
extern unsigned long int GC_make_descriptor(const unsigned long int *bm, unsigned long int len);
// GC_make_disappearing_links_disappear
// file finalize.c line 702
static inline void GC_make_disappearing_links_disappear(struct dl_hashtbl_s *dl_hashtbl);
// GC_make_sequence_descriptor
// file typd_mlc.c line 303
union ComplexDescriptor * GC_make_sequence_descriptor(union ComplexDescriptor *first, union ComplexDescriptor *second);
// GC_malloc
// file ./include/gc.h line 412
extern void * GC_malloc(unsigned long int bytes);
// GC_malloc::_tmp::return_value_GC_get_oom_fn_2_object
//
void * return_value_GC_get_oom_fn_2_object(unsigned long int);
// GC_malloc_atomic
// file ./include/gc.h line 414
extern void * GC_malloc_atomic(unsigned long int bytes);
// GC_malloc_atomic::_tmp::return_value_GC_get_oom_fn_2_object
//
void * return_value_GC_get_oom_fn_2_object(unsigned long int);
// GC_malloc_atomic_ignore_off_page
// file ./include/private/../gc.h line 745
extern void * GC_malloc_atomic_ignore_off_page(unsigned long int lb);
// GC_malloc_atomic_uncollectable
// file ./include/private/../gc.h line 758
extern void * GC_malloc_atomic_uncollectable(unsigned long int lb);
// GC_malloc_explicitly_typed
// file typd_mlc.c line 584
extern void * GC_malloc_explicitly_typed(unsigned long int lb, unsigned long int d);
// GC_malloc_explicitly_typed_ignore_off_page
// file typd_mlc.c line 622
extern void * GC_malloc_explicitly_typed_ignore_off_page(unsigned long int lb, unsigned long int d);
// GC_malloc_ignore_off_page
// file ./include/private/../gc.h line 743
extern void * GC_malloc_ignore_off_page(unsigned long int lb);
// GC_malloc_many
// file mallocx.c line 438
extern void * GC_malloc_many(unsigned long int lb);
// GC_malloc_stubborn
// file stubborn.c line 43
extern void * GC_malloc_stubborn(unsigned long int lb);
// GC_malloc_uncollectable
// file ./include/private/../gc.h line 419
extern void * GC_malloc_uncollectable(unsigned long int lb);
// GC_mark_and_push
// file ./include/private/../gc_mark.h line 145
extern struct GC_ms_entry * GC_mark_and_push(void *obj, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, void **src);
// GC_mark_and_push_stack
// file mark.c line 1393
void GC_mark_and_push_stack(char *p);
// GC_mark_from
// file ./include/private/gc_pmark.h line 400
struct GC_ms_entry * GC_mark_from(struct GC_ms_entry *mark_stack_top, struct GC_ms_entry *mark_stack, struct GC_ms_entry *mark_stack_limit);
// GC_mark_init
// file mark.c line 1238
void GC_mark_init(void);
// GC_mark_local
// file mark.c line 1014
void GC_mark_local(struct GC_ms_entry *local_mark_stack, signed int id);
// GC_mark_some
// file ./include/private/gc_priv.h line 1560
signed int GC_mark_some(char *cold_gc_frame);
// GC_mark_thread
// file pthread_support.c line 356
void * GC_mark_thread(void *id);
// GC_mark_thread_local_fls_for
// file thread_local_alloc.c line 285
void GC_mark_thread_local_fls_for(struct thread_local_freelists *p);
// GC_mark_thread_local_free_lists
// file ./include/private/gc_priv.h line 2197
void GC_mark_thread_local_free_lists(void);
// GC_max
// file alloc.c line 1132
static inline unsigned long int GC_max(unsigned long int x, unsigned long int y);
// GC_maybe_gc
// file alloc.c line 351
void GC_maybe_gc(void);
// GC_memalign
// file mallocx.c line 451
extern void * GC_memalign(unsigned long int align, unsigned long int lb);
// GC_memalign::_tmp::return_value_GC_get_oom_fn_2_object
//
void * return_value_GC_get_oom_fn_2_object(unsigned long int);
// GC_min
// file alloc.c line 1137
static inline unsigned long int GC_min(unsigned long int x, unsigned long int y);
// GC_move_disappearing_link
// file finalize.c line 343
extern signed int GC_move_disappearing_link(void **link, void **new_link);
// GC_move_disappearing_link_inner
// file finalize.c line 292
signed int GC_move_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link, void **new_link);
// GC_move_long_link
// file finalize.c line 360
extern signed int GC_move_long_link(void **link, void **new_link);
// GC_n_set_marks
// file reclaim.c line 474
signed int GC_n_set_marks(struct hblkhdr *hhdr);
// GC_never_stop_func
// file alloc.c line 125
signed int GC_never_stop_func(void);
// GC_new_free_list
// file misc.c line 1748
extern void ** GC_new_free_list(void);
// GC_new_free_list_inner
// file ./include/private/../gc_mark.h line 168
extern void ** GC_new_free_list_inner(void);
// GC_new_hblk
// file ./include/private/gc_priv.h line 1743
void GC_new_hblk(unsigned long int gran, signed int kind);
// GC_new_kind
// file misc.c line 1780
extern unsigned int GC_new_kind(void **fl, unsigned long int descr, signed int adjust, signed int clear);
// GC_new_kind_inner
// file ./include/private/../gc_mark.h line 176
extern unsigned int GC_new_kind_inner(void **fl, unsigned long int descr, signed int adjust, signed int clear);
// GC_new_proc
// file misc.c line 1804
extern unsigned int GC_new_proc(struct GC_ms_entry * (*proc)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int));
// GC_new_proc::proc_object
//
struct GC_ms_entry * proc_object(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int);
// GC_new_proc_inner
// file misc.c line 1791
extern unsigned int GC_new_proc_inner(struct GC_ms_entry * (*proc)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int));
// GC_new_proc_inner::proc_object
//
struct GC_ms_entry * proc_object(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int);
// GC_new_thread
// file pthread_support.c line 489
struct GC_Thread_Rep * GC_new_thread(unsigned long int id);
// GC_next_exclusion
// file mark_rts.c line 417
struct exclusion * GC_next_exclusion(char *start_addr);
// GC_next_used_block
// file headers.c line 337
struct hblk * GC_next_used_block(struct hblk *h);
// GC_noop1
// file ./include/private/gc_priv.h line 2075
extern void GC_noop1(unsigned long int x);
// GC_noop6
// file ./include/private/gc_priv.h line 2073
void GC_noop6(unsigned long int arg1, unsigned long int arg2, unsigned long int arg3, unsigned long int arg4, unsigned long int arg5, unsigned long int arg6);
// GC_normal_finalize_mark_proc
// file finalize.c line 380
void GC_normal_finalize_mark_proc(char *p);
// GC_notify_all_builder
// file ./include/private/gc_priv.h line 2373
void GC_notify_all_builder(void);
// GC_notify_all_marker
// file ./include/private/gc_priv.h line 2378
void GC_notify_all_marker(void);
// GC_notify_full_gc
// file alloc.c line 334
static inline void GC_notify_full_gc(void);
// GC_notify_or_invoke_finalizers
// file ./include/private/gc_priv.h line 254
void GC_notify_or_invoke_finalizers(void);
// GC_notify_or_invoke_finalizers::1::notifier_fn_object
//
void notifier_fn_object(void);
// GC_null_finalize_mark_proc
// file finalize.c line 413
void GC_null_finalize_mark_proc(char *p);
// GC_number_stack_black_listed
// file blacklst.c line 262
unsigned long int GC_number_stack_black_listed(struct hblk *start, struct hblk *endp1);
// GC_old_bus_handler_object
//
void GC_old_bus_handler_object(signed int, struct anonymous_10 *, void *);
// GC_old_segv_handler_object
//
void GC_old_segv_handler_object(signed int, struct anonymous_10 *, void *);
// GC_on_abort_object
//
void GC_on_abort_object(const char *);
// GC_on_heap_resize_object
//
void GC_on_heap_resize_object(unsigned long int);
// GC_oom_fn_object
//
void * GC_oom_fn_object(unsigned long int);
// GC_page_was_dirty
// file ./include/private/gc_priv.h line 2031
signed int GC_page_was_dirty(struct hblk *h);
// GC_parse_mem_size_arg
// file misc.c line 787
unsigned long int GC_parse_mem_size_arg(const char *str);
// GC_pause
// file pthread_support.c line 1774
void GC_pause(void);
// GC_posix_memalign
// file mallocx.c line 485
extern signed int GC_posix_memalign(void **memptr, unsigned long int align, unsigned long int lb);
// GC_post_incr
// file ptr_chck.c line 268
extern void * GC_post_incr(void **p, signed long int how_much);
// GC_pre_incr
// file ptr_chck.c line 257
extern void * GC_pre_incr(void **p, signed long int how_much);
// GC_prev_block
// file ./include/private/gc_priv.h line 1548
struct hblk * GC_prev_block(struct hblk *h);
// GC_print_address_map
// file ./include/private/gc_priv.h line 1925
void GC_print_address_map(void);
// GC_print_all_errors
// file ./include/private/gc_priv.h line 1908
void GC_print_all_errors(void);
// GC_print_all_smashed_object
//
void GC_print_all_smashed_object(void);
// GC_print_all_smashed_proc
// file dbg_mlc.c line 957
void GC_print_all_smashed_proc(void);
// GC_print_block_descr
// file reclaim.c line 531
void GC_print_block_descr(struct hblk *h, unsigned long int raw_ps);
// GC_print_block_list
// file ./include/private/gc_priv.h line 2054
void GC_print_block_list(void);
// GC_print_finalization_stats
// file ./include/private/gc_priv.h line 270
void GC_print_finalization_stats(void);
// GC_print_free_list
// file reclaim.c line 568
void GC_print_free_list(signed int kind, unsigned long int sz_in_granules);
// GC_print_hblkfreelist
// file allchblk.c line 122
void GC_print_hblkfreelist(void);
// GC_print_heap_obj_object
//
void GC_print_heap_obj_object(char *);
// GC_print_heap_sects
// file alloc.c line 1105
void GC_print_heap_sects(void);
// GC_print_obj
// file dbg_mlc.c line 336
void GC_print_obj(char *p);
// GC_print_smashed_obj
// file dbg_mlc.c line 418
void GC_print_smashed_obj(const char *msg, char *p, char *clobbered_addr);
// GC_print_static_roots
// file mark_rts.c line 58
void GC_print_static_roots(void);
// GC_printf
// file ./include/private/gc_priv.h line 2090
extern void GC_printf(const char *format, ...);
// GC_promote_black_lists
// file ./include/private/gc_priv.h line 1721
void GC_promote_black_lists(void);
// GC_protect_heap
// file os_dep.c line 3394
void GC_protect_heap(void);
// GC_pthread_cancel
// file pthread_support.c line 1451
extern signed int GC_pthread_cancel(unsigned long int thread);
// GC_pthread_create
// file pthread_support.c line 1661
extern signed int GC_pthread_create(unsigned long int *new_thread, const union pthread_attr_t *attr, void * (*start_routine)(void *), void *arg);
// GC_pthread_create::_tmp::return_value_GC_get_oom_fn_3_object
//
void * return_value_GC_get_oom_fn_3_object(unsigned long int);
// GC_pthread_create::start_routine_object
//
void * start_routine_object(void *);
// GC_pthread_detach
// file pthread_support.c line 1418
extern signed int GC_pthread_detach(unsigned long int thread);
// GC_pthread_exit
// file pthread_support.c line 1476
extern void GC_pthread_exit(void *retval);
// GC_pthread_join
// file pthread_support.c line 1384
extern signed int GC_pthread_join(unsigned long int thread, void **retval);
// GC_pthread_sigmask
// file pthread_support.c line 1174
extern signed int GC_pthread_sigmask(signed int how, const struct anonymous_0 *set, struct anonymous_0 *oset);
// GC_push_all
// file ./include/private/../gc_mark.h line 252
extern void GC_push_all(char *bottom, char *top);
// GC_push_all_eager
// file mark.c line 1491
void GC_push_all_eager(char *bottom, char *top);
// GC_push_all_stack
// file mark.c line 1516
void GC_push_all_stack(char *bottom, char *top);
// GC_push_all_stack_sections
// file mark_rts.c line 536
void GC_push_all_stack_sections(char *lo, char *hi, struct GC_traced_stack_sect_s *traced_stack_sect);
// GC_push_all_stacks
// file ./include/private/gc_priv.h line 2272
void GC_push_all_stacks(void);
// GC_push_complex_descriptor
// file typd_mlc.c line 440
struct GC_ms_entry * GC_push_complex_descriptor(unsigned long int *addr, union ComplexDescriptor *d, struct GC_ms_entry *msp, struct GC_ms_entry *msl);
// GC_push_conditional
// file mark.c line 1323
extern void GC_push_conditional(char *bottom, char *top, signed int all);
// GC_push_conditional_with_exclusions
// file mark_rts.c line 491
void GC_push_conditional_with_exclusions(char *bottom, char *top, signed int all);
// GC_push_current_stack
// file mark_rts.c line 658
void GC_push_current_stack(char *cold_gc_frame, void *context);
// GC_push_finalizer_structures
// file finalize.c line 77
void GC_push_finalizer_structures(void);
// GC_push_gc_structures
// file mark_rts.c line 716
void GC_push_gc_structures(void);
// GC_push_marked
// file mark.c line 1727
void GC_push_marked(struct hblk *h, struct hblkhdr *hhdr);
// GC_push_next_marked
// file mark.c line 1835
struct hblk * GC_push_next_marked(struct hblk *h);
// GC_push_next_marked_dirty
// file mark.c line 1850
struct hblk * GC_push_next_marked_dirty(struct hblk *h);
// GC_push_next_marked_uncollectable
// file mark.c line 1883
struct hblk * GC_push_next_marked_uncollectable(struct hblk *h);
// GC_push_one
// file mark.c line 1350
void GC_push_one(unsigned long int p);
// GC_push_other_roots_object
//
void GC_push_other_roots_object(void);
// GC_push_regs_and_stack
// file mark_rts.c line 739
void GC_push_regs_and_stack(char *cold_gc_frame);
// GC_push_roots
// file ./include/private/gc_priv.h line 1598
void GC_push_roots(signed int all, char *cold_gc_frame);
// GC_push_selected
// file mark.c line 1281
void GC_push_selected(char *bottom, char *top, signed int (*dirty_fn)(struct hblk *));
// GC_push_selected::dirty_fn_object
//
signed int dirty_fn_object(struct hblk *);
// GC_push_thread_structures
// file ./include/private/gc_priv.h line 1612
void GC_push_thread_structures(void);
// GC_push_typed_structures_object
//
void GC_push_typed_structures_object(void);
// GC_push_typed_structures_proc
// file typd_mlc.c line 103
void GC_push_typed_structures_proc(void);
// GC_push_unconditionally
// file mark.c line 1787
void GC_push_unconditionally(struct hblk *h, struct hblkhdr *hhdr);
// GC_read_dirty
// file ./include/private/gc_priv.h line 2029
void GC_read_dirty(void);
// GC_realloc
// file ./include/gc.h line 485
extern void * GC_realloc(void *p, unsigned long int lb);
// GC_rebuild_root_index
// file mark_rts.c line 299
void GC_rebuild_root_index(void);
// GC_reclaim_all
// file ./include/private/gc_priv.h line 1790
signed int GC_reclaim_all(signed int (*stop_func)(void), signed int ignore_old);
// GC_reclaim_all::stop_func_object
//
signed int stop_func_object(void);
// GC_reclaim_block
// file reclaim.c line 374
void GC_reclaim_block(struct hblk *hbp, unsigned long int report_if_found);
// GC_reclaim_check
// file reclaim.c line 274
void GC_reclaim_check(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz);
// GC_reclaim_clear
// file reclaim.c line 146
char * GC_reclaim_clear(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count);
// GC_reclaim_generic
// file ./include/private/gc_priv.h line 1793
char * GC_reclaim_generic(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, signed int init, char *list, signed long int *count);
// GC_reclaim_small_nonempty_block
// file reclaim.c line 327
void GC_reclaim_small_nonempty_block(struct hblk *hbp, signed int report_if_found);
// GC_reclaim_unconditionally_marked
// file reclaim.c line 747
void GC_reclaim_unconditionally_marked(void);
// GC_reclaim_uninit
// file reclaim.c line 193
char * GC_reclaim_uninit(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count);
// GC_record_stack_base
// file pthread_support.c line 1506
static inline void GC_record_stack_base(struct GC_Thread_Rep *me, struct GC_stack_base *sb);
// GC_register_data_segments
// file ./include/private/gc_priv.h line 1677
void GC_register_data_segments(void);
// GC_register_describe_type_fn
// file dbg_mlc.c line 318
extern void GC_register_describe_type_fn(signed int kind, void (*fn)(void *, char *));
// GC_register_describe_type_fn::fn_object
//
void fn_object(void *, char *);
// GC_register_disappearing_link
// file finalize.c line 137
extern signed int GC_register_disappearing_link(void **link);
// GC_register_disappearing_link_inner
// file finalize.c line 147
signed int GC_register_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link, const void *obj);
// GC_register_disappearing_link_inner::1::4::oom_fn_object
//
void * oom_fn_object(unsigned long int);
// GC_register_disclaim_proc
// file fnlz_mlc.c line 76
extern void GC_register_disclaim_proc(signed int kind, signed int (*proc)(void *), signed int mark_unconditionally);
// GC_register_disclaim_proc::proc_object
//
signed int proc_object(void *);
// GC_register_displacement
// file ./include/private/../gc.h line 535
extern void GC_register_displacement(unsigned long int offset);
// GC_register_displacement_inner
// file ./include/private/gc_priv.h line 1738
void GC_register_displacement_inner(unsigned long int offset);
// GC_register_dynamic_libraries
// file dyn_load.c line 707
void GC_register_dynamic_libraries(void);
// GC_register_dynamic_libraries_dl_iterate_phdr
// file dyn_load.c line 568
signed int GC_register_dynamic_libraries_dl_iterate_phdr(void);
// GC_register_dynlib_callback
// file dyn_load.c line 469
signed int GC_register_dynlib_callback(struct dl_phdr_info *info, unsigned long int size, void *ptr);
// GC_register_dynlib_callback::1::1::1::1::2::callback_object
//
signed int callback_object(const char *, void *, unsigned long int);
// GC_register_finalizer
// file ./include/private/../gc.h line 914
extern void GC_register_finalizer(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_register_finalizer::fn_object
//
void fn_object(void *, void *);
// GC_register_finalizer::ofn_object_object
//
void ofn_object_object(void *, void *);
// GC_register_finalizer_ignore_self
// file ./include/private/../gc.h line 970
extern void GC_register_finalizer_ignore_self(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_register_finalizer_ignore_self::fn_object
//
void fn_object(void *, void *);
// GC_register_finalizer_ignore_self::ofn_object_object
//
void ofn_object_object(void *, void *);
// GC_register_finalizer_inner
// file finalize.c line 433
void GC_register_finalizer_inner(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd, void (*mp)(char *));
// GC_register_finalizer_inner::1::oom_fn_object
//
void * oom_fn_object(unsigned long int);
// GC_register_finalizer_inner::fn_object
//
void fn_object(void *, void *);
// GC_register_finalizer_inner::mp_object
//
void mp_object(char *);
// GC_register_finalizer_inner::ofn_object_object
//
void ofn_object_object(void *, void *);
// GC_register_finalizer_no_order
// file ./include/private/../gc.h line 983
extern void GC_register_finalizer_no_order(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_register_finalizer_no_order::fn_object
//
void fn_object(void *, void *);
// GC_register_finalizer_no_order::ofn_object_object
//
void ofn_object_object(void *, void *);
// GC_register_finalizer_unreachable
// file ./include/private/../gc.h line 1008
extern void GC_register_finalizer_unreachable(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_register_finalizer_unreachable::fn_object
//
void fn_object(void *, void *);
// GC_register_finalizer_unreachable::ofn_object_object
//
void ofn_object_object(void *, void *);
// GC_register_has_static_roots_callback
// file dyn_load.c line 1503
extern void GC_register_has_static_roots_callback(signed int (*callback)(const char *, void *, unsigned long int));
// GC_register_has_static_roots_callback::callback_object
//
signed int callback_object(const char *, void *, unsigned long int);
// GC_register_long_link
// file finalize.c line 267
extern signed int GC_register_long_link(void **link, const void *obj);
// GC_register_main_static_data
// file dyn_load.c line 556
signed int GC_register_main_static_data(void);
// GC_register_my_thread
// file pthread_support.c line 1550
extern signed int GC_register_my_thread(struct GC_stack_base *sb);
// GC_register_my_thread_inner
// file pthread_support.c line 1520
struct GC_Thread_Rep * GC_register_my_thread_inner(struct GC_stack_base *sb, unsigned long int my_pthread);
// GC_release_mark_lock
// file ./include/private/gc_priv.h line 2372
void GC_release_mark_lock(void);
// GC_remove_all_threads_but_me
// file pthread_support.c line 664
void GC_remove_all_threads_but_me(void);
// GC_remove_allowed_signals
// file pthread_stop_world.c line 82
void GC_remove_allowed_signals(struct anonymous_0 *set);
// GC_remove_counts
// file ./include/private/gc_priv.h line 1893
void GC_remove_counts(struct hblk *h, unsigned long int sz);
// GC_remove_dangling_disappearing_links
// file finalize.c line 719
static inline void GC_remove_dangling_disappearing_links(struct dl_hashtbl_s *dl_hashtbl);
// GC_remove_from_fl
// file allchblk.c line 317
static inline void GC_remove_from_fl(struct hblkhdr *hhdr);
// GC_remove_from_fl_at
// file allchblk.c line 293
void GC_remove_from_fl_at(struct hblkhdr *hhdr, signed int index);
// GC_remove_header
// file ./include/private/gc_priv.h line 1891
void GC_remove_header(struct hblk *h);
// GC_remove_protection
// file ./include/private/gc_priv.h line 2033
void GC_remove_protection(struct hblk *h, unsigned long int nblocks, signed int is_ptrfree);
// GC_remove_root_at_pos
// file mark_rts.c line 284
void GC_remove_root_at_pos(signed int i);
// GC_remove_roots
// file mark_rts.c line 331
extern void GC_remove_roots(void *b, void *e);
// GC_remove_roots_inner
// file mark_rts.c line 346
void GC_remove_roots_inner(char *b, char *e);
// GC_remove_tmp_roots
// file mark_rts.c line 311
void GC_remove_tmp_roots(void);
// GC_repeat_read
// file os_dep.c line 145
signed long int GC_repeat_read(signed int fd, char *buf, unsigned long int count);
// GC_reset_fault_handler
// file os_dep.c line 935
void GC_reset_fault_handler(void);
// GC_reset_finalizer_nested
// file ./include/private/gc_priv.h line 2269
void GC_reset_finalizer_nested(void);
// GC_restart_handler
// file pthread_stop_world.c line 311
void GC_restart_handler(signed int sig);
// GC_return_mark_stack
// file mark.c line 931
void GC_return_mark_stack(struct GC_ms_entry *low, struct GC_ms_entry *high);
// GC_roots_present
// file mark_rts.c line 127
void * GC_roots_present(char *b);
// GC_same_obj
// file ptr_chck.c line 39
extern void * GC_same_obj(void *p, void *q);
// GC_same_obj_print_proc_object
//
void GC_same_obj_print_proc_object(void *, void *);
// GC_scratch_alloc
// file ./include/private/gc_priv.h line 1728
char * GC_scratch_alloc(unsigned long int bytes);
// GC_set_abort_func
// file misc.c line 1695
extern void GC_set_abort_func(void (*fn)(const char *));
// GC_set_abort_func::fn_object
//
void fn_object(const char *);
// GC_set_all_interior_pointers
// file misc.c line 2061
extern void GC_set_all_interior_pointers(signed int value);
// GC_set_and_save_fault_handler
// file ./include/private/gc_priv.h line 2297
void GC_set_and_save_fault_handler(void (*h)(signed int));
// GC_set_and_save_fault_handler::h_object
//
void h_object(signed int);
// GC_set_dont_expand
// file misc.c line 2107
extern void GC_set_dont_expand(signed int value);
// GC_set_dont_precollect
// file misc.c line 2163
extern void GC_set_dont_precollect(signed int value);
// GC_set_finalize_on_demand
// file misc.c line 2083
extern void GC_set_finalize_on_demand(signed int value);
// GC_set_finalizer_notifier
// file misc.c line 2024
extern void GC_set_finalizer_notifier(void (*fn)(void));
// GC_set_finalizer_notifier::fn_object
//
void fn_object(void);
// GC_set_find_leak
// file misc.c line 2050
extern void GC_set_find_leak(signed int value);
// GC_set_fl_marks
// file alloc.c line 687
void GC_set_fl_marks(char *q);
// GC_set_force_unmap_on_gcollect
// file misc.c line 2197
extern void GC_set_force_unmap_on_gcollect(signed int value);
// GC_set_free_space_divisor
// file misc.c line 2141
extern void GC_set_free_space_divisor(unsigned long int value);
// GC_set_full_freq
// file misc.c line 2175
extern void GC_set_full_freq(signed int value);
// GC_set_handle_fork
// file misc.c line 204
extern void GC_set_handle_fork(signed int value);
// GC_set_hdr_marks
// file ./include/private/gc_priv.h line 1649
void GC_set_hdr_marks(struct hblkhdr *hhdr);
// GC_set_java_finalization
// file misc.c line 2095
extern void GC_set_java_finalization(signed int value);
// GC_set_mark_bit
// file ./include/private/../gc_mark.h line 247
extern void GC_set_mark_bit(const void *p);
// GC_set_max_heap_size
// file alloc.c line 1144
extern void GC_set_max_heap_size(unsigned long int n);
// GC_set_max_retries
// file misc.c line 2152
extern void GC_set_max_retries(unsigned long int value);
// GC_set_no_dls
// file misc.c line 2119
extern void GC_set_no_dls(signed int value);
// GC_set_non_gc_bytes
// file misc.c line 2131
extern void GC_set_non_gc_bytes(unsigned long int value);
// GC_set_on_heap_resize
// file misc.c line 2005
extern void GC_set_on_heap_resize(void (*fn)(unsigned long int));
// GC_set_on_heap_resize::fn_object
//
void fn_object(unsigned long int);
// GC_set_oom_fn
// file misc.c line 1986
extern void GC_set_oom_fn(void * (*fn)(unsigned long int));
// GC_set_oom_fn::fn_object
//
void * fn_object(unsigned long int);
// GC_set_pages_executable
// file os_dep.c line 4435
extern void GC_set_pages_executable(signed int value);
// GC_set_push_other_roots
// file os_dep.c line 2610
extern void GC_set_push_other_roots(void (*fn)(void));
// GC_set_push_other_roots::fn_object
//
void fn_object(void);
// GC_set_start_callback
// file alloc.c line 316
extern void GC_set_start_callback(void (*fn)(void));
// GC_set_start_callback::fn_object
//
void fn_object(void);
// GC_set_stop_func
// file alloc.c line 149
extern void GC_set_stop_func(signed int (*stop_func)(void));
// GC_set_stop_func::stop_func_object
//
signed int stop_func_object(void);
// GC_set_suspend_signal
// file pthread_stop_world.c line 153
extern void GC_set_suspend_signal(signed int sig);
// GC_set_thr_restart_signal
// file pthread_stop_world.c line 160
extern void GC_set_thr_restart_signal(signed int sig);
// GC_set_time_limit
// file misc.c line 2186
extern void GC_set_time_limit(unsigned long int value);
// GC_set_warn_proc
// file misc.c line 1607
extern void GC_set_warn_proc(void (*p)(char *, unsigned long int));
// GC_set_warn_proc::p_object
//
void p_object(char *, unsigned long int);
// GC_setpagesize
// file ./include/private/gc_priv.h line 2222
void GC_setpagesize(void);
// GC_setup_temporary_fault_handler
// file os_dep.c line 927
void GC_setup_temporary_fault_handler(void);
// GC_should_collect
// file ./include/private/gc_priv.h line 1540
signed int GC_should_collect(void);
// GC_should_invoke_finalizers
// file finalize.c line 959
extern signed int GC_should_invoke_finalizers(void);
// GC_signal_mark_stack_overflow
// file ./include/private/gc_pmark.h line 113
struct GC_ms_entry * GC_signal_mark_stack_overflow(struct GC_ms_entry *msp);
// GC_size
// file ./include/private/../gc.h line 475
extern unsigned long int GC_size(const void *p);
// GC_split_block
// file allchblk.c line 530
void GC_split_block(struct hblk *h, struct hblkhdr *hhdr, struct hblk *n, struct hblkhdr *nhdr, signed int index);
// GC_start_call_back_object
//
void GC_start_call_back_object(void);
// GC_start_debugging
// file dbg_mlc.c line 467
void GC_start_debugging(void);
// GC_start_debugging_inner
// file dbg_mlc.c line 452
void GC_start_debugging_inner(void);
// GC_start_mark_threads
// file pthread_support.c line 403
extern void GC_start_mark_threads(void);
// GC_start_reclaim
// file ./include/private/gc_priv.h line 1778
void GC_start_reclaim(signed int report_if_found);
// GC_start_routine
// file pthread_support.c line 1638
void * GC_start_routine(void *arg);
// GC_start_rtn_prepare_thread
// file ./include/private/pthread_support.h line 145
struct GC_Thread_Rep * GC_start_rtn_prepare_thread(void * (**pstart)(void *), void **pstart_arg, struct GC_stack_base *sb, void *arg);
// GC_start_rtn_prepare_thread::pstart_object_object
//
void * pstart_object_object(void *);
// GC_start_world
// file ./include/private/gc_priv.h line 448
void GC_start_world(void);
// GC_steal_mark_stack
// file mark.c line 897
struct GC_ms_entry * GC_steal_mark_stack(struct GC_ms_entry *low, struct GC_ms_entry *high, struct GC_ms_entry *local, unsigned int max, struct GC_ms_entry **next);
// GC_stop_init
// file ./include/private/pthread_stop_world.h line 42
void GC_stop_init(void);
// GC_stop_world
// file ./include/private/gc_priv.h line 447
void GC_stop_world(void);
// GC_stopped_mark
// file alloc.c line 586
signed int GC_stopped_mark(signed int (*stop_func)(void));
// GC_stopped_mark::stop_func_object
//
signed int stop_func_object(void);
// GC_store_debug_info
// file dbg_mlc.c line 279
char * GC_store_debug_info(char *p, unsigned long int sz, const char *string, signed int linenum);
// GC_store_debug_info_inner
// file dbg_mlc.c line 255
char * GC_store_debug_info_inner(char *p, unsigned long int sz, const char *string, signed int linenum);
// GC_strdup
// file mallocx.c line 563
extern char * GC_strdup(const char *s);
// GC_strndup
// file mallocx.c line 579
extern char * GC_strndup(const char *str, unsigned long int size);
// GC_suspend_all
// file pthread_stop_world.c line 465
signed int GC_suspend_all(void);
// GC_suspend_handler
// file pthread_stop_world.c line 206
void GC_suspend_handler(signed int sig, struct anonymous_10 *info, void *context);
// GC_suspend_handler_inner
// file pthread_stop_world.c line 227
void GC_suspend_handler_inner(char *sig_arg, void *context);
// GC_thr_init
// file ./include/private/gc_priv.h line 1680
void GC_thr_init(void);
// GC_thread_exit_proc
// file ./include/private/pthread_support.h line 149
void GC_thread_exit_proc(void *arg);
// GC_thread_is_registered
// file pthread_support.c line 647
extern signed int GC_thread_is_registered(void);
// GC_timeout_stop_func
// file alloc.c line 171
signed int GC_timeout_stop_func(void);
// GC_try_to_collect
// file alloc.c line 1000
extern signed int GC_try_to_collect(signed int (*stop_func)(void));
// GC_try_to_collect::stop_func_object
//
signed int stop_func_object(void);
// GC_try_to_collect_general
// file alloc.c line 964
signed int GC_try_to_collect_general(signed int (*stop_func)(void), signed int force_unmap);
// GC_try_to_collect_general::stop_func_object
//
signed int stop_func_object(void);
// GC_try_to_collect_inner
// file alloc.c line 411
signed int GC_try_to_collect_inner(signed int (*stop_func)(void));
// GC_try_to_collect_inner::stop_func_object
//
signed int stop_func_object(void);
// GC_typed_mark_proc
// file typd_mlc.c line 381
struct GC_ms_entry * GC_typed_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env);
// GC_unix_get_mem
// file ./include/private/gcconfig.h line 2963
char * GC_unix_get_mem(unsigned long int bytes);
// GC_unix_mmap_get_mem
// file os_dep.c line 2040
char * GC_unix_mmap_get_mem(unsigned long int bytes);
// GC_unix_sbrk_get_mem
// file os_dep.c line 2100
char * GC_unix_sbrk_get_mem(unsigned long int bytes);
// GC_unpromote_black_lists
// file ./include/private/gc_priv.h line 1723
void GC_unpromote_black_lists(void);
// GC_unreachable_finalize_mark_proc
// file finalize.c line 423
void GC_unreachable_finalize_mark_proc(char *p);
// GC_unregister_disappearing_link
// file finalize.c line 251
extern signed int GC_unregister_disappearing_link(void **link);
// GC_unregister_disappearing_link_inner
// file finalize.c line 227
static inline struct disappearing_link * GC_unregister_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link);
// GC_unregister_long_link
// file finalize.c line 274
extern signed int GC_unregister_long_link(void **link);
// GC_unregister_my_thread
// file pthread_support.c line 1337
extern signed int GC_unregister_my_thread(void);
// GC_unregister_my_thread_inner
// file pthread_support.c line 1307
void GC_unregister_my_thread_inner(struct GC_Thread_Rep *me);
// GC_wait_builder
// file pthread_support.c line 2002
void GC_wait_builder(void);
// GC_wait_for_gc_completion
// file pthread_support.c line 911
void GC_wait_for_gc_completion(signed int wait_for_all);
// GC_wait_for_reclaim
// file ./include/private/gc_priv.h line 2374
void GC_wait_for_reclaim(void);
// GC_wait_marker
// file ./include/private/gc_priv.h line 2379
void GC_wait_marker(void);
// GC_with_callee_saves_pushed
// file mach_dep.c line 213
void GC_with_callee_saves_pushed(void (*fn)(char *, void *), char *arg);
// GC_with_callee_saves_pushed::fn_object
//
void fn_object(char *, void *);
// GC_write
// file misc.c line 1456
signed int GC_write(signed int fd, const char *buf, unsigned long int len);
// GC_write_fault_handler
// file os_dep.c line 3124
void GC_write_fault_handler(signed int sig, struct anonymous_10 *si, void *raw_sc);
// GC_write_fault_handler::1::1::1::old_handler_object
//
void old_handler_object(signed int, struct anonymous_10 *, void *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 680
extern void __pthread_register_cancel(struct anonymous_26 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 692
extern void __pthread_unregister_cancel(struct anonymous_26 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 733
extern void __pthread_unwind_next(struct anonymous_26 *);
// __sigsetjmp
// file /usr/include/pthread.h line 743
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// __sync_bool_compare_and_swap
// file gcc_builtin_headers_generic.h line 105
_Bool __sync_bool_compare_and_swap();
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_roots_to_index
// file mark_rts.c line 140
static inline void add_roots_to_index(struct roots *p);
// alloc_hdr
// file headers.c line 164
static struct hblkhdr * alloc_hdr(void);
// alloc_mark_stack
// file mark.c line 1187
static void alloc_mark_stack(unsigned long int n);
// async_set_pht_entry_from_index
// file os_dep.c line 3028
static void async_set_pht_entry_from_index(unsigned long int * volatile db, unsigned long int index);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1);
// atol
// file /usr/include/stdlib.h line 283
static inline signed long int atol(const char *__nptr);
// clear_marks_for_block
// file mark.c line 166
static void clear_marks_for_block(struct hblk *h, unsigned long int dummy);
// clock
// file /usr/include/time.h line 189
extern signed long int clock(void);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// disable_gc_for_dlopen
// file gc_dlopen.c line 44
static void disable_gc_for_dlopen(void);
// dl_iterate_phdr
// file /usr/include/link.h line 167
extern signed int dl_iterate_phdr(signed int (*)(struct dl_phdr_info *, unsigned long int, void *), void *);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// fill_prof_stats
// file misc.c line 541
static void fill_prof_stats(struct GC_prof_stats_s *pstats);
// fork_child_proc
// file pthread_support.c line 983
static void fork_child_proc(void);
// fork_parent_proc
// file pthread_support.c line 972
static void fork_parent_proc(void);
// fork_prepare_proc
// file pthread_support.c line 948
static void fork_prepare_proc(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free_hdr
// file headers.c line 177
static inline void free_hdr(struct hblkhdr *hhdr);
// free_list_index_of
// file allchblk.c line 153
static signed int free_list_index_of(struct hblkhdr *wanted);
// get_index
// file headers.c line 206
static signed int get_index(unsigned long int addr);
// getcontext
// file /usr/include/ucontext.h line 31
extern signed int getcontext(struct ucontext *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpagesize
// file /usr/include/unistd.h line 981
extern signed int getpagesize(void);
// looping_handler
// file misc.c line 753
static void looping_handler(signed int sig);
// maybe_finalize
// file gcj_mlc.c line 142
static void maybe_finalize(void);
// maybe_install_looping_handler
// file misc.c line 763
static void maybe_install_looping_handler(void);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// min_bytes_allocd
// file alloc.c line 199
static unsigned long int min_bytes_allocd(void);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mprotect
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 81
extern signed int mprotect(void *, unsigned long int, signed int);
// old_bus_handler_object
//
void old_bus_handler_object(signed int);
// old_segv_handler_object
//
void old_segv_handler_object(signed int);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_atfork
// file /usr/include/pthread.h line 1145
extern signed int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
// pthread_attr_destroy
// file /usr/include/pthread.h line 290
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_getdetachstate
// file /usr/include/pthread.h line 294
extern signed int pthread_attr_getdetachstate(const union pthread_attr_t *, signed int *);
// pthread_attr_getstack
// file /usr/include/pthread.h line 381
extern signed int pthread_attr_getstack(const union pthread_attr_t *, void ** restrict , unsigned long int *);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 299
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cancel
// file /usr/include/pthread.h line 513
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 981
extern signed int pthread_cond_broadcast(union anonymous_15 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous_15 *, union anonymous *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 271
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 242
extern void pthread_exit(void *);
// pthread_getattr_np
// file /usr/include/pthread.h line 420
extern signed int pthread_getattr_np(unsigned long int, union pthread_attr_t *);
// pthread_join
// file /usr/include/pthread.h line 250
extern signed int pthread_join(unsigned long int, void **);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 758
extern signed int pthread_mutex_trylock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_self
// file /usr/include/pthread.h line 275
extern unsigned long int pthread_self(void);
// pthread_setcancelstate
// file /usr/include/pthread.h line 506
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_0 *, struct anonymous_0 *);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// return_freelists
// file thread_local_alloc.c line 64
static void return_freelists(void **fl, void **gfl);
// return_single_freelist
// file thread_local_alloc.c line 44
static void return_single_freelist(void *fl, void **gfl);
// rt_hash
// file mark_rts.c line 110
static inline signed int rt_hash(char *addr);
// sbrk
// file /usr/include/unistd.h line 1046
extern void * sbrk(signed long int);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// sem_destroy
// file /usr/include/semaphore.h line 39
extern signed int sem_destroy(union anonymous_12 *);
// sem_getvalue
// file /usr/include/semaphore.h line 72
extern signed int sem_getvalue(union anonymous_12 *, signed int *);
// sem_init
// file /usr/include/semaphore.h line 36
extern signed int sem_init(union anonymous_12 *, signed int, unsigned int);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous_12 *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous_12 *);
// setup_header
// file allchblk.c line 225
static signed int setup_header(struct hblkhdr *hhdr, struct hblk *block, unsigned long int byte_sz, signed int kind, unsigned int flags);
// sigaction
// file /usr/include/signal.h line 257
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 219
extern signed int sigaddset(struct anonymous_0 *, signed int);
// sigdelset
// file /usr/include/signal.h line 222
extern signed int sigdelset(struct anonymous_0 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 213
extern signed int sigemptyset(struct anonymous_0 *);
// sigfillset
// file /usr/include/signal.h line 216
extern signed int sigfillset(struct anonymous_0 *);
// siglongjmp
// file /usr/include/setjmp.h line 102
extern void siglongjmp(struct __jmp_buf_tag *, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigsuspend
// file /usr/include/signal.h line 254
extern signed int sigsuspend(const struct anonymous_0 *);
// store_old
// file dbg_mlc.c line 1075
static void store_old(void *obj, void (*my_old_fn)(void *, void *), struct closure *my_old_cd, void (**ofn)(void *, void *), void **ocd);
// store_old::my_old_fn_object
//
void my_old_fn_object(void *, void *);
// store_old::ofn_object_object
//
void ofn_object_object(void *, void *);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// total_stack_black_listed
// file blacklst.c line 277
static unsigned long int total_stack_black_listed(void);
// usleep
// file /usr/include/unistd.h line 463
extern signed int usleep(unsigned int);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_8
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_13
{
  // _lower
  void *_lower;
  // _upper
  void *_upper;
};

struct anonymous_6
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
  // si_addr_bnd
  struct anonymous_13 si_addr_bnd;
};

struct anonymous_16
{
  // oh_string
  const char *oh_string;
  // oh_int
  unsigned long int oh_int;
  // oh_sz
  unsigned long int oh_sz;
  // oh_sf
  unsigned long int oh_sf;
};

struct anonymous_0
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_24
{
  // e_ident
  unsigned char e_ident[16l];
  // e_type
  unsigned short int e_type;
  // e_machine
  unsigned short int e_machine;
  // e_version
  unsigned int e_version;
  // e_entry
  unsigned long int e_entry;
  // e_phoff
  unsigned long int e_phoff;
  // e_shoff
  unsigned long int e_shoff;
  // e_flags
  unsigned int e_flags;
  // e_ehsize
  unsigned short int e_ehsize;
  // e_phentsize
  unsigned short int e_phentsize;
  // e_phnum
  unsigned short int e_phnum;
  // e_shentsize
  unsigned short int e_shentsize;
  // e_shnum
  unsigned short int e_shnum;
  // e_shstrndx
  unsigned short int e_shstrndx;
};

struct anonymous_25
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_26
{
  // __cancel_jmp_buf
  struct anonymous_25 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_18
{
  // gregs
  signed long long int gregs[23l];
  // fpregs
  struct _libc_fpstate *fpregs;
  // __reserved1
  unsigned long long int __reserved1[8l];
};

struct anonymous_14
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_2
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_5
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_4
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_3
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_7
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_9
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_2 _kill;
  // _timer
  struct anonymous_3 _timer;
  // _rt
  struct anonymous_4 _rt;
  // _sigchld
  struct anonymous_5 _sigchld;
  // _sigfault
  struct anonymous_6 _sigfault;
  // _sigpoll
  struct anonymous_7 _sigpoll;
  // _sigsys
  struct anonymous_8 _sigsys;
};

struct anonymous_10
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_9 _sifields;
};

union anonymous_21
{
  // d_val
  unsigned long int d_val;
  // d_ptr
  unsigned long int d_ptr;
};

struct anonymous_22
{
  // d_tag
  signed long int d_tag;
  // d_un
  union anonymous_21 d_un;
};

struct anonymous_20
{
  // p_type
  unsigned int p_type;
  // p_flags
  unsigned int p_flags;
  // p_offset
  unsigned long int p_offset;
  // p_vaddr
  unsigned long int p_vaddr;
  // p_paddr
  unsigned long int p_paddr;
  // p_filesz
  unsigned long int p_filesz;
  // p_memsz
  unsigned long int p_memsz;
  // p_align
  unsigned long int p_align;
};

struct anonymous_19
{
  // ed_bitmap
  unsigned long int ed_bitmap;
  // ed_continued
  signed int ed_continued;
};

union anonymous_11
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_10 *, void *);
};

union anonymous_17
{
  // _hb_marks
  char _hb_marks[257l];
  // dummy
  unsigned long int dummy;
};

union anonymous_12
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous_15
{
  // __data
  struct anonymous_14 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ComplexArrayDescriptor
{
  // ad_tag
  unsigned long int ad_tag;
  // ad_nelements
  unsigned long int ad_nelements;
  // ad_element_descr
  union ComplexDescriptor *ad_element_descr;
};

struct LeafDescriptor
{
  // ld_tag
  unsigned long int ld_tag;
  // ld_size
  unsigned long int ld_size;
  // ld_nelements
  unsigned long int ld_nelements;
  // ld_descriptor
  unsigned long int ld_descriptor;
};

struct SequenceDescriptor
{
  // sd_tag
  unsigned long int sd_tag;
  // sd_first
  union ComplexDescriptor *sd_first;
  // sd_second
  union ComplexDescriptor *sd_second;
};

union ComplexDescriptor
{
  // ld
  struct LeafDescriptor ld;
  // ad
  struct ComplexArrayDescriptor ad;
  // sd
  struct SequenceDescriptor sd;
};

struct thread_stop_info
{
  // last_stop_count
  unsigned long int last_stop_count;
  // stack_ptr
  char *stack_ptr;
};

struct thread_local_freelists
{
  // ptrfree_freelists
  void *ptrfree_freelists[25l];
  // normal_freelists
  void *normal_freelists[25l];
  // gcj_freelists
  void *gcj_freelists[25l];
  // finalized_freelists
  void *finalized_freelists[25l];
};

struct GC_Thread_Rep
{
  // next
  struct GC_Thread_Rep *next;
  // id
  unsigned long int id;
  // stop_info
  struct thread_stop_info stop_info;
  // flags
  unsigned char flags;
  // thread_blocked
  unsigned char thread_blocked;
  // finalizer_skipped
  unsigned short int finalizer_skipped;
  // finalizer_nested
  unsigned char finalizer_nested;
  // stack_end
  char *stack_end;
  // traced_stack_sect
  struct GC_traced_stack_sect_s *traced_stack_sect;
  // status
  void *status;
  // tlfs
  struct thread_local_freelists tlfs;
};

struct GC_finalizer_closure
{
  // proc
  void (*proc)(void *, void *);
  // cd
  void *cd;
};

union word_ptr_ao_u
{
  // w
  unsigned long int w;
  // sw
  signed long int sw;
  // vp
  void *vp;
  // ao
  volatile unsigned long int ao;
};

struct GC_ms_entry
{
  // mse_start
  char *mse_start;
  // mse_descr
  union word_ptr_ao_u mse_descr;
};

struct GC_prof_stats_s
{
  // heapsize_full
  unsigned long int heapsize_full;
  // free_bytes_full
  unsigned long int free_bytes_full;
  // unmapped_bytes
  unsigned long int unmapped_bytes;
  // bytes_allocd_since_gc
  unsigned long int bytes_allocd_since_gc;
  // allocd_bytes_before_gc
  unsigned long int allocd_bytes_before_gc;
  // non_gc_bytes
  unsigned long int non_gc_bytes;
  // gc_no
  unsigned long int gc_no;
  // markers_m1
  unsigned long int markers_m1;
  // bytes_reclaimed_since_gc
  unsigned long int bytes_reclaimed_since_gc;
  // reclaimed_bytes_before_gc
  unsigned long int reclaimed_bytes_before_gc;
};

struct GC_stack_base
{
  // mem_base
  void *mem_base;
};

struct GC_traced_stack_sect_s
{
  // saved_stack_ptr
  char *saved_stack_ptr;
  // prev
  struct GC_traced_stack_sect_s *prev;
};

struct HeapSect
{
  // hs_start
  char *hs_start;
  // hs_bytes
  unsigned long int hs_bytes;
};

struct Print_stats
{
  // number_of_blocks
  unsigned long int number_of_blocks;
  // total_bytes
  unsigned long int total_bytes;
};

struct roots
{
  // r_start
  char *r_start;
  // r_end
  char *r_end;
  // r_next
  struct roots *r_next;
  // r_tmp
  signed int r_tmp;
};

struct exclusion
{
  // e_start
  char *e_start;
  // e_end
  char *e_end;
};

struct hblkhdr
{
  // hb_next
  struct hblk *hb_next;
  // hb_prev
  struct hblk *hb_prev;
  // hb_block
  struct hblk *hb_block;
  // hb_obj_kind
  unsigned char hb_obj_kind;
  // hb_flags
  unsigned char hb_flags;
  // hb_last_reclaimed
  unsigned short int hb_last_reclaimed;
  // hb_sz
  unsigned long int hb_sz;
  // hb_descr
  unsigned long int hb_descr;
  // hb_large_block
  unsigned char hb_large_block;
  // hb_map
  signed short int *hb_map;
  // hb_n_marks
  volatile unsigned long int hb_n_marks;
  // _mark_byte_union
  union anonymous_17 _mark_byte_union;
};

struct bi
{
  // index
  struct hblkhdr *index[1024l];
  // asc_link
  struct bi *asc_link;
  // desc_link
  struct bi *desc_link;
  // key
  unsigned long int key;
  // hash_link
  struct bi *hash_link;
};

struct _GC_arrays
{
  // _heapsize
  unsigned long int _heapsize;
  // _requested_heapsize
  unsigned long int _requested_heapsize;
  // _last_heap_addr
  char *_last_heap_addr;
  // _prev_heap_addr
  char *_prev_heap_addr;
  // _large_free_bytes
  unsigned long int _large_free_bytes;
  // _large_allocd_bytes
  unsigned long int _large_allocd_bytes;
  // _max_large_allocd_bytes
  unsigned long int _max_large_allocd_bytes;
  // _bytes_allocd_before_gc
  unsigned long int _bytes_allocd_before_gc;
  // _bytes_allocd
  unsigned long int _bytes_allocd;
  // _bytes_dropped
  unsigned long int _bytes_dropped;
  // _bytes_finalized
  unsigned long int _bytes_finalized;
  // _bytes_freed
  unsigned long int _bytes_freed;
  // _finalizer_bytes_freed
  unsigned long int _finalizer_bytes_freed;
  // _scratch_end_ptr
  char *_scratch_end_ptr;
  // _scratch_last_end_ptr
  char *_scratch_last_end_ptr;
  // _mark_stack
  struct GC_ms_entry *_mark_stack;
  // _mark_stack_limit
  struct GC_ms_entry *_mark_stack_limit;
  // _mark_stack_top
  struct GC_ms_entry * volatile _mark_stack_top;
  // _mark_procs
  struct GC_ms_entry * (*_mark_procs[64l])(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int);
  // _objfreelist
  void *_objfreelist[129l];
  // _aobjfreelist
  void *_aobjfreelist[129l];
  // _uobjfreelist
  void *_uobjfreelist[129l];
  // _auobjfreelist
  void *_auobjfreelist[129l];
  // _composite_in_use
  unsigned long int _composite_in_use;
  // _atomic_in_use
  unsigned long int _atomic_in_use;
  // _size_map
  unsigned long int _size_map[2049l];
  // _obj_map
  signed short int *_obj_map[129l];
  // _valid_offsets
  char _valid_offsets[4096l];
  // _modws_valid_offsets
  char _modws_valid_offsets[(signed long int)sizeof(unsigned long int) /*8l*/ ];
  // _grungy_pages
  unsigned long int _grungy_pages[4096l];
  // _dirty_pages
  unsigned long int _dirty_pages[4096l];
  // _heap_sects
  struct HeapSect _heap_sects[1024l];
  // _static_roots
  struct roots _static_roots[2048l];
  // _root_index
  struct roots *_root_index[64l];
  // _excl_table
  struct exclusion _excl_table[512l];
  // _all_nils
  struct bi *_all_nils;
  // _top_index
  struct bi *_top_index[2048l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_0 __saved_mask;
};

struct _libc_fpxreg
{
  // significand
  unsigned short int significand[4l];
  // exponent
  unsigned short int exponent;
  // padding
  unsigned short int padding[3l];
};

struct _libc_xmmreg
{
  // element
  unsigned int element[4l];
};

struct _libc_fpstate
{
  // cwd
  unsigned short int cwd;
  // swd
  unsigned short int swd;
  // ftw
  unsigned short int ftw;
  // fop
  unsigned short int fop;
  // rip
  unsigned long int rip;
  // rdp
  unsigned long int rdp;
  // mxcsr
  unsigned int mxcsr;
  // mxcr_mask
  unsigned int mxcr_mask;
  // _st
  struct _libc_fpxreg _st[8l];
  // _xmm
  struct _libc_xmmreg _xmm[16l];
  // padding
  unsigned int padding[24l];
};

struct blocking_data
{
  // fn
  void * (*fn)(void *);
  // client_data
  void *client_data;
};

struct closure
{
  // cl_fn
  void (*cl_fn)(void *, void *);
  // cl_data
  void *cl_data;
};

struct hash_chain_entry
{
  // hidden_key
  unsigned long int hidden_key;
  // next
  struct hash_chain_entry *next;
};

struct disappearing_link
{
  // prolog
  struct hash_chain_entry prolog;
  // dl_hidden_obj
  unsigned long int dl_hidden_obj;
};

struct dl_hashtbl_s
{
  // head
  struct disappearing_link **head;
  // log_size
  signed long int log_size;
  // entries
  unsigned long int entries;
};

struct dl_phdr_info
{
  // dlpi_addr
  unsigned long int dlpi_addr;
  // dlpi_name
  const char *dlpi_name;
  // dlpi_phdr
  const struct anonymous_20 *dlpi_phdr;
  // dlpi_phnum
  unsigned short int dlpi_phnum;
  // dlpi_adds
  unsigned long long int dlpi_adds;
  // dlpi_subs
  unsigned long long int dlpi_subs;
  // dlpi_tls_modid
  unsigned long int dlpi_tls_modid;
  // dlpi_tls_data
  void *dlpi_tls_data;
};

struct finalizable_object
{
  // prolog
  struct hash_chain_entry prolog;
  // fo_fn
  void (*fo_fn)(void *, void *);
  // fo_client_data
  char *fo_client_data;
  // fo_object_size
  unsigned long int fo_object_size;
  // fo_mark_proc
  void (*fo_mark_proc)(char *);
};

struct hblk
{
  // hb_body
  char hb_body[4096l];
};

struct hce
{
  // block_addr
  unsigned long int block_addr;
  // hce_hdr
  struct hblkhdr *hce_hdr;
};

struct link_map
{
  // l_addr
  unsigned long int l_addr;
  // l_name
  char *l_name;
  // l_ld
  struct anonymous_22 *l_ld;
  // l_next
  struct link_map *l_next;
  // l_prev
  struct link_map *l_prev;
};

struct load_segment
{
  // start
  char *start;
  // end
  char *end;
  // start2
  char *start2;
  // end2
  char *end2;
};

struct obj_kind
{
  // ok_freelist
  void **ok_freelist;
  // ok_reclaim_list
  struct hblk **ok_reclaim_list;
  // ok_descriptor
  unsigned long int ok_descriptor;
  // ok_relocate_descr
  signed int ok_relocate_descr;
  // ok_init
  signed int ok_init;
  // ok_mark_unconditionally
  signed int ok_mark_unconditionally;
  // ok_disclaim_proc
  signed int (*ok_disclaim_proc)(void *);
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct r_debug
{
  // r_version
  signed int r_version;
  // r_map
  struct link_map *r_map;
  // r_brk
  unsigned long int r_brk;
  // r_state
  enum anonymous_23 r_state;
  // r_ldbase
  unsigned long int r_ldbase;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_11 __sigaction_handler;
  // sa_mask
  struct anonymous_0 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sigaltstack
{
  // ss_sp
  void *ss_sp;
  // ss_flags
  signed int ss_flags;
  // ss_size
  unsigned long int ss_size;
};

struct start_info
{
  // start_routine
  void * (*start_routine)(void *);
  // arg
  void *arg;
  // flags
  unsigned long int flags;
  // registered
  union anonymous_12 registered;
};

struct ucontext
{
  // uc_flags
  unsigned long int uc_flags;
  // uc_link
  struct ucontext *uc_link;
  // uc_stack
  struct sigaltstack uc_stack;
  // uc_mcontext
  struct anonymous_18 uc_mcontext;
  // uc_sigmask
  struct anonymous_0 uc_sigmask;
  // __fpregs_mem
  struct _libc_fpstate __fpregs_mem;
};


// GC_active_count
// file mark.c line 877
unsigned int GC_active_count = (unsigned int)0;
// GC_all_bottom_indices
// file headers.c line 27
struct bi *GC_all_bottom_indices = ((struct bi *)NULL);
// GC_all_bottom_indices_end
// file headers.c line 31
struct bi *GC_all_bottom_indices_end = ((struct bi *)NULL);
// GC_all_interior_pointers
// file misc.c line 129
signed int GC_all_interior_pointers = 1;
// GC_allocate_ml
// file pthread_support.c line 83
union anonymous GC_allocate_ml = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// GC_aobjfreelist_ptr
// file mallocx.c line 43
void ** const GC_aobjfreelist_ptr;
// GC_arrays
// file misc.c line 77
struct _GC_arrays GC_arrays;
// GC_aobjfreelist_ptr
// file mallocx.c line 43
void ** const GC_aobjfreelist_ptr = GC_arrays._aobjfreelist;
// GC_arobjfreelist
// file typd_mlc.c line 339
char **GC_arobjfreelist = (char **)(void *)0;
// GC_array_kind
// file typd_mlc.c line 50
signed int GC_array_kind = 0;
// GC_array_mark_proc_index
// file typd_mlc.c line 101
signed int GC_array_mark_proc_index = 0;
// GC_auobjfreelist_ptr
// file mallocx.c line 46
void ** const GC_auobjfreelist_ptr;
// GC_auobjfreelist_ptr
// file mallocx.c line 46
void ** const GC_auobjfreelist_ptr = GC_arrays._auobjfreelist;
// GC_avail_descr
// file typd_mlc.c line 98
unsigned long int GC_avail_descr = (unsigned long int)0;
// GC_black_list_spacing
// file blacklst.c line 52
unsigned long int GC_black_list_spacing = (unsigned long int)16 * (unsigned long int)(1 << 12);
// GC_bm_table
// file typd_mlc.c line 168
unsigned long int GC_bm_table[32l];
// GC_bytes_allocd_tmp
// file mallocx.c line 246
volatile unsigned long int GC_bytes_allocd_tmp = (volatile unsigned long int)0;
// GC_bytes_found
// file reclaim.c line 25
signed long int GC_bytes_found = (signed long int)0;
// GC_check_heap
// file alloc.c line 543
void (*GC_check_heap)(void) = ((void (*)(void))NULL);
// GC_collect_at_heapsize
// file alloc.c line 296
unsigned long int GC_collect_at_heapsize = (unsigned long int)-1;
// GC_collecting
// file pthread_support.c line 1795
volatile signed int GC_collecting = 0;
// GC_copyright
// file alloc.c line 89
char * const GC_copyright[7l] = { "Copyright 1988,1989 Hans-J. Boehm and Alan J. Demers ",
    "Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved. ",
    "Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved. ",
    "Copyright (c) 1999-2009 by Hewlett-Packard Company.  All rights reserved. ",
    "THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY",
    " EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.",
    "See source code for details." };
// GC_current_warn_proc
// file misc.c line 1596
void (*GC_current_warn_proc)(char *, unsigned long int);
// GC_current_warn_proc
// file misc.c line 1596
void (*GC_current_warn_proc)(char *, unsigned long int) = GC_default_warn_proc;
// GC_data_start
// file os_dep.c line 451
char *GC_data_start = (char *)(void *)0;
// GC_debug_header_size
// file dbg_mlc.c line 476
unsigned long int GC_debug_header_size = sizeof(struct anonymous_16) /*32ul*/ ;
// GC_debugging_started
// file misc.c line 79
signed int GC_debugging_started = 0;
// GC_default_stop_func
// file alloc.c line 146
signed int (*GC_default_stop_func)(void);
// GC_default_stop_func
// file alloc.c line 146
signed int (*GC_default_stop_func)(void) = GC_never_stop_func;
// GC_deficit
// file alloc.c line 496
signed int GC_deficit = 0;
// GC_describe_type_fns
// file dbg_mlc.c line 316
void (*GC_describe_type_fns[16l])(void *, char *) = { ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL) };
// GC_dirty_maintained
// file os_dep.c line 2660
signed int GC_dirty_maintained = 0;
// GC_dl_hashtbl
// file finalize.c line 52
struct dl_hashtbl_s GC_dl_hashtbl = { .head=(struct disappearing_link **)(void *)0, .log_size=(signed long int)-1,
    .entries=(unsigned long int)0 };
// GC_dont_expand
// file alloc.c line 116
signed int GC_dont_expand = 0;
// GC_dont_gc
// file misc.c line 88
signed int GC_dont_gc = 0;
// GC_dont_precollect
// file misc.c line 90
signed int GC_dont_precollect = 0;
// GC_dump_regularly
// file misc.c line 105
signed int GC_dump_regularly = 0;
// GC_ed_size
// file typd_mlc.c line 95
unsigned long int GC_ed_size = (unsigned long int)0;
// GC_eobjfreelist
// file typd_mlc.c line 337
char **GC_eobjfreelist = (char **)(void *)0;
// GC_excl_table_entries
// file mark_rts.c line 412
unsigned long int GC_excl_table_entries = (unsigned long int)0;
// GC_explicit_kind
// file typd_mlc.c line 46
signed int GC_explicit_kind = 0;
// GC_explicit_typing_initialized
// file typd_mlc.c line 44
signed int GC_explicit_typing_initialized = 0;
// GC_ext_descriptors
// file typd_mlc.c line 91
struct anonymous_19 *GC_ext_descriptors = (struct anonymous_19 *)(void *)0;
// GC_fail_count
// file alloc.c line 1238
unsigned int GC_fail_count = (unsigned int)0;
// GC_fault_handler_lock
// file os_dep.c line 3027
volatile unsigned char GC_fault_handler_lock = (volatile unsigned char)(unsigned long int)AO_BYTE_TS_clear;
// GC_finalize_now
// file finalize.c line 72
struct finalizable_object *GC_finalize_now = ((struct finalizable_object *)NULL);
// GC_finalize_on_demand
// file misc.c line 137
signed int GC_finalize_on_demand = 0;
// GC_finalized_kind
// file fnlz_mlc.c line 27
signed int GC_finalized_kind = 0;
// GC_finalized_objfreelist
// file thread_local_alloc.c line 36
char **GC_finalized_objfreelist = (char **)(void *)0;
// GC_finalizer_notifier
// file misc.c line 147
void (*GC_finalizer_notifier)(void) = (void (*)(void))0;
// GC_find_leak
// file misc.c line 117
signed int GC_find_leak = 0;
// GC_findleak_delay_free
// file misc.c line 124
signed int GC_findleak_delay_free = 0;
// GC_first_nonempty
// file mark.c line 107
volatile unsigned long int GC_first_nonempty = (volatile unsigned long int)0;
// GC_fl_builder_count
// file reclaim.c line 31
unsigned long int GC_fl_builder_count = (unsigned long int)0;
// GC_fo_entries
// file alloc.c line 1236
unsigned long int GC_fo_entries = (unsigned long int)0;
// GC_fo_head
// file finalize.c line 70
struct finalizable_object **GC_fo_head = ((struct finalizable_object **)NULL);
// GC_force_unmap_on_gcollect
// file misc.c line 155
signed int GC_force_unmap_on_gcollect = 0;
// GC_free_bytes
// file allchblk.c line 64
unsigned long int GC_free_bytes[61l] = { (unsigned long int)0, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul };
// GC_free_space_divisor
// file alloc.c line 123
unsigned long int GC_free_space_divisor = (unsigned long int)3;
// GC_full_freq
// file alloc.c line 77
signed int GC_full_freq = 19;
// GC_gc_no
// file alloc.c line 61
unsigned long int GC_gc_no = (unsigned long int)0;
// GC_gcj_debug_kind
// file gcj_mlc.c line 51
signed int GC_gcj_debug_kind = 0;
// GC_gcj_kind
// file gcj_mlc.c line 49
signed int GC_gcj_kind = 0;
// GC_gcj_malloc_initialized
// file gcj_mlc.c line 47
signed int GC_gcj_malloc_initialized = 0;
// GC_gcjdebugobjfreelist
// file gcj_mlc.c line 57
char **GC_gcjdebugobjfreelist = (char **)(void *)0;
// GC_gcjobjfreelist
// file gcj_mlc.c line 55
char **GC_gcjobjfreelist = (char **)(void *)0;
// GC_greatest_plausible_heap_addr
// file alloc.c line 1130
void *GC_greatest_plausible_heap_addr = NULL;
// GC_handle_fork
// file misc.c line 178
signed int GC_handle_fork = 0;
// GC_has_static_roots
// file dyn_load.c line 50
signed int (*GC_has_static_roots)(const char *, void *, unsigned long int) = ((signed int (*)(const char *, void *, unsigned long int))NULL);
// GC_have_errors
// file reclaim.c line 46
signed int GC_have_errors = 0;
// GC_hblkfreelist
// file allchblk.c line 54
struct hblk *GC_hblkfreelist[61l] = { ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL) };
// GC_help_wanted
// file mark.c line 874
signed int GC_help_wanted = 0;
// GC_helper_count
// file mark.c line 875
unsigned int GC_helper_count = (unsigned int)0;
// GC_in_thread_creation
// file pthread_support.c line 1503
signed int GC_in_thread_creation = 0;
// GC_incomplete_normal_bl
// file blacklst.c line 43
unsigned long int *GC_incomplete_normal_bl = (unsigned long int *)(void *)0;
// GC_incomplete_stack_bl
// file blacklst.c line 47
unsigned long int *GC_incomplete_stack_bl = (unsigned long int *)(void *)0;
// GC_incremental
// file alloc.c line 64
signed int GC_incremental = 0;
// GC_is_full_gc
// file alloc.c line 341
signed int GC_is_full_gc = 0;
// GC_is_initialized
// file misc.c line 737
signed int GC_is_initialized = 0;
// GC_is_valid_displacement_print_proc
// file ptr_chck.c line 108
void (*GC_is_valid_displacement_print_proc)(void *);
// GC_is_valid_displacement_print_proc
// file ptr_chck.c line 108
void (*GC_is_valid_displacement_print_proc)(void *) = GC_default_is_valid_displacement_print_proc;
// GC_is_visible_print_proc
// file ptr_chck.c line 157
void (*GC_is_visible_print_proc)(void *);
// GC_is_visible_print_proc
// file ptr_chck.c line 157
void (*GC_is_visible_print_proc)(void *) = GC_default_is_visible_print_proc;
// GC_java_finalization
// file misc.c line 141
signed int GC_java_finalization = 1;
// GC_jmp_buf
// file ./include/private/gc_priv.h line 2484
struct __jmp_buf_tag GC_jmp_buf[1l];
// GC_large_alloc_warn_interval
// file misc.c line 161
signed long int GC_large_alloc_warn_interval = (signed long int)5;
// GC_large_alloc_warn_suppressed
// file allchblk.c line 631
signed long int GC_large_alloc_warn_suppressed = (signed long int)0;
// GC_leaked
// file reclaim.c line 43
char *GC_leaked[40l] = { (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) };
// GC_least_plausible_heap_addr
// file alloc.c line 1129
void *GC_least_plausible_heap_addr = (void *)(unsigned long int)(signed long int)-1;
// GC_ll_hashtbl
// file finalize.c line 55
struct dl_hashtbl_s GC_ll_hashtbl = { .head=(struct disappearing_link **)(void *)0, .log_size=(signed long int)-1,
    .entries=(unsigned long int)0 };
// GC_log
// file misc.c line 784
signed int GC_log = 2;
// GC_mark_no
// file mark.c line 884
unsigned long int GC_mark_no = (unsigned long int)0;
// GC_mark_stack_size
// file mark.c line 104
unsigned long int GC_mark_stack_size = (unsigned long int)0;
// GC_mark_stack_too_small
// file mark.c line 116
signed int GC_mark_stack_too_small = 0;
// GC_mark_state
// file mark.c line 114
signed int GC_mark_state = 0;
// GC_mark_threads
// file pthread_support.c line 393
unsigned long int GC_mark_threads[16l];
// GC_max_heapsize
// file alloc.c line 1142
unsigned long int GC_max_heapsize = (unsigned long int)0;
// GC_max_retries
// file alloc.c line 1149
unsigned long int GC_max_retries = (unsigned long int)0;
// GC_n_attempts
// file alloc.c line 143
signed int GC_n_attempts = 0;
// GC_n_heap_sects
// file alloc.c line 1019
unsigned long int GC_n_heap_sects = (unsigned long int)0;
// GC_n_kinds
// file mark.c line 88
unsigned int GC_n_kinds = (unsigned int)4;
// GC_n_leaked
// file reclaim.c line 44
unsigned int GC_n_leaked = (unsigned int)0;
// GC_n_mark_procs
// file mark.c line 43
unsigned int GC_n_mark_procs = (unsigned int)8;
// GC_n_rescuing_pages
// file mark.c line 100
unsigned long int GC_n_rescuing_pages = (unsigned long int)0;
// GC_n_smashed
// file dbg_mlc.c line 943
unsigned int GC_n_smashed = (unsigned int)0;
// GC_need_full_gc
// file alloc.c line 79
signed int GC_need_full_gc = 0;
// GC_need_to_lock
// file pthread_support.c line 277
signed int GC_need_to_lock = 0;
// GC_no_dls
// file mark_rts.c line 37
signed int GC_no_dls = 0;
// GC_non_gc_bytes
// file alloc.c line 59
unsigned long int GC_non_gc_bytes = (unsigned long int)0;
// GC_non_gc_bytes_at_gc
// file alloc.c line 237
unsigned long int GC_non_gc_bytes_at_gc = (unsigned long int)0;
// GC_noop_sink
// file mark.c line 35
volatile unsigned long int GC_noop_sink;
// GC_nprocs
// file pthread_support.c line 279
signed int GC_nprocs = 1;
// GC_obj_kinds
// file mark.c line 49
struct obj_kind GC_obj_kinds[16l];
// GC_obj_kinds
// file mark.c line 49
struct obj_kind GC_obj_kinds[16l] = { { .ok_freelist=&GC_arrays._aobjfreelist[(signed long int)0], .ok_reclaim_list=((struct hblk **)NULL),
    .ok_descriptor=(unsigned long int)(0 | 0),
    .ok_relocate_descr=0,
    .ok_init=0, .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=&GC_arrays._objfreelist[(signed long int)0], .ok_reclaim_list=((struct hblk **)NULL),
    .ok_descriptor=(unsigned long int)(0 | 0),
    .ok_relocate_descr=1,
    .ok_init=1, .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=&GC_arrays._uobjfreelist[(signed long int)0], .ok_reclaim_list=((struct hblk **)NULL),
    .ok_descriptor=(unsigned long int)(0 | 0),
    .ok_relocate_descr=1,
    .ok_init=1, .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=&GC_arrays._auobjfreelist[(signed long int)0], .ok_reclaim_list=((struct hblk **)NULL),
    .ok_descriptor=(unsigned long int)(0 | 0),
    .ok_relocate_descr=0,
    .ok_init=0, .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) } };
// GC_objects_are_marked
// file mark.c line 120
signed int GC_objects_are_marked = 0;
// GC_objfreelist_ptr
// file mallocx.c line 42
void ** const GC_objfreelist_ptr;
// GC_objfreelist_ptr
// file mallocx.c line 42
void ** const GC_objfreelist_ptr = GC_arrays._objfreelist;
// GC_old_bus_handler
// file os_dep.c line 3010
void (*GC_old_bus_handler)(signed int, struct anonymous_10 *, void *) = ((void (*)(signed int, struct anonymous_10 *, void *))NULL);
// GC_old_dl_entries
// file finalize.c line 637
unsigned long int GC_old_dl_entries = (unsigned long int)0;
// GC_old_ll_entries
// file finalize.c line 639
unsigned long int GC_old_ll_entries = (unsigned long int)0;
// GC_old_normal_bl
// file blacklst.c line 40
unsigned long int *GC_old_normal_bl = (unsigned long int *)(void *)0;
// GC_old_segv_handler
// file os_dep.c line 3007
void (*GC_old_segv_handler)(signed int, struct anonymous_10 *, void *) = ((void (*)(signed int, struct anonymous_10 *, void *))NULL);
// GC_old_segv_handler_used_si
// file os_dep.c line 3014
signed int GC_old_segv_handler_used_si = 0;
// GC_old_stack_bl
// file blacklst.c line 46
unsigned long int *GC_old_stack_bl = (unsigned long int *)(void *)0;
// GC_on_abort
// file misc.c line 1693
void (*GC_on_abort)(const char *);
// GC_on_abort
// file misc.c line 1693
void (*GC_on_abort)(const char *) = GC_default_on_abort;
// GC_on_heap_resize
// file alloc.c line 812
void (*GC_on_heap_resize)(unsigned long int) = ((void (*)(unsigned long int))NULL);
// GC_oom_fn
// file misc.c line 171
void * (*GC_oom_fn)(unsigned long int);
// GC_oom_fn
// file misc.c line 171
void * (*GC_oom_fn)(unsigned long int) = GC_default_oom_fn;
// GC_page_size
// file os_dep.c line 716
unsigned long int GC_page_size = (unsigned long int)0;
// GC_pages_executable
// file os_dep.c line 131
signed int GC_pages_executable = 0;
// GC_parallel
// file alloc.c line 68
signed int GC_parallel = 0;
// GC_print_all_smashed
// file alloc.c line 544
void (*GC_print_all_smashed)(void) = ((void (*)(void))NULL);
// GC_print_back_height
// file misc.c line 101
signed int GC_print_back_height = 0;
// GC_print_heap_obj
// file blacklst.c line 68
void (*GC_print_heap_obj)(char *);
// GC_print_heap_obj
// file blacklst.c line 68
void (*GC_print_heap_obj)(char *) = GC_default_print_heap_obj_proc;
// GC_print_stats
// file misc.c line 95
signed int GC_print_stats = 0;
// GC_push_other_roots
// file os_dep.c line 2607
void (*GC_push_other_roots)(void);
// GC_push_other_roots
// file os_dep.c line 2607
void (*GC_push_other_roots)(void) = GC_default_push_other_roots;
// GC_push_typed_structures
// file mark_rts.c line 705
void (*GC_push_typed_structures)(void) = ((void (*)(void))NULL);
// GC_quiet
// file misc.c line 92
signed int GC_quiet = 0;
// GC_reclaimed_bytes_before_gc
// file misc.c line 538
unsigned long int GC_reclaimed_bytes_before_gc = (unsigned long int)0;
// GC_retry_signals
// file pthread_stop_world.c line 118
signed int GC_retry_signals = 0;
// GC_root_size
// file mark_rts.c line 149
unsigned long int GC_root_size = (unsigned long int)0;
// GC_same_obj_print_proc
// file ptr_chck.c line 27
void (*GC_same_obj_print_proc)(void *, void *);
// GC_same_obj_print_proc
// file ptr_chck.c line 27
void (*GC_same_obj_print_proc)(void *, void *) = GC_default_same_obj_print_proc;
// GC_sig_suspend
// file pthread_stop_world.c line 150
signed int GC_sig_suspend = -1;
// GC_sig_thr_restart
// file pthread_stop_world.c line 151
signed int GC_sig_thr_restart = -1;
// GC_smashed
// file dbg_mlc.c line 942
char *GC_smashed[20l] = { ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) };
// GC_stackbottom
// file misc.c line 82
char *GC_stackbottom = ((char *)NULL);
// GC_start_call_back
// file alloc.c line 311
void (*GC_start_call_back)(void) = ((void (*)(void))NULL);
// GC_start_time
// file alloc.c line 138
signed long int GC_start_time = (signed long int)0;
// GC_stderr
// file misc.c line 783
signed int GC_stderr = 2;
// GC_stdout
// file misc.c line 782
signed int GC_stdout = 1;
// GC_stop_count
// file pthread_stop_world.c line 106
volatile unsigned long int GC_stop_count = (volatile unsigned long int)0;
// GC_suspend_ack_sem
// file pthread_stop_world.c line 194
union anonymous_12 GC_suspend_ack_sem;
// GC_thr_initialized
// file pthread_support.c line 452
signed int GC_thr_initialized = 0;
// GC_thread_key
// file thread_local_alloc.c line 31
void *GC_thread_key;
// GC_threads
// file pthread_support.c line 454
struct GC_Thread_Rep * volatile GC_threads[256l] = { ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL) };
// GC_time_limit
// file alloc.c line 135
unsigned long int GC_time_limit = (unsigned long int)50;
// GC_total_stack_black_listed
// file blacklst.c line 49
unsigned long int GC_total_stack_black_listed = (unsigned long int)0;
// GC_total_stacksize
// file alloc.c line 194
unsigned long int GC_total_stacksize = (unsigned long int)0;
// GC_typed_mark_proc_index
// file typd_mlc.c line 100
signed int GC_typed_mark_proc_index = 0;
// GC_uobjfreelist_ptr
// file mallocx.c line 44
void ** const GC_uobjfreelist_ptr;
// GC_uobjfreelist_ptr
// file mallocx.c line 44
void ** const GC_uobjfreelist_ptr = GC_arrays._uobjfreelist;
// GC_use_entire_heap
// file allchblk.c line 24
signed int GC_use_entire_heap = 0;
// GC_used_heap_size_after_full
// file alloc.c line 86
unsigned long int GC_used_heap_size_after_full = (unsigned long int)0;
// GC_version
// file alloc.c line 101
const unsigned int GC_version = (const unsigned int)(7 << 16 | 4 << 8 | 2);
// GC_world_is_stopped
// file pthread_stop_world.c line 109
volatile unsigned long int GC_world_is_stopped = (volatile unsigned long int)0;
// GC_world_stopped
// file alloc.c line 83
signed int GC_world_stopped = 0;
// _DYNAMIC
// file /usr/include/link.h line 76
extern struct anonymous_22 _DYNAMIC[];
// __data_start
// file os_dep.c line 442
extern signed int __data_start[];
// __libc_stack_end
// file os_dep.c line 1037
extern char *__libc_stack_end;
// _end
// file ./include/private/gcconfig.h line 2247
extern signed int _end[];
// available_markers_m1
// file pthread_support.c line 396
static signed int available_markers_m1 = 0;
// builder_cv
// file pthread_support.c line 1980
static union anonymous_15 builder_cv = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// data_start
// file os_dep.c line 442
extern signed int data_start[];
// done_init
// file fnlz_mlc.c line 48
static signed int done_init = 0;
// first_thread
// file pthread_support.c line 485
static struct GC_Thread_Rep first_thread;
// fork_cancel_state
// file pthread_support.c line 944
static signed int fork_cancel_state;
// hdr_free_list
// file headers.c line 161
static struct hblkhdr *hdr_free_list = ((struct hblkhdr *)NULL);
// installed_looping_handler
// file misc.c line 761
static signed int installed_looping_handler = 0;
// keys_initialized
// file thread_local_alloc.c line 33
static signed int keys_initialized;
// last_bytes_finalized
// file alloc.c line 1243
static unsigned long int last_bytes_finalized = (unsigned long int)0;
// last_finalizer_notification
// file finalize.c line 1010
static unsigned long int last_finalizer_notification = (unsigned long int)0;
// last_fo_entries
// file alloc.c line 1242
static unsigned long int last_fo_entries = (unsigned long int)0;
// load_segs
// file dyn_load.c line 464
static struct load_segment load_segs[2048l];
// log_fo_table_size
// file finalize.c line 75
static signed long int log_fo_table_size = (signed long int)-1;
// mark_cv
// file pthread_support.c line 2030
static union anonymous_15 mark_cv = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mark_mutex
// file pthread_support.c line 1977
static union anonymous mark_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// marker_sp
// file pthread_support.c line 336
static char *marker_sp[15l] = { ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) };
// n_load_segs
// file dyn_load.c line 466
static signed int n_load_segs;
// n_root_sets
// file mark_rts.c line 39
static signed int n_root_sets = 0;
// need_unreachable_finalization
// file finalize.c line 579
static signed int need_unreachable_finalization = 0;
// old_bus_handler
// file os_dep.c line 872
static void (*old_bus_handler)(signed int);
// old_segv_handler
// file os_dep.c line 870
static void (*old_segv_handler)(signed int);
// parallel_initialized
// file pthread_support.c line 275
static signed int parallel_initialized = 0;
// roots_were_cleared
// file mark_rts.c line 263
static signed int roots_were_cleared = 0;
// scan_ptr
// file mark.c line 118
static struct hblk *scan_ptr;
// scratch_free_ptr
// file headers.c line 113
static char *scratch_free_ptr = ((char *)NULL);
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// suspend_handler_mask
// file pthread_stop_world.c line 104
static struct anonymous_0 suspend_handler_mask;
// world_stopped_total_divisor
// file alloc.c line 564
static unsigned int world_stopped_total_divisor = (unsigned int)0;
// world_stopped_total_time
// file alloc.c line 563
static unsigned int world_stopped_total_time = (unsigned int)0;
// zero_fd
// file os_dep.c line 2028
static signed int zero_fd;

// AO_char_store
// file /usr/include/atomic_ops/sysdeps/loadstore/char_atomic_store.h line 28
static inline void AO_char_store(volatile unsigned char *addr, unsigned char new_val)
{
  *((unsigned char *)addr) = new_val;
}

// AO_compare_and_swap_full
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full(volatile unsigned long int *addr, unsigned long int old, unsigned long int new_val)
{
  _Bool return_value___sync_bool_compare_and_swap_1;
  __CPROVER_atomic_begin();
  return_value___sync_bool_compare_and_swap_1 = *addr == old;
  *addr = *addr == old ? new_val : *addr;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  return (signed int)return_value___sync_bool_compare_and_swap_1;
}

// AO_compare_and_swap_full_link1
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full_link1(volatile unsigned long int *addr_link1, unsigned long int old_link1, unsigned long int new_val_link1)
{
  _Bool return_value___sync_bool_compare_and_swap_1_link1;
  __CPROVER_atomic_begin();
  return_value___sync_bool_compare_and_swap_1_link1 = *addr_link1 == old_link1;
  *addr_link1 = *addr_link1 == old_link1 ? new_val_link1 : *addr_link1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  return (signed int)return_value___sync_bool_compare_and_swap_1_link1;
}

// AO_fetch_and_add
// file /usr/include/atomic_ops/generalize-arithm.h line 2726
static inline unsigned long int AO_fetch_and_add(volatile unsigned long int *addr, unsigned long int incr)
{
  unsigned long int old;
  signed int return_value_AO_compare_and_swap_full_1;
  do
  {
    old = *((unsigned long int *)addr);
    return_value_AO_compare_and_swap_full_1=AO_compare_and_swap_full(addr, old, old + incr);
  }
  while(return_value_AO_compare_and_swap_full_1 == 0);
  return old;
}

// AO_load
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load(const volatile unsigned long int *addr)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr);
}

// AO_load_link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load_link1(const volatile unsigned long int *addr_link1)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr_link1 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr_link1);
}

// AO_load_link2
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load_link2(const volatile unsigned long int *addr_link2)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr_link2 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr_link2);
}

// AO_load_link3
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load_link3(const volatile unsigned long int *addr_link3)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr_link3 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr_link3);
}

// AO_load_read
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read(const volatile unsigned long int *addr)
{
  unsigned long int result;
  result=AO_load_link1(addr);
  AO_nop_read();
  return result;
}

// AO_load_read_link1
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read_link1(const volatile unsigned long int *addr_link1)
{
  unsigned long int result_link1;
  result_link1=AO_load_link3(addr_link1);
  AO_nop_read_link1();
  return result_link1;
}

// AO_nop_read
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_read_link1
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read_link1(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_write
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_write_link1
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write_link1(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_write_link2
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write_link2(void)
{
  asm("" :  :  : "memory");
}

// AO_store
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store(volatile unsigned long int *addr, unsigned long int new_val)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr & sizeof(volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  *((unsigned long int *)addr) = new_val;
}

// AO_store_link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store_link1(volatile unsigned long int *addr_link1, unsigned long int new_val_link1)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr_link1 & sizeof(volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  *((unsigned long int *)addr_link1) = new_val_link1;
}

// AO_store_link2
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store_link2(volatile unsigned long int *addr_link2, unsigned long int new_val_link2)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr_link2 & sizeof(volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  *((unsigned long int *)addr_link2) = new_val_link2;
}

// AO_test_and_set_full
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 124
static inline enum anonymous_1 AO_test_and_set_full(volatile unsigned char *addr)
{
  unsigned char oldval;
  asm("xchgb %0, %1" : "=q"(oldval), "=m"(*addr) : "0"((unsigned char)0xff), "m"(*addr) : "memory");
  return (enum anonymous_1)oldval;
}

// GC_FirstDLOpenedLinkMap
// file dyn_load.c line 678
struct link_map * GC_FirstDLOpenedLinkMap(void)
{
  struct anonymous_22 *dp;
  static struct link_map *cachedResult = ((struct link_map *)NULL);
  if(cachedResult == ((struct link_map *)NULL))
  {
    signed int tag;
    dp = _DYNAMIC;
    do
    {
      tag = (signed int)dp->d_tag;
      if(tag == 0)
        break;

      if(tag == 21)
      {
        struct link_map *lm = ((struct r_debug *)dp->d_un.d_ptr)->r_map;
        if(!(lm == ((struct link_map *)NULL)))
          cachedResult = lm->l_next;

        break;
      }

      dp = dp + 1l;
    }
    while((_Bool)1);
  }

  return cachedResult;
}

// GC_acquire_mark_lock
// file ./include/private/gc_priv.h line 2371
void GC_acquire_mark_lock(void)
{
  GC_generic_lock(&mark_mutex);
}

// GC_add_ext_descriptor
// file typd_mlc.c line 113
signed long int GC_add_ext_descriptor(const unsigned long int *bm, unsigned long int nbits)
{
  unsigned long int nwords = (nbits + (unsigned long int)64) - (unsigned long int)1 >> (unsigned long int)6;
  signed long int result;
  unsigned long int i;
  unsigned long int last_part;
  unsigned long int extra_bits;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  while(nwords + GC_avail_descr >= GC_ed_size)
  {
    struct anonymous_19 *new;
    unsigned long int new_size;
    unsigned long int ed_size = GC_ed_size;
    if(ed_size == 0ul)
    {
      GC_push_typed_structures = GC_push_typed_structures_proc;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      new_size = (unsigned long int)100;
    }

    else
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      new_size = (unsigned long int)2 * ed_size;
      if(new_size >= 72057594037927936ul)
        return (signed long int)-1;

    }
    void *return_value_GC_malloc_atomic_2;
    return_value_GC_malloc_atomic_2=GC_malloc_atomic(new_size * sizeof(struct anonymous_19) /*16ul*/ );
    new = (struct anonymous_19 *)return_value_GC_malloc_atomic_2;
    if(new == ((struct anonymous_19 *)NULL))
      return (signed long int)-1;

    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_3;
        return_value_pthread_mutex_trylock_3=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_3 == 0))
          GC_lock();

      }

    while((_Bool)0);
    if(ed_size == GC_ed_size)
    {
      if(!(GC_avail_descr == 0ul))
        memcpy((void *)new, (const void *)GC_ext_descriptors, (unsigned long int)(GC_avail_descr * sizeof(struct anonymous_19) /*16ul*/ ));

      GC_ed_size = new_size;
      GC_ext_descriptors = new;
    }

  }
  result = (signed long int)GC_avail_descr;
  i = (unsigned long int)0;
  for( ; !(i >= nwords + 18446744073709551615ul); i = i + 1ul)
  {
    (GC_ext_descriptors + (signed long int)((unsigned long int)result + i))->ed_bitmap = bm[(signed long int)i];
    (GC_ext_descriptors + (signed long int)((unsigned long int)result + i))->ed_continued = 1;
  }
  last_part = bm[(signed long int)i];
  extra_bits = nwords * (unsigned long int)64 - nbits;
  last_part = last_part << extra_bits;
  last_part = last_part >> extra_bits;
  (GC_ext_descriptors + (signed long int)((unsigned long int)result + i))->ed_bitmap = last_part;
  (GC_ext_descriptors + (signed long int)((unsigned long int)result + i))->ed_continued = 0;
  GC_avail_descr = GC_avail_descr + nwords;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_add_leaked
// file reclaim.c line 52
static inline void GC_add_leaked(char *leaked)
{
  signed int return_value_GC_check_leaked_1;
  if(!(GC_findleak_delay_free == 0))
  {
    return_value_GC_check_leaked_1=GC_check_leaked(leaked);
    if(return_value_GC_check_leaked_1 == 0)
      goto __CPROVER_DUMP_L3;

  }

  GC_have_errors = 1;
  if(!(GC_n_leaked >= 40u))
  {
    unsigned int tmp_post_2 = GC_n_leaked;
    GC_n_leaked = GC_n_leaked + 1u;
    GC_leaked[(signed long int)tmp_post_2] = leaked;
    GC_set_mark_bit((const void *)leaked);
  }


__CPROVER_DUMP_L3:
  ;
}

// GC_add_map_entry
// file ./include/private/gc_priv.h line 1734
signed int GC_add_map_entry(unsigned long int granules)
{
  unsigned int displ;
  signed short int *new_map;
  if(granules >= 129ul)
    granules = (unsigned long int)0;

  if(!(GC_arrays._obj_map[(signed long int)granules] == ((signed short int *)NULL)))
    return 1;

  else
  {
    char *return_value_GC_scratch_alloc_1;
    return_value_GC_scratch_alloc_1=GC_scratch_alloc(((unsigned long int)(1 << 12) >> 4) * sizeof(signed short int) /*2ul*/ );
    new_map = (signed short int *)return_value_GC_scratch_alloc_1;
    if(new_map == ((signed short int *)NULL))
      return 0;

    else
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Adding block map for size of %u granules (%u bytes)\n", (unsigned int)granules, (unsigned int)(granules << 4));

      if(granules == 0ul)
      {
        displ = (unsigned int)0;
        for( ; !((unsigned long int)displ >= 256ul); displ = displ + 1u)
          new_map[(signed long int)displ] = (signed short int)1;
      }

      else
      {
        displ = (unsigned int)0;
        for( ; !((unsigned long int)displ >= 256ul); displ = displ + 1u)
          new_map[(signed long int)displ] = (signed short int)((unsigned long int)displ % granules);
      }
      GC_arrays._obj_map[(signed long int)granules] = new_map;
      return 1;
    }
  }
}

// GC_add_roots
// file mark_rts.c line 151
extern void GC_add_roots(void *b, void *e)
{
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_add_roots_inner((char *)b, (char *)e, 0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_add_roots_inner
// file ./include/private/gc_priv.h line 1660
void GC_add_roots_inner(char *b, char *e, signed int tmp)
{
  struct roots *old;
  b = (char *)((unsigned long int)b + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1) & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
  e = (char *)((unsigned long int)e & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
  if(!((unsigned long int)b >= (unsigned long int)e))
  {
    void *return_value_GC_roots_present_1;
    return_value_GC_roots_present_1=GC_roots_present(b);
    old = (struct roots *)return_value_GC_roots_present_1;
    if(!(old == ((struct roots *)NULL)))
    {
      if((unsigned long int)old->r_end >= (unsigned long int)e)
        goto __CPROVER_DUMP_L5;

      GC_root_size = GC_root_size + (unsigned long int)(e - old->r_end);
      old->r_end = e;
    }

    else
    {
      if(n_root_sets == 2048)
      {
        GC_on_abort("Too many root sets");
        abort();
      }

      GC_arrays._static_roots[(signed long int)n_root_sets].r_start = (char *)b;
      GC_arrays._static_roots[(signed long int)n_root_sets].r_end = (char *)e;
      GC_arrays._static_roots[(signed long int)n_root_sets].r_tmp = tmp;
      GC_arrays._static_roots[(signed long int)n_root_sets].r_next = ((struct roots *)NULL);
      add_roots_to_index(GC_arrays._static_roots + (signed long int)n_root_sets);
      GC_root_size = GC_root_size + (unsigned long int)(e - b);
      n_root_sets = n_root_sets + 1;
    }
  }


__CPROVER_DUMP_L5:
  ;
}

// GC_add_smashed
// file dbg_mlc.c line 945
void GC_add_smashed(char *smashed)
{
  GC_smashed[(signed long int)GC_n_smashed] = smashed;
  if(!(GC_n_smashed >= 19u))
    GC_n_smashed = GC_n_smashed + 1u;

  GC_have_errors = 1;
}

// GC_add_to_black_list_normal
// file blacklst.c line 183
void GC_add_to_black_list_normal(unsigned long int p)
{
  if(!(GC_arrays._modws_valid_offsets[7l & (signed long int)p] == 0))
  {
    unsigned long int index = (unsigned long int)p >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
    struct hblkhdr *return_value_GC_find_header_1;
    return_value_GC_find_header_1=GC_find_header((char *)p);
    _Bool tmp_if_expr_2;
    if(return_value_GC_find_header_1 == ((struct hblkhdr *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (GC_old_normal_bl[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      GC_incomplete_normal_bl[(signed long int)(index >> (unsigned long int)6)] = GC_incomplete_normal_bl[(signed long int)(index >> (unsigned long int)6)] | (unsigned long int)1 << (index & (unsigned long int)0x3f);

  }

}

// GC_add_to_black_list_stack
// file blacklst.c line 205
void GC_add_to_black_list_stack(unsigned long int p)
{
  unsigned long int index = (unsigned long int)p >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
  struct hblkhdr *return_value_GC_find_header_1;
  return_value_GC_find_header_1=GC_find_header((char *)p);
  _Bool tmp_if_expr_2;
  if(return_value_GC_find_header_1 == ((struct hblkhdr *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (GC_old_stack_bl[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    GC_incomplete_stack_bl[(signed long int)(index >> (unsigned long int)6)] = GC_incomplete_stack_bl[(signed long int)(index >> (unsigned long int)6)] | (unsigned long int)1 << (index & (unsigned long int)0x3f);

}

// GC_add_to_fl
// file allchblk.c line 352
void GC_add_to_fl(struct hblk *h, struct hblkhdr *hhdr)
{
  signed int index;
  index=GC_hblk_fl_from_blocks(hhdr->hb_sz >> (unsigned long int)12);
  struct hblk *second = GC_hblkfreelist[(signed long int)index];
  struct hblkhdr *second_hdr;
  GC_hblkfreelist[(signed long int)index] = h;
  GC_free_bytes[(signed long int)index] = GC_free_bytes[(signed long int)index] + hhdr->hb_sz;
  hhdr->hb_next = second;
  hhdr->hb_prev = ((struct hblk *)NULL);
  if(!(second == ((struct hblk *)NULL)))
  {
    do
    {
      struct hblkhdr **_ha;
      do
      {
        struct bi *bi;
        do
        {
          unsigned long int hi = (unsigned long int)second >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(_bi->key == hi); _bi = _bi->hash_link)
            if(_bi == GC_arrays._all_nils)
              break;

          bi = _bi;
        }
        while((_Bool)0);
        _ha = &bi->index[(signed long int)((unsigned long int)second >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      second_hdr = *_ha;
    }
    while((_Bool)0);
    second_hdr->hb_prev = h;
  }

  hhdr->hb_flags = hhdr->hb_flags | (unsigned char)4;
}

// GC_add_to_heap
// file alloc.c line 1045
void GC_add_to_heap(struct hblk *p, unsigned long int bytes)
{
  struct hblkhdr *phdr;
  unsigned long int endp;
  if(GC_n_heap_sects >= 1024ul)
  {
    GC_on_abort("Too many heap sections: Increase MAXHINCR or MAX_HEAP_SECTS");
    abort();
  }

  while(!((unsigned long int)p >= 4097ul))
  {
    p = p + 1l;
    bytes = bytes - (unsigned long int)(1 << 12);
    if(bytes == 0ul)
      goto __CPROVER_DUMP_L10;

  }
  endp = (unsigned long int)p + bytes;
  if((unsigned long int)p >= endp)
  {
    bytes = bytes - (unsigned long int)(1 << 12);
    if(bytes == 0ul)
      goto __CPROVER_DUMP_L10;

    endp = endp - (unsigned long int)(1 << 12);
  }

  phdr=GC_install_header(p);
  if(!(phdr == ((struct hblkhdr *)NULL)))
  {
    GC_arrays._heap_sects[(signed long int)GC_n_heap_sects].hs_start = (char *)p;
    GC_arrays._heap_sects[(signed long int)GC_n_heap_sects].hs_bytes = bytes;
    GC_n_heap_sects = GC_n_heap_sects + 1ul;
    phdr->hb_sz = bytes;
    phdr->hb_flags = (unsigned char)0;
    GC_freehblk(p);
    GC_arrays._heapsize = GC_arrays._heapsize + bytes;
    GC_collect_at_heapsize = GC_collect_at_heapsize + bytes;
    if(!(GC_collect_at_heapsize >= GC_arrays._heapsize))
      GC_collect_at_heapsize = (unsigned long int)-1;

    if(GC_least_plausible_heap_addr == NULL || (unsigned long int)GC_least_plausible_heap_addr >= (unsigned long int)p)
      GC_least_plausible_heap_addr = (void *)((char *)p - (signed long int)sizeof(unsigned long int) /*8ul*/ );

    if(bytes + (unsigned long int)p >= (unsigned long int)GC_greatest_plausible_heap_addr)
      GC_greatest_plausible_heap_addr = (void *)endp;

  }


__CPROVER_DUMP_L10:
  ;
}

// GC_adj_bytes_allocd
// file alloc.c line 244
unsigned long int GC_adj_bytes_allocd(void)
{
  signed long int result;
  signed long int expl_managed = (signed long int)GC_non_gc_bytes - (signed long int)GC_non_gc_bytes_at_gc;
  result = ((((signed long int)GC_arrays._bytes_allocd + (signed long int)GC_arrays._bytes_dropped) - (signed long int)GC_arrays._bytes_freed) + (signed long int)GC_arrays._finalizer_bytes_freed) - expl_managed;
  if(!((signed long int)GC_arrays._bytes_allocd >= result))
    result = (signed long int)GC_arrays._bytes_allocd;

  result = result + (signed long int)GC_arrays._bytes_finalized;
  if(!(result >= (signed long int)(GC_arrays._bytes_allocd >> 3)))
    return GC_arrays._bytes_allocd >> 3;

  else
    return (unsigned long int)result;
}

// GC_alloc_large
// file malloc.c line 42
char * GC_alloc_large(unsigned long int lb, signed int k, unsigned int flags)
{
  struct hblk *h;
  unsigned long int n_blocks;
  char *result;
  signed int retry = 0;
  lb = (lb + (unsigned long int)16) - (unsigned long int)1 & (unsigned long int)~(16 - 1);
  n_blocks = (lb + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  if(GC_dont_gc == 0 && !(GC_incremental == 0))
    GC_collect_a_little_inner((signed int)n_blocks);

  h=GC_allochblk(lb, k, flags);
  signed int return_value_GC_collect_or_expand_1;
  for( ; h == ((struct hblk *)NULL); retry = 1)
  {
    return_value_GC_collect_or_expand_1=GC_collect_or_expand(n_blocks, (signed int)(flags != (unsigned int)0), retry);
    if(return_value_GC_collect_or_expand_1 == 0)
      break;

    h=GC_allochblk(lb, k, flags);
  }
  if(h == ((struct hblk *)NULL))
    result = ((char *)NULL);

  else
  {
    unsigned long int total_bytes = n_blocks * (unsigned long int)(1 << 12);
    if(n_blocks >= 2ul)
    {
      GC_arrays._large_allocd_bytes = GC_arrays._large_allocd_bytes + total_bytes;
      if(!(GC_arrays._max_large_allocd_bytes >= GC_arrays._large_allocd_bytes))
        GC_arrays._max_large_allocd_bytes = GC_arrays._large_allocd_bytes;

    }

    result = h->hb_body;
  }
  return result;
}

// GC_alloc_large_and_clear
// file malloc.c line 85
char * GC_alloc_large_and_clear(unsigned long int lb, signed int k, unsigned int flags)
{
  char *result;
  result=GC_alloc_large(lb, k, flags);
  unsigned long int n_blocks = (lb + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
  if(result == ((char *)NULL))
    return ((char *)NULL);

  else
  {
    _Bool tmp_if_expr_1;
    if(!(GC_debugging_started == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = GC_obj_kinds[(signed long int)k].ok_init != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      memset((void *)result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

    return result;
  }
}

// GC_alloc_reclaim_list
// file malloc.c line 23
signed int GC_alloc_reclaim_list(struct obj_kind *kind)
{
  struct hblk **result;
  char *return_value_GC_scratch_alloc_1;
  return_value_GC_scratch_alloc_1=GC_scratch_alloc(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(struct hblk *) /*8ul*/ );
  result = (struct hblk **)return_value_GC_scratch_alloc_1;
  if(result == ((struct hblk **)NULL))
    return 0;

  else
  {
    memset((void *)result, 0, (unsigned long int)(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(struct hblk *) /*8ul*/ ));
    kind->ok_reclaim_list = result;
    return 1;
  }
}

// GC_allochblk
// file allchblk.c line 576
struct hblk * GC_allochblk(unsigned long int sz, signed int kind, unsigned int flags)
{
  unsigned long int blocks;
  signed int start_list;
  struct hblk *result;
  signed int may_split;
  signed int split_limit;
  blocks = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
  signed int return_value_GC_should_collect_1;
  if(!(4096l * (signed long int)blocks >= 0l))
    return ((struct hblk *)NULL);

  else
  {
    start_list=GC_hblk_fl_from_blocks(blocks);
    result=GC_allochblk_nth(sz, kind, flags, start_list, 0);
    if(!(result == ((struct hblk *)NULL)))
      return result;

    else
    {
      may_split = 1;
      _Bool tmp_if_expr_2;
      if(!(GC_dont_gc == 0) || !(GC_incremental == 0) || !(GC_use_entire_heap == 0) || !(GC_arrays._heapsize + -GC_arrays._large_free_bytes >= GC_arrays._requested_heapsize))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        return_value_GC_should_collect_1=GC_should_collect();
        tmp_if_expr_2 = !(return_value_GC_should_collect_1 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        split_limit = (256 - 32) / 8 + 32;

      else
        if(!(GC_arrays._heapsize >> 4 >= GC_arrays._finalizer_bytes_freed))
          split_limit = 0;

        else
          split_limit=GC_enough_large_bytes_left();
      if(!(start_list >= 32))
        start_list = start_list + 1;

      for( ; split_limit >= start_list; start_list = start_list + 1)
      {
        result=GC_allochblk_nth(sz, kind, flags, start_list, may_split);
        if(!(result == ((struct hblk *)NULL)))
          break;

      }
      return result;
    }
  }
}

// GC_allochblk_nth
// file allchblk.c line 640
struct hblk * GC_allochblk_nth(unsigned long int sz, signed int kind, unsigned int flags, signed int n, signed int may_split)
{
  struct hblk *hbp;
  struct hblkhdr *hhdr;
  struct hblk *thishbp;
  struct hblkhdr *thishdr;
  signed long int size_needed;
  signed long int size_avail;
  size_needed = (signed long int)((unsigned long int)(1 << 12) * ((sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12));
  hbp = GC_hblkfreelist[(signed long int)n];
  struct hblk *return_value_GC_is_black_listed_1;
  for( ; (_Bool)1; hbp = hhdr->hb_next)
  {
    if(hbp == ((struct hblk *)NULL))
      return (struct hblk *)(void *)0;

    do
    {
      struct hblkhdr **GC_allochblk_nth__1__1__1__1___ha;
      do
      {
        struct bi *GC_allochblk_nth__1__1__1__1__1__bi;
        do
        {
          unsigned long int GC_allochblk_nth__1__1__1__1__1__1__hi = (unsigned long int)hbp >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *GC_allochblk_nth__1__1__1__1__1__1___bi = GC_arrays._top_index[(signed long int)(GC_allochblk_nth__1__1__1__1__1__1__hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(GC_allochblk_nth__1__1__1__1__1__1___bi->key == GC_allochblk_nth__1__1__1__1__1__1__hi); GC_allochblk_nth__1__1__1__1__1__1___bi = GC_allochblk_nth__1__1__1__1__1__1___bi->hash_link)
            if(GC_allochblk_nth__1__1__1__1__1__1___bi == GC_arrays._all_nils)
              break;

          GC_allochblk_nth__1__1__1__1__1__bi = GC_allochblk_nth__1__1__1__1__1__1___bi;
        }
        while((_Bool)0);
        GC_allochblk_nth__1__1__1__1___ha = &GC_allochblk_nth__1__1__1__1__1__bi->index[(signed long int)((unsigned long int)hbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      hhdr = *GC_allochblk_nth__1__1__1__1___ha;
    }
    while((_Bool)0);
    size_avail = (signed long int)hhdr->hb_sz;
    if(size_avail >= size_needed)
    {
      if(!(size_avail == size_needed))
      {
        signed long int next_size;
        if(may_split == 0)
          goto __CPROVER_DUMP_L28;

        thishbp = hhdr->hb_next;
        if(!(thishbp == ((struct hblk *)NULL)))
        {
          do
          {
            struct hblkhdr **_ha;
            do
            {
              struct bi *bi;
              do
              {
                unsigned long int hi = (unsigned long int)thishbp >> (unsigned long int)10 + (unsigned long int)12;
                struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
                for( ; !(_bi->key == hi); _bi = _bi->hash_link)
                  if(_bi == GC_arrays._all_nils)
                    break;

                bi = _bi;
              }
              while((_Bool)0);
              _ha = &bi->index[(signed long int)((unsigned long int)thishbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
            }
            while((_Bool)0);
            thishdr = *_ha;
          }
          while((_Bool)0);
          next_size = (signed long int)thishdr->hb_sz;
          if(next_size >= size_needed && !(next_size >= size_avail))
          {
            return_value_GC_is_black_listed_1=GC_is_black_listed(thishbp, (unsigned long int)size_needed);
            if(return_value_GC_is_black_listed_1 == ((struct hblk *)NULL))
              goto __CPROVER_DUMP_L28;

          }

        }

      }

      if(!((-2 & kind) == 2) && (size_needed >= 8193l || !(kind == 0)))
      {
        struct hblk *lasthbp = hbp;
        char *search_end = ((char *)hbp + size_avail) - size_needed;
        signed long int orig_avail = size_avail;
        signed long int eff_size_needed = (flags & (unsigned int)1) != (unsigned int)0 ? (signed long int)(unsigned long int)(1 << 12) : size_needed;
        for( ; (unsigned long int)search_end >= (unsigned long int)lasthbp; lasthbp = thishbp)
        {
          thishbp=GC_is_black_listed(lasthbp, (unsigned long int)eff_size_needed);
          if(thishbp == ((struct hblk *)NULL))
            break;

        }
        size_avail = size_avail - ((char *)lasthbp - (char *)hbp);
        thishbp = lasthbp;
        if(size_avail >= size_needed)
        {
          if(!(thishbp == hbp))
          {
            thishdr=GC_install_header(thishbp);
            if(!(thishdr == ((struct hblkhdr *)NULL)))
            {
              GC_split_block(hbp, hhdr, thishbp, thishdr, n);
              hbp = thishbp;
              hhdr = thishdr;
            }

          }

        }

        else
          if(!((signed long int)GC_black_list_spacing >= orig_avail + -size_needed) && !((signed long int)GC_black_list_spacing >= size_needed))
          {
            GC_large_alloc_warn_suppressed = GC_large_alloc_warn_suppressed + 1l;
            if(GC_large_alloc_warn_suppressed >= GC_large_alloc_warn_interval)
            {
              GC_current_warn_proc("GC Warning: Repeated allocation of very large block (appr. size %ld):\n\tMay lead to memory leak and poor performance.\n", (unsigned long int)size_needed);
              GC_large_alloc_warn_suppressed = (signed long int)0;
            }

            size_avail = orig_avail;
          }

          else
            if(size_avail == 0l && (unsigned long int)size_needed == 4096ul)
            {
              if(GC_find_leak == 0)
              {
                static unsigned int count = (unsigned int)0;
                count = count + 1u;
                if((3u & count) == 0u)
                {
                  unsigned long int total_size = hhdr->hb_sz;
                  struct hblk *limit = hbp + (signed long int)(total_size >> (unsigned long int)12);
                  struct hblk *h;
                  struct hblk *prev = hhdr->hb_prev;
                  GC_arrays._large_free_bytes = GC_arrays._large_free_bytes - total_size;
                  GC_arrays._bytes_dropped = GC_arrays._bytes_dropped + total_size;
                  GC_remove_from_fl_at(hhdr, n);
                  h = hbp;
                  for( ; !((unsigned long int)h >= (unsigned long int)limit); h = h + 1l)
                  {
                    if(!(h == hbp))
                      hhdr=GC_install_header(h);

                    if(!(hhdr == ((struct hblkhdr *)NULL)))
                    {
                      setup_header(hhdr, h, (unsigned long int)(1 << 12), 0, (unsigned int)0);
                      if(!(GC_debugging_started == 0))
                        memset((void *)h, 0, (unsigned long int)(1 << 12));

                    }

                  }
                  hbp = prev;
                  if(hbp == ((struct hblk *)NULL))
                  {
                    struct hblk *return_value_GC_allochblk_nth_2;
                    return_value_GC_allochblk_nth_2=GC_allochblk_nth(sz, kind, flags, n, may_split);
                    return return_value_GC_allochblk_nth_2;
                  }

                  hhdr=GC_find_header((char *)hbp);
                }

              }

            }

      }

      if(size_avail >= size_needed)
      {
        hbp=GC_get_first_part(hbp, hhdr, (unsigned long int)size_needed, n);
        break;
      }

    }


  __CPROVER_DUMP_L28:
    ;
  }
  if(hbp == ((struct hblk *)NULL))
    return ((struct hblk *)NULL);

  else
  {
    signed int return_value_GC_install_counts_3;
    return_value_GC_install_counts_3=GC_install_counts(hbp, (unsigned long int)size_needed);
    if(return_value_GC_install_counts_3 == 0)
      return ((struct hblk *)NULL);

    else
    {
      signed int return_value_setup_header_4;
      return_value_setup_header_4=setup_header(hhdr, hbp, sz, kind, flags);
      if(return_value_setup_header_4 == 0)
      {
        GC_remove_counts(hbp, (unsigned long int)size_needed);
        return ((struct hblk *)NULL);
      }

      else
      {
        GC_remove_protection(hbp, (unsigned long int)(size_needed >> (unsigned long int)12), (signed int)(hhdr->hb_descr == (unsigned long int)0));
        GC_fail_count = (unsigned int)0;
        GC_arrays._large_free_bytes = GC_arrays._large_free_bytes - (unsigned long int)size_needed;
        return hbp;
      }
    }
  }
}

// GC_allocobj
// file alloc.c line 1330
char * GC_allocobj(unsigned long int gran, signed int kind)
{
  void **flh = &GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)gran];
  signed int tried_minor = 0;
  signed int retry = 0;
  if(gran == 0ul)
    return ((char *)NULL);

  else
  {
    while(*flh == NULL)
    {
      GC_collecting = 1;
      if(!(GC_incremental == 0) && !(GC_time_limit == 999999ul))
        GC_collect_a_little_inner(1);

      GC_continue_reclaim(gran, kind);
      GC_collecting = 0;
      if(*flh == NULL)
        GC_new_hblk(gran, kind);

      if(*flh == NULL)
      {
        GC_collecting = 1;
        if(tried_minor == 0 && GC_time_limit == 999999ul && !(GC_incremental == 0))
        {
          GC_collect_a_little_inner(1);
          tried_minor = 1;
        }

        else
        {
          signed int return_value_GC_collect_or_expand_1;
          return_value_GC_collect_or_expand_1=GC_collect_or_expand((unsigned long int)1, 0, retry);
          if(return_value_GC_collect_or_expand_1 == 0)
          {
            GC_collecting = 0;
            return ((char *)NULL);
          }

          retry = 1;
        }
        GC_collecting = 0;
      }

    }
    GC_fail_count = (unsigned int)0;
    return (char *)*flh;
  }
}

// GC_allow_register_threads
// file pthread_support.c line 1542
extern void GC_allow_register_threads(void)
{
  GC_need_to_lock = 1;
}

// GC_apply_to_all_blocks
// file ./include/private/gc_priv.h line 1542
void GC_apply_to_all_blocks(void (*fn)(struct hblk *, unsigned long int), unsigned long int client_data)
{
  signed long int j;
  struct bi *index_p = GC_all_bottom_indices;
  for( ; !(index_p == ((struct bi *)NULL)); index_p = index_p->asc_link)
  {
    j = (signed long int)((1 << 10) - 1);
    while(j >= 0l)
      if((unsigned long int)index_p->index[j] >= 4096ul)
      {
        if((4 & (signed int)index_p->index[j]->hb_flags) == 0)
          fn((struct hblk *)((index_p->key << 10) + (unsigned long int)j << (unsigned long int)12), client_data);

        j = j - 1l;
      }

      else
        if(index_p->index[j] == ((struct hblkhdr *)NULL))
          j = j - 1l;

        else
          j = j - (signed long int)index_p->index[j];
  }
}

// GC_approx_sp
// file ./include/private/gc_priv.h line 1538
char * GC_approx_sp(void)
{
  volatile unsigned long int sp = (unsigned long int)&sp;
  return (char *)sp;
}

// GC_array_mark_proc
// file typd_mlc.c line 495
struct GC_ms_entry * GC_array_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)addr);
  unsigned long int sz = hhdr->hb_sz;
  unsigned long int nwords = sz >> 3;
  union ComplexDescriptor *descr = (union ComplexDescriptor *)addr[(signed long int)(nwords - (unsigned long int)1)];
  struct GC_ms_entry *orig_mark_stack_ptr = mark_stack_ptr;
  struct GC_ms_entry *new_mark_stack_ptr;
  if(descr == ((union ComplexDescriptor *)NULL))
    return orig_mark_stack_ptr;

  else
  {
    new_mark_stack_ptr=GC_push_complex_descriptor(addr, descr, mark_stack_ptr, mark_stack_limit - (signed long int)1);
    if(new_mark_stack_ptr == ((struct GC_ms_entry *)NULL))
    {
      GC_mark_stack_too_small = 1;
      new_mark_stack_ptr = orig_mark_stack_ptr + (signed long int)1;
      new_mark_stack_ptr->mse_start = (char *)addr;
      new_mark_stack_ptr->mse_descr.w = sz | (unsigned long int)0;
    }

    else
    {
      new_mark_stack_ptr = new_mark_stack_ptr + 1l;
      new_mark_stack_ptr->mse_start = (char *)((addr + (signed long int)nwords) - (signed long int)1);
      new_mark_stack_ptr->mse_descr.w = sizeof(unsigned long int) /*8ul*/  | (unsigned long int)0;
    }
    return new_mark_stack_ptr;
  }
}

// GC_atfork_child
// file pthread_support.c line 1019
extern void GC_atfork_child(void)
{
  if(!(GC_handle_fork >= 1))
    fork_child_proc();

}

// GC_atfork_parent
// file pthread_support.c line 1013
extern void GC_atfork_parent(void)
{
  if(!(GC_handle_fork >= 1))
    fork_parent_proc();

}

// GC_atfork_prepare
// file pthread_support.c line 1001
extern void GC_atfork_prepare(void)
{
  if(!(GC_handle_fork >= 1))
    fork_prepare_proc();

}

// GC_base
// file ./include/private/../gc.h line 464
extern void * GC_base(void *p)
{
  char *r;
  struct hblk *h;
  struct bi *bi;
  struct hblkhdr *candidate_hdr;
  char *limit;
  r = (char *)p;
  if((signed long int)GC_is_initialized == 0l)
    return NULL;

  else
  {
    h = (struct hblk *)((unsigned long int)r & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    do
    {
      unsigned long int hi = (unsigned long int)r >> (unsigned long int)10 + (unsigned long int)12;
      struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
      for( ; !(_bi->key == hi); _bi = _bi->hash_link)
        if(_bi == GC_arrays._all_nils)
          break;

      bi = _bi;
    }
    while((_Bool)0);
    candidate_hdr = bi->index[(signed long int)((unsigned long int)r >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    if(candidate_hdr == ((struct hblkhdr *)NULL))
      return NULL;

    else
    {
      while(!((unsigned long int)candidate_hdr >= 4096ul))
      {
        h = (struct hblk *)h - (signed long int)(unsigned long int)candidate_hdr;
        r = (char *)h;
        candidate_hdr=GC_find_header((char *)h);
      }
      if(!((4 & (signed int)candidate_hdr->hb_flags) == 0))
        return NULL;

      else
      {
        r = (char *)((unsigned long int)r & (unsigned long int)~((1 << 3) - 1));
        unsigned long int offset = (unsigned long int)r & (unsigned long int)(1 << 12) - (unsigned long int)1;
        unsigned long int sz = candidate_hdr->hb_sz;
        unsigned long int obj_displ = offset % sz;
        r = r - (signed long int)obj_displ;
        limit = r + (signed long int)sz;
        if(!(sz >= 4097ul) && !((unsigned long int)(h + 1l) >= (unsigned long int)limit))
          return NULL;

        else
          if((unsigned long int)p >= (unsigned long int)limit)
            return NULL;

          else
            return (void *)r;
      }
    }
  }
}

// GC_bl_init
// file blacklst.c line 107
void GC_bl_init(void)
{
  if(GC_all_interior_pointers == 0)
    GC_bl_init_no_interiors();

  char *return_value_GC_scratch_alloc_1;
  return_value_GC_scratch_alloc_1=GC_scratch_alloc(sizeof(unsigned long int [4096l]) /*32768ul*/ );
  GC_old_stack_bl = (unsigned long int *)return_value_GC_scratch_alloc_1;
  char *return_value_GC_scratch_alloc_2;
  return_value_GC_scratch_alloc_2=GC_scratch_alloc(sizeof(unsigned long int [4096l]) /*32768ul*/ );
  GC_incomplete_stack_bl = (unsigned long int *)return_value_GC_scratch_alloc_2;
  if(GC_incomplete_stack_bl == ((unsigned long int *)NULL) || GC_old_stack_bl == ((unsigned long int *)NULL))
  {
    GC_err_printf("Insufficient memory for black list\n");
    GC_on_abort((const char *)(void *)0);
    exit(1);
  }

  GC_clear_bl(GC_old_stack_bl);
  GC_clear_bl(GC_incomplete_stack_bl);
}

// GC_bl_init_no_interiors
// file blacklst.c line 92
void GC_bl_init_no_interiors(void)
{
  if(GC_incomplete_normal_bl == ((unsigned long int *)NULL))
  {
    char *return_value_GC_scratch_alloc_1;
    return_value_GC_scratch_alloc_1=GC_scratch_alloc(sizeof(unsigned long int [4096l]) /*32768ul*/ );
    GC_old_normal_bl = (unsigned long int *)return_value_GC_scratch_alloc_1;
    char *return_value_GC_scratch_alloc_2;
    return_value_GC_scratch_alloc_2=GC_scratch_alloc(sizeof(unsigned long int [4096l]) /*32768ul*/ );
    GC_incomplete_normal_bl = (unsigned long int *)return_value_GC_scratch_alloc_2;
    if(GC_incomplete_normal_bl == ((unsigned long int *)NULL) || GC_old_normal_bl == ((unsigned long int *)NULL))
    {
      GC_err_printf("Insufficient memory for black list\n");
      GC_on_abort((const char *)(void *)0);
      exit(1);
    }

    GC_clear_bl(GC_old_normal_bl);
    GC_clear_bl(GC_incomplete_normal_bl);
  }

}

// GC_block_empty
// file ./include/private/gc_priv.h line 1801
signed int GC_block_empty(struct hblkhdr *hhdr)
{
  return (signed int)(hhdr->hb_n_marks == (unsigned long int)0);
}

// GC_block_nearly_full
// file reclaim.c line 133
signed int GC_block_nearly_full(struct hblkhdr *hhdr)
{
  return (signed int)(hhdr->hb_n_marks > ((unsigned long int)7 * ((unsigned long int)(1 << 12) / hhdr->hb_sz)) / (unsigned long int)8);
}

// GC_block_was_dirty
// file mark.c line 1816
signed int GC_block_was_dirty(struct hblk *h, struct hblkhdr *hhdr)
{
  unsigned long int sz = hhdr->hb_sz;
  if(!(sz >= 2049ul))
  {
    signed int return_value_GC_page_was_dirty_1;
    return_value_GC_page_was_dirty_1=GC_page_was_dirty(h);
    return return_value_GC_page_was_dirty_1;
  }

  else
  {
    char *p = (char *)h;
    while(!((unsigned long int)p >= sz + (unsigned long int)h))
    {
      signed int return_value_GC_page_was_dirty_2;
      return_value_GC_page_was_dirty_2=GC_page_was_dirty((struct hblk *)p);
      if(!(return_value_GC_page_was_dirty_2 == 0))
        return 1;

      p = p + (signed long int)(unsigned long int)(1 << 12);
    }
    return 0;
  }
}

// GC_build_fl
// file ./include/private/gc_priv.h line 1747
char * GC_build_fl(struct hblk *h, unsigned long int sz, signed int clear, char *list)
{
  unsigned long int *p;
  unsigned long int *prev;
  unsigned long int *last_object;
  char *return_value_GC_build_fl2_2;
  char *return_value_GC_build_fl4_4;
  switch(sz)
  {
    case (unsigned long int)2:
    {
      if(!(clear == 0))
      {
        char *return_value_GC_build_fl_clear2_1;
        return_value_GC_build_fl_clear2_1=GC_build_fl_clear2(h, list);
        return return_value_GC_build_fl_clear2_1;
      }

      return_value_GC_build_fl2_2=GC_build_fl2(h, list);
      return return_value_GC_build_fl2_2;
    }
    case (unsigned long int)4:
    {
      if(!(clear == 0))
      {
        char *return_value_GC_build_fl_clear4_3;
        return_value_GC_build_fl_clear4_3=GC_build_fl_clear4(h, list);
        return return_value_GC_build_fl_clear4_3;
      }

      return_value_GC_build_fl4_4=GC_build_fl4(h, list);
      return return_value_GC_build_fl4_4;
    }
    default:
    {
      if(!(clear == 0))
        memset((void *)h, 0, (unsigned long int)(1 << 12));

      p = (unsigned long int *)h->hb_body + (signed long int)sz;
      prev = (unsigned long int *)h->hb_body;
      last_object = (unsigned long int *)((char *)h + (signed long int)(unsigned long int)(1 << 12));
      last_object = last_object - (signed long int)sz;
      for( ; (unsigned long int)last_object >= (unsigned long int)p; p = p + (signed long int)sz)
      {
        *((void **)p) = (void *)(char *)prev;
        prev = p;
      }
      p = p - (signed long int)sz;
      *((char **)h) = list;
      return (char *)p;
    }
  }
}

// GC_build_fl2
// file new_hblk.c line 70
char * GC_build_fl2(struct hblk *h, char *ofl)
{
  unsigned long int *p = (unsigned long int *)h->hb_body;
  unsigned long int *lim = (unsigned long int *)(h + (signed long int)1);
  p[(signed long int)0] = (unsigned long int)ofl;
  p[(signed long int)2] = (unsigned long int)p;
  p = p + (signed long int)4;
  for( ; !((unsigned long int)p >= (unsigned long int)lim); p = p + (signed long int)4)
  {
    p[(signed long int)0] = (unsigned long int)(p - (signed long int)2);
    p[(signed long int)2] = (unsigned long int)p;
  }
  return (char *)(p - (signed long int)2);
}

// GC_build_fl4
// file new_hblk.c line 86
char * GC_build_fl4(struct hblk *h, char *ofl)
{
  unsigned long int *p = (unsigned long int *)h->hb_body;
  unsigned long int *lim = (unsigned long int *)(h + (signed long int)1);
  p[(signed long int)0] = (unsigned long int)ofl;
  p[(signed long int)4] = (unsigned long int)p;
  p = p + (signed long int)8;
  for( ; !((unsigned long int)p >= (unsigned long int)lim); p = p + (signed long int)8)
  {
    p[(signed long int)0] = (unsigned long int)(p - (signed long int)4);
    p[(signed long int)4] = (unsigned long int)p;
  }
  return (char *)(p - (signed long int)4);
}

// GC_build_fl_clear2
// file new_hblk.c line 30
char * GC_build_fl_clear2(struct hblk *h, char *ofl)
{
  unsigned long int *p = (unsigned long int *)h->hb_body;
  unsigned long int *lim = (unsigned long int *)(h + (signed long int)1);
  p[(signed long int)0] = (unsigned long int)ofl;
  p[(signed long int)1] = (unsigned long int)0;
  p[(signed long int)2] = (unsigned long int)p;
  p[(signed long int)3] = (unsigned long int)0;
  p = p + (signed long int)4;
  for( ; !((unsigned long int)p >= (unsigned long int)lim); p = p + (signed long int)4)
  {
    p[(signed long int)0] = (unsigned long int)(p - (signed long int)2);
    p[(signed long int)1] = (unsigned long int)0;
    p[(signed long int)2] = (unsigned long int)p;
    p[(signed long int)3] = (unsigned long int)0;
  }
  return (char *)(p - (signed long int)2);
}

// GC_build_fl_clear4
// file new_hblk.c line 50
char * GC_build_fl_clear4(struct hblk *h, char *ofl)
{
  unsigned long int *p = (unsigned long int *)h->hb_body;
  unsigned long int *lim = (unsigned long int *)(h + (signed long int)1);
  p[(signed long int)0] = (unsigned long int)ofl;
  p[(signed long int)1] = (unsigned long int)0;
  p[(signed long int)2] = (unsigned long int)0;
  p[(signed long int)3] = (unsigned long int)0;
  p = p + (signed long int)4;
  for( ; !((unsigned long int)p >= (unsigned long int)lim); p = p + (signed long int)4)
  {
    p[(signed long int)0] = (unsigned long int)(p - (signed long int)4);
    p[(signed long int)1] = (unsigned long int)0;
    ((unsigned long int *)(p + (signed long int)2))[(signed long int)0] = (unsigned long int)0;
    ((unsigned long int *)(p + (signed long int)2))[(signed long int)1] = (unsigned long int)0;
  }
  return (char *)(p - (signed long int)4);
}

// GC_call_with_alloc_lock
// file misc.c line 1814
extern void * GC_call_with_alloc_lock(void * (*fn)(void *), void *client_data)
{
  void *result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result=fn(client_data);
  if(!(GC_need_to_lock == 0))
    pthread_mutex_unlock(&GC_allocate_ml);

  return result;
}

// GC_call_with_gc_active
// file pthread_support.c line 1244
extern void * GC_call_with_gc_active(void * (*fn)(void *), void *client_data)
{
  struct GC_traced_stack_sect_s stacksect;
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  if((4 & (signed int)me->flags) == 0)
  {
    if(!((unsigned long int)me->stack_end >= (unsigned long int)&stacksect))
      me->stack_end = (char *)&stacksect;

  }

  else
    if(!((unsigned long int)GC_stackbottom >= (unsigned long int)&stacksect))
      GC_stackbottom = (char *)&stacksect;

  if(me->thread_blocked == 0)
  {
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    client_data=fn(client_data);
    GC_noop1((unsigned long int)&stacksect);
    return client_data;
  }

  else
  {
    stacksect.saved_stack_ptr = me->stop_info.stack_ptr;
    stacksect.prev = me->traced_stack_sect;
    me->thread_blocked = (unsigned char)0;
    me->traced_stack_sect = &stacksect;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    client_data=fn(client_data);
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_2;
      return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_2 == 0))
        GC_lock();

    }

    me->traced_stack_sect = stacksect.prev;
    me->thread_blocked = (unsigned char)1;
    me->stop_info.stack_ptr = stacksect.saved_stack_ptr;
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

    return client_data;
  }
}

// GC_call_with_stack_base
// file misc.c line 1829
extern void * GC_call_with_stack_base(void * (*fn)(struct GC_stack_base *, void *), void *arg)
{
  struct GC_stack_base base;
  void *result;
  base.mem_base = (void *)&base;
  result=fn(&base, arg);
  GC_noop1((unsigned long int)&base);
  return result;
}

// GC_calloc_explicitly_typed
// file typd_mlc.c line 658
extern void * GC_calloc_explicitly_typed(unsigned long int n, unsigned long int lb, unsigned long int d)
{
  char *op;
  char **opp;
  unsigned long int lg;
  unsigned long int simple_descr;
  union ComplexDescriptor *complex_descr;
  signed int descr_type;
  struct LeafDescriptor leaf;
  descr_type=GC_make_array_descriptor((unsigned long int)n, (unsigned long int)lb, d, &simple_descr, &complex_descr, &leaf);
  if(!(descr_type == -1))
  {
    if(descr_type == 0)
      goto __CPROVER_DUMP_L2;

    if(descr_type == 1)
      goto __CPROVER_DUMP_L3;

    if(descr_type == 2)
      goto __CPROVER_DUMP_L4;

  }

  else
  {
    return NULL;

  __CPROVER_DUMP_L2:
    ;
    void *return_value_GC_malloc_explicitly_typed_1;
    return_value_GC_malloc_explicitly_typed_1=GC_malloc_explicitly_typed(n * lb, simple_descr);
    return return_value_GC_malloc_explicitly_typed_1;

  __CPROVER_DUMP_L3:
    ;
    lb = lb * n;
    lb = lb + sizeof(struct LeafDescriptor) /*32ul*/  + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)GC_all_interior_pointers);
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L4:
    ;
    lb = lb * n;
    lb = lb + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)GC_all_interior_pointers);
    goto __CPROVER_DUMP_L5;
  }

__CPROVER_DUMP_L5:
  ;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_arobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_2;
        return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_2 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc_3;
      return_value_GC_generic_malloc_3=GC_generic_malloc((unsigned long int)lb, GC_array_kind);
      void *return_value_GC_clear_stack_4;
      return_value_GC_clear_stack_4=GC_clear_stack(return_value_GC_generic_malloc_3);
      op = (char *)return_value_GC_clear_stack_4;
      if(op == ((char *)NULL))
        return NULL;

      lg = GC_arrays._size_map[(signed long int)lb];
    }

    else
    {
      *opp = (char *)*((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
  }

  else
  {
    void *return_value_GC_generic_malloc_5;
    return_value_GC_generic_malloc_5=GC_generic_malloc((unsigned long int)lb, GC_array_kind);
    void *return_value_GC_clear_stack_6;
    return_value_GC_clear_stack_6=GC_clear_stack(return_value_GC_generic_malloc_5);
    op = (char *)return_value_GC_clear_stack_6;
    if(op == ((char *)NULL))
      return NULL;

    unsigned long int return_value_GC_size_7;
    return_value_GC_size_7=GC_size((const void *)op);
    lg = return_value_GC_size_7 >> 4;
  }
  if(descr_type == 1)
  {
    struct LeafDescriptor *lp = (struct LeafDescriptor *)(((unsigned long int *)op + (signed long int)(lg << 1)) - (signed long int)((sizeof(struct LeafDescriptor) /*32ul*/  >> 3) + (unsigned long int)1));
    lp->ld_tag = (unsigned long int)1;
    lp->ld_size = leaf.ld_size;
    lp->ld_nelements = leaf.ld_nelements;
    lp->ld_descriptor = leaf.ld_descriptor;
    ((volatile unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = (unsigned long int)lp;
  }

  else
  {
    unsigned long int lw = lg << 1;
    ((unsigned long int *)op)[(signed long int)(lw - (unsigned long int)1)] = (unsigned long int)complex_descr;
    signed int return_value_GC_general_register_disappearing_link_9;
    return_value_GC_general_register_disappearing_link_9=GC_general_register_disappearing_link((void **)(((unsigned long int *)op + (signed long int)lw) - (signed long int)1), (const void *)op);
    if(return_value_GC_general_register_disappearing_link_9 == 2)
    {
      void *return_value_GC_malloc_8;
      return_value_GC_malloc_8=GC_malloc(n * lb);
      return return_value_GC_malloc_8;
    }

  }
  return (void *)op;
}

// GC_change_stubborn
// file stubborn.c line 52
extern void GC_change_stubborn(const void *p)
{
  ;
}

// GC_check_annotated_obj
// file dbg_mlc.c line 295
char * GC_check_annotated_obj(struct anonymous_16 *ohdr)
{
  char *body = (char *)(ohdr + (signed long int)1);
  unsigned long int gc_sz;
  gc_sz=GC_size((const void *)(char *)ohdr);
  if(!(gc_sz >= sizeof(unsigned long int) * 5 /*40ul*/  + ohdr->oh_sz + -((unsigned long int)GC_all_interior_pointers)))
    return (char *)&ohdr->oh_sz;

  else
    if(!(ohdr->oh_sf == (0xFEDCEDCBfedcedcbUL ^ (unsigned long int)body)))
      return (char *)&ohdr->oh_sf;

    else
      if(!(((unsigned long int *)ohdr)[-1l + (signed long int)(gc_sz >> 3)] == (0xBCDECDEFbcdecdefUL ^ (unsigned long int)body)))
        return (char *)(((unsigned long int *)ohdr + (signed long int)(gc_sz >> 3)) - (signed long int)1);

      else
        if(!(((unsigned long int *)body)[(signed long int)(8ul + ohdr->oh_sz + 18446744073709551615ul >> 3)] == (0xBCDECDEFbcdecdefUL ^ (unsigned long int)body)))
          return (char *)((unsigned long int *)body + (signed long int)((ohdr->oh_sz + (unsigned long int)(1 << 3)) - (unsigned long int)1 >> 3));

        else
          return ((char *)NULL);
}

// GC_check_finalizer_nested
// file ./include/private/gc_priv.h line 2270
unsigned char * GC_check_finalizer_nested(void)
{
  struct GC_Thread_Rep *me;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  me=GC_lookup_thread(return_value_pthread_self_1);
  unsigned int nesting_level = (unsigned int)me->finalizer_nested;
  if(!(nesting_level == 0u))
  {
    me->finalizer_skipped = me->finalizer_skipped + 1;
    if(!((unsigned int)me->finalizer_skipped >= 1U << nesting_level))
      return (unsigned char *)(void *)0;

    me->finalizer_skipped = (unsigned short int)0;
  }

  me->finalizer_nested = (unsigned char)(nesting_level + (unsigned int)1);
  return &me->finalizer_nested;
}

// GC_check_heap_block
// file dbg_mlc.c line 979
void GC_check_heap_block(struct hblk *hbp, unsigned long int dummy)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)hbp);
  unsigned long int sz = hhdr->hb_sz;
  unsigned long int bit_no;
  char *p;
  char *plim;
  p = hbp->hb_body;
  if(sz >= 2049ul)
    plim = p;

  else
    plim = (hbp->hb_body + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz;
  bit_no = (unsigned long int)0;
  signed int return_value_GC_has_other_debug_info_1;
  for( ; (unsigned long int)plim >= (unsigned long int)p; p = p + (signed long int)sz)
  {
    if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
    {
      return_value_GC_has_other_debug_info_1=GC_has_other_debug_info((char *)p);
      if(return_value_GC_has_other_debug_info_1 >= 1)
      {
        char *clobbered;
        clobbered=GC_check_annotated_obj((struct anonymous_16 *)p);
        if(!(clobbered == ((char *)NULL)))
          GC_add_smashed(clobbered);

      }

    }

    bit_no = bit_no + (sz >> 4);
  }
}

// GC_check_heap_proc
// file dbg_mlc.c line 1005
void GC_check_heap_proc(void)
{
  GC_apply_to_all_blocks(GC_check_heap_block, (unsigned long int)0);
}

// GC_check_leaked
// file dbg_mlc.c line 1012
signed int GC_check_leaked(char *base)
{
  unsigned long int i;
  unsigned long int obj_sz;
  unsigned long int *p;
  signed int return_value_GC_has_other_debug_info_1;
  return_value_GC_has_other_debug_info_1=GC_has_other_debug_info(base);
  if(return_value_GC_has_other_debug_info_1 >= 0)
    return 1;

  else
  {
    p = (unsigned long int *)(base + (signed long int)sizeof(struct anonymous_16) /*32ul*/ );
    struct hblkhdr *return_value_GC_find_header_2;
    return_value_GC_find_header_2=GC_find_header((char *)base);
    obj_sz = return_value_GC_find_header_2->hb_sz - sizeof(struct anonymous_16) /*32ul*/  >> 3;
    i = (unsigned long int)0;
    for( ; !(i >= obj_sz); i = i + 1ul)
      if(!(p[(signed long int)i] == 0xEFBEADDEdeadbeefUL))
      {
        GC_set_mark_bit((const void *)base);
        GC_add_smashed((char *)&p[(signed long int)i]);
        break;
      }

    return 0;
  }
}

// GC_clear_a_few_frames
// file alloc.c line 285
void GC_clear_a_few_frames(void)
{
  volatile unsigned long int frames[64l];
  memset((void *)(unsigned long int *)frames, 0, (unsigned long int)((unsigned long int)64 * sizeof(unsigned long int) /*8ul*/ ));
}

// GC_clear_bl
// file blacklst.c line 122
void GC_clear_bl(unsigned long int *doomed)
{
  memset((void *)doomed, 0, (unsigned long int)sizeof(unsigned long int [4096l]) /*32768ul*/ );
}

// GC_clear_fl_links
// file reclaim.c line 591
void GC_clear_fl_links(void **flp)
{
  void *next = *flp;
  for( ; !(next == NULL); next = *flp)
  {
    *flp = NULL;
    flp = &(*((void **)next));
  }
}

// GC_clear_fl_marks
// file alloc.c line 765
void GC_clear_fl_marks(char *q)
{
  struct hblk *h;
  struct hblk *last_h;
  struct hblkhdr *hhdr;
  unsigned long int sz;
  unsigned int bit_no;
  if(!(q == ((char *)NULL)))
  {
    h = (struct hblk *)((unsigned long int)q & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    last_h = h;
    hhdr=GC_find_header((char *)h);
    sz = hhdr->hb_sz;
    do
    {
      bit_no = (unsigned int)((char *)q - (char *)h) >> 4;
      if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
      {
        unsigned long int n_marks = hhdr->hb_n_marks - (unsigned long int)1;
        hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] = (char)0;
        if(GC_parallel == 0 || !(n_marks == 0ul))
          hhdr->hb_n_marks = n_marks;

      }

      GC_bytes_found = GC_bytes_found - (signed long int)sz;
      q = (char *)*((void **)q);
      if(q == ((char *)NULL))
        break;

      h = (struct hblk *)((unsigned long int)q & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
      if(!(h == last_h))
      {
        last_h = h;
        hhdr=GC_find_header((char *)h);
        sz = hhdr->hb_sz;
      }

    }
    while((_Bool)1);
  }

}

// GC_clear_hdr_marks
// file ./include/private/gc_priv.h line 1647
void GC_clear_hdr_marks(struct hblkhdr *hhdr)
{
  unsigned long int last_bit;
  unsigned long int tmp_if_expr_1;
  if(hhdr->hb_sz >= 2049ul)
    tmp_if_expr_1 = (unsigned long int)(1 << 12) / (unsigned long int)16;

  else
    tmp_if_expr_1 = hhdr->hb_sz * ((unsigned long int)(1 << 12) / hhdr->hb_sz) >> 4;
  last_bit = tmp_if_expr_1;
  memset((void *)hhdr->_mark_byte_union._hb_marks, 0, (unsigned long int)sizeof(char [257l]) /*257ul*/ );
  hhdr->_mark_byte_union._hb_marks[(signed long int)last_bit] = (char)1;
  hhdr->hb_n_marks = (volatile unsigned long int)0;
}

// GC_clear_mark_bit
// file ./include/private/../gc_mark.h line 246
extern void GC_clear_mark_bit(const void *p)
{
  struct hblk *h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  unsigned long int bit_no = (unsigned long int)((unsigned int)((char *)p - (char *)h) >> 4);
  if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
  {
    unsigned long int n_marks;
    hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] = (char)0;
    n_marks = hhdr->hb_n_marks - (unsigned long int)1;
    if(GC_parallel == 0 || !(n_marks == 0ul))
      hhdr->hb_n_marks = n_marks;

  }

}

// GC_clear_marks
// file ./include/private/gc_priv.h line 1553
void GC_clear_marks(void)
{
  GC_apply_to_all_blocks(clear_marks_for_block, (unsigned long int)0);
  GC_objects_are_marked = 0;
  GC_mark_state = 5;
  scan_ptr = ((struct hblk *)NULL);
}

// GC_clear_roots
// file mark_rts.c line 265
extern void GC_clear_roots(void)
{
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  roots_were_cleared = 1;
  n_root_sets = 0;
  GC_root_size = (unsigned long int)0;
  memset((void *)GC_arrays._root_index, 0, (unsigned long int)((unsigned long int)(1 << 6) * sizeof(void *) /*8ul*/ ));
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_clear_stack
// file ./include/private/../gc_mark.h line 229
extern void * GC_clear_stack(void *arg)
{
  char *sp;
  sp=GC_approx_sp();
  volatile unsigned long int dummy[256l];
  char *limit;
  static unsigned int random_no = (unsigned int)0;
  random_no = random_no + 1u;
  if(random_no % 13u == 0u)
  {
    limit = sp;
    limit = limit - (signed long int)((unsigned long int)2048 * sizeof(unsigned long int) /*8ul*/ );
    limit = (char *)((unsigned long int)limit & (unsigned long int)~0xf);
    void *return_value_GC_clear_stack_inner_1;
    return_value_GC_clear_stack_inner_1=GC_clear_stack_inner(arg, limit);
    return return_value_GC_clear_stack_inner_1;
  }

  else
  {
    memset((void *)dummy, 0, (unsigned long int)((unsigned long int)256 * sizeof(unsigned long int) /*8ul*/ ));
    return arg;
  }
}

// GC_clear_stack_inner
// file misc.c line 328
void * GC_clear_stack_inner(void *arg, char *limit)
{
  volatile unsigned long int dummy[213l];
  memset((void *)dummy, 0, (unsigned long int)sizeof(volatile unsigned long int [213l]) /*1704ul*/ );
  char *return_value_GC_approx_sp_1;
  return_value_GC_approx_sp_1=GC_approx_sp();
  if(!((unsigned long int)limit >= (unsigned long int)return_value_GC_approx_sp_1))
    GC_clear_stack_inner(arg, limit);

  GC_noop1((unsigned long int)dummy);
  return arg;
}

// GC_collect_a_little
// file alloc.c line 546
extern signed int GC_collect_a_little(void)
{
  signed int result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_collect_a_little_inner(1);
  signed int return_value_GC_collection_in_progress_2;
  return_value_GC_collection_in_progress_2=GC_collection_in_progress();
  result = (signed int)return_value_GC_collection_in_progress_2;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if(result == 0 && !(GC_debugging_started == 0))
    GC_print_all_smashed();

  return result;
}

// GC_collect_a_little_inner
// file alloc.c line 499
void GC_collect_a_little_inner(signed int n)
{
  signed int i;
  signed int cancel_state;
  signed int return_value_GC_collection_in_progress_3;
  if(GC_dont_gc == 0)
  {
    do
      pthread_setcancelstate(1, &cancel_state);
    while((_Bool)0);
    _Bool tmp_if_expr_4;
    if(!(GC_incremental == 0))
    {
      return_value_GC_collection_in_progress_3=GC_collection_in_progress();
      tmp_if_expr_4 = return_value_GC_collection_in_progress_3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      i = GC_deficit;
      for( ; !(i >= 10 * n); i = i + 1)
      {
        signed int return_value_GC_mark_some_2;
        return_value_GC_mark_some_2=GC_mark_some((char *)0);
        if(!(return_value_GC_mark_some_2 == 0))
        {
          if(!(GC_parallel == 0))
            GC_wait_for_reclaim();

          if(!(GC_time_limit == 999999ul) && !(GC_n_attempts >= 1))
          {
            GC_start_time=clock();
            signed int return_value_GC_stopped_mark_1;
            return_value_GC_stopped_mark_1=GC_stopped_mark(GC_timeout_stop_func);
            if(return_value_GC_stopped_mark_1 == 0)
            {
              GC_n_attempts = GC_n_attempts + 1;
              break;
            }

          }

          else
            GC_stopped_mark(GC_never_stop_func);
          GC_finish_collection();
          break;
        }

      }
      if(GC_deficit >= 1)
        GC_deficit = GC_deficit - 10 * n;

      if(!(GC_deficit >= 0))
        GC_deficit = 0;

    }

    else
      GC_maybe_gc();
    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }

}

// GC_collect_or_expand
// file alloc.c line 1249
signed int GC_collect_or_expand(unsigned long int needed_blocks, signed int ignore_off_page, signed int retry)
{
  signed int gc_not_stopped = 1;
  unsigned long int blocks_to_get;
  signed int cancel_state;
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  signed int return_value_GC_should_collect_1;
  if(GC_dont_gc == 0 && GC_incremental == 0)
  {
    _Bool tmp_if_expr_2;
    if(GC_arrays._bytes_allocd >= 1ul && !(GC_dont_expand == 0) || !((GC_arrays._bytes_finalized | last_bytes_finalized) == 0ul) && !(500ul + last_fo_entries >= GC_fo_entries))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_GC_should_collect_1=GC_should_collect();
      tmp_if_expr_2 = return_value_GC_should_collect_1 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
    {
      gc_not_stopped=GC_try_to_collect_inner(GC_arrays._bytes_allocd > (unsigned long int)0 && (!(GC_dont_expand != 0) || !(retry != 0)) ? GC_default_stop_func : GC_never_stop_func);
      if(gc_not_stopped == 1 || retry == 0)
      {
        last_fo_entries = GC_fo_entries;
        last_bytes_finalized = GC_arrays._bytes_finalized;
        do
          pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
        while((_Bool)0);
        return 1;
      }

    }

  }

  blocks_to_get = GC_arrays._heapsize / ((unsigned long int)(1 << 12) * GC_free_space_divisor) + needed_blocks;
  if(blocks_to_get >= 2049ul)
  {
    unsigned long int slop;
    if(!(ignore_off_page == 0))
      slop = (unsigned long int)4;

    else
    {
      slop = (unsigned long int)2 * (GC_black_list_spacing >> (unsigned long int)12);
      if(!(needed_blocks >= slop))
        slop = needed_blocks;

    }
    if(slop + needed_blocks >= 2049ul)
      blocks_to_get = needed_blocks + slop;

    else
      blocks_to_get = (unsigned long int)2048;
  }

  signed int return_value_GC_expand_hp_inner_4;
  return_value_GC_expand_hp_inner_4=GC_expand_hp_inner(blocks_to_get);
  _Bool tmp_if_expr_6;
  signed int return_value_GC_expand_hp_inner_5;
  if(return_value_GC_expand_hp_inner_4 == 0)
  {
    return_value_GC_expand_hp_inner_5=GC_expand_hp_inner(needed_blocks);
    tmp_if_expr_6 = !(return_value_GC_expand_hp_inner_5 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_6 = (_Bool)0;
  if(tmp_if_expr_6)
  {
    if(gc_not_stopped == 0)
      GC_try_to_collect_inner(GC_never_stop_func);

    else
    {
      unsigned int tmp_post_3 = GC_fail_count;
      GC_fail_count = GC_fail_count + 1u;
      if(!((unsigned long int)tmp_post_3 >= GC_max_retries))
      {
        GC_current_warn_proc("GC Warning: Out of Memory!  Trying to continue ...\n", (unsigned long int)0);
        GC_try_to_collect_inner(GC_never_stop_func);
      }

      else
      {
        GC_current_warn_proc("GC Warning: Out of Memory! Heap size: %ld MiB. Returning NULL!\n", (unsigned long int)(GC_arrays._heapsize - (unsigned long int)0 >> 20));
        pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
        return 0;
      }
    }
  }

  else
    if(!(GC_fail_count == 0u))
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Memory available again...\n");

    }

  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  return 1;
}

// GC_collection_in_progress
// file ./include/private/gc_priv.h line 1571
signed int GC_collection_in_progress(void)
{
  return (signed int)(GC_mark_state != 0);
}

// GC_compute_heap_usage_percent
// file alloc.c line 815
static inline signed int GC_compute_heap_usage_percent(void)
{
  unsigned long int used = GC_arrays._composite_in_use + GC_arrays._atomic_in_use;
  unsigned long int heap_sz = GC_arrays._heapsize - (unsigned long int)0;
  return used >= heap_sz ? 0 : (used < (unsigned long int)-1 / (unsigned long int)100 ? (signed int)((used * (unsigned long int)100) / heap_sz) : (signed int)(used / (heap_sz / (unsigned long int)100)));
}

// GC_compute_large_free_bytes
// file allchblk.c line 104
unsigned long int GC_compute_large_free_bytes(void)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned long int total_free = (unsigned long int)0;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 61u); i = i + 1u)
  {
    h = GC_hblkfreelist[(signed long int)i];
    for( ; !(h == ((struct hblk *)NULL)); h = hhdr->hb_next)
    {
      hhdr=GC_find_header((char *)h);
      total_free = total_free + hhdr->hb_sz;
    }
  }
  return total_free;
}

// GC_compute_root_size
// file mark_rts.c line 44
unsigned long int GC_compute_root_size(void)
{
  signed int i;
  unsigned long int size = (unsigned long int)0;
  i = 0;
  for( ; !(i >= n_root_sets); i = i + 1)
    size = size + (unsigned long int)(GC_arrays._static_roots[(signed long int)i].r_end - GC_arrays._static_roots[(signed long int)i].r_start);
  return size;
}

// GC_cond_register_dynamic_libraries
// file ./include/private/gc_priv.h line 1667
void GC_cond_register_dynamic_libraries(void)
{
  GC_remove_tmp_roots();
  if(GC_no_dls == 0)
    GC_register_dynamic_libraries();

}

// GC_continue_reclaim
// file ./include/private/gc_priv.h line 1784
void GC_continue_reclaim(unsigned long int sz, signed int kind)
{
  struct hblkhdr *hhdr;
  struct hblk *hbp;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)kind];
  struct hblk **rlh = ok->ok_reclaim_list;
  void **flh = &ok->ok_freelist[(signed long int)sz];
  if(!(rlh == ((struct hblk **)NULL)))
  {
    rlh = rlh + (signed long int)sz;
    do
    {
      hbp = *rlh;
      if(hbp == ((struct hblk *)NULL))
        break;

      hhdr=GC_find_header((char *)hbp);
      *rlh = hhdr->hb_next;
      GC_reclaim_small_nonempty_block(hbp, 0);
      if(!(*flh == NULL))
        break;

    }
    while((_Bool)1);
  }

}

// GC_copy_bl
// file blacklst.c line 127
void GC_copy_bl(unsigned long int *old, unsigned long int *new)
{
  memcpy((void *)new, (const void *)old, (unsigned long int)sizeof(unsigned long int [4096l]) /*32768ul*/ );
}

// GC_core_finalized_malloc
// file fnlz_mlc.c line 85
void * GC_core_finalized_malloc(unsigned long int lb, struct GC_finalizer_closure *fclos)
{
  char *op;
  char **opp;
  unsigned long int lg;
  lb = lb + sizeof(unsigned long int) /*8ul*/ ;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_finalized_objfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc_2;
      return_value_GC_generic_malloc_2=GC_generic_malloc((unsigned long int)lb, GC_finalized_kind);
      op = (char *)return_value_GC_generic_malloc_2;
      if(op == ((char *)NULL))
        return (void *)0;

      lg = GC_arrays._size_map[(signed long int)lb];
    }

    else
    {
      *opp = (char *)*((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
  }

  else
  {
    void *return_value_GC_generic_malloc_3;
    return_value_GC_generic_malloc_3=GC_generic_malloc(lb, GC_finalized_kind);
    op = (char *)return_value_GC_generic_malloc_3;
    if(op == ((char *)NULL))
      return (void *)0;

  }
  *((unsigned long int *)op) = (unsigned long int)fclos | (unsigned long int)1;
  void *return_value_GC_clear_stack_4;
  return_value_GC_clear_stack_4=GC_clear_stack((void *)((unsigned long int *)op + (signed long int)1));
  return return_value_GC_clear_stack_4;
}

// GC_core_gcj_malloc
// file gcj_mlc.c line 159
void * GC_core_gcj_malloc(unsigned long int lb, void *ptr_to_struct_containing_descr)
{
  char *op;
  char **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_gcjobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      maybe_finalize();
      void *return_value_GC_generic_malloc_inner_2;
      return_value_GC_generic_malloc_inner_2=GC_generic_malloc_inner((unsigned long int)lb, GC_gcj_kind);
      void *return_value_GC_clear_stack_3;
      return_value_GC_clear_stack_3=GC_clear_stack(return_value_GC_generic_malloc_inner_2);
      op = (char *)return_value_GC_clear_stack_3;
      if(op == ((char *)NULL))
      {
        void * (*oom_fn)(unsigned long int) = GC_oom_fn;
        do
          if(!(GC_need_to_lock == 0))
            pthread_mutex_unlock(&GC_allocate_ml);

        while((_Bool)0);
        void *return_value;
        return_value=oom_fn(lb);
        return return_value;
      }

    }

    else
    {
      *opp = (char *)*((void **)op);
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
    }
    *((void **)op) = ptr_to_struct_containing_descr;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_4;
        return_value_pthread_mutex_trylock_4=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_4 == 0))
          GC_lock();

      }

    while((_Bool)0);
    maybe_finalize();
    void *return_value_GC_generic_malloc_inner_5;
    return_value_GC_generic_malloc_inner_5=GC_generic_malloc_inner((unsigned long int)lb, GC_gcj_kind);
    void *return_value_GC_clear_stack_6;
    return_value_GC_clear_stack_6=GC_clear_stack(return_value_GC_generic_malloc_inner_5);
    op = (char *)return_value_GC_clear_stack_6;
    if(op == ((char *)NULL))
    {
      void * (*GC_core_gcj_malloc__1__2__2__oom_fn)(unsigned long int) = GC_oom_fn;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_1;
      return_value_1=GC_core_gcj_malloc__1__2__2__oom_fn(lb);
      return return_value_1;
    }

    *((void **)op) = ptr_to_struct_containing_descr;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
  return (void *)op;
}

// GC_core_malloc
// file malloc.c line 257
void * GC_core_malloc(unsigned long int lb)
{
  void *op;
  void **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = (void **)&GC_arrays._objfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == NULL)
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc_2;
      return_value_GC_generic_malloc_2=GC_generic_malloc((unsigned long int)lb, 1);
      void *return_value_GC_clear_stack_3;
      return_value_GC_clear_stack_3=GC_clear_stack(return_value_GC_generic_malloc_2);
      return return_value_GC_clear_stack_3;
    }

    *opp = *((void **)op);
    *((void **)op) = NULL;
    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return op;
  }

  else
  {
    void *return_value_GC_generic_malloc_4;
    return_value_GC_generic_malloc_4=GC_generic_malloc(lb, 1);
    void *return_value_GC_clear_stack_5;
    return_value_GC_clear_stack_5=GC_clear_stack(return_value_GC_generic_malloc_4);
    return return_value_GC_clear_stack_5;
  }
}

// GC_core_malloc_atomic
// file malloc.c line 227
void * GC_core_malloc_atomic(unsigned long int lb)
{
  void *op;
  void **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_arrays._aobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == NULL)
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc_2;
      return_value_GC_generic_malloc_2=GC_generic_malloc((unsigned long int)lb, 0);
      void *return_value_GC_clear_stack_3;
      return_value_GC_clear_stack_3=GC_clear_stack(return_value_GC_generic_malloc_2);
      return return_value_GC_clear_stack_3;
    }

    *opp = *((void **)op);
    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return (void *)op;
  }

  else
  {
    void *return_value_GC_generic_malloc_4;
    return_value_GC_generic_malloc_4=GC_generic_malloc((unsigned long int)lb, 0);
    void *return_value_GC_clear_stack_5;
    return_value_GC_clear_stack_5=GC_clear_stack(return_value_GC_generic_malloc_4);
    return return_value_GC_clear_stack_5;
  }
}

// GC_debug_change_stubborn
// file dbg_mlc.c line 667
extern void GC_debug_change_stubborn(const void *p)
{
  ;
}

// GC_debug_end_stubborn_change
// file dbg_mlc.c line 670
extern void GC_debug_end_stubborn_change(const void *p)
{
  ;
}

// GC_debug_free
// file dbg_mlc.c line 797
extern void GC_debug_free(void *p)
{
  char *base;
  if(!(p == NULL))
  {
    void *return_value_GC_base_1;
    return_value_GC_base_1=GC_base(p);
    base = (char *)return_value_GC_base_1;
    if(base == ((char *)NULL))
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Invalid pointer passed to free(): %p", p);

      GC_on_abort("Invalid pointer passed to free()");
      abort();
    }

    if(!((unsigned long int)((char *)p - base) == sizeof(struct anonymous_16) /*32ul*/ ))
      GC_err_printf("GC_debug_free called on pointer %p w/o debugging info\n", p);

    else
    {
      char *clobbered;
      clobbered=GC_check_annotated_obj((struct anonymous_16 *)base);
      unsigned long int sz;
      sz=GC_size((const void *)base);
      if(!(clobbered == ((char *)NULL)))
      {
        GC_have_errors = 1;
        if(((struct anonymous_16 *)base)->oh_sz == sz)
        {
          GC_print_smashed_obj("GC_debug_free: found previously deallocated (?) object at", (char *)p, clobbered);
          goto __CPROVER_DUMP_L17;
        }

        else
          GC_print_smashed_obj("GC_debug_free: found smashed location at", (char *)p, clobbered);
      }

      ((struct anonymous_16 *)base)->oh_sz = sz;
    }
    if(!(GC_find_leak == 0) && (GC_findleak_delay_free == 0 || !((unsigned long int)((char *)p - base) == sizeof(struct anonymous_16) /*32ul*/ )))
      GC_free((void *)base);

    else
    {
      struct hblkhdr *hhdr;
      hhdr=GC_find_header((char *)p);
      _Bool tmp_if_expr_2;
      if((signed int)hhdr->hb_obj_kind == 2)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)hhdr->hb_obj_kind == 3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        GC_free((void *)base);

      else
      {
        unsigned long int i;
        unsigned long int obj_sz = hhdr->hb_sz - sizeof(struct anonymous_16) /*32ul*/  >> 3;
        i = (unsigned long int)0;
        for( ; !(i >= obj_sz); i = i + 1ul)
          ((unsigned long int *)p)[(signed long int)i] = (unsigned long int)0xEFBEADDEdeadbeefUL;
      }
    }
  }


__CPROVER_DUMP_L17:
  ;
}

// GC_debug_gcj_malloc
// file gcj_mlc.c line 209
extern void * GC_debug_gcj_malloc(unsigned long int lb, void *ptr_to_struct_containing_descr, const char *s, signed int i)
{
  void *result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  maybe_finalize();
  result=GC_generic_malloc_inner(lb + ((sizeof(struct anonymous_16) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers), GC_gcj_debug_kind);
  if(result == NULL)
  {
    void * (*oom_fn)(unsigned long int) = GC_oom_fn;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    GC_err_printf("GC_debug_gcj_malloc(%lu, %p) returning NULL (%s:%d)\n", (unsigned long int)lb, ptr_to_struct_containing_descr, s, i);
    void *return_value;
    return_value=oom_fn(lb);
    return return_value;
  }

  *((void **)((char *)result + (signed long int)sizeof(struct anonymous_16) /*32ul*/ )) = ptr_to_struct_containing_descr;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if(GC_debugging_started == 0)
    GC_start_debugging();

  char *return_value_GC_store_debug_info_2;
  return_value_GC_store_debug_info_2=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
  return (void *)return_value_GC_store_debug_info_2;
}

// GC_debug_invoke_finalizer
// file dbg_mlc.c line 1065
void GC_debug_invoke_finalizer(void *obj, void *data)
{
  struct closure *cl = (struct closure *)data;
  cl->cl_fn((void *)((char *)obj + (signed long int)sizeof(struct anonymous_16) /*32ul*/ ), cl->cl_data);
}

// GC_debug_malloc
// file dbg_mlc.c line 509
extern void * GC_debug_malloc(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc(lb + ((sizeof(struct anonymous_16) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers));
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info_1;
    return_value_GC_store_debug_info_1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info_1;
  }
}

// GC_debug_malloc_atomic
// file dbg_mlc.c line 674
extern void * GC_debug_malloc_atomic(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_atomic(lb + ((sizeof(struct anonymous_16) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers));
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_atomic(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info_1;
    return_value_GC_store_debug_info_1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info_1;
  }
}

// GC_debug_malloc_atomic_ignore_off_page
// file dbg_mlc.c line 553
extern void * GC_debug_malloc_atomic_ignore_off_page(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_atomic_ignore_off_page(lb + ((sizeof(struct anonymous_16) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers));
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_atomic_ignore_off_page(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info_1;
    return_value_GC_store_debug_info_1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info_1;
  }
}

// GC_debug_malloc_atomic_uncollectable
// file dbg_mlc.c line 771
extern void * GC_debug_malloc_atomic_uncollectable(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_atomic_uncollectable(lb + sizeof(struct anonymous_16) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ );
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_atomic_uncollectable(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info_1;
    return_value_GC_store_debug_info_1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info_1;
  }
}

// GC_debug_malloc_ignore_off_page
// file dbg_mlc.c line 536
extern void * GC_debug_malloc_ignore_off_page(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_ignore_off_page(lb + ((sizeof(struct anonymous_16) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers));
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_ignore_off_page(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info_1;
    return_value_GC_store_debug_info_1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info_1;
  }
}

// GC_debug_malloc_replacement
// file dbg_mlc.c line 1216
extern void * GC_debug_malloc_replacement(unsigned long int lb)
{
  void *return_value_GC_debug_malloc_1;
  return_value_GC_debug_malloc_1=GC_debug_malloc(lb, "unknown", 0);
  return return_value_GC_debug_malloc_1;
}

// GC_debug_malloc_stubborn
// file dbg_mlc.c line 661
extern void * GC_debug_malloc_stubborn(unsigned long int lb, const char *s, signed int i)
{
  void *return_value_GC_debug_malloc_1;
  return_value_GC_debug_malloc_1=GC_debug_malloc(lb, s, i);
  return return_value_GC_debug_malloc_1;
}

// GC_debug_malloc_uncollectable
// file dbg_mlc.c line 752
extern void * GC_debug_malloc_uncollectable(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_uncollectable(lb + sizeof(struct anonymous_16) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ );
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_uncollectable(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info_1;
    return_value_GC_store_debug_info_1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info_1;
  }
}

// GC_debug_print_heap_obj_proc
// file dbg_mlc.c line 404
void GC_debug_print_heap_obj_proc(char *p)
{
  signed int return_value_GC_has_other_debug_info_1;
  return_value_GC_has_other_debug_info_1=GC_has_other_debug_info(p);
  if(return_value_GC_has_other_debug_info_1 >= 1)
    GC_print_obj(p);

  else
    GC_default_print_heap_obj_proc(p);
}

// GC_debug_realloc
// file dbg_mlc.c line 871
extern void * GC_debug_realloc(void *p, unsigned long int lb, const char *s, signed int i)
{
  void *base;
  void *result;
  struct hblkhdr *hhdr;
  if(p == NULL)
  {
    void *return_value_GC_debug_malloc_1;
    return_value_GC_debug_malloc_1=GC_debug_malloc(lb, s, i);
    return return_value_GC_debug_malloc_1;
  }

  base=GC_base(p);
  if(base == NULL)
  {
    if(!(GC_print_stats == 0))
      GC_log_printf("Invalid pointer passed to realloc(): %p", p);

    GC_on_abort("Invalid pointer passed to realloc()");
    abort();
  }

  if(!((unsigned long int)((char *)p - (char *)base) == sizeof(struct anonymous_16) /*32ul*/ ))
  {
    GC_err_printf("GC_debug_realloc called on pointer %p w/o debugging info\n", p);
    void *return_value_GC_realloc_2;
    return_value_GC_realloc_2=GC_realloc(p, lb);
    return return_value_GC_realloc_2;
  }

  hhdr=GC_find_header((char *)base);
  switch((signed int)hhdr->hb_obj_kind)
  {
    case 1:
    {
      result=GC_debug_malloc(lb, s, i);
      break;
    }
    case 0:
    {
      result=GC_debug_malloc_atomic(lb, s, i);
      break;
    }
    case 2:
    {
      result=GC_debug_malloc_uncollectable(lb, s, i);
      break;
    }
    case 3:
    {
      result=GC_debug_malloc_atomic_uncollectable(lb, s, i);
      break;
    }
    default:
    {
      result = (void *)0;
      if((signed long int)GC_current_warn_proc == -1l)
        break;

      GC_on_abort("GC_debug_realloc: encountered bad kind");
    }
  }
  abort();
  if(!(result == NULL))
  {
    unsigned long int old_sz = ((struct anonymous_16 *)base)->oh_sz;
    memcpy(result, p, (unsigned long int)(old_sz < lb ? old_sz : lb));
    GC_debug_free(p);
  }

  return result;
}

// GC_debug_realloc_replacement
// file dbg_mlc.c line 1221
extern void * GC_debug_realloc_replacement(void *p, unsigned long int lb)
{
  void *return_value_GC_debug_realloc_1;
  return_value_GC_debug_realloc_1=GC_debug_realloc(p, lb, "unknown", 0);
  return return_value_GC_debug_realloc_1;
}

// GC_debug_register_displacement
// file dbg_mlc.c line 478
extern void GC_debug_register_displacement(unsigned long int offset)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_register_displacement_inner(offset);
  GC_register_displacement_inner((unsigned long int)sizeof(struct anonymous_16) /*32ul*/  + offset);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_debug_register_finalizer
// file dbg_mlc.c line 1098
extern void GC_debug_register_finalizer(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  void (*my_old_fn)(void *, void *) = (void (*)(void *, void *))(signed long int)-1;
  void *my_old_cd;
  char *base;
  void *return_value_GC_base_1;
  return_value_GC_base_1=GC_base(obj);
  base = (char *)return_value_GC_base_1;
  if(base == ((char *)NULL))
  {
    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

  }

  else
  {
    if(!((unsigned long int)((char *)obj - base) == sizeof(struct anonymous_16) /*32ul*/ ))
      GC_err_printf("GC_debug_register_finalizer called with non-base-pointer %p\n", obj);

    if(fn == ((void (*)(void *, void *))NULL))
      GC_register_finalizer((void *)base, ((void (*)(void *, void *))NULL), NULL, &my_old_fn, &my_old_cd);

    else
    {
      cd=GC_make_closure(fn, cd);
      if(cd == NULL)
        goto __CPROVER_DUMP_L8;

      GC_register_finalizer((void *)base, GC_debug_invoke_finalizer, cd, &my_old_fn, &my_old_cd);
    }
    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);
  }

__CPROVER_DUMP_L8:
  ;
}

// GC_debug_register_finalizer_ignore_self
// file dbg_mlc.c line 1185
extern void GC_debug_register_finalizer_ignore_self(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  void (*my_old_fn)(void *, void *) = (void (*)(void *, void *))(signed long int)-1;
  void *my_old_cd;
  char *base;
  void *return_value_GC_base_1;
  return_value_GC_base_1=GC_base(obj);
  base = (char *)return_value_GC_base_1;
  if(base == ((char *)NULL))
  {
    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

  }

  else
  {
    if(!((unsigned long int)((char *)obj - base) == sizeof(struct anonymous_16) /*32ul*/ ))
      GC_err_printf("GC_debug_register_finalizer_ignore_self called with non-base-pointer %p\n", obj);

    if(fn == ((void (*)(void *, void *))NULL))
      GC_register_finalizer_ignore_self((void *)base, ((void (*)(void *, void *))NULL), NULL, &my_old_fn, &my_old_cd);

    else
    {
      cd=GC_make_closure(fn, cd);
      if(cd == NULL)
        goto __CPROVER_DUMP_L8;

      GC_register_finalizer_ignore_self((void *)base, GC_debug_invoke_finalizer, cd, &my_old_fn, &my_old_cd);
    }
    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);
  }

__CPROVER_DUMP_L8:
  ;
}

// GC_debug_register_finalizer_no_order
// file dbg_mlc.c line 1127
extern void GC_debug_register_finalizer_no_order(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  void (*my_old_fn)(void *, void *) = (void (*)(void *, void *))(signed long int)-1;
  void *my_old_cd;
  char *base;
  void *return_value_GC_base_1;
  return_value_GC_base_1=GC_base(obj);
  base = (char *)return_value_GC_base_1;
  if(base == ((char *)NULL))
  {
    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

  }

  else
  {
    if(!((unsigned long int)((char *)obj - base) == sizeof(struct anonymous_16) /*32ul*/ ))
      GC_err_printf("GC_debug_register_finalizer_no_order called with non-base-pointer %p\n", obj);

    if(fn == ((void (*)(void *, void *))NULL))
      GC_register_finalizer_no_order((void *)base, ((void (*)(void *, void *))NULL), NULL, &my_old_fn, &my_old_cd);

    else
    {
      cd=GC_make_closure(fn, cd);
      if(cd == NULL)
        goto __CPROVER_DUMP_L8;

      GC_register_finalizer_no_order((void *)base, GC_debug_invoke_finalizer, cd, &my_old_fn, &my_old_cd);
    }
    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);
  }

__CPROVER_DUMP_L8:
  ;
}

// GC_debug_register_finalizer_unreachable
// file dbg_mlc.c line 1156
extern void GC_debug_register_finalizer_unreachable(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  void (*my_old_fn)(void *, void *) = (void (*)(void *, void *))(signed long int)-1;
  void *my_old_cd;
  char *base;
  void *return_value_GC_base_1;
  return_value_GC_base_1=GC_base(obj);
  base = (char *)return_value_GC_base_1;
  if(base == ((char *)NULL))
  {
    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

  }

  else
  {
    if(!((unsigned long int)((char *)obj - base) == sizeof(struct anonymous_16) /*32ul*/ ))
      GC_err_printf("GC_debug_register_finalizer_unreachable called with non-base-pointer %p\n", obj);

    if(fn == ((void (*)(void *, void *))NULL))
      GC_register_finalizer_unreachable((void *)base, ((void (*)(void *, void *))NULL), NULL, &my_old_fn, &my_old_cd);

    else
    {
      cd=GC_make_closure(fn, cd);
      if(cd == NULL)
        goto __CPROVER_DUMP_L8;

      GC_register_finalizer_unreachable((void *)base, GC_debug_invoke_finalizer, cd, &my_old_fn, &my_old_cd);
    }
    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);
  }

__CPROVER_DUMP_L8:
  ;
}

// GC_debug_strdup
// file dbg_mlc.c line 691
extern char * GC_debug_strdup(const char *str, const char *s, signed int i)
{
  char *copy;
  unsigned long int lb;
  if(str == ((const char *)NULL))
  {
    if(!(GC_find_leak == 0))
      GC_err_printf("strdup(NULL) behavior is undefined\n");

    return (char *)(void *)0;
  }

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(str);
    lb = return_value_strlen_1 + (unsigned long int)1;
    void *return_value_GC_debug_malloc_atomic_2;
    return_value_GC_debug_malloc_atomic_2=GC_debug_malloc_atomic(lb, s, i);
    copy = (char *)return_value_GC_debug_malloc_atomic_2;
    if(copy == ((char *)NULL))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 12;
      return (char *)(void *)0;
    }

    memcpy((void *)copy, (const void *)str, (unsigned long int)lb);
    return copy;
  }
}

// GC_debug_strndup
// file dbg_mlc.c line 714
extern char * GC_debug_strndup(const char *str, unsigned long int size, const char *s, signed int i)
{
  char *copy;
  unsigned long int len;
  len=strlen(str);
  if(!(size >= len))
    len = size;

  void *return_value_GC_debug_malloc_atomic_1;
  return_value_GC_debug_malloc_atomic_1=GC_debug_malloc_atomic(len + (unsigned long int)1, s, i);
  copy = (char *)return_value_GC_debug_malloc_atomic_1;
  if(copy == ((char *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 12;
    return (char *)(void *)0;
  }

  memcpy((void *)copy, (const void *)str, (unsigned long int)len);
  copy[(signed long int)len] = (char)0;
  return copy;
}

// GC_default_is_valid_displacement_print_proc
// file ptr_chck.c line 103
void GC_default_is_valid_displacement_print_proc(void *p)
{
  if(!(GC_print_stats == 0))
    GC_log_printf("GC_is_valid_displacement test failed: %p not valid", p);

  GC_on_abort("GC_is_valid_displacement test failed");
  abort();
}

// GC_default_is_visible_print_proc
// file ptr_chck.c line 152
void GC_default_is_visible_print_proc(void *p)
{
  if(!(GC_print_stats == 0))
    GC_log_printf("GC_is_visible test failed: %p not GC-visible", p);

  GC_on_abort("GC_is_visible test failed");
  abort();
}

// GC_default_on_abort
// file misc.c line 1638
void GC_default_on_abort(const char *msg)
{
  GC_find_leak = 0;
  if(!(msg == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(msg);
    signed int return_value_GC_write_2;
    return_value_GC_write_2=GC_write(GC_stderr, (const char *)(void *)msg, return_value_strlen_1);
    if(return_value_GC_write_2 >= 0)
      GC_write(GC_stderr, (const char *)(void *)"\n", (unsigned long int)1);

  }

  char *return_value_getenv_3;
  return_value_getenv_3=getenv("GC_LOOP_ON_ABORT");
  if(!(return_value_getenv_3 == ((char *)NULL)))
  {

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

}

// GC_default_oom_fn
// file misc.c line 164
void * GC_default_oom_fn(unsigned long int bytes_requested)
{
  return NULL;
}

// GC_default_print_heap_obj_proc
// file blacklst.c line 57
void GC_default_print_heap_obj_proc(char *p)
{
  char *base;
  void *return_value_GC_base_1;
  return_value_GC_base_1=GC_base((void *)p);
  base = (char *)return_value_GC_base_1;
  signed int kind;
  struct hblkhdr *return_value_GC_find_header_2;
  return_value_GC_find_header_2=GC_find_header((char *)base);
  kind = (signed int)return_value_GC_find_header_2->hb_obj_kind;
  unsigned long int return_value_GC_size_3;
  return_value_GC_size_3=GC_size((const void *)base);
  GC_err_printf("object at %p of appr. %lu bytes (%s)\n", base, (unsigned long int)return_value_GC_size_3, kind == 0 ? "atomic" : ((kind & ~1) == 2 ? "uncollectable" : "composite"));
}

// GC_default_push_other_roots
// file os_dep.c line 2589
void GC_default_push_other_roots(void)
{
  GC_push_all_stacks();
}

// GC_default_same_obj_print_proc
// file ptr_chck.c line 21
void GC_default_same_obj_print_proc(void *p, void *q)
{
  if(!(GC_print_stats == 0))
    GC_log_printf("GC_same_obj test failed: %p and %p are not in the same object", p, q);

  GC_on_abort("GC_same_obj test failed");
  abort();
}

// GC_default_warn_proc
// file misc.c line 1590
void GC_default_warn_proc(char *msg, unsigned long int arg)
{
  GC_err_printf(msg, arg);
}

// GC_delete_gc_thread
// file pthread_support.c line 562
void GC_delete_gc_thread(struct GC_Thread_Rep *t)
{
  unsigned long int id = t->id;
  signed int hv = (signed int)((unsigned long int)id % (unsigned long int)256);
  struct GC_Thread_Rep *p = GC_threads[(signed long int)hv];
  struct GC_Thread_Rep *prev = ((struct GC_Thread_Rep *)NULL);
  for( ; !(p == t); p = p->next)
    prev = p;
  if(prev == ((struct GC_Thread_Rep *)NULL))
    GC_threads[(signed long int)hv] = p->next;

  else
    prev->next = p->next;
  GC_free_inner((void *)p);
}

// GC_delete_thread
// file pthread_support.c line 524
void GC_delete_thread(unsigned long int id)
{
  signed int hv = (signed int)((unsigned long int)id % (unsigned long int)256);
  struct GC_Thread_Rep *p = GC_threads[(signed long int)hv];
  struct GC_Thread_Rep *prev = ((struct GC_Thread_Rep *)NULL);
  for( ; !(p->id == id); p = p->next)
    prev = p;
  if(prev == ((struct GC_Thread_Rep *)NULL))
    GC_threads[(signed long int)hv] = p->next;

  else
    prev->next = p->next;
  if(!(p == &first_thread))
    GC_free_inner((void *)p);

}

// GC_descr_obj_size
// file typd_mlc.c line 421
unsigned long int GC_descr_obj_size(union ComplexDescriptor *d)
{
  unsigned long int return_value_GC_descr_obj_size_1;
  unsigned long int return_value_GC_descr_obj_size_2;
  unsigned long int return_value_GC_descr_obj_size_3;
  switch(d->ld.ld_tag)
  {
    case (unsigned long int)1:
      return d->ld.ld_nelements * d->ld.ld_size;
    case (unsigned long int)2:
    {
      return_value_GC_descr_obj_size_1=GC_descr_obj_size(d->ad.ad_element_descr);
      return d->ad.ad_nelements * return_value_GC_descr_obj_size_1;
    }
    case (unsigned long int)3:
    {
      return_value_GC_descr_obj_size_2=GC_descr_obj_size(d->sd.sd_first);
      return_value_GC_descr_obj_size_3=GC_descr_obj_size(d->sd.sd_second);
      return return_value_GC_descr_obj_size_2 + return_value_GC_descr_obj_size_3;
    }
    default:
    {
      if(!((signed long int)GC_current_warn_proc == -1l))
      {
        GC_on_abort("Bad complex descriptor");
        abort();
      }

      return (unsigned long int)0;
    }
  }
}

// GC_destroy_thread_local
// file thread_local_alloc.c line 127
void GC_destroy_thread_local(struct thread_local_freelists *p)
{
  return_freelists(p->ptrfree_freelists, GC_arrays._aobjfreelist);
  return_freelists(p->normal_freelists, GC_arrays._objfreelist);
  return_freelists(p->gcj_freelists, (void **)GC_gcjobjfreelist);
  return_freelists(p->finalized_freelists, (void **)GC_finalized_objfreelist);
}

// GC_dirty_init
// file ./include/private/gc_priv.h line 2039
void GC_dirty_init(void)
{
  struct sigaction act;
  struct sigaction oldact;
  act.sa_flags = 0x10000000 | 4;
  act.__sigaction_handler.sa_sigaction = GC_write_fault_handler;
  sigemptyset(&act.sa_mask);
  signed int return_value_GC_get_suspend_signal_1;
  return_value_GC_get_suspend_signal_1=GC_get_suspend_signal();
  sigaddset(&act.sa_mask, return_value_GC_get_suspend_signal_1);
  if(GC_print_stats == 2)
    GC_log_printf("Initializing mprotect virtual dirty bit implementation\n");

  GC_dirty_maintained = 1;
  if(!(GC_page_size % 4096ul == 0ul))
  {
    GC_on_abort("Page size not multiple of HBLKSIZE");
    abort();
  }

  signed int res;
  res=sigaction(11, &act, &oldact);
  if(!(res == 0))
  {
    GC_on_abort("Sigaction failed");
    abort();
  }

  if(!((4 & oldact.sa_flags) == 0))
  {
    GC_old_segv_handler = oldact.__sigaction_handler.sa_sigaction;
    GC_old_segv_handler_used_si = 1;
  }

  else
  {
    GC_old_segv_handler = (void (*)(signed int, struct anonymous_10 *, void *))oldact.__sigaction_handler.sa_handler;
    GC_old_segv_handler_used_si = 0;
  }
  if(GC_old_segv_handler == (void (*)(signed int, struct anonymous_10 *, void *))1)
  {
    GC_current_warn_proc("GC Warning: Previously ignored segmentation violation!?\n", (unsigned long int)0);
    GC_old_segv_handler = (void (*)(signed int, struct anonymous_10 *, void *))(void (*)(signed int))0;
  }

  if(!(GC_old_segv_handler == ((void (*)(signed int, struct anonymous_10 *, void *))NULL)))
  {
    if(GC_print_stats == 2)
      GC_log_printf("Replaced other SIGSEGV handler\n");

  }

  sigaction(7, &act, &oldact);
  if(!((4 & oldact.sa_flags) == 0))
    GC_old_bus_handler = oldact.__sigaction_handler.sa_sigaction;

  else
    GC_old_bus_handler = (void (*)(signed int, struct anonymous_10 *, void *))oldact.__sigaction_handler.sa_handler;
  if(GC_old_bus_handler == (void (*)(signed int, struct anonymous_10 *, void *))1)
    GC_current_warn_proc("GC Warning: Previously ignored bus error!?\n", (unsigned long int)0);

  else
    if(!(GC_old_bus_handler == ((void (*)(signed int, struct anonymous_10 *, void *))NULL)))
    {
      if(GC_print_stats == 2)
        GC_log_printf("Replaced other SIGBUS handler\n");

    }

}

// GC_disable
// file misc.c line 1725
extern void GC_disable(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_dont_gc = GC_dont_gc + 1;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_disclaim_and_reclaim
// file reclaim.c line 222
char * GC_disclaim_and_reclaim(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count)
{
  signed int bit_no = 0;
  unsigned long int *p;
  unsigned long int *q;
  unsigned long int *plim;
  signed long int n_bytes_found = (signed long int)0;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
  signed int (*disclaim)(void *) = ok->ok_disclaim_proc;
  p = (unsigned long int *)hbp->hb_body;
  plim = (unsigned long int *)(((char *)p + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz);
  signed int return_value;
  while((unsigned long int)plim >= (unsigned long int)p)
  {
    signed int marked = (signed int)hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no];
    if(marked == 0)
    {
      return_value=disclaim((void *)p);
      if(!(return_value == 0))
      {
        hhdr->hb_n_marks = hhdr->hb_n_marks + 1ul;
        marked = 1;
      }

    }

    if(!(marked == 0))
      p = (unsigned long int *)((char *)p + (signed long int)sz);

    else
    {
      n_bytes_found = n_bytes_found + (signed long int)sz;
      *((void **)p) = (void *)list;
      list = (char *)p;
      q = (unsigned long int *)((char *)p + (signed long int)sz);
      p[(signed long int)1] = (unsigned long int)0;
      p = p + (signed long int)2;
      for( ; !((unsigned long int)p >= (unsigned long int)q); p = p + (signed long int)2)
      {
        ((unsigned long int *)p)[(signed long int)0] = (unsigned long int)0;
        ((unsigned long int *)p)[(signed long int)1] = (unsigned long int)0;
      }
    }
    bit_no = bit_no + (signed int)(sz >> 4);
  }
  *count = *count + n_bytes_found;
  return list;
}

// GC_disclaim_and_reclaim_or_free_small_block
// file reclaim.c line 346
void GC_disclaim_and_reclaim_or_free_small_block(struct hblk *hbp)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)hbp);
  unsigned long int sz = hhdr->hb_sz;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
  void **flh = &ok->ok_freelist[(signed long int)(sz >> 4)];
  void *flh_next;
  hhdr->hb_last_reclaimed = (unsigned short int)GC_gc_no;
  char *return_value_GC_reclaim_generic_1;
  return_value_GC_reclaim_generic_1=GC_reclaim_generic(hbp, hhdr, sz, ok->ok_init, (char *)*flh, &GC_bytes_found);
  flh_next = (void *)return_value_GC_reclaim_generic_1;
  if(!(hhdr->hb_n_marks == 0ul))
    *flh = flh_next;

  else
  {
    GC_bytes_found = GC_bytes_found + (signed long int)(unsigned long int)(1 << 12);
    GC_freehblk(hbp);
  }
}

// GC_dlopen
// file gc_dlopen.c line 70
extern void * GC_dlopen(const char *path, signed int mode)
{
  void *result;
  disable_gc_for_dlopen();
  result=dlopen(path, mode);
  GC_enable();
  return result;
}

// GC_do_blocking
// file misc.c line 1940
extern void * GC_do_blocking(void * (*fn)(void *), void *client_data)
{
  struct blocking_data my_data;
  my_data.fn = fn;
  my_data.client_data = client_data;
  GC_with_callee_saves_pushed(GC_do_blocking_inner, (char *)&my_data);
  return my_data.client_data;
}

// GC_do_blocking_inner
// file ./include/private/gc_priv.h line 2271
void GC_do_blocking_inner(char *data, void *context)
{
  struct blocking_data *d = (struct blocking_data *)data;
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  me->stop_info.stack_ptr=GC_approx_sp();
  me->thread_blocked = (unsigned char)1;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  d->client_data=d->fn(d->client_data);
  if(!(GC_need_to_lock == 0))
  {
    signed int return_value_pthread_mutex_trylock_2;
    return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(&GC_allocate_ml);
    if(!(return_value_pthread_mutex_trylock_2 == 0))
      GC_lock();

  }

  me->thread_blocked = (unsigned char)0;
  if(!(GC_need_to_lock == 0))
    pthread_mutex_unlock(&GC_allocate_ml);

}

// GC_do_local_mark
// file mark.c line 964
void GC_do_local_mark(struct GC_ms_entry *local_mark_stack, struct GC_ms_entry *local_top)
{
  unsigned int n;
  do
  {
    n = (unsigned int)0;
    for( ; !(n >= 1u); n = n + 1u)
    {
      local_top=GC_mark_from(local_top, local_mark_stack, local_mark_stack + (signed long int)(unsigned long int)(1 << 12));
      if(!((unsigned long int)local_top >= (unsigned long int)local_mark_stack))
        goto __CPROVER_DUMP_L7;

      if((unsigned long int)(local_top - local_mark_stack) >= 2048ul)
      {
        GC_return_mark_stack(local_mark_stack, local_top);
        goto __CPROVER_DUMP_L7;
      }

    }
    unsigned long int return_value_AO_load_1;
    return_value_AO_load_1=AO_load_link1((volatile unsigned long int *)&GC_arrays._mark_stack_top);
    unsigned long int return_value_AO_load_2;
    return_value_AO_load_2=AO_load_link1(&GC_first_nonempty);
    if(!(return_value_AO_load_1 >= return_value_AO_load_2))
    {
      if(!(GC_active_count >= GC_helper_count))
      {
        if(!((unsigned long int)(local_mark_stack + 1l) >= (unsigned long int)local_top))
        {
          struct GC_ms_entry *new_bottom = local_mark_stack + (local_top - local_mark_stack) / (signed long int)2;
          GC_return_mark_stack(local_mark_stack, new_bottom - (signed long int)1);
          memmove((void *)local_mark_stack, (const void *)new_bottom, (unsigned long int)((local_top - new_bottom) + (signed long int)1) * sizeof(struct GC_ms_entry) /*16ul*/ );
          local_top = local_top - (new_bottom - local_mark_stack);
        }

      }

    }

  }
  while((_Bool)1);

__CPROVER_DUMP_L7:
  ;
}

// GC_do_parallel_mark
// file mark.c line 1119
void GC_do_parallel_mark(void)
{
  struct GC_ms_entry local_mark_stack[4096l];
  GC_acquire_mark_lock();
  if(!(GC_help_wanted == 0) || !(GC_active_count == 0u) || !(GC_helper_count == 0u))
  {
    GC_on_abort("Tried to start parallel mark in bad state");
    abort();
  }

  if(GC_print_stats == 2)
    GC_log_printf("Starting marking for mark phase number %lu\n", (unsigned long int)GC_mark_no);

  GC_first_nonempty = (unsigned long int)GC_arrays._mark_stack;
  GC_active_count = (unsigned int)0;
  GC_helper_count = (unsigned int)1;
  GC_help_wanted = 1;
  GC_release_mark_lock();
  GC_notify_all_marker();
  GC_mark_local(local_mark_stack, 0);
  GC_acquire_mark_lock();
  GC_help_wanted = 0;
  while(GC_helper_count >= 1u)
    GC_wait_marker();
  if(GC_print_stats == 2)
    GC_log_printf("Finished marking for mark phase number %lu\n", (unsigned long int)GC_mark_no);

  GC_mark_no = GC_mark_no + 1ul;
  GC_release_mark_lock();
  GC_notify_all_marker();
}

// GC_double_descr
// file typd_mlc.c line 175
unsigned long int GC_double_descr(unsigned long int descriptor, unsigned long int nwords)
{
  if((3ul & descriptor) == 0ul)
    descriptor = GC_bm_table[(signed long int)((unsigned long int)descriptor >> 3)];

  descriptor = descriptor | (descriptor & (unsigned long int)~((1 << 2) - 1)) >> nwords;
  return descriptor;
}

// GC_dump
// file ./include/private/../gc.h line 1395
extern void GC_dump(void)
{
  GC_printf("***Static roots:\n");
  GC_print_static_roots();
  GC_printf("\n***Heap sections:\n");
  GC_print_heap_sects();
  GC_printf("\n***Free blocks:\n");
  GC_print_hblkfreelist();
  GC_printf("\n***Blocks in use:\n");
  GC_print_block_list();
}

// GC_dump_finalization
// file finalize.c line 612
void GC_dump_finalization(void)
{
  struct finalizable_object *curr_fo;
  unsigned long int fo_size = (unsigned long int)(log_fo_table_size == (signed long int)-1 ? 0 : 1 << log_fo_table_size);
  char *real_ptr;
  unsigned long int i;
  GC_printf("Disappearing (short) links:\n");
  GC_dump_finalization_links(&GC_dl_hashtbl);
  GC_printf("Disappearing long links:\n");
  GC_dump_finalization_links(&GC_ll_hashtbl);
  GC_printf("Finalizers:\n");
  i = (unsigned long int)0;
  for( ; !(i >= fo_size); i = i + 1ul)
  {
    curr_fo = GC_fo_head[(signed long int)i];
    for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = (struct finalizable_object *)curr_fo->prolog.next)
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      GC_printf("Finalizable object: %p\n", real_ptr);
    }
  }
}

// GC_dump_finalization_links
// file finalize.c line 593
void GC_dump_finalization_links(struct dl_hashtbl_s *dl_hashtbl)
{
  struct disappearing_link *curr_dl;
  char *real_ptr;
  char *real_link;
  unsigned long int dl_size;
  signed int tmp_if_expr_1;
  if(dl_hashtbl->log_size == -1l)
    tmp_if_expr_1 = 0;

  else
    tmp_if_expr_1 = 1 << dl_hashtbl->log_size;
  dl_size = (unsigned long int)tmp_if_expr_1;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= dl_size); i = i + 1ul)
  {
    curr_dl = dl_hashtbl->head[(signed long int)i];
    for( ; !(curr_dl == ((struct disappearing_link *)NULL)); curr_dl = (struct disappearing_link *)curr_dl->prolog.next)
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_dl->dl_hidden_obj);
      real_link = (char *)(void *)~((unsigned long int)curr_dl->prolog.hidden_key);
      GC_printf("Object: %p, link: %p\n", real_ptr, real_link);
    }
  }
}

// GC_dump_regions
// file allchblk.c line 170
void GC_dump_regions(void)
{
  unsigned int i;
  char *start;
  char *end;
  char *p;
  unsigned long int bytes;
  struct hblkhdr *hhdr;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= GC_n_heap_sects); i = i + 1u)
  {
    start = GC_arrays._heap_sects[(signed long int)i].hs_start;
    bytes = GC_arrays._heap_sects[(signed long int)i].hs_bytes;
    end = start + (signed long int)bytes;
    for( ; !((unsigned long int)(1u + i) >= GC_n_heap_sects); end = GC_arrays._heap_sects[(signed long int)i].hs_start + (signed long int)GC_arrays._heap_sects[(signed long int)i].hs_bytes)
    {
      if(!(GC_arrays._heap_sects[(signed long int)(1u + i)].hs_start == end))
        break;

      i = i + 1u;
    }
    GC_printf("***Section from %p to %p\n", start, end);
    p = start;
    while(!((unsigned long int)p >= (unsigned long int)end))
    {
      hhdr=GC_find_header((char *)p);
      if(!((unsigned long int)hhdr >= 4096ul))
      {
        GC_printf("\t%p Missing header!!(%p)\n", p, (void *)hhdr);
        p = p + (signed long int)(unsigned long int)(1 << 12);
      }

      else
        if(!((4 & (signed int)hhdr->hb_flags) == 0))
        {
          signed int correct_index;
          correct_index=GC_hblk_fl_from_blocks(hhdr->hb_sz >> (unsigned long int)12);
          signed int actual_index;
          GC_printf("\t%p\tfree block of size 0x%lx bytes%s\n", p, (unsigned long int)hhdr->hb_sz, 1 != 0 ? "" : " (unmapped)");
          actual_index=free_list_index_of(hhdr);
          if(actual_index == -1)
            GC_printf("\t\tBlock not on free list %d!!\n", correct_index);

          else
            if(!(correct_index == actual_index))
              GC_printf("\t\tBlock on list %d, should be on %d!!\n", actual_index, correct_index);

          p = p + (signed long int)hhdr->hb_sz;
        }

        else
        {
          GC_printf("\t%p\tused for blocks of size 0x%lx bytes\n", p, (unsigned long int)hhdr->hb_sz);
          p = p + (signed long int)((unsigned long int)(1 << 12) * ((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12));
        }
    }
  }
}

// GC_enable
// file ./include/private/../gc.h line 693
extern void GC_enable(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_dont_gc = GC_dont_gc - 1;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_enable_incremental
// file misc.c line 1228
extern void GC_enable_incremental(void)
{
  char *return_value_getenv_2;
  if(GC_find_leak == 0)
  {
    return_value_getenv_2=getenv("GC_DISABLE_INCREMENTAL");
    if(return_value_getenv_2 == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
        {
          signed int return_value_pthread_mutex_trylock_1;
          return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
          if(!(return_value_pthread_mutex_trylock_1 == 0))
            GC_lock();

        }

      while((_Bool)0);
      if(GC_incremental == 0)
      {
        GC_setpagesize();
        maybe_install_looping_handler();
        GC_incremental = 1;
        if(GC_is_initialized == 0)
          GC_init();

        else
          GC_dirty_init();
        if(GC_dont_gc == 0 && !(GC_dirty_maintained == 0))
        {
          if(GC_arrays._bytes_allocd >= 1ul)
            GC_try_to_collect_inner(GC_never_stop_func);

          GC_read_dirty();
        }

      }

      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      goto __CPROVER_DUMP_L11;
    }

  }

  GC_init();

__CPROVER_DUMP_L11:
  ;
}

// GC_end_stubborn_change
// file stubborn.c line 48
extern void GC_end_stubborn_change(const void *p)
{
  ;
}

// GC_enough_large_bytes_left
// file allchblk.c line 70
static inline signed int GC_enough_large_bytes_left(void)
{
  signed int n;
  unsigned long int bytes = GC_arrays._large_allocd_bytes;
  n = (256 - 32) / 8 + 32;
  for( ; n >= 0; n = n - 1)
  {
    bytes = bytes + GC_free_bytes[(signed long int)n];
    if(bytes >= GC_arrays._max_large_allocd_bytes)
      return n;

  }
  return 0;
}

// GC_enqueue_all_finalizers
// file finalize.c line 881
void GC_enqueue_all_finalizers(void)
{
  struct finalizable_object *curr_fo;
  struct finalizable_object *prev_fo;
  struct finalizable_object *next_fo;
  char *real_ptr;
  signed int i;
  signed int fo_size = log_fo_table_size == (signed long int)-1 ? 0 : 1 << log_fo_table_size;
  GC_arrays._bytes_finalized = (unsigned long int)0;
  i = 0;
  for( ; !(i >= fo_size); i = i + 1)
  {
    curr_fo = GC_fo_head[(signed long int)i];
    prev_fo = ((struct finalizable_object *)NULL);
    if(!(curr_fo == ((struct finalizable_object *)NULL)))
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      (GC_normal_finalize_mark_proc)(real_ptr);
      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);

      if(!(GC_mark_state == 0))
      {
        GC_set_mark_bit((const void *)real_ptr);
        signed int return_value_GC_mark_some_1;
        return_value_GC_mark_some_1=GC_mark_some((char *)0);
      }

      GC_set_mark_bit((const void *)real_ptr);
      next_fo = (struct finalizable_object *)curr_fo->prolog.next;
      if(prev_fo == ((struct finalizable_object *)NULL))
        GC_fo_head[(signed long int)i] = next_fo;

      else
        prev_fo->prolog.next = (struct hash_chain_entry *)next_fo;
      GC_fo_entries = GC_fo_entries - 1ul;
      curr_fo->prolog.next = (struct hash_chain_entry *)GC_finalize_now;
      GC_finalize_now = curr_fo;
      curr_fo->prolog.hidden_key = (unsigned long int)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      GC_arrays._bytes_finalized = GC_arrays._bytes_finalized + curr_fo->fo_object_size + sizeof(struct finalizable_object) /*48ul*/ ;
      curr_fo = next_fo;
    }

  }
}

// GC_err_printf
// file ./include/private/gc_priv.h line 2096
extern void GC_err_printf(const char *format, ...)
{
  char buf[1025l];
  do
  {
    void **args = (void **)&format;
    buf[(signed long int)(sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1)] = (char)0x15;
    vsnprintf(buf, sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1, format, args);
    args = ((void **)NULL);
    if(!((signed int)buf[1024l] == 0x15))
    {
      GC_on_abort("GC_printf clobbered stack");
      abort();
    }

  }
  while((_Bool)0);
  GC_err_puts(buf);
}

// GC_err_puts
// file misc.c line 1585
void GC_err_puts(const char *s)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  GC_write(GC_stderr, s, return_value_strlen_1);
}

// GC_exclude_static_roots
// file mark_rts.c line 474
extern void GC_exclude_static_roots(void *b, void *e)
{
  if(!(b == e))
  {
    b = (void *)((unsigned long int)b & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
    e = (void *)((unsigned long int)e + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1) & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
    if(e == NULL)
      e = (void *)(unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1);

    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_exclude_static_roots_inner(b, e);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

}

// GC_exclude_static_roots_inner
// file ./include/private/gc_priv.h line 1661
void GC_exclude_static_roots_inner(void *start, void *finish)
{
  struct exclusion *next;
  unsigned long int next_index;
  unsigned long int i;
  if(GC_excl_table_entries == 0ul)
    next = ((struct exclusion *)NULL);

  else
    next=GC_next_exclusion((char *)start);
  if(!(next == ((struct exclusion *)NULL)))
  {
    if(!((unsigned long int)next->e_start >= (unsigned long int)finish))
    {
      GC_on_abort("Exclusion ranges overlap");
      abort();
    }

    if((unsigned long int)next->e_start == (unsigned long int)finish)
    {
      next->e_start = (char *)start;
      goto __CPROVER_DUMP_L10;
    }

    next_index = (unsigned long int)(next - GC_arrays._excl_table);
    i = GC_excl_table_entries;
    for( ; !(next_index >= i); i = i - 1ul)
      GC_arrays._excl_table[(signed long int)i] = GC_arrays._excl_table[(signed long int)(i - (unsigned long int)1)];
  }

  else
    next_index = GC_excl_table_entries;
  if(GC_excl_table_entries == 512ul)
  {
    GC_on_abort("Too many exclusions");
    abort();
  }

  GC_arrays._excl_table[(signed long int)next_index].e_start = (char *)start;
  GC_arrays._excl_table[(signed long int)next_index].e_end = (char *)finish;
  GC_excl_table_entries = GC_excl_table_entries + 1ul;

__CPROVER_DUMP_L10:
  ;
}

// GC_exit_check
// file misc.c line 744
void GC_exit_check(void)
{
  if(!(GC_find_leak == 0))
    GC_gcollect();

}

// GC_expand_hp
// file alloc.c line 1223
extern signed int GC_expand_hp(unsigned long int bytes)
{
  signed int result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  signed int return_value_GC_expand_hp_inner_2;
  return_value_GC_expand_hp_inner_2=GC_expand_hp_inner((unsigned long int)bytes >> (unsigned long int)12);
  result = (signed int)return_value_GC_expand_hp_inner_2;
  if(!(result == 0))
    GC_arrays._requested_heapsize = GC_arrays._requested_heapsize + bytes;

  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_expand_hp_inner
// file alloc.c line 1155
signed int GC_expand_hp_inner(unsigned long int n)
{
  unsigned long int bytes;
  struct hblk *space;
  unsigned long int expansion_slop;
  if(!(n >= 16ul))
    n = (unsigned long int)16;

  bytes = n * (unsigned long int)(1 << 12);
  unsigned long int mask = GC_page_size - (unsigned long int)1;
  bytes = bytes + mask;
  bytes = bytes & ~mask;
  if(!(GC_max_heapsize == 0ul) && !(GC_max_heapsize >= GC_arrays._heapsize + bytes))
    return 0;

  else
  {
    char *return_value_GC_unix_get_mem_1;
    return_value_GC_unix_get_mem_1=GC_unix_get_mem(bytes);
    space = (struct hblk *)return_value_GC_unix_get_mem_1;
    if(space == ((struct hblk *)NULL))
    {
      GC_current_warn_proc("GC Warning: Failed to expand heap by %ld bytes\n", (unsigned long int)bytes);
      return 0;
    }

    else
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Grow heap to %lu KiB after %lu bytes allocated\n", (unsigned long int)(GC_arrays._heapsize + bytes + (unsigned long int)((1 << 9) - 1) >> 10), (unsigned long int)GC_arrays._bytes_allocd);

      unsigned long int return_value_min_bytes_allocd_2;
      return_value_min_bytes_allocd_2=min_bytes_allocd();
      expansion_slop = return_value_min_bytes_allocd_2 + (unsigned long int)(4 * 2048) * (unsigned long int)(1 << 12);
      if((9223372036854775808ul & (unsigned long int)space) == 0ul && GC_arrays._last_heap_addr == ((char *)NULL) || !(GC_arrays._last_heap_addr == ((char *)NULL)) && !((unsigned long int)GC_arrays._last_heap_addr >= (unsigned long int)space))
      {
        unsigned long int new_limit = (unsigned long int)space + bytes + expansion_slop;
        if(!((unsigned long int)space >= new_limit))
        {
          unsigned long int return_value_GC_max_3;
          return_value_GC_max_3=GC_max((unsigned long int)GC_greatest_plausible_heap_addr, (unsigned long int)new_limit);
          GC_greatest_plausible_heap_addr = (void *)return_value_GC_max_3;
        }

      }

      else
      {
        unsigned long int GC_expand_hp_inner__1__6__new_limit = (unsigned long int)space - expansion_slop;
        if(!(GC_expand_hp_inner__1__6__new_limit >= (unsigned long int)space))
        {
          unsigned long int return_value_GC_min_4;
          return_value_GC_min_4=GC_min((unsigned long int)GC_least_plausible_heap_addr, (unsigned long int)space - expansion_slop);
          GC_least_plausible_heap_addr = (void *)return_value_GC_min_4;
        }

      }
      GC_arrays._prev_heap_addr = GC_arrays._last_heap_addr;
      GC_arrays._last_heap_addr = (char *)space;
      GC_add_to_heap(space, bytes);
      GC_collect_at_heapsize = (GC_arrays._heapsize + expansion_slop) - (unsigned long int)(2 * 2048) * (unsigned long int)(1 << 12);
      if(!(GC_collect_at_heapsize >= GC_arrays._heapsize))
        GC_collect_at_heapsize = (unsigned long int)-1;

      if(!(GC_on_heap_resize == ((void (*)(unsigned long int))NULL)))
        GC_on_heap_resize(GC_arrays._heapsize);

      return 1;
    }
  }
}

// GC_extend_size_map
// file ./include/private/gc_priv.h line 2220
void GC_extend_size_map(unsigned long int i)
{
  unsigned long int orig_granule_sz = i + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  unsigned long int granule_sz = orig_granule_sz;
  unsigned long int byte_sz = granule_sz << 4;
  unsigned long int smaller_than_i = byte_sz - (byte_sz >> 3);
  unsigned long int much_smaller_than_i = byte_sz - (byte_sz >> 2);
  unsigned long int low_limit;
  unsigned long int j;
  if(GC_arrays._size_map[(signed long int)smaller_than_i] == 0ul)
  {
    low_limit = much_smaller_than_i;
    for( ; !(GC_arrays._size_map[(signed long int)low_limit] == 0ul); low_limit = low_limit + 1ul)
      ;
  }

  else
  {
    low_limit = smaller_than_i + (unsigned long int)1;
    for( ; !(GC_arrays._size_map[(signed long int)low_limit] == 0ul); low_limit = low_limit + 1ul)
      ;
    granule_sz = low_limit + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
    granule_sz = granule_sz + (granule_sz >> 3);
    if(!(granule_sz >= orig_granule_sz))
      granule_sz = orig_granule_sz;

  }
  granule_sz = granule_sz + (unsigned long int)1;
  granule_sz = granule_sz & (unsigned long int)~1;
  if(granule_sz >= 129ul)
    granule_sz = (unsigned long int)((1 << 12) / 2 >> 4);

  unsigned long int number_of_objs = ((unsigned long int)(1 << 12) / (unsigned long int)16) / granule_sz;
  granule_sz = ((unsigned long int)(1 << 12) / (unsigned long int)16) / number_of_objs;
  granule_sz = granule_sz & (unsigned long int)~1;
  byte_sz = granule_sz << 4;
  byte_sz = byte_sz - (unsigned long int)GC_all_interior_pointers;
  j = low_limit;
  for( ; byte_sz >= j; j = j + 1ul)
    GC_arrays._size_map[(signed long int)j] = granule_sz;
}

// GC_fault_handler
// file os_dep.c line 922
void GC_fault_handler(signed int sig)
{
  siglongjmp(GC_jmp_buf, 1);
}

// GC_finalize
// file ./include/private/gc_priv.h line 262
void GC_finalize(void)
{
  struct finalizable_object *curr_fo;
  struct finalizable_object *prev_fo;
  struct finalizable_object *next_fo;
  char *real_ptr;
  unsigned long int i;
  unsigned long int fo_size = (unsigned long int)(log_fo_table_size == (signed long int)-1 ? 0 : 1 << log_fo_table_size);
  GC_old_dl_entries = GC_dl_hashtbl.entries;
  GC_old_ll_entries = GC_ll_hashtbl.entries;
  GC_make_disappearing_links_disappear(&GC_dl_hashtbl);
  i = (unsigned long int)0;
  for( ; !(i >= fo_size); i = i + 1ul)
  {
    curr_fo = GC_fo_head[(signed long int)i];
    for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = (struct finalizable_object *)curr_fo->prolog.next)
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      signed int return_value_GC_is_marked_3;
      return_value_GC_is_marked_3=GC_is_marked((const void *)real_ptr);
      if(return_value_GC_is_marked_3 == 0)
      {
        curr_fo->fo_mark_proc(real_ptr);
        if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
          GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);

        if(!(GC_mark_state == 0))
        {
          GC_set_mark_bit((const void *)real_ptr);
          signed int return_value_GC_mark_some_1;
          return_value_GC_mark_some_1=GC_mark_some((char *)0);
        }

        signed int return_value_GC_is_marked_2;
        return_value_GC_is_marked_2=GC_is_marked((const void *)real_ptr);
        if(!(return_value_GC_is_marked_2 == 0))
          GC_current_warn_proc("GC Warning: Finalization cycle involving %p\n", (unsigned long int)real_ptr);

      }

    }
  }
  GC_arrays._bytes_finalized = (unsigned long int)0;
  i = (unsigned long int)0;
  for( ; !(i >= fo_size); i = i + 1ul)
  {
    curr_fo = GC_fo_head[(signed long int)i];
    prev_fo = ((struct finalizable_object *)NULL);
    while(!(curr_fo == ((struct finalizable_object *)NULL)))
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      signed int return_value_GC_is_marked_4;
      return_value_GC_is_marked_4=GC_is_marked((const void *)real_ptr);
      if(return_value_GC_is_marked_4 == 0)
      {
        if(GC_java_finalization == 0)
          GC_set_mark_bit((const void *)real_ptr);

        next_fo = (struct finalizable_object *)curr_fo->prolog.next;
        if(prev_fo == ((struct finalizable_object *)NULL))
          GC_fo_head[(signed long int)i] = next_fo;

        else
          prev_fo->prolog.next = (struct hash_chain_entry *)next_fo;
        GC_fo_entries = GC_fo_entries - 1ul;
        curr_fo->prolog.next = (struct hash_chain_entry *)GC_finalize_now;
        GC_finalize_now = curr_fo;
        curr_fo->prolog.hidden_key = (unsigned long int)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
        GC_arrays._bytes_finalized = GC_arrays._bytes_finalized + curr_fo->fo_object_size + sizeof(struct finalizable_object) /*48ul*/ ;
        curr_fo = next_fo;
      }

      else
      {
        prev_fo = curr_fo;
        curr_fo = (struct finalizable_object *)curr_fo->prolog.next;
      }
    }
  }
  if(!(GC_java_finalization == 0))
  {
    curr_fo = GC_finalize_now;
    for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = (struct finalizable_object *)curr_fo->prolog.next)
    {
      real_ptr = (char *)curr_fo->prolog.hidden_key;
      signed int return_value_GC_is_marked_6;
      return_value_GC_is_marked_6=GC_is_marked((const void *)real_ptr);
      if(return_value_GC_is_marked_6 == 0)
      {
        if(curr_fo->fo_mark_proc == GC_null_finalize_mark_proc)
        {
          (GC_normal_finalize_mark_proc)(real_ptr);
          if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
            GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);

          if(!(GC_mark_state == 0))
          {
            GC_set_mark_bit((const void *)real_ptr);
            signed int return_value_GC_mark_some_5;
            return_value_GC_mark_some_5=GC_mark_some((char *)0);
          }

        }

        if(!(curr_fo->fo_mark_proc == GC_unreachable_finalize_mark_proc))
          GC_set_mark_bit((const void *)real_ptr);

      }

    }
    if(!(need_unreachable_finalization == 0))
    {
      curr_fo = GC_finalize_now;
      prev_fo = ((struct finalizable_object *)NULL);
      for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = next_fo)
      {
        next_fo = (struct finalizable_object *)curr_fo->prolog.next;
        if(curr_fo->fo_mark_proc == GC_unreachable_finalize_mark_proc)
        {
          real_ptr = (char *)curr_fo->prolog.hidden_key;
          signed int return_value_GC_is_marked_7;
          return_value_GC_is_marked_7=GC_is_marked((const void *)real_ptr);
          if(return_value_GC_is_marked_7 == 0)
            GC_set_mark_bit((const void *)real_ptr);

          else
          {
            if(prev_fo == ((struct finalizable_object *)NULL))
              GC_finalize_now = next_fo;

            else
              prev_fo->prolog.next = (struct hash_chain_entry *)next_fo;
            curr_fo->prolog.hidden_key = ~((unsigned long int)curr_fo->prolog.hidden_key);
            GC_arrays._bytes_finalized = GC_arrays._bytes_finalized - (curr_fo->fo_object_size + sizeof(struct finalizable_object) /*48ul*/ );
            i = ((unsigned long int)real_ptr >> 3 ^ (unsigned long int)real_ptr >> (signed long int)3 + log_fo_table_size) & (unsigned long int)((1 << log_fo_table_size) - 1);
            curr_fo->prolog.next = (struct hash_chain_entry *)GC_fo_head[(signed long int)i];
            GC_fo_entries = GC_fo_entries + 1ul;
            GC_fo_head[(signed long int)i] = curr_fo;
            curr_fo = prev_fo;
          }
        }

        prev_fo = curr_fo;
      }
    }

  }

  GC_remove_dangling_disappearing_links(&GC_dl_hashtbl);
  GC_make_disappearing_links_disappear(&GC_ll_hashtbl);
  GC_remove_dangling_disappearing_links(&GC_ll_hashtbl);
  if(!(GC_fail_count == 0u))
    GC_reset_finalizer_nested();

}

// GC_finalize_all
// file finalize.c line 936
extern void GC_finalize_all(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  while(GC_fo_entries >= 1ul)
  {
    GC_enqueue_all_finalizers();
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    GC_invoke_finalizers();
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_2;
        return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_2 == 0))
          GC_lock();

      }

    while((_Bool)0);
  }
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_finalized_disclaim
// file fnlz_mlc.c line 29
signed int GC_finalized_disclaim(void *obj)
{
  unsigned long int fc_word = *((unsigned long int *)obj);
  if(!((1ul & fc_word) == 0ul))
  {
    struct GC_finalizer_closure *fc = (struct GC_finalizer_closure *)(void *)(fc_word & ~((unsigned long int)1));
    fc->proc((void *)((unsigned long int *)obj + (signed long int)1), fc->cd);
  }

  return 0;
}

// GC_finalized_malloc
// file fnlz_mlc.c line 130
extern void * GC_finalized_malloc(unsigned long int client_lb, struct GC_finalizer_closure *fclos)
{
  unsigned long int lb = client_lb + sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int lg = lb + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  struct thread_local_freelists *tsd;
  void *result;
  void **tiny_fl;
  void **my_fl;
  void *my_entry;
  void *next;
  void *return_value_GC_core_finalized_malloc_1;
  if(lg >= 25ul)
  {
    return_value_GC_core_finalized_malloc_1=GC_core_finalized_malloc(client_lb, fclos);
    return return_value_GC_core_finalized_malloc_1;
  }

  tsd = (struct thread_local_freelists *)GC_thread_key;
  tiny_fl = tsd->finalized_freelists;
  my_fl = tiny_fl + (signed long int)lg;
  my_entry = *my_fl;
  while(!((unsigned long int)my_entry >= 283ul))
    if(!((unsigned long int)my_entry + 18446744073709551615ul >= 256ul))
    {
      *my_fl = (void *)((char *)my_entry + (signed long int)lg + (signed long int)1);
      void *return_value_GC_core_finalized_malloc_2;
      return_value_GC_core_finalized_malloc_2=GC_core_finalized_malloc(client_lb, fclos);
      return return_value_GC_core_finalized_malloc_2;
    }

    else
    {
      GC_generic_malloc_many(lg * (unsigned long int)16, GC_finalized_kind, my_fl);
      my_entry = *my_fl;
      if(my_entry == NULL)
      {
        void * (*return_value_GC_get_oom_fn_3)(unsigned long int);
        return_value_GC_get_oom_fn_3=GC_get_oom_fn();
        void *return_value;
        return_value=return_value_GC_get_oom_fn_3(lb);
        return return_value;
      }

    }
  next = *((void **)my_entry);
  result = (void *)my_entry;
  *my_fl = next;
  *((void **)result) = NULL;
  *((unsigned long int *)result) = (unsigned long int)fclos | (unsigned long int)1;
  return (void *)((unsigned long int *)result + (signed long int)1);
}

// GC_find_header
// file ./include/private/gc_priv.h line 1895
struct hblkhdr * GC_find_header(char *h)
{
  struct hblkhdr *result;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    result = *_ha;
  }
  while((_Bool)0);
  return result;
}

// GC_find_limit
// file os_dep.c line 998
char * GC_find_limit(char *p, signed int up)
{
  char *return_value_GC_find_limit_with_bound_1;
  return_value_GC_find_limit_with_bound_1=GC_find_limit_with_bound(p, up, up != 0 ? (char *)(unsigned long int)-1 : ((char *)NULL));
  return return_value_GC_find_limit_with_bound_1;
}

// GC_find_limit_with_bound
// file os_dep.c line 956
char * GC_find_limit_with_bound(char *p, signed int up, char *bound)
{
  GC_setup_temporary_fault_handler();
  signed int return_value___sigsetjmp_1;
  return_value___sigsetjmp_1=__sigsetjmp(GC_jmp_buf, 1);
  static char * volatile result;
  if(return_value___sigsetjmp_1 == 0)
  {
    result = (char *)((unsigned long int)p & (unsigned long int)~(256 - 1));
    while((_Bool)1)
    {
      if(!(up == 0))
      {
        result = result + (signed long int)256;
        if((unsigned long int)result >= (unsigned long int)bound)
        {
          result = bound;
          goto __CPROVER_DUMP_L5;
        }

      }

      else
      {
        result = result - (signed long int)256;
        if((unsigned long int)bound >= (unsigned long int)result)
        {
          result = bound - (signed long int)256;
          goto __CPROVER_DUMP_L5;
        }

      }
      GC_noop1((unsigned long int)*result);
    }
  }


__CPROVER_DUMP_L5:
  ;
  GC_reset_fault_handler();
  if(up == 0)
    result = result + (signed long int)256;

  return result;
}

// GC_finish_collection
// file alloc.c line 825
void GC_finish_collection(void)
{
  signed long int start_time = (signed long int)0;
  signed long int finalize_time = (signed long int)0;
  signed long int done_time;
  if(!(GC_print_stats == 0))
    start_time=clock();

  if(GC_bytes_found >= 1l)
    GC_reclaimed_bytes_before_gc = GC_reclaimed_bytes_before_gc + (unsigned long int)GC_bytes_found;

  GC_bytes_found = (signed long int)0;
  char *return_value_getenv_1;
  return_value_getenv_1=getenv("GC_PRINT_ADDRESS_MAP");
  if(!(return_value_getenv_1 == ((char *)NULL)))
    GC_print_address_map();

  if(!((signed long int)GC_dump_regularly == 0l))
    GC_dump();

  else

    __CPROVER_DUMP_L4:
      ;
  if(!(GC_find_leak == 0))
  {
    unsigned long int size;
    unsigned int GC_finish_collection__1__3__kind;
    char *q;
    GC_finish_collection__1__3__kind = (unsigned int)0;
    for( ; !(GC_finish_collection__1__3__kind >= GC_n_kinds); GC_finish_collection__1__3__kind = GC_finish_collection__1__3__kind + 1u)
    {
      size = (unsigned long int)1;
      for( ; !(size >= 129ul); size = size + 1ul)
      {
        q = (char *)GC_obj_kinds[(signed long int)GC_finish_collection__1__3__kind].ok_freelist[(signed long int)size];
        if(!(q == ((char *)NULL)))
          GC_set_fl_marks(q);

      }
    }
    GC_start_reclaim(1);
  }

  GC_finalize();
  if(!(GC_print_stats == 0))
    finalize_time=clock();

  if(!(GC_print_back_height == 0))
    GC_err_printf("Back height not available: Rebuild collector with -DMAKE_BACK_GRAPH\n");

  unsigned long int GC_finish_collection__1__5__size;
  char *GC_finish_collection__1__5__q;
  unsigned int kind = (unsigned int)0;
  for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
  {
    GC_finish_collection__1__5__size = (unsigned long int)1;
    for( ; !(GC_finish_collection__1__5__size >= 129ul); GC_finish_collection__1__5__size = GC_finish_collection__1__5__size + 1ul)
    {
      GC_finish_collection__1__5__q = (char *)GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)GC_finish_collection__1__5__size];
      if(!(GC_finish_collection__1__5__q == ((char *)NULL)))
        GC_clear_fl_marks(GC_finish_collection__1__5__q);

    }
  }
  if(GC_print_stats == 2)
    GC_log_printf("Bytes recovered before sweep - f.l. count = %ld\n", (signed long int)GC_bytes_found);

  GC_start_reclaim(0);
  signed int return_value_GC_compute_heap_usage_percent_2;
  if(!(GC_print_stats == 0))
  {
    return_value_GC_compute_heap_usage_percent_2=GC_compute_heap_usage_percent();
    GC_log_printf("In-use heap: %d%% (%lu KiB pointers + %lu KiB other)\n", return_value_GC_compute_heap_usage_percent_2, (unsigned long int)(GC_arrays._composite_in_use + (unsigned long int)((1 << 9) - 1) >> 10), (unsigned long int)(GC_arrays._atomic_in_use + (unsigned long int)((1 << 9) - 1) >> 10));
  }

  if(!(GC_is_full_gc == 0))
  {
    GC_used_heap_size_after_full = GC_arrays._heapsize - GC_arrays._large_free_bytes;
    GC_need_full_gc = 0;
  }

  else
  {
    unsigned long int return_value_min_bytes_allocd_3;
    return_value_min_bytes_allocd_3=min_bytes_allocd();
    GC_need_full_gc = (signed int)((GC_arrays._heapsize - GC_arrays._large_free_bytes) - GC_used_heap_size_after_full > return_value_min_bytes_allocd_3);
  }
  if(GC_print_stats == 2)
    GC_log_printf("Immediately reclaimed %ld bytes, heapsize: %lu bytes\n", (signed long int)GC_bytes_found, (unsigned long int)GC_arrays._heapsize);

  GC_n_attempts = 0;
  GC_is_full_gc = 0;
  GC_arrays._bytes_allocd_before_gc = GC_arrays._bytes_allocd_before_gc + GC_arrays._bytes_allocd;
  GC_non_gc_bytes_at_gc = GC_non_gc_bytes;
  GC_arrays._bytes_allocd = (unsigned long int)0;
  GC_arrays._bytes_dropped = (unsigned long int)0;
  GC_arrays._bytes_freed = (unsigned long int)0;
  GC_arrays._finalizer_bytes_freed = (unsigned long int)0;
  if(!(GC_print_stats == 0))
  {
    done_time=clock();
    GC_print_finalization_stats();
    GC_log_printf("Finalize plus initiate sweep took %lu + %lu msecs\n", (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(finalize_time - start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(finalize_time - start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000, (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(done_time - finalize_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(done_time - finalize_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000);
  }

}

// GC_free
// file ./include/private/../gc.h line 435
extern void GC_free(void *p)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned long int sz;
  unsigned long int ngranules;
  void **flh;
  signed int knd;
  struct obj_kind *ok;
  if(!(p == NULL))
  {
    h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    hhdr=GC_find_header((char *)h);
    sz = hhdr->hb_sz;
    ngranules = sz >> 4;
    knd = (signed int)hhdr->hb_obj_kind;
    ok = &GC_obj_kinds[(signed long int)knd];
    if(!(ngranules >= 129ul))
    {
      do
        if(!(GC_need_to_lock == 0))
        {
          signed int return_value_pthread_mutex_trylock_1;
          return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
          if(!(return_value_pthread_mutex_trylock_1 == 0))
            GC_lock();

        }

      while((_Bool)0);
      GC_arrays._bytes_freed = GC_arrays._bytes_freed + sz;
      if((-2 & knd) == 2)
        GC_non_gc_bytes = GC_non_gc_bytes - sz;

      if(!(ok->ok_init == 0))
        memset((void *)((unsigned long int *)p + (signed long int)1), 0, (unsigned long int)(sz - sizeof(unsigned long int) /*8ul*/ ));

      flh = &ok->ok_freelist[(signed long int)ngranules];
      *((void **)p) = *flh;
      *flh = (void *)(char *)p;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }

    else
    {
      unsigned long int nblocks = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
      do
        if(!(GC_need_to_lock == 0))
        {
          signed int return_value_pthread_mutex_trylock_2;
          return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(&GC_allocate_ml);
          if(!(return_value_pthread_mutex_trylock_2 == 0))
            GC_lock();

        }

      while((_Bool)0);
      GC_arrays._bytes_freed = GC_arrays._bytes_freed + sz;
      if((-2 & knd) == 2)
        GC_non_gc_bytes = GC_non_gc_bytes - sz;

      if(nblocks >= 2ul)
        GC_arrays._large_allocd_bytes = GC_arrays._large_allocd_bytes - nblocks * (unsigned long int)(1 << 12);

      GC_freehblk(h);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
  }

}

// GC_free_block_ending_at
// file allchblk.c line 323
struct hblk * GC_free_block_ending_at(struct hblk *h)
{
  struct hblk *p = h - (signed long int)1;
  struct hblkhdr *phdr;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)p >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)p >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    phdr = *_ha;
  }
  while((_Bool)0);
  while(!(phdr == ((struct hblkhdr *)NULL)) && !((unsigned long int)phdr >= 4096ul))
  {
    p = (struct hblk *)p - (signed long int)(unsigned long int)phdr;
    phdr=GC_find_header((char *)p);
  }
  if(!(phdr == ((struct hblkhdr *)NULL)))
  {
    if(!((4 & (signed int)phdr->hb_flags) == 0))
      return p;

    return ((struct hblk *)NULL);
  }

  else
  {
    p=GC_prev_block(h - (signed long int)1);
    if(!(p == ((struct hblk *)NULL)))
    {
      phdr=GC_find_header((char *)p);
      if((4 & (signed int)phdr->hb_flags) == 0)
        goto __CPROVER_DUMP_L10;

      if(!((char *)p + (signed long int)phdr->hb_sz == (char *)h))
        goto __CPROVER_DUMP_L10;

      return p;
    }

    else
    {

    __CPROVER_DUMP_L10:
      ;
      return ((struct hblk *)NULL);
    }
  }
}

// GC_free_inner
// file malloc.c line 542
void GC_free_inner(void *p)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned long int sz;
  unsigned long int ngranules;
  void **flh;
  signed int knd;
  struct obj_kind *ok;
  h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  hhdr=GC_find_header((char *)h);
  knd = (signed int)hhdr->hb_obj_kind;
  sz = hhdr->hb_sz;
  ngranules = sz >> 4;
  ok = &GC_obj_kinds[(signed long int)knd];
  if(!(ngranules >= 129ul))
  {
    GC_arrays._bytes_freed = GC_arrays._bytes_freed + sz;
    if((-2 & knd) == 2)
      GC_non_gc_bytes = GC_non_gc_bytes - sz;

    if(!(ok->ok_init == 0))
      memset((void *)((unsigned long int *)p + (signed long int)1), 0, (unsigned long int)(sz - sizeof(unsigned long int) /*8ul*/ ));

    flh = &ok->ok_freelist[(signed long int)ngranules];
    *((void **)p) = *flh;
    *flh = (void *)(char *)p;
  }

  else
  {
    unsigned long int nblocks = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
    GC_arrays._bytes_freed = GC_arrays._bytes_freed + sz;
    if((-2 & knd) == 2)
      GC_non_gc_bytes = GC_non_gc_bytes - sz;

    if(nblocks >= 2ul)
      GC_arrays._large_allocd_bytes = GC_arrays._large_allocd_bytes - nblocks * (unsigned long int)(1 << 12);

    GC_freehblk(h);
  }
}

// GC_freehblk
// file allchblk.c line 825
void GC_freehblk(struct hblk *hbp)
{
  struct hblk *next;
  struct hblk *prev;
  struct hblkhdr *hhdr;
  struct hblkhdr *prevhdr;
  struct hblkhdr *nexthdr;
  unsigned long int size;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)hbp >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)hbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    hhdr = *_ha;
  }
  while((_Bool)0);
  size = (unsigned long int)(1 << 12) * ((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
  if(!((signed long int)size >= 1l))
  {
    GC_on_abort("Deallocating excessively large block.  Too large an allocation?");
    abort();
  }

  GC_remove_counts(hbp, size);
  hhdr->hb_sz = size;
  if(!((4 & (signed int)hhdr->hb_flags) == 0))
  {
    if(!(GC_print_stats == 0))
      GC_log_printf("Duplicate large block deallocation of %p", (void *)hbp);

    GC_on_abort("Duplicate large block deallocation");
    abort();
  }

  hhdr->hb_flags = hhdr->hb_flags | (unsigned char)4;
  next = (struct hblk *)((char *)hbp + (signed long int)size);
  do
  {
    struct hblkhdr **GC_freehblk__1__3___ha;
    do
    {
      struct bi *GC_freehblk__1__3__1__bi;
      do
      {
        unsigned long int GC_freehblk__1__3__1__1__hi = (unsigned long int)next >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *GC_freehblk__1__3__1__1___bi = GC_arrays._top_index[(signed long int)(GC_freehblk__1__3__1__1__hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(GC_freehblk__1__3__1__1___bi->key == GC_freehblk__1__3__1__1__hi); GC_freehblk__1__3__1__1___bi = GC_freehblk__1__3__1__1___bi->hash_link)
          if(GC_freehblk__1__3__1__1___bi == GC_arrays._all_nils)
            break;

        GC_freehblk__1__3__1__bi = GC_freehblk__1__3__1__1___bi;
      }
      while((_Bool)0);
      GC_freehblk__1__3___ha = &GC_freehblk__1__3__1__bi->index[(signed long int)((unsigned long int)next >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    nexthdr = *GC_freehblk__1__3___ha;
  }
  while((_Bool)0);
  prev=GC_free_block_ending_at(hbp);
  if(!(nexthdr == ((struct hblkhdr *)NULL)))
  {
    if(!((4 & (signed int)nexthdr->hb_flags) == 0))
    {
      if((signed long int)hhdr->hb_sz + (signed long int)nexthdr->hb_sz >= 1l)
      {
        GC_remove_from_fl(nexthdr);
        hhdr->hb_sz = hhdr->hb_sz + nexthdr->hb_sz;
        GC_remove_header(next);
      }

    }

  }

  if(!(prev == ((struct hblk *)NULL)))
  {
    prevhdr=GC_find_header((char *)prev);
    if((signed long int)hhdr->hb_sz + (signed long int)prevhdr->hb_sz >= 1l)
    {
      GC_remove_from_fl(prevhdr);
      prevhdr->hb_sz = prevhdr->hb_sz + hhdr->hb_sz;
      GC_remove_header(hbp);
      hbp = prev;
      hhdr = prevhdr;
    }

  }

  GC_arrays._large_free_bytes = GC_arrays._large_free_bytes + size;
  GC_add_to_fl(hbp, hhdr);
}

// GC_gcj_fake_mark_proc
// file gcj_mlc.c line 59
struct GC_ms_entry * GC_gcj_fake_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env)
{
  if(!((signed long int)GC_current_warn_proc == -1l))
  {
    GC_on_abort("No client gcj mark proc is specified");
    abort();
  }

  return mark_stack_ptr;
}

// GC_gcj_malloc
// file thread_local_alloc.c line 240
extern void * GC_gcj_malloc(unsigned long int bytes, void *ptr_to_struct_containing_descr)
{
  if(!((signed long int)GC_incremental == 0l))
  {
    void *return_value_GC_core_gcj_malloc_1;
    return_value_GC_core_gcj_malloc_1=GC_core_gcj_malloc(bytes, ptr_to_struct_containing_descr);
    return return_value_GC_core_gcj_malloc_1;
  }

  else
  {
    unsigned long int granules = bytes + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
    void *result;
    void **tiny_fl = ((struct thread_local_freelists *)GC_thread_key)->gcj_freelists;
    do
    {
      if(granules >= 25ul)
        result=GC_core_gcj_malloc(bytes, ptr_to_struct_containing_descr);

      else
      {
        void **my_fl = tiny_fl + (signed long int)granules;
        void *my_entry = *my_fl;
        void *next;
        while(!((unsigned long int)my_entry >= 283ul))
          if(!((unsigned long int)my_entry + 18446744073709551615ul >= 256ul))
          {
            *my_fl = (void *)((char *)my_entry + (signed long int)granules + (signed long int)1);
            result=GC_core_gcj_malloc(bytes, ptr_to_struct_containing_descr);
            goto out;
          }

          else
          {
            GC_generic_malloc_many(granules == (unsigned long int)0 ? (unsigned long int)16 : granules * (unsigned long int)16, GC_gcj_kind, my_fl);
            my_entry = *my_fl;
            if(my_entry == NULL)
            {
              void * (*return_value_GC_get_oom_fn_2)(unsigned long int);
              return_value_GC_get_oom_fn_2=GC_get_oom_fn();
              result=return_value_GC_get_oom_fn_2(granules * (unsigned long int)16);
            }

          }
        next = *((void **)my_entry);
        result = (void *)my_entry;
        *my_fl = next;
        asm("" :  :  : "memory");
        *((void **)result) = ptr_to_struct_containing_descr;
      }

    out:
      ;
    }
    while((_Bool)0);
    return result;
  }
}

// GC_gcj_malloc_ignore_off_page
// file gcj_mlc.c line 237
extern void * GC_gcj_malloc_ignore_off_page(unsigned long int lb, void *ptr_to_struct_containing_descr)
{
  char *op;
  char **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_gcjobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      maybe_finalize();
      void *return_value_GC_generic_malloc_inner_ignore_off_page_2;
      return_value_GC_generic_malloc_inner_ignore_off_page_2=GC_generic_malloc_inner_ignore_off_page(lb, GC_gcj_kind);
      void *return_value_GC_clear_stack_3;
      return_value_GC_clear_stack_3=GC_clear_stack(return_value_GC_generic_malloc_inner_ignore_off_page_2);
      op = (char *)return_value_GC_clear_stack_3;
      if(op == ((char *)NULL))
      {
        void * (*oom_fn)(unsigned long int) = GC_oom_fn;
        do
          if(!(GC_need_to_lock == 0))
            pthread_mutex_unlock(&GC_allocate_ml);

        while((_Bool)0);
        void *return_value;
        return_value=oom_fn(lb);
        return return_value;
      }

    }

    else
    {
      *opp = (char *)*((void **)op);
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
    }
  }

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_4;
        return_value_pthread_mutex_trylock_4=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_4 == 0))
          GC_lock();

      }

    while((_Bool)0);
    maybe_finalize();
    void *return_value_GC_generic_malloc_inner_ignore_off_page_5;
    return_value_GC_generic_malloc_inner_ignore_off_page_5=GC_generic_malloc_inner_ignore_off_page(lb, GC_gcj_kind);
    void *return_value_GC_clear_stack_6;
    return_value_GC_clear_stack_6=GC_clear_stack(return_value_GC_generic_malloc_inner_ignore_off_page_5);
    op = (char *)return_value_GC_clear_stack_6;
    if(op == ((char *)NULL))
    {
      void * (*GC_gcj_malloc_ignore_off_page__1__2__2__oom_fn)(unsigned long int) = GC_oom_fn;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_1;
      return_value_1=GC_gcj_malloc_ignore_off_page__1__2__2__oom_fn(lb);
      return return_value_1;
    }

  }
  *((void **)op) = ptr_to_struct_containing_descr;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return (void *)op;
}

// GC_gcollect
// file alloc.c line 1006
extern void GC_gcollect(void)
{
  GC_try_to_collect_general(((signed int (*)(void))NULL), 0);
  if(!(GC_have_errors == 0))
    GC_print_all_errors();

}

// GC_gcollect_and_unmap
// file alloc.c line 1014
extern void GC_gcollect_and_unmap(void)
{
  GC_try_to_collect_general(GC_never_stop_func, 1);
}

// GC_general_register_disappearing_link
// file finalize.c line 211
extern signed int GC_general_register_disappearing_link(void **link, const void *obj)
{
  if(link == ((void **)NULL) || !((7ul & (unsigned long int)link) == 0ul))
  {
    GC_on_abort("Bad arg to GC_general_register_disappearing_link");
    abort();
  }

  signed int return_value_GC_register_disappearing_link_inner_1;
  return_value_GC_register_disappearing_link_inner_1=GC_register_disappearing_link_inner(&GC_dl_hashtbl, link, obj);
  return return_value_GC_register_disappearing_link_inner_1;
}

// GC_generic_lock
// file pthread_support.c line 1826
void GC_generic_lock(union anonymous *lock)
{
  unsigned int pause_length = (unsigned int)1;
  unsigned int i;
  signed int return_value_pthread_mutex_trylock_1;
  return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(lock);
  if(!(return_value_pthread_mutex_trylock_1 == 0))
  {
    for( ; !(pause_length >= 129u); pause_length = pause_length << 1)
    {
      i = (unsigned int)0;
      for( ; !(i >= pause_length); i = i + 1u)
        GC_pause();
      signed int return_value_pthread_mutex_trylock_2;
      return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(lock);
      switch(return_value_pthread_mutex_trylock_2)
      {
        case 0:
          goto __CPROVER_DUMP_L10;
        case 16:
          break;
        default:
          GC_on_abort("Unexpected error from pthread_mutex_trylock");
      }
      abort();
    }
    pthread_mutex_lock(lock);
  }


__CPROVER_DUMP_L10:
  ;
}

// GC_generic_malloc
// file malloc.c line 171
extern void * GC_generic_malloc(unsigned long int lb, signed int k)
{
  void *result;
  if(!((signed long int)GC_have_errors == 0l))
    GC_print_all_errors();

  GC_notify_or_invoke_finalizers();
  void * (*return_value_GC_get_oom_fn_2)(unsigned long int);
  void *return_value;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    result=GC_generic_malloc_inner((unsigned long int)lb, k);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  else
  {
    unsigned long int lg;
    unsigned long int lb_rounded;
    unsigned long int n_blocks;
    signed int init;
    lg = lb + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
    lb_rounded = lg << 4;
    if(!(lb_rounded >= lb))
    {
      return_value_GC_get_oom_fn_2=GC_get_oom_fn();
      return_value=return_value_GC_get_oom_fn_2(lb);
      return return_value;
    }

    n_blocks = (lb_rounded + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
    init = GC_obj_kinds[(signed long int)k].ok_init;
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_3;
        return_value_pthread_mutex_trylock_3=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_3 == 0))
          GC_lock();

      }

    while((_Bool)0);
    char *return_value_GC_alloc_large_4;
    return_value_GC_alloc_large_4=GC_alloc_large(lb_rounded, k, (unsigned int)0);
    result = (void *)(char *)return_value_GC_alloc_large_4;
    if(!(result == NULL))
    {
      if(!(GC_debugging_started == 0))
        memset(result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

      else
      {
        ((unsigned long int *)result)[(signed long int)0] = (unsigned long int)0;
        ((unsigned long int *)result)[(signed long int)1] = (unsigned long int)0;
        ((unsigned long int *)result)[(signed long int)((lg << 1) - (unsigned long int)1)] = (unsigned long int)0;
        ((unsigned long int *)result)[(signed long int)((lg << 1) - (unsigned long int)2)] = (unsigned long int)0;
      }
    }

    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + lb_rounded;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(GC_debugging_started == 0 && !(result == NULL) && !(init == 0))
      memset(result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

  }
  if(result == NULL)
  {
    void * (*return_value_GC_get_oom_fn_5)(unsigned long int);
    return_value_GC_get_oom_fn_5=GC_get_oom_fn();
    void *return_value_1;
    return_value_1=return_value_GC_get_oom_fn_5(lb);
    return return_value_1;
  }

  else
    return result;
}

// GC_generic_malloc_ignore_off_page
// file mallocx.c line 170
extern void * GC_generic_malloc_ignore_off_page(unsigned long int lb, signed int k)
{
  void *result;
  unsigned long int lg;
  unsigned long int lb_rounded;
  unsigned long int n_blocks;
  signed int init;
  void *return_value_GC_generic_malloc_1;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    return_value_GC_generic_malloc_1=GC_generic_malloc((unsigned long int)lb, k);
    return return_value_GC_generic_malloc_1;
  }

  lg = lb + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  lb_rounded = lg << 4;
  void * (*return_value_GC_get_oom_fn_2)(unsigned long int);
  void *return_value;
  if(!(lb_rounded >= lb))
  {
    return_value_GC_get_oom_fn_2=GC_get_oom_fn();
    return_value=return_value_GC_get_oom_fn_2(lb);
    return return_value;
  }

  n_blocks = (lb_rounded + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
  init = GC_obj_kinds[(signed long int)k].ok_init;
  if(!((signed long int)GC_have_errors == 0l))
    GC_print_all_errors();

  GC_notify_or_invoke_finalizers();
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_3;
      return_value_pthread_mutex_trylock_3=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_3 == 0))
        GC_lock();

    }

  while((_Bool)0);
  char *return_value_GC_alloc_large_4;
  return_value_GC_alloc_large_4=GC_alloc_large(lb + (unsigned long int)GC_all_interior_pointers, k, (unsigned int)1);
  result = (void *)(char *)return_value_GC_alloc_large_4;
  if(!(result == NULL))
  {
    if(!(GC_debugging_started == 0))
      memset(result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

    else
    {
      ((unsigned long int *)result)[(signed long int)0] = (unsigned long int)0;
      ((unsigned long int *)result)[(signed long int)1] = (unsigned long int)0;
      ((unsigned long int *)result)[(signed long int)((lg << 1) - (unsigned long int)1)] = (unsigned long int)0;
      ((unsigned long int *)result)[(signed long int)((lg << 1) - (unsigned long int)2)] = (unsigned long int)0;
    }
  }

  GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + lb_rounded;
  if(result == NULL)
  {
    void * (*oom_fn)(unsigned long int) = GC_oom_fn;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    void *return_value_1;
    return_value_1=oom_fn(lb);
    return return_value_1;
  }

  else
  {
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(GC_debugging_started == 0 && !(init == 0))
      memset(result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

    return result;
  }
}

// GC_generic_malloc_inner
// file ./include/private/gc_priv.h line 1828
void * GC_generic_malloc_inner(unsigned long int lb, signed int k)
{
  void *op;
  signed int return_value_GC_alloc_reclaim_list_1;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    struct obj_kind *kind = GC_obj_kinds + (signed long int)k;
    unsigned long int lg = GC_arrays._size_map[(signed long int)lb];
    void **opp = &kind->ok_freelist[(signed long int)lg];
    op = *opp;
    if(op == NULL)
    {
      if(lg == 0ul)
      {
        if((signed long int)GC_is_initialized == 0l)
        {
          GC_init();
          lg = GC_arrays._size_map[(signed long int)lb];
        }

        if(lg == 0ul)
        {
          GC_extend_size_map(lb);
          lg = GC_arrays._size_map[(signed long int)lb];
        }

        opp = &kind->ok_freelist[(signed long int)lg];
        op = *opp;
      }

      if(op == NULL)
      {
        if(kind->ok_reclaim_list == ((struct hblk **)NULL))
        {
          return_value_GC_alloc_reclaim_list_1=GC_alloc_reclaim_list(kind);
          if(return_value_GC_alloc_reclaim_list_1 == 0)
            return (void *)0;

        }

        char *return_value_GC_allocobj_2;
        return_value_GC_allocobj_2=GC_allocobj(lg, k);
        op = (void *)return_value_GC_allocobj_2;
        if(op == NULL)
          return (void *)0;

      }

    }

    *opp = *((void **)op);
    *((void **)op) = NULL;
    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
  }

  else
  {
    char *return_value_GC_alloc_large_and_clear_3;
    return_value_GC_alloc_large_and_clear_3=GC_alloc_large_and_clear(lb + (unsigned long int)GC_all_interior_pointers, k, (unsigned int)0);
    op = (void *)(char *)return_value_GC_alloc_large_and_clear_3;
    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + lb;
  }
  return op;
}

// GC_generic_malloc_inner_ignore_off_page
// file ./include/private/gc_priv.h line 1831
void * GC_generic_malloc_inner_ignore_off_page(unsigned long int lb, signed int k)
{
  unsigned long int lb_adjusted;
  void *op;
  void *return_value_GC_generic_malloc_inner_1;
  if(!(lb >= 4097ul))
  {
    return_value_GC_generic_malloc_inner_1=GC_generic_malloc_inner(lb, k);
    return return_value_GC_generic_malloc_inner_1;
  }

  lb_adjusted = lb + (unsigned long int)GC_all_interior_pointers;
  char *return_value_GC_alloc_large_and_clear_2;
  return_value_GC_alloc_large_and_clear_2=GC_alloc_large_and_clear(lb_adjusted, k, (unsigned int)1);
  op = (void *)return_value_GC_alloc_large_and_clear_2;
  GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + lb_adjusted;
  return op;
}

// GC_generic_malloc_many
// file mallocx.c line 272
extern void GC_generic_malloc_many(unsigned long int lb, signed int k, void **result)
{
  void *op;
  void *p;
  void **opp;
  unsigned long int lw;
  unsigned long int lg;
  signed long int my_bytes_allocd = (signed long int)0;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)k];
  struct hblk **rlh;
  struct hblkhdr *return_value_GC_find_header_5;
  if(!(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb) && lb >= 2048ul)
  {
    op=GC_generic_malloc(lb, k);
    if(!(op == NULL))
      *((void **)op) = NULL;

    *result = op;
  }

  else
  {
    lw = lb >> 3;
    lg = lb >> 4;
    if(!((signed long int)GC_have_errors == 0l))
      GC_print_all_errors();

    GC_notify_or_invoke_finalizers();
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    if((signed long int)GC_is_initialized == 0l)
      GC_init();

    if(GC_dont_gc == 0 && !(GC_incremental == 0))
    {
      GC_collecting = 1;
      GC_collect_a_little_inner(1);
      GC_collecting = 0;
    }

    rlh = ok->ok_reclaim_list;
    if(!(rlh == ((struct hblk **)NULL)))
    {
      struct hblk *hbp;
      struct hblkhdr *hhdr;
      rlh = rlh + (signed long int)lg;
      do
      {
        hbp = *rlh;
        if(hbp == ((struct hblk *)NULL))
          break;

        hhdr=GC_find_header((char *)hbp);
        *rlh = hhdr->hb_next;
        hhdr->hb_last_reclaimed = (unsigned short int)GC_gc_no;
        if(!(GC_parallel == 0))
        {
          signed long int my_bytes_allocd_tmp;
          unsigned long int return_value_AO_load_2;
          return_value_AO_load_2=AO_load(&GC_bytes_allocd_tmp);
          my_bytes_allocd_tmp = (signed long int)return_value_AO_load_2;
          if(!(my_bytes_allocd_tmp == 0l))
          {
            AO_fetch_and_add(&GC_bytes_allocd_tmp, (unsigned long int)-my_bytes_allocd_tmp);
            GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (unsigned long int)my_bytes_allocd_tmp;
          }

          GC_acquire_mark_lock();
          GC_fl_builder_count = GC_fl_builder_count + 1ul;
          do
            if(!(GC_need_to_lock == 0))
              pthread_mutex_unlock(&GC_allocate_ml);

          while((_Bool)0);
          GC_release_mark_lock();
        }

        char *return_value_GC_reclaim_generic_3;
        return_value_GC_reclaim_generic_3=GC_reclaim_generic(hbp, hhdr, lb, ok->ok_init, ((char *)NULL), &my_bytes_allocd);
        op = (void *)return_value_GC_reclaim_generic_3;
        if(!(op == NULL))
        {
          GC_bytes_found = GC_bytes_found + my_bytes_allocd;
          if(!(GC_parallel == 0))
          {
            *result = op;
            AO_fetch_and_add(&GC_bytes_allocd_tmp, (unsigned long int)my_bytes_allocd);
            GC_acquire_mark_lock();
            GC_fl_builder_count = GC_fl_builder_count - 1ul;
            if(GC_fl_builder_count == 0ul)
              GC_notify_all_builder();

            GC_release_mark_lock();
            GC_clear_stack(NULL);
            goto __CPROVER_DUMP_L37;
          }

          GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (unsigned long int)my_bytes_allocd;
          goto out;
        }

        if(!(GC_parallel == 0))
        {
          GC_acquire_mark_lock();
          GC_fl_builder_count = GC_fl_builder_count - 1ul;
          if(GC_fl_builder_count == 0ul)
            GC_notify_all_builder();

          GC_release_mark_lock();
          do
            if(!(GC_need_to_lock == 0))
            {
              signed int return_value_pthread_mutex_trylock_4;
              return_value_pthread_mutex_trylock_4=pthread_mutex_trylock(&GC_allocate_ml);
              if(!(return_value_pthread_mutex_trylock_4 == 0))
                GC_lock();

            }

          while((_Bool)0);
        }

      }
      while((_Bool)1);
    }

    opp = &GC_obj_kinds[(signed long int)k].ok_freelist[(signed long int)lg];
    op = *opp;
    if(!(op == NULL))
    {
      *opp = NULL;
      my_bytes_allocd = (signed long int)0;
      p = op;
      for( ; !(p == NULL); p = *((void **)p))
      {
        my_bytes_allocd = my_bytes_allocd + (signed long int)lb;
        if((unsigned long int)my_bytes_allocd >= 4096ul)
        {
          *opp = *((void **)p);
          *((void **)p) = NULL;
          break;
        }

      }
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (unsigned long int)my_bytes_allocd;
    }

    else
    {
      struct hblk *h;
      h=GC_allochblk(lb, k, (unsigned int)0);
      if(!(h == ((struct hblk *)NULL)))
      {
        if((-2 & k) == 2)
        {
          return_value_GC_find_header_5=GC_find_header((char *)h);
          GC_set_hdr_marks(return_value_GC_find_header_5);
        }

        GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + ((unsigned long int)(1 << 12) - (unsigned long int)(1 << 12) % lb);
        if(!(GC_parallel == 0))
        {
          GC_acquire_mark_lock();
          GC_fl_builder_count = GC_fl_builder_count + 1ul;
          do
            if(!(GC_need_to_lock == 0))
              pthread_mutex_unlock(&GC_allocate_ml);

          while((_Bool)0);
          GC_release_mark_lock();
          char *return_value_GC_build_fl_6;
          return_value_GC_build_fl_6=GC_build_fl(h, lw, (signed int)(ok->ok_init != 0 ? (_Bool)1 : (GC_debugging_started != 0 ? (_Bool)1 : (_Bool)0)), ((char *)NULL));
          op = (void *)return_value_GC_build_fl_6;
          *result = op;
          GC_acquire_mark_lock();
          GC_fl_builder_count = GC_fl_builder_count - 1ul;
          if(GC_fl_builder_count == 0ul)
            GC_notify_all_builder();

          GC_release_mark_lock();
          GC_clear_stack(NULL);
          goto __CPROVER_DUMP_L37;
        }

        char *return_value_GC_build_fl_7;
        return_value_GC_build_fl_7=GC_build_fl(h, lw, (signed int)(ok->ok_init != 0 ? (_Bool)1 : (GC_debugging_started != 0 ? (_Bool)1 : (_Bool)0)), ((char *)NULL));
        op = (void *)return_value_GC_build_fl_7;
        goto out;
      }

      op=GC_generic_malloc_inner(lb, k);
      if(!(op == NULL))
        *((void **)op) = NULL;

    }

  out:
    ;
    *result = op;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    GC_clear_stack(NULL);
  }

__CPROVER_DUMP_L37:
  ;
}

// GC_generic_or_special_malloc
// file mallocx.c line 50
void * GC_generic_or_special_malloc(unsigned long int lb, signed int knd)
{
  void *return_value_GC_malloc_atomic_1;
  void *return_value_GC_malloc_2;
  void *return_value_GC_malloc_uncollectable_3;
  void *return_value_GC_malloc_atomic_uncollectable_4;
  void *return_value_GC_generic_malloc_5;
  switch(knd)
  {
    case 0:
    {
      return_value_GC_malloc_atomic_1=GC_malloc_atomic((unsigned long int)lb);
      return return_value_GC_malloc_atomic_1;
    }
    case 1:
    {
      return_value_GC_malloc_2=GC_malloc((unsigned long int)lb);
      return return_value_GC_malloc_2;
    }
    case 2:
    {
      return_value_GC_malloc_uncollectable_3=GC_malloc_uncollectable((unsigned long int)lb);
      return return_value_GC_malloc_uncollectable_3;
    }
    case 3:
    {
      return_value_GC_malloc_atomic_uncollectable_4=GC_malloc_atomic_uncollectable((unsigned long int)lb);
      return return_value_GC_malloc_atomic_uncollectable_4;
    }
    default:
    {
      return_value_GC_generic_malloc_5=GC_generic_malloc(lb, knd);
      return return_value_GC_generic_malloc_5;
    }
  }
}

// GC_get_abort_func
// file misc.c line 1704
extern void (*GC_get_abort_func(void))(const char *)
{
  void (*fn)(const char *);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_on_abort;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_all_interior_pointers
// file misc.c line 2078
extern signed int GC_get_all_interior_pointers(void)
{
  return GC_all_interior_pointers;
}

// GC_get_bytes_since_gc
// file misc.c line 503
extern unsigned long int GC_get_bytes_since_gc(void)
{
  return (unsigned long int)GC_arrays._bytes_allocd;
}

// GC_get_dont_expand
// file misc.c line 2114
extern signed int GC_get_dont_expand(void)
{
  return GC_dont_expand;
}

// GC_get_dont_precollect
// file misc.c line 2170
extern signed int GC_get_dont_precollect(void)
{
  return GC_dont_precollect;
}

// GC_get_file_len
// file os_dep.c line 164
unsigned long int GC_get_file_len(signed int f)
{
  unsigned long int total = (unsigned long int)0;
  signed long int result;
  char buf[500l];
  do
  {
    result=read(f, (void *)buf, (unsigned long int)500);
    if(result == -1l)
      return (unsigned long int)0;

    total = total + (unsigned long int)result;
  }
  while(result >= 1l);
  return total;
}

// GC_get_finalize_on_demand
// file misc.c line 2090
extern signed int GC_get_finalize_on_demand(void)
{
  return GC_finalize_on_demand;
}

// GC_get_finalizer_notifier
// file misc.c line 2033
extern void (*GC_get_finalizer_notifier(void))(void)
{
  void (*fn)(void);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_finalizer_notifier;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_find_leak
// file misc.c line 2056
extern signed int GC_get_find_leak(void)
{
  return GC_find_leak;
}

// GC_get_first_part
// file allchblk.c line 489
struct hblk * GC_get_first_part(struct hblk *h, struct hblkhdr *hhdr, unsigned long int bytes, signed int index)
{
  unsigned long int total_size = hhdr->hb_sz;
  struct hblk *rest;
  struct hblkhdr *rest_hdr;
  GC_remove_from_fl_at(hhdr, index);
  if(total_size == bytes)
    return h;

  else
  {
    rest = (struct hblk *)((unsigned long int)h + bytes);
    rest_hdr=GC_install_header(rest);
    if(rest_hdr == ((struct hblkhdr *)NULL))
    {
      GC_current_warn_proc("GC Warning: Header allocation failed: Dropping block.\n", (unsigned long int)0);
      return ((struct hblk *)NULL);
    }

    else
    {
      rest_hdr->hb_sz = total_size - bytes;
      rest_hdr->hb_flags = (unsigned char)0;
      GC_add_to_fl(rest, rest_hdr);
      return h;
    }
  }
}

// GC_get_force_unmap_on_gcollect
// file misc.c line 2202
extern signed int GC_get_force_unmap_on_gcollect(void)
{
  return (signed int)GC_force_unmap_on_gcollect;
}

// GC_get_free_bytes
// file misc.c line 492
extern unsigned long int GC_get_free_bytes(void)
{
  return (unsigned long int)(GC_arrays._large_free_bytes - (unsigned long int)0);
}

// GC_get_free_space_divisor
// file misc.c line 2147
extern unsigned long int GC_get_free_space_divisor(void)
{
  return GC_free_space_divisor;
}

// GC_get_full_freq
// file misc.c line 2181
extern signed int GC_get_full_freq(void)
{
  return GC_full_freq;
}

// GC_get_gc_no
// file misc.c line 1969
extern unsigned long int GC_get_gc_no(void)
{
  return GC_gc_no;
}

// GC_get_heap_size
// file ./include/gc.h line 589
extern unsigned long int GC_get_heap_size(void)
{
  return (unsigned long int)(GC_arrays._heapsize - (unsigned long int)0);
}

// GC_get_heap_usage_safe
// file misc.c line 518
extern void GC_get_heap_usage_safe(unsigned long int *pheap_size, unsigned long int *pfree_bytes, unsigned long int *punmapped_bytes, unsigned long int *pbytes_since_gc, unsigned long int *ptotal_bytes)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(!(pheap_size == ((unsigned long int *)NULL)))
    *pheap_size = GC_arrays._heapsize - (unsigned long int)0;

  if(!(pfree_bytes == ((unsigned long int *)NULL)))
    *pfree_bytes = GC_arrays._large_free_bytes - (unsigned long int)0;

  if(!(punmapped_bytes == ((unsigned long int *)NULL)))
    *punmapped_bytes = (unsigned long int)0;

  if(!(pbytes_since_gc == ((unsigned long int *)NULL)))
    *pbytes_since_gc = GC_arrays._bytes_allocd;

  if(!(ptotal_bytes == ((unsigned long int *)NULL)))
    *ptotal_bytes = GC_arrays._bytes_allocd + GC_arrays._bytes_allocd_before_gc;

  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_get_java_finalization
// file misc.c line 2102
extern signed int GC_get_java_finalization(void)
{
  return GC_java_finalization;
}

// GC_get_main_stack_base
// file ./include/private/gc_priv.h line 1672
char * GC_get_main_stack_base(void)
{
  char *result;
  union pthread_attr_t attr;
  void *stackaddr;
  unsigned long int size;
  unsigned long int return_value_pthread_self_2;
  return_value_pthread_self_2=pthread_self();
  signed int return_value_pthread_getattr_np_3;
  return_value_pthread_getattr_np_3=pthread_getattr_np(return_value_pthread_self_2, &attr);
  if(return_value_pthread_getattr_np_3 == 0)
  {
    signed int return_value_pthread_attr_getstack_1;
    return_value_pthread_attr_getstack_1=pthread_attr_getstack(&attr, &stackaddr, &size);
    if(return_value_pthread_attr_getstack_1 == 0)
    {
      if(!(stackaddr == NULL))
      {
        pthread_attr_destroy(&attr);
        stackaddr = (void *)((char *)stackaddr + (signed long int)size);
        return (char *)stackaddr;
      }

    }

    pthread_attr_destroy(&attr);
  }

  GC_current_warn_proc("GC Warning: pthread_getattr_np or pthread_attr_getstack failed for main thread\n", (unsigned long int)0);
  result=GC_linux_main_stack_base();
  if(result == ((char *)NULL))
    result = (char *)(signed long int)-sizeof(char *) /*8ul*/ ;

  return result;
}

// GC_get_maps
// file os_dep.c line 194
char * GC_get_maps(void)
{
  signed int f;
  signed long int result;
  unsigned long int maps_size;
  unsigned long int old_maps_size = (unsigned long int)0;
  maps_size=GC_get_maps_len();
  if(maps_size == 0ul)
    return ((char *)NULL);

  else
  {

  __CPROVER_DUMP_L1:
    ;
    static char *maps_buf = (char *)(void *)0;
    while((_Bool)1)
    {
      static unsigned long int maps_buf_sz = (unsigned long int)1;
      if(maps_size >= maps_buf_sz)
      {
        for( ; maps_size >= maps_buf_sz; maps_buf_sz = maps_buf_sz * (unsigned long int)2)
          ;
        maps_buf=GC_scratch_alloc(maps_buf_sz);
        maps_size=GC_get_maps_len();
        if(maps_size == 0ul)
          return ((char *)NULL);

        if(maps_buf == ((char *)NULL))
          return ((char *)NULL);

        goto __CPROVER_DUMP_L1;
      }

      f=open("/proc/self/maps", 00);
      if(f == -1)
        return ((char *)NULL);

      old_maps_size = maps_size;
      maps_size = (unsigned long int)0;
      do
      {
        result=GC_repeat_read(f, maps_buf, maps_buf_sz - (unsigned long int)1);
        if(!(result >= 1l))
          break;

        maps_size = maps_size + (unsigned long int)result;
      }
      while((unsigned long int)result == maps_buf_sz + 18446744073709551615ul);
      close(f);
      if(!(result >= 1l))
        return ((char *)NULL);

      if(!(old_maps_size >= maps_size))
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("Unexpected asynchronous /proc/self/maps growth (unregistered thread?) from %lu to %lu", (unsigned long int)old_maps_size, (unsigned long int)maps_size);

        GC_on_abort("Unexpected asynchronous /proc/self/maps growth (unregistered thread?)");
        abort();
      }

      if(!(maps_size >= maps_buf_sz) && maps_size >= old_maps_size)
        break;

    }
    maps_buf[(signed long int)maps_size] = (char)0;
    return maps_buf;
  }
}

// GC_get_maps_len
// file os_dep.c line 179
unsigned long int GC_get_maps_len(void)
{
  signed int f;
  f=open("/proc/self/maps", 00);
  unsigned long int result;
  if(!(f >= 0))
    return (unsigned long int)0;

  else
  {
    result=GC_get_file_len(f);
    close(f);
    return result;
  }
}

// GC_get_max_retries
// file misc.c line 2158
extern unsigned long int GC_get_max_retries(void)
{
  return GC_max_retries;
}

// GC_get_no_dls
// file misc.c line 2126
extern signed int GC_get_no_dls(void)
{
  return GC_no_dls;
}

// GC_get_non_gc_bytes
// file misc.c line 2136
extern unsigned long int GC_get_non_gc_bytes(void)
{
  return GC_non_gc_bytes;
}

// GC_get_nprocs
// file pthread_support.c line 804
signed int GC_get_nprocs(void)
{
  char stat_buf[4096l];
  signed int f;
  signed int result;
  signed int i;
  signed int len;
  f=open("/proc/stat", 00);
  if(!(f >= 0))
  {
    GC_current_warn_proc("GC Warning: Couldn't read /proc/stat\n", (unsigned long int)0);
    return 1;
  }

  else
  {
    signed long int return_value_read_1;
    return_value_read_1=read(f, (void *)stat_buf, (unsigned long int)4096);
    len = (signed int)return_value_read_1;
    close(f);
    result = 1;
    i = 0;
    for( ; !(i >= len + -100); i = i + 1)
      if((signed int)stat_buf[(signed long int)i] == 10)
      {
        if((signed int)stat_buf[(signed long int)(1 + i)] == 99)
        {
          if((signed int)stat_buf[(signed long int)(2 + i)] == 112)
          {
            if((signed int)stat_buf[(signed long int)(3 + i)] == 117)
            {
              signed int cpu_no;
              cpu_no=atoi_link1(&stat_buf[(signed long int)(i + 4)]);
              if(cpu_no >= result)
                result = cpu_no + 1;

            }

          }

        }

      }

    return result;
  }
}

// GC_get_on_heap_resize
// file misc.c line 2014
extern void (*GC_get_on_heap_resize(void))(unsigned long int)
{
  void (*fn)(unsigned long int);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_on_heap_resize;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_oom_fn
// file ./include/private/../gc.h line 120
extern void * (*GC_get_oom_fn(void))(unsigned long int)
{
  void * (*fn)(unsigned long int);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_oom_fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_pages_executable
// file os_dep.c line 4446
extern signed int GC_get_pages_executable(void)
{
  return (signed int)GC_pages_executable;
}

// GC_get_parallel
// file misc.c line 1975
extern signed int GC_get_parallel(void)
{
  return GC_parallel;
}

// GC_get_prof_stats
// file misc.c line 562
extern unsigned long int GC_get_prof_stats(struct GC_prof_stats_s *pstats, unsigned long int stats_sz)
{
  struct GC_prof_stats_s stats;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fill_prof_stats(stats_sz >= sizeof(struct GC_prof_stats_s) /*80ul*/  ? pstats : &stats);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if(stats_sz == sizeof(struct GC_prof_stats_s) /*80ul*/ )
    return sizeof(struct GC_prof_stats_s) /*80ul*/ ;

  else
    if(stats_sz >= 81ul)
    {
      memset((void *)((char *)pstats + (signed long int)sizeof(struct GC_prof_stats_s) /*80ul*/ ), 0xff, stats_sz - sizeof(struct GC_prof_stats_s) /*80ul*/ );
      return sizeof(struct GC_prof_stats_s) /*80ul*/ ;
    }

    else
    {
      memcpy((void *)pstats, (const void *)&stats, (unsigned long int)stats_sz);
      return stats_sz;
    }
}

// GC_get_prof_stats_unsafe
// file misc.c line 586
extern unsigned long int GC_get_prof_stats_unsafe(struct GC_prof_stats_s *pstats, unsigned long int stats_sz)
{
  struct GC_prof_stats_s stats;
  if(stats_sz >= sizeof(struct GC_prof_stats_s) /*80ul*/ )
  {
    fill_prof_stats(pstats);
    if(stats_sz >= 81ul)
      memset((void *)((char *)pstats + (signed long int)sizeof(struct GC_prof_stats_s) /*80ul*/ ), 0xff, stats_sz - sizeof(struct GC_prof_stats_s) /*80ul*/ );

    return sizeof(struct GC_prof_stats_s) /*80ul*/ ;
  }

  else
  {
    fill_prof_stats(&stats);
    memcpy((void *)pstats, (const void *)&stats, (unsigned long int)stats_sz);
    return stats_sz;
  }
}

// GC_get_push_other_roots
// file os_dep.c line 2615
extern void (*GC_get_push_other_roots(void))(void)
{
  return GC_push_other_roots;
}

// GC_get_stack_base
// file os_dep.c line 1273
extern signed int GC_get_stack_base(struct GC_stack_base *b)
{
  union pthread_attr_t attr;
  unsigned long int size;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  signed int return_value_pthread_getattr_np_2;
  return_value_pthread_getattr_np_2=pthread_getattr_np(return_value_pthread_self_1, &attr);
  if(!(return_value_pthread_getattr_np_2 == 0))
  {
    GC_current_warn_proc("GC Warning: pthread_getattr_np failed\n", (unsigned long int)0);
    return 3;
  }

  else
  {
    signed int return_value_pthread_attr_getstack_3;
    return_value_pthread_attr_getstack_3=pthread_attr_getstack(&attr, &b->mem_base, &size);
    if(!(return_value_pthread_attr_getstack_3 == 0))
    {
      GC_on_abort("pthread_attr_getstack failed");
      abort();
    }

    pthread_attr_destroy(&attr);
    b->mem_base = (void *)((char *)b->mem_base + (signed long int)size);
    return 0;
  }
}

// GC_get_start_callback
// file alloc.c line 324
extern void (*GC_get_start_callback(void))(void)
{
  void (*fn)(void);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_start_call_back;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_stop_func
// file alloc.c line 158
extern signed int (*GC_get_stop_func(void))(void)
{
  signed int (*stop_func)(void);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  stop_func = GC_default_stop_func;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return stop_func;
}

// GC_get_suspend_signal
// file ./include/private/../gc.h line 1259
extern signed int GC_get_suspend_signal(void)
{
  return GC_sig_suspend != -1 ? GC_sig_suspend : 30;
}

// GC_get_thr_restart_signal
// file pthread_stop_world.c line 172
extern signed int GC_get_thr_restart_signal(void)
{
  return GC_sig_thr_restart != -1 ? GC_sig_thr_restart : 24;
}

// GC_get_time_limit
// file misc.c line 2192
extern unsigned long int GC_get_time_limit(void)
{
  return GC_time_limit;
}

// GC_get_total_bytes
// file misc.c line 508
extern unsigned long int GC_get_total_bytes(void)
{
  return (unsigned long int)(GC_arrays._bytes_allocd + GC_arrays._bytes_allocd_before_gc);
}

// GC_get_unmapped_bytes
// file misc.c line 498
extern unsigned long int GC_get_unmapped_bytes(void)
{
  return (unsigned long int)0;
}

// GC_get_version
// file alloc.c line 105
extern unsigned int GC_get_version(void)
{
  return (unsigned int)(7 << 16 | 4 << 8 | 2);
}

// GC_get_warn_proc
// file misc.c line 1624
extern void (*GC_get_warn_proc(void))(char *, unsigned long int)
{
  void (*result)(char *, unsigned long int);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result = GC_current_warn_proc;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_grow_table
// file finalize.c line 100
void GC_grow_table(struct hash_chain_entry ***table, signed long int *log_size_ptr)
{
  unsigned long int i;
  struct hash_chain_entry *p;
  signed long int log_old_size = *log_size_ptr;
  signed long int log_new_size = log_old_size + (signed long int)1;
  unsigned long int old_size = (unsigned long int)(log_old_size == (signed long int)-1 ? 0 : 1 << log_old_size);
  unsigned long int new_size = (unsigned long int)1 << log_new_size;
  struct hash_chain_entry **new_table;
  void *return_value_GC_generic_malloc_inner_ignore_off_page_1;
  return_value_GC_generic_malloc_inner_ignore_off_page_1=GC_generic_malloc_inner_ignore_off_page((unsigned long int)new_size * sizeof(struct hash_chain_entry *) /*8ul*/ , 1);
  new_table = (struct hash_chain_entry **)return_value_GC_generic_malloc_inner_ignore_off_page_1;
  if(new_table == ((struct hash_chain_entry **)NULL))
  {
    if(*table == ((struct hash_chain_entry **)NULL))
    {
      GC_on_abort("Insufficient space for initial table allocation");
      abort();
    }

  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= old_size); i = i + 1ul)
    {
      p = (*table)[(signed long int)i];
      while(!(p == ((struct hash_chain_entry *)NULL)))
      {
        char *real_key = (char *)(void *)~((unsigned long int)p->hidden_key);
        struct hash_chain_entry *next = p->next;
        unsigned long int new_hash = ((unsigned long int)real_key >> 3 ^ (unsigned long int)real_key >> (signed long int)3 + log_new_size) & new_size - (unsigned long int)1;
        p->next = new_table[(signed long int)new_hash];
        new_table[(signed long int)new_hash] = p;
        p = next;
      }
    }
    *log_size_ptr = log_new_size;
    *table = new_table;
  }
}

// GC_has_other_debug_info
// file dbg_mlc.c line 36
signed int GC_has_other_debug_info(char *p)
{
  char *body = (char *)((struct anonymous_16 *)p + (signed long int)1);
  unsigned long int sz;
  sz=GC_size((const void *)p);
  if(!((struct hblk *)(18446744073709547520ul & (unsigned long int)p) == (struct hblk *)(18446744073709547520ul & (unsigned long int)body)) || !(sz >= sizeof(unsigned long int) * 5 /*40ul*/ ))
    return 0;

  else
    if(!(((struct anonymous_16 *)p)->oh_sf == (0xFEDCEDCBfedcedcbUL ^ (unsigned long int)body)))
    {
      if(((unsigned long int *)p)[-1l + (signed long int)(sz >> 3)] == (0xBCDECDEFbcdecdefUL ^ (unsigned long int)body))
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(((struct anonymous_16 *)p)->oh_sz == sz)
        return -1;

      else
        return 1;
    }
}

// GC_hblk_fl_from_blocks
// file allchblk.c line 84
signed int GC_hblk_fl_from_blocks(unsigned long int blocks_needed)
{
  if(!(blocks_needed >= 33ul))
    return (signed int)blocks_needed;

  else
    if(blocks_needed >= 256ul)
      return (256 - 32) / 8 + 32;

    else
      return (signed int)(blocks_needed - (unsigned long int)32) / 8 + 32;
}

// GC_header_cache_miss
// file headers.c line 58
struct hblkhdr * GC_header_cache_miss(char *p, struct hce *hce)
{
  struct hblkhdr *hhdr;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)p >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)p >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    hhdr = *_ha;
  }
  while((_Bool)0);
  if(!((unsigned long int)hhdr >= 4096ul))
  {
    if(!(GC_all_interior_pointers == 0))
    {
      if(!(hhdr == ((struct hblkhdr *)NULL)))
      {
        char *current = p;
        current = (char *)(struct hblk *)((unsigned long int)current & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
        do
        {
          current = current - (signed long int)((unsigned long int)(1 << 12) * (unsigned long int)hhdr);
          hhdr=GC_find_header((char *)current);
        }
        while(!((unsigned long int)hhdr >= 4096ul));
        if(!((1 & (signed int)hhdr->hb_flags) == 0))
          return ((struct hblkhdr *)NULL);

        _Bool tmp_if_expr_1;
        if(!((4 & (signed int)hhdr->hb_flags) == 0))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = p - current >= (signed long int)hhdr->hb_sz ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          if(!(GC_all_interior_pointers == 0))
            GC_add_to_black_list_stack((unsigned long int)p);

          else
            GC_add_to_black_list_normal((unsigned long int)p);
          return ((struct hblkhdr *)NULL);
        }

      }

      else
        if(!(GC_all_interior_pointers == 0))
          GC_add_to_black_list_stack((unsigned long int)p);

        else
          GC_add_to_black_list_normal((unsigned long int)p);
      return hhdr;
    }

    else
    {
      if(hhdr == ((struct hblkhdr *)NULL))
      {
        if(!(GC_all_interior_pointers == 0))
          GC_add_to_black_list_stack((unsigned long int)p);

        else
          GC_add_to_black_list_normal((unsigned long int)p);
      }

      return ((struct hblkhdr *)NULL);
    }
  }

  else
    if(!((4 & (signed int)hhdr->hb_flags) == 0))
    {
      if(!(GC_all_interior_pointers == 0))
        GC_add_to_black_list_stack((unsigned long int)p);

      else
        GC_add_to_black_list_normal((unsigned long int)p);
      return ((struct hblkhdr *)NULL);
    }

    else
    {
      hce->block_addr = (unsigned long int)p >> (unsigned long int)12;
      hce->hce_hdr = hhdr;
      return hhdr;
    }
}

// GC_help_marker
// file mark.c line 1157
void GC_help_marker(unsigned long int my_mark_no)
{
  unsigned int my_id;
  struct GC_ms_entry local_mark_stack[4096l];
  if(!(GC_parallel == 0))
  {
    GC_acquire_mark_lock();
    while(GC_help_wanted == 0 && GC_mark_no == my_mark_no || !(GC_mark_no >= my_mark_no))
      GC_wait_marker();
    my_id = GC_helper_count;
    if(!(GC_mark_no == my_mark_no) || !((unsigned int)GC_parallel >= my_id))
      GC_release_mark_lock();

    else
    {
      GC_helper_count = my_id + (unsigned int)1;
      GC_release_mark_lock();
      GC_mark_local(local_mark_stack, (signed int)my_id);
    }
  }

}

// GC_ignore_self_finalize_mark_proc
// file finalize.c line 391
void GC_ignore_self_finalize_mark_proc(char *p)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)p);
  unsigned long int descr = hhdr->hb_descr;
  char *q;
  unsigned long int r;
  char *scan_limit;
  char *target_limit = (p + (signed long int)hhdr->hb_sz) - (signed long int)1;
  if((3ul & descr) == 0ul)
    scan_limit = (p + (signed long int)descr) - (signed long int)sizeof(unsigned long int) /*8ul*/ ;

  else
    scan_limit = (target_limit + (signed long int)1) - (signed long int)sizeof(unsigned long int) /*8ul*/ ;
  q = p;
  for( ; (unsigned long int)scan_limit >= (unsigned long int)q; q = q + (signed long int)8)
  {
    r = *((unsigned long int *)q);
    if(!(r >= (unsigned long int)p) || !((unsigned long int)target_limit >= r))
      do
        if(r >= (unsigned long int)GC_least_plausible_heap_addr && !(r >= (unsigned long int)GC_greatest_plausible_heap_addr))
          GC_arrays._mark_stack_top=GC_mark_and_push((void *)r, GC_arrays._mark_stack_top, GC_arrays._mark_stack_limit, (void **)q);

      while((_Bool)0);

  }
}

// GC_ignore_warn_proc
// file misc.c line 1599
extern void GC_ignore_warn_proc(char *msg, unsigned long int arg)
{
  if(!(GC_print_stats == 0))
    GC_default_warn_proc(msg, arg);

}

// GC_incr_bytes_allocd
// file mallocx.c line 234
extern void GC_incr_bytes_allocd(unsigned long int n)
{
  GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + n;
}

// GC_incr_bytes_freed
// file mallocx.c line 240
extern void GC_incr_bytes_freed(unsigned long int n)
{
  GC_arrays._bytes_freed = GC_arrays._bytes_freed + n;
}

// GC_incremental_protection_needs
// file os_dep.c line 3379
extern signed int GC_incremental_protection_needs(void)
{
  if(GC_page_size == 4096ul)
    return 1;

  else
    return 1 | 2;
}

// GC_init
// file ./include/gc.h line 396
extern void GC_init(void)
{
  unsigned long int initial_heap_sz;
  signed int cancel_state;
  char *return_value_getenv_1;
  _Bool tmp_if_expr_3;
  char *return_value_getenv_12;
  if((signed long int)GC_is_initialized == 0l)
  {
    initial_heap_sz = (unsigned long int)16;
    do
      pthread_setcancelstate(1, &cancel_state);
    while((_Bool)0);
    GC_setpagesize();
    char *return_value_getenv_2;
    return_value_getenv_2=getenv("GC_PRINT_VERBOSE_STATS");
    if(!(return_value_getenv_2 == ((char *)NULL)))
      GC_print_stats = 2;

    else
    {
      return_value_getenv_1=getenv("GC_PRINT_STATS");
      if(!(return_value_getenv_1 == ((char *)NULL)))
        GC_print_stats = 1;

    }
    char *file_name;
    file_name=getenv("GC_LOG_FILE");
    if(!(file_name == ((char *)NULL)))
    {
      signed int log_d;
      log_d=open(file_name, 0100 | 01 | 02000, 0666);
      if(!(log_d >= 0))
        GC_err_printf("Failed to open %s as log file\n", file_name);

      else
      {
        char *str;
        GC_log = log_d;
        str=getenv("GC_ONLY_LOG_TO_FILE");
        _Bool tmp_if_expr_4;
        if(str == ((char *)NULL))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          if((signed int)*str == 48)
            tmp_if_expr_3 = (signed int)str[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          GC_stdout = log_d;
          GC_stderr = log_d;
        }

      }
    }

    char *return_value_getenv_5;
    return_value_getenv_5=getenv("GC_DUMP_REGULARLY");
    if(!(return_value_getenv_5 == ((char *)NULL)))
      GC_dump_regularly = 1;

    char *return_value_getenv_6;
    return_value_getenv_6=getenv("GC_FIND_LEAK");
    if(!(return_value_getenv_6 == ((char *)NULL)))
      GC_find_leak = 1;

    char *return_value_getenv_7;
    return_value_getenv_7=getenv("GC_FINDLEAK_DELAY_FREE");
    if(!(return_value_getenv_7 == ((char *)NULL)))
      GC_findleak_delay_free = 1;

    char *return_value_getenv_8;
    return_value_getenv_8=getenv("GC_ALL_INTERIOR_POINTERS");
    if(!(return_value_getenv_8 == ((char *)NULL)))
      GC_all_interior_pointers = 1;

    char *return_value_getenv_9;
    return_value_getenv_9=getenv("GC_DONT_GC");
    if(!(return_value_getenv_9 == ((char *)NULL)))
      GC_dont_gc = 1;

    char *return_value_getenv_10;
    return_value_getenv_10=getenv("GC_PRINT_BACK_HEIGHT");
    if(!(return_value_getenv_10 == ((char *)NULL)))
      GC_print_back_height = 1;

    char *return_value_getenv_11;
    return_value_getenv_11=getenv("GC_NO_BLACKLIST_WARNING");
    if(!(return_value_getenv_11 == ((char *)NULL)))
      GC_large_alloc_warn_interval = 0x7fffffffffffffffL;

    char *addr_string;
    addr_string=getenv("GC_TRACE");
    if(!(addr_string == ((char *)NULL)))
      GC_current_warn_proc("GC Warning: Tracing not enabled: Ignoring GC_TRACE value\n", (unsigned long int)0);

    char *time_limit_string;
    time_limit_string=getenv("GC_PAUSE_TIME_TARGET");
    if(!(time_limit_string == ((char *)NULL)))
    {
      signed long int time_limit;
      time_limit=atol(time_limit_string);
      if(!(time_limit >= 5l))
        GC_current_warn_proc("GC Warning: GC_PAUSE_TIME_TARGET environment variable value too small or bad syntax: Ignoring\n", (unsigned long int)0);

      else
        GC_time_limit = (unsigned long int)time_limit;
    }

    char *full_freq_string;
    full_freq_string=getenv("GC_FULL_FREQUENCY");
    if(!(full_freq_string == ((char *)NULL)))
    {
      signed int full_freq;
      full_freq=atoi(full_freq_string);
      if(full_freq >= 1)
        GC_full_freq = full_freq;

    }

    char *interval_string;
    interval_string=getenv("GC_LARGE_ALLOC_WARN_INTERVAL");
    if(!(interval_string == ((char *)NULL)))
    {
      signed long int interval;
      interval=atol(interval_string);
      if(!(interval >= 1l))
        GC_current_warn_proc("GC Warning: GC_LARGE_ALLOC_WARN_INTERVAL environment variable has bad value: Ignoring\n", (unsigned long int)0);

      else
        GC_large_alloc_warn_interval = interval;
    }

    char *space_divisor_string;
    space_divisor_string=getenv("GC_FREE_SPACE_DIVISOR");
    if(!(space_divisor_string == ((char *)NULL)))
    {
      signed int space_divisor;
      space_divisor=atoi(space_divisor_string);
      if(space_divisor >= 1)
        GC_free_space_divisor = (unsigned long int)space_divisor;

    }

    maybe_install_looping_handler();
    if(!(GC_all_interior_pointers == 0))
      GC_obj_kinds[(signed long int)1].ok_descriptor = (unsigned long int)-8 | (unsigned long int)0;

    GC_exclude_static_roots_inner((void *)(char *)&GC_arrays, (void *)((char *)&GC_arrays + (signed long int)sizeof(struct _GC_arrays) /*198880ul*/ ));
    GC_exclude_static_roots_inner((void *)(char *)&GC_obj_kinds, (void *)((char *)&GC_obj_kinds + (signed long int)sizeof(struct obj_kind [16l]) /*768ul*/ ));
    GC_init_linux_data_start();
    if(GC_stackbottom == ((char *)NULL))
      GC_stackbottom=GC_get_main_stack_base();

    _Bool tmp_if_expr_13;
    if(!(GC_incremental == 0))
      tmp_if_expr_13 = (_Bool)1;

    else
    {
      return_value_getenv_12=getenv("GC_ENABLE_INCREMENTAL");
      tmp_if_expr_13 = ((char *)NULL) != return_value_getenv_12 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_13)
    {
      GC_dirty_init();
      GC_incremental = 1;
    }

    signed int return_value_GC_register_main_static_data_14;
    return_value_GC_register_main_static_data_14=GC_register_main_static_data();
    if(!(return_value_GC_register_main_static_data_14 == 0))
      GC_register_data_segments();

    GC_init_headers();
    GC_bl_init();
    GC_mark_init();
    char *sz_str;
    sz_str=getenv("GC_INITIAL_HEAP_SIZE");
    if(!(sz_str == ((char *)NULL)))
    {
      initial_heap_sz=GC_parse_mem_size_arg(sz_str);
      if(!(initial_heap_sz >= 65537ul))
        GC_current_warn_proc("GC Warning: Bad initial heap size %s - ignoring it.\n", (unsigned long int)sz_str);

      initial_heap_sz = initial_heap_sz >> (unsigned long int)12;
    }

    char *GC_init__1__22__sz_str;
    GC_init__1__22__sz_str=getenv("GC_MAXIMUM_HEAP_SIZE");
    if(!(GC_init__1__22__sz_str == ((char *)NULL)))
    {
      unsigned long int max_heap_sz;
      max_heap_sz=GC_parse_mem_size_arg(GC_init__1__22__sz_str);
      if(!(max_heap_sz >= 4096ul * initial_heap_sz))
        GC_current_warn_proc("GC Warning: Bad maximum heap size %s - ignoring it.\n", (unsigned long int)GC_init__1__22__sz_str);

      if(GC_max_retries == 0ul)
        GC_max_retries = (unsigned long int)2;

      GC_set_max_heap_size(max_heap_sz);
    }

    signed int return_value_GC_expand_hp_inner_15;
    return_value_GC_expand_hp_inner_15=GC_expand_hp_inner(initial_heap_sz);
    if(return_value_GC_expand_hp_inner_15 == 0)
    {
      GC_err_printf("Can't start up: not enough memory\n");
      GC_on_abort((const char *)(void *)0);
      exit(1);
    }

    else
      GC_arrays._requested_heapsize = GC_arrays._requested_heapsize + initial_heap_sz;
    if(!(GC_all_interior_pointers == 0))
      GC_initialize_offsets();

    GC_register_displacement_inner((unsigned long int)0L);
    GC_init_size_map();
    GC_is_initialized = 1;
    GC_thr_init();
    if(!((signed long int)GC_dump_regularly == 0l))
      GC_dump();

    else

      __CPROVER_DUMP_L46:
        ;
    if(GC_dont_precollect == 0 || !(GC_incremental == 0))
      GC_try_to_collect_inner(GC_never_stop_func);

    if(!(GC_find_leak == 0))
      atexit(GC_exit_check);

    GC_init_parallel();
    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }

}

// GC_init_explicit_typing
// file typd_mlc.c line 348
void GC_init_explicit_typing(void)
{
  unsigned int i;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(!(GC_explicit_typing_initialized == 0))
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);

  else
  {
    GC_explicit_typing_initialized = 1;
    void **return_value_GC_new_free_list_inner_2;
    return_value_GC_new_free_list_inner_2=GC_new_free_list_inner();
    GC_eobjfreelist = (char **)return_value_GC_new_free_list_inner_2;
    unsigned int return_value_GC_new_kind_inner_3;
    return_value_GC_new_kind_inner_3=GC_new_kind_inner((void **)GC_eobjfreelist, (unsigned long int)-1 << 3 | (unsigned long int)3, 1, 1);
    GC_explicit_kind = (signed int)return_value_GC_new_kind_inner_3;
    unsigned int return_value_GC_new_proc_inner_4;
    return_value_GC_new_proc_inner_4=GC_new_proc_inner(GC_typed_mark_proc);
    GC_typed_mark_proc_index = (signed int)return_value_GC_new_proc_inner_4;
    void **return_value_GC_new_free_list_inner_5;
    return_value_GC_new_free_list_inner_5=GC_new_free_list_inner();
    GC_arobjfreelist = (char **)return_value_GC_new_free_list_inner_5;
    unsigned int return_value_GC_new_proc_inner_6;
    return_value_GC_new_proc_inner_6=GC_new_proc_inner(GC_array_mark_proc);
    GC_array_mark_proc_index = (signed int)return_value_GC_new_proc_inner_6;
    unsigned int return_value_GC_new_kind_inner_7;
    return_value_GC_new_kind_inner_7=GC_new_kind_inner((void **)GC_arobjfreelist, (unsigned long int)((0 << 6 | GC_array_mark_proc_index) << 2 | 2), 0, 1);
    GC_array_kind = (signed int)return_value_GC_new_kind_inner_7;
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 32ul); i = i + 1u)
      GC_bm_table[(signed long int)i] = (unsigned long int)-1 << (unsigned long int)64 - (unsigned long int)i | (unsigned long int)1;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
}

// GC_init_finalized_malloc
// file fnlz_mlc.c line 50
extern void GC_init_finalized_malloc(void)
{
  GC_init();
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(!(done_init == 0))
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);

  else
  {
    done_init = 1;
    GC_register_displacement_inner(sizeof(unsigned long int) /*8ul*/ );
    void **return_value_GC_new_free_list_inner_2;
    return_value_GC_new_free_list_inner_2=GC_new_free_list_inner();
    GC_finalized_objfreelist = (char **)return_value_GC_new_free_list_inner_2;
    unsigned int return_value_GC_new_kind_inner_3;
    return_value_GC_new_kind_inner_3=GC_new_kind_inner((void **)GC_finalized_objfreelist, (unsigned long int)0, 1, 1);
    GC_finalized_kind = (signed int)return_value_GC_new_kind_inner_3;
    GC_register_disclaim_proc(GC_finalized_kind, GC_finalized_disclaim, 1);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
}

// GC_init_gcj_malloc
// file gcj_mlc.c line 69
extern void GC_init_gcj_malloc(signed int mp_index, void *mp)
{
  signed int ignore_gcj_info;
  if(mp == NULL)
    mp = (void *)(unsigned long int)GC_gcj_fake_mark_proc;

  GC_init();
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(!(GC_gcj_malloc_initialized == 0))
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);

  else
  {
    GC_gcj_malloc_initialized = 1;
    char *return_value_getenv_2;
    return_value_getenv_2=getenv("GC_IGNORE_GCJ_INFO");
    ignore_gcj_info = (signed int)(((char *)NULL) != return_value_getenv_2);
    if(!(ignore_gcj_info == 0))
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Gcj-style type information is disabled!\n");

    }

    GC_arrays._mark_procs[(signed long int)mp_index] = (struct GC_ms_entry * (*)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int))(unsigned long int)mp;
    if((unsigned int)mp_index >= GC_n_mark_procs)
    {
      GC_on_abort("GC_init_gcj_malloc: bad index");
      abort();
    }

    void **return_value_GC_new_free_list_inner_3;
    return_value_GC_new_free_list_inner_3=GC_new_free_list_inner();
    GC_gcjobjfreelist = (char **)return_value_GC_new_free_list_inner_3;
    if(!(ignore_gcj_info == 0))
    {
      unsigned int return_value_GC_new_kind_inner_4;
      return_value_GC_new_kind_inner_4=GC_new_kind_inner((void **)GC_gcjobjfreelist, (unsigned long int)(0 | 0), 1, 1);
      GC_gcj_kind = (signed int)return_value_GC_new_kind_inner_4;
    }

    else
    {
      unsigned int return_value_GC_new_kind_inner_5;
      return_value_GC_new_kind_inner_5=GC_new_kind_inner((void **)GC_gcjobjfreelist, (unsigned long int)(-((signed long int)sizeof(unsigned long int) /*8ul*/ ) - (signed long int)0x10) | (unsigned long int)3, 0, 1);
      GC_gcj_kind = (signed int)return_value_GC_new_kind_inner_5;
    }
    if(!(ignore_gcj_info == 0))
    {
      GC_gcj_debug_kind = GC_gcj_kind;
      GC_gcjdebugobjfreelist = GC_gcjobjfreelist;
    }

    else
    {
      void **return_value_GC_new_free_list_inner_6;
      return_value_GC_new_free_list_inner_6=GC_new_free_list_inner();
      GC_gcjdebugobjfreelist = (char **)return_value_GC_new_free_list_inner_6;
      unsigned int return_value_GC_new_kind_inner_7;
      return_value_GC_new_kind_inner_7=GC_new_kind_inner((void **)GC_gcjdebugobjfreelist, (unsigned long int)((1 << 6 | mp_index) << 2 | 2), 0, 1);
      GC_gcj_debug_kind = (signed int)return_value_GC_new_kind_inner_7;
    }
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
}

// GC_init_headers
// file headers.c line 189
void GC_init_headers(void)
{
  unsigned int i;
  char *return_value_GC_scratch_alloc_1;
  return_value_GC_scratch_alloc_1=GC_scratch_alloc((unsigned long int)sizeof(struct bi) /*8224ul*/ );
  GC_arrays._all_nils = (struct bi *)return_value_GC_scratch_alloc_1;
  if(GC_arrays._all_nils == ((struct bi *)NULL))
  {
    GC_err_printf("Insufficient memory for GC_all_nils\n");
    GC_on_abort((const char *)(void *)0);
    exit(1);
  }

  memset((void *)GC_arrays._all_nils, 0, (unsigned long int)sizeof(struct bi) /*8224ul*/ );
  i = (unsigned int)0;
  for( ; !(i >= 2048u); i = i + 1u)
    GC_arrays._top_index[(signed long int)i] = GC_arrays._all_nils;
}

// GC_init_linux_data_start
// file ./include/private/gc_priv.h line 2289
void GC_init_linux_data_start(void)
{
  GC_data_start = (char *)__data_start;
}

// GC_init_parallel
// file ./include/private/gc_priv.h line 1681
void GC_init_parallel(void)
{
  if(parallel_initialized == 0)
  {
    parallel_initialized = 1;
    if(GC_is_initialized == 0)
      GC_init();

    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    struct GC_Thread_Rep *return_value_GC_lookup_thread_3;
    return_value_GC_lookup_thread_3=GC_lookup_thread(return_value_pthread_self_2);
    GC_init_thread_local(&return_value_GC_lookup_thread_3->tlfs);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

}

// GC_init_size_map
// file misc.c line 227
void GC_init_size_map(void)
{
  signed int i;
  GC_arrays._size_map[(signed long int)0] = (unsigned long int)1;
  i = 1;
  for( ; 384 + -GC_all_interior_pointers >= i; i = i + 1)
    GC_arrays._size_map[(signed long int)i] = (unsigned long int)(i + (16 - 1) + GC_all_interior_pointers >> 4);
}

// GC_init_thread_local
// file thread_local_alloc.c line 87
void GC_init_thread_local(struct thread_local_freelists *p)
{
  signed int i;
  if((signed long int)keys_initialized == 0l)
    keys_initialized = 1;

  GC_thread_key = (void *)p;
  i = 1;
  for( ; !(i >= 25); i = i + 1)
  {
    p->ptrfree_freelists[(signed long int)i] = (void *)(unsigned long int)1;
    p->normal_freelists[(signed long int)i] = (void *)(unsigned long int)1;
    p->gcj_freelists[(signed long int)i] = (void *)(unsigned long int)1;
    p->finalized_freelists[(signed long int)i] = (void *)(unsigned long int)1;
  }
  p->ptrfree_freelists[(signed long int)0] = (void *)(unsigned long int)1;
  p->normal_freelists[(signed long int)0] = (void *)(unsigned long int)1;
  p->gcj_freelists[(signed long int)0] = (void *)(unsigned long int)-1;
  p->finalized_freelists[(signed long int)0] = (void *)(unsigned long int)1;
}

// GC_initialize_offsets
// file ./include/private/gc_priv.h line 2224
void GC_initialize_offsets(void)
{
  unsigned int i;
  if(!(GC_all_interior_pointers == 0))
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 4096ul); i = i + 1u)
      GC_arrays._valid_offsets[(signed long int)i] = (char)1;
  }

  else
  {
    memset((void *)GC_arrays._valid_offsets, 0, (unsigned long int)sizeof(char [4096l]) /*4096ul*/ );
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= sizeof(unsigned long int) /*8ul*/ ); i = i + 1u)
      GC_arrays._modws_valid_offsets[(signed long int)i] = (char)0;
  }
}

// GC_initiate_gc
// file ./include/private/gc_priv.h line 1565
void GC_initiate_gc(void)
{
  if(!(GC_dirty_maintained == 0))
    GC_read_dirty();

  GC_n_rescuing_pages = (unsigned long int)0;
  if(GC_mark_state == 0)
    GC_mark_state = 1;

  else
    if(!(GC_mark_state == 5))
    {
      GC_on_abort("Unexpected state");
      abort();
    }

  scan_ptr = ((struct hblk *)NULL);
}

// GC_inner_start_routine
// file pthread_start.c line 45
void * GC_inner_start_routine(struct GC_stack_base *sb, void *arg)
{
  void * (*start)(void *);
  void *start_arg;
  void *result;
  struct GC_Thread_Rep * volatile me;
  me=GC_start_rtn_prepare_thread(&start, &start_arg, sb, arg);
  struct anonymous_26 __cancel_buf;
  void (*__cancel_routine)(void *) = GC_thread_exit_proc;
  void *__cancel_arg = (void *)me;
  signed int __not_first_call;
  __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
  if(!((signed long int)__not_first_call == 0l))
  {
    __cancel_routine(__cancel_arg);
    __pthread_unwind_next(&__cancel_buf);
  }

  __pthread_register_cancel(&__cancel_buf);
  result=start(start_arg);
  me->status = result;
  __pthread_unregister_cancel(&__cancel_buf);
  __cancel_routine(__cancel_arg);
  return result;
}

// GC_install_counts
// file ./include/private/gc_priv.h line 1887
signed int GC_install_counts(struct hblk *h, unsigned long int sz)
{
  struct hblk *hbp;
  unsigned long int i;
  hbp = h;
  for( ; !((unsigned long int)hbp >= sz + (unsigned long int)h); hbp = hbp + (signed long int)(1 << 10))
  {
    signed int return_value_get_index_1;
    return_value_get_index_1=get_index((unsigned long int)hbp);
    if(return_value_get_index_1 == 0)
      return 0;

  }
  signed int return_value_get_index_2;
  return_value_get_index_2=get_index(((unsigned long int)h + sz) - (unsigned long int)1);
  if(return_value_get_index_2 == 0)
    return 0;

  else
  {
    hbp = h + (signed long int)1;
    for( ; !((unsigned long int)hbp >= sz + (unsigned long int)h); hbp = hbp + (signed long int)1)
    {
      i = (unsigned long int)((char *)hbp - (char *)h >> (unsigned long int)12);
      do
      {
        struct hblkhdr **_ha;
        do
        {
          struct bi *bi;
          do
          {
            unsigned long int hi = (unsigned long int)hbp >> (unsigned long int)10 + (unsigned long int)12;
            struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
            for( ; !(_bi->key == hi); _bi = _bi->hash_link)
              if(_bi == GC_arrays._all_nils)
                break;

            bi = _bi;
          }
          while((_Bool)0);
          _ha = &bi->index[(signed long int)((unsigned long int)hbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
        }
        while((_Bool)0);
        *_ha = (struct hblkhdr *)(i > (unsigned long int)(1 << 12) - (unsigned long int)1 ? (unsigned long int)(1 << 12) - (unsigned long int)1 : i);
      }
      while((_Bool)0);
    }
    return 1;
  }
}

// GC_install_header
// file ./include/private/gc_priv.h line 1883
struct hblkhdr * GC_install_header(struct hblk *h)
{
  struct hblkhdr *result;
  signed int return_value_get_index_1;
  return_value_get_index_1=get_index((unsigned long int)h);
  if(return_value_get_index_1 == 0)
    return ((struct hblkhdr *)NULL);

  else
  {
    result=alloc_hdr();
    if(!(result == ((struct hblkhdr *)NULL)))
      do
      {
        struct hblkhdr **_ha;
        do
        {
          struct bi *bi;
          do
          {
            unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
            struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
            for( ; !(_bi->key == hi); _bi = _bi->hash_link)
              if(_bi == GC_arrays._all_nils)
                break;

            bi = _bi;
          }
          while((_Bool)0);
          _ha = &bi->index[(signed long int)((unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
        }
        while((_Bool)0);
        *_ha = result;
      }
      while((_Bool)0);

    return result;
  }
}

// GC_invalidate_mark_state
// file ./include/private/gc_priv.h line 1555
void GC_invalidate_mark_state(void)
{
  GC_mark_state = 5;
  GC_arrays._mark_stack_top = GC_arrays._mark_stack - (signed long int)1;
}

// GC_invoke_finalizers
// file finalize.c line 966
extern signed int GC_invoke_finalizers(void)
{
  struct finalizable_object *curr_fo;
  signed int count = 0;
  unsigned long int bytes_freed_before = (unsigned long int)0;
  if(!(GC_finalize_now == ((struct finalizable_object *)NULL)))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    if(count == 0)
      bytes_freed_before = GC_arrays._bytes_freed;

    curr_fo = GC_finalize_now;
    if(!(curr_fo == ((struct finalizable_object *)NULL)))
      GC_finalize_now = (struct finalizable_object *)curr_fo->prolog.next;

    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(!(curr_fo == ((struct finalizable_object *)NULL)))
    {
      curr_fo->prolog.next = (struct hash_chain_entry *)0;
      curr_fo->fo_fn((void *)(char *)curr_fo->prolog.hidden_key, (void *)curr_fo->fo_client_data);
      curr_fo->fo_client_data = ((char *)NULL);
      count = count + 1;
    }

  }

  if(!(count == 0) && !(bytes_freed_before == GC_arrays._bytes_freed))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_2;
        return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_2 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_arrays._finalizer_bytes_freed = GC_arrays._finalizer_bytes_freed + (GC_arrays._bytes_freed - bytes_freed_before);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  return count;
}

// GC_is_black_listed
// file ./include/private/gc_priv.h line 1713
struct hblk * GC_is_black_listed(struct hblk *h, unsigned long int len)
{
  unsigned long int index = (unsigned long int)h >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
  unsigned long int i;
  unsigned long int nblocks;
  if(GC_all_interior_pointers == 0)
  {
    _Bool tmp_if_expr_1;
    if(!((1ul & GC_old_normal_bl[(signed long int)(index >> 6ul)] >> (63ul & index)) == 0ul))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (GC_incomplete_normal_bl[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return h + (signed long int)1;

  }

  nblocks = len >> (unsigned long int)12;
  i = (unsigned long int)0;
  do
  {
    _Bool tmp_if_expr_3;
    if(GC_old_stack_bl[(signed long int)(index >> 6ul)] == 0ul)
      tmp_if_expr_3 = GC_incomplete_stack_bl[(signed long int)(index >> (unsigned long int)6)] == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      i = i + ((unsigned long int)64 - (index & (unsigned long int)0x3f));

    else
    {
      _Bool tmp_if_expr_2;
      if(!((1ul & GC_old_stack_bl[(signed long int)(index >> 6ul)] >> (63ul & index)) == 0ul))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (GC_incomplete_stack_bl[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        return h + (signed long int)i + (signed long int)1;

      i = i + 1ul;
    }
    if(i >= nblocks)
      break;

    index = (unsigned long int)(h + (signed long int)i) >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
  }
  while((_Bool)1);
  return ((struct hblk *)NULL);
}

// GC_is_disabled
// file misc.c line 1733
extern signed int GC_is_disabled(void)
{
  return (signed int)(GC_dont_gc != 0);
}

// GC_is_heap_ptr
// file misc.c line 462
extern signed int GC_is_heap_ptr(const void *p)
{
  struct bi *bi;
  do
  {
    unsigned long int hi = (unsigned long int)p >> (unsigned long int)10 + (unsigned long int)12;
    struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
    for( ; !(_bi->key == hi); _bi = _bi->hash_link)
      if(_bi == GC_arrays._all_nils)
        break;

    bi = _bi;
  }
  while((_Bool)0);
  return (signed int)(bi->index[(signed long int)((unsigned long int)p >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))] != ((struct hblkhdr *)NULL));
}

// GC_is_marked
// file ./include/private/../gc_mark.h line 245
extern signed int GC_is_marked(const void *p)
{
  struct hblk *h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  unsigned long int bit_no = (unsigned long int)((unsigned int)((char *)p - (char *)h) >> 4);
  return (signed int)hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no];
}

// GC_is_valid_displacement
// file ptr_chck.c line 117
extern void * GC_is_valid_displacement(void *p)
{
  struct hblkhdr *hhdr;
  unsigned long int pdispl;
  unsigned long int offset;
  struct hblk *h;
  unsigned long int sz;
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  hhdr=GC_find_header((char *)(unsigned long int)p);
  if(hhdr == ((struct hblkhdr *)NULL))
    return p;

  else
  {
    h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    if(!(GC_all_interior_pointers == 0))
      while(!((unsigned long int)hhdr >= 4096ul))
      {
        h = (struct hblk *)h - (signed long int)(unsigned long int)hhdr;
        hhdr=GC_find_header((char *)h);
      }

    if((unsigned long int)hhdr >= 4096ul)
    {
      sz = hhdr->hb_sz;
      pdispl = (unsigned long int)p & (unsigned long int)(1 << 12) - (unsigned long int)1;
      offset = pdispl % sz;
      _Bool tmp_if_expr_1;
      if(sz >= 2049ul && (unsigned long int)p >= sz + (unsigned long int)h)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = !(GC_arrays._valid_offsets[(signed long int)offset] != 0) ? (_Bool)1 : (_Bool)0;
      if(!((unsigned long int)(h + 1l) >= sz + (unsigned long int)p + -offset) || tmp_if_expr_1)
        goto fail;

      return p;
    }

    else
    {

    fail:
      ;
      GC_is_valid_displacement_print_proc((void *)(char *)p);
      return p;
    }
  }
}

// GC_is_visible
// file ptr_chck.c line 187
extern void * GC_is_visible(void *p)
{
  struct hblkhdr *hhdr;
  void *return_value_GC_base_1;
  if((7ul & (unsigned long int)p) == 0ul)
  {
    if((signed long int)GC_is_initialized == 0l)
      GC_init();

    hhdr=GC_find_header((char *)(unsigned long int)p);
    _Bool tmp_if_expr_2;
    if(!(hhdr == ((struct hblkhdr *)NULL)))
    {
      return_value_GC_base_1=GC_base(p);
      tmp_if_expr_2 = return_value_GC_base_1 == NULL ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      goto fail;

    else
      return p;
  }


fail:
  ;
  GC_is_visible_print_proc((void *)(char *)p);
  return p;
}

// GC_linux_main_stack_base
// file os_dep.c line 1071
char * GC_linux_main_stack_base(void)
{
  char stat_buf[4096l];
  signed int f;
  unsigned long int result;
  signed int i;
  signed int buf_offset = 0;
  signed int len;
  const unsigned short int **return_value___ctype_b_loc_2;
  signed int tmp_post_3;
  const unsigned short int **return_value___ctype_b_loc_4;
  signed int tmp_post_5;
  const unsigned short int **return_value___ctype_b_loc_6;
  if(!(__libc_stack_end == ((char *)NULL)))
    return __libc_stack_end;

  else
  {
    f=open("/proc/self/stat", 00);
    if(!(f >= 0))
    {
      GC_on_abort("Couldn't read /proc/self/stat");
      abort();
    }

    signed long int return_value_read_1;
    return_value_read_1=read(f, (void *)stat_buf, (unsigned long int)4096);
    len = (signed int)return_value_read_1;
    close(f);
    i = 0;
    for( ; !(i >= 27); i = i + 1)
    {
      while(!(buf_offset >= len))
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        tmp_post_3 = buf_offset;
        buf_offset = buf_offset + 1;
        if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)stat_buf[(signed long int)tmp_post_3]]) == 0)
          break;

      }
      while(!(buf_offset >= len))
      {
        return_value___ctype_b_loc_4=__ctype_b_loc();
        tmp_post_5 = buf_offset;
        buf_offset = buf_offset + 1;
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)stat_buf[(signed long int)tmp_post_5]]) == 0))
          break;

      }
    }
    for( ; !(buf_offset >= len); buf_offset = buf_offset + 1)
    {
      return_value___ctype_b_loc_6=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)stat_buf[(signed long int)buf_offset]]) == 0)
        break;

    }
    i = 0;
    for( ; !(buf_offset + i >= len); i = i + 1)
    {
      const unsigned short int **return_value___ctype_b_loc_7;
      return_value___ctype_b_loc_7=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)stat_buf[(signed long int)(buf_offset + i)]]) == 0)
        break;

    }
    if(buf_offset + i >= len)
    {
      GC_on_abort("Could not parse /proc/self/stat");
      abort();
    }

    stat_buf[(signed long int)(buf_offset + i)] = (char)0;
    unsigned long int return_value_strtoul_8;
    return_value_strtoul_8=strtoul(&stat_buf[(signed long int)buf_offset], (char ** restrict )(void *)0, 10);
    result = (unsigned long int)return_value_strtoul_8;
    if(!((7ul & result) == 0ul) || !(result >= 1048576ul))
    {
      GC_on_abort("Absurd stack bottom value");
      abort();
    }

    return (char *)result;
  }
}

// GC_lock
// file ./include/private/gc_locks.h line 182
void GC_lock(void)
{
  if(GC_nprocs == 1 || !(GC_collecting == 0))
    pthread_mutex_lock(&GC_allocate_ml);

  else
    GC_generic_lock(&GC_allocate_ml);
}

// GC_log_printf
// file ./include/private/gc_priv.h line 2104
extern void GC_log_printf(const char *format, ...)
{
  char buf[1025l];
  do
  {
    void **args = (void **)&format;
    buf[(signed long int)(sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1)] = (char)0x15;
    vsnprintf(buf, sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1, format, args);
    args = ((void **)NULL);
    if(!((signed int)buf[1024l] == 0x15))
    {
      GC_on_abort("GC_printf clobbered stack");
      abort();
    }

  }
  while((_Bool)0);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  signed int return_value_GC_write_2;
  return_value_GC_write_2=GC_write(GC_log, buf, return_value_strlen_1);
  if(!(return_value_GC_write_2 >= 0))
  {
    GC_on_abort("write to GC log failed");
    abort();
  }

}

// GC_lookup_thread
// file pthread_support.c line 596
struct GC_Thread_Rep * GC_lookup_thread(unsigned long int id)
{
  signed int hv = (signed int)((unsigned long int)id % (unsigned long int)256);
  struct GC_Thread_Rep *p = GC_threads[(signed long int)hv];
  for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
    if(p->id == id)
      break;

  return p;
}

// GC_make_array_descriptor
// file typd_mlc.c line 207
signed int GC_make_array_descriptor(unsigned long int nelements, unsigned long int size, unsigned long int descriptor, unsigned long int *simple_d, union ComplexDescriptor **complex_d, struct LeafDescriptor *leaf)
{
  struct LeafDescriptor *beginning;
  void *return_value_GC_malloc_atomic_3;
  struct LeafDescriptor *GC_make_array_descriptor__1__3__2__1__2__beginning;
  void *return_value_GC_malloc_atomic_4;
  if((3ul & descriptor) == 0ul)
  {
    if(descriptor == size)
    {
      *simple_d = nelements * descriptor;
      return 0;
    }

    if(!(descriptor == 0ul))
      goto __CPROVER_DUMP_L2;

    *simple_d = (unsigned long int)0;
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(!(nelements >= 51ul))
    {
      if(!(nelements >= 2ul))
      {
        if(nelements == 1ul)
        {
          *simple_d = descriptor;
          return 0;
        }

        else
        {
          *simple_d = (unsigned long int)0;
          return 0;
        }
      }

    }

    else
      if((7ul & size) == 0ul && !((3ul & descriptor) == 2ul) && !(size >= 32ul))
      {
        signed int result;
        unsigned long int return_value_GC_double_descr_1;
        return_value_GC_double_descr_1=GC_double_descr(descriptor, size >> 3);
        result=GC_make_array_descriptor(nelements / (unsigned long int)2, (unsigned long int)2 * size, return_value_GC_double_descr_1, simple_d, complex_d, leaf);
        if((1ul & nelements) == 0ul)
          return result;

        else
        {
          struct LeafDescriptor *one_element;
          void *return_value_GC_malloc_atomic_2;
          return_value_GC_malloc_atomic_2=GC_malloc_atomic(sizeof(struct LeafDescriptor) /*32ul*/ );
          one_element = (struct LeafDescriptor *)return_value_GC_malloc_atomic_2;
          if(one_element == ((struct LeafDescriptor *)NULL) || result == -1)
            return -1;

          one_element->ld_tag = (unsigned long int)1;
          one_element->ld_size = size;
          one_element->ld_nelements = (unsigned long int)1;
          one_element->ld_descriptor = descriptor;
          switch(result)
          {
            case 0:
            {
              return_value_GC_malloc_atomic_3=GC_malloc_atomic(sizeof(struct LeafDescriptor) /*32ul*/ );
              beginning = (struct LeafDescriptor *)return_value_GC_malloc_atomic_3;
              if(beginning == ((struct LeafDescriptor *)NULL))
                return -1;

              beginning->ld_tag = (unsigned long int)1;
              beginning->ld_size = size;
              beginning->ld_nelements = (unsigned long int)1;
              beginning->ld_descriptor = *simple_d;
              *complex_d=GC_make_sequence_descriptor((union ComplexDescriptor *)beginning, (union ComplexDescriptor *)one_element);
              break;
            }
            case 1:
            {
              return_value_GC_malloc_atomic_4=GC_malloc_atomic(sizeof(struct LeafDescriptor) /*32ul*/ );
              GC_make_array_descriptor__1__3__2__1__2__beginning = (struct LeafDescriptor *)return_value_GC_malloc_atomic_4;
              if(GC_make_array_descriptor__1__3__2__1__2__beginning == ((struct LeafDescriptor *)NULL))
                return -1;

              GC_make_array_descriptor__1__3__2__1__2__beginning->ld_tag = (unsigned long int)1;
              GC_make_array_descriptor__1__3__2__1__2__beginning->ld_size = leaf->ld_size;
              GC_make_array_descriptor__1__3__2__1__2__beginning->ld_nelements = leaf->ld_nelements;
              GC_make_array_descriptor__1__3__2__1__2__beginning->ld_descriptor = leaf->ld_descriptor;
              *complex_d=GC_make_sequence_descriptor((union ComplexDescriptor *)GC_make_array_descriptor__1__3__2__1__2__beginning, (union ComplexDescriptor *)one_element);
              break;
            }
            case 2:
              *complex_d=GC_make_sequence_descriptor(*complex_d, (union ComplexDescriptor *)one_element);
          }
          return 2;
        }
      }

    leaf->ld_size = size;
    leaf->ld_nelements = nelements;
    leaf->ld_descriptor = descriptor;
    return 1;
  }
}

// GC_make_closure
// file dbg_mlc.c line 1047
void * GC_make_closure(void (*fn)(void *, void *), void *data)
{
  struct closure *result;
  void *return_value_GC_malloc_1;
  return_value_GC_malloc_1=GC_malloc(sizeof(struct closure) /*16ul*/ );
  result = (struct closure *)return_value_GC_malloc_1;
  if(!(result == ((struct closure *)NULL)))
  {
    result->cl_fn = fn;
    result->cl_data = data;
  }

  return (void *)result;
}

// GC_make_descriptor
// file typd_mlc.c line 534
extern unsigned long int GC_make_descriptor(const unsigned long int *bm, unsigned long int len)
{
  signed long int last_set_bit = (signed long int)(len - (unsigned long int)1);
  unsigned long int result;
  signed long int i;
  if((signed long int)GC_explicit_typing_initialized == 0l)
    GC_init_explicit_typing();

  for( ; last_set_bit >= 0l; last_set_bit = last_set_bit - 1l)
    if(!((1ul & bm[(signed long int)((unsigned long int)last_set_bit / sizeof(unsigned long int) * 8 /*64ul*/ )] >> (unsigned long int)last_set_bit % sizeof(unsigned long int) * 8 /*64ul*/ ) == 0ul))
      break;

  if(!(last_set_bit >= 0l))
    return (unsigned long int)0;

  else
  {
    signed int all_bits_set = 1;
    i = (signed long int)0;
    for( ; !(i >= last_set_bit); i = i + 1l)
      if((1ul & bm[(signed long int)((unsigned long int)i / sizeof(unsigned long int) * 8 /*64ul*/ )] >> (unsigned long int)i % sizeof(unsigned long int) * 8 /*64ul*/ ) == 0ul)
      {
        all_bits_set = 0;
        break;
      }

    if(!(all_bits_set == 0))
      return (unsigned long int)(last_set_bit + (signed long int)1 << 3 | (signed long int)0);

    else
      if(!((unsigned long int)last_set_bit >= 62ul))
      {
        result = (unsigned long int)1 << (unsigned long int)64 - (unsigned long int)1;
        i = last_set_bit - (signed long int)1;
        for( ; i >= 0l; i = i - 1l)
        {
          result = result >> 1;
          if(!((1ul & bm[(signed long int)((unsigned long int)i / sizeof(unsigned long int) * 8 /*64ul*/ )] >> (unsigned long int)i % sizeof(unsigned long int) * 8 /*64ul*/ ) == 0ul))
            result = result | (unsigned long int)1 << (unsigned long int)64 - (unsigned long int)1;

        }
        result = result | (unsigned long int)1;
        return result;
      }

      else
      {
        signed long int index;
        index=GC_add_ext_descriptor(bm, (unsigned long int)last_set_bit + (unsigned long int)1);
        if(index == -1l)
          return (unsigned long int)(last_set_bit + (signed long int)1 << 3 | (signed long int)0);

        result = ((unsigned long int)index << 6 | (unsigned long int)GC_typed_mark_proc_index) << 2 | (unsigned long int)2;
        return result;
      }
  }
}

// GC_make_disappearing_links_disappear
// file finalize.c line 702
static inline void GC_make_disappearing_links_disappear(struct dl_hashtbl_s *dl_hashtbl)
{
  struct disappearing_link *curr;
  struct disappearing_link *prev;
  struct disappearing_link *next;
  char *real_ptr;
  char *real_link;
  unsigned long int i;
  unsigned long int dl_size;
  signed int tmp_if_expr_1;
  if(dl_hashtbl->log_size == -1l)
    tmp_if_expr_1 = 0;

  else
    tmp_if_expr_1 = 1 << dl_hashtbl->log_size;
  dl_size = (unsigned long int)tmp_if_expr_1;
  i = (unsigned long int)0;
  for( ; !(i >= dl_size); i = i + 1ul)
  {
    curr = dl_hashtbl->head[(signed long int)i];
    prev = (struct disappearing_link *)(void *)0;
    while(!(curr == ((struct disappearing_link *)NULL)))
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr->dl_hidden_obj);
      real_link = (char *)(void *)~((unsigned long int)curr->prolog.hidden_key);
      signed int return_value_GC_is_marked_2;
      return_value_GC_is_marked_2=GC_is_marked((const void *)real_ptr);
      if(return_value_GC_is_marked_2 == 0)
      {
        *((unsigned long int *)real_link) = (unsigned long int)0;
        GC_clear_mark_bit((const void *)curr);
        next = (struct disappearing_link *)curr->prolog.next;
        if(prev == ((struct disappearing_link *)NULL))
          dl_hashtbl->head[(signed long int)i] = next;

        else
          prev->prolog.next = (struct hash_chain_entry *)next;
        GC_clear_mark_bit((const void *)curr);
        dl_hashtbl->entries = dl_hashtbl->entries - 1ul;
        curr = next;
      }

      else
      {
        prev = curr;
        curr = (struct disappearing_link *)curr->prolog.next;
      }
    }
  }
}

// GC_make_sequence_descriptor
// file typd_mlc.c line 303
union ComplexDescriptor * GC_make_sequence_descriptor(union ComplexDescriptor *first, union ComplexDescriptor *second)
{
  struct SequenceDescriptor *result;
  void *return_value_GC_malloc_1;
  return_value_GC_malloc_1=GC_malloc(sizeof(struct SequenceDescriptor) /*24ul*/ );
  result = (struct SequenceDescriptor *)return_value_GC_malloc_1;
  if(!(result == ((struct SequenceDescriptor *)NULL)))
  {
    result->sd_tag = (unsigned long int)3;
    result->sd_first = first;
    result->sd_second = second;
  }

  return (union ComplexDescriptor *)result;
}

// GC_malloc
// file ./include/gc.h line 412
extern void * GC_malloc(unsigned long int bytes)
{
  unsigned long int granules = bytes + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  void *tsd;
  void *result;
  void **tiny_fl;
  void *k = GC_thread_key;
  if(k == NULL)
  {
    void *return_value_GC_core_malloc_1;
    return_value_GC_core_malloc_1=GC_core_malloc(bytes);
    return return_value_GC_core_malloc_1;
  }

  tsd = k;
  tiny_fl = ((struct thread_local_freelists *)tsd)->normal_freelists;
  do
  {
    if(granules >= 25ul)
      result=GC_core_malloc(bytes);

    else
    {
      void **my_fl = tiny_fl + (signed long int)granules;
      void *my_entry = *my_fl;
      void *next;
      while(!((unsigned long int)my_entry >= 283ul))
        if(!((unsigned long int)my_entry + 18446744073709551615ul >= 256ul))
        {
          *my_fl = (void *)((char *)my_entry + (signed long int)granules + (signed long int)1);
          result=GC_core_malloc(bytes);
          goto out;
        }

        else
        {
          GC_generic_malloc_many(granules == (unsigned long int)0 ? (unsigned long int)16 : granules * (unsigned long int)16, 1, my_fl);
          my_entry = *my_fl;
          if(my_entry == NULL)
          {
            void * (*return_value_GC_get_oom_fn_2)(unsigned long int);
            return_value_GC_get_oom_fn_2=GC_get_oom_fn();
            result=return_value_GC_get_oom_fn_2(granules * (unsigned long int)16);
          }

        }
      next = *((void **)my_entry);
      result = (void *)my_entry;
      *my_fl = next;
      *((void **)result) = NULL;
    }

  out:
    ;
  }
  while((_Bool)0);
  return result;
}

// GC_malloc_atomic
// file ./include/gc.h line 414
extern void * GC_malloc_atomic(unsigned long int bytes)
{
  unsigned long int granules = bytes + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  void *tsd;
  void *result;
  void **tiny_fl;
  void *k = GC_thread_key;
  if(k == NULL)
  {
    void *return_value_GC_core_malloc_atomic_1;
    return_value_GC_core_malloc_atomic_1=GC_core_malloc_atomic(bytes);
    return return_value_GC_core_malloc_atomic_1;
  }

  tsd = k;
  tiny_fl = ((struct thread_local_freelists *)tsd)->ptrfree_freelists;
  do
  {
    if(granules >= 25ul)
      result=GC_core_malloc_atomic(bytes);

    else
    {
      void **my_fl = tiny_fl + (signed long int)granules;
      void *my_entry = *my_fl;
      void *next;
      while(!((unsigned long int)my_entry >= 283ul))
        if(!((unsigned long int)my_entry + 18446744073709551615ul >= 256ul))
        {
          *my_fl = (void *)((char *)my_entry + (signed long int)granules + (signed long int)1);
          result=GC_core_malloc_atomic(bytes);
          goto out;
        }

        else
        {
          GC_generic_malloc_many(granules == (unsigned long int)0 ? (unsigned long int)16 : granules * (unsigned long int)16, 0, my_fl);
          my_entry = *my_fl;
          if(my_entry == NULL)
          {
            void * (*return_value_GC_get_oom_fn_2)(unsigned long int);
            return_value_GC_get_oom_fn_2=GC_get_oom_fn();
            result=return_value_GC_get_oom_fn_2(granules * (unsigned long int)16);
          }

        }
      next = *((void **)my_entry);
      result = (void *)my_entry;
      *my_fl = next;
    }

  out:
    ;
  }
  while((_Bool)0);
  return result;
}

// GC_malloc_atomic_ignore_off_page
// file ./include/private/../gc.h line 745
extern void * GC_malloc_atomic_ignore_off_page(unsigned long int lb)
{
  void *return_value_GC_generic_malloc_ignore_off_page_1;
  return_value_GC_generic_malloc_ignore_off_page_1=GC_generic_malloc_ignore_off_page(lb, 0);
  return (void *)return_value_GC_generic_malloc_ignore_off_page_1;
}

// GC_malloc_atomic_uncollectable
// file ./include/private/../gc.h line 758
extern void * GC_malloc_atomic_uncollectable(unsigned long int lb)
{
  void *op;
  void **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    if(!(GC_all_interior_pointers == 0) && !(lb == 0ul))
      lb = lb - 1ul;

    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_arrays._auobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(!(op == NULL))
    {
      *opp = *((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      GC_non_gc_bytes = GC_non_gc_bytes + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }

    else
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc_2;
      return_value_GC_generic_malloc_2=GC_generic_malloc(lb, 3);
      op = (void *)(char *)return_value_GC_generic_malloc_2;
    }
    return (void *)op;
  }

  else
  {
    struct hblkhdr *hhdr;
    void *return_value_GC_generic_malloc_3;
    return_value_GC_generic_malloc_3=GC_generic_malloc(lb, 3);
    op = (void *)(char *)return_value_GC_generic_malloc_3;
    if(op == NULL)
      return NULL;

    hhdr=GC_find_header((char *)op);
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_4;
        return_value_pthread_mutex_trylock_4=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_4 == 0))
          GC_lock();

      }

    while((_Bool)0);
    hhdr->_mark_byte_union._hb_marks[(signed long int)0] = (char)1;
    hhdr->hb_n_marks = (volatile unsigned long int)1;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return (void *)op;
  }
}

// GC_malloc_explicitly_typed
// file typd_mlc.c line 584
extern void * GC_malloc_explicitly_typed(unsigned long int lb, unsigned long int d)
{
  char *op;
  char **opp;
  unsigned long int lg;
  lb = lb + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)GC_all_interior_pointers);
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_eobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc_2;
      return_value_GC_generic_malloc_2=GC_generic_malloc((unsigned long int)lb, GC_explicit_kind);
      void *return_value_GC_clear_stack_3;
      return_value_GC_clear_stack_3=GC_clear_stack(return_value_GC_generic_malloc_2);
      op = (char *)return_value_GC_clear_stack_3;
      if(op == ((char *)NULL))
        return NULL;

      lg = GC_arrays._size_map[(signed long int)lb];
    }

    else
    {
      *opp = (char *)*((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
    ((unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = d;
  }

  else
  {
    void *return_value_GC_generic_malloc_4;
    return_value_GC_generic_malloc_4=GC_generic_malloc((unsigned long int)lb, GC_explicit_kind);
    void *return_value_GC_clear_stack_5;
    return_value_GC_clear_stack_5=GC_clear_stack(return_value_GC_generic_malloc_4);
    op = (char *)return_value_GC_clear_stack_5;
    if(!(op == ((char *)NULL)))
    {
      unsigned long int return_value_GC_size_6;
      return_value_GC_size_6=GC_size((const void *)op);
      lg = return_value_GC_size_6 >> 4;
      ((unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = d;
    }

  }
  return (void *)op;
}

// GC_malloc_explicitly_typed_ignore_off_page
// file typd_mlc.c line 622
extern void * GC_malloc_explicitly_typed_ignore_off_page(unsigned long int lb, unsigned long int d)
{
  char *op;
  char **opp;
  unsigned long int lg;
  lb = lb + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)GC_all_interior_pointers);
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_eobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc_ignore_off_page_2;
      return_value_GC_generic_malloc_ignore_off_page_2=GC_generic_malloc_ignore_off_page(lb, GC_explicit_kind);
      void *return_value_GC_clear_stack_3;
      return_value_GC_clear_stack_3=GC_clear_stack(return_value_GC_generic_malloc_ignore_off_page_2);
      op = (char *)return_value_GC_clear_stack_3;
      if(op == ((char *)NULL))
        return NULL;

      lg = GC_arrays._size_map[(signed long int)lb];
    }

    else
    {
      *opp = (char *)*((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
    ((unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = d;
  }

  else
  {
    void *return_value_GC_generic_malloc_ignore_off_page_4;
    return_value_GC_generic_malloc_ignore_off_page_4=GC_generic_malloc_ignore_off_page(lb, GC_explicit_kind);
    void *return_value_GC_clear_stack_5;
    return_value_GC_clear_stack_5=GC_clear_stack(return_value_GC_generic_malloc_ignore_off_page_4);
    op = (char *)return_value_GC_clear_stack_5;
    if(!(op == ((char *)NULL)))
    {
      unsigned long int return_value_GC_size_6;
      return_value_GC_size_6=GC_size((const void *)op);
      lg = return_value_GC_size_6 >> 4;
      ((unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = d;
    }

  }
  return (void *)op;
}

// GC_malloc_ignore_off_page
// file ./include/private/../gc.h line 743
extern void * GC_malloc_ignore_off_page(unsigned long int lb)
{
  void *return_value_GC_generic_malloc_ignore_off_page_1;
  return_value_GC_generic_malloc_ignore_off_page_1=GC_generic_malloc_ignore_off_page(lb, 1);
  return (void *)return_value_GC_generic_malloc_ignore_off_page_1;
}

// GC_malloc_many
// file mallocx.c line 438
extern void * GC_malloc_many(unsigned long int lb)
{
  void *result;
  GC_generic_malloc_many((lb + (unsigned long int)GC_all_interior_pointers + (unsigned long int)16) - (unsigned long int)1 & (unsigned long int)~(16 - 1), 1, &result);
  return result;
}

// GC_malloc_stubborn
// file stubborn.c line 43
extern void * GC_malloc_stubborn(unsigned long int lb)
{
  void *return_value_GC_malloc_1;
  return_value_GC_malloc_1=GC_malloc(lb);
  return return_value_GC_malloc_1;
}

// GC_malloc_uncollectable
// file ./include/private/../gc.h line 419
extern void * GC_malloc_uncollectable(unsigned long int lb)
{
  void *op;
  void **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    if(!(GC_all_interior_pointers == 0) && !(lb == 0ul))
      lb = lb - 1ul;

    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_arrays._uobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(!(op == NULL))
    {
      *opp = *((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      GC_non_gc_bytes = GC_non_gc_bytes + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }

    else
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc_2;
      return_value_GC_generic_malloc_2=GC_generic_malloc((unsigned long int)lb, 2);
      op = (void *)(char *)return_value_GC_generic_malloc_2;
    }
    return (void *)op;
  }

  else
  {
    struct hblkhdr *hhdr;
    void *return_value_GC_generic_malloc_3;
    return_value_GC_generic_malloc_3=GC_generic_malloc((unsigned long int)lb, 2);
    op = (void *)(char *)return_value_GC_generic_malloc_3;
    if(op == NULL)
      return NULL;

    hhdr=GC_find_header((char *)op);
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_4;
        return_value_pthread_mutex_trylock_4=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_4 == 0))
          GC_lock();

      }

    while((_Bool)0);
    hhdr->_mark_byte_union._hb_marks[(signed long int)0] = (char)1;
    hhdr->hb_n_marks = (volatile unsigned long int)1;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return (void *)op;
  }
}

// GC_mark_and_push
// file ./include/private/../gc_mark.h line 145
extern struct GC_ms_entry * GC_mark_and_push(void *obj, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, void **src)
{
  struct hblkhdr *hhdr;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)obj >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)obj >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    hhdr = *_ha;
  }
  while((_Bool)0);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  void *return_value_GC_base_1;
  if(!((unsigned long int)hhdr >= 4096ul))
  {
    if(GC_all_interior_pointers == 0)
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_GC_base_1=GC_base(obj);
      hhdr=GC_find_header((char *)return_value_GC_base_1);
      tmp_if_expr_2 = (struct hblkhdr *)(void *)0 == hhdr ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed long int)(((signed int)hhdr->hb_flags & 4) != 0) != 0l ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
  {
    if(!(GC_all_interior_pointers == 0))
      GC_add_to_black_list_stack((unsigned long int)obj);

    else
      GC_add_to_black_list_normal((unsigned long int)obj);
    return mark_stack_ptr;
  }

  else
  {
    do
    {
      unsigned long int displ = (unsigned long int)obj & (unsigned long int)(1 << 12) - (unsigned long int)1;
      unsigned long int gran_displ = displ >> 4;
      unsigned long int gran_offset = (unsigned long int)hhdr->hb_map[(signed long int)gran_displ];
      unsigned long int byte_offset = displ & (unsigned long int)(16 - 1);
      char *base = (char *)obj;
      if(!((byte_offset | gran_offset) == 0ul))
      {
        if(!(hhdr->hb_large_block == 0))
        {
          unsigned long int obj_displ;
          base = (char *)hhdr->hb_block;
          obj_displ = (unsigned long int)((char *)obj - base);
          if(obj_displ == displ)
          {
            if(GC_arrays._valid_offsets[(signed long int)obj_displ] == 0)
            {
              if(!(GC_all_interior_pointers == 0))
                GC_add_to_black_list_stack((unsigned long int)obj);

              else
                GC_add_to_black_list_normal((unsigned long int)obj);
              break;
            }

          }

          gran_displ = (unsigned long int)0;
        }

        else
        {
          unsigned long int GC_mark_and_push__1__3__1__2__obj_displ = (gran_offset << 4) + byte_offset;
          if(GC_arrays._valid_offsets[(signed long int)GC_mark_and_push__1__3__1__2__obj_displ] == 0)
          {
            if(!(GC_all_interior_pointers == 0))
              GC_add_to_black_list_stack((unsigned long int)obj);

            else
              GC_add_to_black_list_normal((unsigned long int)obj);
            break;
          }

          gran_displ = gran_displ - gran_offset;
          base = base - (signed long int)GC_mark_and_push__1__3__1__2__obj_displ;
        }
      }

      do
      {
        char *mark_byte_addr = (char *)hhdr->_mark_byte_union._hb_marks + (signed long int)gran_displ;
        if(!(*mark_byte_addr == 0))
          goto was_marked;

        *mark_byte_addr = (char)1;
      }
      while((_Bool)0);
      unsigned long int return_value_AO_load_5;
      return_value_AO_load_5=AO_load_link1(&hhdr->hb_n_marks);
      AO_store(&hhdr->hb_n_marks, return_value_AO_load_5 + (unsigned long int)1);
      do
      {
        unsigned long int _descr = hhdr->hb_descr;
        if(!(_descr == 0ul))
        {
          mark_stack_ptr = mark_stack_ptr + 1l;
          if((unsigned long int)mark_stack_ptr >= (unsigned long int)mark_stack_limit)
            mark_stack_ptr=GC_signal_mark_stack_overflow(mark_stack_ptr);

          mark_stack_ptr->mse_start = base;
          mark_stack_ptr->mse_descr.w = _descr;
        }

      }
      while((_Bool)0);
    }
    while((_Bool)0);

  was_marked:
    ;
    return mark_stack_ptr;
  }
}

// GC_mark_and_push_stack
// file mark.c line 1393
void GC_mark_and_push_stack(char *p)
{
  struct hblkhdr *hhdr;
  char *r = p;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)p >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)p >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    hhdr = *_ha;
  }
  while((_Bool)0);
  if(!((unsigned long int)hhdr >= 4096ul))
  {
    if(!(hhdr == ((struct hblkhdr *)NULL)))
    {
      void *return_value_GC_base_1;
      return_value_GC_base_1=GC_base((void *)p);
      r = (char *)return_value_GC_base_1;
      hhdr=GC_find_header((char *)r);
    }

    if(!(hhdr == ((struct hblkhdr *)NULL)))
      goto __CPROVER_DUMP_L7;

    GC_add_to_black_list_stack((unsigned long int)p);
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if(!((4 & (signed int)hhdr->hb_flags) == 0))
    {
      if(!(GC_all_interior_pointers == 0))
        GC_add_to_black_list_stack((unsigned long int)p);

      else
        GC_add_to_black_list_normal((unsigned long int)p);
    }

    else
      do
      {
        unsigned long int displ = (unsigned long int)r & (unsigned long int)(1 << 12) - (unsigned long int)1;
        unsigned long int gran_displ = displ >> 4;
        unsigned long int gran_offset = (unsigned long int)hhdr->hb_map[(signed long int)gran_displ];
        unsigned long int byte_offset = displ & (unsigned long int)(16 - 1);
        char *base = r;
        if(!((byte_offset | gran_offset) == 0ul))
        {
          if(!(hhdr->hb_large_block == 0))
          {
            unsigned long int obj_displ;
            base = (char *)hhdr->hb_block;
            obj_displ = (unsigned long int)((char *)r - base);
            gran_displ = (unsigned long int)0;
          }

          else
          {
            unsigned long int GC_mark_and_push_stack__1__4__1__2__obj_displ = (gran_offset << 4) + byte_offset;
            gran_displ = gran_displ - gran_offset;
            base = base - (signed long int)GC_mark_and_push_stack__1__4__1__2__obj_displ;
          }
        }

        do
        {
          char *mark_byte_addr = (char *)hhdr->_mark_byte_union._hb_marks + (signed long int)gran_displ;
          if(!(*mark_byte_addr == 0))
            goto mark_and_push_exit;

          *mark_byte_addr = (char)1;
        }
        while((_Bool)0);
        unsigned long int return_value_AO_load_2;
        return_value_AO_load_2=AO_load_link1(&hhdr->hb_n_marks);
        AO_store(&hhdr->hb_n_marks, return_value_AO_load_2 + (unsigned long int)1);
        do
        {
          unsigned long int _descr = hhdr->hb_descr;
          if(!(_descr == 0ul))
          {
            GC_arrays._mark_stack_top = GC_arrays._mark_stack_top + 1l;
            if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack_limit)
              GC_arrays._mark_stack_top=GC_signal_mark_stack_overflow(GC_arrays._mark_stack_top);

            GC_arrays._mark_stack_top->mse_start = base;
            GC_arrays._mark_stack_top->mse_descr.w = _descr;
          }

        }
        while((_Bool)0);
      }
      while((_Bool)0);
  }

mark_and_push_exit:
  ;
}

// GC_mark_from
// file ./include/private/gc_pmark.h line 400
struct GC_ms_entry * GC_mark_from(struct GC_ms_entry *mark_stack_top, struct GC_ms_entry *mark_stack, struct GC_ms_entry *mark_stack_limit)
{
  signed long int credit = (signed long int)(unsigned long int)(1 << 12);
  char *current_p;
  unsigned long int current;
  char *limit;
  unsigned long int descr;
  char *greatest_ha = (char *)GC_greatest_plausible_heap_addr;
  char *least_ha = (char *)GC_least_plausible_heap_addr;
  struct hce hdr_cache[8l];
  GC_objects_are_marked = 1;
  memset((void *)hdr_cache, 0, (unsigned long int)sizeof(struct hce [8l]) /*128ul*/ );
  unsigned long int tag;
  while(((char *)mark_stack_top - (char *)mark_stack | credit) >= 0l)
  {
    current_p = mark_stack_top->mse_start;
    descr = mark_stack_top->mse_descr.w;

  retry:
    ;
    while((_Bool)1)
    {
      if((18446744073709550595ul & descr) == 0ul)
        goto __CPROVER_DUMP_L35;

      tag = descr & (unsigned long int)((1 << 2) - 1);
      if(!(tag == 0ul))
      {
        if(tag == 1ul)
          goto __CPROVER_DUMP_L5;

        if(tag == 2ul)
          goto __CPROVER_DUMP_L27;

        if(tag == 3ul)
          goto __CPROVER_DUMP_L28;

        break;
      }

      if(descr >= 2049ul && !(GC_parallel == 0) && !((unsigned long int)mark_stack_top >= (unsigned long int)(mark_stack_limit + -1l)))
      {
        signed int new_size = (signed int)(descr / (unsigned long int)2 & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
        mark_stack_top->mse_start = current_p;
        mark_stack_top->mse_descr.w = (unsigned long int)new_size + sizeof(unsigned long int) /*8ul*/ ;
        mark_stack_top = mark_stack_top + 1l;
        current_p = current_p + (signed long int)new_size;
        descr = descr - (unsigned long int)new_size;
        goto retry;
      }

      limit = current_p + (signed long int)(128 - 1 << 3);
      mark_stack_top->mse_start = limit;
      mark_stack_top->mse_descr.w = descr - (unsigned long int)(128 - 1 << 3);
      limit = limit + (signed long int)(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)8);
      goto __CPROVER_DUMP_L34;

    __CPROVER_DUMP_L5:
      ;
      mark_stack_top = mark_stack_top - 1l;
      descr = descr & (unsigned long int)~((1 << 2) - 1);
      credit = credit - (signed long int)((unsigned long int)64 / (unsigned long int)2 << 3);
      for( ; !(descr == 0ul); current_p = current_p + (signed long int)sizeof(unsigned long int) /*8ul*/ )
      {
        if(!((signed long int)descr >= 0l))
        {
          current = *((unsigned long int *)current_p);
          if(current >= (unsigned long int)least_ha && !(current >= (unsigned long int)greatest_ha))
            do
            {
              struct hblkhdr *GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr;
              do
              {
                struct hce *GC_mark_from__1__1__1__1__2__1__1__1__1__hce = hdr_cache + (signed long int)((unsigned long int)(char *)current >> (unsigned long int)12 & (unsigned long int)(8 - 1));
                if(GC_mark_from__1__1__1__1__2__1__1__1__1__hce->block_addr == current >> 12ul)
                  GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr = GC_mark_from__1__1__1__1__2__1__1__1__1__hce->hce_hdr;

                else
                {
                  GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr=GC_header_cache_miss((char *)current, GC_mark_from__1__1__1__1__2__1__1__1__1__hce);
                  if(GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr == ((struct hblkhdr *)NULL))
                    goto exit1;

                }
              }
              while((_Bool)0);
              do
              {
                unsigned long int displ = (unsigned long int)(char *)current & (unsigned long int)(1 << 12) - (unsigned long int)1;
                unsigned long int GC_mark_from__1__1__1__1__2__1__1__1__2__gran_displ = displ >> 4;
                unsigned long int gran_offset = (unsigned long int)GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr->hb_map[(signed long int)GC_mark_from__1__1__1__1__2__1__1__1__2__gran_displ];
                unsigned long int byte_offset = displ & (unsigned long int)(16 - 1);
                char *GC_mark_from__1__1__1__1__2__1__1__1__2__base = (char *)current;
                if(!((byte_offset | gran_offset) == 0ul))
                {
                  if(!(GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr->hb_large_block == 0))
                  {
                    unsigned long int GC_mark_from__1__1__1__1__2__1__1__1__2__1__1__obj_displ;
                    GC_mark_from__1__1__1__1__2__1__1__1__2__base = (char *)GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr->hb_block;
                    GC_mark_from__1__1__1__1__2__1__1__1__2__1__1__obj_displ = (unsigned long int)((char *)current - GC_mark_from__1__1__1__1__2__1__1__1__2__base);
                    if(GC_mark_from__1__1__1__1__2__1__1__1__2__1__1__obj_displ == displ)
                    {
                      if(GC_arrays._valid_offsets[(signed long int)GC_mark_from__1__1__1__1__2__1__1__1__2__1__1__obj_displ] == 0)
                      {
                        if(!(GC_all_interior_pointers == 0))
                          GC_add_to_black_list_stack((unsigned long int)(char *)current);

                        else
                          GC_add_to_black_list_normal((unsigned long int)(char *)current);
                        break;
                      }

                    }

                    GC_mark_from__1__1__1__1__2__1__1__1__2__gran_displ = (unsigned long int)0;
                  }

                  else
                  {
                    unsigned long int GC_mark_from__1__1__1__1__2__1__1__1__2__1__2__obj_displ = (gran_offset << 4) + byte_offset;
                    if(GC_arrays._valid_offsets[(signed long int)GC_mark_from__1__1__1__1__2__1__1__1__2__1__2__obj_displ] == 0)
                    {
                      if(!(GC_all_interior_pointers == 0))
                        GC_add_to_black_list_stack((unsigned long int)(char *)current);

                      else
                        GC_add_to_black_list_normal((unsigned long int)(char *)current);
                      break;
                    }

                    GC_mark_from__1__1__1__1__2__1__1__1__2__gran_displ = GC_mark_from__1__1__1__1__2__1__1__1__2__gran_displ - gran_offset;
                    GC_mark_from__1__1__1__1__2__1__1__1__2__base = GC_mark_from__1__1__1__1__2__1__1__1__2__base - (signed long int)GC_mark_from__1__1__1__1__2__1__1__1__2__1__2__obj_displ;
                  }
                }

                do
                {
                  char *GC_mark_from__1__1__1__1__2__1__1__1__2__2__mark_byte_addr = (char *)GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr->_mark_byte_union._hb_marks + (signed long int)GC_mark_from__1__1__1__1__2__1__1__1__2__gran_displ;
                  if(!(*GC_mark_from__1__1__1__1__2__1__1__1__2__2__mark_byte_addr == 0))
                    goto exit1;

                  *GC_mark_from__1__1__1__1__2__1__1__1__2__2__mark_byte_addr = (char)1;
                }
                while((_Bool)0);
                unsigned long int return_value_AO_load_1;
                return_value_AO_load_1=AO_load_link1(&GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr->hb_n_marks);
                AO_store(&GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr->hb_n_marks, return_value_AO_load_1 + (unsigned long int)1);
                do
                {
                  unsigned long int GC_mark_from__1__1__1__1__2__1__1__1__2__3___descr = GC_mark_from__1__1__1__1__2__1__1__1__my_hhdr->hb_descr;
                  if(!(GC_mark_from__1__1__1__1__2__1__1__1__2__3___descr == 0ul))
                  {
                    mark_stack_top = mark_stack_top + 1l;
                    if((unsigned long int)mark_stack_top >= (unsigned long int)mark_stack_limit)
                      mark_stack_top=GC_signal_mark_stack_overflow(mark_stack_top);

                    mark_stack_top->mse_start = GC_mark_from__1__1__1__1__2__1__1__1__2__base;
                    mark_stack_top->mse_descr.w = GC_mark_from__1__1__1__1__2__1__1__1__2__3___descr;
                  }

                }
                while((_Bool)0);
              }
              while((_Bool)0);

            exit1:
              ;
            }
            while((_Bool)0);

        }

        descr = descr << 1;
      }
      goto __CPROVER_DUMP_L79;

    __CPROVER_DUMP_L27:
      ;
      mark_stack_top = mark_stack_top - 1l;
      credit = credit - (signed long int)100;
      mark_stack_top=GC_arrays._mark_procs[(signed long int)(descr >> 2 & (unsigned long int)((1 << 6) - 1))]((unsigned long int *)current_p, mark_stack_top, mark_stack_limit, descr >> 2 + 6);

    __CPROVER_DUMP_L28:
      ;
      if((signed long int)descr >= 0l)
        descr = *((unsigned long int *)((current_p + (signed long int)descr) - (signed long int)3));

      else
      {
        char *type_descr = *((char **)current_p);
        if(type_descr == ((char *)NULL))
        {
          mark_stack_top = mark_stack_top - 1l;
          goto __CPROVER_DUMP_L79;
        }

        descr = *((unsigned long int *)(type_descr - (signed long int)(descr + (unsigned long int)(0x10 - 3))));
      }
      if(descr == 0ul)
      {
        mark_stack_top = mark_stack_top - 1l;
        goto __CPROVER_DUMP_L79;
      }

    }
    limit = ((char *)NULL);
    if(!((signed long int)GC_current_warn_proc == -1l))
    {
      GC_on_abort("GC_mark_from: bad state");
      abort();
    }


  __CPROVER_DUMP_L34:
    ;
    goto __CPROVER_DUMP_L36;

  __CPROVER_DUMP_L35:
    ;
    mark_stack_top = mark_stack_top - 1l;
    if(descr >= sizeof(unsigned long int) /*8ul*/ )
    {
      limit = current_p + (signed long int)(unsigned long int)descr;

    __CPROVER_DUMP_L36:
      ;
      credit = credit - (limit - current_p);
      limit = limit - (signed long int)sizeof(unsigned long int) /*8ul*/ ;
      unsigned long int deferred;
      do
      {
        deferred = *((unsigned long int *)limit);
        limit = limit - (signed long int)8;
        if(deferred >= (unsigned long int)least_ha && !(deferred >= (unsigned long int)greatest_ha))
          break;

        if(!((unsigned long int)limit >= (unsigned long int)current_p))
          goto next_object;

        deferred = *((unsigned long int *)limit);
        limit = limit - (signed long int)8;
        if(deferred >= (unsigned long int)least_ha && !(deferred >= (unsigned long int)greatest_ha))
          break;

        if(!((unsigned long int)limit >= (unsigned long int)current_p))
          goto next_object;

      }
      while((_Bool)1);
      for( ; (unsigned long int)limit >= (unsigned long int)current_p; current_p = current_p + (signed long int)8)
      {
        current = *((unsigned long int *)current_p);
        if(current >= (unsigned long int)least_ha && !(current >= (unsigned long int)greatest_ha))
          do
          {
            struct hblkhdr *GC_mark_from__1__1__3__2__1__1__my_hhdr;
            do
            {
              struct hce *hce = hdr_cache + (signed long int)((unsigned long int)(char *)current >> (unsigned long int)12 & (unsigned long int)(8 - 1));
              if(hce->block_addr == current >> 12ul)
                GC_mark_from__1__1__3__2__1__1__my_hhdr = hce->hce_hdr;

              else
              {
                GC_mark_from__1__1__3__2__1__1__my_hhdr=GC_header_cache_miss((char *)current, hce);
                if(GC_mark_from__1__1__3__2__1__1__my_hhdr == ((struct hblkhdr *)NULL))
                  goto exit2;

              }
            }
            while((_Bool)0);
            do
            {
              unsigned long int GC_mark_from__1__1__3__2__1__1__2__displ = (unsigned long int)(char *)current & (unsigned long int)(1 << 12) - (unsigned long int)1;
              unsigned long int GC_mark_from__1__1__3__2__1__1__2__gran_displ = GC_mark_from__1__1__3__2__1__1__2__displ >> 4;
              unsigned long int GC_mark_from__1__1__3__2__1__1__2__gran_offset = (unsigned long int)GC_mark_from__1__1__3__2__1__1__my_hhdr->hb_map[(signed long int)GC_mark_from__1__1__3__2__1__1__2__gran_displ];
              unsigned long int GC_mark_from__1__1__3__2__1__1__2__byte_offset = GC_mark_from__1__1__3__2__1__1__2__displ & (unsigned long int)(16 - 1);
              char *base = (char *)current;
              if(!((GC_mark_from__1__1__3__2__1__1__2__byte_offset | GC_mark_from__1__1__3__2__1__1__2__gran_offset) == 0ul))
              {
                if(!(GC_mark_from__1__1__3__2__1__1__my_hhdr->hb_large_block == 0))
                {
                  unsigned long int obj_displ;
                  base = (char *)GC_mark_from__1__1__3__2__1__1__my_hhdr->hb_block;
                  obj_displ = (unsigned long int)((char *)current - base);
                  if(obj_displ == GC_mark_from__1__1__3__2__1__1__2__displ)
                  {
                    if(GC_arrays._valid_offsets[(signed long int)obj_displ] == 0)
                    {
                      if(!(GC_all_interior_pointers == 0))
                        GC_add_to_black_list_stack((unsigned long int)(char *)current);

                      else
                        GC_add_to_black_list_normal((unsigned long int)(char *)current);
                      break;
                    }

                  }

                  GC_mark_from__1__1__3__2__1__1__2__gran_displ = (unsigned long int)0;
                }

                else
                {
                  unsigned long int GC_mark_from__1__1__3__2__1__1__2__1__2__obj_displ = (GC_mark_from__1__1__3__2__1__1__2__gran_offset << 4) + GC_mark_from__1__1__3__2__1__1__2__byte_offset;
                  if(GC_arrays._valid_offsets[(signed long int)GC_mark_from__1__1__3__2__1__1__2__1__2__obj_displ] == 0)
                  {
                    if(!(GC_all_interior_pointers == 0))
                      GC_add_to_black_list_stack((unsigned long int)(char *)current);

                    else
                      GC_add_to_black_list_normal((unsigned long int)(char *)current);
                    break;
                  }

                  GC_mark_from__1__1__3__2__1__1__2__gran_displ = GC_mark_from__1__1__3__2__1__1__2__gran_displ - GC_mark_from__1__1__3__2__1__1__2__gran_offset;
                  base = base - (signed long int)GC_mark_from__1__1__3__2__1__1__2__1__2__obj_displ;
                }
              }

              do
              {
                char *GC_mark_from__1__1__3__2__1__1__2__2__mark_byte_addr = (char *)GC_mark_from__1__1__3__2__1__1__my_hhdr->_mark_byte_union._hb_marks + (signed long int)GC_mark_from__1__1__3__2__1__1__2__gran_displ;
                if(!(*GC_mark_from__1__1__3__2__1__1__2__2__mark_byte_addr == 0))
                  goto exit2;

                *GC_mark_from__1__1__3__2__1__1__2__2__mark_byte_addr = (char)1;
              }
              while((_Bool)0);
              unsigned long int return_value_AO_load_2;
              return_value_AO_load_2=AO_load_link1(&GC_mark_from__1__1__3__2__1__1__my_hhdr->hb_n_marks);
              AO_store(&GC_mark_from__1__1__3__2__1__1__my_hhdr->hb_n_marks, return_value_AO_load_2 + (unsigned long int)1);
              do
              {
                unsigned long int GC_mark_from__1__1__3__2__1__1__2__3___descr = GC_mark_from__1__1__3__2__1__1__my_hhdr->hb_descr;
                if(!(GC_mark_from__1__1__3__2__1__1__2__3___descr == 0ul))
                {
                  mark_stack_top = mark_stack_top + 1l;
                  if((unsigned long int)mark_stack_top >= (unsigned long int)mark_stack_limit)
                    mark_stack_top=GC_signal_mark_stack_overflow(mark_stack_top);

                  mark_stack_top->mse_start = base;
                  mark_stack_top->mse_descr.w = GC_mark_from__1__1__3__2__1__1__2__3___descr;
                }

              }
              while((_Bool)0);
            }
            while((_Bool)0);

          exit2:
            ;
          }
          while((_Bool)0);

      }
      do
      {
        struct hblkhdr *my_hhdr;
        do
        {
          struct hce *GC_mark_from__1__1__3__3__1__hce = hdr_cache + (signed long int)((unsigned long int)(char *)deferred >> (unsigned long int)12 & (unsigned long int)(8 - 1));
          if(GC_mark_from__1__1__3__3__1__hce->block_addr == deferred >> 12ul)
            my_hhdr = GC_mark_from__1__1__3__3__1__hce->hce_hdr;

          else
          {
            my_hhdr=GC_header_cache_miss((char *)deferred, GC_mark_from__1__1__3__3__1__hce);
            if(my_hhdr == ((struct hblkhdr *)NULL))
              goto exit4;

          }
        }
        while((_Bool)0);
        do
        {
          unsigned long int GC_mark_from__1__1__3__3__2__displ = (unsigned long int)(char *)deferred & (unsigned long int)(1 << 12) - (unsigned long int)1;
          unsigned long int gran_displ = GC_mark_from__1__1__3__3__2__displ >> 4;
          unsigned long int GC_mark_from__1__1__3__3__2__gran_offset = (unsigned long int)my_hhdr->hb_map[(signed long int)gran_displ];
          unsigned long int GC_mark_from__1__1__3__3__2__byte_offset = GC_mark_from__1__1__3__3__2__displ & (unsigned long int)(16 - 1);
          char *GC_mark_from__1__1__3__3__2__base = (char *)deferred;
          if(!((GC_mark_from__1__1__3__3__2__byte_offset | GC_mark_from__1__1__3__3__2__gran_offset) == 0ul))
          {
            if(!(my_hhdr->hb_large_block == 0))
            {
              unsigned long int GC_mark_from__1__1__3__3__2__1__1__obj_displ;
              GC_mark_from__1__1__3__3__2__base = (char *)my_hhdr->hb_block;
              GC_mark_from__1__1__3__3__2__1__1__obj_displ = (unsigned long int)((char *)deferred - GC_mark_from__1__1__3__3__2__base);
              if(GC_mark_from__1__1__3__3__2__1__1__obj_displ == GC_mark_from__1__1__3__3__2__displ)
              {
                if(GC_arrays._valid_offsets[(signed long int)GC_mark_from__1__1__3__3__2__1__1__obj_displ] == 0)
                {
                  if(!(GC_all_interior_pointers == 0))
                    GC_add_to_black_list_stack((unsigned long int)(char *)deferred);

                  else
                    GC_add_to_black_list_normal((unsigned long int)(char *)deferred);
                  break;
                }

              }

              gran_displ = (unsigned long int)0;
            }

            else
            {
              unsigned long int GC_mark_from__1__1__3__3__2__1__2__obj_displ = (GC_mark_from__1__1__3__3__2__gran_offset << 4) + GC_mark_from__1__1__3__3__2__byte_offset;
              if(GC_arrays._valid_offsets[(signed long int)GC_mark_from__1__1__3__3__2__1__2__obj_displ] == 0)
              {
                if(!(GC_all_interior_pointers == 0))
                  GC_add_to_black_list_stack((unsigned long int)(char *)deferred);

                else
                  GC_add_to_black_list_normal((unsigned long int)(char *)deferred);
                break;
              }

              gran_displ = gran_displ - GC_mark_from__1__1__3__3__2__gran_offset;
              GC_mark_from__1__1__3__3__2__base = GC_mark_from__1__1__3__3__2__base - (signed long int)GC_mark_from__1__1__3__3__2__1__2__obj_displ;
            }
          }

          do
          {
            char *mark_byte_addr = (char *)my_hhdr->_mark_byte_union._hb_marks + (signed long int)gran_displ;
            if(!(*mark_byte_addr == 0))
              goto exit4;

            *mark_byte_addr = (char)1;
          }
          while((_Bool)0);
          unsigned long int return_value_AO_load_3;
          return_value_AO_load_3=AO_load_link1(&my_hhdr->hb_n_marks);
          AO_store(&my_hhdr->hb_n_marks, return_value_AO_load_3 + (unsigned long int)1);
          do
          {
            unsigned long int _descr = my_hhdr->hb_descr;
            if(!(_descr == 0ul))
            {
              mark_stack_top = mark_stack_top + 1l;
              if((unsigned long int)mark_stack_top >= (unsigned long int)mark_stack_limit)
                mark_stack_top=GC_signal_mark_stack_overflow(mark_stack_top);

              mark_stack_top->mse_start = GC_mark_from__1__1__3__3__2__base;
              mark_stack_top->mse_descr.w = _descr;
            }

          }
          while((_Bool)0);
        }
        while((_Bool)0);

      exit4:
        ;
      }
      while((_Bool)0);
    }


  next_object:
    ;

  __CPROVER_DUMP_L79:
    ;
  }
  return mark_stack_top;
}

// GC_mark_init
// file mark.c line 1238
void GC_mark_init(void)
{
  alloc_mark_stack((unsigned long int)1 * (unsigned long int)(1 << 12));
}

// GC_mark_local
// file mark.c line 1014
void GC_mark_local(struct GC_ms_entry *local_mark_stack, signed int id)
{
  struct GC_ms_entry *my_first_nonempty;
  GC_acquire_mark_lock();
  GC_active_count = GC_active_count + 1u;
  unsigned long int return_value_AO_load_1;
  return_value_AO_load_1=AO_load_link1(&GC_first_nonempty);
  my_first_nonempty = (struct GC_ms_entry *)return_value_AO_load_1;
  if(GC_print_stats == 2)
    GC_log_printf("Starting mark helper %lu\n", (unsigned long int)id);

  GC_release_mark_lock();
  unsigned long int return_value_AO_load_4;
  unsigned long int return_value_AO_load_5;
  do
  {
    unsigned long int n_on_stack;
    unsigned int n_to_get;
    struct GC_ms_entry *my_top;
    struct GC_ms_entry *local_top;
    struct GC_ms_entry *global_first_nonempty;
    unsigned long int return_value_AO_load_2;
    return_value_AO_load_2=AO_load_link1(&GC_first_nonempty);
    global_first_nonempty = (struct GC_ms_entry *)return_value_AO_load_2;
    if(!((unsigned long int)my_first_nonempty >= (unsigned long int)global_first_nonempty))
      my_first_nonempty = global_first_nonempty;

    else
      if(!((unsigned long int)global_first_nonempty >= (unsigned long int)my_first_nonempty))
        AO_compare_and_swap_full_link1(&GC_first_nonempty, (unsigned long int)global_first_nonempty, (unsigned long int)my_first_nonempty);

    unsigned long int return_value_AO_load_read_3;
    return_value_AO_load_read_3=AO_load_read((volatile unsigned long int *)&GC_arrays._mark_stack_top);
    my_top = (struct GC_ms_entry *)return_value_AO_load_read_3;
    n_on_stack = (unsigned long int)((my_top - my_first_nonempty) + (signed long int)1);
    if(n_on_stack == 0ul)
    {
      GC_acquire_mark_lock();
      my_top = GC_arrays._mark_stack_top;
      n_on_stack = (unsigned long int)((my_top - my_first_nonempty) + (signed long int)1);
      if(n_on_stack == 0ul)
      {
        GC_active_count = GC_active_count - 1u;
        if(GC_active_count == 0u)
          GC_notify_all_marker();

        while(GC_active_count >= 1u)
        {
          return_value_AO_load_4=AO_load_link1(&GC_first_nonempty);
          if((unsigned long int)GC_arrays._mark_stack_top >= return_value_AO_load_4)
            break;

          GC_wait_marker();
        }
        if(GC_active_count == 0u)
        {
          return_value_AO_load_5=AO_load_link1(&GC_first_nonempty);
          if(!((unsigned long int)GC_arrays._mark_stack_top >= return_value_AO_load_5))
          {
            signed int need_to_notify = 0;
            GC_helper_count = GC_helper_count - 1u;
            if(GC_helper_count == 0u)
              need_to_notify = 1;

            if(GC_print_stats == 2)
              GC_log_printf("Finished mark helper %lu\n", (unsigned long int)id);

            GC_release_mark_lock();
            if(!(need_to_notify == 0))
              GC_notify_all_marker();

            break;
          }

        }

        GC_active_count = GC_active_count + 1u;
        GC_release_mark_lock();
        continue;
      }

      else
        GC_release_mark_lock();
    }

    n_to_get = (unsigned int)5;
    if(!(n_on_stack >= 10ul))
      n_to_get = (unsigned int)1;

    local_top=GC_steal_mark_stack(my_first_nonempty, my_top, local_mark_stack, n_to_get, &my_first_nonempty);
    GC_do_local_mark(local_mark_stack, local_top);
  }
  while((_Bool)1);
}

// GC_mark_some
// file ./include/private/gc_priv.h line 1560
signed int GC_mark_some(char *cold_gc_frame)
{
  switch(GC_mark_state)
  {
    case 0:
      break;
    case 1:
    {
      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)(GC_arrays._mark_stack_limit + -2048l))
      {
        GC_mark_stack_too_small = 1;
        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);
        break;
      }

      else
      {
        scan_ptr=GC_push_next_marked_dirty(scan_ptr);
        if(scan_ptr == ((struct hblk *)NULL))
        {
          if(!(GC_print_stats == 0))
            GC_log_printf("Marked from %lu dirty pages\n", (unsigned long int)GC_n_rescuing_pages);

          GC_push_roots(0, cold_gc_frame);
          GC_objects_are_marked = 1;
          if(!(GC_mark_state == 5))
            GC_mark_state = 3;

        }

      }
      break;
    }
    case 2:
    {
      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)(GC_arrays._mark_stack + (signed long int)(GC_mark_stack_size / 4ul)))
      {
        if(!(GC_parallel == 0))
          GC_mark_stack_too_small = 1;

        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);
        break;
      }

      else
      {
        scan_ptr=GC_push_next_marked_uncollectable(scan_ptr);
        if(scan_ptr == ((struct hblk *)NULL))
        {
          GC_push_roots(1, cold_gc_frame);
          GC_objects_are_marked = 1;
          if(!(GC_mark_state == 5))
            GC_mark_state = 3;

        }

      }
      break;
    }
    case 3:
    {
      if(!(GC_parallel == 0))
      {
        GC_do_parallel_mark();
        GC_arrays._mark_stack_top = GC_arrays._mark_stack - (signed long int)1;
        if(!(GC_mark_stack_too_small == 0))
          alloc_mark_stack((unsigned long int)2 * GC_mark_stack_size);

        if(GC_mark_state == 3)
        {
          GC_mark_state = 0;
          return 1;
        }

        break;
      }

      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
      {
        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);
        break;
      }

      else
      {
        GC_mark_state = 0;
        if(!(GC_mark_stack_too_small == 0))
          alloc_mark_stack((unsigned long int)2 * GC_mark_stack_size);

        return 1;
      }
    }
    case 5:

    case 4:
    {
      if(GC_objects_are_marked == 0)
      {
        GC_mark_state = 2;
        break;
      }

      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
      {
        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);
        break;
      }

      if(scan_ptr == ((struct hblk *)NULL) && GC_mark_state == 5)
      {
        if(!(GC_mark_stack_too_small == 0))
          alloc_mark_stack((unsigned long int)2 * GC_mark_stack_size);

        GC_mark_state = 4;
      }

      scan_ptr=GC_push_next_marked(scan_ptr);
      if(scan_ptr == ((struct hblk *)NULL) && GC_mark_state == 4)
      {
        GC_push_roots(1, cold_gc_frame);
        GC_objects_are_marked = 1;
        if(!(GC_mark_state == 5))
          GC_mark_state = 3;

      }

      break;
    }
    default:
      GC_on_abort("GC_mark_some: bad state");
  }
  abort();
  return 0;
}

// GC_mark_thread
// file pthread_support.c line 356
void * GC_mark_thread(void *id)
{
  unsigned long int my_mark_no = (unsigned long int)0;
  signed int cancel_state;
  if((unsigned long int)id == 18446744073709551615ul)
    return NULL;

  else
  {
    do
      pthread_setcancelstate(1, &cancel_state);
    while((_Bool)0);
    marker_sp[(signed long int)(unsigned long int)id]=GC_approx_sp();
    for( ; (_Bool)1; my_mark_no = my_mark_no + 1ul)
    {
      if(!(2ul + GC_mark_no >= my_mark_no) || !(my_mark_no >= GC_mark_no))
        my_mark_no = GC_mark_no;

      GC_help_marker(my_mark_no);
    }
  }
}

// GC_mark_thread_local_fls_for
// file thread_local_alloc.c line 285
void GC_mark_thread_local_fls_for(struct thread_local_freelists *p)
{
  char *q;
  signed int j = 0;
  for( ; !(j >= 25); j = j + 1)
  {
    q = (char *)p->ptrfree_freelists[(signed long int)j];
    if((unsigned long int)q >= 4097ul)
      GC_set_fl_marks(q);

    q = (char *)p->normal_freelists[(signed long int)j];
    if((unsigned long int)q >= 4097ul)
      GC_set_fl_marks(q);

    if(j >= 1)
    {
      q = (char *)p->gcj_freelists[(signed long int)j];
      if((unsigned long int)q >= 4097ul)
        GC_set_fl_marks(q);

    }

    q = (char *)p->finalized_freelists[(signed long int)j];
    if((unsigned long int)q >= 4097ul)
      GC_set_fl_marks(q);

  }
}

// GC_mark_thread_local_free_lists
// file ./include/private/gc_priv.h line 2197
void GC_mark_thread_local_free_lists(void)
{
  signed int i;
  struct GC_Thread_Rep *p;
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    p = GC_threads[(signed long int)i];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
      if((1 & (signed int)p->flags) == 0)
        GC_mark_thread_local_fls_for(&p->tlfs);

  }
}

// GC_max
// file alloc.c line 1132
static inline unsigned long int GC_max(unsigned long int x, unsigned long int y)
{
  return x > y ? x : y;
}

// GC_maybe_gc
// file alloc.c line 351
void GC_maybe_gc(void)
{
  signed int return_value_GC_should_collect_2;
  return_value_GC_should_collect_2=GC_should_collect();
  if(!(return_value_GC_should_collect_2 == 0))
  {
    static signed int n_partial_gcs = 0;
    if(GC_incremental == 0)
    {
      GC_try_to_collect_inner(GC_never_stop_func);
      n_partial_gcs = 0;
      goto __CPROVER_DUMP_L10;
    }

    else
    {
      if(!(GC_parallel == 0))
        GC_wait_for_reclaim();

      if(n_partial_gcs >= GC_full_freq || !(GC_need_full_gc == 0))
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("***>Full mark for collection #%lu after %lu allocd bytes\n", (unsigned long int)GC_gc_no + (unsigned long int)1, (unsigned long int)GC_arrays._bytes_allocd);

        GC_promote_black_lists();
        GC_reclaim_all((signed int (*)(void))0, 1);
        GC_notify_full_gc();
        GC_clear_marks();
        n_partial_gcs = 0;
        GC_is_full_gc = 1;
      }

      else
        n_partial_gcs = n_partial_gcs + 1;
    }
    if(!(GC_time_limit == 999999ul))
      GC_start_time=clock();

    signed int return_value_GC_stopped_mark_1;
    return_value_GC_stopped_mark_1=GC_stopped_mark(GC_time_limit == (unsigned long int)999999 ? GC_never_stop_func : GC_timeout_stop_func);
    if(!(return_value_GC_stopped_mark_1 == 0))
      GC_finish_collection();

    else
      if(GC_is_full_gc == 0)
        GC_n_attempts = GC_n_attempts + 1;

  }


__CPROVER_DUMP_L10:
  ;
}

// GC_memalign
// file mallocx.c line 451
extern void * GC_memalign(unsigned long int align, unsigned long int lb)
{
  unsigned long int new_lb;
  unsigned long int offset;
  char *result;
  void *return_value_GC_malloc_1;
  if(!(align >= 17ul))
  {
    return_value_GC_malloc_1=GC_malloc(lb);
    return return_value_GC_malloc_1;
  }

  if(align >= 2048ul || lb >= 2048ul)
  {
    if(align >= 4097ul)
    {
      void * (*return_value_GC_get_oom_fn_2)(unsigned long int);
      return_value_GC_get_oom_fn_2=GC_get_oom_fn();
      void *return_value;
      return_value=return_value_GC_get_oom_fn_2((unsigned long int)(0x7fffffffffffffffL - (signed long int)1024));
      return return_value;
    }

    void *return_value_GC_malloc_3;
    return_value_GC_malloc_3=GC_malloc(lb <= (unsigned long int)(1 << 12) ? (unsigned long int)(1 << 12) : lb);
    return return_value_GC_malloc_3;
  }

  new_lb = (lb + align) - (unsigned long int)1;
  void *return_value_GC_malloc_4;
  return_value_GC_malloc_4=GC_malloc(new_lb);
  result = (char *)return_value_GC_malloc_4;
  offset = (unsigned long int)result % align;
  void *return_value_GC_malloc_5;
  if(!(offset == 0ul))
  {
    offset = align - offset;
    if(GC_all_interior_pointers == 0)
    {
      if(offset >= 4096ul)
      {
        return_value_GC_malloc_5=GC_malloc((unsigned long int)(1 << 12));
        return return_value_GC_malloc_5;
      }

      GC_register_displacement(offset);
    }

  }

  result = (char *)(void *)((char *)result + (signed long int)offset);
  return (void *)result;
}

// GC_min
// file alloc.c line 1137
static inline unsigned long int GC_min(unsigned long int x, unsigned long int y)
{
  return x < y ? x : y;
}

// GC_move_disappearing_link
// file finalize.c line 343
extern signed int GC_move_disappearing_link(void **link, void **new_link)
{
  signed int result;
  if(new_link == ((void **)NULL) || !((7ul & (unsigned long int)new_link) == 0ul))
  {
    GC_on_abort("Bad new_link arg to GC_move_disappearing_link");
    abort();
  }

  if(!((7ul & (unsigned long int)link) == 0ul))
    return 4;

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    result=GC_move_disappearing_link_inner(&GC_dl_hashtbl, link, new_link);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return result;
  }
}

// GC_move_disappearing_link_inner
// file finalize.c line 292
signed int GC_move_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link, void **new_link)
{
  struct disappearing_link *curr_dl;
  struct disappearing_link *prev_dl;
  struct disappearing_link *new_dl;
  unsigned long int curr_index;
  unsigned long int new_index;
  unsigned long int curr_hidden_link;
  unsigned long int new_hidden_link;
  curr_index = ((unsigned long int)link >> 3 ^ (unsigned long int)link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
  curr_hidden_link = ~((unsigned long int)link);
  prev_dl = (struct disappearing_link *)(void *)0;
  curr_dl = dl_hashtbl->head[(signed long int)curr_index];
  for( ; !(curr_dl == ((struct disappearing_link *)NULL)); curr_dl = (struct disappearing_link *)curr_dl->prolog.next)
  {
    if(curr_dl->prolog.hidden_key == curr_hidden_link)
      break;

    prev_dl = curr_dl;
  }
  if(curr_dl == ((struct disappearing_link *)NULL))
    return 4;

  else
    if(link == new_link)
      return 0;

    else
    {
      new_index = ((unsigned long int)new_link >> 3 ^ (unsigned long int)new_link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
      new_hidden_link = ~((unsigned long int)new_link);
      new_dl = dl_hashtbl->head[(signed long int)new_index];
      for( ; !(new_dl == ((struct disappearing_link *)NULL)); new_dl = (struct disappearing_link *)new_dl->prolog.next)
        if(new_dl->prolog.hidden_key == new_hidden_link)
          return 1;

      if(prev_dl == ((struct disappearing_link *)NULL))
        dl_hashtbl->head[(signed long int)curr_index] = (struct disappearing_link *)curr_dl->prolog.next;

      else
        prev_dl->prolog.next = (struct hash_chain_entry *)(struct disappearing_link *)curr_dl->prolog.next;
      curr_dl->prolog.hidden_key = new_hidden_link;
      curr_dl->prolog.next = (struct hash_chain_entry *)dl_hashtbl->head[(signed long int)new_index];
      dl_hashtbl->head[(signed long int)new_index] = curr_dl;
      return 0;
    }
}

// GC_move_long_link
// file finalize.c line 360
extern signed int GC_move_long_link(void **link, void **new_link)
{
  signed int result;
  if(new_link == ((void **)NULL) || !((7ul & (unsigned long int)new_link) == 0ul))
  {
    GC_on_abort("Bad new_link arg to GC_move_disappearing_link");
    abort();
  }

  if(!((7ul & (unsigned long int)link) == 0ul))
    return 4;

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    result=GC_move_disappearing_link_inner(&GC_ll_hashtbl, link, new_link);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return result;
  }
}

// GC_n_set_marks
// file reclaim.c line 474
signed int GC_n_set_marks(struct hblkhdr *hhdr)
{
  signed int result = 0;
  signed int i;
  unsigned long int sz = hhdr->hb_sz;
  signed int offset = (signed int)(sz >> 4);
  signed int limit = (signed int)(sz > (unsigned long int)((1 << 12) / 2) ? (unsigned long int)(1 << 12) / (unsigned long int)16 : sz * ((unsigned long int)(1 << 12) / sz) >> 4);
  i = 0;
  for( ; !(i >= limit); i = i + offset)
    result = result + (signed int)hhdr->_mark_byte_union._hb_marks[(signed long int)i];
  return result;
}

// GC_never_stop_func
// file alloc.c line 125
signed int GC_never_stop_func(void)
{
  return 0;
}

// GC_new_free_list
// file misc.c line 1748
extern void ** GC_new_free_list(void)
{
  void *result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  void **return_value_GC_new_free_list_inner_2;
  return_value_GC_new_free_list_inner_2=GC_new_free_list_inner();
  result = (void *)return_value_GC_new_free_list_inner_2;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return (void **)result;
}

// GC_new_free_list_inner
// file ./include/private/../gc_mark.h line 168
extern void ** GC_new_free_list_inner(void)
{
  void *result;
  result=GC_generic_malloc_inner(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(char *) /*8ul*/ , 0);
  if(result == NULL)
  {
    GC_on_abort("Failed to allocate freelist for new kind");
    abort();
  }

  memset(result, 0, (unsigned long int)(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(char *) /*8ul*/ ));
  return (void **)result;
}

// GC_new_hblk
// file ./include/private/gc_priv.h line 1743
void GC_new_hblk(unsigned long int gran, signed int kind)
{
  struct hblk *h;
  signed int clear = GC_obj_kinds[(signed long int)kind].ok_init;
  if(!(GC_debugging_started == 0))
    clear = 1;

  h=GC_allochblk(gran << 4, kind, (unsigned int)0);
  struct hblkhdr *return_value_GC_find_header_1;
  if(!(h == ((struct hblk *)NULL)))
  {
    if((-2 & kind) == 2)
    {
      return_value_GC_find_header_1=GC_find_header((char *)h);
      GC_set_hdr_marks(return_value_GC_find_header_1);
    }

    char *return_value_GC_build_fl_2;
    return_value_GC_build_fl_2=GC_build_fl(h, gran << 1, clear, (char *)GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)gran]);
    GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)gran] = (void *)return_value_GC_build_fl_2;
  }

}

// GC_new_kind
// file misc.c line 1780
extern unsigned int GC_new_kind(void **fl, unsigned long int descr, signed int adjust, signed int clear)
{
  unsigned int result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result=GC_new_kind_inner(fl, descr, adjust, clear);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_new_kind_inner
// file ./include/private/../gc_mark.h line 176
extern unsigned int GC_new_kind_inner(void **fl, unsigned long int descr, signed int adjust, signed int clear)
{
  unsigned int result = GC_n_kinds;
  if(!(result >= 16u))
  {
    GC_n_kinds = GC_n_kinds + 1u;
    GC_obj_kinds[(signed long int)result].ok_freelist = fl;
    GC_obj_kinds[(signed long int)result].ok_reclaim_list = ((struct hblk **)NULL);
    GC_obj_kinds[(signed long int)result].ok_descriptor = descr;
    GC_obj_kinds[(signed long int)result].ok_relocate_descr = adjust;
    GC_obj_kinds[(signed long int)result].ok_init = (signed int)clear;
    GC_obj_kinds[(signed long int)result].ok_mark_unconditionally = 0;
    GC_obj_kinds[(signed long int)result].ok_disclaim_proc = ((signed int (*)(void *))NULL);
  }

  else
  {
    GC_on_abort("Too many kinds");
    abort();
  }
  return result;
}

// GC_new_proc
// file misc.c line 1804
extern unsigned int GC_new_proc(struct GC_ms_entry * (*proc)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int))
{
  unsigned int result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result=GC_new_proc_inner(proc);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_new_proc_inner
// file misc.c line 1791
extern unsigned int GC_new_proc_inner(struct GC_ms_entry * (*proc)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int))
{
  unsigned int result = GC_n_mark_procs;
  if(!(result >= 64u))
  {
    GC_n_mark_procs = GC_n_mark_procs + 1u;
    GC_arrays._mark_procs[(signed long int)result] = proc;
  }

  else
  {
    GC_on_abort("Too many mark procedures");
    abort();
  }
  return result;
}

// GC_new_thread
// file pthread_support.c line 489
struct GC_Thread_Rep * GC_new_thread(unsigned long int id)
{
  signed int hv = (signed int)((unsigned long int)id % (unsigned long int)256);
  struct GC_Thread_Rep *result;
  static signed int first_thread_used = 0;
  if((signed long int)first_thread_used == 0l)
  {
    result = &first_thread;
    first_thread_used = 1;
  }

  else
  {
    void *return_value_GC_generic_malloc_inner_1;
    return_value_GC_generic_malloc_inner_1=GC_generic_malloc_inner(sizeof(struct GC_Thread_Rep) /*864ul*/ , 1);
    result = (struct GC_Thread_Rep *)return_value_GC_generic_malloc_inner_1;
    if(result == ((struct GC_Thread_Rep *)NULL))
      return ((struct GC_Thread_Rep *)NULL);

  }
  result->id = id;
  result->next = GC_threads[(signed long int)hv];
  GC_threads[(signed long int)hv] = result;
  return result;
}

// GC_next_exclusion
// file mark_rts.c line 417
struct exclusion * GC_next_exclusion(char *start_addr)
{
  unsigned long int low = (unsigned long int)0;
  unsigned long int high = GC_excl_table_entries - (unsigned long int)1;
  unsigned long int mid;
  while(!(low >= high))
  {
    mid = low + high >> 1;
    if((unsigned long int)start_addr >= (unsigned long int)GC_arrays._excl_table[(signed long int)mid].e_end)
      low = mid + (unsigned long int)1;

    else
      high = mid;
  }
  if((unsigned long int)start_addr >= (unsigned long int)GC_arrays._excl_table[(signed long int)low].e_end)
    return ((struct exclusion *)NULL);

  else
    return GC_arrays._excl_table + (signed long int)low;
}

// GC_next_used_block
// file headers.c line 337
struct hblk * GC_next_used_block(struct hblk *h)
{
  struct bi *bi;
  unsigned long int j = (unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1);
  do
  {
    unsigned long int GC_next_used_block__1__1__hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
    struct bi *_bi = GC_arrays._top_index[(signed long int)(GC_next_used_block__1__1__hi & (unsigned long int)((1 << 11) - 1))];
    for( ; !(_bi->key == GC_next_used_block__1__1__hi); _bi = _bi->hash_link)
      if(_bi == GC_arrays._all_nils)
        break;

    bi = _bi;
  }
  while((_Bool)0);
  if(bi == GC_arrays._all_nils)
  {
    unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
    bi = GC_all_bottom_indices;
    for( ; !(bi == ((struct bi *)NULL)); bi = bi->asc_link)
      if(bi->key >= hi)
        break;

    j = (unsigned long int)0;
  }

  for( ; !(bi == ((struct bi *)NULL)); bi = bi->asc_link)
  {
    while(!(j >= 1024ul))
    {
      struct hblkhdr *hhdr = bi->index[(signed long int)j];
      if(!((unsigned long int)hhdr >= 4096ul))
        j = j + 1ul;

      else
        if((4 & (signed int)hhdr->hb_flags) == 0)
          return (struct hblk *)((bi->key << 10) + j << (unsigned long int)12);

        else
          j = j + (hhdr->hb_sz >> (unsigned long int)12);
    }
    j = (unsigned long int)0;
  }
  return ((struct hblk *)NULL);
}

// GC_noop1
// file ./include/private/gc_priv.h line 2075
extern void GC_noop1(unsigned long int x)
{
  GC_noop_sink = x;
}

// GC_noop6
// file ./include/private/gc_priv.h line 2073
void GC_noop6(unsigned long int arg1, unsigned long int arg2, unsigned long int arg3, unsigned long int arg4, unsigned long int arg5, unsigned long int arg6)
{
  ;
}

// GC_normal_finalize_mark_proc
// file finalize.c line 380
void GC_normal_finalize_mark_proc(char *p)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)p);
  do
  {
    unsigned long int _descr = hhdr->hb_descr;
    if(!(_descr == 0ul))
    {
      GC_arrays._mark_stack_top = GC_arrays._mark_stack_top + 1l;
      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)(GC_arrays._mark_stack + (signed long int)GC_mark_stack_size))
        GC_arrays._mark_stack_top=GC_signal_mark_stack_overflow(GC_arrays._mark_stack_top);

      GC_arrays._mark_stack_top->mse_start = p;
      GC_arrays._mark_stack_top->mse_descr.w = _descr;
    }

  }
  while((_Bool)0);
}

// GC_notify_all_builder
// file ./include/private/gc_priv.h line 2373
void GC_notify_all_builder(void)
{
  signed int return_value_pthread_cond_broadcast_1;
  return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&builder_cv);
  if(!(return_value_pthread_cond_broadcast_1 == 0))
  {
    GC_on_abort("pthread_cond_broadcast failed");
    abort();
  }

}

// GC_notify_all_marker
// file ./include/private/gc_priv.h line 2378
void GC_notify_all_marker(void)
{
  signed int return_value_pthread_cond_broadcast_1;
  return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&mark_cv);
  if(!(return_value_pthread_cond_broadcast_1 == 0))
  {
    GC_on_abort("pthread_cond_broadcast failed");
    abort();
  }

}

// GC_notify_full_gc
// file alloc.c line 334
static inline void GC_notify_full_gc(void)
{
  if(!(GC_start_call_back == ((void (*)(void))NULL)))
    GC_start_call_back();

}

// GC_notify_or_invoke_finalizers
// file ./include/private/gc_priv.h line 254
void GC_notify_or_invoke_finalizers(void)
{
  void (*notifier_fn)(void) = ((void (*)(void))NULL);
  if(!(GC_finalize_now == ((struct finalizable_object *)NULL)))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    if(GC_finalize_now == ((struct finalizable_object *)NULL))
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);

    else
    {
      if(GC_finalize_on_demand == 0)
      {
        unsigned char *pnested;
        pnested=GC_check_finalizer_nested();
        do
          if(!(GC_need_to_lock == 0))
            pthread_mutex_unlock(&GC_allocate_ml);

        while((_Bool)0);
        if(!(pnested == ((unsigned char *)NULL)))
        {
          GC_invoke_finalizers();
          *pnested = (unsigned char)0;
        }

        goto __CPROVER_DUMP_L14;
      }

      if(!(last_finalizer_notification == GC_gc_no))
      {
        last_finalizer_notification = GC_gc_no;
        notifier_fn = GC_finalizer_notifier;
      }

      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      if(!(notifier_fn == ((void (*)(void))NULL)))
        notifier_fn();

    }
  }


__CPROVER_DUMP_L14:
  ;
}

// GC_null_finalize_mark_proc
// file finalize.c line 413
void GC_null_finalize_mark_proc(char *p)
{
  ;
}

// GC_number_stack_black_listed
// file blacklst.c line 262
unsigned long int GC_number_stack_black_listed(struct hblk *start, struct hblk *endp1)
{
  struct hblk *h;
  unsigned long int result = (unsigned long int)0;
  h = start;
  for( ; !((unsigned long int)h >= (unsigned long int)endp1); h = h + 1l)
  {
    unsigned long int index = (unsigned long int)h >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
    if(!((1ul & GC_old_stack_bl[(signed long int)(index >> 6ul)] >> (63ul & index)) == 0ul))
      result = result + 1ul;

  }
  return result;
}

// GC_page_was_dirty
// file ./include/private/gc_priv.h line 2031
signed int GC_page_was_dirty(struct hblk *h)
{
  unsigned long int index = (unsigned long int)h >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
  struct hblkhdr *return_value_GC_find_header_1;
  return_value_GC_find_header_1=GC_find_header((char *)h);
  _Bool tmp_if_expr_2;
  if(return_value_GC_find_header_1 == ((struct hblkhdr *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (GC_arrays._grungy_pages[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// GC_parse_mem_size_arg
// file misc.c line 787
unsigned long int GC_parse_mem_size_arg(const char *str)
{
  char *endptr;
  unsigned long int result = (unsigned long int)0;
  char ch;
  if(!((signed int)*str == 0))
  {
    unsigned long int return_value_strtoul_1;
    return_value_strtoul_1=strtoul(str, &endptr, 10);
    result = (unsigned long int)return_value_strtoul_1;
    ch = *endptr;
    if(!((signed int)ch == 0))
    {
      if(!((signed int)endptr[1l] == 0))
        return (unsigned long int)0;

      switch((signed int)ch)
      {
        case 75:

        case 107:
        {
          result = result << 10;
          break;
        }
        case 77:

        case 109:
        {
          result = result << 20;
          break;
        }
        case 71:

        case 103:
        {
          result = result << 30;
          break;
        }
        default:
          result = (unsigned long int)0;
      }
    }

  }

  return result;
}

// GC_pause
// file pthread_support.c line 1774
void GC_pause(void)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
    asm(" " :  :  : "memory");
}

// GC_posix_memalign
// file mallocx.c line 485
extern signed int GC_posix_memalign(void **memptr, unsigned long int align, unsigned long int lb)
{
  if(!((align + 18446744073709551615ul & align) == 0ul) || !(align >= sizeof(void *) /*8ul*/ ))
    return 22;

  else
  {
    *memptr=GC_memalign(align, lb);
    if(*memptr == NULL)
      return 12;

    else
      return 0;
  }
}

// GC_post_incr
// file ptr_chck.c line 268
extern void * GC_post_incr(void **p, signed long int how_much)
{
  void *initial = *p;
  void *result;
  result=GC_same_obj((void *)((char *)initial + how_much), initial);
  if(GC_all_interior_pointers == 0)
    GC_is_valid_displacement(result);

  *p = result;
  return initial;
}

// GC_pre_incr
// file ptr_chck.c line 257
extern void * GC_pre_incr(void **p, signed long int how_much)
{
  void *initial = *p;
  void *result;
  result=GC_same_obj((void *)((char *)initial + how_much), initial);
  if(GC_all_interior_pointers == 0)
    GC_is_valid_displacement(result);

  *p = result;
  return *p;
}

// GC_prev_block
// file ./include/private/gc_priv.h line 1548
struct hblk * GC_prev_block(struct hblk *h)
{
  struct bi *bi;
  signed long int j = (signed long int)((unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1));
  do
  {
    unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
    struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
    for( ; !(_bi->key == hi); _bi = _bi->hash_link)
      if(_bi == GC_arrays._all_nils)
        break;

    bi = _bi;
  }
  while((_Bool)0);
  if(bi == GC_arrays._all_nils)
  {
    unsigned long int GC_prev_block__1__2__hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
    bi = GC_all_bottom_indices_end;
    for( ; !(bi == ((struct bi *)NULL)); bi = bi->desc_link)
      if(GC_prev_block__1__2__hi >= bi->key)
        break;

    j = (signed long int)((1 << 10) - 1);
  }

  for( ; !(bi == ((struct bi *)NULL)); bi = bi->desc_link)
  {
    while(j >= 0l)
    {
      struct hblkhdr *hhdr = bi->index[j];
      if(hhdr == ((struct hblkhdr *)NULL))
        j = j - 1l;

      else
        if(!((unsigned long int)hhdr >= 4096ul))
          j = j - (signed long int)hhdr;

        else
          return (struct hblk *)((bi->key << 10) + (unsigned long int)j << (unsigned long int)12);
    }
    j = (signed long int)((1 << 10) - 1);
  }
  return ((struct hblk *)NULL);
}

// GC_print_address_map
// file ./include/private/gc_priv.h line 1925
void GC_print_address_map(void)
{
  char *maps;
  GC_err_printf("---------- Begin address map ----------\n");
  maps=GC_get_maps();
  GC_err_puts(maps != (char *)(void *)0 ? maps : "Failed to get map!\n");
  GC_err_printf("---------- End address map ----------\n");
}

// GC_print_all_errors
// file ./include/private/gc_priv.h line 1908
void GC_print_all_errors(void)
{
  signed int have_errors;
  unsigned int i;
  unsigned int n_leaked;
  char *leaked[40l];
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  char *return_value_getenv_2;
  static signed int printing_errors = 0;
  if(!(printing_errors == 0))
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);

  else
  {
    have_errors = GC_have_errors;
    printing_errors = 1;
    n_leaked = GC_n_leaked;
    memcpy((void *)leaked, (const void *)GC_leaked, (unsigned long int)((unsigned long int)n_leaked * sizeof(char *) /*8ul*/ ));
    GC_n_leaked = (unsigned int)0;
    memset((void *)GC_leaked, 0, (unsigned long int)((unsigned long int)n_leaked * sizeof(char *) /*8ul*/ ));
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(!(GC_debugging_started == 0))
      GC_print_all_smashed();

    else
      have_errors = 0;
    if(n_leaked >= 1u)
    {
      GC_err_printf("Found %u leaked objects:\n", n_leaked);
      have_errors = 1;
    }

    i = (unsigned int)0;
    if(!(i >= n_leaked))
    {
      char *p = leaked[(signed long int)i];
      GC_print_heap_obj(p);
      GC_free((void *)p);
      i = i + 1u;
    }

    if(!(have_errors == 0))
    {
      return_value_getenv_2=getenv("GC_ABORT_ON_LEAK");
      if(!(return_value_getenv_2 == ((char *)NULL)))
      {
        GC_on_abort("Leaked or smashed objects encountered");
        abort();
      }

    }

    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_3;
        return_value_pthread_mutex_trylock_3=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_3 == 0))
          GC_lock();

      }

    while((_Bool)0);
    printing_errors = 0;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
}

// GC_print_all_smashed_proc
// file dbg_mlc.c line 957
void GC_print_all_smashed_proc(void)
{
  unsigned int i;
  if(!(GC_n_smashed == 0u))
  {
    GC_err_printf("GC_check_heap_block: found %u smashed heap objects:\n", GC_n_smashed);
    i = (unsigned int)0;
    for( ; !(i >= GC_n_smashed); i = i + 1u)
    {
      char *base;
      void *return_value_GC_base_1;
      return_value_GC_base_1=GC_base((void *)GC_smashed[(signed long int)i]);
      base = (char *)return_value_GC_base_1;
      GC_print_smashed_obj("", base + (signed long int)sizeof(struct anonymous_16) /*32ul*/ , GC_smashed[(signed long int)i]);
      GC_smashed[(signed long int)i] = ((char *)NULL);
    }
    GC_n_smashed = (unsigned int)0;
  }

}

// GC_print_block_descr
// file reclaim.c line 531
void GC_print_block_descr(struct hblk *h, unsigned long int raw_ps)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  unsigned long int bytes = hhdr->hb_sz;
  struct Print_stats *ps;
  unsigned int n_marks;
  signed int return_value_GC_n_set_marks_1;
  return_value_GC_n_set_marks_1=GC_n_set_marks(hhdr);
  n_marks = (unsigned int)return_value_GC_n_set_marks_1;
  if(!(hhdr->hb_n_marks == (unsigned long int)n_marks))
    GC_printf("(%u:%u,%u!=%u)\n", hhdr->hb_obj_kind, (unsigned int)bytes, (unsigned int)hhdr->hb_n_marks, n_marks);

  else
    GC_printf("(%u:%u,%u)\n", hhdr->hb_obj_kind, (unsigned int)bytes, n_marks);
  bytes = bytes + ((unsigned long int)(1 << 12) - (unsigned long int)1);
  bytes = bytes & ~((unsigned long int)(1 << 12) - (unsigned long int)1);
  ps = (struct Print_stats *)raw_ps;
  ps->total_bytes = ps->total_bytes + bytes;
  ps->number_of_blocks = ps->number_of_blocks + 1ul;
}

// GC_print_block_list
// file ./include/private/gc_priv.h line 2054
void GC_print_block_list(void)
{
  struct Print_stats pstats;
  GC_printf("(kind(0=ptrfree,1=normal,2=unc.):size_in_bytes, #_marks_set)\n");
  pstats.number_of_blocks = (unsigned long int)0;
  pstats.total_bytes = (unsigned long int)0;
  GC_apply_to_all_blocks(GC_print_block_descr, (unsigned long int)&pstats);
  GC_printf("blocks= %lu, bytes= %lu\n", (unsigned long int)pstats.number_of_blocks, (unsigned long int)pstats.total_bytes);
}

// GC_print_finalization_stats
// file ./include/private/gc_priv.h line 270
void GC_print_finalization_stats(void)
{
  struct finalizable_object *fo;
  unsigned long int ready = (unsigned long int)0;
  GC_log_printf("%lu finalization entries; %lu/%lu short/long disappearing links alive\n", (unsigned long int)GC_fo_entries, (unsigned long int)GC_dl_hashtbl.entries, (unsigned long int)GC_ll_hashtbl.entries);
  fo = GC_finalize_now;
  for( ; !(fo == ((struct finalizable_object *)NULL)); fo = (struct finalizable_object *)fo->prolog.next)
    ready = ready + 1ul;
  GC_log_printf("%lu finalization-ready objects; %ld/%ld short/long links cleared\n", ready, (signed long int)GC_old_dl_entries - (signed long int)GC_dl_hashtbl.entries, (signed long int)(GC_old_ll_entries - GC_ll_hashtbl.entries));
}

// GC_print_free_list
// file reclaim.c line 568
void GC_print_free_list(signed int kind, unsigned long int sz_in_granules)
{
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)kind];
  char *flh = (char *)ok->ok_freelist[(signed long int)sz_in_granules];
  signed int n = 0;
  for( ; !(flh == ((char *)NULL)); n = n + 1)
  {
    struct hblk *block = (struct hblk *)((unsigned long int)flh & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    GC_printf("Free object in heap block %p [%d]: %p\n", (void *)block, n, flh);
    flh = (char *)*((void **)flh);
  }
}

// GC_print_hblkfreelist
// file allchblk.c line 122
void GC_print_hblkfreelist(void)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned int i;
  unsigned long int total;
  i = (unsigned int)0;
  struct hblk *return_value_GC_is_black_listed_2;
  for( ; !(i >= 61u); i = i + 1u)
  {
    h = GC_hblkfreelist[(signed long int)i];
    if(!(h == ((struct hblk *)NULL)))
      GC_printf("Free list %u (total size %lu):\n", i, (unsigned long int)GC_free_bytes[(signed long int)i]);

    while(!(h == ((struct hblk *)NULL)))
    {
      hhdr=GC_find_header((char *)h);
      struct hblk *return_value_GC_is_black_listed_1;
      return_value_GC_is_black_listed_1=GC_is_black_listed(h, (unsigned long int)(1 << 12));
      char *tmp_if_expr_3;
      if(!(return_value_GC_is_black_listed_1 == ((struct hblk *)NULL)))
        tmp_if_expr_3 = "start";

      else
      {
        return_value_GC_is_black_listed_2=GC_is_black_listed(h, hhdr->hb_sz);
        tmp_if_expr_3 = return_value_GC_is_black_listed_2 != ((struct hblk *)NULL) ? "partially" : "not";
      }
      GC_printf("\t%p size %lu %s black listed\n", (void *)h, (unsigned long int)hhdr->hb_sz, tmp_if_expr_3);
      h = hhdr->hb_next;
    }
  }
  GC_printf("GC_large_free_bytes: %lu\n", (unsigned long int)GC_arrays._large_free_bytes);
  total=GC_compute_large_free_bytes();
  if(!(total == GC_arrays._large_free_bytes))
    GC_err_printf("GC_large_free_bytes INCONSISTENT!! Should be: %lu\n", (unsigned long int)total);

}

// GC_print_heap_sects
// file alloc.c line 1105
void GC_print_heap_sects(void)
{
  unsigned int i;
  GC_printf("Total heap size: %lu\n", (unsigned long int)GC_arrays._heapsize);
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= GC_n_heap_sects); i = i + 1u)
  {
    char *start = GC_arrays._heap_sects[(signed long int)i].hs_start;
    unsigned long int len = GC_arrays._heap_sects[(signed long int)i].hs_bytes;
    struct hblk *h;
    unsigned int nbl = (unsigned int)0;
    h = (struct hblk *)start;
    for( ; !((unsigned long int)h >= (unsigned long int)(start + (signed long int)len)); h = h + 1l)
    {
      struct hblk *return_value_GC_is_black_listed_1;
      return_value_GC_is_black_listed_1=GC_is_black_listed(h, (unsigned long int)(1 << 12));
      if(!(return_value_GC_is_black_listed_1 == ((struct hblk *)NULL)))
        nbl = nbl + 1u;

    }
    GC_printf("Section %d from %p to %p %lu/%lu blacklisted\n", i, start, start + (signed long int)len, (unsigned long int)nbl, (unsigned long int)(len / (unsigned long int)(1 << 12)));
  }
}

// GC_print_obj
// file dbg_mlc.c line 336
void GC_print_obj(char *p)
{
  struct anonymous_16 *ohdr;
  void *return_value_GC_base_1;
  return_value_GC_base_1=GC_base((void *)p);
  ohdr = (struct anonymous_16 *)return_value_GC_base_1;
  char *q;
  struct hblkhdr *hhdr;
  signed int kind;
  char *kind_str;
  char buffer[41l];
  q = (char *)(ohdr + (signed long int)1);
  hhdr=GC_find_header(q);
  kind = (signed int)hhdr->hb_obj_kind;
  _Bool tmp_if_expr_3;
  signed int return_value_GC_is_marked_2;
  if(!(GC_describe_type_fns[(signed long int)kind] == ((void (*)(void *, char *))NULL)))
  {
    return_value_GC_is_marked_2=GC_is_marked((const void *)ohdr);
    tmp_if_expr_3 = return_value_GC_is_marked_2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    buffer[(signed long int)40] = (char)0;
    GC_describe_type_fns[(signed long int)kind]((void *)q, buffer);
    kind_str = buffer;
  }

  else
    switch(kind)
    {
      case 0:
      {
        kind_str = "PTRFREE";
        break;
      }
      case 1:
      {
        kind_str = "NORMAL";
        break;
      }
      case 2:
      {
        kind_str = "UNCOLLECTABLE";
        break;
      }
      case 3:
      {
        kind_str = "ATOMIC_UNCOLLECTABLE";
        break;
      }
      case 4:
      {
        kind_str = "STUBBORN";
        break;
      }
      default:
        kind_str = (char *)(void *)0;
    }
  if(!(kind_str == ((char *)NULL)))
    GC_err_printf("%p (%s:%d, sz=%lu, %s)\n", (char *)ohdr + (signed long int)sizeof(struct anonymous_16) /*32ul*/ , ohdr->oh_string, (signed int)ohdr->oh_int, (unsigned long int)ohdr->oh_sz, kind_str);

  else
    GC_err_printf("%p (%s:%d, sz=%lu, kind=%d descr=0x%lx)\n", (char *)ohdr + (signed long int)sizeof(struct anonymous_16) /*32ul*/ , ohdr->oh_string, (signed int)ohdr->oh_int, (unsigned long int)ohdr->oh_sz, kind, (unsigned long int)hhdr->hb_descr);
}

// GC_print_smashed_obj
// file dbg_mlc.c line 418
void GC_print_smashed_obj(const char *msg, char *p, char *clobbered_addr)
{
  struct anonymous_16 *ohdr;
  void *return_value_GC_base_1;
  return_value_GC_base_1=GC_base((void *)p);
  ohdr = (struct anonymous_16 *)return_value_GC_base_1;
  _Bool tmp_if_expr_5;
  if((unsigned long int)&ohdr->oh_sz >= (unsigned long int)clobbered_addr)
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = ohdr->oh_string == ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
  char *tmp_if_expr_3;
  if(tmp_if_expr_5)
  {
    unsigned long int return_value_GC_size_2;
    return_value_GC_size_2=GC_size((const void *)(char *)ohdr);
    GC_err_printf("%s %p in or near object at %p(<smashed>, appr. sz = %lu)\n", msg, clobbered_addr, p, (unsigned long int)(return_value_GC_size_2 - ((sizeof(struct anonymous_16) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers)));
  }

  else
  {
    char *tmp_if_expr_4;
    if(!((unsigned long int)ohdr->oh_string >= 4096ul))
      tmp_if_expr_4 = "(smashed string)";

    else
    {
      if((signed int)*ohdr->oh_string == 0)
        tmp_if_expr_3 = "EMPTY(smashed?)";

      else
        tmp_if_expr_3 = ohdr->oh_string;
      tmp_if_expr_4 = tmp_if_expr_3;
    }
    GC_err_printf("%s %p in or near object at %p (%s:%d, sz=%lu)\n", msg, clobbered_addr, p, tmp_if_expr_4, (signed int)ohdr->oh_int, (unsigned long int)ohdr->oh_sz);
  }
}

// GC_print_static_roots
// file mark_rts.c line 58
void GC_print_static_roots(void)
{
  signed int i;
  unsigned long int size;
  i = 0;
  for( ; !(i >= n_root_sets); i = i + 1)
    GC_printf("From %p to %p%s\n", GC_arrays._static_roots[(signed long int)i].r_start, GC_arrays._static_roots[(signed long int)i].r_end, GC_arrays._static_roots[(signed long int)i].r_tmp != 0 ? " (temporary)" : "");
  GC_printf("GC_root_size: %lu\n", (unsigned long int)GC_root_size);
  size=GC_compute_root_size();
  if(!(size == GC_root_size))
    GC_err_printf("GC_root_size incorrect!! Should be: %lu\n", (unsigned long int)size);

}

// GC_printf
// file ./include/private/gc_priv.h line 2090
extern void GC_printf(const char *format, ...)
{
  char buf[1025l];
  if(GC_quiet == 0)
  {
    do
    {
      void **args = (void **)&format;
      buf[(signed long int)(sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1)] = (char)0x15;
      vsnprintf(buf, sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1, format, args);
      args = ((void **)NULL);
      if(!((signed int)buf[1024l] == 0x15))
      {
        GC_on_abort("GC_printf clobbered stack");
        abort();
      }

    }
    while((_Bool)0);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(buf);
    signed int return_value_GC_write_2;
    return_value_GC_write_2=GC_write(GC_stdout, buf, return_value_strlen_1);
    if(!(return_value_GC_write_2 >= 0))
    {
      GC_on_abort("write to stdout failed");
      abort();
    }

  }

}

// GC_promote_black_lists
// file ./include/private/gc_priv.h line 1721
void GC_promote_black_lists(void)
{
  unsigned long int *very_old_normal_bl = GC_old_normal_bl;
  unsigned long int *very_old_stack_bl = GC_old_stack_bl;
  GC_old_normal_bl = GC_incomplete_normal_bl;
  GC_old_stack_bl = GC_incomplete_stack_bl;
  if(GC_all_interior_pointers == 0)
    GC_clear_bl(very_old_normal_bl);

  GC_clear_bl(very_old_stack_bl);
  GC_incomplete_normal_bl = very_old_normal_bl;
  GC_incomplete_stack_bl = very_old_stack_bl;
  GC_total_stack_black_listed=total_stack_black_listed();
  if(GC_print_stats == 2)
    GC_log_printf("%lu bytes in heap blacklisted for interior pointers\n", (unsigned long int)GC_total_stack_black_listed);

  if(!(GC_total_stack_black_listed == 0ul))
    GC_black_list_spacing = (unsigned long int)(1 << 12) * (GC_arrays._heapsize / GC_total_stack_black_listed);

  if(!(GC_black_list_spacing >= 12288ul))
    GC_black_list_spacing = (unsigned long int)3 * (unsigned long int)(1 << 12);

  if(GC_black_list_spacing >= 8388609ul)
    GC_black_list_spacing = (unsigned long int)2048 * (unsigned long int)(1 << 12);

}

// GC_protect_heap
// file os_dep.c line 3394
void GC_protect_heap(void)
{
  char *start;
  unsigned long int len;
  struct hblk *current;
  struct hblk *current_start;
  struct hblk *limit;
  unsigned int i;
  signed int protect_all;
  signed int return_value_GC_incremental_protection_needs_1;
  return_value_GC_incremental_protection_needs_1=GC_incremental_protection_needs();
  protect_all = (signed int)(0 != (return_value_GC_incremental_protection_needs_1 & 2));
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= GC_n_heap_sects); i = i + 1u)
  {
    start = GC_arrays._heap_sects[(signed long int)i].hs_start;
    len = GC_arrays._heap_sects[(signed long int)i].hs_bytes;
    if(!(protect_all == 0))
    {
      signed int return_value_mprotect_2;
      return_value_mprotect_2=mprotect((void *)(char *)start, (unsigned long int)len, 0x1 | (GC_pages_executable != 0 ? 0x4 : 0));
      if(!(return_value_mprotect_2 >= 0))
      {
        GC_on_abort("mprotect failed");
        abort();
      }

    }

    else
    {
      current = (struct hblk *)start;
      current_start = current;
      limit = (struct hblk *)(start + (signed long int)len);
      while(!((unsigned long int)current >= (unsigned long int)limit))
      {
        struct hblkhdr *hhdr;
        unsigned long int nhblks;
        signed int is_ptrfree;
        do
        {
          struct hblkhdr **_ha;
          do
          {
            struct bi *bi;
            do
            {
              unsigned long int hi = (unsigned long int)current >> (unsigned long int)10 + (unsigned long int)12;
              struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
              for( ; !(_bi->key == hi); _bi = _bi->hash_link)
                if(_bi == GC_arrays._all_nils)
                  break;

              bi = _bi;
            }
            while((_Bool)0);
            _ha = &bi->index[(signed long int)((unsigned long int)current >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
          }
          while((_Bool)0);
          hhdr = *_ha;
        }
        while((_Bool)0);
        if(!((unsigned long int)hhdr >= 4096ul))
        {
          current = current + 1l;
          current_start = current;
        }

        else
        {
          if(!((4 & (signed int)hhdr->hb_flags) == 0))
          {
            nhblks = hhdr->hb_sz >> (unsigned long int)12;
            is_ptrfree = 1;
          }

          else
          {
            nhblks = (hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
            is_ptrfree = (signed int)(hhdr->hb_descr == (unsigned long int)0);
          }
          if(!(is_ptrfree == 0))
          {
            if(!((unsigned long int)current_start >= (unsigned long int)current))
            {
              signed int return_value_mprotect_3;
              return_value_mprotect_3=mprotect((void *)(char *)current_start, (unsigned long int)((char *)current - (char *)current_start), 0x1 | (GC_pages_executable != 0 ? 0x4 : 0));
              if(!(return_value_mprotect_3 >= 0))
              {
                GC_on_abort("mprotect failed");
                abort();
              }

            }

            current = current + (signed long int)nhblks;
            current_start = current;
          }

          else
            current = current + (signed long int)nhblks;
        }
      }
      if(!((unsigned long int)current_start >= (unsigned long int)current))
      {
        signed int return_value_mprotect_4;
        return_value_mprotect_4=mprotect((void *)(char *)current_start, (unsigned long int)((char *)current - (char *)current_start), 0x1 | (GC_pages_executable != 0 ? 0x4 : 0));
        if(!(return_value_mprotect_4 >= 0))
        {
          GC_on_abort("mprotect failed");
          abort();
        }

      }

    }
  }
}

// GC_pthread_cancel
// file pthread_support.c line 1451
extern signed int GC_pthread_cancel(unsigned long int thread)
{
  struct GC_Thread_Rep *t;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  t=GC_lookup_thread(thread);
  if(!(t == ((struct GC_Thread_Rep *)NULL)))
  {
    if((0x10 & (signed int)t->flags) == 0)
    {
      t->flags = t->flags | (unsigned char)0x10;
      GC_dont_gc = GC_dont_gc + 1;
    }

  }

  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  signed int return_value_pthread_cancel_2;
  return_value_pthread_cancel_2=pthread_cancel(thread);
  return return_value_pthread_cancel_2;
}

// GC_pthread_create
// file pthread_support.c line 1661
extern signed int GC_pthread_create(unsigned long int *new_thread, const union pthread_attr_t *attr, void * (*start_routine)(void *), void *arg)
{
  signed int result;
  signed int detachstate;
  unsigned long int my_flags = (unsigned long int)0;
  struct start_info *si;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  void *return_value_GC_generic_malloc_inner_2;
  return_value_GC_generic_malloc_inner_2=GC_generic_malloc_inner(sizeof(struct start_info) /*56ul*/ , 1);
  si = (struct start_info *)return_value_GC_generic_malloc_inner_2;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if((signed long int)parallel_initialized == 0l)
    GC_init_parallel();

  void * (*return_value_GC_get_oom_fn_3)(unsigned long int);
  void *return_value;
  if(si == ((struct start_info *)NULL))
  {
    return_value_GC_get_oom_fn_3=GC_get_oom_fn();
    return_value=return_value_GC_get_oom_fn_3(sizeof(struct start_info) /*56ul*/ );
    si = (struct start_info *)return_value;
    if(si == ((struct start_info *)NULL))
      return 12;

  }

  signed int return_value_sem_init_4;
  return_value_sem_init_4=sem_init(&si->registered, 0, (unsigned int)0);
  if(!(return_value_sem_init_4 == 0))
  {
    GC_on_abort("sem_init failed");
    abort();
  }

  si->start_routine = start_routine;
  si->arg = arg;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_5;
      return_value_pthread_mutex_trylock_5=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_5 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if((signed long int)GC_thr_initialized == 0l)
    GC_thr_init();

  if(attr == ((const union pthread_attr_t *)NULL))
    detachstate = 0;

  else
    pthread_attr_getdetachstate(attr, &detachstate);
  if(detachstate == 1)
    my_flags = my_flags | (unsigned long int)2;

  si->flags = my_flags;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  GC_need_to_lock = 1;
  result=pthread_create(new_thread, attr, GC_start_routine, (void *)si);
  signed int return_value_sem_wait_6;
  if(result == 0)
  {
    signed int cancel_state;
    do
      pthread_setcancelstate(1, &cancel_state);
    while((_Bool)0);
    do
    {
      return_value_sem_wait_6=sem_wait(&si->registered);
      if(return_value_sem_wait_6 == 0)
        break;

      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      if(!(*return_value___errno_location_7 == 4))
      {
        GC_on_abort("sem_wait failed");
        abort();
      }

    }
    while((_Bool)1);
    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }

  sem_destroy(&si->registered);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_8;
      return_value_pthread_mutex_trylock_8=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_8 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_free_inner((void *)si);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_pthread_detach
// file pthread_support.c line 1418
extern signed int GC_pthread_detach(unsigned long int thread)
{
  signed int result;
  struct GC_Thread_Rep *t;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  t=GC_lookup_thread(thread);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  result=pthread_detach(thread);
  if(result == 0)
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_2;
        return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_2 == 0))
          GC_lock();

      }

    while((_Bool)0);
    t->flags = t->flags | (unsigned char)2;
    if(!((1 & (signed int)t->flags) == 0))
      GC_delete_gc_thread(t);

    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  return result;
}

// GC_pthread_exit
// file pthread_support.c line 1476
extern void GC_pthread_exit(void *retval)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  if(!(me == ((struct GC_Thread_Rep *)NULL)))
  {
    if((0x10 & (signed int)me->flags) == 0)
    {
      me->flags = me->flags | (unsigned char)0x10;
      GC_dont_gc = GC_dont_gc + 1;
    }

  }

  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  pthread_exit(retval);
}

// GC_pthread_join
// file pthread_support.c line 1384
extern signed int GC_pthread_join(unsigned long int thread, void **retval)
{
  signed int result;
  struct GC_Thread_Rep *t;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  t=GC_lookup_thread(thread);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  result=pthread_join(thread, retval);
  if(result == 0)
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_2;
        return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_2 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_delete_gc_thread(t);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  return result;
}

// GC_pthread_sigmask
// file pthread_support.c line 1174
extern signed int GC_pthread_sigmask(signed int how, const struct anonymous_0 *set, struct anonymous_0 *oset)
{
  struct anonymous_0 fudged_set;
  signed int sig_suspend;
  if(!(set == ((const struct anonymous_0 *)NULL)) && (how == 0 || how == 2))
  {
    fudged_set = *set;
    sig_suspend=GC_get_suspend_signal();
    sigdelset(&fudged_set, sig_suspend);
    set = &fudged_set;
  }

  signed int return_value_pthread_sigmask_1;
  return_value_pthread_sigmask_1=pthread_sigmask(how, set, oset);
  return return_value_pthread_sigmask_1;
}

// GC_push_all
// file ./include/private/../gc_mark.h line 252
extern void GC_push_all(char *bottom, char *top)
{
  unsigned long int length;
  bottom = (char *)(((unsigned long int)bottom + (unsigned long int)8) - (unsigned long int)1 & (unsigned long int)~(8 - 1));
  top = (char *)((unsigned long int)top & (unsigned long int)~(8 - 1));
  if(!((unsigned long int)bottom >= (unsigned long int)top))
  {
    GC_arrays._mark_stack_top = GC_arrays._mark_stack_top + 1l;
    if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack_limit)
    {
      GC_on_abort("Unexpected mark stack overflow");
      abort();
    }

    length = (unsigned long int)(top - bottom);
    GC_arrays._mark_stack_top->mse_start = bottom;
    GC_arrays._mark_stack_top->mse_descr.w = length;
  }

}

// GC_push_all_eager
// file mark.c line 1491
void GC_push_all_eager(char *bottom, char *top)
{
  unsigned long int *b = (unsigned long int *)(((unsigned long int)bottom + (unsigned long int)8) - (unsigned long int)1 & (unsigned long int)~(8 - 1));
  unsigned long int *t = (unsigned long int *)((unsigned long int)top & (unsigned long int)~(8 - 1));
  unsigned long int *p;
  unsigned long int q;
  unsigned long int *lim;
  char *greatest_ha = (char *)GC_greatest_plausible_heap_addr;
  char *least_ha = (char *)GC_least_plausible_heap_addr;
  if(!(top == ((char *)NULL)))
  {
    lim = t - (signed long int)1;
    p = b;
    for( ; (unsigned long int)lim >= (unsigned long int)p; p = (unsigned long int *)((char *)p + (signed long int)8))
    {
      q = *p;
      do
        if(q >= (unsigned long int)least_ha && !(q >= (unsigned long int)greatest_ha))
          GC_mark_and_push_stack((char *)q);

      while((_Bool)0);
    }
  }

}

// GC_push_all_stack
// file mark.c line 1516
void GC_push_all_stack(char *bottom, char *top)
{
  GC_push_all_eager(bottom, top);
}

// GC_push_all_stack_sections
// file mark_rts.c line 536
void GC_push_all_stack_sections(char *lo, char *hi, struct GC_traced_stack_sect_s *traced_stack_sect)
{
  for( ; !(traced_stack_sect == ((struct GC_traced_stack_sect_s *)NULL)); traced_stack_sect = traced_stack_sect->prev)
  {
    GC_push_all_stack(lo, (char *)traced_stack_sect);
    lo = traced_stack_sect->saved_stack_ptr;
  }
  GC_push_all_stack(lo, hi);
}

// GC_push_all_stacks
// file ./include/private/gc_priv.h line 2272
void GC_push_all_stacks(void)
{
  signed int found_me = 0;
  unsigned long int nthreads = (unsigned long int)0;
  signed int i;
  struct GC_Thread_Rep *p;
  char *lo;
  char *hi;
  struct GC_traced_stack_sect_s *traced_stack_sect;
  unsigned long int self;
  self=pthread_self();
  unsigned long int total_size = (unsigned long int)0;
  if((signed long int)GC_thr_initialized == 0l)
    GC_thr_init();

  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    p = GC_threads[(signed long int)i];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
      if((1 & (signed int)p->flags) == 0)
      {
        nthreads = nthreads + 1ul;
        traced_stack_sect = p->traced_stack_sect;
        if(p->id == self)
        {
          lo=GC_approx_sp();
          found_me = 1;
        }

        else
        {
          lo = p->stop_info.stack_ptr;
          if(!(traced_stack_sect == ((struct GC_traced_stack_sect_s *)NULL)))
          {
            if(traced_stack_sect->saved_stack_ptr == lo)
              traced_stack_sect = traced_stack_sect->prev;

          }

        }
        if((4 & (signed int)p->flags) == 0)
          hi = p->stack_end;

        else
          hi = GC_stackbottom;
        if(lo == ((char *)NULL))
        {
          GC_on_abort("GC_push_all_stacks: sp not set!");
          abort();
        }

        GC_push_all_stack_sections(lo, hi, traced_stack_sect);
        total_size = total_size + (unsigned long int)(hi - lo);
      }

  }
  if(GC_print_stats == 2)
    GC_log_printf("Pushed %d thread stacks\n", (signed int)nthreads);

  if(GC_in_thread_creation == 0 && found_me == 0)
  {
    GC_on_abort("Collecting from unknown thread");
    abort();
  }

  GC_total_stacksize = total_size;
}

// GC_push_complex_descriptor
// file typd_mlc.c line 440
struct GC_ms_entry * GC_push_complex_descriptor(unsigned long int *addr, union ComplexDescriptor *d, struct GC_ms_entry *msp, struct GC_ms_entry *msl)
{
  char *current = (char *)addr;
  unsigned long int nelements;
  unsigned long int sz;
  unsigned long int i;
  unsigned long int descr;
  union ComplexDescriptor *GC_push_complex_descriptor__1__1__2__descr;
  switch(d->ld.ld_tag)
  {
    case (unsigned long int)1:
    {
      descr = d->ld.ld_descriptor;
      nelements = d->ld.ld_nelements;
      if((signed long int)nelements >= msl - msp)
        return ((struct GC_ms_entry *)NULL);

      sz = d->ld.ld_size;
      i = (unsigned long int)0;
      for( ; !(i >= nelements); i = i + 1ul)
      {
        msp = msp + 1l;
        msp->mse_start = current;
        msp->mse_descr.w = descr;
        current = current + (signed long int)sz;
      }
      return msp;
    }
    case (unsigned long int)2:
    {
      GC_push_complex_descriptor__1__1__2__descr = d->ad.ad_element_descr;
      nelements = d->ad.ad_nelements;
      sz=GC_descr_obj_size(GC_push_complex_descriptor__1__1__2__descr);
      i = (unsigned long int)0;
      for( ; !(i >= nelements); i = i + 1ul)
      {
        msp=GC_push_complex_descriptor((unsigned long int *)current, GC_push_complex_descriptor__1__1__2__descr, msp, msl);
        if(msp == ((struct GC_ms_entry *)NULL))
          return ((struct GC_ms_entry *)NULL);

        current = current + (signed long int)sz;
      }
      return msp;
    }
    case (unsigned long int)3:
    {
      sz=GC_descr_obj_size(d->sd.sd_first);
      msp=GC_push_complex_descriptor((unsigned long int *)current, d->sd.sd_first, msp, msl);
      if(msp == ((struct GC_ms_entry *)NULL))
        return ((struct GC_ms_entry *)NULL);

      current = current + (signed long int)sz;
      msp=GC_push_complex_descriptor((unsigned long int *)current, d->sd.sd_second, msp, msl);
      return msp;
    }
    default:
    {
      if(!((signed long int)GC_current_warn_proc == -1l))
      {
        GC_on_abort("Bad complex descriptor");
        abort();
      }

      return ((struct GC_ms_entry *)NULL);
    }
  }
}

// GC_push_conditional
// file mark.c line 1323
extern void GC_push_conditional(char *bottom, char *top, signed int all)
{
  if(all == 0)
    GC_push_selected((char *)bottom, (char *)top, GC_page_was_dirty);

  else
    GC_push_all(bottom, top);
}

// GC_push_conditional_with_exclusions
// file mark_rts.c line 491
void GC_push_conditional_with_exclusions(char *bottom, char *top, signed int all)
{
  struct exclusion *next;
  char *excl_start;
  for( ; !((unsigned long int)bottom >= (unsigned long int)top); bottom = next->e_end)
  {
    next=GC_next_exclusion(bottom);
    _Bool tmp_if_expr_1;
    if(next == ((struct exclusion *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      excl_start = next->e_start;
      tmp_if_expr_1 = (unsigned long int)excl_start >= (unsigned long int)top ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
    {
      GC_push_conditional((char *)bottom, (char *)top, all);
      goto __CPROVER_DUMP_L7;
    }

    if(!((unsigned long int)bottom >= (unsigned long int)excl_start))
      GC_push_conditional((char *)bottom, (char *)excl_start, all);

  }

__CPROVER_DUMP_L7:
  ;
}

// GC_push_current_stack
// file mark_rts.c line 658
void GC_push_current_stack(char *cold_gc_frame, void *context)
{
  if(!(cold_gc_frame == ((char *)NULL)))
  {
    char *return_value_GC_approx_sp_1;
    return_value_GC_approx_sp_1=GC_approx_sp();
    GC_push_all_eager(return_value_GC_approx_sp_1, cold_gc_frame);
  }

}

// GC_push_finalizer_structures
// file finalize.c line 77
void GC_push_finalizer_structures(void)
{
  GC_push_all((char *)&GC_ll_hashtbl.head, (char *)&GC_ll_hashtbl.head + (signed long int)sizeof(unsigned long int) /*8ul*/ );
  GC_push_all((char *)&GC_dl_hashtbl.head, (char *)&GC_dl_hashtbl.head + (signed long int)sizeof(unsigned long int) /*8ul*/ );
  GC_push_all((char *)&GC_fo_head, (char *)&GC_fo_head + (signed long int)sizeof(unsigned long int) /*8ul*/ );
  GC_push_all((char *)&GC_finalize_now, (char *)&GC_finalize_now + (signed long int)sizeof(unsigned long int) /*8ul*/ );
}

// GC_push_gc_structures
// file mark_rts.c line 716
void GC_push_gc_structures(void)
{
  GC_push_finalizer_structures();
  GC_push_thread_structures();
  if(!(GC_push_typed_structures == ((void (*)(void))NULL)))
    GC_push_typed_structures();

}

// GC_push_marked
// file mark.c line 1727
void GC_push_marked(struct hblk *h, struct hblkhdr *hhdr)
{
  unsigned long int sz = hhdr->hb_sz;
  unsigned long int descr = hhdr->hb_descr;
  char *p;
  unsigned long int bit_no;
  char *lim;
  struct GC_ms_entry *GC_mark_stack_top_reg;
  struct GC_ms_entry *mark_stack_limit = GC_arrays._mark_stack_limit;
  if(!(descr == 0ul))
  {
    signed int return_value_GC_block_empty_1;
    return_value_GC_block_empty_1=GC_block_empty(hhdr);
    if(return_value_GC_block_empty_1 == 0)
    {
      GC_n_rescuing_pages = GC_n_rescuing_pages + 1ul;
      GC_objects_are_marked = 1;
      if(sz >= 2049ul)
        lim = h->hb_body;

      else
        lim = (h + (signed long int)1)->hb_body - (signed long int)sz;
      GC_mark_stack_top_reg = GC_arrays._mark_stack_top;
      p = h->hb_body;
      bit_no = (unsigned long int)0;
      for( ; (unsigned long int)lim >= (unsigned long int)p; bit_no = bit_no + (sz >> 4))
      {
        if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
          do
          {
            unsigned long int _descr = hhdr->hb_descr;
            if(!(_descr == 0ul))
            {
              GC_mark_stack_top_reg = GC_mark_stack_top_reg + 1l;
              if((unsigned long int)GC_mark_stack_top_reg >= (unsigned long int)mark_stack_limit)
                GC_mark_stack_top_reg=GC_signal_mark_stack_overflow(GC_mark_stack_top_reg);

              GC_mark_stack_top_reg->mse_start = p;
              GC_mark_stack_top_reg->mse_descr.w = _descr;
            }

          }
          while((_Bool)0);

        p = p + (signed long int)sz;
      }
      GC_arrays._mark_stack_top = GC_mark_stack_top_reg;
    }

  }

}

// GC_push_next_marked
// file mark.c line 1835
struct hblk * GC_push_next_marked(struct hblk *h)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  _Bool tmp_if_expr_1;
  if(!((unsigned long int)hhdr >= 4096ul))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ((signed int)hhdr->hb_flags & 4) != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    h=GC_next_used_block(h);
    if(h == ((struct hblk *)NULL))
      return ((struct hblk *)NULL);

    hhdr=GC_find_header((char *)h);
  }

  GC_push_marked(h, hhdr);
  return h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
}

// GC_push_next_marked_dirty
// file mark.c line 1850
struct hblk * GC_push_next_marked_dirty(struct hblk *h)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  if(GC_dirty_maintained == 0)
  {
    GC_on_abort("Dirty bits not set up");
    abort();
  }

  do
  {
    _Bool tmp_if_expr_1;
    if(!((unsigned long int)hhdr >= 4096ul))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = ((signed int)hhdr->hb_flags & 4) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      h=GC_next_used_block(h);
      if(h == ((struct hblk *)NULL))
        return ((struct hblk *)NULL);

      hhdr=GC_find_header((char *)h);
    }

    signed int return_value_GC_block_was_dirty_2;
    return_value_GC_block_was_dirty_2=GC_block_was_dirty(h, hhdr);
    if(!(return_value_GC_block_was_dirty_2 == 0))
      break;

    h = h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
    hhdr=GC_find_header((char *)h);
  }
  while((_Bool)1);
  GC_push_marked(h, hhdr);
  return h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
}

// GC_push_next_marked_uncollectable
// file mark.c line 1883
struct hblk * GC_push_next_marked_uncollectable(struct hblk *h)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  do
  {
    _Bool tmp_if_expr_1;
    if(!((unsigned long int)hhdr >= 4096ul))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = ((signed int)hhdr->hb_flags & 4) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      h=GC_next_used_block(h);
      if(h == ((struct hblk *)NULL))
        return ((struct hblk *)NULL);

      hhdr=GC_find_header((char *)h);
    }

    if((signed int)hhdr->hb_obj_kind == 2)
    {
      GC_push_marked(h, hhdr);
      break;
    }

    if(!((0x10 & (signed int)hhdr->hb_flags) == 0))
    {
      GC_push_unconditionally(h, hhdr);
      break;
    }

    h = h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
    hhdr=GC_find_header((char *)h);
  }
  while((_Bool)1);
  return h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
}

// GC_push_one
// file mark.c line 1350
void GC_push_one(unsigned long int p)
{
  do
    if(p >= (unsigned long int)GC_least_plausible_heap_addr && !(p >= (unsigned long int)GC_greatest_plausible_heap_addr))
      GC_mark_and_push_stack((char *)p);

  while((_Bool)0);
}

// GC_push_regs_and_stack
// file mark_rts.c line 739
void GC_push_regs_and_stack(char *cold_gc_frame)
{
  GC_with_callee_saves_pushed(GC_push_current_stack, cold_gc_frame);
}

// GC_push_roots
// file ./include/private/gc_priv.h line 1598
void GC_push_roots(signed int all, char *cold_gc_frame)
{
  signed int i;
  unsigned int kind;
  i = 0;
  for( ; !(i >= n_root_sets); i = i + 1)
    GC_push_conditional_with_exclusions(GC_arrays._static_roots[(signed long int)i].r_start, GC_arrays._static_roots[(signed long int)i].r_end, all);
  kind = (unsigned int)0;
  for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
  {
    void *base;
    base=GC_base((void *)GC_obj_kinds[(signed long int)kind].ok_freelist);
    if(!(base == NULL))
      GC_set_mark_bit(base);

  }
  if(!(GC_no_dls == 0) || !(roots_were_cleared == 0))
    GC_push_gc_structures();

  if(!(GC_world_stopped == 0))
    GC_mark_thread_local_free_lists();

  GC_push_regs_and_stack(cold_gc_frame);
  if(!(GC_push_other_roots == ((void (*)(void))NULL)))
    GC_push_other_roots();

}

// GC_push_selected
// file mark.c line 1281
void GC_push_selected(char *bottom, char *top, signed int (*dirty_fn)(struct hblk *))
{
  struct hblk *h;
  bottom = (char *)(((unsigned long int)bottom + (unsigned long int)8) - (unsigned long int)1 & (unsigned long int)~(8 - 1));
  top = (char *)((unsigned long int)top & (unsigned long int)~(8 - 1));
  signed int return_value_3;
  if(!((unsigned long int)bottom >= (unsigned long int)top))
  {
    h = (struct hblk *)((unsigned long int)(bottom + (signed long int)(unsigned long int)(1 << 12)) & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    if((unsigned long int)h >= (unsigned long int)top)
    {
      signed int return_value;
      return_value=dirty_fn(h - (signed long int)1);
      if(!(return_value == 0))
        GC_push_all(bottom, top);

    }

    signed int return_value_1;
    return_value_1=dirty_fn(h - (signed long int)1);
    if(!(return_value_1 == 0))
      GC_push_all(bottom, (char *)h);

    if((unsigned long int)top >= (unsigned long int)(h + 1l))
    {
      signed int return_value_2;
      return_value_2=dirty_fn(h);
      if(!(return_value_2 == 0))
      {
        if(!((3ul * GC_mark_stack_size) / 4ul >= (unsigned long int)(GC_arrays._mark_stack_top - GC_arrays._mark_stack)))
          GC_push_all((char *)h, top);

        else
          GC_push_all((char *)h, (char *)(h + (signed long int)1));
      }

      h = h + 1l;
    }

    if(!((char *)h == top))
    {
      return_value_3=dirty_fn(h);
      if(!(return_value_3 == 0))
        GC_push_all((char *)h, top);

    }

    if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack_limit)
    {
      GC_on_abort("Unexpected mark stack overflow");
      abort();
    }

  }

}

// GC_push_thread_structures
// file ./include/private/gc_priv.h line 1612
void GC_push_thread_structures(void)
{
  GC_push_all((char *)GC_threads, (char *)GC_threads + (signed long int)sizeof(struct GC_Thread_Rep * volatile [256l]) /*2048ul*/ );
  GC_push_all((char *)&GC_thread_key, (char *)&GC_thread_key + (signed long int)sizeof(void *) /*8ul*/ );
}

// GC_push_typed_structures_proc
// file typd_mlc.c line 103
void GC_push_typed_structures_proc(void)
{
  GC_push_all((char *)&GC_ext_descriptors, (char *)&GC_ext_descriptors + (signed long int)sizeof(unsigned long int) /*8ul*/ );
}

// GC_push_unconditionally
// file mark.c line 1787
void GC_push_unconditionally(struct hblk *h, struct hblkhdr *hhdr)
{
  unsigned long int sz = hhdr->hb_sz;
  unsigned long int descr = hhdr->hb_descr;
  char *p;
  char *lim;
  struct GC_ms_entry *GC_mark_stack_top_reg;
  struct GC_ms_entry *mark_stack_limit = GC_arrays._mark_stack_limit;
  if(!(descr == 0ul))
  {
    GC_n_rescuing_pages = GC_n_rescuing_pages + 1ul;
    GC_objects_are_marked = 1;
    if(sz >= 2049ul)
      lim = h->hb_body;

    else
      lim = (h + (signed long int)1)->hb_body - (signed long int)sz;
    GC_mark_stack_top_reg = GC_arrays._mark_stack_top;
    p = h->hb_body;
    for( ; (unsigned long int)lim >= (unsigned long int)p; p = p + (signed long int)sz)
      if(!((3ul & *((unsigned long int *)p)) == 0ul))
        do
        {
          unsigned long int _descr = hhdr->hb_descr;
          if(!(_descr == 0ul))
          {
            GC_mark_stack_top_reg = GC_mark_stack_top_reg + 1l;
            if((unsigned long int)GC_mark_stack_top_reg >= (unsigned long int)mark_stack_limit)
              GC_mark_stack_top_reg=GC_signal_mark_stack_overflow(GC_mark_stack_top_reg);

            GC_mark_stack_top_reg->mse_start = p;
            GC_mark_stack_top_reg->mse_descr.w = _descr;
          }

        }
        while((_Bool)0);

    GC_arrays._mark_stack_top = GC_mark_stack_top_reg;
  }

}

// GC_read_dirty
// file ./include/private/gc_priv.h line 2029
void GC_read_dirty(void)
{
  memcpy((void *)GC_arrays._grungy_pages, (const void *)(unsigned long int *)GC_arrays._dirty_pages, (unsigned long int)sizeof(unsigned long int [4096l]) /*32768ul*/ );
  memset((void *)(unsigned long int *)GC_arrays._dirty_pages, 0, (unsigned long int)sizeof(unsigned long int [4096l]) /*32768ul*/ );
  GC_protect_heap();
}

// GC_realloc
// file ./include/gc.h line 485
extern void * GC_realloc(void *p, unsigned long int lb)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned long int sz;
  unsigned long int orig_sz;
  signed int obj_kind;
  void *return_value_GC_malloc_1;
  if(p == NULL)
  {
    return_value_GC_malloc_1=GC_malloc(lb);
    return return_value_GC_malloc_1;
  }

  h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  hhdr=GC_find_header((char *)h);
  sz = hhdr->hb_sz;
  obj_kind = (signed int)hhdr->hb_obj_kind;
  orig_sz = sz;
  if(sz >= 2049ul)
  {
    unsigned long int descr;
    sz = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 & ~((unsigned long int)(1 << 12) - (unsigned long int)1);
    hhdr->hb_sz = sz;
    descr = GC_obj_kinds[(signed long int)obj_kind].ok_descriptor;
    if(!(GC_obj_kinds[(signed long int)obj_kind].ok_relocate_descr == 0))
      descr = descr + sz;

    hhdr->hb_descr = descr;
    if((-2 & obj_kind) == 2)
      GC_non_gc_bytes = GC_non_gc_bytes + (sz - orig_sz);

  }

  if(sz >= lb + (unsigned long int)GC_all_interior_pointers)
  {
    if(lb >= sz >> 1)
    {
      if(!(lb >= orig_sz))
        memset((void *)((char *)p + (signed long int)lb), 0, (unsigned long int)(orig_sz - lb));

      return p;
    }

    else
    {
      void *result;
      result=GC_generic_or_special_malloc((unsigned long int)lb, obj_kind);
      if(result == NULL)
        return NULL;

      memcpy(result, p, (unsigned long int)lb);
      GC_free(p);
      return result;
    }
  }

  else
  {
    void *GC_realloc__1__3__result;
    GC_realloc__1__3__result=GC_generic_or_special_malloc((unsigned long int)lb, obj_kind);
    if(GC_realloc__1__3__result == NULL)
      return NULL;

    memcpy(GC_realloc__1__3__result, p, (unsigned long int)sz);
    GC_free(p);
    return GC_realloc__1__3__result;
  }
}

// GC_rebuild_root_index
// file mark_rts.c line 299
void GC_rebuild_root_index(void)
{
  signed int i;
  memset((void *)GC_arrays._root_index, 0, (unsigned long int)((unsigned long int)(1 << 6) * sizeof(void *) /*8ul*/ ));
  i = 0;
  for( ; !(i >= n_root_sets); i = i + 1)
    add_roots_to_index(GC_arrays._static_roots + (signed long int)i);
}

// GC_reclaim_all
// file ./include/private/gc_priv.h line 1790
signed int GC_reclaim_all(signed int (*stop_func)(void), signed int ignore_old)
{
  unsigned long int sz;
  unsigned int kind;
  struct hblkhdr *hhdr;
  struct hblk *hbp;
  struct obj_kind *ok;
  struct hblk **rlp;
  struct hblk **rlh;
  signed long int start_time = (signed long int)0;
  signed long int done_time;
  if(GC_print_stats == 2)
    start_time=clock();

  kind = (unsigned int)0;
  signed int return_value;
  for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
  {
    ok = &GC_obj_kinds[(signed long int)kind];
    rlp = ok->ok_reclaim_list;
    if(!(rlp == ((struct hblk **)NULL)))
    {
      sz = (unsigned long int)1;
      for( ; !(sz >= 129ul); sz = sz + 1ul)
      {
        rlh = rlp + (signed long int)sz;
        do
        {
          hbp = *rlh;
          if(hbp == ((struct hblk *)NULL))
            break;

          if(!(stop_func == ((signed int (*)(void))NULL)))
          {
            return_value=stop_func();
            if(!(return_value == 0))
              return 0;

          }

          hhdr=GC_find_header((char *)hbp);
          *rlh = hhdr->hb_next;
          _Bool tmp_if_expr_1;
          if(ignore_old == 0)
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = (unsigned long int)hhdr->hb_last_reclaimed == GC_gc_no - (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
            GC_reclaim_small_nonempty_block(hbp, 0);

        }
        while((_Bool)1);
      }
    }

  }
  if(GC_print_stats == 2)
  {
    done_time=clock();
    GC_log_printf("Disposing of reclaim lists took %lu msecs\n", (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(done_time - start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(done_time - start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000);
  }

  return 1;
}

// GC_reclaim_block
// file reclaim.c line 374
void GC_reclaim_block(struct hblk *hbp, unsigned long int report_if_found)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)hbp);
  unsigned long int sz = hhdr->hb_sz;
  struct obj_kind *GC_reclaim_block__1__ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
  struct hblk **rlh;
  signed int return_value_GC_block_nearly_full_1;
  if(sz >= 2049ul)
  {
    if(hhdr->_mark_byte_union._hb_marks[0l] == 0)
    {
      if(!(report_if_found == 0ul))
        GC_add_leaked((char *)hbp);

      else
      {
        unsigned long int blocks;
        if(!((signed long int)(8 & (signed int)hhdr->hb_flags) == 0l))
        {
          struct obj_kind *ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
          signed int return_value;
          return_value=ok->ok_disclaim_proc((void *)hbp);
          if(!(return_value == 0))
            hhdr->_mark_byte_union._hb_marks[(signed long int)0] = (char)1;

        }

        blocks = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
        if(blocks >= 2ul)
          GC_arrays._large_allocd_bytes = GC_arrays._large_allocd_bytes - blocks * (unsigned long int)(1 << 12);

        GC_bytes_found = GC_bytes_found + (signed long int)sz;
        GC_freehblk(hbp);
      }
    }

    else
    {

    in_use:
      ;
      if(!(hhdr->hb_descr == 0ul))
        GC_arrays._composite_in_use = GC_arrays._composite_in_use + sz;

      else
        GC_arrays._atomic_in_use = GC_arrays._atomic_in_use + sz;
    }
  }

  else
  {
    signed int empty;
    empty=GC_block_empty(hhdr);
    if(!(report_if_found == 0ul))
      GC_reclaim_small_nonempty_block(hbp, 1);

    else
      if(!(empty == 0))
      {
        if(!((8 & (signed int)hhdr->hb_flags) == 0))
          GC_disclaim_and_reclaim_or_free_small_block(hbp);

        else
        {
          GC_bytes_found = GC_bytes_found + (signed long int)(unsigned long int)(1 << 12);
          GC_freehblk(hbp);
        }
      }

      else
      {
        _Bool tmp_if_expr_2;
        if(!(GC_find_leak == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          return_value_GC_block_nearly_full_1=GC_block_nearly_full(hhdr);
          tmp_if_expr_2 = !(return_value_GC_block_nearly_full_1 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
        {
          rlh = &GC_reclaim_block__1__ok->ok_reclaim_list[(signed long int)(sz >> 4)];
          hhdr->hb_next = *rlh;
          *rlh = hbp;
        }

      }
    if(!(hhdr->hb_descr == 0ul))
      GC_arrays._composite_in_use = GC_arrays._composite_in_use + sz * hhdr->hb_n_marks;

    else
      GC_arrays._atomic_in_use = GC_arrays._atomic_in_use + sz * hhdr->hb_n_marks;
  }
}

// GC_reclaim_check
// file reclaim.c line 274
void GC_reclaim_check(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz)
{
  unsigned long int bit_no;
  char *p;
  char *plim;
  p = hbp->hb_body;
  plim = (p + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz;
  bit_no = (unsigned long int)0;
  for( ; (unsigned long int)plim >= (unsigned long int)p; bit_no = bit_no + (sz >> 4))
  {
    if(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0)
      GC_add_leaked(p);

    p = p + (signed long int)sz;
  }
}

// GC_reclaim_clear
// file reclaim.c line 146
char * GC_reclaim_clear(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count)
{
  unsigned long int bit_no = (unsigned long int)0;
  unsigned long int *p;
  unsigned long int *q;
  unsigned long int *plim;
  signed long int n_bytes_found = (signed long int)0;
  p = (unsigned long int *)hbp->hb_body;
  plim = (unsigned long int *)((hbp->hb_body + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz);
  for( ; (unsigned long int)plim >= (unsigned long int)p; bit_no = bit_no + (sz >> 4))
    if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
      p = (unsigned long int *)((char *)p + (signed long int)sz);

    else
    {
      n_bytes_found = n_bytes_found + (signed long int)sz;
      *((void **)p) = (void *)list;
      list = (char *)p;
      q = (unsigned long int *)((char *)p + (signed long int)sz);
      p[(signed long int)1] = (unsigned long int)0;
      p = p + (signed long int)2;
      for( ; !((unsigned long int)p >= (unsigned long int)q); p = p + (signed long int)2)
      {
        ((unsigned long int *)p)[(signed long int)0] = (unsigned long int)0;
        ((unsigned long int *)p)[(signed long int)1] = (unsigned long int)0;
      }
    }
  *count = *count + n_bytes_found;
  return list;
}

// GC_reclaim_generic
// file ./include/private/gc_priv.h line 1793
char * GC_reclaim_generic(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, signed int init, char *list, signed long int *count)
{
  char *result;
  GC_remove_protection(hbp, (unsigned long int)1, (signed int)(hhdr->hb_descr == (unsigned long int)0));
  if(!((8 & (signed int)hhdr->hb_flags) == 0))
    result=GC_disclaim_and_reclaim(hbp, hhdr, sz, list, count);

  else
    if(!(GC_debugging_started == 0) || !(init == 0))
      result=GC_reclaim_clear(hbp, hhdr, sz, list, count);

    else
      result=GC_reclaim_uninit(hbp, hhdr, sz, list, count);
  if((-2 & (signed int)hhdr->hb_obj_kind) == 2)
    GC_set_hdr_marks(hhdr);

  return result;
}

// GC_reclaim_small_nonempty_block
// file reclaim.c line 327
void GC_reclaim_small_nonempty_block(struct hblk *hbp, signed int report_if_found)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)hbp);
  unsigned long int sz = hhdr->hb_sz;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
  void **flh = &ok->ok_freelist[(signed long int)(sz >> 4)];
  hhdr->hb_last_reclaimed = (unsigned short int)GC_gc_no;
  if(!(report_if_found == 0))
    GC_reclaim_check(hbp, hhdr, sz);

  else
  {
    char *return_value_GC_reclaim_generic_1;
    return_value_GC_reclaim_generic_1=GC_reclaim_generic(hbp, hhdr, sz, ok->ok_init, (char *)*flh, &GC_bytes_found);
    *flh = (void *)return_value_GC_reclaim_generic_1;
  }
}

// GC_reclaim_unconditionally_marked
// file reclaim.c line 747
void GC_reclaim_unconditionally_marked(void)
{
  unsigned long int sz;
  unsigned int kind;
  struct hblkhdr *hhdr;
  struct hblk *hbp;
  struct obj_kind *ok;
  struct hblk **rlp;
  struct hblk **rlh;
  kind = (unsigned int)0;
  for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
  {
    ok = &GC_obj_kinds[(signed long int)kind];
    if(!(ok->ok_mark_unconditionally == 0))
    {
      rlp = ok->ok_reclaim_list;
      if(!(rlp == ((struct hblk **)NULL)))
      {
        sz = (unsigned long int)1;
        for( ; !(sz >= 129ul); sz = sz + 1ul)
        {
          rlh = rlp + (signed long int)sz;
          do
          {
            hbp = *rlh;
            if(hbp == ((struct hblk *)NULL))
              break;

            hhdr=GC_find_header((char *)hbp);
            *rlh = hhdr->hb_next;
            GC_reclaim_small_nonempty_block(hbp, 0);
          }
          while((_Bool)1);
        }
      }

    }

  }
}

// GC_reclaim_uninit
// file reclaim.c line 193
char * GC_reclaim_uninit(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count)
{
  unsigned long int bit_no = (unsigned long int)0;
  unsigned long int *p;
  unsigned long int *plim;
  signed long int n_bytes_found = (signed long int)0;
  p = (unsigned long int *)hbp->hb_body;
  plim = (unsigned long int *)(((char *)hbp + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz);
  for( ; (unsigned long int)plim >= (unsigned long int)p; bit_no = bit_no + (sz >> 4))
  {
    if(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0)
    {
      n_bytes_found = n_bytes_found + (signed long int)sz;
      *((void **)p) = (void *)list;
      list = (char *)p;
    }

    p = (unsigned long int *)((char *)p + (signed long int)sz);
  }
  *count = *count + n_bytes_found;
  return list;
}

// GC_record_stack_base
// file pthread_support.c line 1506
static inline void GC_record_stack_base(struct GC_Thread_Rep *me, struct GC_stack_base *sb)
{
  me->stop_info.stack_ptr = (char *)sb->mem_base;
  me->stack_end = (char *)sb->mem_base;
  if(me->stack_end == ((char *)NULL))
  {
    GC_on_abort("Bad stack base in GC_register_my_thread");
    abort();
  }

}

// GC_register_data_segments
// file ./include/private/gc_priv.h line 1677
void GC_register_data_segments(void)
{
  GC_add_roots_inner(GC_data_start, (char *)_end, 0);
}

// GC_register_describe_type_fn
// file dbg_mlc.c line 318
extern void GC_register_describe_type_fn(signed int kind, void (*fn)(void *, char *))
{
  GC_describe_type_fns[(signed long int)kind] = fn;
}

// GC_register_disappearing_link
// file finalize.c line 137
extern signed int GC_register_disappearing_link(void **link)
{
  char *base;
  void *return_value_GC_base_1;
  return_value_GC_base_1=GC_base((void *)link);
  base = (char *)return_value_GC_base_1;
  if(base == ((char *)NULL))
  {
    GC_on_abort("Bad arg to GC_register_disappearing_link");
    abort();
  }

  signed int return_value_GC_general_register_disappearing_link_2;
  return_value_GC_general_register_disappearing_link_2=GC_general_register_disappearing_link(link, (const void *)base);
  return return_value_GC_general_register_disappearing_link_2;
}

// GC_register_disappearing_link_inner
// file finalize.c line 147
signed int GC_register_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link, const void *obj)
{
  struct disappearing_link *curr_dl;
  unsigned long int index;
  struct disappearing_link *new_dl;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  _Bool tmp_if_expr_2;
  if(dl_hashtbl->log_size == -1l)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = dl_hashtbl->entries > (unsigned long int)1 << dl_hashtbl->log_size ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    GC_grow_table((struct hash_chain_entry ***)&dl_hashtbl->head, &dl_hashtbl->log_size);
    if(!(GC_print_stats == 0))
      GC_log_printf("Grew dl table to %u entries\n", 1 << (unsigned int)dl_hashtbl->log_size);

  }

  index = ((unsigned long int)link >> 3 ^ (unsigned long int)link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
  curr_dl = dl_hashtbl->head[(signed long int)index];
  for( ; !(curr_dl == ((struct disappearing_link *)NULL)); curr_dl = (struct disappearing_link *)curr_dl->prolog.next)
    if(curr_dl->prolog.hidden_key == ~((unsigned long int)link))
    {
      curr_dl->dl_hidden_obj = ~((unsigned long int)obj);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      return 1;
    }

  void *return_value_GC_generic_malloc_inner_3;
  return_value_GC_generic_malloc_inner_3=GC_generic_malloc_inner(sizeof(struct disappearing_link) /*24ul*/ , 1);
  new_dl = (struct disappearing_link *)return_value_GC_generic_malloc_inner_3;
  if(new_dl == ((struct disappearing_link *)NULL))
  {
    void * (*oom_fn)(unsigned long int) = GC_oom_fn;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    void *return_value;
    return_value=oom_fn(sizeof(struct disappearing_link) /*24ul*/ );
    new_dl = (struct disappearing_link *)return_value;
    if(new_dl == ((struct disappearing_link *)NULL))
      return 2;

    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_4;
      return_value_pthread_mutex_trylock_4=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_4 == 0))
        GC_lock();

    }

    index = ((unsigned long int)link >> 3 ^ (unsigned long int)link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
    curr_dl = dl_hashtbl->head[(signed long int)index];
    if(!(curr_dl == ((struct disappearing_link *)NULL)))
    {
      if(curr_dl->prolog.hidden_key == ~((unsigned long int)link))
      {
        curr_dl->dl_hidden_obj = ~((unsigned long int)obj);
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

        GC_free((void *)new_dl);
        return 1;
      }

      curr_dl = (struct disappearing_link *)curr_dl->prolog.next;
    }

  }

  new_dl->dl_hidden_obj = ~((unsigned long int)obj);
  new_dl->prolog.hidden_key = ~((unsigned long int)link);
  new_dl->prolog.next = (struct hash_chain_entry *)dl_hashtbl->head[(signed long int)index];
  dl_hashtbl->head[(signed long int)index] = new_dl;
  dl_hashtbl->entries = dl_hashtbl->entries + 1ul;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return 0;
}

// GC_register_disclaim_proc
// file fnlz_mlc.c line 76
extern void GC_register_disclaim_proc(signed int kind, signed int (*proc)(void *), signed int mark_unconditionally)
{
  GC_obj_kinds[(signed long int)kind].ok_disclaim_proc = proc;
  GC_obj_kinds[(signed long int)kind].ok_mark_unconditionally = (signed int)mark_unconditionally;
}

// GC_register_displacement
// file ./include/private/../gc.h line 535
extern void GC_register_displacement(unsigned long int offset)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_register_displacement_inner(offset);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_register_displacement_inner
// file ./include/private/gc_priv.h line 1738
void GC_register_displacement_inner(unsigned long int offset)
{
  if(offset >= 4096ul)
  {
    GC_on_abort("Bad argument to GC_register_displacement");
    abort();
  }

  if(GC_arrays._valid_offsets[(signed long int)offset] == 0)
  {
    GC_arrays._valid_offsets[(signed long int)offset] = (char)1;
    GC_arrays._modws_valid_offsets[(signed long int)(offset % sizeof(unsigned long int) /*8ul*/ )] = (char)1;
  }

}

// GC_register_dynamic_libraries
// file dyn_load.c line 707
void GC_register_dynamic_libraries(void)
{
  struct link_map *lm;
  signed int return_value_GC_register_dynamic_libraries_dl_iterate_phdr_1;
  return_value_GC_register_dynamic_libraries_dl_iterate_phdr_1=GC_register_dynamic_libraries_dl_iterate_phdr();
  if(return_value_GC_register_dynamic_libraries_dl_iterate_phdr_1 == 0)
  {
    lm=GC_FirstDLOpenedLinkMap();
    for( ; !(lm == ((struct link_map *)NULL)); lm = lm->l_next)
    {
      struct anonymous_24 *e;
      struct anonymous_20 *p;
      unsigned long int offset;
      char *start;
      signed int i;
      e = (struct anonymous_24 *)lm->l_addr;
      p = (struct anonymous_20 *)((char *)e + (signed long int)e->e_phoff);
      offset = (unsigned long int)lm->l_addr;
      i = 0;
      for( ; !(i >= (signed int)e->e_phnum); p = p + 1l)
      {
        if(p->p_type == 1u)
        {
          if(!((2u & p->p_flags) == 0u))
          {
            start = (char *)p->p_vaddr + (signed long int)offset;
            GC_add_roots_inner(start, start + (signed long int)p->p_memsz, 1);
          }

        }

        i = i + 1;
      }
    }
  }

}

// GC_register_dynamic_libraries_dl_iterate_phdr
// file dyn_load.c line 568
signed int GC_register_dynamic_libraries_dl_iterate_phdr(void)
{
  signed int did_something;
  signed int return_value_GC_register_main_static_data_1;
  return_value_GC_register_main_static_data_1=GC_register_main_static_data();
  if(!(return_value_GC_register_main_static_data_1 == 0))
    return 0;

  else
  {
    n_load_segs = 0;
    static signed int excluded_segs = 0;
    if((signed long int)excluded_segs == 0l)
    {
      GC_exclude_static_roots_inner((void *)(char *)load_segs, (void *)((char *)load_segs + (signed long int)sizeof(struct load_segment [2048l]) /*65536ul*/ ));
      excluded_segs = 1;
    }

    did_something = 0;
    dl_iterate_phdr(GC_register_dynlib_callback, (void *)&did_something);
    if(!(did_something == 0))
    {
      signed int i = 0;
      for( ; !(i >= n_load_segs); i = i + 1)
      {
        if(!((unsigned long int)load_segs[(signed long int)i].start >= (unsigned long int)load_segs[(signed long int)i].end))
          GC_add_roots_inner(load_segs[(signed long int)i].start, load_segs[(signed long int)i].end, 1);

        if(!((unsigned long int)load_segs[(signed long int)i].start2 >= (unsigned long int)load_segs[(signed long int)i].end2))
          GC_add_roots_inner(load_segs[(signed long int)i].start2, load_segs[(signed long int)i].end2, 1);

      }
    }

    else
    {
      char *datastart;
      char *dataend;
      datastart = GC_data_start;
      dataend = (char *)_end;
      GC_add_roots_inner(datastart, dataend, 1);
    }
    return 1;
  }
}

// GC_register_dynlib_callback
// file dyn_load.c line 469
signed int GC_register_dynlib_callback(struct dl_phdr_info *info, unsigned long int size, void *ptr)
{
  const struct anonymous_20 *p;
  char *start;
  char *end;
  signed int i;
  signed int return_value;
  if(!(size >= sizeof(unsigned short int) * 13 /*26ul*/ ))
    return -1;

  else
  {
    p = info->dlpi_phdr;
    i = 0;
    for( ; !(i >= (signed int)info->dlpi_phnum); p = p + 1l)
    {
      switch(p->p_type)
      {
        case (unsigned int)0x6474e552:
        {
          signed int j;
          start = (char *)p->p_vaddr + (signed long int)info->dlpi_addr;
          end = start + (signed long int)p->p_memsz;
          j = n_load_segs;
          do
          {
            j = j - 1;
            if(!(j >= 0))
              break;

            if((unsigned long int)start >= (unsigned long int)load_segs[(signed long int)j].start)
            {
              if(!((unsigned long int)start >= (unsigned long int)load_segs[(signed long int)j].end))
              {
                if(!(load_segs[(signed long int)j].start2 == ((char *)NULL)))
                  GC_current_warn_proc("GC Warning: More than one GNU_RELRO segment per load seg\n", (unsigned long int)0);

                else
                {
                  load_segs[(signed long int)j].end2 = load_segs[(signed long int)j].end;
                  load_segs[(signed long int)j].end = start;
                  load_segs[(signed long int)j].start2 = end;
                }
                break;
              }

            }

            if(j == 0)
              GC_current_warn_proc("GC Warning: Failed to find PT_GNU_RELRO segment inside PT_LOAD region", (unsigned long int)0);

          }
          while((_Bool)1);
          break;
        }
        case (unsigned int)1:
        {
          signed int (*callback)(const char *, void *, unsigned long int) = GC_has_static_roots;
          if(!((2u & p->p_flags) == 0u))
          {
            start = (char *)p->p_vaddr + (signed long int)info->dlpi_addr;
            end = start + (signed long int)p->p_memsz;
            if(!(callback == ((signed int (*)(const char *, void *, unsigned long int))NULL)))
            {
              return_value=callback(info->dlpi_name, (void *)start, p->p_memsz);
              if(return_value == 0)
                break;

            }

            if(n_load_segs >= 2048)
            {
              GC_on_abort("Too many PT_LOAD segs");
              abort();
            }

            start = (char *)((unsigned long int)start & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
            load_segs[(signed long int)n_load_segs].start = start;
            load_segs[(signed long int)n_load_segs].end = end;
            load_segs[(signed long int)n_load_segs].start2 = ((char *)NULL);
            load_segs[(signed long int)n_load_segs].end2 = ((char *)NULL);
            n_load_segs = n_load_segs + 1;
          }

        }
      }
      i = i + 1;
    }
    *((signed int *)ptr) = 1;
    return 0;
  }
}

// GC_register_finalizer
// file ./include/private/../gc.h line 914
extern void GC_register_finalizer(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, GC_normal_finalize_mark_proc);
}

// GC_register_finalizer_ignore_self
// file ./include/private/../gc.h line 970
extern void GC_register_finalizer_ignore_self(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, GC_ignore_self_finalize_mark_proc);
}

// GC_register_finalizer_inner
// file finalize.c line 433
void GC_register_finalizer_inner(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd, void (*mp)(char *))
{
  char *base;
  struct finalizable_object *curr_fo;
  struct finalizable_object *prev_fo;
  unsigned long int index;
  struct finalizable_object *new_fo = ((struct finalizable_object *)NULL);
  struct hblkhdr *hhdr = (struct hblkhdr *)(void *)0;
  void * (*oom_fn)(unsigned long int);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(log_fo_table_size == -1l || !(1ul << log_fo_table_size >= GC_fo_entries))
  {
    GC_grow_table((struct hash_chain_entry ***)&GC_fo_head, &log_fo_table_size);
    if(!(GC_print_stats == 0))
      GC_log_printf("Grew fo table to %u entries\n", 1 << (unsigned int)log_fo_table_size);

  }

  base = (char *)obj;
  index = ((unsigned long int)base >> 3 ^ (unsigned long int)base >> (signed long int)3 + log_fo_table_size) & (unsigned long int)((1 << log_fo_table_size) - 1);
  prev_fo = ((struct finalizable_object *)NULL);
  curr_fo = GC_fo_head[(signed long int)index];
  for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = (struct finalizable_object *)curr_fo->prolog.next)
  {
    if(curr_fo->prolog.hidden_key == ~((unsigned long int)base))
    {
      if(!(ocd == ((void **)NULL)))
        *ocd = (void *)curr_fo->fo_client_data;

      if(!(ofn == ((void (**)(void *, void *))NULL)))
        *ofn = curr_fo->fo_fn;

      if(prev_fo == ((struct finalizable_object *)NULL))
        GC_fo_head[(signed long int)index] = (struct finalizable_object *)curr_fo->prolog.next;

      else
        prev_fo->prolog.next = (struct hash_chain_entry *)(struct finalizable_object *)curr_fo->prolog.next;
      if(fn == ((void (*)(void *, void *))NULL))
        GC_fo_entries = GC_fo_entries - 1ul;

      else
      {
        curr_fo->fo_fn = fn;
        curr_fo->fo_client_data = (char *)cd;
        curr_fo->fo_mark_proc = mp;
        if(prev_fo == ((struct finalizable_object *)NULL))
          GC_fo_head[(signed long int)index] = curr_fo;

        else
          prev_fo->prolog.next = (struct hash_chain_entry *)curr_fo;
      }
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      if(!(new_fo == ((struct finalizable_object *)NULL)))
        GC_free((void *)new_fo);

      goto __CPROVER_DUMP_L41;
    }

    prev_fo = curr_fo;
  }
  if(new_fo == ((struct finalizable_object *)NULL))
  {
    if(fn == ((void (*)(void *, void *))NULL))
    {
      if(!(ocd == ((void **)NULL)))
        *ocd = NULL;

      if(!(ofn == ((void (**)(void *, void *))NULL)))
        *ofn = ((void (*)(void *, void *))NULL);

      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      goto __CPROVER_DUMP_L41;
    }

    do
    {
      struct hblkhdr **_ha;
      do
      {
        struct bi *bi;
        do
        {
          unsigned long int hi = (unsigned long int)base >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(_bi->key == hi); _bi = _bi->hash_link)
            if(_bi == GC_arrays._all_nils)
              break;

          bi = _bi;
        }
        while((_Bool)0);
        _ha = &bi->index[(signed long int)((unsigned long int)base >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      hhdr = *_ha;
    }
    while((_Bool)0);
    if(hhdr == ((struct hblkhdr *)NULL))
    {
      if(!(ocd == ((void **)NULL)))
        *ocd = NULL;

      if(!(ofn == ((void (**)(void *, void *))NULL)))
        *ofn = ((void (*)(void *, void *))NULL);

      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      goto __CPROVER_DUMP_L41;
    }

    void *return_value_GC_generic_malloc_inner_2;
    return_value_GC_generic_malloc_inner_2=GC_generic_malloc_inner(sizeof(struct finalizable_object) /*48ul*/ , 1);
    new_fo = (struct finalizable_object *)return_value_GC_generic_malloc_inner_2;
    if(new_fo == ((struct finalizable_object *)NULL))
    {
      oom_fn = GC_oom_fn;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value;
      return_value=oom_fn(sizeof(struct finalizable_object) /*48ul*/ );
      new_fo = (struct finalizable_object *)return_value;
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_3;
        return_value_pthread_mutex_trylock_3=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_3 == 0))
          GC_lock();

      }

    }

  }

  if(!(ocd == ((void **)NULL)))
    *ocd = NULL;

  if(!(ofn == ((void (**)(void *, void *))NULL)))
    *ofn = ((void (*)(void *, void *))NULL);

  new_fo->prolog.hidden_key = ~((unsigned long int)base);
  new_fo->fo_fn = fn;
  new_fo->fo_client_data = (char *)cd;
  new_fo->fo_object_size = hhdr->hb_sz;
  new_fo->fo_mark_proc = mp;
  new_fo->prolog.next = (struct hash_chain_entry *)GC_fo_head[(signed long int)index];
  GC_fo_entries = GC_fo_entries + 1ul;
  GC_fo_head[(signed long int)index] = new_fo;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);

__CPROVER_DUMP_L41:
  ;
}

// GC_register_finalizer_no_order
// file ./include/private/../gc.h line 983
extern void GC_register_finalizer_no_order(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, GC_null_finalize_mark_proc);
}

// GC_register_finalizer_unreachable
// file ./include/private/../gc.h line 1008
extern void GC_register_finalizer_unreachable(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  need_unreachable_finalization = 1;
  GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, GC_unreachable_finalize_mark_proc);
}

// GC_register_has_static_roots_callback
// file dyn_load.c line 1503
extern void GC_register_has_static_roots_callback(signed int (*callback)(const char *, void *, unsigned long int))
{
  GC_has_static_roots = callback;
}

// GC_register_long_link
// file finalize.c line 267
extern signed int GC_register_long_link(void **link, const void *obj)
{
  if(link == ((void **)NULL) || !((7ul & (unsigned long int)link) == 0ul))
  {
    GC_on_abort("Bad arg to GC_register_long_link");
    abort();
  }

  signed int return_value_GC_register_disappearing_link_inner_1;
  return_value_GC_register_disappearing_link_inner_1=GC_register_disappearing_link_inner(&GC_ll_hashtbl, link, obj);
  return return_value_GC_register_disappearing_link_inner_1;
}

// GC_register_main_static_data
// file dyn_load.c line 556
signed int GC_register_main_static_data(void)
{
  return (signed int)(dl_iterate_phdr == ((signed int (*)(signed int (*)(struct dl_phdr_info *, unsigned long int, void *), void *))NULL));
}

// GC_register_my_thread
// file pthread_support.c line 1550
extern signed int GC_register_my_thread(struct GC_stack_base *sb)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  if(GC_need_to_lock == 0)
  {
    GC_on_abort("Threads explicit registering is not previously enabled");
    abort();
  }

  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  if(me == ((struct GC_Thread_Rep *)NULL))
  {
    me=GC_register_my_thread_inner(sb, self);
    me->flags = me->flags | (unsigned char)2;
    GC_init_thread_local(&me->tlfs);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return 0;
  }

  else
    if(!((1 & (signed int)me->flags) == 0))
    {
      GC_record_stack_base(me, sb);
      me->flags = me->flags & (unsigned char)~1;
      GC_init_thread_local(&me->tlfs);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      return 0;
    }

    else
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      return 1;
    }
}

// GC_register_my_thread_inner
// file pthread_support.c line 1520
struct GC_Thread_Rep * GC_register_my_thread_inner(struct GC_stack_base *sb, unsigned long int my_pthread)
{
  struct GC_Thread_Rep *me;
  GC_in_thread_creation = 1;
  me=GC_new_thread(my_pthread);
  GC_in_thread_creation = 0;
  if(me == ((struct GC_Thread_Rep *)NULL))
  {
    GC_on_abort("Failed to allocate memory for thread registering");
    abort();
  }

  GC_record_stack_base(me, sb);
  return me;
}

// GC_release_mark_lock
// file ./include/private/gc_priv.h line 2372
void GC_release_mark_lock(void)
{
  signed int return_value_pthread_mutex_unlock_1;
  return_value_pthread_mutex_unlock_1=pthread_mutex_unlock(&mark_mutex);
  if(!(return_value_pthread_mutex_unlock_1 == 0))
  {
    GC_on_abort("pthread_mutex_unlock failed");
    abort();
  }

}

// GC_remove_all_threads_but_me
// file pthread_support.c line 664
void GC_remove_all_threads_but_me(void)
{
  unsigned long int self;
  self=pthread_self();
  signed int hv;
  struct GC_Thread_Rep *p;
  struct GC_Thread_Rep *next;
  struct GC_Thread_Rep *me;
  hv = 0;
  for( ; !(hv >= 256); hv = hv + 1)
  {
    me = ((struct GC_Thread_Rep *)NULL);
    p = GC_threads[(signed long int)hv];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = next)
    {
      next = p->next;
      if(p->id == self)
      {
        me = p;
        p->next = ((struct GC_Thread_Rep *)NULL);
        GC_thread_key = (void *)&me->tlfs;
      }

      else
      {
        if((1 & (signed int)p->flags) == 0)
          GC_destroy_thread_local(&p->tlfs);

        if(!(p == &first_thread))
          GC_free_inner((void *)p);

      }
    }
    GC_threads[(signed long int)hv] = me;
  }
}

// GC_remove_allowed_signals
// file pthread_stop_world.c line 82
void GC_remove_allowed_signals(struct anonymous_0 *set)
{
  signed int return_value_sigdelset_1;
  return_value_sigdelset_1=sigdelset(set, 2);
  _Bool tmp_if_expr_3;
  signed int return_value_sigdelset_2;
  if(!(return_value_sigdelset_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_sigdelset_2=sigdelset(set, 3);
    tmp_if_expr_3 = return_value_sigdelset_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_sigdelset_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_sigdelset_4=sigdelset(set, 6);
    tmp_if_expr_5 = return_value_sigdelset_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_sigdelset_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_sigdelset_6=sigdelset(set, 15);
    tmp_if_expr_7 = return_value_sigdelset_6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_7)
  {
    GC_on_abort("sigdelset failed");
    abort();
  }

  signed int return_value_sigdelset_8;
  return_value_sigdelset_8=sigdelset(set, 11);
  _Bool tmp_if_expr_10;
  signed int return_value_sigdelset_9;
  if(!(return_value_sigdelset_8 == 0))
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    return_value_sigdelset_9=sigdelset(set, 7);
    tmp_if_expr_10 = return_value_sigdelset_9 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_10)
  {
    GC_on_abort("sigdelset failed");
    abort();
  }

}

// GC_remove_counts
// file ./include/private/gc_priv.h line 1893
void GC_remove_counts(struct hblk *h, unsigned long int sz)
{
  struct hblk *hbp = h + (signed long int)1;
  for( ; !((unsigned long int)hbp >= sz + (unsigned long int)h); hbp = hbp + (signed long int)1)
    do
    {
      struct hblkhdr **_ha;
      do
      {
        struct bi *bi;
        do
        {
          unsigned long int hi = (unsigned long int)hbp >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(_bi->key == hi); _bi = _bi->hash_link)
            if(_bi == GC_arrays._all_nils)
              break;

          bi = _bi;
        }
        while((_Bool)0);
        _ha = &bi->index[(signed long int)((unsigned long int)hbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      *_ha = ((struct hblkhdr *)NULL);
    }
    while((_Bool)0);
}

// GC_remove_dangling_disappearing_links
// file finalize.c line 719
static inline void GC_remove_dangling_disappearing_links(struct dl_hashtbl_s *dl_hashtbl)
{
  struct disappearing_link *curr;
  struct disappearing_link *prev;
  struct disappearing_link *next;
  char *real_link;
  unsigned long int i;
  unsigned long int dl_size;
  signed int tmp_if_expr_1;
  if(dl_hashtbl->log_size == -1l)
    tmp_if_expr_1 = 0;

  else
    tmp_if_expr_1 = 1 << dl_hashtbl->log_size;
  dl_size = (unsigned long int)tmp_if_expr_1;
  i = (unsigned long int)0;
  signed int return_value_GC_is_marked_3;
  for( ; !(i >= dl_size); i = i + 1ul)
  {
    curr = dl_hashtbl->head[(signed long int)i];
    prev = (struct disappearing_link *)(void *)0;
    while(!(curr == ((struct disappearing_link *)NULL)))
    {
      void *return_value_GC_base_2;
      return_value_GC_base_2=GC_base((void *)~((unsigned long int)curr->prolog.hidden_key));
      real_link = (char *)return_value_GC_base_2;
      if(!(real_link == ((char *)NULL)))
      {
        return_value_GC_is_marked_3=GC_is_marked((const void *)real_link);
        if(return_value_GC_is_marked_3 == 0)
        {
          GC_clear_mark_bit((const void *)curr);
          next = (struct disappearing_link *)curr->prolog.next;
          if(prev == ((struct disappearing_link *)NULL))
            dl_hashtbl->head[(signed long int)i] = next;

          else
            prev->prolog.next = (struct hash_chain_entry *)next;
          GC_clear_mark_bit((const void *)curr);
          dl_hashtbl->entries = dl_hashtbl->entries - 1ul;
          curr = next;
          continue;
        }

      }

      prev = curr;
      curr = (struct disappearing_link *)curr->prolog.next;
    }
  }
}

// GC_remove_from_fl
// file allchblk.c line 317
static inline void GC_remove_from_fl(struct hblkhdr *hhdr)
{
  signed int return_value_GC_hblk_fl_from_blocks_1;
  return_value_GC_hblk_fl_from_blocks_1=GC_hblk_fl_from_blocks(hhdr->hb_sz >> (unsigned long int)12);
  GC_remove_from_fl_at(hhdr, return_value_GC_hblk_fl_from_blocks_1);
}

// GC_remove_from_fl_at
// file allchblk.c line 293
void GC_remove_from_fl_at(struct hblkhdr *hhdr, signed int index)
{
  if(hhdr->hb_prev == ((struct hblk *)NULL))
    GC_hblkfreelist[(signed long int)index] = hhdr->hb_next;

  else
  {
    struct hblkhdr *phdr;
    do
    {
      struct hblkhdr **_ha;
      do
      {
        struct bi *GC_remove_from_fl_at__1__2__1__1__bi;
        do
        {
          unsigned long int hi = (unsigned long int)hhdr->hb_prev >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(_bi->key == hi); _bi = _bi->hash_link)
            if(_bi == GC_arrays._all_nils)
              break;

          GC_remove_from_fl_at__1__2__1__1__bi = _bi;
        }
        while((_Bool)0);
        _ha = &GC_remove_from_fl_at__1__2__1__1__bi->index[(signed long int)((unsigned long int)hhdr->hb_prev >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      phdr = *_ha;
    }
    while((_Bool)0);
    phdr->hb_next = hhdr->hb_next;
  }
  GC_free_bytes[(signed long int)index] = GC_free_bytes[(signed long int)index] - hhdr->hb_sz;
  if(!(hhdr->hb_next == ((struct hblk *)NULL)))
  {
    struct hblkhdr *nhdr;
    do
    {
      struct hblkhdr **GC_remove_from_fl_at__1__3__1___ha;
      do
      {
        struct bi *bi;
        do
        {
          unsigned long int GC_remove_from_fl_at__1__3__1__1__1__hi = (unsigned long int)hhdr->hb_next >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *GC_remove_from_fl_at__1__3__1__1__1___bi = GC_arrays._top_index[(signed long int)(GC_remove_from_fl_at__1__3__1__1__1__hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(GC_remove_from_fl_at__1__3__1__1__1___bi->key == GC_remove_from_fl_at__1__3__1__1__1__hi); GC_remove_from_fl_at__1__3__1__1__1___bi = GC_remove_from_fl_at__1__3__1__1__1___bi->hash_link)
            if(GC_remove_from_fl_at__1__3__1__1__1___bi == GC_arrays._all_nils)
              break;

          bi = GC_remove_from_fl_at__1__3__1__1__1___bi;
        }
        while((_Bool)0);
        GC_remove_from_fl_at__1__3__1___ha = &bi->index[(signed long int)((unsigned long int)hhdr->hb_next >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      nhdr = *GC_remove_from_fl_at__1__3__1___ha;
    }
    while((_Bool)0);
    nhdr->hb_prev = hhdr->hb_prev;
  }

}

// GC_remove_header
// file ./include/private/gc_priv.h line 1891
void GC_remove_header(struct hblk *h)
{
  struct hblkhdr **ha;
  do
  {
    struct bi *bi;
    do
    {
      unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
      struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
      for( ; !(_bi->key == hi); _bi = _bi->hash_link)
        if(_bi == GC_arrays._all_nils)
          break;

      bi = _bi;
    }
    while((_Bool)0);
    ha = &bi->index[(signed long int)((unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
  }
  while((_Bool)0);
  free_hdr(*ha);
  *ha = ((struct hblkhdr *)NULL);
}

// GC_remove_protection
// file ./include/private/gc_priv.h line 2033
void GC_remove_protection(struct hblk *h, unsigned long int nblocks, signed int is_ptrfree)
{
  struct hblk *h_trunc;
  struct hblk *h_end;
  struct hblk *current;
  if(!(GC_dirty_maintained == 0))
  {
    h_trunc = (struct hblk *)((unsigned long int)h & ~(GC_page_size - (unsigned long int)1));
    h_end = (struct hblk *)(((unsigned long int)(h + (signed long int)nblocks) + GC_page_size) - (unsigned long int)1 & ~(GC_page_size - (unsigned long int)1));
    if(h_end == h_trunc + 1l)
    {
      if((1ul & GC_arrays._dirty_pages[(signed long int)((262143ul & (unsigned long int)h_trunc >> 12ul) >> 6ul)] >> (63ul & (unsigned long int)h_trunc >> 12ul)) == 0ul)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      current = h_trunc;
      for( ; !((unsigned long int)current >= (unsigned long int)h_end); current = current + 1l)
      {
        unsigned long int index = (unsigned long int)current >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
        if(is_ptrfree == 0 || (unsigned long int)current >= (unsigned long int)(h + (signed long int)nblocks) || !((unsigned long int)current >= (unsigned long int)h))
          async_set_pht_entry_from_index(GC_arrays._dirty_pages, index);

      }
      signed int return_value_mprotect_1;
      return_value_mprotect_1=mprotect((void *)(char *)h_trunc, (unsigned long int)((char *)h_end - (char *)h_trunc), 0x1 | 0x2 | (GC_pages_executable != 0 ? 0x4 : 0));
      if(!(return_value_mprotect_1 >= 0))
      {
        GC_on_abort(GC_pages_executable != 0 ? "un-mprotect executable page failed (probably disabled by OS)" : "un-mprotect failed");
        abort();
      }

    }
  }

}

// GC_remove_root_at_pos
// file mark_rts.c line 284
void GC_remove_root_at_pos(signed int i)
{
  GC_root_size = GC_root_size - (unsigned long int)(GC_arrays._static_roots[(signed long int)i].r_end - GC_arrays._static_roots[(signed long int)i].r_start);
  GC_arrays._static_roots[(signed long int)i].r_start = GC_arrays._static_roots[(signed long int)(n_root_sets - 1)].r_start;
  GC_arrays._static_roots[(signed long int)i].r_end = GC_arrays._static_roots[(signed long int)(n_root_sets - 1)].r_end;
  GC_arrays._static_roots[(signed long int)i].r_tmp = GC_arrays._static_roots[(signed long int)(n_root_sets - 1)].r_tmp;
  n_root_sets = n_root_sets - 1;
}

// GC_remove_roots
// file mark_rts.c line 331
extern void GC_remove_roots(void *b, void *e)
{
  if(!((7ul + (unsigned long int)b & 18446744073709551608ul) >= (18446744073709551608ul & (unsigned long int)e)))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_remove_roots_inner((char *)b, (char *)e);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

}

// GC_remove_roots_inner
// file mark_rts.c line 346
void GC_remove_roots_inner(char *b, char *e)
{
  signed int i = 0;
  while(!(i >= n_root_sets))
  {
    _Bool tmp_if_expr_1;
    if((unsigned long int)GC_arrays._static_roots[(signed long int)i].r_start >= (unsigned long int)b)
      tmp_if_expr_1 = (unsigned long int)GC_arrays._static_roots[(signed long int)i].r_end <= (unsigned long int)e ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      GC_remove_root_at_pos(i);

    else
      i = i + 1;
  }
  GC_rebuild_root_index();
}

// GC_remove_tmp_roots
// file mark_rts.c line 311
void GC_remove_tmp_roots(void)
{
  signed int i = 0;
  while(!(i >= n_root_sets))
    if(!(GC_arrays._static_roots[(signed long int)i].r_tmp == 0))
      GC_remove_root_at_pos(i);

    else
      i = i + 1;
  GC_rebuild_root_index();
}

// GC_repeat_read
// file os_dep.c line 145
signed long int GC_repeat_read(signed int fd, char *buf, unsigned long int count)
{
  unsigned long int num_read = (unsigned long int)0;
  signed long int result;
  for( ; !(num_read >= count); num_read = num_read + (unsigned long int)result)
  {
    result=read(fd, (void *)(buf + (signed long int)num_read), count - num_read);
    if(!(result >= 0l))
      return result;

    if(result == 0l)
      break;

  }
  return (signed long int)num_read;
}

// GC_reset_fault_handler
// file os_dep.c line 935
void GC_reset_fault_handler(void)
{
  signal(11, old_segv_handler);
  signal(7, old_bus_handler);
}

// GC_reset_finalizer_nested
// file ./include/private/gc_priv.h line 2269
void GC_reset_finalizer_nested(void)
{
  struct GC_Thread_Rep *me;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  me=GC_lookup_thread(return_value_pthread_self_1);
  me->finalizer_nested = (unsigned char)0;
}

// GC_restart_handler
// file pthread_stop_world.c line 311
void GC_restart_handler(signed int sig)
{
  if(!(sig == GC_sig_thr_restart))
  {
    GC_on_abort("Bad signal in restart handler");
    abort();
  }

}

// GC_return_mark_stack
// file mark.c line 931
void GC_return_mark_stack(struct GC_ms_entry *low, struct GC_ms_entry *high)
{
  struct GC_ms_entry *my_top;
  struct GC_ms_entry *my_start;
  unsigned long int stack_size;
  if((unsigned long int)high >= (unsigned long int)low)
  {
    stack_size = (unsigned long int)((high - low) + (signed long int)1);
    GC_acquire_mark_lock();
    my_top = GC_arrays._mark_stack_top;
    my_start = my_top + (signed long int)1;
    if(!(GC_mark_stack_size >= stack_size + (unsigned long int)(my_start - GC_arrays._mark_stack)))
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("No room to copy back mark stack\n");

      GC_mark_state = 5;
      GC_mark_stack_too_small = 1;
    }

    else
    {
      memcpy((void *)my_start, (const void *)low, (unsigned long int)(stack_size * sizeof(struct GC_ms_entry) /*16ul*/ ));
      AO_nop_write();
      AO_store((volatile unsigned long int *)&GC_arrays._mark_stack_top, (unsigned long int)(my_top + (signed long int)stack_size));
    }
    GC_release_mark_lock();
    GC_notify_all_marker();
  }

}

// GC_roots_present
// file mark_rts.c line 127
void * GC_roots_present(char *b)
{
  signed int h;
  h=rt_hash(b);
  struct roots *p = GC_arrays._root_index[(signed long int)h];
  for( ; !(p == ((struct roots *)NULL)); p = p->r_next)
    if(p->r_start == b)
      return (void *)p;

  return (void *)0;
}

// GC_same_obj
// file ptr_chck.c line 39
extern void * GC_same_obj(void *p, void *q)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  char *base;
  char *limit;
  unsigned long int sz;
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  hhdr=GC_find_header((char *)(unsigned long int)p);
  struct hblkhdr *return_value_GC_find_header_1;
  if(hhdr == ((struct hblkhdr *)NULL))
  {
    if(!((unsigned long int)p >> 12ul == (unsigned long int)q >> 12ul))
    {
      return_value_GC_find_header_1=GC_find_header((char *)(unsigned long int)q);
      if(!(return_value_GC_find_header_1 == ((struct hblkhdr *)NULL)))
        goto fail;

    }

    return p;
  }

  if(!((unsigned long int)hhdr >= 4096ul))
  {
    h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1)) - (signed long int)(unsigned long int)hhdr;
    hhdr=GC_find_header((char *)h);
    while(!((unsigned long int)hhdr >= 4096ul))
    {
      h = (struct hblk *)h - (signed long int)(unsigned long int)hhdr;
      hhdr=GC_find_header((char *)h);
    }
    limit = (char *)h + (signed long int)hhdr->hb_sz;
    if((unsigned long int)p >= (unsigned long int)limit || (unsigned long int)q >= (unsigned long int)limit || !((unsigned long int)q >= (unsigned long int)h))
      goto fail;

    return p;
  }

  else
  {
    sz = hhdr->hb_sz;
    if(sz >= 2049ul)
    {
      base = (char *)(struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
      limit = base + (signed long int)sz;
      if((unsigned long int)p >= (unsigned long int)limit)
        goto fail;

    }

    else
    {
      unsigned long int offset;
      unsigned long int pdispl = (unsigned long int)p & (unsigned long int)(1 << 12) - (unsigned long int)1;
      offset = pdispl % sz;
      if(!((struct hblk *)(18446744073709547520ul & (unsigned long int)p) == (struct hblk *)(18446744073709547520ul & (unsigned long int)q)))
        goto fail;

      base = (char *)p - (signed long int)offset;
      limit = base + (signed long int)sz;
    }
    if(!((unsigned long int)q >= (unsigned long int)limit) && (unsigned long int)q >= (unsigned long int)base)
      return p;

    else
    {

    fail:
      ;
      GC_same_obj_print_proc((void *)(char *)p, (void *)(char *)q);
      return p;
    }
  }
}

// GC_scratch_alloc
// file ./include/private/gc_priv.h line 1728
char * GC_scratch_alloc(unsigned long int bytes)
{
  char *result = scratch_free_ptr;
  bytes = bytes + (unsigned long int)(16 - 1);
  bytes = bytes & (unsigned long int)~(16 - 1);
  scratch_free_ptr = scratch_free_ptr + (signed long int)bytes;
  if((unsigned long int)GC_arrays._scratch_end_ptr >= (unsigned long int)scratch_free_ptr)
    return result;

  else
  {
    unsigned long int bytes_to_get = (unsigned long int)16 * (unsigned long int)(1 << 12);
    if(bytes >= bytes_to_get)
    {
      bytes_to_get = (bytes + GC_page_size) - (unsigned long int)1 & ~(GC_page_size - (unsigned long int)1);
      char *return_value_GC_unix_get_mem_1;
      return_value_GC_unix_get_mem_1=GC_unix_get_mem(bytes_to_get);
      result = (char *)(struct hblk *)return_value_GC_unix_get_mem_1;
      scratch_free_ptr = scratch_free_ptr - (signed long int)bytes;
      if(!(result == ((char *)NULL)))
        GC_arrays._scratch_last_end_ptr = result + (signed long int)bytes;

      return result;
    }

    bytes_to_get = (bytes_to_get + GC_page_size) - (unsigned long int)1 & ~(GC_page_size - (unsigned long int)1);
    char *return_value_GC_unix_get_mem_2;
    return_value_GC_unix_get_mem_2=GC_unix_get_mem(bytes_to_get);
    result = (char *)(struct hblk *)return_value_GC_unix_get_mem_2;
    if(result == ((char *)NULL))
    {
      GC_current_warn_proc("GC Warning: Out of memory - trying to allocate less\n", (unsigned long int)0);
      scratch_free_ptr = scratch_free_ptr - (signed long int)bytes;
      bytes_to_get = (bytes + GC_page_size) - (unsigned long int)1 & ~(GC_page_size - (unsigned long int)1);
      char *return_value_GC_unix_get_mem_3;
      return_value_GC_unix_get_mem_3=GC_unix_get_mem(bytes_to_get);
      result = (char *)(struct hblk *)return_value_GC_unix_get_mem_3;
      return result;
    }

    scratch_free_ptr = result;
    GC_arrays._scratch_end_ptr = scratch_free_ptr + (signed long int)bytes_to_get;
    GC_arrays._scratch_last_end_ptr = GC_arrays._scratch_end_ptr;
    char *return_value_GC_scratch_alloc_4;
    return_value_GC_scratch_alloc_4=GC_scratch_alloc(bytes);
    return return_value_GC_scratch_alloc_4;
  }
}

// GC_set_abort_func
// file misc.c line 1695
extern void GC_set_abort_func(void (*fn)(const char *))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_on_abort = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_all_interior_pointers
// file misc.c line 2061
extern void GC_set_all_interior_pointers(signed int value)
{
  GC_all_interior_pointers = value != 0 ? 1 : 0;
  if(!(GC_is_initialized == 0))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_initialize_offsets();
    if(GC_all_interior_pointers == 0)
      GC_bl_init_no_interiors();

    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

}

// GC_set_and_save_fault_handler
// file ./include/private/gc_priv.h line 2297
void GC_set_and_save_fault_handler(void (*h)(signed int))
{
  old_segv_handler=signal(11, h);
  old_bus_handler=signal(7, h);
}

// GC_set_dont_expand
// file misc.c line 2107
extern void GC_set_dont_expand(signed int value)
{
  GC_dont_expand = value;
}

// GC_set_dont_precollect
// file misc.c line 2163
extern void GC_set_dont_precollect(signed int value)
{
  GC_dont_precollect = value;
}

// GC_set_finalize_on_demand
// file misc.c line 2083
extern void GC_set_finalize_on_demand(signed int value)
{
  GC_finalize_on_demand = value;
}

// GC_set_finalizer_notifier
// file misc.c line 2024
extern void GC_set_finalizer_notifier(void (*fn)(void))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_finalizer_notifier = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_find_leak
// file misc.c line 2050
extern void GC_set_find_leak(signed int value)
{
  GC_find_leak = value;
}

// GC_set_fl_marks
// file alloc.c line 687
void GC_set_fl_marks(char *q)
{
  struct hblk *h;
  struct hblk *last_h;
  struct hblkhdr *hhdr;
  unsigned int bit_no;
  if(!(q == ((char *)NULL)))
  {
    h = (struct hblk *)((unsigned long int)q & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    last_h = h;
    hhdr=GC_find_header((char *)h);
    do
    {
      bit_no = (unsigned int)((char *)q - (char *)h) >> 4;
      if(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0)
      {
        hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] = (char)1;
        hhdr->hb_n_marks = hhdr->hb_n_marks + 1ul;
      }

      q = (char *)*((void **)q);
      if(q == ((char *)NULL))
        break;

      h = (struct hblk *)((unsigned long int)q & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
      if(!(h == last_h))
      {
        last_h = h;
        hhdr=GC_find_header((char *)h);
      }

    }
    while((_Bool)1);
  }

}

// GC_set_force_unmap_on_gcollect
// file misc.c line 2197
extern void GC_set_force_unmap_on_gcollect(signed int value)
{
  GC_force_unmap_on_gcollect = (signed int)value;
}

// GC_set_free_space_divisor
// file misc.c line 2141
extern void GC_set_free_space_divisor(unsigned long int value)
{
  GC_free_space_divisor = value;
}

// GC_set_full_freq
// file misc.c line 2175
extern void GC_set_full_freq(signed int value)
{
  GC_full_freq = value;
}

// GC_set_handle_fork
// file misc.c line 204
extern void GC_set_handle_fork(signed int value)
{
  if(GC_is_initialized == 0)
    GC_handle_fork = value >= -1 ? value : 1;

}

// GC_set_hdr_marks
// file ./include/private/gc_priv.h line 1649
void GC_set_hdr_marks(struct hblkhdr *hhdr)
{
  unsigned int i;
  unsigned long int sz = hhdr->hb_sz;
  unsigned int n_marks = (unsigned int)(sz > (unsigned long int)((1 << 12) / 2) ? (unsigned long int)(1 << 12) / (unsigned long int)16 : sz * ((unsigned long int)(1 << 12) / sz) >> 4);
  i = (unsigned int)0;
  for( ; n_marks >= i; i = i + (unsigned int)(sz >> 4))
    hhdr->_mark_byte_union._hb_marks[(signed long int)i] = (char)1;
  hhdr->hb_n_marks = (unsigned long int)(1 << 12) / sz;
}

// GC_set_java_finalization
// file misc.c line 2095
extern void GC_set_java_finalization(signed int value)
{
  GC_java_finalization = value;
}

// GC_set_mark_bit
// file ./include/private/../gc_mark.h line 247
extern void GC_set_mark_bit(const void *p)
{
  struct hblk *h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  unsigned long int bit_no = (unsigned long int)((unsigned int)((char *)p - (char *)h) >> 4);
  if(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0)
  {
    hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] = (char)1;
    hhdr->hb_n_marks = hhdr->hb_n_marks + 1ul;
  }

}

// GC_set_max_heap_size
// file alloc.c line 1144
extern void GC_set_max_heap_size(unsigned long int n)
{
  GC_max_heapsize = n;
}

// GC_set_max_retries
// file misc.c line 2152
extern void GC_set_max_retries(unsigned long int value)
{
  GC_max_retries = value;
}

// GC_set_no_dls
// file misc.c line 2119
extern void GC_set_no_dls(signed int value)
{
  GC_no_dls = value;
}

// GC_set_non_gc_bytes
// file misc.c line 2131
extern void GC_set_non_gc_bytes(unsigned long int value)
{
  GC_non_gc_bytes = value;
}

// GC_set_on_heap_resize
// file misc.c line 2005
extern void GC_set_on_heap_resize(void (*fn)(unsigned long int))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_on_heap_resize = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_oom_fn
// file misc.c line 1986
extern void GC_set_oom_fn(void * (*fn)(unsigned long int))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_oom_fn = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_pages_executable
// file os_dep.c line 4435
extern void GC_set_pages_executable(signed int value)
{
  GC_pages_executable = (signed int)(value != 0);
}

// GC_set_push_other_roots
// file os_dep.c line 2610
extern void GC_set_push_other_roots(void (*fn)(void))
{
  GC_push_other_roots = fn;
}

// GC_set_start_callback
// file alloc.c line 316
extern void GC_set_start_callback(void (*fn)(void))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_start_call_back = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_stop_func
// file alloc.c line 149
extern void GC_set_stop_func(signed int (*stop_func)(void))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_default_stop_func = stop_func;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_suspend_signal
// file pthread_stop_world.c line 153
extern void GC_set_suspend_signal(signed int sig)
{
  if(GC_is_initialized == 0)
    GC_sig_suspend = sig;

}

// GC_set_thr_restart_signal
// file pthread_stop_world.c line 160
extern void GC_set_thr_restart_signal(signed int sig)
{
  if(GC_is_initialized == 0)
    GC_sig_thr_restart = sig;

}

// GC_set_time_limit
// file misc.c line 2186
extern void GC_set_time_limit(unsigned long int value)
{
  GC_time_limit = value;
}

// GC_set_warn_proc
// file misc.c line 1607
extern void GC_set_warn_proc(void (*p)(char *, unsigned long int))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_current_warn_proc = p;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_setpagesize
// file ./include/private/gc_priv.h line 2222
void GC_setpagesize(void)
{
  signed int return_value_getpagesize_1;
  return_value_getpagesize_1=getpagesize();
  GC_page_size = (unsigned long int)return_value_getpagesize_1;
  if(GC_page_size == 0ul)
  {
    GC_on_abort("getpagesize failed");
    abort();
  }

}

// GC_setup_temporary_fault_handler
// file os_dep.c line 927
void GC_setup_temporary_fault_handler(void)
{
  GC_set_and_save_fault_handler(GC_fault_handler);
}

// GC_should_collect
// file ./include/private/gc_priv.h line 1540
signed int GC_should_collect(void)
{
  static unsigned long int last_min_bytes_allocd;
  static unsigned long int last_gc_no;
  if(!(last_gc_no == GC_gc_no))
  {
    last_gc_no = GC_gc_no;
    last_min_bytes_allocd=min_bytes_allocd();
  }

  unsigned long int return_value_GC_adj_bytes_allocd_1;
  return_value_GC_adj_bytes_allocd_1=GC_adj_bytes_allocd();
  return (signed int)(return_value_GC_adj_bytes_allocd_1 >= last_min_bytes_allocd ? (_Bool)1 : (GC_arrays._heapsize >= GC_collect_at_heapsize ? (_Bool)1 : (_Bool)0));
}

// GC_should_invoke_finalizers
// file finalize.c line 959
extern signed int GC_should_invoke_finalizers(void)
{
  return (signed int)(GC_finalize_now != ((struct finalizable_object *)NULL));
}

// GC_signal_mark_stack_overflow
// file ./include/private/gc_pmark.h line 113
struct GC_ms_entry * GC_signal_mark_stack_overflow(struct GC_ms_entry *msp)
{
  GC_mark_state = 5;
  if(GC_parallel == 0)
    GC_mark_stack_too_small = 1;

  if(!(GC_print_stats == 0))
    GC_log_printf("Mark stack overflow; current size = %lu entries\n", (unsigned long int)GC_mark_stack_size);

  return msp - (signed long int)(((unsigned long int)1 * (unsigned long int)(1 << 12)) / (unsigned long int)8);
}

// GC_size
// file ./include/private/../gc.h line 475
extern unsigned long int GC_size(const void *p)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)p);
  return hhdr->hb_sz;
}

// GC_split_block
// file allchblk.c line 530
void GC_split_block(struct hblk *h, struct hblkhdr *hhdr, struct hblk *n, struct hblkhdr *nhdr, signed int index)
{
  unsigned long int total_size = hhdr->hb_sz;
  unsigned long int h_size = (unsigned long int)n - (unsigned long int)h;
  struct hblk *prev = hhdr->hb_prev;
  struct hblk *next = hhdr->hb_next;
  nhdr->hb_prev = prev;
  nhdr->hb_next = next;
  nhdr->hb_sz = total_size - h_size;
  nhdr->hb_flags = (unsigned char)0;
  if(!(prev == ((struct hblk *)NULL)))
  {
    struct hblkhdr *return_value_GC_find_header_1;
    return_value_GC_find_header_1=GC_find_header((char *)prev);
    return_value_GC_find_header_1->hb_next = n;
  }

  else
    GC_hblkfreelist[(signed long int)index] = n;
  if(!(next == ((struct hblk *)NULL)))
  {
    struct hblkhdr *return_value_GC_find_header_2;
    return_value_GC_find_header_2=GC_find_header((char *)next);
    return_value_GC_find_header_2->hb_prev = n;
  }

  GC_free_bytes[(signed long int)index] = GC_free_bytes[(signed long int)index] - h_size;
  hhdr->hb_sz = h_size;
  GC_add_to_fl(h, hhdr);
  nhdr->hb_flags = nhdr->hb_flags | (unsigned char)4;
}

// GC_start_debugging
// file dbg_mlc.c line 467
void GC_start_debugging(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_start_debugging_inner();
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_start_debugging_inner
// file dbg_mlc.c line 452
void GC_start_debugging_inner(void)
{
  GC_check_heap = GC_check_heap_proc;
  GC_print_all_smashed = GC_print_all_smashed_proc;
  GC_print_heap_obj = GC_debug_print_heap_obj_proc;
  GC_debugging_started = 1;
  GC_register_displacement_inner((unsigned long int)sizeof(struct anonymous_16) /*32ul*/ );
}

// GC_start_mark_threads
// file pthread_support.c line 403
extern void GC_start_mark_threads(void)
{
  signed int i;
  union pthread_attr_t attr;
  if(GC_parallel == 0 && available_markers_m1 >= 1)
  {
    signed int return_value_pthread_attr_init_1;
    return_value_pthread_attr_init_1=pthread_attr_init(&attr);
    if(!(return_value_pthread_attr_init_1 == 0))
    {
      GC_on_abort("pthread_attr_init failed");
      abort();
    }

    signed int return_value_pthread_attr_setdetachstate_2;
    return_value_pthread_attr_setdetachstate_2=pthread_attr_setdetachstate(&attr, 1);
    if(!(return_value_pthread_attr_setdetachstate_2 == 0))
    {
      GC_on_abort("pthread_attr_setdetachstate failed");
      abort();
    }

    i = 0;
    for( ; !(i >= available_markers_m1); i = i + 1)
    {
      signed int return_value_pthread_create_4;
      return_value_pthread_create_4=pthread_create(GC_mark_threads + (signed long int)i, &attr, GC_mark_thread, (void *)(unsigned long int)i);
      if(!(return_value_pthread_create_4 == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        GC_current_warn_proc("GC Warning: Marker thread creation failed, errno = %ld\n", (unsigned long int)*return_value___errno_location_3);
        break;
      }

    }
    GC_parallel = i;
    pthread_attr_destroy(&attr);
    if(!(GC_print_stats == 0))
      GC_log_printf("Started %d mark helper threads\n", GC_parallel);

  }

}

// GC_start_reclaim
// file ./include/private/gc_priv.h line 1778
void GC_start_reclaim(signed int report_if_found)
{
  unsigned int kind;
  GC_arrays._composite_in_use = (unsigned long int)0;
  GC_arrays._atomic_in_use = (unsigned long int)0;
  kind = (unsigned int)0;
  for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
  {
    void **fop;
    void **lim;
    struct hblk **rlist = GC_obj_kinds[(signed long int)kind].ok_reclaim_list;
    signed int should_clobber = (signed int)(GC_obj_kinds[(signed long int)kind].ok_descriptor != (unsigned long int)0);
    if(!(rlist == ((struct hblk **)NULL)))
    {
      if(report_if_found == 0)
      {
        lim = &GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1)];
        fop = GC_obj_kinds[(signed long int)kind].ok_freelist;
        for( ; !((unsigned long int)fop >= (unsigned long int)lim); fop = fop + 1l)
          if(!(*fop == NULL))
          {
            if(!(should_clobber == 0))
              GC_clear_fl_links(fop);

            else
              *fop = NULL;
          }

      }

      memset((void *)rlist, 0, (unsigned long int)(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(void *) /*8ul*/ ));
    }

  }
  GC_apply_to_all_blocks(GC_reclaim_block, (unsigned long int)report_if_found);
  GC_reclaim_unconditionally_marked();
}

// GC_start_routine
// file pthread_support.c line 1638
void * GC_start_routine(void *arg)
{
  void *return_value_GC_call_with_stack_base_1;
  return_value_GC_call_with_stack_base_1=GC_call_with_stack_base(GC_inner_start_routine, arg);
  return return_value_GC_call_with_stack_base_1;
}

// GC_start_rtn_prepare_thread
// file ./include/private/pthread_support.h line 145
struct GC_Thread_Rep * GC_start_rtn_prepare_thread(void * (**pstart)(void *), void **pstart_arg, struct GC_stack_base *sb, void *arg)
{
  struct start_info *si = (struct start_info *)arg;
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_register_my_thread_inner(sb, self);
  me->flags = (unsigned char)si->flags;
  GC_init_thread_local(&me->tlfs);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  *pstart = si->start_routine;
  *pstart_arg = si->arg;
  sem_post(&si->registered);
  return me;
}

// GC_start_world
// file ./include/private/gc_priv.h line 448
void GC_start_world(void)
{
  unsigned long int self;
  self=pthread_self();
  signed int i;
  struct GC_Thread_Rep *p;
  signed int n_live_threads = 0;
  signed int result;
  AO_store_link2(&GC_world_is_stopped, (unsigned long int)0);
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    p = GC_threads[(signed long int)i];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
      if(!(p->id == self))
      {
        if((1 & (signed int)p->flags) == 0)
        {
          if(p->thread_blocked == 0)
          {
            n_live_threads = n_live_threads + 1;
            result=pthread_kill(p->id, GC_sig_thr_restart);
            switch(result)
            {
              case 3:
              {
                n_live_threads = n_live_threads - 1;
                break;
              }
              case 0:
                break;
              default:
              {
                if(!(GC_print_stats == 0))
                  GC_log_printf("pthread_kill failed at resume: errcode= %d", result);

                GC_on_abort("pthread_kill failed at resume");
              }
            }
            abort();
          }

        }

      }

  }
}

// GC_steal_mark_stack
// file mark.c line 897
struct GC_ms_entry * GC_steal_mark_stack(struct GC_ms_entry *low, struct GC_ms_entry *high, struct GC_ms_entry *local, unsigned int max, struct GC_ms_entry **next)
{
  struct GC_ms_entry *p;
  struct GC_ms_entry *top = local - (signed long int)1;
  unsigned int i = (unsigned int)0;
  p = low;
  for( ; max >= i && (unsigned long int)high >= (unsigned long int)p; p = p + 1l)
  {
    unsigned long int descr;
    unsigned long int return_value_AO_load_1;
    return_value_AO_load_1=AO_load_link1(&p->mse_descr.ao);
    descr = (unsigned long int)return_value_AO_load_1;
    if(!(descr == 0ul))
    {
      AO_nop_write();
      AO_store(&p->mse_descr.ao, (unsigned long int)0);
      top = top + 1l;
      top->mse_descr.w = descr;
      top->mse_start = p->mse_start;
      i = i + 1u;
      if((3ul & descr) == 0ul)
        i = i + (unsigned int)(signed int)(descr >> 8);

    }

  }
  *next = p;
  return top;
}

// GC_stop_init
// file ./include/private/pthread_stop_world.h line 42
void GC_stop_init(void)
{
  struct sigaction act;
  if(GC_sig_suspend == -1)
    GC_sig_suspend = 30;

  if(GC_sig_thr_restart == -1)
    GC_sig_thr_restart = 24;

  if(GC_sig_suspend == GC_sig_thr_restart)
  {
    GC_on_abort("Cannot use same signal for thread suspend and resume");
    abort();
  }

  signed int return_value_sem_init_1;
  return_value_sem_init_1=sem_init(&GC_suspend_ack_sem, 0, (unsigned int)0);
  if(!(return_value_sem_init_1 == 0))
  {
    GC_on_abort("sem_init failed");
    abort();
  }

  act.sa_flags = 0x10000000 | 4;
  signed int return_value_sigfillset_2;
  return_value_sigfillset_2=sigfillset(&act.sa_mask);
  if(!(return_value_sigfillset_2 == 0))
  {
    GC_on_abort("sigfillset failed");
    abort();
  }

  GC_remove_allowed_signals(&act.sa_mask);
  act.__sigaction_handler.sa_sigaction = GC_suspend_handler;
  signed int return_value_sigaction_3;
  return_value_sigaction_3=sigaction(GC_sig_suspend, &act, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction_3 == 0))
  {
    GC_on_abort("Cannot set SIG_SUSPEND handler");
    abort();
  }

  act.sa_flags = act.sa_flags & ~4;
  act.__sigaction_handler.sa_handler = GC_restart_handler;
  signed int return_value_sigaction_4;
  return_value_sigaction_4=sigaction(GC_sig_thr_restart, &act, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction_4 == 0))
  {
    GC_on_abort("Cannot set SIG_THR_RESTART handler");
    abort();
  }

  signed int return_value_sigfillset_5;
  return_value_sigfillset_5=sigfillset(&suspend_handler_mask);
  if(!(return_value_sigfillset_5 == 0))
  {
    GC_on_abort("sigfillset failed");
    abort();
  }

  GC_remove_allowed_signals(&suspend_handler_mask);
  signed int return_value_sigdelset_6;
  return_value_sigdelset_6=sigdelset(&suspend_handler_mask, GC_sig_thr_restart);
  if(!(return_value_sigdelset_6 == 0))
  {
    GC_on_abort("sigdelset failed");
    abort();
  }

  char *return_value_getenv_7;
  return_value_getenv_7=getenv("GC_RETRY_SIGNALS");
  if(!(return_value_getenv_7 == ((char *)NULL)))
    GC_retry_signals = 1;

  char *return_value_getenv_8;
  return_value_getenv_8=getenv("GC_NO_RETRY_SIGNALS");
  if(!(return_value_getenv_8 == ((char *)NULL)))
    GC_retry_signals = 0;

  if(!(GC_retry_signals == 0))
  {
    if(!(GC_print_stats == 0))
      GC_log_printf("Will retry suspend signal if necessary\n");

  }

}

// GC_stop_world
// file ./include/private/gc_priv.h line 447
void GC_stop_world(void)
{
  signed int i;
  signed int n_live_threads;
  signed int code;
  if(!(GC_parallel == 0))
    GC_acquire_mark_lock();

  AO_store_link2(&GC_stop_count, GC_stop_count + (unsigned long int)1);
  AO_nop_write_link2();
  AO_store_link2(&GC_world_is_stopped, (unsigned long int)1);
  n_live_threads=GC_suspend_all();
  if(!(GC_retry_signals == 0))
  {
    unsigned long int wait_usecs = (unsigned long int)0;
    do
    {
      signed int ack_count;
      sem_getvalue(&GC_suspend_ack_sem, &ack_count);
      if(ack_count == n_live_threads)
        break;

      if(wait_usecs >= 100001ul)
      {
        signed int newly_sent;
        newly_sent=GC_suspend_all();
        if(!(GC_print_stats == 0))
          GC_log_printf("Resent %d signals after timeout\n", newly_sent);

        sem_getvalue(&GC_suspend_ack_sem, &ack_count);
        if(!(newly_sent >= n_live_threads + -ack_count))
        {
          GC_current_warn_proc("GC Warning: Lost some threads during GC_stop_world?!\n", (unsigned long int)0);
          n_live_threads = ack_count + newly_sent;
        }

        wait_usecs = (unsigned long int)0;
      }

      usleep((unsigned int)3000);
      wait_usecs = wait_usecs + (unsigned long int)3000;
    }
    while((_Bool)1);
  }

  i = 0;
  signed int *return_value___errno_location_1;
  for( ; !(i >= n_live_threads); i = i + 1)
  {
    do
    {

    retry:
      ;
      code=sem_wait(&GC_suspend_ack_sem);
      if(code == 0)
        goto __CPROVER_DUMP_L11;

      return_value___errno_location_1=__errno_location();
    }
    while(*return_value___errno_location_1 == 4);
    GC_on_abort("sem_wait for handler failed");
    abort();

  __CPROVER_DUMP_L11:
    ;
  }
  if(!(GC_parallel == 0))
    GC_release_mark_lock();

}

// GC_stopped_mark
// file alloc.c line 586
signed int GC_stopped_mark(signed int (*stop_func)(void))
{
  unsigned int i;
  signed long int start_time = (signed long int)0;
  signed long int current_time;
  GC_cond_register_dynamic_libraries();
  if(!(GC_print_stats == 0))
    start_time=clock();

  GC_stop_world();
  GC_world_stopped = 1;
  if(!(GC_print_stats == 0))
    GC_log_printf("\n--> Marking for collection #%lu after %lu allocated bytes\n", (unsigned long int)GC_gc_no + (unsigned long int)1, (unsigned long int)GC_arrays._bytes_allocd);

  GC_clear_a_few_frames();
  GC_noop6((unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
  GC_initiate_gc();
  i = (unsigned int)0;
  signed int return_value;
  return_value=stop_func();
  if(!(return_value == 0))
  {
    if(!(GC_print_stats == 0))
      GC_log_printf("Abandoned stopped marking after %u iterations\n", i);

    GC_deficit = (signed int)i;
    GC_world_stopped = 0;
    GC_start_world();
    return 0;
  }

  else
  {
    char *return_value_GC_approx_sp_1;
    return_value_GC_approx_sp_1=GC_approx_sp();
    signed int return_value_GC_mark_some_2;
    return_value_GC_mark_some_2=GC_mark_some(return_value_GC_approx_sp_1);
    if(return_value_GC_mark_some_2 == 0)
      i = i + 1u;

    GC_gc_no = GC_gc_no + 1ul;
    if(!(GC_print_stats == 0))
      GC_log_printf("GC #%lu freed %ld bytes, heap %lu KiB\n", (unsigned long int)GC_gc_no, (signed long int)GC_bytes_found, (unsigned long int)((GC_arrays._heapsize - (unsigned long int)0) + (unsigned long int)((1 << 9) - 1) >> 10));

    if(!(GC_debugging_started == 0))
      GC_check_heap();

    GC_world_stopped = 0;
    GC_start_world();
    if(!(GC_print_stats == 0))
    {
      unsigned long int time_diff;
      unsigned int total_time;
      unsigned int divisor;
      current_time=clock();
      time_diff = (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(current_time - start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(current_time - start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000;
      total_time = world_stopped_total_time;
      divisor = world_stopped_total_divisor;
      if(divisor >= 1000u || !((signed int)total_time >= 0))
      {
        total_time = total_time >> 1;
        divisor = divisor >> 1;
      }

      total_time = total_time + (time_diff < (unsigned long int)((unsigned int)-1 >> 1) ? (unsigned int)time_diff : (unsigned int)-1 >> 1);
      world_stopped_total_time = total_time;
      divisor = divisor + 1u;
      world_stopped_total_divisor = divisor;
      GC_log_printf("World-stopped marking took %lu msecs (%u in average)\n", time_diff, total_time / divisor);
    }

    return 1;
  }
}

// GC_store_debug_info
// file dbg_mlc.c line 279
char * GC_store_debug_info(char *p, unsigned long int sz, const char *string, signed int linenum)
{
  char *result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result=GC_store_debug_info_inner(p, sz, string, linenum);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_store_debug_info_inner
// file dbg_mlc.c line 255
char * GC_store_debug_info_inner(char *p, unsigned long int sz, const char *string, signed int linenum)
{
  unsigned long int *result = (unsigned long int *)((struct anonymous_16 *)p + (signed long int)1);
  ((struct anonymous_16 *)p)->oh_string = string;
  ((struct anonymous_16 *)p)->oh_int = (unsigned long int)linenum;
  ((struct anonymous_16 *)p)->oh_sz = sz;
  ((struct anonymous_16 *)p)->oh_sf = (unsigned long int)0xFEDCEDCBfedcedcbUL ^ (unsigned long int)result;
  unsigned long int return_value_GC_size_1;
  return_value_GC_size_1=GC_size((const void *)p);
  result[(signed long int)((sz + (unsigned long int)(1 << 3)) - (unsigned long int)1 >> 3)] = (unsigned long int)0xBCDECDEFbcdecdefUL ^ (unsigned long int)result;
  ((unsigned long int *)p)[(signed long int)((return_value_GC_size_1 >> 3) - (unsigned long int)1)] = result[(signed long int)((sz + (unsigned long int)(1 << 3)) - (unsigned long int)1 >> 3)];
  return (char *)result;
}

// GC_strdup
// file mallocx.c line 563
extern char * GC_strdup(const char *s)
{
  char *copy;
  unsigned long int lb;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(s);
    lb = return_value_strlen_1 + (unsigned long int)1;
    void *return_value_GC_malloc_atomic_3;
    return_value_GC_malloc_atomic_3=GC_malloc_atomic(lb);
    copy = (char *)return_value_GC_malloc_atomic_3;
    if(copy == ((char *)NULL))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 12;
      return (char *)(void *)0;
    }

    memcpy((void *)copy, (const void *)s, (unsigned long int)lb);
    return copy;
  }
}

// GC_strndup
// file mallocx.c line 579
extern char * GC_strndup(const char *str, unsigned long int size)
{
  char *copy;
  unsigned long int len;
  len=strlen(str);
  if(!(size >= len))
    len = size;

  void *return_value_GC_malloc_atomic_1;
  return_value_GC_malloc_atomic_1=GC_malloc_atomic(len + (unsigned long int)1);
  copy = (char *)return_value_GC_malloc_atomic_1;
  if(copy == ((char *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 12;
    return (char *)(void *)0;
  }

  memcpy((void *)copy, (const void *)str, (unsigned long int)len);
  copy[(signed long int)len] = (char)0;
  return copy;
}

// GC_suspend_all
// file pthread_stop_world.c line 465
signed int GC_suspend_all(void)
{
  signed int n_live_threads = 0;
  signed int i;
  struct GC_Thread_Rep *p;
  signed int result;
  unsigned long int self;
  self=pthread_self();
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    p = GC_threads[(signed long int)i];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
      if(!(p->id == self))
      {
        if((1 & (signed int)p->flags) == 0)
        {
          if(p->thread_blocked == 0)
          {
            if(!(p->stop_info.last_stop_count == GC_stop_count))
            {
              n_live_threads = n_live_threads + 1;
              result=pthread_kill(p->id, GC_sig_suspend);
              switch(result)
              {
                case 3:
                {
                  n_live_threads = n_live_threads - 1;
                  break;
                }
                case 0:
                  break;
                default:
                {
                  if(!(GC_print_stats == 0))
                    GC_log_printf("pthread_kill failed at suspend: errcode= %d", result);

                  GC_on_abort("pthread_kill failed at suspend");
                }
              }
              abort();
            }

          }

        }

      }

  }
  return n_live_threads;
}

// GC_suspend_handler
// file pthread_stop_world.c line 206
void GC_suspend_handler(signed int sig, struct anonymous_10 *info, void *context)
{
  signed int old_errno;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  old_errno = *return_value___errno_location_1;
  GC_suspend_handler_inner((char *)(unsigned long int)sig, context);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  *return_value___errno_location_2 = old_errno;
}

// GC_suspend_handler_inner
// file pthread_stop_world.c line 227
void GC_suspend_handler_inner(char *sig_arg, void *context)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  signed int cancel_state;
  unsigned long int my_stop_count;
  my_stop_count=AO_load_link3(&GC_stop_count);
  if(!((signed long int)sig_arg == (signed long int)GC_sig_suspend))
  {
    GC_on_abort("Bad signal in suspend_handler");
    abort();
  }

  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  me=GC_lookup_thread(self);
  unsigned long int return_value_AO_load_read_1;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_AO_load_2;
  if(me->stop_info.last_stop_count == my_stop_count)
  {
    if(GC_retry_signals == 0)
      GC_current_warn_proc("GC Warning: Duplicate suspend signal in thread %p\n", (unsigned long int)self);

    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }

  else
  {
    me->stop_info.stack_ptr=GC_approx_sp();
    sem_post(&GC_suspend_ack_sem);
    me->stop_info.last_stop_count = my_stop_count;
    do
    {
      sigsuspend(&suspend_handler_mask);
      return_value_AO_load_read_1=AO_load_read_link1(&GC_world_is_stopped);
      if(!(return_value_AO_load_read_1 == 0ul))
      {
        return_value_AO_load_2=AO_load_link3(&GC_stop_count);
        tmp_if_expr_3 = return_value_AO_load_2 == my_stop_count ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
    }
    while(tmp_if_expr_3);
    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }
}

// GC_thr_init
// file ./include/private/gc_priv.h line 1680
void GC_thr_init(void)
{
  if(GC_thr_initialized == 0)
  {
    GC_thr_initialized = 1;
    if(!(GC_handle_fork == 0))
    {
      signed int return_value_pthread_atfork_1;
      return_value_pthread_atfork_1=pthread_atfork(fork_prepare_proc, fork_parent_proc, fork_child_proc);
      if(return_value_pthread_atfork_1 == 0)
        GC_handle_fork = 1;

      else
        if(!(GC_handle_fork == -1))
        {
          GC_on_abort("pthread_atfork failed");
          abort();
        }

    }

    struct GC_Thread_Rep *t;
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    t=GC_new_thread(return_value_pthread_self_2);
    if(t == ((struct GC_Thread_Rep *)NULL))
    {
      GC_on_abort("Failed to allocate memory for the initial thread");
      abort();
    }

    t->stop_info.stack_ptr=GC_approx_sp();
    t->flags = (unsigned char)(2 | 4);
    GC_stop_init();
    char *nprocs_string;
    nprocs_string=getenv("GC_NPROCS");
    GC_nprocs = -1;
    if(!(nprocs_string == ((char *)NULL)))
      GC_nprocs=atoi_link1(nprocs_string);

    if(!(GC_nprocs >= 1))
      GC_nprocs=GC_get_nprocs();

    if(!(GC_nprocs >= 1))
    {
      GC_current_warn_proc("GC Warning: GC_get_nprocs() returned %ld\n", (unsigned long int)GC_nprocs);
      GC_nprocs = 2;
      available_markers_m1 = 0;
    }

    else
    {
      char *markers_string;
      markers_string=getenv("GC_MARKERS");
      signed int markers_m1;
      if(!(markers_string == ((char *)NULL)))
      {
        signed int return_value_atoi_3;
        return_value_atoi_3=atoi_link1(markers_string);
        markers_m1 = return_value_atoi_3 - 1;
        if(markers_m1 >= 16)
        {
          GC_current_warn_proc("GC Warning: Limiting number of mark threads\n", (unsigned long int)0);
          markers_m1 = 16 - 1;
        }

      }

      else
      {
        markers_m1 = GC_nprocs - 1;
        if(markers_m1 >= 16)
          markers_m1 = 16 - 1;

      }
      available_markers_m1 = markers_m1;
    }
    if(!(GC_print_stats == 0))
      GC_log_printf("Number of processors = %d\n", GC_nprocs);

    if(!(available_markers_m1 >= 1))
    {
      GC_parallel = 0;
      if(!(GC_print_stats == 0))
        GC_log_printf("Single marker thread, turning off parallel marking\n");

    }

    else
    {
      GC_time_limit = (unsigned long int)999999;
      GC_start_mark_threads();
    }
  }

}

// GC_thread_exit_proc
// file ./include/private/pthread_support.h line 149
void GC_thread_exit_proc(void *arg)
{
  signed int cancel_state;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  GC_wait_for_gc_completion(0);
  GC_unregister_my_thread_inner((struct GC_Thread_Rep *)arg);
  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_thread_is_registered
// file pthread_support.c line 647
extern signed int GC_thread_is_registered(void)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return (signed int)(me != (struct GC_Thread_Rep *)(void *)0);
}

// GC_timeout_stop_func
// file alloc.c line 171
signed int GC_timeout_stop_func(void)
{
  signed long int current_time;
  unsigned long int time_diff;
  signed int return_value;
  return_value=GC_default_stop_func();
  if(!(return_value == 0))
    return 1;

  else
  {
    static unsigned int count = (unsigned int)0;
    unsigned int tmp_post_1 = count;
    count = count + 1u;
    if(!((3u & tmp_post_1) == 0u))
      return 0;

    else
    {
      current_time=clock();
      time_diff = (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(current_time - GC_start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(current_time - GC_start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000;
      if(time_diff >= GC_time_limit)
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("Abandoning stopped marking after %lu msecs (attempt %d)\n", time_diff, GC_n_attempts);

        return 1;
      }

      else
        return 0;
    }
  }
}

// GC_try_to_collect
// file alloc.c line 1000
extern signed int GC_try_to_collect(signed int (*stop_func)(void))
{
  signed int return_value_GC_try_to_collect_general_1;
  return_value_GC_try_to_collect_general_1=GC_try_to_collect_general(stop_func, 0);
  return (signed int)return_value_GC_try_to_collect_general_1;
}

// GC_try_to_collect_general
// file alloc.c line 964
signed int GC_try_to_collect_general(signed int (*stop_func)(void), signed int force_unmap)
{
  signed int result;
  signed int cancel_state;
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  if(!(GC_debugging_started == 0))
    GC_print_all_smashed();

  GC_notify_or_invoke_finalizers();
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  GC_collecting = 1;
  GC_noop6((unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
  result=GC_try_to_collect_inner(stop_func != ((signed int (*)(void))NULL) ? stop_func : GC_default_stop_func);
  GC_collecting = 0;
  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if(!(result == 0))
  {
    if(!(GC_debugging_started == 0))
      GC_print_all_smashed();

    GC_notify_or_invoke_finalizers();
  }

  return result;
}

// GC_try_to_collect_inner
// file alloc.c line 411
signed int GC_try_to_collect_inner(signed int (*stop_func)(void))
{
  signed long int start_time = (signed long int)0;
  signed long int current_time;
  _Bool tmp_if_expr_1;
  signed int return_value;
  if(!(GC_dont_gc == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    return_value=stop_func();
    tmp_if_expr_1 = return_value != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_GC_collection_in_progress_3;
  signed int return_value_GC_reclaim_all_4;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    if(!(GC_incremental == 0))
    {
      return_value_GC_collection_in_progress_3=GC_collection_in_progress();
      if(!(return_value_GC_collection_in_progress_3 == 0))
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("GC_try_to_collect_inner: finishing collection in progress\n");

        signed int return_value_GC_collection_in_progress_2;
        return_value_GC_collection_in_progress_2=GC_collection_in_progress();
        if(!(return_value_GC_collection_in_progress_2 == 0))
        {
          signed int return_value_1;
          return_value_1=stop_func();
          if(!(return_value_1 == 0))
            return 0;

          GC_collect_a_little_inner(1);
        }

      }

    }

    GC_notify_full_gc();
    if(!(GC_print_stats == 0))
    {
      start_time=clock();
      GC_log_printf("Initiating full world-stop collection!\n");
    }

    GC_promote_black_lists();
    if(!(GC_parallel == 0))
      GC_wait_for_reclaim();

    if(!(stop_func == GC_never_stop_func) || !(GC_find_leak == 0))
    {
      return_value_GC_reclaim_all_4=GC_reclaim_all(stop_func, 0);
      if(return_value_GC_reclaim_all_4 == 0)
        return 0;

    }

    GC_invalidate_mark_state();
    GC_clear_marks();
    GC_is_full_gc = 1;
    signed int return_value_GC_stopped_mark_5;
    return_value_GC_stopped_mark_5=GC_stopped_mark(stop_func);
    if(return_value_GC_stopped_mark_5 == 0)
    {
      if(GC_incremental == 0)
      {
        GC_invalidate_mark_state();
        GC_unpromote_black_lists();
      }

      return 0;
    }

    else
    {
      GC_finish_collection();
      if(!(GC_print_stats == 0))
      {
        current_time=clock();
        GC_log_printf("Complete collection took %lu msecs\n", (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(current_time - start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(current_time - start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000);
      }

      return 1;
    }
  }
}

// GC_typed_mark_proc
// file typd_mlc.c line 381
struct GC_ms_entry * GC_typed_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env)
{
  unsigned long int bm = (GC_ext_descriptors + (signed long int)env)->ed_bitmap;
  unsigned long int *current_p = addr;
  unsigned long int current;
  char *greatest_ha = (char *)GC_greatest_plausible_heap_addr;
  char *least_ha = (char *)GC_least_plausible_heap_addr;
  struct hce hdr_cache[8l];
  memset((void *)hdr_cache, 0, (unsigned long int)sizeof(struct hce [8l]) /*128ul*/ );
  for( ; !(bm == 0ul); current_p = current_p + 1l)
  {
    if(!((1ul & bm) == 0ul))
    {
      current = *current_p;
      if(current >= (unsigned long int)least_ha && (unsigned long int)greatest_ha >= current)
        do
        {
          struct hblkhdr *my_hhdr;
          do
          {
            struct hce *hce = hdr_cache + (signed long int)((unsigned long int)(char *)current >> (unsigned long int)12 & (unsigned long int)(8 - 1));
            if(hce->block_addr == current >> 12ul)
              my_hhdr = hce->hce_hdr;

            else
            {
              my_hhdr=GC_header_cache_miss((char *)current, hce);
              if(my_hhdr == ((struct hblkhdr *)NULL))
                goto exit1;

            }
          }
          while((_Bool)0);
          do
          {
            unsigned long int displ = (unsigned long int)(char *)current & (unsigned long int)(1 << 12) - (unsigned long int)1;
            unsigned long int gran_displ = displ >> 4;
            unsigned long int gran_offset = (unsigned long int)my_hhdr->hb_map[(signed long int)gran_displ];
            unsigned long int byte_offset = displ & (unsigned long int)(16 - 1);
            char *base = (char *)current;
            if(!((byte_offset | gran_offset) == 0ul))
            {
              if(!(my_hhdr->hb_large_block == 0))
              {
                unsigned long int obj_displ;
                base = (char *)my_hhdr->hb_block;
                obj_displ = (unsigned long int)((char *)current - base);
                if(obj_displ == displ)
                {
                  if(GC_arrays._valid_offsets[(signed long int)obj_displ] == 0)
                  {
                    if(!(GC_all_interior_pointers == 0))
                      GC_add_to_black_list_stack((unsigned long int)(char *)current);

                    else
                      GC_add_to_black_list_normal((unsigned long int)(char *)current);
                    break;
                  }

                }

                gran_displ = (unsigned long int)0;
              }

              else
              {
                unsigned long int GC_typed_mark_proc__1__1__1__1__1__1__2__1__2__obj_displ = (gran_offset << 4) + byte_offset;
                if(GC_arrays._valid_offsets[(signed long int)GC_typed_mark_proc__1__1__1__1__1__1__2__1__2__obj_displ] == 0)
                {
                  if(!(GC_all_interior_pointers == 0))
                    GC_add_to_black_list_stack((unsigned long int)(char *)current);

                  else
                    GC_add_to_black_list_normal((unsigned long int)(char *)current);
                  break;
                }

                gran_displ = gran_displ - gran_offset;
                base = base - (signed long int)GC_typed_mark_proc__1__1__1__1__1__1__2__1__2__obj_displ;
              }
            }

            do
            {
              char *mark_byte_addr = (char *)my_hhdr->_mark_byte_union._hb_marks + (signed long int)gran_displ;
              if(!(*mark_byte_addr == 0))
                goto exit1;

              *mark_byte_addr = (char)1;
            }
            while((_Bool)0);
            unsigned long int return_value_AO_load_1;
            return_value_AO_load_1=AO_load_link2(&my_hhdr->hb_n_marks);
            AO_store_link1(&my_hhdr->hb_n_marks, return_value_AO_load_1 + (unsigned long int)1);
            do
            {
              unsigned long int _descr = my_hhdr->hb_descr;
              if(!(_descr == 0ul))
              {
                mark_stack_ptr = mark_stack_ptr + 1l;
                if((unsigned long int)mark_stack_ptr >= (unsigned long int)mark_stack_limit)
                  mark_stack_ptr=GC_signal_mark_stack_overflow(mark_stack_ptr);

                mark_stack_ptr->mse_start = base;
                mark_stack_ptr->mse_descr.w = _descr;
              }

            }
            while((_Bool)0);
          }
          while((_Bool)0);

        exit1:
          ;
        }
        while((_Bool)0);

    }

    bm = bm >> 1;
  }
  if(!((GC_ext_descriptors + (signed long int)env)->ed_continued == 0))
  {
    mark_stack_ptr = mark_stack_ptr + 1l;
    if((unsigned long int)mark_stack_ptr >= (unsigned long int)mark_stack_limit)
      mark_stack_ptr=GC_signal_mark_stack_overflow(mark_stack_ptr);

    mark_stack_ptr->mse_start = (char *)(addr + (signed long int)(unsigned long int)64);
    mark_stack_ptr->mse_descr.w = (env + (unsigned long int)1 << 6 | (unsigned long int)GC_typed_mark_proc_index) << 2 | (unsigned long int)2;
  }

  return mark_stack_ptr;
}

// GC_unix_get_mem
// file ./include/private/gcconfig.h line 2963
char * GC_unix_get_mem(unsigned long int bytes)
{
  char *result = ((char *)NULL);
  static signed int sbrk_failed = 0;
  if(sbrk_failed == 0)
    result=GC_unix_sbrk_get_mem(bytes);

  if(result == ((char *)NULL))
  {
    sbrk_failed = 1;
    result=GC_unix_mmap_get_mem(bytes);
  }

  if(result == ((char *)NULL))
    result=GC_unix_sbrk_get_mem(bytes);

  return result;
}

// GC_unix_mmap_get_mem
// file os_dep.c line 2040
char * GC_unix_mmap_get_mem(unsigned long int bytes)
{
  void *result;
  static signed int initialized = 0;
  if((signed long int)initialized == 0l)
  {
    zero_fd=open("/dev/zero", 00);
    if(zero_fd == -1)
    {
      GC_on_abort("Could not open /dev/zero");
      abort();
    }

    fcntl(zero_fd, 2, 1);
    initialized = 1;
  }

  if(!((GC_page_size + 18446744073709551615ul & bytes) == 0ul))
  {
    GC_on_abort("Bad GET_MEM arg");
    abort();
  }

  static char *last_addr = (char *)0;
  result=mmap((void *)last_addr, bytes, 0x1 | 0x2 | (GC_pages_executable != 0 ? 0x4 : 0), 0x02 | 0, zero_fd, (signed long int)0);
  if(result == (void *)-1)
    return ((char *)NULL);

  else
  {
    last_addr = ((char *)result + (signed long int)bytes + (signed long int)GC_page_size) - (signed long int)1;
    last_addr = (char *)((unsigned long int)last_addr & ~(GC_page_size - (unsigned long int)1));
    if(!((unsigned long int)result % 4096ul == 0ul))
    {
      GC_on_abort("GC_unix_get_mem: Memory returned by mmap is not aligned to HBLKSIZE.");
      abort();
    }

    return (char *)result;
  }
}

// GC_unix_sbrk_get_mem
// file os_dep.c line 2100
char * GC_unix_sbrk_get_mem(unsigned long int bytes)
{
  char *result;
  char *cur_brk;
  void *return_value_sbrk_1;
  return_value_sbrk_1=sbrk((signed long int)0);
  cur_brk = (char *)return_value_sbrk_1;
  signed long int lsbs = (signed long int)((unsigned long int)cur_brk & GC_page_size - (unsigned long int)1);
  if(!((signed long int)bytes >= 0l))
    result = ((char *)NULL);

  else
  {
    if(!(lsbs == 0l))
    {
      void *return_value_sbrk_2;
      return_value_sbrk_2=sbrk((signed long int)(GC_page_size - (unsigned long int)lsbs));
      if((char *)return_value_sbrk_2 == (char *)-1)
      {
        result = ((char *)NULL);
        goto out;
      }

    }

    void *return_value_sbrk_3;
    return_value_sbrk_3=sbrk((signed long int)bytes);
    result = (char *)return_value_sbrk_3;
    if(result == (char *)-1)
      result = ((char *)NULL);

  }

out:
  ;
  return result;
}

// GC_unpromote_black_lists
// file ./include/private/gc_priv.h line 1723
void GC_unpromote_black_lists(void)
{
  if(GC_all_interior_pointers == 0)
    GC_copy_bl(GC_old_normal_bl, GC_incomplete_normal_bl);

  GC_copy_bl(GC_old_stack_bl, GC_incomplete_stack_bl);
}

// GC_unreachable_finalize_mark_proc
// file finalize.c line 423
void GC_unreachable_finalize_mark_proc(char *p)
{
  GC_normal_finalize_mark_proc(p);
}

// GC_unregister_disappearing_link
// file finalize.c line 251
extern signed int GC_unregister_disappearing_link(void **link)
{
  struct disappearing_link *curr_dl;
  if(!((7ul & (unsigned long int)link) == 0ul))
    return 0;

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    curr_dl=GC_unregister_disappearing_link_inner(&GC_dl_hashtbl, link);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(curr_dl == ((struct disappearing_link *)NULL))
      return 0;

    else
    {
      GC_free((void *)curr_dl);
      return 1;
    }
  }
}

// GC_unregister_disappearing_link_inner
// file finalize.c line 227
static inline struct disappearing_link * GC_unregister_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link)
{
  struct disappearing_link *curr_dl;
  struct disappearing_link *prev_dl = (struct disappearing_link *)(void *)0;
  unsigned long int index = ((unsigned long int)link >> 3 ^ (unsigned long int)link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
  curr_dl = dl_hashtbl->head[(signed long int)index];
  for( ; !(curr_dl == ((struct disappearing_link *)NULL)); curr_dl = (struct disappearing_link *)curr_dl->prolog.next)
  {
    if(curr_dl->prolog.hidden_key == ~((unsigned long int)link))
    {
      if(prev_dl == ((struct disappearing_link *)NULL))
        dl_hashtbl->head[(signed long int)index] = (struct disappearing_link *)curr_dl->prolog.next;

      else
        prev_dl->prolog.next = (struct hash_chain_entry *)(struct disappearing_link *)curr_dl->prolog.next;
      dl_hashtbl->entries = dl_hashtbl->entries - 1ul;
      break;
    }

    prev_dl = curr_dl;
  }
  return curr_dl;
}

// GC_unregister_long_link
// file finalize.c line 274
extern signed int GC_unregister_long_link(void **link)
{
  struct disappearing_link *curr_dl;
  if(!((7ul & (unsigned long int)link) == 0ul))
    return 0;

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    curr_dl=GC_unregister_disappearing_link_inner(&GC_ll_hashtbl, link);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(curr_dl == ((struct disappearing_link *)NULL))
      return 0;

    else
    {
      GC_free((void *)curr_dl);
      return 1;
    }
  }
}

// GC_unregister_my_thread
// file pthread_support.c line 1337
extern signed int GC_unregister_my_thread(void)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  signed int cancel_state;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  GC_wait_for_gc_completion(0);
  me=GC_lookup_thread(self);
  GC_unregister_my_thread_inner(me);
  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return 0;
}

// GC_unregister_my_thread_inner
// file pthread_support.c line 1307
void GC_unregister_my_thread_inner(struct GC_Thread_Rep *me)
{
  GC_destroy_thread_local(&me->tlfs);
  if(!((0x10 & (signed int)me->flags) == 0))
    GC_dont_gc = GC_dont_gc - 1;

  if(!((2 & (signed int)me->flags) == 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    GC_delete_thread(return_value_pthread_self_1);
  }

  else
    me->flags = me->flags | (unsigned char)1;
}

// GC_wait_builder
// file pthread_support.c line 2002
void GC_wait_builder(void)
{
  signed int return_value_pthread_cond_wait_1;
  return_value_pthread_cond_wait_1=pthread_cond_wait(&builder_cv, &mark_mutex);
  if(!(return_value_pthread_cond_wait_1 == 0))
  {
    GC_on_abort("pthread_cond_wait failed");
    abort();
  }

}

// GC_wait_for_gc_completion
// file pthread_support.c line 911
void GC_wait_for_gc_completion(signed int wait_for_all)
{
  signed int return_value_GC_collection_in_progress_3;
  signed int return_value_GC_collection_in_progress_1;
  if(!(GC_incremental == 0))
  {
    return_value_GC_collection_in_progress_3=GC_collection_in_progress();
    if(!(return_value_GC_collection_in_progress_3 == 0))
    {
      unsigned long int old_gc_no = GC_gc_no;
      while(!(GC_incremental == 0))
      {
        return_value_GC_collection_in_progress_1=GC_collection_in_progress();
        if(return_value_GC_collection_in_progress_1 == 0)
          break;

        if(!(old_gc_no == GC_gc_no) && wait_for_all == 0)
          break;

        GC_collecting = 1;
        GC_in_thread_creation = 1;
        GC_collect_a_little_inner(1);
        GC_in_thread_creation = 0;
        GC_collecting = 0;
        do
          if(!(GC_need_to_lock == 0))
            pthread_mutex_unlock(&GC_allocate_ml);

        while((_Bool)0);
        sched_yield();
        do
          if(!(GC_need_to_lock == 0))
          {
            signed int return_value_pthread_mutex_trylock_2;
            return_value_pthread_mutex_trylock_2=pthread_mutex_trylock(&GC_allocate_ml);
            if(!(return_value_pthread_mutex_trylock_2 == 0))
              GC_lock();

          }

        while((_Bool)0);
      }
    }

  }

}

// GC_wait_for_reclaim
// file ./include/private/gc_priv.h line 2374
void GC_wait_for_reclaim(void)
{
  GC_acquire_mark_lock();
  while(GC_fl_builder_count >= 1ul)
    GC_wait_builder();
  GC_release_mark_lock();
}

// GC_wait_marker
// file ./include/private/gc_priv.h line 2379
void GC_wait_marker(void)
{
  signed int return_value_pthread_cond_wait_1;
  return_value_pthread_cond_wait_1=pthread_cond_wait(&mark_cv, &mark_mutex);
  if(!(return_value_pthread_cond_wait_1 == 0))
  {
    GC_on_abort("pthread_cond_wait failed");
    abort();
  }

}

// GC_with_callee_saves_pushed
// file mach_dep.c line 213
void GC_with_callee_saves_pushed(void (*fn)(char *, void *), char *arg)
{
  volatile signed int dummy;
  void *context = NULL;
  struct ucontext ctxt;
  unsigned short int old_fcw;
  asm("fstcw %0" : "=m"(*(&old_fcw)) :  : );
  signed int return_value_getcontext_1;
  return_value_getcontext_1=getcontext(&ctxt);
  if(!(return_value_getcontext_1 >= 0))
  {
    GC_on_abort("getcontext failed: Use another register retrieval method?");
    abort();
  }

  asm("fldcw %0" :  : "m"(*(&old_fcw)) : );
  unsigned int mxcsr;
  asm("stmxcsr %0" : "=m"(*(&mxcsr)) :  : );
  mxcsr = mxcsr & (unsigned int)~((0x20 | 0x04 | 0x10 | 0x08 | 0x01) << 7) | (unsigned int)(((signed int)old_fcw & (0x20 | 0x04 | 0x10 | 0x08 | 0x01)) << 7);
  asm("ldmxcsr %0" :  : "m"(*(&mxcsr)) : );
  context = (void *)&ctxt;
  fn(arg, context);
  GC_noop1((unsigned long int)&dummy);
}

// GC_write
// file misc.c line 1456
signed int GC_write(signed int fd, const char *buf, unsigned long int len)
{
  signed int bytes_written = 0;
  signed int result;
  signed int cancel_state;
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  while(!((unsigned long int)bytes_written >= len))
  {
    signed long int return_value_write_1;
    return_value_write_1=write(fd, (const void *)(buf + (signed long int)bytes_written), len - (unsigned long int)bytes_written);
    result = (signed int)return_value_write_1;
    if(result == -1)
    {
      do
        pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
      while((_Bool)0);
      return result;
    }

    bytes_written = bytes_written + result;
  }
  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  return bytes_written;
}

// GC_write_fault_handler
// file os_dep.c line 3124
void GC_write_fault_handler(signed int sig, struct anonymous_10 *si, void *raw_sc)
{
  char *addr = (char *)si->_sifields._sigfault.si_addr;
  unsigned int i;
  if(sig == 11)
  {
    struct hblk *h = (struct hblk *)((unsigned long int)addr & ~(GC_page_size - (unsigned long int)1));
    signed int in_allocd_block;
    struct hblkhdr *return_value_GC_find_header_1;
    return_value_GC_find_header_1=GC_find_header((char *)addr);
    in_allocd_block = (signed int)(return_value_GC_find_header_1 != ((struct hblkhdr *)NULL));
    if(in_allocd_block == 0)
    {
      void (*old_handler)(signed int, struct anonymous_10 *, void *);
      signed int used_si;
      old_handler = GC_old_segv_handler;
      used_si = GC_old_segv_handler_used_si;
      if(old_handler == ((void (*)(signed int, struct anonymous_10 *, void *))NULL))
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("Unexpected bus error or segmentation fault at %p", addr);

        GC_on_abort("Unexpected bus error or segmentation fault");
        abort();
      }

      else
        if(!(used_si == 0))
          ((void (*)(signed int, struct anonymous_10 *, void *))old_handler)(sig, si, raw_sc);

        else
          ((void (*)(signed int))old_handler)(sig);
    }

    signed int return_value_mprotect_2;
    return_value_mprotect_2=mprotect((void *)(char *)h, (unsigned long int)GC_page_size, 0x1 | 0x2 | (GC_pages_executable != 0 ? 0x4 : 0));
    if(!(return_value_mprotect_2 >= 0))
    {
      GC_on_abort(GC_pages_executable != 0 ? "un-mprotect executable page failed (probably disabled by OS)" : "un-mprotect failed");
      abort();
    }

    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= GC_page_size >> 12ul); i = i + 1u)
    {
      unsigned long int index = (unsigned long int)(h + (signed long int)i) >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
      async_set_pht_entry_from_index(GC_arrays._dirty_pages, index);
    }
    goto __CPROVER_DUMP_L13;
  }

  if(!(GC_print_stats == 0))
    GC_log_printf("Unexpected bus error or segmentation fault at %p", addr);

  GC_on_abort("Unexpected bus error or segmentation fault");
  abort();

__CPROVER_DUMP_L13:
  ;
}

// add_roots_to_index
// file mark_rts.c line 140
static inline void add_roots_to_index(struct roots *p)
{
  signed int h;
  h=rt_hash(p->r_start);
  p->r_next = GC_arrays._root_index[(signed long int)h];
  GC_arrays._root_index[(signed long int)h] = p;
}

// alloc_hdr
// file headers.c line 164
static struct hblkhdr * alloc_hdr(void)
{
  struct hblkhdr *result;
  if(hdr_free_list == ((struct hblkhdr *)NULL))
  {
    char *return_value_GC_scratch_alloc_1;
    return_value_GC_scratch_alloc_1=GC_scratch_alloc((unsigned long int)sizeof(struct hblkhdr) /*528ul*/ );
    result = (struct hblkhdr *)return_value_GC_scratch_alloc_1;
  }

  else
  {
    result = hdr_free_list;
    hdr_free_list = (struct hblkhdr *)result->hb_next;
  }
  return result;
}

// alloc_mark_stack
// file mark.c line 1187
static void alloc_mark_stack(unsigned long int n)
{
  struct GC_ms_entry *new_stack;
  char *return_value_GC_scratch_alloc_1;
  return_value_GC_scratch_alloc_1=GC_scratch_alloc(n * sizeof(struct GC_ms_entry) /*16ul*/ );
  new_stack = (struct GC_ms_entry *)return_value_GC_scratch_alloc_1;
  GC_mark_stack_too_small = 0;
  if(!(GC_mark_stack_size == 0ul))
  {
    if(!(new_stack == ((struct GC_ms_entry *)NULL)))
    {
      {
        unsigned long int page_offset = (unsigned long int)GC_arrays._mark_stack & GC_page_size - (unsigned long int)1;
        unsigned long int size = GC_mark_stack_size * sizeof(struct GC_ms_entry) /*16ul*/ ;
        unsigned long int displ = (unsigned long int)0;
        if(!(page_offset == 0ul))
          displ = GC_page_size - page_offset;

        size = size - displ & ~(GC_page_size - (unsigned long int)1);
        if(size >= 1ul)
          GC_add_to_heap((struct hblk *)((unsigned long int)GC_arrays._mark_stack + displ), (unsigned long int)size);

      }
      GC_arrays._mark_stack = new_stack;
      GC_mark_stack_size = n;
      GC_arrays._mark_stack_limit = new_stack + (signed long int)n;
      if(!(GC_print_stats == 0))
        GC_log_printf("Grew mark stack to %lu frames\n", (unsigned long int)GC_mark_stack_size);

    }

    else
      GC_current_warn_proc("GC Warning: Failed to grow mark stack to %ld frames\n", (unsigned long int)n);
  }

  else
  {
    if(new_stack == ((struct GC_ms_entry *)NULL))
    {
      GC_err_printf("No space for mark stack\n");
      GC_on_abort((const char *)(void *)0);
      exit(1);
    }

    GC_arrays._mark_stack = new_stack;
    GC_mark_stack_size = n;
    GC_arrays._mark_stack_limit = new_stack + (signed long int)n;
  }
  GC_arrays._mark_stack_top = GC_arrays._mark_stack - (signed long int)1;
}

// async_set_pht_entry_from_index
// file os_dep.c line 3028
static void async_set_pht_entry_from_index(unsigned long int * volatile db, unsigned long int index)
{
  enum anonymous_1 return_value_AO_test_and_set_full_1;
  do
  {
    return_value_AO_test_and_set_full_1=AO_test_and_set_full(&GC_fault_handler_lock);
    if(!((signed int)return_value_AO_test_and_set_full_1 == AO_BYTE_TS_set))
      break;

  }
  while((_Bool)1);
  db[(signed long int)(index >> (unsigned long int)6)] = db[(signed long int)(index >> (unsigned long int)6)] | (unsigned long int)1 << (index & (unsigned long int)0x3f);
  AO_nop_write_link1();
  AO_char_store((unsigned char *)&GC_fault_handler_lock, (unsigned char)AO_BYTE_TS_clear);
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1)
{
  signed long int return_value_strtol_1_link1;
  return_value_strtol_1_link1=strtol(__nptr_link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link1;
}

// atol
// file /usr/include/stdlib.h line 283
static inline signed long int atol(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return return_value_strtol_1;
}

// clear_marks_for_block
// file mark.c line 166
static void clear_marks_for_block(struct hblk *h, unsigned long int dummy)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  if(!((-2 & (signed int)hhdr->hb_obj_kind) == 2))
    GC_clear_hdr_marks(hhdr);

}

// disable_gc_for_dlopen
// file gc_dlopen.c line 44
static void disable_gc_for_dlopen(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  signed int return_value_GC_collection_in_progress_2;
  while(!(GC_incremental == 0))
  {
    return_value_GC_collection_in_progress_2=GC_collection_in_progress();
    if(return_value_GC_collection_in_progress_2 == 0)
      break;

    GC_collect_a_little_inner(1000);
  }
  GC_dont_gc = GC_dont_gc + 1;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// fill_prof_stats
// file misc.c line 541
static void fill_prof_stats(struct GC_prof_stats_s *pstats)
{
  pstats->heapsize_full = GC_arrays._heapsize;
  pstats->free_bytes_full = GC_arrays._large_free_bytes;
  pstats->unmapped_bytes = (unsigned long int)0;
  pstats->bytes_allocd_since_gc = GC_arrays._bytes_allocd;
  pstats->allocd_bytes_before_gc = GC_arrays._bytes_allocd_before_gc;
  pstats->non_gc_bytes = GC_non_gc_bytes;
  pstats->gc_no = GC_gc_no;
  pstats->markers_m1 = (unsigned long int)GC_parallel;
  pstats->bytes_reclaimed_since_gc = GC_bytes_found > (signed long int)0 ? (unsigned long int)GC_bytes_found : (unsigned long int)0;
  pstats->reclaimed_bytes_before_gc = GC_reclaimed_bytes_before_gc;
}

// fork_child_proc
// file pthread_support.c line 983
static void fork_child_proc(void)
{
  if(!(GC_parallel == 0))
    GC_release_mark_lock();

  GC_remove_all_threads_but_me();
  GC_parallel = 0;
  do
    pthread_setcancelstate(fork_cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// fork_parent_proc
// file pthread_support.c line 972
static void fork_parent_proc(void)
{
  if(!(GC_parallel == 0))
    GC_release_mark_lock();

  do
    pthread_setcancelstate(fork_cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// fork_prepare_proc
// file pthread_support.c line 948
static void fork_prepare_proc(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock_1;
      return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock_1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  do
    pthread_setcancelstate(1, &fork_cancel_state);
  while((_Bool)0);
  if(!(GC_parallel == 0))
    GC_wait_for_reclaim();

  GC_wait_for_gc_completion(1);
  if(!(GC_parallel == 0))
    GC_acquire_mark_lock();

}

// free_hdr
// file headers.c line 177
static inline void free_hdr(struct hblkhdr *hhdr)
{
  hhdr->hb_next = (struct hblk *)hdr_free_list;
  hdr_free_list = hhdr;
}

// free_list_index_of
// file allchblk.c line 153
static signed int free_list_index_of(struct hblkhdr *wanted)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  signed int i = 0;
  for( ; !(i >= 61); i = i + 1)
  {
    h = GC_hblkfreelist[(signed long int)i];
    for( ; !(h == ((struct hblk *)NULL)); h = hhdr->hb_next)
    {
      hhdr=GC_find_header((char *)h);
      if(hhdr == wanted)
        return i;

    }
  }
  return -1;
}

// get_index
// file headers.c line 206
static signed int get_index(unsigned long int addr)
{
  unsigned long int hi = (unsigned long int)addr >> (unsigned long int)10 + (unsigned long int)12;
  struct bi *r;
  struct bi *p;
  struct bi **prev;
  struct bi *pi;
  unsigned long int i = hi & (unsigned long int)((1 << 11) - 1);
  struct bi *old;
  p = GC_arrays._top_index[(signed long int)i];
  old = p;
  for( ; !(p == GC_arrays._all_nils); p = p->hash_link)
    if(p->key == hi)
      return 1;

  char *return_value_GC_scratch_alloc_1;
  return_value_GC_scratch_alloc_1=GC_scratch_alloc((unsigned long int)sizeof(struct bi) /*8224ul*/ );
  r = (struct bi *)return_value_GC_scratch_alloc_1;
  if(r == ((struct bi *)NULL))
    return 0;

  else
  {
    memset((void *)r, 0, (unsigned long int)sizeof(struct bi) /*8224ul*/ );
    r->hash_link = old;
    GC_arrays._top_index[(signed long int)i] = r;
    r->key = hi;
    prev = &GC_all_bottom_indices;
    pi = ((struct bi *)NULL);
    do
    {
      p = *prev;
      if(p == ((struct bi *)NULL))
        break;

      if(p->key >= hi)
        break;

      pi = p;
      prev = &p->asc_link;
    }
    while((_Bool)1);
    r->desc_link = pi;
    if(p == ((struct bi *)NULL))
      GC_all_bottom_indices_end = r;

    else
      p->desc_link = r;
    r->asc_link = p;
    *prev = r;
    return 1;
  }
}

// looping_handler
// file misc.c line 753
static void looping_handler(signed int sig)
{
  GC_err_printf("Caught signal %d: looping in handler\n", sig);

__CPROVER_DUMP_L1:
  ;
  goto __CPROVER_DUMP_L1;
}

// main
// file tests/realloc_test.c line 8
signed int main(void)
{
  signed int i;
  unsigned long int last_heap_size = (unsigned long int)0;
  GC_init();
  i = 0;
  for( ; !(i >= 10000000); i = i + 1)
  {
    signed int **p;
    void *return_value_GC_malloc_1;
    return_value_GC_malloc_1=GC_malloc(sizeof(signed int *) /*8ul*/ );
    p = (signed int **)return_value_GC_malloc_1;
    signed int *q;
    void *return_value_GC_malloc_atomic_2;
    return_value_GC_malloc_atomic_2=GC_malloc_atomic(sizeof(signed int) /*4ul*/ );
    q = (signed int *)return_value_GC_malloc_atomic_2;
    _Bool tmp_if_expr_3;
    if(p == ((signed int **)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = *p != ((signed int *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      fprintf(stderr, "GC_malloc returned garbage (or NULL)\n");
      exit(1);
    }

    void *return_value_GC_realloc_4;
    return_value_GC_realloc_4=GC_realloc((void *)q, (unsigned long int)2 * sizeof(signed int) /*4ul*/ );
    *p = (signed int *)return_value_GC_realloc_4;
    if(i % 10 == 0)
    {
      unsigned long int heap_size;
      unsigned long int return_value_GC_get_heap_size_5;
      return_value_GC_get_heap_size_5=GC_get_heap_size();
      heap_size = (unsigned long int)return_value_GC_get_heap_size_5;
      if(!(heap_size == last_heap_size))
      {
        printf("Heap size: %lu\n", heap_size);
        last_heap_size = heap_size;
      }

    }

  }
  return 0;
}

// maybe_finalize
// file gcj_mlc.c line 142
static void maybe_finalize(void)
{
  static unsigned long int last_finalized_no = (unsigned long int)0;
  if(!(GC_gc_no == last_finalized_no) && !((signed long int)GC_is_initialized == 0l))
  {
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    GC_notify_or_invoke_finalizers();
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock_1;
        return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock_1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    last_finalized_no = GC_gc_no;
  }

}

// maybe_install_looping_handler
// file misc.c line 763
static void maybe_install_looping_handler(void)
{
  char *return_value_getenv_1;
  if(installed_looping_handler == 0)
  {
    return_value_getenv_1=getenv("GC_LOOP_ON_ABORT");
    if(!(return_value_getenv_1 == ((char *)NULL)))
    {
      GC_set_and_save_fault_handler(looping_handler);
      installed_looping_handler = 1;
    }

  }

}

// min_bytes_allocd
// file alloc.c line 199
static unsigned long int min_bytes_allocd(void)
{
  unsigned long int result;
  unsigned long int stack_size;
  char *return_value_GC_approx_sp_1;
  return_value_GC_approx_sp_1=GC_approx_sp();
  stack_size = (unsigned long int)(GC_stackbottom - return_value_GC_approx_sp_1);
  unsigned long int total_root_size;
  unsigned long int scan_size;
  if(!(GC_need_to_lock == 0))
    stack_size = GC_total_stacksize;

  total_root_size = (unsigned long int)2 * stack_size + GC_root_size;
  scan_size = (unsigned long int)2 * GC_arrays._composite_in_use + GC_arrays._atomic_in_use / (unsigned long int)4 + total_root_size;
  result = scan_size / GC_free_space_divisor;
  if(!(GC_incremental == 0))
    result = result / (unsigned long int)2;

  return result > (unsigned long int)0 ? result : (unsigned long int)1;
}

// return_freelists
// file thread_local_alloc.c line 64
static void return_freelists(void **fl, void **gfl)
{
  signed int i = 1;
  for( ; !(i >= 25); i = i + 1)
  {
    if((unsigned long int)fl[(signed long int)i] >= 4096ul)
      return_single_freelist(fl[(signed long int)i], gfl + (signed long int)i);

    fl[(signed long int)i] = (void *)(char *)(unsigned long int)(1 << 12);
  }
  if(!(*fl == (void *)18446744073709551615ul))
  {
    if((unsigned long int)*fl >= 4096ul)
      return_single_freelist(fl[(signed long int)0], gfl + (signed long int)1);

  }

}

// return_single_freelist
// file thread_local_alloc.c line 44
static void return_single_freelist(void *fl, void **gfl)
{
  void *q;
  void **qptr;
  if(*gfl == NULL)
    *gfl = fl;

  else
  {
    qptr = &(*((void **)fl));
    do
    {
      q = *qptr;
      if(!((unsigned long int)q >= 4096ul))
        break;

      qptr = &(*((void **)q));
    }
    while((_Bool)1);
    *qptr = *gfl;
    *gfl = fl;
  }
}

// rt_hash
// file mark_rts.c line 110
static inline signed int rt_hash(char *addr)
{
  unsigned long int result = (unsigned long int)addr;
  result = result ^ result >> 8 * 6;
  result = result ^ result >> 4 * 6;
  result = result ^ result >> 2 * 6;
  result = result ^ result >> 6;
  result = result & (unsigned long int)((1 << 6) - 1);
  return (signed int)result;
}

// setup_header
// file allchblk.c line 225
static signed int setup_header(struct hblkhdr *hhdr, struct hblk *block, unsigned long int byte_sz, signed int kind, unsigned int flags)
{
  unsigned long int descr;
  unsigned long int granules;
  if(!(GC_obj_kinds[(signed long int)kind].ok_disclaim_proc == ((signed int (*)(void *))NULL)))
    flags = flags | (unsigned int)8;

  if(!(GC_obj_kinds[(signed long int)kind].ok_mark_unconditionally == 0))
    flags = flags | (unsigned int)0x10;

  hhdr->hb_sz = byte_sz;
  hhdr->hb_obj_kind = (unsigned char)kind;
  hhdr->hb_flags = (unsigned char)flags;
  hhdr->hb_block = block;
  descr = GC_obj_kinds[(signed long int)kind].ok_descriptor;
  if(!(GC_obj_kinds[(signed long int)kind].ok_relocate_descr == 0))
    descr = descr + byte_sz;

  hhdr->hb_descr = descr;
  hhdr->hb_large_block = (unsigned char)(byte_sz > (unsigned long int)((1 << 12) / 2));
  granules = byte_sz >> 4;
  signed int return_value_GC_add_map_entry_1;
  return_value_GC_add_map_entry_1=GC_add_map_entry(granules);
  if(return_value_GC_add_map_entry_1 == 0)
  {
    hhdr->hb_sz = (unsigned long int)(1 << 12);
    hhdr->hb_descr = (unsigned long int)0;
    hhdr->hb_large_block = (unsigned char)1;
    hhdr->hb_map = ((signed short int *)NULL);
    return 0;
  }

  else
  {
    unsigned long int index = hhdr->hb_large_block != 0 ? (unsigned long int)0 : granules;
    hhdr->hb_map = GC_arrays._obj_map[(signed long int)index];
  }
  GC_clear_hdr_marks(hhdr);
  hhdr->hb_last_reclaimed = (unsigned short int)GC_gc_no;
  return 1;
}

// store_old
// file dbg_mlc.c line 1075
static void store_old(void *obj, void (*my_old_fn)(void *, void *), struct closure *my_old_cd, void (**ofn)(void *, void *), void **ocd)
{
  if(!(my_old_fn == ((void (*)(void *, void *))NULL)))
  {
    if(my_old_fn == (void (*)(void *, void *))-1l)
      goto __CPROVER_DUMP_L6;

    if(!(my_old_fn == GC_debug_invoke_finalizer))
      GC_err_printf("Debuggable object at %p had a non-debug finalizer\n", obj);

    else
    {
      if(!(ofn == ((void (**)(void *, void *))NULL)))
        *ofn = my_old_cd->cl_fn;

      if(!(ocd == ((void **)NULL)))
        *ocd = my_old_cd->cl_data;

    }
  }

  else
  {
    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

  }

__CPROVER_DUMP_L6:
  ;
}

// total_stack_black_listed
// file blacklst.c line 277
static unsigned long int total_stack_black_listed(void)
{
  unsigned int i;
  unsigned long int total = (unsigned long int)0;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= GC_n_heap_sects); i = i + 1u)
  {
    struct hblk *start = (struct hblk *)GC_arrays._heap_sects[(signed long int)i].hs_start;
    struct hblk *endp1 = start + (signed long int)(GC_arrays._heap_sects[(signed long int)i].hs_bytes / (unsigned long int)(1 << 12));
    unsigned long int return_value_GC_number_stack_black_listed_1;
    return_value_GC_number_stack_black_listed_1=GC_number_stack_black_listed(start, endp1);
    total = total + return_value_GC_number_stack_black_listed_1;
  }
  return total * (unsigned long int)(1 << 12);
}

