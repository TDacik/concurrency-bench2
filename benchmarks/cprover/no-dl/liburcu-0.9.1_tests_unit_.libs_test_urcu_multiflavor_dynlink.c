// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$9;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$7;

// tag-#anon#ST[ARR16{U64}$U64$'__bits'|]
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 125
struct anonymous$2;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$16;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$4;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$10;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$6;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$12;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$14;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$11;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$8;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$15;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$13;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$3;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$5;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$0;

// tag-#anon#tUN[*{SYM#tag-__cds_wfcq_head#}$SYM#tag-__cds_wfcq_head#$'_h'||*{SYM#tag-cds_wfcq_head#}$SYM#tag-cds_wfcq_head#$'h'|]
// file urcu/wfcqueue.h line 82
union anonymous$1;

// tag-#anon#tUN[*{SYM#tag-__cds_wfs_stack#}$SYM#tag-__cds_wfs_stack#$'_s'||*{SYM#tag-cds_wfs_stack#}$SYM#tag-cds_wfs_stack#$'s'|]
// file ./urcu/wfstack.h line 100
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__cds_wfcq_head
// file urcu/wfcqueue.h line 68
struct __cds_wfcq_head;

// tag-__cds_wfs_stack
// file ./urcu/wfstack.h line 86
struct __cds_wfs_stack;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__uatomic_dummy
// file ./urcu/uatomic.h line 37
struct __uatomic_dummy;

// tag-call_rcu_completion
// file urcu-call-rcu-impl.h line 73
struct call_rcu_completion;

// tag-call_rcu_completion_work
// file urcu-call-rcu-impl.h line 79
struct call_rcu_completion_work;

// tag-call_rcu_data
// file ./urcu-call-rcu.h line 43
struct call_rcu_data;

// tag-cds_list_head
// file ./urcu/list.h line 35
struct cds_list_head;

// tag-cds_wfcq_head
// file urcu/wfcqueue.h line 72
struct cds_wfcq_head;

// tag-cds_wfcq_node
// file urcu/wfcqueue.h line 59
struct cds_wfcq_node;

// tag-cds_wfcq_ret
// file urcu/wfcqueue.h line 48
enum cds_wfcq_ret { CDS_WFCQ_RET_WOULDBLOCK=-1, CDS_WFCQ_RET_DEST_EMPTY=0, CDS_WFCQ_RET_DEST_NON_EMPTY=1, CDS_WFCQ_RET_SRC_EMPTY=2 };

// tag-cds_wfcq_tail
// file urcu/wfcqueue.h line 87
struct cds_wfcq_tail;

// tag-cds_wfq_node
// file urcu/wfqueue.h line 48
struct cds_wfq_node;

// tag-cds_wfq_queue
// file urcu/wfqueue.h line 52
struct cds_wfq_queue;

// tag-cds_wfs_head
// file ./urcu/wfstack.h line 82
struct cds_wfs_head;

// tag-cds_wfs_node
// file ./urcu/wfstack.h line 72
struct cds_wfs_node;

// tag-cds_wfs_stack
// file ./urcu/wfstack.h line 90
struct cds_wfs_stack;

// tag-defer_queue
// file urcu-defer-impl.h line 98
struct defer_queue;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rcu_flavor_struct
// file ./urcu-flavor.h line 30
struct rcu_flavor_struct;

// tag-rcu_gp_bp
// file urcu/static/urcu-bp.h line 76
struct rcu_gp_bp;

// tag-rcu_gp_mb
// file urcu/static/urcu.h line 127
struct rcu_gp_mb;

// tag-rcu_gp_memb
// file urcu/static/urcu.h line 127
struct rcu_gp_memb;

// tag-rcu_gp_qsbr
// file urcu/static/urcu-qsbr.h line 68
struct rcu_gp_qsbr;

// tag-rcu_gp_sig
// file urcu/static/urcu.h line 127
struct rcu_gp_sig;

// tag-rcu_head
// file ./urcu-call-rcu.h line 59
struct rcu_head;

// tag-rcu_reader_bp
// file urcu/static/urcu-bp.h line 89
struct rcu_reader_bp;

// tag-rcu_reader_mb
// file urcu/static/urcu.h line 142
struct rcu_reader_mb;

// tag-rcu_reader_memb
// file urcu/static/urcu.h line 142
struct rcu_reader_memb;

// tag-rcu_reader_qsbr
// file urcu/static/urcu-qsbr.h line 81
struct rcu_reader_qsbr;

// tag-rcu_reader_sig
// file urcu/static/urcu.h line 142
struct rcu_reader_sig;

// tag-rcu_state
// file urcu/static/urcu.h line 77
enum rcu_state { RCU_READER_ACTIVE_CURRENT=0, RCU_READER_ACTIVE_OLD=1, RCU_READER_INACTIVE=2 };

// tag-registry_arena
// file urcu-bp.c line 155
struct registry_arena;

// tag-registry_chunk
// file urcu-bp.c line 148
struct registry_chunk;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-urcu_ref
// file urcu/ref.h line 21
struct urcu_ref;

// tag-urcu_wait_node
// file urcu-wait.h line 45
struct urcu_wait_node;

// tag-urcu_wait_queue
// file urcu-wait.h line 59
struct urcu_wait_queue;

// tag-urcu_wait_state
// file urcu-wait.h line 36
enum urcu_wait_state { URCU_WAIT_WAITING=0, URCU_WAIT_WAKEUP=1, URCU_WAIT_RUNNING=2, URCU_WAIT_TEARDOWN=4 };

// tag-urcu_waiters
// file urcu-wait.h line 72
struct urcu_waiters;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// ___cds_wfcq_append
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append(union anonymous$1 u_head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *new_head, struct cds_wfcq_node *new_tail);
// ___cds_wfcq_append$link1
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1(union anonymous$1 u_head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *new_head$link1, struct cds_wfcq_node *new_tail$link1);
// ___cds_wfcq_append$link1$link1
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1$link1(union anonymous$1 u_head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, struct cds_wfcq_node *new_head$link1$link1, struct cds_wfcq_node *new_tail$link1$link1);
// ___cds_wfcq_append$link1$link2
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1$link2(union anonymous$1 u_head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, struct cds_wfcq_node *new_head$link1$link2, struct cds_wfcq_node *new_tail$link1$link2);
// ___cds_wfcq_append$link1$link3
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1$link3(union anonymous$1 u_head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, struct cds_wfcq_node *new_head$link1$link3, struct cds_wfcq_node *new_tail$link1$link3);
// ___cds_wfcq_append$link1$link4
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1$link4(union anonymous$1 u_head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, struct cds_wfcq_node *new_head$link1$link4, struct cds_wfcq_node *new_tail$link1$link4);
// ___cds_wfcq_append$link2
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link2(union anonymous$1 u_head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *new_head$link2, struct cds_wfcq_node *new_tail$link2);
// ___cds_wfcq_append$link3
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link3(union anonymous$1 u_head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *new_head$link3, struct cds_wfcq_node *new_tail$link3);
// ___cds_wfcq_append$link4
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link4(union anonymous$1 u_head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *new_head$link4, struct cds_wfcq_node *new_tail$link4);
// ___cds_wfcq_append$link5
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link5(union anonymous$1 u_head$link5, struct cds_wfcq_tail *tail$link5, struct cds_wfcq_node *new_head$link5, struct cds_wfcq_node *new_tail$link5);
// ___cds_wfcq_busy_wait
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait(signed int *attempt, signed int blocking);
// ___cds_wfcq_busy_wait$link1
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1(signed int *attempt$link1, signed int blocking$link1);
// ___cds_wfcq_busy_wait$link1$link1
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1$link1(signed int *attempt$link1$link1, signed int blocking$link1$link1);
// ___cds_wfcq_busy_wait$link1$link2
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1$link2(signed int *attempt$link1$link2, signed int blocking$link1$link2);
// ___cds_wfcq_busy_wait$link1$link3
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1$link3(signed int *attempt$link1$link3, signed int blocking$link1$link3);
// ___cds_wfcq_busy_wait$link1$link4
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1$link4(signed int *attempt$link1$link4, signed int blocking$link1$link4);
// ___cds_wfcq_busy_wait$link2
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link2(signed int *attempt$link2, signed int blocking$link2);
// ___cds_wfcq_busy_wait$link3
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link3(signed int *attempt$link3, signed int blocking$link3);
// ___cds_wfcq_busy_wait$link4
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link4(signed int *attempt$link4, signed int blocking$link4);
// ___cds_wfcq_busy_wait$link5
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link5(signed int *attempt$link5, signed int blocking$link5);
// ___cds_wfcq_dequeue_blocking
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail);
// ___cds_wfcq_dequeue_blocking$link1
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1);
// ___cds_wfcq_dequeue_blocking$link2
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2);
// ___cds_wfcq_dequeue_blocking$link3
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3);
// ___cds_wfcq_dequeue_blocking$link4
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4);
// ___cds_wfcq_dequeue_nonblocking
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail);
// ___cds_wfcq_dequeue_nonblocking$link1
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1);
// ___cds_wfcq_dequeue_nonblocking$link2
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2);
// ___cds_wfcq_dequeue_nonblocking$link3
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3);
// ___cds_wfcq_dequeue_nonblocking$link4
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4);
// ___cds_wfcq_dequeue_with_state
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state(union anonymous$1 u_head, struct cds_wfcq_tail *tail, signed int *state, signed int blocking);
// ___cds_wfcq_dequeue_with_state$link1
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state$link1(union anonymous$1 u_head$link1, struct cds_wfcq_tail *tail$link1, signed int *state$link1, signed int blocking$link1);
// ___cds_wfcq_dequeue_with_state$link2
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state$link2(union anonymous$1 u_head$link2, struct cds_wfcq_tail *tail$link2, signed int *state$link2, signed int blocking$link2);
// ___cds_wfcq_dequeue_with_state$link3
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state$link3(union anonymous$1 u_head$link3, struct cds_wfcq_tail *tail$link3, signed int *state$link3, signed int blocking$link3);
// ___cds_wfcq_dequeue_with_state$link4
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state$link4(union anonymous$1 u_head$link4, struct cds_wfcq_tail *tail$link4, signed int *state$link4, signed int blocking$link4);
// ___cds_wfcq_dequeue_with_state_blocking
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail, signed int *state);
// ___cds_wfcq_dequeue_with_state_blocking$link1
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, signed int *state$link1);
// ___cds_wfcq_dequeue_with_state_blocking$link2
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, signed int *state$link2);
// ___cds_wfcq_dequeue_with_state_blocking$link3
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, signed int *state$link3);
// ___cds_wfcq_dequeue_with_state_blocking$link4
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, signed int *state$link4);
// ___cds_wfcq_dequeue_with_state_nonblocking
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail, signed int *state);
// ___cds_wfcq_dequeue_with_state_nonblocking$link1
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, signed int *state$link1);
// ___cds_wfcq_dequeue_with_state_nonblocking$link2
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, signed int *state$link2);
// ___cds_wfcq_dequeue_with_state_nonblocking$link3
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, signed int *state$link3);
// ___cds_wfcq_dequeue_with_state_nonblocking$link4
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, signed int *state$link4);
// ___cds_wfcq_first
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first(union anonymous$1 u_head, struct cds_wfcq_tail *tail, signed int blocking);
// ___cds_wfcq_first$link1
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1(union anonymous$1 u_head$link1, struct cds_wfcq_tail *tail$link1, signed int blocking$link1);
// ___cds_wfcq_first$link1$link1
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1$link1(union anonymous$1 u_head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, signed int blocking$link1$link1);
// ___cds_wfcq_first$link1$link2
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1$link2(union anonymous$1 u_head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, signed int blocking$link1$link2);
// ___cds_wfcq_first$link1$link3
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1$link3(union anonymous$1 u_head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, signed int blocking$link1$link3);
// ___cds_wfcq_first$link1$link4
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1$link4(union anonymous$1 u_head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, signed int blocking$link1$link4);
// ___cds_wfcq_first$link2
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link2(union anonymous$1 u_head$link2, struct cds_wfcq_tail *tail$link2, signed int blocking$link2);
// ___cds_wfcq_first$link3
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link3(union anonymous$1 u_head$link3, struct cds_wfcq_tail *tail$link3, signed int blocking$link3);
// ___cds_wfcq_first$link4
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link4(union anonymous$1 u_head$link4, struct cds_wfcq_tail *tail$link4, signed int blocking$link4);
// ___cds_wfcq_first$link5
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link5(union anonymous$1 u_head$link5, struct cds_wfcq_tail *tail$link5, signed int blocking$link5);
// ___cds_wfcq_first_blocking
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail);
// ___cds_wfcq_first_blocking$link1
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1);
// ___cds_wfcq_first_blocking$link1$link1
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1$link1(union anonymous$1 head$link1$link1, struct cds_wfcq_tail *tail$link1$link1);
// ___cds_wfcq_first_blocking$link1$link2
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1$link2(union anonymous$1 head$link1$link2, struct cds_wfcq_tail *tail$link1$link2);
// ___cds_wfcq_first_blocking$link1$link3
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1$link3(union anonymous$1 head$link1$link3, struct cds_wfcq_tail *tail$link1$link3);
// ___cds_wfcq_first_blocking$link1$link4
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1$link4(union anonymous$1 head$link1$link4, struct cds_wfcq_tail *tail$link1$link4);
// ___cds_wfcq_first_blocking$link2
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2);
// ___cds_wfcq_first_blocking$link3
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3);
// ___cds_wfcq_first_blocking$link4
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4);
// ___cds_wfcq_first_blocking$link5
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link5(union anonymous$1 head$link5, struct cds_wfcq_tail *tail$link5);
// ___cds_wfcq_first_nonblocking
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail);
// ___cds_wfcq_first_nonblocking$link1
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1);
// ___cds_wfcq_first_nonblocking$link2
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2);
// ___cds_wfcq_first_nonblocking$link3
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3);
// ___cds_wfcq_first_nonblocking$link4
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4);
// ___cds_wfcq_init
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init(struct __cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// ___cds_wfcq_init$link1
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init$link1(struct __cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1);
// ___cds_wfcq_init$link2
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init$link2(struct __cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2);
// ___cds_wfcq_init$link3
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init$link3(struct __cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3);
// ___cds_wfcq_init$link4
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init$link4(struct __cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4);
// ___cds_wfcq_next
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node, signed int blocking);
// ___cds_wfcq_next$link1
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *node$link1, signed int blocking$link1);
// ___cds_wfcq_next$link1$link1
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1$link1(union anonymous$1 head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, struct cds_wfcq_node *node$link1$link1, signed int blocking$link1$link1);
// ___cds_wfcq_next$link1$link2
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1$link2(union anonymous$1 head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, struct cds_wfcq_node *node$link1$link2, signed int blocking$link1$link2);
// ___cds_wfcq_next$link1$link3
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1$link3(union anonymous$1 head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, struct cds_wfcq_node *node$link1$link3, signed int blocking$link1$link3);
// ___cds_wfcq_next$link1$link4
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1$link4(union anonymous$1 head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, struct cds_wfcq_node *node$link1$link4, signed int blocking$link1$link4);
// ___cds_wfcq_next$link2
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *node$link2, signed int blocking$link2);
// ___cds_wfcq_next$link3
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *node$link3, signed int blocking$link3);
// ___cds_wfcq_next$link4
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *node$link4, signed int blocking$link4);
// ___cds_wfcq_next$link5
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link5(union anonymous$1 head$link5, struct cds_wfcq_tail *tail$link5, struct cds_wfcq_node *node$link5, signed int blocking$link5);
// ___cds_wfcq_next_blocking
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node);
// ___cds_wfcq_next_blocking$link1
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *node$link1);
// ___cds_wfcq_next_blocking$link1$link1
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1$link1(union anonymous$1 head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, struct cds_wfcq_node *node$link1$link1);
// ___cds_wfcq_next_blocking$link1$link2
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1$link2(union anonymous$1 head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, struct cds_wfcq_node *node$link1$link2);
// ___cds_wfcq_next_blocking$link1$link3
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1$link3(union anonymous$1 head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, struct cds_wfcq_node *node$link1$link3);
// ___cds_wfcq_next_blocking$link1$link4
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1$link4(union anonymous$1 head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, struct cds_wfcq_node *node$link1$link4);
// ___cds_wfcq_next_blocking$link2
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *node$link2);
// ___cds_wfcq_next_blocking$link3
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *node$link3);
// ___cds_wfcq_next_blocking$link4
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *node$link4);
// ___cds_wfcq_next_blocking$link5
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link5(union anonymous$1 head$link5, struct cds_wfcq_tail *tail$link5, struct cds_wfcq_node *node$link5);
// ___cds_wfcq_next_nonblocking
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node);
// ___cds_wfcq_next_nonblocking$link1
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *node$link1);
// ___cds_wfcq_next_nonblocking$link2
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *node$link2);
// ___cds_wfcq_next_nonblocking$link3
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *node$link3);
// ___cds_wfcq_next_nonblocking$link4
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *node$link4);
// ___cds_wfcq_node_sync_next
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next(struct cds_wfcq_node *node, signed int blocking);
// ___cds_wfcq_node_sync_next$link1
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1(struct cds_wfcq_node *node$link1, signed int blocking$link1);
// ___cds_wfcq_node_sync_next$link1$link1
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1$link1(struct cds_wfcq_node *node$link1$link1, signed int blocking$link1$link1);
// ___cds_wfcq_node_sync_next$link1$link2
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1$link2(struct cds_wfcq_node *node$link1$link2, signed int blocking$link1$link2);
// ___cds_wfcq_node_sync_next$link1$link3
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1$link3(struct cds_wfcq_node *node$link1$link3, signed int blocking$link1$link3);
// ___cds_wfcq_node_sync_next$link1$link4
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1$link4(struct cds_wfcq_node *node$link1$link4, signed int blocking$link1$link4);
// ___cds_wfcq_node_sync_next$link2
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link2(struct cds_wfcq_node *node$link2, signed int blocking$link2);
// ___cds_wfcq_node_sync_next$link3
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link3(struct cds_wfcq_node *node$link3, signed int blocking$link3);
// ___cds_wfcq_node_sync_next$link4
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link4(struct cds_wfcq_node *node$link4, signed int blocking$link4);
// ___cds_wfcq_node_sync_next$link5
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link5(struct cds_wfcq_node *node$link5, signed int blocking$link5);
// ___cds_wfcq_splice
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice(union anonymous$1 u_dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 u_src_q_head, struct cds_wfcq_tail *src_q_tail, signed int blocking);
// ___cds_wfcq_splice$link1
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1(union anonymous$1 u_dest_q_head$link1, struct cds_wfcq_tail *dest_q_tail$link1, union anonymous$1 u_src_q_head$link1, struct cds_wfcq_tail *src_q_tail$link1, signed int blocking$link1);
// ___cds_wfcq_splice$link1$link1
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1$link1(union anonymous$1 u_dest_q_head$link1$link1, struct cds_wfcq_tail *dest_q_tail$link1$link1, union anonymous$1 u_src_q_head$link1$link1, struct cds_wfcq_tail *src_q_tail$link1$link1, signed int blocking$link1$link1);
// ___cds_wfcq_splice$link1$link2
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1$link2(union anonymous$1 u_dest_q_head$link1$link2, struct cds_wfcq_tail *dest_q_tail$link1$link2, union anonymous$1 u_src_q_head$link1$link2, struct cds_wfcq_tail *src_q_tail$link1$link2, signed int blocking$link1$link2);
// ___cds_wfcq_splice$link1$link3
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1$link3(union anonymous$1 u_dest_q_head$link1$link3, struct cds_wfcq_tail *dest_q_tail$link1$link3, union anonymous$1 u_src_q_head$link1$link3, struct cds_wfcq_tail *src_q_tail$link1$link3, signed int blocking$link1$link3);
// ___cds_wfcq_splice$link1$link4
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1$link4(union anonymous$1 u_dest_q_head$link1$link4, struct cds_wfcq_tail *dest_q_tail$link1$link4, union anonymous$1 u_src_q_head$link1$link4, struct cds_wfcq_tail *src_q_tail$link1$link4, signed int blocking$link1$link4);
// ___cds_wfcq_splice$link2
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link2(union anonymous$1 u_dest_q_head$link2, struct cds_wfcq_tail *dest_q_tail$link2, union anonymous$1 u_src_q_head$link2, struct cds_wfcq_tail *src_q_tail$link2, signed int blocking$link2);
// ___cds_wfcq_splice$link3
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link3(union anonymous$1 u_dest_q_head$link3, struct cds_wfcq_tail *dest_q_tail$link3, union anonymous$1 u_src_q_head$link3, struct cds_wfcq_tail *src_q_tail$link3, signed int blocking$link3);
// ___cds_wfcq_splice$link4
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link4(union anonymous$1 u_dest_q_head$link4, struct cds_wfcq_tail *dest_q_tail$link4, union anonymous$1 u_src_q_head$link4, struct cds_wfcq_tail *src_q_tail$link4, signed int blocking$link4);
// ___cds_wfcq_splice$link5
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link5(union anonymous$1 u_dest_q_head$link5, struct cds_wfcq_tail *dest_q_tail$link5, union anonymous$1 u_src_q_head$link5, struct cds_wfcq_tail *src_q_tail$link5, signed int blocking$link5);
// ___cds_wfcq_splice_blocking
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking(union anonymous$1 dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 src_q_head, struct cds_wfcq_tail *src_q_tail);
// ___cds_wfcq_splice_blocking$link1
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1(union anonymous$1 dest_q_head$link1, struct cds_wfcq_tail *dest_q_tail$link1, union anonymous$1 src_q_head$link1, struct cds_wfcq_tail *src_q_tail$link1);
// ___cds_wfcq_splice_blocking$link1$link1
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1$link1(union anonymous$1 dest_q_head$link1$link1, struct cds_wfcq_tail *dest_q_tail$link1$link1, union anonymous$1 src_q_head$link1$link1, struct cds_wfcq_tail *src_q_tail$link1$link1);
// ___cds_wfcq_splice_blocking$link1$link2
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1$link2(union anonymous$1 dest_q_head$link1$link2, struct cds_wfcq_tail *dest_q_tail$link1$link2, union anonymous$1 src_q_head$link1$link2, struct cds_wfcq_tail *src_q_tail$link1$link2);
// ___cds_wfcq_splice_blocking$link1$link3
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1$link3(union anonymous$1 dest_q_head$link1$link3, struct cds_wfcq_tail *dest_q_tail$link1$link3, union anonymous$1 src_q_head$link1$link3, struct cds_wfcq_tail *src_q_tail$link1$link3);
// ___cds_wfcq_splice_blocking$link1$link4
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1$link4(union anonymous$1 dest_q_head$link1$link4, struct cds_wfcq_tail *dest_q_tail$link1$link4, union anonymous$1 src_q_head$link1$link4, struct cds_wfcq_tail *src_q_tail$link1$link4);
// ___cds_wfcq_splice_blocking$link2
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link2(union anonymous$1 dest_q_head$link2, struct cds_wfcq_tail *dest_q_tail$link2, union anonymous$1 src_q_head$link2, struct cds_wfcq_tail *src_q_tail$link2);
// ___cds_wfcq_splice_blocking$link3
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link3(union anonymous$1 dest_q_head$link3, struct cds_wfcq_tail *dest_q_tail$link3, union anonymous$1 src_q_head$link3, struct cds_wfcq_tail *src_q_tail$link3);
// ___cds_wfcq_splice_blocking$link4
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link4(union anonymous$1 dest_q_head$link4, struct cds_wfcq_tail *dest_q_tail$link4, union anonymous$1 src_q_head$link4, struct cds_wfcq_tail *src_q_tail$link4);
// ___cds_wfcq_splice_blocking$link5
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link5(union anonymous$1 dest_q_head$link5, struct cds_wfcq_tail *dest_q_tail$link5, union anonymous$1 src_q_head$link5, struct cds_wfcq_tail *src_q_tail$link5);
// ___cds_wfcq_splice_nonblocking
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking(union anonymous$1 dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 src_q_head, struct cds_wfcq_tail *src_q_tail);
// ___cds_wfcq_splice_nonblocking$link1
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking$link1(union anonymous$1 dest_q_head$link1, struct cds_wfcq_tail *dest_q_tail$link1, union anonymous$1 src_q_head$link1, struct cds_wfcq_tail *src_q_tail$link1);
// ___cds_wfcq_splice_nonblocking$link2
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking$link2(union anonymous$1 dest_q_head$link2, struct cds_wfcq_tail *dest_q_tail$link2, union anonymous$1 src_q_head$link2, struct cds_wfcq_tail *src_q_tail$link2);
// ___cds_wfcq_splice_nonblocking$link3
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking$link3(union anonymous$1 dest_q_head$link3, struct cds_wfcq_tail *dest_q_tail$link3, union anonymous$1 src_q_head$link3, struct cds_wfcq_tail *src_q_tail$link3);
// ___cds_wfcq_splice_nonblocking$link4
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking$link4(union anonymous$1 dest_q_head$link4, struct cds_wfcq_tail *dest_q_tail$link4, union anonymous$1 src_q_head$link4, struct cds_wfcq_tail *src_q_tail$link4);
// ___cds_wfq_dequeue_blocking
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking(struct cds_wfq_queue *q);
// ___cds_wfq_dequeue_blocking$link1
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking$link1(struct cds_wfq_queue *q$link1);
// ___cds_wfq_dequeue_blocking$link2
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking$link2(struct cds_wfq_queue *q$link2);
// ___cds_wfq_dequeue_blocking$link3
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking$link3(struct cds_wfq_queue *q$link3);
// ___cds_wfq_dequeue_blocking$link4
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking$link4(struct cds_wfq_queue *q$link4);
// ___cds_wfq_node_sync_next
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next(struct cds_wfq_node *node);
// ___cds_wfq_node_sync_next$link1
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next$link1(struct cds_wfq_node *node$link1);
// ___cds_wfq_node_sync_next$link2
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next$link2(struct cds_wfq_node *node$link2);
// ___cds_wfq_node_sync_next$link3
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next$link3(struct cds_wfq_node *node$link3);
// ___cds_wfq_node_sync_next$link4
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next$link4(struct cds_wfq_node *node$link4);
// ___cds_wfs_end
// file ./urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end(void *node);
// ___cds_wfs_end$link1
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link1(void *node$link1);
// ___cds_wfs_end$link1$link1
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link1$link1(void *node$link1$link1);
// ___cds_wfs_end$link1$link2
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link1$link2(void *node$link1$link2);
// ___cds_wfs_end$link1$link3
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link1$link3(void *node$link1$link3);
// ___cds_wfs_end$link2
// file ./urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link2(void *node$link2);
// ___cds_wfs_end$link3
// file ./urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link3(void *node$link3);
// ___cds_wfs_end$link4
// file ./urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link4(void *node$link4);
// ___cds_wfs_end$link5
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link5(void *node$link5);
// ___cds_wfs_init
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init(struct __cds_wfs_stack *s);
// ___cds_wfs_init$link1
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init$link1(struct __cds_wfs_stack *s$link1);
// ___cds_wfs_init$link2
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init$link2(struct __cds_wfs_stack *s$link2);
// ___cds_wfs_init$link3
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init$link3(struct __cds_wfs_stack *s$link3);
// ___cds_wfs_init$link4
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init$link4(struct __cds_wfs_stack *s$link4);
// ___cds_wfs_next
// file ./urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next(struct cds_wfs_node *node, signed int blocking);
// ___cds_wfs_next$link1
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link1(struct cds_wfs_node *node$link1, signed int blocking$link1);
// ___cds_wfs_next$link1$link1
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link1$link1(struct cds_wfs_node *node$link1$link1, signed int blocking$link1$link1);
// ___cds_wfs_next$link1$link2
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link1$link2(struct cds_wfs_node *node$link1$link2, signed int blocking$link1$link2);
// ___cds_wfs_next$link1$link3
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link1$link3(struct cds_wfs_node *node$link1$link3, signed int blocking$link1$link3);
// ___cds_wfs_next$link2
// file ./urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link2(struct cds_wfs_node *node$link2, signed int blocking$link2);
// ___cds_wfs_next$link3
// file ./urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link3(struct cds_wfs_node *node$link3, signed int blocking$link3);
// ___cds_wfs_next$link4
// file ./urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link4(struct cds_wfs_node *node$link4, signed int blocking$link4);
// ___cds_wfs_next$link5
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link5(struct cds_wfs_node *node$link5, signed int blocking$link5);
// ___cds_wfs_node_sync_next
// file ./urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next(struct cds_wfs_node *node, signed int blocking);
// ___cds_wfs_node_sync_next$link1
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link1(struct cds_wfs_node *node$link1, signed int blocking$link1);
// ___cds_wfs_node_sync_next$link1$link1
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link1$link1(struct cds_wfs_node *node$link1$link1, signed int blocking$link1$link1);
// ___cds_wfs_node_sync_next$link1$link2
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link1$link2(struct cds_wfs_node *node$link1$link2, signed int blocking$link1$link2);
// ___cds_wfs_node_sync_next$link1$link3
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link1$link3(struct cds_wfs_node *node$link1$link3, signed int blocking$link1$link3);
// ___cds_wfs_node_sync_next$link2
// file ./urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link2(struct cds_wfs_node *node$link2, signed int blocking$link2);
// ___cds_wfs_node_sync_next$link3
// file ./urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link3(struct cds_wfs_node *node$link3, signed int blocking$link3);
// ___cds_wfs_node_sync_next$link4
// file ./urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link4(struct cds_wfs_node *node$link4, signed int blocking$link4);
// ___cds_wfs_node_sync_next$link5
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link5(struct cds_wfs_node *node$link5, signed int blocking$link5);
// ___cds_wfs_pop
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop(union anonymous u_stack, signed int *state, signed int blocking);
// ___cds_wfs_pop$link1
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop$link1(union anonymous u_stack$link1, signed int *state$link1, signed int blocking$link1);
// ___cds_wfs_pop$link2
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop$link2(union anonymous u_stack$link2, signed int *state$link2, signed int blocking$link2);
// ___cds_wfs_pop$link3
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop$link3(union anonymous u_stack$link3, signed int *state$link3, signed int blocking$link3);
// ___cds_wfs_pop$link4
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop$link4(union anonymous u_stack$link4, signed int *state$link4, signed int blocking$link4);
// ___cds_wfs_pop_all
// file ./urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all(union anonymous u_stack);
// ___cds_wfs_pop_all$link1
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link1(union anonymous u_stack$link1);
// ___cds_wfs_pop_all$link1$link1
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link1$link1(union anonymous u_stack$link1$link1);
// ___cds_wfs_pop_all$link1$link2
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link1$link2(union anonymous u_stack$link1$link2);
// ___cds_wfs_pop_all$link1$link3
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link1$link3(union anonymous u_stack$link1$link3);
// ___cds_wfs_pop_all$link2
// file ./urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link2(union anonymous u_stack$link2);
// ___cds_wfs_pop_all$link3
// file ./urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link3(union anonymous u_stack$link3);
// ___cds_wfs_pop_all$link4
// file ./urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link4(union anonymous u_stack$link4);
// ___cds_wfs_pop_all$link5
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link5(union anonymous u_stack$link5);
// ___cds_wfs_pop_blocking
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking(union anonymous u_stack);
// ___cds_wfs_pop_blocking$link1
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking$link1(union anonymous u_stack$link1);
// ___cds_wfs_pop_blocking$link2
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking$link2(union anonymous u_stack$link2);
// ___cds_wfs_pop_blocking$link3
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking$link3(union anonymous u_stack$link3);
// ___cds_wfs_pop_blocking$link4
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking$link4(union anonymous u_stack$link4);
// ___cds_wfs_pop_nonblocking
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking(union anonymous u_stack);
// ___cds_wfs_pop_nonblocking$link1
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking$link1(union anonymous u_stack$link1);
// ___cds_wfs_pop_nonblocking$link2
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking$link2(union anonymous u_stack$link2);
// ___cds_wfs_pop_nonblocking$link3
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking$link3(union anonymous u_stack$link3);
// ___cds_wfs_pop_nonblocking$link4
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking$link4(union anonymous u_stack$link4);
// ___cds_wfs_pop_with_state_blocking
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking(union anonymous u_stack, signed int *state);
// ___cds_wfs_pop_with_state_blocking$link1
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking$link1(union anonymous u_stack$link1, signed int *state$link1);
// ___cds_wfs_pop_with_state_blocking$link2
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking$link2(union anonymous u_stack$link2, signed int *state$link2);
// ___cds_wfs_pop_with_state_blocking$link3
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking$link3(union anonymous u_stack$link3, signed int *state$link3);
// ___cds_wfs_pop_with_state_blocking$link4
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking$link4(union anonymous u_stack$link4, signed int *state$link4);
// ___cds_wfs_pop_with_state_nonblocking
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking(union anonymous u_stack, signed int *state);
// ___cds_wfs_pop_with_state_nonblocking$link1
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking$link1(union anonymous u_stack$link1, signed int *state$link1);
// ___cds_wfs_pop_with_state_nonblocking$link2
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking$link2(union anonymous u_stack$link2, signed int *state$link2);
// ___cds_wfs_pop_with_state_nonblocking$link3
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking$link3(union anonymous u_stack$link3, signed int *state$link3);
// ___cds_wfs_pop_with_state_nonblocking$link4
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking$link4(union anonymous u_stack$link4, signed int *state$link4);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __cds_list_del
// file ./urcu/list.h line 71
static inline void __cds_list_del(struct cds_list_head *prev, struct cds_list_head *next);
// __cds_list_del$link1
// file ./urcu/list.h line 71
static inline void __cds_list_del$link1(struct cds_list_head *prev$link1, struct cds_list_head *next$link1);
// __cds_list_del$link2
// file ./urcu/list.h line 71
static inline void __cds_list_del$link2(struct cds_list_head *prev$link2, struct cds_list_head *next$link2);
// __cds_list_del$link3
// file ./urcu/list.h line 71
static inline void __cds_list_del$link3(struct cds_list_head *prev$link3, struct cds_list_head *next$link3);
// __cds_list_del$link4
// file ./urcu/list.h line 71
static inline void __cds_list_del$link4(struct cds_list_head *prev$link4, struct cds_list_head *next$link4);
// __cds_wfcq_dequeue_blocking
// file wfcqueue.c line 100
extern struct cds_wfcq_node * __cds_wfcq_dequeue_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail);
// __cds_wfcq_dequeue_nonblocking
// file wfcqueue.c line 115
extern struct cds_wfcq_node * __cds_wfcq_dequeue_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail);
// __cds_wfcq_dequeue_with_state_blocking
// file wfcqueue.c line 107
extern struct cds_wfcq_node * __cds_wfcq_dequeue_with_state_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail, signed int *state);
// __cds_wfcq_dequeue_with_state_nonblocking
// file wfcqueue.c line 122
extern struct cds_wfcq_node * __cds_wfcq_dequeue_with_state_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail, signed int *state);
// __cds_wfcq_first_blocking
// file wfcqueue.c line 150
extern struct cds_wfcq_node * __cds_wfcq_first_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail);
// __cds_wfcq_first_nonblocking
// file wfcqueue.c line 157
extern struct cds_wfcq_node * __cds_wfcq_first_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail);
// __cds_wfcq_init
// file wfcqueue.c line 43
extern void __cds_wfcq_init(struct __cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// __cds_wfcq_next_blocking
// file wfcqueue.c line 164
extern struct cds_wfcq_node * __cds_wfcq_next_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node);
// __cds_wfcq_next_nonblocking
// file wfcqueue.c line 172
extern struct cds_wfcq_node * __cds_wfcq_next_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node);
// __cds_wfcq_splice_blocking
// file wfcqueue.c line 130
extern enum cds_wfcq_ret __cds_wfcq_splice_blocking(union anonymous$1 dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 src_q_head, struct cds_wfcq_tail *src_q_tail);
// __cds_wfcq_splice_nonblocking
// file wfcqueue.c line 140
extern enum cds_wfcq_ret __cds_wfcq_splice_nonblocking(union anonymous$1 dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 src_q_head, struct cds_wfcq_tail *src_q_tail);
// __cds_wfq_dequeue_blocking
// file wfqueue.c line 49
extern struct cds_wfq_node * __cds_wfq_dequeue_blocking(struct cds_wfq_queue *q);
// __cds_wfs_init
// file wfstack.c line 41
extern void __cds_wfs_init(struct __cds_wfs_stack *s);
// __cds_wfs_pop_all
// file wfstack.c line 121
extern struct cds_wfs_head * __cds_wfs_pop_all(union anonymous u_stack);
// __cds_wfs_pop_blocking
// file wfstack.c line 97
extern struct cds_wfs_node * __cds_wfs_pop_blocking(union anonymous u_stack);
// __cds_wfs_pop_nonblocking
// file wfstack.c line 109
extern struct cds_wfs_node * __cds_wfs_pop_nonblocking(union anonymous u_stack);
// __cds_wfs_pop_with_state_blocking
// file wfstack.c line 103
extern struct cds_wfs_node * __cds_wfs_pop_with_state_blocking(union anonymous u_stack, signed int *state);
// __cds_wfs_pop_with_state_nonblocking
// file wfstack.c line 115
extern struct cds_wfs_node * __cds_wfs_pop_with_state_nonblocking(union anonymous u_stack, signed int *state);
// __create_call_rcu_data
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data(unsigned long int flags, signed int cpu_affinity);
// __create_call_rcu_data$link1
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data$link1(unsigned long int flags$link1, signed int cpu_affinity$link1);
// __create_call_rcu_data$link2
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data$link2(unsigned long int flags$link2, signed int cpu_affinity$link2);
// __create_call_rcu_data$link3
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data$link3(unsigned long int flags$link3, signed int cpu_affinity$link3);
// __create_call_rcu_data$link4
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data$link4(unsigned long int flags$link4, signed int cpu_affinity$link4);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __uatomic_add
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add(void *addr, unsigned long int val, signed int len);
// __uatomic_add$link1
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1);
// __uatomic_add$link2
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2);
// __uatomic_add$link3
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3);
// __uatomic_add$link4
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4);
// __uatomic_add_return
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return(void *addr, unsigned long int val, signed int len);
// __uatomic_add_return$link1
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1);
// __uatomic_add_return$link2
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2);
// __uatomic_add_return$link3
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3);
// __uatomic_add_return$link4
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4);
// __uatomic_and
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and(void *addr, unsigned long int val, signed int len);
// __uatomic_and$link1
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1);
// __uatomic_and$link2
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2);
// __uatomic_and$link3
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3);
// __uatomic_and$link4
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4);
// __uatomic_cmpxchg
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg(void *addr, unsigned long int old, unsigned long int _new, signed int len);
// __uatomic_cmpxchg$link1
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1(void *addr$link1, unsigned long int old$link1, unsigned long int _new$link1, signed int len$link1);
// __uatomic_cmpxchg$link1$link1
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link1(void *addr$link1$link1, unsigned long int old$link1$link1, unsigned long int _new$link1$link1, signed int len$link1$link1);
// __uatomic_cmpxchg$link1$link1$link1
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link1$link1(void *addr$link1$link1$link1, unsigned long int old$link1$link1$link1, unsigned long int _new$link1$link1$link1, signed int len$link1$link1$link1);
// __uatomic_cmpxchg$link1$link2
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link2(void *addr$link1$link2, unsigned long int old$link1$link2, unsigned long int _new$link1$link2, signed int len$link1$link2);
// __uatomic_cmpxchg$link1$link3
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link3(void *addr$link1$link3, unsigned long int old$link1$link3, unsigned long int _new$link1$link3, signed int len$link1$link3);
// __uatomic_cmpxchg$link1$link4
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link4(void *addr$link1$link4, unsigned long int old$link1$link4, unsigned long int _new$link1$link4, signed int len$link1$link4);
// __uatomic_cmpxchg$link2
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2(void *addr$link2, unsigned long int old$link2, unsigned long int _new$link2, signed int len$link2);
// __uatomic_cmpxchg$link2$link1
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2$link1(void *addr$link2$link1, unsigned long int old$link2$link1, unsigned long int _new$link2$link1, signed int len$link2$link1);
// __uatomic_cmpxchg$link2$link2
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2$link2(void *addr$link2$link2, unsigned long int old$link2$link2, unsigned long int _new$link2$link2, signed int len$link2$link2);
// __uatomic_cmpxchg$link2$link3
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2$link3(void *addr$link2$link3, unsigned long int old$link2$link3, unsigned long int _new$link2$link3, signed int len$link2$link3);
// __uatomic_cmpxchg$link2$link4
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2$link4(void *addr$link2$link4, unsigned long int old$link2$link4, unsigned long int _new$link2$link4, signed int len$link2$link4);
// __uatomic_cmpxchg$link3
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link3(void *addr$link3, unsigned long int old$link3, unsigned long int _new$link3, signed int len$link3);
// __uatomic_cmpxchg$link4
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link4(void *addr$link4, unsigned long int old$link4, unsigned long int _new$link4, signed int len$link4);
// __uatomic_cmpxchg$link5
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link5(void *addr$link5, unsigned long int old$link5, unsigned long int _new$link5, signed int len$link5);
// __uatomic_cmpxchg$link6
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link6(void *addr$link6, unsigned long int old$link6, unsigned long int _new$link6, signed int len$link6);
// __uatomic_dec
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec(void *addr, signed int len);
// __uatomic_dec$link1
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec$link1(void *addr$link1, signed int len$link1);
// __uatomic_dec$link2
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec$link2(void *addr$link2, signed int len$link2);
// __uatomic_dec$link3
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec$link3(void *addr$link3, signed int len$link3);
// __uatomic_dec$link4
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec$link4(void *addr$link4, signed int len$link4);
// __uatomic_exchange
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange(void *addr, unsigned long int val, signed int len);
// __uatomic_exchange$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1);
// __uatomic_exchange$link1$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1(void *addr$link1$link1, unsigned long int val$link1$link1, signed int len$link1$link1);
// __uatomic_exchange$link1$link1$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1$link1(void *addr$link1$link1$link1, unsigned long int val$link1$link1$link1, signed int len$link1$link1$link1);
// __uatomic_exchange$link1$link1$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1$link2(void *addr$link1$link1$link2, unsigned long int val$link1$link1$link2, signed int len$link1$link1$link2);
// __uatomic_exchange$link1$link1$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1$link3(void *addr$link1$link1$link3, unsigned long int val$link1$link1$link3, signed int len$link1$link1$link3);
// __uatomic_exchange$link1$link1$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1$link4(void *addr$link1$link1$link4, unsigned long int val$link1$link1$link4, signed int len$link1$link1$link4);
// __uatomic_exchange$link1$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link2(void *addr$link1$link2, unsigned long int val$link1$link2, signed int len$link1$link2);
// __uatomic_exchange$link1$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link3(void *addr$link1$link3, unsigned long int val$link1$link3, signed int len$link1$link3);
// __uatomic_exchange$link1$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link4(void *addr$link1$link4, unsigned long int val$link1$link4, signed int len$link1$link4);
// __uatomic_exchange$link1$link5
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link5(void *addr$link1$link5, unsigned long int val$link1$link5, signed int len$link1$link5);
// __uatomic_exchange$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2);
// __uatomic_exchange$link2$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2$link1(void *addr$link2$link1, unsigned long int val$link2$link1, signed int len$link2$link1);
// __uatomic_exchange$link2$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2$link2(void *addr$link2$link2, unsigned long int val$link2$link2, signed int len$link2$link2);
// __uatomic_exchange$link2$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2$link3(void *addr$link2$link3, unsigned long int val$link2$link3, signed int len$link2$link3);
// __uatomic_exchange$link2$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2$link4(void *addr$link2$link4, unsigned long int val$link2$link4, signed int len$link2$link4);
// __uatomic_exchange$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3);
// __uatomic_exchange$link3$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3$link1(void *addr$link3$link1, unsigned long int val$link3$link1, signed int len$link3$link1);
// __uatomic_exchange$link3$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3$link2(void *addr$link3$link2, unsigned long int val$link3$link2, signed int len$link3$link2);
// __uatomic_exchange$link3$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3$link3(void *addr$link3$link3, unsigned long int val$link3$link3, signed int len$link3$link3);
// __uatomic_exchange$link3$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3$link4(void *addr$link3$link4, unsigned long int val$link3$link4, signed int len$link3$link4);
// __uatomic_exchange$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4);
// __uatomic_exchange$link5
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link5(void *addr$link5, unsigned long int val$link5, signed int len$link5);
// __uatomic_exchange$link6
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link6(void *addr$link6, unsigned long int val$link6, signed int len$link6);
// __uatomic_exchange$link7
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link7(void *addr$link7, unsigned long int val$link7, signed int len$link7);
// __uatomic_inc
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc(void *addr, signed int len);
// __uatomic_inc$link1
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc$link1(void *addr$link1, signed int len$link1);
// __uatomic_inc$link2
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc$link2(void *addr$link2, signed int len$link2);
// __uatomic_inc$link3
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc$link3(void *addr$link3, signed int len$link3);
// __uatomic_inc$link4
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc$link4(void *addr$link4, signed int len$link4);
// __uatomic_or
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or(void *addr, unsigned long int val, signed int len);
// __uatomic_or$link1
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1);
// __uatomic_or$link2
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2);
// __uatomic_or$link3
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3);
// __uatomic_or$link4
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4);
// _call_rcu
// file urcu-call-rcu-impl.h line 680
static void _call_rcu(struct rcu_head *head, void (*func)(struct rcu_head *), struct call_rcu_data *crdp);
// _call_rcu$link1
// file urcu-call-rcu-impl.h line 680
static void _call_rcu$link1(struct rcu_head *head$link1, void (*func$link1)(struct rcu_head *), struct call_rcu_data *crdp$link1);
// _call_rcu$link2
// file urcu-call-rcu-impl.h line 680
static void _call_rcu$link2(struct rcu_head *head$link2, void (*func$link2)(struct rcu_head *), struct call_rcu_data *crdp$link2);
// _call_rcu$link3
// file urcu-call-rcu-impl.h line 680
static void _call_rcu$link3(struct rcu_head *head$link3, void (*func$link3)(struct rcu_head *), struct call_rcu_data *crdp$link3);
// _call_rcu$link4
// file urcu-call-rcu-impl.h line 680
static void _call_rcu$link4(struct rcu_head *head$link4, void (*func$link4)(struct rcu_head *), struct call_rcu_data *crdp$link4);
// _call_rcu::func$link1$object
//
void func$link1$object(struct rcu_head *);
// _call_rcu::func$link2$object
//
void func$link2$object(struct rcu_head *);
// _call_rcu::func$link3$object
//
void func$link3$object(struct rcu_head *);
// _call_rcu::func$link4$object
//
void func$link4$object(struct rcu_head *);
// _call_rcu::func$object
//
void func$object(struct rcu_head *);
// _cds_wfcq_dequeue_blocking
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// _cds_wfcq_dequeue_blocking$link1
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1);
// _cds_wfcq_dequeue_blocking$link2
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2);
// _cds_wfcq_dequeue_blocking$link3
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3);
// _cds_wfcq_dequeue_blocking$link4
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4);
// _cds_wfcq_dequeue_lock
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// _cds_wfcq_dequeue_lock$link1
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1);
// _cds_wfcq_dequeue_lock$link2
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2);
// _cds_wfcq_dequeue_lock$link3
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3);
// _cds_wfcq_dequeue_lock$link4
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4);
// _cds_wfcq_dequeue_unlock
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// _cds_wfcq_dequeue_unlock$link1
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1);
// _cds_wfcq_dequeue_unlock$link2
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2);
// _cds_wfcq_dequeue_unlock$link3
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3);
// _cds_wfcq_dequeue_unlock$link4
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4);
// _cds_wfcq_dequeue_with_state_blocking
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail, signed int *state);
// _cds_wfcq_dequeue_with_state_blocking$link1
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1, signed int *state$link1);
// _cds_wfcq_dequeue_with_state_blocking$link2
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2, signed int *state$link2);
// _cds_wfcq_dequeue_with_state_blocking$link3
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3, signed int *state$link3);
// _cds_wfcq_dequeue_with_state_blocking$link4
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4, signed int *state$link4);
// _cds_wfcq_empty
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty(union anonymous$1 u_head, struct cds_wfcq_tail *tail);
// _cds_wfcq_empty$link1
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1(union anonymous$1 u_head$link1, struct cds_wfcq_tail *tail$link1);
// _cds_wfcq_empty$link1$link1
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1$link1(union anonymous$1 u_head$link1$link1, struct cds_wfcq_tail *tail$link1$link1);
// _cds_wfcq_empty$link1$link2
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1$link2(union anonymous$1 u_head$link1$link2, struct cds_wfcq_tail *tail$link1$link2);
// _cds_wfcq_empty$link1$link3
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1$link3(union anonymous$1 u_head$link1$link3, struct cds_wfcq_tail *tail$link1$link3);
// _cds_wfcq_empty$link1$link4
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1$link4(union anonymous$1 u_head$link1$link4, struct cds_wfcq_tail *tail$link1$link4);
// _cds_wfcq_empty$link2
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link2(union anonymous$1 u_head$link2, struct cds_wfcq_tail *tail$link2);
// _cds_wfcq_empty$link3
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link3(union anonymous$1 u_head$link3, struct cds_wfcq_tail *tail$link3);
// _cds_wfcq_empty$link4
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link4(union anonymous$1 u_head$link4, struct cds_wfcq_tail *tail$link4);
// _cds_wfcq_empty$link5
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link5(union anonymous$1 u_head$link5, struct cds_wfcq_tail *tail$link5);
// _cds_wfcq_enqueue
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *new_tail);
// _cds_wfcq_enqueue$link1
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *new_tail$link1);
// _cds_wfcq_enqueue$link1$link1
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1$link1(union anonymous$1 head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, struct cds_wfcq_node *new_tail$link1$link1);
// _cds_wfcq_enqueue$link1$link2
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1$link2(union anonymous$1 head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, struct cds_wfcq_node *new_tail$link1$link2);
// _cds_wfcq_enqueue$link1$link3
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1$link3(union anonymous$1 head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, struct cds_wfcq_node *new_tail$link1$link3);
// _cds_wfcq_enqueue$link1$link4
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1$link4(union anonymous$1 head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, struct cds_wfcq_node *new_tail$link1$link4);
// _cds_wfcq_enqueue$link2
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *new_tail$link2);
// _cds_wfcq_enqueue$link3
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *new_tail$link3);
// _cds_wfcq_enqueue$link4
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *new_tail$link4);
// _cds_wfcq_enqueue$link5
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link5(union anonymous$1 head$link5, struct cds_wfcq_tail *tail$link5, struct cds_wfcq_node *new_tail$link5);
// _cds_wfcq_init
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// _cds_wfcq_init$link1
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1);
// _cds_wfcq_init$link1$link1
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1$link1(struct cds_wfcq_head *head$link1$link1, struct cds_wfcq_tail *tail$link1$link1);
// _cds_wfcq_init$link1$link2
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1$link2(struct cds_wfcq_head *head$link1$link2, struct cds_wfcq_tail *tail$link1$link2);
// _cds_wfcq_init$link1$link3
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1$link3(struct cds_wfcq_head *head$link1$link3, struct cds_wfcq_tail *tail$link1$link3);
// _cds_wfcq_init$link1$link4
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1$link4(struct cds_wfcq_head *head$link1$link4, struct cds_wfcq_tail *tail$link1$link4);
// _cds_wfcq_init$link2
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2);
// _cds_wfcq_init$link3
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3);
// _cds_wfcq_init$link4
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4);
// _cds_wfcq_init$link5
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link5(struct cds_wfcq_head *head$link5, struct cds_wfcq_tail *tail$link5);
// _cds_wfcq_node_init
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init(struct cds_wfcq_node *node);
// _cds_wfcq_node_init$link1
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1(struct cds_wfcq_node *node$link1);
// _cds_wfcq_node_init$link1$link1
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1$link1(struct cds_wfcq_node *node$link1$link1);
// _cds_wfcq_node_init$link1$link2
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1$link2(struct cds_wfcq_node *node$link1$link2);
// _cds_wfcq_node_init$link1$link3
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1$link3(struct cds_wfcq_node *node$link1$link3);
// _cds_wfcq_node_init$link1$link4
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1$link4(struct cds_wfcq_node *node$link1$link4);
// _cds_wfcq_node_init$link2
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link2(struct cds_wfcq_node *node$link2);
// _cds_wfcq_node_init$link3
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link3(struct cds_wfcq_node *node$link3);
// _cds_wfcq_node_init$link4
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link4(struct cds_wfcq_node *node$link4);
// _cds_wfcq_node_init$link5
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link5(struct cds_wfcq_node *node$link5);
// _cds_wfcq_splice_blocking
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking(struct cds_wfcq_head *dest_q_head, struct cds_wfcq_tail *dest_q_tail, struct cds_wfcq_head *src_q_head, struct cds_wfcq_tail *src_q_tail);
// _cds_wfcq_splice_blocking$link1
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking$link1(struct cds_wfcq_head *dest_q_head$link1, struct cds_wfcq_tail *dest_q_tail$link1, struct cds_wfcq_head *src_q_head$link1, struct cds_wfcq_tail *src_q_tail$link1);
// _cds_wfcq_splice_blocking$link2
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking$link2(struct cds_wfcq_head *dest_q_head$link2, struct cds_wfcq_tail *dest_q_tail$link2, struct cds_wfcq_head *src_q_head$link2, struct cds_wfcq_tail *src_q_tail$link2);
// _cds_wfcq_splice_blocking$link3
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking$link3(struct cds_wfcq_head *dest_q_head$link3, struct cds_wfcq_tail *dest_q_tail$link3, struct cds_wfcq_head *src_q_head$link3, struct cds_wfcq_tail *src_q_tail$link3);
// _cds_wfcq_splice_blocking$link4
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking$link4(struct cds_wfcq_head *dest_q_head$link4, struct cds_wfcq_tail *dest_q_tail$link4, struct cds_wfcq_head *src_q_head$link4, struct cds_wfcq_tail *src_q_tail$link4);
// _cds_wfq_dequeue_blocking
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking(struct cds_wfq_queue *q);
// _cds_wfq_dequeue_blocking$link1
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking$link1(struct cds_wfq_queue *q$link1);
// _cds_wfq_dequeue_blocking$link2
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking$link2(struct cds_wfq_queue *q$link2);
// _cds_wfq_dequeue_blocking$link3
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking$link3(struct cds_wfq_queue *q$link3);
// _cds_wfq_dequeue_blocking$link4
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking$link4(struct cds_wfq_queue *q$link4);
// _cds_wfq_enqueue
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue(struct cds_wfq_queue *q, struct cds_wfq_node *node);
// _cds_wfq_enqueue$link1
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue$link1(struct cds_wfq_queue *q$link1, struct cds_wfq_node *node$link1);
// _cds_wfq_enqueue$link2
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue$link2(struct cds_wfq_queue *q$link2, struct cds_wfq_node *node$link2);
// _cds_wfq_enqueue$link3
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue$link3(struct cds_wfq_queue *q$link3, struct cds_wfq_node *node$link3);
// _cds_wfq_enqueue$link4
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue$link4(struct cds_wfq_queue *q$link4, struct cds_wfq_node *node$link4);
// _cds_wfq_init
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init(struct cds_wfq_queue *q);
// _cds_wfq_init$link1
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init$link1(struct cds_wfq_queue *q$link1);
// _cds_wfq_init$link2
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init$link2(struct cds_wfq_queue *q$link2);
// _cds_wfq_init$link3
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init$link3(struct cds_wfq_queue *q$link3);
// _cds_wfq_init$link4
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init$link4(struct cds_wfq_queue *q$link4);
// _cds_wfq_node_init
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init(struct cds_wfq_node *node);
// _cds_wfq_node_init$link1
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init$link1(struct cds_wfq_node *node$link1);
// _cds_wfq_node_init$link2
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init$link2(struct cds_wfq_node *node$link2);
// _cds_wfq_node_init$link3
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init$link3(struct cds_wfq_node *node$link3);
// _cds_wfq_node_init$link4
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init$link4(struct cds_wfq_node *node$link4);
// _cds_wfs_empty
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty(union anonymous u_stack);
// _cds_wfs_empty$link1
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty$link1(union anonymous u_stack$link1);
// _cds_wfs_empty$link2
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty$link2(union anonymous u_stack$link2);
// _cds_wfs_empty$link3
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty$link3(union anonymous u_stack$link3);
// _cds_wfs_empty$link4
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty$link4(union anonymous u_stack$link4);
// _cds_wfs_first
// file ./urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first(struct cds_wfs_head *head);
// _cds_wfs_first$link1
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link1(struct cds_wfs_head *head$link1);
// _cds_wfs_first$link1$link1
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link1$link1(struct cds_wfs_head *head$link1$link1);
// _cds_wfs_first$link1$link2
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link1$link2(struct cds_wfs_head *head$link1$link2);
// _cds_wfs_first$link1$link3
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link1$link3(struct cds_wfs_head *head$link1$link3);
// _cds_wfs_first$link2
// file ./urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link2(struct cds_wfs_head *head$link2);
// _cds_wfs_first$link3
// file ./urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link3(struct cds_wfs_head *head$link3);
// _cds_wfs_first$link4
// file ./urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link4(struct cds_wfs_head *head$link4);
// _cds_wfs_first$link5
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link5(struct cds_wfs_head *head$link5);
// _cds_wfs_init
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init(struct cds_wfs_stack *s);
// _cds_wfs_init$link1
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init$link1(struct cds_wfs_stack *s$link1);
// _cds_wfs_init$link2
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init$link2(struct cds_wfs_stack *s$link2);
// _cds_wfs_init$link3
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init$link3(struct cds_wfs_stack *s$link3);
// _cds_wfs_init$link4
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init$link4(struct cds_wfs_stack *s$link4);
// _cds_wfs_next_blocking
// file ./urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking(struct cds_wfs_node *node);
// _cds_wfs_next_blocking$link1
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link1(struct cds_wfs_node *node$link1);
// _cds_wfs_next_blocking$link1$link1
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link1$link1(struct cds_wfs_node *node$link1$link1);
// _cds_wfs_next_blocking$link1$link2
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link1$link2(struct cds_wfs_node *node$link1$link2);
// _cds_wfs_next_blocking$link1$link3
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link1$link3(struct cds_wfs_node *node$link1$link3);
// _cds_wfs_next_blocking$link2
// file ./urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link2(struct cds_wfs_node *node$link2);
// _cds_wfs_next_blocking$link3
// file ./urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link3(struct cds_wfs_node *node$link3);
// _cds_wfs_next_blocking$link4
// file ./urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link4(struct cds_wfs_node *node$link4);
// _cds_wfs_next_blocking$link5
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link5(struct cds_wfs_node *node$link5);
// _cds_wfs_next_nonblocking
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking(struct cds_wfs_node *node);
// _cds_wfs_next_nonblocking$link1
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking$link1(struct cds_wfs_node *node$link1);
// _cds_wfs_next_nonblocking$link2
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking$link2(struct cds_wfs_node *node$link2);
// _cds_wfs_next_nonblocking$link3
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking$link3(struct cds_wfs_node *node$link3);
// _cds_wfs_next_nonblocking$link4
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking$link4(struct cds_wfs_node *node$link4);
// _cds_wfs_node_init
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init(struct cds_wfs_node *node);
// _cds_wfs_node_init$link1
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init$link1(struct cds_wfs_node *node$link1);
// _cds_wfs_node_init$link2
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init$link2(struct cds_wfs_node *node$link2);
// _cds_wfs_node_init$link3
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init$link3(struct cds_wfs_node *node$link3);
// _cds_wfs_node_init$link4
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init$link4(struct cds_wfs_node *node$link4);
// _cds_wfs_pop_all_blocking
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking(struct cds_wfs_stack *s);
// _cds_wfs_pop_all_blocking$link1
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking$link1(struct cds_wfs_stack *s$link1);
// _cds_wfs_pop_all_blocking$link2
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking$link2(struct cds_wfs_stack *s$link2);
// _cds_wfs_pop_all_blocking$link3
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking$link3(struct cds_wfs_stack *s$link3);
// _cds_wfs_pop_all_blocking$link4
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking$link4(struct cds_wfs_stack *s$link4);
// _cds_wfs_pop_blocking
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking(struct cds_wfs_stack *s);
// _cds_wfs_pop_blocking$link1
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking$link1(struct cds_wfs_stack *s$link1);
// _cds_wfs_pop_blocking$link2
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking$link2(struct cds_wfs_stack *s$link2);
// _cds_wfs_pop_blocking$link3
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking$link3(struct cds_wfs_stack *s$link3);
// _cds_wfs_pop_blocking$link4
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking$link4(struct cds_wfs_stack *s$link4);
// _cds_wfs_pop_lock
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock(struct cds_wfs_stack *s);
// _cds_wfs_pop_lock$link1
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock$link1(struct cds_wfs_stack *s$link1);
// _cds_wfs_pop_lock$link2
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock$link2(struct cds_wfs_stack *s$link2);
// _cds_wfs_pop_lock$link3
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock$link3(struct cds_wfs_stack *s$link3);
// _cds_wfs_pop_lock$link4
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock$link4(struct cds_wfs_stack *s$link4);
// _cds_wfs_pop_unlock
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock(struct cds_wfs_stack *s);
// _cds_wfs_pop_unlock$link1
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock$link1(struct cds_wfs_stack *s$link1);
// _cds_wfs_pop_unlock$link2
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock$link2(struct cds_wfs_stack *s$link2);
// _cds_wfs_pop_unlock$link3
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock$link3(struct cds_wfs_stack *s$link3);
// _cds_wfs_pop_unlock$link4
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock$link4(struct cds_wfs_stack *s$link4);
// _cds_wfs_pop_with_state_blocking
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking(struct cds_wfs_stack *s, signed int *state);
// _cds_wfs_pop_with_state_blocking$link1
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking$link1(struct cds_wfs_stack *s$link1, signed int *state$link1);
// _cds_wfs_pop_with_state_blocking$link2
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking$link2(struct cds_wfs_stack *s$link2, signed int *state$link2);
// _cds_wfs_pop_with_state_blocking$link3
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking$link3(struct cds_wfs_stack *s$link3, signed int *state$link3);
// _cds_wfs_pop_with_state_blocking$link4
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking$link4(struct cds_wfs_stack *s$link4, signed int *state$link4);
// _cds_wfs_push
// file ./urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push(union anonymous u_stack, struct cds_wfs_node *node);
// _cds_wfs_push$link1
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link1(union anonymous u_stack$link1, struct cds_wfs_node *node$link1);
// _cds_wfs_push$link1$link1
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link1$link1(union anonymous u_stack$link1$link1, struct cds_wfs_node *node$link1$link1);
// _cds_wfs_push$link1$link2
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link1$link2(union anonymous u_stack$link1$link2, struct cds_wfs_node *node$link1$link2);
// _cds_wfs_push$link1$link3
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link1$link3(union anonymous u_stack$link1$link3, struct cds_wfs_node *node$link1$link3);
// _cds_wfs_push$link2
// file ./urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link2(union anonymous u_stack$link2, struct cds_wfs_node *node$link2);
// _cds_wfs_push$link3
// file ./urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link3(union anonymous u_stack$link3, struct cds_wfs_node *node$link3);
// _cds_wfs_push$link4
// file ./urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link4(union anonymous u_stack$link4, struct cds_wfs_node *node$link4);
// _cds_wfs_push$link5
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link5(union anonymous u_stack$link5, struct cds_wfs_node *node$link5);
// _cleanup
// file tap.c line 414
static void _cleanup(void);
// _defer_rcu
// file urcu-defer-impl.h line 311
static void _defer_rcu(void (*fct)(void *), void *p);
// _defer_rcu$link1
// file urcu-defer-impl.h line 311
static void _defer_rcu$link1(void (*fct$link1)(void *), void *p$link1);
// _defer_rcu$link2
// file urcu-defer-impl.h line 311
static void _defer_rcu$link2(void (*fct$link2)(void *), void *p$link2);
// _defer_rcu$link3
// file urcu-defer-impl.h line 311
static void _defer_rcu$link3(void (*fct$link3)(void *), void *p$link3);
// _defer_rcu$link4
// file urcu-defer-impl.h line 311
static void _defer_rcu$link4(void (*fct$link4)(void *), void *p$link4);
// _defer_rcu::fct$link1$object
//
void fct$link1$object(void *);
// _defer_rcu::fct$link2$object
//
void fct$link2$object(void *);
// _defer_rcu::fct$link3$object
//
void fct$link3$object(void *);
// _defer_rcu::fct$link4$object
//
void fct$link4$object(void *);
// _defer_rcu::fct$object
//
void fct$object(void *);
// _expected_tests
// file tap.c line 315
static void _expected_tests(unsigned int tests);
// _gen_result
// file ../../tests/utils/tap.h line 76
unsigned int _gen_result(signed int ok, const char *func, char *file, unsigned int line, char *test_name, ...);
// _rcu_barrier_complete
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete(struct rcu_head *head);
// _rcu_barrier_complete$link1
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete$link1(struct rcu_head *head$link1);
// _rcu_barrier_complete$link2
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete$link2(struct rcu_head *head$link2);
// _rcu_barrier_complete$link3
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete$link3(struct rcu_head *head$link3);
// _rcu_barrier_complete$link4
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete$link4(struct rcu_head *head$link4);
// _rcu_defer_barrier_thread
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread(void);
// _rcu_defer_barrier_thread$link1
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread$link1(void);
// _rcu_defer_barrier_thread$link2
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread$link2(void);
// _rcu_defer_barrier_thread$link3
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread$link3(void);
// _rcu_defer_barrier_thread$link4
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread$link4(void);
// _rcu_quiescent_state_qsbr
// file urcu/static/urcu-qsbr.h line 193
static inline void _rcu_quiescent_state_qsbr(void);
// _rcu_quiescent_state_update_and_wakeup
// file urcu/static/urcu-qsbr.h line 172
static inline void _rcu_quiescent_state_update_and_wakeup(unsigned long int gp_ctr);
// _rcu_read_lock_bp
// file urcu/static/urcu-bp.h line 159
static inline void _rcu_read_lock_bp(void);
// _rcu_read_lock_mb
// file urcu/static/urcu.h line 214
static inline void _rcu_read_lock_mb(void);
// _rcu_read_lock_memb
// file urcu/static/urcu.h line 214
static inline void _rcu_read_lock_memb(void);
// _rcu_read_lock_qsbr
// file urcu/static/urcu-qsbr.h line 134
static inline void _rcu_read_lock_qsbr(void);
// _rcu_read_lock_sig
// file urcu/static/urcu.h line 214
static inline void _rcu_read_lock_sig(void);
// _rcu_read_lock_update
// file urcu/static/urcu.h line 195
static inline void _rcu_read_lock_update(unsigned long int tmp);
// _rcu_read_lock_update$link1
// file urcu/static/urcu.h line 195
static inline void _rcu_read_lock_update$link1(unsigned long int tmp$link1);
// _rcu_read_lock_update$link2
// file urcu/static/urcu.h line 195
static inline void _rcu_read_lock_update$link2(unsigned long int tmp$link2);
// _rcu_read_lock_update$link3
// file urcu/static/urcu-bp.h line 140
static inline void _rcu_read_lock_update$link3(unsigned long int tmp$link3);
// _rcu_read_ongoing_bp
// file urcu/static/urcu-bp.h line 195
static inline signed int _rcu_read_ongoing_bp(void);
// _rcu_read_ongoing_mb
// file urcu/static/urcu.h line 267
static inline signed int _rcu_read_ongoing_mb(void);
// _rcu_read_ongoing_memb
// file urcu/static/urcu.h line 267
static inline signed int _rcu_read_ongoing_memb(void);
// _rcu_read_ongoing_qsbr
// file urcu/static/urcu-qsbr.h line 158
static inline signed int _rcu_read_ongoing_qsbr(void);
// _rcu_read_ongoing_sig
// file urcu/static/urcu.h line 267
static inline signed int _rcu_read_ongoing_sig(void);
// _rcu_read_unlock_bp
// file urcu/static/urcu-bp.h line 176
static inline void _rcu_read_unlock_bp(void);
// _rcu_read_unlock_mb
// file urcu/static/urcu.h line 249
static inline void _rcu_read_unlock_mb(void);
// _rcu_read_unlock_memb
// file urcu/static/urcu.h line 249
static inline void _rcu_read_unlock_memb(void);
// _rcu_read_unlock_qsbr
// file urcu/static/urcu-qsbr.h line 146
static inline void _rcu_read_unlock_qsbr(void);
// _rcu_read_unlock_sig
// file urcu/static/urcu.h line 249
static inline void _rcu_read_unlock_sig(void);
// _rcu_read_unlock_update_and_wakeup
// file urcu/static/urcu.h line 233
static inline void _rcu_read_unlock_update_and_wakeup(unsigned long int tmp);
// _rcu_read_unlock_update_and_wakeup$link1
// file urcu/static/urcu.h line 233
static inline void _rcu_read_unlock_update_and_wakeup$link1(unsigned long int tmp$link1);
// _rcu_read_unlock_update_and_wakeup$link2
// file urcu/static/urcu.h line 233
static inline void _rcu_read_unlock_update_and_wakeup$link2(unsigned long int tmp$link2);
// _rcu_thread_offline
// file urcu/static/urcu-qsbr.h line 211
static inline void _rcu_thread_offline(void);
// _rcu_thread_online
// file urcu/static/urcu-qsbr.h line 229
static inline void _rcu_thread_online(void);
// _tap_init
// file tap.c line 172
static void _tap_init(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_thread
// file urcu-bp.c line 457
static void add_thread(void);
// alloc_cpu_call_rcu_data
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data(void);
// alloc_cpu_call_rcu_data$link1
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data$link1(void);
// alloc_cpu_call_rcu_data$link2
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data$link2(void);
// alloc_cpu_call_rcu_data$link3
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data$link3(void);
// alloc_cpu_call_rcu_data$link4
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data$link4(void);
// arena_alloc
// file urcu-bp.c line 423
static struct rcu_reader_bp * arena_alloc(struct registry_arena *arena);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// call_rcu_after_fork_child_bp
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_bp(void);
// call_rcu_after_fork_child_mb
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_mb(void);
// call_rcu_after_fork_child_memb
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_memb(void);
// call_rcu_after_fork_child_qsbr
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_qsbr(void);
// call_rcu_after_fork_child_sig
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_sig(void);
// call_rcu_after_fork_parent_bp
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_bp(void);
// call_rcu_after_fork_parent_mb
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_mb(void);
// call_rcu_after_fork_parent_memb
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_memb(void);
// call_rcu_after_fork_parent_qsbr
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_qsbr(void);
// call_rcu_after_fork_parent_sig
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_sig(void);
// call_rcu_before_fork_bp
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_bp(void);
// call_rcu_before_fork_mb
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_mb(void);
// call_rcu_before_fork_memb
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_memb(void);
// call_rcu_before_fork_qsbr
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_qsbr(void);
// call_rcu_before_fork_sig
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_sig(void);
// call_rcu_bp
// file urcu-call-rcu-impl.h line 705
void call_rcu_bp(struct rcu_head *head, void (*func)(struct rcu_head *));
// call_rcu_bp::func$object
//
void func$object(struct rcu_head *);
// call_rcu_completion_wait
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait(struct call_rcu_completion *completion);
// call_rcu_completion_wait$link1
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait$link1(struct call_rcu_completion *completion$link1);
// call_rcu_completion_wait$link2
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait$link2(struct call_rcu_completion *completion$link2);
// call_rcu_completion_wait$link3
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait$link3(struct call_rcu_completion *completion$link3);
// call_rcu_completion_wait$link4
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait$link4(struct call_rcu_completion *completion$link4);
// call_rcu_completion_wake_up
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up(struct call_rcu_completion *completion);
// call_rcu_completion_wake_up$link1
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up$link1(struct call_rcu_completion *completion$link1);
// call_rcu_completion_wake_up$link2
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up$link2(struct call_rcu_completion *completion$link2);
// call_rcu_completion_wake_up$link3
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up$link3(struct call_rcu_completion *completion$link3);
// call_rcu_completion_wake_up$link4
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up$link4(struct call_rcu_completion *completion$link4);
// call_rcu_data_free_bp
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_bp(struct call_rcu_data *crdp);
// call_rcu_data_free_mb
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_mb(struct call_rcu_data *crdp);
// call_rcu_data_free_memb
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_memb(struct call_rcu_data *crdp);
// call_rcu_data_free_qsbr
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_qsbr(struct call_rcu_data *crdp);
// call_rcu_data_free_sig
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_sig(struct call_rcu_data *crdp);
// call_rcu_data_init
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init(struct call_rcu_data **crdpp, unsigned long int flags, signed int cpu_affinity);
// call_rcu_data_init$link1
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init$link1(struct call_rcu_data **crdpp$link1, unsigned long int flags$link1, signed int cpu_affinity$link1);
// call_rcu_data_init$link2
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init$link2(struct call_rcu_data **crdpp$link2, unsigned long int flags$link2, signed int cpu_affinity$link2);
// call_rcu_data_init$link3
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init$link3(struct call_rcu_data **crdpp$link3, unsigned long int flags$link3, signed int cpu_affinity$link3);
// call_rcu_data_init$link4
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init$link4(struct call_rcu_data **crdpp$link4, unsigned long int flags$link4, signed int cpu_affinity$link4);
// call_rcu_lock
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock(union anonymous$0 *pmp);
// call_rcu_lock$link1
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock$link1(union anonymous$0 *pmp$link1);
// call_rcu_lock$link2
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock$link2(union anonymous$0 *pmp$link2);
// call_rcu_lock$link3
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock$link3(union anonymous$0 *pmp$link3);
// call_rcu_lock$link4
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock$link4(union anonymous$0 *pmp$link4);
// call_rcu_mb
// file urcu-call-rcu-impl.h line 705
void call_rcu_mb(struct rcu_head *head, void (*func)(struct rcu_head *));
// call_rcu_mb::func$object
//
void func$object(struct rcu_head *);
// call_rcu_memb
// file urcu-call-rcu-impl.h line 705
void call_rcu_memb(struct rcu_head *head, void (*func)(struct rcu_head *));
// call_rcu_memb::func$object
//
void func$object(struct rcu_head *);
// call_rcu_qsbr
// file urcu-call-rcu-impl.h line 705
void call_rcu_qsbr(struct rcu_head *head, void (*func)(struct rcu_head *));
// call_rcu_qsbr::func$object
//
void func$object(struct rcu_head *);
// call_rcu_sig
// file urcu-call-rcu-impl.h line 705
void call_rcu_sig(struct rcu_head *head, void (*func)(struct rcu_head *));
// call_rcu_sig::func$object
//
void func$object(struct rcu_head *);
// call_rcu_thread
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread(void *arg);
// call_rcu_thread$link1
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread$link1(void *arg$link1);
// call_rcu_thread$link2
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread$link2(void *arg$link2);
// call_rcu_thread$link3
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread$link3(void *arg$link3);
// call_rcu_thread$link4
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread$link4(void *arg$link4);
// call_rcu_unlock
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock(union anonymous$0 *pmp);
// call_rcu_unlock$link1
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock$link1(union anonymous$0 *pmp$link1);
// call_rcu_unlock$link2
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock$link2(union anonymous$0 *pmp$link2);
// call_rcu_unlock$link3
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock$link3(union anonymous$0 *pmp$link3);
// call_rcu_unlock$link4
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock$link4(union anonymous$0 *pmp$link4);
// call_rcu_wait
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait(struct call_rcu_data *crdp);
// call_rcu_wait$link1
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait$link1(struct call_rcu_data *crdp$link1);
// call_rcu_wait$link2
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait$link2(struct call_rcu_data *crdp$link2);
// call_rcu_wait$link3
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait$link3(struct call_rcu_data *crdp$link3);
// call_rcu_wait$link4
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait$link4(struct call_rcu_data *crdp$link4);
// call_rcu_wake_up
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up(struct call_rcu_data *crdp);
// call_rcu_wake_up$link1
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up$link1(struct call_rcu_data *crdp$link1);
// call_rcu_wake_up$link2
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up$link2(struct call_rcu_data *crdp$link2);
// call_rcu_wake_up$link3
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up$link3(struct call_rcu_data *crdp$link3);
// call_rcu_wake_up$link4
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up$link4(struct call_rcu_data *crdp$link4);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cds_list_add
// file ./urcu/list.h line 51
static inline void cds_list_add(struct cds_list_head *newp, struct cds_list_head *head);
// cds_list_add$link1
// file ./urcu/list.h line 51
static inline void cds_list_add$link1(struct cds_list_head *newp$link1, struct cds_list_head *head$link1);
// cds_list_add$link2
// file ./urcu/list.h line 51
static inline void cds_list_add$link2(struct cds_list_head *newp$link2, struct cds_list_head *head$link2);
// cds_list_add$link3
// file ./urcu/list.h line 51
static inline void cds_list_add$link3(struct cds_list_head *newp$link3, struct cds_list_head *head$link3);
// cds_list_add$link4
// file ./urcu/list.h line 51
static inline void cds_list_add$link4(struct cds_list_head *newp$link4, struct cds_list_head *head$link4);
// cds_list_add_tail
// file ./urcu/list.h line 61
static inline void cds_list_add_tail(struct cds_list_head *newp, struct cds_list_head *head);
// cds_list_del
// file ./urcu/list.h line 79
static inline void cds_list_del(struct cds_list_head *elem);
// cds_list_del$link1
// file ./urcu/list.h line 79
static inline void cds_list_del$link1(struct cds_list_head *elem$link1);
// cds_list_del$link2
// file ./urcu/list.h line 79
static inline void cds_list_del$link2(struct cds_list_head *elem$link2);
// cds_list_del$link3
// file ./urcu/list.h line 79
static inline void cds_list_del$link3(struct cds_list_head *elem$link3);
// cds_list_del$link4
// file ./urcu/list.h line 79
static inline void cds_list_del$link4(struct cds_list_head *elem$link4);
// cds_list_empty
// file ./urcu/list.h line 184
static inline signed int cds_list_empty(struct cds_list_head *head);
// cds_list_empty$link1
// file ./urcu/list.h line 184
static inline signed int cds_list_empty$link1(struct cds_list_head *head$link1);
// cds_list_empty$link2
// file ./urcu/list.h line 184
static inline signed int cds_list_empty$link2(struct cds_list_head *head$link2);
// cds_list_empty$link3
// file ./urcu/list.h line 184
static inline signed int cds_list_empty$link3(struct cds_list_head *head$link3);
// cds_list_empty$link4
// file ./urcu/list.h line 184
static inline signed int cds_list_empty$link4(struct cds_list_head *head$link4);
// cds_list_move
// file ./urcu/list.h line 94
static inline void cds_list_move(struct cds_list_head *elem, struct cds_list_head *head);
// cds_list_move$link1
// file ./urcu/list.h line 94
static inline void cds_list_move$link1(struct cds_list_head *elem$link1, struct cds_list_head *head$link1);
// cds_list_move$link2
// file ./urcu/list.h line 94
static inline void cds_list_move$link2(struct cds_list_head *elem$link2, struct cds_list_head *head$link2);
// cds_list_move$link3
// file ./urcu/list.h line 94
static inline void cds_list_move$link3(struct cds_list_head *elem$link3, struct cds_list_head *head$link3);
// cds_list_move$link4
// file ./urcu/list.h line 94
static inline void cds_list_move$link4(struct cds_list_head *elem$link4, struct cds_list_head *head$link4);
// cds_list_splice
// file ./urcu/list.h line 112
static inline void cds_list_splice(struct cds_list_head *add, struct cds_list_head *head);
// cds_list_splice$link1
// file ./urcu/list.h line 112
static inline void cds_list_splice$link1(struct cds_list_head *add$link1, struct cds_list_head *head$link1);
// cds_list_splice$link2
// file ./urcu/list.h line 112
static inline void cds_list_splice$link2(struct cds_list_head *add$link2, struct cds_list_head *head$link2);
// cds_list_splice$link3
// file ./urcu/list.h line 112
static inline void cds_list_splice$link3(struct cds_list_head *add$link3, struct cds_list_head *head$link3);
// cds_list_splice$link4
// file ./urcu/list.h line 112
static inline void cds_list_splice$link4(struct cds_list_head *add$link4, struct cds_list_head *head$link4);
// cds_wfcq_dequeue_blocking
// file wfcqueue.c line 75
extern struct cds_wfcq_node * cds_wfcq_dequeue_blocking(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// cds_wfcq_dequeue_lock
// file wfcqueue.c line 63
extern void cds_wfcq_dequeue_lock(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// cds_wfcq_dequeue_unlock
// file wfcqueue.c line 69
extern void cds_wfcq_dequeue_unlock(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// cds_wfcq_dequeue_with_state_blocking
// file wfcqueue.c line 82
extern struct cds_wfcq_node * cds_wfcq_dequeue_with_state_blocking(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail, signed int *state);
// cds_wfcq_empty
// file wfcqueue.c line 49
extern _Bool cds_wfcq_empty(union anonymous$1 head, struct cds_wfcq_tail *tail);
// cds_wfcq_enqueue
// file wfcqueue.c line 56
extern _Bool cds_wfcq_enqueue(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node);
// cds_wfcq_init
// file wfcqueue.c line 37
extern void cds_wfcq_init(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail);
// cds_wfcq_node_init
// file wfcqueue.c line 32
extern void cds_wfcq_node_init(struct cds_wfcq_node *node);
// cds_wfcq_splice_blocking
// file wfcqueue.c line 90
extern enum cds_wfcq_ret cds_wfcq_splice_blocking(struct cds_wfcq_head *dest_q_head, struct cds_wfcq_tail *dest_q_tail, struct cds_wfcq_head *src_q_head, struct cds_wfcq_tail *src_q_tail);
// cds_wfq_dequeue_blocking
// file wfqueue.c line 54
extern struct cds_wfq_node * cds_wfq_dequeue_blocking(struct cds_wfq_queue *q);
// cds_wfq_enqueue
// file wfqueue.c line 44
extern void cds_wfq_enqueue(struct cds_wfq_queue *q, struct cds_wfq_node *node);
// cds_wfq_init
// file wfqueue.c line 39
extern void cds_wfq_init(struct cds_wfq_queue *q);
// cds_wfq_node_init
// file wfqueue.c line 34
extern void cds_wfq_node_init(struct cds_wfq_node *node);
// cds_wfs_empty
// file wfstack.c line 46
extern _Bool cds_wfs_empty(union anonymous u_stack);
// cds_wfs_first
// file wfstack.c line 72
extern struct cds_wfs_node * cds_wfs_first(struct cds_wfs_head *head);
// cds_wfs_init
// file wfstack.c line 36
extern void cds_wfs_init(struct cds_wfs_stack *s);
// cds_wfs_next_blocking
// file wfstack.c line 77
extern struct cds_wfs_node * cds_wfs_next_blocking(struct cds_wfs_node *node);
// cds_wfs_next_nonblocking
// file wfstack.c line 82
extern struct cds_wfs_node * cds_wfs_next_nonblocking(struct cds_wfs_node *node);
// cds_wfs_node_init
// file wfstack.c line 31
extern void cds_wfs_node_init(struct cds_wfs_node *node);
// cds_wfs_pop_all_blocking
// file wfstack.c line 67
extern struct cds_wfs_head * cds_wfs_pop_all_blocking(struct cds_wfs_stack *s);
// cds_wfs_pop_blocking
// file wfstack.c line 56
extern struct cds_wfs_node * cds_wfs_pop_blocking(struct cds_wfs_stack *s);
// cds_wfs_pop_lock
// file wfstack.c line 87
extern void cds_wfs_pop_lock(struct cds_wfs_stack *s);
// cds_wfs_pop_unlock
// file wfstack.c line 92
extern void cds_wfs_pop_unlock(struct cds_wfs_stack *s);
// cds_wfs_pop_with_state_blocking
// file wfstack.c line 62
extern struct cds_wfs_node * cds_wfs_pop_with_state_blocking(struct cds_wfs_stack *s, signed int *state);
// cds_wfs_push
// file wfstack.c line 51
extern signed int cds_wfs_push(union anonymous u_stack, struct cds_wfs_node *node);
// cleanup_thread
// file urcu-bp.c line 482
static void cleanup_thread(struct registry_chunk *chunk, struct rcu_reader_bp *rcu_reader_reg);
// compat_futex_async
// file ./urcu/futex.h line 52
extern signed int compat_futex_async(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3);
// compat_futex_noasync
// file ./urcu/futex.h line 50
extern signed int compat_futex_noasync(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3);
// create_all_cpu_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_bp(unsigned long int flags);
// create_all_cpu_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_mb(unsigned long int flags);
// create_all_cpu_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_memb(unsigned long int flags);
// create_all_cpu_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_qsbr(unsigned long int flags);
// create_all_cpu_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_sig(unsigned long int flags);
// create_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_bp(unsigned long int flags, signed int cpu_affinity);
// create_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_mb(unsigned long int flags, signed int cpu_affinity);
// create_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_memb(unsigned long int flags, signed int cpu_affinity);
// create_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_qsbr(unsigned long int flags, signed int cpu_affinity);
// create_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_sig(unsigned long int flags, signed int cpu_affinity);
// defer_rcu_bp
// file urcu-defer-impl.h line 395
extern void defer_rcu_bp(void (*fct)(void *), void *p);
// defer_rcu_bp::fct$object
//
void fct$object(void *);
// defer_rcu_mb
// file urcu-defer-impl.h line 395
extern void defer_rcu_mb(void (*fct)(void *), void *p);
// defer_rcu_mb::fct$object
//
void fct$object(void *);
// defer_rcu_memb
// file urcu-defer-impl.h line 395
extern void defer_rcu_memb(void (*fct)(void *), void *p);
// defer_rcu_memb::fct$object
//
void fct$object(void *);
// defer_rcu_qsbr
// file urcu-defer-impl.h line 395
extern void defer_rcu_qsbr(void (*fct)(void *), void *p);
// defer_rcu_qsbr::fct$object
//
void fct$object(void *);
// defer_rcu_sig
// file urcu-defer-impl.h line 395
extern void defer_rcu_sig(void (*fct)(void *), void *p);
// defer_rcu_sig::fct$object
//
void fct$object(void *);
// diag
// file tap.c line 273
unsigned int diag(char *fmt, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_status
// file ../../tests/utils/tap.h line 89
signed int exit_status(void);
// expand_arena
// file urcu-bp.c line 365
static void expand_arena(struct registry_arena *arena);
// find_chunk
// file urcu-bp.c line 493
static struct registry_chunk * find_chunk(struct rcu_reader_bp *rcu_reader_reg);
// flockfile
// file /usr/include/stdio.h line 912
extern void flockfile(struct _IO_FILE *);
// force_mb_all_readers
// file urcu.c line 179
static void force_mb_all_readers(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_all_cpu_call_rcu_data
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data(void);
// free_all_cpu_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data_bp(void);
// free_all_cpu_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data_mb(void);
// free_all_cpu_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data_memb(void);
// free_all_cpu_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data_sig(void);
// free_completion
// file urcu-call-rcu-impl.h line 813
static void free_completion(struct urcu_ref *ref);
// free_completion$link1
// file urcu-call-rcu-impl.h line 813
static void free_completion$link1(struct urcu_ref *ref$link1);
// free_completion$link2
// file urcu-call-rcu-impl.h line 813
static void free_completion$link2(struct urcu_ref *ref$link2);
// free_completion$link3
// file urcu-call-rcu-impl.h line 813
static void free_completion$link3(struct urcu_ref *ref$link3);
// free_completion$link4
// file urcu-call-rcu-impl.h line 813
static void free_completion$link4(struct urcu_ref *ref$link4);
// funlockfile
// file /usr/include/stdio.h line 919
extern void funlockfile(struct _IO_FILE *);
// futex
// file ./urcu/futex.h line 62
static inline signed int futex(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3);
// futex$link1
// file ./urcu/futex.h line 62
static inline signed int futex$link1(signed int *uaddr$link1, signed int op$link1, signed int val$link1, struct timespec *timeout$link1, signed int *uaddr2$link1, signed int val3$link1);
// futex$link2
// file ./urcu/futex.h line 62
static inline signed int futex$link2(signed int *uaddr$link2, signed int op$link2, signed int val$link2, struct timespec *timeout$link2, signed int *uaddr2$link2, signed int val3$link2);
// futex$link3
// file ./urcu/futex.h line 62
static inline signed int futex$link3(signed int *uaddr$link3, signed int op$link3, signed int val$link3, struct timespec *timeout$link3, signed int *uaddr2$link3, signed int val3$link3);
// futex$link4
// file urcu/futex.h line 62
static inline signed int futex$link4(signed int *uaddr$link4, signed int op$link4, signed int val$link4, struct timespec *timeout$link4, signed int *uaddr2$link4, signed int val3$link4);
// futex_async
// file ./urcu/futex.h line 83
static inline signed int futex_async(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3);
// futex_async$link1
// file ./urcu/futex.h line 83
static inline signed int futex_async$link1(signed int *uaddr$link1, signed int op$link1, signed int val$link1, struct timespec *timeout$link1, signed int *uaddr2$link1, signed int val3$link1);
// futex_async$link2
// file ./urcu/futex.h line 83
static inline signed int futex_async$link2(signed int *uaddr$link2, signed int op$link2, signed int val$link2, struct timespec *timeout$link2, signed int *uaddr2$link2, signed int val3$link2);
// futex_async$link3
// file ./urcu/futex.h line 83
static inline signed int futex_async$link3(signed int *uaddr$link3, signed int op$link3, signed int val$link3, struct timespec *timeout$link3, signed int *uaddr2$link3, signed int val3$link3);
// futex_async$link4
// file urcu/futex.h line 83
static inline signed int futex_async$link4(signed int *uaddr$link4, signed int op$link4, signed int val$link4, struct timespec *timeout$link4, signed int *uaddr2$link4, signed int val3$link4);
// futex_noasync
// file ./urcu/futex.h line 69
static inline signed int futex_noasync(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3);
// futex_noasync$link1
// file ./urcu/futex.h line 69
static inline signed int futex_noasync$link1(signed int *uaddr$link1, signed int op$link1, signed int val$link1, struct timespec *timeout$link1, signed int *uaddr2$link1, signed int val3$link1);
// futex_noasync$link2
// file ./urcu/futex.h line 69
static inline signed int futex_noasync$link2(signed int *uaddr$link2, signed int op$link2, signed int val$link2, struct timespec *timeout$link2, signed int *uaddr2$link2, signed int val3$link2);
// futex_noasync$link3
// file ./urcu/futex.h line 69
static inline signed int futex_noasync$link3(signed int *uaddr$link3, signed int op$link3, signed int val$link3, struct timespec *timeout$link3, signed int *uaddr2$link3, signed int val3$link3);
// futex_noasync$link4
// file urcu/futex.h line 69
static inline signed int futex_noasync$link4(signed int *uaddr$link4, signed int op$link4, signed int val$link4, struct timespec *timeout$link4, signed int *uaddr2$link4, signed int val3$link4);
// get_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_bp(void);
// get_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_mb(void);
// get_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_memb(void);
// get_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_qsbr(void);
// get_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_sig(void);
// get_call_rcu_thread_bp
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_bp(struct call_rcu_data *crdp);
// get_call_rcu_thread_mb
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_mb(struct call_rcu_data *crdp);
// get_call_rcu_thread_memb
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_memb(struct call_rcu_data *crdp);
// get_call_rcu_thread_qsbr
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_qsbr(struct call_rcu_data *crdp);
// get_call_rcu_thread_sig
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_sig(struct call_rcu_data *crdp);
// get_cpu_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_bp(signed int cpu);
// get_cpu_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_mb(signed int cpu);
// get_cpu_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_memb(signed int cpu);
// get_cpu_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_qsbr(signed int cpu);
// get_cpu_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_sig(signed int cpu);
// get_default_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_bp(void);
// get_default_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_mb(void);
// get_default_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_memb(void);
// get_default_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_qsbr(void);
// get_default_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_sig(void);
// get_thread_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_bp(void);
// get_thread_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_mb(void);
// get_thread_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_memb(void);
// get_thread_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_qsbr(void);
// get_thread_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_sig(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// maxcpus_reset
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset(void);
// maxcpus_reset$link1
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset$link1(void);
// maxcpus_reset$link2
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset$link2(void);
// maxcpus_reset$link3
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset$link3(void);
// maxcpus_reset$link4
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset$link4(void);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mremap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 133
extern void * mremap(void *, unsigned long int, unsigned long int, signed int, ...);
// mremap_wrapper
// file urcu-bp.c line 59
static void * mremap_wrapper(void *old_address, unsigned long int old_size, unsigned long int new_size, signed int flags);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// mutex_lock
// file urcu.c line 130
static void mutex_lock(union anonymous$0 *mutex);
// mutex_lock$link1
// file urcu.c line 130
static void mutex_lock$link1(union anonymous$0 *mutex$link1);
// mutex_lock$link2
// file urcu.c line 130
static void mutex_lock$link2(union anonymous$0 *mutex$link2);
// mutex_lock$link3
// file urcu-qsbr.c line 91
static void mutex_lock$link3(union anonymous$0 *mutex$link3);
// mutex_lock$link4
// file urcu-bp.c line 166
static void mutex_lock$link4(union anonymous$0 *mutex$link4);
// mutex_lock_defer
// file urcu-defer-impl.h line 133
static void mutex_lock_defer(union anonymous$0 *mutex);
// mutex_lock_defer$link1
// file urcu-defer-impl.h line 133
static void mutex_lock_defer$link1(union anonymous$0 *mutex$link1);
// mutex_lock_defer$link2
// file urcu-defer-impl.h line 133
static void mutex_lock_defer$link2(union anonymous$0 *mutex$link2);
// mutex_lock_defer$link3
// file urcu-defer-impl.h line 133
static void mutex_lock_defer$link3(union anonymous$0 *mutex$link3);
// mutex_lock_defer$link4
// file urcu-defer-impl.h line 133
static void mutex_lock_defer$link4(union anonymous$0 *mutex$link4);
// mutex_unlock
// file urcu.c line 152
static void mutex_unlock(union anonymous$0 *mutex);
// mutex_unlock$link1
// file urcu.c line 152
static void mutex_unlock$link1(union anonymous$0 *mutex$link1);
// mutex_unlock$link2
// file urcu.c line 152
static void mutex_unlock$link2(union anonymous$0 *mutex$link2);
// mutex_unlock$link3
// file urcu-qsbr.c line 108
static void mutex_unlock$link3(union anonymous$0 *mutex$link3);
// mutex_unlock$link4
// file urcu-bp.c line 183
static void mutex_unlock$link4(union anonymous$0 *mutex$link4);
// plan_no_plan
// file tap.c line 191
signed int plan_no_plan(void);
// plan_skip_all
// file tap.c line 217
signed int plan_skip_all(char *reason);
// plan_tests
// file ../../tests/utils/tap.h line 80
signed int plan_tests(unsigned int tests);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$5 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$5 *, union anonymous$0 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_key_delete
// file /usr/include/pthread.h line 1118
extern signed int pthread_key_delete(unsigned int);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$0 *, const union anonymous$3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$0 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$16 *, struct anonymous$16 *);
// rcu_barrier_bp
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_bp(void);
// rcu_barrier_mb
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_mb(void);
// rcu_barrier_memb
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_memb(void);
// rcu_barrier_qsbr
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_qsbr(void);
// rcu_barrier_sig
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_sig(void);
// rcu_bp_after_fork_child
// file urcu-bp.c line 677
extern void rcu_bp_after_fork_child(void);
// rcu_bp_after_fork_parent
// file urcu-bp.c line 642
extern void rcu_bp_after_fork_parent(void);
// rcu_bp_before_fork
// file urcu-bp.c line 628
extern void rcu_bp_before_fork(void);
// rcu_bp_exit
// file urcu-bp.c line 603
static void rcu_bp_exit(void);
// rcu_bp_init
// file urcu-bp.c line 583
static void rcu_bp_init(void);
// rcu_bp_register
// file urcu-bp.c line 516
extern void rcu_bp_register(void);
// rcu_bp_unregister
// file urcu-bp.c line 551
static void rcu_bp_unregister(struct rcu_reader_bp *rcu_reader_reg);
// rcu_cmpxchg_pointer_sym
// file urcu-pointer.c line 53
extern void * rcu_cmpxchg_pointer_sym(void **p, void *old, void *_new);
// rcu_cmpxchg_pointer_sym_bp
// file urcu-bp.c line 708
extern void * rcu_cmpxchg_pointer_sym_bp(void **p, void *old, void *_new);
// rcu_defer_barrier_bp
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_bp(void);
// rcu_defer_barrier_mb
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_mb(void);
// rcu_defer_barrier_memb
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_memb(void);
// rcu_defer_barrier_qsbr
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_qsbr(void);
// rcu_defer_barrier_queue
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue(struct defer_queue *queue, unsigned long int head);
// rcu_defer_barrier_queue$link1
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue$link1(struct defer_queue *queue$link1, unsigned long int head$link1);
// rcu_defer_barrier_queue$link2
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue$link2(struct defer_queue *queue$link2, unsigned long int head$link2);
// rcu_defer_barrier_queue$link3
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue$link3(struct defer_queue *queue$link3, unsigned long int head$link3);
// rcu_defer_barrier_queue$link4
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue$link4(struct defer_queue *queue$link4, unsigned long int head$link4);
// rcu_defer_barrier_queue::1::fct$link1$object
//
void fct$link1$object(void *);
// rcu_defer_barrier_queue::1::fct$link2$object
//
void fct$link2$object(void *);
// rcu_defer_barrier_queue::1::fct$link3$object
//
void fct$link3$object(void *);
// rcu_defer_barrier_queue::1::fct$link4$object
//
void fct$link4$object(void *);
// rcu_defer_barrier_queue::1::fct$object
//
void fct$object(void *);
// rcu_defer_barrier_sig
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_sig(void);
// rcu_defer_barrier_thread_bp
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_bp(void);
// rcu_defer_barrier_thread_mb
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_mb(void);
// rcu_defer_barrier_thread_memb
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_memb(void);
// rcu_defer_barrier_thread_qsbr
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_qsbr(void);
// rcu_defer_barrier_thread_sig
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_sig(void);
// rcu_defer_exit_bp
// file urcu-defer-impl.h line 466
void rcu_defer_exit_bp(void);
// rcu_defer_exit_mb
// file urcu-defer-impl.h line 466
void rcu_defer_exit_mb(void);
// rcu_defer_exit_memb
// file urcu-defer-impl.h line 466
void rcu_defer_exit_memb(void);
// rcu_defer_exit_qsbr
// file urcu-defer-impl.h line 466
void rcu_defer_exit_qsbr(void);
// rcu_defer_exit_sig
// file urcu-defer-impl.h line 466
void rcu_defer_exit_sig(void);
// rcu_defer_num_callbacks
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks(void);
// rcu_defer_num_callbacks$link1
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks$link1(void);
// rcu_defer_num_callbacks$link2
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks$link2(void);
// rcu_defer_num_callbacks$link3
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks$link3(void);
// rcu_defer_num_callbacks$link4
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks$link4(void);
// rcu_defer_register_thread_bp
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_bp(void);
// rcu_defer_register_thread_mb
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_mb(void);
// rcu_defer_register_thread_memb
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_memb(void);
// rcu_defer_register_thread_qsbr
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_qsbr(void);
// rcu_defer_register_thread_sig
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_sig(void);
// rcu_defer_unregister_thread_bp
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_bp(void);
// rcu_defer_unregister_thread_mb
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_mb(void);
// rcu_defer_unregister_thread_memb
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_memb(void);
// rcu_defer_unregister_thread_qsbr
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_qsbr(void);
// rcu_defer_unregister_thread_sig
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_sig(void);
// rcu_dereference_sym
// file urcu-pointer.c line 35
extern void * rcu_dereference_sym(void *p);
// rcu_dereference_sym_bp
// file urcu-bp.c line 690
extern void * rcu_dereference_sym_bp(void *p);
// rcu_exit_qsbr
// file urcu-qsbr.c line 492
void rcu_exit_qsbr(void);
// rcu_exit_sig
// file urcu.c line 588
void rcu_exit_sig(void);
// rcu_init_mb
// file urcu.c line 87
extern void rcu_init_mb(void);
// rcu_init_memb
// file urcu.c line 536
extern void rcu_init_memb(void);
// rcu_init_sig
// file urcu.c line 571
extern void rcu_init_sig(void);
// rcu_quiescent_state
// file urcu.h line 117
static inline void rcu_quiescent_state(void);
// rcu_quiescent_state$link1
// file urcu.h line 117
static inline void rcu_quiescent_state$link1(void);
// rcu_quiescent_state$link2
// file urcu.h line 117
static inline void rcu_quiescent_state$link2(void);
// rcu_quiescent_state$link3
// file urcu-bp.h line 171
static inline void rcu_quiescent_state$link3(void);
// rcu_quiescent_state_qsbr
// file urcu-qsbr.c line 450
extern void rcu_quiescent_state_qsbr(void);
// rcu_read_lock_bp
// file ../../urcu-bp.h line 91
extern void rcu_read_lock_bp(void);
// rcu_read_lock_mb
// file ../../urcu.h line 95
extern void rcu_read_lock_mb(void);
// rcu_read_lock_memb
// file ../../urcu.h line 95
extern void rcu_read_lock_memb(void);
// rcu_read_lock_qsbr
// file ../../urcu-qsbr.h line 100
static inline void rcu_read_lock_qsbr(void);
// rcu_read_lock_qsbr$link1
// file urcu-qsbr.c line 435
extern void rcu_read_lock_qsbr$link1(void);
// rcu_read_lock_sig
// file ../../urcu.h line 95
extern void rcu_read_lock_sig(void);
// rcu_read_ongoing_bp
// file urcu-bp.c line 351
extern signed int rcu_read_ongoing_bp(void);
// rcu_read_ongoing_mb
// file urcu.c line 507
extern signed int rcu_read_ongoing_mb(void);
// rcu_read_ongoing_memb
// file urcu.c line 507
extern signed int rcu_read_ongoing_memb(void);
// rcu_read_ongoing_qsbr
// file urcu-qsbr.c line 445
extern signed int rcu_read_ongoing_qsbr(void);
// rcu_read_ongoing_sig
// file urcu.c line 507
extern signed int rcu_read_ongoing_sig(void);
// rcu_read_unlock_bp
// file ../../urcu-bp.h line 92
extern void rcu_read_unlock_bp(void);
// rcu_read_unlock_mb
// file ../../urcu.h line 96
extern void rcu_read_unlock_mb(void);
// rcu_read_unlock_memb
// file ../../urcu.h line 96
extern void rcu_read_unlock_memb(void);
// rcu_read_unlock_qsbr
// file ../../urcu-qsbr.h line 104
static inline void rcu_read_unlock_qsbr(void);
// rcu_read_unlock_qsbr$link1
// file urcu-qsbr.c line 440
extern void rcu_read_unlock_qsbr$link1(void);
// rcu_read_unlock_sig
// file ../../urcu.h line 96
extern void rcu_read_unlock_sig(void);
// rcu_reader_state
// file urcu/static/urcu.h line 172
static inline enum rcu_state rcu_reader_state(unsigned long int *ctr);
// rcu_reader_state$link1
// file urcu/static/urcu.h line 172
static inline enum rcu_state rcu_reader_state$link1(unsigned long int *ctr$link1);
// rcu_reader_state$link2
// file urcu/static/urcu.h line 172
static inline enum rcu_state rcu_reader_state$link2(unsigned long int *ctr$link2);
// rcu_reader_state$link3
// file urcu/static/urcu-qsbr.h line 115
static inline enum rcu_state rcu_reader_state$link3(unsigned long int *ctr$link3);
// rcu_reader_state$link4
// file urcu/static/urcu-bp.h line 115
static inline enum rcu_state rcu_reader_state$link4(unsigned long int *ctr$link4);
// rcu_register_thread_bp
// file ../../urcu-bp.h line 156
static inline void rcu_register_thread_bp(void);
// rcu_register_thread_bp$link1
// file urcu-bp.h line 156
static inline void rcu_register_thread_bp$link1(void);
// rcu_register_thread_mb
// file ../../urcu.h line 106
extern void rcu_register_thread_mb(void);
// rcu_register_thread_memb
// file ../../urcu.h line 106
extern void rcu_register_thread_memb(void);
// rcu_register_thread_qsbr
// file ../../urcu-qsbr.h line 127
extern void rcu_register_thread_qsbr(void);
// rcu_register_thread_sig
// file ../../urcu.h line 106
extern void rcu_register_thread_sig(void);
// rcu_set_pointer_sym
// file urcu-pointer.c line 40
extern void * rcu_set_pointer_sym(void **p, void *v);
// rcu_set_pointer_sym_bp
// file urcu-bp.c line 695
extern void * rcu_set_pointer_sym_bp(void **p, void *v);
// rcu_thread_offline
// file urcu.h line 121
static inline void rcu_thread_offline(void);
// rcu_thread_offline$link1
// file urcu.h line 121
static inline void rcu_thread_offline$link1(void);
// rcu_thread_offline$link2
// file urcu.h line 121
static inline void rcu_thread_offline$link2(void);
// rcu_thread_offline$link3
// file urcu-bp.h line 175
static inline void rcu_thread_offline$link3(void);
// rcu_thread_offline_qsbr
// file urcu-qsbr.c line 455
extern void rcu_thread_offline_qsbr(void);
// rcu_thread_online
// file urcu.h line 125
static inline void rcu_thread_online(void);
// rcu_thread_online$link1
// file urcu.h line 125
static inline void rcu_thread_online$link1(void);
// rcu_thread_online$link2
// file urcu.h line 125
static inline void rcu_thread_online$link2(void);
// rcu_thread_online$link3
// file urcu-bp.h line 179
static inline void rcu_thread_online$link3(void);
// rcu_thread_online_qsbr
// file urcu-qsbr.c line 460
extern void rcu_thread_online_qsbr(void);
// rcu_unregister_thread_bp
// file ../../urcu-bp.h line 160
static inline void rcu_unregister_thread_bp(void);
// rcu_unregister_thread_bp$link1
// file urcu-bp.h line 160
static inline void rcu_unregister_thread_bp$link1(void);
// rcu_unregister_thread_mb
// file ../../urcu.h line 107
extern void rcu_unregister_thread_mb(void);
// rcu_unregister_thread_memb
// file ../../urcu.h line 107
extern void rcu_unregister_thread_memb(void);
// rcu_unregister_thread_qsbr
// file ../../urcu-qsbr.h line 128
extern void rcu_unregister_thread_qsbr(void);
// rcu_unregister_thread_sig
// file ../../urcu.h line 107
extern void rcu_unregister_thread_sig(void);
// rcu_xchg_pointer_sym
// file urcu-pointer.c line 47
extern void * rcu_xchg_pointer_sym(void **p, void *v);
// rcu_xchg_pointer_sym_bp
// file urcu-bp.c line 702
extern void * rcu_xchg_pointer_sym_bp(void **p, void *v);
// rdiag
// file tap.c line 296
unsigned int rdiag(char *fmt, ...);
// rdiag_end
// file tap.c line 308
unsigned int rdiag_end(void);
// rdiag_start
// file tap.c line 289
unsigned int rdiag_start(void);
// remove_thread
// file urcu-bp.c line 509
static void remove_thread(struct rcu_reader_bp *rcu_reader_reg);
// sched_getcpu
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 88
extern signed int sched_getcpu(void);
// sched_setaffinity
// file /usr/include/sched.h line 118
extern signed int sched_setaffinity(signed int, unsigned long int, const struct anonymous$2 *);
// set_cpu_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_bp(signed int cpu, struct call_rcu_data *crdp);
// set_cpu_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_mb(signed int cpu, struct call_rcu_data *crdp);
// set_cpu_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_memb(signed int cpu, struct call_rcu_data *crdp);
// set_cpu_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_qsbr(signed int cpu, struct call_rcu_data *crdp);
// set_cpu_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_sig(signed int cpu, struct call_rcu_data *crdp);
// set_thread_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_bp(struct call_rcu_data *crdp);
// set_thread_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_mb(struct call_rcu_data *crdp);
// set_thread_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_memb(struct call_rcu_data *crdp);
// set_thread_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_qsbr(struct call_rcu_data *crdp);
// set_thread_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_sig(struct call_rcu_data *crdp);
// set_thread_cpu_affinity
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity(struct call_rcu_data *crdp);
// set_thread_cpu_affinity$link1
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity$link1(struct call_rcu_data *crdp$link1);
// set_thread_cpu_affinity$link2
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity$link2(struct call_rcu_data *crdp$link2);
// set_thread_cpu_affinity$link3
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity$link3(struct call_rcu_data *crdp$link3);
// set_thread_cpu_affinity$link4
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity$link4(struct call_rcu_data *crdp$link4);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$16 *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$16 *);
// sigrcu_handler
// file urcu.c line 551
static void sigrcu_handler(signed int signo, struct anonymous$14 *siginfo, void *context);
// skip
// file tap.c line 323
signed int skip(unsigned int n, char *fmt, ...);
// smp_mb_master
// file urcu.c line 162
static void smp_mb_master(void);
// smp_mb_master$link1
// file urcu.c line 172
static void smp_mb_master$link1(void);
// smp_mb_master$link2
// file urcu.c line 221
static void smp_mb_master$link2(void);
// smp_mb_master$link3
// file urcu-bp.c line 192
static void smp_mb_master$link3(void);
// smp_mb_slave
// file urcu/static/urcu.h line 95
static inline void smp_mb_slave(void);
// smp_mb_slave$link1
// file urcu/static/urcu.h line 105
static inline void smp_mb_slave$link1(void);
// smp_mb_slave$link2
// file urcu/static/urcu.h line 112
static inline void smp_mb_slave$link2(void);
// start_defer_thread
// file urcu-defer-impl.h line 400
static void start_defer_thread(void);
// start_defer_thread$link1
// file urcu-defer-impl.h line 400
static void start_defer_thread$link1(void);
// start_defer_thread$link2
// file urcu-defer-impl.h line 400
static void start_defer_thread$link2(void);
// start_defer_thread$link3
// file urcu-defer-impl.h line 400
static void start_defer_thread$link3(void);
// start_defer_thread$link4
// file urcu-defer-impl.h line 400
static void start_defer_thread$link4(void);
// stop_defer_thread
// file urcu-defer-impl.h line 408
static void stop_defer_thread(void);
// stop_defer_thread$link1
// file urcu-defer-impl.h line 408
static void stop_defer_thread$link1(void);
// stop_defer_thread$link2
// file urcu-defer-impl.h line 408
static void stop_defer_thread$link2(void);
// stop_defer_thread$link3
// file urcu-defer-impl.h line 408
static void stop_defer_thread$link3(void);
// stop_defer_thread$link4
// file urcu-defer-impl.h line 408
static void stop_defer_thread$link4(void);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// synchronize_rcu_bp
// file ../../urcu-bp.h line 141
extern void synchronize_rcu_bp(void);
// synchronize_rcu_mb
// file ../../urcu.h line 101
extern void synchronize_rcu_mb(void);
// synchronize_rcu_memb
// file ../../urcu.h line 101
extern void synchronize_rcu_memb(void);
// synchronize_rcu_qsbr
// file ../../urcu-qsbr.h line 122
extern void synchronize_rcu_qsbr(void);
// synchronize_rcu_sig
// file ../../urcu.h line 101
extern void synchronize_rcu_sig(void);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// tap_disable
// file tap.c line 469
void tap_disable(void);
// test_mf_bp
// file test_urcu_multiflavor.h line 28
extern signed int test_mf_bp(void);
// test_mf_mb
// file test_urcu_multiflavor.h line 25
extern signed int test_mf_mb(void);
// test_mf_memb
// file test_urcu_multiflavor.h line 24
extern signed int test_mf_memb(void);
// test_mf_qsbr
// file test_urcu_multiflavor.h line 27
extern signed int test_mf_qsbr(void);
// test_mf_signal
// file test_urcu_multiflavor.h line 26
extern signed int test_mf_signal(void);
// thr_defer
// file urcu-defer-impl.h line 374
static void * thr_defer(void *args);
// thr_defer$link1
// file urcu-defer-impl.h line 374
static void * thr_defer$link1(void *args$link1);
// thr_defer$link2
// file urcu-defer-impl.h line 374
static void * thr_defer$link2(void *args$link2);
// thr_defer$link3
// file urcu-defer-impl.h line 374
static void * thr_defer$link3(void *args$link3);
// thr_defer$link4
// file urcu-defer-impl.h line 374
static void * thr_defer$link4(void *args$link4);
// todo_end
// file tap.c line 369
void todo_end(void);
// todo_start
// file tap.c line 351
void todo_start(char *fmt, ...);
// urcu_adaptative_busy_wait
// file urcu-wait.h line 140
static inline void urcu_adaptative_busy_wait(struct urcu_wait_node *wait);
// urcu_adaptative_busy_wait$link1
// file urcu-wait.h line 140
static inline void urcu_adaptative_busy_wait$link1(struct urcu_wait_node *wait$link1);
// urcu_adaptative_busy_wait$link2
// file urcu-wait.h line 140
static inline void urcu_adaptative_busy_wait$link2(struct urcu_wait_node *wait$link2);
// urcu_adaptative_busy_wait$link3
// file urcu-wait.h line 140
static inline void urcu_adaptative_busy_wait$link3(struct urcu_wait_node *wait$link3);
// urcu_adaptative_wake_up
// file urcu-wait.h line 121
static inline void urcu_adaptative_wake_up(struct urcu_wait_node *wait);
// urcu_adaptative_wake_up$link1
// file urcu-wait.h line 121
static inline void urcu_adaptative_wake_up$link1(struct urcu_wait_node *wait$link1);
// urcu_adaptative_wake_up$link2
// file urcu-wait.h line 121
static inline void urcu_adaptative_wake_up$link2(struct urcu_wait_node *wait$link2);
// urcu_adaptative_wake_up$link3
// file urcu-wait.h line 121
static inline void urcu_adaptative_wake_up$link3(struct urcu_wait_node *wait$link3);
// urcu_bp_prune_registry
// file urcu-bp.c line 659
static void urcu_bp_prune_registry(void);
// urcu_bp_smp_mb_slave
// file urcu/static/urcu-bp.h line 107
static inline void urcu_bp_smp_mb_slave(void);
// urcu_bp_thread_exit_notifier
// file urcu-bp.c line 577
static void urcu_bp_thread_exit_notifier(void *rcu_key);
// urcu_move_waiters
// file urcu-wait.h line 93
static inline void urcu_move_waiters(struct urcu_waiters *waiters, struct urcu_wait_queue *queue);
// urcu_move_waiters$link1
// file urcu-wait.h line 93
static inline void urcu_move_waiters$link1(struct urcu_waiters *waiters$link1, struct urcu_wait_queue *queue$link1);
// urcu_move_waiters$link2
// file urcu-wait.h line 93
static inline void urcu_move_waiters$link2(struct urcu_waiters *waiters$link2, struct urcu_wait_queue *queue$link2);
// urcu_move_waiters$link3
// file urcu-wait.h line 93
static inline void urcu_move_waiters$link3(struct urcu_waiters *waiters$link3, struct urcu_wait_queue *queue$link3);
// urcu_ref_put
// file urcu/ref.h line 40
static inline void urcu_ref_put(struct urcu_ref *ref, void (*release)(struct urcu_ref *));
// urcu_ref_put$link1
// file urcu/ref.h line 40
static inline void urcu_ref_put$link1(struct urcu_ref *ref$link1, void (*release$link1)(struct urcu_ref *));
// urcu_ref_put$link2
// file urcu/ref.h line 40
static inline void urcu_ref_put$link2(struct urcu_ref *ref$link2, void (*release$link2)(struct urcu_ref *));
// urcu_ref_put$link3
// file urcu/ref.h line 40
static inline void urcu_ref_put$link3(struct urcu_ref *ref$link3, void (*release$link3)(struct urcu_ref *));
// urcu_ref_put$link4
// file urcu/ref.h line 40
static inline void urcu_ref_put$link4(struct urcu_ref *ref$link4, void (*release$link4)(struct urcu_ref *));
// urcu_ref_put::release$link1$object
//
void release$link1$object(struct urcu_ref *);
// urcu_ref_put::release$link2$object
//
void release$link2$object(struct urcu_ref *);
// urcu_ref_put::release$link3$object
//
void release$link3$object(struct urcu_ref *);
// urcu_ref_put::release$link4$object
//
void release$link4$object(struct urcu_ref *);
// urcu_ref_put::release$object
//
void release$object(struct urcu_ref *);
// urcu_ref_set
// file urcu/ref.h line 25
static inline void urcu_ref_set(struct urcu_ref *ref, signed long int val);
// urcu_ref_set$link1
// file urcu/ref.h line 25
static inline void urcu_ref_set$link1(struct urcu_ref *ref$link1, signed long int val$link1);
// urcu_ref_set$link2
// file urcu/ref.h line 25
static inline void urcu_ref_set$link2(struct urcu_ref *ref$link2, signed long int val$link2);
// urcu_ref_set$link3
// file urcu/ref.h line 25
static inline void urcu_ref_set$link3(struct urcu_ref *ref$link3, signed long int val$link3);
// urcu_ref_set$link4
// file urcu/ref.h line 25
static inline void urcu_ref_set$link4(struct urcu_ref *ref$link4, signed long int val$link4);
// urcu_sched_getcpu
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu(void);
// urcu_sched_getcpu$link1
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu$link1(void);
// urcu_sched_getcpu$link2
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu$link2(void);
// urcu_sched_getcpu$link3
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu$link3(void);
// urcu_sched_getcpu$link4
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu$link4(void);
// urcu_wait_add
// file urcu-wait.h line 82
static inline _Bool urcu_wait_add(struct urcu_wait_queue *queue, struct urcu_wait_node *node);
// urcu_wait_add$link1
// file urcu-wait.h line 82
static inline _Bool urcu_wait_add$link1(struct urcu_wait_queue *queue$link1, struct urcu_wait_node *node$link1);
// urcu_wait_add$link2
// file urcu-wait.h line 82
static inline _Bool urcu_wait_add$link2(struct urcu_wait_queue *queue$link2, struct urcu_wait_node *node$link2);
// urcu_wait_add$link3
// file urcu-wait.h line 82
static inline _Bool urcu_wait_add$link3(struct urcu_wait_queue *queue$link3, struct urcu_wait_node *node$link3);
// urcu_wait_set_state
// file urcu-wait.h line 100
static inline void urcu_wait_set_state(struct urcu_wait_node *node, enum urcu_wait_state state);
// urcu_wait_set_state$link1
// file urcu-wait.h line 100
static inline void urcu_wait_set_state$link1(struct urcu_wait_node *node$link1, enum urcu_wait_state state$link1);
// urcu_wait_set_state$link2
// file urcu-wait.h line 100
static inline void urcu_wait_set_state$link2(struct urcu_wait_node *node$link2, enum urcu_wait_state state$link2);
// urcu_wait_set_state$link3
// file urcu-wait.h line 100
static inline void urcu_wait_set_state$link3(struct urcu_wait_node *node$link3, enum urcu_wait_state state$link3);
// urcu_wake_all_waiters
// file urcu-wait.h line 185
static inline void urcu_wake_all_waiters(struct urcu_waiters *waiters);
// urcu_wake_all_waiters$link1
// file urcu-wait.h line 185
static inline void urcu_wake_all_waiters$link1(struct urcu_waiters *waiters$link1);
// urcu_wake_all_waiters$link2
// file urcu-wait.h line 185
static inline void urcu_wake_all_waiters$link2(struct urcu_waiters *waiters$link2);
// urcu_wake_all_waiters$link3
// file urcu-wait.h line 185
static inline void urcu_wake_all_waiters$link3(struct urcu_waiters *waiters$link3);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// wait_defer
// file urcu-defer-impl.h line 180
static void wait_defer(void);
// wait_defer$link1
// file urcu-defer-impl.h line 180
static void wait_defer$link1(void);
// wait_defer$link2
// file urcu-defer-impl.h line 180
static void wait_defer$link2(void);
// wait_defer$link3
// file urcu-defer-impl.h line 180
static void wait_defer$link3(void);
// wait_defer$link4
// file urcu-defer-impl.h line 180
static void wait_defer$link4(void);
// wait_for_readers
// file urcu.c line 269
static void wait_for_readers(struct cds_list_head *input_readers, struct cds_list_head *cur_snap_readers, struct cds_list_head *qsreaders);
// wait_for_readers$link1
// file urcu.c line 269
static void wait_for_readers$link1(struct cds_list_head *input_readers$link1, struct cds_list_head *cur_snap_readers$link1, struct cds_list_head *qsreaders$link1);
// wait_for_readers$link2
// file urcu.c line 269
static void wait_for_readers$link2(struct cds_list_head *input_readers$link2, struct cds_list_head *cur_snap_readers$link2, struct cds_list_head *qsreaders$link2);
// wait_for_readers$link3
// file urcu-qsbr.c line 146
static void wait_for_readers$link3(struct cds_list_head *input_readers$link3, struct cds_list_head *cur_snap_readers$link3, struct cds_list_head *qsreaders$link3);
// wait_for_readers$link4
// file urcu-bp.c line 204
static void wait_for_readers$link4(struct cds_list_head *input_readers$link4, struct cds_list_head *cur_snap_readers$link4, struct cds_list_head *qsreaders$link4);
// wait_gp
// file urcu.c line 232
static void wait_gp(void);
// wait_gp$link1
// file urcu.c line 232
static void wait_gp$link1(void);
// wait_gp$link2
// file urcu.c line 232
static void wait_gp$link2(void);
// wait_gp$link3
// file urcu-qsbr.c line 120
static void wait_gp$link3(void);
// wake_call_rcu_thread
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread(struct call_rcu_data *crdp);
// wake_call_rcu_thread$link1
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread$link1(struct call_rcu_data *crdp$link1);
// wake_call_rcu_thread$link2
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread$link2(struct call_rcu_data *crdp$link2);
// wake_call_rcu_thread$link3
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread$link3(struct call_rcu_data *crdp$link3);
// wake_call_rcu_thread$link4
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread$link4(struct call_rcu_data *crdp$link4);
// wake_up_defer
// file urcu-defer-impl.h line 153
static void wake_up_defer(void);
// wake_up_defer$link1
// file urcu-defer-impl.h line 153
static void wake_up_defer$link1(void);
// wake_up_defer$link2
// file urcu-defer-impl.h line 153
static void wake_up_defer$link2(void);
// wake_up_defer$link3
// file urcu-defer-impl.h line 153
static void wake_up_defer$link3(void);
// wake_up_defer$link4
// file urcu-defer-impl.h line 153
static void wake_up_defer$link4(void);
// wake_up_gp
// file urcu/static/urcu.h line 158
static inline void wake_up_gp(void);
// wake_up_gp$link1
// file urcu/static/urcu.h line 158
static inline void wake_up_gp$link1(void);
// wake_up_gp$link2
// file urcu/static/urcu.h line 158
static inline void wake_up_gp$link2(void);
// wake_up_gp$link3
// file urcu/static/urcu-qsbr.h line 97
static inline void wake_up_gp$link3(void);

struct anonymous$9
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$7
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$2
{
  // __bits
  unsigned long int __bits[16l];
};

struct anonymous$16
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$4
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$6
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$12
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$11
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$8
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$13
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$10 _kill;
  // _timer
  struct anonymous$11 _timer;
  // _rt
  struct anonymous$12 _rt;
  // _sigchld
  struct anonymous$6 _sigchld;
  // _sigfault
  struct anonymous$7 _sigfault;
  // _sigpoll
  struct anonymous$8 _sigpoll;
  // _sigsys
  struct anonymous$9 _sigsys;
};

struct anonymous$14
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$13 _sifields;
};

union anonymous$15
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$14 *, void *);
};

union anonymous$3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$5
{
  // __data
  struct anonymous$4 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$1
{
  // _h
  struct __cds_wfcq_head *_h;
  // h
  struct cds_wfcq_head *h;
} __attribute__ ((__transparent_union__));

union anonymous
{
  // _s
  struct __cds_wfs_stack *_s;
  // s
  struct cds_wfs_stack *s;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct cds_wfcq_node
{
  // next
  struct cds_wfcq_node *next;
};

struct __cds_wfcq_head
{
  // node
  struct cds_wfcq_node node;
};

struct __cds_wfs_stack
{
  // head
  struct cds_wfs_head *head;
};

struct __uatomic_dummy
{
  // v
  unsigned long int v[10l];
};

struct urcu_ref
{
  // refcount
  signed long int refcount;
};

struct call_rcu_completion
{
  // barrier_count
  signed int barrier_count;
  // futex
  signed int futex;
  // ref
  struct urcu_ref ref;
};

struct rcu_head
{
  // next
  struct cds_wfcq_node next;
  // func
  void (*func)(struct rcu_head *);
};

struct call_rcu_completion_work
{
  // head
  struct rcu_head head;
  // completion
  struct call_rcu_completion *completion;
};

struct cds_wfcq_tail
{
  // p
  struct cds_wfcq_node *p;
};

struct cds_wfcq_head
{
  // node
  struct cds_wfcq_node node;
  // lock
  union anonymous$0 lock;
};

struct cds_list_head
{
  // next
  struct cds_list_head *next;
  // prev
  struct cds_list_head *prev;
};

struct call_rcu_data
{
  // cbs_tail
  struct cds_wfcq_tail cbs_tail;
  // cbs_head
  struct cds_wfcq_head cbs_head;
  // flags
  unsigned long int flags;
  // futex
  signed int futex;
  // qlen
  unsigned long int qlen;
  // tid
  unsigned long int tid;
  // cpu_affinity
  signed int cpu_affinity;
  // gp_count
  unsigned long int gp_count;
  // list
  struct cds_list_head list;
};

struct cds_wfq_node
{
  // next
  struct cds_wfq_node *next;
};

struct cds_wfq_queue
{
  // head
  struct cds_wfq_node *head;
  // tail
  struct cds_wfq_node **tail;
  // dummy
  struct cds_wfq_node dummy;
  // lock
  union anonymous$0 lock;
};

struct cds_wfs_node
{
  // next
  struct cds_wfs_node *next;
};

struct cds_wfs_head
{
  // node
  struct cds_wfs_node node;
};

struct cds_wfs_stack
{
  // head
  struct cds_wfs_head *head;
  // lock
  union anonymous$0 lock;
};

struct defer_queue
{
  // head
  unsigned long int head;
  // last_fct_in
  void *last_fct_in;
  // tail
  unsigned long int tail;
  // last_fct_out
  void *last_fct_out;
  // q
  void **q;
  // last_head
  unsigned long int last_head;
  // list
  struct cds_list_head list;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rcu_flavor_struct
{
  // read_lock
  void (*read_lock)(void);
  // read_unlock
  void (*read_unlock)(void);
  // read_ongoing
  signed int (*read_ongoing)(void);
  // read_quiescent_state
  void (*read_quiescent_state)(void);
  // update_call_rcu
  void (*update_call_rcu)(struct rcu_head *, void (*)(struct rcu_head *));
  // update_synchronize_rcu
  void (*update_synchronize_rcu)(void);
  // update_defer_rcu
  void (*update_defer_rcu)(void (*)(void *), void *);
  // thread_offline
  void (*thread_offline)(void);
  // thread_online
  void (*thread_online)(void);
  // register_thread
  void (*register_thread)(void);
  // unregister_thread
  void (*unregister_thread)(void);
  // barrier
  void (*barrier)(void);
};

struct rcu_gp_bp
{
  // ctr
  unsigned long int ctr;
};

struct rcu_gp_mb
{
  // ctr
  unsigned long int ctr;
  // futex
  signed int futex;
};

struct rcu_gp_memb
{
  // ctr
  unsigned long int ctr;
  // futex
  signed int futex;
};

struct rcu_gp_qsbr
{
  // ctr
  unsigned long int ctr;
  // futex
  signed int futex;
};

struct rcu_gp_sig
{
  // ctr
  unsigned long int ctr;
  // futex
  signed int futex;
};

struct rcu_reader_bp
{
  // ctr
  unsigned long int ctr;
  // node
  struct cds_list_head node;
  // tid
  unsigned long int tid;
  // alloc
  signed int alloc;
};

struct rcu_reader_mb
{
  // ctr
  unsigned long int ctr;
  // need_mb
  char need_mb;
  // node
  struct cds_list_head node;
  // tid
  unsigned long int tid;
  // registered
  unsigned int registered : 1;
};

struct rcu_reader_memb
{
  // ctr
  unsigned long int ctr;
  // need_mb
  char need_mb;
  // node
  struct cds_list_head node;
  // tid
  unsigned long int tid;
  // registered
  unsigned int registered : 1;
};

struct rcu_reader_qsbr
{
  // ctr
  unsigned long int ctr;
  // node
  struct cds_list_head node;
  // waiting
  signed int waiting;
  // tid
  unsigned long int tid;
  // registered
  unsigned int registered : 1;
};

struct rcu_reader_sig
{
  // ctr
  unsigned long int ctr;
  // need_mb
  char need_mb;
  // node
  struct cds_list_head node;
  // tid
  unsigned long int tid;
  // registered
  unsigned int registered : 1;
};

struct registry_arena
{
  // chunk_list
  struct cds_list_head chunk_list;
};

struct registry_chunk
{
  // data_len
  unsigned long int data_len;
  // used
  unsigned long int used;
  // node
  struct cds_list_head node;
  // data
  char data[0l];
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$15 __sigaction_handler;
  // sa_mask
  struct anonymous$16 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct urcu_wait_node
{
  // node
  struct cds_wfs_node node;
  // state
  signed int state;
};

struct urcu_wait_queue
{
  // stack
  struct cds_wfs_stack stack;
};

struct urcu_waiters
{
  // head
  struct cds_wfs_head *head;
};


// __urcu_compat_futex_cond
// file compat_futex.c line 46
union anonymous$5 __urcu_compat_futex_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// __urcu_compat_futex_lock
// file compat_futex.c line 44
union anonymous$0 __urcu_compat_futex_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// call_rcu_data_list
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list;
// call_rcu_data_list
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list = { .next=&call_rcu_data_list, .prev=&call_rcu_data_list };
// call_rcu_data_list$link1
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list$link1;
// call_rcu_data_list$link1
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list$link1 = { .next=&call_rcu_data_list$link1, .prev=&call_rcu_data_list$link1 };
// call_rcu_data_list$link2
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list$link2;
// call_rcu_data_list$link2
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list$link2 = { .next=&call_rcu_data_list$link2, .prev=&call_rcu_data_list$link2 };
// call_rcu_data_list$link3
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list$link3;
// call_rcu_data_list$link3
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list$link3 = { .next=&call_rcu_data_list$link3, .prev=&call_rcu_data_list$link3 };
// call_rcu_data_list$link4
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list$link4;
// call_rcu_data_list$link4
// file urcu-call-rcu-impl.h line 89
static struct cds_list_head call_rcu_data_list$link4 = { .next=&call_rcu_data_list$link4, .prev=&call_rcu_data_list$link4 };
// call_rcu_mutex
// file urcu-call-rcu-impl.h line 98
static union anonymous$0 call_rcu_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// call_rcu_mutex$link1
// file urcu-call-rcu-impl.h line 98
static union anonymous$0 call_rcu_mutex$link1 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// call_rcu_mutex$link2
// file urcu-call-rcu-impl.h line 98
static union anonymous$0 call_rcu_mutex$link2 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// call_rcu_mutex$link3
// file urcu-call-rcu-impl.h line 98
static union anonymous$0 call_rcu_mutex$link3 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// call_rcu_mutex$link4
// file urcu-call-rcu-impl.h line 98
static union anonymous$0 call_rcu_mutex$link4 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// default_call_rcu_data
// file urcu-call-rcu-impl.h line 102
static struct call_rcu_data *default_call_rcu_data;
// default_call_rcu_data$link1
// file urcu-call-rcu-impl.h line 102
static struct call_rcu_data *default_call_rcu_data$link1;
// default_call_rcu_data$link2
// file urcu-call-rcu-impl.h line 102
static struct call_rcu_data *default_call_rcu_data$link2;
// default_call_rcu_data$link3
// file urcu-call-rcu-impl.h line 102
static struct call_rcu_data *default_call_rcu_data$link3;
// default_call_rcu_data$link4
// file urcu-call-rcu-impl.h line 102
static struct call_rcu_data *default_call_rcu_data$link4;
// defer_queue
// file urcu-defer-impl.h line 129
static struct defer_queue defer_queue;
// defer_queue$link1
// file urcu-defer-impl.h line 129
static struct defer_queue defer_queue$link1;
// defer_queue$link2
// file urcu-defer-impl.h line 129
static struct defer_queue defer_queue$link2;
// defer_queue$link3
// file urcu-defer-impl.h line 129
static struct defer_queue defer_queue$link3;
// defer_queue$link4
// file urcu-defer-impl.h line 129
static struct defer_queue defer_queue$link4;
// defer_thread_futex
// file urcu-defer-impl.h line 122
static signed int defer_thread_futex;
// defer_thread_futex$link1
// file urcu-defer-impl.h line 122
static signed int defer_thread_futex$link1;
// defer_thread_futex$link2
// file urcu-defer-impl.h line 122
static signed int defer_thread_futex$link2;
// defer_thread_futex$link3
// file urcu-defer-impl.h line 122
static signed int defer_thread_futex$link3;
// defer_thread_futex$link4
// file urcu-defer-impl.h line 122
static signed int defer_thread_futex$link4;
// defer_thread_mutex
// file urcu-defer-impl.h line 120
static union anonymous$0 defer_thread_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// defer_thread_mutex$link1
// file urcu-defer-impl.h line 120
static union anonymous$0 defer_thread_mutex$link1 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// defer_thread_mutex$link2
// file urcu-defer-impl.h line 120
static union anonymous$0 defer_thread_mutex$link2 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// defer_thread_mutex$link3
// file urcu-defer-impl.h line 120
static union anonymous$0 defer_thread_mutex$link3 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// defer_thread_mutex$link4
// file urcu-defer-impl.h line 120
static union anonymous$0 defer_thread_mutex$link4 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// defer_thread_stop
// file urcu-defer-impl.h line 123
static signed int defer_thread_stop;
// defer_thread_stop$link1
// file urcu-defer-impl.h line 123
static signed int defer_thread_stop$link1;
// defer_thread_stop$link2
// file urcu-defer-impl.h line 123
static signed int defer_thread_stop$link2;
// defer_thread_stop$link3
// file urcu-defer-impl.h line 123
static signed int defer_thread_stop$link3;
// defer_thread_stop$link4
// file urcu-defer-impl.h line 123
static signed int defer_thread_stop$link4;
// e_tests
// file tap.c line 39
static unsigned int e_tests = (unsigned int)0;
// failures
// file tap.c line 40
static unsigned int failures = (unsigned int)0;
// gp_waiters
// file urcu.c line 128
static struct urcu_wait_queue gp_waiters = { .stack={ .head=(struct cds_wfs_head *)(void *)0x1UL, .lock={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } } };
// gp_waiters$link1
// file urcu.c line 128
static struct urcu_wait_queue gp_waiters$link1 = { .stack={ .head=(struct cds_wfs_head *)(void *)0x1UL, .lock={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } } };
// gp_waiters$link2
// file urcu.c line 128
static struct urcu_wait_queue gp_waiters$link2 = { .stack={ .head=(struct cds_wfs_head *)(void *)0x1UL, .lock={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } } };
// gp_waiters$link3
// file urcu-qsbr.c line 89
static struct urcu_wait_queue gp_waiters$link3 = { .stack={ .head=(struct cds_wfs_head *)(void *)0x1UL, .lock={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } } };
// have_plan
// file tap.c line 37
static signed int have_plan = 0;
// init_done
// file urcu.c line 80
static signed int init_done;
// init_done$link1
// file urcu.c line 93
static signed int init_done$link1;
// init_lock
// file urcu-bp.c line 133
static union anonymous$0 init_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// initialized
// file urcu-bp.c line 134
static signed int initialized;
// maxcpus
// file urcu-call-rcu-impl.h line 121
static signed long int maxcpus;
// maxcpus$link1
// file urcu-call-rcu-impl.h line 121
static signed long int maxcpus$link1;
// maxcpus$link2
// file urcu-call-rcu-impl.h line 121
static signed long int maxcpus$link2;
// maxcpus$link3
// file urcu-call-rcu-impl.h line 121
static signed long int maxcpus$link3;
// maxcpus$link4
// file urcu-call-rcu-impl.h line 121
static signed long int maxcpus$link4;
// no_plan
// file tap.c line 35
static signed int no_plan = 0;
// per_cpu_call_rcu_data
// file urcu-call-rcu-impl.h line 120
static struct call_rcu_data **per_cpu_call_rcu_data;
// per_cpu_call_rcu_data$link1
// file urcu-call-rcu-impl.h line 120
static struct call_rcu_data **per_cpu_call_rcu_data$link1;
// per_cpu_call_rcu_data$link2
// file urcu-call-rcu-impl.h line 120
static struct call_rcu_data **per_cpu_call_rcu_data$link2;
// per_cpu_call_rcu_data$link3
// file urcu-call-rcu-impl.h line 120
static struct call_rcu_data **per_cpu_call_rcu_data$link3;
// per_cpu_call_rcu_data$link4
// file urcu-call-rcu-impl.h line 120
static struct call_rcu_data **per_cpu_call_rcu_data$link4;
// rcu_bp_refcount
// file urcu-bp.c line 96
static signed int rcu_bp_refcount;
// rcu_defer_mutex
// file urcu-defer-impl.h line 119
static union anonymous$0 rcu_defer_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_defer_mutex$link1
// file urcu-defer-impl.h line 119
static union anonymous$0 rcu_defer_mutex$link1 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_defer_mutex$link2
// file urcu-defer-impl.h line 119
static union anonymous$0 rcu_defer_mutex$link2 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_defer_mutex$link3
// file urcu-defer-impl.h line 119
static union anonymous$0 rcu_defer_mutex$link3 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_defer_mutex$link4
// file urcu-defer-impl.h line 119
static union anonymous$0 rcu_defer_mutex$link4 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_flavor_bp
// file urcu-bp.c line 714
struct rcu_flavor_struct rcu_flavor_bp;
// rcu_flavor_bp
// file urcu-bp.c line 714
struct rcu_flavor_struct rcu_flavor_bp = { .read_lock=rcu_read_lock_bp, .read_unlock=rcu_read_unlock_bp, .read_ongoing=rcu_read_ongoing_bp,
    .read_quiescent_state=rcu_quiescent_state$link3, .update_call_rcu=call_rcu_bp,
    .update_synchronize_rcu=synchronize_rcu_bp, .update_defer_rcu=defer_rcu_bp,
    .thread_offline=rcu_thread_offline$link3, .thread_online=rcu_thread_online$link3,
    .register_thread=rcu_register_thread_bp$link1,
    .unregister_thread=rcu_unregister_thread_bp$link1,
    .barrier=rcu_barrier_bp };
// rcu_flavor_mb
// file urcu.c line 602
struct rcu_flavor_struct rcu_flavor_mb;
// rcu_flavor_mb
// file urcu.c line 602
struct rcu_flavor_struct rcu_flavor_mb = { .read_lock=rcu_read_lock_mb, .read_unlock=rcu_read_unlock_mb, .read_ongoing=rcu_read_ongoing_mb,
    .read_quiescent_state=rcu_quiescent_state$link1, .update_call_rcu=call_rcu_mb,
    .update_synchronize_rcu=synchronize_rcu_mb, .update_defer_rcu=defer_rcu_mb,
    .thread_offline=rcu_thread_offline$link1, .thread_online=rcu_thread_online$link1,
    .register_thread=rcu_register_thread_mb,
    .unregister_thread=rcu_unregister_thread_mb,
    .barrier=rcu_barrier_mb };
// rcu_flavor_memb
// file urcu.c line 602
struct rcu_flavor_struct rcu_flavor_memb;
// rcu_flavor_memb
// file urcu.c line 602
struct rcu_flavor_struct rcu_flavor_memb = { .read_lock=rcu_read_lock_memb, .read_unlock=rcu_read_unlock_memb, .read_ongoing=rcu_read_ongoing_memb,
    .read_quiescent_state=rcu_quiescent_state,
    .update_call_rcu=call_rcu_memb,
    .update_synchronize_rcu=synchronize_rcu_memb, .update_defer_rcu=defer_rcu_memb,
    .thread_offline=rcu_thread_offline, .thread_online=rcu_thread_online,
    .register_thread=rcu_register_thread_memb, .unregister_thread=rcu_unregister_thread_memb,
    .barrier=rcu_barrier_memb };
// rcu_flavor_qsbr
// file urcu-qsbr.c line 501
struct rcu_flavor_struct rcu_flavor_qsbr;
// rcu_flavor_qsbr
// file urcu-qsbr.c line 501
struct rcu_flavor_struct rcu_flavor_qsbr = { .read_lock=rcu_read_lock_qsbr$link1, .read_unlock=rcu_read_unlock_qsbr$link1, .read_ongoing=rcu_read_ongoing_qsbr,
    .read_quiescent_state=rcu_quiescent_state_qsbr,
    .update_call_rcu=call_rcu_qsbr,
    .update_synchronize_rcu=synchronize_rcu_qsbr, .update_defer_rcu=defer_rcu_qsbr,
    .thread_offline=rcu_thread_offline_qsbr, .thread_online=rcu_thread_online_qsbr,
    .register_thread=rcu_register_thread_qsbr,
    .unregister_thread=rcu_unregister_thread_qsbr,
    .barrier=rcu_barrier_qsbr };
// rcu_flavor_sig
// file urcu.c line 602
struct rcu_flavor_struct rcu_flavor_sig;
// rcu_flavor_sig
// file urcu.c line 602
struct rcu_flavor_struct rcu_flavor_sig = { .read_lock=rcu_read_lock_sig, .read_unlock=rcu_read_unlock_sig, .read_ongoing=rcu_read_ongoing_sig,
    .read_quiescent_state=rcu_quiescent_state$link2, .update_call_rcu=call_rcu_sig,
    .update_synchronize_rcu=synchronize_rcu_sig, .update_defer_rcu=defer_rcu_sig,
    .thread_offline=rcu_thread_offline$link2, .thread_online=rcu_thread_online$link2,
    .register_thread=rcu_register_thread_sig,
    .unregister_thread=rcu_unregister_thread_sig,
    .barrier=rcu_barrier_sig };
// rcu_gp_bp
// file urcu-bp.c line 138
struct rcu_gp_bp rcu_gp_bp = { .ctr=1UL << 0 };
// rcu_gp_lock
// file urcu.c line 103
static union anonymous$0 rcu_gp_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_gp_lock$link1
// file urcu.c line 103
static union anonymous$0 rcu_gp_lock$link1 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_gp_lock$link2
// file urcu.c line 103
static union anonymous$0 rcu_gp_lock$link2 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_gp_lock$link3
// file urcu-qsbr.c line 59
static union anonymous$0 rcu_gp_lock$link3 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_gp_lock$link4
// file urcu-bp.c line 121
static union anonymous$0 rcu_gp_lock$link4 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_gp_mb
// file urcu.c line 114
struct rcu_gp_mb rcu_gp_mb = { .ctr=1UL << 0, .futex=0 };
// rcu_gp_memb
// file urcu.c line 114
struct rcu_gp_memb rcu_gp_memb = { .ctr=1UL << 0, .futex=0 };
// rcu_gp_qsbr
// file urcu-qsbr.c line 70
struct rcu_gp_qsbr rcu_gp_qsbr = { .ctr=1UL << 0, .futex=0 };
// rcu_gp_sig
// file urcu.c line 114
struct rcu_gp_sig rcu_gp_sig = { .ctr=1UL << 0, .futex=0 };
// rcu_has_sys_membarrier_memb
// file urcu.c line 81
signed int rcu_has_sys_membarrier_memb;
// rcu_reader_bp
// file urcu-bp.c line 144
struct rcu_reader_bp *rcu_reader_bp;
// rcu_reader_mb
// file urcu.c line 120
struct rcu_reader_mb rcu_reader_mb;
// rcu_reader_memb
// file urcu.c line 120
struct rcu_reader_memb rcu_reader_memb;
// rcu_reader_qsbr
// file urcu-qsbr.c line 81
struct rcu_reader_qsbr rcu_reader_qsbr;
// rcu_reader_sig
// file urcu.c line 120
struct rcu_reader_sig rcu_reader_sig;
// rcu_registry_lock
// file urcu.c line 113
static union anonymous$0 rcu_registry_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_registry_lock$link1
// file urcu.c line 113
static union anonymous$0 rcu_registry_lock$link1 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_registry_lock$link2
// file urcu.c line 113
static union anonymous$0 rcu_registry_lock$link2 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_registry_lock$link3
// file urcu-qsbr.c line 69
static union anonymous$0 rcu_registry_lock$link3 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rcu_registry_lock$link4
// file urcu-bp.c line 131
static union anonymous$0 rcu_registry_lock$link4 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// registry
// file urcu.c line 122
static struct cds_list_head registry;
// registry
// file urcu.c line 122
static struct cds_list_head registry = { .next=&registry, .prev=&registry };
// registry$link1
// file urcu.c line 122
static struct cds_list_head registry$link1;
// registry$link1
// file urcu.c line 122
static struct cds_list_head registry$link1 = { .next=&registry$link1, .prev=&registry$link1 };
// registry$link2
// file urcu.c line 122
static struct cds_list_head registry$link2;
// registry$link2
// file urcu.c line 122
static struct cds_list_head registry$link2 = { .next=&registry$link2, .prev=&registry$link2 };
// registry$link3
// file urcu-qsbr.c line 83
static struct cds_list_head registry$link3;
// registry$link3
// file urcu-qsbr.c line 83
static struct cds_list_head registry$link3 = { .next=&registry$link3, .prev=&registry$link3 };
// registry$link4
// file urcu-bp.c line 146
static struct cds_list_head registry$link4;
// registry$link4
// file urcu-bp.c line 146
static struct cds_list_head registry$link4 = { .next=&registry$link4, .prev=&registry$link4 };
// registry_arena
// file urcu-bp.c line 159
static struct registry_arena registry_arena;
// registry_arena
// file urcu-bp.c line 159
static struct registry_arena registry_arena = { .chunk_list={ .next=&registry_arena.chunk_list, .prev=&registry_arena.chunk_list } };
// registry_defer
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer;
// registry_defer
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer = { .next=&registry_defer, .prev=&registry_defer };
// registry_defer$link1
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer$link1;
// registry_defer$link1
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer$link1 = { .next=&registry_defer$link1, .prev=&registry_defer$link1 };
// registry_defer$link2
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer$link2;
// registry_defer$link2
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer$link2 = { .next=&registry_defer$link2, .prev=&registry_defer$link2 };
// registry_defer$link3
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer$link3;
// registry_defer$link3
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer$link3 = { .next=&registry_defer$link3, .prev=&registry_defer$link3 };
// registry_defer$link4
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer$link4;
// registry_defer$link4
// file urcu-defer-impl.h line 130
static struct cds_list_head registry_defer$link4 = { .next=&registry_defer$link4, .prev=&registry_defer$link4 };
// saved_fork_signal_mask
// file urcu-bp.c line 164
static struct anonymous$16 saved_fork_signal_mask;
// skip_all
// file tap.c line 36
static signed int skip_all = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tap_is_disabled
// file tap.c line 45
static signed int tap_is_disabled = 0;
// test_count
// file tap.c line 38
static unsigned int test_count = (unsigned int)0;
// test_died
// file tap.c line 44
static signed int test_died = 0;
// thread_call_rcu_data
// file urcu-call-rcu-impl.h line 93
static struct call_rcu_data *thread_call_rcu_data;
// thread_call_rcu_data$link1
// file urcu-call-rcu-impl.h line 93
static struct call_rcu_data *thread_call_rcu_data$link1;
// thread_call_rcu_data$link2
// file urcu-call-rcu-impl.h line 93
static struct call_rcu_data *thread_call_rcu_data$link2;
// thread_call_rcu_data$link3
// file urcu-call-rcu-impl.h line 93
static struct call_rcu_data *thread_call_rcu_data$link3;
// thread_call_rcu_data$link4
// file urcu-call-rcu-impl.h line 93
static struct call_rcu_data *thread_call_rcu_data$link4;
// tid_defer
// file urcu-defer-impl.h line 131
static unsigned long int tid_defer;
// tid_defer$link1
// file urcu-defer-impl.h line 131
static unsigned long int tid_defer$link1;
// tid_defer$link2
// file urcu-defer-impl.h line 131
static unsigned long int tid_defer$link2;
// tid_defer$link3
// file urcu-defer-impl.h line 131
static unsigned long int tid_defer$link3;
// tid_defer$link4
// file urcu-defer-impl.h line 131
static unsigned long int tid_defer$link4;
// todo
// file tap.c line 43
static signed int todo = 0;
// todo_msg
// file tap.c line 41
static char *todo_msg = (char *)(void *)0;
// todo_msg_fixed
// file tap.c line 42
static char *todo_msg_fixed = "libtap malloc issue";
// urcu_bp_has_sys_membarrier
// file urcu-bp.c line 115
signed int urcu_bp_has_sys_membarrier;
// urcu_bp_key
// file urcu-bp.c line 136
static unsigned int urcu_bp_key;

// ___cds_wfcq_append
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append(union anonymous$1 u_head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *new_head, struct cds_wfcq_node *new_tail)
{
  struct __cds_wfcq_head *head = u_head._h;
  struct cds_wfcq_node *old_tail;
  unsigned long int return_value___uatomic_exchange$1;
  return_value___uatomic_exchange$1=__uatomic_exchange((void *)&tail->p, (unsigned long int)new_tail, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail = (struct cds_wfcq_node *)return_value___uatomic_exchange$1;
  struct cds_wfcq_node *_v;
  struct cds_wfcq_node * volatile tmp_statement_expression$2;
  *((struct cds_wfcq_node * volatile *)&old_tail->next) = new_head;
  tmp_statement_expression$2 = *((struct cds_wfcq_node * volatile *)&old_tail->next);
  _v = tmp_statement_expression$2;
  asm("" :  :  : "memory");
  _v = _v;
  return old_tail != &head->node;
}

// ___cds_wfcq_append$link1
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1(union anonymous$1 u_head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *new_head$link1, struct cds_wfcq_node *new_tail$link1)
{
  struct __cds_wfcq_head *head$link1 = u_head$link1._h;
  struct cds_wfcq_node *old_tail$link1;
  unsigned long int return_value___uatomic_exchange$1$link1;
  return_value___uatomic_exchange$1$link1=__uatomic_exchange$link1$link1((void *)&tail$link1->p, (unsigned long int)new_tail$link1, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail$link1 = (struct cds_wfcq_node *)return_value___uatomic_exchange$1$link1;
  struct cds_wfcq_node *_v$link1;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1;
  *((struct cds_wfcq_node * volatile *)&old_tail$link1->next) = new_head$link1;
  tmp_statement_expression$2$link1 = *((struct cds_wfcq_node * volatile *)&old_tail$link1->next);
  _v$link1 = tmp_statement_expression$2$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
  return old_tail$link1 != &head$link1->node;
}

// ___cds_wfcq_append$link1$link1
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1$link1(union anonymous$1 u_head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, struct cds_wfcq_node *new_head$link1$link1, struct cds_wfcq_node *new_tail$link1$link1)
{
  struct __cds_wfcq_head *head$link1$link1 = u_head$link1$link1._h;
  struct cds_wfcq_node *old_tail$link1$link1;
  unsigned long int return_value___uatomic_exchange$1$link1$link1;
  return_value___uatomic_exchange$1$link1$link1=__uatomic_exchange$link1$link1$link1((void *)&tail$link1$link1->p, (unsigned long int)new_tail$link1$link1, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail$link1$link1 = (struct cds_wfcq_node *)return_value___uatomic_exchange$1$link1$link1;
  struct cds_wfcq_node *_v$link1$link1;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link1;
  *((struct cds_wfcq_node * volatile *)&old_tail$link1$link1->next) = new_head$link1$link1;
  tmp_statement_expression$2$link1$link1 = *((struct cds_wfcq_node * volatile *)&old_tail$link1$link1->next);
  _v$link1$link1 = tmp_statement_expression$2$link1$link1;
  asm("" :  :  : "memory");
  _v$link1$link1 = _v$link1$link1;
  return old_tail$link1$link1 != &head$link1$link1->node;
}

// ___cds_wfcq_append$link1$link2
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1$link2(union anonymous$1 u_head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, struct cds_wfcq_node *new_head$link1$link2, struct cds_wfcq_node *new_tail$link1$link2)
{
  struct __cds_wfcq_head *head$link1$link2 = u_head$link1$link2._h;
  struct cds_wfcq_node *old_tail$link1$link2;
  unsigned long int return_value___uatomic_exchange$1$link1$link2;
  return_value___uatomic_exchange$1$link1$link2=__uatomic_exchange$link1$link1$link2((void *)&tail$link1$link2->p, (unsigned long int)new_tail$link1$link2, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail$link1$link2 = (struct cds_wfcq_node *)return_value___uatomic_exchange$1$link1$link2;
  struct cds_wfcq_node *_v$link1$link2;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link2;
  *((struct cds_wfcq_node * volatile *)&old_tail$link1$link2->next) = new_head$link1$link2;
  tmp_statement_expression$2$link1$link2 = *((struct cds_wfcq_node * volatile *)&old_tail$link1$link2->next);
  _v$link1$link2 = tmp_statement_expression$2$link1$link2;
  asm("" :  :  : "memory");
  _v$link1$link2 = _v$link1$link2;
  return old_tail$link1$link2 != &head$link1$link2->node;
}

// ___cds_wfcq_append$link1$link3
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1$link3(union anonymous$1 u_head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, struct cds_wfcq_node *new_head$link1$link3, struct cds_wfcq_node *new_tail$link1$link3)
{
  struct __cds_wfcq_head *head$link1$link3 = u_head$link1$link3._h;
  struct cds_wfcq_node *old_tail$link1$link3;
  unsigned long int return_value___uatomic_exchange$1$link1$link3;
  return_value___uatomic_exchange$1$link1$link3=__uatomic_exchange$link1$link1$link3((void *)&tail$link1$link3->p, (unsigned long int)new_tail$link1$link3, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail$link1$link3 = (struct cds_wfcq_node *)return_value___uatomic_exchange$1$link1$link3;
  struct cds_wfcq_node *_v$link1$link3;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link3;
  *((struct cds_wfcq_node * volatile *)&old_tail$link1$link3->next) = new_head$link1$link3;
  tmp_statement_expression$2$link1$link3 = *((struct cds_wfcq_node * volatile *)&old_tail$link1$link3->next);
  _v$link1$link3 = tmp_statement_expression$2$link1$link3;
  asm("" :  :  : "memory");
  _v$link1$link3 = _v$link1$link3;
  return old_tail$link1$link3 != &head$link1$link3->node;
}

// ___cds_wfcq_append$link1$link4
// file urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link1$link4(union anonymous$1 u_head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, struct cds_wfcq_node *new_head$link1$link4, struct cds_wfcq_node *new_tail$link1$link4)
{
  struct __cds_wfcq_head *head$link1$link4 = u_head$link1$link4._h;
  struct cds_wfcq_node *old_tail$link1$link4;
  unsigned long int return_value___uatomic_exchange$1$link1$link4;
  return_value___uatomic_exchange$1$link1$link4=__uatomic_exchange$link1$link1$link4((void *)&tail$link1$link4->p, (unsigned long int)new_tail$link1$link4, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail$link1$link4 = (struct cds_wfcq_node *)return_value___uatomic_exchange$1$link1$link4;
  struct cds_wfcq_node *_v$link1$link4;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link4;
  *((struct cds_wfcq_node * volatile *)&old_tail$link1$link4->next) = new_head$link1$link4;
  tmp_statement_expression$2$link1$link4 = *((struct cds_wfcq_node * volatile *)&old_tail$link1$link4->next);
  _v$link1$link4 = tmp_statement_expression$2$link1$link4;
  asm("" :  :  : "memory");
  _v$link1$link4 = _v$link1$link4;
  return old_tail$link1$link4 != &head$link1$link4->node;
}

// ___cds_wfcq_append$link2
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link2(union anonymous$1 u_head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *new_head$link2, struct cds_wfcq_node *new_tail$link2)
{
  struct __cds_wfcq_head *head$link2 = u_head$link2._h;
  struct cds_wfcq_node *old_tail$link2;
  unsigned long int return_value___uatomic_exchange$1$link2;
  return_value___uatomic_exchange$1$link2=__uatomic_exchange$link4((void *)&tail$link2->p, (unsigned long int)new_tail$link2, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail$link2 = (struct cds_wfcq_node *)return_value___uatomic_exchange$1$link2;
  struct cds_wfcq_node *_v$link2;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link2;
  *((struct cds_wfcq_node * volatile *)&old_tail$link2->next) = new_head$link2;
  tmp_statement_expression$2$link2 = *((struct cds_wfcq_node * volatile *)&old_tail$link2->next);
  _v$link2 = tmp_statement_expression$2$link2;
  asm("" :  :  : "memory");
  _v$link2 = _v$link2;
  return old_tail$link2 != &head$link2->node;
}

// ___cds_wfcq_append$link3
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link3(union anonymous$1 u_head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *new_head$link3, struct cds_wfcq_node *new_tail$link3)
{
  struct __cds_wfcq_head *head$link3 = u_head$link3._h;
  struct cds_wfcq_node *old_tail$link3;
  unsigned long int return_value___uatomic_exchange$1$link3;
  return_value___uatomic_exchange$1$link3=__uatomic_exchange$link5((void *)&tail$link3->p, (unsigned long int)new_tail$link3, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail$link3 = (struct cds_wfcq_node *)return_value___uatomic_exchange$1$link3;
  struct cds_wfcq_node *_v$link3;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link3;
  *((struct cds_wfcq_node * volatile *)&old_tail$link3->next) = new_head$link3;
  tmp_statement_expression$2$link3 = *((struct cds_wfcq_node * volatile *)&old_tail$link3->next);
  _v$link3 = tmp_statement_expression$2$link3;
  asm("" :  :  : "memory");
  _v$link3 = _v$link3;
  return old_tail$link3 != &head$link3->node;
}

// ___cds_wfcq_append$link4
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link4(union anonymous$1 u_head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *new_head$link4, struct cds_wfcq_node *new_tail$link4)
{
  struct __cds_wfcq_head *head$link4 = u_head$link4._h;
  struct cds_wfcq_node *old_tail$link4;
  unsigned long int return_value___uatomic_exchange$1$link4;
  return_value___uatomic_exchange$1$link4=__uatomic_exchange$link6((void *)&tail$link4->p, (unsigned long int)new_tail$link4, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail$link4 = (struct cds_wfcq_node *)return_value___uatomic_exchange$1$link4;
  struct cds_wfcq_node *_v$link4;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link4;
  *((struct cds_wfcq_node * volatile *)&old_tail$link4->next) = new_head$link4;
  tmp_statement_expression$2$link4 = *((struct cds_wfcq_node * volatile *)&old_tail$link4->next);
  _v$link4 = tmp_statement_expression$2$link4;
  asm("" :  :  : "memory");
  _v$link4 = _v$link4;
  return old_tail$link4 != &head$link4->node;
}

// ___cds_wfcq_append$link5
// file ./urcu/static/wfcqueue.h line 165
static inline _Bool ___cds_wfcq_append$link5(union anonymous$1 u_head$link5, struct cds_wfcq_tail *tail$link5, struct cds_wfcq_node *new_head$link5, struct cds_wfcq_node *new_tail$link5)
{
  struct __cds_wfcq_head *head$link5 = u_head$link5._h;
  struct cds_wfcq_node *old_tail$link5;
  unsigned long int return_value___uatomic_exchange$1$link5;
  return_value___uatomic_exchange$1$link5=__uatomic_exchange$link7((void *)&tail$link5->p, (unsigned long int)new_tail$link5, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
  old_tail$link5 = (struct cds_wfcq_node *)return_value___uatomic_exchange$1$link5;
  struct cds_wfcq_node *_v$link5;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link5;
  *((struct cds_wfcq_node * volatile *)&old_tail$link5->next) = new_head$link5;
  tmp_statement_expression$2$link5 = *((struct cds_wfcq_node * volatile *)&old_tail$link5->next);
  _v$link5 = tmp_statement_expression$2$link5;
  asm("" :  :  : "memory");
  _v$link5 = _v$link5;
  return old_tail$link5 != &head$link5->node;
}

// ___cds_wfcq_busy_wait
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait(signed int *attempt, signed int blocking)
{
  if(blocking == 0)
    return (_Bool)1;

  else
  {
    *attempt = *attempt + 1;
    if(*attempt >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_busy_wait$link1
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1(signed int *attempt$link1, signed int blocking$link1)
{
  if(blocking$link1 == 0)
    return (_Bool)1;

  else
  {
    *attempt$link1 = *attempt$link1 + 1;
    if(*attempt$link1 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt$link1 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_busy_wait$link1$link1
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1$link1(signed int *attempt$link1$link1, signed int blocking$link1$link1)
{
  if(blocking$link1$link1 == 0)
    return (_Bool)1;

  else
  {
    *attempt$link1$link1 = *attempt$link1$link1 + 1;
    if(*attempt$link1$link1 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt$link1$link1 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_busy_wait$link1$link2
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1$link2(signed int *attempt$link1$link2, signed int blocking$link1$link2)
{
  if(blocking$link1$link2 == 0)
    return (_Bool)1;

  else
  {
    *attempt$link1$link2 = *attempt$link1$link2 + 1;
    if(*attempt$link1$link2 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt$link1$link2 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_busy_wait$link1$link3
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1$link3(signed int *attempt$link1$link3, signed int blocking$link1$link3)
{
  if(blocking$link1$link3 == 0)
    return (_Bool)1;

  else
  {
    *attempt$link1$link3 = *attempt$link1$link3 + 1;
    if(*attempt$link1$link3 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt$link1$link3 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_busy_wait$link1$link4
// file urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link1$link4(signed int *attempt$link1$link4, signed int blocking$link1$link4)
{
  if(blocking$link1$link4 == 0)
    return (_Bool)1;

  else
  {
    *attempt$link1$link4 = *attempt$link1$link4 + 1;
    if(*attempt$link1$link4 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt$link1$link4 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_busy_wait$link2
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link2(signed int *attempt$link2, signed int blocking$link2)
{
  if(blocking$link2 == 0)
    return (_Bool)1;

  else
  {
    *attempt$link2 = *attempt$link2 + 1;
    if(*attempt$link2 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt$link2 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_busy_wait$link3
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link3(signed int *attempt$link3, signed int blocking$link3)
{
  if(blocking$link3 == 0)
    return (_Bool)1;

  else
  {
    *attempt$link3 = *attempt$link3 + 1;
    if(*attempt$link3 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt$link3 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_busy_wait$link4
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link4(signed int *attempt$link4, signed int blocking$link4)
{
  if(blocking$link4 == 0)
    return (_Bool)1;

  else
  {
    *attempt$link4 = *attempt$link4 + 1;
    if(*attempt$link4 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt$link4 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_busy_wait$link5
// file ./urcu/static/wfcqueue.h line 219
static inline _Bool ___cds_wfcq_busy_wait$link5(signed int *attempt$link5, signed int blocking$link5)
{
  if(blocking$link5 == 0)
    return (_Bool)1;

  else
  {
    *attempt$link5 = *attempt$link5 + 1;
    if(*attempt$link5 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      *attempt$link5 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
    return (_Bool)0;
  }
}

// ___cds_wfcq_dequeue_blocking
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_blocking$1;
  return_value____cds_wfcq_dequeue_with_state_blocking$1=___cds_wfcq_dequeue_with_state_blocking(head, tail, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_blocking$1;
}

// ___cds_wfcq_dequeue_blocking$link1
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_blocking$1$link1;
  return_value____cds_wfcq_dequeue_with_state_blocking$1$link1=___cds_wfcq_dequeue_with_state_blocking$link1(head$link1, tail$link1, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_blocking$1$link1;
}

// ___cds_wfcq_dequeue_blocking$link2
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_blocking$1$link2;
  return_value____cds_wfcq_dequeue_with_state_blocking$1$link2=___cds_wfcq_dequeue_with_state_blocking$link2(head$link2, tail$link2, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_blocking$1$link2;
}

// ___cds_wfcq_dequeue_blocking$link3
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_blocking$1$link3;
  return_value____cds_wfcq_dequeue_with_state_blocking$1$link3=___cds_wfcq_dequeue_with_state_blocking$link3(head$link3, tail$link3, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_blocking$1$link3;
}

// ___cds_wfcq_dequeue_blocking$link4
// file urcu/static/wfcqueue.h line 453
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_blocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_blocking$1$link4;
  return_value____cds_wfcq_dequeue_with_state_blocking$1$link4=___cds_wfcq_dequeue_with_state_blocking$link4(head$link4, tail$link4, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_blocking$1$link4;
}

// ___cds_wfcq_dequeue_nonblocking
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_nonblocking$1;
  return_value____cds_wfcq_dequeue_with_state_nonblocking$1=___cds_wfcq_dequeue_with_state_nonblocking(head, tail, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_nonblocking$1;
}

// ___cds_wfcq_dequeue_nonblocking$link1
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link1;
  return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link1=___cds_wfcq_dequeue_with_state_nonblocking$link1(head$link1, tail$link1, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link1;
}

// ___cds_wfcq_dequeue_nonblocking$link2
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link2;
  return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link2=___cds_wfcq_dequeue_with_state_nonblocking$link2(head$link2, tail$link2, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link2;
}

// ___cds_wfcq_dequeue_nonblocking$link3
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link3;
  return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link3=___cds_wfcq_dequeue_with_state_nonblocking$link3(head$link3, tail$link3, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link3;
}

// ___cds_wfcq_dequeue_nonblocking$link4
// file urcu/static/wfcqueue.h line 479
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_nonblocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link4;
  return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link4=___cds_wfcq_dequeue_with_state_nonblocking$link4(head$link4, tail$link4, (signed int *)(void *)0);
  return return_value____cds_wfcq_dequeue_with_state_nonblocking$1$link4;
}

// ___cds_wfcq_dequeue_with_state
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state(union anonymous$1 u_head, struct cds_wfcq_tail *tail, signed int *state, signed int blocking)
{
  struct __cds_wfcq_head *head = u_head._h;
  struct cds_wfcq_node *node;
  struct cds_wfcq_node *next;
  if(!(state == ((signed int *)NULL)))
    *state = 0;

  _Bool return_value__cds_wfcq_empty$1;
  return_value__cds_wfcq_empty$1=_cds_wfcq_empty$link1(head, tail);
  struct cds_wfcq_node * volatile tmp_statement_expression$3;
  if(!(return_value__cds_wfcq_empty$1 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node=___cds_wfcq_node_sync_next$link1(&head->node, blocking);
    if(node == (struct cds_wfcq_node *)18446744073709551615ul && blocking == 0)
      return (struct cds_wfcq_node *)(void *)-1UL;

    else
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$3 = *((struct cds_wfcq_node * volatile *)&node->next);
      next = tmp_statement_expression$3;
      if(next == ((struct cds_wfcq_node *)NULL))
      {
        _cds_wfcq_node_init$link1(&head->node);
        unsigned long int return_value___uatomic_cmpxchg$2;
        return_value___uatomic_cmpxchg$2=__uatomic_cmpxchg$link2((void *)&tail->p, (unsigned long int)node, (unsigned long int)&head->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
        if((struct cds_wfcq_node *)return_value___uatomic_cmpxchg$2 == node)
        {
          if(!(state == ((signed int *)NULL)))
            *state = *state | 1;

          return node;
        }

        next=___cds_wfcq_node_sync_next$link1(node, blocking);
        if(next == (struct cds_wfcq_node *)18446744073709551615ul && blocking == 0)
        {
          head->node.next = node;
          return (struct cds_wfcq_node *)(void *)-1UL;
        }

      }

      head->node.next = next;
      return node;
    }
  }
}

// ___cds_wfcq_dequeue_with_state$link1
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state$link1(union anonymous$1 u_head$link1, struct cds_wfcq_tail *tail$link1, signed int *state$link1, signed int blocking$link1)
{
  struct __cds_wfcq_head *head$link1 = u_head$link1._h;
  struct cds_wfcq_node *node$link1;
  struct cds_wfcq_node *next$link1;
  if(!(state$link1 == ((signed int *)NULL)))
    *state$link1 = 0;

  _Bool return_value__cds_wfcq_empty$1$link1;
  return_value__cds_wfcq_empty$1$link1=_cds_wfcq_empty$link1$link1(head$link1, tail$link1);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link1;
  if(!(return_value__cds_wfcq_empty$1$link1 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link1=___cds_wfcq_node_sync_next$link1$link1(&head$link1->node, blocking$link1);
    if(node$link1 == (struct cds_wfcq_node *)18446744073709551615ul && blocking$link1 == 0)
      return (struct cds_wfcq_node *)(void *)-1UL;

    else
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$3$link1 = *((struct cds_wfcq_node * volatile *)&node$link1->next);
      next$link1 = tmp_statement_expression$3$link1;
      if(next$link1 == ((struct cds_wfcq_node *)NULL))
      {
        _cds_wfcq_node_init$link1$link1(&head$link1->node);
        unsigned long int return_value___uatomic_cmpxchg$2$link1;
        return_value___uatomic_cmpxchg$2$link1=__uatomic_cmpxchg$link2$link1((void *)&tail$link1->p, (unsigned long int)node$link1, (unsigned long int)&head$link1->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
        if((struct cds_wfcq_node *)return_value___uatomic_cmpxchg$2$link1 == node$link1)
        {
          if(!(state$link1 == ((signed int *)NULL)))
            *state$link1 = *state$link1 | 1;

          return node$link1;
        }

        next$link1=___cds_wfcq_node_sync_next$link1$link1(node$link1, blocking$link1);
        if(next$link1 == (struct cds_wfcq_node *)18446744073709551615ul && blocking$link1 == 0)
        {
          head$link1->node.next = node$link1;
          return (struct cds_wfcq_node *)(void *)-1UL;
        }

      }

      head$link1->node.next = next$link1;
      return node$link1;
    }
  }
}

// ___cds_wfcq_dequeue_with_state$link2
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state$link2(union anonymous$1 u_head$link2, struct cds_wfcq_tail *tail$link2, signed int *state$link2, signed int blocking$link2)
{
  struct __cds_wfcq_head *head$link2 = u_head$link2._h;
  struct cds_wfcq_node *node$link2;
  struct cds_wfcq_node *next$link2;
  if(!(state$link2 == ((signed int *)NULL)))
    *state$link2 = 0;

  _Bool return_value__cds_wfcq_empty$1$link2;
  return_value__cds_wfcq_empty$1$link2=_cds_wfcq_empty$link1$link2(head$link2, tail$link2);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link2;
  if(!(return_value__cds_wfcq_empty$1$link2 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link2=___cds_wfcq_node_sync_next$link1$link2(&head$link2->node, blocking$link2);
    if(node$link2 == (struct cds_wfcq_node *)18446744073709551615ul && blocking$link2 == 0)
      return (struct cds_wfcq_node *)(void *)-1UL;

    else
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$3$link2 = *((struct cds_wfcq_node * volatile *)&node$link2->next);
      next$link2 = tmp_statement_expression$3$link2;
      if(next$link2 == ((struct cds_wfcq_node *)NULL))
      {
        _cds_wfcq_node_init$link1$link2(&head$link2->node);
        unsigned long int return_value___uatomic_cmpxchg$2$link2;
        return_value___uatomic_cmpxchg$2$link2=__uatomic_cmpxchg$link2$link2((void *)&tail$link2->p, (unsigned long int)node$link2, (unsigned long int)&head$link2->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
        if((struct cds_wfcq_node *)return_value___uatomic_cmpxchg$2$link2 == node$link2)
        {
          if(!(state$link2 == ((signed int *)NULL)))
            *state$link2 = *state$link2 | 1;

          return node$link2;
        }

        next$link2=___cds_wfcq_node_sync_next$link1$link2(node$link2, blocking$link2);
        if(next$link2 == (struct cds_wfcq_node *)18446744073709551615ul && blocking$link2 == 0)
        {
          head$link2->node.next = node$link2;
          return (struct cds_wfcq_node *)(void *)-1UL;
        }

      }

      head$link2->node.next = next$link2;
      return node$link2;
    }
  }
}

// ___cds_wfcq_dequeue_with_state$link3
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state$link3(union anonymous$1 u_head$link3, struct cds_wfcq_tail *tail$link3, signed int *state$link3, signed int blocking$link3)
{
  struct __cds_wfcq_head *head$link3 = u_head$link3._h;
  struct cds_wfcq_node *node$link3;
  struct cds_wfcq_node *next$link3;
  if(!(state$link3 == ((signed int *)NULL)))
    *state$link3 = 0;

  _Bool return_value__cds_wfcq_empty$1$link3;
  return_value__cds_wfcq_empty$1$link3=_cds_wfcq_empty$link1$link3(head$link3, tail$link3);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link3;
  if(!(return_value__cds_wfcq_empty$1$link3 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link3=___cds_wfcq_node_sync_next$link1$link3(&head$link3->node, blocking$link3);
    if(node$link3 == (struct cds_wfcq_node *)18446744073709551615ul && blocking$link3 == 0)
      return (struct cds_wfcq_node *)(void *)-1UL;

    else
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$3$link3 = *((struct cds_wfcq_node * volatile *)&node$link3->next);
      next$link3 = tmp_statement_expression$3$link3;
      if(next$link3 == ((struct cds_wfcq_node *)NULL))
      {
        _cds_wfcq_node_init$link1$link3(&head$link3->node);
        unsigned long int return_value___uatomic_cmpxchg$2$link3;
        return_value___uatomic_cmpxchg$2$link3=__uatomic_cmpxchg$link2$link3((void *)&tail$link3->p, (unsigned long int)node$link3, (unsigned long int)&head$link3->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
        if((struct cds_wfcq_node *)return_value___uatomic_cmpxchg$2$link3 == node$link3)
        {
          if(!(state$link3 == ((signed int *)NULL)))
            *state$link3 = *state$link3 | 1;

          return node$link3;
        }

        next$link3=___cds_wfcq_node_sync_next$link1$link3(node$link3, blocking$link3);
        if(next$link3 == (struct cds_wfcq_node *)18446744073709551615ul && blocking$link3 == 0)
        {
          head$link3->node.next = node$link3;
          return (struct cds_wfcq_node *)(void *)-1UL;
        }

      }

      head$link3->node.next = next$link3;
      return node$link3;
    }
  }
}

// ___cds_wfcq_dequeue_with_state$link4
// file urcu/static/wfcqueue.h line 367
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state$link4(union anonymous$1 u_head$link4, struct cds_wfcq_tail *tail$link4, signed int *state$link4, signed int blocking$link4)
{
  struct __cds_wfcq_head *head$link4 = u_head$link4._h;
  struct cds_wfcq_node *node$link4;
  struct cds_wfcq_node *next$link4;
  if(!(state$link4 == ((signed int *)NULL)))
    *state$link4 = 0;

  _Bool return_value__cds_wfcq_empty$1$link4;
  return_value__cds_wfcq_empty$1$link4=_cds_wfcq_empty$link1$link4(head$link4, tail$link4);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link4;
  if(!(return_value__cds_wfcq_empty$1$link4 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link4=___cds_wfcq_node_sync_next$link1$link4(&head$link4->node, blocking$link4);
    if(node$link4 == (struct cds_wfcq_node *)18446744073709551615ul && blocking$link4 == 0)
      return (struct cds_wfcq_node *)(void *)-1UL;

    else
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$3$link4 = *((struct cds_wfcq_node * volatile *)&node$link4->next);
      next$link4 = tmp_statement_expression$3$link4;
      if(next$link4 == ((struct cds_wfcq_node *)NULL))
      {
        _cds_wfcq_node_init$link1$link4(&head$link4->node);
        unsigned long int return_value___uatomic_cmpxchg$2$link4;
        return_value___uatomic_cmpxchg$2$link4=__uatomic_cmpxchg$link2$link4((void *)&tail$link4->p, (unsigned long int)node$link4, (unsigned long int)&head$link4->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
        if((struct cds_wfcq_node *)return_value___uatomic_cmpxchg$2$link4 == node$link4)
        {
          if(!(state$link4 == ((signed int *)NULL)))
            *state$link4 = *state$link4 | 1;

          return node$link4;
        }

        next$link4=___cds_wfcq_node_sync_next$link1$link4(node$link4, blocking$link4);
        if(next$link4 == (struct cds_wfcq_node *)18446744073709551615ul && blocking$link4 == 0)
        {
          head$link4->node.next = node$link4;
          return (struct cds_wfcq_node *)(void *)-1UL;
        }

      }

      head$link4->node.next = next$link4;
      return node$link4;
    }
  }
}

// ___cds_wfcq_dequeue_with_state_blocking
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail, signed int *state)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1;
  return_value____cds_wfcq_dequeue_with_state$1=___cds_wfcq_dequeue_with_state(head, tail, state, 1);
  return return_value____cds_wfcq_dequeue_with_state$1;
}

// ___cds_wfcq_dequeue_with_state_blocking$link1
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, signed int *state$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1$link1;
  return_value____cds_wfcq_dequeue_with_state$1$link1=___cds_wfcq_dequeue_with_state$link1(head$link1, tail$link1, state$link1, 1);
  return return_value____cds_wfcq_dequeue_with_state$1$link1;
}

// ___cds_wfcq_dequeue_with_state_blocking$link2
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, signed int *state$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1$link2;
  return_value____cds_wfcq_dequeue_with_state$1$link2=___cds_wfcq_dequeue_with_state$link2(head$link2, tail$link2, state$link2, 1);
  return return_value____cds_wfcq_dequeue_with_state$1$link2;
}

// ___cds_wfcq_dequeue_with_state_blocking$link3
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, signed int *state$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1$link3;
  return_value____cds_wfcq_dequeue_with_state$1$link3=___cds_wfcq_dequeue_with_state$link3(head$link3, tail$link3, state$link3, 1);
  return return_value____cds_wfcq_dequeue_with_state$1$link3;
}

// ___cds_wfcq_dequeue_with_state_blocking$link4
// file urcu/static/wfcqueue.h line 440
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_blocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, signed int *state$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1$link4;
  return_value____cds_wfcq_dequeue_with_state$1$link4=___cds_wfcq_dequeue_with_state$link4(head$link4, tail$link4, state$link4, 1);
  return return_value____cds_wfcq_dequeue_with_state$1$link4;
}

// ___cds_wfcq_dequeue_with_state_nonblocking
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail, signed int *state)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1;
  return_value____cds_wfcq_dequeue_with_state$1=___cds_wfcq_dequeue_with_state(head, tail, state, 0);
  return return_value____cds_wfcq_dequeue_with_state$1;
}

// ___cds_wfcq_dequeue_with_state_nonblocking$link1
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, signed int *state$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1$link1;
  return_value____cds_wfcq_dequeue_with_state$1$link1=___cds_wfcq_dequeue_with_state$link1(head$link1, tail$link1, state$link1, 0);
  return return_value____cds_wfcq_dequeue_with_state$1$link1;
}

// ___cds_wfcq_dequeue_with_state_nonblocking$link2
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, signed int *state$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1$link2;
  return_value____cds_wfcq_dequeue_with_state$1$link2=___cds_wfcq_dequeue_with_state$link2(head$link2, tail$link2, state$link2, 0);
  return return_value____cds_wfcq_dequeue_with_state$1$link2;
}

// ___cds_wfcq_dequeue_with_state_nonblocking$link3
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, signed int *state$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1$link3;
  return_value____cds_wfcq_dequeue_with_state$1$link3=___cds_wfcq_dequeue_with_state$link3(head$link3, tail$link3, state$link3, 0);
  return return_value____cds_wfcq_dequeue_with_state$1$link3;
}

// ___cds_wfcq_dequeue_with_state_nonblocking$link4
// file urcu/static/wfcqueue.h line 466
static inline struct cds_wfcq_node * ___cds_wfcq_dequeue_with_state_nonblocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, signed int *state$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state$1$link4;
  return_value____cds_wfcq_dequeue_with_state$1$link4=___cds_wfcq_dequeue_with_state$link4(head$link4, tail$link4, state$link4, 0);
  return return_value____cds_wfcq_dequeue_with_state$1$link4;
}

// ___cds_wfcq_first
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first(union anonymous$1 u_head, struct cds_wfcq_tail *tail, signed int blocking)
{
  struct __cds_wfcq_head *head = u_head._h;
  struct cds_wfcq_node *node;
  _Bool return_value__cds_wfcq_empty$1;
  return_value__cds_wfcq_empty$1=_cds_wfcq_empty(head, tail);
  if(!(return_value__cds_wfcq_empty$1 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node=___cds_wfcq_node_sync_next(&head->node, blocking);
    return node;
  }
}

// ___cds_wfcq_first$link1
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1(union anonymous$1 u_head$link1, struct cds_wfcq_tail *tail$link1, signed int blocking$link1)
{
  struct __cds_wfcq_head *head$link1 = u_head$link1._h;
  struct cds_wfcq_node *node$link1;
  _Bool return_value__cds_wfcq_empty$1$link1;
  return_value__cds_wfcq_empty$1$link1=_cds_wfcq_empty$link1(head$link1, tail$link1);
  if(!(return_value__cds_wfcq_empty$1$link1 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link1=___cds_wfcq_node_sync_next$link1(&head$link1->node, blocking$link1);
    return node$link1;
  }
}

// ___cds_wfcq_first$link1$link1
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1$link1(union anonymous$1 u_head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, signed int blocking$link1$link1)
{
  struct __cds_wfcq_head *head$link1$link1 = u_head$link1$link1._h;
  struct cds_wfcq_node *node$link1$link1;
  _Bool return_value__cds_wfcq_empty$1$link1$link1;
  return_value__cds_wfcq_empty$1$link1$link1=_cds_wfcq_empty$link1$link1(head$link1$link1, tail$link1$link1);
  if(!(return_value__cds_wfcq_empty$1$link1$link1 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link1$link1=___cds_wfcq_node_sync_next$link1$link1(&head$link1$link1->node, blocking$link1$link1);
    return node$link1$link1;
  }
}

// ___cds_wfcq_first$link1$link2
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1$link2(union anonymous$1 u_head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, signed int blocking$link1$link2)
{
  struct __cds_wfcq_head *head$link1$link2 = u_head$link1$link2._h;
  struct cds_wfcq_node *node$link1$link2;
  _Bool return_value__cds_wfcq_empty$1$link1$link2;
  return_value__cds_wfcq_empty$1$link1$link2=_cds_wfcq_empty$link1$link2(head$link1$link2, tail$link1$link2);
  if(!(return_value__cds_wfcq_empty$1$link1$link2 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link1$link2=___cds_wfcq_node_sync_next$link1$link2(&head$link1$link2->node, blocking$link1$link2);
    return node$link1$link2;
  }
}

// ___cds_wfcq_first$link1$link3
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1$link3(union anonymous$1 u_head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, signed int blocking$link1$link3)
{
  struct __cds_wfcq_head *head$link1$link3 = u_head$link1$link3._h;
  struct cds_wfcq_node *node$link1$link3;
  _Bool return_value__cds_wfcq_empty$1$link1$link3;
  return_value__cds_wfcq_empty$1$link1$link3=_cds_wfcq_empty$link1$link3(head$link1$link3, tail$link1$link3);
  if(!(return_value__cds_wfcq_empty$1$link1$link3 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link1$link3=___cds_wfcq_node_sync_next$link1$link3(&head$link1$link3->node, blocking$link1$link3);
    return node$link1$link3;
  }
}

// ___cds_wfcq_first$link1$link4
// file urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link1$link4(union anonymous$1 u_head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, signed int blocking$link1$link4)
{
  struct __cds_wfcq_head *head$link1$link4 = u_head$link1$link4._h;
  struct cds_wfcq_node *node$link1$link4;
  _Bool return_value__cds_wfcq_empty$1$link1$link4;
  return_value__cds_wfcq_empty$1$link1$link4=_cds_wfcq_empty$link1$link4(head$link1$link4, tail$link1$link4);
  if(!(return_value__cds_wfcq_empty$1$link1$link4 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link1$link4=___cds_wfcq_node_sync_next$link1$link4(&head$link1$link4->node, blocking$link1$link4);
    return node$link1$link4;
  }
}

// ___cds_wfcq_first$link2
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link2(union anonymous$1 u_head$link2, struct cds_wfcq_tail *tail$link2, signed int blocking$link2)
{
  struct __cds_wfcq_head *head$link2 = u_head$link2._h;
  struct cds_wfcq_node *node$link2;
  _Bool return_value__cds_wfcq_empty$1$link2;
  return_value__cds_wfcq_empty$1$link2=_cds_wfcq_empty$link2(head$link2, tail$link2);
  if(!(return_value__cds_wfcq_empty$1$link2 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link2=___cds_wfcq_node_sync_next$link2(&head$link2->node, blocking$link2);
    return node$link2;
  }
}

// ___cds_wfcq_first$link3
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link3(union anonymous$1 u_head$link3, struct cds_wfcq_tail *tail$link3, signed int blocking$link3)
{
  struct __cds_wfcq_head *head$link3 = u_head$link3._h;
  struct cds_wfcq_node *node$link3;
  _Bool return_value__cds_wfcq_empty$1$link3;
  return_value__cds_wfcq_empty$1$link3=_cds_wfcq_empty$link3(head$link3, tail$link3);
  if(!(return_value__cds_wfcq_empty$1$link3 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link3=___cds_wfcq_node_sync_next$link3(&head$link3->node, blocking$link3);
    return node$link3;
  }
}

// ___cds_wfcq_first$link4
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link4(union anonymous$1 u_head$link4, struct cds_wfcq_tail *tail$link4, signed int blocking$link4)
{
  struct __cds_wfcq_head *head$link4 = u_head$link4._h;
  struct cds_wfcq_node *node$link4;
  _Bool return_value__cds_wfcq_empty$1$link4;
  return_value__cds_wfcq_empty$1$link4=_cds_wfcq_empty$link4(head$link4, tail$link4);
  if(!(return_value__cds_wfcq_empty$1$link4 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link4=___cds_wfcq_node_sync_next$link4(&head$link4->node, blocking$link4);
    return node$link4;
  }
}

// ___cds_wfcq_first$link5
// file ./urcu/static/wfcqueue.h line 253
static inline struct cds_wfcq_node * ___cds_wfcq_first$link5(union anonymous$1 u_head$link5, struct cds_wfcq_tail *tail$link5, signed int blocking$link5)
{
  struct __cds_wfcq_head *head$link5 = u_head$link5._h;
  struct cds_wfcq_node *node$link5;
  _Bool return_value__cds_wfcq_empty$1$link5;
  return_value__cds_wfcq_empty$1$link5=_cds_wfcq_empty$link5(head$link5, tail$link5);
  if(!(return_value__cds_wfcq_empty$1$link5 == (_Bool)0))
    return (struct cds_wfcq_node *)(void *)0;

  else
  {
    node$link5=___cds_wfcq_node_sync_next$link5(&head$link5->node, blocking$link5);
    return node$link5;
  }
}

// ___cds_wfcq_first_blocking
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1;
  return_value____cds_wfcq_first$1=___cds_wfcq_first(head, tail, 1);
  return return_value____cds_wfcq_first$1;
}

// ___cds_wfcq_first_blocking$link1
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link1;
  return_value____cds_wfcq_first$1$link1=___cds_wfcq_first$link1(head$link1, tail$link1, 1);
  return return_value____cds_wfcq_first$1$link1;
}

// ___cds_wfcq_first_blocking$link1$link1
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1$link1(union anonymous$1 head$link1$link1, struct cds_wfcq_tail *tail$link1$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link1$link1;
  return_value____cds_wfcq_first$1$link1$link1=___cds_wfcq_first$link1$link1(head$link1$link1, tail$link1$link1, 1);
  return return_value____cds_wfcq_first$1$link1$link1;
}

// ___cds_wfcq_first_blocking$link1$link2
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1$link2(union anonymous$1 head$link1$link2, struct cds_wfcq_tail *tail$link1$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link1$link2;
  return_value____cds_wfcq_first$1$link1$link2=___cds_wfcq_first$link1$link2(head$link1$link2, tail$link1$link2, 1);
  return return_value____cds_wfcq_first$1$link1$link2;
}

// ___cds_wfcq_first_blocking$link1$link3
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1$link3(union anonymous$1 head$link1$link3, struct cds_wfcq_tail *tail$link1$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link1$link3;
  return_value____cds_wfcq_first$1$link1$link3=___cds_wfcq_first$link1$link3(head$link1$link3, tail$link1$link3, 1);
  return return_value____cds_wfcq_first$1$link1$link3;
}

// ___cds_wfcq_first_blocking$link1$link4
// file urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link1$link4(union anonymous$1 head$link1$link4, struct cds_wfcq_tail *tail$link1$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link1$link4;
  return_value____cds_wfcq_first$1$link1$link4=___cds_wfcq_first$link1$link4(head$link1$link4, tail$link1$link4, 1);
  return return_value____cds_wfcq_first$1$link1$link4;
}

// ___cds_wfcq_first_blocking$link2
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link2;
  return_value____cds_wfcq_first$1$link2=___cds_wfcq_first$link2(head$link2, tail$link2, 1);
  return return_value____cds_wfcq_first$1$link2;
}

// ___cds_wfcq_first_blocking$link3
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link3;
  return_value____cds_wfcq_first$1$link3=___cds_wfcq_first$link3(head$link3, tail$link3, 1);
  return return_value____cds_wfcq_first$1$link3;
}

// ___cds_wfcq_first_blocking$link4
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link4;
  return_value____cds_wfcq_first$1$link4=___cds_wfcq_first$link4(head$link4, tail$link4, 1);
  return return_value____cds_wfcq_first$1$link4;
}

// ___cds_wfcq_first_blocking$link5
// file ./urcu/static/wfcqueue.h line 283
static inline struct cds_wfcq_node * ___cds_wfcq_first_blocking$link5(union anonymous$1 head$link5, struct cds_wfcq_tail *tail$link5)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link5;
  return_value____cds_wfcq_first$1$link5=___cds_wfcq_first$link5(head$link5, tail$link5, 1);
  return return_value____cds_wfcq_first$1$link5;
}

// ___cds_wfcq_first_nonblocking
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1;
  return_value____cds_wfcq_first$1=___cds_wfcq_first$link1(head, tail, 0);
  return return_value____cds_wfcq_first$1;
}

// ___cds_wfcq_first_nonblocking$link1
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link1;
  return_value____cds_wfcq_first$1$link1=___cds_wfcq_first$link1$link1(head$link1, tail$link1, 0);
  return return_value____cds_wfcq_first$1$link1;
}

// ___cds_wfcq_first_nonblocking$link2
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link2;
  return_value____cds_wfcq_first$1$link2=___cds_wfcq_first$link1$link2(head$link2, tail$link2, 0);
  return return_value____cds_wfcq_first$1$link2;
}

// ___cds_wfcq_first_nonblocking$link3
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link3;
  return_value____cds_wfcq_first$1$link3=___cds_wfcq_first$link1$link3(head$link3, tail$link3, 0);
  return return_value____cds_wfcq_first$1$link3;
}

// ___cds_wfcq_first_nonblocking$link4
// file urcu/static/wfcqueue.h line 297
static inline struct cds_wfcq_node * ___cds_wfcq_first_nonblocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first$1$link4;
  return_value____cds_wfcq_first$1$link4=___cds_wfcq_first$link1$link4(head$link4, tail$link4, 0);
  return return_value____cds_wfcq_first$1$link4;
}

// ___cds_wfcq_init
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init(struct __cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  _cds_wfcq_node_init$link1(&head->node);
  tail->p = &head->node;
}

// ___cds_wfcq_init$link1
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init$link1(struct __cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1)
{
  _cds_wfcq_node_init$link1$link1(&head$link1->node);
  tail$link1->p = &head$link1->node;
}

// ___cds_wfcq_init$link2
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init$link2(struct __cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2)
{
  _cds_wfcq_node_init$link1$link2(&head$link2->node);
  tail$link2->p = &head$link2->node;
}

// ___cds_wfcq_init$link3
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init$link3(struct __cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3)
{
  _cds_wfcq_node_init$link1$link3(&head$link3->node);
  tail$link3->p = &head$link3->node;
}

// ___cds_wfcq_init$link4
// file urcu/static/wfcqueue.h line 112
static inline void ___cds_wfcq_init$link4(struct __cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4)
{
  _cds_wfcq_node_init$link1$link4(&head$link4->node);
  tail$link4->p = &head$link4->node;
}

// ___cds_wfcq_next
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node, signed int blocking)
{
  struct cds_wfcq_node *next;
  struct cds_wfcq_node * volatile tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((struct cds_wfcq_node * volatile *)&node->next);
  next = tmp_statement_expression$2;
  struct cds_wfcq_node * volatile tmp_statement_expression$1;
  if(next == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1 = *((struct cds_wfcq_node * volatile *)&tail->p);
    if(tmp_statement_expression$1 == node)
      return (struct cds_wfcq_node *)(void *)0;

    next=___cds_wfcq_node_sync_next(node, blocking);
  }

  return next;
}

// ___cds_wfcq_next$link1
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *node$link1, signed int blocking$link1)
{
  struct cds_wfcq_node *next$link1;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link1 = *((struct cds_wfcq_node * volatile *)&node$link1->next);
  next$link1 = tmp_statement_expression$2$link1;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1;
  if(next$link1 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1 = *((struct cds_wfcq_node * volatile *)&tail$link1->p);
    if(tmp_statement_expression$1$link1 == node$link1)
      return (struct cds_wfcq_node *)(void *)0;

    next$link1=___cds_wfcq_node_sync_next$link1(node$link1, blocking$link1);
  }

  return next$link1;
}

// ___cds_wfcq_next$link1$link1
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1$link1(union anonymous$1 head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, struct cds_wfcq_node *node$link1$link1, signed int blocking$link1$link1)
{
  struct cds_wfcq_node *next$link1$link1;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link1$link1 = *((struct cds_wfcq_node * volatile *)&node$link1$link1->next);
  next$link1$link1 = tmp_statement_expression$2$link1$link1;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link1;
  if(next$link1$link1 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link1 = *((struct cds_wfcq_node * volatile *)&tail$link1$link1->p);
    if(tmp_statement_expression$1$link1$link1 == node$link1$link1)
      return (struct cds_wfcq_node *)(void *)0;

    next$link1$link1=___cds_wfcq_node_sync_next$link1$link1(node$link1$link1, blocking$link1$link1);
  }

  return next$link1$link1;
}

// ___cds_wfcq_next$link1$link2
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1$link2(union anonymous$1 head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, struct cds_wfcq_node *node$link1$link2, signed int blocking$link1$link2)
{
  struct cds_wfcq_node *next$link1$link2;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link1$link2 = *((struct cds_wfcq_node * volatile *)&node$link1$link2->next);
  next$link1$link2 = tmp_statement_expression$2$link1$link2;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link2;
  if(next$link1$link2 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link2 = *((struct cds_wfcq_node * volatile *)&tail$link1$link2->p);
    if(tmp_statement_expression$1$link1$link2 == node$link1$link2)
      return (struct cds_wfcq_node *)(void *)0;

    next$link1$link2=___cds_wfcq_node_sync_next$link1$link2(node$link1$link2, blocking$link1$link2);
  }

  return next$link1$link2;
}

// ___cds_wfcq_next$link1$link3
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1$link3(union anonymous$1 head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, struct cds_wfcq_node *node$link1$link3, signed int blocking$link1$link3)
{
  struct cds_wfcq_node *next$link1$link3;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link1$link3 = *((struct cds_wfcq_node * volatile *)&node$link1$link3->next);
  next$link1$link3 = tmp_statement_expression$2$link1$link3;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link3;
  if(next$link1$link3 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link3 = *((struct cds_wfcq_node * volatile *)&tail$link1$link3->p);
    if(tmp_statement_expression$1$link1$link3 == node$link1$link3)
      return (struct cds_wfcq_node *)(void *)0;

    next$link1$link3=___cds_wfcq_node_sync_next$link1$link3(node$link1$link3, blocking$link1$link3);
  }

  return next$link1$link3;
}

// ___cds_wfcq_next$link1$link4
// file urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link1$link4(union anonymous$1 head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, struct cds_wfcq_node *node$link1$link4, signed int blocking$link1$link4)
{
  struct cds_wfcq_node *next$link1$link4;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link1$link4 = *((struct cds_wfcq_node * volatile *)&node$link1$link4->next);
  next$link1$link4 = tmp_statement_expression$2$link1$link4;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link4;
  if(next$link1$link4 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link4 = *((struct cds_wfcq_node * volatile *)&tail$link1$link4->p);
    if(tmp_statement_expression$1$link1$link4 == node$link1$link4)
      return (struct cds_wfcq_node *)(void *)0;

    next$link1$link4=___cds_wfcq_node_sync_next$link1$link4(node$link1$link4, blocking$link1$link4);
  }

  return next$link1$link4;
}

// ___cds_wfcq_next$link2
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *node$link2, signed int blocking$link2)
{
  struct cds_wfcq_node *next$link2;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link2 = *((struct cds_wfcq_node * volatile *)&node$link2->next);
  next$link2 = tmp_statement_expression$2$link2;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link2;
  if(next$link2 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link2 = *((struct cds_wfcq_node * volatile *)&tail$link2->p);
    if(tmp_statement_expression$1$link2 == node$link2)
      return (struct cds_wfcq_node *)(void *)0;

    next$link2=___cds_wfcq_node_sync_next$link2(node$link2, blocking$link2);
  }

  return next$link2;
}

// ___cds_wfcq_next$link3
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *node$link3, signed int blocking$link3)
{
  struct cds_wfcq_node *next$link3;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link3 = *((struct cds_wfcq_node * volatile *)&node$link3->next);
  next$link3 = tmp_statement_expression$2$link3;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link3;
  if(next$link3 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link3 = *((struct cds_wfcq_node * volatile *)&tail$link3->p);
    if(tmp_statement_expression$1$link3 == node$link3)
      return (struct cds_wfcq_node *)(void *)0;

    next$link3=___cds_wfcq_node_sync_next$link3(node$link3, blocking$link3);
  }

  return next$link3;
}

// ___cds_wfcq_next$link4
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *node$link4, signed int blocking$link4)
{
  struct cds_wfcq_node *next$link4;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link4 = *((struct cds_wfcq_node * volatile *)&node$link4->next);
  next$link4 = tmp_statement_expression$2$link4;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link4;
  if(next$link4 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link4 = *((struct cds_wfcq_node * volatile *)&tail$link4->p);
    if(tmp_statement_expression$1$link4 == node$link4)
      return (struct cds_wfcq_node *)(void *)0;

    next$link4=___cds_wfcq_node_sync_next$link4(node$link4, blocking$link4);
  }

  return next$link4;
}

// ___cds_wfcq_next$link5
// file ./urcu/static/wfcqueue.h line 304
static inline struct cds_wfcq_node * ___cds_wfcq_next$link5(union anonymous$1 head$link5, struct cds_wfcq_tail *tail$link5, struct cds_wfcq_node *node$link5, signed int blocking$link5)
{
  struct cds_wfcq_node *next$link5;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link5;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link5 = *((struct cds_wfcq_node * volatile *)&node$link5->next);
  next$link5 = tmp_statement_expression$2$link5;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link5;
  if(next$link5 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link5 = *((struct cds_wfcq_node * volatile *)&tail$link5->p);
    if(tmp_statement_expression$1$link5 == node$link5)
      return (struct cds_wfcq_node *)(void *)0;

    next$link5=___cds_wfcq_node_sync_next$link5(node$link5, blocking$link5);
  }

  return next$link5;
}

// ___cds_wfcq_next_blocking
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1;
  return_value____cds_wfcq_next$1=___cds_wfcq_next(head, tail, node, 1);
  return return_value____cds_wfcq_next$1;
}

// ___cds_wfcq_next_blocking$link1
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *node$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link1;
  return_value____cds_wfcq_next$1$link1=___cds_wfcq_next$link1(head$link1, tail$link1, node$link1, 1);
  return return_value____cds_wfcq_next$1$link1;
}

// ___cds_wfcq_next_blocking$link1$link1
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1$link1(union anonymous$1 head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, struct cds_wfcq_node *node$link1$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link1$link1;
  return_value____cds_wfcq_next$1$link1$link1=___cds_wfcq_next$link1$link1(head$link1$link1, tail$link1$link1, node$link1$link1, 1);
  return return_value____cds_wfcq_next$1$link1$link1;
}

// ___cds_wfcq_next_blocking$link1$link2
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1$link2(union anonymous$1 head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, struct cds_wfcq_node *node$link1$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link1$link2;
  return_value____cds_wfcq_next$1$link1$link2=___cds_wfcq_next$link1$link2(head$link1$link2, tail$link1$link2, node$link1$link2, 1);
  return return_value____cds_wfcq_next$1$link1$link2;
}

// ___cds_wfcq_next_blocking$link1$link3
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1$link3(union anonymous$1 head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, struct cds_wfcq_node *node$link1$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link1$link3;
  return_value____cds_wfcq_next$1$link1$link3=___cds_wfcq_next$link1$link3(head$link1$link3, tail$link1$link3, node$link1$link3, 1);
  return return_value____cds_wfcq_next$1$link1$link3;
}

// ___cds_wfcq_next_blocking$link1$link4
// file urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link1$link4(union anonymous$1 head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, struct cds_wfcq_node *node$link1$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link1$link4;
  return_value____cds_wfcq_next$1$link1$link4=___cds_wfcq_next$link1$link4(head$link1$link4, tail$link1$link4, node$link1$link4, 1);
  return return_value____cds_wfcq_next$1$link1$link4;
}

// ___cds_wfcq_next_blocking$link2
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *node$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link2;
  return_value____cds_wfcq_next$1$link2=___cds_wfcq_next$link2(head$link2, tail$link2, node$link2, 1);
  return return_value____cds_wfcq_next$1$link2;
}

// ___cds_wfcq_next_blocking$link3
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *node$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link3;
  return_value____cds_wfcq_next$1$link3=___cds_wfcq_next$link3(head$link3, tail$link3, node$link3, 1);
  return return_value____cds_wfcq_next$1$link3;
}

// ___cds_wfcq_next_blocking$link4
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *node$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link4;
  return_value____cds_wfcq_next$1$link4=___cds_wfcq_next$link4(head$link4, tail$link4, node$link4, 1);
  return return_value____cds_wfcq_next$1$link4;
}

// ___cds_wfcq_next_blocking$link5
// file ./urcu/static/wfcqueue.h line 345
static inline struct cds_wfcq_node * ___cds_wfcq_next_blocking$link5(union anonymous$1 head$link5, struct cds_wfcq_tail *tail$link5, struct cds_wfcq_node *node$link5)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link5;
  return_value____cds_wfcq_next$1$link5=___cds_wfcq_next$link5(head$link5, tail$link5, node$link5, 1);
  return return_value____cds_wfcq_next$1$link5;
}

// ___cds_wfcq_next_nonblocking
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1;
  return_value____cds_wfcq_next$1=___cds_wfcq_next$link1(head, tail, node, 0);
  return return_value____cds_wfcq_next$1;
}

// ___cds_wfcq_next_nonblocking$link1
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *node$link1)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link1;
  return_value____cds_wfcq_next$1$link1=___cds_wfcq_next$link1$link1(head$link1, tail$link1, node$link1, 0);
  return return_value____cds_wfcq_next$1$link1;
}

// ___cds_wfcq_next_nonblocking$link2
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *node$link2)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link2;
  return_value____cds_wfcq_next$1$link2=___cds_wfcq_next$link1$link2(head$link2, tail$link2, node$link2, 0);
  return return_value____cds_wfcq_next$1$link2;
}

// ___cds_wfcq_next_nonblocking$link3
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *node$link3)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link3;
  return_value____cds_wfcq_next$1$link3=___cds_wfcq_next$link1$link3(head$link3, tail$link3, node$link3, 0);
  return return_value____cds_wfcq_next$1$link3;
}

// ___cds_wfcq_next_nonblocking$link4
// file urcu/static/wfcqueue.h line 359
static inline struct cds_wfcq_node * ___cds_wfcq_next_nonblocking$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *node$link4)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next$1$link4;
  return_value____cds_wfcq_next$1$link4=___cds_wfcq_next$link1$link4(head$link4, tail$link4, node$link4, 0);
  return return_value____cds_wfcq_next$1$link4;
}

// ___cds_wfcq_node_sync_next
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next(struct cds_wfcq_node *node, signed int blocking)
{
  struct cds_wfcq_node *next;
  signed int attempt = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1 = *((struct cds_wfcq_node * volatile *)&node->next);
    next = tmp_statement_expression$1;
    if(!(next == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2;
    return_value____cds_wfcq_busy_wait$2=___cds_wfcq_busy_wait(&attempt, blocking);
    if(!(return_value____cds_wfcq_busy_wait$2 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next;
}

// ___cds_wfcq_node_sync_next$link1
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1(struct cds_wfcq_node *node$link1, signed int blocking$link1)
{
  struct cds_wfcq_node *next$link1;
  signed int attempt$link1 = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1 = *((struct cds_wfcq_node * volatile *)&node$link1->next);
    next$link1 = tmp_statement_expression$1$link1;
    if(!(next$link1 == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2$link1;
    return_value____cds_wfcq_busy_wait$2$link1=___cds_wfcq_busy_wait$link1(&attempt$link1, blocking$link1);
    if(!(return_value____cds_wfcq_busy_wait$2$link1 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next$link1;
}

// ___cds_wfcq_node_sync_next$link1$link1
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1$link1(struct cds_wfcq_node *node$link1$link1, signed int blocking$link1$link1)
{
  struct cds_wfcq_node *next$link1$link1;
  signed int attempt$link1$link1 = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link1 = *((struct cds_wfcq_node * volatile *)&node$link1$link1->next);
    next$link1$link1 = tmp_statement_expression$1$link1$link1;
    if(!(next$link1$link1 == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2$link1$link1;
    return_value____cds_wfcq_busy_wait$2$link1$link1=___cds_wfcq_busy_wait$link1$link1(&attempt$link1$link1, blocking$link1$link1);
    if(!(return_value____cds_wfcq_busy_wait$2$link1$link1 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next$link1$link1;
}

// ___cds_wfcq_node_sync_next$link1$link2
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1$link2(struct cds_wfcq_node *node$link1$link2, signed int blocking$link1$link2)
{
  struct cds_wfcq_node *next$link1$link2;
  signed int attempt$link1$link2 = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link2;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link2 = *((struct cds_wfcq_node * volatile *)&node$link1$link2->next);
    next$link1$link2 = tmp_statement_expression$1$link1$link2;
    if(!(next$link1$link2 == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2$link1$link2;
    return_value____cds_wfcq_busy_wait$2$link1$link2=___cds_wfcq_busy_wait$link1$link2(&attempt$link1$link2, blocking$link1$link2);
    if(!(return_value____cds_wfcq_busy_wait$2$link1$link2 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next$link1$link2;
}

// ___cds_wfcq_node_sync_next$link1$link3
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1$link3(struct cds_wfcq_node *node$link1$link3, signed int blocking$link1$link3)
{
  struct cds_wfcq_node *next$link1$link3;
  signed int attempt$link1$link3 = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link3;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link3 = *((struct cds_wfcq_node * volatile *)&node$link1$link3->next);
    next$link1$link3 = tmp_statement_expression$1$link1$link3;
    if(!(next$link1$link3 == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2$link1$link3;
    return_value____cds_wfcq_busy_wait$2$link1$link3=___cds_wfcq_busy_wait$link1$link3(&attempt$link1$link3, blocking$link1$link3);
    if(!(return_value____cds_wfcq_busy_wait$2$link1$link3 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next$link1$link3;
}

// ___cds_wfcq_node_sync_next$link1$link4
// file urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link1$link4(struct cds_wfcq_node *node$link1$link4, signed int blocking$link1$link4)
{
  struct cds_wfcq_node *next$link1$link4;
  signed int attempt$link1$link4 = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link4;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link4 = *((struct cds_wfcq_node * volatile *)&node$link1$link4->next);
    next$link1$link4 = tmp_statement_expression$1$link1$link4;
    if(!(next$link1$link4 == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2$link1$link4;
    return_value____cds_wfcq_busy_wait$2$link1$link4=___cds_wfcq_busy_wait$link1$link4(&attempt$link1$link4, blocking$link1$link4);
    if(!(return_value____cds_wfcq_busy_wait$2$link1$link4 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next$link1$link4;
}

// ___cds_wfcq_node_sync_next$link2
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link2(struct cds_wfcq_node *node$link2, signed int blocking$link2)
{
  struct cds_wfcq_node *next$link2;
  signed int attempt$link2 = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link2;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link2 = *((struct cds_wfcq_node * volatile *)&node$link2->next);
    next$link2 = tmp_statement_expression$1$link2;
    if(!(next$link2 == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2$link2;
    return_value____cds_wfcq_busy_wait$2$link2=___cds_wfcq_busy_wait$link2(&attempt$link2, blocking$link2);
    if(!(return_value____cds_wfcq_busy_wait$2$link2 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next$link2;
}

// ___cds_wfcq_node_sync_next$link3
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link3(struct cds_wfcq_node *node$link3, signed int blocking$link3)
{
  struct cds_wfcq_node *next$link3;
  signed int attempt$link3 = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link3;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link3 = *((struct cds_wfcq_node * volatile *)&node$link3->next);
    next$link3 = tmp_statement_expression$1$link3;
    if(!(next$link3 == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2$link3;
    return_value____cds_wfcq_busy_wait$2$link3=___cds_wfcq_busy_wait$link3(&attempt$link3, blocking$link3);
    if(!(return_value____cds_wfcq_busy_wait$2$link3 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next$link3;
}

// ___cds_wfcq_node_sync_next$link4
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link4(struct cds_wfcq_node *node$link4, signed int blocking$link4)
{
  struct cds_wfcq_node *next$link4;
  signed int attempt$link4 = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link4;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link4 = *((struct cds_wfcq_node * volatile *)&node$link4->next);
    next$link4 = tmp_statement_expression$1$link4;
    if(!(next$link4 == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2$link4;
    return_value____cds_wfcq_busy_wait$2$link4=___cds_wfcq_busy_wait$link4(&attempt$link4, blocking$link4);
    if(!(return_value____cds_wfcq_busy_wait$2$link4 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next$link4;
}

// ___cds_wfcq_node_sync_next$link5
// file ./urcu/static/wfcqueue.h line 236
static inline struct cds_wfcq_node * ___cds_wfcq_node_sync_next$link5(struct cds_wfcq_node *node$link5, signed int blocking$link5)
{
  struct cds_wfcq_node *next$link5;
  signed int attempt$link5 = 0;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link5;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link5 = *((struct cds_wfcq_node * volatile *)&node$link5->next);
    next$link5 = tmp_statement_expression$1$link5;
    if(!(next$link5 == ((struct cds_wfcq_node *)NULL)))
      break;

    _Bool return_value____cds_wfcq_busy_wait$2$link5;
    return_value____cds_wfcq_busy_wait$2$link5=___cds_wfcq_busy_wait$link5(&attempt$link5, blocking$link5);
    if(!(return_value____cds_wfcq_busy_wait$2$link5 == (_Bool)0))
      return (struct cds_wfcq_node *)(void *)-1UL;

  }
  while((_Bool)1);
  return next$link5;
}

// ___cds_wfcq_splice
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice(union anonymous$1 u_dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 u_src_q_head, struct cds_wfcq_tail *src_q_tail, signed int blocking)
{
  struct __cds_wfcq_head *dest_q_head = u_dest_q_head._h;
  struct __cds_wfcq_head *src_q_head = u_src_q_head._h;
  struct cds_wfcq_node *head;
  struct cds_wfcq_node *tail;
  signed int attempt = 0;
  _Bool return_value__cds_wfcq_empty$1;
  return_value__cds_wfcq_empty$1=_cds_wfcq_empty(src_q_head, src_q_tail);
  struct cds_wfcq_node * volatile tmp_statement_expression$3;
  if(!(return_value__cds_wfcq_empty$1 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2;
      return_value___uatomic_exchange$2=__uatomic_exchange((void *)&src_q_head->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head = (struct cds_wfcq_node *)return_value___uatomic_exchange$2;
      if(!(head == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3 = *((struct cds_wfcq_node * volatile *)&src_q_tail->p);
      if(tmp_statement_expression$3 == &src_q_head->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4;
      return_value____cds_wfcq_busy_wait$4=___cds_wfcq_busy_wait(&attempt, blocking);
      if(!(return_value____cds_wfcq_busy_wait$4 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5;
    return_value___uatomic_exchange$5=__uatomic_exchange((void *)&src_q_tail->p, (unsigned long int)&src_q_head->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail = (struct cds_wfcq_node *)return_value___uatomic_exchange$5;
    _Bool return_value____cds_wfcq_append$6;
    return_value____cds_wfcq_append$6=___cds_wfcq_append(dest_q_head, dest_q_tail, head, tail);
    if(!(return_value____cds_wfcq_append$6 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice$link1
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1(union anonymous$1 u_dest_q_head$link1, struct cds_wfcq_tail *dest_q_tail$link1, union anonymous$1 u_src_q_head$link1, struct cds_wfcq_tail *src_q_tail$link1, signed int blocking$link1)
{
  struct __cds_wfcq_head *dest_q_head$link1 = u_dest_q_head$link1._h;
  struct __cds_wfcq_head *src_q_head$link1 = u_src_q_head$link1._h;
  struct cds_wfcq_node *head$link1;
  struct cds_wfcq_node *tail$link1;
  signed int attempt$link1 = 0;
  _Bool return_value__cds_wfcq_empty$1$link1;
  return_value__cds_wfcq_empty$1$link1=_cds_wfcq_empty$link1(src_q_head$link1, src_q_tail$link1);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link1;
  if(!(return_value__cds_wfcq_empty$1$link1 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2$link1;
      return_value___uatomic_exchange$2$link1=__uatomic_exchange$link1$link1((void *)&src_q_head$link1->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head$link1 = (struct cds_wfcq_node *)return_value___uatomic_exchange$2$link1;
      if(!(head$link1 == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3$link1 = *((struct cds_wfcq_node * volatile *)&src_q_tail$link1->p);
      if(tmp_statement_expression$3$link1 == &src_q_head$link1->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4$link1;
      return_value____cds_wfcq_busy_wait$4$link1=___cds_wfcq_busy_wait$link1(&attempt$link1, blocking$link1);
      if(!(return_value____cds_wfcq_busy_wait$4$link1 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5$link1;
    return_value___uatomic_exchange$5$link1=__uatomic_exchange$link1$link1((void *)&src_q_tail$link1->p, (unsigned long int)&src_q_head$link1->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail$link1 = (struct cds_wfcq_node *)return_value___uatomic_exchange$5$link1;
    _Bool return_value____cds_wfcq_append$6$link1;
    return_value____cds_wfcq_append$6$link1=___cds_wfcq_append$link1(dest_q_head$link1, dest_q_tail$link1, head$link1, tail$link1);
    if(!(return_value____cds_wfcq_append$6$link1 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice$link1$link1
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1$link1(union anonymous$1 u_dest_q_head$link1$link1, struct cds_wfcq_tail *dest_q_tail$link1$link1, union anonymous$1 u_src_q_head$link1$link1, struct cds_wfcq_tail *src_q_tail$link1$link1, signed int blocking$link1$link1)
{
  struct __cds_wfcq_head *dest_q_head$link1$link1 = u_dest_q_head$link1$link1._h;
  struct __cds_wfcq_head *src_q_head$link1$link1 = u_src_q_head$link1$link1._h;
  struct cds_wfcq_node *head$link1$link1;
  struct cds_wfcq_node *tail$link1$link1;
  signed int attempt$link1$link1 = 0;
  _Bool return_value__cds_wfcq_empty$1$link1$link1;
  return_value__cds_wfcq_empty$1$link1$link1=_cds_wfcq_empty$link1$link1(src_q_head$link1$link1, src_q_tail$link1$link1);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link1$link1;
  if(!(return_value__cds_wfcq_empty$1$link1$link1 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2$link1$link1;
      return_value___uatomic_exchange$2$link1$link1=__uatomic_exchange$link1$link1$link1((void *)&src_q_head$link1$link1->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head$link1$link1 = (struct cds_wfcq_node *)return_value___uatomic_exchange$2$link1$link1;
      if(!(head$link1$link1 == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3$link1$link1 = *((struct cds_wfcq_node * volatile *)&src_q_tail$link1$link1->p);
      if(tmp_statement_expression$3$link1$link1 == &src_q_head$link1$link1->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4$link1$link1;
      return_value____cds_wfcq_busy_wait$4$link1$link1=___cds_wfcq_busy_wait$link1$link1(&attempt$link1$link1, blocking$link1$link1);
      if(!(return_value____cds_wfcq_busy_wait$4$link1$link1 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5$link1$link1;
    return_value___uatomic_exchange$5$link1$link1=__uatomic_exchange$link1$link1$link1((void *)&src_q_tail$link1$link1->p, (unsigned long int)&src_q_head$link1$link1->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail$link1$link1 = (struct cds_wfcq_node *)return_value___uatomic_exchange$5$link1$link1;
    _Bool return_value____cds_wfcq_append$6$link1$link1;
    return_value____cds_wfcq_append$6$link1$link1=___cds_wfcq_append$link1$link1(dest_q_head$link1$link1, dest_q_tail$link1$link1, head$link1$link1, tail$link1$link1);
    if(!(return_value____cds_wfcq_append$6$link1$link1 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice$link1$link2
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1$link2(union anonymous$1 u_dest_q_head$link1$link2, struct cds_wfcq_tail *dest_q_tail$link1$link2, union anonymous$1 u_src_q_head$link1$link2, struct cds_wfcq_tail *src_q_tail$link1$link2, signed int blocking$link1$link2)
{
  struct __cds_wfcq_head *dest_q_head$link1$link2 = u_dest_q_head$link1$link2._h;
  struct __cds_wfcq_head *src_q_head$link1$link2 = u_src_q_head$link1$link2._h;
  struct cds_wfcq_node *head$link1$link2;
  struct cds_wfcq_node *tail$link1$link2;
  signed int attempt$link1$link2 = 0;
  _Bool return_value__cds_wfcq_empty$1$link1$link2;
  return_value__cds_wfcq_empty$1$link1$link2=_cds_wfcq_empty$link1$link2(src_q_head$link1$link2, src_q_tail$link1$link2);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link1$link2;
  if(!(return_value__cds_wfcq_empty$1$link1$link2 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2$link1$link2;
      return_value___uatomic_exchange$2$link1$link2=__uatomic_exchange$link1$link1$link2((void *)&src_q_head$link1$link2->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head$link1$link2 = (struct cds_wfcq_node *)return_value___uatomic_exchange$2$link1$link2;
      if(!(head$link1$link2 == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3$link1$link2 = *((struct cds_wfcq_node * volatile *)&src_q_tail$link1$link2->p);
      if(tmp_statement_expression$3$link1$link2 == &src_q_head$link1$link2->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4$link1$link2;
      return_value____cds_wfcq_busy_wait$4$link1$link2=___cds_wfcq_busy_wait$link1$link2(&attempt$link1$link2, blocking$link1$link2);
      if(!(return_value____cds_wfcq_busy_wait$4$link1$link2 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5$link1$link2;
    return_value___uatomic_exchange$5$link1$link2=__uatomic_exchange$link1$link1$link2((void *)&src_q_tail$link1$link2->p, (unsigned long int)&src_q_head$link1$link2->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail$link1$link2 = (struct cds_wfcq_node *)return_value___uatomic_exchange$5$link1$link2;
    _Bool return_value____cds_wfcq_append$6$link1$link2;
    return_value____cds_wfcq_append$6$link1$link2=___cds_wfcq_append$link1$link2(dest_q_head$link1$link2, dest_q_tail$link1$link2, head$link1$link2, tail$link1$link2);
    if(!(return_value____cds_wfcq_append$6$link1$link2 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice$link1$link3
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1$link3(union anonymous$1 u_dest_q_head$link1$link3, struct cds_wfcq_tail *dest_q_tail$link1$link3, union anonymous$1 u_src_q_head$link1$link3, struct cds_wfcq_tail *src_q_tail$link1$link3, signed int blocking$link1$link3)
{
  struct __cds_wfcq_head *dest_q_head$link1$link3 = u_dest_q_head$link1$link3._h;
  struct __cds_wfcq_head *src_q_head$link1$link3 = u_src_q_head$link1$link3._h;
  struct cds_wfcq_node *head$link1$link3;
  struct cds_wfcq_node *tail$link1$link3;
  signed int attempt$link1$link3 = 0;
  _Bool return_value__cds_wfcq_empty$1$link1$link3;
  return_value__cds_wfcq_empty$1$link1$link3=_cds_wfcq_empty$link1$link3(src_q_head$link1$link3, src_q_tail$link1$link3);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link1$link3;
  if(!(return_value__cds_wfcq_empty$1$link1$link3 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2$link1$link3;
      return_value___uatomic_exchange$2$link1$link3=__uatomic_exchange$link1$link1$link3((void *)&src_q_head$link1$link3->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head$link1$link3 = (struct cds_wfcq_node *)return_value___uatomic_exchange$2$link1$link3;
      if(!(head$link1$link3 == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3$link1$link3 = *((struct cds_wfcq_node * volatile *)&src_q_tail$link1$link3->p);
      if(tmp_statement_expression$3$link1$link3 == &src_q_head$link1$link3->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4$link1$link3;
      return_value____cds_wfcq_busy_wait$4$link1$link3=___cds_wfcq_busy_wait$link1$link3(&attempt$link1$link3, blocking$link1$link3);
      if(!(return_value____cds_wfcq_busy_wait$4$link1$link3 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5$link1$link3;
    return_value___uatomic_exchange$5$link1$link3=__uatomic_exchange$link1$link1$link3((void *)&src_q_tail$link1$link3->p, (unsigned long int)&src_q_head$link1$link3->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail$link1$link3 = (struct cds_wfcq_node *)return_value___uatomic_exchange$5$link1$link3;
    _Bool return_value____cds_wfcq_append$6$link1$link3;
    return_value____cds_wfcq_append$6$link1$link3=___cds_wfcq_append$link1$link3(dest_q_head$link1$link3, dest_q_tail$link1$link3, head$link1$link3, tail$link1$link3);
    if(!(return_value____cds_wfcq_append$6$link1$link3 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice$link1$link4
// file urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link1$link4(union anonymous$1 u_dest_q_head$link1$link4, struct cds_wfcq_tail *dest_q_tail$link1$link4, union anonymous$1 u_src_q_head$link1$link4, struct cds_wfcq_tail *src_q_tail$link1$link4, signed int blocking$link1$link4)
{
  struct __cds_wfcq_head *dest_q_head$link1$link4 = u_dest_q_head$link1$link4._h;
  struct __cds_wfcq_head *src_q_head$link1$link4 = u_src_q_head$link1$link4._h;
  struct cds_wfcq_node *head$link1$link4;
  struct cds_wfcq_node *tail$link1$link4;
  signed int attempt$link1$link4 = 0;
  _Bool return_value__cds_wfcq_empty$1$link1$link4;
  return_value__cds_wfcq_empty$1$link1$link4=_cds_wfcq_empty$link1$link4(src_q_head$link1$link4, src_q_tail$link1$link4);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link1$link4;
  if(!(return_value__cds_wfcq_empty$1$link1$link4 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2$link1$link4;
      return_value___uatomic_exchange$2$link1$link4=__uatomic_exchange$link1$link1$link4((void *)&src_q_head$link1$link4->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head$link1$link4 = (struct cds_wfcq_node *)return_value___uatomic_exchange$2$link1$link4;
      if(!(head$link1$link4 == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3$link1$link4 = *((struct cds_wfcq_node * volatile *)&src_q_tail$link1$link4->p);
      if(tmp_statement_expression$3$link1$link4 == &src_q_head$link1$link4->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4$link1$link4;
      return_value____cds_wfcq_busy_wait$4$link1$link4=___cds_wfcq_busy_wait$link1$link4(&attempt$link1$link4, blocking$link1$link4);
      if(!(return_value____cds_wfcq_busy_wait$4$link1$link4 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5$link1$link4;
    return_value___uatomic_exchange$5$link1$link4=__uatomic_exchange$link1$link1$link4((void *)&src_q_tail$link1$link4->p, (unsigned long int)&src_q_head$link1$link4->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail$link1$link4 = (struct cds_wfcq_node *)return_value___uatomic_exchange$5$link1$link4;
    _Bool return_value____cds_wfcq_append$6$link1$link4;
    return_value____cds_wfcq_append$6$link1$link4=___cds_wfcq_append$link1$link4(dest_q_head$link1$link4, dest_q_tail$link1$link4, head$link1$link4, tail$link1$link4);
    if(!(return_value____cds_wfcq_append$6$link1$link4 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice$link2
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link2(union anonymous$1 u_dest_q_head$link2, struct cds_wfcq_tail *dest_q_tail$link2, union anonymous$1 u_src_q_head$link2, struct cds_wfcq_tail *src_q_tail$link2, signed int blocking$link2)
{
  struct __cds_wfcq_head *dest_q_head$link2 = u_dest_q_head$link2._h;
  struct __cds_wfcq_head *src_q_head$link2 = u_src_q_head$link2._h;
  struct cds_wfcq_node *head$link2;
  struct cds_wfcq_node *tail$link2;
  signed int attempt$link2 = 0;
  _Bool return_value__cds_wfcq_empty$1$link2;
  return_value__cds_wfcq_empty$1$link2=_cds_wfcq_empty$link2(src_q_head$link2, src_q_tail$link2);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link2;
  if(!(return_value__cds_wfcq_empty$1$link2 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2$link2;
      return_value___uatomic_exchange$2$link2=__uatomic_exchange$link4((void *)&src_q_head$link2->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head$link2 = (struct cds_wfcq_node *)return_value___uatomic_exchange$2$link2;
      if(!(head$link2 == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3$link2 = *((struct cds_wfcq_node * volatile *)&src_q_tail$link2->p);
      if(tmp_statement_expression$3$link2 == &src_q_head$link2->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4$link2;
      return_value____cds_wfcq_busy_wait$4$link2=___cds_wfcq_busy_wait$link2(&attempt$link2, blocking$link2);
      if(!(return_value____cds_wfcq_busy_wait$4$link2 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5$link2;
    return_value___uatomic_exchange$5$link2=__uatomic_exchange$link4((void *)&src_q_tail$link2->p, (unsigned long int)&src_q_head$link2->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail$link2 = (struct cds_wfcq_node *)return_value___uatomic_exchange$5$link2;
    _Bool return_value____cds_wfcq_append$6$link2;
    return_value____cds_wfcq_append$6$link2=___cds_wfcq_append$link2(dest_q_head$link2, dest_q_tail$link2, head$link2, tail$link2);
    if(!(return_value____cds_wfcq_append$6$link2 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice$link3
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link3(union anonymous$1 u_dest_q_head$link3, struct cds_wfcq_tail *dest_q_tail$link3, union anonymous$1 u_src_q_head$link3, struct cds_wfcq_tail *src_q_tail$link3, signed int blocking$link3)
{
  struct __cds_wfcq_head *dest_q_head$link3 = u_dest_q_head$link3._h;
  struct __cds_wfcq_head *src_q_head$link3 = u_src_q_head$link3._h;
  struct cds_wfcq_node *head$link3;
  struct cds_wfcq_node *tail$link3;
  signed int attempt$link3 = 0;
  _Bool return_value__cds_wfcq_empty$1$link3;
  return_value__cds_wfcq_empty$1$link3=_cds_wfcq_empty$link3(src_q_head$link3, src_q_tail$link3);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link3;
  if(!(return_value__cds_wfcq_empty$1$link3 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2$link3;
      return_value___uatomic_exchange$2$link3=__uatomic_exchange$link5((void *)&src_q_head$link3->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head$link3 = (struct cds_wfcq_node *)return_value___uatomic_exchange$2$link3;
      if(!(head$link3 == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3$link3 = *((struct cds_wfcq_node * volatile *)&src_q_tail$link3->p);
      if(tmp_statement_expression$3$link3 == &src_q_head$link3->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4$link3;
      return_value____cds_wfcq_busy_wait$4$link3=___cds_wfcq_busy_wait$link3(&attempt$link3, blocking$link3);
      if(!(return_value____cds_wfcq_busy_wait$4$link3 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5$link3;
    return_value___uatomic_exchange$5$link3=__uatomic_exchange$link5((void *)&src_q_tail$link3->p, (unsigned long int)&src_q_head$link3->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail$link3 = (struct cds_wfcq_node *)return_value___uatomic_exchange$5$link3;
    _Bool return_value____cds_wfcq_append$6$link3;
    return_value____cds_wfcq_append$6$link3=___cds_wfcq_append$link3(dest_q_head$link3, dest_q_tail$link3, head$link3, tail$link3);
    if(!(return_value____cds_wfcq_append$6$link3 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice$link4
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link4(union anonymous$1 u_dest_q_head$link4, struct cds_wfcq_tail *dest_q_tail$link4, union anonymous$1 u_src_q_head$link4, struct cds_wfcq_tail *src_q_tail$link4, signed int blocking$link4)
{
  struct __cds_wfcq_head *dest_q_head$link4 = u_dest_q_head$link4._h;
  struct __cds_wfcq_head *src_q_head$link4 = u_src_q_head$link4._h;
  struct cds_wfcq_node *head$link4;
  struct cds_wfcq_node *tail$link4;
  signed int attempt$link4 = 0;
  _Bool return_value__cds_wfcq_empty$1$link4;
  return_value__cds_wfcq_empty$1$link4=_cds_wfcq_empty$link4(src_q_head$link4, src_q_tail$link4);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link4;
  if(!(return_value__cds_wfcq_empty$1$link4 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2$link4;
      return_value___uatomic_exchange$2$link4=__uatomic_exchange$link6((void *)&src_q_head$link4->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head$link4 = (struct cds_wfcq_node *)return_value___uatomic_exchange$2$link4;
      if(!(head$link4 == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3$link4 = *((struct cds_wfcq_node * volatile *)&src_q_tail$link4->p);
      if(tmp_statement_expression$3$link4 == &src_q_head$link4->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4$link4;
      return_value____cds_wfcq_busy_wait$4$link4=___cds_wfcq_busy_wait$link4(&attempt$link4, blocking$link4);
      if(!(return_value____cds_wfcq_busy_wait$4$link4 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5$link4;
    return_value___uatomic_exchange$5$link4=__uatomic_exchange$link6((void *)&src_q_tail$link4->p, (unsigned long int)&src_q_head$link4->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail$link4 = (struct cds_wfcq_node *)return_value___uatomic_exchange$5$link4;
    _Bool return_value____cds_wfcq_append$6$link4;
    return_value____cds_wfcq_append$6$link4=___cds_wfcq_append$link4(dest_q_head$link4, dest_q_tail$link4, head$link4, tail$link4);
    if(!(return_value____cds_wfcq_append$6$link4 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice$link5
// file ./urcu/static/wfcqueue.h line 496
static inline enum cds_wfcq_ret ___cds_wfcq_splice$link5(union anonymous$1 u_dest_q_head$link5, struct cds_wfcq_tail *dest_q_tail$link5, union anonymous$1 u_src_q_head$link5, struct cds_wfcq_tail *src_q_tail$link5, signed int blocking$link5)
{
  struct __cds_wfcq_head *dest_q_head$link5 = u_dest_q_head$link5._h;
  struct __cds_wfcq_head *src_q_head$link5 = u_src_q_head$link5._h;
  struct cds_wfcq_node *head$link5;
  struct cds_wfcq_node *tail$link5;
  signed int attempt$link5 = 0;
  _Bool return_value__cds_wfcq_empty$1$link5;
  return_value__cds_wfcq_empty$1$link5=_cds_wfcq_empty$link5(src_q_head$link5, src_q_tail$link5);
  struct cds_wfcq_node * volatile tmp_statement_expression$3$link5;
  if(!(return_value__cds_wfcq_empty$1$link5 == (_Bool)0))
    return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

  else
  {
    do
    {
      unsigned long int return_value___uatomic_exchange$2$link5;
      return_value___uatomic_exchange$2$link5=__uatomic_exchange$link7((void *)&src_q_head$link5->node.next, (unsigned long int)(void *)0, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
      head$link5 = (struct cds_wfcq_node *)return_value___uatomic_exchange$2$link5;
      if(!(head$link5 == ((struct cds_wfcq_node *)NULL)))
        break;

      asm("" :  :  : "memory");
      tmp_statement_expression$3$link5 = *((struct cds_wfcq_node * volatile *)&src_q_tail$link5->p);
      if(tmp_statement_expression$3$link5 == &src_q_head$link5->node)
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_SRC_EMPTY;

      _Bool return_value____cds_wfcq_busy_wait$4$link5;
      return_value____cds_wfcq_busy_wait$4$link5=___cds_wfcq_busy_wait$link5(&attempt$link5, blocking$link5);
      if(!(return_value____cds_wfcq_busy_wait$4$link5 == (_Bool)0))
        return (enum cds_wfcq_ret)CDS_WFCQ_RET_WOULDBLOCK;

    }
    while((_Bool)1);
    unsigned long int return_value___uatomic_exchange$5$link5;
    return_value___uatomic_exchange$5$link5=__uatomic_exchange$link7((void *)&src_q_tail$link5->p, (unsigned long int)&src_q_head$link5->node, (signed int)sizeof(struct cds_wfcq_node *) /*8ul*/ );
    tail$link5 = (struct cds_wfcq_node *)return_value___uatomic_exchange$5$link5;
    _Bool return_value____cds_wfcq_append$6$link5;
    return_value____cds_wfcq_append$6$link5=___cds_wfcq_append$link5(dest_q_head$link5, dest_q_tail$link5, head$link5, tail$link5);
    if(!(return_value____cds_wfcq_append$6$link5 == (_Bool)0))
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_NON_EMPTY;

    else
      return (enum cds_wfcq_ret)CDS_WFCQ_RET_DEST_EMPTY;
  }
}

// ___cds_wfcq_splice_blocking
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking(union anonymous$1 dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 src_q_head, struct cds_wfcq_tail *src_q_tail)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1;
  return_value____cds_wfcq_splice$1=___cds_wfcq_splice(dest_q_head, dest_q_tail, src_q_head, src_q_tail, 1);
  return return_value____cds_wfcq_splice$1;
}

// ___cds_wfcq_splice_blocking$link1
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1(union anonymous$1 dest_q_head$link1, struct cds_wfcq_tail *dest_q_tail$link1, union anonymous$1 src_q_head$link1, struct cds_wfcq_tail *src_q_tail$link1)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link1;
  return_value____cds_wfcq_splice$1$link1=___cds_wfcq_splice$link1(dest_q_head$link1, dest_q_tail$link1, src_q_head$link1, src_q_tail$link1, 1);
  return return_value____cds_wfcq_splice$1$link1;
}

// ___cds_wfcq_splice_blocking$link1$link1
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1$link1(union anonymous$1 dest_q_head$link1$link1, struct cds_wfcq_tail *dest_q_tail$link1$link1, union anonymous$1 src_q_head$link1$link1, struct cds_wfcq_tail *src_q_tail$link1$link1)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link1$link1;
  return_value____cds_wfcq_splice$1$link1$link1=___cds_wfcq_splice$link1$link1(dest_q_head$link1$link1, dest_q_tail$link1$link1, src_q_head$link1$link1, src_q_tail$link1$link1, 1);
  return return_value____cds_wfcq_splice$1$link1$link1;
}

// ___cds_wfcq_splice_blocking$link1$link2
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1$link2(union anonymous$1 dest_q_head$link1$link2, struct cds_wfcq_tail *dest_q_tail$link1$link2, union anonymous$1 src_q_head$link1$link2, struct cds_wfcq_tail *src_q_tail$link1$link2)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link1$link2;
  return_value____cds_wfcq_splice$1$link1$link2=___cds_wfcq_splice$link1$link2(dest_q_head$link1$link2, dest_q_tail$link1$link2, src_q_head$link1$link2, src_q_tail$link1$link2, 1);
  return return_value____cds_wfcq_splice$1$link1$link2;
}

// ___cds_wfcq_splice_blocking$link1$link3
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1$link3(union anonymous$1 dest_q_head$link1$link3, struct cds_wfcq_tail *dest_q_tail$link1$link3, union anonymous$1 src_q_head$link1$link3, struct cds_wfcq_tail *src_q_tail$link1$link3)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link1$link3;
  return_value____cds_wfcq_splice$1$link1$link3=___cds_wfcq_splice$link1$link3(dest_q_head$link1$link3, dest_q_tail$link1$link3, src_q_head$link1$link3, src_q_tail$link1$link3, 1);
  return return_value____cds_wfcq_splice$1$link1$link3;
}

// ___cds_wfcq_splice_blocking$link1$link4
// file urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link1$link4(union anonymous$1 dest_q_head$link1$link4, struct cds_wfcq_tail *dest_q_tail$link1$link4, union anonymous$1 src_q_head$link1$link4, struct cds_wfcq_tail *src_q_tail$link1$link4)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link1$link4;
  return_value____cds_wfcq_splice$1$link1$link4=___cds_wfcq_splice$link1$link4(dest_q_head$link1$link4, dest_q_tail$link1$link4, src_q_head$link1$link4, src_q_tail$link1$link4, 1);
  return return_value____cds_wfcq_splice$1$link1$link4;
}

// ___cds_wfcq_splice_blocking$link2
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link2(union anonymous$1 dest_q_head$link2, struct cds_wfcq_tail *dest_q_tail$link2, union anonymous$1 src_q_head$link2, struct cds_wfcq_tail *src_q_tail$link2)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link2;
  return_value____cds_wfcq_splice$1$link2=___cds_wfcq_splice$link2(dest_q_head$link2, dest_q_tail$link2, src_q_head$link2, src_q_tail$link2, 1);
  return return_value____cds_wfcq_splice$1$link2;
}

// ___cds_wfcq_splice_blocking$link3
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link3(union anonymous$1 dest_q_head$link3, struct cds_wfcq_tail *dest_q_tail$link3, union anonymous$1 src_q_head$link3, struct cds_wfcq_tail *src_q_tail$link3)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link3;
  return_value____cds_wfcq_splice$1$link3=___cds_wfcq_splice$link3(dest_q_head$link3, dest_q_tail$link3, src_q_head$link3, src_q_tail$link3, 1);
  return return_value____cds_wfcq_splice$1$link3;
}

// ___cds_wfcq_splice_blocking$link4
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link4(union anonymous$1 dest_q_head$link4, struct cds_wfcq_tail *dest_q_tail$link4, union anonymous$1 src_q_head$link4, struct cds_wfcq_tail *src_q_tail$link4)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link4;
  return_value____cds_wfcq_splice$1$link4=___cds_wfcq_splice$link4(dest_q_head$link4, dest_q_tail$link4, src_q_head$link4, src_q_tail$link4, 1);
  return return_value____cds_wfcq_splice$1$link4;
}

// ___cds_wfcq_splice_blocking$link5
// file ./urcu/static/wfcqueue.h line 559
static inline enum cds_wfcq_ret ___cds_wfcq_splice_blocking$link5(union anonymous$1 dest_q_head$link5, struct cds_wfcq_tail *dest_q_tail$link5, union anonymous$1 src_q_head$link5, struct cds_wfcq_tail *src_q_tail$link5)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link5;
  return_value____cds_wfcq_splice$1$link5=___cds_wfcq_splice$link5(dest_q_head$link5, dest_q_tail$link5, src_q_head$link5, src_q_tail$link5, 1);
  return return_value____cds_wfcq_splice$1$link5;
}

// ___cds_wfcq_splice_nonblocking
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking(union anonymous$1 dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 src_q_head, struct cds_wfcq_tail *src_q_tail)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1;
  return_value____cds_wfcq_splice$1=___cds_wfcq_splice$link1(dest_q_head, dest_q_tail, src_q_head, src_q_tail, 0);
  return return_value____cds_wfcq_splice$1;
}

// ___cds_wfcq_splice_nonblocking$link1
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking$link1(union anonymous$1 dest_q_head$link1, struct cds_wfcq_tail *dest_q_tail$link1, union anonymous$1 src_q_head$link1, struct cds_wfcq_tail *src_q_tail$link1)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link1;
  return_value____cds_wfcq_splice$1$link1=___cds_wfcq_splice$link1$link1(dest_q_head$link1, dest_q_tail$link1, src_q_head$link1, src_q_tail$link1, 0);
  return return_value____cds_wfcq_splice$1$link1;
}

// ___cds_wfcq_splice_nonblocking$link2
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking$link2(union anonymous$1 dest_q_head$link2, struct cds_wfcq_tail *dest_q_tail$link2, union anonymous$1 src_q_head$link2, struct cds_wfcq_tail *src_q_tail$link2)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link2;
  return_value____cds_wfcq_splice$1$link2=___cds_wfcq_splice$link1$link2(dest_q_head$link2, dest_q_tail$link2, src_q_head$link2, src_q_tail$link2, 0);
  return return_value____cds_wfcq_splice$1$link2;
}

// ___cds_wfcq_splice_nonblocking$link3
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking$link3(union anonymous$1 dest_q_head$link3, struct cds_wfcq_tail *dest_q_tail$link3, union anonymous$1 src_q_head$link3, struct cds_wfcq_tail *src_q_tail$link3)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link3;
  return_value____cds_wfcq_splice$1$link3=___cds_wfcq_splice$link1$link3(dest_q_head$link3, dest_q_tail$link3, src_q_head$link3, src_q_tail$link3, 0);
  return return_value____cds_wfcq_splice$1$link3;
}

// ___cds_wfcq_splice_nonblocking$link4
// file urcu/static/wfcqueue.h line 576
static inline enum cds_wfcq_ret ___cds_wfcq_splice_nonblocking$link4(union anonymous$1 dest_q_head$link4, struct cds_wfcq_tail *dest_q_tail$link4, union anonymous$1 src_q_head$link4, struct cds_wfcq_tail *src_q_tail$link4)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice$1$link4;
  return_value____cds_wfcq_splice$1$link4=___cds_wfcq_splice$link1$link4(dest_q_head$link4, dest_q_tail$link4, src_q_head$link4, src_q_tail$link4, 0);
  return return_value____cds_wfcq_splice$1$link4;
}

// ___cds_wfq_dequeue_blocking
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking(struct cds_wfq_queue *q)
{
  struct cds_wfq_node *node;
  struct cds_wfq_node *next;
  struct cds_wfq_node ** volatile tmp_statement_expression$1;
  if(q->head == &q->dummy)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1 = *((struct cds_wfq_node ** volatile *)&q->tail);
    if(!(tmp_statement_expression$1 == &q->dummy.next))
      goto __CPROVER_DUMP_L1;

    return (struct cds_wfq_node *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    node = q->head;
    next=___cds_wfq_node_sync_next(node);
    q->head = next;
    if(node == &q->dummy)
    {
      _cds_wfq_node_init(node);
      _cds_wfq_enqueue(q, node);
      struct cds_wfq_node *return_value____cds_wfq_dequeue_blocking$2;
      return_value____cds_wfq_dequeue_blocking$2=___cds_wfq_dequeue_blocking(q);
      return return_value____cds_wfq_dequeue_blocking$2;
    }

    return node;
  }
}

// ___cds_wfq_dequeue_blocking$link1
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking$link1(struct cds_wfq_queue *q$link1)
{
  struct cds_wfq_node *node$link1;
  struct cds_wfq_node *next$link1;
  struct cds_wfq_node ** volatile tmp_statement_expression$1$link1;
  if(q$link1->head == &q$link1->dummy)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1 = *((struct cds_wfq_node ** volatile *)&q$link1->tail);
    if(!(tmp_statement_expression$1$link1 == &q$link1->dummy.next))
      goto __CPROVER_DUMP_L1;

    return (struct cds_wfq_node *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    node$link1 = q$link1->head;
    next$link1=___cds_wfq_node_sync_next$link1(node$link1);
    q$link1->head = next$link1;
    if(node$link1 == &q$link1->dummy)
    {
      _cds_wfq_node_init$link1(node$link1);
      _cds_wfq_enqueue$link1(q$link1, node$link1);
      struct cds_wfq_node *return_value____cds_wfq_dequeue_blocking$2$link1;
      return_value____cds_wfq_dequeue_blocking$2$link1=___cds_wfq_dequeue_blocking$link1(q$link1);
      return return_value____cds_wfq_dequeue_blocking$2$link1;
    }

    return node$link1;
  }
}

// ___cds_wfq_dequeue_blocking$link2
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking$link2(struct cds_wfq_queue *q$link2)
{
  struct cds_wfq_node *node$link2;
  struct cds_wfq_node *next$link2;
  struct cds_wfq_node ** volatile tmp_statement_expression$1$link2;
  if(q$link2->head == &q$link2->dummy)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link2 = *((struct cds_wfq_node ** volatile *)&q$link2->tail);
    if(!(tmp_statement_expression$1$link2 == &q$link2->dummy.next))
      goto __CPROVER_DUMP_L1;

    return (struct cds_wfq_node *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    node$link2 = q$link2->head;
    next$link2=___cds_wfq_node_sync_next$link2(node$link2);
    q$link2->head = next$link2;
    if(node$link2 == &q$link2->dummy)
    {
      _cds_wfq_node_init$link2(node$link2);
      _cds_wfq_enqueue$link2(q$link2, node$link2);
      struct cds_wfq_node *return_value____cds_wfq_dequeue_blocking$2$link2;
      return_value____cds_wfq_dequeue_blocking$2$link2=___cds_wfq_dequeue_blocking$link2(q$link2);
      return return_value____cds_wfq_dequeue_blocking$2$link2;
    }

    return node$link2;
  }
}

// ___cds_wfq_dequeue_blocking$link3
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking$link3(struct cds_wfq_queue *q$link3)
{
  struct cds_wfq_node *node$link3;
  struct cds_wfq_node *next$link3;
  struct cds_wfq_node ** volatile tmp_statement_expression$1$link3;
  if(q$link3->head == &q$link3->dummy)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link3 = *((struct cds_wfq_node ** volatile *)&q$link3->tail);
    if(!(tmp_statement_expression$1$link3 == &q$link3->dummy.next))
      goto __CPROVER_DUMP_L1;

    return (struct cds_wfq_node *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    node$link3 = q$link3->head;
    next$link3=___cds_wfq_node_sync_next$link3(node$link3);
    q$link3->head = next$link3;
    if(node$link3 == &q$link3->dummy)
    {
      _cds_wfq_node_init$link3(node$link3);
      _cds_wfq_enqueue$link3(q$link3, node$link3);
      struct cds_wfq_node *return_value____cds_wfq_dequeue_blocking$2$link3;
      return_value____cds_wfq_dequeue_blocking$2$link3=___cds_wfq_dequeue_blocking$link3(q$link3);
      return return_value____cds_wfq_dequeue_blocking$2$link3;
    }

    return node$link3;
  }
}

// ___cds_wfq_dequeue_blocking$link4
// file urcu/static/wfqueue.h line 119
static inline struct cds_wfq_node * ___cds_wfq_dequeue_blocking$link4(struct cds_wfq_queue *q$link4)
{
  struct cds_wfq_node *node$link4;
  struct cds_wfq_node *next$link4;
  struct cds_wfq_node ** volatile tmp_statement_expression$1$link4;
  if(q$link4->head == &q$link4->dummy)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link4 = *((struct cds_wfq_node ** volatile *)&q$link4->tail);
    if(!(tmp_statement_expression$1$link4 == &q$link4->dummy.next))
      goto __CPROVER_DUMP_L1;

    return (struct cds_wfq_node *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    node$link4 = q$link4->head;
    next$link4=___cds_wfq_node_sync_next$link4(node$link4);
    q$link4->head = next$link4;
    if(node$link4 == &q$link4->dummy)
    {
      _cds_wfq_node_init$link4(node$link4);
      _cds_wfq_enqueue$link4(q$link4, node$link4);
      struct cds_wfq_node *return_value____cds_wfq_dequeue_blocking$2$link4;
      return_value____cds_wfq_dequeue_blocking$2$link4=___cds_wfq_dequeue_blocking$link4(q$link4);
      return return_value____cds_wfq_dequeue_blocking$2$link4;
    }

    return node$link4;
  }
}

// ___cds_wfq_node_sync_next
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next(struct cds_wfq_node *node)
{
  struct cds_wfq_node *next;
  signed int attempt = 0;
  struct cds_wfq_node * volatile tmp_statement_expression$1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1 = *((struct cds_wfq_node * volatile *)&node->next);
    next = tmp_statement_expression$1;
    if(!(next == ((struct cds_wfq_node *)NULL)))
      break;

    attempt = attempt + 1;
    if(attempt >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next;
}

// ___cds_wfq_node_sync_next$link1
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next$link1(struct cds_wfq_node *node$link1)
{
  struct cds_wfq_node *next$link1;
  signed int attempt$link1 = 0;
  struct cds_wfq_node * volatile tmp_statement_expression$1$link1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1 = *((struct cds_wfq_node * volatile *)&node$link1->next);
    next$link1 = tmp_statement_expression$1$link1;
    if(!(next$link1 == ((struct cds_wfq_node *)NULL)))
      break;

    attempt$link1 = attempt$link1 + 1;
    if(attempt$link1 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link1 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link1;
}

// ___cds_wfq_node_sync_next$link2
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next$link2(struct cds_wfq_node *node$link2)
{
  struct cds_wfq_node *next$link2;
  signed int attempt$link2 = 0;
  struct cds_wfq_node * volatile tmp_statement_expression$1$link2;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link2 = *((struct cds_wfq_node * volatile *)&node$link2->next);
    next$link2 = tmp_statement_expression$1$link2;
    if(!(next$link2 == ((struct cds_wfq_node *)NULL)))
      break;

    attempt$link2 = attempt$link2 + 1;
    if(attempt$link2 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link2 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link2;
}

// ___cds_wfq_node_sync_next$link3
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next$link3(struct cds_wfq_node *node$link3)
{
  struct cds_wfq_node *next$link3;
  signed int attempt$link3 = 0;
  struct cds_wfq_node * volatile tmp_statement_expression$1$link3;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link3 = *((struct cds_wfq_node * volatile *)&node$link3->next);
    next$link3 = tmp_statement_expression$1$link3;
    if(!(next$link3 == ((struct cds_wfq_node *)NULL)))
      break;

    attempt$link3 = attempt$link3 + 1;
    if(attempt$link3 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link3 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link3;
}

// ___cds_wfq_node_sync_next$link4
// file urcu/static/wfqueue.h line 91
static inline struct cds_wfq_node * ___cds_wfq_node_sync_next$link4(struct cds_wfq_node *node$link4)
{
  struct cds_wfq_node *next$link4;
  signed int attempt$link4 = 0;
  struct cds_wfq_node * volatile tmp_statement_expression$1$link4;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link4 = *((struct cds_wfq_node * volatile *)&node$link4->next);
    next$link4 = tmp_statement_expression$1$link4;
    if(!(next$link4 == ((struct cds_wfq_node *)NULL)))
      break;

    attempt$link4 = attempt$link4 + 1;
    if(attempt$link4 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link4 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link4;
}

// ___cds_wfs_end
// file ./urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end(void *node)
{
  return node == (void *)0x1UL;
}

// ___cds_wfs_end$link1
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link1(void *node$link1)
{
  return node$link1 == (void *)0x1UL;
}

// ___cds_wfs_end$link1$link1
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link1$link1(void *node$link1$link1)
{
  return node$link1$link1 == (void *)0x1UL;
}

// ___cds_wfs_end$link1$link2
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link1$link2(void *node$link1$link2)
{
  return node$link1$link2 == (void *)0x1UL;
}

// ___cds_wfs_end$link1$link3
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link1$link3(void *node$link1$link3)
{
  return node$link1$link3 == (void *)0x1UL;
}

// ___cds_wfs_end$link2
// file ./urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link2(void *node$link2)
{
  return node$link2 == (void *)0x1UL;
}

// ___cds_wfs_end$link3
// file ./urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link3(void *node$link3)
{
  return node$link3 == (void *)0x1UL;
}

// ___cds_wfs_end$link4
// file ./urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link4(void *node$link4)
{
  return node$link4 == (void *)0x1UL;
}

// ___cds_wfs_end$link5
// file urcu/static/wfstack.h line 100
static inline _Bool ___cds_wfs_end$link5(void *node$link5)
{
  return node$link5 == (void *)0x1UL;
}

// ___cds_wfs_init
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init(struct __cds_wfs_stack *s)
{
  s->head = (struct cds_wfs_head *)(void *)0x1UL;
}

// ___cds_wfs_init$link1
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init$link1(struct __cds_wfs_stack *s$link1)
{
  s$link1->head = (struct cds_wfs_head *)(void *)0x1UL;
}

// ___cds_wfs_init$link2
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init$link2(struct __cds_wfs_stack *s$link2)
{
  s$link2->head = (struct cds_wfs_head *)(void *)0x1UL;
}

// ___cds_wfs_init$link3
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init$link3(struct __cds_wfs_stack *s$link3)
{
  s$link3->head = (struct cds_wfs_head *)(void *)0x1UL;
}

// ___cds_wfs_init$link4
// file urcu/static/wfstack.h line 82
static inline void ___cds_wfs_init$link4(struct __cds_wfs_stack *s$link4)
{
  s$link4->head = (struct cds_wfs_head *)(void *)0x1UL;
}

// ___cds_wfs_next
// file ./urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next(struct cds_wfs_node *node, signed int blocking)
{
  struct cds_wfs_node *next;
  next=___cds_wfs_node_sync_next(node, blocking);
  _Bool return_value____cds_wfs_end$1;
  return_value____cds_wfs_end$1=___cds_wfs_end((void *)next);
  if(!(return_value____cds_wfs_end$1 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return next;
}

// ___cds_wfs_next$link1
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link1(struct cds_wfs_node *node$link1, signed int blocking$link1)
{
  struct cds_wfs_node *next$link1;
  next$link1=___cds_wfs_node_sync_next$link1(node$link1, blocking$link1);
  _Bool return_value____cds_wfs_end$1$link1;
  return_value____cds_wfs_end$1$link1=___cds_wfs_end$link1((void *)next$link1);
  if(!(return_value____cds_wfs_end$1$link1 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return next$link1;
}

// ___cds_wfs_next$link1$link1
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link1$link1(struct cds_wfs_node *node$link1$link1, signed int blocking$link1$link1)
{
  struct cds_wfs_node *next$link1$link1;
  next$link1$link1=___cds_wfs_node_sync_next$link1$link1(node$link1$link1, blocking$link1$link1);
  _Bool return_value____cds_wfs_end$1$link1$link1;
  return_value____cds_wfs_end$1$link1$link1=___cds_wfs_end$link1$link1((void *)next$link1$link1);
  if(!(return_value____cds_wfs_end$1$link1$link1 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return next$link1$link1;
}

// ___cds_wfs_next$link1$link2
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link1$link2(struct cds_wfs_node *node$link1$link2, signed int blocking$link1$link2)
{
  struct cds_wfs_node *next$link1$link2;
  next$link1$link2=___cds_wfs_node_sync_next$link1$link2(node$link1$link2, blocking$link1$link2);
  _Bool return_value____cds_wfs_end$1$link1$link2;
  return_value____cds_wfs_end$1$link1$link2=___cds_wfs_end$link1$link2((void *)next$link1$link2);
  if(!(return_value____cds_wfs_end$1$link1$link2 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return next$link1$link2;
}

// ___cds_wfs_next$link1$link3
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link1$link3(struct cds_wfs_node *node$link1$link3, signed int blocking$link1$link3)
{
  struct cds_wfs_node *next$link1$link3;
  next$link1$link3=___cds_wfs_node_sync_next$link1$link3(node$link1$link3, blocking$link1$link3);
  _Bool return_value____cds_wfs_end$1$link1$link3;
  return_value____cds_wfs_end$1$link1$link3=___cds_wfs_end$link1$link3((void *)next$link1$link3);
  if(!(return_value____cds_wfs_end$1$link1$link3 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return next$link1$link3;
}

// ___cds_wfs_next$link2
// file ./urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link2(struct cds_wfs_node *node$link2, signed int blocking$link2)
{
  struct cds_wfs_node *next$link2;
  next$link2=___cds_wfs_node_sync_next$link2(node$link2, blocking$link2);
  _Bool return_value____cds_wfs_end$1$link2;
  return_value____cds_wfs_end$1$link2=___cds_wfs_end$link2((void *)next$link2);
  if(!(return_value____cds_wfs_end$1$link2 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return next$link2;
}

// ___cds_wfs_next$link3
// file ./urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link3(struct cds_wfs_node *node$link3, signed int blocking$link3)
{
  struct cds_wfs_node *next$link3;
  next$link3=___cds_wfs_node_sync_next$link3(node$link3, blocking$link3);
  _Bool return_value____cds_wfs_end$1$link3;
  return_value____cds_wfs_end$1$link3=___cds_wfs_end$link3((void *)next$link3);
  if(!(return_value____cds_wfs_end$1$link3 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return next$link3;
}

// ___cds_wfs_next$link4
// file ./urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link4(struct cds_wfs_node *node$link4, signed int blocking$link4)
{
  struct cds_wfs_node *next$link4;
  next$link4=___cds_wfs_node_sync_next$link4(node$link4, blocking$link4);
  _Bool return_value____cds_wfs_end$1$link4;
  return_value____cds_wfs_end$1$link4=___cds_wfs_end$link4((void *)next$link4);
  if(!(return_value____cds_wfs_end$1$link4 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return next$link4;
}

// ___cds_wfs_next$link5
// file urcu/static/wfstack.h line 388
static inline struct cds_wfs_node * ___cds_wfs_next$link5(struct cds_wfs_node *node$link5, signed int blocking$link5)
{
  struct cds_wfs_node *next$link5;
  next$link5=___cds_wfs_node_sync_next$link5(node$link5, blocking$link5);
  _Bool return_value____cds_wfs_end$1$link5;
  return_value____cds_wfs_end$1$link5=___cds_wfs_end$link5((void *)next$link5);
  if(!(return_value____cds_wfs_end$1$link5 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return next$link5;
}

// ___cds_wfs_node_sync_next
// file ./urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next(struct cds_wfs_node *node, signed int blocking)
{
  struct cds_wfs_node *next;
  signed int attempt = 0;
  struct cds_wfs_node * volatile tmp_statement_expression$1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1 = *((struct cds_wfs_node * volatile *)&node->next);
    next = tmp_statement_expression$1;
    if(!(next == ((struct cds_wfs_node *)NULL)))
      break;

    if(blocking == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    attempt = attempt + 1;
    if(attempt >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next;
}

// ___cds_wfs_node_sync_next$link1
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link1(struct cds_wfs_node *node$link1, signed int blocking$link1)
{
  struct cds_wfs_node *next$link1;
  signed int attempt$link1 = 0;
  struct cds_wfs_node * volatile tmp_statement_expression$1$link1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1 = *((struct cds_wfs_node * volatile *)&node$link1->next);
    next$link1 = tmp_statement_expression$1$link1;
    if(!(next$link1 == ((struct cds_wfs_node *)NULL)))
      break;

    if(blocking$link1 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    attempt$link1 = attempt$link1 + 1;
    if(attempt$link1 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link1 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link1;
}

// ___cds_wfs_node_sync_next$link1$link1
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link1$link1(struct cds_wfs_node *node$link1$link1, signed int blocking$link1$link1)
{
  struct cds_wfs_node *next$link1$link1;
  signed int attempt$link1$link1 = 0;
  struct cds_wfs_node * volatile tmp_statement_expression$1$link1$link1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link1 = *((struct cds_wfs_node * volatile *)&node$link1$link1->next);
    next$link1$link1 = tmp_statement_expression$1$link1$link1;
    if(!(next$link1$link1 == ((struct cds_wfs_node *)NULL)))
      break;

    if(blocking$link1$link1 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    attempt$link1$link1 = attempt$link1$link1 + 1;
    if(attempt$link1$link1 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link1$link1 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link1$link1;
}

// ___cds_wfs_node_sync_next$link1$link2
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link1$link2(struct cds_wfs_node *node$link1$link2, signed int blocking$link1$link2)
{
  struct cds_wfs_node *next$link1$link2;
  signed int attempt$link1$link2 = 0;
  struct cds_wfs_node * volatile tmp_statement_expression$1$link1$link2;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link2 = *((struct cds_wfs_node * volatile *)&node$link1$link2->next);
    next$link1$link2 = tmp_statement_expression$1$link1$link2;
    if(!(next$link1$link2 == ((struct cds_wfs_node *)NULL)))
      break;

    if(blocking$link1$link2 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    attempt$link1$link2 = attempt$link1$link2 + 1;
    if(attempt$link1$link2 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link1$link2 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link1$link2;
}

// ___cds_wfs_node_sync_next$link1$link3
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link1$link3(struct cds_wfs_node *node$link1$link3, signed int blocking$link1$link3)
{
  struct cds_wfs_node *next$link1$link3;
  signed int attempt$link1$link3 = 0;
  struct cds_wfs_node * volatile tmp_statement_expression$1$link1$link3;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1$link3 = *((struct cds_wfs_node * volatile *)&node$link1$link3->next);
    next$link1$link3 = tmp_statement_expression$1$link1$link3;
    if(!(next$link1$link3 == ((struct cds_wfs_node *)NULL)))
      break;

    if(blocking$link1$link3 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    attempt$link1$link3 = attempt$link1$link3 + 1;
    if(attempt$link1$link3 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link1$link3 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link1$link3;
}

// ___cds_wfs_node_sync_next$link2
// file ./urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link2(struct cds_wfs_node *node$link2, signed int blocking$link2)
{
  struct cds_wfs_node *next$link2;
  signed int attempt$link2 = 0;
  struct cds_wfs_node * volatile tmp_statement_expression$1$link2;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link2 = *((struct cds_wfs_node * volatile *)&node$link2->next);
    next$link2 = tmp_statement_expression$1$link2;
    if(!(next$link2 == ((struct cds_wfs_node *)NULL)))
      break;

    if(blocking$link2 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    attempt$link2 = attempt$link2 + 1;
    if(attempt$link2 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link2 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link2;
}

// ___cds_wfs_node_sync_next$link3
// file ./urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link3(struct cds_wfs_node *node$link3, signed int blocking$link3)
{
  struct cds_wfs_node *next$link3;
  signed int attempt$link3 = 0;
  struct cds_wfs_node * volatile tmp_statement_expression$1$link3;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link3 = *((struct cds_wfs_node * volatile *)&node$link3->next);
    next$link3 = tmp_statement_expression$1$link3;
    if(!(next$link3 == ((struct cds_wfs_node *)NULL)))
      break;

    if(blocking$link3 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    attempt$link3 = attempt$link3 + 1;
    if(attempt$link3 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link3 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link3;
}

// ___cds_wfs_node_sync_next$link4
// file ./urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link4(struct cds_wfs_node *node$link4, signed int blocking$link4)
{
  struct cds_wfs_node *next$link4;
  signed int attempt$link4 = 0;
  struct cds_wfs_node * volatile tmp_statement_expression$1$link4;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link4 = *((struct cds_wfs_node * volatile *)&node$link4->next);
    next$link4 = tmp_statement_expression$1$link4;
    if(!(next$link4 == ((struct cds_wfs_node *)NULL)))
      break;

    if(blocking$link4 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    attempt$link4 = attempt$link4 + 1;
    if(attempt$link4 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link4 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link4;
}

// ___cds_wfs_node_sync_next$link5
// file urcu/static/wfstack.h line 151
static inline struct cds_wfs_node * ___cds_wfs_node_sync_next$link5(struct cds_wfs_node *node$link5, signed int blocking$link5)
{
  struct cds_wfs_node *next$link5;
  signed int attempt$link5 = 0;
  struct cds_wfs_node * volatile tmp_statement_expression$1$link5;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link5 = *((struct cds_wfs_node * volatile *)&node$link5->next);
    next$link5 = tmp_statement_expression$1$link5;
    if(!(next$link5 == ((struct cds_wfs_node *)NULL)))
      break;

    if(blocking$link5 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    attempt$link5 = attempt$link5 + 1;
    if(attempt$link5 >= 10)
    {
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
      attempt$link5 = 0;
    }

    else
      asm("rep; nop" :  :  : "memory");
  }
  while((_Bool)1);
  return next$link5;
}

// ___cds_wfs_pop
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop(union anonymous u_stack, signed int *state, signed int blocking)
{
  struct cds_wfs_head *head;
  struct cds_wfs_head *new_head;
  struct cds_wfs_node *next;
  struct __cds_wfs_stack *s = u_stack._s;
  if(!(state == ((signed int *)NULL)))
    *state = 0;

  struct cds_wfs_head * volatile tmp_statement_expression$1;
  struct cds_wfs_head *tmp_statement_expression$3;
  _Bool return_value____cds_wfs_end$4;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1 = *((struct cds_wfs_head * volatile *)&s->head);
    head = tmp_statement_expression$1;
    _Bool return_value____cds_wfs_end$2;
    return_value____cds_wfs_end$2=___cds_wfs_end$link1((void *)head);
    if(!(return_value____cds_wfs_end$2 == (_Bool)0))
      return (struct cds_wfs_node *)(void *)0;

    next=___cds_wfs_node_sync_next$link1(&head->node, blocking);
    if(next == (struct cds_wfs_node *)18446744073709551615ul && blocking == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    const struct cds_wfs_node *__ptr = next;
    tmp_statement_expression$3 = (struct cds_wfs_head *)((char *)__ptr - (signed long int)0ul);
    new_head = tmp_statement_expression$3;
    unsigned long int return_value___uatomic_cmpxchg$5;
    return_value___uatomic_cmpxchg$5=__uatomic_cmpxchg$link1((void *)&s->head, (unsigned long int)head, (unsigned long int)new_head, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
    if((struct cds_wfs_head *)return_value___uatomic_cmpxchg$5 == head)
    {
      if(!(state == ((signed int *)NULL)))
      {
        return_value____cds_wfs_end$4=___cds_wfs_end$link1((void *)new_head);
        if(!(return_value____cds_wfs_end$4 == (_Bool)0))
          *state = *state | 1;

      }

      return &head->node;
    }

    if(blocking == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

  }
  while((_Bool)1);
}

// ___cds_wfs_pop$link1
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop$link1(union anonymous u_stack$link1, signed int *state$link1, signed int blocking$link1)
{
  struct cds_wfs_head *head$link1;
  struct cds_wfs_head *new_head$link1;
  struct cds_wfs_node *next$link1;
  struct __cds_wfs_stack *s$link1 = u_stack$link1._s;
  if(!(state$link1 == ((signed int *)NULL)))
    *state$link1 = 0;

  struct cds_wfs_head * volatile tmp_statement_expression$1$link1;
  struct cds_wfs_head *tmp_statement_expression$3$link1;
  _Bool return_value____cds_wfs_end$4$link1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1 = *((struct cds_wfs_head * volatile *)&s$link1->head);
    head$link1 = tmp_statement_expression$1$link1;
    _Bool return_value____cds_wfs_end$2$link1;
    return_value____cds_wfs_end$2$link1=___cds_wfs_end$link1$link1((void *)head$link1);
    if(!(return_value____cds_wfs_end$2$link1 == (_Bool)0))
      return (struct cds_wfs_node *)(void *)0;

    next$link1=___cds_wfs_node_sync_next$link1$link1(&head$link1->node, blocking$link1);
    if(next$link1 == (struct cds_wfs_node *)18446744073709551615ul && blocking$link1 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    const struct cds_wfs_node *__ptr$link1 = next$link1;
    tmp_statement_expression$3$link1 = (struct cds_wfs_head *)((char *)__ptr$link1 - (signed long int)0ul);
    new_head$link1 = tmp_statement_expression$3$link1;
    unsigned long int return_value___uatomic_cmpxchg$5$link1;
    return_value___uatomic_cmpxchg$5$link1=__uatomic_cmpxchg$link1$link1((void *)&s$link1->head, (unsigned long int)head$link1, (unsigned long int)new_head$link1, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
    if((struct cds_wfs_head *)return_value___uatomic_cmpxchg$5$link1 == head$link1)
    {
      if(!(state$link1 == ((signed int *)NULL)))
      {
        return_value____cds_wfs_end$4$link1=___cds_wfs_end$link1$link1((void *)new_head$link1);
        if(!(return_value____cds_wfs_end$4$link1 == (_Bool)0))
          *state$link1 = *state$link1 | 1;

      }

      return &head$link1->node;
    }

    if(blocking$link1 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

  }
  while((_Bool)1);
}

// ___cds_wfs_pop$link2
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop$link2(union anonymous u_stack$link2, signed int *state$link2, signed int blocking$link2)
{
  struct cds_wfs_head *head$link2;
  struct cds_wfs_head *new_head$link2;
  struct cds_wfs_node *next$link2;
  struct __cds_wfs_stack *s$link2 = u_stack$link2._s;
  if(!(state$link2 == ((signed int *)NULL)))
    *state$link2 = 0;

  struct cds_wfs_head * volatile tmp_statement_expression$1$link2;
  struct cds_wfs_head *tmp_statement_expression$3$link2;
  _Bool return_value____cds_wfs_end$4$link2;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link2 = *((struct cds_wfs_head * volatile *)&s$link2->head);
    head$link2 = tmp_statement_expression$1$link2;
    _Bool return_value____cds_wfs_end$2$link2;
    return_value____cds_wfs_end$2$link2=___cds_wfs_end$link1$link2((void *)head$link2);
    if(!(return_value____cds_wfs_end$2$link2 == (_Bool)0))
      return (struct cds_wfs_node *)(void *)0;

    next$link2=___cds_wfs_node_sync_next$link1$link2(&head$link2->node, blocking$link2);
    if(next$link2 == (struct cds_wfs_node *)18446744073709551615ul && blocking$link2 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    const struct cds_wfs_node *__ptr$link2 = next$link2;
    tmp_statement_expression$3$link2 = (struct cds_wfs_head *)((char *)__ptr$link2 - (signed long int)0ul);
    new_head$link2 = tmp_statement_expression$3$link2;
    unsigned long int return_value___uatomic_cmpxchg$5$link2;
    return_value___uatomic_cmpxchg$5$link2=__uatomic_cmpxchg$link1$link2((void *)&s$link2->head, (unsigned long int)head$link2, (unsigned long int)new_head$link2, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
    if((struct cds_wfs_head *)return_value___uatomic_cmpxchg$5$link2 == head$link2)
    {
      if(!(state$link2 == ((signed int *)NULL)))
      {
        return_value____cds_wfs_end$4$link2=___cds_wfs_end$link1$link2((void *)new_head$link2);
        if(!(return_value____cds_wfs_end$4$link2 == (_Bool)0))
          *state$link2 = *state$link2 | 1;

      }

      return &head$link2->node;
    }

    if(blocking$link2 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

  }
  while((_Bool)1);
}

// ___cds_wfs_pop$link3
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop$link3(union anonymous u_stack$link3, signed int *state$link3, signed int blocking$link3)
{
  struct cds_wfs_head *head$link3;
  struct cds_wfs_head *new_head$link3;
  struct cds_wfs_node *next$link3;
  struct __cds_wfs_stack *s$link3 = u_stack$link3._s;
  if(!(state$link3 == ((signed int *)NULL)))
    *state$link3 = 0;

  struct cds_wfs_head * volatile tmp_statement_expression$1$link3;
  struct cds_wfs_head *tmp_statement_expression$3$link3;
  _Bool return_value____cds_wfs_end$4$link3;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link3 = *((struct cds_wfs_head * volatile *)&s$link3->head);
    head$link3 = tmp_statement_expression$1$link3;
    _Bool return_value____cds_wfs_end$2$link3;
    return_value____cds_wfs_end$2$link3=___cds_wfs_end$link1$link3((void *)head$link3);
    if(!(return_value____cds_wfs_end$2$link3 == (_Bool)0))
      return (struct cds_wfs_node *)(void *)0;

    next$link3=___cds_wfs_node_sync_next$link1$link3(&head$link3->node, blocking$link3);
    if(next$link3 == (struct cds_wfs_node *)18446744073709551615ul && blocking$link3 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    const struct cds_wfs_node *__ptr$link3 = next$link3;
    tmp_statement_expression$3$link3 = (struct cds_wfs_head *)((char *)__ptr$link3 - (signed long int)0ul);
    new_head$link3 = tmp_statement_expression$3$link3;
    unsigned long int return_value___uatomic_cmpxchg$5$link3;
    return_value___uatomic_cmpxchg$5$link3=__uatomic_cmpxchg$link1$link3((void *)&s$link3->head, (unsigned long int)head$link3, (unsigned long int)new_head$link3, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
    if((struct cds_wfs_head *)return_value___uatomic_cmpxchg$5$link3 == head$link3)
    {
      if(!(state$link3 == ((signed int *)NULL)))
      {
        return_value____cds_wfs_end$4$link3=___cds_wfs_end$link1$link3((void *)new_head$link3);
        if(!(return_value____cds_wfs_end$4$link3 == (_Bool)0))
          *state$link3 = *state$link3 | 1;

      }

      return &head$link3->node;
    }

    if(blocking$link3 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

  }
  while((_Bool)1);
}

// ___cds_wfs_pop$link4
// file urcu/static/wfstack.h line 175
static inline struct cds_wfs_node * ___cds_wfs_pop$link4(union anonymous u_stack$link4, signed int *state$link4, signed int blocking$link4)
{
  struct cds_wfs_head *head$link4;
  struct cds_wfs_head *new_head$link4;
  struct cds_wfs_node *next$link4;
  struct __cds_wfs_stack *s$link4 = u_stack$link4._s;
  if(!(state$link4 == ((signed int *)NULL)))
    *state$link4 = 0;

  struct cds_wfs_head * volatile tmp_statement_expression$1$link4;
  struct cds_wfs_head *tmp_statement_expression$3$link4;
  _Bool return_value____cds_wfs_end$4$link4;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link4 = *((struct cds_wfs_head * volatile *)&s$link4->head);
    head$link4 = tmp_statement_expression$1$link4;
    _Bool return_value____cds_wfs_end$2$link4;
    return_value____cds_wfs_end$2$link4=___cds_wfs_end$link5((void *)head$link4);
    if(!(return_value____cds_wfs_end$2$link4 == (_Bool)0))
      return (struct cds_wfs_node *)(void *)0;

    next$link4=___cds_wfs_node_sync_next$link5(&head$link4->node, blocking$link4);
    if(next$link4 == (struct cds_wfs_node *)18446744073709551615ul && blocking$link4 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

    const struct cds_wfs_node *__ptr$link4 = next$link4;
    tmp_statement_expression$3$link4 = (struct cds_wfs_head *)((char *)__ptr$link4 - (signed long int)0ul);
    new_head$link4 = tmp_statement_expression$3$link4;
    unsigned long int return_value___uatomic_cmpxchg$5$link4;
    return_value___uatomic_cmpxchg$5$link4=__uatomic_cmpxchg$link1$link1$link1((void *)&s$link4->head, (unsigned long int)head$link4, (unsigned long int)new_head$link4, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
    if((struct cds_wfs_head *)return_value___uatomic_cmpxchg$5$link4 == head$link4)
    {
      if(!(state$link4 == ((signed int *)NULL)))
      {
        return_value____cds_wfs_end$4$link4=___cds_wfs_end$link5((void *)new_head$link4);
        if(!(return_value____cds_wfs_end$4$link4 == (_Bool)0))
          *state$link4 = *state$link4 | 1;

      }

      return &head$link4->node;
    }

    if(blocking$link4 == 0)
      return (struct cds_wfs_node *)(void *)-1UL;

  }
  while((_Bool)1);
}

// ___cds_wfs_pop_all
// file ./urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all(union anonymous u_stack)
{
  struct __cds_wfs_stack *s = u_stack._s;
  struct cds_wfs_head *head;
  unsigned long int return_value___uatomic_exchange$1;
  return_value___uatomic_exchange$1=__uatomic_exchange((void *)&s->head, (unsigned long int)(void *)0x1UL, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  head = (struct cds_wfs_head *)return_value___uatomic_exchange$1;
  _Bool return_value____cds_wfs_end$2;
  return_value____cds_wfs_end$2=___cds_wfs_end((void *)head);
  if(!(return_value____cds_wfs_end$2 == (_Bool)0))
    return (struct cds_wfs_head *)(void *)0;

  else
    return head;
}

// ___cds_wfs_pop_all$link1
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link1(union anonymous u_stack$link1)
{
  struct __cds_wfs_stack *s$link1 = u_stack$link1._s;
  struct cds_wfs_head *head$link1;
  unsigned long int return_value___uatomic_exchange$1$link1;
  return_value___uatomic_exchange$1$link1=__uatomic_exchange$link2((void *)&s$link1->head, (unsigned long int)(void *)0x1UL, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  head$link1 = (struct cds_wfs_head *)return_value___uatomic_exchange$1$link1;
  _Bool return_value____cds_wfs_end$2$link1;
  return_value____cds_wfs_end$2$link1=___cds_wfs_end$link1((void *)head$link1);
  if(!(return_value____cds_wfs_end$2$link1 == (_Bool)0))
    return (struct cds_wfs_head *)(void *)0;

  else
    return head$link1;
}

// ___cds_wfs_pop_all$link1$link1
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link1$link1(union anonymous u_stack$link1$link1)
{
  struct __cds_wfs_stack *s$link1$link1 = u_stack$link1$link1._s;
  struct cds_wfs_head *head$link1$link1;
  unsigned long int return_value___uatomic_exchange$1$link1$link1;
  return_value___uatomic_exchange$1$link1$link1=__uatomic_exchange$link2$link1((void *)&s$link1$link1->head, (unsigned long int)(void *)0x1UL, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  head$link1$link1 = (struct cds_wfs_head *)return_value___uatomic_exchange$1$link1$link1;
  _Bool return_value____cds_wfs_end$2$link1$link1;
  return_value____cds_wfs_end$2$link1$link1=___cds_wfs_end$link1$link1((void *)head$link1$link1);
  if(!(return_value____cds_wfs_end$2$link1$link1 == (_Bool)0))
    return (struct cds_wfs_head *)(void *)0;

  else
    return head$link1$link1;
}

// ___cds_wfs_pop_all$link1$link2
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link1$link2(union anonymous u_stack$link1$link2)
{
  struct __cds_wfs_stack *s$link1$link2 = u_stack$link1$link2._s;
  struct cds_wfs_head *head$link1$link2;
  unsigned long int return_value___uatomic_exchange$1$link1$link2;
  return_value___uatomic_exchange$1$link1$link2=__uatomic_exchange$link2$link2((void *)&s$link1$link2->head, (unsigned long int)(void *)0x1UL, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  head$link1$link2 = (struct cds_wfs_head *)return_value___uatomic_exchange$1$link1$link2;
  _Bool return_value____cds_wfs_end$2$link1$link2;
  return_value____cds_wfs_end$2$link1$link2=___cds_wfs_end$link1$link2((void *)head$link1$link2);
  if(!(return_value____cds_wfs_end$2$link1$link2 == (_Bool)0))
    return (struct cds_wfs_head *)(void *)0;

  else
    return head$link1$link2;
}

// ___cds_wfs_pop_all$link1$link3
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link1$link3(union anonymous u_stack$link1$link3)
{
  struct __cds_wfs_stack *s$link1$link3 = u_stack$link1$link3._s;
  struct cds_wfs_head *head$link1$link3;
  unsigned long int return_value___uatomic_exchange$1$link1$link3;
  return_value___uatomic_exchange$1$link1$link3=__uatomic_exchange$link2$link3((void *)&s$link1$link3->head, (unsigned long int)(void *)0x1UL, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  head$link1$link3 = (struct cds_wfs_head *)return_value___uatomic_exchange$1$link1$link3;
  _Bool return_value____cds_wfs_end$2$link1$link3;
  return_value____cds_wfs_end$2$link1$link3=___cds_wfs_end$link1$link3((void *)head$link1$link3);
  if(!(return_value____cds_wfs_end$2$link1$link3 == (_Bool)0))
    return (struct cds_wfs_head *)(void *)0;

  else
    return head$link1$link3;
}

// ___cds_wfs_pop_all$link2
// file ./urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link2(union anonymous u_stack$link2)
{
  struct __cds_wfs_stack *s$link2 = u_stack$link2._s;
  struct cds_wfs_head *head$link2;
  unsigned long int return_value___uatomic_exchange$1$link2;
  return_value___uatomic_exchange$1$link2=__uatomic_exchange$link4((void *)&s$link2->head, (unsigned long int)(void *)0x1UL, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  head$link2 = (struct cds_wfs_head *)return_value___uatomic_exchange$1$link2;
  _Bool return_value____cds_wfs_end$2$link2;
  return_value____cds_wfs_end$2$link2=___cds_wfs_end$link2((void *)head$link2);
  if(!(return_value____cds_wfs_end$2$link2 == (_Bool)0))
    return (struct cds_wfs_head *)(void *)0;

  else
    return head$link2;
}

// ___cds_wfs_pop_all$link3
// file ./urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link3(union anonymous u_stack$link3)
{
  struct __cds_wfs_stack *s$link3 = u_stack$link3._s;
  struct cds_wfs_head *head$link3;
  unsigned long int return_value___uatomic_exchange$1$link3;
  return_value___uatomic_exchange$1$link3=__uatomic_exchange$link5((void *)&s$link3->head, (unsigned long int)(void *)0x1UL, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  head$link3 = (struct cds_wfs_head *)return_value___uatomic_exchange$1$link3;
  _Bool return_value____cds_wfs_end$2$link3;
  return_value____cds_wfs_end$2$link3=___cds_wfs_end$link3((void *)head$link3);
  if(!(return_value____cds_wfs_end$2$link3 == (_Bool)0))
    return (struct cds_wfs_head *)(void *)0;

  else
    return head$link3;
}

// ___cds_wfs_pop_all$link4
// file ./urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link4(union anonymous u_stack$link4)
{
  struct __cds_wfs_stack *s$link4 = u_stack$link4._s;
  struct cds_wfs_head *head$link4;
  unsigned long int return_value___uatomic_exchange$1$link4;
  return_value___uatomic_exchange$1$link4=__uatomic_exchange$link6((void *)&s$link4->head, (unsigned long int)(void *)0x1UL, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  head$link4 = (struct cds_wfs_head *)return_value___uatomic_exchange$1$link4;
  _Bool return_value____cds_wfs_end$2$link4;
  return_value____cds_wfs_end$2$link4=___cds_wfs_end$link4((void *)head$link4);
  if(!(return_value____cds_wfs_end$2$link4 == (_Bool)0))
    return (struct cds_wfs_head *)(void *)0;

  else
    return head$link4;
}

// ___cds_wfs_pop_all$link5
// file urcu/static/wfstack.h line 284
static inline struct cds_wfs_head * ___cds_wfs_pop_all$link5(union anonymous u_stack$link5)
{
  struct __cds_wfs_stack *s$link5 = u_stack$link5._s;
  struct cds_wfs_head *head$link5;
  unsigned long int return_value___uatomic_exchange$1$link5;
  return_value___uatomic_exchange$1$link5=__uatomic_exchange$link2$link4((void *)&s$link5->head, (unsigned long int)(void *)0x1UL, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  head$link5 = (struct cds_wfs_head *)return_value___uatomic_exchange$1$link5;
  _Bool return_value____cds_wfs_end$2$link5;
  return_value____cds_wfs_end$2$link5=___cds_wfs_end$link5((void *)head$link5);
  if(!(return_value____cds_wfs_end$2$link5 == (_Bool)0))
    return (struct cds_wfs_head *)(void *)0;

  else
    return head$link5;
}

// ___cds_wfs_pop_blocking
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking(union anonymous u_stack)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_blocking$1;
  return_value____cds_wfs_pop_with_state_blocking$1=___cds_wfs_pop_with_state_blocking(u_stack, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_blocking$1;
}

// ___cds_wfs_pop_blocking$link1
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking$link1(union anonymous u_stack$link1)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_blocking$1$link1;
  return_value____cds_wfs_pop_with_state_blocking$1$link1=___cds_wfs_pop_with_state_blocking$link1(u_stack$link1, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_blocking$1$link1;
}

// ___cds_wfs_pop_blocking$link2
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking$link2(union anonymous u_stack$link2)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_blocking$1$link2;
  return_value____cds_wfs_pop_with_state_blocking$1$link2=___cds_wfs_pop_with_state_blocking$link2(u_stack$link2, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_blocking$1$link2;
}

// ___cds_wfs_pop_blocking$link3
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking$link3(union anonymous u_stack$link3)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_blocking$1$link3;
  return_value____cds_wfs_pop_with_state_blocking$1$link3=___cds_wfs_pop_with_state_blocking$link3(u_stack$link3, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_blocking$1$link3;
}

// ___cds_wfs_pop_blocking$link4
// file urcu/static/wfstack.h line 232
static inline struct cds_wfs_node * ___cds_wfs_pop_blocking$link4(union anonymous u_stack$link4)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_blocking$1$link4;
  return_value____cds_wfs_pop_with_state_blocking$1$link4=___cds_wfs_pop_with_state_blocking$link4(u_stack$link4, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_blocking$1$link4;
}

// ___cds_wfs_pop_nonblocking
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking(union anonymous u_stack)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_nonblocking$1;
  return_value____cds_wfs_pop_with_state_nonblocking$1=___cds_wfs_pop_with_state_nonblocking(u_stack, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_nonblocking$1;
}

// ___cds_wfs_pop_nonblocking$link1
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking$link1(union anonymous u_stack$link1)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_nonblocking$1$link1;
  return_value____cds_wfs_pop_with_state_nonblocking$1$link1=___cds_wfs_pop_with_state_nonblocking$link1(u_stack$link1, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_nonblocking$1$link1;
}

// ___cds_wfs_pop_nonblocking$link2
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking$link2(union anonymous u_stack$link2)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_nonblocking$1$link2;
  return_value____cds_wfs_pop_with_state_nonblocking$1$link2=___cds_wfs_pop_with_state_nonblocking$link2(u_stack$link2, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_nonblocking$1$link2;
}

// ___cds_wfs_pop_nonblocking$link3
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking$link3(union anonymous u_stack$link3)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_nonblocking$1$link3;
  return_value____cds_wfs_pop_with_state_nonblocking$1$link3=___cds_wfs_pop_with_state_nonblocking$link3(u_stack$link3, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_nonblocking$1$link3;
}

// ___cds_wfs_pop_nonblocking$link4
// file urcu/static/wfstack.h line 260
static inline struct cds_wfs_node * ___cds_wfs_pop_nonblocking$link4(union anonymous u_stack$link4)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_nonblocking$1$link4;
  return_value____cds_wfs_pop_with_state_nonblocking$1$link4=___cds_wfs_pop_with_state_nonblocking$link4(u_stack$link4, (signed int *)(void *)0);
  return return_value____cds_wfs_pop_with_state_nonblocking$1$link4;
}

// ___cds_wfs_pop_with_state_blocking
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking(union anonymous u_stack, signed int *state)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1;
  return_value____cds_wfs_pop$1=___cds_wfs_pop(u_stack, state, 1);
  return return_value____cds_wfs_pop$1;
}

// ___cds_wfs_pop_with_state_blocking$link1
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking$link1(union anonymous u_stack$link1, signed int *state$link1)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1$link1;
  return_value____cds_wfs_pop$1$link1=___cds_wfs_pop$link1(u_stack$link1, state$link1, 1);
  return return_value____cds_wfs_pop$1$link1;
}

// ___cds_wfs_pop_with_state_blocking$link2
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking$link2(union anonymous u_stack$link2, signed int *state$link2)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1$link2;
  return_value____cds_wfs_pop$1$link2=___cds_wfs_pop$link2(u_stack$link2, state$link2, 1);
  return return_value____cds_wfs_pop$1$link2;
}

// ___cds_wfs_pop_with_state_blocking$link3
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking$link3(union anonymous u_stack$link3, signed int *state$link3)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1$link3;
  return_value____cds_wfs_pop$1$link3=___cds_wfs_pop$link3(u_stack$link3, state$link3, 1);
  return return_value____cds_wfs_pop$1$link3;
}

// ___cds_wfs_pop_with_state_blocking$link4
// file urcu/static/wfstack.h line 225
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_blocking$link4(union anonymous u_stack$link4, signed int *state$link4)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1$link4;
  return_value____cds_wfs_pop$1$link4=___cds_wfs_pop$link4(u_stack$link4, state$link4, 1);
  return return_value____cds_wfs_pop$1$link4;
}

// ___cds_wfs_pop_with_state_nonblocking
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking(union anonymous u_stack, signed int *state)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1;
  return_value____cds_wfs_pop$1=___cds_wfs_pop(u_stack, state, 0);
  return return_value____cds_wfs_pop$1;
}

// ___cds_wfs_pop_with_state_nonblocking$link1
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking$link1(union anonymous u_stack$link1, signed int *state$link1)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1$link1;
  return_value____cds_wfs_pop$1$link1=___cds_wfs_pop$link1(u_stack$link1, state$link1, 0);
  return return_value____cds_wfs_pop$1$link1;
}

// ___cds_wfs_pop_with_state_nonblocking$link2
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking$link2(union anonymous u_stack$link2, signed int *state$link2)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1$link2;
  return_value____cds_wfs_pop$1$link2=___cds_wfs_pop$link2(u_stack$link2, state$link2, 0);
  return return_value____cds_wfs_pop$1$link2;
}

// ___cds_wfs_pop_with_state_nonblocking$link3
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking$link3(union anonymous u_stack$link3, signed int *state$link3)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1$link3;
  return_value____cds_wfs_pop$1$link3=___cds_wfs_pop$link3(u_stack$link3, state$link3, 0);
  return return_value____cds_wfs_pop$1$link3;
}

// ___cds_wfs_pop_with_state_nonblocking$link4
// file urcu/static/wfstack.h line 247
static inline struct cds_wfs_node * ___cds_wfs_pop_with_state_nonblocking$link4(union anonymous u_stack$link4, signed int *state$link4)
{
  struct cds_wfs_node *return_value____cds_wfs_pop$1$link4;
  return_value____cds_wfs_pop$1$link4=___cds_wfs_pop$link4(u_stack$link4, state$link4, 0);
  return return_value____cds_wfs_pop$1$link4;
}

// __cds_list_del
// file ./urcu/list.h line 71
static inline void __cds_list_del(struct cds_list_head *prev, struct cds_list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

// __cds_list_del$link1
// file ./urcu/list.h line 71
static inline void __cds_list_del$link1(struct cds_list_head *prev$link1, struct cds_list_head *next$link1)
{
  next$link1->prev = prev$link1;
  prev$link1->next = next$link1;
}

// __cds_list_del$link2
// file ./urcu/list.h line 71
static inline void __cds_list_del$link2(struct cds_list_head *prev$link2, struct cds_list_head *next$link2)
{
  next$link2->prev = prev$link2;
  prev$link2->next = next$link2;
}

// __cds_list_del$link3
// file ./urcu/list.h line 71
static inline void __cds_list_del$link3(struct cds_list_head *prev$link3, struct cds_list_head *next$link3)
{
  next$link3->prev = prev$link3;
  prev$link3->next = next$link3;
}

// __cds_list_del$link4
// file ./urcu/list.h line 71
static inline void __cds_list_del$link4(struct cds_list_head *prev$link4, struct cds_list_head *next$link4)
{
  next$link4->prev = prev$link4;
  prev$link4->next = next$link4;
}

// __cds_wfcq_dequeue_blocking
// file wfcqueue.c line 100
extern struct cds_wfcq_node * __cds_wfcq_dequeue_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_blocking$1;
  return_value____cds_wfcq_dequeue_blocking$1=___cds_wfcq_dequeue_blocking(head, tail);
  return return_value____cds_wfcq_dequeue_blocking$1;
}

// __cds_wfcq_dequeue_nonblocking
// file wfcqueue.c line 115
extern struct cds_wfcq_node * __cds_wfcq_dequeue_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_nonblocking$1;
  return_value____cds_wfcq_dequeue_nonblocking$1=___cds_wfcq_dequeue_nonblocking(head, tail);
  return return_value____cds_wfcq_dequeue_nonblocking$1;
}

// __cds_wfcq_dequeue_with_state_blocking
// file wfcqueue.c line 107
extern struct cds_wfcq_node * __cds_wfcq_dequeue_with_state_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail, signed int *state)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_blocking$1;
  return_value____cds_wfcq_dequeue_with_state_blocking$1=___cds_wfcq_dequeue_with_state_blocking(head, tail, state);
  return return_value____cds_wfcq_dequeue_with_state_blocking$1;
}

// __cds_wfcq_dequeue_with_state_nonblocking
// file wfcqueue.c line 122
extern struct cds_wfcq_node * __cds_wfcq_dequeue_with_state_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail, signed int *state)
{
  struct cds_wfcq_node *return_value____cds_wfcq_dequeue_with_state_nonblocking$1;
  return_value____cds_wfcq_dequeue_with_state_nonblocking$1=___cds_wfcq_dequeue_with_state_nonblocking(head, tail, state);
  return return_value____cds_wfcq_dequeue_with_state_nonblocking$1;
}

// __cds_wfcq_first_blocking
// file wfcqueue.c line 150
extern struct cds_wfcq_node * __cds_wfcq_first_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first_blocking$1;
  return_value____cds_wfcq_first_blocking$1=___cds_wfcq_first_blocking$link1(head, tail);
  return return_value____cds_wfcq_first_blocking$1;
}

// __cds_wfcq_first_nonblocking
// file wfcqueue.c line 157
extern struct cds_wfcq_node * __cds_wfcq_first_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value____cds_wfcq_first_nonblocking$1;
  return_value____cds_wfcq_first_nonblocking$1=___cds_wfcq_first_nonblocking(head, tail);
  return return_value____cds_wfcq_first_nonblocking$1;
}

// __cds_wfcq_init
// file wfcqueue.c line 43
extern void __cds_wfcq_init(struct __cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  ___cds_wfcq_init(head, tail);
}

// __cds_wfcq_next_blocking
// file wfcqueue.c line 164
extern struct cds_wfcq_node * __cds_wfcq_next_blocking(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$1;
  return_value____cds_wfcq_next_blocking$1=___cds_wfcq_next_blocking$link1(head, tail, node);
  return return_value____cds_wfcq_next_blocking$1;
}

// __cds_wfcq_next_nonblocking
// file wfcqueue.c line 172
extern struct cds_wfcq_node * __cds_wfcq_next_nonblocking(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node)
{
  struct cds_wfcq_node *return_value____cds_wfcq_next_nonblocking$1;
  return_value____cds_wfcq_next_nonblocking$1=___cds_wfcq_next_nonblocking(head, tail, node);
  return return_value____cds_wfcq_next_nonblocking$1;
}

// __cds_wfcq_splice_blocking
// file wfcqueue.c line 130
extern enum cds_wfcq_ret __cds_wfcq_splice_blocking(union anonymous$1 dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 src_q_head, struct cds_wfcq_tail *src_q_tail)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice_blocking$1;
  return_value____cds_wfcq_splice_blocking$1=___cds_wfcq_splice_blocking$link1(dest_q_head, dest_q_tail, src_q_head, src_q_tail);
  return return_value____cds_wfcq_splice_blocking$1;
}

// __cds_wfcq_splice_nonblocking
// file wfcqueue.c line 140
extern enum cds_wfcq_ret __cds_wfcq_splice_nonblocking(union anonymous$1 dest_q_head, struct cds_wfcq_tail *dest_q_tail, union anonymous$1 src_q_head, struct cds_wfcq_tail *src_q_tail)
{
  enum cds_wfcq_ret return_value____cds_wfcq_splice_nonblocking$1;
  return_value____cds_wfcq_splice_nonblocking$1=___cds_wfcq_splice_nonblocking(dest_q_head, dest_q_tail, src_q_head, src_q_tail);
  return return_value____cds_wfcq_splice_nonblocking$1;
}

// __cds_wfq_dequeue_blocking
// file wfqueue.c line 49
extern struct cds_wfq_node * __cds_wfq_dequeue_blocking(struct cds_wfq_queue *q)
{
  struct cds_wfq_node *return_value____cds_wfq_dequeue_blocking$1;
  return_value____cds_wfq_dequeue_blocking$1=___cds_wfq_dequeue_blocking(q);
  return return_value____cds_wfq_dequeue_blocking$1;
}

// __cds_wfs_init
// file wfstack.c line 41
extern void __cds_wfs_init(struct __cds_wfs_stack *s)
{
  ___cds_wfs_init(s);
}

// __cds_wfs_pop_all
// file wfstack.c line 121
extern struct cds_wfs_head * __cds_wfs_pop_all(union anonymous u_stack)
{
  struct cds_wfs_head *return_value____cds_wfs_pop_all$1;
  return_value____cds_wfs_pop_all$1=___cds_wfs_pop_all$link1(u_stack);
  return return_value____cds_wfs_pop_all$1;
}

// __cds_wfs_pop_blocking
// file wfstack.c line 97
extern struct cds_wfs_node * __cds_wfs_pop_blocking(union anonymous u_stack)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_blocking$1;
  return_value____cds_wfs_pop_blocking$1=___cds_wfs_pop_blocking(u_stack);
  return return_value____cds_wfs_pop_blocking$1;
}

// __cds_wfs_pop_nonblocking
// file wfstack.c line 109
extern struct cds_wfs_node * __cds_wfs_pop_nonblocking(union anonymous u_stack)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_nonblocking$1;
  return_value____cds_wfs_pop_nonblocking$1=___cds_wfs_pop_nonblocking(u_stack);
  return return_value____cds_wfs_pop_nonblocking$1;
}

// __cds_wfs_pop_with_state_blocking
// file wfstack.c line 103
extern struct cds_wfs_node * __cds_wfs_pop_with_state_blocking(union anonymous u_stack, signed int *state)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_blocking$1;
  return_value____cds_wfs_pop_with_state_blocking$1=___cds_wfs_pop_with_state_blocking(u_stack, state);
  return return_value____cds_wfs_pop_with_state_blocking$1;
}

// __cds_wfs_pop_with_state_nonblocking
// file wfstack.c line 115
extern struct cds_wfs_node * __cds_wfs_pop_with_state_nonblocking(union anonymous u_stack, signed int *state)
{
  struct cds_wfs_node *return_value____cds_wfs_pop_with_state_nonblocking$1;
  return_value____cds_wfs_pop_with_state_nonblocking$1=___cds_wfs_pop_with_state_nonblocking(u_stack, state);
  return return_value____cds_wfs_pop_with_state_nonblocking$1;
}

// __create_call_rcu_data
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data(unsigned long int flags, signed int cpu_affinity)
{
  struct call_rcu_data *crdp;
  call_rcu_data_init(&crdp, flags, cpu_affinity);
  return crdp;
}

// __create_call_rcu_data$link1
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data$link1(unsigned long int flags$link1, signed int cpu_affinity$link1)
{
  struct call_rcu_data *crdp$link1;
  call_rcu_data_init$link1(&crdp$link1, flags$link1, cpu_affinity$link1);
  return crdp$link1;
}

// __create_call_rcu_data$link2
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data$link2(unsigned long int flags$link2, signed int cpu_affinity$link2)
{
  struct call_rcu_data *crdp$link2;
  call_rcu_data_init$link2(&crdp$link2, flags$link2, cpu_affinity$link2);
  return crdp$link2;
}

// __create_call_rcu_data$link3
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data$link3(unsigned long int flags$link3, signed int cpu_affinity$link3)
{
  struct call_rcu_data *crdp$link3;
  call_rcu_data_init$link3(&crdp$link3, flags$link3, cpu_affinity$link3);
  return crdp$link3;
}

// __create_call_rcu_data$link4
// file urcu-call-rcu-impl.h line 481
static struct call_rcu_data * __create_call_rcu_data$link4(unsigned long int flags$link4, signed int cpu_affinity$link4)
{
  struct call_rcu_data *crdp$link4;
  call_rcu_data_init$link4(&crdp$link4, flags$link4, cpu_affinity$link4);
  return crdp$link4;
}

// __uatomic_add
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add(void *addr, unsigned long int val, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; addb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "iq"((unsigned char)val) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; addw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned short int)val) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; addl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned int)val) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; addq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "er"((unsigned long int)val) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_add$link1
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1)
{
  switch(len$link1)
  {
    case 1:
    {
      asm("lock; addb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "iq"((unsigned char)val$link1) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; addw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "ir"((unsigned short int)val$link1) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; addl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "ir"((unsigned int)val$link1) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; addq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "er"((unsigned long int)val$link1) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_add$link2
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2)
{
  switch(len$link2)
  {
    case 1:
    {
      asm("lock; addb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "iq"((unsigned char)val$link2) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; addw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "ir"((unsigned short int)val$link2) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; addl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "ir"((unsigned int)val$link2) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; addq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "er"((unsigned long int)val$link2) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_add$link3
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3)
{
  switch(len$link3)
  {
    case 1:
    {
      asm("lock; addb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "iq"((unsigned char)val$link3) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; addw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "ir"((unsigned short int)val$link3) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; addl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "ir"((unsigned int)val$link3) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; addq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "er"((unsigned long int)val$link3) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_add$link4
// file ./urcu/uatomic.h line 357
static inline void __uatomic_add$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4)
{
  switch(len$link4)
  {
    case 1:
    {
      asm("lock; addb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "iq"((unsigned char)val$link4) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; addw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "ir"((unsigned short int)val$link4) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; addl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "ir"((unsigned int)val$link4) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; addq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "er"((unsigned long int)val$link4) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_add_return
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return(void *addr, unsigned long int val, signed int len)
{
  unsigned char __uatomic_add_return$$1$$1$$1$$result;
  unsigned short int __uatomic_add_return$$1$$1$$2$$result;
  unsigned int __uatomic_add_return$$1$$1$$3$$result;
  unsigned long int result;
  switch(len)
  {
    case 1:
    {
      __uatomic_add_return$$1$$1$$1$$result = (unsigned char)val;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+q"(__uatomic_add_return$$1$$1$$1$$result) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$1$$result + (signed int)(unsigned char)val);
    }
    case 2:
    {
      __uatomic_add_return$$1$$1$$2$$result = (unsigned short int)val;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return$$1$$1$$2$$result) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$2$$result + (signed int)(unsigned short int)val);
    }
    case 4:
    {
      __uatomic_add_return$$1$$1$$3$$result = (unsigned int)val;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return$$1$$1$$3$$result) :  : "memory");
      return (unsigned long int)(__uatomic_add_return$$1$$1$$3$$result + (unsigned int)val);
    }
    case 8:
    {
      result = val;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(result) :  : "memory");
      return result + (unsigned long int)val;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_add_return$link1
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1)
{
  unsigned char result$link1;
  unsigned short int __uatomic_add_return$$1$$1$$2$$result$link1;
  unsigned int __uatomic_add_return$$1$$1$$3$$result$link1;
  unsigned long int __uatomic_add_return$$1$$1$$4$$result$link1;
  switch(len$link1)
  {
    case 1:
    {
      result$link1 = (unsigned char)val$link1;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link1)), "+q"(result$link1) :  : "memory");
      return (unsigned long int)((signed int)result$link1 + (signed int)(unsigned char)val$link1);
    }
    case 2:
    {
      __uatomic_add_return$$1$$1$$2$$result$link1 = (unsigned short int)val$link1;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link1)), "+r"(__uatomic_add_return$$1$$1$$2$$result$link1) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$2$$result$link1 + (signed int)(unsigned short int)val$link1);
    }
    case 4:
    {
      __uatomic_add_return$$1$$1$$3$$result$link1 = (unsigned int)val$link1;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link1)), "+r"(__uatomic_add_return$$1$$1$$3$$result$link1) :  : "memory");
      return (unsigned long int)(__uatomic_add_return$$1$$1$$3$$result$link1 + (unsigned int)val$link1);
    }
    case 8:
    {
      __uatomic_add_return$$1$$1$$4$$result$link1 = val$link1;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link1)), "+r"(__uatomic_add_return$$1$$1$$4$$result$link1) :  : "memory");
      return __uatomic_add_return$$1$$1$$4$$result$link1 + (unsigned long int)val$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_add_return$link2
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2)
{
  unsigned char result$link2;
  unsigned short int __uatomic_add_return$$1$$1$$2$$result$link2;
  unsigned int __uatomic_add_return$$1$$1$$3$$result$link2;
  unsigned long int __uatomic_add_return$$1$$1$$4$$result$link2;
  switch(len$link2)
  {
    case 1:
    {
      result$link2 = (unsigned char)val$link2;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link2)), "+q"(result$link2) :  : "memory");
      return (unsigned long int)((signed int)result$link2 + (signed int)(unsigned char)val$link2);
    }
    case 2:
    {
      __uatomic_add_return$$1$$1$$2$$result$link2 = (unsigned short int)val$link2;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link2)), "+r"(__uatomic_add_return$$1$$1$$2$$result$link2) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$2$$result$link2 + (signed int)(unsigned short int)val$link2);
    }
    case 4:
    {
      __uatomic_add_return$$1$$1$$3$$result$link2 = (unsigned int)val$link2;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link2)), "+r"(__uatomic_add_return$$1$$1$$3$$result$link2) :  : "memory");
      return (unsigned long int)(__uatomic_add_return$$1$$1$$3$$result$link2 + (unsigned int)val$link2);
    }
    case 8:
    {
      __uatomic_add_return$$1$$1$$4$$result$link2 = val$link2;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link2)), "+r"(__uatomic_add_return$$1$$1$$4$$result$link2) :  : "memory");
      return __uatomic_add_return$$1$$1$$4$$result$link2 + (unsigned long int)val$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_add_return$link3
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3)
{
  unsigned char __uatomic_add_return$$1$$1$$1$$result$link3;
  unsigned short int result$link3;
  unsigned int __uatomic_add_return$$1$$1$$3$$result$link3;
  unsigned long int __uatomic_add_return$$1$$1$$4$$result$link3;
  switch(len$link3)
  {
    case 1:
    {
      __uatomic_add_return$$1$$1$$1$$result$link3 = (unsigned char)val$link3;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link3)), "+q"(__uatomic_add_return$$1$$1$$1$$result$link3) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$1$$result$link3 + (signed int)(unsigned char)val$link3);
    }
    case 2:
    {
      result$link3 = (unsigned short int)val$link3;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link3)), "+r"(result$link3) :  : "memory");
      return (unsigned long int)((signed int)result$link3 + (signed int)(unsigned short int)val$link3);
    }
    case 4:
    {
      __uatomic_add_return$$1$$1$$3$$result$link3 = (unsigned int)val$link3;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link3)), "+r"(__uatomic_add_return$$1$$1$$3$$result$link3) :  : "memory");
      return (unsigned long int)(__uatomic_add_return$$1$$1$$3$$result$link3 + (unsigned int)val$link3);
    }
    case 8:
    {
      __uatomic_add_return$$1$$1$$4$$result$link3 = val$link3;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link3)), "+r"(__uatomic_add_return$$1$$1$$4$$result$link3) :  : "memory");
      return __uatomic_add_return$$1$$1$$4$$result$link3 + (unsigned long int)val$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_add_return$link4
// file ./urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4)
{
  unsigned char result$link4;
  unsigned short int __uatomic_add_return$$1$$1$$2$$result$link4;
  unsigned int __uatomic_add_return$$1$$1$$3$$result$link4;
  unsigned long int __uatomic_add_return$$1$$1$$4$$result$link4;
  switch(len$link4)
  {
    case 1:
    {
      result$link4 = (unsigned char)val$link4;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link4)), "+q"(result$link4) :  : "memory");
      return (unsigned long int)((signed int)result$link4 + (signed int)(unsigned char)val$link4);
    }
    case 2:
    {
      __uatomic_add_return$$1$$1$$2$$result$link4 = (unsigned short int)val$link4;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link4)), "+r"(__uatomic_add_return$$1$$1$$2$$result$link4) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$2$$result$link4 + (signed int)(unsigned short int)val$link4);
    }
    case 4:
    {
      __uatomic_add_return$$1$$1$$3$$result$link4 = (unsigned int)val$link4;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link4)), "+r"(__uatomic_add_return$$1$$1$$3$$result$link4) :  : "memory");
      return (unsigned long int)(__uatomic_add_return$$1$$1$$3$$result$link4 + (unsigned int)val$link4);
    }
    case 8:
    {
      __uatomic_add_return$$1$$1$$4$$result$link4 = val$link4;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link4)), "+r"(__uatomic_add_return$$1$$1$$4$$result$link4) :  : "memory");
      return __uatomic_add_return$$1$$1$$4$$result$link4 + (unsigned long int)val$link4;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_and
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and(void *addr, unsigned long int val, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; andb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "iq"((unsigned char)val) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; andw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned short int)val) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; andl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned int)val) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; andq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "er"((unsigned long int)val) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_and$link1
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1)
{
  switch(len$link1)
  {
    case 1:
    {
      asm("lock; andb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "iq"((unsigned char)val$link1) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; andw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "ir"((unsigned short int)val$link1) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; andl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "ir"((unsigned int)val$link1) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; andq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "er"((unsigned long int)val$link1) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_and$link2
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2)
{
  switch(len$link2)
  {
    case 1:
    {
      asm("lock; andb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "iq"((unsigned char)val$link2) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; andw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "ir"((unsigned short int)val$link2) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; andl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "ir"((unsigned int)val$link2) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; andq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "er"((unsigned long int)val$link2) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_and$link3
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3)
{
  switch(len$link3)
  {
    case 1:
    {
      asm("lock; andb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "iq"((unsigned char)val$link3) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; andw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "ir"((unsigned short int)val$link3) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; andl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "ir"((unsigned int)val$link3) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; andq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "er"((unsigned long int)val$link3) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_and$link4
// file ./urcu/uatomic.h line 245
static inline void __uatomic_and$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4)
{
  switch(len$link4)
  {
    case 1:
    {
      asm("lock; andb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "iq"((unsigned char)val$link4) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; andw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "ir"((unsigned short int)val$link4) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; andl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "ir"((unsigned int)val$link4) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; andq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "er"((unsigned long int)val$link4) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_cmpxchg
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg(void *addr, unsigned long int old, unsigned long int _new, signed int len)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result;
  unsigned long int result;
  switch(len)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result = (unsigned char)old;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "q"((unsigned char)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result = (unsigned short int)old;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned short int)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result = (unsigned int)old;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned int)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result;
    }
    case 8:
    {
      result = old;
      asm("lock; cmpxchgq %2, %1" : "+a"(result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned long int)_new) : "memory");
      return result;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link1
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1(void *addr$link1, unsigned long int old$link1, unsigned long int _new$link1, signed int len$link1)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link1;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link1;
  unsigned int result$link1;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link1;
  switch(len$link1)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link1 = (unsigned char)old$link1;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "q"((unsigned char)_new$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link1;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link1 = (unsigned short int)old$link1;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "r"((unsigned short int)_new$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link1;
    }
    case 4:
    {
      result$link1 = (unsigned int)old$link1;
      asm("lock; cmpxchgl %2, %1" : "+a"(result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "r"((unsigned int)_new$link1) : "memory");
      return (unsigned long int)result$link1;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link1 = old$link1;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "r"((unsigned long int)_new$link1) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link1$link1
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link1(void *addr$link1$link1, unsigned long int old$link1$link1, unsigned long int _new$link1$link1, signed int len$link1$link1)
{
  unsigned char result$link1$link1;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link1$link1;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link1$link1;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link1$link1;
  switch(len$link1$link1)
  {
    case 1:
    {
      result$link1$link1 = (unsigned char)old$link1$link1;
      asm("lock; cmpxchgb %2, %1" : "+a"(result$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1)) : "q"((unsigned char)_new$link1$link1) : "memory");
      return (unsigned long int)result$link1$link1;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link1$link1 = (unsigned short int)old$link1$link1;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1)) : "r"((unsigned short int)_new$link1$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link1$link1;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link1$link1 = (unsigned int)old$link1$link1;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1)) : "r"((unsigned int)_new$link1$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link1$link1;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link1$link1 = old$link1$link1;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1)) : "r"((unsigned long int)_new$link1$link1) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link1$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link1$link1$link1
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link1$link1(void *addr$link1$link1$link1, unsigned long int old$link1$link1$link1, unsigned long int _new$link1$link1$link1, signed int len$link1$link1$link1)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link1$link1$link1;
  unsigned short int result$link1$link1$link1;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link1$link1$link1;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link1$link1$link1;
  switch(len$link1$link1$link1)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link1$link1$link1 = (unsigned char)old$link1$link1$link1;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link1$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link1)) : "q"((unsigned char)_new$link1$link1$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link1$link1$link1;
    }
    case 2:
    {
      result$link1$link1$link1 = (unsigned short int)old$link1$link1$link1;
      asm("lock; cmpxchgw %2, %1" : "+a"(result$link1$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link1)) : "r"((unsigned short int)_new$link1$link1$link1) : "memory");
      return (unsigned long int)result$link1$link1$link1;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link1$link1$link1 = (unsigned int)old$link1$link1$link1;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link1$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link1)) : "r"((unsigned int)_new$link1$link1$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link1$link1$link1;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link1$link1$link1 = old$link1$link1$link1;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link1$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link1)) : "r"((unsigned long int)_new$link1$link1$link1) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link1$link1$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link1$link2
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link2(void *addr$link1$link2, unsigned long int old$link1$link2, unsigned long int _new$link1$link2, signed int len$link1$link2)
{
  unsigned char result$link1$link2;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link1$link2;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link1$link2;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link1$link2;
  switch(len$link1$link2)
  {
    case 1:
    {
      result$link1$link2 = (unsigned char)old$link1$link2;
      asm("lock; cmpxchgb %2, %1" : "+a"(result$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link2)) : "q"((unsigned char)_new$link1$link2) : "memory");
      return (unsigned long int)result$link1$link2;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link1$link2 = (unsigned short int)old$link1$link2;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link2)) : "r"((unsigned short int)_new$link1$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link1$link2;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link1$link2 = (unsigned int)old$link1$link2;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link2)) : "r"((unsigned int)_new$link1$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link1$link2;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link1$link2 = old$link1$link2;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link2)) : "r"((unsigned long int)_new$link1$link2) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link1$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link1$link3
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link3(void *addr$link1$link3, unsigned long int old$link1$link3, unsigned long int _new$link1$link3, signed int len$link1$link3)
{
  unsigned char result$link1$link3;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link1$link3;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link1$link3;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link1$link3;
  switch(len$link1$link3)
  {
    case 1:
    {
      result$link1$link3 = (unsigned char)old$link1$link3;
      asm("lock; cmpxchgb %2, %1" : "+a"(result$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link3)) : "q"((unsigned char)_new$link1$link3) : "memory");
      return (unsigned long int)result$link1$link3;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link1$link3 = (unsigned short int)old$link1$link3;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link3)) : "r"((unsigned short int)_new$link1$link3) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link1$link3;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link1$link3 = (unsigned int)old$link1$link3;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link3)) : "r"((unsigned int)_new$link1$link3) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link1$link3;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link1$link3 = old$link1$link3;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link3)) : "r"((unsigned long int)_new$link1$link3) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link1$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link1$link4
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1$link4(void *addr$link1$link4, unsigned long int old$link1$link4, unsigned long int _new$link1$link4, signed int len$link1$link4)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link1$link4;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link1$link4;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link1$link4;
  unsigned long int result$link1$link4;
  switch(len$link1$link4)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link1$link4 = (unsigned char)old$link1$link4;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link4)) : "q"((unsigned char)_new$link1$link4) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link1$link4;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link1$link4 = (unsigned short int)old$link1$link4;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link4)) : "r"((unsigned short int)_new$link1$link4) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link1$link4;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link1$link4 = (unsigned int)old$link1$link4;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link4)) : "r"((unsigned int)_new$link1$link4) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link1$link4;
    }
    case 8:
    {
      result$link1$link4 = old$link1$link4;
      asm("lock; cmpxchgq %2, %1" : "+a"(result$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link4)) : "r"((unsigned long int)_new$link1$link4) : "memory");
      return result$link1$link4;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link2
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2(void *addr$link2, unsigned long int old$link2, unsigned long int _new$link2, signed int len$link2)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link2;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link2;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link2;
  unsigned long int result$link2;
  switch(len$link2)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link2 = (unsigned char)old$link2;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "q"((unsigned char)_new$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link2;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link2 = (unsigned short int)old$link2;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "r"((unsigned short int)_new$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link2;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link2 = (unsigned int)old$link2;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "r"((unsigned int)_new$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link2;
    }
    case 8:
    {
      result$link2 = old$link2;
      asm("lock; cmpxchgq %2, %1" : "+a"(result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "r"((unsigned long int)_new$link2) : "memory");
      return result$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link2$link1
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2$link1(void *addr$link2$link1, unsigned long int old$link2$link1, unsigned long int _new$link2$link1, signed int len$link2$link1)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link2$link1;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link2$link1;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link2$link1;
  unsigned long int result$link2$link1;
  switch(len$link2$link1)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link2$link1 = (unsigned char)old$link2$link1;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link2$link1), "+m"(*((struct __uatomic_dummy *)addr$link2$link1)) : "q"((unsigned char)_new$link2$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link2$link1;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link2$link1 = (unsigned short int)old$link2$link1;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link2$link1), "+m"(*((struct __uatomic_dummy *)addr$link2$link1)) : "r"((unsigned short int)_new$link2$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link2$link1;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link2$link1 = (unsigned int)old$link2$link1;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link2$link1), "+m"(*((struct __uatomic_dummy *)addr$link2$link1)) : "r"((unsigned int)_new$link2$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link2$link1;
    }
    case 8:
    {
      result$link2$link1 = old$link2$link1;
      asm("lock; cmpxchgq %2, %1" : "+a"(result$link2$link1), "+m"(*((struct __uatomic_dummy *)addr$link2$link1)) : "r"((unsigned long int)_new$link2$link1) : "memory");
      return result$link2$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link2$link2
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2$link2(void *addr$link2$link2, unsigned long int old$link2$link2, unsigned long int _new$link2$link2, signed int len$link2$link2)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link2$link2;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link2$link2;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link2$link2;
  unsigned long int result$link2$link2;
  switch(len$link2$link2)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link2$link2 = (unsigned char)old$link2$link2;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link2$link2), "+m"(*((struct __uatomic_dummy *)addr$link2$link2)) : "q"((unsigned char)_new$link2$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link2$link2;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link2$link2 = (unsigned short int)old$link2$link2;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link2$link2), "+m"(*((struct __uatomic_dummy *)addr$link2$link2)) : "r"((unsigned short int)_new$link2$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link2$link2;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link2$link2 = (unsigned int)old$link2$link2;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link2$link2), "+m"(*((struct __uatomic_dummy *)addr$link2$link2)) : "r"((unsigned int)_new$link2$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link2$link2;
    }
    case 8:
    {
      result$link2$link2 = old$link2$link2;
      asm("lock; cmpxchgq %2, %1" : "+a"(result$link2$link2), "+m"(*((struct __uatomic_dummy *)addr$link2$link2)) : "r"((unsigned long int)_new$link2$link2) : "memory");
      return result$link2$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link2$link3
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2$link3(void *addr$link2$link3, unsigned long int old$link2$link3, unsigned long int _new$link2$link3, signed int len$link2$link3)
{
  unsigned char result$link2$link3;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link2$link3;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link2$link3;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link2$link3;
  switch(len$link2$link3)
  {
    case 1:
    {
      result$link2$link3 = (unsigned char)old$link2$link3;
      asm("lock; cmpxchgb %2, %1" : "+a"(result$link2$link3), "+m"(*((struct __uatomic_dummy *)addr$link2$link3)) : "q"((unsigned char)_new$link2$link3) : "memory");
      return (unsigned long int)result$link2$link3;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link2$link3 = (unsigned short int)old$link2$link3;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link2$link3), "+m"(*((struct __uatomic_dummy *)addr$link2$link3)) : "r"((unsigned short int)_new$link2$link3) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link2$link3;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link2$link3 = (unsigned int)old$link2$link3;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link2$link3), "+m"(*((struct __uatomic_dummy *)addr$link2$link3)) : "r"((unsigned int)_new$link2$link3) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link2$link3;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link2$link3 = old$link2$link3;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link2$link3), "+m"(*((struct __uatomic_dummy *)addr$link2$link3)) : "r"((unsigned long int)_new$link2$link3) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link2$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link2$link4
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2$link4(void *addr$link2$link4, unsigned long int old$link2$link4, unsigned long int _new$link2$link4, signed int len$link2$link4)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link2$link4;
  unsigned short int result$link2$link4;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link2$link4;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link2$link4;
  switch(len$link2$link4)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link2$link4 = (unsigned char)old$link2$link4;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link2$link4), "+m"(*((struct __uatomic_dummy *)addr$link2$link4)) : "q"((unsigned char)_new$link2$link4) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link2$link4;
    }
    case 2:
    {
      result$link2$link4 = (unsigned short int)old$link2$link4;
      asm("lock; cmpxchgw %2, %1" : "+a"(result$link2$link4), "+m"(*((struct __uatomic_dummy *)addr$link2$link4)) : "r"((unsigned short int)_new$link2$link4) : "memory");
      return (unsigned long int)result$link2$link4;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link2$link4 = (unsigned int)old$link2$link4;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link2$link4), "+m"(*((struct __uatomic_dummy *)addr$link2$link4)) : "r"((unsigned int)_new$link2$link4) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link2$link4;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link2$link4 = old$link2$link4;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link2$link4), "+m"(*((struct __uatomic_dummy *)addr$link2$link4)) : "r"((unsigned long int)_new$link2$link4) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link2$link4;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link3
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link3(void *addr$link3, unsigned long int old$link3, unsigned long int _new$link3, signed int len$link3)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link3;
  unsigned short int result$link3;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link3;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link3;
  switch(len$link3)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link3 = (unsigned char)old$link3;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link3), "+m"(*((struct __uatomic_dummy *)addr$link3)) : "q"((unsigned char)_new$link3) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link3;
    }
    case 2:
    {
      result$link3 = (unsigned short int)old$link3;
      asm("lock; cmpxchgw %2, %1" : "+a"(result$link3), "+m"(*((struct __uatomic_dummy *)addr$link3)) : "r"((unsigned short int)_new$link3) : "memory");
      return (unsigned long int)result$link3;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link3 = (unsigned int)old$link3;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link3), "+m"(*((struct __uatomic_dummy *)addr$link3)) : "r"((unsigned int)_new$link3) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link3;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link3 = old$link3;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link3), "+m"(*((struct __uatomic_dummy *)addr$link3)) : "r"((unsigned long int)_new$link3) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link4
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link4(void *addr$link4, unsigned long int old$link4, unsigned long int _new$link4, signed int len$link4)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link4;
  unsigned short int result$link4;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link4;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link4;
  switch(len$link4)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link4 = (unsigned char)old$link4;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link4), "+m"(*((struct __uatomic_dummy *)addr$link4)) : "q"((unsigned char)_new$link4) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link4;
    }
    case 2:
    {
      result$link4 = (unsigned short int)old$link4;
      asm("lock; cmpxchgw %2, %1" : "+a"(result$link4), "+m"(*((struct __uatomic_dummy *)addr$link4)) : "r"((unsigned short int)_new$link4) : "memory");
      return (unsigned long int)result$link4;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link4 = (unsigned int)old$link4;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link4), "+m"(*((struct __uatomic_dummy *)addr$link4)) : "r"((unsigned int)_new$link4) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link4;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link4 = old$link4;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link4), "+m"(*((struct __uatomic_dummy *)addr$link4)) : "r"((unsigned long int)_new$link4) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link4;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link5
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link5(void *addr$link5, unsigned long int old$link5, unsigned long int _new$link5, signed int len$link5)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link5;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link5;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link5;
  unsigned long int result$link5;
  switch(len$link5)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link5 = (unsigned char)old$link5;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link5), "+m"(*((struct __uatomic_dummy *)addr$link5)) : "q"((unsigned char)_new$link5) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link5;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link5 = (unsigned short int)old$link5;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link5), "+m"(*((struct __uatomic_dummy *)addr$link5)) : "r"((unsigned short int)_new$link5) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link5;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link5 = (unsigned int)old$link5;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link5), "+m"(*((struct __uatomic_dummy *)addr$link5)) : "r"((unsigned int)_new$link5) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link5;
    }
    case 8:
    {
      result$link5 = old$link5;
      asm("lock; cmpxchgq %2, %1" : "+a"(result$link5), "+m"(*((struct __uatomic_dummy *)addr$link5)) : "r"((unsigned long int)_new$link5) : "memory");
      return result$link5;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link6
// file ./urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link6(void *addr$link6, unsigned long int old$link6, unsigned long int _new$link6, signed int len$link6)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link6;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link6;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link6;
  unsigned long int result$link6;
  switch(len$link6)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link6 = (unsigned char)old$link6;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link6), "+m"(*((struct __uatomic_dummy *)addr$link6)) : "q"((unsigned char)_new$link6) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link6;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link6 = (unsigned short int)old$link6;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link6), "+m"(*((struct __uatomic_dummy *)addr$link6)) : "r"((unsigned short int)_new$link6) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link6;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link6 = (unsigned int)old$link6;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link6), "+m"(*((struct __uatomic_dummy *)addr$link6)) : "r"((unsigned int)_new$link6) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link6;
    }
    case 8:
    {
      result$link6 = old$link6;
      asm("lock; cmpxchgq %2, %1" : "+a"(result$link6), "+m"(*((struct __uatomic_dummy *)addr$link6)) : "r"((unsigned long int)_new$link6) : "memory");
      return result$link6;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_dec
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec(void *addr, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_dec$link1
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec$link1(void *addr$link1, signed int len$link1)
{
  switch(len$link1)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_dec$link2
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec$link2(void *addr$link2, signed int len$link2)
{
  switch(len$link2)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_dec$link3
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec$link3(void *addr$link3, signed int len$link3)
{
  switch(len$link3)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_dec$link4
// file ./urcu/uatomic.h line 467
static inline void __uatomic_dec$link4(void *addr$link4, signed int len$link4)
{
  switch(len$link4)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_exchange
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange(void *addr, unsigned long int val, signed int len)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result;
  unsigned int result;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result;
  switch(len)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "0"((unsigned char)val) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "0"((unsigned short int)val) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(result), "+m"(*((struct __uatomic_dummy *)addr)) : "0"((unsigned int)val) : "memory");
      return (unsigned long int)result;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "0"((unsigned long int)val) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link1;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link1;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link1;
  unsigned long int result$link1;
  switch(len$link1)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "0"((unsigned char)val$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link1;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "0"((unsigned short int)val$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link1;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "0"((unsigned int)val$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link1;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "0"((unsigned long int)val$link1) : "memory");
      return result$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1(void *addr$link1$link1, unsigned long int val$link1$link1, signed int len$link1$link1)
{
  unsigned char result$link1$link1;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link1$link1;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link1$link1;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link1$link1;
  switch(len$link1$link1)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(result$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1)) : "0"((unsigned char)val$link1$link1) : "memory");
      return (unsigned long int)result$link1$link1;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1)) : "0"((unsigned short int)val$link1$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link1$link1;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1)) : "0"((unsigned int)val$link1$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link1$link1;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1)) : "0"((unsigned long int)val$link1$link1) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link1$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1$link1$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1$link1(void *addr$link1$link1$link1, unsigned long int val$link1$link1$link1, signed int len$link1$link1$link1)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link1$link1$link1;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link1$link1$link1;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link1$link1$link1;
  unsigned long int result$link1$link1$link1;
  switch(len$link1$link1$link1)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link1$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link1)) : "0"((unsigned char)val$link1$link1$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link1$link1$link1;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link1$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link1)) : "0"((unsigned short int)val$link1$link1$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link1$link1$link1;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link1$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link1)) : "0"((unsigned int)val$link1$link1$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link1$link1$link1;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(result$link1$link1$link1), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link1)) : "0"((unsigned long int)val$link1$link1$link1) : "memory");
      return result$link1$link1$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1$link1$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1$link2(void *addr$link1$link1$link2, unsigned long int val$link1$link1$link2, signed int len$link1$link1$link2)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link1$link1$link2;
  unsigned short int result$link1$link1$link2;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link1$link1$link2;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link1$link1$link2;
  switch(len$link1$link1$link2)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link1$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link2)) : "0"((unsigned char)val$link1$link1$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link1$link1$link2;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(result$link1$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link2)) : "0"((unsigned short int)val$link1$link1$link2) : "memory");
      return (unsigned long int)result$link1$link1$link2;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link1$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link2)) : "0"((unsigned int)val$link1$link1$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link1$link1$link2;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link1$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link2)) : "0"((unsigned long int)val$link1$link1$link2) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link1$link1$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1$link1$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1$link3(void *addr$link1$link1$link3, unsigned long int val$link1$link1$link3, signed int len$link1$link1$link3)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link1$link1$link3;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link1$link1$link3;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link1$link1$link3;
  unsigned long int result$link1$link1$link3;
  switch(len$link1$link1$link3)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link1$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link3)) : "0"((unsigned char)val$link1$link1$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link1$link1$link3;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link1$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link3)) : "0"((unsigned short int)val$link1$link1$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link1$link1$link3;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link1$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link3)) : "0"((unsigned int)val$link1$link1$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link1$link1$link3;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(result$link1$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link3)) : "0"((unsigned long int)val$link1$link1$link3) : "memory");
      return result$link1$link1$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1$link1$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link1$link4(void *addr$link1$link1$link4, unsigned long int val$link1$link1$link4, signed int len$link1$link1$link4)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link1$link1$link4;
  unsigned short int result$link1$link1$link4;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link1$link1$link4;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link1$link1$link4;
  switch(len$link1$link1$link4)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link1$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link4)) : "0"((unsigned char)val$link1$link1$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link1$link1$link4;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(result$link1$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link4)) : "0"((unsigned short int)val$link1$link1$link4) : "memory");
      return (unsigned long int)result$link1$link1$link4;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link1$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link4)) : "0"((unsigned int)val$link1$link1$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link1$link1$link4;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link1$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link1$link4)) : "0"((unsigned long int)val$link1$link1$link4) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link1$link1$link4;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link2(void *addr$link1$link2, unsigned long int val$link1$link2, signed int len$link1$link2)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link1$link2;
  unsigned short int result$link1$link2;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link1$link2;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link1$link2;
  switch(len$link1$link2)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link2)) : "0"((unsigned char)val$link1$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link1$link2;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(result$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link2)) : "0"((unsigned short int)val$link1$link2) : "memory");
      return (unsigned long int)result$link1$link2;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link2)) : "0"((unsigned int)val$link1$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link1$link2;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link1$link2), "+m"(*((struct __uatomic_dummy *)addr$link1$link2)) : "0"((unsigned long int)val$link1$link2) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link1$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link3(void *addr$link1$link3, unsigned long int val$link1$link3, signed int len$link1$link3)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link1$link3;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link1$link3;
  unsigned int result$link1$link3;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link1$link3;
  switch(len$link1$link3)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link3)) : "0"((unsigned char)val$link1$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link1$link3;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link3)) : "0"((unsigned short int)val$link1$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link1$link3;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(result$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link3)) : "0"((unsigned int)val$link1$link3) : "memory");
      return (unsigned long int)result$link1$link3;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link1$link3), "+m"(*((struct __uatomic_dummy *)addr$link1$link3)) : "0"((unsigned long int)val$link1$link3) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link1$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link4(void *addr$link1$link4, unsigned long int val$link1$link4, signed int len$link1$link4)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link1$link4;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link1$link4;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link1$link4;
  unsigned long int result$link1$link4;
  switch(len$link1$link4)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link4)) : "0"((unsigned char)val$link1$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link1$link4;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link4)) : "0"((unsigned short int)val$link1$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link1$link4;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link4)) : "0"((unsigned int)val$link1$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link1$link4;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(result$link1$link4), "+m"(*((struct __uatomic_dummy *)addr$link1$link4)) : "0"((unsigned long int)val$link1$link4) : "memory");
      return result$link1$link4;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link1$link5
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link1$link5(void *addr$link1$link5, unsigned long int val$link1$link5, signed int len$link1$link5)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link1$link5;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link1$link5;
  unsigned int result$link1$link5;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link1$link5;
  switch(len$link1$link5)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link1$link5), "+m"(*((struct __uatomic_dummy *)addr$link1$link5)) : "0"((unsigned char)val$link1$link5) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link1$link5;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link1$link5), "+m"(*((struct __uatomic_dummy *)addr$link1$link5)) : "0"((unsigned short int)val$link1$link5) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link1$link5;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(result$link1$link5), "+m"(*((struct __uatomic_dummy *)addr$link1$link5)) : "0"((unsigned int)val$link1$link5) : "memory");
      return (unsigned long int)result$link1$link5;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link1$link5), "+m"(*((struct __uatomic_dummy *)addr$link1$link5)) : "0"((unsigned long int)val$link1$link5) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link1$link5;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link2;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link2;
  unsigned int result$link2;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link2;
  switch(len$link2)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "0"((unsigned char)val$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link2;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "0"((unsigned short int)val$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link2;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "0"((unsigned int)val$link2) : "memory");
      return (unsigned long int)result$link2;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "0"((unsigned long int)val$link2) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link2$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2$link1(void *addr$link2$link1, unsigned long int val$link2$link1, signed int len$link2$link1)
{
  unsigned char result$link2$link1;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link2$link1;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link2$link1;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link2$link1;
  switch(len$link2$link1)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(result$link2$link1), "+m"(*((struct __uatomic_dummy *)addr$link2$link1)) : "0"((unsigned char)val$link2$link1) : "memory");
      return (unsigned long int)result$link2$link1;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link2$link1), "+m"(*((struct __uatomic_dummy *)addr$link2$link1)) : "0"((unsigned short int)val$link2$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link2$link1;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link2$link1), "+m"(*((struct __uatomic_dummy *)addr$link2$link1)) : "0"((unsigned int)val$link2$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link2$link1;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link2$link1), "+m"(*((struct __uatomic_dummy *)addr$link2$link1)) : "0"((unsigned long int)val$link2$link1) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link2$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link2$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2$link2(void *addr$link2$link2, unsigned long int val$link2$link2, signed int len$link2$link2)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link2$link2;
  unsigned short int result$link2$link2;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link2$link2;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link2$link2;
  switch(len$link2$link2)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link2$link2), "+m"(*((struct __uatomic_dummy *)addr$link2$link2)) : "0"((unsigned char)val$link2$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link2$link2;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(result$link2$link2), "+m"(*((struct __uatomic_dummy *)addr$link2$link2)) : "0"((unsigned short int)val$link2$link2) : "memory");
      return (unsigned long int)result$link2$link2;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link2$link2), "+m"(*((struct __uatomic_dummy *)addr$link2$link2)) : "0"((unsigned int)val$link2$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link2$link2;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link2$link2), "+m"(*((struct __uatomic_dummy *)addr$link2$link2)) : "0"((unsigned long int)val$link2$link2) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link2$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link2$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2$link3(void *addr$link2$link3, unsigned long int val$link2$link3, signed int len$link2$link3)
{
  unsigned char result$link2$link3;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link2$link3;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link2$link3;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link2$link3;
  switch(len$link2$link3)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(result$link2$link3), "+m"(*((struct __uatomic_dummy *)addr$link2$link3)) : "0"((unsigned char)val$link2$link3) : "memory");
      return (unsigned long int)result$link2$link3;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link2$link3), "+m"(*((struct __uatomic_dummy *)addr$link2$link3)) : "0"((unsigned short int)val$link2$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link2$link3;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link2$link3), "+m"(*((struct __uatomic_dummy *)addr$link2$link3)) : "0"((unsigned int)val$link2$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link2$link3;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link2$link3), "+m"(*((struct __uatomic_dummy *)addr$link2$link3)) : "0"((unsigned long int)val$link2$link3) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link2$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link2$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link2$link4(void *addr$link2$link4, unsigned long int val$link2$link4, signed int len$link2$link4)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link2$link4;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link2$link4;
  unsigned int result$link2$link4;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link2$link4;
  switch(len$link2$link4)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link2$link4), "+m"(*((struct __uatomic_dummy *)addr$link2$link4)) : "0"((unsigned char)val$link2$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link2$link4;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link2$link4), "+m"(*((struct __uatomic_dummy *)addr$link2$link4)) : "0"((unsigned short int)val$link2$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link2$link4;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(result$link2$link4), "+m"(*((struct __uatomic_dummy *)addr$link2$link4)) : "0"((unsigned int)val$link2$link4) : "memory");
      return (unsigned long int)result$link2$link4;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link2$link4), "+m"(*((struct __uatomic_dummy *)addr$link2$link4)) : "0"((unsigned long int)val$link2$link4) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link2$link4;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3)
{
  unsigned char result$link3;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link3;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link3;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link3;
  switch(len$link3)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(result$link3), "+m"(*((struct __uatomic_dummy *)addr$link3)) : "0"((unsigned char)val$link3) : "memory");
      return (unsigned long int)result$link3;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link3), "+m"(*((struct __uatomic_dummy *)addr$link3)) : "0"((unsigned short int)val$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link3;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link3), "+m"(*((struct __uatomic_dummy *)addr$link3)) : "0"((unsigned int)val$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link3;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link3), "+m"(*((struct __uatomic_dummy *)addr$link3)) : "0"((unsigned long int)val$link3) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link3$link1
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3$link1(void *addr$link3$link1, unsigned long int val$link3$link1, signed int len$link3$link1)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link3$link1;
  unsigned short int result$link3$link1;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link3$link1;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link3$link1;
  switch(len$link3$link1)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link3$link1), "+m"(*((struct __uatomic_dummy *)addr$link3$link1)) : "0"((unsigned char)val$link3$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link3$link1;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(result$link3$link1), "+m"(*((struct __uatomic_dummy *)addr$link3$link1)) : "0"((unsigned short int)val$link3$link1) : "memory");
      return (unsigned long int)result$link3$link1;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link3$link1), "+m"(*((struct __uatomic_dummy *)addr$link3$link1)) : "0"((unsigned int)val$link3$link1) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link3$link1;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link3$link1), "+m"(*((struct __uatomic_dummy *)addr$link3$link1)) : "0"((unsigned long int)val$link3$link1) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link3$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link3$link2
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3$link2(void *addr$link3$link2, unsigned long int val$link3$link2, signed int len$link3$link2)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link3$link2;
  unsigned short int result$link3$link2;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link3$link2;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link3$link2;
  switch(len$link3$link2)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link3$link2), "+m"(*((struct __uatomic_dummy *)addr$link3$link2)) : "0"((unsigned char)val$link3$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link3$link2;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(result$link3$link2), "+m"(*((struct __uatomic_dummy *)addr$link3$link2)) : "0"((unsigned short int)val$link3$link2) : "memory");
      return (unsigned long int)result$link3$link2;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link3$link2), "+m"(*((struct __uatomic_dummy *)addr$link3$link2)) : "0"((unsigned int)val$link3$link2) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link3$link2;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link3$link2), "+m"(*((struct __uatomic_dummy *)addr$link3$link2)) : "0"((unsigned long int)val$link3$link2) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link3$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link3$link3
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3$link3(void *addr$link3$link3, unsigned long int val$link3$link3, signed int len$link3$link3)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link3$link3;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link3$link3;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link3$link3;
  unsigned long int result$link3$link3;
  switch(len$link3$link3)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link3$link3), "+m"(*((struct __uatomic_dummy *)addr$link3$link3)) : "0"((unsigned char)val$link3$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link3$link3;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link3$link3), "+m"(*((struct __uatomic_dummy *)addr$link3$link3)) : "0"((unsigned short int)val$link3$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link3$link3;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link3$link3), "+m"(*((struct __uatomic_dummy *)addr$link3$link3)) : "0"((unsigned int)val$link3$link3) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link3$link3;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(result$link3$link3), "+m"(*((struct __uatomic_dummy *)addr$link3$link3)) : "0"((unsigned long int)val$link3$link3) : "memory");
      return result$link3$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link3$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link3$link4(void *addr$link3$link4, unsigned long int val$link3$link4, signed int len$link3$link4)
{
  unsigned char result$link3$link4;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link3$link4;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link3$link4;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link3$link4;
  switch(len$link3$link4)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(result$link3$link4), "+m"(*((struct __uatomic_dummy *)addr$link3$link4)) : "0"((unsigned char)val$link3$link4) : "memory");
      return (unsigned long int)result$link3$link4;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link3$link4), "+m"(*((struct __uatomic_dummy *)addr$link3$link4)) : "0"((unsigned short int)val$link3$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link3$link4;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link3$link4), "+m"(*((struct __uatomic_dummy *)addr$link3$link4)) : "0"((unsigned int)val$link3$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link3$link4;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link3$link4), "+m"(*((struct __uatomic_dummy *)addr$link3$link4)) : "0"((unsigned long int)val$link3$link4) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link3$link4;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link4
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4)
{
  unsigned char result$link4;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link4;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link4;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link4;
  switch(len$link4)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(result$link4), "+m"(*((struct __uatomic_dummy *)addr$link4)) : "0"((unsigned char)val$link4) : "memory");
      return (unsigned long int)result$link4;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link4), "+m"(*((struct __uatomic_dummy *)addr$link4)) : "0"((unsigned short int)val$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link4;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link4), "+m"(*((struct __uatomic_dummy *)addr$link4)) : "0"((unsigned int)val$link4) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link4;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link4), "+m"(*((struct __uatomic_dummy *)addr$link4)) : "0"((unsigned long int)val$link4) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link4;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link5
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link5(void *addr$link5, unsigned long int val$link5, signed int len$link5)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link5;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link5;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link5;
  unsigned long int result$link5;
  switch(len$link5)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link5), "+m"(*((struct __uatomic_dummy *)addr$link5)) : "0"((unsigned char)val$link5) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link5;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link5), "+m"(*((struct __uatomic_dummy *)addr$link5)) : "0"((unsigned short int)val$link5) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link5;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link5), "+m"(*((struct __uatomic_dummy *)addr$link5)) : "0"((unsigned int)val$link5) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link5;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(result$link5), "+m"(*((struct __uatomic_dummy *)addr$link5)) : "0"((unsigned long int)val$link5) : "memory");
      return result$link5;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link6
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link6(void *addr$link6, unsigned long int val$link6, signed int len$link6)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link6;
  unsigned short int result$link6;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link6;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result$link6;
  switch(len$link6)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link6), "+m"(*((struct __uatomic_dummy *)addr$link6)) : "0"((unsigned char)val$link6) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link6;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(result$link6), "+m"(*((struct __uatomic_dummy *)addr$link6)) : "0"((unsigned short int)val$link6) : "memory");
      return (unsigned long int)result$link6;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link6), "+m"(*((struct __uatomic_dummy *)addr$link6)) : "0"((unsigned int)val$link6) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link6;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result$link6), "+m"(*((struct __uatomic_dummy *)addr$link6)) : "0"((unsigned long int)val$link6) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result$link6;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_exchange$link7
// file ./urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange$link7(void *addr$link7, unsigned long int val$link7, signed int len$link7)
{
  unsigned char __uatomic_exchange$$1$$1$$1$$result$link7;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result$link7;
  unsigned int __uatomic_exchange$$1$$1$$3$$result$link7;
  unsigned long int result$link7;
  switch(len$link7)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(__uatomic_exchange$$1$$1$$1$$result$link7), "+m"(*((struct __uatomic_dummy *)addr$link7)) : "0"((unsigned char)val$link7) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$1$$result$link7;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result$link7), "+m"(*((struct __uatomic_dummy *)addr$link7)) : "0"((unsigned short int)val$link7) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result$link7;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result$link7), "+m"(*((struct __uatomic_dummy *)addr$link7)) : "0"((unsigned int)val$link7) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result$link7;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(result$link7), "+m"(*((struct __uatomic_dummy *)addr$link7)) : "0"((unsigned long int)val$link7) : "memory");
      return result$link7;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_inc
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc(void *addr, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_inc$link1
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc$link1(void *addr$link1, signed int len$link1)
{
  switch(len$link1)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_inc$link2
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc$link2(void *addr$link2, signed int len$link2)
{
  switch(len$link2)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_inc$link3
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc$link3(void *addr$link3, signed int len$link3)
{
  switch(len$link3)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_inc$link4
// file ./urcu/uatomic.h line 414
static inline void __uatomic_inc$link4(void *addr$link4, signed int len$link4)
{
  switch(len$link4)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_or
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or(void *addr, unsigned long int val, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; orb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "iq"((unsigned char)val) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; orw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned short int)val) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; orl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned int)val) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; orq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "er"((unsigned long int)val) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_or$link1
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1)
{
  switch(len$link1)
  {
    case 1:
    {
      asm("lock; orb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "iq"((unsigned char)val$link1) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; orw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "ir"((unsigned short int)val$link1) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; orl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "ir"((unsigned int)val$link1) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; orq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "er"((unsigned long int)val$link1) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_or$link2
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2)
{
  switch(len$link2)
  {
    case 1:
    {
      asm("lock; orb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "iq"((unsigned char)val$link2) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; orw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "ir"((unsigned short int)val$link2) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; orl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "ir"((unsigned int)val$link2) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; orq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "er"((unsigned long int)val$link2) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_or$link3
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3)
{
  switch(len$link3)
  {
    case 1:
    {
      asm("lock; orb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "iq"((unsigned char)val$link3) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; orw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "ir"((unsigned short int)val$link3) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; orl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "ir"((unsigned int)val$link3) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; orq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link3)) : "er"((unsigned long int)val$link3) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_or$link4
// file ./urcu/uatomic.h line 301
static inline void __uatomic_or$link4(void *addr$link4, unsigned long int val$link4, signed int len$link4)
{
  switch(len$link4)
  {
    case 1:
    {
      asm("lock; orb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "iq"((unsigned char)val$link4) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; orw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "ir"((unsigned short int)val$link4) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; orl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "ir"((unsigned int)val$link4) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; orq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link4)) : "er"((unsigned long int)val$link4) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// _call_rcu
// file urcu-call-rcu-impl.h line 680
static void _call_rcu(struct rcu_head *head, void (*func)(struct rcu_head *), struct call_rcu_data *crdp)
{
  _cds_wfcq_node_init(&head->next);
  head->func = func;
  _cds_wfcq_enqueue(&crdp->cbs_head, &crdp->cbs_tail, &head->next);
  __uatomic_inc((void *)&crdp->qlen, (signed int)sizeof(unsigned long int) /*8ul*/ );
  wake_call_rcu_thread(crdp);
}

// _call_rcu$link1
// file urcu-call-rcu-impl.h line 680
static void _call_rcu$link1(struct rcu_head *head$link1, void (*func$link1)(struct rcu_head *), struct call_rcu_data *crdp$link1)
{
  _cds_wfcq_node_init$link2(&head$link1->next);
  head$link1->func = func$link1;
  _cds_wfcq_enqueue$link2(&crdp$link1->cbs_head, &crdp$link1->cbs_tail, &head$link1->next);
  __uatomic_inc$link1((void *)&crdp$link1->qlen, (signed int)sizeof(unsigned long int) /*8ul*/ );
  wake_call_rcu_thread$link1(crdp$link1);
}

// _call_rcu$link2
// file urcu-call-rcu-impl.h line 680
static void _call_rcu$link2(struct rcu_head *head$link2, void (*func$link2)(struct rcu_head *), struct call_rcu_data *crdp$link2)
{
  _cds_wfcq_node_init$link3(&head$link2->next);
  head$link2->func = func$link2;
  _cds_wfcq_enqueue$link3(&crdp$link2->cbs_head, &crdp$link2->cbs_tail, &head$link2->next);
  __uatomic_inc$link2((void *)&crdp$link2->qlen, (signed int)sizeof(unsigned long int) /*8ul*/ );
  wake_call_rcu_thread$link2(crdp$link2);
}

// _call_rcu$link3
// file urcu-call-rcu-impl.h line 680
static void _call_rcu$link3(struct rcu_head *head$link3, void (*func$link3)(struct rcu_head *), struct call_rcu_data *crdp$link3)
{
  _cds_wfcq_node_init$link4(&head$link3->next);
  head$link3->func = func$link3;
  _cds_wfcq_enqueue$link4(&crdp$link3->cbs_head, &crdp$link3->cbs_tail, &head$link3->next);
  __uatomic_inc$link3((void *)&crdp$link3->qlen, (signed int)sizeof(unsigned long int) /*8ul*/ );
  wake_call_rcu_thread$link3(crdp$link3);
}

// _call_rcu$link4
// file urcu-call-rcu-impl.h line 680
static void _call_rcu$link4(struct rcu_head *head$link4, void (*func$link4)(struct rcu_head *), struct call_rcu_data *crdp$link4)
{
  _cds_wfcq_node_init$link5(&head$link4->next);
  head$link4->func = func$link4;
  _cds_wfcq_enqueue$link5(&crdp$link4->cbs_head, &crdp$link4->cbs_tail, &head$link4->next);
  __uatomic_inc$link4((void *)&crdp$link4->qlen, (signed int)sizeof(unsigned long int) /*8ul*/ );
  wake_call_rcu_thread$link4(crdp$link4);
}

// _cds_wfcq_dequeue_blocking
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value__cds_wfcq_dequeue_with_state_blocking$1;
  return_value__cds_wfcq_dequeue_with_state_blocking$1=_cds_wfcq_dequeue_with_state_blocking(head, tail, (signed int *)(void *)0);
  return return_value__cds_wfcq_dequeue_with_state_blocking$1;
}

// _cds_wfcq_dequeue_blocking$link1
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1)
{
  struct cds_wfcq_node *return_value__cds_wfcq_dequeue_with_state_blocking$1$link1;
  return_value__cds_wfcq_dequeue_with_state_blocking$1$link1=_cds_wfcq_dequeue_with_state_blocking$link1(head$link1, tail$link1, (signed int *)(void *)0);
  return return_value__cds_wfcq_dequeue_with_state_blocking$1$link1;
}

// _cds_wfcq_dequeue_blocking$link2
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2)
{
  struct cds_wfcq_node *return_value__cds_wfcq_dequeue_with_state_blocking$1$link2;
  return_value__cds_wfcq_dequeue_with_state_blocking$1$link2=_cds_wfcq_dequeue_with_state_blocking$link2(head$link2, tail$link2, (signed int *)(void *)0);
  return return_value__cds_wfcq_dequeue_with_state_blocking$1$link2;
}

// _cds_wfcq_dequeue_blocking$link3
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3)
{
  struct cds_wfcq_node *return_value__cds_wfcq_dequeue_with_state_blocking$1$link3;
  return_value__cds_wfcq_dequeue_with_state_blocking$1$link3=_cds_wfcq_dequeue_with_state_blocking$link3(head$link3, tail$link3, (signed int *)(void *)0);
  return return_value__cds_wfcq_dequeue_with_state_blocking$1$link3;
}

// _cds_wfcq_dequeue_blocking$link4
// file urcu/static/wfcqueue.h line 613
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_blocking$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4)
{
  struct cds_wfcq_node *return_value__cds_wfcq_dequeue_with_state_blocking$1$link4;
  return_value__cds_wfcq_dequeue_with_state_blocking$1$link4=_cds_wfcq_dequeue_with_state_blocking$link4(head$link4, tail$link4, (signed int *)(void *)0);
  return return_value__cds_wfcq_dequeue_with_state_blocking$1$link4;
}

// _cds_wfcq_dequeue_lock
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  signed int ret;
  ret=pthread_mutex_lock(&head->lock);
  /* assertion !ret */
  assert(!(ret != 0));
}

// _cds_wfcq_dequeue_lock$link1
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1)
{
  signed int ret$link1;
  ret$link1=pthread_mutex_lock(&head$link1->lock);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
}

// _cds_wfcq_dequeue_lock$link2
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2)
{
  signed int ret$link2;
  ret$link2=pthread_mutex_lock(&head$link2->lock);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
}

// _cds_wfcq_dequeue_lock$link3
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3)
{
  signed int ret$link3;
  ret$link3=pthread_mutex_lock(&head$link3->lock);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
}

// _cds_wfcq_dequeue_lock$link4
// file urcu/static/wfcqueue.h line 147
static inline void _cds_wfcq_dequeue_lock$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4)
{
  signed int ret$link4;
  ret$link4=pthread_mutex_lock(&head$link4->lock);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
}

// _cds_wfcq_dequeue_unlock
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  signed int ret;
  ret=pthread_mutex_unlock(&head->lock);
  /* assertion !ret */
  assert(!(ret != 0));
}

// _cds_wfcq_dequeue_unlock$link1
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1)
{
  signed int ret$link1;
  ret$link1=pthread_mutex_unlock(&head$link1->lock);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
}

// _cds_wfcq_dequeue_unlock$link2
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2)
{
  signed int ret$link2;
  ret$link2=pthread_mutex_unlock(&head$link2->lock);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
}

// _cds_wfcq_dequeue_unlock$link3
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3)
{
  signed int ret$link3;
  ret$link3=pthread_mutex_unlock(&head$link3->lock);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
}

// _cds_wfcq_dequeue_unlock$link4
// file urcu/static/wfcqueue.h line 156
static inline void _cds_wfcq_dequeue_unlock$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4)
{
  signed int ret$link4;
  ret$link4=pthread_mutex_unlock(&head$link4->lock);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
}

// _cds_wfcq_dequeue_with_state_blocking
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail, signed int *state)
{
  struct cds_wfcq_node *retval;
  _cds_wfcq_dequeue_lock(head, tail);
  retval=___cds_wfcq_dequeue_with_state_blocking(head, tail, state);
  _cds_wfcq_dequeue_unlock(head, tail);
  return retval;
}

// _cds_wfcq_dequeue_with_state_blocking$link1
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1, signed int *state$link1)
{
  struct cds_wfcq_node *retval$link1;
  _cds_wfcq_dequeue_lock$link1(head$link1, tail$link1);
  retval$link1=___cds_wfcq_dequeue_with_state_blocking$link1(head$link1, tail$link1, state$link1);
  _cds_wfcq_dequeue_unlock$link1(head$link1, tail$link1);
  return retval$link1;
}

// _cds_wfcq_dequeue_with_state_blocking$link2
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2, signed int *state$link2)
{
  struct cds_wfcq_node *retval$link2;
  _cds_wfcq_dequeue_lock$link2(head$link2, tail$link2);
  retval$link2=___cds_wfcq_dequeue_with_state_blocking$link2(head$link2, tail$link2, state$link2);
  _cds_wfcq_dequeue_unlock$link2(head$link2, tail$link2);
  return retval$link2;
}

// _cds_wfcq_dequeue_with_state_blocking$link3
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3, signed int *state$link3)
{
  struct cds_wfcq_node *retval$link3;
  _cds_wfcq_dequeue_lock$link3(head$link3, tail$link3);
  retval$link3=___cds_wfcq_dequeue_with_state_blocking$link3(head$link3, tail$link3, state$link3);
  _cds_wfcq_dequeue_unlock$link3(head$link3, tail$link3);
  return retval$link3;
}

// _cds_wfcq_dequeue_with_state_blocking$link4
// file urcu/static/wfcqueue.h line 596
static inline struct cds_wfcq_node * _cds_wfcq_dequeue_with_state_blocking$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4, signed int *state$link4)
{
  struct cds_wfcq_node *retval$link4;
  _cds_wfcq_dequeue_lock$link4(head$link4, tail$link4);
  retval$link4=___cds_wfcq_dequeue_with_state_blocking$link4(head$link4, tail$link4, state$link4);
  _cds_wfcq_dequeue_unlock$link4(head$link4, tail$link4);
  return retval$link4;
}

// _cds_wfcq_empty
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty(union anonymous$1 u_head, struct cds_wfcq_tail *tail)
{
  struct __cds_wfcq_head *head = u_head._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((struct cds_wfcq_node * volatile *)&head->node.next);
  _Bool tmp_if_expr$3;
  struct cds_wfcq_node * volatile tmp_statement_expression$2;
  if(tmp_statement_expression$1 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((struct cds_wfcq_node * volatile *)&tail->p);
    tmp_if_expr$3 = tmp_statement_expression$2 == &head->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return tmp_if_expr$3;
}

// _cds_wfcq_empty$link1
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1(union anonymous$1 u_head$link1, struct cds_wfcq_tail *tail$link1)
{
  struct __cds_wfcq_head *head$link1 = u_head$link1._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((struct cds_wfcq_node * volatile *)&head$link1->node.next);
  _Bool tmp_if_expr$3$link1;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1;
  if(tmp_statement_expression$1$link1 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link1 = *((struct cds_wfcq_node * volatile *)&tail$link1->p);
    tmp_if_expr$3$link1 = tmp_statement_expression$2$link1 == &head$link1->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1 = (_Bool)0;
  return tmp_if_expr$3$link1;
}

// _cds_wfcq_empty$link1$link1
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1$link1(union anonymous$1 u_head$link1$link1, struct cds_wfcq_tail *tail$link1$link1)
{
  struct __cds_wfcq_head *head$link1$link1 = u_head$link1$link1._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1$link1 = *((struct cds_wfcq_node * volatile *)&head$link1$link1->node.next);
  _Bool tmp_if_expr$3$link1$link1;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link1;
  if(tmp_statement_expression$1$link1$link1 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link1$link1 = *((struct cds_wfcq_node * volatile *)&tail$link1$link1->p);
    tmp_if_expr$3$link1$link1 = tmp_statement_expression$2$link1$link1 == &head$link1$link1->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1$link1 = (_Bool)0;
  return tmp_if_expr$3$link1$link1;
}

// _cds_wfcq_empty$link1$link2
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1$link2(union anonymous$1 u_head$link1$link2, struct cds_wfcq_tail *tail$link1$link2)
{
  struct __cds_wfcq_head *head$link1$link2 = u_head$link1$link2._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1$link2 = *((struct cds_wfcq_node * volatile *)&head$link1$link2->node.next);
  _Bool tmp_if_expr$3$link1$link2;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link2;
  if(tmp_statement_expression$1$link1$link2 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link1$link2 = *((struct cds_wfcq_node * volatile *)&tail$link1$link2->p);
    tmp_if_expr$3$link1$link2 = tmp_statement_expression$2$link1$link2 == &head$link1$link2->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1$link2 = (_Bool)0;
  return tmp_if_expr$3$link1$link2;
}

// _cds_wfcq_empty$link1$link3
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1$link3(union anonymous$1 u_head$link1$link3, struct cds_wfcq_tail *tail$link1$link3)
{
  struct __cds_wfcq_head *head$link1$link3 = u_head$link1$link3._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1$link3 = *((struct cds_wfcq_node * volatile *)&head$link1$link3->node.next);
  _Bool tmp_if_expr$3$link1$link3;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link3;
  if(tmp_statement_expression$1$link1$link3 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link1$link3 = *((struct cds_wfcq_node * volatile *)&tail$link1$link3->p);
    tmp_if_expr$3$link1$link3 = tmp_statement_expression$2$link1$link3 == &head$link1$link3->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1$link3 = (_Bool)0;
  return tmp_if_expr$3$link1$link3;
}

// _cds_wfcq_empty$link1$link4
// file urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link1$link4(union anonymous$1 u_head$link1$link4, struct cds_wfcq_tail *tail$link1$link4)
{
  struct __cds_wfcq_head *head$link1$link4 = u_head$link1$link4._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link1$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1$link4 = *((struct cds_wfcq_node * volatile *)&head$link1$link4->node.next);
  _Bool tmp_if_expr$3$link1$link4;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link1$link4;
  if(tmp_statement_expression$1$link1$link4 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link1$link4 = *((struct cds_wfcq_node * volatile *)&tail$link1$link4->p);
    tmp_if_expr$3$link1$link4 = tmp_statement_expression$2$link1$link4 == &head$link1$link4->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1$link4 = (_Bool)0;
  return tmp_if_expr$3$link1$link4;
}

// _cds_wfcq_empty$link2
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link2(union anonymous$1 u_head$link2, struct cds_wfcq_tail *tail$link2)
{
  struct __cds_wfcq_head *head$link2 = u_head$link2._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((struct cds_wfcq_node * volatile *)&head$link2->node.next);
  _Bool tmp_if_expr$3$link2;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link2;
  if(tmp_statement_expression$1$link2 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link2 = *((struct cds_wfcq_node * volatile *)&tail$link2->p);
    tmp_if_expr$3$link2 = tmp_statement_expression$2$link2 == &head$link2->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link2 = (_Bool)0;
  return tmp_if_expr$3$link2;
}

// _cds_wfcq_empty$link3
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link3(union anonymous$1 u_head$link3, struct cds_wfcq_tail *tail$link3)
{
  struct __cds_wfcq_head *head$link3 = u_head$link3._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((struct cds_wfcq_node * volatile *)&head$link3->node.next);
  _Bool tmp_if_expr$3$link3;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link3;
  if(tmp_statement_expression$1$link3 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link3 = *((struct cds_wfcq_node * volatile *)&tail$link3->p);
    tmp_if_expr$3$link3 = tmp_statement_expression$2$link3 == &head$link3->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link3 = (_Bool)0;
  return tmp_if_expr$3$link3;
}

// _cds_wfcq_empty$link4
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link4(union anonymous$1 u_head$link4, struct cds_wfcq_tail *tail$link4)
{
  struct __cds_wfcq_head *head$link4 = u_head$link4._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link4 = *((struct cds_wfcq_node * volatile *)&head$link4->node.next);
  _Bool tmp_if_expr$3$link4;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link4;
  if(tmp_statement_expression$1$link4 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link4 = *((struct cds_wfcq_node * volatile *)&tail$link4->p);
    tmp_if_expr$3$link4 = tmp_statement_expression$2$link4 == &head$link4->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link4 = (_Bool)0;
  return tmp_if_expr$3$link4;
}

// _cds_wfcq_empty$link5
// file ./urcu/static/wfcqueue.h line 132
static inline _Bool _cds_wfcq_empty$link5(union anonymous$1 u_head$link5, struct cds_wfcq_tail *tail$link5)
{
  struct __cds_wfcq_head *head$link5 = u_head$link5._h;
  struct cds_wfcq_node * volatile tmp_statement_expression$1$link5;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link5 = *((struct cds_wfcq_node * volatile *)&head$link5->node.next);
  _Bool tmp_if_expr$3$link5;
  struct cds_wfcq_node * volatile tmp_statement_expression$2$link5;
  if(tmp_statement_expression$1$link5 == ((struct cds_wfcq_node *)NULL))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link5 = *((struct cds_wfcq_node * volatile *)&tail$link5->p);
    tmp_if_expr$3$link5 = tmp_statement_expression$2$link5 == &head$link5->node ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link5 = (_Bool)0;
  return tmp_if_expr$3$link5;
}

// _cds_wfcq_enqueue
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *new_tail)
{
  _Bool return_value____cds_wfcq_append$1;
  return_value____cds_wfcq_append$1=___cds_wfcq_append(head, tail, new_tail, new_tail);
  return return_value____cds_wfcq_append$1;
}

// _cds_wfcq_enqueue$link1
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1(union anonymous$1 head$link1, struct cds_wfcq_tail *tail$link1, struct cds_wfcq_node *new_tail$link1)
{
  _Bool return_value____cds_wfcq_append$1$link1;
  return_value____cds_wfcq_append$1$link1=___cds_wfcq_append$link1(head$link1, tail$link1, new_tail$link1, new_tail$link1);
  return return_value____cds_wfcq_append$1$link1;
}

// _cds_wfcq_enqueue$link1$link1
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1$link1(union anonymous$1 head$link1$link1, struct cds_wfcq_tail *tail$link1$link1, struct cds_wfcq_node *new_tail$link1$link1)
{
  _Bool return_value____cds_wfcq_append$1$link1$link1;
  return_value____cds_wfcq_append$1$link1$link1=___cds_wfcq_append$link1$link1(head$link1$link1, tail$link1$link1, new_tail$link1$link1, new_tail$link1$link1);
  return return_value____cds_wfcq_append$1$link1$link1;
}

// _cds_wfcq_enqueue$link1$link2
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1$link2(union anonymous$1 head$link1$link2, struct cds_wfcq_tail *tail$link1$link2, struct cds_wfcq_node *new_tail$link1$link2)
{
  _Bool return_value____cds_wfcq_append$1$link1$link2;
  return_value____cds_wfcq_append$1$link1$link2=___cds_wfcq_append$link1$link2(head$link1$link2, tail$link1$link2, new_tail$link1$link2, new_tail$link1$link2);
  return return_value____cds_wfcq_append$1$link1$link2;
}

// _cds_wfcq_enqueue$link1$link3
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1$link3(union anonymous$1 head$link1$link3, struct cds_wfcq_tail *tail$link1$link3, struct cds_wfcq_node *new_tail$link1$link3)
{
  _Bool return_value____cds_wfcq_append$1$link1$link3;
  return_value____cds_wfcq_append$1$link1$link3=___cds_wfcq_append$link1$link3(head$link1$link3, tail$link1$link3, new_tail$link1$link3, new_tail$link1$link3);
  return return_value____cds_wfcq_append$1$link1$link3;
}

// _cds_wfcq_enqueue$link1$link4
// file urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link1$link4(union anonymous$1 head$link1$link4, struct cds_wfcq_tail *tail$link1$link4, struct cds_wfcq_node *new_tail$link1$link4)
{
  _Bool return_value____cds_wfcq_append$1$link1$link4;
  return_value____cds_wfcq_append$1$link1$link4=___cds_wfcq_append$link1$link4(head$link1$link4, tail$link1$link4, new_tail$link1$link4, new_tail$link1$link4);
  return return_value____cds_wfcq_append$1$link1$link4;
}

// _cds_wfcq_enqueue$link2
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link2(union anonymous$1 head$link2, struct cds_wfcq_tail *tail$link2, struct cds_wfcq_node *new_tail$link2)
{
  _Bool return_value____cds_wfcq_append$1$link2;
  return_value____cds_wfcq_append$1$link2=___cds_wfcq_append$link2(head$link2, tail$link2, new_tail$link2, new_tail$link2);
  return return_value____cds_wfcq_append$1$link2;
}

// _cds_wfcq_enqueue$link3
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link3(union anonymous$1 head$link3, struct cds_wfcq_tail *tail$link3, struct cds_wfcq_node *new_tail$link3)
{
  _Bool return_value____cds_wfcq_append$1$link3;
  return_value____cds_wfcq_append$1$link3=___cds_wfcq_append$link3(head$link3, tail$link3, new_tail$link3, new_tail$link3);
  return return_value____cds_wfcq_append$1$link3;
}

// _cds_wfcq_enqueue$link4
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link4(union anonymous$1 head$link4, struct cds_wfcq_tail *tail$link4, struct cds_wfcq_node *new_tail$link4)
{
  _Bool return_value____cds_wfcq_append$1$link4;
  return_value____cds_wfcq_append$1$link4=___cds_wfcq_append$link4(head$link4, tail$link4, new_tail$link4, new_tail$link4);
  return return_value____cds_wfcq_append$1$link4;
}

// _cds_wfcq_enqueue$link5
// file ./urcu/static/wfcqueue.h line 206
static inline _Bool _cds_wfcq_enqueue$link5(union anonymous$1 head$link5, struct cds_wfcq_tail *tail$link5, struct cds_wfcq_node *new_tail$link5)
{
  _Bool return_value____cds_wfcq_append$1$link5;
  return_value____cds_wfcq_append$1$link5=___cds_wfcq_append$link5(head$link5, tail$link5, new_tail$link5, new_tail$link5);
  return return_value____cds_wfcq_append$1$link5;
}

// _cds_wfcq_init
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  signed int ret;
  _cds_wfcq_node_init(&head->node);
  tail->p = &head->node;
  ret=pthread_mutex_init(&head->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret != 0));
}

// _cds_wfcq_init$link1
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1(struct cds_wfcq_head *head$link1, struct cds_wfcq_tail *tail$link1)
{
  signed int ret$link1;
  _cds_wfcq_node_init$link1(&head$link1->node);
  tail$link1->p = &head$link1->node;
  ret$link1=pthread_mutex_init(&head$link1->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
}

// _cds_wfcq_init$link1$link1
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1$link1(struct cds_wfcq_head *head$link1$link1, struct cds_wfcq_tail *tail$link1$link1)
{
  signed int ret$link1$link1;
  _cds_wfcq_node_init$link1$link1(&head$link1$link1->node);
  tail$link1$link1->p = &head$link1$link1->node;
  ret$link1$link1=pthread_mutex_init(&head$link1$link1->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link1$link1 != 0));
}

// _cds_wfcq_init$link1$link2
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1$link2(struct cds_wfcq_head *head$link1$link2, struct cds_wfcq_tail *tail$link1$link2)
{
  signed int ret$link1$link2;
  _cds_wfcq_node_init$link1$link2(&head$link1$link2->node);
  tail$link1$link2->p = &head$link1$link2->node;
  ret$link1$link2=pthread_mutex_init(&head$link1$link2->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link1$link2 != 0));
}

// _cds_wfcq_init$link1$link3
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1$link3(struct cds_wfcq_head *head$link1$link3, struct cds_wfcq_tail *tail$link1$link3)
{
  signed int ret$link1$link3;
  _cds_wfcq_node_init$link1$link3(&head$link1$link3->node);
  tail$link1$link3->p = &head$link1$link3->node;
  ret$link1$link3=pthread_mutex_init(&head$link1$link3->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link1$link3 != 0));
}

// _cds_wfcq_init$link1$link4
// file urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link1$link4(struct cds_wfcq_head *head$link1$link4, struct cds_wfcq_tail *tail$link1$link4)
{
  signed int ret$link1$link4;
  _cds_wfcq_node_init$link1$link4(&head$link1$link4->node);
  tail$link1$link4->p = &head$link1$link4->node;
  ret$link1$link4=pthread_mutex_init(&head$link1$link4->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link1$link4 != 0));
}

// _cds_wfcq_init$link2
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link2(struct cds_wfcq_head *head$link2, struct cds_wfcq_tail *tail$link2)
{
  signed int ret$link2;
  _cds_wfcq_node_init$link2(&head$link2->node);
  tail$link2->p = &head$link2->node;
  ret$link2=pthread_mutex_init(&head$link2->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
}

// _cds_wfcq_init$link3
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link3(struct cds_wfcq_head *head$link3, struct cds_wfcq_tail *tail$link3)
{
  signed int ret$link3;
  _cds_wfcq_node_init$link3(&head$link3->node);
  tail$link3->p = &head$link3->node;
  ret$link3=pthread_mutex_init(&head$link3->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
}

// _cds_wfcq_init$link4
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link4(struct cds_wfcq_head *head$link4, struct cds_wfcq_tail *tail$link4)
{
  signed int ret$link4;
  _cds_wfcq_node_init$link4(&head$link4->node);
  tail$link4->p = &head$link4->node;
  ret$link4=pthread_mutex_init(&head$link4->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
}

// _cds_wfcq_init$link5
// file ./urcu/static/wfcqueue.h line 97
static inline void _cds_wfcq_init$link5(struct cds_wfcq_head *head$link5, struct cds_wfcq_tail *tail$link5)
{
  signed int ret$link5;
  _cds_wfcq_node_init$link5(&head$link5->node);
  tail$link5->p = &head$link5->node;
  ret$link5=pthread_mutex_init(&head$link5->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link5 != 0));
}

// _cds_wfcq_node_init
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init(struct cds_wfcq_node *node)
{
  node->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_node_init$link1
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1(struct cds_wfcq_node *node$link1)
{
  node$link1->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_node_init$link1$link1
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1$link1(struct cds_wfcq_node *node$link1$link1)
{
  node$link1$link1->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_node_init$link1$link2
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1$link2(struct cds_wfcq_node *node$link1$link2)
{
  node$link1$link2->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_node_init$link1$link3
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1$link3(struct cds_wfcq_node *node$link1$link3)
{
  node$link1$link3->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_node_init$link1$link4
// file urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link1$link4(struct cds_wfcq_node *node$link1$link4)
{
  node$link1$link4->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_node_init$link2
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link2(struct cds_wfcq_node *node$link2)
{
  node$link2->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_node_init$link3
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link3(struct cds_wfcq_node *node$link3)
{
  node$link3->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_node_init$link4
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link4(struct cds_wfcq_node *node$link4)
{
  node$link4->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_node_init$link5
// file ./urcu/static/wfcqueue.h line 89
static inline void _cds_wfcq_node_init$link5(struct cds_wfcq_node *node$link5)
{
  node$link5->next = (struct cds_wfcq_node *)(void *)0;
}

// _cds_wfcq_splice_blocking
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking(struct cds_wfcq_head *dest_q_head, struct cds_wfcq_tail *dest_q_tail, struct cds_wfcq_head *src_q_head, struct cds_wfcq_tail *src_q_tail)
{
  enum cds_wfcq_ret ret;
  _cds_wfcq_dequeue_lock(src_q_head, src_q_tail);
  ret=___cds_wfcq_splice_blocking$link1(dest_q_head, dest_q_tail, src_q_head, src_q_tail);
  _cds_wfcq_dequeue_unlock(src_q_head, src_q_tail);
  return ret;
}

// _cds_wfcq_splice_blocking$link1
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking$link1(struct cds_wfcq_head *dest_q_head$link1, struct cds_wfcq_tail *dest_q_tail$link1, struct cds_wfcq_head *src_q_head$link1, struct cds_wfcq_tail *src_q_tail$link1)
{
  enum cds_wfcq_ret ret$link1;
  _cds_wfcq_dequeue_lock$link1(src_q_head$link1, src_q_tail$link1);
  ret$link1=___cds_wfcq_splice_blocking$link1$link1(dest_q_head$link1, dest_q_tail$link1, src_q_head$link1, src_q_tail$link1);
  _cds_wfcq_dequeue_unlock$link1(src_q_head$link1, src_q_tail$link1);
  return ret$link1;
}

// _cds_wfcq_splice_blocking$link2
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking$link2(struct cds_wfcq_head *dest_q_head$link2, struct cds_wfcq_tail *dest_q_tail$link2, struct cds_wfcq_head *src_q_head$link2, struct cds_wfcq_tail *src_q_tail$link2)
{
  enum cds_wfcq_ret ret$link2;
  _cds_wfcq_dequeue_lock$link2(src_q_head$link2, src_q_tail$link2);
  ret$link2=___cds_wfcq_splice_blocking$link1$link2(dest_q_head$link2, dest_q_tail$link2, src_q_head$link2, src_q_tail$link2);
  _cds_wfcq_dequeue_unlock$link2(src_q_head$link2, src_q_tail$link2);
  return ret$link2;
}

// _cds_wfcq_splice_blocking$link3
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking$link3(struct cds_wfcq_head *dest_q_head$link3, struct cds_wfcq_tail *dest_q_tail$link3, struct cds_wfcq_head *src_q_head$link3, struct cds_wfcq_tail *src_q_tail$link3)
{
  enum cds_wfcq_ret ret$link3;
  _cds_wfcq_dequeue_lock$link3(src_q_head$link3, src_q_tail$link3);
  ret$link3=___cds_wfcq_splice_blocking$link1$link3(dest_q_head$link3, dest_q_tail$link3, src_q_head$link3, src_q_tail$link3);
  _cds_wfcq_dequeue_unlock$link3(src_q_head$link3, src_q_tail$link3);
  return ret$link3;
}

// _cds_wfcq_splice_blocking$link4
// file urcu/static/wfcqueue.h line 632
static inline enum cds_wfcq_ret _cds_wfcq_splice_blocking$link4(struct cds_wfcq_head *dest_q_head$link4, struct cds_wfcq_tail *dest_q_tail$link4, struct cds_wfcq_head *src_q_head$link4, struct cds_wfcq_tail *src_q_tail$link4)
{
  enum cds_wfcq_ret ret$link4;
  _cds_wfcq_dequeue_lock$link4(src_q_head$link4, src_q_tail$link4);
  ret$link4=___cds_wfcq_splice_blocking$link1$link4(dest_q_head$link4, dest_q_tail$link4, src_q_head$link4, src_q_tail$link4);
  _cds_wfcq_dequeue_unlock$link4(src_q_head$link4, src_q_tail$link4);
  return ret$link4;
}

// _cds_wfq_dequeue_blocking
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking(struct cds_wfq_queue *q)
{
  struct cds_wfq_node *retnode;
  signed int ret;
  ret=pthread_mutex_lock(&q->lock);
  /* assertion !ret */
  assert(!(ret != 0));
  retnode=___cds_wfq_dequeue_blocking(q);
  ret=pthread_mutex_unlock(&q->lock);
  /* assertion !ret */
  assert(!(ret != 0));
  return retnode;
}

// _cds_wfq_dequeue_blocking$link1
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking$link1(struct cds_wfq_queue *q$link1)
{
  struct cds_wfq_node *retnode$link1;
  signed int ret$link1;
  ret$link1=pthread_mutex_lock(&q$link1->lock);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
  retnode$link1=___cds_wfq_dequeue_blocking$link1(q$link1);
  ret$link1=pthread_mutex_unlock(&q$link1->lock);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
  return retnode$link1;
}

// _cds_wfq_dequeue_blocking$link2
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking$link2(struct cds_wfq_queue *q$link2)
{
  struct cds_wfq_node *retnode$link2;
  signed int ret$link2;
  ret$link2=pthread_mutex_lock(&q$link2->lock);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
  retnode$link2=___cds_wfq_dequeue_blocking$link2(q$link2);
  ret$link2=pthread_mutex_unlock(&q$link2->lock);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
  return retnode$link2;
}

// _cds_wfq_dequeue_blocking$link3
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking$link3(struct cds_wfq_queue *q$link3)
{
  struct cds_wfq_node *retnode$link3;
  signed int ret$link3;
  ret$link3=pthread_mutex_lock(&q$link3->lock);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
  retnode$link3=___cds_wfq_dequeue_blocking$link3(q$link3);
  ret$link3=pthread_mutex_unlock(&q$link3->lock);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
  return retnode$link3;
}

// _cds_wfq_dequeue_blocking$link4
// file urcu/static/wfqueue.h line 148
static inline struct cds_wfq_node * _cds_wfq_dequeue_blocking$link4(struct cds_wfq_queue *q$link4)
{
  struct cds_wfq_node *retnode$link4;
  signed int ret$link4;
  ret$link4=pthread_mutex_lock(&q$link4->lock);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
  retnode$link4=___cds_wfq_dequeue_blocking$link4(q$link4);
  ret$link4=pthread_mutex_unlock(&q$link4->lock);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
  return retnode$link4;
}

// _cds_wfq_enqueue
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue(struct cds_wfq_queue *q, struct cds_wfq_node *node)
{
  struct cds_wfq_node **old_tail;
  unsigned long int return_value___uatomic_exchange$1;
  return_value___uatomic_exchange$1=__uatomic_exchange$link3((void *)&q->tail, (unsigned long int)&node->next, (signed int)sizeof(struct cds_wfq_node **) /*8ul*/ );
  old_tail = (struct cds_wfq_node **)return_value___uatomic_exchange$1;
  struct cds_wfq_node *_v;
  struct cds_wfq_node * volatile tmp_statement_expression$2;
  *((struct cds_wfq_node * volatile *)&(*old_tail)) = node;
  tmp_statement_expression$2 = *((struct cds_wfq_node * volatile *)&(*old_tail));
  _v = tmp_statement_expression$2;
  asm("" :  :  : "memory");
  _v = _v;
}

// _cds_wfq_enqueue$link1
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue$link1(struct cds_wfq_queue *q$link1, struct cds_wfq_node *node$link1)
{
  struct cds_wfq_node **old_tail$link1;
  unsigned long int return_value___uatomic_exchange$1$link1;
  return_value___uatomic_exchange$1$link1=__uatomic_exchange$link3$link1((void *)&q$link1->tail, (unsigned long int)&node$link1->next, (signed int)sizeof(struct cds_wfq_node **) /*8ul*/ );
  old_tail$link1 = (struct cds_wfq_node **)return_value___uatomic_exchange$1$link1;
  struct cds_wfq_node *_v$link1;
  struct cds_wfq_node * volatile tmp_statement_expression$2$link1;
  *((struct cds_wfq_node * volatile *)&(*old_tail$link1)) = node$link1;
  tmp_statement_expression$2$link1 = *((struct cds_wfq_node * volatile *)&(*old_tail$link1));
  _v$link1 = tmp_statement_expression$2$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
}

// _cds_wfq_enqueue$link2
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue$link2(struct cds_wfq_queue *q$link2, struct cds_wfq_node *node$link2)
{
  struct cds_wfq_node **old_tail$link2;
  unsigned long int return_value___uatomic_exchange$1$link2;
  return_value___uatomic_exchange$1$link2=__uatomic_exchange$link3$link2((void *)&q$link2->tail, (unsigned long int)&node$link2->next, (signed int)sizeof(struct cds_wfq_node **) /*8ul*/ );
  old_tail$link2 = (struct cds_wfq_node **)return_value___uatomic_exchange$1$link2;
  struct cds_wfq_node *_v$link2;
  struct cds_wfq_node * volatile tmp_statement_expression$2$link2;
  *((struct cds_wfq_node * volatile *)&(*old_tail$link2)) = node$link2;
  tmp_statement_expression$2$link2 = *((struct cds_wfq_node * volatile *)&(*old_tail$link2));
  _v$link2 = tmp_statement_expression$2$link2;
  asm("" :  :  : "memory");
  _v$link2 = _v$link2;
}

// _cds_wfq_enqueue$link3
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue$link3(struct cds_wfq_queue *q$link3, struct cds_wfq_node *node$link3)
{
  struct cds_wfq_node **old_tail$link3;
  unsigned long int return_value___uatomic_exchange$1$link3;
  return_value___uatomic_exchange$1$link3=__uatomic_exchange$link3$link3((void *)&q$link3->tail, (unsigned long int)&node$link3->next, (signed int)sizeof(struct cds_wfq_node **) /*8ul*/ );
  old_tail$link3 = (struct cds_wfq_node **)return_value___uatomic_exchange$1$link3;
  struct cds_wfq_node *_v$link3;
  struct cds_wfq_node * volatile tmp_statement_expression$2$link3;
  *((struct cds_wfq_node * volatile *)&(*old_tail$link3)) = node$link3;
  tmp_statement_expression$2$link3 = *((struct cds_wfq_node * volatile *)&(*old_tail$link3));
  _v$link3 = tmp_statement_expression$2$link3;
  asm("" :  :  : "memory");
  _v$link3 = _v$link3;
}

// _cds_wfq_enqueue$link4
// file urcu/static/wfqueue.h line 68
static inline void _cds_wfq_enqueue$link4(struct cds_wfq_queue *q$link4, struct cds_wfq_node *node$link4)
{
  struct cds_wfq_node **old_tail$link4;
  unsigned long int return_value___uatomic_exchange$1$link4;
  return_value___uatomic_exchange$1$link4=__uatomic_exchange$link3$link4((void *)&q$link4->tail, (unsigned long int)&node$link4->next, (signed int)sizeof(struct cds_wfq_node **) /*8ul*/ );
  old_tail$link4 = (struct cds_wfq_node **)return_value___uatomic_exchange$1$link4;
  struct cds_wfq_node *_v$link4;
  struct cds_wfq_node * volatile tmp_statement_expression$2$link4;
  *((struct cds_wfq_node * volatile *)&(*old_tail$link4)) = node$link4;
  tmp_statement_expression$2$link4 = *((struct cds_wfq_node * volatile *)&(*old_tail$link4));
  _v$link4 = tmp_statement_expression$2$link4;
  asm("" :  :  : "memory");
  _v$link4 = _v$link4;
}

// _cds_wfq_init
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init(struct cds_wfq_queue *q)
{
  signed int ret;
  _cds_wfq_node_init(&q->dummy);
  q->head = &q->dummy;
  q->tail = &q->dummy.next;
  ret=pthread_mutex_init(&q->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret != 0));
}

// _cds_wfq_init$link1
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init$link1(struct cds_wfq_queue *q$link1)
{
  signed int ret$link1;
  _cds_wfq_node_init$link1(&q$link1->dummy);
  q$link1->head = &q$link1->dummy;
  q$link1->tail = &q$link1->dummy.next;
  ret$link1=pthread_mutex_init(&q$link1->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
}

// _cds_wfq_init$link2
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init$link2(struct cds_wfq_queue *q$link2)
{
  signed int ret$link2;
  _cds_wfq_node_init$link2(&q$link2->dummy);
  q$link2->head = &q$link2->dummy;
  q$link2->tail = &q$link2->dummy.next;
  ret$link2=pthread_mutex_init(&q$link2->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
}

// _cds_wfq_init$link3
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init$link3(struct cds_wfq_queue *q$link3)
{
  signed int ret$link3;
  _cds_wfq_node_init$link3(&q$link3->dummy);
  q$link3->head = &q$link3->dummy;
  q$link3->tail = &q$link3->dummy.next;
  ret$link3=pthread_mutex_init(&q$link3->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
}

// _cds_wfq_init$link4
// file urcu/static/wfqueue.h line 56
static inline void _cds_wfq_init$link4(struct cds_wfq_queue *q$link4)
{
  signed int ret$link4;
  _cds_wfq_node_init$link4(&q$link4->dummy);
  q$link4->head = &q$link4->dummy;
  q$link4->tail = &q$link4->dummy.next;
  ret$link4=pthread_mutex_init(&q$link4->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
}

// _cds_wfq_node_init
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init(struct cds_wfq_node *node)
{
  node->next = (struct cds_wfq_node *)(void *)0;
}

// _cds_wfq_node_init$link1
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init$link1(struct cds_wfq_node *node$link1)
{
  node$link1->next = (struct cds_wfq_node *)(void *)0;
}

// _cds_wfq_node_init$link2
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init$link2(struct cds_wfq_node *node$link2)
{
  node$link2->next = (struct cds_wfq_node *)(void *)0;
}

// _cds_wfq_node_init$link3
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init$link3(struct cds_wfq_node *node$link3)
{
  node$link3->next = (struct cds_wfq_node *)(void *)0;
}

// _cds_wfq_node_init$link4
// file urcu/static/wfqueue.h line 51
static inline void _cds_wfq_node_init$link4(struct cds_wfq_node *node$link4)
{
  node$link4->next = (struct cds_wfq_node *)(void *)0;
}

// _cds_wfs_empty
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty(union anonymous u_stack)
{
  struct __cds_wfs_stack *s = u_stack._s;
  struct cds_wfs_head * volatile tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((struct cds_wfs_head * volatile *)&s->head);
  _Bool return_value____cds_wfs_end$2;
  return_value____cds_wfs_end$2=___cds_wfs_end$link1((void *)tmp_statement_expression$1);
  return return_value____cds_wfs_end$2;
}

// _cds_wfs_empty$link1
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty$link1(union anonymous u_stack$link1)
{
  struct __cds_wfs_stack *s$link1 = u_stack$link1._s;
  struct cds_wfs_head * volatile tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((struct cds_wfs_head * volatile *)&s$link1->head);
  _Bool return_value____cds_wfs_end$2$link1;
  return_value____cds_wfs_end$2$link1=___cds_wfs_end$link1$link1((void *)tmp_statement_expression$1$link1);
  return return_value____cds_wfs_end$2$link1;
}

// _cds_wfs_empty$link2
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty$link2(union anonymous u_stack$link2)
{
  struct __cds_wfs_stack *s$link2 = u_stack$link2._s;
  struct cds_wfs_head * volatile tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((struct cds_wfs_head * volatile *)&s$link2->head);
  _Bool return_value____cds_wfs_end$2$link2;
  return_value____cds_wfs_end$2$link2=___cds_wfs_end$link1$link2((void *)tmp_statement_expression$1$link2);
  return return_value____cds_wfs_end$2$link2;
}

// _cds_wfs_empty$link3
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty$link3(union anonymous u_stack$link3)
{
  struct __cds_wfs_stack *s$link3 = u_stack$link3._s;
  struct cds_wfs_head * volatile tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((struct cds_wfs_head * volatile *)&s$link3->head);
  _Bool return_value____cds_wfs_end$2$link3;
  return_value____cds_wfs_end$2$link3=___cds_wfs_end$link1$link3((void *)tmp_statement_expression$1$link3);
  return return_value____cds_wfs_end$2$link3;
}

// _cds_wfs_empty$link4
// file urcu/static/wfstack.h line 110
static inline _Bool _cds_wfs_empty$link4(union anonymous u_stack$link4)
{
  struct __cds_wfs_stack *s$link4 = u_stack$link4._s;
  struct cds_wfs_head * volatile tmp_statement_expression$1$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link4 = *((struct cds_wfs_head * volatile *)&s$link4->head);
  _Bool return_value____cds_wfs_end$2$link4;
  return_value____cds_wfs_end$2$link4=___cds_wfs_end$link5((void *)tmp_statement_expression$1$link4);
  return return_value____cds_wfs_end$2$link4;
}

// _cds_wfs_first
// file ./urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first(struct cds_wfs_head *head)
{
  _Bool return_value____cds_wfs_end$1;
  return_value____cds_wfs_end$1=___cds_wfs_end((void *)head);
  if(!(return_value____cds_wfs_end$1 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return &head->node;
}

// _cds_wfs_first$link1
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link1(struct cds_wfs_head *head$link1)
{
  _Bool return_value____cds_wfs_end$1$link1;
  return_value____cds_wfs_end$1$link1=___cds_wfs_end$link1((void *)head$link1);
  if(!(return_value____cds_wfs_end$1$link1 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return &head$link1->node;
}

// _cds_wfs_first$link1$link1
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link1$link1(struct cds_wfs_head *head$link1$link1)
{
  _Bool return_value____cds_wfs_end$1$link1$link1;
  return_value____cds_wfs_end$1$link1$link1=___cds_wfs_end$link1$link1((void *)head$link1$link1);
  if(!(return_value____cds_wfs_end$1$link1$link1 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return &head$link1$link1->node;
}

// _cds_wfs_first$link1$link2
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link1$link2(struct cds_wfs_head *head$link1$link2)
{
  _Bool return_value____cds_wfs_end$1$link1$link2;
  return_value____cds_wfs_end$1$link1$link2=___cds_wfs_end$link1$link2((void *)head$link1$link2);
  if(!(return_value____cds_wfs_end$1$link1$link2 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return &head$link1$link2->node;
}

// _cds_wfs_first$link1$link3
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link1$link3(struct cds_wfs_head *head$link1$link3)
{
  _Bool return_value____cds_wfs_end$1$link1$link3;
  return_value____cds_wfs_end$1$link1$link3=___cds_wfs_end$link1$link3((void *)head$link1$link3);
  if(!(return_value____cds_wfs_end$1$link1$link3 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return &head$link1$link3->node;
}

// _cds_wfs_first$link2
// file ./urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link2(struct cds_wfs_head *head$link2)
{
  _Bool return_value____cds_wfs_end$1$link2;
  return_value____cds_wfs_end$1$link2=___cds_wfs_end$link2((void *)head$link2);
  if(!(return_value____cds_wfs_end$1$link2 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return &head$link2->node;
}

// _cds_wfs_first$link3
// file ./urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link3(struct cds_wfs_head *head$link3)
{
  _Bool return_value____cds_wfs_end$1$link3;
  return_value____cds_wfs_end$1$link3=___cds_wfs_end$link3((void *)head$link3);
  if(!(return_value____cds_wfs_end$1$link3 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return &head$link3->node;
}

// _cds_wfs_first$link4
// file ./urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link4(struct cds_wfs_head *head$link4)
{
  _Bool return_value____cds_wfs_end$1$link4;
  return_value____cds_wfs_end$1$link4=___cds_wfs_end$link4((void *)head$link4);
  if(!(return_value____cds_wfs_end$1$link4 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return &head$link4->node;
}

// _cds_wfs_first$link5
// file urcu/static/wfstack.h line 380
static inline struct cds_wfs_node * _cds_wfs_first$link5(struct cds_wfs_head *head$link5)
{
  _Bool return_value____cds_wfs_end$1$link5;
  return_value____cds_wfs_end$1$link5=___cds_wfs_end$link5((void *)head$link5);
  if(!(return_value____cds_wfs_end$1$link5 == (_Bool)0))
    return (struct cds_wfs_node *)(void *)0;

  else
    return &head$link5->node;
}

// _cds_wfs_init
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init(struct cds_wfs_stack *s)
{
  signed int ret;
  s->head = (struct cds_wfs_head *)(void *)0x1UL;
  ret=pthread_mutex_init(&s->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret != 0));
}

// _cds_wfs_init$link1
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init$link1(struct cds_wfs_stack *s$link1)
{
  signed int ret$link1;
  s$link1->head = (struct cds_wfs_head *)(void *)0x1UL;
  ret$link1=pthread_mutex_init(&s$link1->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
}

// _cds_wfs_init$link2
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init$link2(struct cds_wfs_stack *s$link2)
{
  signed int ret$link2;
  s$link2->head = (struct cds_wfs_head *)(void *)0x1UL;
  ret$link2=pthread_mutex_init(&s$link2->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
}

// _cds_wfs_init$link3
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init$link3(struct cds_wfs_stack *s$link3)
{
  signed int ret$link3;
  s$link3->head = (struct cds_wfs_head *)(void *)0x1UL;
  ret$link3=pthread_mutex_init(&s$link3->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
}

// _cds_wfs_init$link4
// file urcu/static/wfstack.h line 91
static inline void _cds_wfs_init$link4(struct cds_wfs_stack *s$link4)
{
  signed int ret$link4;
  s$link4->head = (struct cds_wfs_head *)(void *)0x1UL;
  ret$link4=pthread_mutex_init(&s$link4->lock, (const union anonymous$3 *)(void *)0);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
}

// _cds_wfs_next_blocking
// file ./urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking(struct cds_wfs_node *node)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1;
  return_value____cds_wfs_next$1=___cds_wfs_next(node, 1);
  return return_value____cds_wfs_next$1;
}

// _cds_wfs_next_blocking$link1
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link1(struct cds_wfs_node *node$link1)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link1;
  return_value____cds_wfs_next$1$link1=___cds_wfs_next$link1(node$link1, 1);
  return return_value____cds_wfs_next$1$link1;
}

// _cds_wfs_next_blocking$link1$link1
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link1$link1(struct cds_wfs_node *node$link1$link1)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link1$link1;
  return_value____cds_wfs_next$1$link1$link1=___cds_wfs_next$link1$link1(node$link1$link1, 1);
  return return_value____cds_wfs_next$1$link1$link1;
}

// _cds_wfs_next_blocking$link1$link2
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link1$link2(struct cds_wfs_node *node$link1$link2)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link1$link2;
  return_value____cds_wfs_next$1$link1$link2=___cds_wfs_next$link1$link2(node$link1$link2, 1);
  return return_value____cds_wfs_next$1$link1$link2;
}

// _cds_wfs_next_blocking$link1$link3
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link1$link3(struct cds_wfs_node *node$link1$link3)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link1$link3;
  return_value____cds_wfs_next$1$link1$link3=___cds_wfs_next$link1$link3(node$link1$link3, 1);
  return return_value____cds_wfs_next$1$link1$link3;
}

// _cds_wfs_next_blocking$link2
// file ./urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link2(struct cds_wfs_node *node$link2)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link2;
  return_value____cds_wfs_next$1$link2=___cds_wfs_next$link2(node$link2, 1);
  return return_value____cds_wfs_next$1$link2;
}

// _cds_wfs_next_blocking$link3
// file ./urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link3(struct cds_wfs_node *node$link3)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link3;
  return_value____cds_wfs_next$1$link3=___cds_wfs_next$link3(node$link3, 1);
  return return_value____cds_wfs_next$1$link3;
}

// _cds_wfs_next_blocking$link4
// file ./urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link4(struct cds_wfs_node *node$link4)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link4;
  return_value____cds_wfs_next$1$link4=___cds_wfs_next$link4(node$link4, 1);
  return return_value____cds_wfs_next$1$link4;
}

// _cds_wfs_next_blocking$link5
// file urcu/static/wfstack.h line 417
static inline struct cds_wfs_node * _cds_wfs_next_blocking$link5(struct cds_wfs_node *node$link5)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link5;
  return_value____cds_wfs_next$1$link5=___cds_wfs_next$link5(node$link5, 1);
  return return_value____cds_wfs_next$1$link5;
}

// _cds_wfs_next_nonblocking
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking(struct cds_wfs_node *node)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1;
  return_value____cds_wfs_next$1=___cds_wfs_next$link1(node, 0);
  return return_value____cds_wfs_next$1;
}

// _cds_wfs_next_nonblocking$link1
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking$link1(struct cds_wfs_node *node$link1)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link1;
  return_value____cds_wfs_next$1$link1=___cds_wfs_next$link1$link1(node$link1, 0);
  return return_value____cds_wfs_next$1$link1;
}

// _cds_wfs_next_nonblocking$link2
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking$link2(struct cds_wfs_node *node$link2)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link2;
  return_value____cds_wfs_next$1$link2=___cds_wfs_next$link1$link2(node$link2, 0);
  return return_value____cds_wfs_next$1$link2;
}

// _cds_wfs_next_nonblocking$link3
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking$link3(struct cds_wfs_node *node$link3)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link3;
  return_value____cds_wfs_next$1$link3=___cds_wfs_next$link1$link3(node$link3, 0);
  return return_value____cds_wfs_next$1$link3;
}

// _cds_wfs_next_nonblocking$link4
// file urcu/static/wfstack.h line 430
static inline struct cds_wfs_node * _cds_wfs_next_nonblocking$link4(struct cds_wfs_node *node$link4)
{
  struct cds_wfs_node *return_value____cds_wfs_next$1$link4;
  return_value____cds_wfs_next$1$link4=___cds_wfs_next$link5(node$link4, 0);
  return return_value____cds_wfs_next$1$link4;
}

// _cds_wfs_node_init
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init(struct cds_wfs_node *node)
{
  node->next = (struct cds_wfs_node *)(void *)0;
}

// _cds_wfs_node_init$link1
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init$link1(struct cds_wfs_node *node$link1)
{
  node$link1->next = (struct cds_wfs_node *)(void *)0;
}

// _cds_wfs_node_init$link2
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init$link2(struct cds_wfs_node *node$link2)
{
  node$link2->next = (struct cds_wfs_node *)(void *)0;
}

// _cds_wfs_node_init$link3
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init$link3(struct cds_wfs_node *node$link3)
{
  node$link3->next = (struct cds_wfs_node *)(void *)0;
}

// _cds_wfs_node_init$link4
// file urcu/static/wfstack.h line 74
static inline void _cds_wfs_node_init$link4(struct cds_wfs_node *node$link4)
{
  node$link4->next = (struct cds_wfs_node *)(void *)0;
}

// _cds_wfs_pop_all_blocking
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking(struct cds_wfs_stack *s)
{
  struct cds_wfs_head *rethead;
  _cds_wfs_pop_lock(s);
  rethead=___cds_wfs_pop_all$link1(s);
  _cds_wfs_pop_unlock(s);
  return rethead;
}

// _cds_wfs_pop_all_blocking$link1
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking$link1(struct cds_wfs_stack *s$link1)
{
  struct cds_wfs_head *rethead$link1;
  _cds_wfs_pop_lock$link1(s$link1);
  rethead$link1=___cds_wfs_pop_all$link1$link1(s$link1);
  _cds_wfs_pop_unlock$link1(s$link1);
  return rethead$link1;
}

// _cds_wfs_pop_all_blocking$link2
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking$link2(struct cds_wfs_stack *s$link2)
{
  struct cds_wfs_head *rethead$link2;
  _cds_wfs_pop_lock$link2(s$link2);
  rethead$link2=___cds_wfs_pop_all$link1$link2(s$link2);
  _cds_wfs_pop_unlock$link2(s$link2);
  return rethead$link2;
}

// _cds_wfs_pop_all_blocking$link3
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking$link3(struct cds_wfs_stack *s$link3)
{
  struct cds_wfs_head *rethead$link3;
  _cds_wfs_pop_lock$link3(s$link3);
  rethead$link3=___cds_wfs_pop_all$link1$link3(s$link3);
  _cds_wfs_pop_unlock$link3(s$link3);
  return rethead$link3;
}

// _cds_wfs_pop_all_blocking$link4
// file urcu/static/wfstack.h line 357
static inline struct cds_wfs_head * _cds_wfs_pop_all_blocking$link4(struct cds_wfs_stack *s$link4)
{
  struct cds_wfs_head *rethead$link4;
  _cds_wfs_pop_lock$link4(s$link4);
  rethead$link4=___cds_wfs_pop_all$link5(s$link4);
  _cds_wfs_pop_unlock$link4(s$link4);
  return rethead$link4;
}

// _cds_wfs_pop_blocking
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking(struct cds_wfs_stack *s)
{
  struct cds_wfs_node *return_value__cds_wfs_pop_with_state_blocking$1;
  return_value__cds_wfs_pop_with_state_blocking$1=_cds_wfs_pop_with_state_blocking(s, (signed int *)(void *)0);
  return return_value__cds_wfs_pop_with_state_blocking$1;
}

// _cds_wfs_pop_blocking$link1
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking$link1(struct cds_wfs_stack *s$link1)
{
  struct cds_wfs_node *return_value__cds_wfs_pop_with_state_blocking$1$link1;
  return_value__cds_wfs_pop_with_state_blocking$1$link1=_cds_wfs_pop_with_state_blocking$link1(s$link1, (signed int *)(void *)0);
  return return_value__cds_wfs_pop_with_state_blocking$1$link1;
}

// _cds_wfs_pop_blocking$link2
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking$link2(struct cds_wfs_stack *s$link2)
{
  struct cds_wfs_node *return_value__cds_wfs_pop_with_state_blocking$1$link2;
  return_value__cds_wfs_pop_with_state_blocking$1$link2=_cds_wfs_pop_with_state_blocking$link2(s$link2, (signed int *)(void *)0);
  return return_value__cds_wfs_pop_with_state_blocking$1$link2;
}

// _cds_wfs_pop_blocking$link3
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking$link3(struct cds_wfs_stack *s$link3)
{
  struct cds_wfs_node *return_value__cds_wfs_pop_with_state_blocking$1$link3;
  return_value__cds_wfs_pop_with_state_blocking$1$link3=_cds_wfs_pop_with_state_blocking$link3(s$link3, (signed int *)(void *)0);
  return return_value__cds_wfs_pop_with_state_blocking$1$link3;
}

// _cds_wfs_pop_blocking$link4
// file urcu/static/wfstack.h line 347
static inline struct cds_wfs_node * _cds_wfs_pop_blocking$link4(struct cds_wfs_stack *s$link4)
{
  struct cds_wfs_node *return_value__cds_wfs_pop_with_state_blocking$1$link4;
  return_value__cds_wfs_pop_with_state_blocking$1$link4=_cds_wfs_pop_with_state_blocking$link4(s$link4, (signed int *)(void *)0);
  return return_value__cds_wfs_pop_with_state_blocking$1$link4;
}

// _cds_wfs_pop_lock
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock(struct cds_wfs_stack *s)
{
  signed int ret;
  ret=pthread_mutex_lock(&s->lock);
  /* assertion !ret */
  assert(!(ret != 0));
}

// _cds_wfs_pop_lock$link1
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock$link1(struct cds_wfs_stack *s$link1)
{
  signed int ret$link1;
  ret$link1=pthread_mutex_lock(&s$link1->lock);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
}

// _cds_wfs_pop_lock$link2
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock$link2(struct cds_wfs_stack *s$link2)
{
  signed int ret$link2;
  ret$link2=pthread_mutex_lock(&s$link2->lock);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
}

// _cds_wfs_pop_lock$link3
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock$link3(struct cds_wfs_stack *s$link3)
{
  signed int ret$link3;
  ret$link3=pthread_mutex_lock(&s$link3->lock);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
}

// _cds_wfs_pop_lock$link4
// file urcu/static/wfstack.h line 308
static inline void _cds_wfs_pop_lock$link4(struct cds_wfs_stack *s$link4)
{
  signed int ret$link4;
  ret$link4=pthread_mutex_lock(&s$link4->lock);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
}

// _cds_wfs_pop_unlock
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock(struct cds_wfs_stack *s)
{
  signed int ret;
  ret=pthread_mutex_unlock(&s->lock);
  /* assertion !ret */
  assert(!(ret != 0));
}

// _cds_wfs_pop_unlock$link1
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock$link1(struct cds_wfs_stack *s$link1)
{
  signed int ret$link1;
  ret$link1=pthread_mutex_unlock(&s$link1->lock);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
}

// _cds_wfs_pop_unlock$link2
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock$link2(struct cds_wfs_stack *s$link2)
{
  signed int ret$link2;
  ret$link2=pthread_mutex_unlock(&s$link2->lock);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
}

// _cds_wfs_pop_unlock$link3
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock$link3(struct cds_wfs_stack *s$link3)
{
  signed int ret$link3;
  ret$link3=pthread_mutex_unlock(&s$link3->lock);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
}

// _cds_wfs_pop_unlock$link4
// file urcu/static/wfstack.h line 319
static inline void _cds_wfs_pop_unlock$link4(struct cds_wfs_stack *s$link4)
{
  signed int ret$link4;
  ret$link4=pthread_mutex_unlock(&s$link4->lock);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
}

// _cds_wfs_pop_with_state_blocking
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking(struct cds_wfs_stack *s, signed int *state)
{
  struct cds_wfs_node *retnode;
  _cds_wfs_pop_lock(s);
  retnode=___cds_wfs_pop_with_state_blocking(s, state);
  _cds_wfs_pop_unlock(s);
  return retnode;
}

// _cds_wfs_pop_with_state_blocking$link1
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking$link1(struct cds_wfs_stack *s$link1, signed int *state$link1)
{
  struct cds_wfs_node *retnode$link1;
  _cds_wfs_pop_lock$link1(s$link1);
  retnode$link1=___cds_wfs_pop_with_state_blocking$link1(s$link1, state$link1);
  _cds_wfs_pop_unlock$link1(s$link1);
  return retnode$link1;
}

// _cds_wfs_pop_with_state_blocking$link2
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking$link2(struct cds_wfs_stack *s$link2, signed int *state$link2)
{
  struct cds_wfs_node *retnode$link2;
  _cds_wfs_pop_lock$link2(s$link2);
  retnode$link2=___cds_wfs_pop_with_state_blocking$link2(s$link2, state$link2);
  _cds_wfs_pop_unlock$link2(s$link2);
  return retnode$link2;
}

// _cds_wfs_pop_with_state_blocking$link3
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking$link3(struct cds_wfs_stack *s$link3, signed int *state$link3)
{
  struct cds_wfs_node *retnode$link3;
  _cds_wfs_pop_lock$link3(s$link3);
  retnode$link3=___cds_wfs_pop_with_state_blocking$link3(s$link3, state$link3);
  _cds_wfs_pop_unlock$link3(s$link3);
  return retnode$link3;
}

// _cds_wfs_pop_with_state_blocking$link4
// file urcu/static/wfstack.h line 332
static inline struct cds_wfs_node * _cds_wfs_pop_with_state_blocking$link4(struct cds_wfs_stack *s$link4, signed int *state$link4)
{
  struct cds_wfs_node *retnode$link4;
  _cds_wfs_pop_lock$link4(s$link4);
  retnode$link4=___cds_wfs_pop_with_state_blocking$link4(s$link4, state$link4);
  _cds_wfs_pop_unlock$link4(s$link4);
  return retnode$link4;
}

// _cds_wfs_push
// file ./urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push(union anonymous u_stack, struct cds_wfs_node *node)
{
  struct __cds_wfs_stack *s = u_stack._s;
  struct cds_wfs_head *old_head;
  struct cds_wfs_head *new_head;
  /* assertion node->next == ((void *)0) */
  assert(node->next == (struct cds_wfs_node *)(void *)0);
  struct cds_wfs_head *tmp_statement_expression$1;
  const struct cds_wfs_node *__ptr = node;
  tmp_statement_expression$1 = (struct cds_wfs_head *)((char *)__ptr - (signed long int)0ul);
  new_head = tmp_statement_expression$1;
  unsigned long int return_value___uatomic_exchange$2;
  return_value___uatomic_exchange$2=__uatomic_exchange((void *)&s->head, (unsigned long int)new_head, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  old_head = (struct cds_wfs_head *)return_value___uatomic_exchange$2;
  struct cds_wfs_node *_v;
  struct cds_wfs_node * volatile tmp_statement_expression$3;
  *((struct cds_wfs_node * volatile *)&node->next) = &old_head->node;
  tmp_statement_expression$3 = *((struct cds_wfs_node * volatile *)&node->next);
  _v = tmp_statement_expression$3;
  asm("" :  :  : "memory");
  _v = _v;
  _Bool return_value____cds_wfs_end$4;
  return_value____cds_wfs_end$4=___cds_wfs_end((void *)old_head);
  return (signed int)!(return_value____cds_wfs_end$4 != (_Bool)0);
}

// _cds_wfs_push$link1
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link1(union anonymous u_stack$link1, struct cds_wfs_node *node$link1)
{
  struct __cds_wfs_stack *s$link1 = u_stack$link1._s;
  struct cds_wfs_head *old_head$link1;
  struct cds_wfs_head *new_head$link1;
  /* assertion node->next == ((void *)0) */
  assert(node$link1->next == (struct cds_wfs_node *)(void *)0);
  struct cds_wfs_head *tmp_statement_expression$1$link1;
  const struct cds_wfs_node *__ptr$link1 = node$link1;
  tmp_statement_expression$1$link1 = (struct cds_wfs_head *)((char *)__ptr$link1 - (signed long int)0ul);
  new_head$link1 = tmp_statement_expression$1$link1;
  unsigned long int return_value___uatomic_exchange$2$link1;
  return_value___uatomic_exchange$2$link1=__uatomic_exchange$link2((void *)&s$link1->head, (unsigned long int)new_head$link1, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  old_head$link1 = (struct cds_wfs_head *)return_value___uatomic_exchange$2$link1;
  struct cds_wfs_node *_v$link1;
  struct cds_wfs_node * volatile tmp_statement_expression$3$link1;
  *((struct cds_wfs_node * volatile *)&node$link1->next) = &old_head$link1->node;
  tmp_statement_expression$3$link1 = *((struct cds_wfs_node * volatile *)&node$link1->next);
  _v$link1 = tmp_statement_expression$3$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
  _Bool return_value____cds_wfs_end$4$link1;
  return_value____cds_wfs_end$4$link1=___cds_wfs_end$link1((void *)old_head$link1);
  return (signed int)!(return_value____cds_wfs_end$4$link1 != (_Bool)0);
}

// _cds_wfs_push$link1$link1
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link1$link1(union anonymous u_stack$link1$link1, struct cds_wfs_node *node$link1$link1)
{
  struct __cds_wfs_stack *s$link1$link1 = u_stack$link1$link1._s;
  struct cds_wfs_head *old_head$link1$link1;
  struct cds_wfs_head *new_head$link1$link1;
  /* assertion node->next == ((void *)0) */
  assert(node$link1$link1->next == (struct cds_wfs_node *)(void *)0);
  struct cds_wfs_head *tmp_statement_expression$1$link1$link1;
  const struct cds_wfs_node *__ptr$link1$link1 = node$link1$link1;
  tmp_statement_expression$1$link1$link1 = (struct cds_wfs_head *)((char *)__ptr$link1$link1 - (signed long int)0ul);
  new_head$link1$link1 = tmp_statement_expression$1$link1$link1;
  unsigned long int return_value___uatomic_exchange$2$link1$link1;
  return_value___uatomic_exchange$2$link1$link1=__uatomic_exchange$link2$link1((void *)&s$link1$link1->head, (unsigned long int)new_head$link1$link1, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  old_head$link1$link1 = (struct cds_wfs_head *)return_value___uatomic_exchange$2$link1$link1;
  struct cds_wfs_node *_v$link1$link1;
  struct cds_wfs_node * volatile tmp_statement_expression$3$link1$link1;
  *((struct cds_wfs_node * volatile *)&node$link1$link1->next) = &old_head$link1$link1->node;
  tmp_statement_expression$3$link1$link1 = *((struct cds_wfs_node * volatile *)&node$link1$link1->next);
  _v$link1$link1 = tmp_statement_expression$3$link1$link1;
  asm("" :  :  : "memory");
  _v$link1$link1 = _v$link1$link1;
  _Bool return_value____cds_wfs_end$4$link1$link1;
  return_value____cds_wfs_end$4$link1$link1=___cds_wfs_end$link1$link1((void *)old_head$link1$link1);
  return (signed int)!(return_value____cds_wfs_end$4$link1$link1 != (_Bool)0);
}

// _cds_wfs_push$link1$link2
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link1$link2(union anonymous u_stack$link1$link2, struct cds_wfs_node *node$link1$link2)
{
  struct __cds_wfs_stack *s$link1$link2 = u_stack$link1$link2._s;
  struct cds_wfs_head *old_head$link1$link2;
  struct cds_wfs_head *new_head$link1$link2;
  /* assertion node->next == ((void *)0) */
  assert(node$link1$link2->next == (struct cds_wfs_node *)(void *)0);
  struct cds_wfs_head *tmp_statement_expression$1$link1$link2;
  const struct cds_wfs_node *__ptr$link1$link2 = node$link1$link2;
  tmp_statement_expression$1$link1$link2 = (struct cds_wfs_head *)((char *)__ptr$link1$link2 - (signed long int)0ul);
  new_head$link1$link2 = tmp_statement_expression$1$link1$link2;
  unsigned long int return_value___uatomic_exchange$2$link1$link2;
  return_value___uatomic_exchange$2$link1$link2=__uatomic_exchange$link2$link2((void *)&s$link1$link2->head, (unsigned long int)new_head$link1$link2, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  old_head$link1$link2 = (struct cds_wfs_head *)return_value___uatomic_exchange$2$link1$link2;
  struct cds_wfs_node *_v$link1$link2;
  struct cds_wfs_node * volatile tmp_statement_expression$3$link1$link2;
  *((struct cds_wfs_node * volatile *)&node$link1$link2->next) = &old_head$link1$link2->node;
  tmp_statement_expression$3$link1$link2 = *((struct cds_wfs_node * volatile *)&node$link1$link2->next);
  _v$link1$link2 = tmp_statement_expression$3$link1$link2;
  asm("" :  :  : "memory");
  _v$link1$link2 = _v$link1$link2;
  _Bool return_value____cds_wfs_end$4$link1$link2;
  return_value____cds_wfs_end$4$link1$link2=___cds_wfs_end$link1$link2((void *)old_head$link1$link2);
  return (signed int)!(return_value____cds_wfs_end$4$link1$link2 != (_Bool)0);
}

// _cds_wfs_push$link1$link3
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link1$link3(union anonymous u_stack$link1$link3, struct cds_wfs_node *node$link1$link3)
{
  struct __cds_wfs_stack *s$link1$link3 = u_stack$link1$link3._s;
  struct cds_wfs_head *old_head$link1$link3;
  struct cds_wfs_head *new_head$link1$link3;
  /* assertion node->next == ((void *)0) */
  assert(node$link1$link3->next == (struct cds_wfs_node *)(void *)0);
  struct cds_wfs_head *tmp_statement_expression$1$link1$link3;
  const struct cds_wfs_node *__ptr$link1$link3 = node$link1$link3;
  tmp_statement_expression$1$link1$link3 = (struct cds_wfs_head *)((char *)__ptr$link1$link3 - (signed long int)0ul);
  new_head$link1$link3 = tmp_statement_expression$1$link1$link3;
  unsigned long int return_value___uatomic_exchange$2$link1$link3;
  return_value___uatomic_exchange$2$link1$link3=__uatomic_exchange$link2$link3((void *)&s$link1$link3->head, (unsigned long int)new_head$link1$link3, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  old_head$link1$link3 = (struct cds_wfs_head *)return_value___uatomic_exchange$2$link1$link3;
  struct cds_wfs_node *_v$link1$link3;
  struct cds_wfs_node * volatile tmp_statement_expression$3$link1$link3;
  *((struct cds_wfs_node * volatile *)&node$link1$link3->next) = &old_head$link1$link3->node;
  tmp_statement_expression$3$link1$link3 = *((struct cds_wfs_node * volatile *)&node$link1$link3->next);
  _v$link1$link3 = tmp_statement_expression$3$link1$link3;
  asm("" :  :  : "memory");
  _v$link1$link3 = _v$link1$link3;
  _Bool return_value____cds_wfs_end$4$link1$link3;
  return_value____cds_wfs_end$4$link1$link3=___cds_wfs_end$link1$link3((void *)old_head$link1$link3);
  return (signed int)!(return_value____cds_wfs_end$4$link1$link3 != (_Bool)0);
}

// _cds_wfs_push$link2
// file ./urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link2(union anonymous u_stack$link2, struct cds_wfs_node *node$link2)
{
  struct __cds_wfs_stack *s$link2 = u_stack$link2._s;
  struct cds_wfs_head *old_head$link2;
  struct cds_wfs_head *new_head$link2;
  /* assertion node->next == ((void *)0) */
  assert(node$link2->next == (struct cds_wfs_node *)(void *)0);
  struct cds_wfs_head *tmp_statement_expression$1$link2;
  const struct cds_wfs_node *__ptr$link2 = node$link2;
  tmp_statement_expression$1$link2 = (struct cds_wfs_head *)((char *)__ptr$link2 - (signed long int)0ul);
  new_head$link2 = tmp_statement_expression$1$link2;
  unsigned long int return_value___uatomic_exchange$2$link2;
  return_value___uatomic_exchange$2$link2=__uatomic_exchange$link4((void *)&s$link2->head, (unsigned long int)new_head$link2, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  old_head$link2 = (struct cds_wfs_head *)return_value___uatomic_exchange$2$link2;
  struct cds_wfs_node *_v$link2;
  struct cds_wfs_node * volatile tmp_statement_expression$3$link2;
  *((struct cds_wfs_node * volatile *)&node$link2->next) = &old_head$link2->node;
  tmp_statement_expression$3$link2 = *((struct cds_wfs_node * volatile *)&node$link2->next);
  _v$link2 = tmp_statement_expression$3$link2;
  asm("" :  :  : "memory");
  _v$link2 = _v$link2;
  _Bool return_value____cds_wfs_end$4$link2;
  return_value____cds_wfs_end$4$link2=___cds_wfs_end$link2((void *)old_head$link2);
  return (signed int)!(return_value____cds_wfs_end$4$link2 != (_Bool)0);
}

// _cds_wfs_push$link3
// file ./urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link3(union anonymous u_stack$link3, struct cds_wfs_node *node$link3)
{
  struct __cds_wfs_stack *s$link3 = u_stack$link3._s;
  struct cds_wfs_head *old_head$link3;
  struct cds_wfs_head *new_head$link3;
  /* assertion node->next == ((void *)0) */
  assert(node$link3->next == (struct cds_wfs_node *)(void *)0);
  struct cds_wfs_head *tmp_statement_expression$1$link3;
  const struct cds_wfs_node *__ptr$link3 = node$link3;
  tmp_statement_expression$1$link3 = (struct cds_wfs_head *)((char *)__ptr$link3 - (signed long int)0ul);
  new_head$link3 = tmp_statement_expression$1$link3;
  unsigned long int return_value___uatomic_exchange$2$link3;
  return_value___uatomic_exchange$2$link3=__uatomic_exchange$link5((void *)&s$link3->head, (unsigned long int)new_head$link3, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  old_head$link3 = (struct cds_wfs_head *)return_value___uatomic_exchange$2$link3;
  struct cds_wfs_node *_v$link3;
  struct cds_wfs_node * volatile tmp_statement_expression$3$link3;
  *((struct cds_wfs_node * volatile *)&node$link3->next) = &old_head$link3->node;
  tmp_statement_expression$3$link3 = *((struct cds_wfs_node * volatile *)&node$link3->next);
  _v$link3 = tmp_statement_expression$3$link3;
  asm("" :  :  : "memory");
  _v$link3 = _v$link3;
  _Bool return_value____cds_wfs_end$4$link3;
  return_value____cds_wfs_end$4$link3=___cds_wfs_end$link3((void *)old_head$link3);
  return (signed int)!(return_value____cds_wfs_end$4$link3 != (_Bool)0);
}

// _cds_wfs_push$link4
// file ./urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link4(union anonymous u_stack$link4, struct cds_wfs_node *node$link4)
{
  struct __cds_wfs_stack *s$link4 = u_stack$link4._s;
  struct cds_wfs_head *old_head$link4;
  struct cds_wfs_head *new_head$link4;
  /* assertion node->next == ((void *)0) */
  assert(node$link4->next == (struct cds_wfs_node *)(void *)0);
  struct cds_wfs_head *tmp_statement_expression$1$link4;
  const struct cds_wfs_node *__ptr$link4 = node$link4;
  tmp_statement_expression$1$link4 = (struct cds_wfs_head *)((char *)__ptr$link4 - (signed long int)0ul);
  new_head$link4 = tmp_statement_expression$1$link4;
  unsigned long int return_value___uatomic_exchange$2$link4;
  return_value___uatomic_exchange$2$link4=__uatomic_exchange$link6((void *)&s$link4->head, (unsigned long int)new_head$link4, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  old_head$link4 = (struct cds_wfs_head *)return_value___uatomic_exchange$2$link4;
  struct cds_wfs_node *_v$link4;
  struct cds_wfs_node * volatile tmp_statement_expression$3$link4;
  *((struct cds_wfs_node * volatile *)&node$link4->next) = &old_head$link4->node;
  tmp_statement_expression$3$link4 = *((struct cds_wfs_node * volatile *)&node$link4->next);
  _v$link4 = tmp_statement_expression$3$link4;
  asm("" :  :  : "memory");
  _v$link4 = _v$link4;
  _Bool return_value____cds_wfs_end$4$link4;
  return_value____cds_wfs_end$4$link4=___cds_wfs_end$link4((void *)old_head$link4);
  return (signed int)!(return_value____cds_wfs_end$4$link4 != (_Bool)0);
}

// _cds_wfs_push$link5
// file urcu/static/wfstack.h line 127
static inline signed int _cds_wfs_push$link5(union anonymous u_stack$link5, struct cds_wfs_node *node$link5)
{
  struct __cds_wfs_stack *s$link5 = u_stack$link5._s;
  struct cds_wfs_head *old_head$link5;
  struct cds_wfs_head *new_head$link5;
  /* assertion node->next == ((void *)0) */
  assert(node$link5->next == (struct cds_wfs_node *)(void *)0);
  struct cds_wfs_head *tmp_statement_expression$1$link5;
  const struct cds_wfs_node *__ptr$link5 = node$link5;
  tmp_statement_expression$1$link5 = (struct cds_wfs_head *)((char *)__ptr$link5 - (signed long int)0ul);
  new_head$link5 = tmp_statement_expression$1$link5;
  unsigned long int return_value___uatomic_exchange$2$link5;
  return_value___uatomic_exchange$2$link5=__uatomic_exchange$link2$link4((void *)&s$link5->head, (unsigned long int)new_head$link5, (signed int)sizeof(struct cds_wfs_head *) /*8ul*/ );
  old_head$link5 = (struct cds_wfs_head *)return_value___uatomic_exchange$2$link5;
  struct cds_wfs_node *_v$link5;
  struct cds_wfs_node * volatile tmp_statement_expression$3$link5;
  *((struct cds_wfs_node * volatile *)&node$link5->next) = &old_head$link5->node;
  tmp_statement_expression$3$link5 = *((struct cds_wfs_node * volatile *)&node$link5->next);
  _v$link5 = tmp_statement_expression$3$link5;
  asm("" :  :  : "memory");
  _v$link5 = _v$link5;
  _Bool return_value____cds_wfs_end$4$link5;
  return_value____cds_wfs_end$4$link5=___cds_wfs_end$link5((void *)old_head$link5);
  return (signed int)!(return_value____cds_wfs_end$4$link5 != (_Bool)0);
}

// _cleanup
// file tap.c line 414
static void _cleanup(void)
{
  if(tap_is_disabled == 0)
  {
    if(have_plan == 0 && no_plan == 0 && skip_all == 0)
      diag("Looks like your test died before it could output anything.");

    else
      if(!(test_died == 0))
        diag("Looks like your test died just after %d.", test_count);

      else
      {
        if(skip_all == 0 && (have_plan == 0 || !(no_plan == 0)))
          printf("1..%d\n", test_count);

        if(no_plan == 0 && !(have_plan == 0) && !(e_tests >= test_count))
          diag("Looks like you planned %d %s but ran %d extra.", e_tests, e_tests == (unsigned int)1 ? "test" : "tests", test_count - e_tests);

        else
          if(!(test_count >= e_tests) && (no_plan == 0 || !(have_plan == 0)))
            diag("Looks like you planned %d %s but only ran %d.", e_tests, e_tests == (unsigned int)1 ? "test" : "tests", test_count);

          else
            if(!(failures == 0u))
              diag("Looks like you failed %d %s of %d.", failures, failures == (unsigned int)1 ? "test" : "tests", test_count);

      }
  }

}

// _defer_rcu
// file urcu-defer-impl.h line 311
static void _defer_rcu(void (*fct)(void *), void *p)
{
  unsigned long int head;
  unsigned long int tail;
  head = defer_queue.head;
  volatile unsigned long int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile unsigned long int *)&defer_queue.tail);
  tail = tmp_statement_expression$1;
  volatile unsigned long int tmp_statement_expression$2;
  if(head + -tail >= 4094ul)
  {
    /* assertion head - tail <= (1 << 12) */
    assert(head - tail <= (unsigned long int)(1 << 12));
    rcu_defer_barrier_thread_memb();
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((volatile unsigned long int *)&defer_queue.tail);
    /* assertion head - __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__((defer_queue).tail) *)&((defer_queue).tail)); }) == 0 */
    assert(head - tmp_statement_expression$2 == (unsigned long int)0);
  }

  unsigned long int tmp_post$3;
  unsigned long int tmp_post$4;
  unsigned long int tmp_post$5;
  if(p == (void *)-2 || !((1ul & (unsigned long int)p) == 0ul) || !((void (*)(void *))defer_queue.last_fct_in == fct))
  {
    defer_queue.last_fct_in = (void *)fct;
    if(fct == (void (*)(void *))-2 || !((1ul & (unsigned long int)fct) == 0ul))
    {
      tmp_post$3 = head;
      head = head + 1ul;
      *((void * volatile *)&defer_queue.q[(signed long int)(tmp_post$3 & (unsigned long int)((1 << 12) - 1))]) = (void *)~(1 << 0);
      tmp_post$4 = head;
      head = head + 1ul;
      *((void * volatile *)&defer_queue.q[(signed long int)(tmp_post$4 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct;
    }

    else
    {
      fct = (void (*)(void *))(void *)((unsigned long int)fct | (unsigned long int)(1 << 0));
      tmp_post$5 = head;
      head = head + 1ul;
      *((void * volatile *)&defer_queue.q[(signed long int)(tmp_post$5 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct;
    }
  }

  unsigned long int tmp_post$6 = head;
  head = head + 1ul;
  *((void * volatile *)&defer_queue.q[(signed long int)(tmp_post$6 & (unsigned long int)((1 << 12) - 1))]) = p;
  asm("" :  :  : "memory");
  unsigned long int _v;
  volatile unsigned long int tmp_statement_expression$7;
  *((volatile unsigned long int *)&defer_queue.head) = head;
  tmp_statement_expression$7 = *((volatile unsigned long int *)&defer_queue.head);
  _v = tmp_statement_expression$7;
  asm("" :  :  : "memory");
  _v = _v;
  asm("mfence" :  :  : "memory");
  wake_up_defer();
}

// _defer_rcu$link1
// file urcu-defer-impl.h line 311
static void _defer_rcu$link1(void (*fct$link1)(void *), void *p$link1)
{
  unsigned long int head$link1;
  unsigned long int tail$link1;
  head$link1 = defer_queue$link1.head;
  volatile unsigned long int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile unsigned long int *)&defer_queue$link1.tail);
  tail$link1 = tmp_statement_expression$1$link1;
  volatile unsigned long int tmp_statement_expression$2$link1;
  if(head$link1 + -tail$link1 >= 4094ul)
  {
    /* assertion head - tail <= (1 << 12) */
    assert(head$link1 - tail$link1 <= (unsigned long int)(1 << 12));
    rcu_defer_barrier_thread_mb();
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link1 = *((volatile unsigned long int *)&defer_queue$link1.tail);
    /* assertion head - __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__((defer_queue).tail) *)&((defer_queue).tail)); }) == 0 */
    assert(head$link1 - tmp_statement_expression$2$link1 == (unsigned long int)0);
  }

  unsigned long int tmp_post$3$link1;
  unsigned long int tmp_post$4$link1;
  unsigned long int tmp_post$5$link1;
  if(p$link1 == (void *)-2 || !((1ul & (unsigned long int)p$link1) == 0ul) || !((void (*)(void *))defer_queue$link1.last_fct_in == fct$link1))
  {
    defer_queue$link1.last_fct_in = (void *)fct$link1;
    if(fct$link1 == (void (*)(void *))-2 || !((1ul & (unsigned long int)fct$link1) == 0ul))
    {
      tmp_post$3$link1 = head$link1;
      head$link1 = head$link1 + 1ul;
      *((void * volatile *)&defer_queue$link1.q[(signed long int)(tmp_post$3$link1 & (unsigned long int)((1 << 12) - 1))]) = (void *)~(1 << 0);
      tmp_post$4$link1 = head$link1;
      head$link1 = head$link1 + 1ul;
      *((void * volatile *)&defer_queue$link1.q[(signed long int)(tmp_post$4$link1 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct$link1;
    }

    else
    {
      fct$link1 = (void (*)(void *))(void *)((unsigned long int)fct$link1 | (unsigned long int)(1 << 0));
      tmp_post$5$link1 = head$link1;
      head$link1 = head$link1 + 1ul;
      *((void * volatile *)&defer_queue$link1.q[(signed long int)(tmp_post$5$link1 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct$link1;
    }
  }

  unsigned long int tmp_post$6$link1 = head$link1;
  head$link1 = head$link1 + 1ul;
  *((void * volatile *)&defer_queue$link1.q[(signed long int)(tmp_post$6$link1 & (unsigned long int)((1 << 12) - 1))]) = p$link1;
  asm("" :  :  : "memory");
  unsigned long int _v$link1;
  volatile unsigned long int tmp_statement_expression$7$link1;
  *((volatile unsigned long int *)&defer_queue$link1.head) = head$link1;
  tmp_statement_expression$7$link1 = *((volatile unsigned long int *)&defer_queue$link1.head);
  _v$link1 = tmp_statement_expression$7$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
  asm("mfence" :  :  : "memory");
  wake_up_defer$link1();
}

// _defer_rcu$link2
// file urcu-defer-impl.h line 311
static void _defer_rcu$link2(void (*fct$link2)(void *), void *p$link2)
{
  unsigned long int head$link2;
  unsigned long int tail$link2;
  head$link2 = defer_queue$link2.head;
  volatile unsigned long int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile unsigned long int *)&defer_queue$link2.tail);
  tail$link2 = tmp_statement_expression$1$link2;
  volatile unsigned long int tmp_statement_expression$2$link2;
  if(head$link2 + -tail$link2 >= 4094ul)
  {
    /* assertion head - tail <= (1 << 12) */
    assert(head$link2 - tail$link2 <= (unsigned long int)(1 << 12));
    rcu_defer_barrier_thread_sig();
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link2 = *((volatile unsigned long int *)&defer_queue$link2.tail);
    /* assertion head - __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__((defer_queue).tail) *)&((defer_queue).tail)); }) == 0 */
    assert(head$link2 - tmp_statement_expression$2$link2 == (unsigned long int)0);
  }

  unsigned long int tmp_post$3$link2;
  unsigned long int tmp_post$4$link2;
  unsigned long int tmp_post$5$link2;
  if(p$link2 == (void *)-2 || !((1ul & (unsigned long int)p$link2) == 0ul) || !((void (*)(void *))defer_queue$link2.last_fct_in == fct$link2))
  {
    defer_queue$link2.last_fct_in = (void *)fct$link2;
    if(fct$link2 == (void (*)(void *))-2 || !((1ul & (unsigned long int)fct$link2) == 0ul))
    {
      tmp_post$3$link2 = head$link2;
      head$link2 = head$link2 + 1ul;
      *((void * volatile *)&defer_queue$link2.q[(signed long int)(tmp_post$3$link2 & (unsigned long int)((1 << 12) - 1))]) = (void *)~(1 << 0);
      tmp_post$4$link2 = head$link2;
      head$link2 = head$link2 + 1ul;
      *((void * volatile *)&defer_queue$link2.q[(signed long int)(tmp_post$4$link2 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct$link2;
    }

    else
    {
      fct$link2 = (void (*)(void *))(void *)((unsigned long int)fct$link2 | (unsigned long int)(1 << 0));
      tmp_post$5$link2 = head$link2;
      head$link2 = head$link2 + 1ul;
      *((void * volatile *)&defer_queue$link2.q[(signed long int)(tmp_post$5$link2 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct$link2;
    }
  }

  unsigned long int tmp_post$6$link2 = head$link2;
  head$link2 = head$link2 + 1ul;
  *((void * volatile *)&defer_queue$link2.q[(signed long int)(tmp_post$6$link2 & (unsigned long int)((1 << 12) - 1))]) = p$link2;
  asm("" :  :  : "memory");
  unsigned long int _v$link2;
  volatile unsigned long int tmp_statement_expression$7$link2;
  *((volatile unsigned long int *)&defer_queue$link2.head) = head$link2;
  tmp_statement_expression$7$link2 = *((volatile unsigned long int *)&defer_queue$link2.head);
  _v$link2 = tmp_statement_expression$7$link2;
  asm("" :  :  : "memory");
  _v$link2 = _v$link2;
  asm("mfence" :  :  : "memory");
  wake_up_defer$link2();
}

// _defer_rcu$link3
// file urcu-defer-impl.h line 311
static void _defer_rcu$link3(void (*fct$link3)(void *), void *p$link3)
{
  unsigned long int head$link3;
  unsigned long int tail$link3;
  head$link3 = defer_queue$link3.head;
  volatile unsigned long int tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((volatile unsigned long int *)&defer_queue$link3.tail);
  tail$link3 = tmp_statement_expression$1$link3;
  volatile unsigned long int tmp_statement_expression$2$link3;
  if(head$link3 + -tail$link3 >= 4094ul)
  {
    /* assertion head - tail <= (1 << 12) */
    assert(head$link3 - tail$link3 <= (unsigned long int)(1 << 12));
    rcu_defer_barrier_thread_qsbr();
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link3 = *((volatile unsigned long int *)&defer_queue$link3.tail);
    /* assertion head - __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__((defer_queue).tail) *)&((defer_queue).tail)); }) == 0 */
    assert(head$link3 - tmp_statement_expression$2$link3 == (unsigned long int)0);
  }

  unsigned long int tmp_post$3$link3;
  unsigned long int tmp_post$4$link3;
  unsigned long int tmp_post$5$link3;
  if(p$link3 == (void *)-2 || !((1ul & (unsigned long int)p$link3) == 0ul) || !((void (*)(void *))defer_queue$link3.last_fct_in == fct$link3))
  {
    defer_queue$link3.last_fct_in = (void *)fct$link3;
    if(fct$link3 == (void (*)(void *))-2 || !((1ul & (unsigned long int)fct$link3) == 0ul))
    {
      tmp_post$3$link3 = head$link3;
      head$link3 = head$link3 + 1ul;
      *((void * volatile *)&defer_queue$link3.q[(signed long int)(tmp_post$3$link3 & (unsigned long int)((1 << 12) - 1))]) = (void *)~(1 << 0);
      tmp_post$4$link3 = head$link3;
      head$link3 = head$link3 + 1ul;
      *((void * volatile *)&defer_queue$link3.q[(signed long int)(tmp_post$4$link3 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct$link3;
    }

    else
    {
      fct$link3 = (void (*)(void *))(void *)((unsigned long int)fct$link3 | (unsigned long int)(1 << 0));
      tmp_post$5$link3 = head$link3;
      head$link3 = head$link3 + 1ul;
      *((void * volatile *)&defer_queue$link3.q[(signed long int)(tmp_post$5$link3 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct$link3;
    }
  }

  unsigned long int tmp_post$6$link3 = head$link3;
  head$link3 = head$link3 + 1ul;
  *((void * volatile *)&defer_queue$link3.q[(signed long int)(tmp_post$6$link3 & (unsigned long int)((1 << 12) - 1))]) = p$link3;
  asm("" :  :  : "memory");
  unsigned long int _v$link3;
  volatile unsigned long int tmp_statement_expression$7$link3;
  *((volatile unsigned long int *)&defer_queue$link3.head) = head$link3;
  tmp_statement_expression$7$link3 = *((volatile unsigned long int *)&defer_queue$link3.head);
  _v$link3 = tmp_statement_expression$7$link3;
  asm("" :  :  : "memory");
  _v$link3 = _v$link3;
  asm("mfence" :  :  : "memory");
  wake_up_defer$link3();
}

// _defer_rcu$link4
// file urcu-defer-impl.h line 311
static void _defer_rcu$link4(void (*fct$link4)(void *), void *p$link4)
{
  unsigned long int head$link4;
  unsigned long int tail$link4;
  head$link4 = defer_queue$link4.head;
  volatile unsigned long int tmp_statement_expression$1$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link4 = *((volatile unsigned long int *)&defer_queue$link4.tail);
  tail$link4 = tmp_statement_expression$1$link4;
  volatile unsigned long int tmp_statement_expression$2$link4;
  if(head$link4 + -tail$link4 >= 4094ul)
  {
    /* assertion head - tail <= (1 << 12) */
    assert(head$link4 - tail$link4 <= (unsigned long int)(1 << 12));
    rcu_defer_barrier_thread_bp();
    asm("" :  :  : "memory");
    tmp_statement_expression$2$link4 = *((volatile unsigned long int *)&defer_queue$link4.tail);
    /* assertion head - __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__((defer_queue).tail) *)&((defer_queue).tail)); }) == 0 */
    assert(head$link4 - tmp_statement_expression$2$link4 == (unsigned long int)0);
  }

  unsigned long int tmp_post$3$link4;
  unsigned long int tmp_post$4$link4;
  unsigned long int tmp_post$5$link4;
  if(p$link4 == (void *)-2 || !((1ul & (unsigned long int)p$link4) == 0ul) || !((void (*)(void *))defer_queue$link4.last_fct_in == fct$link4))
  {
    defer_queue$link4.last_fct_in = (void *)fct$link4;
    if(fct$link4 == (void (*)(void *))-2 || !((1ul & (unsigned long int)fct$link4) == 0ul))
    {
      tmp_post$3$link4 = head$link4;
      head$link4 = head$link4 + 1ul;
      *((void * volatile *)&defer_queue$link4.q[(signed long int)(tmp_post$3$link4 & (unsigned long int)((1 << 12) - 1))]) = (void *)~(1 << 0);
      tmp_post$4$link4 = head$link4;
      head$link4 = head$link4 + 1ul;
      *((void * volatile *)&defer_queue$link4.q[(signed long int)(tmp_post$4$link4 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct$link4;
    }

    else
    {
      fct$link4 = (void (*)(void *))(void *)((unsigned long int)fct$link4 | (unsigned long int)(1 << 0));
      tmp_post$5$link4 = head$link4;
      head$link4 = head$link4 + 1ul;
      *((void * volatile *)&defer_queue$link4.q[(signed long int)(tmp_post$5$link4 & (unsigned long int)((1 << 12) - 1))]) = (void *)fct$link4;
    }
  }

  unsigned long int tmp_post$6$link4 = head$link4;
  head$link4 = head$link4 + 1ul;
  *((void * volatile *)&defer_queue$link4.q[(signed long int)(tmp_post$6$link4 & (unsigned long int)((1 << 12) - 1))]) = p$link4;
  asm("" :  :  : "memory");
  unsigned long int _v$link4;
  volatile unsigned long int tmp_statement_expression$7$link4;
  *((volatile unsigned long int *)&defer_queue$link4.head) = head$link4;
  tmp_statement_expression$7$link4 = *((volatile unsigned long int *)&defer_queue$link4.head);
  _v$link4 = tmp_statement_expression$7$link4;
  asm("" :  :  : "memory");
  _v$link4 = _v$link4;
  asm("mfence" :  :  : "memory");
  wake_up_defer$link4();
}

// _expected_tests
// file tap.c line 315
static void _expected_tests(unsigned int tests)
{
  printf("1..%d\n", tests);
  e_tests = tests;
}

// _gen_result
// file ../../tests/utils/tap.h line 76
unsigned int _gen_result(signed int ok, const char *func, char *file, unsigned int line, char *test_name, ...)
{
  void **ap;
  char *local_test_name = (char *)(void *)0;
  char *c;
  signed int name_is_digits;
  test_count = test_count + 1u;
  const unsigned short int **return_value___ctype_b_loc$2;
  if(!(test_name == ((char *)NULL)))
  {
    ap = (void **)&test_name;
    signed int return_value_vasprintf$1;
    return_value_vasprintf$1=vasprintf(&local_test_name, test_name, ap);
    if(return_value_vasprintf$1 == -1)
      local_test_name = (char *)(void *)0;

    ap = ((void **)NULL);
    if(!(local_test_name == ((char *)NULL)))
    {
      name_is_digits = 1;
      c = local_test_name;
      for( ; !((signed int)*c == 0); c = c + 1l)
      {
        const unsigned short int **return_value___ctype_b_loc$3;
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*c]) == 0)
        {
          return_value___ctype_b_loc$2=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*c]) == 0)
          {
            name_is_digits = 0;
            break;
          }

        }

      }
      if(!(name_is_digits == 0))
      {
        diag("    You named your test '%s'.  You shouldn't use numbers for your test names.", local_test_name);
        diag("    Very confusing.");
      }

    }

  }

  if(ok == 0)
  {
    printf("not ");
    failures = failures + 1u;
  }

  printf("ok %d", test_count);
  if(!(test_name == ((char *)NULL)))
  {
    printf(" - ");
    if(!(local_test_name == ((char *)NULL)))
    {
      flockfile(stdout);
      c = local_test_name;
      for( ; !((signed int)*c == 0); c = c + 1l)
      {
        if((signed int)*c == 35)
          fputc(92, stdout);

        fputc((signed int)*c, stdout);
      }
      funlockfile(stdout);
    }

    else
      printf("%s", todo_msg_fixed);
  }

  if(!(todo == 0))
  {
    printf(" # TODO %s", todo_msg != ((char *)NULL) ? todo_msg : todo_msg_fixed);
    if(ok == 0)
      failures = failures - 1u;

  }

  printf("\n");
  if(ok == 0)
  {
    char *return_value_getenv$4;
    return_value_getenv$4=getenv("HARNESS_ACTIVE");
    if(!(return_value_getenv$4 == ((char *)NULL)))
      fputs("\n", stderr);

    diag("    Failed %stest (%s:%s() at line %d)", todo != 0 ? "(TODO) " : "", file, func, line);
  }

  free((void *)local_test_name);
  return (unsigned int)(ok != 0 ? 1 : 0);
}

// _rcu_barrier_complete
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete(struct rcu_head *head)
{
  struct call_rcu_completion_work *work;
  struct call_rcu_completion *completion;
  struct call_rcu_completion_work *tmp_statement_expression$1;
  const struct rcu_head *__ptr = head;
  tmp_statement_expression$1 = (struct call_rcu_completion_work *)((char *)__ptr - (signed long int)0ul);
  work = tmp_statement_expression$1;
  completion = work->completion;
  unsigned long int return_value___uatomic_add_return$2;
  return_value___uatomic_add_return$2=__uatomic_add_return((void *)&completion->barrier_count, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
  if((signed int)return_value___uatomic_add_return$2 == 0)
    call_rcu_completion_wake_up(completion);

  urcu_ref_put(&completion->ref, free_completion);
  free((void *)work);
}

// _rcu_barrier_complete$link1
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete$link1(struct rcu_head *head$link1)
{
  struct call_rcu_completion_work *work$link1;
  struct call_rcu_completion *completion$link1;
  struct call_rcu_completion_work *tmp_statement_expression$1$link1;
  const struct rcu_head *__ptr$link1 = head$link1;
  tmp_statement_expression$1$link1 = (struct call_rcu_completion_work *)((char *)__ptr$link1 - (signed long int)0ul);
  work$link1 = tmp_statement_expression$1$link1;
  completion$link1 = work$link1->completion;
  unsigned long int return_value___uatomic_add_return$2$link1;
  return_value___uatomic_add_return$2$link1=__uatomic_add_return$link1((void *)&completion$link1->barrier_count, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
  if((signed int)return_value___uatomic_add_return$2$link1 == 0)
    call_rcu_completion_wake_up$link1(completion$link1);

  urcu_ref_put$link1(&completion$link1->ref, free_completion$link1);
  free((void *)work$link1);
}

// _rcu_barrier_complete$link2
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete$link2(struct rcu_head *head$link2)
{
  struct call_rcu_completion_work *work$link2;
  struct call_rcu_completion *completion$link2;
  struct call_rcu_completion_work *tmp_statement_expression$1$link2;
  const struct rcu_head *__ptr$link2 = head$link2;
  tmp_statement_expression$1$link2 = (struct call_rcu_completion_work *)((char *)__ptr$link2 - (signed long int)0ul);
  work$link2 = tmp_statement_expression$1$link2;
  completion$link2 = work$link2->completion;
  unsigned long int return_value___uatomic_add_return$2$link2;
  return_value___uatomic_add_return$2$link2=__uatomic_add_return$link2((void *)&completion$link2->barrier_count, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
  if((signed int)return_value___uatomic_add_return$2$link2 == 0)
    call_rcu_completion_wake_up$link2(completion$link2);

  urcu_ref_put$link2(&completion$link2->ref, free_completion$link2);
  free((void *)work$link2);
}

// _rcu_barrier_complete$link3
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete$link3(struct rcu_head *head$link3)
{
  struct call_rcu_completion_work *work$link3;
  struct call_rcu_completion *completion$link3;
  struct call_rcu_completion_work *tmp_statement_expression$1$link3;
  const struct rcu_head *__ptr$link3 = head$link3;
  tmp_statement_expression$1$link3 = (struct call_rcu_completion_work *)((char *)__ptr$link3 - (signed long int)0ul);
  work$link3 = tmp_statement_expression$1$link3;
  completion$link3 = work$link3->completion;
  unsigned long int return_value___uatomic_add_return$2$link3;
  return_value___uatomic_add_return$2$link3=__uatomic_add_return$link3((void *)&completion$link3->barrier_count, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
  if((signed int)return_value___uatomic_add_return$2$link3 == 0)
    call_rcu_completion_wake_up$link3(completion$link3);

  urcu_ref_put$link3(&completion$link3->ref, free_completion$link3);
  free((void *)work$link3);
}

// _rcu_barrier_complete$link4
// file urcu-call-rcu-impl.h line 822
static void _rcu_barrier_complete$link4(struct rcu_head *head$link4)
{
  struct call_rcu_completion_work *work$link4;
  struct call_rcu_completion *completion$link4;
  struct call_rcu_completion_work *tmp_statement_expression$1$link4;
  const struct rcu_head *__ptr$link4 = head$link4;
  tmp_statement_expression$1$link4 = (struct call_rcu_completion_work *)((char *)__ptr$link4 - (signed long int)0ul);
  work$link4 = tmp_statement_expression$1$link4;
  completion$link4 = work$link4->completion;
  unsigned long int return_value___uatomic_add_return$2$link4;
  return_value___uatomic_add_return$2$link4=__uatomic_add_return$link4((void *)&completion$link4->barrier_count, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
  if((signed int)return_value___uatomic_add_return$2$link4 == 0)
    call_rcu_completion_wake_up$link4(completion$link4);

  urcu_ref_put$link4(&completion$link4->ref, free_completion$link4);
  free((void *)work$link4);
}

// _rcu_defer_barrier_thread
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread(void)
{
  unsigned long int head;
  unsigned long int num_items;
  head = defer_queue.head;
  num_items = head - defer_queue.tail;
  if(!(num_items == 0ul))
  {
    synchronize_rcu_memb();
    rcu_defer_barrier_queue(&defer_queue, head);
  }

}

// _rcu_defer_barrier_thread$link1
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread$link1(void)
{
  unsigned long int head$link1;
  unsigned long int num_items$link1;
  head$link1 = defer_queue$link1.head;
  num_items$link1 = head$link1 - defer_queue$link1.tail;
  if(!(num_items$link1 == 0ul))
  {
    synchronize_rcu_mb();
    rcu_defer_barrier_queue$link1(&defer_queue$link1, head$link1);
  }

}

// _rcu_defer_barrier_thread$link2
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread$link2(void)
{
  unsigned long int head$link2;
  unsigned long int num_items$link2;
  head$link2 = defer_queue$link2.head;
  num_items$link2 = head$link2 - defer_queue$link2.tail;
  if(!(num_items$link2 == 0ul))
  {
    synchronize_rcu_sig();
    rcu_defer_barrier_queue$link2(&defer_queue$link2, head$link2);
  }

}

// _rcu_defer_barrier_thread$link3
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread$link3(void)
{
  unsigned long int head$link3;
  unsigned long int num_items$link3;
  head$link3 = defer_queue$link3.head;
  num_items$link3 = head$link3 - defer_queue$link3.tail;
  if(!(num_items$link3 == 0ul))
  {
    synchronize_rcu_qsbr();
    rcu_defer_barrier_queue$link3(&defer_queue$link3, head$link3);
  }

}

// _rcu_defer_barrier_thread$link4
// file urcu-defer-impl.h line 249
static void _rcu_defer_barrier_thread$link4(void)
{
  unsigned long int head$link4;
  unsigned long int num_items$link4;
  head$link4 = defer_queue$link4.head;
  num_items$link4 = head$link4 - defer_queue$link4.tail;
  if(!(num_items$link4 == 0ul))
  {
    synchronize_rcu_bp();
    rcu_defer_barrier_queue$link4(&defer_queue$link4, head$link4);
  }

}

// _rcu_quiescent_state_qsbr
// file urcu/static/urcu-qsbr.h line 193
static inline void _rcu_quiescent_state_qsbr(void)
{
  unsigned long int gp_ctr;
  volatile unsigned long int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile unsigned long int *)&rcu_gp_qsbr.ctr);
  gp_ctr = tmp_statement_expression$1;
  if(!(gp_ctr == rcu_reader_qsbr.ctr))
    _rcu_quiescent_state_update_and_wakeup(gp_ctr);

}

// _rcu_quiescent_state_update_and_wakeup
// file urcu/static/urcu-qsbr.h line 172
static inline void _rcu_quiescent_state_update_and_wakeup(unsigned long int gp_ctr)
{
  asm("mfence" :  :  : "memory");
  *((volatile unsigned long int *)&rcu_reader_qsbr.ctr) = gp_ctr;
  asm("mfence" :  :  : "memory");
  wake_up_gp$link3();
  asm("mfence" :  :  : "memory");
}

// _rcu_read_lock_bp
// file urcu/static/urcu-bp.h line 159
static inline void _rcu_read_lock_bp(void)
{
  unsigned long int tmp;
  if(rcu_reader_bp == ((struct rcu_reader_bp *)NULL))
    rcu_bp_register();

  asm("" :  :  : "memory");
  tmp = rcu_reader_bp->ctr;
  _rcu_read_lock_update$link3(tmp);
}

// _rcu_read_lock_mb
// file urcu/static/urcu.h line 214
static inline void _rcu_read_lock_mb(void)
{
  unsigned long int tmp;
  asm("" :  :  : "memory");
  tmp = rcu_reader_mb.ctr;
  _rcu_read_lock_update$link1(tmp);
}

// _rcu_read_lock_memb
// file urcu/static/urcu.h line 214
static inline void _rcu_read_lock_memb(void)
{
  unsigned long int tmp;
  asm("" :  :  : "memory");
  tmp = rcu_reader_memb.ctr;
  _rcu_read_lock_update(tmp);
}

// _rcu_read_lock_qsbr
// file urcu/static/urcu-qsbr.h line 134
static inline void _rcu_read_lock_qsbr(void)
{
  ;
}

// _rcu_read_lock_sig
// file urcu/static/urcu.h line 214
static inline void _rcu_read_lock_sig(void)
{
  unsigned long int tmp;
  asm("" :  :  : "memory");
  tmp = rcu_reader_sig.ctr;
  _rcu_read_lock_update$link2(tmp);
}

// _rcu_read_lock_update
// file urcu/static/urcu.h line 195
static inline void _rcu_read_lock_update(unsigned long int tmp)
{
  if((4294967295ul & tmp) == 0ul)
  {
    *((volatile unsigned long int *)&rcu_reader_memb.ctr) = *((volatile unsigned long int *)&rcu_gp_memb.ctr);
    smp_mb_slave();
  }

  else
    *((volatile unsigned long int *)&rcu_reader_memb.ctr) = tmp + (1UL << 0);
}

// _rcu_read_lock_update$link1
// file urcu/static/urcu.h line 195
static inline void _rcu_read_lock_update$link1(unsigned long int tmp$link1)
{
  if((4294967295ul & tmp$link1) == 0ul)
  {
    *((volatile unsigned long int *)&rcu_reader_mb.ctr) = *((volatile unsigned long int *)&rcu_gp_mb.ctr);
    smp_mb_slave$link1();
  }

  else
    *((volatile unsigned long int *)&rcu_reader_mb.ctr) = tmp$link1 + (1UL << 0);
}

// _rcu_read_lock_update$link2
// file urcu/static/urcu.h line 195
static inline void _rcu_read_lock_update$link2(unsigned long int tmp$link2)
{
  if((4294967295ul & tmp$link2) == 0ul)
  {
    *((volatile unsigned long int *)&rcu_reader_sig.ctr) = *((volatile unsigned long int *)&rcu_gp_sig.ctr);
    smp_mb_slave$link2();
  }

  else
    *((volatile unsigned long int *)&rcu_reader_sig.ctr) = tmp$link2 + (1UL << 0);
}

// _rcu_read_lock_update$link3
// file urcu/static/urcu-bp.h line 140
static inline void _rcu_read_lock_update$link3(unsigned long int tmp$link3)
{
  if((4294967295ul & tmp$link3) == 0ul)
  {
    *((volatile unsigned long int *)&rcu_reader_bp->ctr) = *((volatile unsigned long int *)&rcu_gp_bp.ctr);
    urcu_bp_smp_mb_slave();
  }

  else
    *((volatile unsigned long int *)&rcu_reader_bp->ctr) = tmp$link3 + (1UL << 0);
}

// _rcu_read_ongoing_bp
// file urcu/static/urcu-bp.h line 195
static inline signed int _rcu_read_ongoing_bp(void)
{
  if(rcu_reader_bp == ((struct rcu_reader_bp *)NULL))
    rcu_bp_register();

  return (signed int)(rcu_reader_bp->ctr & (1UL << (sizeof(signed long int) /*8ul*/  << 2)) - (unsigned long int)1);
}

// _rcu_read_ongoing_mb
// file urcu/static/urcu.h line 267
static inline signed int _rcu_read_ongoing_mb(void)
{
  return (signed int)(rcu_reader_mb.ctr & (1UL << (sizeof(unsigned long int) /*8ul*/  << 2)) - (unsigned long int)1);
}

// _rcu_read_ongoing_memb
// file urcu/static/urcu.h line 267
static inline signed int _rcu_read_ongoing_memb(void)
{
  return (signed int)(rcu_reader_memb.ctr & (1UL << (sizeof(unsigned long int) /*8ul*/  << 2)) - (unsigned long int)1);
}

// _rcu_read_ongoing_qsbr
// file urcu/static/urcu-qsbr.h line 158
static inline signed int _rcu_read_ongoing_qsbr(void)
{
  return (signed int)rcu_reader_qsbr.ctr;
}

// _rcu_read_ongoing_sig
// file urcu/static/urcu.h line 267
static inline signed int _rcu_read_ongoing_sig(void)
{
  return (signed int)(rcu_reader_sig.ctr & (1UL << (sizeof(unsigned long int) /*8ul*/  << 2)) - (unsigned long int)1);
}

// _rcu_read_unlock_bp
// file urcu/static/urcu-bp.h line 176
static inline void _rcu_read_unlock_bp(void)
{
  unsigned long int tmp = rcu_reader_bp->ctr;
  urcu_bp_smp_mb_slave();
  *((volatile unsigned long int *)&rcu_reader_bp->ctr) = tmp - (1UL << 0);
  asm("" :  :  : "memory");
}

// _rcu_read_unlock_mb
// file urcu/static/urcu.h line 249
static inline void _rcu_read_unlock_mb(void)
{
  unsigned long int tmp = rcu_reader_mb.ctr;
  _rcu_read_unlock_update_and_wakeup$link1(tmp);
  asm("" :  :  : "memory");
}

// _rcu_read_unlock_memb
// file urcu/static/urcu.h line 249
static inline void _rcu_read_unlock_memb(void)
{
  unsigned long int tmp = rcu_reader_memb.ctr;
  _rcu_read_unlock_update_and_wakeup(tmp);
  asm("" :  :  : "memory");
}

// _rcu_read_unlock_qsbr
// file urcu/static/urcu-qsbr.h line 146
static inline void _rcu_read_unlock_qsbr(void)
{
  ;
}

// _rcu_read_unlock_sig
// file urcu/static/urcu.h line 249
static inline void _rcu_read_unlock_sig(void)
{
  unsigned long int tmp = rcu_reader_sig.ctr;
  _rcu_read_unlock_update_and_wakeup$link2(tmp);
  asm("" :  :  : "memory");
}

// _rcu_read_unlock_update_and_wakeup
// file urcu/static/urcu.h line 233
static inline void _rcu_read_unlock_update_and_wakeup(unsigned long int tmp)
{
  if((4294967295ul & tmp) == 1UL)
  {
    smp_mb_slave();
    *((volatile unsigned long int *)&rcu_reader_memb.ctr) = tmp - (1UL << 0);
    smp_mb_slave();
    wake_up_gp();
  }

  else
    *((volatile unsigned long int *)&rcu_reader_memb.ctr) = tmp - (1UL << 0);
}

// _rcu_read_unlock_update_and_wakeup$link1
// file urcu/static/urcu.h line 233
static inline void _rcu_read_unlock_update_and_wakeup$link1(unsigned long int tmp$link1)
{
  if((4294967295ul & tmp$link1) == 1UL)
  {
    smp_mb_slave$link1();
    *((volatile unsigned long int *)&rcu_reader_mb.ctr) = tmp$link1 - (1UL << 0);
    smp_mb_slave$link1();
    wake_up_gp$link1();
  }

  else
    *((volatile unsigned long int *)&rcu_reader_mb.ctr) = tmp$link1 - (1UL << 0);
}

// _rcu_read_unlock_update_and_wakeup$link2
// file urcu/static/urcu.h line 233
static inline void _rcu_read_unlock_update_and_wakeup$link2(unsigned long int tmp$link2)
{
  if((4294967295ul & tmp$link2) == 1UL)
  {
    smp_mb_slave$link2();
    *((volatile unsigned long int *)&rcu_reader_sig.ctr) = tmp$link2 - (1UL << 0);
    smp_mb_slave$link2();
    wake_up_gp$link2();
  }

  else
    *((volatile unsigned long int *)&rcu_reader_sig.ctr) = tmp$link2 - (1UL << 0);
}

// _rcu_thread_offline
// file urcu/static/urcu-qsbr.h line 211
static inline void _rcu_thread_offline(void)
{
  asm("mfence" :  :  : "memory");
  unsigned long int _v;
  volatile unsigned long int tmp_statement_expression$1;
  *((volatile unsigned long int *)&rcu_reader_qsbr.ctr) = (volatile unsigned long int)0;
  tmp_statement_expression$1 = *((volatile unsigned long int *)&rcu_reader_qsbr.ctr);
  _v = tmp_statement_expression$1;
  asm("" :  :  : "memory");
  _v = _v;
  asm("mfence" :  :  : "memory");
  wake_up_gp$link3();
  asm("" :  :  : "memory");
}

// _rcu_thread_online
// file urcu/static/urcu-qsbr.h line 229
static inline void _rcu_thread_online(void)
{
  asm("" :  :  : "memory");
  volatile unsigned long int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile unsigned long int *)&rcu_gp_qsbr.ctr);
  *((volatile unsigned long int *)&rcu_reader_qsbr.ctr) = tmp_statement_expression$1;
  asm("mfence" :  :  : "memory");
}

// _tap_init
// file tap.c line 172
static void _tap_init(void)
{
  static signed int run_once = 0;
  if(run_once == 0)
  {
    atexit(_cleanup);
    setbuf(stdout, ((char *)NULL));
    run_once = 1;
  }

}

// add_thread
// file urcu-bp.c line 457
static void add_thread(void)
{
  struct rcu_reader_bp *rcu_reader_reg;
  signed int ret;
  rcu_reader_reg=arena_alloc(&registry_arena);
  if(rcu_reader_reg == ((struct rcu_reader_bp *)NULL))
    abort();

  ret=pthread_setspecific(urcu_bp_key, (const void *)rcu_reader_reg);
  if(!(ret == 0))
    abort();

  rcu_reader_reg->tid=pthread_self();
  /* assertion rcu_reader_reg->ctr == 0 */
  assert(rcu_reader_reg->ctr == (unsigned long int)0);
  cds_list_add$link4(&rcu_reader_reg->node, &registry$link4);
  rcu_reader_bp = rcu_reader_reg;
}

// alloc_cpu_call_rcu_data
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data(void)
{
  struct call_rcu_data **p;
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  if(maxcpus == 0l)
  {
    maxcpus=sysconf(83);
    if(maxcpus >= 1l)
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc((unsigned long int)maxcpus * sizeof(struct call_rcu_data *) /*8ul*/ );
      p = (struct call_rcu_data **)return_value_malloc$1;
      if(!(p == ((struct call_rcu_data **)NULL)))
      {
        memset((void *)p, 0, (unsigned long int)maxcpus * sizeof(struct call_rcu_data *) /*8ul*/ );
        do
        {
          struct call_rcu_data **_________pv = p;
          asm("sfence" :  :  : "memory");
          struct call_rcu_data **_v;
          *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data))) = _________pv;
          tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data)));
          _v = tmp_statement_expression$2;
          asm("" :  :  : "memory");
          _v = _v;
        }
        while((_Bool)0);
      }

      else
      {
        static signed int warned = 0;
        if(warned == 0)
          fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

        warned = 1;
      }
    }

  }

}

// alloc_cpu_call_rcu_data$link1
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data$link1(void)
{
  struct call_rcu_data **p$link1;
  struct call_rcu_data ** volatile tmp_statement_expression$2$link1;
  if(maxcpus$link1 == 0l)
  {
    maxcpus$link1=sysconf(83);
    if(maxcpus$link1 >= 1l)
    {
      void *return_value_malloc$1$link1;
      return_value_malloc$1$link1=malloc((unsigned long int)maxcpus$link1 * sizeof(struct call_rcu_data *) /*8ul*/ );
      p$link1 = (struct call_rcu_data **)return_value_malloc$1$link1;
      if(!(p$link1 == ((struct call_rcu_data **)NULL)))
      {
        memset((void *)p$link1, 0, (unsigned long int)maxcpus$link1 * sizeof(struct call_rcu_data *) /*8ul*/ );
        do
        {
          struct call_rcu_data **_________pv$link1 = p$link1;
          asm("sfence" :  :  : "memory");
          struct call_rcu_data **_v$link1;
          *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link1))) = _________pv$link1;
          tmp_statement_expression$2$link1 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link1)));
          _v$link1 = tmp_statement_expression$2$link1;
          asm("" :  :  : "memory");
          _v$link1 = _v$link1;
        }
        while((_Bool)0);
      }

      else
      {
        static signed int warned$link1 = 0;
        if(warned$link1 == 0)
          fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

        warned$link1 = 1;
      }
    }

  }

}

// alloc_cpu_call_rcu_data$link2
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data$link2(void)
{
  struct call_rcu_data **p$link2;
  struct call_rcu_data ** volatile tmp_statement_expression$2$link2;
  if(maxcpus$link2 == 0l)
  {
    maxcpus$link2=sysconf(83);
    if(maxcpus$link2 >= 1l)
    {
      void *return_value_malloc$1$link2;
      return_value_malloc$1$link2=malloc((unsigned long int)maxcpus$link2 * sizeof(struct call_rcu_data *) /*8ul*/ );
      p$link2 = (struct call_rcu_data **)return_value_malloc$1$link2;
      if(!(p$link2 == ((struct call_rcu_data **)NULL)))
      {
        memset((void *)p$link2, 0, (unsigned long int)maxcpus$link2 * sizeof(struct call_rcu_data *) /*8ul*/ );
        do
        {
          struct call_rcu_data **_________pv$link2 = p$link2;
          asm("sfence" :  :  : "memory");
          struct call_rcu_data **_v$link2;
          *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link2))) = _________pv$link2;
          tmp_statement_expression$2$link2 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link2)));
          _v$link2 = tmp_statement_expression$2$link2;
          asm("" :  :  : "memory");
          _v$link2 = _v$link2;
        }
        while((_Bool)0);
      }

      else
      {
        static signed int warned$link2 = 0;
        if(warned$link2 == 0)
          fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

        warned$link2 = 1;
      }
    }

  }

}

// alloc_cpu_call_rcu_data$link3
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data$link3(void)
{
  struct call_rcu_data **p$link3;
  struct call_rcu_data ** volatile tmp_statement_expression$2$link3;
  if(maxcpus$link3 == 0l)
  {
    maxcpus$link3=sysconf(83);
    if(maxcpus$link3 >= 1l)
    {
      void *return_value_malloc$1$link3;
      return_value_malloc$1$link3=malloc((unsigned long int)maxcpus$link3 * sizeof(struct call_rcu_data *) /*8ul*/ );
      p$link3 = (struct call_rcu_data **)return_value_malloc$1$link3;
      if(!(p$link3 == ((struct call_rcu_data **)NULL)))
      {
        memset((void *)p$link3, 0, (unsigned long int)maxcpus$link3 * sizeof(struct call_rcu_data *) /*8ul*/ );
        do
        {
          struct call_rcu_data **_________pv$link3 = p$link3;
          asm("sfence" :  :  : "memory");
          struct call_rcu_data **_v$link3;
          *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link3))) = _________pv$link3;
          tmp_statement_expression$2$link3 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link3)));
          _v$link3 = tmp_statement_expression$2$link3;
          asm("" :  :  : "memory");
          _v$link3 = _v$link3;
        }
        while((_Bool)0);
      }

      else
      {
        static signed int warned$link3 = 0;
        if(warned$link3 == 0)
          fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

        warned$link3 = 1;
      }
    }

  }

}

// alloc_cpu_call_rcu_data$link4
// file urcu-call-rcu-impl.h line 130
static void alloc_cpu_call_rcu_data$link4(void)
{
  struct call_rcu_data **p$link4;
  struct call_rcu_data ** volatile tmp_statement_expression$2$link4;
  if(maxcpus$link4 == 0l)
  {
    maxcpus$link4=sysconf(83);
    if(maxcpus$link4 >= 1l)
    {
      void *return_value_malloc$1$link4;
      return_value_malloc$1$link4=malloc((unsigned long int)maxcpus$link4 * sizeof(struct call_rcu_data *) /*8ul*/ );
      p$link4 = (struct call_rcu_data **)return_value_malloc$1$link4;
      if(!(p$link4 == ((struct call_rcu_data **)NULL)))
      {
        memset((void *)p$link4, 0, (unsigned long int)maxcpus$link4 * sizeof(struct call_rcu_data *) /*8ul*/ );
        do
        {
          struct call_rcu_data **_________pv$link4 = p$link4;
          asm("sfence" :  :  : "memory");
          struct call_rcu_data **_v$link4;
          *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link4))) = _________pv$link4;
          tmp_statement_expression$2$link4 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link4)));
          _v$link4 = tmp_statement_expression$2$link4;
          asm("" :  :  : "memory");
          _v$link4 = _v$link4;
        }
        while((_Bool)0);
      }

      else
      {
        static signed int warned$link4 = 0;
        if(warned$link4 == 0)
          fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

        warned$link4 = 1;
      }
    }

  }

}

// arena_alloc
// file urcu-bp.c line 423
static struct rcu_reader_bp * arena_alloc(struct registry_arena *arena)
{
  struct registry_chunk *chunk;
  struct rcu_reader_bp *rcu_reader_reg;
  signed int expand_done = 0;
  unsigned long int len = sizeof(struct rcu_reader_bp) /*40ul*/ ;
  do
  {

  retry:
    ;
    chunk = (struct registry_chunk *)((char *)(&arena->chunk_list)->next - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node);
    for( ; !(&chunk->node == &arena->chunk_list); chunk = (struct registry_chunk *)((char *)chunk->node.next - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node))
      if(chunk->data_len + -chunk->used >= len)
      {
        rcu_reader_reg = (struct rcu_reader_bp *)&chunk->data[(signed long int)0];
        for( ; !(rcu_reader_reg >= (struct rcu_reader_bp *)(chunk->data + (signed long int)chunk->data_len)); rcu_reader_reg = rcu_reader_reg + 1l)
          if(rcu_reader_reg->alloc == 0)
          {
            rcu_reader_reg->alloc = 1;
            chunk->used = chunk->used + len;
            return rcu_reader_reg;
          }

      }

    if(!(expand_done == 0))
      break;

    expand_arena(arena);
    expand_done = 1;
  }
  while((_Bool)1);
  return (struct rcu_reader_bp *)(void *)0;
}

// call_rcu_after_fork_child_bp
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_bp(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_data *next;
  call_rcu_unlock$link4(&call_rcu_mutex$link4);
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link4(&call_rcu_data_list$link4);
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$3;
  if(return_value_cds_list_empty$1 == 0)
  {
    default_call_rcu_data$link4 = (struct call_rcu_data *)(void *)0;
    get_default_call_rcu_data_bp();
    maxcpus_reset$link4();
    free((void *)per_cpu_call_rcu_data$link4);
    do
    {
      struct call_rcu_data **_________pv = (struct call_rcu_data **)(void *)0;
      struct call_rcu_data **_v;
      *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link4))) = _________pv;
      tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link4)));
      _v = tmp_statement_expression$2;
      asm("" :  :  : "memory");
      _v = _v;
    }
    while((_Bool)0);
    thread_call_rcu_data$link4 = (struct call_rcu_data *)(void *)0;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link4)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link4); next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      if(!(crdp == default_call_rcu_data$link4))
      {
        unsigned long int call_rcu_after_fork_child_bp$$1$$2$$1$$1$$_v;
        *((volatile unsigned long int *)&(*(&crdp->flags))) = (volatile unsigned long int)(1U << 3);
        tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        call_rcu_after_fork_child_bp$$1$$2$$1$$1$$_v = tmp_statement_expression$3;
        asm("" :  :  : "memory");
        call_rcu_after_fork_child_bp$$1$$2$$1$$1$$_v = call_rcu_after_fork_child_bp$$1$$2$$1$$1$$_v;
        call_rcu_data_free_bp(crdp);
      }

      crdp = next;
    }
  }

}

// call_rcu_after_fork_child_mb
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_mb(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_data *next;
  call_rcu_unlock$link1(&call_rcu_mutex$link1);
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link1(&call_rcu_data_list$link1);
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$3;
  if(return_value_cds_list_empty$1 == 0)
  {
    default_call_rcu_data$link1 = (struct call_rcu_data *)(void *)0;
    get_default_call_rcu_data_mb();
    maxcpus_reset$link1();
    free((void *)per_cpu_call_rcu_data$link1);
    do
    {
      struct call_rcu_data **_________pv = (struct call_rcu_data **)(void *)0;
      struct call_rcu_data **_v;
      *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link1))) = _________pv;
      tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link1)));
      _v = tmp_statement_expression$2;
      asm("" :  :  : "memory");
      _v = _v;
    }
    while((_Bool)0);
    thread_call_rcu_data$link1 = (struct call_rcu_data *)(void *)0;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link1)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link1); next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      if(!(crdp == default_call_rcu_data$link1))
      {
        unsigned long int call_rcu_after_fork_child_mb$$1$$2$$1$$1$$_v;
        *((volatile unsigned long int *)&(*(&crdp->flags))) = (volatile unsigned long int)(1U << 3);
        tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        call_rcu_after_fork_child_mb$$1$$2$$1$$1$$_v = tmp_statement_expression$3;
        asm("" :  :  : "memory");
        call_rcu_after_fork_child_mb$$1$$2$$1$$1$$_v = call_rcu_after_fork_child_mb$$1$$2$$1$$1$$_v;
        call_rcu_data_free_mb(crdp);
      }

      crdp = next;
    }
  }

}

// call_rcu_after_fork_child_memb
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_memb(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_data *next;
  call_rcu_unlock(&call_rcu_mutex);
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty(&call_rcu_data_list);
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$3;
  if(return_value_cds_list_empty$1 == 0)
  {
    default_call_rcu_data = (struct call_rcu_data *)(void *)0;
    get_default_call_rcu_data_memb();
    maxcpus_reset();
    free((void *)per_cpu_call_rcu_data);
    do
    {
      struct call_rcu_data **_________pv = (struct call_rcu_data **)(void *)0;
      struct call_rcu_data **_v;
      *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data))) = _________pv;
      tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data)));
      _v = tmp_statement_expression$2;
      asm("" :  :  : "memory");
      _v = _v;
    }
    while((_Bool)0);
    thread_call_rcu_data = (struct call_rcu_data *)(void *)0;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list); next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      if(!(crdp == default_call_rcu_data))
      {
        unsigned long int call_rcu_after_fork_child_memb$$1$$2$$1$$1$$_v;
        *((volatile unsigned long int *)&(*(&crdp->flags))) = (volatile unsigned long int)(1U << 3);
        tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        call_rcu_after_fork_child_memb$$1$$2$$1$$1$$_v = tmp_statement_expression$3;
        asm("" :  :  : "memory");
        call_rcu_after_fork_child_memb$$1$$2$$1$$1$$_v = call_rcu_after_fork_child_memb$$1$$2$$1$$1$$_v;
        call_rcu_data_free_memb(crdp);
      }

      crdp = next;
    }
  }

}

// call_rcu_after_fork_child_qsbr
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_qsbr(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_data *next;
  call_rcu_unlock$link3(&call_rcu_mutex$link3);
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link3(&call_rcu_data_list$link3);
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$3;
  if(return_value_cds_list_empty$1 == 0)
  {
    default_call_rcu_data$link3 = (struct call_rcu_data *)(void *)0;
    get_default_call_rcu_data_qsbr();
    maxcpus_reset$link3();
    free((void *)per_cpu_call_rcu_data$link3);
    do
    {
      struct call_rcu_data **_________pv = (struct call_rcu_data **)(void *)0;
      struct call_rcu_data **_v;
      *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link3))) = _________pv;
      tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link3)));
      _v = tmp_statement_expression$2;
      asm("" :  :  : "memory");
      _v = _v;
    }
    while((_Bool)0);
    thread_call_rcu_data$link3 = (struct call_rcu_data *)(void *)0;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link3)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link3); next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      if(!(crdp == default_call_rcu_data$link3))
      {
        unsigned long int call_rcu_after_fork_child_qsbr$$1$$2$$1$$1$$_v;
        *((volatile unsigned long int *)&(*(&crdp->flags))) = (volatile unsigned long int)(1U << 3);
        tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        call_rcu_after_fork_child_qsbr$$1$$2$$1$$1$$_v = tmp_statement_expression$3;
        asm("" :  :  : "memory");
        call_rcu_after_fork_child_qsbr$$1$$2$$1$$1$$_v = call_rcu_after_fork_child_qsbr$$1$$2$$1$$1$$_v;
        call_rcu_data_free_qsbr(crdp);
      }

      crdp = next;
    }
  }

}

// call_rcu_after_fork_child_sig
// file urcu-call-rcu-impl.h line 949
void call_rcu_after_fork_child_sig(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_data *next;
  call_rcu_unlock$link2(&call_rcu_mutex$link2);
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link2(&call_rcu_data_list$link2);
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$3;
  if(return_value_cds_list_empty$1 == 0)
  {
    default_call_rcu_data$link2 = (struct call_rcu_data *)(void *)0;
    get_default_call_rcu_data_sig();
    maxcpus_reset$link2();
    free((void *)per_cpu_call_rcu_data$link2);
    do
    {
      struct call_rcu_data **_________pv = (struct call_rcu_data **)(void *)0;
      struct call_rcu_data **_v;
      *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link2))) = _________pv;
      tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&(*(&per_cpu_call_rcu_data$link2)));
      _v = tmp_statement_expression$2;
      asm("" :  :  : "memory");
      _v = _v;
    }
    while((_Bool)0);
    thread_call_rcu_data$link2 = (struct call_rcu_data *)(void *)0;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link2)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link2); next = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      if(!(crdp == default_call_rcu_data$link2))
      {
        unsigned long int call_rcu_after_fork_child_sig$$1$$2$$1$$1$$_v;
        *((volatile unsigned long int *)&(*(&crdp->flags))) = (volatile unsigned long int)(1U << 3);
        tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        call_rcu_after_fork_child_sig$$1$$2$$1$$1$$_v = tmp_statement_expression$3;
        asm("" :  :  : "memory");
        call_rcu_after_fork_child_sig$$1$$2$$1$$1$$_v = call_rcu_after_fork_child_sig$$1$$2$$1$$1$$_v;
        call_rcu_data_free_sig(crdp);
      }

      crdp = next;
    }
  }

}

// call_rcu_after_fork_parent_bp
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_bp(void)
{
  struct call_rcu_data *crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link4)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list$link4); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    __uatomic_and$link4((void *)&crdp->flags, (unsigned long int)~(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link4)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list$link4); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if((32ul & tmp_statement_expression$1) == 0ul)
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
  call_rcu_unlock$link4(&call_rcu_mutex$link4);
}

// call_rcu_after_fork_parent_mb
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_mb(void)
{
  struct call_rcu_data *crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link1)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list$link1); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    __uatomic_and$link1((void *)&crdp->flags, (unsigned long int)~(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link1)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list$link1); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if((32ul & tmp_statement_expression$1) == 0ul)
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
  call_rcu_unlock$link1(&call_rcu_mutex$link1);
}

// call_rcu_after_fork_parent_memb
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_memb(void)
{
  struct call_rcu_data *crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    __uatomic_and((void *)&crdp->flags, (unsigned long int)~(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if((32ul & tmp_statement_expression$1) == 0ul)
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
  call_rcu_unlock(&call_rcu_mutex);
}

// call_rcu_after_fork_parent_qsbr
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_qsbr(void)
{
  struct call_rcu_data *crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link3)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list$link3); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    __uatomic_and$link3((void *)&crdp->flags, (unsigned long int)~(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link3)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list$link3); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if((32ul & tmp_statement_expression$1) == 0ul)
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
  call_rcu_unlock$link3(&call_rcu_mutex$link3);
}

// call_rcu_after_fork_parent_sig
// file urcu-call-rcu-impl.h line 931
void call_rcu_after_fork_parent_sig(void)
{
  struct call_rcu_data *crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link2)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list$link2); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    __uatomic_and$link2((void *)&crdp->flags, (unsigned long int)~(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link2)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list$link2); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if((32ul & tmp_statement_expression$1) == 0ul)
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
  call_rcu_unlock$link2(&call_rcu_mutex$link2);
}

// call_rcu_before_fork_bp
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_bp(void)
{
  struct call_rcu_data *crdp;
  call_rcu_lock$link4(&call_rcu_mutex$link4);
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link4)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list$link4); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
  {
    __uatomic_or$link4((void *)&crdp->flags, (unsigned long int)(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
    asm("" :  :  : "memory");
    wake_call_rcu_thread$link4(crdp);
  }
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link4)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list$link4); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if(!((32ul & tmp_statement_expression$1) == 0ul))
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
}

// call_rcu_before_fork_mb
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_mb(void)
{
  struct call_rcu_data *crdp;
  call_rcu_lock$link1(&call_rcu_mutex$link1);
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link1)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list$link1); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
  {
    __uatomic_or$link1((void *)&crdp->flags, (unsigned long int)(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
    asm("" :  :  : "memory");
    wake_call_rcu_thread$link1(crdp);
  }
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link1)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list$link1); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if(!((32ul & tmp_statement_expression$1) == 0ul))
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
}

// call_rcu_before_fork_memb
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_memb(void)
{
  struct call_rcu_data *crdp;
  call_rcu_lock(&call_rcu_mutex);
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
  {
    __uatomic_or((void *)&crdp->flags, (unsigned long int)(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
    asm("" :  :  : "memory");
    wake_call_rcu_thread(crdp);
  }
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if(!((32ul & tmp_statement_expression$1) == 0ul))
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
}

// call_rcu_before_fork_qsbr
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_qsbr(void)
{
  struct call_rcu_data *crdp;
  call_rcu_lock$link3(&call_rcu_mutex$link3);
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link3)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list$link3); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
  {
    __uatomic_or$link3((void *)&crdp->flags, (unsigned long int)(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
    asm("" :  :  : "memory");
    wake_call_rcu_thread$link3(crdp);
  }
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link3)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list$link3); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if(!((32ul & tmp_statement_expression$1) == 0ul))
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
}

// call_rcu_before_fork_sig
// file urcu-call-rcu-impl.h line 909
void call_rcu_before_fork_sig(void)
{
  struct call_rcu_data *crdp;
  call_rcu_lock$link2(&call_rcu_mutex$link2);
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link2)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  for( ; !(&crdp->list == &call_rcu_data_list$link2); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
  {
    __uatomic_or$link2((void *)&crdp->flags, (unsigned long int)(1U << 4), (signed int)sizeof(unsigned long int) /*8ul*/ );
    asm("" :  :  : "memory");
    wake_call_rcu_thread$link2(crdp);
  }
  crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link2)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&crdp->list == &call_rcu_data_list$link2); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    do
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
      if(!((32ul & tmp_statement_expression$1) == 0ul))
        break;

      poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
    }
    while((_Bool)1);
}

// call_rcu_bp
// file urcu-call-rcu-impl.h line 705
void call_rcu_bp(struct rcu_head *head, void (*func)(struct rcu_head *))
{
  struct call_rcu_data *crdp;
  _rcu_read_lock_bp();
  crdp=get_call_rcu_data_bp();
  _call_rcu$link4(head, func, crdp);
  _rcu_read_unlock_bp();
}

// call_rcu_completion_wait
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait(struct call_rcu_completion *completion)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile signed int *)&(*(&completion->futex)));
  signed int return_value_futex_async$2;
  if(tmp_statement_expression$1 == -1)
    do
    {
      return_value_futex_async$2=futex_async(&completion->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2 == 0)
        break;

      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      switch(*return_value___errno_location$3)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            char *return_value_strerror$5;
            return_value_strerror$5=strerror(*return_value___errno_location$4);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wait", 291, return_value_strerror$5);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_completion_wait$link1
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait$link1(struct call_rcu_completion *completion$link1)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&completion$link1->futex)));
  signed int return_value_futex_async$2$link1;
  if(tmp_statement_expression$1$link1 == -1)
    do
    {
      return_value_futex_async$2$link1=futex_async$link1(&completion$link1->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link1 == 0)
        break;

      signed int *return_value___errno_location$3$link1;
      return_value___errno_location$3$link1=__errno_location();
      switch(*return_value___errno_location$3$link1)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link1;
            return_value___errno_location$4$link1=__errno_location();
            char *return_value_strerror$5$link1;
            return_value_strerror$5$link1=strerror(*return_value___errno_location$4$link1);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wait", 291, return_value_strerror$5$link1);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_completion_wait$link2
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait$link2(struct call_rcu_completion *completion$link2)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&completion$link2->futex)));
  signed int return_value_futex_async$2$link2;
  if(tmp_statement_expression$1$link2 == -1)
    do
    {
      return_value_futex_async$2$link2=futex_async$link2(&completion$link2->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link2 == 0)
        break;

      signed int *return_value___errno_location$3$link2;
      return_value___errno_location$3$link2=__errno_location();
      switch(*return_value___errno_location$3$link2)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link2;
            return_value___errno_location$4$link2=__errno_location();
            char *return_value_strerror$5$link2;
            return_value_strerror$5$link2=strerror(*return_value___errno_location$4$link2);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wait", 291, return_value_strerror$5$link2);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_completion_wait$link3
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait$link3(struct call_rcu_completion *completion$link3)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&completion$link3->futex)));
  signed int return_value_futex_async$2$link3;
  if(tmp_statement_expression$1$link3 == -1)
    do
    {
      return_value_futex_async$2$link3=futex_async$link3(&completion$link3->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link3 == 0)
        break;

      signed int *return_value___errno_location$3$link3;
      return_value___errno_location$3$link3=__errno_location();
      switch(*return_value___errno_location$3$link3)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link3;
            return_value___errno_location$4$link3=__errno_location();
            char *return_value_strerror$5$link3;
            return_value_strerror$5$link3=strerror(*return_value___errno_location$4$link3);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wait", 291, return_value_strerror$5$link3);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_completion_wait$link4
// file urcu-call-rcu-impl.h line 274
static void call_rcu_completion_wait$link4(struct call_rcu_completion *completion$link4)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link4 = *((volatile signed int *)&(*(&completion$link4->futex)));
  signed int return_value_futex_async$2$link4;
  if(tmp_statement_expression$1$link4 == -1)
    do
    {
      return_value_futex_async$2$link4=futex_async$link4(&completion$link4->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link4 == 0)
        break;

      signed int *return_value___errno_location$3$link4;
      return_value___errno_location$3$link4=__errno_location();
      switch(*return_value___errno_location$3$link4)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link4;
            return_value___errno_location$4$link4=__errno_location();
            char *return_value_strerror$5$link4;
            return_value_strerror$5$link4=strerror(*return_value___errno_location$4$link4);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wait", 291, return_value_strerror$5$link4);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_completion_wake_up
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up(struct call_rcu_completion *completion)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5;
  asm("" :  :  : "memory");
  tmp_statement_expression$5 = *((volatile signed int *)&(*(&completion->futex)));
  volatile signed int tmp_statement_expression$1;
  if(tmp_statement_expression$5 == -1)
  {
    signed int _v;
    *((volatile signed int *)&(*(&completion->futex))) = 0;
    tmp_statement_expression$1 = *((volatile signed int *)&(*(&completion->futex)));
    _v = tmp_statement_expression$1;
    asm("" :  :  : "memory");
    _v = _v;
    signed int return_value_futex_async$4;
    return_value_futex_async$4=futex_async(&completion->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4 >= 0))
      do
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wake_up", 304, return_value_strerror$3);
        abort();
      }
      while((_Bool)0);

  }

}

// call_rcu_completion_wake_up$link1
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up$link1(struct call_rcu_completion *completion$link1)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link1 = *((volatile signed int *)&(*(&completion$link1->futex)));
  volatile signed int tmp_statement_expression$1$link1;
  if(tmp_statement_expression$5$link1 == -1)
  {
    signed int _v$link1;
    *((volatile signed int *)&(*(&completion$link1->futex))) = 0;
    tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&completion$link1->futex)));
    _v$link1 = tmp_statement_expression$1$link1;
    asm("" :  :  : "memory");
    _v$link1 = _v$link1;
    signed int return_value_futex_async$4$link1;
    return_value_futex_async$4$link1=futex_async$link1(&completion$link1->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4$link1 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link1;
        return_value___errno_location$2$link1=__errno_location();
        char *return_value_strerror$3$link1;
        return_value_strerror$3$link1=strerror(*return_value___errno_location$2$link1);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wake_up", 304, return_value_strerror$3$link1);
        abort();
      }
      while((_Bool)0);

  }

}

// call_rcu_completion_wake_up$link2
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up$link2(struct call_rcu_completion *completion$link2)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link2 = *((volatile signed int *)&(*(&completion$link2->futex)));
  volatile signed int tmp_statement_expression$1$link2;
  if(tmp_statement_expression$5$link2 == -1)
  {
    signed int _v$link2;
    *((volatile signed int *)&(*(&completion$link2->futex))) = 0;
    tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&completion$link2->futex)));
    _v$link2 = tmp_statement_expression$1$link2;
    asm("" :  :  : "memory");
    _v$link2 = _v$link2;
    signed int return_value_futex_async$4$link2;
    return_value_futex_async$4$link2=futex_async$link2(&completion$link2->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4$link2 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link2;
        return_value___errno_location$2$link2=__errno_location();
        char *return_value_strerror$3$link2;
        return_value_strerror$3$link2=strerror(*return_value___errno_location$2$link2);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wake_up", 304, return_value_strerror$3$link2);
        abort();
      }
      while((_Bool)0);

  }

}

// call_rcu_completion_wake_up$link3
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up$link3(struct call_rcu_completion *completion$link3)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link3 = *((volatile signed int *)&(*(&completion$link3->futex)));
  volatile signed int tmp_statement_expression$1$link3;
  if(tmp_statement_expression$5$link3 == -1)
  {
    signed int _v$link3;
    *((volatile signed int *)&(*(&completion$link3->futex))) = 0;
    tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&completion$link3->futex)));
    _v$link3 = tmp_statement_expression$1$link3;
    asm("" :  :  : "memory");
    _v$link3 = _v$link3;
    signed int return_value_futex_async$4$link3;
    return_value_futex_async$4$link3=futex_async$link3(&completion$link3->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4$link3 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link3;
        return_value___errno_location$2$link3=__errno_location();
        char *return_value_strerror$3$link3;
        return_value_strerror$3$link3=strerror(*return_value___errno_location$2$link3);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wake_up", 304, return_value_strerror$3$link3);
        abort();
      }
      while((_Bool)0);

  }

}

// call_rcu_completion_wake_up$link4
// file urcu-call-rcu-impl.h line 296
static void call_rcu_completion_wake_up$link4(struct call_rcu_completion *completion$link4)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link4 = *((volatile signed int *)&(*(&completion$link4->futex)));
  volatile signed int tmp_statement_expression$1$link4;
  if(tmp_statement_expression$5$link4 == -1)
  {
    signed int _v$link4;
    *((volatile signed int *)&(*(&completion$link4->futex))) = 0;
    tmp_statement_expression$1$link4 = *((volatile signed int *)&(*(&completion$link4->futex)));
    _v$link4 = tmp_statement_expression$1$link4;
    asm("" :  :  : "memory");
    _v$link4 = _v$link4;
    signed int return_value_futex_async$4$link4;
    return_value_futex_async$4$link4=futex_async$link4(&completion$link4->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4$link4 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link4;
        return_value___errno_location$2$link4=__errno_location();
        char *return_value_strerror$3$link4;
        return_value_strerror$3$link4=strerror(*return_value___errno_location$2$link4);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_completion_wake_up", 304, return_value_strerror$3$link4);
        abort();
      }
      while((_Bool)0);

  }

}

// call_rcu_data_free_bp
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_bp(struct call_rcu_data *crdp)
{
  volatile unsigned long int tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$1;
  volatile unsigned long int tmp_statement_expression$3;
  if(!(crdp == ((struct call_rcu_data *)NULL)) && !(crdp == default_call_rcu_data$link4))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((volatile unsigned long int *)&(*(&crdp->flags)));
    if((8ul & tmp_statement_expression$2) == 0ul)
    {
      __uatomic_or$link4((void *)&crdp->flags, (unsigned long int)(1U << 2), (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread$link4(crdp);
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        if(!((8ul & tmp_statement_expression$1) == 0ul))
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
    }

    _Bool return_value__cds_wfcq_empty$4;
    return_value__cds_wfcq_empty$4=_cds_wfcq_empty$link5(&crdp->cbs_head, &crdp->cbs_tail);
    if(return_value__cds_wfcq_empty$4 == (_Bool)0)
    {
      get_default_call_rcu_data_bp();
      ___cds_wfcq_splice_blocking$link5(&default_call_rcu_data$link4->cbs_head, &default_call_rcu_data$link4->cbs_tail, &crdp->cbs_head, &crdp->cbs_tail);
      asm("" :  :  : "memory");
      tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->qlen)));
      __uatomic_add$link4((void *)&default_call_rcu_data$link4->qlen, (unsigned long int)tmp_statement_expression$3, (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread$link4(default_call_rcu_data$link4);
    }

    call_rcu_lock$link4(&call_rcu_mutex$link4);
    cds_list_del$link4(&crdp->list);
    call_rcu_unlock$link4(&call_rcu_mutex$link4);
    free((void *)crdp);
  }

}

// call_rcu_data_free_mb
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_mb(struct call_rcu_data *crdp)
{
  volatile unsigned long int tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$1;
  volatile unsigned long int tmp_statement_expression$3;
  if(!(crdp == ((struct call_rcu_data *)NULL)) && !(crdp == default_call_rcu_data$link1))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((volatile unsigned long int *)&(*(&crdp->flags)));
    if((8ul & tmp_statement_expression$2) == 0ul)
    {
      __uatomic_or$link1((void *)&crdp->flags, (unsigned long int)(1U << 2), (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread$link1(crdp);
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        if(!((8ul & tmp_statement_expression$1) == 0ul))
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
    }

    _Bool return_value__cds_wfcq_empty$4;
    return_value__cds_wfcq_empty$4=_cds_wfcq_empty$link2(&crdp->cbs_head, &crdp->cbs_tail);
    if(return_value__cds_wfcq_empty$4 == (_Bool)0)
    {
      get_default_call_rcu_data_mb();
      ___cds_wfcq_splice_blocking$link2(&default_call_rcu_data$link1->cbs_head, &default_call_rcu_data$link1->cbs_tail, &crdp->cbs_head, &crdp->cbs_tail);
      asm("" :  :  : "memory");
      tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->qlen)));
      __uatomic_add$link1((void *)&default_call_rcu_data$link1->qlen, (unsigned long int)tmp_statement_expression$3, (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread$link1(default_call_rcu_data$link1);
    }

    call_rcu_lock$link1(&call_rcu_mutex$link1);
    cds_list_del$link1(&crdp->list);
    call_rcu_unlock$link1(&call_rcu_mutex$link1);
    free((void *)crdp);
  }

}

// call_rcu_data_free_memb
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_memb(struct call_rcu_data *crdp)
{
  volatile unsigned long int tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$1;
  volatile unsigned long int tmp_statement_expression$3;
  if(!(crdp == ((struct call_rcu_data *)NULL)) && !(crdp == default_call_rcu_data))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((volatile unsigned long int *)&(*(&crdp->flags)));
    if((8ul & tmp_statement_expression$2) == 0ul)
    {
      __uatomic_or((void *)&crdp->flags, (unsigned long int)(1U << 2), (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread(crdp);
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        if(!((8ul & tmp_statement_expression$1) == 0ul))
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
    }

    _Bool return_value__cds_wfcq_empty$4;
    return_value__cds_wfcq_empty$4=_cds_wfcq_empty(&crdp->cbs_head, &crdp->cbs_tail);
    if(return_value__cds_wfcq_empty$4 == (_Bool)0)
    {
      get_default_call_rcu_data_memb();
      ___cds_wfcq_splice_blocking(&default_call_rcu_data->cbs_head, &default_call_rcu_data->cbs_tail, &crdp->cbs_head, &crdp->cbs_tail);
      asm("" :  :  : "memory");
      tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->qlen)));
      __uatomic_add((void *)&default_call_rcu_data->qlen, (unsigned long int)tmp_statement_expression$3, (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread(default_call_rcu_data);
    }

    call_rcu_lock(&call_rcu_mutex);
    cds_list_del(&crdp->list);
    call_rcu_unlock(&call_rcu_mutex);
    free((void *)crdp);
  }

}

// call_rcu_data_free_qsbr
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_qsbr(struct call_rcu_data *crdp)
{
  volatile unsigned long int tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$1;
  volatile unsigned long int tmp_statement_expression$3;
  if(!(crdp == ((struct call_rcu_data *)NULL)) && !(crdp == default_call_rcu_data$link3))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((volatile unsigned long int *)&(*(&crdp->flags)));
    if((8ul & tmp_statement_expression$2) == 0ul)
    {
      __uatomic_or$link3((void *)&crdp->flags, (unsigned long int)(1U << 2), (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread$link3(crdp);
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        if(!((8ul & tmp_statement_expression$1) == 0ul))
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
    }

    _Bool return_value__cds_wfcq_empty$4;
    return_value__cds_wfcq_empty$4=_cds_wfcq_empty$link4(&crdp->cbs_head, &crdp->cbs_tail);
    if(return_value__cds_wfcq_empty$4 == (_Bool)0)
    {
      get_default_call_rcu_data_qsbr();
      ___cds_wfcq_splice_blocking$link4(&default_call_rcu_data$link3->cbs_head, &default_call_rcu_data$link3->cbs_tail, &crdp->cbs_head, &crdp->cbs_tail);
      asm("" :  :  : "memory");
      tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->qlen)));
      __uatomic_add$link3((void *)&default_call_rcu_data$link3->qlen, (unsigned long int)tmp_statement_expression$3, (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread$link3(default_call_rcu_data$link3);
    }

    call_rcu_lock$link3(&call_rcu_mutex$link3);
    cds_list_del$link3(&crdp->list);
    call_rcu_unlock$link3(&call_rcu_mutex$link3);
    free((void *)crdp);
  }

}

// call_rcu_data_free_sig
// file urcu-call-rcu-impl.h line 743
void call_rcu_data_free_sig(struct call_rcu_data *crdp)
{
  volatile unsigned long int tmp_statement_expression$2;
  volatile unsigned long int tmp_statement_expression$1;
  volatile unsigned long int tmp_statement_expression$3;
  if(!(crdp == ((struct call_rcu_data *)NULL)) && !(crdp == default_call_rcu_data$link2))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((volatile unsigned long int *)&(*(&crdp->flags)));
    if((8ul & tmp_statement_expression$2) == 0ul)
    {
      __uatomic_or$link2((void *)&crdp->flags, (unsigned long int)(1U << 2), (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread$link2(crdp);
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        if(!((8ul & tmp_statement_expression$1) == 0ul))
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
    }

    _Bool return_value__cds_wfcq_empty$4;
    return_value__cds_wfcq_empty$4=_cds_wfcq_empty$link3(&crdp->cbs_head, &crdp->cbs_tail);
    if(return_value__cds_wfcq_empty$4 == (_Bool)0)
    {
      get_default_call_rcu_data_sig();
      ___cds_wfcq_splice_blocking$link3(&default_call_rcu_data$link2->cbs_head, &default_call_rcu_data$link2->cbs_tail, &crdp->cbs_head, &crdp->cbs_tail);
      asm("" :  :  : "memory");
      tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&crdp->qlen)));
      __uatomic_add$link2((void *)&default_call_rcu_data$link2->qlen, (unsigned long int)tmp_statement_expression$3, (signed int)sizeof(unsigned long int) /*8ul*/ );
      wake_call_rcu_thread$link2(default_call_rcu_data$link2);
    }

    call_rcu_lock$link2(&call_rcu_mutex$link2);
    cds_list_del$link2(&crdp->list);
    call_rcu_unlock$link2(&call_rcu_mutex$link2);
    free((void *)crdp);
  }

}

// call_rcu_data_init
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init(struct call_rcu_data **crdpp, unsigned long int flags, signed int cpu_affinity)
{
  struct call_rcu_data *crdp;
  signed int ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct call_rcu_data) /*128ul*/ );
  crdp = (struct call_rcu_data *)return_value_malloc$1;
  if(crdp == ((struct call_rcu_data *)NULL))
    do
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 424, return_value_strerror$3);
      abort();
    }
    while((_Bool)0);

  memset((void *)crdp, 0, sizeof(struct call_rcu_data) /*128ul*/ );
  _cds_wfcq_init(&crdp->cbs_head, &crdp->cbs_tail);
  crdp->qlen = (unsigned long int)0;
  crdp->futex = 0;
  crdp->flags = flags;
  cds_list_add(&crdp->list, &call_rcu_data_list);
  crdp->cpu_affinity = cpu_affinity;
  crdp->gp_count = (unsigned long int)0;
  asm("mfence" :  :  : "memory");
  *crdpp = crdp;
  ret=pthread_create(&crdp->tid, (const union pthread_attr_t *)(void *)0, call_rcu_thread, (void *)crdp);
  if(!(ret == 0))
    do
    {
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(ret);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 437, return_value_strerror$4);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_data_init$link1
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init$link1(struct call_rcu_data **crdpp$link1, unsigned long int flags$link1, signed int cpu_affinity$link1)
{
  struct call_rcu_data *crdp$link1;
  signed int ret$link1;
  void *return_value_malloc$1$link1;
  return_value_malloc$1$link1=malloc(sizeof(struct call_rcu_data) /*128ul*/ );
  crdp$link1 = (struct call_rcu_data *)return_value_malloc$1$link1;
  if(crdp$link1 == ((struct call_rcu_data *)NULL))
    do
    {
      signed int *return_value___errno_location$2$link1;
      return_value___errno_location$2$link1=__errno_location();
      char *return_value_strerror$3$link1;
      return_value_strerror$3$link1=strerror(*return_value___errno_location$2$link1);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 424, return_value_strerror$3$link1);
      abort();
    }
    while((_Bool)0);

  memset((void *)crdp$link1, 0, sizeof(struct call_rcu_data) /*128ul*/ );
  _cds_wfcq_init$link2(&crdp$link1->cbs_head, &crdp$link1->cbs_tail);
  crdp$link1->qlen = (unsigned long int)0;
  crdp$link1->futex = 0;
  crdp$link1->flags = flags$link1;
  cds_list_add$link1(&crdp$link1->list, &call_rcu_data_list$link1);
  crdp$link1->cpu_affinity = cpu_affinity$link1;
  crdp$link1->gp_count = (unsigned long int)0;
  asm("mfence" :  :  : "memory");
  *crdpp$link1 = crdp$link1;
  ret$link1=pthread_create(&crdp$link1->tid, (const union pthread_attr_t *)(void *)0, call_rcu_thread$link1, (void *)crdp$link1);
  if(!(ret$link1 == 0))
    do
    {
      char *return_value_strerror$4$link1;
      return_value_strerror$4$link1=strerror(ret$link1);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 437, return_value_strerror$4$link1);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_data_init$link2
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init$link2(struct call_rcu_data **crdpp$link2, unsigned long int flags$link2, signed int cpu_affinity$link2)
{
  struct call_rcu_data *crdp$link2;
  signed int ret$link2;
  void *return_value_malloc$1$link2;
  return_value_malloc$1$link2=malloc(sizeof(struct call_rcu_data) /*128ul*/ );
  crdp$link2 = (struct call_rcu_data *)return_value_malloc$1$link2;
  if(crdp$link2 == ((struct call_rcu_data *)NULL))
    do
    {
      signed int *return_value___errno_location$2$link2;
      return_value___errno_location$2$link2=__errno_location();
      char *return_value_strerror$3$link2;
      return_value_strerror$3$link2=strerror(*return_value___errno_location$2$link2);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 424, return_value_strerror$3$link2);
      abort();
    }
    while((_Bool)0);

  memset((void *)crdp$link2, 0, sizeof(struct call_rcu_data) /*128ul*/ );
  _cds_wfcq_init$link3(&crdp$link2->cbs_head, &crdp$link2->cbs_tail);
  crdp$link2->qlen = (unsigned long int)0;
  crdp$link2->futex = 0;
  crdp$link2->flags = flags$link2;
  cds_list_add$link2(&crdp$link2->list, &call_rcu_data_list$link2);
  crdp$link2->cpu_affinity = cpu_affinity$link2;
  crdp$link2->gp_count = (unsigned long int)0;
  asm("mfence" :  :  : "memory");
  *crdpp$link2 = crdp$link2;
  ret$link2=pthread_create(&crdp$link2->tid, (const union pthread_attr_t *)(void *)0, call_rcu_thread$link2, (void *)crdp$link2);
  if(!(ret$link2 == 0))
    do
    {
      char *return_value_strerror$4$link2;
      return_value_strerror$4$link2=strerror(ret$link2);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 437, return_value_strerror$4$link2);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_data_init$link3
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init$link3(struct call_rcu_data **crdpp$link3, unsigned long int flags$link3, signed int cpu_affinity$link3)
{
  struct call_rcu_data *crdp$link3;
  signed int ret$link3;
  void *return_value_malloc$1$link3;
  return_value_malloc$1$link3=malloc(sizeof(struct call_rcu_data) /*128ul*/ );
  crdp$link3 = (struct call_rcu_data *)return_value_malloc$1$link3;
  if(crdp$link3 == ((struct call_rcu_data *)NULL))
    do
    {
      signed int *return_value___errno_location$2$link3;
      return_value___errno_location$2$link3=__errno_location();
      char *return_value_strerror$3$link3;
      return_value_strerror$3$link3=strerror(*return_value___errno_location$2$link3);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 424, return_value_strerror$3$link3);
      abort();
    }
    while((_Bool)0);

  memset((void *)crdp$link3, 0, sizeof(struct call_rcu_data) /*128ul*/ );
  _cds_wfcq_init$link4(&crdp$link3->cbs_head, &crdp$link3->cbs_tail);
  crdp$link3->qlen = (unsigned long int)0;
  crdp$link3->futex = 0;
  crdp$link3->flags = flags$link3;
  cds_list_add$link3(&crdp$link3->list, &call_rcu_data_list$link3);
  crdp$link3->cpu_affinity = cpu_affinity$link3;
  crdp$link3->gp_count = (unsigned long int)0;
  asm("mfence" :  :  : "memory");
  *crdpp$link3 = crdp$link3;
  ret$link3=pthread_create(&crdp$link3->tid, (const union pthread_attr_t *)(void *)0, call_rcu_thread$link3, (void *)crdp$link3);
  if(!(ret$link3 == 0))
    do
    {
      char *return_value_strerror$4$link3;
      return_value_strerror$4$link3=strerror(ret$link3);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 437, return_value_strerror$4$link3);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_data_init$link4
// file urcu-call-rcu-impl.h line 415
static void call_rcu_data_init$link4(struct call_rcu_data **crdpp$link4, unsigned long int flags$link4, signed int cpu_affinity$link4)
{
  struct call_rcu_data *crdp$link4;
  signed int ret$link4;
  void *return_value_malloc$1$link4;
  return_value_malloc$1$link4=malloc(sizeof(struct call_rcu_data) /*128ul*/ );
  crdp$link4 = (struct call_rcu_data *)return_value_malloc$1$link4;
  if(crdp$link4 == ((struct call_rcu_data *)NULL))
    do
    {
      signed int *return_value___errno_location$2$link4;
      return_value___errno_location$2$link4=__errno_location();
      char *return_value_strerror$3$link4;
      return_value_strerror$3$link4=strerror(*return_value___errno_location$2$link4);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 424, return_value_strerror$3$link4);
      abort();
    }
    while((_Bool)0);

  memset((void *)crdp$link4, 0, sizeof(struct call_rcu_data) /*128ul*/ );
  _cds_wfcq_init$link5(&crdp$link4->cbs_head, &crdp$link4->cbs_tail);
  crdp$link4->qlen = (unsigned long int)0;
  crdp$link4->futex = 0;
  crdp$link4->flags = flags$link4;
  cds_list_add$link4(&crdp$link4->list, &call_rcu_data_list$link4);
  crdp$link4->cpu_affinity = cpu_affinity$link4;
  crdp$link4->gp_count = (unsigned long int)0;
  asm("mfence" :  :  : "memory");
  *crdpp$link4 = crdp$link4;
  ret$link4=pthread_create(&crdp$link4->tid, (const union pthread_attr_t *)(void *)0, call_rcu_thread$link4, (void *)crdp$link4);
  if(!(ret$link4 == 0))
    do
    {
      char *return_value_strerror$4$link4;
      return_value_strerror$4$link4=strerror(ret$link4);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_data_init", 437, return_value_strerror$4$link4);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_lock
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock(union anonymous$0 *pmp)
{
  signed int ret;
  ret=pthread_mutex_lock(pmp);
  if(!(ret == 0))
    do
    {
      char *return_value_strerror$1;
      return_value_strerror$1=strerror(ret);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_lock", 181, return_value_strerror$1);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_lock$link1
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock$link1(union anonymous$0 *pmp$link1)
{
  signed int ret$link1;
  ret$link1=pthread_mutex_lock(pmp$link1);
  if(!(ret$link1 == 0))
    do
    {
      char *return_value_strerror$1$link1;
      return_value_strerror$1$link1=strerror(ret$link1);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_lock", 181, return_value_strerror$1$link1);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_lock$link2
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock$link2(union anonymous$0 *pmp$link2)
{
  signed int ret$link2;
  ret$link2=pthread_mutex_lock(pmp$link2);
  if(!(ret$link2 == 0))
    do
    {
      char *return_value_strerror$1$link2;
      return_value_strerror$1$link2=strerror(ret$link2);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_lock", 181, return_value_strerror$1$link2);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_lock$link3
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock$link3(union anonymous$0 *pmp$link3)
{
  signed int ret$link3;
  ret$link3=pthread_mutex_lock(pmp$link3);
  if(!(ret$link3 == 0))
    do
    {
      char *return_value_strerror$1$link3;
      return_value_strerror$1$link3=strerror(ret$link3);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_lock", 181, return_value_strerror$1$link3);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_lock$link4
// file urcu-call-rcu-impl.h line 175
static void call_rcu_lock$link4(union anonymous$0 *pmp$link4)
{
  signed int ret$link4;
  ret$link4=pthread_mutex_lock(pmp$link4);
  if(!(ret$link4 == 0))
    do
    {
      char *return_value_strerror$1$link4;
      return_value_strerror$1$link4=strerror(ret$link4);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_lock", 181, return_value_strerror$1$link4);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_mb
// file urcu-call-rcu-impl.h line 705
void call_rcu_mb(struct rcu_head *head, void (*func)(struct rcu_head *))
{
  struct call_rcu_data *crdp;
  _rcu_read_lock_mb();
  crdp=get_call_rcu_data_mb();
  _call_rcu$link1(head, func, crdp);
  _rcu_read_unlock_mb();
}

// call_rcu_memb
// file urcu-call-rcu-impl.h line 705
void call_rcu_memb(struct rcu_head *head, void (*func)(struct rcu_head *))
{
  struct call_rcu_data *crdp;
  _rcu_read_lock_memb();
  crdp=get_call_rcu_data_memb();
  _call_rcu(head, func, crdp);
  _rcu_read_unlock_memb();
}

// call_rcu_qsbr
// file urcu-call-rcu-impl.h line 705
void call_rcu_qsbr(struct rcu_head *head, void (*func)(struct rcu_head *))
{
  struct call_rcu_data *crdp;
  _rcu_read_lock_qsbr();
  crdp=get_call_rcu_data_qsbr();
  _call_rcu$link3(head, func, crdp);
  _rcu_read_unlock_qsbr();
}

// call_rcu_sig
// file urcu-call-rcu-impl.h line 705
void call_rcu_sig(struct rcu_head *head, void (*func)(struct rcu_head *))
{
  struct call_rcu_data *crdp;
  _rcu_read_lock_sig();
  crdp=get_call_rcu_data_sig();
  _call_rcu$link2(head, func, crdp);
  _rcu_read_unlock_sig();
}

// call_rcu_thread
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread(void *arg)
{
  unsigned long int cbcount;
  struct call_rcu_data *crdp = (struct call_rcu_data *)arg;
  signed int rt;
  volatile unsigned long int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&crdp->flags)));
  rt = (signed int)!(!((tmp_statement_expression$1 & (unsigned long int)(1U << 0)) != 0ul));
  signed int return_value_set_thread_cpu_affinity$4;
  return_value_set_thread_cpu_affinity$4=set_thread_cpu_affinity(crdp);
  if(!(return_value_set_thread_cpu_affinity$4 == 0))
    do
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 317, return_value_strerror$3);
      abort();
    }
    while((_Bool)0);

  rcu_register_thread_memb();
  thread_call_rcu_data = crdp;
  if(rt == 0)
  {
    __uatomic_dec((void *)&crdp->futex, (signed int)sizeof(signed int) /*4ul*/ );
    asm("mfence" :  :  : "memory");
  }

  volatile unsigned long int tmp_statement_expression$9;
  volatile unsigned long int tmp_statement_expression$8;
  struct cds_wfcq_node *tmp_if_expr$11;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$10;
  struct rcu_head *tmp_statement_expression$14;
  struct cds_wfcq_node *tmp_if_expr$13;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$12;
  volatile unsigned long int tmp_statement_expression$15;
  do
  {
    struct cds_wfcq_head cbs_tmp_head;
    struct cds_wfcq_tail cbs_tmp_tail;
    struct cds_wfcq_node *cbs;
    struct cds_wfcq_node *cbs_tmp_n;
    enum cds_wfcq_ret splice_ret;
    signed int return_value_set_thread_cpu_affinity$7;
    return_value_set_thread_cpu_affinity$7=set_thread_cpu_affinity(crdp);
    if(!(return_value_set_thread_cpu_affinity$7 == 0))
      do
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 337, return_value_strerror$6);
        abort();
      }
      while((_Bool)0);

    asm("" :  :  : "memory");
    tmp_statement_expression$9 = *((volatile unsigned long int *)&(*(&crdp->flags)));
    if(!((16ul & tmp_statement_expression$9) == 0ul))
    {
      rcu_unregister_thread_memb();
      asm("" :  :  : "memory");
      __uatomic_or((void *)&crdp->flags, (unsigned long int)(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$8 = *((volatile unsigned long int *)&(*(&crdp->flags)));
        if((16ul & tmp_statement_expression$8) == 0ul)
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
      __uatomic_and((void *)&crdp->flags, (unsigned long int)~(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      asm("" :  :  : "memory");
      rcu_register_thread_memb();
    }

    _cds_wfcq_init(&cbs_tmp_head, &cbs_tmp_tail);
    splice_ret=___cds_wfcq_splice_blocking(&cbs_tmp_head, &cbs_tmp_tail, &crdp->cbs_head, &crdp->cbs_tail);
    /* assertion splice_ret != CDS_WFCQ_RET_WOULDBLOCK */
    assert((signed int)splice_ret != CDS_WFCQ_RET_WOULDBLOCK);
    /* assertion splice_ret != CDS_WFCQ_RET_DEST_NON_EMPTY */
    assert((signed int)splice_ret != CDS_WFCQ_RET_DEST_NON_EMPTY);
    if(!((signed int)splice_ret == CDS_WFCQ_RET_SRC_EMPTY))
    {
      synchronize_rcu_memb();
      cbcount = (unsigned long int)0;
      cbs=___cds_wfcq_first_blocking(&cbs_tmp_head, &cbs_tmp_tail);
      if(!(cbs == ((struct cds_wfcq_node *)NULL)))
      {
        return_value____cds_wfcq_next_blocking$10=___cds_wfcq_next_blocking(&cbs_tmp_head, &cbs_tmp_tail, cbs);
        tmp_if_expr$11 = return_value____cds_wfcq_next_blocking$10;
      }

      else
        tmp_if_expr$11 = (struct cds_wfcq_node *)(void *)0;
      cbs_tmp_n = tmp_if_expr$11;
      if(!(cbs == ((struct cds_wfcq_node *)NULL)))
      {
        struct rcu_head *rhp;
        const struct cds_wfcq_node *__ptr = cbs;
        tmp_statement_expression$14 = (struct rcu_head *)((char *)__ptr - (signed long int)0ul);
        rhp = tmp_statement_expression$14;
        rhp->func(rhp);
        cbcount = cbcount + 1ul;
        cbs = cbs_tmp_n;
        if(!(cbs == ((struct cds_wfcq_node *)NULL)))
        {
          return_value____cds_wfcq_next_blocking$12=___cds_wfcq_next_blocking(&cbs_tmp_head, &cbs_tmp_tail, cbs);
          tmp_if_expr$13 = return_value____cds_wfcq_next_blocking$12;
        }

        else
          tmp_if_expr$13 = (struct cds_wfcq_node *)(void *)0;
        cbs_tmp_n = tmp_if_expr$13;
      }

      __uatomic_add((void *)&crdp->qlen, (unsigned long int)-((unsigned long int)cbcount), (signed int)sizeof(unsigned long int) /*8ul*/ );
    }

    asm("" :  :  : "memory");
    tmp_statement_expression$15 = *((volatile unsigned long int *)&(*(&crdp->flags)));
    if(!((4ul & tmp_statement_expression$15) == 0ul))
      break;

    rcu_thread_offline();
    if(rt == 0)
    {
      _Bool return_value__cds_wfcq_empty$16;
      return_value__cds_wfcq_empty$16=_cds_wfcq_empty(&crdp->cbs_head, &crdp->cbs_tail);
      if(!(return_value__cds_wfcq_empty$16 == (_Bool)0))
      {
        call_rcu_wait(crdp);
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
        __uatomic_dec((void *)&crdp->futex, (signed int)sizeof(signed int) /*4ul*/ );
        asm("mfence" :  :  : "memory");
      }

      else
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    }

    else
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    rcu_thread_online();
  }
  while((_Bool)1);
  volatile signed int tmp_statement_expression$17;
  if(rt == 0)
  {
    asm("mfence" :  :  : "memory");
    signed int _v;
    *((volatile signed int *)&(*(&crdp->futex))) = 0;
    tmp_statement_expression$17 = *((volatile signed int *)&(*(&crdp->futex)));
    _v = tmp_statement_expression$17;
    asm("" :  :  : "memory");
    _v = _v;
  }

  __uatomic_or((void *)&crdp->flags, (unsigned long int)(1U << 3), (signed int)sizeof(unsigned long int) /*8ul*/ );
  rcu_unregister_thread_memb();
  return (void *)0;
}

// call_rcu_thread$link1
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread$link1(void *arg$link1)
{
  unsigned long int cbcount$link1;
  struct call_rcu_data *crdp$link1 = (struct call_rcu_data *)arg$link1;
  signed int rt$link1;
  volatile unsigned long int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile unsigned long int *)&(*(&crdp$link1->flags)));
  rt$link1 = (signed int)!(!((tmp_statement_expression$1$link1 & (unsigned long int)(1U << 0)) != 0ul));
  signed int return_value_set_thread_cpu_affinity$4$link1;
  return_value_set_thread_cpu_affinity$4$link1=set_thread_cpu_affinity$link1(crdp$link1);
  if(!(return_value_set_thread_cpu_affinity$4$link1 == 0))
    do
    {
      signed int *return_value___errno_location$2$link1;
      return_value___errno_location$2$link1=__errno_location();
      char *return_value_strerror$3$link1;
      return_value_strerror$3$link1=strerror(*return_value___errno_location$2$link1);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 317, return_value_strerror$3$link1);
      abort();
    }
    while((_Bool)0);

  rcu_register_thread_mb();
  thread_call_rcu_data$link1 = crdp$link1;
  if(rt$link1 == 0)
  {
    __uatomic_dec$link1((void *)&crdp$link1->futex, (signed int)sizeof(signed int) /*4ul*/ );
    asm("mfence" :  :  : "memory");
  }

  volatile unsigned long int tmp_statement_expression$9$link1;
  volatile unsigned long int tmp_statement_expression$8$link1;
  struct cds_wfcq_node *tmp_if_expr$11$link1;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$10$link1;
  struct rcu_head *tmp_statement_expression$14$link1;
  struct cds_wfcq_node *tmp_if_expr$13$link1;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$12$link1;
  volatile unsigned long int tmp_statement_expression$15$link1;
  do
  {
    struct cds_wfcq_head cbs_tmp_head$link1;
    struct cds_wfcq_tail cbs_tmp_tail$link1;
    struct cds_wfcq_node *cbs$link1;
    struct cds_wfcq_node *cbs_tmp_n$link1;
    enum cds_wfcq_ret splice_ret$link1;
    signed int return_value_set_thread_cpu_affinity$7$link1;
    return_value_set_thread_cpu_affinity$7$link1=set_thread_cpu_affinity$link1(crdp$link1);
    if(!(return_value_set_thread_cpu_affinity$7$link1 == 0))
      do
      {
        signed int *return_value___errno_location$5$link1;
        return_value___errno_location$5$link1=__errno_location();
        char *return_value_strerror$6$link1;
        return_value_strerror$6$link1=strerror(*return_value___errno_location$5$link1);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 337, return_value_strerror$6$link1);
        abort();
      }
      while((_Bool)0);

    asm("" :  :  : "memory");
    tmp_statement_expression$9$link1 = *((volatile unsigned long int *)&(*(&crdp$link1->flags)));
    if(!((16ul & tmp_statement_expression$9$link1) == 0ul))
    {
      rcu_unregister_thread_mb();
      asm("" :  :  : "memory");
      __uatomic_or$link1((void *)&crdp$link1->flags, (unsigned long int)(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$8$link1 = *((volatile unsigned long int *)&(*(&crdp$link1->flags)));
        if((16ul & tmp_statement_expression$8$link1) == 0ul)
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
      __uatomic_and$link1((void *)&crdp$link1->flags, (unsigned long int)~(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      asm("" :  :  : "memory");
      rcu_register_thread_mb();
    }

    _cds_wfcq_init$link2(&cbs_tmp_head$link1, &cbs_tmp_tail$link1);
    splice_ret$link1=___cds_wfcq_splice_blocking$link2(&cbs_tmp_head$link1, &cbs_tmp_tail$link1, &crdp$link1->cbs_head, &crdp$link1->cbs_tail);
    /* assertion splice_ret != CDS_WFCQ_RET_WOULDBLOCK */
    assert((signed int)splice_ret$link1 != CDS_WFCQ_RET_WOULDBLOCK);
    /* assertion splice_ret != CDS_WFCQ_RET_DEST_NON_EMPTY */
    assert((signed int)splice_ret$link1 != CDS_WFCQ_RET_DEST_NON_EMPTY);
    if(!((signed int)splice_ret$link1 == CDS_WFCQ_RET_SRC_EMPTY))
    {
      synchronize_rcu_mb();
      cbcount$link1 = (unsigned long int)0;
      cbs$link1=___cds_wfcq_first_blocking$link2(&cbs_tmp_head$link1, &cbs_tmp_tail$link1);
      if(!(cbs$link1 == ((struct cds_wfcq_node *)NULL)))
      {
        return_value____cds_wfcq_next_blocking$10$link1=___cds_wfcq_next_blocking$link2(&cbs_tmp_head$link1, &cbs_tmp_tail$link1, cbs$link1);
        tmp_if_expr$11$link1 = return_value____cds_wfcq_next_blocking$10$link1;
      }

      else
        tmp_if_expr$11$link1 = (struct cds_wfcq_node *)(void *)0;
      cbs_tmp_n$link1 = tmp_if_expr$11$link1;
      if(!(cbs$link1 == ((struct cds_wfcq_node *)NULL)))
      {
        struct rcu_head *rhp$link1;
        const struct cds_wfcq_node *__ptr$link1 = cbs$link1;
        tmp_statement_expression$14$link1 = (struct rcu_head *)((char *)__ptr$link1 - (signed long int)0ul);
        rhp$link1 = tmp_statement_expression$14$link1;
        rhp$link1->func(rhp$link1);
        cbcount$link1 = cbcount$link1 + 1ul;
        cbs$link1 = cbs_tmp_n$link1;
        if(!(cbs$link1 == ((struct cds_wfcq_node *)NULL)))
        {
          return_value____cds_wfcq_next_blocking$12$link1=___cds_wfcq_next_blocking$link2(&cbs_tmp_head$link1, &cbs_tmp_tail$link1, cbs$link1);
          tmp_if_expr$13$link1 = return_value____cds_wfcq_next_blocking$12$link1;
        }

        else
          tmp_if_expr$13$link1 = (struct cds_wfcq_node *)(void *)0;
        cbs_tmp_n$link1 = tmp_if_expr$13$link1;
      }

      __uatomic_add$link1((void *)&crdp$link1->qlen, (unsigned long int)-((unsigned long int)cbcount$link1), (signed int)sizeof(unsigned long int) /*8ul*/ );
    }

    asm("" :  :  : "memory");
    tmp_statement_expression$15$link1 = *((volatile unsigned long int *)&(*(&crdp$link1->flags)));
    if(!((4ul & tmp_statement_expression$15$link1) == 0ul))
      break;

    rcu_thread_offline$link1();
    if(rt$link1 == 0)
    {
      _Bool return_value__cds_wfcq_empty$16$link1;
      return_value__cds_wfcq_empty$16$link1=_cds_wfcq_empty$link2(&crdp$link1->cbs_head, &crdp$link1->cbs_tail);
      if(!(return_value__cds_wfcq_empty$16$link1 == (_Bool)0))
      {
        call_rcu_wait$link1(crdp$link1);
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
        __uatomic_dec$link1((void *)&crdp$link1->futex, (signed int)sizeof(signed int) /*4ul*/ );
        asm("mfence" :  :  : "memory");
      }

      else
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    }

    else
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    rcu_thread_online$link1();
  }
  while((_Bool)1);
  volatile signed int tmp_statement_expression$17$link1;
  if(rt$link1 == 0)
  {
    asm("mfence" :  :  : "memory");
    signed int _v$link1;
    *((volatile signed int *)&(*(&crdp$link1->futex))) = 0;
    tmp_statement_expression$17$link1 = *((volatile signed int *)&(*(&crdp$link1->futex)));
    _v$link1 = tmp_statement_expression$17$link1;
    asm("" :  :  : "memory");
    _v$link1 = _v$link1;
  }

  __uatomic_or$link1((void *)&crdp$link1->flags, (unsigned long int)(1U << 3), (signed int)sizeof(unsigned long int) /*8ul*/ );
  rcu_unregister_thread_mb();
  return (void *)0;
}

// call_rcu_thread$link2
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread$link2(void *arg$link2)
{
  unsigned long int cbcount$link2;
  struct call_rcu_data *crdp$link2 = (struct call_rcu_data *)arg$link2;
  signed int rt$link2;
  volatile unsigned long int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile unsigned long int *)&(*(&crdp$link2->flags)));
  rt$link2 = (signed int)!(!((tmp_statement_expression$1$link2 & (unsigned long int)(1U << 0)) != 0ul));
  signed int return_value_set_thread_cpu_affinity$4$link2;
  return_value_set_thread_cpu_affinity$4$link2=set_thread_cpu_affinity$link2(crdp$link2);
  if(!(return_value_set_thread_cpu_affinity$4$link2 == 0))
    do
    {
      signed int *return_value___errno_location$2$link2;
      return_value___errno_location$2$link2=__errno_location();
      char *return_value_strerror$3$link2;
      return_value_strerror$3$link2=strerror(*return_value___errno_location$2$link2);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 317, return_value_strerror$3$link2);
      abort();
    }
    while((_Bool)0);

  rcu_register_thread_sig();
  thread_call_rcu_data$link2 = crdp$link2;
  if(rt$link2 == 0)
  {
    __uatomic_dec$link2((void *)&crdp$link2->futex, (signed int)sizeof(signed int) /*4ul*/ );
    asm("mfence" :  :  : "memory");
  }

  volatile unsigned long int tmp_statement_expression$9$link2;
  volatile unsigned long int tmp_statement_expression$8$link2;
  struct cds_wfcq_node *tmp_if_expr$11$link2;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$10$link2;
  struct rcu_head *tmp_statement_expression$14$link2;
  struct cds_wfcq_node *tmp_if_expr$13$link2;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$12$link2;
  volatile unsigned long int tmp_statement_expression$15$link2;
  do
  {
    struct cds_wfcq_head cbs_tmp_head$link2;
    struct cds_wfcq_tail cbs_tmp_tail$link2;
    struct cds_wfcq_node *cbs$link2;
    struct cds_wfcq_node *cbs_tmp_n$link2;
    enum cds_wfcq_ret splice_ret$link2;
    signed int return_value_set_thread_cpu_affinity$7$link2;
    return_value_set_thread_cpu_affinity$7$link2=set_thread_cpu_affinity$link2(crdp$link2);
    if(!(return_value_set_thread_cpu_affinity$7$link2 == 0))
      do
      {
        signed int *return_value___errno_location$5$link2;
        return_value___errno_location$5$link2=__errno_location();
        char *return_value_strerror$6$link2;
        return_value_strerror$6$link2=strerror(*return_value___errno_location$5$link2);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 337, return_value_strerror$6$link2);
        abort();
      }
      while((_Bool)0);

    asm("" :  :  : "memory");
    tmp_statement_expression$9$link2 = *((volatile unsigned long int *)&(*(&crdp$link2->flags)));
    if(!((16ul & tmp_statement_expression$9$link2) == 0ul))
    {
      rcu_unregister_thread_sig();
      asm("" :  :  : "memory");
      __uatomic_or$link2((void *)&crdp$link2->flags, (unsigned long int)(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$8$link2 = *((volatile unsigned long int *)&(*(&crdp$link2->flags)));
        if((16ul & tmp_statement_expression$8$link2) == 0ul)
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
      __uatomic_and$link2((void *)&crdp$link2->flags, (unsigned long int)~(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      asm("" :  :  : "memory");
      rcu_register_thread_sig();
    }

    _cds_wfcq_init$link3(&cbs_tmp_head$link2, &cbs_tmp_tail$link2);
    splice_ret$link2=___cds_wfcq_splice_blocking$link3(&cbs_tmp_head$link2, &cbs_tmp_tail$link2, &crdp$link2->cbs_head, &crdp$link2->cbs_tail);
    /* assertion splice_ret != CDS_WFCQ_RET_WOULDBLOCK */
    assert((signed int)splice_ret$link2 != CDS_WFCQ_RET_WOULDBLOCK);
    /* assertion splice_ret != CDS_WFCQ_RET_DEST_NON_EMPTY */
    assert((signed int)splice_ret$link2 != CDS_WFCQ_RET_DEST_NON_EMPTY);
    if(!((signed int)splice_ret$link2 == CDS_WFCQ_RET_SRC_EMPTY))
    {
      synchronize_rcu_sig();
      cbcount$link2 = (unsigned long int)0;
      cbs$link2=___cds_wfcq_first_blocking$link3(&cbs_tmp_head$link2, &cbs_tmp_tail$link2);
      if(!(cbs$link2 == ((struct cds_wfcq_node *)NULL)))
      {
        return_value____cds_wfcq_next_blocking$10$link2=___cds_wfcq_next_blocking$link3(&cbs_tmp_head$link2, &cbs_tmp_tail$link2, cbs$link2);
        tmp_if_expr$11$link2 = return_value____cds_wfcq_next_blocking$10$link2;
      }

      else
        tmp_if_expr$11$link2 = (struct cds_wfcq_node *)(void *)0;
      cbs_tmp_n$link2 = tmp_if_expr$11$link2;
      if(!(cbs$link2 == ((struct cds_wfcq_node *)NULL)))
      {
        struct rcu_head *rhp$link2;
        const struct cds_wfcq_node *__ptr$link2 = cbs$link2;
        tmp_statement_expression$14$link2 = (struct rcu_head *)((char *)__ptr$link2 - (signed long int)0ul);
        rhp$link2 = tmp_statement_expression$14$link2;
        rhp$link2->func(rhp$link2);
        cbcount$link2 = cbcount$link2 + 1ul;
        cbs$link2 = cbs_tmp_n$link2;
        if(!(cbs$link2 == ((struct cds_wfcq_node *)NULL)))
        {
          return_value____cds_wfcq_next_blocking$12$link2=___cds_wfcq_next_blocking$link3(&cbs_tmp_head$link2, &cbs_tmp_tail$link2, cbs$link2);
          tmp_if_expr$13$link2 = return_value____cds_wfcq_next_blocking$12$link2;
        }

        else
          tmp_if_expr$13$link2 = (struct cds_wfcq_node *)(void *)0;
        cbs_tmp_n$link2 = tmp_if_expr$13$link2;
      }

      __uatomic_add$link2((void *)&crdp$link2->qlen, (unsigned long int)-((unsigned long int)cbcount$link2), (signed int)sizeof(unsigned long int) /*8ul*/ );
    }

    asm("" :  :  : "memory");
    tmp_statement_expression$15$link2 = *((volatile unsigned long int *)&(*(&crdp$link2->flags)));
    if(!((4ul & tmp_statement_expression$15$link2) == 0ul))
      break;

    rcu_thread_offline$link2();
    if(rt$link2 == 0)
    {
      _Bool return_value__cds_wfcq_empty$16$link2;
      return_value__cds_wfcq_empty$16$link2=_cds_wfcq_empty$link3(&crdp$link2->cbs_head, &crdp$link2->cbs_tail);
      if(!(return_value__cds_wfcq_empty$16$link2 == (_Bool)0))
      {
        call_rcu_wait$link2(crdp$link2);
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
        __uatomic_dec$link2((void *)&crdp$link2->futex, (signed int)sizeof(signed int) /*4ul*/ );
        asm("mfence" :  :  : "memory");
      }

      else
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    }

    else
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    rcu_thread_online$link2();
  }
  while((_Bool)1);
  volatile signed int tmp_statement_expression$17$link2;
  if(rt$link2 == 0)
  {
    asm("mfence" :  :  : "memory");
    signed int _v$link2;
    *((volatile signed int *)&(*(&crdp$link2->futex))) = 0;
    tmp_statement_expression$17$link2 = *((volatile signed int *)&(*(&crdp$link2->futex)));
    _v$link2 = tmp_statement_expression$17$link2;
    asm("" :  :  : "memory");
    _v$link2 = _v$link2;
  }

  __uatomic_or$link2((void *)&crdp$link2->flags, (unsigned long int)(1U << 3), (signed int)sizeof(unsigned long int) /*8ul*/ );
  rcu_unregister_thread_sig();
  return (void *)0;
}

// call_rcu_thread$link3
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread$link3(void *arg$link3)
{
  unsigned long int cbcount$link3;
  struct call_rcu_data *crdp$link3 = (struct call_rcu_data *)arg$link3;
  signed int rt$link3;
  volatile unsigned long int tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((volatile unsigned long int *)&(*(&crdp$link3->flags)));
  rt$link3 = (signed int)!(!((tmp_statement_expression$1$link3 & (unsigned long int)(1U << 0)) != 0ul));
  signed int return_value_set_thread_cpu_affinity$4$link3;
  return_value_set_thread_cpu_affinity$4$link3=set_thread_cpu_affinity$link3(crdp$link3);
  if(!(return_value_set_thread_cpu_affinity$4$link3 == 0))
    do
    {
      signed int *return_value___errno_location$2$link3;
      return_value___errno_location$2$link3=__errno_location();
      char *return_value_strerror$3$link3;
      return_value_strerror$3$link3=strerror(*return_value___errno_location$2$link3);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 317, return_value_strerror$3$link3);
      abort();
    }
    while((_Bool)0);

  rcu_register_thread_qsbr();
  thread_call_rcu_data$link3 = crdp$link3;
  if(rt$link3 == 0)
  {
    __uatomic_dec$link3((void *)&crdp$link3->futex, (signed int)sizeof(signed int) /*4ul*/ );
    asm("mfence" :  :  : "memory");
  }

  volatile unsigned long int tmp_statement_expression$9$link3;
  volatile unsigned long int tmp_statement_expression$8$link3;
  struct cds_wfcq_node *tmp_if_expr$11$link3;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$10$link3;
  struct rcu_head *tmp_statement_expression$14$link3;
  struct cds_wfcq_node *tmp_if_expr$13$link3;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$12$link3;
  volatile unsigned long int tmp_statement_expression$15$link3;
  do
  {
    struct cds_wfcq_head cbs_tmp_head$link3;
    struct cds_wfcq_tail cbs_tmp_tail$link3;
    struct cds_wfcq_node *cbs$link3;
    struct cds_wfcq_node *cbs_tmp_n$link3;
    enum cds_wfcq_ret splice_ret$link3;
    signed int return_value_set_thread_cpu_affinity$7$link3;
    return_value_set_thread_cpu_affinity$7$link3=set_thread_cpu_affinity$link3(crdp$link3);
    if(!(return_value_set_thread_cpu_affinity$7$link3 == 0))
      do
      {
        signed int *return_value___errno_location$5$link3;
        return_value___errno_location$5$link3=__errno_location();
        char *return_value_strerror$6$link3;
        return_value_strerror$6$link3=strerror(*return_value___errno_location$5$link3);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 337, return_value_strerror$6$link3);
        abort();
      }
      while((_Bool)0);

    asm("" :  :  : "memory");
    tmp_statement_expression$9$link3 = *((volatile unsigned long int *)&(*(&crdp$link3->flags)));
    if(!((16ul & tmp_statement_expression$9$link3) == 0ul))
    {
      rcu_unregister_thread_qsbr();
      asm("" :  :  : "memory");
      __uatomic_or$link3((void *)&crdp$link3->flags, (unsigned long int)(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$8$link3 = *((volatile unsigned long int *)&(*(&crdp$link3->flags)));
        if((16ul & tmp_statement_expression$8$link3) == 0ul)
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
      __uatomic_and$link3((void *)&crdp$link3->flags, (unsigned long int)~(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      asm("" :  :  : "memory");
      rcu_register_thread_qsbr();
    }

    _cds_wfcq_init$link4(&cbs_tmp_head$link3, &cbs_tmp_tail$link3);
    splice_ret$link3=___cds_wfcq_splice_blocking$link4(&cbs_tmp_head$link3, &cbs_tmp_tail$link3, &crdp$link3->cbs_head, &crdp$link3->cbs_tail);
    /* assertion splice_ret != CDS_WFCQ_RET_WOULDBLOCK */
    assert((signed int)splice_ret$link3 != CDS_WFCQ_RET_WOULDBLOCK);
    /* assertion splice_ret != CDS_WFCQ_RET_DEST_NON_EMPTY */
    assert((signed int)splice_ret$link3 != CDS_WFCQ_RET_DEST_NON_EMPTY);
    if(!((signed int)splice_ret$link3 == CDS_WFCQ_RET_SRC_EMPTY))
    {
      synchronize_rcu_qsbr();
      cbcount$link3 = (unsigned long int)0;
      cbs$link3=___cds_wfcq_first_blocking$link4(&cbs_tmp_head$link3, &cbs_tmp_tail$link3);
      if(!(cbs$link3 == ((struct cds_wfcq_node *)NULL)))
      {
        return_value____cds_wfcq_next_blocking$10$link3=___cds_wfcq_next_blocking$link4(&cbs_tmp_head$link3, &cbs_tmp_tail$link3, cbs$link3);
        tmp_if_expr$11$link3 = return_value____cds_wfcq_next_blocking$10$link3;
      }

      else
        tmp_if_expr$11$link3 = (struct cds_wfcq_node *)(void *)0;
      cbs_tmp_n$link3 = tmp_if_expr$11$link3;
      if(!(cbs$link3 == ((struct cds_wfcq_node *)NULL)))
      {
        struct rcu_head *rhp$link3;
        const struct cds_wfcq_node *__ptr$link3 = cbs$link3;
        tmp_statement_expression$14$link3 = (struct rcu_head *)((char *)__ptr$link3 - (signed long int)0ul);
        rhp$link3 = tmp_statement_expression$14$link3;
        rhp$link3->func(rhp$link3);
        cbcount$link3 = cbcount$link3 + 1ul;
        cbs$link3 = cbs_tmp_n$link3;
        if(!(cbs$link3 == ((struct cds_wfcq_node *)NULL)))
        {
          return_value____cds_wfcq_next_blocking$12$link3=___cds_wfcq_next_blocking$link4(&cbs_tmp_head$link3, &cbs_tmp_tail$link3, cbs$link3);
          tmp_if_expr$13$link3 = return_value____cds_wfcq_next_blocking$12$link3;
        }

        else
          tmp_if_expr$13$link3 = (struct cds_wfcq_node *)(void *)0;
        cbs_tmp_n$link3 = tmp_if_expr$13$link3;
      }

      __uatomic_add$link3((void *)&crdp$link3->qlen, (unsigned long int)-((unsigned long int)cbcount$link3), (signed int)sizeof(unsigned long int) /*8ul*/ );
    }

    asm("" :  :  : "memory");
    tmp_statement_expression$15$link3 = *((volatile unsigned long int *)&(*(&crdp$link3->flags)));
    if(!((4ul & tmp_statement_expression$15$link3) == 0ul))
      break;

    rcu_thread_offline_qsbr();
    if(rt$link3 == 0)
    {
      _Bool return_value__cds_wfcq_empty$16$link3;
      return_value__cds_wfcq_empty$16$link3=_cds_wfcq_empty$link4(&crdp$link3->cbs_head, &crdp$link3->cbs_tail);
      if(!(return_value__cds_wfcq_empty$16$link3 == (_Bool)0))
      {
        call_rcu_wait$link3(crdp$link3);
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
        __uatomic_dec$link3((void *)&crdp$link3->futex, (signed int)sizeof(signed int) /*4ul*/ );
        asm("mfence" :  :  : "memory");
      }

      else
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    }

    else
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    rcu_thread_online_qsbr();
  }
  while((_Bool)1);
  volatile signed int tmp_statement_expression$17$link3;
  if(rt$link3 == 0)
  {
    asm("mfence" :  :  : "memory");
    signed int _v$link3;
    *((volatile signed int *)&(*(&crdp$link3->futex))) = 0;
    tmp_statement_expression$17$link3 = *((volatile signed int *)&(*(&crdp$link3->futex)));
    _v$link3 = tmp_statement_expression$17$link3;
    asm("" :  :  : "memory");
    _v$link3 = _v$link3;
  }

  __uatomic_or$link3((void *)&crdp$link3->flags, (unsigned long int)(1U << 3), (signed int)sizeof(unsigned long int) /*8ul*/ );
  rcu_unregister_thread_qsbr();
  return (void *)0;
}

// call_rcu_thread$link4
// file urcu-call-rcu-impl.h line 310
static void * call_rcu_thread$link4(void *arg$link4)
{
  unsigned long int cbcount$link4;
  struct call_rcu_data *crdp$link4 = (struct call_rcu_data *)arg$link4;
  signed int rt$link4;
  volatile unsigned long int tmp_statement_expression$1$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link4 = *((volatile unsigned long int *)&(*(&crdp$link4->flags)));
  rt$link4 = (signed int)!(!((tmp_statement_expression$1$link4 & (unsigned long int)(1U << 0)) != 0ul));
  signed int return_value_set_thread_cpu_affinity$4$link4;
  return_value_set_thread_cpu_affinity$4$link4=set_thread_cpu_affinity$link4(crdp$link4);
  if(!(return_value_set_thread_cpu_affinity$4$link4 == 0))
    do
    {
      signed int *return_value___errno_location$2$link4;
      return_value___errno_location$2$link4=__errno_location();
      char *return_value_strerror$3$link4;
      return_value_strerror$3$link4=strerror(*return_value___errno_location$2$link4);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 317, return_value_strerror$3$link4);
      abort();
    }
    while((_Bool)0);

  rcu_register_thread_bp$link1();
  thread_call_rcu_data$link4 = crdp$link4;
  if(rt$link4 == 0)
  {
    __uatomic_dec$link4((void *)&crdp$link4->futex, (signed int)sizeof(signed int) /*4ul*/ );
    asm("mfence" :  :  : "memory");
  }

  volatile unsigned long int tmp_statement_expression$9$link4;
  volatile unsigned long int tmp_statement_expression$8$link4;
  struct cds_wfcq_node *tmp_if_expr$11$link4;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$10$link4;
  struct rcu_head *tmp_statement_expression$14$link4;
  struct cds_wfcq_node *tmp_if_expr$13$link4;
  struct cds_wfcq_node *return_value____cds_wfcq_next_blocking$12$link4;
  volatile unsigned long int tmp_statement_expression$15$link4;
  do
  {
    struct cds_wfcq_head cbs_tmp_head$link4;
    struct cds_wfcq_tail cbs_tmp_tail$link4;
    struct cds_wfcq_node *cbs$link4;
    struct cds_wfcq_node *cbs_tmp_n$link4;
    enum cds_wfcq_ret splice_ret$link4;
    signed int return_value_set_thread_cpu_affinity$7$link4;
    return_value_set_thread_cpu_affinity$7$link4=set_thread_cpu_affinity$link4(crdp$link4);
    if(!(return_value_set_thread_cpu_affinity$7$link4 == 0))
      do
      {
        signed int *return_value___errno_location$5$link4;
        return_value___errno_location$5$link4=__errno_location();
        char *return_value_strerror$6$link4;
        return_value_strerror$6$link4=strerror(*return_value___errno_location$5$link4);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_thread", 337, return_value_strerror$6$link4);
        abort();
      }
      while((_Bool)0);

    asm("" :  :  : "memory");
    tmp_statement_expression$9$link4 = *((volatile unsigned long int *)&(*(&crdp$link4->flags)));
    if(!((16ul & tmp_statement_expression$9$link4) == 0ul))
    {
      rcu_unregister_thread_bp$link1();
      asm("" :  :  : "memory");
      __uatomic_or$link4((void *)&crdp$link4->flags, (unsigned long int)(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$8$link4 = *((volatile unsigned long int *)&(*(&crdp$link4->flags)));
        if((16ul & tmp_statement_expression$8$link4) == 0ul)
          break;

        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
      __uatomic_and$link4((void *)&crdp$link4->flags, (unsigned long int)~(1U << 5), (signed int)sizeof(unsigned long int) /*8ul*/ );
      asm("" :  :  : "memory");
      rcu_register_thread_bp$link1();
    }

    _cds_wfcq_init$link5(&cbs_tmp_head$link4, &cbs_tmp_tail$link4);
    splice_ret$link4=___cds_wfcq_splice_blocking$link5(&cbs_tmp_head$link4, &cbs_tmp_tail$link4, &crdp$link4->cbs_head, &crdp$link4->cbs_tail);
    /* assertion splice_ret != CDS_WFCQ_RET_WOULDBLOCK */
    assert((signed int)splice_ret$link4 != CDS_WFCQ_RET_WOULDBLOCK);
    /* assertion splice_ret != CDS_WFCQ_RET_DEST_NON_EMPTY */
    assert((signed int)splice_ret$link4 != CDS_WFCQ_RET_DEST_NON_EMPTY);
    if(!((signed int)splice_ret$link4 == CDS_WFCQ_RET_SRC_EMPTY))
    {
      synchronize_rcu_bp();
      cbcount$link4 = (unsigned long int)0;
      cbs$link4=___cds_wfcq_first_blocking$link5(&cbs_tmp_head$link4, &cbs_tmp_tail$link4);
      if(!(cbs$link4 == ((struct cds_wfcq_node *)NULL)))
      {
        return_value____cds_wfcq_next_blocking$10$link4=___cds_wfcq_next_blocking$link5(&cbs_tmp_head$link4, &cbs_tmp_tail$link4, cbs$link4);
        tmp_if_expr$11$link4 = return_value____cds_wfcq_next_blocking$10$link4;
      }

      else
        tmp_if_expr$11$link4 = (struct cds_wfcq_node *)(void *)0;
      cbs_tmp_n$link4 = tmp_if_expr$11$link4;
      if(!(cbs$link4 == ((struct cds_wfcq_node *)NULL)))
      {
        struct rcu_head *rhp$link4;
        const struct cds_wfcq_node *__ptr$link4 = cbs$link4;
        tmp_statement_expression$14$link4 = (struct rcu_head *)((char *)__ptr$link4 - (signed long int)0ul);
        rhp$link4 = tmp_statement_expression$14$link4;
        rhp$link4->func(rhp$link4);
        cbcount$link4 = cbcount$link4 + 1ul;
        cbs$link4 = cbs_tmp_n$link4;
        if(!(cbs$link4 == ((struct cds_wfcq_node *)NULL)))
        {
          return_value____cds_wfcq_next_blocking$12$link4=___cds_wfcq_next_blocking$link5(&cbs_tmp_head$link4, &cbs_tmp_tail$link4, cbs$link4);
          tmp_if_expr$13$link4 = return_value____cds_wfcq_next_blocking$12$link4;
        }

        else
          tmp_if_expr$13$link4 = (struct cds_wfcq_node *)(void *)0;
        cbs_tmp_n$link4 = tmp_if_expr$13$link4;
      }

      __uatomic_add$link4((void *)&crdp$link4->qlen, (unsigned long int)-((unsigned long int)cbcount$link4), (signed int)sizeof(unsigned long int) /*8ul*/ );
    }

    asm("" :  :  : "memory");
    tmp_statement_expression$15$link4 = *((volatile unsigned long int *)&(*(&crdp$link4->flags)));
    if(!((4ul & tmp_statement_expression$15$link4) == 0ul))
      break;

    rcu_thread_offline$link3();
    if(rt$link4 == 0)
    {
      _Bool return_value__cds_wfcq_empty$16$link4;
      return_value__cds_wfcq_empty$16$link4=_cds_wfcq_empty$link5(&crdp$link4->cbs_head, &crdp$link4->cbs_tail);
      if(!(return_value__cds_wfcq_empty$16$link4 == (_Bool)0))
      {
        call_rcu_wait$link4(crdp$link4);
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
        __uatomic_dec$link4((void *)&crdp$link4->futex, (signed int)sizeof(signed int) /*4ul*/ );
        asm("mfence" :  :  : "memory");
      }

      else
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    }

    else
      poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
    rcu_thread_online$link3();
  }
  while((_Bool)1);
  volatile signed int tmp_statement_expression$17$link4;
  if(rt$link4 == 0)
  {
    asm("mfence" :  :  : "memory");
    signed int _v$link4;
    *((volatile signed int *)&(*(&crdp$link4->futex))) = 0;
    tmp_statement_expression$17$link4 = *((volatile signed int *)&(*(&crdp$link4->futex)));
    _v$link4 = tmp_statement_expression$17$link4;
    asm("" :  :  : "memory");
    _v$link4 = _v$link4;
  }

  __uatomic_or$link4((void *)&crdp$link4->flags, (unsigned long int)(1U << 3), (signed int)sizeof(unsigned long int) /*8ul*/ );
  rcu_unregister_thread_bp$link1();
  return (void *)0;
}

// call_rcu_unlock
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock(union anonymous$0 *pmp)
{
  signed int ret;
  ret=pthread_mutex_unlock(pmp);
  if(!(ret == 0))
    do
    {
      char *return_value_strerror$1;
      return_value_strerror$1=strerror(ret);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_unlock", 192, return_value_strerror$1);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_unlock$link1
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock$link1(union anonymous$0 *pmp$link1)
{
  signed int ret$link1;
  ret$link1=pthread_mutex_unlock(pmp$link1);
  if(!(ret$link1 == 0))
    do
    {
      char *return_value_strerror$1$link1;
      return_value_strerror$1$link1=strerror(ret$link1);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_unlock", 192, return_value_strerror$1$link1);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_unlock$link2
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock$link2(union anonymous$0 *pmp$link2)
{
  signed int ret$link2;
  ret$link2=pthread_mutex_unlock(pmp$link2);
  if(!(ret$link2 == 0))
    do
    {
      char *return_value_strerror$1$link2;
      return_value_strerror$1$link2=strerror(ret$link2);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_unlock", 192, return_value_strerror$1$link2);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_unlock$link3
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock$link3(union anonymous$0 *pmp$link3)
{
  signed int ret$link3;
  ret$link3=pthread_mutex_unlock(pmp$link3);
  if(!(ret$link3 == 0))
    do
    {
      char *return_value_strerror$1$link3;
      return_value_strerror$1$link3=strerror(ret$link3);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_unlock", 192, return_value_strerror$1$link3);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_unlock$link4
// file urcu-call-rcu-impl.h line 186
static void call_rcu_unlock$link4(union anonymous$0 *pmp$link4)
{
  signed int ret$link4;
  ret$link4=pthread_mutex_unlock(pmp$link4);
  if(!(ret$link4 == 0))
    do
    {
      char *return_value_strerror$1$link4;
      return_value_strerror$1$link4=strerror(ret$link4);
      fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_unlock", 192, return_value_strerror$1$link4);
      abort();
    }
    while((_Bool)0);

}

// call_rcu_wait
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait(struct call_rcu_data *crdp)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile signed int *)&(*(&crdp->futex)));
  signed int return_value_futex_async$2;
  if(tmp_statement_expression$1 == -1)
    do
    {
      return_value_futex_async$2=futex_async(&crdp->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2 == 0)
        break;

      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      switch(*return_value___errno_location$3)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            char *return_value_strerror$5;
            return_value_strerror$5=strerror(*return_value___errno_location$4);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wait", 257, return_value_strerror$5);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_wait$link1
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait$link1(struct call_rcu_data *crdp$link1)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&crdp$link1->futex)));
  signed int return_value_futex_async$2$link1;
  if(tmp_statement_expression$1$link1 == -1)
    do
    {
      return_value_futex_async$2$link1=futex_async$link1(&crdp$link1->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link1 == 0)
        break;

      signed int *return_value___errno_location$3$link1;
      return_value___errno_location$3$link1=__errno_location();
      switch(*return_value___errno_location$3$link1)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link1;
            return_value___errno_location$4$link1=__errno_location();
            char *return_value_strerror$5$link1;
            return_value_strerror$5$link1=strerror(*return_value___errno_location$4$link1);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wait", 257, return_value_strerror$5$link1);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_wait$link2
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait$link2(struct call_rcu_data *crdp$link2)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&crdp$link2->futex)));
  signed int return_value_futex_async$2$link2;
  if(tmp_statement_expression$1$link2 == -1)
    do
    {
      return_value_futex_async$2$link2=futex_async$link2(&crdp$link2->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link2 == 0)
        break;

      signed int *return_value___errno_location$3$link2;
      return_value___errno_location$3$link2=__errno_location();
      switch(*return_value___errno_location$3$link2)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link2;
            return_value___errno_location$4$link2=__errno_location();
            char *return_value_strerror$5$link2;
            return_value_strerror$5$link2=strerror(*return_value___errno_location$4$link2);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wait", 257, return_value_strerror$5$link2);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_wait$link3
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait$link3(struct call_rcu_data *crdp$link3)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&crdp$link3->futex)));
  signed int return_value_futex_async$2$link3;
  if(tmp_statement_expression$1$link3 == -1)
    do
    {
      return_value_futex_async$2$link3=futex_async$link3(&crdp$link3->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link3 == 0)
        break;

      signed int *return_value___errno_location$3$link3;
      return_value___errno_location$3$link3=__errno_location();
      switch(*return_value___errno_location$3$link3)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link3;
            return_value___errno_location$4$link3=__errno_location();
            char *return_value_strerror$5$link3;
            return_value_strerror$5$link3=strerror(*return_value___errno_location$4$link3);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wait", 257, return_value_strerror$5$link3);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_wait$link4
// file urcu-call-rcu-impl.h line 240
static void call_rcu_wait$link4(struct call_rcu_data *crdp$link4)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link4 = *((volatile signed int *)&(*(&crdp$link4->futex)));
  signed int return_value_futex_async$2$link4;
  if(tmp_statement_expression$1$link4 == -1)
    do
    {
      return_value_futex_async$2$link4=futex_async$link4(&crdp$link4->futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link4 == 0)
        break;

      signed int *return_value___errno_location$3$link4;
      return_value___errno_location$3$link4=__errno_location();
      switch(*return_value___errno_location$3$link4)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link4;
            return_value___errno_location$4$link4=__errno_location();
            char *return_value_strerror$5$link4;
            return_value_strerror$5$link4=strerror(*return_value___errno_location$4$link4);
            fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wait", 257, return_value_strerror$5$link4);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// call_rcu_wake_up
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up(struct call_rcu_data *crdp)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5;
  asm("" :  :  : "memory");
  tmp_statement_expression$5 = *((volatile signed int *)&(*(&crdp->futex)));
  volatile signed int tmp_statement_expression$1;
  if(tmp_statement_expression$5 == -1)
  {
    signed int _v;
    *((volatile signed int *)&(*(&crdp->futex))) = 0;
    tmp_statement_expression$1 = *((volatile signed int *)&(*(&crdp->futex)));
    _v = tmp_statement_expression$1;
    asm("" :  :  : "memory");
    _v = _v;
    signed int return_value_futex_async$4;
    return_value_futex_async$4=futex_async(&crdp->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4 >= 0))
      do
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wake_up", 270, return_value_strerror$3);
        abort();
      }
      while((_Bool)0);

  }

}

// call_rcu_wake_up$link1
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up$link1(struct call_rcu_data *crdp$link1)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link1 = *((volatile signed int *)&(*(&crdp$link1->futex)));
  volatile signed int tmp_statement_expression$1$link1;
  if(tmp_statement_expression$5$link1 == -1)
  {
    signed int _v$link1;
    *((volatile signed int *)&(*(&crdp$link1->futex))) = 0;
    tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&crdp$link1->futex)));
    _v$link1 = tmp_statement_expression$1$link1;
    asm("" :  :  : "memory");
    _v$link1 = _v$link1;
    signed int return_value_futex_async$4$link1;
    return_value_futex_async$4$link1=futex_async$link1(&crdp$link1->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4$link1 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link1;
        return_value___errno_location$2$link1=__errno_location();
        char *return_value_strerror$3$link1;
        return_value_strerror$3$link1=strerror(*return_value___errno_location$2$link1);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wake_up", 270, return_value_strerror$3$link1);
        abort();
      }
      while((_Bool)0);

  }

}

// call_rcu_wake_up$link2
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up$link2(struct call_rcu_data *crdp$link2)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link2 = *((volatile signed int *)&(*(&crdp$link2->futex)));
  volatile signed int tmp_statement_expression$1$link2;
  if(tmp_statement_expression$5$link2 == -1)
  {
    signed int _v$link2;
    *((volatile signed int *)&(*(&crdp$link2->futex))) = 0;
    tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&crdp$link2->futex)));
    _v$link2 = tmp_statement_expression$1$link2;
    asm("" :  :  : "memory");
    _v$link2 = _v$link2;
    signed int return_value_futex_async$4$link2;
    return_value_futex_async$4$link2=futex_async$link2(&crdp$link2->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4$link2 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link2;
        return_value___errno_location$2$link2=__errno_location();
        char *return_value_strerror$3$link2;
        return_value_strerror$3$link2=strerror(*return_value___errno_location$2$link2);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wake_up", 270, return_value_strerror$3$link2);
        abort();
      }
      while((_Bool)0);

  }

}

// call_rcu_wake_up$link3
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up$link3(struct call_rcu_data *crdp$link3)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link3 = *((volatile signed int *)&(*(&crdp$link3->futex)));
  volatile signed int tmp_statement_expression$1$link3;
  if(tmp_statement_expression$5$link3 == -1)
  {
    signed int _v$link3;
    *((volatile signed int *)&(*(&crdp$link3->futex))) = 0;
    tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&crdp$link3->futex)));
    _v$link3 = tmp_statement_expression$1$link3;
    asm("" :  :  : "memory");
    _v$link3 = _v$link3;
    signed int return_value_futex_async$4$link3;
    return_value_futex_async$4$link3=futex_async$link3(&crdp$link3->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4$link3 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link3;
        return_value___errno_location$2$link3=__errno_location();
        char *return_value_strerror$3$link3;
        return_value_strerror$3$link3=strerror(*return_value___errno_location$2$link3);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wake_up", 270, return_value_strerror$3$link3);
        abort();
      }
      while((_Bool)0);

  }

}

// call_rcu_wake_up$link4
// file urcu-call-rcu-impl.h line 262
static void call_rcu_wake_up$link4(struct call_rcu_data *crdp$link4)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$5$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link4 = *((volatile signed int *)&(*(&crdp$link4->futex)));
  volatile signed int tmp_statement_expression$1$link4;
  if(tmp_statement_expression$5$link4 == -1)
  {
    signed int _v$link4;
    *((volatile signed int *)&(*(&crdp$link4->futex))) = 0;
    tmp_statement_expression$1$link4 = *((volatile signed int *)&(*(&crdp$link4->futex)));
    _v$link4 = tmp_statement_expression$1$link4;
    asm("" :  :  : "memory");
    _v$link4 = _v$link4;
    signed int return_value_futex_async$4$link4;
    return_value_futex_async$4$link4=futex_async$link4(&crdp$link4->futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_async$4$link4 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link4;
        return_value___errno_location$2$link4=__errno_location();
        char *return_value_strerror$3$link4;
        return_value_strerror$3$link4=strerror(*return_value___errno_location$2$link4);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"call_rcu_wake_up", 270, return_value_strerror$3$link4);
        abort();
      }
      while((_Bool)0);

  }

}

// cds_list_add
// file ./urcu/list.h line 51
static inline void cds_list_add(struct cds_list_head *newp, struct cds_list_head *head)
{
  head->next->prev = newp;
  newp->next = head->next;
  newp->prev = head;
  head->next = newp;
}

// cds_list_add$link1
// file ./urcu/list.h line 51
static inline void cds_list_add$link1(struct cds_list_head *newp$link1, struct cds_list_head *head$link1)
{
  head$link1->next->prev = newp$link1;
  newp$link1->next = head$link1->next;
  newp$link1->prev = head$link1;
  head$link1->next = newp$link1;
}

// cds_list_add$link2
// file ./urcu/list.h line 51
static inline void cds_list_add$link2(struct cds_list_head *newp$link2, struct cds_list_head *head$link2)
{
  head$link2->next->prev = newp$link2;
  newp$link2->next = head$link2->next;
  newp$link2->prev = head$link2;
  head$link2->next = newp$link2;
}

// cds_list_add$link3
// file ./urcu/list.h line 51
static inline void cds_list_add$link3(struct cds_list_head *newp$link3, struct cds_list_head *head$link3)
{
  head$link3->next->prev = newp$link3;
  newp$link3->next = head$link3->next;
  newp$link3->prev = head$link3;
  head$link3->next = newp$link3;
}

// cds_list_add$link4
// file ./urcu/list.h line 51
static inline void cds_list_add$link4(struct cds_list_head *newp$link4, struct cds_list_head *head$link4)
{
  head$link4->next->prev = newp$link4;
  newp$link4->next = head$link4->next;
  newp$link4->prev = head$link4;
  head$link4->next = newp$link4;
}

// cds_list_add_tail
// file ./urcu/list.h line 61
static inline void cds_list_add_tail(struct cds_list_head *newp, struct cds_list_head *head)
{
  head->prev->next = newp;
  newp->next = head;
  newp->prev = head->prev;
  head->prev = newp;
}

// cds_list_del
// file ./urcu/list.h line 79
static inline void cds_list_del(struct cds_list_head *elem)
{
  __cds_list_del(elem->prev, elem->next);
}

// cds_list_del$link1
// file ./urcu/list.h line 79
static inline void cds_list_del$link1(struct cds_list_head *elem$link1)
{
  __cds_list_del$link1(elem$link1->prev, elem$link1->next);
}

// cds_list_del$link2
// file ./urcu/list.h line 79
static inline void cds_list_del$link2(struct cds_list_head *elem$link2)
{
  __cds_list_del$link2(elem$link2->prev, elem$link2->next);
}

// cds_list_del$link3
// file ./urcu/list.h line 79
static inline void cds_list_del$link3(struct cds_list_head *elem$link3)
{
  __cds_list_del$link3(elem$link3->prev, elem$link3->next);
}

// cds_list_del$link4
// file ./urcu/list.h line 79
static inline void cds_list_del$link4(struct cds_list_head *elem$link4)
{
  __cds_list_del$link4(elem$link4->prev, elem$link4->next);
}

// cds_list_empty
// file ./urcu/list.h line 184
static inline signed int cds_list_empty(struct cds_list_head *head)
{
  return (signed int)(head == head->next);
}

// cds_list_empty$link1
// file ./urcu/list.h line 184
static inline signed int cds_list_empty$link1(struct cds_list_head *head$link1)
{
  return (signed int)(head$link1 == head$link1->next);
}

// cds_list_empty$link2
// file ./urcu/list.h line 184
static inline signed int cds_list_empty$link2(struct cds_list_head *head$link2)
{
  return (signed int)(head$link2 == head$link2->next);
}

// cds_list_empty$link3
// file ./urcu/list.h line 184
static inline signed int cds_list_empty$link3(struct cds_list_head *head$link3)
{
  return (signed int)(head$link3 == head$link3->next);
}

// cds_list_empty$link4
// file ./urcu/list.h line 184
static inline signed int cds_list_empty$link4(struct cds_list_head *head$link4)
{
  return (signed int)(head$link4 == head$link4->next);
}

// cds_list_move
// file ./urcu/list.h line 94
static inline void cds_list_move(struct cds_list_head *elem, struct cds_list_head *head)
{
  __cds_list_del(elem->prev, elem->next);
  cds_list_add(elem, head);
}

// cds_list_move$link1
// file ./urcu/list.h line 94
static inline void cds_list_move$link1(struct cds_list_head *elem$link1, struct cds_list_head *head$link1)
{
  __cds_list_del$link1(elem$link1->prev, elem$link1->next);
  cds_list_add$link1(elem$link1, head$link1);
}

// cds_list_move$link2
// file ./urcu/list.h line 94
static inline void cds_list_move$link2(struct cds_list_head *elem$link2, struct cds_list_head *head$link2)
{
  __cds_list_del$link2(elem$link2->prev, elem$link2->next);
  cds_list_add$link2(elem$link2, head$link2);
}

// cds_list_move$link3
// file ./urcu/list.h line 94
static inline void cds_list_move$link3(struct cds_list_head *elem$link3, struct cds_list_head *head$link3)
{
  __cds_list_del$link3(elem$link3->prev, elem$link3->next);
  cds_list_add$link3(elem$link3, head$link3);
}

// cds_list_move$link4
// file ./urcu/list.h line 94
static inline void cds_list_move$link4(struct cds_list_head *elem$link4, struct cds_list_head *head$link4)
{
  __cds_list_del$link4(elem$link4->prev, elem$link4->next);
  cds_list_add$link4(elem$link4, head$link4);
}

// cds_list_splice
// file ./urcu/list.h line 112
static inline void cds_list_splice(struct cds_list_head *add, struct cds_list_head *head)
{
  if(!(add == add->next))
  {
    add->next->prev = head;
    add->prev->next = head->next;
    head->next->prev = add->prev;
    head->next = add->next;
  }

}

// cds_list_splice$link1
// file ./urcu/list.h line 112
static inline void cds_list_splice$link1(struct cds_list_head *add$link1, struct cds_list_head *head$link1)
{
  if(!(add$link1 == add$link1->next))
  {
    add$link1->next->prev = head$link1;
    add$link1->prev->next = head$link1->next;
    head$link1->next->prev = add$link1->prev;
    head$link1->next = add$link1->next;
  }

}

// cds_list_splice$link2
// file ./urcu/list.h line 112
static inline void cds_list_splice$link2(struct cds_list_head *add$link2, struct cds_list_head *head$link2)
{
  if(!(add$link2 == add$link2->next))
  {
    add$link2->next->prev = head$link2;
    add$link2->prev->next = head$link2->next;
    head$link2->next->prev = add$link2->prev;
    head$link2->next = add$link2->next;
  }

}

// cds_list_splice$link3
// file ./urcu/list.h line 112
static inline void cds_list_splice$link3(struct cds_list_head *add$link3, struct cds_list_head *head$link3)
{
  if(!(add$link3 == add$link3->next))
  {
    add$link3->next->prev = head$link3;
    add$link3->prev->next = head$link3->next;
    head$link3->next->prev = add$link3->prev;
    head$link3->next = add$link3->next;
  }

}

// cds_list_splice$link4
// file ./urcu/list.h line 112
static inline void cds_list_splice$link4(struct cds_list_head *add$link4, struct cds_list_head *head$link4)
{
  if(!(add$link4 == add$link4->next))
  {
    add$link4->next->prev = head$link4;
    add$link4->prev->next = head$link4->next;
    head$link4->next->prev = add$link4->prev;
    head$link4->next = add$link4->next;
  }

}

// cds_wfcq_dequeue_blocking
// file wfcqueue.c line 75
extern struct cds_wfcq_node * cds_wfcq_dequeue_blocking(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  struct cds_wfcq_node *return_value__cds_wfcq_dequeue_blocking$1;
  return_value__cds_wfcq_dequeue_blocking$1=_cds_wfcq_dequeue_blocking(head, tail);
  return return_value__cds_wfcq_dequeue_blocking$1;
}

// cds_wfcq_dequeue_lock
// file wfcqueue.c line 63
extern void cds_wfcq_dequeue_lock(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  _cds_wfcq_dequeue_lock(head, tail);
}

// cds_wfcq_dequeue_unlock
// file wfcqueue.c line 69
extern void cds_wfcq_dequeue_unlock(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  _cds_wfcq_dequeue_unlock(head, tail);
}

// cds_wfcq_dequeue_with_state_blocking
// file wfcqueue.c line 82
extern struct cds_wfcq_node * cds_wfcq_dequeue_with_state_blocking(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail, signed int *state)
{
  struct cds_wfcq_node *return_value__cds_wfcq_dequeue_with_state_blocking$1;
  return_value__cds_wfcq_dequeue_with_state_blocking$1=_cds_wfcq_dequeue_with_state_blocking(head, tail, state);
  return return_value__cds_wfcq_dequeue_with_state_blocking$1;
}

// cds_wfcq_empty
// file wfcqueue.c line 49
extern _Bool cds_wfcq_empty(union anonymous$1 head, struct cds_wfcq_tail *tail)
{
  _Bool return_value__cds_wfcq_empty$1;
  return_value__cds_wfcq_empty$1=_cds_wfcq_empty$link1(head, tail);
  return return_value__cds_wfcq_empty$1;
}

// cds_wfcq_enqueue
// file wfcqueue.c line 56
extern _Bool cds_wfcq_enqueue(union anonymous$1 head, struct cds_wfcq_tail *tail, struct cds_wfcq_node *node)
{
  _Bool return_value__cds_wfcq_enqueue$1;
  return_value__cds_wfcq_enqueue$1=_cds_wfcq_enqueue$link1(head, tail, node);
  return return_value__cds_wfcq_enqueue$1;
}

// cds_wfcq_init
// file wfcqueue.c line 37
extern void cds_wfcq_init(struct cds_wfcq_head *head, struct cds_wfcq_tail *tail)
{
  _cds_wfcq_init$link1(head, tail);
}

// cds_wfcq_node_init
// file wfcqueue.c line 32
extern void cds_wfcq_node_init(struct cds_wfcq_node *node)
{
  _cds_wfcq_node_init$link1(node);
}

// cds_wfcq_splice_blocking
// file wfcqueue.c line 90
extern enum cds_wfcq_ret cds_wfcq_splice_blocking(struct cds_wfcq_head *dest_q_head, struct cds_wfcq_tail *dest_q_tail, struct cds_wfcq_head *src_q_head, struct cds_wfcq_tail *src_q_tail)
{
  enum cds_wfcq_ret return_value__cds_wfcq_splice_blocking$1;
  return_value__cds_wfcq_splice_blocking$1=_cds_wfcq_splice_blocking(dest_q_head, dest_q_tail, src_q_head, src_q_tail);
  return return_value__cds_wfcq_splice_blocking$1;
}

// cds_wfq_dequeue_blocking
// file wfqueue.c line 54
extern struct cds_wfq_node * cds_wfq_dequeue_blocking(struct cds_wfq_queue *q)
{
  struct cds_wfq_node *return_value__cds_wfq_dequeue_blocking$1;
  return_value__cds_wfq_dequeue_blocking$1=_cds_wfq_dequeue_blocking(q);
  return return_value__cds_wfq_dequeue_blocking$1;
}

// cds_wfq_enqueue
// file wfqueue.c line 44
extern void cds_wfq_enqueue(struct cds_wfq_queue *q, struct cds_wfq_node *node)
{
  _cds_wfq_enqueue(q, node);
}

// cds_wfq_init
// file wfqueue.c line 39
extern void cds_wfq_init(struct cds_wfq_queue *q)
{
  _cds_wfq_init(q);
}

// cds_wfq_node_init
// file wfqueue.c line 34
extern void cds_wfq_node_init(struct cds_wfq_node *node)
{
  _cds_wfq_node_init(node);
}

// cds_wfs_empty
// file wfstack.c line 46
extern _Bool cds_wfs_empty(union anonymous u_stack)
{
  _Bool return_value__cds_wfs_empty$1;
  return_value__cds_wfs_empty$1=_cds_wfs_empty(u_stack);
  return return_value__cds_wfs_empty$1;
}

// cds_wfs_first
// file wfstack.c line 72
extern struct cds_wfs_node * cds_wfs_first(struct cds_wfs_head *head)
{
  struct cds_wfs_node *return_value__cds_wfs_first$1;
  return_value__cds_wfs_first$1=_cds_wfs_first$link1(head);
  return return_value__cds_wfs_first$1;
}

// cds_wfs_init
// file wfstack.c line 36
extern void cds_wfs_init(struct cds_wfs_stack *s)
{
  _cds_wfs_init(s);
}

// cds_wfs_next_blocking
// file wfstack.c line 77
extern struct cds_wfs_node * cds_wfs_next_blocking(struct cds_wfs_node *node)
{
  struct cds_wfs_node *return_value__cds_wfs_next_blocking$1;
  return_value__cds_wfs_next_blocking$1=_cds_wfs_next_blocking$link1(node);
  return return_value__cds_wfs_next_blocking$1;
}

// cds_wfs_next_nonblocking
// file wfstack.c line 82
extern struct cds_wfs_node * cds_wfs_next_nonblocking(struct cds_wfs_node *node)
{
  struct cds_wfs_node *return_value__cds_wfs_next_nonblocking$1;
  return_value__cds_wfs_next_nonblocking$1=_cds_wfs_next_nonblocking(node);
  return return_value__cds_wfs_next_nonblocking$1;
}

// cds_wfs_node_init
// file wfstack.c line 31
extern void cds_wfs_node_init(struct cds_wfs_node *node)
{
  _cds_wfs_node_init(node);
}

// cds_wfs_pop_all_blocking
// file wfstack.c line 67
extern struct cds_wfs_head * cds_wfs_pop_all_blocking(struct cds_wfs_stack *s)
{
  struct cds_wfs_head *return_value__cds_wfs_pop_all_blocking$1;
  return_value__cds_wfs_pop_all_blocking$1=_cds_wfs_pop_all_blocking(s);
  return return_value__cds_wfs_pop_all_blocking$1;
}

// cds_wfs_pop_blocking
// file wfstack.c line 56
extern struct cds_wfs_node * cds_wfs_pop_blocking(struct cds_wfs_stack *s)
{
  struct cds_wfs_node *return_value__cds_wfs_pop_blocking$1;
  return_value__cds_wfs_pop_blocking$1=_cds_wfs_pop_blocking(s);
  return return_value__cds_wfs_pop_blocking$1;
}

// cds_wfs_pop_lock
// file wfstack.c line 87
extern void cds_wfs_pop_lock(struct cds_wfs_stack *s)
{
  _cds_wfs_pop_lock(s);
}

// cds_wfs_pop_unlock
// file wfstack.c line 92
extern void cds_wfs_pop_unlock(struct cds_wfs_stack *s)
{
  _cds_wfs_pop_unlock(s);
}

// cds_wfs_pop_with_state_blocking
// file wfstack.c line 62
extern struct cds_wfs_node * cds_wfs_pop_with_state_blocking(struct cds_wfs_stack *s, signed int *state)
{
  struct cds_wfs_node *return_value__cds_wfs_pop_with_state_blocking$1;
  return_value__cds_wfs_pop_with_state_blocking$1=_cds_wfs_pop_with_state_blocking(s, state);
  return return_value__cds_wfs_pop_with_state_blocking$1;
}

// cds_wfs_push
// file wfstack.c line 51
extern signed int cds_wfs_push(union anonymous u_stack, struct cds_wfs_node *node)
{
  signed int return_value__cds_wfs_push$1;
  return_value__cds_wfs_push$1=_cds_wfs_push$link1(u_stack, node);
  return return_value__cds_wfs_push$1;
}

// cleanup_thread
// file urcu-bp.c line 482
static void cleanup_thread(struct registry_chunk *chunk, struct rcu_reader_bp *rcu_reader_reg)
{
  rcu_reader_reg->ctr = (unsigned long int)0;
  cds_list_del$link4(&rcu_reader_reg->node);
  rcu_reader_reg->tid = (unsigned long int)0;
  rcu_reader_reg->alloc = 0;
  chunk->used = chunk->used - sizeof(struct rcu_reader_bp) /*40ul*/ ;
}

// compat_futex_async
// file ./urcu/futex.h line 52
extern signed int compat_futex_async(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3)
{
  signed int ret = 0;
  /* assertion !timeout */
  assert(!(timeout != ((struct timespec *)NULL)));
  /* assertion !uaddr2 */
  assert(!(uaddr2 != ((signed int *)NULL)));
  /* assertion !val3 */
  assert(!(val3 != 0));
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1;
  switch(op)
  {
    case 0:
    {
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$1 = *((volatile signed int *)&(*uaddr));
        if(!(tmp_statement_expression$1 == val))
          break;

        signed int return_value_poll$2;
        return_value_poll$2=poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
        if(!(return_value_poll$2 >= 0))
        {
          ret = -1;
          goto end;
        }

      }
      while((_Bool)1);
      break;
    }
    case 1:
      break;
    default:
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 22;
      ret = -1;
    }
  }

end:
  ;
  return ret;
}

// compat_futex_noasync
// file ./urcu/futex.h line 50
extern signed int compat_futex_noasync(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3)
{
  signed int ret = 0;
  signed int lockret;
  /* assertion !timeout */
  assert(!(timeout != ((struct timespec *)NULL)));
  /* assertion !uaddr2 */
  assert(!(uaddr2 != ((signed int *)NULL)));
  /* assertion !val3 */
  assert(!(val3 != 0));
  asm("mfence" :  :  : "memory");
  lockret=pthread_mutex_lock(&__urcu_compat_futex_lock);
  if(!(lockret == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = lockret;
    ret = -1;
    goto end;
  }

  volatile signed int tmp_statement_expression$2;
  switch(op)
  {
    case 0:
    {
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$2 = *((volatile signed int *)&(*uaddr));
        if(!(tmp_statement_expression$2 == val))
          break;

        pthread_cond_wait(&__urcu_compat_futex_cond, &__urcu_compat_futex_lock);
      }
      while((_Bool)1);
      break;
    }
    case 1:
    {
      pthread_cond_broadcast(&__urcu_compat_futex_cond);
      break;
    }
    default:
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 22;
      ret = -1;
    }
  }
  lockret=pthread_mutex_unlock(&__urcu_compat_futex_lock);
  if(!(lockret == 0))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    *return_value___errno_location$4 = lockret;
    ret = -1;
  }


end:
  ;
  return ret;
}

// create_all_cpu_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_bp(unsigned long int flags)
{
  signed int i;
  struct call_rcu_data *crdp;
  signed int ret;
  call_rcu_lock$link4(&call_rcu_mutex$link4);
  alloc_cpu_call_rcu_data$link4();
  call_rcu_unlock$link4(&call_rcu_mutex$link4);
  if(!(maxcpus$link4 >= 1l))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data$link4 == ((struct call_rcu_data **)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  i = 0;
  for( ; !((signed long int)i >= maxcpus$link4); i = i + 1)
  {
    call_rcu_lock$link4(&call_rcu_mutex$link4);
    struct call_rcu_data *return_value_get_cpu_call_rcu_data_bp$3;
    return_value_get_cpu_call_rcu_data_bp$3=get_cpu_call_rcu_data_bp(i);
    if(!(return_value_get_cpu_call_rcu_data_bp$3 == ((struct call_rcu_data *)NULL)))
      call_rcu_unlock$link4(&call_rcu_mutex$link4);

    else
    {
      crdp=__create_call_rcu_data$link4(flags, i);
      if(crdp == ((struct call_rcu_data *)NULL))
      {
        call_rcu_unlock$link4(&call_rcu_mutex$link4);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 12;
        return -12;
      }

      call_rcu_unlock$link4(&call_rcu_mutex$link4);
      ret=set_cpu_call_rcu_data_bp(i, crdp);
      if(!(ret == 0))
      {
        call_rcu_data_free_bp(crdp);
        if(ret == -17)
          goto __CPROVER_DUMP_L8;

        return ret;
      }

    }

  __CPROVER_DUMP_L8:
    ;
  }
  return 0;
}

// create_all_cpu_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_mb(unsigned long int flags)
{
  signed int i;
  struct call_rcu_data *crdp;
  signed int ret;
  call_rcu_lock$link1(&call_rcu_mutex$link1);
  alloc_cpu_call_rcu_data$link1();
  call_rcu_unlock$link1(&call_rcu_mutex$link1);
  if(!(maxcpus$link1 >= 1l))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data$link1 == ((struct call_rcu_data **)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  i = 0;
  for( ; !((signed long int)i >= maxcpus$link1); i = i + 1)
  {
    call_rcu_lock$link1(&call_rcu_mutex$link1);
    struct call_rcu_data *return_value_get_cpu_call_rcu_data_mb$3;
    return_value_get_cpu_call_rcu_data_mb$3=get_cpu_call_rcu_data_mb(i);
    if(!(return_value_get_cpu_call_rcu_data_mb$3 == ((struct call_rcu_data *)NULL)))
      call_rcu_unlock$link1(&call_rcu_mutex$link1);

    else
    {
      crdp=__create_call_rcu_data$link1(flags, i);
      if(crdp == ((struct call_rcu_data *)NULL))
      {
        call_rcu_unlock$link1(&call_rcu_mutex$link1);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 12;
        return -12;
      }

      call_rcu_unlock$link1(&call_rcu_mutex$link1);
      ret=set_cpu_call_rcu_data_mb(i, crdp);
      if(!(ret == 0))
      {
        call_rcu_data_free_mb(crdp);
        if(ret == -17)
          goto __CPROVER_DUMP_L8;

        return ret;
      }

    }

  __CPROVER_DUMP_L8:
    ;
  }
  return 0;
}

// create_all_cpu_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_memb(unsigned long int flags)
{
  signed int i;
  struct call_rcu_data *crdp;
  signed int ret;
  call_rcu_lock(&call_rcu_mutex);
  alloc_cpu_call_rcu_data();
  call_rcu_unlock(&call_rcu_mutex);
  if(!(maxcpus >= 1l))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data == ((struct call_rcu_data **)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  i = 0;
  for( ; !((signed long int)i >= maxcpus); i = i + 1)
  {
    call_rcu_lock(&call_rcu_mutex);
    struct call_rcu_data *return_value_get_cpu_call_rcu_data_memb$3;
    return_value_get_cpu_call_rcu_data_memb$3=get_cpu_call_rcu_data_memb(i);
    if(!(return_value_get_cpu_call_rcu_data_memb$3 == ((struct call_rcu_data *)NULL)))
      call_rcu_unlock(&call_rcu_mutex);

    else
    {
      crdp=__create_call_rcu_data(flags, i);
      if(crdp == ((struct call_rcu_data *)NULL))
      {
        call_rcu_unlock(&call_rcu_mutex);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 12;
        return -12;
      }

      call_rcu_unlock(&call_rcu_mutex);
      ret=set_cpu_call_rcu_data_memb(i, crdp);
      if(!(ret == 0))
      {
        call_rcu_data_free_memb(crdp);
        if(ret == -17)
          goto __CPROVER_DUMP_L8;

        return ret;
      }

    }

  __CPROVER_DUMP_L8:
    ;
  }
  return 0;
}

// create_all_cpu_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_qsbr(unsigned long int flags)
{
  signed int i;
  struct call_rcu_data *crdp;
  signed int ret;
  call_rcu_lock$link3(&call_rcu_mutex$link3);
  alloc_cpu_call_rcu_data$link3();
  call_rcu_unlock$link3(&call_rcu_mutex$link3);
  if(!(maxcpus$link3 >= 1l))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data$link3 == ((struct call_rcu_data **)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  i = 0;
  for( ; !((signed long int)i >= maxcpus$link3); i = i + 1)
  {
    call_rcu_lock$link3(&call_rcu_mutex$link3);
    struct call_rcu_data *return_value_get_cpu_call_rcu_data_qsbr$3;
    return_value_get_cpu_call_rcu_data_qsbr$3=get_cpu_call_rcu_data_qsbr(i);
    if(!(return_value_get_cpu_call_rcu_data_qsbr$3 == ((struct call_rcu_data *)NULL)))
      call_rcu_unlock$link3(&call_rcu_mutex$link3);

    else
    {
      crdp=__create_call_rcu_data$link3(flags, i);
      if(crdp == ((struct call_rcu_data *)NULL))
      {
        call_rcu_unlock$link3(&call_rcu_mutex$link3);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 12;
        return -12;
      }

      call_rcu_unlock$link3(&call_rcu_mutex$link3);
      ret=set_cpu_call_rcu_data_qsbr(i, crdp);
      if(!(ret == 0))
      {
        call_rcu_data_free_qsbr(crdp);
        if(ret == -17)
          goto __CPROVER_DUMP_L8;

        return ret;
      }

    }

  __CPROVER_DUMP_L8:
    ;
  }
  return 0;
}

// create_all_cpu_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 627
signed int create_all_cpu_call_rcu_data_sig(unsigned long int flags)
{
  signed int i;
  struct call_rcu_data *crdp;
  signed int ret;
  call_rcu_lock$link2(&call_rcu_mutex$link2);
  alloc_cpu_call_rcu_data$link2();
  call_rcu_unlock$link2(&call_rcu_mutex$link2);
  if(!(maxcpus$link2 >= 1l))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data$link2 == ((struct call_rcu_data **)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  i = 0;
  for( ; !((signed long int)i >= maxcpus$link2); i = i + 1)
  {
    call_rcu_lock$link2(&call_rcu_mutex$link2);
    struct call_rcu_data *return_value_get_cpu_call_rcu_data_sig$3;
    return_value_get_cpu_call_rcu_data_sig$3=get_cpu_call_rcu_data_sig(i);
    if(!(return_value_get_cpu_call_rcu_data_sig$3 == ((struct call_rcu_data *)NULL)))
      call_rcu_unlock$link2(&call_rcu_mutex$link2);

    else
    {
      crdp=__create_call_rcu_data$link2(flags, i);
      if(crdp == ((struct call_rcu_data *)NULL))
      {
        call_rcu_unlock$link2(&call_rcu_mutex$link2);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 12;
        return -12;
      }

      call_rcu_unlock$link2(&call_rcu_mutex$link2);
      ret=set_cpu_call_rcu_data_sig(i, crdp);
      if(!(ret == 0))
      {
        call_rcu_data_free_sig(crdp);
        if(ret == -17)
          goto __CPROVER_DUMP_L8;

        return ret;
      }

    }

  __CPROVER_DUMP_L8:
    ;
  }
  return 0;
}

// create_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_bp(unsigned long int flags, signed int cpu_affinity)
{
  struct call_rcu_data *crdp;
  call_rcu_lock$link4(&call_rcu_mutex$link4);
  crdp=__create_call_rcu_data$link4(flags, cpu_affinity);
  call_rcu_unlock$link4(&call_rcu_mutex$link4);
  return crdp;
}

// create_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_mb(unsigned long int flags, signed int cpu_affinity)
{
  struct call_rcu_data *crdp;
  call_rcu_lock$link1(&call_rcu_mutex$link1);
  crdp=__create_call_rcu_data$link1(flags, cpu_affinity);
  call_rcu_unlock$link1(&call_rcu_mutex$link1);
  return crdp;
}

// create_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_memb(unsigned long int flags, signed int cpu_affinity)
{
  struct call_rcu_data *crdp;
  call_rcu_lock(&call_rcu_mutex);
  crdp=__create_call_rcu_data(flags, cpu_affinity);
  call_rcu_unlock(&call_rcu_mutex);
  return crdp;
}

// create_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_qsbr(unsigned long int flags, signed int cpu_affinity)
{
  struct call_rcu_data *crdp;
  call_rcu_lock$link3(&call_rcu_mutex$link3);
  crdp=__create_call_rcu_data$link3(flags, cpu_affinity);
  call_rcu_unlock$link3(&call_rcu_mutex$link3);
  return crdp;
}

// create_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 490
struct call_rcu_data * create_call_rcu_data_sig(unsigned long int flags, signed int cpu_affinity)
{
  struct call_rcu_data *crdp;
  call_rcu_lock$link2(&call_rcu_mutex$link2);
  crdp=__create_call_rcu_data$link2(flags, cpu_affinity);
  call_rcu_unlock$link2(&call_rcu_mutex$link2);
  return crdp;
}

// defer_rcu_bp
// file urcu-defer-impl.h line 395
extern void defer_rcu_bp(void (*fct)(void *), void *p)
{
  _defer_rcu$link4(fct, p);
}

// defer_rcu_mb
// file urcu-defer-impl.h line 395
extern void defer_rcu_mb(void (*fct)(void *), void *p)
{
  _defer_rcu$link1(fct, p);
}

// defer_rcu_memb
// file urcu-defer-impl.h line 395
extern void defer_rcu_memb(void (*fct)(void *), void *p)
{
  _defer_rcu(fct, p);
}

// defer_rcu_qsbr
// file urcu-defer-impl.h line 395
extern void defer_rcu_qsbr(void (*fct)(void *), void *p)
{
  _defer_rcu$link3(fct, p);
}

// defer_rcu_sig
// file urcu-defer-impl.h line 395
extern void defer_rcu_sig(void (*fct)(void *), void *p)
{
  _defer_rcu$link2(fct, p);
}

// diag
// file tap.c line 273
unsigned int diag(char *fmt, ...)
{
  void **ap;
  fputs("# ", stderr);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  fputs("\n", stderr);
  return (unsigned int)0;
}

// exit_status
// file ../../tests/utils/tap.h line 89
signed int exit_status(void)
{
  signed int r;
  if(have_plan == 0 || !(no_plan == 0))
    return (signed int)failures;

  else
    if(!(e_tests >= test_count))
    {
      r = (signed int)(test_count - e_tests);
      return r;
    }

    else
    {
      r = (signed int)((failures + e_tests) - test_count);
      return r;
    }
}

// expand_arena
// file urcu-bp.c line 365
static void expand_arena(struct registry_arena *arena)
{
  struct registry_chunk *new_chunk;
  struct registry_chunk *last_chunk;
  unsigned long int old_chunk_len;
  unsigned long int new_chunk_len;
  signed int return_value_cds_list_empty$2;
  return_value_cds_list_empty$2=cds_list_empty$link4(&arena->chunk_list);
  if(!(return_value_cds_list_empty$2 == 0))
  {
    /* assertion sizeof(struct registry_chunk) + 8 * sizeof(struct rcu_reader_bp) >= sizeof(struct registry_chunk) + sizeof(struct rcu_reader_bp) */
    assert(sizeof(struct registry_chunk) /*32ul*/  + (unsigned long int)8 * sizeof(struct rcu_reader_bp) /*40ul*/  >= sizeof(struct registry_chunk) /*32ul*/  + sizeof(struct rcu_reader_bp) /*40ul*/ );
    new_chunk_len = sizeof(struct registry_chunk) /*32ul*/  + (unsigned long int)8 * sizeof(struct rcu_reader_bp) /*40ul*/ ;
    void *return_value_mmap$1;
    return_value_mmap$1=mmap((void *)0, new_chunk_len, 0x1 | 0x2, 0x20 | 0x02, -1, (signed long int)0);
    new_chunk = (struct registry_chunk *)return_value_mmap$1;
    if(new_chunk == (struct registry_chunk *)-1)
      abort();

    memset((void *)new_chunk, 0, new_chunk_len);
    new_chunk->data_len = new_chunk_len - sizeof(struct registry_chunk) /*32ul*/ ;
    cds_list_add_tail(&new_chunk->node, &arena->chunk_list);
    goto __CPROVER_DUMP_L5;
  }

  last_chunk = (struct registry_chunk *)((char *)arena->chunk_list.prev - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node);
  old_chunk_len = last_chunk->data_len + sizeof(struct registry_chunk) /*32ul*/ ;
  new_chunk_len = old_chunk_len << 1;
  void *return_value_mremap_wrapper$3;
  return_value_mremap_wrapper$3=mremap_wrapper((void *)last_chunk, old_chunk_len, new_chunk_len, 0);
  new_chunk = (struct registry_chunk *)return_value_mremap_wrapper$3;
  if(!(new_chunk == (struct registry_chunk *)-1))
  {
    /* assertion new_chunk == last_chunk */
    assert(new_chunk == last_chunk);
    memset((void *)((char *)last_chunk + (signed long int)old_chunk_len), 0, new_chunk_len - old_chunk_len);
    last_chunk->data_len = new_chunk_len - sizeof(struct registry_chunk) /*32ul*/ ;
  }

  else
  {
    void *return_value_mmap$4;
    return_value_mmap$4=mmap((void *)0, new_chunk_len, 0x1 | 0x2, 0x20 | 0x02, -1, (signed long int)0);
    new_chunk = (struct registry_chunk *)return_value_mmap$4;
    if(new_chunk == (struct registry_chunk *)-1)
      abort();

    memset((void *)new_chunk, 0, new_chunk_len);
    new_chunk->data_len = new_chunk_len - sizeof(struct registry_chunk) /*32ul*/ ;
    cds_list_add_tail(&new_chunk->node, &arena->chunk_list);
  }

__CPROVER_DUMP_L5:
  ;
}

// find_chunk
// file urcu-bp.c line 493
static struct registry_chunk * find_chunk(struct rcu_reader_bp *rcu_reader_reg)
{
  struct registry_chunk *chunk = (struct registry_chunk *)((char *)(&registry_arena.chunk_list)->next - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node);
  for( ; !(&chunk->node == &registry_arena.chunk_list); chunk = (struct registry_chunk *)((char *)chunk->node.next - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node))
    if(rcu_reader_reg >= (struct rcu_reader_bp *)chunk->data)
    {
      if(!(rcu_reader_reg >= (struct rcu_reader_bp *)(chunk->data + (signed long int)chunk->data_len)))
        return chunk;

    }

  return (struct registry_chunk *)(void *)0;
}

// force_mb_all_readers
// file urcu.c line 179
static void force_mb_all_readers(void)
{
  struct rcu_reader_sig *index;
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link2(&registry$link2);
  volatile char tmp_statement_expression$2;
  volatile char tmp_statement_expression$3;
  if(return_value_cds_list_empty$1 == 0)
  {
    index = (struct rcu_reader_sig *)((char *)(&registry$link2)->next - (signed long int)(unsigned long int)&((struct rcu_reader_sig *)0)->node);
    for( ; !(&index->node == &registry$link2); index = (struct rcu_reader_sig *)((char *)index->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_sig *)0)->node))
    {
      char _v;
      *((volatile char *)&index->need_mb) = (volatile char)1;
      tmp_statement_expression$2 = *((volatile char *)&index->need_mb);
      _v = tmp_statement_expression$2;
      asm("" :  :  : "memory");
      _v = _v;
      pthread_kill(index->tid, 10);
    }
    index = (struct rcu_reader_sig *)((char *)(&registry$link2)->next - (signed long int)(unsigned long int)&((struct rcu_reader_sig *)0)->node);
    for( ; !(&index->node == &registry$link2); index = (struct rcu_reader_sig *)((char *)index->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_sig *)0)->node))
      do
      {
        asm("" :  :  : "memory");
        tmp_statement_expression$3 = *((volatile char *)&index->need_mb);
        if(tmp_statement_expression$3 == 0)
          break;

        pthread_kill(index->tid, 10);
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 1);
      }
      while((_Bool)1);
    asm("mfence" :  :  : "memory");
  }

}

// free_all_cpu_call_rcu_data
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data(void)
{
  signed int cpu;
  struct call_rcu_data **crdp;
  if(maxcpus$link3 >= 1l)
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct call_rcu_data *) /*8ul*/  * (unsigned long int)maxcpus$link3);
    crdp = (struct call_rcu_data **)return_value_malloc$1;
    if(crdp == ((struct call_rcu_data **)NULL))
    {
      static signed int warned = 0;
      if(warned == 0)
        fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

      warned = 1;
    }

    else
    {
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus$link3); cpu = cpu + 1)
      {
        crdp[(signed long int)cpu]=get_cpu_call_rcu_data_qsbr(cpu);
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          set_cpu_call_rcu_data_qsbr(cpu, (struct call_rcu_data *)(void *)0);

      }
      synchronize_rcu_qsbr();
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus$link3); cpu = cpu + 1)
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          call_rcu_data_free_qsbr(crdp[(signed long int)cpu]);

      free((void *)crdp);
    }
  }

}

// free_all_cpu_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data_bp(void)
{
  signed int cpu;
  struct call_rcu_data **crdp;
  if(maxcpus$link4 >= 1l)
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct call_rcu_data *) /*8ul*/  * (unsigned long int)maxcpus$link4);
    crdp = (struct call_rcu_data **)return_value_malloc$1;
    if(crdp == ((struct call_rcu_data **)NULL))
    {
      static signed int warned = 0;
      if(warned == 0)
        fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

      warned = 1;
    }

    else
    {
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus$link4); cpu = cpu + 1)
      {
        crdp[(signed long int)cpu]=get_cpu_call_rcu_data_bp(cpu);
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          set_cpu_call_rcu_data_bp(cpu, (struct call_rcu_data *)(void *)0);

      }
      synchronize_rcu_bp();
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus$link4); cpu = cpu + 1)
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          call_rcu_data_free_bp(crdp[(signed long int)cpu]);

      free((void *)crdp);
    }
  }

}

// free_all_cpu_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data_mb(void)
{
  signed int cpu;
  struct call_rcu_data **crdp;
  if(maxcpus$link1 >= 1l)
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct call_rcu_data *) /*8ul*/  * (unsigned long int)maxcpus$link1);
    crdp = (struct call_rcu_data **)return_value_malloc$1;
    if(crdp == ((struct call_rcu_data **)NULL))
    {
      static signed int warned = 0;
      if(warned == 0)
        fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

      warned = 1;
    }

    else
    {
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus$link1); cpu = cpu + 1)
      {
        crdp[(signed long int)cpu]=get_cpu_call_rcu_data_mb(cpu);
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          set_cpu_call_rcu_data_mb(cpu, (struct call_rcu_data *)(void *)0);

      }
      synchronize_rcu_mb();
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus$link1); cpu = cpu + 1)
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          call_rcu_data_free_mb(crdp[(signed long int)cpu]);

      free((void *)crdp);
    }
  }

}

// free_all_cpu_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data_memb(void)
{
  signed int cpu;
  struct call_rcu_data **crdp;
  if(maxcpus >= 1l)
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct call_rcu_data *) /*8ul*/  * (unsigned long int)maxcpus);
    crdp = (struct call_rcu_data **)return_value_malloc$1;
    if(crdp == ((struct call_rcu_data **)NULL))
    {
      static signed int warned = 0;
      if(warned == 0)
        fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

      warned = 1;
    }

    else
    {
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus); cpu = cpu + 1)
      {
        crdp[(signed long int)cpu]=get_cpu_call_rcu_data_memb(cpu);
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          set_cpu_call_rcu_data_memb(cpu, (struct call_rcu_data *)(void *)0);

      }
      synchronize_rcu_memb();
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus); cpu = cpu + 1)
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          call_rcu_data_free_memb(crdp[(signed long int)cpu]);

      free((void *)crdp);
    }
  }

}

// free_all_cpu_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 775
void free_all_cpu_call_rcu_data_sig(void)
{
  signed int cpu;
  struct call_rcu_data **crdp;
  if(maxcpus$link2 >= 1l)
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct call_rcu_data *) /*8ul*/  * (unsigned long int)maxcpus$link2);
    crdp = (struct call_rcu_data **)return_value_malloc$1;
    if(crdp == ((struct call_rcu_data **)NULL))
    {
      static signed int warned = 0;
      if(warned == 0)
        fprintf(stderr, "[error] liburcu: unable to allocate per-CPU pointer array\n");

      warned = 1;
    }

    else
    {
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus$link2); cpu = cpu + 1)
      {
        crdp[(signed long int)cpu]=get_cpu_call_rcu_data_sig(cpu);
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          set_cpu_call_rcu_data_sig(cpu, (struct call_rcu_data *)(void *)0);

      }
      synchronize_rcu_sig();
      cpu = 0;
      for( ; !((signed long int)cpu >= maxcpus$link2); cpu = cpu + 1)
        if(!(crdp[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
          call_rcu_data_free_sig(crdp[(signed long int)cpu]);

      free((void *)crdp);
    }
  }

}

// free_completion
// file urcu-call-rcu-impl.h line 813
static void free_completion(struct urcu_ref *ref)
{
  struct call_rcu_completion *completion;
  struct call_rcu_completion *tmp_statement_expression$1;
  const struct urcu_ref *__ptr = ref;
  tmp_statement_expression$1 = (struct call_rcu_completion *)((char *)__ptr - (signed long int)8ul);
  completion = tmp_statement_expression$1;
  free((void *)completion);
}

// free_completion$link1
// file urcu-call-rcu-impl.h line 813
static void free_completion$link1(struct urcu_ref *ref$link1)
{
  struct call_rcu_completion *completion$link1;
  struct call_rcu_completion *tmp_statement_expression$1$link1;
  const struct urcu_ref *__ptr$link1 = ref$link1;
  tmp_statement_expression$1$link1 = (struct call_rcu_completion *)((char *)__ptr$link1 - (signed long int)8ul);
  completion$link1 = tmp_statement_expression$1$link1;
  free((void *)completion$link1);
}

// free_completion$link2
// file urcu-call-rcu-impl.h line 813
static void free_completion$link2(struct urcu_ref *ref$link2)
{
  struct call_rcu_completion *completion$link2;
  struct call_rcu_completion *tmp_statement_expression$1$link2;
  const struct urcu_ref *__ptr$link2 = ref$link2;
  tmp_statement_expression$1$link2 = (struct call_rcu_completion *)((char *)__ptr$link2 - (signed long int)8ul);
  completion$link2 = tmp_statement_expression$1$link2;
  free((void *)completion$link2);
}

// free_completion$link3
// file urcu-call-rcu-impl.h line 813
static void free_completion$link3(struct urcu_ref *ref$link3)
{
  struct call_rcu_completion *completion$link3;
  struct call_rcu_completion *tmp_statement_expression$1$link3;
  const struct urcu_ref *__ptr$link3 = ref$link3;
  tmp_statement_expression$1$link3 = (struct call_rcu_completion *)((char *)__ptr$link3 - (signed long int)8ul);
  completion$link3 = tmp_statement_expression$1$link3;
  free((void *)completion$link3);
}

// free_completion$link4
// file urcu-call-rcu-impl.h line 813
static void free_completion$link4(struct urcu_ref *ref$link4)
{
  struct call_rcu_completion *completion$link4;
  struct call_rcu_completion *tmp_statement_expression$1$link4;
  const struct urcu_ref *__ptr$link4 = ref$link4;
  tmp_statement_expression$1$link4 = (struct call_rcu_completion *)((char *)__ptr$link4 - (signed long int)8ul);
  completion$link4 = tmp_statement_expression$1$link4;
  free((void *)completion$link4);
}

// futex
// file ./urcu/futex.h line 62
static inline signed int futex(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3)
{
  signed long int return_value_syscall$1;
  return_value_syscall$1=syscall((signed long int)202, uaddr, op, val, timeout, uaddr2, val3);
  return (signed int)return_value_syscall$1;
}

// futex$link1
// file ./urcu/futex.h line 62
static inline signed int futex$link1(signed int *uaddr$link1, signed int op$link1, signed int val$link1, struct timespec *timeout$link1, signed int *uaddr2$link1, signed int val3$link1)
{
  signed long int return_value_syscall$1$link1;
  return_value_syscall$1$link1=syscall((signed long int)202, uaddr$link1, op$link1, val$link1, timeout$link1, uaddr2$link1, val3$link1);
  return (signed int)return_value_syscall$1$link1;
}

// futex$link2
// file ./urcu/futex.h line 62
static inline signed int futex$link2(signed int *uaddr$link2, signed int op$link2, signed int val$link2, struct timespec *timeout$link2, signed int *uaddr2$link2, signed int val3$link2)
{
  signed long int return_value_syscall$1$link2;
  return_value_syscall$1$link2=syscall((signed long int)202, uaddr$link2, op$link2, val$link2, timeout$link2, uaddr2$link2, val3$link2);
  return (signed int)return_value_syscall$1$link2;
}

// futex$link3
// file ./urcu/futex.h line 62
static inline signed int futex$link3(signed int *uaddr$link3, signed int op$link3, signed int val$link3, struct timespec *timeout$link3, signed int *uaddr2$link3, signed int val3$link3)
{
  signed long int return_value_syscall$1$link3;
  return_value_syscall$1$link3=syscall((signed long int)202, uaddr$link3, op$link3, val$link3, timeout$link3, uaddr2$link3, val3$link3);
  return (signed int)return_value_syscall$1$link3;
}

// futex$link4
// file urcu/futex.h line 62
static inline signed int futex$link4(signed int *uaddr$link4, signed int op$link4, signed int val$link4, struct timespec *timeout$link4, signed int *uaddr2$link4, signed int val3$link4)
{
  signed long int return_value_syscall$1$link4;
  return_value_syscall$1$link4=syscall((signed long int)202, uaddr$link4, op$link4, val$link4, timeout$link4, uaddr2$link4, val3$link4);
  return (signed int)return_value_syscall$1$link4;
}

// futex_async
// file ./urcu/futex.h line 83
static inline signed int futex_async(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3)
{
  signed int ret;
  ret=futex(uaddr, op, val, timeout, uaddr2, val3);
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(!(ret >= 0))
  {
    return_value___errno_location$2=__errno_location();
    tmp_if_expr$3 = *return_value___errno_location$2 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
  {
    signed int return_value_compat_futex_async$1;
    return_value_compat_futex_async$1=compat_futex_async(uaddr, op, val, timeout, uaddr2, val3);
    return return_value_compat_futex_async$1;
  }

  return ret;
}

// futex_async$link1
// file ./urcu/futex.h line 83
static inline signed int futex_async$link1(signed int *uaddr$link1, signed int op$link1, signed int val$link1, struct timespec *timeout$link1, signed int *uaddr2$link1, signed int val3$link1)
{
  signed int ret$link1;
  ret$link1=futex$link1(uaddr$link1, op$link1, val$link1, timeout$link1, uaddr2$link1, val3$link1);
  _Bool tmp_if_expr$3$link1;
  signed int *return_value___errno_location$2$link1;
  if(!(ret$link1 >= 0))
  {
    return_value___errno_location$2$link1=__errno_location();
    tmp_if_expr$3$link1 = *return_value___errno_location$2$link1 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1 = (_Bool)0;
  if(tmp_if_expr$3$link1)
  {
    signed int return_value_compat_futex_async$1$link1;
    return_value_compat_futex_async$1$link1=compat_futex_async(uaddr$link1, op$link1, val$link1, timeout$link1, uaddr2$link1, val3$link1);
    return return_value_compat_futex_async$1$link1;
  }

  return ret$link1;
}

// futex_async$link2
// file ./urcu/futex.h line 83
static inline signed int futex_async$link2(signed int *uaddr$link2, signed int op$link2, signed int val$link2, struct timespec *timeout$link2, signed int *uaddr2$link2, signed int val3$link2)
{
  signed int ret$link2;
  ret$link2=futex$link2(uaddr$link2, op$link2, val$link2, timeout$link2, uaddr2$link2, val3$link2);
  _Bool tmp_if_expr$3$link2;
  signed int *return_value___errno_location$2$link2;
  if(!(ret$link2 >= 0))
  {
    return_value___errno_location$2$link2=__errno_location();
    tmp_if_expr$3$link2 = *return_value___errno_location$2$link2 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link2 = (_Bool)0;
  if(tmp_if_expr$3$link2)
  {
    signed int return_value_compat_futex_async$1$link2;
    return_value_compat_futex_async$1$link2=compat_futex_async(uaddr$link2, op$link2, val$link2, timeout$link2, uaddr2$link2, val3$link2);
    return return_value_compat_futex_async$1$link2;
  }

  return ret$link2;
}

// futex_async$link3
// file ./urcu/futex.h line 83
static inline signed int futex_async$link3(signed int *uaddr$link3, signed int op$link3, signed int val$link3, struct timespec *timeout$link3, signed int *uaddr2$link3, signed int val3$link3)
{
  signed int ret$link3;
  ret$link3=futex$link3(uaddr$link3, op$link3, val$link3, timeout$link3, uaddr2$link3, val3$link3);
  _Bool tmp_if_expr$3$link3;
  signed int *return_value___errno_location$2$link3;
  if(!(ret$link3 >= 0))
  {
    return_value___errno_location$2$link3=__errno_location();
    tmp_if_expr$3$link3 = *return_value___errno_location$2$link3 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link3 = (_Bool)0;
  if(tmp_if_expr$3$link3)
  {
    signed int return_value_compat_futex_async$1$link3;
    return_value_compat_futex_async$1$link3=compat_futex_async(uaddr$link3, op$link3, val$link3, timeout$link3, uaddr2$link3, val3$link3);
    return return_value_compat_futex_async$1$link3;
  }

  return ret$link3;
}

// futex_async$link4
// file urcu/futex.h line 83
static inline signed int futex_async$link4(signed int *uaddr$link4, signed int op$link4, signed int val$link4, struct timespec *timeout$link4, signed int *uaddr2$link4, signed int val3$link4)
{
  signed int ret$link4;
  ret$link4=futex$link4(uaddr$link4, op$link4, val$link4, timeout$link4, uaddr2$link4, val3$link4);
  _Bool tmp_if_expr$3$link4;
  signed int *return_value___errno_location$2$link4;
  if(!(ret$link4 >= 0))
  {
    return_value___errno_location$2$link4=__errno_location();
    tmp_if_expr$3$link4 = *return_value___errno_location$2$link4 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link4 = (_Bool)0;
  if(tmp_if_expr$3$link4)
  {
    signed int return_value_compat_futex_async$1$link4;
    return_value_compat_futex_async$1$link4=compat_futex_async(uaddr$link4, op$link4, val$link4, timeout$link4, uaddr2$link4, val3$link4);
    return return_value_compat_futex_async$1$link4;
  }

  return ret$link4;
}

// futex_noasync
// file ./urcu/futex.h line 69
static inline signed int futex_noasync(signed int *uaddr, signed int op, signed int val, struct timespec *timeout, signed int *uaddr2, signed int val3)
{
  signed int ret;
  ret=futex(uaddr, op, val, timeout, uaddr2, val3);
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(!(ret >= 0))
  {
    return_value___errno_location$2=__errno_location();
    tmp_if_expr$3 = *return_value___errno_location$2 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
  {
    signed int return_value_compat_futex_noasync$1;
    return_value_compat_futex_noasync$1=compat_futex_noasync(uaddr, op, val, timeout, uaddr2, val3);
    return return_value_compat_futex_noasync$1;
  }

  return ret;
}

// futex_noasync$link1
// file ./urcu/futex.h line 69
static inline signed int futex_noasync$link1(signed int *uaddr$link1, signed int op$link1, signed int val$link1, struct timespec *timeout$link1, signed int *uaddr2$link1, signed int val3$link1)
{
  signed int ret$link1;
  ret$link1=futex$link1(uaddr$link1, op$link1, val$link1, timeout$link1, uaddr2$link1, val3$link1);
  _Bool tmp_if_expr$3$link1;
  signed int *return_value___errno_location$2$link1;
  if(!(ret$link1 >= 0))
  {
    return_value___errno_location$2$link1=__errno_location();
    tmp_if_expr$3$link1 = *return_value___errno_location$2$link1 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1 = (_Bool)0;
  if(tmp_if_expr$3$link1)
  {
    signed int return_value_compat_futex_noasync$1$link1;
    return_value_compat_futex_noasync$1$link1=compat_futex_noasync(uaddr$link1, op$link1, val$link1, timeout$link1, uaddr2$link1, val3$link1);
    return return_value_compat_futex_noasync$1$link1;
  }

  return ret$link1;
}

// futex_noasync$link2
// file ./urcu/futex.h line 69
static inline signed int futex_noasync$link2(signed int *uaddr$link2, signed int op$link2, signed int val$link2, struct timespec *timeout$link2, signed int *uaddr2$link2, signed int val3$link2)
{
  signed int ret$link2;
  ret$link2=futex$link2(uaddr$link2, op$link2, val$link2, timeout$link2, uaddr2$link2, val3$link2);
  _Bool tmp_if_expr$3$link2;
  signed int *return_value___errno_location$2$link2;
  if(!(ret$link2 >= 0))
  {
    return_value___errno_location$2$link2=__errno_location();
    tmp_if_expr$3$link2 = *return_value___errno_location$2$link2 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link2 = (_Bool)0;
  if(tmp_if_expr$3$link2)
  {
    signed int return_value_compat_futex_noasync$1$link2;
    return_value_compat_futex_noasync$1$link2=compat_futex_noasync(uaddr$link2, op$link2, val$link2, timeout$link2, uaddr2$link2, val3$link2);
    return return_value_compat_futex_noasync$1$link2;
  }

  return ret$link2;
}

// futex_noasync$link3
// file ./urcu/futex.h line 69
static inline signed int futex_noasync$link3(signed int *uaddr$link3, signed int op$link3, signed int val$link3, struct timespec *timeout$link3, signed int *uaddr2$link3, signed int val3$link3)
{
  signed int ret$link3;
  ret$link3=futex$link3(uaddr$link3, op$link3, val$link3, timeout$link3, uaddr2$link3, val3$link3);
  _Bool tmp_if_expr$3$link3;
  signed int *return_value___errno_location$2$link3;
  if(!(ret$link3 >= 0))
  {
    return_value___errno_location$2$link3=__errno_location();
    tmp_if_expr$3$link3 = *return_value___errno_location$2$link3 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link3 = (_Bool)0;
  if(tmp_if_expr$3$link3)
  {
    signed int return_value_compat_futex_noasync$1$link3;
    return_value_compat_futex_noasync$1$link3=compat_futex_noasync(uaddr$link3, op$link3, val$link3, timeout$link3, uaddr2$link3, val3$link3);
    return return_value_compat_futex_noasync$1$link3;
  }

  return ret$link3;
}

// futex_noasync$link4
// file urcu/futex.h line 69
static inline signed int futex_noasync$link4(signed int *uaddr$link4, signed int op$link4, signed int val$link4, struct timespec *timeout$link4, signed int *uaddr2$link4, signed int val3$link4)
{
  signed int ret$link4;
  ret$link4=futex$link4(uaddr$link4, op$link4, val$link4, timeout$link4, uaddr2$link4, val3$link4);
  _Bool tmp_if_expr$3$link4;
  signed int *return_value___errno_location$2$link4;
  if(!(ret$link4 >= 0))
  {
    return_value___errno_location$2$link4=__errno_location();
    tmp_if_expr$3$link4 = *return_value___errno_location$2$link4 == 38 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link4 = (_Bool)0;
  if(tmp_if_expr$3$link4)
  {
    signed int return_value_compat_futex_noasync$1$link4;
    return_value_compat_futex_noasync$1$link4=compat_futex_noasync(uaddr$link4, op$link4, val$link4, timeout$link4, uaddr2$link4, val3$link4);
    return return_value_compat_futex_noasync$1$link4;
  }

  return ret$link4;
}

// get_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_bp(void)
{
  struct call_rcu_data *crd;
  if(!(thread_call_rcu_data$link4 == ((struct call_rcu_data *)NULL)))
    return thread_call_rcu_data$link4;

  else
  {
    if(maxcpus$link4 >= 1l)
    {
      signed int return_value_urcu_sched_getcpu$1;
      return_value_urcu_sched_getcpu$1=urcu_sched_getcpu$link4();
      crd=get_cpu_call_rcu_data_bp(return_value_urcu_sched_getcpu$1);
      if(!(crd == ((struct call_rcu_data *)NULL)))
        return crd;

    }

    struct call_rcu_data *return_value_get_default_call_rcu_data_bp$2;
    return_value_get_default_call_rcu_data_bp$2=get_default_call_rcu_data_bp();
    return return_value_get_default_call_rcu_data_bp$2;
  }
}

// get_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_mb(void)
{
  struct call_rcu_data *crd;
  if(!(thread_call_rcu_data$link1 == ((struct call_rcu_data *)NULL)))
    return thread_call_rcu_data$link1;

  else
  {
    if(maxcpus$link1 >= 1l)
    {
      signed int return_value_urcu_sched_getcpu$1;
      return_value_urcu_sched_getcpu$1=urcu_sched_getcpu$link1();
      crd=get_cpu_call_rcu_data_mb(return_value_urcu_sched_getcpu$1);
      if(!(crd == ((struct call_rcu_data *)NULL)))
        return crd;

    }

    struct call_rcu_data *return_value_get_default_call_rcu_data_mb$2;
    return_value_get_default_call_rcu_data_mb$2=get_default_call_rcu_data_mb();
    return return_value_get_default_call_rcu_data_mb$2;
  }
}

// get_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_memb(void)
{
  struct call_rcu_data *crd;
  if(!(thread_call_rcu_data == ((struct call_rcu_data *)NULL)))
    return thread_call_rcu_data;

  else
  {
    if(maxcpus >= 1l)
    {
      signed int return_value_urcu_sched_getcpu$1;
      return_value_urcu_sched_getcpu$1=urcu_sched_getcpu();
      crd=get_cpu_call_rcu_data_memb(return_value_urcu_sched_getcpu$1);
      if(!(crd == ((struct call_rcu_data *)NULL)))
        return crd;

    }

    struct call_rcu_data *return_value_get_default_call_rcu_data_memb$2;
    return_value_get_default_call_rcu_data_memb$2=get_default_call_rcu_data_memb();
    return return_value_get_default_call_rcu_data_memb$2;
  }
}

// get_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_qsbr(void)
{
  struct call_rcu_data *crd;
  if(!(thread_call_rcu_data$link3 == ((struct call_rcu_data *)NULL)))
    return thread_call_rcu_data$link3;

  else
  {
    if(maxcpus$link3 >= 1l)
    {
      signed int return_value_urcu_sched_getcpu$1;
      return_value_urcu_sched_getcpu$1=urcu_sched_getcpu$link3();
      crd=get_cpu_call_rcu_data_qsbr(return_value_urcu_sched_getcpu$1);
      if(!(crd == ((struct call_rcu_data *)NULL)))
        return crd;

    }

    struct call_rcu_data *return_value_get_default_call_rcu_data_qsbr$2;
    return_value_get_default_call_rcu_data_qsbr$2=get_default_call_rcu_data_qsbr();
    return return_value_get_default_call_rcu_data_qsbr$2;
  }
}

// get_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 578
struct call_rcu_data * get_call_rcu_data_sig(void)
{
  struct call_rcu_data *crd;
  if(!(thread_call_rcu_data$link2 == ((struct call_rcu_data *)NULL)))
    return thread_call_rcu_data$link2;

  else
  {
    if(maxcpus$link2 >= 1l)
    {
      signed int return_value_urcu_sched_getcpu$1;
      return_value_urcu_sched_getcpu$1=urcu_sched_getcpu$link2();
      crd=get_cpu_call_rcu_data_sig(return_value_urcu_sched_getcpu$1);
      if(!(crd == ((struct call_rcu_data *)NULL)))
        return crd;

    }

    struct call_rcu_data *return_value_get_default_call_rcu_data_sig$2;
    return_value_get_default_call_rcu_data_sig$2=get_default_call_rcu_data_sig();
    return return_value_get_default_call_rcu_data_sig$2;
  }
}

// get_call_rcu_thread_bp
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_bp(struct call_rcu_data *crdp)
{
  return crdp->tid;
}

// get_call_rcu_thread_mb
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_mb(struct call_rcu_data *crdp)
{
  return crdp->tid;
}

// get_call_rcu_thread_memb
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_memb(struct call_rcu_data *crdp)
{
  return crdp->tid;
}

// get_call_rcu_thread_qsbr
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_qsbr(struct call_rcu_data *crdp)
{
  return crdp->tid;
}

// get_call_rcu_thread_sig
// file urcu-call-rcu-impl.h line 472
unsigned long int get_call_rcu_thread_sig(struct call_rcu_data *crdp)
{
  return crdp->tid;
}

// get_cpu_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_bp(signed int cpu)
{
  struct call_rcu_data **pcpu_crdp;
  struct call_rcu_data **tmp_statement_expression$1;
  struct call_rcu_data **_________p1;
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&per_cpu_call_rcu_data$link4);
  _________p1 = tmp_statement_expression$2;
  tmp_statement_expression$1 = _________p1;
  pcpu_crdp = tmp_statement_expression$1;
  struct call_rcu_data *tmp_statement_expression$3;
  struct call_rcu_data * volatile tmp_statement_expression$4;
  if(pcpu_crdp == ((struct call_rcu_data **)NULL))
    return (struct call_rcu_data *)(void *)0;

  else
  {
    static signed int warned = 0;
    if(warned == 0 && maxcpus$link4 >= 1l && ((signed long int)cpu >= maxcpus$link4 || !(cpu >= 0)))
    {
      fprintf(stderr, "[error] liburcu: get CPU # out of range\n");
      warned = 1;
    }

    if((signed long int)cpu >= maxcpus$link4 || !(cpu >= 0))
      return (struct call_rcu_data *)(void *)0;

    else
    {
      struct call_rcu_data *get_cpu_call_rcu_data_bp$$1$$3$$_________p1;
      asm("" :  :  : "memory");
      tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&pcpu_crdp[(signed long int)cpu]);
      get_cpu_call_rcu_data_bp$$1$$3$$_________p1 = tmp_statement_expression$4;
      tmp_statement_expression$3 = get_cpu_call_rcu_data_bp$$1$$3$$_________p1;
      return tmp_statement_expression$3;
    }
  }
}

// get_cpu_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_mb(signed int cpu)
{
  struct call_rcu_data **pcpu_crdp;
  struct call_rcu_data **tmp_statement_expression$1;
  struct call_rcu_data **_________p1;
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&per_cpu_call_rcu_data$link1);
  _________p1 = tmp_statement_expression$2;
  tmp_statement_expression$1 = _________p1;
  pcpu_crdp = tmp_statement_expression$1;
  struct call_rcu_data *tmp_statement_expression$3;
  struct call_rcu_data * volatile tmp_statement_expression$4;
  if(pcpu_crdp == ((struct call_rcu_data **)NULL))
    return (struct call_rcu_data *)(void *)0;

  else
  {
    static signed int warned = 0;
    if(warned == 0 && maxcpus$link1 >= 1l && ((signed long int)cpu >= maxcpus$link1 || !(cpu >= 0)))
    {
      fprintf(stderr, "[error] liburcu: get CPU # out of range\n");
      warned = 1;
    }

    if((signed long int)cpu >= maxcpus$link1 || !(cpu >= 0))
      return (struct call_rcu_data *)(void *)0;

    else
    {
      struct call_rcu_data *get_cpu_call_rcu_data_mb$$1$$3$$_________p1;
      asm("" :  :  : "memory");
      tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&pcpu_crdp[(signed long int)cpu]);
      get_cpu_call_rcu_data_mb$$1$$3$$_________p1 = tmp_statement_expression$4;
      tmp_statement_expression$3 = get_cpu_call_rcu_data_mb$$1$$3$$_________p1;
      return tmp_statement_expression$3;
    }
  }
}

// get_cpu_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_memb(signed int cpu)
{
  struct call_rcu_data **pcpu_crdp;
  struct call_rcu_data **tmp_statement_expression$1;
  struct call_rcu_data **_________p1;
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&per_cpu_call_rcu_data);
  _________p1 = tmp_statement_expression$2;
  tmp_statement_expression$1 = _________p1;
  pcpu_crdp = tmp_statement_expression$1;
  struct call_rcu_data *tmp_statement_expression$3;
  struct call_rcu_data * volatile tmp_statement_expression$4;
  if(pcpu_crdp == ((struct call_rcu_data **)NULL))
    return (struct call_rcu_data *)(void *)0;

  else
  {
    static signed int warned = 0;
    if(warned == 0 && maxcpus >= 1l && ((signed long int)cpu >= maxcpus || !(cpu >= 0)))
    {
      fprintf(stderr, "[error] liburcu: get CPU # out of range\n");
      warned = 1;
    }

    if((signed long int)cpu >= maxcpus || !(cpu >= 0))
      return (struct call_rcu_data *)(void *)0;

    else
    {
      struct call_rcu_data *get_cpu_call_rcu_data_memb$$1$$3$$_________p1;
      asm("" :  :  : "memory");
      tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&pcpu_crdp[(signed long int)cpu]);
      get_cpu_call_rcu_data_memb$$1$$3$$_________p1 = tmp_statement_expression$4;
      tmp_statement_expression$3 = get_cpu_call_rcu_data_memb$$1$$3$$_________p1;
      return tmp_statement_expression$3;
    }
  }
}

// get_cpu_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_qsbr(signed int cpu)
{
  struct call_rcu_data **pcpu_crdp;
  struct call_rcu_data **tmp_statement_expression$1;
  struct call_rcu_data **_________p1;
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&per_cpu_call_rcu_data$link3);
  _________p1 = tmp_statement_expression$2;
  tmp_statement_expression$1 = _________p1;
  pcpu_crdp = tmp_statement_expression$1;
  struct call_rcu_data *tmp_statement_expression$3;
  struct call_rcu_data * volatile tmp_statement_expression$4;
  if(pcpu_crdp == ((struct call_rcu_data **)NULL))
    return (struct call_rcu_data *)(void *)0;

  else
  {
    static signed int warned = 0;
    if(warned == 0 && maxcpus$link3 >= 1l && ((signed long int)cpu >= maxcpus$link3 || !(cpu >= 0)))
    {
      fprintf(stderr, "[error] liburcu: get CPU # out of range\n");
      warned = 1;
    }

    if((signed long int)cpu >= maxcpus$link3 || !(cpu >= 0))
      return (struct call_rcu_data *)(void *)0;

    else
    {
      struct call_rcu_data *get_cpu_call_rcu_data_qsbr$$1$$3$$_________p1;
      asm("" :  :  : "memory");
      tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&pcpu_crdp[(signed long int)cpu]);
      get_cpu_call_rcu_data_qsbr$$1$$3$$_________p1 = tmp_statement_expression$4;
      tmp_statement_expression$3 = get_cpu_call_rcu_data_qsbr$$1$$3$$_________p1;
      return tmp_statement_expression$3;
    }
  }
}

// get_cpu_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 450
struct call_rcu_data * get_cpu_call_rcu_data_sig(signed int cpu)
{
  struct call_rcu_data **pcpu_crdp;
  struct call_rcu_data **tmp_statement_expression$1;
  struct call_rcu_data **_________p1;
  struct call_rcu_data ** volatile tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((struct call_rcu_data ** volatile *)&per_cpu_call_rcu_data$link2);
  _________p1 = tmp_statement_expression$2;
  tmp_statement_expression$1 = _________p1;
  pcpu_crdp = tmp_statement_expression$1;
  struct call_rcu_data *tmp_statement_expression$3;
  struct call_rcu_data * volatile tmp_statement_expression$4;
  if(pcpu_crdp == ((struct call_rcu_data **)NULL))
    return (struct call_rcu_data *)(void *)0;

  else
  {
    static signed int warned = 0;
    if(warned == 0 && maxcpus$link2 >= 1l && ((signed long int)cpu >= maxcpus$link2 || !(cpu >= 0)))
    {
      fprintf(stderr, "[error] liburcu: get CPU # out of range\n");
      warned = 1;
    }

    if((signed long int)cpu >= maxcpus$link2 || !(cpu >= 0))
      return (struct call_rcu_data *)(void *)0;

    else
    {
      struct call_rcu_data *get_cpu_call_rcu_data_sig$$1$$3$$_________p1;
      asm("" :  :  : "memory");
      tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&pcpu_crdp[(signed long int)cpu]);
      get_cpu_call_rcu_data_sig$$1$$3$$_________p1 = tmp_statement_expression$4;
      tmp_statement_expression$3 = get_cpu_call_rcu_data_sig$$1$$3$$_________p1;
      return tmp_statement_expression$3;
    }
  }
}

// get_default_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_bp(void)
{
  struct call_rcu_data *tmp_statement_expression$1;
  struct call_rcu_data * volatile tmp_statement_expression$2;
  if(!(default_call_rcu_data$link4 == ((struct call_rcu_data *)NULL)))
  {
    struct call_rcu_data *_________p1;
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((struct call_rcu_data * volatile *)&default_call_rcu_data$link4);
    _________p1 = tmp_statement_expression$2;
    tmp_statement_expression$1 = _________p1;
    return tmp_statement_expression$1;
  }

  else
  {
    call_rcu_lock$link4(&call_rcu_mutex$link4);
    if(!(default_call_rcu_data$link4 == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock$link4(&call_rcu_mutex$link4);
      return default_call_rcu_data$link4;
    }

    else
    {
      call_rcu_data_init$link4(&default_call_rcu_data$link4, (unsigned long int)0, -1);
      call_rcu_unlock$link4(&call_rcu_mutex$link4);
      return default_call_rcu_data$link4;
    }
  }
}

// get_default_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_mb(void)
{
  struct call_rcu_data *tmp_statement_expression$1;
  struct call_rcu_data * volatile tmp_statement_expression$2;
  if(!(default_call_rcu_data$link1 == ((struct call_rcu_data *)NULL)))
  {
    struct call_rcu_data *_________p1;
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((struct call_rcu_data * volatile *)&default_call_rcu_data$link1);
    _________p1 = tmp_statement_expression$2;
    tmp_statement_expression$1 = _________p1;
    return tmp_statement_expression$1;
  }

  else
  {
    call_rcu_lock$link1(&call_rcu_mutex$link1);
    if(!(default_call_rcu_data$link1 == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock$link1(&call_rcu_mutex$link1);
      return default_call_rcu_data$link1;
    }

    else
    {
      call_rcu_data_init$link1(&default_call_rcu_data$link1, (unsigned long int)0, -1);
      call_rcu_unlock$link1(&call_rcu_mutex$link1);
      return default_call_rcu_data$link1;
    }
  }
}

// get_default_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_memb(void)
{
  struct call_rcu_data *tmp_statement_expression$1;
  struct call_rcu_data * volatile tmp_statement_expression$2;
  if(!(default_call_rcu_data == ((struct call_rcu_data *)NULL)))
  {
    struct call_rcu_data *_________p1;
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((struct call_rcu_data * volatile *)&default_call_rcu_data);
    _________p1 = tmp_statement_expression$2;
    tmp_statement_expression$1 = _________p1;
    return tmp_statement_expression$1;
  }

  else
  {
    call_rcu_lock(&call_rcu_mutex);
    if(!(default_call_rcu_data == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock(&call_rcu_mutex);
      return default_call_rcu_data;
    }

    else
    {
      call_rcu_data_init(&default_call_rcu_data, (unsigned long int)0, -1);
      call_rcu_unlock(&call_rcu_mutex);
      return default_call_rcu_data;
    }
  }
}

// get_default_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_qsbr(void)
{
  struct call_rcu_data *tmp_statement_expression$1;
  struct call_rcu_data * volatile tmp_statement_expression$2;
  if(!(default_call_rcu_data$link3 == ((struct call_rcu_data *)NULL)))
  {
    struct call_rcu_data *_________p1;
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((struct call_rcu_data * volatile *)&default_call_rcu_data$link3);
    _________p1 = tmp_statement_expression$2;
    tmp_statement_expression$1 = _________p1;
    return tmp_statement_expression$1;
  }

  else
  {
    call_rcu_lock$link3(&call_rcu_mutex$link3);
    if(!(default_call_rcu_data$link3 == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock$link3(&call_rcu_mutex$link3);
      return default_call_rcu_data$link3;
    }

    else
    {
      call_rcu_data_init$link3(&default_call_rcu_data$link3, (unsigned long int)0, -1);
      call_rcu_unlock$link3(&call_rcu_mutex$link3);
      return default_call_rcu_data$link3;
    }
  }
}

// get_default_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 553
struct call_rcu_data * get_default_call_rcu_data_sig(void)
{
  struct call_rcu_data *tmp_statement_expression$1;
  struct call_rcu_data * volatile tmp_statement_expression$2;
  if(!(default_call_rcu_data$link2 == ((struct call_rcu_data *)NULL)))
  {
    struct call_rcu_data *_________p1;
    asm("" :  :  : "memory");
    tmp_statement_expression$2 = *((struct call_rcu_data * volatile *)&default_call_rcu_data$link2);
    _________p1 = tmp_statement_expression$2;
    tmp_statement_expression$1 = _________p1;
    return tmp_statement_expression$1;
  }

  else
  {
    call_rcu_lock$link2(&call_rcu_mutex$link2);
    if(!(default_call_rcu_data$link2 == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock$link2(&call_rcu_mutex$link2);
      return default_call_rcu_data$link2;
    }

    else
    {
      call_rcu_data_init$link2(&default_call_rcu_data$link2, (unsigned long int)0, -1);
      call_rcu_unlock$link2(&call_rcu_mutex$link2);
      return default_call_rcu_data$link2;
    }
  }
}

// get_thread_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_bp(void)
{
  return thread_call_rcu_data$link4;
}

// get_thread_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_mb(void)
{
  return thread_call_rcu_data$link1;
}

// get_thread_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_memb(void)
{
  return thread_call_rcu_data;
}

// get_thread_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_qsbr(void)
{
  return thread_call_rcu_data$link3;
}

// get_thread_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 598
struct call_rcu_data * get_thread_call_rcu_data_sig(void)
{
  return thread_call_rcu_data$link2;
}

// main
// file test_urcu_multiflavor.c line 28
signed int main(signed int argc, char **argv)
{
  plan_tests((unsigned int)5);
  signed int return_value_test_mf_memb$1;
  return_value_test_mf_memb$1=test_mf_memb();
  if(return_value_test_mf_memb$1 == 0)
    _gen_result(1, "main", "test_urcu_multiflavor.c", (unsigned int)32, "%s", (const void *)"!test_mf_memb()");

  else
    _gen_result(0, "main", "test_urcu_multiflavor.c", (unsigned int)32, "%s", (const void *)"!test_mf_memb()");
  signed int return_value_test_mf_mb$2;
  return_value_test_mf_mb$2=test_mf_mb();
  if(return_value_test_mf_mb$2 == 0)
    _gen_result(1, "main", "test_urcu_multiflavor.c", (unsigned int)34, "%s", (const void *)"!test_mf_mb()");

  else
    _gen_result(0, "main", "test_urcu_multiflavor.c", (unsigned int)34, "%s", (const void *)"!test_mf_mb()");
  signed int return_value_test_mf_signal$3;
  return_value_test_mf_signal$3=test_mf_signal();
  if(return_value_test_mf_signal$3 == 0)
    _gen_result(1, "main", "test_urcu_multiflavor.c", (unsigned int)35, "%s", (const void *)"!test_mf_signal()");

  else
    _gen_result(0, "main", "test_urcu_multiflavor.c", (unsigned int)35, "%s", (const void *)"!test_mf_signal()");
  signed int return_value_test_mf_qsbr$4;
  return_value_test_mf_qsbr$4=test_mf_qsbr();
  if(return_value_test_mf_qsbr$4 == 0)
    _gen_result(1, "main", "test_urcu_multiflavor.c", (unsigned int)36, "%s", (const void *)"!test_mf_qsbr()");

  else
    _gen_result(0, "main", "test_urcu_multiflavor.c", (unsigned int)36, "%s", (const void *)"!test_mf_qsbr()");
  signed int return_value_test_mf_bp$5;
  return_value_test_mf_bp$5=test_mf_bp();
  if(return_value_test_mf_bp$5 == 0)
    _gen_result(1, "main", "test_urcu_multiflavor.c", (unsigned int)37, "%s", (const void *)"!test_mf_bp()");

  else
    _gen_result(0, "main", "test_urcu_multiflavor.c", (unsigned int)37, "%s", (const void *)"!test_mf_bp()");
  signed int return_value_exit_status$6;
  return_value_exit_status$6=exit_status();
  return return_value_exit_status$6;
}

// maxcpus_reset
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset(void)
{
  maxcpus = (signed long int)0;
}

// maxcpus_reset$link1
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset$link1(void)
{
  maxcpus$link1 = (signed long int)0;
}

// maxcpus_reset$link2
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset$link2(void)
{
  maxcpus$link2 = (signed long int)0;
}

// maxcpus_reset$link3
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset$link3(void)
{
  maxcpus$link3 = (signed long int)0;
}

// maxcpus_reset$link4
// file urcu-call-rcu-impl.h line 123
static void maxcpus_reset$link4(void)
{
  maxcpus$link4 = (signed long int)0;
}

// mremap_wrapper
// file urcu-bp.c line 59
static void * mremap_wrapper(void *old_address, unsigned long int old_size, unsigned long int new_size, signed int flags)
{
  void *return_value_mremap$1;
  return_value_mremap$1=mremap(old_address, old_size, new_size, flags);
  return return_value_mremap$1;
}

// mutex_lock
// file urcu.c line 130
static void mutex_lock(union anonymous$0 *mutex)
{
  signed int ret;
  ret=pthread_mutex_lock(mutex);
  if(!(ret == 0))
    do
    {
      char *return_value_strerror$1;
      return_value_strerror$1=strerror(ret);
      fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock", 137, return_value_strerror$1);
      abort();
    }
    while((_Bool)0);

}

// mutex_lock$link1
// file urcu.c line 130
static void mutex_lock$link1(union anonymous$0 *mutex$link1)
{
  signed int ret$link1;
  ret$link1=pthread_mutex_lock(mutex$link1);
  if(!(ret$link1 == 0))
    do
    {
      char *return_value_strerror$1$link1;
      return_value_strerror$1$link1=strerror(ret$link1);
      fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock", 137, return_value_strerror$1$link1);
      abort();
    }
    while((_Bool)0);

}

// mutex_lock$link2
// file urcu.c line 130
static void mutex_lock$link2(union anonymous$0 *mutex$link2)
{
  signed int ret$link2;
  ret$link2=pthread_mutex_lock(mutex$link2);
  if(!(ret$link2 == 0))
    do
    {
      char *return_value_strerror$1$link2;
      return_value_strerror$1$link2=strerror(ret$link2);
      fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock", 137, return_value_strerror$1$link2);
      abort();
    }
    while((_Bool)0);

}

// mutex_lock$link3
// file urcu-qsbr.c line 91
static void mutex_lock$link3(union anonymous$0 *mutex$link3)
{
  signed int ret$link3;
  ret$link3=pthread_mutex_lock(mutex$link3);
  if(!(ret$link3 == 0))
    do
    {
      char *return_value_strerror$1$link3;
      return_value_strerror$1$link3=strerror(ret$link3);
      fprintf(stderr, "(urcu-qsbr.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock", 98, return_value_strerror$1$link3);
      abort();
    }
    while((_Bool)0);

}

// mutex_lock$link4
// file urcu-bp.c line 166
static void mutex_lock$link4(union anonymous$0 *mutex$link4)
{
  signed int ret$link4;
  ret$link4=pthread_mutex_lock(mutex$link4);
  if(!(ret$link4 == 0))
    do
    {
      char *return_value_strerror$1$link4;
      return_value_strerror$1$link4=strerror(ret$link4);
      fprintf(stderr, "(urcu-bp.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock", 173, return_value_strerror$1$link4);
      abort();
    }
    while((_Bool)0);

}

// mutex_lock_defer
// file urcu-defer-impl.h line 133
static void mutex_lock_defer(union anonymous$0 *mutex)
{
  signed int ret;
  ret=pthread_mutex_lock(mutex);
  if(!(ret == 0))
    do
    {
      char *return_value_strerror$1;
      return_value_strerror$1=strerror(ret);
      fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock_defer", 140, return_value_strerror$1);
      abort();
    }
    while((_Bool)0);

}

// mutex_lock_defer$link1
// file urcu-defer-impl.h line 133
static void mutex_lock_defer$link1(union anonymous$0 *mutex$link1)
{
  signed int ret$link1;
  ret$link1=pthread_mutex_lock(mutex$link1);
  if(!(ret$link1 == 0))
    do
    {
      char *return_value_strerror$1$link1;
      return_value_strerror$1$link1=strerror(ret$link1);
      fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock_defer", 140, return_value_strerror$1$link1);
      abort();
    }
    while((_Bool)0);

}

// mutex_lock_defer$link2
// file urcu-defer-impl.h line 133
static void mutex_lock_defer$link2(union anonymous$0 *mutex$link2)
{
  signed int ret$link2;
  ret$link2=pthread_mutex_lock(mutex$link2);
  if(!(ret$link2 == 0))
    do
    {
      char *return_value_strerror$1$link2;
      return_value_strerror$1$link2=strerror(ret$link2);
      fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock_defer", 140, return_value_strerror$1$link2);
      abort();
    }
    while((_Bool)0);

}

// mutex_lock_defer$link3
// file urcu-defer-impl.h line 133
static void mutex_lock_defer$link3(union anonymous$0 *mutex$link3)
{
  signed int ret$link3;
  ret$link3=pthread_mutex_lock(mutex$link3);
  if(!(ret$link3 == 0))
    do
    {
      char *return_value_strerror$1$link3;
      return_value_strerror$1$link3=strerror(ret$link3);
      fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock_defer", 140, return_value_strerror$1$link3);
      abort();
    }
    while((_Bool)0);

}

// mutex_lock_defer$link4
// file urcu-defer-impl.h line 133
static void mutex_lock_defer$link4(union anonymous$0 *mutex$link4)
{
  signed int ret$link4;
  ret$link4=pthread_mutex_lock(mutex$link4);
  if(!(ret$link4 == 0))
    do
    {
      char *return_value_strerror$1$link4;
      return_value_strerror$1$link4=strerror(ret$link4);
      fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_lock_defer", 140, return_value_strerror$1$link4);
      abort();
    }
    while((_Bool)0);

}

// mutex_unlock
// file urcu.c line 152
static void mutex_unlock(union anonymous$0 *mutex)
{
  signed int ret;
  ret=pthread_mutex_unlock(mutex);
  if(!(ret == 0))
    do
    {
      char *return_value_strerror$1;
      return_value_strerror$1=strerror(ret);
      fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_unlock", 158, return_value_strerror$1);
      abort();
    }
    while((_Bool)0);

}

// mutex_unlock$link1
// file urcu.c line 152
static void mutex_unlock$link1(union anonymous$0 *mutex$link1)
{
  signed int ret$link1;
  ret$link1=pthread_mutex_unlock(mutex$link1);
  if(!(ret$link1 == 0))
    do
    {
      char *return_value_strerror$1$link1;
      return_value_strerror$1$link1=strerror(ret$link1);
      fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_unlock", 158, return_value_strerror$1$link1);
      abort();
    }
    while((_Bool)0);

}

// mutex_unlock$link2
// file urcu.c line 152
static void mutex_unlock$link2(union anonymous$0 *mutex$link2)
{
  signed int ret$link2;
  ret$link2=pthread_mutex_unlock(mutex$link2);
  if(!(ret$link2 == 0))
    do
    {
      char *return_value_strerror$1$link2;
      return_value_strerror$1$link2=strerror(ret$link2);
      fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_unlock", 158, return_value_strerror$1$link2);
      abort();
    }
    while((_Bool)0);

}

// mutex_unlock$link3
// file urcu-qsbr.c line 108
static void mutex_unlock$link3(union anonymous$0 *mutex$link3)
{
  signed int ret$link3;
  ret$link3=pthread_mutex_unlock(mutex$link3);
  if(!(ret$link3 == 0))
    do
    {
      char *return_value_strerror$1$link3;
      return_value_strerror$1$link3=strerror(ret$link3);
      fprintf(stderr, "(urcu-qsbr.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_unlock", 114, return_value_strerror$1$link3);
      abort();
    }
    while((_Bool)0);

}

// mutex_unlock$link4
// file urcu-bp.c line 183
static void mutex_unlock$link4(union anonymous$0 *mutex$link4)
{
  signed int ret$link4;
  ret$link4=pthread_mutex_unlock(mutex$link4);
  if(!(ret$link4 == 0))
    do
    {
      char *return_value_strerror$1$link4;
      return_value_strerror$1$link4=strerror(ret$link4);
      fprintf(stderr, "(urcu-bp.c:%s@%u) Unrecoverable error: %s\n", (const void *)"mutex_unlock", 189, return_value_strerror$1$link4);
      abort();
    }
    while((_Bool)0);

}

// plan_no_plan
// file tap.c line 191
signed int plan_no_plan(void)
{
  _tap_init();
  if(!(have_plan == 0))
  {
    fprintf(stderr, "You tried to plan twice!\n");
    test_died = 1;
    exit(255);
  }

  have_plan = 1;
  no_plan = 1;
  return 1;
}

// plan_skip_all
// file tap.c line 217
signed int plan_skip_all(char *reason)
{
  _tap_init();
  skip_all = 1;
  printf("1..0");
  if(!(reason == ((char *)NULL)))
    printf(" # Skip %s", reason);

  printf("\n");
  exit(0);
}

// plan_tests
// file ../../tests/utils/tap.h line 80
signed int plan_tests(unsigned int tests)
{
  _tap_init();
  if(!(have_plan == 0))
  {
    fprintf(stderr, "You tried to plan twice!\n");
    test_died = 1;
    exit(255);
  }

  if(tests == 0u)
  {
    fprintf(stderr, "You said to run 0 tests!  You've got to run something.\n");
    test_died = 1;
    exit(255);
  }

  have_plan = 1;
  _expected_tests(tests);
  return (signed int)e_tests;
}

// rcu_barrier_bp
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_bp(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_completion *completion;
  signed int count = 0;
  signed int was_online;
  was_online=_rcu_read_ongoing_bp();
  if(!(was_online == 0))
    rcu_thread_offline$link3();

  signed int return_value__rcu_read_ongoing_bp$1;
  return_value__rcu_read_ongoing_bp$1=_rcu_read_ongoing_bp();
  void *return_value_calloc$2;
  volatile signed int tmp_statement_expression$8;
  if(!(return_value__rcu_read_ongoing_bp$1 == 0))
  {
    static signed int warned = 0;
    if(warned == 0)
      fprintf(stderr, "[error] liburcu: rcu_barrier() called from within RCU read-side critical section.\n");

    warned = 1;
  }

  else
  {
    return_value_calloc$2=calloc(sizeof(struct call_rcu_completion) /*16ul*/ , (unsigned long int)1);
    completion = (struct call_rcu_completion *)return_value_calloc$2;
    if(completion == ((struct call_rcu_completion *)NULL))
      do
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_bp", 865, return_value_strerror$4);
        abort();
      }
      while((_Bool)0);

    call_rcu_lock$link4(&call_rcu_mutex$link4);
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link4)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link4); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
      count = count + 1;
    urcu_ref_set$link4(&completion->ref, (signed long int)(count + 1));
    completion->barrier_count = count;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link4)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link4); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      struct call_rcu_completion_work *work;
      void *return_value_calloc$5;
      return_value_calloc$5=calloc(sizeof(struct call_rcu_completion_work) /*24ul*/ , (unsigned long int)1);
      work = (struct call_rcu_completion_work *)return_value_calloc$5;
      if(work == ((struct call_rcu_completion_work *)NULL))
        do
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_bp", 880, return_value_strerror$7);
          abort();
        }
        while((_Bool)0);

      work->completion = completion;
      _call_rcu$link4(&work->head, _rcu_barrier_complete$link4, crdp);
    }
    call_rcu_unlock$link4(&call_rcu_mutex$link4);
    do
    {
      __uatomic_dec$link4((void *)&completion->futex, (signed int)sizeof(signed int) /*4ul*/ );
      asm("mfence" :  :  : "memory");
      asm("" :  :  : "memory");
      tmp_statement_expression$8 = *((volatile signed int *)&(*(&completion->barrier_count)));
      if(tmp_statement_expression$8 == 0)
        break;

      call_rcu_completion_wait$link4(completion);
    }
    while((_Bool)1);
    urcu_ref_put$link4(&completion->ref, free_completion$link4);
  }

online:
  ;
  if(!(was_online == 0))
    rcu_thread_online$link3();

}

// rcu_barrier_mb
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_mb(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_completion *completion;
  signed int count = 0;
  signed int was_online;
  was_online=_rcu_read_ongoing_mb();
  if(!(was_online == 0))
    rcu_thread_offline$link1();

  signed int return_value__rcu_read_ongoing_mb$1;
  return_value__rcu_read_ongoing_mb$1=_rcu_read_ongoing_mb();
  void *return_value_calloc$2;
  volatile signed int tmp_statement_expression$8;
  if(!(return_value__rcu_read_ongoing_mb$1 == 0))
  {
    static signed int warned = 0;
    if(warned == 0)
      fprintf(stderr, "[error] liburcu: rcu_barrier() called from within RCU read-side critical section.\n");

    warned = 1;
  }

  else
  {
    return_value_calloc$2=calloc(sizeof(struct call_rcu_completion) /*16ul*/ , (unsigned long int)1);
    completion = (struct call_rcu_completion *)return_value_calloc$2;
    if(completion == ((struct call_rcu_completion *)NULL))
      do
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_mb", 865, return_value_strerror$4);
        abort();
      }
      while((_Bool)0);

    call_rcu_lock$link1(&call_rcu_mutex$link1);
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link1)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link1); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
      count = count + 1;
    urcu_ref_set$link1(&completion->ref, (signed long int)(count + 1));
    completion->barrier_count = count;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link1)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link1); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      struct call_rcu_completion_work *work;
      void *return_value_calloc$5;
      return_value_calloc$5=calloc(sizeof(struct call_rcu_completion_work) /*24ul*/ , (unsigned long int)1);
      work = (struct call_rcu_completion_work *)return_value_calloc$5;
      if(work == ((struct call_rcu_completion_work *)NULL))
        do
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_mb", 880, return_value_strerror$7);
          abort();
        }
        while((_Bool)0);

      work->completion = completion;
      _call_rcu$link1(&work->head, _rcu_barrier_complete$link1, crdp);
    }
    call_rcu_unlock$link1(&call_rcu_mutex$link1);
    do
    {
      __uatomic_dec$link1((void *)&completion->futex, (signed int)sizeof(signed int) /*4ul*/ );
      asm("mfence" :  :  : "memory");
      asm("" :  :  : "memory");
      tmp_statement_expression$8 = *((volatile signed int *)&(*(&completion->barrier_count)));
      if(tmp_statement_expression$8 == 0)
        break;

      call_rcu_completion_wait$link1(completion);
    }
    while((_Bool)1);
    urcu_ref_put$link1(&completion->ref, free_completion$link1);
  }

online:
  ;
  if(!(was_online == 0))
    rcu_thread_online$link1();

}

// rcu_barrier_memb
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_memb(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_completion *completion;
  signed int count = 0;
  signed int was_online;
  was_online=_rcu_read_ongoing_memb();
  if(!(was_online == 0))
    rcu_thread_offline();

  signed int return_value__rcu_read_ongoing_memb$1;
  return_value__rcu_read_ongoing_memb$1=_rcu_read_ongoing_memb();
  void *return_value_calloc$2;
  volatile signed int tmp_statement_expression$8;
  if(!(return_value__rcu_read_ongoing_memb$1 == 0))
  {
    static signed int warned = 0;
    if(warned == 0)
      fprintf(stderr, "[error] liburcu: rcu_barrier() called from within RCU read-side critical section.\n");

    warned = 1;
  }

  else
  {
    return_value_calloc$2=calloc(sizeof(struct call_rcu_completion) /*16ul*/ , (unsigned long int)1);
    completion = (struct call_rcu_completion *)return_value_calloc$2;
    if(completion == ((struct call_rcu_completion *)NULL))
      do
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_memb", 865, return_value_strerror$4);
        abort();
      }
      while((_Bool)0);

    call_rcu_lock(&call_rcu_mutex);
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
      count = count + 1;
    urcu_ref_set(&completion->ref, (signed long int)(count + 1));
    completion->barrier_count = count;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      struct call_rcu_completion_work *work;
      void *return_value_calloc$5;
      return_value_calloc$5=calloc(sizeof(struct call_rcu_completion_work) /*24ul*/ , (unsigned long int)1);
      work = (struct call_rcu_completion_work *)return_value_calloc$5;
      if(work == ((struct call_rcu_completion_work *)NULL))
        do
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_memb", 880, return_value_strerror$7);
          abort();
        }
        while((_Bool)0);

      work->completion = completion;
      _call_rcu(&work->head, _rcu_barrier_complete, crdp);
    }
    call_rcu_unlock(&call_rcu_mutex);
    do
    {
      __uatomic_dec((void *)&completion->futex, (signed int)sizeof(signed int) /*4ul*/ );
      asm("mfence" :  :  : "memory");
      asm("" :  :  : "memory");
      tmp_statement_expression$8 = *((volatile signed int *)&(*(&completion->barrier_count)));
      if(tmp_statement_expression$8 == 0)
        break;

      call_rcu_completion_wait(completion);
    }
    while((_Bool)1);
    urcu_ref_put(&completion->ref, free_completion);
  }

online:
  ;
  if(!(was_online == 0))
    rcu_thread_online();

}

// rcu_barrier_qsbr
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_qsbr(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_completion *completion;
  signed int count = 0;
  signed int was_online;
  was_online=_rcu_read_ongoing_qsbr();
  if(!(was_online == 0))
    rcu_thread_offline_qsbr();

  signed int return_value__rcu_read_ongoing_qsbr$1;
  return_value__rcu_read_ongoing_qsbr$1=_rcu_read_ongoing_qsbr();
  void *return_value_calloc$2;
  volatile signed int tmp_statement_expression$8;
  if(!(return_value__rcu_read_ongoing_qsbr$1 == 0))
  {
    static signed int warned = 0;
    if(warned == 0)
      fprintf(stderr, "[error] liburcu: rcu_barrier() called from within RCU read-side critical section.\n");

    warned = 1;
  }

  else
  {
    return_value_calloc$2=calloc(sizeof(struct call_rcu_completion) /*16ul*/ , (unsigned long int)1);
    completion = (struct call_rcu_completion *)return_value_calloc$2;
    if(completion == ((struct call_rcu_completion *)NULL))
      do
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_qsbr", 865, return_value_strerror$4);
        abort();
      }
      while((_Bool)0);

    call_rcu_lock$link3(&call_rcu_mutex$link3);
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link3)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link3); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
      count = count + 1;
    urcu_ref_set$link3(&completion->ref, (signed long int)(count + 1));
    completion->barrier_count = count;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link3)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link3); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      struct call_rcu_completion_work *work;
      void *return_value_calloc$5;
      return_value_calloc$5=calloc(sizeof(struct call_rcu_completion_work) /*24ul*/ , (unsigned long int)1);
      work = (struct call_rcu_completion_work *)return_value_calloc$5;
      if(work == ((struct call_rcu_completion_work *)NULL))
        do
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_qsbr", 880, return_value_strerror$7);
          abort();
        }
        while((_Bool)0);

      work->completion = completion;
      _call_rcu$link3(&work->head, _rcu_barrier_complete$link3, crdp);
    }
    call_rcu_unlock$link3(&call_rcu_mutex$link3);
    do
    {
      __uatomic_dec$link3((void *)&completion->futex, (signed int)sizeof(signed int) /*4ul*/ );
      asm("mfence" :  :  : "memory");
      asm("" :  :  : "memory");
      tmp_statement_expression$8 = *((volatile signed int *)&(*(&completion->barrier_count)));
      if(tmp_statement_expression$8 == 0)
        break;

      call_rcu_completion_wait$link3(completion);
    }
    while((_Bool)1);
    urcu_ref_put$link3(&completion->ref, free_completion$link3);
  }

online:
  ;
  if(!(was_online == 0))
    rcu_thread_online_qsbr();

}

// rcu_barrier_sig
// file urcu-call-rcu-impl.h line 838
void rcu_barrier_sig(void)
{
  struct call_rcu_data *crdp;
  struct call_rcu_completion *completion;
  signed int count = 0;
  signed int was_online;
  was_online=_rcu_read_ongoing_sig();
  if(!(was_online == 0))
    rcu_thread_offline$link2();

  signed int return_value__rcu_read_ongoing_sig$1;
  return_value__rcu_read_ongoing_sig$1=_rcu_read_ongoing_sig();
  void *return_value_calloc$2;
  volatile signed int tmp_statement_expression$8;
  if(!(return_value__rcu_read_ongoing_sig$1 == 0))
  {
    static signed int warned = 0;
    if(warned == 0)
      fprintf(stderr, "[error] liburcu: rcu_barrier() called from within RCU read-side critical section.\n");

    warned = 1;
  }

  else
  {
    return_value_calloc$2=calloc(sizeof(struct call_rcu_completion) /*16ul*/ , (unsigned long int)1);
    completion = (struct call_rcu_completion *)return_value_calloc$2;
    if(completion == ((struct call_rcu_completion *)NULL))
      do
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_sig", 865, return_value_strerror$4);
        abort();
      }
      while((_Bool)0);

    call_rcu_lock$link2(&call_rcu_mutex$link2);
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link2)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link2); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
      count = count + 1;
    urcu_ref_set$link2(&completion->ref, (signed long int)(count + 1));
    completion->barrier_count = count;
    crdp = (struct call_rcu_data *)((char *)(&call_rcu_data_list$link2)->next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list);
    for( ; !(&crdp->list == &call_rcu_data_list$link2); crdp = (struct call_rcu_data *)((char *)crdp->list.next - (signed long int)(unsigned long int)&((struct call_rcu_data *)0)->list))
    {
      struct call_rcu_completion_work *work;
      void *return_value_calloc$5;
      return_value_calloc$5=calloc(sizeof(struct call_rcu_completion_work) /*24ul*/ , (unsigned long int)1);
      work = (struct call_rcu_completion_work *)return_value_calloc$5;
      if(work == ((struct call_rcu_completion_work *)NULL))
        do
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          fprintf(stderr, "(urcu-call-rcu-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_barrier_sig", 880, return_value_strerror$7);
          abort();
        }
        while((_Bool)0);

      work->completion = completion;
      _call_rcu$link2(&work->head, _rcu_barrier_complete$link2, crdp);
    }
    call_rcu_unlock$link2(&call_rcu_mutex$link2);
    do
    {
      __uatomic_dec$link2((void *)&completion->futex, (signed int)sizeof(signed int) /*4ul*/ );
      asm("mfence" :  :  : "memory");
      asm("" :  :  : "memory");
      tmp_statement_expression$8 = *((volatile signed int *)&(*(&completion->barrier_count)));
      if(tmp_statement_expression$8 == 0)
        break;

      call_rcu_completion_wait$link2(completion);
    }
    while((_Bool)1);
    urcu_ref_put$link2(&completion->ref, free_completion$link2);
  }

online:
  ;
  if(!(was_online == 0))
    rcu_thread_online$link2();

}

// rcu_bp_after_fork_child
// file urcu-bp.c line 677
extern void rcu_bp_after_fork_child(void)
{
  struct anonymous$16 oldmask;
  signed int ret;
  urcu_bp_prune_registry();
  oldmask = saved_fork_signal_mask;
  mutex_unlock$link4(&rcu_registry_lock$link4);
  mutex_unlock$link4(&rcu_gp_lock$link4);
  ret=pthread_sigmask(2, &oldmask, (struct anonymous$16 *)(void *)0);
  /* assertion !ret */
  assert(!(ret != 0));
}

// rcu_bp_after_fork_parent
// file urcu-bp.c line 642
extern void rcu_bp_after_fork_parent(void)
{
  struct anonymous$16 oldmask;
  signed int ret;
  oldmask = saved_fork_signal_mask;
  mutex_unlock$link4(&rcu_registry_lock$link4);
  mutex_unlock$link4(&rcu_gp_lock$link4);
  ret=pthread_sigmask(2, &oldmask, (struct anonymous$16 *)(void *)0);
  /* assertion !ret */
  assert(!(ret != 0));
}

// rcu_bp_before_fork
// file urcu-bp.c line 628
extern void rcu_bp_before_fork(void)
{
  struct anonymous$16 newmask;
  struct anonymous$16 oldmask;
  signed int ret;
  ret=sigfillset(&newmask);
  /* assertion !ret */
  assert(!(ret != 0));
  ret=pthread_sigmask(0, &newmask, &oldmask);
  /* assertion !ret */
  assert(!(ret != 0));
  mutex_lock$link4(&rcu_gp_lock$link4);
  mutex_lock$link4(&rcu_registry_lock$link4);
  saved_fork_signal_mask = oldmask;
}

// rcu_bp_exit
// file urcu-bp.c line 603
static void rcu_bp_exit(void)
{
  mutex_lock$link4(&init_lock);
  rcu_bp_refcount = rcu_bp_refcount - 1;
  if(rcu_bp_refcount == 0)
  {
    struct registry_chunk *chunk;
    struct registry_chunk *tmp;
    signed int ret;
    chunk = (struct registry_chunk *)((char *)(&registry_arena.chunk_list)->next - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node);
    tmp = (struct registry_chunk *)((char *)chunk->node.next - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node);
    for( ; !(&chunk->node == &registry_arena.chunk_list); tmp = (struct registry_chunk *)((char *)chunk->node.next - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node))
    {
      munmap((void *)chunk, chunk->data_len + sizeof(struct registry_chunk) /*32ul*/ );
      chunk = tmp;
    }
    ret=pthread_key_delete(urcu_bp_key);
    if(!(ret == 0))
      abort();

  }

  mutex_unlock$link4(&init_lock);
}

// rcu_bp_init
// file urcu-bp.c line 583
static void rcu_bp_init(void)
{
  mutex_lock$link4(&init_lock);
  signed int tmp_post$2 = rcu_bp_refcount;
  rcu_bp_refcount = rcu_bp_refcount + 1;
  if(tmp_post$2 == 0)
  {
    signed int ret;
    ret=pthread_key_create(&urcu_bp_key, urcu_bp_thread_exit_notifier);
    if(!(ret == 0))
      abort();

    signed long int return_value_syscall$1;
    return_value_syscall$1=syscall((signed long int)324, 0, 0);
    ret = (signed int)return_value_syscall$1;
    if(ret >= 0 && !((1 & ret) == 0))
      urcu_bp_has_sys_membarrier = 1;

    initialized = 1;
  }

  mutex_unlock$link4(&init_lock);
}

// rcu_bp_register
// file urcu-bp.c line 516
extern void rcu_bp_register(void)
{
  struct anonymous$16 newmask;
  struct anonymous$16 oldmask;
  signed int ret;
  ret=sigfillset(&newmask);
  if(!(ret == 0))
    abort();

  ret=pthread_sigmask(0, &newmask, &oldmask);
  if(!(ret == 0))
    abort();

  if(rcu_reader_bp == ((struct rcu_reader_bp *)NULL))
  {
    rcu_bp_init();
    mutex_lock$link4(&rcu_registry_lock$link4);
    add_thread();
    mutex_unlock$link4(&rcu_registry_lock$link4);
  }


end:
  ;
  ret=pthread_sigmask(2, &oldmask, (struct anonymous$16 *)(void *)0);
  if(!(ret == 0))
    abort();

}

// rcu_bp_unregister
// file urcu-bp.c line 551
static void rcu_bp_unregister(struct rcu_reader_bp *rcu_reader_reg)
{
  struct anonymous$16 newmask;
  struct anonymous$16 oldmask;
  signed int ret;
  ret=sigfillset(&newmask);
  if(!(ret == 0))
    abort();

  ret=pthread_sigmask(0, &newmask, &oldmask);
  if(!(ret == 0))
    abort();

  mutex_lock$link4(&rcu_registry_lock$link4);
  remove_thread(rcu_reader_reg);
  mutex_unlock$link4(&rcu_registry_lock$link4);
  ret=pthread_sigmask(2, &oldmask, (struct anonymous$16 *)(void *)0);
  if(!(ret == 0))
    abort();

  rcu_bp_exit();
}

// rcu_cmpxchg_pointer_sym
// file urcu-pointer.c line 53
extern void * rcu_cmpxchg_pointer_sym(void **p, void *old, void *_new)
{
  asm("sfence" :  :  : "memory");
  unsigned long int return_value___uatomic_cmpxchg$1;
  return_value___uatomic_cmpxchg$1=__uatomic_cmpxchg((void *)p, (unsigned long int)old, (unsigned long int)_new, (signed int)sizeof(void *) /*8ul*/ );
  return (void *)return_value___uatomic_cmpxchg$1;
}

// rcu_cmpxchg_pointer_sym_bp
// file urcu-bp.c line 708
extern void * rcu_cmpxchg_pointer_sym_bp(void **p, void *old, void *_new)
{
  asm("sfence" :  :  : "memory");
  unsigned long int return_value___uatomic_cmpxchg$1;
  return_value___uatomic_cmpxchg$1=__uatomic_cmpxchg$link6((void *)p, (unsigned long int)old, (unsigned long int)_new, (signed int)sizeof(void *) /*8ul*/ );
  return (void *)return_value___uatomic_cmpxchg$1;
}

// rcu_defer_barrier_bp
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_bp(void)
{
  struct defer_queue *index;
  unsigned long int num_items = (unsigned long int)0;
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link4(&registry_defer$link4);
  volatile unsigned long int tmp_statement_expression$2;
  if(return_value_cds_list_empty$1 == 0)
  {
    mutex_lock_defer$link4(&rcu_defer_mutex$link4);
    index = (struct defer_queue *)((char *)(&registry_defer$link4)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
    for( ; !(&index->list == &registry_defer$link4); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$2 = *((volatile unsigned long int *)&index->head);
      index->last_head = tmp_statement_expression$2;
      num_items = num_items + (index->last_head - index->tail);
    }
    if(!(num_items == 0ul))
    {
      synchronize_rcu_bp();
      index = (struct defer_queue *)((char *)(&registry_defer$link4)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
      for( ; !(&index->list == &registry_defer$link4); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
        rcu_defer_barrier_queue$link4(index, index->last_head);
    }


  end:
    ;
    mutex_unlock$link4(&rcu_defer_mutex$link4);
  }

}

// rcu_defer_barrier_mb
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_mb(void)
{
  struct defer_queue *index;
  unsigned long int num_items = (unsigned long int)0;
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link1(&registry_defer$link1);
  volatile unsigned long int tmp_statement_expression$2;
  if(return_value_cds_list_empty$1 == 0)
  {
    mutex_lock_defer$link1(&rcu_defer_mutex$link1);
    index = (struct defer_queue *)((char *)(&registry_defer$link1)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
    for( ; !(&index->list == &registry_defer$link1); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$2 = *((volatile unsigned long int *)&index->head);
      index->last_head = tmp_statement_expression$2;
      num_items = num_items + (index->last_head - index->tail);
    }
    if(!(num_items == 0ul))
    {
      synchronize_rcu_mb();
      index = (struct defer_queue *)((char *)(&registry_defer$link1)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
      for( ; !(&index->list == &registry_defer$link1); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
        rcu_defer_barrier_queue$link1(index, index->last_head);
    }


  end:
    ;
    mutex_unlock$link1(&rcu_defer_mutex$link1);
  }

}

// rcu_defer_barrier_memb
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_memb(void)
{
  struct defer_queue *index;
  unsigned long int num_items = (unsigned long int)0;
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty(&registry_defer);
  volatile unsigned long int tmp_statement_expression$2;
  if(return_value_cds_list_empty$1 == 0)
  {
    mutex_lock_defer(&rcu_defer_mutex);
    index = (struct defer_queue *)((char *)(&registry_defer)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
    for( ; !(&index->list == &registry_defer); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$2 = *((volatile unsigned long int *)&index->head);
      index->last_head = tmp_statement_expression$2;
      num_items = num_items + (index->last_head - index->tail);
    }
    if(!(num_items == 0ul))
    {
      synchronize_rcu_memb();
      index = (struct defer_queue *)((char *)(&registry_defer)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
      for( ; !(&index->list == &registry_defer); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
        rcu_defer_barrier_queue(index, index->last_head);
    }


  end:
    ;
    mutex_unlock(&rcu_defer_mutex);
  }

}

// rcu_defer_barrier_qsbr
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_qsbr(void)
{
  struct defer_queue *index;
  unsigned long int num_items = (unsigned long int)0;
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link3(&registry_defer$link3);
  volatile unsigned long int tmp_statement_expression$2;
  if(return_value_cds_list_empty$1 == 0)
  {
    mutex_lock_defer$link3(&rcu_defer_mutex$link3);
    index = (struct defer_queue *)((char *)(&registry_defer$link3)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
    for( ; !(&index->list == &registry_defer$link3); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$2 = *((volatile unsigned long int *)&index->head);
      index->last_head = tmp_statement_expression$2;
      num_items = num_items + (index->last_head - index->tail);
    }
    if(!(num_items == 0ul))
    {
      synchronize_rcu_qsbr();
      index = (struct defer_queue *)((char *)(&registry_defer$link3)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
      for( ; !(&index->list == &registry_defer$link3); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
        rcu_defer_barrier_queue$link3(index, index->last_head);
    }


  end:
    ;
    mutex_unlock$link3(&rcu_defer_mutex$link3);
  }

}

// rcu_defer_barrier_queue
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue(struct defer_queue *queue, unsigned long int head)
{
  unsigned long int i;
  void (*fct)(void *);
  void *p;
  i = queue->tail;
  void * volatile tmp_statement_expression$1;
  unsigned long int tmp_post$2;
  void * volatile tmp_statement_expression$3;
  unsigned long int tmp_post$4;
  void * volatile tmp_statement_expression$5;
  unsigned long int tmp_post$6;
  void * volatile tmp_statement_expression$7;
  unsigned long int tmp_post$8;
  if(!(i == head))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_post$2 = i;
    i = i + 1ul;
    tmp_statement_expression$1 = *((void * volatile *)&queue->q[(signed long int)(tmp_post$2 & (unsigned long int)((1 << 12) - 1))]);
    p = tmp_statement_expression$1;
    if(!((1ul & (unsigned long int)p) == 0ul))
    {
      p = (void *)((unsigned long int)p & (unsigned long int)~(1 << 0));
      queue->last_fct_out = p;
      asm("" :  :  : "memory");
      tmp_post$4 = i;
      i = i + 1ul;
      tmp_statement_expression$3 = *((void * volatile *)&queue->q[(signed long int)(tmp_post$4 & (unsigned long int)((1 << 12) - 1))]);
      p = tmp_statement_expression$3;
    }

    else
      if(p == (void *)-2)
      {
        asm("" :  :  : "memory");
        tmp_post$6 = i;
        i = i + 1ul;
        tmp_statement_expression$5 = *((void * volatile *)&queue->q[(signed long int)(tmp_post$6 & (unsigned long int)((1 << 12) - 1))]);
        p = tmp_statement_expression$5;
        queue->last_fct_out = p;
        asm("" :  :  : "memory");
        tmp_post$8 = i;
        i = i + 1ul;
        tmp_statement_expression$7 = *((void * volatile *)&queue->q[(signed long int)(tmp_post$8 & (unsigned long int)((1 << 12) - 1))]);
        p = tmp_statement_expression$7;
      }

    fct = (void (*)(void *))queue->last_fct_out;
    fct(p);
  }

  asm("mfence" :  :  : "memory");
  unsigned long int _v;
  volatile unsigned long int tmp_statement_expression$9;
  *((volatile unsigned long int *)&queue->tail) = i;
  tmp_statement_expression$9 = *((volatile unsigned long int *)&queue->tail);
  _v = tmp_statement_expression$9;
  asm("" :  :  : "memory");
  _v = _v;
}

// rcu_defer_barrier_queue$link1
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue$link1(struct defer_queue *queue$link1, unsigned long int head$link1)
{
  unsigned long int i$link1;
  void (*fct$link1)(void *);
  void *p$link1;
  i$link1 = queue$link1->tail;
  void * volatile tmp_statement_expression$1$link1;
  unsigned long int tmp_post$2$link1;
  void * volatile tmp_statement_expression$3$link1;
  unsigned long int tmp_post$4$link1;
  void * volatile tmp_statement_expression$5$link1;
  unsigned long int tmp_post$6$link1;
  void * volatile tmp_statement_expression$7$link1;
  unsigned long int tmp_post$8$link1;
  if(!(i$link1 == head$link1))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_post$2$link1 = i$link1;
    i$link1 = i$link1 + 1ul;
    tmp_statement_expression$1$link1 = *((void * volatile *)&queue$link1->q[(signed long int)(tmp_post$2$link1 & (unsigned long int)((1 << 12) - 1))]);
    p$link1 = tmp_statement_expression$1$link1;
    if(!((1ul & (unsigned long int)p$link1) == 0ul))
    {
      p$link1 = (void *)((unsigned long int)p$link1 & (unsigned long int)~(1 << 0));
      queue$link1->last_fct_out = p$link1;
      asm("" :  :  : "memory");
      tmp_post$4$link1 = i$link1;
      i$link1 = i$link1 + 1ul;
      tmp_statement_expression$3$link1 = *((void * volatile *)&queue$link1->q[(signed long int)(tmp_post$4$link1 & (unsigned long int)((1 << 12) - 1))]);
      p$link1 = tmp_statement_expression$3$link1;
    }

    else
      if(p$link1 == (void *)-2)
      {
        asm("" :  :  : "memory");
        tmp_post$6$link1 = i$link1;
        i$link1 = i$link1 + 1ul;
        tmp_statement_expression$5$link1 = *((void * volatile *)&queue$link1->q[(signed long int)(tmp_post$6$link1 & (unsigned long int)((1 << 12) - 1))]);
        p$link1 = tmp_statement_expression$5$link1;
        queue$link1->last_fct_out = p$link1;
        asm("" :  :  : "memory");
        tmp_post$8$link1 = i$link1;
        i$link1 = i$link1 + 1ul;
        tmp_statement_expression$7$link1 = *((void * volatile *)&queue$link1->q[(signed long int)(tmp_post$8$link1 & (unsigned long int)((1 << 12) - 1))]);
        p$link1 = tmp_statement_expression$7$link1;
      }

    fct$link1 = (void (*)(void *))queue$link1->last_fct_out;
    fct$link1(p$link1);
  }

  asm("mfence" :  :  : "memory");
  unsigned long int _v$link1;
  volatile unsigned long int tmp_statement_expression$9$link1;
  *((volatile unsigned long int *)&queue$link1->tail) = i$link1;
  tmp_statement_expression$9$link1 = *((volatile unsigned long int *)&queue$link1->tail);
  _v$link1 = tmp_statement_expression$9$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
}

// rcu_defer_barrier_queue$link2
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue$link2(struct defer_queue *queue$link2, unsigned long int head$link2)
{
  unsigned long int i$link2;
  void (*fct$link2)(void *);
  void *p$link2;
  i$link2 = queue$link2->tail;
  void * volatile tmp_statement_expression$1$link2;
  unsigned long int tmp_post$2$link2;
  void * volatile tmp_statement_expression$3$link2;
  unsigned long int tmp_post$4$link2;
  void * volatile tmp_statement_expression$5$link2;
  unsigned long int tmp_post$6$link2;
  void * volatile tmp_statement_expression$7$link2;
  unsigned long int tmp_post$8$link2;
  if(!(i$link2 == head$link2))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_post$2$link2 = i$link2;
    i$link2 = i$link2 + 1ul;
    tmp_statement_expression$1$link2 = *((void * volatile *)&queue$link2->q[(signed long int)(tmp_post$2$link2 & (unsigned long int)((1 << 12) - 1))]);
    p$link2 = tmp_statement_expression$1$link2;
    if(!((1ul & (unsigned long int)p$link2) == 0ul))
    {
      p$link2 = (void *)((unsigned long int)p$link2 & (unsigned long int)~(1 << 0));
      queue$link2->last_fct_out = p$link2;
      asm("" :  :  : "memory");
      tmp_post$4$link2 = i$link2;
      i$link2 = i$link2 + 1ul;
      tmp_statement_expression$3$link2 = *((void * volatile *)&queue$link2->q[(signed long int)(tmp_post$4$link2 & (unsigned long int)((1 << 12) - 1))]);
      p$link2 = tmp_statement_expression$3$link2;
    }

    else
      if(p$link2 == (void *)-2)
      {
        asm("" :  :  : "memory");
        tmp_post$6$link2 = i$link2;
        i$link2 = i$link2 + 1ul;
        tmp_statement_expression$5$link2 = *((void * volatile *)&queue$link2->q[(signed long int)(tmp_post$6$link2 & (unsigned long int)((1 << 12) - 1))]);
        p$link2 = tmp_statement_expression$5$link2;
        queue$link2->last_fct_out = p$link2;
        asm("" :  :  : "memory");
        tmp_post$8$link2 = i$link2;
        i$link2 = i$link2 + 1ul;
        tmp_statement_expression$7$link2 = *((void * volatile *)&queue$link2->q[(signed long int)(tmp_post$8$link2 & (unsigned long int)((1 << 12) - 1))]);
        p$link2 = tmp_statement_expression$7$link2;
      }

    fct$link2 = (void (*)(void *))queue$link2->last_fct_out;
    fct$link2(p$link2);
  }

  asm("mfence" :  :  : "memory");
  unsigned long int _v$link2;
  volatile unsigned long int tmp_statement_expression$9$link2;
  *((volatile unsigned long int *)&queue$link2->tail) = i$link2;
  tmp_statement_expression$9$link2 = *((volatile unsigned long int *)&queue$link2->tail);
  _v$link2 = tmp_statement_expression$9$link2;
  asm("" :  :  : "memory");
  _v$link2 = _v$link2;
}

// rcu_defer_barrier_queue$link3
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue$link3(struct defer_queue *queue$link3, unsigned long int head$link3)
{
  unsigned long int i$link3;
  void (*fct$link3)(void *);
  void *p$link3;
  i$link3 = queue$link3->tail;
  void * volatile tmp_statement_expression$1$link3;
  unsigned long int tmp_post$2$link3;
  void * volatile tmp_statement_expression$3$link3;
  unsigned long int tmp_post$4$link3;
  void * volatile tmp_statement_expression$5$link3;
  unsigned long int tmp_post$6$link3;
  void * volatile tmp_statement_expression$7$link3;
  unsigned long int tmp_post$8$link3;
  if(!(i$link3 == head$link3))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_post$2$link3 = i$link3;
    i$link3 = i$link3 + 1ul;
    tmp_statement_expression$1$link3 = *((void * volatile *)&queue$link3->q[(signed long int)(tmp_post$2$link3 & (unsigned long int)((1 << 12) - 1))]);
    p$link3 = tmp_statement_expression$1$link3;
    if(!((1ul & (unsigned long int)p$link3) == 0ul))
    {
      p$link3 = (void *)((unsigned long int)p$link3 & (unsigned long int)~(1 << 0));
      queue$link3->last_fct_out = p$link3;
      asm("" :  :  : "memory");
      tmp_post$4$link3 = i$link3;
      i$link3 = i$link3 + 1ul;
      tmp_statement_expression$3$link3 = *((void * volatile *)&queue$link3->q[(signed long int)(tmp_post$4$link3 & (unsigned long int)((1 << 12) - 1))]);
      p$link3 = tmp_statement_expression$3$link3;
    }

    else
      if(p$link3 == (void *)-2)
      {
        asm("" :  :  : "memory");
        tmp_post$6$link3 = i$link3;
        i$link3 = i$link3 + 1ul;
        tmp_statement_expression$5$link3 = *((void * volatile *)&queue$link3->q[(signed long int)(tmp_post$6$link3 & (unsigned long int)((1 << 12) - 1))]);
        p$link3 = tmp_statement_expression$5$link3;
        queue$link3->last_fct_out = p$link3;
        asm("" :  :  : "memory");
        tmp_post$8$link3 = i$link3;
        i$link3 = i$link3 + 1ul;
        tmp_statement_expression$7$link3 = *((void * volatile *)&queue$link3->q[(signed long int)(tmp_post$8$link3 & (unsigned long int)((1 << 12) - 1))]);
        p$link3 = tmp_statement_expression$7$link3;
      }

    fct$link3 = (void (*)(void *))queue$link3->last_fct_out;
    fct$link3(p$link3);
  }

  asm("mfence" :  :  : "memory");
  unsigned long int _v$link3;
  volatile unsigned long int tmp_statement_expression$9$link3;
  *((volatile unsigned long int *)&queue$link3->tail) = i$link3;
  tmp_statement_expression$9$link3 = *((volatile unsigned long int *)&queue$link3->tail);
  _v$link3 = tmp_statement_expression$9$link3;
  asm("" :  :  : "memory");
  _v$link3 = _v$link3;
}

// rcu_defer_barrier_queue$link4
// file urcu-defer-impl.h line 218
static void rcu_defer_barrier_queue$link4(struct defer_queue *queue$link4, unsigned long int head$link4)
{
  unsigned long int i$link4;
  void (*fct$link4)(void *);
  void *p$link4;
  i$link4 = queue$link4->tail;
  void * volatile tmp_statement_expression$1$link4;
  unsigned long int tmp_post$2$link4;
  void * volatile tmp_statement_expression$3$link4;
  unsigned long int tmp_post$4$link4;
  void * volatile tmp_statement_expression$5$link4;
  unsigned long int tmp_post$6$link4;
  void * volatile tmp_statement_expression$7$link4;
  unsigned long int tmp_post$8$link4;
  if(!(i$link4 == head$link4))
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_post$2$link4 = i$link4;
    i$link4 = i$link4 + 1ul;
    tmp_statement_expression$1$link4 = *((void * volatile *)&queue$link4->q[(signed long int)(tmp_post$2$link4 & (unsigned long int)((1 << 12) - 1))]);
    p$link4 = tmp_statement_expression$1$link4;
    if(!((1ul & (unsigned long int)p$link4) == 0ul))
    {
      p$link4 = (void *)((unsigned long int)p$link4 & (unsigned long int)~(1 << 0));
      queue$link4->last_fct_out = p$link4;
      asm("" :  :  : "memory");
      tmp_post$4$link4 = i$link4;
      i$link4 = i$link4 + 1ul;
      tmp_statement_expression$3$link4 = *((void * volatile *)&queue$link4->q[(signed long int)(tmp_post$4$link4 & (unsigned long int)((1 << 12) - 1))]);
      p$link4 = tmp_statement_expression$3$link4;
    }

    else
      if(p$link4 == (void *)-2)
      {
        asm("" :  :  : "memory");
        tmp_post$6$link4 = i$link4;
        i$link4 = i$link4 + 1ul;
        tmp_statement_expression$5$link4 = *((void * volatile *)&queue$link4->q[(signed long int)(tmp_post$6$link4 & (unsigned long int)((1 << 12) - 1))]);
        p$link4 = tmp_statement_expression$5$link4;
        queue$link4->last_fct_out = p$link4;
        asm("" :  :  : "memory");
        tmp_post$8$link4 = i$link4;
        i$link4 = i$link4 + 1ul;
        tmp_statement_expression$7$link4 = *((void * volatile *)&queue$link4->q[(signed long int)(tmp_post$8$link4 & (unsigned long int)((1 << 12) - 1))]);
        p$link4 = tmp_statement_expression$7$link4;
      }

    fct$link4 = (void (*)(void *))queue$link4->last_fct_out;
    fct$link4(p$link4);
  }

  asm("mfence" :  :  : "memory");
  unsigned long int _v$link4;
  volatile unsigned long int tmp_statement_expression$9$link4;
  *((volatile unsigned long int *)&queue$link4->tail) = i$link4;
  tmp_statement_expression$9$link4 = *((volatile unsigned long int *)&queue$link4->tail);
  _v$link4 = tmp_statement_expression$9$link4;
  asm("" :  :  : "memory");
  _v$link4 = _v$link4;
}

// rcu_defer_barrier_sig
// file urcu-defer-impl.h line 281
extern void rcu_defer_barrier_sig(void)
{
  struct defer_queue *index;
  unsigned long int num_items = (unsigned long int)0;
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link2(&registry_defer$link2);
  volatile unsigned long int tmp_statement_expression$2;
  if(return_value_cds_list_empty$1 == 0)
  {
    mutex_lock_defer$link2(&rcu_defer_mutex$link2);
    index = (struct defer_queue *)((char *)(&registry_defer$link2)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
    for( ; !(&index->list == &registry_defer$link2); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$2 = *((volatile unsigned long int *)&index->head);
      index->last_head = tmp_statement_expression$2;
      num_items = num_items + (index->last_head - index->tail);
    }
    if(!(num_items == 0ul))
    {
      synchronize_rcu_sig();
      index = (struct defer_queue *)((char *)(&registry_defer$link2)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
      for( ; !(&index->list == &registry_defer$link2); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
        rcu_defer_barrier_queue$link2(index, index->last_head);
    }


  end:
    ;
    mutex_unlock$link2(&rcu_defer_mutex$link2);
  }

}

// rcu_defer_barrier_thread_bp
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_bp(void)
{
  mutex_lock_defer$link4(&rcu_defer_mutex$link4);
  _rcu_defer_barrier_thread$link4();
  mutex_unlock$link4(&rcu_defer_mutex$link4);
}

// rcu_defer_barrier_thread_mb
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_mb(void)
{
  mutex_lock_defer$link1(&rcu_defer_mutex$link1);
  _rcu_defer_barrier_thread$link1();
  mutex_unlock$link1(&rcu_defer_mutex$link1);
}

// rcu_defer_barrier_thread_memb
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_memb(void)
{
  mutex_lock_defer(&rcu_defer_mutex);
  _rcu_defer_barrier_thread();
  mutex_unlock(&rcu_defer_mutex);
}

// rcu_defer_barrier_thread_qsbr
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_qsbr(void)
{
  mutex_lock_defer$link3(&rcu_defer_mutex$link3);
  _rcu_defer_barrier_thread$link3();
  mutex_unlock$link3(&rcu_defer_mutex$link3);
}

// rcu_defer_barrier_thread_sig
// file urcu-defer-impl.h line 261
extern void rcu_defer_barrier_thread_sig(void)
{
  mutex_lock_defer$link2(&rcu_defer_mutex$link2);
  _rcu_defer_barrier_thread$link2();
  mutex_unlock$link2(&rcu_defer_mutex$link2);
}

// rcu_defer_exit_bp
// file urcu-defer-impl.h line 466
void rcu_defer_exit_bp(void)
{
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link4(&registry_defer$link4);
  /* assertion cds_list_empty(&registry_defer) */
  assert(return_value_cds_list_empty$1 != 0);
}

// rcu_defer_exit_mb
// file urcu-defer-impl.h line 466
void rcu_defer_exit_mb(void)
{
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link1(&registry_defer$link1);
  /* assertion cds_list_empty(&registry_defer) */
  assert(return_value_cds_list_empty$1 != 0);
}

// rcu_defer_exit_memb
// file urcu-defer-impl.h line 466
void rcu_defer_exit_memb(void)
{
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty(&registry_defer);
  /* assertion cds_list_empty(&registry_defer) */
  assert(return_value_cds_list_empty$1 != 0);
}

// rcu_defer_exit_qsbr
// file urcu-defer-impl.h line 466
void rcu_defer_exit_qsbr(void)
{
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link3(&registry_defer$link3);
  /* assertion cds_list_empty(&registry_defer) */
  assert(return_value_cds_list_empty$1 != 0);
}

// rcu_defer_exit_sig
// file urcu-defer-impl.h line 466
void rcu_defer_exit_sig(void)
{
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link2(&registry_defer$link2);
  /* assertion cds_list_empty(&registry_defer) */
  assert(return_value_cds_list_empty$1 != 0);
}

// rcu_defer_num_callbacks
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks(void)
{
  unsigned long int num_items = (unsigned long int)0;
  unsigned long int head;
  struct defer_queue *index;
  mutex_lock_defer(&rcu_defer_mutex);
  index = (struct defer_queue *)((char *)(&registry_defer)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
  volatile unsigned long int tmp_statement_expression$1;
  for( ; !(&index->list == &registry_defer); index = (struct defer_queue *)((char *)index->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1 = *((volatile unsigned long int *)&index->head);
    head = tmp_statement_expression$1;
    num_items = num_items + (head - index->tail);
  }
  mutex_unlock(&rcu_defer_mutex);
  return num_items;
}

// rcu_defer_num_callbacks$link1
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks$link1(void)
{
  unsigned long int num_items$link1 = (unsigned long int)0;
  unsigned long int head$link1;
  struct defer_queue *index$link1;
  mutex_lock_defer$link1(&rcu_defer_mutex$link1);
  index$link1 = (struct defer_queue *)((char *)(&registry_defer$link1)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
  volatile unsigned long int tmp_statement_expression$1$link1;
  for( ; !(&index$link1->list == &registry_defer$link1); index$link1 = (struct defer_queue *)((char *)index$link1->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1 = *((volatile unsigned long int *)&index$link1->head);
    head$link1 = tmp_statement_expression$1$link1;
    num_items$link1 = num_items$link1 + (head$link1 - index$link1->tail);
  }
  mutex_unlock$link1(&rcu_defer_mutex$link1);
  return num_items$link1;
}

// rcu_defer_num_callbacks$link2
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks$link2(void)
{
  unsigned long int num_items$link2 = (unsigned long int)0;
  unsigned long int head$link2;
  struct defer_queue *index$link2;
  mutex_lock_defer$link2(&rcu_defer_mutex$link2);
  index$link2 = (struct defer_queue *)((char *)(&registry_defer$link2)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
  volatile unsigned long int tmp_statement_expression$1$link2;
  for( ; !(&index$link2->list == &registry_defer$link2); index$link2 = (struct defer_queue *)((char *)index$link2->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link2 = *((volatile unsigned long int *)&index$link2->head);
    head$link2 = tmp_statement_expression$1$link2;
    num_items$link2 = num_items$link2 + (head$link2 - index$link2->tail);
  }
  mutex_unlock$link2(&rcu_defer_mutex$link2);
  return num_items$link2;
}

// rcu_defer_num_callbacks$link3
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks$link3(void)
{
  unsigned long int num_items$link3 = (unsigned long int)0;
  unsigned long int head$link3;
  struct defer_queue *index$link3;
  mutex_lock_defer$link3(&rcu_defer_mutex$link3);
  index$link3 = (struct defer_queue *)((char *)(&registry_defer$link3)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
  volatile unsigned long int tmp_statement_expression$1$link3;
  for( ; !(&index$link3->list == &registry_defer$link3); index$link3 = (struct defer_queue *)((char *)index$link3->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link3 = *((volatile unsigned long int *)&index$link3->head);
    head$link3 = tmp_statement_expression$1$link3;
    num_items$link3 = num_items$link3 + (head$link3 - index$link3->tail);
  }
  mutex_unlock$link3(&rcu_defer_mutex$link3);
  return num_items$link3;
}

// rcu_defer_num_callbacks$link4
// file urcu-defer-impl.h line 163
static unsigned long int rcu_defer_num_callbacks$link4(void)
{
  unsigned long int num_items$link4 = (unsigned long int)0;
  unsigned long int head$link4;
  struct defer_queue *index$link4;
  mutex_lock_defer$link4(&rcu_defer_mutex$link4);
  index$link4 = (struct defer_queue *)((char *)(&registry_defer$link4)->next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list);
  volatile unsigned long int tmp_statement_expression$1$link4;
  for( ; !(&index$link4->list == &registry_defer$link4); index$link4 = (struct defer_queue *)((char *)index$link4->list.next - (signed long int)(unsigned long int)&((struct defer_queue *)0)->list))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link4 = *((volatile unsigned long int *)&index$link4->head);
    head$link4 = tmp_statement_expression$1$link4;
    num_items$link4 = num_items$link4 + (head$link4 - index$link4->tail);
  }
  mutex_unlock$link4(&rcu_defer_mutex$link4);
  return num_items$link4;
}

// rcu_defer_register_thread_bp
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_bp(void)
{
  signed int was_empty;
  /* assertion (defer_queue).last_head == 0 */
  assert(defer_queue$link4.last_head == (unsigned long int)0);
  /* assertion (defer_queue).q == ((void *)0) */
  assert(defer_queue$link4.q == (void **)(void *)0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(void *) /*8ul*/  * (unsigned long int)(1 << 12));
  defer_queue$link4.q = (void **)return_value_malloc$1;
  if(defer_queue$link4.q == ((void **)NULL))
    return -12;

  else
  {
    mutex_lock_defer$link4(&defer_thread_mutex$link4);
    mutex_lock_defer$link4(&rcu_defer_mutex$link4);
    was_empty=cds_list_empty$link4(&registry_defer$link4);
    cds_list_add$link4(&defer_queue$link4.list, &registry_defer$link4);
    mutex_unlock$link4(&rcu_defer_mutex$link4);
    if(!(was_empty == 0))
      start_defer_thread$link4();

    mutex_unlock$link4(&defer_thread_mutex$link4);
    return 0;
  }
}

// rcu_defer_register_thread_mb
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_mb(void)
{
  signed int was_empty;
  /* assertion (defer_queue).last_head == 0 */
  assert(defer_queue$link1.last_head == (unsigned long int)0);
  /* assertion (defer_queue).q == ((void *)0) */
  assert(defer_queue$link1.q == (void **)(void *)0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(void *) /*8ul*/  * (unsigned long int)(1 << 12));
  defer_queue$link1.q = (void **)return_value_malloc$1;
  if(defer_queue$link1.q == ((void **)NULL))
    return -12;

  else
  {
    mutex_lock_defer$link1(&defer_thread_mutex$link1);
    mutex_lock_defer$link1(&rcu_defer_mutex$link1);
    was_empty=cds_list_empty$link1(&registry_defer$link1);
    cds_list_add$link1(&defer_queue$link1.list, &registry_defer$link1);
    mutex_unlock$link1(&rcu_defer_mutex$link1);
    if(!(was_empty == 0))
      start_defer_thread$link1();

    mutex_unlock$link1(&defer_thread_mutex$link1);
    return 0;
  }
}

// rcu_defer_register_thread_memb
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_memb(void)
{
  signed int was_empty;
  /* assertion (defer_queue).last_head == 0 */
  assert(defer_queue.last_head == (unsigned long int)0);
  /* assertion (defer_queue).q == ((void *)0) */
  assert(defer_queue.q == (void **)(void *)0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(void *) /*8ul*/  * (unsigned long int)(1 << 12));
  defer_queue.q = (void **)return_value_malloc$1;
  if(defer_queue.q == ((void **)NULL))
    return -12;

  else
  {
    mutex_lock_defer(&defer_thread_mutex);
    mutex_lock_defer(&rcu_defer_mutex);
    was_empty=cds_list_empty(&registry_defer);
    cds_list_add(&defer_queue.list, &registry_defer);
    mutex_unlock(&rcu_defer_mutex);
    if(!(was_empty == 0))
      start_defer_thread();

    mutex_unlock(&defer_thread_mutex);
    return 0;
  }
}

// rcu_defer_register_thread_qsbr
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_qsbr(void)
{
  signed int was_empty;
  /* assertion (defer_queue).last_head == 0 */
  assert(defer_queue$link3.last_head == (unsigned long int)0);
  /* assertion (defer_queue).q == ((void *)0) */
  assert(defer_queue$link3.q == (void **)(void *)0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(void *) /*8ul*/  * (unsigned long int)(1 << 12));
  defer_queue$link3.q = (void **)return_value_malloc$1;
  if(defer_queue$link3.q == ((void **)NULL))
    return -12;

  else
  {
    mutex_lock_defer$link3(&defer_thread_mutex$link3);
    mutex_lock_defer$link3(&rcu_defer_mutex$link3);
    was_empty=cds_list_empty$link3(&registry_defer$link3);
    cds_list_add$link3(&defer_queue$link3.list, &registry_defer$link3);
    mutex_unlock$link3(&rcu_defer_mutex$link3);
    if(!(was_empty == 0))
      start_defer_thread$link3();

    mutex_unlock$link3(&defer_thread_mutex$link3);
    return 0;
  }
}

// rcu_defer_register_thread_sig
// file urcu-defer-impl.h line 426
extern signed int rcu_defer_register_thread_sig(void)
{
  signed int was_empty;
  /* assertion (defer_queue).last_head == 0 */
  assert(defer_queue$link2.last_head == (unsigned long int)0);
  /* assertion (defer_queue).q == ((void *)0) */
  assert(defer_queue$link2.q == (void **)(void *)0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(void *) /*8ul*/  * (unsigned long int)(1 << 12));
  defer_queue$link2.q = (void **)return_value_malloc$1;
  if(defer_queue$link2.q == ((void **)NULL))
    return -12;

  else
  {
    mutex_lock_defer$link2(&defer_thread_mutex$link2);
    mutex_lock_defer$link2(&rcu_defer_mutex$link2);
    was_empty=cds_list_empty$link2(&registry_defer$link2);
    cds_list_add$link2(&defer_queue$link2.list, &registry_defer$link2);
    mutex_unlock$link2(&rcu_defer_mutex$link2);
    if(!(was_empty == 0))
      start_defer_thread$link2();

    mutex_unlock$link2(&defer_thread_mutex$link2);
    return 0;
  }
}

// rcu_defer_unregister_thread_bp
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_bp(void)
{
  signed int is_empty;
  mutex_lock_defer$link4(&defer_thread_mutex$link4);
  mutex_lock_defer$link4(&rcu_defer_mutex$link4);
  cds_list_del$link4(&defer_queue$link4.list);
  _rcu_defer_barrier_thread$link4();
  free((void *)defer_queue$link4.q);
  defer_queue$link4.q = (void **)(void *)0;
  is_empty=cds_list_empty$link4(&registry_defer$link4);
  mutex_unlock$link4(&rcu_defer_mutex$link4);
  if(!(is_empty == 0))
    stop_defer_thread$link4();

  mutex_unlock$link4(&defer_thread_mutex$link4);
}

// rcu_defer_unregister_thread_mb
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_mb(void)
{
  signed int is_empty;
  mutex_lock_defer$link1(&defer_thread_mutex$link1);
  mutex_lock_defer$link1(&rcu_defer_mutex$link1);
  cds_list_del$link1(&defer_queue$link1.list);
  _rcu_defer_barrier_thread$link1();
  free((void *)defer_queue$link1.q);
  defer_queue$link1.q = (void **)(void *)0;
  is_empty=cds_list_empty$link1(&registry_defer$link1);
  mutex_unlock$link1(&rcu_defer_mutex$link1);
  if(!(is_empty == 0))
    stop_defer_thread$link1();

  mutex_unlock$link1(&defer_thread_mutex$link1);
}

// rcu_defer_unregister_thread_memb
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_memb(void)
{
  signed int is_empty;
  mutex_lock_defer(&defer_thread_mutex);
  mutex_lock_defer(&rcu_defer_mutex);
  cds_list_del(&defer_queue.list);
  _rcu_defer_barrier_thread();
  free((void *)defer_queue.q);
  defer_queue.q = (void **)(void *)0;
  is_empty=cds_list_empty(&registry_defer);
  mutex_unlock(&rcu_defer_mutex);
  if(!(is_empty == 0))
    stop_defer_thread();

  mutex_unlock(&defer_thread_mutex);
}

// rcu_defer_unregister_thread_qsbr
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_qsbr(void)
{
  signed int is_empty;
  mutex_lock_defer$link3(&defer_thread_mutex$link3);
  mutex_lock_defer$link3(&rcu_defer_mutex$link3);
  cds_list_del$link3(&defer_queue$link3.list);
  _rcu_defer_barrier_thread$link3();
  free((void *)defer_queue$link3.q);
  defer_queue$link3.q = (void **)(void *)0;
  is_empty=cds_list_empty$link3(&registry_defer$link3);
  mutex_unlock$link3(&rcu_defer_mutex$link3);
  if(!(is_empty == 0))
    stop_defer_thread$link3();

  mutex_unlock$link3(&defer_thread_mutex$link3);
}

// rcu_defer_unregister_thread_sig
// file urcu-defer-impl.h line 448
extern void rcu_defer_unregister_thread_sig(void)
{
  signed int is_empty;
  mutex_lock_defer$link2(&defer_thread_mutex$link2);
  mutex_lock_defer$link2(&rcu_defer_mutex$link2);
  cds_list_del$link2(&defer_queue$link2.list);
  _rcu_defer_barrier_thread$link2();
  free((void *)defer_queue$link2.q);
  defer_queue$link2.q = (void **)(void *)0;
  is_empty=cds_list_empty$link2(&registry_defer$link2);
  mutex_unlock$link2(&rcu_defer_mutex$link2);
  if(!(is_empty == 0))
    stop_defer_thread$link2();

  mutex_unlock$link2(&defer_thread_mutex$link2);
}

// rcu_dereference_sym
// file urcu-pointer.c line 35
extern void * rcu_dereference_sym(void *p)
{
  void *tmp_statement_expression$1;
  void *_________p1;
  void * volatile tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((void * volatile *)&p);
  _________p1 = tmp_statement_expression$2;
  tmp_statement_expression$1 = _________p1;
  return tmp_statement_expression$1;
}

// rcu_dereference_sym_bp
// file urcu-bp.c line 690
extern void * rcu_dereference_sym_bp(void *p)
{
  void *tmp_statement_expression$1;
  void *_________p1;
  void * volatile tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((void * volatile *)&p);
  _________p1 = tmp_statement_expression$2;
  tmp_statement_expression$1 = _________p1;
  return tmp_statement_expression$1;
}

// rcu_exit_qsbr
// file urcu-qsbr.c line 492
void rcu_exit_qsbr(void)
{
  ;
}

// rcu_exit_sig
// file urcu.c line 588
void rcu_exit_sig(void)
{
  ;
}

// rcu_init_mb
// file urcu.c line 87
extern void rcu_init_mb(void)
{
  ;
}

// rcu_init_memb
// file urcu.c line 536
extern void rcu_init_memb(void)
{
  signed int ret;
  if(init_done == 0)
  {
    init_done = 1;
    signed long int return_value_syscall$1;
    return_value_syscall$1=syscall((signed long int)324, 0, 0);
    ret = (signed int)return_value_syscall$1;
    if(ret >= 0 && !((1 & ret) == 0))
      rcu_has_sys_membarrier_memb = 1;

  }

}

// rcu_init_sig
// file urcu.c line 571
extern void rcu_init_sig(void)
{
  struct sigaction act;
  signed int ret;
  if(init_done$link1 == 0)
  {
    init_done$link1 = 1;
    act.__sigaction_handler.sa_sigaction = sigrcu_handler;
    act.sa_flags = 4 | 0x10000000;
    sigemptyset(&act.sa_mask);
    ret=sigaction(10, &act, (struct sigaction *)(void *)0);
    if(!(ret == 0))
      do
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"rcu_init_sig", 585, return_value_strerror$2);
        abort();
      }
      while((_Bool)0);

  }

}

// rcu_quiescent_state
// file urcu.h line 117
static inline void rcu_quiescent_state(void)
{
  ;
}

// rcu_quiescent_state$link1
// file urcu.h line 117
static inline void rcu_quiescent_state$link1(void)
{
  ;
}

// rcu_quiescent_state$link2
// file urcu.h line 117
static inline void rcu_quiescent_state$link2(void)
{
  ;
}

// rcu_quiescent_state$link3
// file urcu-bp.h line 171
static inline void rcu_quiescent_state$link3(void)
{
  ;
}

// rcu_quiescent_state_qsbr
// file urcu-qsbr.c line 450
extern void rcu_quiescent_state_qsbr(void)
{
  _rcu_quiescent_state_qsbr();
}

// rcu_read_lock_bp
// file ../../urcu-bp.h line 91
extern void rcu_read_lock_bp(void)
{
  _rcu_read_lock_bp();
}

// rcu_read_lock_mb
// file ../../urcu.h line 95
extern void rcu_read_lock_mb(void)
{
  _rcu_read_lock_mb();
}

// rcu_read_lock_memb
// file ../../urcu.h line 95
extern void rcu_read_lock_memb(void)
{
  _rcu_read_lock_memb();
}

// rcu_read_lock_qsbr
// file ../../urcu-qsbr.h line 100
static inline void rcu_read_lock_qsbr(void)
{
  ;
}

// rcu_read_lock_qsbr$link1
// file urcu-qsbr.c line 435
extern void rcu_read_lock_qsbr$link1(void)
{
  _rcu_read_lock_qsbr();
}

// rcu_read_lock_sig
// file ../../urcu.h line 95
extern void rcu_read_lock_sig(void)
{
  _rcu_read_lock_sig();
}

// rcu_read_ongoing_bp
// file urcu-bp.c line 351
extern signed int rcu_read_ongoing_bp(void)
{
  signed int return_value__rcu_read_ongoing_bp$1;
  return_value__rcu_read_ongoing_bp$1=_rcu_read_ongoing_bp();
  return return_value__rcu_read_ongoing_bp$1;
}

// rcu_read_ongoing_mb
// file urcu.c line 507
extern signed int rcu_read_ongoing_mb(void)
{
  signed int return_value__rcu_read_ongoing_mb$1;
  return_value__rcu_read_ongoing_mb$1=_rcu_read_ongoing_mb();
  return return_value__rcu_read_ongoing_mb$1;
}

// rcu_read_ongoing_memb
// file urcu.c line 507
extern signed int rcu_read_ongoing_memb(void)
{
  signed int return_value__rcu_read_ongoing_memb$1;
  return_value__rcu_read_ongoing_memb$1=_rcu_read_ongoing_memb();
  return return_value__rcu_read_ongoing_memb$1;
}

// rcu_read_ongoing_qsbr
// file urcu-qsbr.c line 445
extern signed int rcu_read_ongoing_qsbr(void)
{
  signed int return_value__rcu_read_ongoing_qsbr$1;
  return_value__rcu_read_ongoing_qsbr$1=_rcu_read_ongoing_qsbr();
  return return_value__rcu_read_ongoing_qsbr$1;
}

// rcu_read_ongoing_sig
// file urcu.c line 507
extern signed int rcu_read_ongoing_sig(void)
{
  signed int return_value__rcu_read_ongoing_sig$1;
  return_value__rcu_read_ongoing_sig$1=_rcu_read_ongoing_sig();
  return return_value__rcu_read_ongoing_sig$1;
}

// rcu_read_unlock_bp
// file ../../urcu-bp.h line 92
extern void rcu_read_unlock_bp(void)
{
  _rcu_read_unlock_bp();
}

// rcu_read_unlock_mb
// file ../../urcu.h line 96
extern void rcu_read_unlock_mb(void)
{
  _rcu_read_unlock_mb();
}

// rcu_read_unlock_memb
// file ../../urcu.h line 96
extern void rcu_read_unlock_memb(void)
{
  _rcu_read_unlock_memb();
}

// rcu_read_unlock_qsbr
// file ../../urcu-qsbr.h line 104
static inline void rcu_read_unlock_qsbr(void)
{
  ;
}

// rcu_read_unlock_qsbr$link1
// file urcu-qsbr.c line 440
extern void rcu_read_unlock_qsbr$link1(void)
{
  _rcu_read_unlock_qsbr();
}

// rcu_read_unlock_sig
// file ../../urcu.h line 96
extern void rcu_read_unlock_sig(void)
{
  _rcu_read_unlock_sig();
}

// rcu_reader_state
// file urcu/static/urcu.h line 172
static inline enum rcu_state rcu_reader_state(unsigned long int *ctr)
{
  unsigned long int v;
  volatile unsigned long int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile unsigned long int *)&(*ctr));
  v = tmp_statement_expression$1;
  if((4294967295ul & v) == 0ul)
    return (enum rcu_state)RCU_READER_INACTIVE;

  else
    if(((rcu_gp_memb.ctr ^ v) & 4294967296ul) == 0ul)
      return (enum rcu_state)RCU_READER_ACTIVE_CURRENT;

    else
      return (enum rcu_state)RCU_READER_ACTIVE_OLD;
}

// rcu_reader_state$link1
// file urcu/static/urcu.h line 172
static inline enum rcu_state rcu_reader_state$link1(unsigned long int *ctr$link1)
{
  unsigned long int v$link1;
  volatile unsigned long int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile unsigned long int *)&(*ctr$link1));
  v$link1 = tmp_statement_expression$1$link1;
  if((4294967295ul & v$link1) == 0ul)
    return (enum rcu_state)RCU_READER_INACTIVE;

  else
    if(((rcu_gp_mb.ctr ^ v$link1) & 4294967296ul) == 0ul)
      return (enum rcu_state)RCU_READER_ACTIVE_CURRENT;

    else
      return (enum rcu_state)RCU_READER_ACTIVE_OLD;
}

// rcu_reader_state$link2
// file urcu/static/urcu.h line 172
static inline enum rcu_state rcu_reader_state$link2(unsigned long int *ctr$link2)
{
  unsigned long int v$link2;
  volatile unsigned long int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile unsigned long int *)&(*ctr$link2));
  v$link2 = tmp_statement_expression$1$link2;
  if((4294967295ul & v$link2) == 0ul)
    return (enum rcu_state)RCU_READER_INACTIVE;

  else
    if(((rcu_gp_sig.ctr ^ v$link2) & 4294967296ul) == 0ul)
      return (enum rcu_state)RCU_READER_ACTIVE_CURRENT;

    else
      return (enum rcu_state)RCU_READER_ACTIVE_OLD;
}

// rcu_reader_state$link3
// file urcu/static/urcu-qsbr.h line 115
static inline enum rcu_state rcu_reader_state$link3(unsigned long int *ctr$link3)
{
  unsigned long int v$link3;
  volatile unsigned long int tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((volatile unsigned long int *)&(*ctr$link3));
  v$link3 = tmp_statement_expression$1$link3;
  if(v$link3 == 0ul)
    return (enum rcu_state)RCU_READER_INACTIVE;

  else
    if(v$link3 == rcu_gp_qsbr.ctr)
      return (enum rcu_state)RCU_READER_ACTIVE_CURRENT;

    else
      return (enum rcu_state)RCU_READER_ACTIVE_OLD;
}

// rcu_reader_state$link4
// file urcu/static/urcu-bp.h line 115
static inline enum rcu_state rcu_reader_state$link4(unsigned long int *ctr$link4)
{
  unsigned long int v$link4;
  volatile unsigned long int tmp_statement_expression$1$link4;
  if(ctr$link4 == ((unsigned long int *)NULL))
    return (enum rcu_state)RCU_READER_INACTIVE;

  else
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link4 = *((volatile unsigned long int *)&(*ctr$link4));
    v$link4 = tmp_statement_expression$1$link4;
    if((4294967295ul & v$link4) == 0ul)
      return (enum rcu_state)RCU_READER_INACTIVE;

    else
      if(((rcu_gp_bp.ctr ^ v$link4) & 4294967296ul) == 0ul)
        return (enum rcu_state)RCU_READER_ACTIVE_CURRENT;

      else
        return (enum rcu_state)RCU_READER_ACTIVE_OLD;
  }
}

// rcu_register_thread_bp
// file ../../urcu-bp.h line 156
static inline void rcu_register_thread_bp(void)
{
  ;
}

// rcu_register_thread_bp$link1
// file urcu-bp.h line 156
static inline void rcu_register_thread_bp$link1(void)
{
  ;
}

// rcu_register_thread_mb
// file ../../urcu.h line 106
extern void rcu_register_thread_mb(void)
{
  rcu_reader_mb.tid=pthread_self();
  /* assertion (rcu_reader_mb).need_mb == 0 */
  assert((signed int)rcu_reader_mb.need_mb == 0);
  /* assertion !((rcu_reader_mb).ctr & ((1UL << (sizeof(unsigned long) << 2)) - 1)) */
  assert(!((rcu_reader_mb.ctr & (1UL << (sizeof(unsigned long int) /*8ul*/  << 2)) - (unsigned long int)1) != 0ul));
  mutex_lock$link1(&rcu_registry_lock$link1);
  /* assertion !(rcu_reader_mb).registered */
  assert(!(rcu_reader_mb.registered != 0u));
  rcu_reader_mb.registered = (unsigned int)1;
  rcu_init_mb();
  cds_list_add$link1(&rcu_reader_mb.node, &registry$link1);
  mutex_unlock$link1(&rcu_registry_lock$link1);
}

// rcu_register_thread_memb
// file ../../urcu.h line 106
extern void rcu_register_thread_memb(void)
{
  rcu_reader_memb.tid=pthread_self();
  /* assertion (rcu_reader_memb).need_mb == 0 */
  assert((signed int)rcu_reader_memb.need_mb == 0);
  /* assertion !((rcu_reader_memb).ctr & ((1UL << (sizeof(unsigned long) << 2)) - 1)) */
  assert(!((rcu_reader_memb.ctr & (1UL << (sizeof(unsigned long int) /*8ul*/  << 2)) - (unsigned long int)1) != 0ul));
  mutex_lock(&rcu_registry_lock);
  /* assertion !(rcu_reader_memb).registered */
  assert(!(rcu_reader_memb.registered != 0u));
  rcu_reader_memb.registered = (unsigned int)1;
  rcu_init_memb();
  cds_list_add(&rcu_reader_memb.node, &registry);
  mutex_unlock(&rcu_registry_lock);
}

// rcu_register_thread_qsbr
// file ../../urcu-qsbr.h line 127
extern void rcu_register_thread_qsbr(void)
{
  rcu_reader_qsbr.tid=pthread_self();
  /* assertion (rcu_reader_qsbr).ctr == 0 */
  assert(rcu_reader_qsbr.ctr == (unsigned long int)0);
  mutex_lock$link3(&rcu_registry_lock$link3);
  /* assertion !(rcu_reader_qsbr).registered */
  assert(!(rcu_reader_qsbr.registered != 0u));
  rcu_reader_qsbr.registered = (unsigned int)1;
  cds_list_add$link3(&rcu_reader_qsbr.node, &registry$link3);
  mutex_unlock$link3(&rcu_registry_lock$link3);
  _rcu_thread_online();
}

// rcu_register_thread_sig
// file ../../urcu.h line 106
extern void rcu_register_thread_sig(void)
{
  rcu_reader_sig.tid=pthread_self();
  /* assertion (rcu_reader_sig).need_mb == 0 */
  assert((signed int)rcu_reader_sig.need_mb == 0);
  /* assertion !((rcu_reader_sig).ctr & ((1UL << (sizeof(unsigned long) << 2)) - 1)) */
  assert(!((rcu_reader_sig.ctr & (1UL << (sizeof(unsigned long int) /*8ul*/  << 2)) - (unsigned long int)1) != 0ul));
  mutex_lock$link2(&rcu_registry_lock$link2);
  /* assertion !(rcu_reader_sig).registered */
  assert(!(rcu_reader_sig.registered != 0u));
  rcu_reader_sig.registered = (unsigned int)1;
  rcu_init_sig();
  cds_list_add$link2(&rcu_reader_sig.node, &registry$link2);
  mutex_unlock$link2(&rcu_registry_lock$link2);
}

// rcu_set_pointer_sym
// file urcu-pointer.c line 40
extern void * rcu_set_pointer_sym(void **p, void *v)
{
  asm("sfence" :  :  : "memory");
  void *_v;
  void * volatile tmp_statement_expression$1;
  *((void * volatile *)&(*p)) = v;
  tmp_statement_expression$1 = *((void * volatile *)&(*p));
  _v = tmp_statement_expression$1;
  asm("" :  :  : "memory");
  _v = _v;
  return v;
}

// rcu_set_pointer_sym_bp
// file urcu-bp.c line 695
extern void * rcu_set_pointer_sym_bp(void **p, void *v)
{
  asm("sfence" :  :  : "memory");
  void *_v;
  void * volatile tmp_statement_expression$1;
  *((void * volatile *)&(*p)) = v;
  tmp_statement_expression$1 = *((void * volatile *)&(*p));
  _v = tmp_statement_expression$1;
  asm("" :  :  : "memory");
  _v = _v;
  return v;
}

// rcu_thread_offline
// file urcu.h line 121
static inline void rcu_thread_offline(void)
{
  ;
}

// rcu_thread_offline$link1
// file urcu.h line 121
static inline void rcu_thread_offline$link1(void)
{
  ;
}

// rcu_thread_offline$link2
// file urcu.h line 121
static inline void rcu_thread_offline$link2(void)
{
  ;
}

// rcu_thread_offline$link3
// file urcu-bp.h line 175
static inline void rcu_thread_offline$link3(void)
{
  ;
}

// rcu_thread_offline_qsbr
// file urcu-qsbr.c line 455
extern void rcu_thread_offline_qsbr(void)
{
  _rcu_thread_offline();
}

// rcu_thread_online
// file urcu.h line 125
static inline void rcu_thread_online(void)
{
  ;
}

// rcu_thread_online$link1
// file urcu.h line 125
static inline void rcu_thread_online$link1(void)
{
  ;
}

// rcu_thread_online$link2
// file urcu.h line 125
static inline void rcu_thread_online$link2(void)
{
  ;
}

// rcu_thread_online$link3
// file urcu-bp.h line 179
static inline void rcu_thread_online$link3(void)
{
  ;
}

// rcu_thread_online_qsbr
// file urcu-qsbr.c line 460
extern void rcu_thread_online_qsbr(void)
{
  _rcu_thread_online();
}

// rcu_unregister_thread_bp
// file ../../urcu-bp.h line 160
static inline void rcu_unregister_thread_bp(void)
{
  ;
}

// rcu_unregister_thread_bp$link1
// file urcu-bp.h line 160
static inline void rcu_unregister_thread_bp$link1(void)
{
  ;
}

// rcu_unregister_thread_mb
// file ../../urcu.h line 107
extern void rcu_unregister_thread_mb(void)
{
  mutex_lock$link1(&rcu_registry_lock$link1);
  /* assertion (rcu_reader_mb).registered */
  assert(rcu_reader_mb.registered != 0u);
  rcu_reader_mb.registered = (unsigned int)0;
  cds_list_del$link1(&rcu_reader_mb.node);
  mutex_unlock$link1(&rcu_registry_lock$link1);
}

// rcu_unregister_thread_memb
// file ../../urcu.h line 107
extern void rcu_unregister_thread_memb(void)
{
  mutex_lock(&rcu_registry_lock);
  /* assertion (rcu_reader_memb).registered */
  assert(rcu_reader_memb.registered != 0u);
  rcu_reader_memb.registered = (unsigned int)0;
  cds_list_del(&rcu_reader_memb.node);
  mutex_unlock(&rcu_registry_lock);
}

// rcu_unregister_thread_qsbr
// file ../../urcu-qsbr.h line 128
extern void rcu_unregister_thread_qsbr(void)
{
  _rcu_thread_offline();
  /* assertion (rcu_reader_qsbr).registered */
  assert(rcu_reader_qsbr.registered != 0u);
  rcu_reader_qsbr.registered = (unsigned int)0;
  mutex_lock$link3(&rcu_registry_lock$link3);
  cds_list_del$link3(&rcu_reader_qsbr.node);
  mutex_unlock$link3(&rcu_registry_lock$link3);
}

// rcu_unregister_thread_sig
// file ../../urcu.h line 107
extern void rcu_unregister_thread_sig(void)
{
  mutex_lock$link2(&rcu_registry_lock$link2);
  /* assertion (rcu_reader_sig).registered */
  assert(rcu_reader_sig.registered != 0u);
  rcu_reader_sig.registered = (unsigned int)0;
  cds_list_del$link2(&rcu_reader_sig.node);
  mutex_unlock$link2(&rcu_registry_lock$link2);
}

// rcu_xchg_pointer_sym
// file urcu-pointer.c line 47
extern void * rcu_xchg_pointer_sym(void **p, void *v)
{
  asm("sfence" :  :  : "memory");
  unsigned long int return_value___uatomic_exchange$1;
  return_value___uatomic_exchange$1=__uatomic_exchange$link1((void *)p, (unsigned long int)v, (signed int)sizeof(void *) /*8ul*/ );
  return (void *)return_value___uatomic_exchange$1;
}

// rcu_xchg_pointer_sym_bp
// file urcu-bp.c line 702
extern void * rcu_xchg_pointer_sym_bp(void **p, void *v)
{
  asm("sfence" :  :  : "memory");
  unsigned long int return_value___uatomic_exchange$1;
  return_value___uatomic_exchange$1=__uatomic_exchange$link7((void *)p, (unsigned long int)v, (signed int)sizeof(void *) /*8ul*/ );
  return (void *)return_value___uatomic_exchange$1;
}

// rdiag
// file tap.c line 296
unsigned int rdiag(char *fmt, ...)
{
  void **ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  return (unsigned int)0;
}

// rdiag_end
// file tap.c line 308
unsigned int rdiag_end(void)
{
  fputs("\n", stderr);
  return (unsigned int)0;
}

// rdiag_start
// file tap.c line 289
unsigned int rdiag_start(void)
{
  fputs("# ", stderr);
  return (unsigned int)0;
}

// remove_thread
// file urcu-bp.c line 509
static void remove_thread(struct rcu_reader_bp *rcu_reader_reg)
{
  struct registry_chunk *return_value_find_chunk$1;
  return_value_find_chunk$1=find_chunk(rcu_reader_reg);
  cleanup_thread(return_value_find_chunk$1, rcu_reader_reg);
  rcu_reader_bp = (struct rcu_reader_bp *)(void *)0;
}

// set_cpu_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_bp(signed int cpu, struct call_rcu_data *crdp)
{
  call_rcu_lock$link4(&call_rcu_mutex$link4);
  alloc_cpu_call_rcu_data$link4();
  if((signed long int)cpu >= maxcpus$link4 || !(cpu >= 0))
  {
    static signed int warned = 0;
    if(warned == 0)
    {
      fprintf(stderr, "[error] liburcu: set CPU # out of range\n");
      warned = 1;
    }

    call_rcu_unlock$link4(&call_rcu_mutex$link4);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data$link4 == ((struct call_rcu_data **)NULL))
  {
    call_rcu_unlock$link4(&call_rcu_mutex$link4);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  if(!(per_cpu_call_rcu_data$link4[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
  {
    if(!(crdp == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock$link4(&call_rcu_mutex$link4);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 17;
      return -17;
    }

  }

  struct call_rcu_data * volatile tmp_statement_expression$4;
  do
  {
    struct call_rcu_data *_________pv = crdp;
    asm("sfence" :  :  : "memory");
    struct call_rcu_data *_v;
    *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data$link4[(signed long int)cpu]))) = _________pv;
    tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data$link4[(signed long int)cpu])));
    _v = tmp_statement_expression$4;
    asm("" :  :  : "memory");
    _v = _v;
  }
  while((_Bool)0);
  call_rcu_unlock$link4(&call_rcu_mutex$link4);
  return 0;
}

// set_cpu_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_mb(signed int cpu, struct call_rcu_data *crdp)
{
  call_rcu_lock$link1(&call_rcu_mutex$link1);
  alloc_cpu_call_rcu_data$link1();
  if((signed long int)cpu >= maxcpus$link1 || !(cpu >= 0))
  {
    static signed int warned = 0;
    if(warned == 0)
    {
      fprintf(stderr, "[error] liburcu: set CPU # out of range\n");
      warned = 1;
    }

    call_rcu_unlock$link1(&call_rcu_mutex$link1);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data$link1 == ((struct call_rcu_data **)NULL))
  {
    call_rcu_unlock$link1(&call_rcu_mutex$link1);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  if(!(per_cpu_call_rcu_data$link1[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
  {
    if(!(crdp == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock$link1(&call_rcu_mutex$link1);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 17;
      return -17;
    }

  }

  struct call_rcu_data * volatile tmp_statement_expression$4;
  do
  {
    struct call_rcu_data *_________pv = crdp;
    asm("sfence" :  :  : "memory");
    struct call_rcu_data *_v;
    *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data$link1[(signed long int)cpu]))) = _________pv;
    tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data$link1[(signed long int)cpu])));
    _v = tmp_statement_expression$4;
    asm("" :  :  : "memory");
    _v = _v;
  }
  while((_Bool)0);
  call_rcu_unlock$link1(&call_rcu_mutex$link1);
  return 0;
}

// set_cpu_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_memb(signed int cpu, struct call_rcu_data *crdp)
{
  call_rcu_lock(&call_rcu_mutex);
  alloc_cpu_call_rcu_data();
  if((signed long int)cpu >= maxcpus || !(cpu >= 0))
  {
    static signed int warned = 0;
    if(warned == 0)
    {
      fprintf(stderr, "[error] liburcu: set CPU # out of range\n");
      warned = 1;
    }

    call_rcu_unlock(&call_rcu_mutex);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data == ((struct call_rcu_data **)NULL))
  {
    call_rcu_unlock(&call_rcu_mutex);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  if(!(per_cpu_call_rcu_data[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
  {
    if(!(crdp == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock(&call_rcu_mutex);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 17;
      return -17;
    }

  }

  struct call_rcu_data * volatile tmp_statement_expression$4;
  do
  {
    struct call_rcu_data *_________pv = crdp;
    asm("sfence" :  :  : "memory");
    struct call_rcu_data *_v;
    *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data[(signed long int)cpu]))) = _________pv;
    tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data[(signed long int)cpu])));
    _v = tmp_statement_expression$4;
    asm("" :  :  : "memory");
    _v = _v;
  }
  while((_Bool)0);
  call_rcu_unlock(&call_rcu_mutex);
  return 0;
}

// set_cpu_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_qsbr(signed int cpu, struct call_rcu_data *crdp)
{
  call_rcu_lock$link3(&call_rcu_mutex$link3);
  alloc_cpu_call_rcu_data$link3();
  if((signed long int)cpu >= maxcpus$link3 || !(cpu >= 0))
  {
    static signed int warned = 0;
    if(warned == 0)
    {
      fprintf(stderr, "[error] liburcu: set CPU # out of range\n");
      warned = 1;
    }

    call_rcu_unlock$link3(&call_rcu_mutex$link3);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data$link3 == ((struct call_rcu_data **)NULL))
  {
    call_rcu_unlock$link3(&call_rcu_mutex$link3);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  if(!(per_cpu_call_rcu_data$link3[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
  {
    if(!(crdp == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock$link3(&call_rcu_mutex$link3);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 17;
      return -17;
    }

  }

  struct call_rcu_data * volatile tmp_statement_expression$4;
  do
  {
    struct call_rcu_data *_________pv = crdp;
    asm("sfence" :  :  : "memory");
    struct call_rcu_data *_v;
    *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data$link3[(signed long int)cpu]))) = _________pv;
    tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data$link3[(signed long int)cpu])));
    _v = tmp_statement_expression$4;
    asm("" :  :  : "memory");
    _v = _v;
  }
  while((_Bool)0);
  call_rcu_unlock$link3(&call_rcu_mutex$link3);
  return 0;
}

// set_cpu_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 514
signed int set_cpu_call_rcu_data_sig(signed int cpu, struct call_rcu_data *crdp)
{
  call_rcu_lock$link2(&call_rcu_mutex$link2);
  alloc_cpu_call_rcu_data$link2();
  if((signed long int)cpu >= maxcpus$link2 || !(cpu >= 0))
  {
    static signed int warned = 0;
    if(warned == 0)
    {
      fprintf(stderr, "[error] liburcu: set CPU # out of range\n");
      warned = 1;
    }

    call_rcu_unlock$link2(&call_rcu_mutex$link2);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -22;
  }

  if(per_cpu_call_rcu_data$link2 == ((struct call_rcu_data **)NULL))
  {
    call_rcu_unlock$link2(&call_rcu_mutex$link2);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return -12;
  }

  if(!(per_cpu_call_rcu_data$link2[(signed long int)cpu] == ((struct call_rcu_data *)NULL)))
  {
    if(!(crdp == ((struct call_rcu_data *)NULL)))
    {
      call_rcu_unlock$link2(&call_rcu_mutex$link2);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 17;
      return -17;
    }

  }

  struct call_rcu_data * volatile tmp_statement_expression$4;
  do
  {
    struct call_rcu_data *_________pv = crdp;
    asm("sfence" :  :  : "memory");
    struct call_rcu_data *_v;
    *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data$link2[(signed long int)cpu]))) = _________pv;
    tmp_statement_expression$4 = *((struct call_rcu_data * volatile *)&(*(&per_cpu_call_rcu_data$link2[(signed long int)cpu])));
    _v = tmp_statement_expression$4;
    asm("" :  :  : "memory");
    _v = _v;
  }
  while((_Bool)0);
  call_rcu_unlock$link2(&call_rcu_mutex$link2);
  return 0;
}

// set_thread_call_rcu_data_bp
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_bp(struct call_rcu_data *crdp)
{
  thread_call_rcu_data$link4 = crdp;
}

// set_thread_call_rcu_data_mb
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_mb(struct call_rcu_data *crdp)
{
  thread_call_rcu_data$link1 = crdp;
}

// set_thread_call_rcu_data_memb
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_memb(struct call_rcu_data *crdp)
{
  thread_call_rcu_data = crdp;
}

// set_thread_call_rcu_data_qsbr
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_qsbr(struct call_rcu_data *crdp)
{
  thread_call_rcu_data$link3 = crdp;
}

// set_thread_call_rcu_data_sig
// file urcu-call-rcu-impl.h line 614
void set_thread_call_rcu_data_sig(struct call_rcu_data *crdp)
{
  thread_call_rcu_data$link2 = crdp;
}

// set_thread_cpu_affinity
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity(struct call_rcu_data *crdp)
{
  struct anonymous$2 mask;
  signed int ret;
  signed int *return_value___errno_location$3;
  if(!(crdp->cpu_affinity >= 0))
    return 0;

  else
  {
    crdp->gp_count = crdp->gp_count + 1ul;
    if(!((255ul & crdp->gp_count) == 0ul))
      return 0;

    else
    {
      signed int return_value_urcu_sched_getcpu$1;
      return_value_urcu_sched_getcpu$1=urcu_sched_getcpu();
      if(return_value_urcu_sched_getcpu$1 == crdp->cpu_affinity)
        return 0;

      else
      {
        do
          __builtin_memset((void *)&mask, 0, sizeof(struct anonymous$2) /*128ul*/ );
        while((_Bool)0);
        unsigned long int __cpu = (unsigned long int)crdp->cpu_affinity;
        if(!(__cpu / 8ul >= sizeof(struct anonymous$2) /*128ul*/ ))
          ((unsigned long int *)(&mask)->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)(&mask)->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

        else
          (unsigned long int)0;
        ret=sched_setaffinity(0, sizeof(struct anonymous$2) /*128ul*/ , &mask);
        if(!(ret == 0))
        {
          return_value___errno_location$3=__errno_location();
          if(*return_value___errno_location$3 == 22)
          {
            ret = 0;
            signed int *return_value___errno_location$2;
            return_value___errno_location$2=__errno_location();
            *return_value___errno_location$2 = 0;
          }

        }

        return ret;
      }
    }
  }
}

// set_thread_cpu_affinity$link1
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity$link1(struct call_rcu_data *crdp$link1)
{
  struct anonymous$2 mask$link1;
  signed int ret$link1;
  signed int *return_value___errno_location$3$link1;
  if(!(crdp$link1->cpu_affinity >= 0))
    return 0;

  else
  {
    crdp$link1->gp_count = crdp$link1->gp_count + 1ul;
    if(!((255ul & crdp$link1->gp_count) == 0ul))
      return 0;

    else
    {
      signed int return_value_urcu_sched_getcpu$1$link1;
      return_value_urcu_sched_getcpu$1$link1=urcu_sched_getcpu$link1();
      if(return_value_urcu_sched_getcpu$1$link1 == crdp$link1->cpu_affinity)
        return 0;

      else
      {
        do
          __builtin_memset((void *)&mask$link1, 0, sizeof(struct anonymous$2) /*128ul*/ );
        while((_Bool)0);
        unsigned long int __cpu$link1 = (unsigned long int)crdp$link1->cpu_affinity;
        if(!(__cpu$link1 / 8ul >= sizeof(struct anonymous$2) /*128ul*/ ))
          ((unsigned long int *)(&mask$link1)->__bits)[(signed long int)(__cpu$link1 / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)(&mask$link1)->__bits)[(signed long int)(__cpu$link1 / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu$link1 % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

        else
          (unsigned long int)0;
        ret$link1=sched_setaffinity(0, sizeof(struct anonymous$2) /*128ul*/ , &mask$link1);
        if(!(ret$link1 == 0))
        {
          return_value___errno_location$3$link1=__errno_location();
          if(*return_value___errno_location$3$link1 == 22)
          {
            ret$link1 = 0;
            signed int *return_value___errno_location$2$link1;
            return_value___errno_location$2$link1=__errno_location();
            *return_value___errno_location$2$link1 = 0;
          }

        }

        return ret$link1;
      }
    }
  }
}

// set_thread_cpu_affinity$link2
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity$link2(struct call_rcu_data *crdp$link2)
{
  struct anonymous$2 mask$link2;
  signed int ret$link2;
  signed int *return_value___errno_location$3$link2;
  if(!(crdp$link2->cpu_affinity >= 0))
    return 0;

  else
  {
    crdp$link2->gp_count = crdp$link2->gp_count + 1ul;
    if(!((255ul & crdp$link2->gp_count) == 0ul))
      return 0;

    else
    {
      signed int return_value_urcu_sched_getcpu$1$link2;
      return_value_urcu_sched_getcpu$1$link2=urcu_sched_getcpu$link2();
      if(return_value_urcu_sched_getcpu$1$link2 == crdp$link2->cpu_affinity)
        return 0;

      else
      {
        do
          __builtin_memset((void *)&mask$link2, 0, sizeof(struct anonymous$2) /*128ul*/ );
        while((_Bool)0);
        unsigned long int __cpu$link2 = (unsigned long int)crdp$link2->cpu_affinity;
        if(!(__cpu$link2 / 8ul >= sizeof(struct anonymous$2) /*128ul*/ ))
          ((unsigned long int *)(&mask$link2)->__bits)[(signed long int)(__cpu$link2 / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)(&mask$link2)->__bits)[(signed long int)(__cpu$link2 / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu$link2 % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

        else
          (unsigned long int)0;
        ret$link2=sched_setaffinity(0, sizeof(struct anonymous$2) /*128ul*/ , &mask$link2);
        if(!(ret$link2 == 0))
        {
          return_value___errno_location$3$link2=__errno_location();
          if(*return_value___errno_location$3$link2 == 22)
          {
            ret$link2 = 0;
            signed int *return_value___errno_location$2$link2;
            return_value___errno_location$2$link2=__errno_location();
            *return_value___errno_location$2$link2 = 0;
          }

        }

        return ret$link2;
      }
    }
  }
}

// set_thread_cpu_affinity$link3
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity$link3(struct call_rcu_data *crdp$link3)
{
  struct anonymous$2 mask$link3;
  signed int ret$link3;
  signed int *return_value___errno_location$3$link3;
  if(!(crdp$link3->cpu_affinity >= 0))
    return 0;

  else
  {
    crdp$link3->gp_count = crdp$link3->gp_count + 1ul;
    if(!((255ul & crdp$link3->gp_count) == 0ul))
      return 0;

    else
    {
      signed int return_value_urcu_sched_getcpu$1$link3;
      return_value_urcu_sched_getcpu$1$link3=urcu_sched_getcpu$link3();
      if(return_value_urcu_sched_getcpu$1$link3 == crdp$link3->cpu_affinity)
        return 0;

      else
      {
        do
          __builtin_memset((void *)&mask$link3, 0, sizeof(struct anonymous$2) /*128ul*/ );
        while((_Bool)0);
        unsigned long int __cpu$link3 = (unsigned long int)crdp$link3->cpu_affinity;
        if(!(__cpu$link3 / 8ul >= sizeof(struct anonymous$2) /*128ul*/ ))
          ((unsigned long int *)(&mask$link3)->__bits)[(signed long int)(__cpu$link3 / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)(&mask$link3)->__bits)[(signed long int)(__cpu$link3 / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu$link3 % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

        else
          (unsigned long int)0;
        ret$link3=sched_setaffinity(0, sizeof(struct anonymous$2) /*128ul*/ , &mask$link3);
        if(!(ret$link3 == 0))
        {
          return_value___errno_location$3$link3=__errno_location();
          if(*return_value___errno_location$3$link3 == 22)
          {
            ret$link3 = 0;
            signed int *return_value___errno_location$2$link3;
            return_value___errno_location$2$link3=__errno_location();
            *return_value___errno_location$2$link3 = 0;
          }

        }

        return ret$link3;
      }
    }
  }
}

// set_thread_cpu_affinity$link4
// file urcu-call-rcu-impl.h line 202
static signed int set_thread_cpu_affinity$link4(struct call_rcu_data *crdp$link4)
{
  struct anonymous$2 mask$link4;
  signed int ret$link4;
  signed int *return_value___errno_location$3$link4;
  if(!(crdp$link4->cpu_affinity >= 0))
    return 0;

  else
  {
    crdp$link4->gp_count = crdp$link4->gp_count + 1ul;
    if(!((255ul & crdp$link4->gp_count) == 0ul))
      return 0;

    else
    {
      signed int return_value_urcu_sched_getcpu$1$link4;
      return_value_urcu_sched_getcpu$1$link4=urcu_sched_getcpu$link4();
      if(return_value_urcu_sched_getcpu$1$link4 == crdp$link4->cpu_affinity)
        return 0;

      else
      {
        do
          __builtin_memset((void *)&mask$link4, 0, sizeof(struct anonymous$2) /*128ul*/ );
        while((_Bool)0);
        unsigned long int __cpu$link4 = (unsigned long int)crdp$link4->cpu_affinity;
        if(!(__cpu$link4 / 8ul >= sizeof(struct anonymous$2) /*128ul*/ ))
          ((unsigned long int *)(&mask$link4)->__bits)[(signed long int)(__cpu$link4 / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)(&mask$link4)->__bits)[(signed long int)(__cpu$link4 / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu$link4 % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

        else
          (unsigned long int)0;
        ret$link4=sched_setaffinity(0, sizeof(struct anonymous$2) /*128ul*/ , &mask$link4);
        if(!(ret$link4 == 0))
        {
          return_value___errno_location$3$link4=__errno_location();
          if(*return_value___errno_location$3$link4 == 22)
          {
            ret$link4 = 0;
            signed int *return_value___errno_location$2$link4;
            return_value___errno_location$2$link4=__errno_location();
            *return_value___errno_location$2$link4 = 0;
          }

        }

        return ret$link4;
      }
    }
  }
}

// sigrcu_handler
// file urcu.c line 551
static void sigrcu_handler(signed int signo, struct anonymous$14 *siginfo, void *context)
{
  asm("mfence" :  :  : "memory");
  *((volatile char *)&rcu_reader_sig.need_mb) = (volatile char)0;
  asm("mfence" :  :  : "memory");
}

// skip
// file tap.c line 323
signed int skip(unsigned int n, char *fmt, ...)
{
  void **ap;
  char *skip_msg = (char *)(void *)0;
  ap = (void **)&fmt;
  signed int return_value_asprintf$1;
  return_value_asprintf$1=asprintf(&skip_msg, fmt, ap);
  if(return_value_asprintf$1 == -1)
    skip_msg = (char *)(void *)0;

  ap = ((void **)NULL);
  unsigned int tmp_post$2;
  do
  {
    tmp_post$2 = n;
    n = n - 1u;
    if(!(tmp_post$2 >= 1u))
      break;

    test_count = test_count + 1u;
    printf("ok %d # skip %s\n", test_count, skip_msg != (char *)(void *)0 ? skip_msg : "libtap():malloc() failed");
  }
  while((_Bool)1);
  free((void *)skip_msg);
  return 1;
}

// smp_mb_master
// file urcu.c line 162
static void smp_mb_master(void)
{
  if(!(rcu_has_sys_membarrier_memb == 0))
    syscall((signed long int)324, 1, 0);

  else
    asm("mfence" :  :  : "memory");
}

// smp_mb_master$link1
// file urcu.c line 172
static void smp_mb_master$link1(void)
{
  asm("mfence" :  :  : "memory");
}

// smp_mb_master$link2
// file urcu.c line 221
static void smp_mb_master$link2(void)
{
  force_mb_all_readers();
}

// smp_mb_master$link3
// file urcu-bp.c line 192
static void smp_mb_master$link3(void)
{
  if(!(urcu_bp_has_sys_membarrier == 0))
    syscall((signed long int)324, 1, 0);

  else
    asm("mfence" :  :  : "memory");
}

// smp_mb_slave
// file urcu/static/urcu.h line 95
static inline void smp_mb_slave(void)
{
  if(!(rcu_has_sys_membarrier_memb == 0))
    asm("" :  :  : "memory");

  else
    asm("mfence" :  :  : "memory");
}

// smp_mb_slave$link1
// file urcu/static/urcu.h line 105
static inline void smp_mb_slave$link1(void)
{
  asm("mfence" :  :  : "memory");
}

// smp_mb_slave$link2
// file urcu/static/urcu.h line 112
static inline void smp_mb_slave$link2(void)
{
  asm("" :  :  : "memory");
}

// start_defer_thread
// file urcu-defer-impl.h line 400
static void start_defer_thread(void)
{
  signed int ret;
  ret=pthread_create(&tid_defer, (const union pthread_attr_t *)(void *)0, thr_defer, (void *)0);
  /* assertion !ret */
  assert(!(ret != 0));
}

// start_defer_thread$link1
// file urcu-defer-impl.h line 400
static void start_defer_thread$link1(void)
{
  signed int ret$link1;
  ret$link1=pthread_create(&tid_defer$link1, (const union pthread_attr_t *)(void *)0, thr_defer$link1, (void *)0);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
}

// start_defer_thread$link2
// file urcu-defer-impl.h line 400
static void start_defer_thread$link2(void)
{
  signed int ret$link2;
  ret$link2=pthread_create(&tid_defer$link2, (const union pthread_attr_t *)(void *)0, thr_defer$link2, (void *)0);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
}

// start_defer_thread$link3
// file urcu-defer-impl.h line 400
static void start_defer_thread$link3(void)
{
  signed int ret$link3;
  ret$link3=pthread_create(&tid_defer$link3, (const union pthread_attr_t *)(void *)0, thr_defer$link3, (void *)0);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
}

// start_defer_thread$link4
// file urcu-defer-impl.h line 400
static void start_defer_thread$link4(void)
{
  signed int ret$link4;
  ret$link4=pthread_create(&tid_defer$link4, (const union pthread_attr_t *)(void *)0, thr_defer$link4, (void *)0);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
}

// stop_defer_thread
// file urcu-defer-impl.h line 408
static void stop_defer_thread(void)
{
  signed int ret;
  void *tret;
  *((volatile signed int *)&defer_thread_stop) = 1;
  asm("mfence" :  :  : "memory");
  wake_up_defer();
  ret=pthread_join(tid_defer, &tret);
  /* assertion !ret */
  assert(!(ret != 0));
  signed int _v;
  volatile signed int tmp_statement_expression$1;
  *((volatile signed int *)&defer_thread_stop) = 0;
  tmp_statement_expression$1 = *((volatile signed int *)&defer_thread_stop);
  _v = tmp_statement_expression$1;
  asm("" :  :  : "memory");
  _v = _v;
  volatile signed int tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((volatile signed int *)&(*(&defer_thread_futex)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&defer_thread_futex)) *)&(*(&defer_thread_futex))); }) == 0 */
  assert(tmp_statement_expression$2 == 0);
}

// stop_defer_thread$link1
// file urcu-defer-impl.h line 408
static void stop_defer_thread$link1(void)
{
  signed int ret$link1;
  void *tret$link1;
  *((volatile signed int *)&defer_thread_stop$link1) = 1;
  asm("mfence" :  :  : "memory");
  wake_up_defer$link1();
  ret$link1=pthread_join(tid_defer$link1, &tret$link1);
  /* assertion !ret */
  assert(!(ret$link1 != 0));
  signed int _v$link1;
  volatile signed int tmp_statement_expression$1$link1;
  *((volatile signed int *)&defer_thread_stop$link1) = 0;
  tmp_statement_expression$1$link1 = *((volatile signed int *)&defer_thread_stop$link1);
  _v$link1 = tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
  volatile signed int tmp_statement_expression$2$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link1 = *((volatile signed int *)&(*(&defer_thread_futex$link1)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&defer_thread_futex)) *)&(*(&defer_thread_futex))); }) == 0 */
  assert(tmp_statement_expression$2$link1 == 0);
}

// stop_defer_thread$link2
// file urcu-defer-impl.h line 408
static void stop_defer_thread$link2(void)
{
  signed int ret$link2;
  void *tret$link2;
  *((volatile signed int *)&defer_thread_stop$link2) = 1;
  asm("mfence" :  :  : "memory");
  wake_up_defer$link2();
  ret$link2=pthread_join(tid_defer$link2, &tret$link2);
  /* assertion !ret */
  assert(!(ret$link2 != 0));
  signed int _v$link2;
  volatile signed int tmp_statement_expression$1$link2;
  *((volatile signed int *)&defer_thread_stop$link2) = 0;
  tmp_statement_expression$1$link2 = *((volatile signed int *)&defer_thread_stop$link2);
  _v$link2 = tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  _v$link2 = _v$link2;
  volatile signed int tmp_statement_expression$2$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link2 = *((volatile signed int *)&(*(&defer_thread_futex$link2)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&defer_thread_futex)) *)&(*(&defer_thread_futex))); }) == 0 */
  assert(tmp_statement_expression$2$link2 == 0);
}

// stop_defer_thread$link3
// file urcu-defer-impl.h line 408
static void stop_defer_thread$link3(void)
{
  signed int ret$link3;
  void *tret$link3;
  *((volatile signed int *)&defer_thread_stop$link3) = 1;
  asm("mfence" :  :  : "memory");
  wake_up_defer$link3();
  ret$link3=pthread_join(tid_defer$link3, &tret$link3);
  /* assertion !ret */
  assert(!(ret$link3 != 0));
  signed int _v$link3;
  volatile signed int tmp_statement_expression$1$link3;
  *((volatile signed int *)&defer_thread_stop$link3) = 0;
  tmp_statement_expression$1$link3 = *((volatile signed int *)&defer_thread_stop$link3);
  _v$link3 = tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  _v$link3 = _v$link3;
  volatile signed int tmp_statement_expression$2$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link3 = *((volatile signed int *)&(*(&defer_thread_futex$link3)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&defer_thread_futex)) *)&(*(&defer_thread_futex))); }) == 0 */
  assert(tmp_statement_expression$2$link3 == 0);
}

// stop_defer_thread$link4
// file urcu-defer-impl.h line 408
static void stop_defer_thread$link4(void)
{
  signed int ret$link4;
  void *tret$link4;
  *((volatile signed int *)&defer_thread_stop$link4) = 1;
  asm("mfence" :  :  : "memory");
  wake_up_defer$link4();
  ret$link4=pthread_join(tid_defer$link4, &tret$link4);
  /* assertion !ret */
  assert(!(ret$link4 != 0));
  signed int _v$link4;
  volatile signed int tmp_statement_expression$1$link4;
  *((volatile signed int *)&defer_thread_stop$link4) = 0;
  tmp_statement_expression$1$link4 = *((volatile signed int *)&defer_thread_stop$link4);
  _v$link4 = tmp_statement_expression$1$link4;
  asm("" :  :  : "memory");
  _v$link4 = _v$link4;
  volatile signed int tmp_statement_expression$2$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link4 = *((volatile signed int *)&(*(&defer_thread_futex$link4)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&defer_thread_futex)) *)&(*(&defer_thread_futex))); }) == 0 */
  assert(tmp_statement_expression$2$link4 == 0);
}

// synchronize_rcu_bp
// file ../../urcu-bp.h line 141
extern void synchronize_rcu_bp(void)
{
  struct cds_list_head cur_snap_readers = { .next=&cur_snap_readers, .prev=&cur_snap_readers };
  struct cds_list_head qsreaders = { .next=&qsreaders, .prev=&qsreaders };
  struct anonymous$16 newmask;
  struct anonymous$16 oldmask;
  signed int ret;
  ret=sigfillset(&newmask);
  /* assertion !ret */
  assert(!(ret != 0));
  ret=pthread_sigmask(0, &newmask, &oldmask);
  /* assertion !ret */
  assert(!(ret != 0));
  mutex_lock$link4(&rcu_gp_lock$link4);
  mutex_lock$link4(&rcu_registry_lock$link4);
  signed int return_value_cds_list_empty$1;
  return_value_cds_list_empty$1=cds_list_empty$link4(&registry$link4);
  volatile unsigned long int tmp_statement_expression$2;
  if(return_value_cds_list_empty$1 == 0)
  {
    smp_mb_master$link3();
    wait_for_readers$link4(&registry$link4, &cur_snap_readers, &qsreaders);
    asm("mfence" :  :  : "memory");
    unsigned long int _v;
    *((volatile unsigned long int *)&rcu_gp_bp.ctr) = rcu_gp_bp.ctr ^ 1UL << (sizeof(signed long int) /*8ul*/  << 2);
    tmp_statement_expression$2 = *((volatile unsigned long int *)&rcu_gp_bp.ctr);
    _v = tmp_statement_expression$2;
    asm("" :  :  : "memory");
    _v = _v;
    asm("mfence" :  :  : "memory");
    wait_for_readers$link4(&cur_snap_readers, (struct cds_list_head *)(void *)0, &qsreaders);
    cds_list_splice$link4(&qsreaders, &registry$link4);
    smp_mb_master$link3();
  }


out:
  ;
  mutex_unlock$link4(&rcu_registry_lock$link4);
  mutex_unlock$link4(&rcu_gp_lock$link4);
  ret=pthread_sigmask(2, &oldmask, (struct anonymous$16 *)(void *)0);
  /* assertion !ret */
  assert(!(ret != 0));
}

// synchronize_rcu_mb
// file ../../urcu.h line 101
extern void synchronize_rcu_mb(void)
{
  struct cds_list_head cur_snap_readers = { .next=&cur_snap_readers, .prev=&cur_snap_readers };
  struct cds_list_head qsreaders = { .next=&qsreaders, .prev=&qsreaders };
  struct urcu_wait_node wait = { .node={ .next=((struct cds_wfs_node *)NULL) }, .state=URCU_WAIT_WAITING };
  struct urcu_waiters waiters;
  _Bool return_value_urcu_wait_add$1;
  return_value_urcu_wait_add$1=urcu_wait_add$link1(&gp_waiters$link1, &wait);
  volatile unsigned long int tmp_statement_expression$3;
  if(!((signed int)return_value_urcu_wait_add$1 == 0))
  {
    urcu_adaptative_busy_wait$link1(&wait);
    asm("mfence" :  :  : "memory");
  }

  else
  {
    urcu_wait_set_state$link1(&wait, (enum urcu_wait_state)URCU_WAIT_RUNNING);
    mutex_lock$link1(&rcu_gp_lock$link1);
    urcu_move_waiters$link1(&waiters, &gp_waiters$link1);
    mutex_lock$link1(&rcu_registry_lock$link1);
    signed int return_value_cds_list_empty$2;
    return_value_cds_list_empty$2=cds_list_empty$link1(&registry$link1);
    if(return_value_cds_list_empty$2 == 0)
    {
      smp_mb_master$link1();
      wait_for_readers$link1(&registry$link1, &cur_snap_readers, &qsreaders);
      asm("" :  :  : "memory");
      asm("mfence" :  :  : "memory");
      unsigned long int _v;
      *((volatile unsigned long int *)&rcu_gp_mb.ctr) = rcu_gp_mb.ctr ^ 1UL << (sizeof(unsigned long int) /*8ul*/  << 2);
      tmp_statement_expression$3 = *((volatile unsigned long int *)&rcu_gp_mb.ctr);
      _v = tmp_statement_expression$3;
      asm("" :  :  : "memory");
      _v = _v;
      asm("" :  :  : "memory");
      asm("mfence" :  :  : "memory");
      wait_for_readers$link1(&cur_snap_readers, (struct cds_list_head *)(void *)0, &qsreaders);
      cds_list_splice$link1(&qsreaders, &registry$link1);
      smp_mb_master$link1();
    }


  out:
    ;
    mutex_unlock$link1(&rcu_registry_lock$link1);
    mutex_unlock$link1(&rcu_gp_lock$link1);
    urcu_wake_all_waiters$link1(&waiters);
  }
}

// synchronize_rcu_memb
// file ../../urcu.h line 101
extern void synchronize_rcu_memb(void)
{
  struct cds_list_head cur_snap_readers = { .next=&cur_snap_readers, .prev=&cur_snap_readers };
  struct cds_list_head qsreaders = { .next=&qsreaders, .prev=&qsreaders };
  struct urcu_wait_node wait = { .node={ .next=((struct cds_wfs_node *)NULL) }, .state=URCU_WAIT_WAITING };
  struct urcu_waiters waiters;
  _Bool return_value_urcu_wait_add$1;
  return_value_urcu_wait_add$1=urcu_wait_add(&gp_waiters, &wait);
  volatile unsigned long int tmp_statement_expression$3;
  if(!((signed int)return_value_urcu_wait_add$1 == 0))
  {
    urcu_adaptative_busy_wait(&wait);
    asm("mfence" :  :  : "memory");
  }

  else
  {
    urcu_wait_set_state(&wait, (enum urcu_wait_state)URCU_WAIT_RUNNING);
    mutex_lock(&rcu_gp_lock);
    urcu_move_waiters(&waiters, &gp_waiters);
    mutex_lock(&rcu_registry_lock);
    signed int return_value_cds_list_empty$2;
    return_value_cds_list_empty$2=cds_list_empty(&registry);
    if(return_value_cds_list_empty$2 == 0)
    {
      smp_mb_master();
      wait_for_readers(&registry, &cur_snap_readers, &qsreaders);
      asm("" :  :  : "memory");
      asm("mfence" :  :  : "memory");
      unsigned long int _v;
      *((volatile unsigned long int *)&rcu_gp_memb.ctr) = rcu_gp_memb.ctr ^ 1UL << (sizeof(unsigned long int) /*8ul*/  << 2);
      tmp_statement_expression$3 = *((volatile unsigned long int *)&rcu_gp_memb.ctr);
      _v = tmp_statement_expression$3;
      asm("" :  :  : "memory");
      _v = _v;
      asm("" :  :  : "memory");
      asm("mfence" :  :  : "memory");
      wait_for_readers(&cur_snap_readers, (struct cds_list_head *)(void *)0, &qsreaders);
      cds_list_splice(&qsreaders, &registry);
      smp_mb_master();
    }


  out:
    ;
    mutex_unlock(&rcu_registry_lock);
    mutex_unlock(&rcu_gp_lock);
    urcu_wake_all_waiters(&waiters);
  }
}

// synchronize_rcu_qsbr
// file ../../urcu-qsbr.h line 122
extern void synchronize_rcu_qsbr(void)
{
  struct cds_list_head qsreaders = { .next=&qsreaders, .prev=&qsreaders };
  unsigned long int was_online;
  struct urcu_wait_node wait = { .node={ .next=((struct cds_wfs_node *)NULL) }, .state=URCU_WAIT_WAITING };
  struct urcu_waiters waiters;
  signed int return_value_rcu_read_ongoing_qsbr$1;
  return_value_rcu_read_ongoing_qsbr$1=rcu_read_ongoing_qsbr();
  was_online = (unsigned long int)return_value_rcu_read_ongoing_qsbr$1;
  if(!(was_online == 0ul))
    rcu_thread_offline_qsbr();

  else
    asm("mfence" :  :  : "memory");
  _Bool return_value_urcu_wait_add$2;
  return_value_urcu_wait_add$2=urcu_wait_add$link3(&gp_waiters$link3, &wait);
  signed int return_value_cds_list_empty$3;
  volatile unsigned long int tmp_statement_expression$4;
  if(!((signed int)return_value_urcu_wait_add$2 == 0))
    urcu_adaptative_busy_wait$link3(&wait);

  else
  {
    urcu_wait_set_state$link3(&wait, (enum urcu_wait_state)URCU_WAIT_RUNNING);
    mutex_lock$link3(&rcu_gp_lock$link3);
    urcu_move_waiters$link3(&waiters, &gp_waiters$link3);
    mutex_lock$link3(&rcu_registry_lock$link3);
    return_value_cds_list_empty$3=cds_list_empty$link3(&registry$link3);
    if(return_value_cds_list_empty$3 == 0)
    {
      unsigned long int _v;
      *((volatile unsigned long int *)&rcu_gp_qsbr.ctr) = rcu_gp_qsbr.ctr + (1UL << 1);
      tmp_statement_expression$4 = *((volatile unsigned long int *)&rcu_gp_qsbr.ctr);
      _v = tmp_statement_expression$4;
      asm("" :  :  : "memory");
      _v = _v;
      asm("" :  :  : "memory");
      asm("mfence" :  :  : "memory");
      wait_for_readers$link3(&registry$link3, (struct cds_list_head *)(void *)0, &qsreaders);
      cds_list_splice$link3(&qsreaders, &registry$link3);
    }


  out:
    ;
    mutex_unlock$link3(&rcu_registry_lock$link3);
    mutex_unlock$link3(&rcu_gp_lock$link3);
    urcu_wake_all_waiters$link3(&waiters);
  }

gp_end:
  ;
  if(!(was_online == 0ul))
    rcu_thread_online_qsbr();

  else
    asm("mfence" :  :  : "memory");
}

// synchronize_rcu_sig
// file ../../urcu.h line 101
extern void synchronize_rcu_sig(void)
{
  struct cds_list_head cur_snap_readers = { .next=&cur_snap_readers, .prev=&cur_snap_readers };
  struct cds_list_head qsreaders = { .next=&qsreaders, .prev=&qsreaders };
  struct urcu_wait_node wait = { .node={ .next=((struct cds_wfs_node *)NULL) }, .state=URCU_WAIT_WAITING };
  struct urcu_waiters waiters;
  _Bool return_value_urcu_wait_add$1;
  return_value_urcu_wait_add$1=urcu_wait_add$link2(&gp_waiters$link2, &wait);
  volatile unsigned long int tmp_statement_expression$3;
  if(!((signed int)return_value_urcu_wait_add$1 == 0))
  {
    urcu_adaptative_busy_wait$link2(&wait);
    asm("mfence" :  :  : "memory");
  }

  else
  {
    urcu_wait_set_state$link2(&wait, (enum urcu_wait_state)URCU_WAIT_RUNNING);
    mutex_lock$link2(&rcu_gp_lock$link2);
    urcu_move_waiters$link2(&waiters, &gp_waiters$link2);
    mutex_lock$link2(&rcu_registry_lock$link2);
    signed int return_value_cds_list_empty$2;
    return_value_cds_list_empty$2=cds_list_empty$link2(&registry$link2);
    if(return_value_cds_list_empty$2 == 0)
    {
      smp_mb_master$link2();
      wait_for_readers$link2(&registry$link2, &cur_snap_readers, &qsreaders);
      asm("" :  :  : "memory");
      asm("mfence" :  :  : "memory");
      unsigned long int _v;
      *((volatile unsigned long int *)&rcu_gp_sig.ctr) = rcu_gp_sig.ctr ^ 1UL << (sizeof(unsigned long int) /*8ul*/  << 2);
      tmp_statement_expression$3 = *((volatile unsigned long int *)&rcu_gp_sig.ctr);
      _v = tmp_statement_expression$3;
      asm("" :  :  : "memory");
      _v = _v;
      asm("" :  :  : "memory");
      asm("mfence" :  :  : "memory");
      wait_for_readers$link2(&cur_snap_readers, (struct cds_list_head *)(void *)0, &qsreaders);
      cds_list_splice$link2(&qsreaders, &registry$link2);
      smp_mb_master$link2();
    }


  out:
    ;
    mutex_unlock$link2(&rcu_registry_lock$link2);
    mutex_unlock$link2(&rcu_gp_lock$link2);
    urcu_wake_all_waiters$link2(&waiters);
  }
}

// tap_disable
// file tap.c line 469
void tap_disable(void)
{
  tap_is_disabled = 1;
}

// test_mf_bp
// file test_urcu_multiflavor.h line 28
extern signed int test_mf_bp(void)
{
  rcu_register_thread_bp();
  rcu_read_lock_bp();
  rcu_read_unlock_bp();
  synchronize_rcu_bp();
  rcu_unregister_thread_bp();
  return 0;
}

// test_mf_mb
// file test_urcu_multiflavor.h line 25
extern signed int test_mf_mb(void)
{
  rcu_register_thread_mb();
  rcu_read_lock_mb();
  rcu_read_unlock_mb();
  synchronize_rcu_mb();
  rcu_unregister_thread_mb();
  return 0;
}

// test_mf_memb
// file test_urcu_multiflavor.h line 24
extern signed int test_mf_memb(void)
{
  rcu_register_thread_memb();
  rcu_read_lock_memb();
  rcu_read_unlock_memb();
  synchronize_rcu_memb();
  rcu_unregister_thread_memb();
  return 0;
}

// test_mf_qsbr
// file test_urcu_multiflavor.h line 27
extern signed int test_mf_qsbr(void)
{
  rcu_register_thread_qsbr();
  rcu_read_lock_qsbr();
  rcu_read_unlock_qsbr();
  synchronize_rcu_qsbr();
  rcu_unregister_thread_qsbr();
  return 0;
}

// test_mf_signal
// file test_urcu_multiflavor.h line 26
extern signed int test_mf_signal(void)
{
  rcu_register_thread_sig();
  rcu_read_lock_sig();
  rcu_read_unlock_sig();
  synchronize_rcu_sig();
  rcu_unregister_thread_sig();
  return 0;
}

// thr_defer
// file urcu-defer-impl.h line 374
static void * thr_defer(void *args)
{
  do
  {
    wait_defer();
    poll((struct pollfd *)(void *)0, (unsigned long int)0, 100);
    rcu_defer_barrier_memb();
  }
  while((_Bool)1);
  return (void *)0;
}

// thr_defer$link1
// file urcu-defer-impl.h line 374
static void * thr_defer$link1(void *args$link1)
{
  do
  {
    wait_defer$link1();
    poll((struct pollfd *)(void *)0, (unsigned long int)0, 100);
    rcu_defer_barrier_mb();
  }
  while((_Bool)1);
  return (void *)0;
}

// thr_defer$link2
// file urcu-defer-impl.h line 374
static void * thr_defer$link2(void *args$link2)
{
  do
  {
    wait_defer$link2();
    poll((struct pollfd *)(void *)0, (unsigned long int)0, 100);
    rcu_defer_barrier_sig();
  }
  while((_Bool)1);
  return (void *)0;
}

// thr_defer$link3
// file urcu-defer-impl.h line 374
static void * thr_defer$link3(void *args$link3)
{
  do
  {
    wait_defer$link3();
    poll((struct pollfd *)(void *)0, (unsigned long int)0, 100);
    rcu_defer_barrier_qsbr();
  }
  while((_Bool)1);
  return (void *)0;
}

// thr_defer$link4
// file urcu-defer-impl.h line 374
static void * thr_defer$link4(void *args$link4)
{
  do
  {
    wait_defer$link4();
    poll((struct pollfd *)(void *)0, (unsigned long int)0, 100);
    rcu_defer_barrier_bp();
  }
  while((_Bool)1);
  return (void *)0;
}

// todo_end
// file tap.c line 369
void todo_end(void)
{
  todo = 0;
  free((void *)todo_msg);
}

// todo_start
// file tap.c line 351
void todo_start(char *fmt, ...)
{
  void **ap = (void **)&fmt;
  signed int return_value_vasprintf$1;
  return_value_vasprintf$1=vasprintf(&todo_msg, fmt, ap);
  if(return_value_vasprintf$1 == -1)
    todo_msg = (char *)(void *)0;

  ap = ((void **)NULL);
  todo = 1;
}

// urcu_adaptative_busy_wait
// file urcu-wait.h line 140
static inline void urcu_adaptative_busy_wait(struct urcu_wait_node *wait)
{
  unsigned int i;
  asm("" :  :  : "memory");
  i = (unsigned int)0;
  volatile signed int tmp_statement_expression$1;
  for( ; !(i >= 1000u); i = i + 1u)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1 = *((volatile signed int *)&(*(&wait->state)));
    if(!(tmp_statement_expression$1 == URCU_WAIT_WAITING))
      goto skip_futex_wait;

    asm("rep; nop" :  :  : "memory");
  }
  signed int return_value_futex_noasync$2;
  do
  {
    return_value_futex_noasync$2=futex_noasync(&wait->state, 0, URCU_WAIT_WAITING, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(return_value_futex_noasync$2 == 0)
      break;

    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    switch(*return_value___errno_location$3)
    {
      case 11:
        goto skip_futex_wait;
      case 4:
        break;
      default:
        do
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          char *return_value_strerror$5;
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          fprintf(stderr, "(urcu-wait.h:%s@%u) Unrecoverable error: %s\n", (const void *)"urcu_adaptative_busy_wait", 162, return_value_strerror$5);
          abort();
        }
        while((_Bool)0);
    }
  }
  while((_Bool)1);

skip_futex_wait:
  ;
  __uatomic_or((void *)&wait->state, (unsigned long int)URCU_WAIT_RUNNING, (signed int)sizeof(signed int) /*4ul*/ );
  i = (unsigned int)0;
  volatile signed int tmp_statement_expression$6;
  for( ; !(i >= 1000u); i = i + 1u)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$6 = *((volatile signed int *)&(*(&wait->state)));
    if(!((URCU_WAIT_TEARDOWN & tmp_statement_expression$6) == 0))
      break;

    asm("rep; nop" :  :  : "memory");
  }
  volatile signed int tmp_statement_expression$7;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$7 = *((volatile signed int *)&(*(&wait->state)));
    if(!((URCU_WAIT_TEARDOWN & tmp_statement_expression$7) == 0))
      break;

    poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
  }
  while((_Bool)1);
  volatile signed int tmp_statement_expression$8;
  asm("" :  :  : "memory");
  tmp_statement_expression$8 = *((volatile signed int *)&(*(&wait->state)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&wait->state)) *)&(*(&wait->state))); }) & URCU_WAIT_TEARDOWN */
  assert((tmp_statement_expression$8 & URCU_WAIT_TEARDOWN) != 0);
}

// urcu_adaptative_busy_wait$link1
// file urcu-wait.h line 140
static inline void urcu_adaptative_busy_wait$link1(struct urcu_wait_node *wait$link1)
{
  unsigned int i$link1;
  asm("" :  :  : "memory");
  i$link1 = (unsigned int)0;
  volatile signed int tmp_statement_expression$1$link1;
  for( ; !(i$link1 >= 1000u); i$link1 = i$link1 + 1u)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&wait$link1->state)));
    if(!(tmp_statement_expression$1$link1 == URCU_WAIT_WAITING))
      goto skip_futex_wait;

    asm("rep; nop" :  :  : "memory");
  }
  signed int return_value_futex_noasync$2$link1;
  do
  {
    return_value_futex_noasync$2$link1=futex_noasync$link1(&wait$link1->state, 0, URCU_WAIT_WAITING, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(return_value_futex_noasync$2$link1 == 0)
      break;

    signed int *return_value___errno_location$3$link1;
    return_value___errno_location$3$link1=__errno_location();
    switch(*return_value___errno_location$3$link1)
    {
      case 11:
        goto skip_futex_wait;
      case 4:
        break;
      default:
        do
        {
          signed int *return_value___errno_location$4$link1;
          return_value___errno_location$4$link1=__errno_location();
          char *return_value_strerror$5$link1;
          return_value_strerror$5$link1=strerror(*return_value___errno_location$4$link1);
          fprintf(stderr, "(urcu-wait.h:%s@%u) Unrecoverable error: %s\n", (const void *)"urcu_adaptative_busy_wait", 162, return_value_strerror$5$link1);
          abort();
        }
        while((_Bool)0);
    }
  }
  while((_Bool)1);

skip_futex_wait:
  ;
  __uatomic_or$link1((void *)&wait$link1->state, (unsigned long int)URCU_WAIT_RUNNING, (signed int)sizeof(signed int) /*4ul*/ );
  i$link1 = (unsigned int)0;
  volatile signed int tmp_statement_expression$6$link1;
  for( ; !(i$link1 >= 1000u); i$link1 = i$link1 + 1u)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$6$link1 = *((volatile signed int *)&(*(&wait$link1->state)));
    if(!((URCU_WAIT_TEARDOWN & tmp_statement_expression$6$link1) == 0))
      break;

    asm("rep; nop" :  :  : "memory");
  }
  volatile signed int tmp_statement_expression$7$link1;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$7$link1 = *((volatile signed int *)&(*(&wait$link1->state)));
    if(!((URCU_WAIT_TEARDOWN & tmp_statement_expression$7$link1) == 0))
      break;

    poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
  }
  while((_Bool)1);
  volatile signed int tmp_statement_expression$8$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$8$link1 = *((volatile signed int *)&(*(&wait$link1->state)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&wait->state)) *)&(*(&wait->state))); }) & URCU_WAIT_TEARDOWN */
  assert((tmp_statement_expression$8$link1 & URCU_WAIT_TEARDOWN) != 0);
}

// urcu_adaptative_busy_wait$link2
// file urcu-wait.h line 140
static inline void urcu_adaptative_busy_wait$link2(struct urcu_wait_node *wait$link2)
{
  unsigned int i$link2;
  asm("" :  :  : "memory");
  i$link2 = (unsigned int)0;
  volatile signed int tmp_statement_expression$1$link2;
  for( ; !(i$link2 >= 1000u); i$link2 = i$link2 + 1u)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&wait$link2->state)));
    if(!(tmp_statement_expression$1$link2 == URCU_WAIT_WAITING))
      goto skip_futex_wait;

    asm("rep; nop" :  :  : "memory");
  }
  signed int return_value_futex_noasync$2$link2;
  do
  {
    return_value_futex_noasync$2$link2=futex_noasync$link2(&wait$link2->state, 0, URCU_WAIT_WAITING, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(return_value_futex_noasync$2$link2 == 0)
      break;

    signed int *return_value___errno_location$3$link2;
    return_value___errno_location$3$link2=__errno_location();
    switch(*return_value___errno_location$3$link2)
    {
      case 11:
        goto skip_futex_wait;
      case 4:
        break;
      default:
        do
        {
          signed int *return_value___errno_location$4$link2;
          return_value___errno_location$4$link2=__errno_location();
          char *return_value_strerror$5$link2;
          return_value_strerror$5$link2=strerror(*return_value___errno_location$4$link2);
          fprintf(stderr, "(urcu-wait.h:%s@%u) Unrecoverable error: %s\n", (const void *)"urcu_adaptative_busy_wait", 162, return_value_strerror$5$link2);
          abort();
        }
        while((_Bool)0);
    }
  }
  while((_Bool)1);

skip_futex_wait:
  ;
  __uatomic_or$link2((void *)&wait$link2->state, (unsigned long int)URCU_WAIT_RUNNING, (signed int)sizeof(signed int) /*4ul*/ );
  i$link2 = (unsigned int)0;
  volatile signed int tmp_statement_expression$6$link2;
  for( ; !(i$link2 >= 1000u); i$link2 = i$link2 + 1u)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$6$link2 = *((volatile signed int *)&(*(&wait$link2->state)));
    if(!((URCU_WAIT_TEARDOWN & tmp_statement_expression$6$link2) == 0))
      break;

    asm("rep; nop" :  :  : "memory");
  }
  volatile signed int tmp_statement_expression$7$link2;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$7$link2 = *((volatile signed int *)&(*(&wait$link2->state)));
    if(!((URCU_WAIT_TEARDOWN & tmp_statement_expression$7$link2) == 0))
      break;

    poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
  }
  while((_Bool)1);
  volatile signed int tmp_statement_expression$8$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$8$link2 = *((volatile signed int *)&(*(&wait$link2->state)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&wait->state)) *)&(*(&wait->state))); }) & URCU_WAIT_TEARDOWN */
  assert((tmp_statement_expression$8$link2 & URCU_WAIT_TEARDOWN) != 0);
}

// urcu_adaptative_busy_wait$link3
// file urcu-wait.h line 140
static inline void urcu_adaptative_busy_wait$link3(struct urcu_wait_node *wait$link3)
{
  unsigned int i$link3;
  asm("" :  :  : "memory");
  i$link3 = (unsigned int)0;
  volatile signed int tmp_statement_expression$1$link3;
  for( ; !(i$link3 >= 1000u); i$link3 = i$link3 + 1u)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&wait$link3->state)));
    if(!(tmp_statement_expression$1$link3 == URCU_WAIT_WAITING))
      goto skip_futex_wait;

    asm("rep; nop" :  :  : "memory");
  }
  signed int return_value_futex_noasync$2$link3;
  do
  {
    return_value_futex_noasync$2$link3=futex_noasync$link3(&wait$link3->state, 0, URCU_WAIT_WAITING, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(return_value_futex_noasync$2$link3 == 0)
      break;

    signed int *return_value___errno_location$3$link3;
    return_value___errno_location$3$link3=__errno_location();
    switch(*return_value___errno_location$3$link3)
    {
      case 11:
        goto skip_futex_wait;
      case 4:
        break;
      default:
        do
        {
          signed int *return_value___errno_location$4$link3;
          return_value___errno_location$4$link3=__errno_location();
          char *return_value_strerror$5$link3;
          return_value_strerror$5$link3=strerror(*return_value___errno_location$4$link3);
          fprintf(stderr, "(urcu-wait.h:%s@%u) Unrecoverable error: %s\n", (const void *)"urcu_adaptative_busy_wait", 162, return_value_strerror$5$link3);
          abort();
        }
        while((_Bool)0);
    }
  }
  while((_Bool)1);

skip_futex_wait:
  ;
  __uatomic_or$link3((void *)&wait$link3->state, (unsigned long int)URCU_WAIT_RUNNING, (signed int)sizeof(signed int) /*4ul*/ );
  i$link3 = (unsigned int)0;
  volatile signed int tmp_statement_expression$6$link3;
  for( ; !(i$link3 >= 1000u); i$link3 = i$link3 + 1u)
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$6$link3 = *((volatile signed int *)&(*(&wait$link3->state)));
    if(!((URCU_WAIT_TEARDOWN & tmp_statement_expression$6$link3) == 0))
      break;

    asm("rep; nop" :  :  : "memory");
  }
  volatile signed int tmp_statement_expression$7$link3;
  do
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$7$link3 = *((volatile signed int *)&(*(&wait$link3->state)));
    if(!((URCU_WAIT_TEARDOWN & tmp_statement_expression$7$link3) == 0))
      break;

    poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);
  }
  while((_Bool)1);
  volatile signed int tmp_statement_expression$8$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$8$link3 = *((volatile signed int *)&(*(&wait$link3->state)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&wait->state)) *)&(*(&wait->state))); }) & URCU_WAIT_TEARDOWN */
  assert((tmp_statement_expression$8$link3 & URCU_WAIT_TEARDOWN) != 0);
}

// urcu_adaptative_wake_up
// file urcu-wait.h line 121
static inline void urcu_adaptative_wake_up(struct urcu_wait_node *wait)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile signed int *)&(*(&wait->state)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&wait->state)) *)&(*(&wait->state))); }) == URCU_WAIT_WAITING */
  assert(tmp_statement_expression$1 == URCU_WAIT_WAITING);
  signed int _v;
  volatile signed int tmp_statement_expression$2;
  *((volatile signed int *)&(*(&wait->state))) = URCU_WAIT_WAKEUP;
  tmp_statement_expression$2 = *((volatile signed int *)&(*(&wait->state)));
  _v = tmp_statement_expression$2;
  asm("" :  :  : "memory");
  _v = _v;
  volatile signed int tmp_statement_expression$6;
  asm("" :  :  : "memory");
  tmp_statement_expression$6 = *((volatile signed int *)&(*(&wait->state)));
  if((URCU_WAIT_RUNNING & tmp_statement_expression$6) == 0)
  {
    signed int return_value_futex_noasync$5;
    return_value_futex_noasync$5=futex_noasync(&wait->state, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_noasync$5 >= 0))
      do
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        fprintf(stderr, "(urcu-wait.h:%s@%u) Unrecoverable error: %s\n", (const void *)"urcu_adaptative_wake_up", 129, return_value_strerror$4);
        abort();
      }
      while((_Bool)0);

  }

  __uatomic_or((void *)&wait->state, (unsigned long int)URCU_WAIT_TEARDOWN, (signed int)sizeof(signed int) /*4ul*/ );
}

// urcu_adaptative_wake_up$link1
// file urcu-wait.h line 121
static inline void urcu_adaptative_wake_up$link1(struct urcu_wait_node *wait$link1)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&wait$link1->state)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&wait->state)) *)&(*(&wait->state))); }) == URCU_WAIT_WAITING */
  assert(tmp_statement_expression$1$link1 == URCU_WAIT_WAITING);
  signed int _v$link1;
  volatile signed int tmp_statement_expression$2$link1;
  *((volatile signed int *)&(*(&wait$link1->state))) = URCU_WAIT_WAKEUP;
  tmp_statement_expression$2$link1 = *((volatile signed int *)&(*(&wait$link1->state)));
  _v$link1 = tmp_statement_expression$2$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
  volatile signed int tmp_statement_expression$6$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$6$link1 = *((volatile signed int *)&(*(&wait$link1->state)));
  if((URCU_WAIT_RUNNING & tmp_statement_expression$6$link1) == 0)
  {
    signed int return_value_futex_noasync$5$link1;
    return_value_futex_noasync$5$link1=futex_noasync$link1(&wait$link1->state, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_noasync$5$link1 >= 0))
      do
      {
        signed int *return_value___errno_location$3$link1;
        return_value___errno_location$3$link1=__errno_location();
        char *return_value_strerror$4$link1;
        return_value_strerror$4$link1=strerror(*return_value___errno_location$3$link1);
        fprintf(stderr, "(urcu-wait.h:%s@%u) Unrecoverable error: %s\n", (const void *)"urcu_adaptative_wake_up", 129, return_value_strerror$4$link1);
        abort();
      }
      while((_Bool)0);

  }

  __uatomic_or$link1((void *)&wait$link1->state, (unsigned long int)URCU_WAIT_TEARDOWN, (signed int)sizeof(signed int) /*4ul*/ );
}

// urcu_adaptative_wake_up$link2
// file urcu-wait.h line 121
static inline void urcu_adaptative_wake_up$link2(struct urcu_wait_node *wait$link2)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&wait$link2->state)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&wait->state)) *)&(*(&wait->state))); }) == URCU_WAIT_WAITING */
  assert(tmp_statement_expression$1$link2 == URCU_WAIT_WAITING);
  signed int _v$link2;
  volatile signed int tmp_statement_expression$2$link2;
  *((volatile signed int *)&(*(&wait$link2->state))) = URCU_WAIT_WAKEUP;
  tmp_statement_expression$2$link2 = *((volatile signed int *)&(*(&wait$link2->state)));
  _v$link2 = tmp_statement_expression$2$link2;
  asm("" :  :  : "memory");
  _v$link2 = _v$link2;
  volatile signed int tmp_statement_expression$6$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$6$link2 = *((volatile signed int *)&(*(&wait$link2->state)));
  if((URCU_WAIT_RUNNING & tmp_statement_expression$6$link2) == 0)
  {
    signed int return_value_futex_noasync$5$link2;
    return_value_futex_noasync$5$link2=futex_noasync$link2(&wait$link2->state, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_noasync$5$link2 >= 0))
      do
      {
        signed int *return_value___errno_location$3$link2;
        return_value___errno_location$3$link2=__errno_location();
        char *return_value_strerror$4$link2;
        return_value_strerror$4$link2=strerror(*return_value___errno_location$3$link2);
        fprintf(stderr, "(urcu-wait.h:%s@%u) Unrecoverable error: %s\n", (const void *)"urcu_adaptative_wake_up", 129, return_value_strerror$4$link2);
        abort();
      }
      while((_Bool)0);

  }

  __uatomic_or$link2((void *)&wait$link2->state, (unsigned long int)URCU_WAIT_TEARDOWN, (signed int)sizeof(signed int) /*4ul*/ );
}

// urcu_adaptative_wake_up$link3
// file urcu-wait.h line 121
static inline void urcu_adaptative_wake_up$link3(struct urcu_wait_node *wait$link3)
{
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&wait$link3->state)));
  /* assertion __extension__ ({ __asm__ __volatile__ ("" : : : "memory"); (*(__volatile__ __typeof__(*(&wait->state)) *)&(*(&wait->state))); }) == URCU_WAIT_WAITING */
  assert(tmp_statement_expression$1$link3 == URCU_WAIT_WAITING);
  signed int _v$link3;
  volatile signed int tmp_statement_expression$2$link3;
  *((volatile signed int *)&(*(&wait$link3->state))) = URCU_WAIT_WAKEUP;
  tmp_statement_expression$2$link3 = *((volatile signed int *)&(*(&wait$link3->state)));
  _v$link3 = tmp_statement_expression$2$link3;
  asm("" :  :  : "memory");
  _v$link3 = _v$link3;
  volatile signed int tmp_statement_expression$6$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$6$link3 = *((volatile signed int *)&(*(&wait$link3->state)));
  if((URCU_WAIT_RUNNING & tmp_statement_expression$6$link3) == 0)
  {
    signed int return_value_futex_noasync$5$link3;
    return_value_futex_noasync$5$link3=futex_noasync$link3(&wait$link3->state, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_noasync$5$link3 >= 0))
      do
      {
        signed int *return_value___errno_location$3$link3;
        return_value___errno_location$3$link3=__errno_location();
        char *return_value_strerror$4$link3;
        return_value_strerror$4$link3=strerror(*return_value___errno_location$3$link3);
        fprintf(stderr, "(urcu-wait.h:%s@%u) Unrecoverable error: %s\n", (const void *)"urcu_adaptative_wake_up", 129, return_value_strerror$4$link3);
        abort();
      }
      while((_Bool)0);

  }

  __uatomic_or$link3((void *)&wait$link3->state, (unsigned long int)URCU_WAIT_TEARDOWN, (signed int)sizeof(signed int) /*4ul*/ );
}

// urcu_bp_prune_registry
// file urcu-bp.c line 659
static void urcu_bp_prune_registry(void)
{
  struct registry_chunk *chunk;
  struct rcu_reader_bp *rcu_reader_reg;
  chunk = (struct registry_chunk *)((char *)(&registry_arena.chunk_list)->next - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node);
  for( ; !(&chunk->node == &registry_arena.chunk_list); chunk = (struct registry_chunk *)((char *)chunk->node.next - (signed long int)(unsigned long int)&((struct registry_chunk *)0)->node))
  {
    rcu_reader_reg = (struct rcu_reader_bp *)&chunk->data[(signed long int)0];
    for( ; !(rcu_reader_reg >= (struct rcu_reader_bp *)(chunk->data + (signed long int)chunk->data_len)); rcu_reader_reg = rcu_reader_reg + 1l)
      if(!(rcu_reader_reg->alloc == 0))
      {
        unsigned long int return_value_pthread_self$1;
        return_value_pthread_self$1=pthread_self();
        if(!(rcu_reader_reg->tid == return_value_pthread_self$1))
          cleanup_thread(chunk, rcu_reader_reg);

      }

  }
}

// urcu_bp_smp_mb_slave
// file urcu/static/urcu-bp.h line 107
static inline void urcu_bp_smp_mb_slave(void)
{
  if(!(urcu_bp_has_sys_membarrier == 0))
    asm("" :  :  : "memory");

  else
    asm("mfence" :  :  : "memory");
}

// urcu_bp_thread_exit_notifier
// file urcu-bp.c line 577
static void urcu_bp_thread_exit_notifier(void *rcu_key)
{
  rcu_bp_unregister((struct rcu_reader_bp *)rcu_key);
}

// urcu_move_waiters
// file urcu-wait.h line 93
static inline void urcu_move_waiters(struct urcu_waiters *waiters, struct urcu_wait_queue *queue)
{
  waiters->head=___cds_wfs_pop_all(&queue->stack);
}

// urcu_move_waiters$link1
// file urcu-wait.h line 93
static inline void urcu_move_waiters$link1(struct urcu_waiters *waiters$link1, struct urcu_wait_queue *queue$link1)
{
  waiters$link1->head=___cds_wfs_pop_all$link2(&queue$link1->stack);
}

// urcu_move_waiters$link2
// file urcu-wait.h line 93
static inline void urcu_move_waiters$link2(struct urcu_waiters *waiters$link2, struct urcu_wait_queue *queue$link2)
{
  waiters$link2->head=___cds_wfs_pop_all$link3(&queue$link2->stack);
}

// urcu_move_waiters$link3
// file urcu-wait.h line 93
static inline void urcu_move_waiters$link3(struct urcu_waiters *waiters$link3, struct urcu_wait_queue *queue$link3)
{
  waiters$link3->head=___cds_wfs_pop_all$link4(&queue$link3->stack);
}

// urcu_ref_put
// file urcu/ref.h line 40
static inline void urcu_ref_put(struct urcu_ref *ref, void (*release)(struct urcu_ref *))
{
  signed long int res;
  unsigned long int return_value___uatomic_add_return$1;
  return_value___uatomic_add_return$1=__uatomic_add_return((void *)&ref->refcount, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed long int) /*8ul*/ );
  res = (signed long int)return_value___uatomic_add_return$1;
  /* assertion res >= 0 */
  assert(res >= (signed long int)0);
  if(res == 0l)
    release(ref);

}

// urcu_ref_put$link1
// file urcu/ref.h line 40
static inline void urcu_ref_put$link1(struct urcu_ref *ref$link1, void (*release$link1)(struct urcu_ref *))
{
  signed long int res$link1;
  unsigned long int return_value___uatomic_add_return$1$link1;
  return_value___uatomic_add_return$1$link1=__uatomic_add_return$link1((void *)&ref$link1->refcount, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed long int) /*8ul*/ );
  res$link1 = (signed long int)return_value___uatomic_add_return$1$link1;
  /* assertion res >= 0 */
  assert(res$link1 >= (signed long int)0);
  if(res$link1 == 0l)
    release$link1(ref$link1);

}

// urcu_ref_put$link2
// file urcu/ref.h line 40
static inline void urcu_ref_put$link2(struct urcu_ref *ref$link2, void (*release$link2)(struct urcu_ref *))
{
  signed long int res$link2;
  unsigned long int return_value___uatomic_add_return$1$link2;
  return_value___uatomic_add_return$1$link2=__uatomic_add_return$link2((void *)&ref$link2->refcount, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed long int) /*8ul*/ );
  res$link2 = (signed long int)return_value___uatomic_add_return$1$link2;
  /* assertion res >= 0 */
  assert(res$link2 >= (signed long int)0);
  if(res$link2 == 0l)
    release$link2(ref$link2);

}

// urcu_ref_put$link3
// file urcu/ref.h line 40
static inline void urcu_ref_put$link3(struct urcu_ref *ref$link3, void (*release$link3)(struct urcu_ref *))
{
  signed long int res$link3;
  unsigned long int return_value___uatomic_add_return$1$link3;
  return_value___uatomic_add_return$1$link3=__uatomic_add_return$link3((void *)&ref$link3->refcount, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed long int) /*8ul*/ );
  res$link3 = (signed long int)return_value___uatomic_add_return$1$link3;
  /* assertion res >= 0 */
  assert(res$link3 >= (signed long int)0);
  if(res$link3 == 0l)
    release$link3(ref$link3);

}

// urcu_ref_put$link4
// file urcu/ref.h line 40
static inline void urcu_ref_put$link4(struct urcu_ref *ref$link4, void (*release$link4)(struct urcu_ref *))
{
  signed long int res$link4;
  unsigned long int return_value___uatomic_add_return$1$link4;
  return_value___uatomic_add_return$1$link4=__uatomic_add_return$link4((void *)&ref$link4->refcount, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed long int) /*8ul*/ );
  res$link4 = (signed long int)return_value___uatomic_add_return$1$link4;
  /* assertion res >= 0 */
  assert(res$link4 >= (signed long int)0);
  if(res$link4 == 0l)
    release$link4(ref$link4);

}

// urcu_ref_set
// file urcu/ref.h line 25
static inline void urcu_ref_set(struct urcu_ref *ref, signed long int val)
{
  signed long int _v;
  volatile signed long int tmp_statement_expression$1;
  *((volatile signed long int *)&(*(&ref->refcount))) = val;
  tmp_statement_expression$1 = *((volatile signed long int *)&(*(&ref->refcount)));
  _v = tmp_statement_expression$1;
  asm("" :  :  : "memory");
  _v = _v;
}

// urcu_ref_set$link1
// file urcu/ref.h line 25
static inline void urcu_ref_set$link1(struct urcu_ref *ref$link1, signed long int val$link1)
{
  signed long int _v$link1;
  volatile signed long int tmp_statement_expression$1$link1;
  *((volatile signed long int *)&(*(&ref$link1->refcount))) = val$link1;
  tmp_statement_expression$1$link1 = *((volatile signed long int *)&(*(&ref$link1->refcount)));
  _v$link1 = tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
}

// urcu_ref_set$link2
// file urcu/ref.h line 25
static inline void urcu_ref_set$link2(struct urcu_ref *ref$link2, signed long int val$link2)
{
  signed long int _v$link2;
  volatile signed long int tmp_statement_expression$1$link2;
  *((volatile signed long int *)&(*(&ref$link2->refcount))) = val$link2;
  tmp_statement_expression$1$link2 = *((volatile signed long int *)&(*(&ref$link2->refcount)));
  _v$link2 = tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  _v$link2 = _v$link2;
}

// urcu_ref_set$link3
// file urcu/ref.h line 25
static inline void urcu_ref_set$link3(struct urcu_ref *ref$link3, signed long int val$link3)
{
  signed long int _v$link3;
  volatile signed long int tmp_statement_expression$1$link3;
  *((volatile signed long int *)&(*(&ref$link3->refcount))) = val$link3;
  tmp_statement_expression$1$link3 = *((volatile signed long int *)&(*(&ref$link3->refcount)));
  _v$link3 = tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  _v$link3 = _v$link3;
}

// urcu_ref_set$link4
// file urcu/ref.h line 25
static inline void urcu_ref_set$link4(struct urcu_ref *ref$link4, signed long int val$link4)
{
  signed long int _v$link4;
  volatile signed long int tmp_statement_expression$1$link4;
  *((volatile signed long int *)&(*(&ref$link4->refcount))) = val$link4;
  tmp_statement_expression$1$link4 = *((volatile signed long int *)&(*(&ref$link4->refcount)));
  _v$link4 = tmp_statement_expression$1$link4;
  asm("" :  :  : "memory");
  _v$link4 = _v$link4;
}

// urcu_sched_getcpu
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu(void)
{
  signed int return_value_sched_getcpu$1;
  return_value_sched_getcpu$1=sched_getcpu();
  return return_value_sched_getcpu$1;
}

// urcu_sched_getcpu$link1
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu$link1(void)
{
  signed int return_value_sched_getcpu$1$link1;
  return_value_sched_getcpu$1$link1=sched_getcpu();
  return return_value_sched_getcpu$1$link1;
}

// urcu_sched_getcpu$link2
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu$link2(void)
{
  signed int return_value_sched_getcpu$1$link2;
  return_value_sched_getcpu$1$link2=sched_getcpu();
  return return_value_sched_getcpu$1$link2;
}

// urcu_sched_getcpu$link3
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu$link3(void)
{
  signed int return_value_sched_getcpu$1$link3;
  return_value_sched_getcpu$1$link3=sched_getcpu();
  return return_value_sched_getcpu$1$link3;
}

// urcu_sched_getcpu$link4
// file compat-getcpu.h line 30
static inline signed int urcu_sched_getcpu$link4(void)
{
  signed int return_value_sched_getcpu$1$link4;
  return_value_sched_getcpu$1$link4=sched_getcpu();
  return return_value_sched_getcpu$1$link4;
}

// urcu_wait_add
// file urcu-wait.h line 82
static inline _Bool urcu_wait_add(struct urcu_wait_queue *queue, struct urcu_wait_node *node)
{
  signed int return_value__cds_wfs_push$1;
  return_value__cds_wfs_push$1=_cds_wfs_push(&queue->stack, &node->node);
  return (_Bool)return_value__cds_wfs_push$1;
}

// urcu_wait_add$link1
// file urcu-wait.h line 82
static inline _Bool urcu_wait_add$link1(struct urcu_wait_queue *queue$link1, struct urcu_wait_node *node$link1)
{
  signed int return_value__cds_wfs_push$1$link1;
  return_value__cds_wfs_push$1$link1=_cds_wfs_push$link2(&queue$link1->stack, &node$link1->node);
  return (_Bool)return_value__cds_wfs_push$1$link1;
}

// urcu_wait_add$link2
// file urcu-wait.h line 82
static inline _Bool urcu_wait_add$link2(struct urcu_wait_queue *queue$link2, struct urcu_wait_node *node$link2)
{
  signed int return_value__cds_wfs_push$1$link2;
  return_value__cds_wfs_push$1$link2=_cds_wfs_push$link3(&queue$link2->stack, &node$link2->node);
  return (_Bool)return_value__cds_wfs_push$1$link2;
}

// urcu_wait_add$link3
// file urcu-wait.h line 82
static inline _Bool urcu_wait_add$link3(struct urcu_wait_queue *queue$link3, struct urcu_wait_node *node$link3)
{
  signed int return_value__cds_wfs_push$1$link3;
  return_value__cds_wfs_push$1$link3=_cds_wfs_push$link4(&queue$link3->stack, &node$link3->node);
  return (_Bool)return_value__cds_wfs_push$1$link3;
}

// urcu_wait_set_state
// file urcu-wait.h line 100
static inline void urcu_wait_set_state(struct urcu_wait_node *node, enum urcu_wait_state state)
{
  node->state = (signed int)state;
}

// urcu_wait_set_state$link1
// file urcu-wait.h line 100
static inline void urcu_wait_set_state$link1(struct urcu_wait_node *node$link1, enum urcu_wait_state state$link1)
{
  node$link1->state = (signed int)state$link1;
}

// urcu_wait_set_state$link2
// file urcu-wait.h line 100
static inline void urcu_wait_set_state$link2(struct urcu_wait_node *node$link2, enum urcu_wait_state state$link2)
{
  node$link2->state = (signed int)state$link2;
}

// urcu_wait_set_state$link3
// file urcu-wait.h line 100
static inline void urcu_wait_set_state$link3(struct urcu_wait_node *node$link3, enum urcu_wait_state state$link3)
{
  node$link3->state = (signed int)state$link3;
}

// urcu_wake_all_waiters
// file urcu-wait.h line 185
static inline void urcu_wake_all_waiters(struct urcu_waiters *waiters)
{
  struct cds_wfs_node *iter;
  struct cds_wfs_node *iter_n;
  iter=_cds_wfs_first(waiters->head);
  struct cds_wfs_node *tmp_if_expr$2;
  struct cds_wfs_node *return_value__cds_wfs_next_blocking$1;
  if(!(iter == ((struct cds_wfs_node *)NULL)))
  {
    return_value__cds_wfs_next_blocking$1=_cds_wfs_next_blocking(iter);
    tmp_if_expr$2 = return_value__cds_wfs_next_blocking$1;
  }

  else
    tmp_if_expr$2 = (struct cds_wfs_node *)(void *)0;
  iter_n = tmp_if_expr$2;
  struct urcu_wait_node *tmp_statement_expression$5;
  struct cds_wfs_node *tmp_if_expr$4;
  struct cds_wfs_node *return_value__cds_wfs_next_blocking$3;
  for( ; !(iter == ((struct cds_wfs_node *)NULL)); iter_n = tmp_if_expr$4)
  {
    struct urcu_wait_node *wait_node;
    const struct cds_wfs_node *__ptr = iter;
    tmp_statement_expression$5 = (struct urcu_wait_node *)((char *)__ptr - (signed long int)0ul);
    wait_node = tmp_statement_expression$5;
    if((URCU_WAIT_RUNNING & wait_node->state) == 0)
      urcu_adaptative_wake_up(wait_node);

    iter = iter_n;
    if(!(iter == ((struct cds_wfs_node *)NULL)))
    {
      return_value__cds_wfs_next_blocking$3=_cds_wfs_next_blocking(iter);
      tmp_if_expr$4 = return_value__cds_wfs_next_blocking$3;
    }

    else
      tmp_if_expr$4 = (struct cds_wfs_node *)(void *)0;
  }
}

// urcu_wake_all_waiters$link1
// file urcu-wait.h line 185
static inline void urcu_wake_all_waiters$link1(struct urcu_waiters *waiters$link1)
{
  struct cds_wfs_node *iter$link1;
  struct cds_wfs_node *iter_n$link1;
  iter$link1=_cds_wfs_first$link2(waiters$link1->head);
  struct cds_wfs_node *tmp_if_expr$2$link1;
  struct cds_wfs_node *return_value__cds_wfs_next_blocking$1$link1;
  if(!(iter$link1 == ((struct cds_wfs_node *)NULL)))
  {
    return_value__cds_wfs_next_blocking$1$link1=_cds_wfs_next_blocking$link2(iter$link1);
    tmp_if_expr$2$link1 = return_value__cds_wfs_next_blocking$1$link1;
  }

  else
    tmp_if_expr$2$link1 = (struct cds_wfs_node *)(void *)0;
  iter_n$link1 = tmp_if_expr$2$link1;
  struct urcu_wait_node *tmp_statement_expression$5$link1;
  struct cds_wfs_node *tmp_if_expr$4$link1;
  struct cds_wfs_node *return_value__cds_wfs_next_blocking$3$link1;
  for( ; !(iter$link1 == ((struct cds_wfs_node *)NULL)); iter_n$link1 = tmp_if_expr$4$link1)
  {
    struct urcu_wait_node *wait_node$link1;
    const struct cds_wfs_node *__ptr$link1 = iter$link1;
    tmp_statement_expression$5$link1 = (struct urcu_wait_node *)((char *)__ptr$link1 - (signed long int)0ul);
    wait_node$link1 = tmp_statement_expression$5$link1;
    if((URCU_WAIT_RUNNING & wait_node$link1->state) == 0)
      urcu_adaptative_wake_up$link1(wait_node$link1);

    iter$link1 = iter_n$link1;
    if(!(iter$link1 == ((struct cds_wfs_node *)NULL)))
    {
      return_value__cds_wfs_next_blocking$3$link1=_cds_wfs_next_blocking$link2(iter$link1);
      tmp_if_expr$4$link1 = return_value__cds_wfs_next_blocking$3$link1;
    }

    else
      tmp_if_expr$4$link1 = (struct cds_wfs_node *)(void *)0;
  }
}

// urcu_wake_all_waiters$link2
// file urcu-wait.h line 185
static inline void urcu_wake_all_waiters$link2(struct urcu_waiters *waiters$link2)
{
  struct cds_wfs_node *iter$link2;
  struct cds_wfs_node *iter_n$link2;
  iter$link2=_cds_wfs_first$link3(waiters$link2->head);
  struct cds_wfs_node *tmp_if_expr$2$link2;
  struct cds_wfs_node *return_value__cds_wfs_next_blocking$1$link2;
  if(!(iter$link2 == ((struct cds_wfs_node *)NULL)))
  {
    return_value__cds_wfs_next_blocking$1$link2=_cds_wfs_next_blocking$link3(iter$link2);
    tmp_if_expr$2$link2 = return_value__cds_wfs_next_blocking$1$link2;
  }

  else
    tmp_if_expr$2$link2 = (struct cds_wfs_node *)(void *)0;
  iter_n$link2 = tmp_if_expr$2$link2;
  struct urcu_wait_node *tmp_statement_expression$5$link2;
  struct cds_wfs_node *tmp_if_expr$4$link2;
  struct cds_wfs_node *return_value__cds_wfs_next_blocking$3$link2;
  for( ; !(iter$link2 == ((struct cds_wfs_node *)NULL)); iter_n$link2 = tmp_if_expr$4$link2)
  {
    struct urcu_wait_node *wait_node$link2;
    const struct cds_wfs_node *__ptr$link2 = iter$link2;
    tmp_statement_expression$5$link2 = (struct urcu_wait_node *)((char *)__ptr$link2 - (signed long int)0ul);
    wait_node$link2 = tmp_statement_expression$5$link2;
    if((URCU_WAIT_RUNNING & wait_node$link2->state) == 0)
      urcu_adaptative_wake_up$link2(wait_node$link2);

    iter$link2 = iter_n$link2;
    if(!(iter$link2 == ((struct cds_wfs_node *)NULL)))
    {
      return_value__cds_wfs_next_blocking$3$link2=_cds_wfs_next_blocking$link3(iter$link2);
      tmp_if_expr$4$link2 = return_value__cds_wfs_next_blocking$3$link2;
    }

    else
      tmp_if_expr$4$link2 = (struct cds_wfs_node *)(void *)0;
  }
}

// urcu_wake_all_waiters$link3
// file urcu-wait.h line 185
static inline void urcu_wake_all_waiters$link3(struct urcu_waiters *waiters$link3)
{
  struct cds_wfs_node *iter$link3;
  struct cds_wfs_node *iter_n$link3;
  iter$link3=_cds_wfs_first$link4(waiters$link3->head);
  struct cds_wfs_node *tmp_if_expr$2$link3;
  struct cds_wfs_node *return_value__cds_wfs_next_blocking$1$link3;
  if(!(iter$link3 == ((struct cds_wfs_node *)NULL)))
  {
    return_value__cds_wfs_next_blocking$1$link3=_cds_wfs_next_blocking$link4(iter$link3);
    tmp_if_expr$2$link3 = return_value__cds_wfs_next_blocking$1$link3;
  }

  else
    tmp_if_expr$2$link3 = (struct cds_wfs_node *)(void *)0;
  iter_n$link3 = tmp_if_expr$2$link3;
  struct urcu_wait_node *tmp_statement_expression$5$link3;
  struct cds_wfs_node *tmp_if_expr$4$link3;
  struct cds_wfs_node *return_value__cds_wfs_next_blocking$3$link3;
  for( ; !(iter$link3 == ((struct cds_wfs_node *)NULL)); iter_n$link3 = tmp_if_expr$4$link3)
  {
    struct urcu_wait_node *wait_node$link3;
    const struct cds_wfs_node *__ptr$link3 = iter$link3;
    tmp_statement_expression$5$link3 = (struct urcu_wait_node *)((char *)__ptr$link3 - (signed long int)0ul);
    wait_node$link3 = tmp_statement_expression$5$link3;
    if((URCU_WAIT_RUNNING & wait_node$link3->state) == 0)
      urcu_adaptative_wake_up$link3(wait_node$link3);

    iter$link3 = iter_n$link3;
    if(!(iter$link3 == ((struct cds_wfs_node *)NULL)))
    {
      return_value__cds_wfs_next_blocking$3$link3=_cds_wfs_next_blocking$link4(iter$link3);
      tmp_if_expr$4$link3 = return_value__cds_wfs_next_blocking$3$link3;
    }

    else
      tmp_if_expr$4$link3 = (struct cds_wfs_node *)(void *)0;
  }
}

// wait_defer
// file urcu-defer-impl.h line 180
static void wait_defer(void)
{
  __uatomic_dec((void *)&defer_thread_futex, (signed int)sizeof(signed int) /*4ul*/ );
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1;
  if(!(defer_thread_stop == 0))
  {
    signed int _v;
    *((volatile signed int *)&(*(&defer_thread_futex))) = 0;
    tmp_statement_expression$1 = *((volatile signed int *)&(*(&defer_thread_futex)));
    _v = tmp_statement_expression$1;
    asm("" :  :  : "memory");
    _v = _v;
    pthread_exit(NULL);
  }

  unsigned long int return_value_rcu_defer_num_callbacks$8;
  return_value_rcu_defer_num_callbacks$8=rcu_defer_num_callbacks();
  volatile signed int tmp_statement_expression$2;
  volatile signed int tmp_statement_expression$3;
  signed int return_value_futex_noasync$4;
  if(!(return_value_rcu_defer_num_callbacks$8 == 0ul))
  {
    asm("mfence" :  :  : "memory");
    signed int wait_defer$$1$$2$$1$$_v;
    *((volatile signed int *)&(*(&defer_thread_futex))) = 0;
    tmp_statement_expression$2 = *((volatile signed int *)&(*(&defer_thread_futex)));
    wait_defer$$1$$2$$1$$_v = tmp_statement_expression$2;
    asm("" :  :  : "memory");
    wait_defer$$1$$2$$1$$_v = wait_defer$$1$$2$$1$$_v;
  }

  else
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$3 = *((volatile signed int *)&(*(&defer_thread_futex)));
    if(!(tmp_statement_expression$3 == -1))
      goto __CPROVER_DUMP_L10;

    do
    {
      return_value_futex_noasync$4=futex_noasync(&defer_thread_futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_noasync$4 == 0)
        break;

      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      switch(*return_value___errno_location$5)
      {
        case 11:
          goto __CPROVER_DUMP_L10;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$6;
            return_value___errno_location$6=__errno_location();
            char *return_value_strerror$7;
            return_value_strerror$7=strerror(*return_value___errno_location$6);
            fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wait_defer", 209, return_value_strerror$7);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);
  }

__CPROVER_DUMP_L10:
  ;
}

// wait_defer$link1
// file urcu-defer-impl.h line 180
static void wait_defer$link1(void)
{
  __uatomic_dec$link1((void *)&defer_thread_futex$link1, (signed int)sizeof(signed int) /*4ul*/ );
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link1;
  if(!(defer_thread_stop$link1 == 0))
  {
    signed int _v$link1;
    *((volatile signed int *)&(*(&defer_thread_futex$link1))) = 0;
    tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&defer_thread_futex$link1)));
    _v$link1 = tmp_statement_expression$1$link1;
    asm("" :  :  : "memory");
    _v$link1 = _v$link1;
    pthread_exit(NULL);
  }

  unsigned long int return_value_rcu_defer_num_callbacks$8$link1;
  return_value_rcu_defer_num_callbacks$8$link1=rcu_defer_num_callbacks$link1();
  volatile signed int tmp_statement_expression$2$link1;
  volatile signed int tmp_statement_expression$3$link1;
  signed int return_value_futex_noasync$4$link1;
  if(!(return_value_rcu_defer_num_callbacks$8$link1 == 0ul))
  {
    asm("mfence" :  :  : "memory");
    signed int wait_defer$$1$$2$$1$$_v$link1;
    *((volatile signed int *)&(*(&defer_thread_futex$link1))) = 0;
    tmp_statement_expression$2$link1 = *((volatile signed int *)&(*(&defer_thread_futex$link1)));
    wait_defer$$1$$2$$1$$_v$link1 = tmp_statement_expression$2$link1;
    asm("" :  :  : "memory");
    wait_defer$$1$$2$$1$$_v$link1 = wait_defer$$1$$2$$1$$_v$link1;
  }

  else
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$3$link1 = *((volatile signed int *)&(*(&defer_thread_futex$link1)));
    if(!(tmp_statement_expression$3$link1 == -1))
      goto __CPROVER_DUMP_L10;

    do
    {
      return_value_futex_noasync$4$link1=futex_noasync$link1(&defer_thread_futex$link1, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_noasync$4$link1 == 0)
        break;

      signed int *return_value___errno_location$5$link1;
      return_value___errno_location$5$link1=__errno_location();
      switch(*return_value___errno_location$5$link1)
      {
        case 11:
          goto __CPROVER_DUMP_L10;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$6$link1;
            return_value___errno_location$6$link1=__errno_location();
            char *return_value_strerror$7$link1;
            return_value_strerror$7$link1=strerror(*return_value___errno_location$6$link1);
            fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wait_defer", 209, return_value_strerror$7$link1);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);
  }

__CPROVER_DUMP_L10:
  ;
}

// wait_defer$link2
// file urcu-defer-impl.h line 180
static void wait_defer$link2(void)
{
  __uatomic_dec$link2((void *)&defer_thread_futex$link2, (signed int)sizeof(signed int) /*4ul*/ );
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link2;
  if(!(defer_thread_stop$link2 == 0))
  {
    signed int _v$link2;
    *((volatile signed int *)&(*(&defer_thread_futex$link2))) = 0;
    tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&defer_thread_futex$link2)));
    _v$link2 = tmp_statement_expression$1$link2;
    asm("" :  :  : "memory");
    _v$link2 = _v$link2;
    pthread_exit(NULL);
  }

  unsigned long int return_value_rcu_defer_num_callbacks$8$link2;
  return_value_rcu_defer_num_callbacks$8$link2=rcu_defer_num_callbacks$link2();
  volatile signed int tmp_statement_expression$2$link2;
  volatile signed int tmp_statement_expression$3$link2;
  signed int return_value_futex_noasync$4$link2;
  if(!(return_value_rcu_defer_num_callbacks$8$link2 == 0ul))
  {
    asm("mfence" :  :  : "memory");
    signed int wait_defer$$1$$2$$1$$_v$link2;
    *((volatile signed int *)&(*(&defer_thread_futex$link2))) = 0;
    tmp_statement_expression$2$link2 = *((volatile signed int *)&(*(&defer_thread_futex$link2)));
    wait_defer$$1$$2$$1$$_v$link2 = tmp_statement_expression$2$link2;
    asm("" :  :  : "memory");
    wait_defer$$1$$2$$1$$_v$link2 = wait_defer$$1$$2$$1$$_v$link2;
  }

  else
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$3$link2 = *((volatile signed int *)&(*(&defer_thread_futex$link2)));
    if(!(tmp_statement_expression$3$link2 == -1))
      goto __CPROVER_DUMP_L10;

    do
    {
      return_value_futex_noasync$4$link2=futex_noasync$link2(&defer_thread_futex$link2, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_noasync$4$link2 == 0)
        break;

      signed int *return_value___errno_location$5$link2;
      return_value___errno_location$5$link2=__errno_location();
      switch(*return_value___errno_location$5$link2)
      {
        case 11:
          goto __CPROVER_DUMP_L10;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$6$link2;
            return_value___errno_location$6$link2=__errno_location();
            char *return_value_strerror$7$link2;
            return_value_strerror$7$link2=strerror(*return_value___errno_location$6$link2);
            fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wait_defer", 209, return_value_strerror$7$link2);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);
  }

__CPROVER_DUMP_L10:
  ;
}

// wait_defer$link3
// file urcu-defer-impl.h line 180
static void wait_defer$link3(void)
{
  __uatomic_dec$link3((void *)&defer_thread_futex$link3, (signed int)sizeof(signed int) /*4ul*/ );
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link3;
  if(!(defer_thread_stop$link3 == 0))
  {
    signed int _v$link3;
    *((volatile signed int *)&(*(&defer_thread_futex$link3))) = 0;
    tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&defer_thread_futex$link3)));
    _v$link3 = tmp_statement_expression$1$link3;
    asm("" :  :  : "memory");
    _v$link3 = _v$link3;
    pthread_exit(NULL);
  }

  unsigned long int return_value_rcu_defer_num_callbacks$8$link3;
  return_value_rcu_defer_num_callbacks$8$link3=rcu_defer_num_callbacks$link3();
  volatile signed int tmp_statement_expression$2$link3;
  volatile signed int tmp_statement_expression$3$link3;
  signed int return_value_futex_noasync$4$link3;
  if(!(return_value_rcu_defer_num_callbacks$8$link3 == 0ul))
  {
    asm("mfence" :  :  : "memory");
    signed int wait_defer$$1$$2$$1$$_v$link3;
    *((volatile signed int *)&(*(&defer_thread_futex$link3))) = 0;
    tmp_statement_expression$2$link3 = *((volatile signed int *)&(*(&defer_thread_futex$link3)));
    wait_defer$$1$$2$$1$$_v$link3 = tmp_statement_expression$2$link3;
    asm("" :  :  : "memory");
    wait_defer$$1$$2$$1$$_v$link3 = wait_defer$$1$$2$$1$$_v$link3;
  }

  else
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$3$link3 = *((volatile signed int *)&(*(&defer_thread_futex$link3)));
    if(!(tmp_statement_expression$3$link3 == -1))
      goto __CPROVER_DUMP_L10;

    do
    {
      return_value_futex_noasync$4$link3=futex_noasync$link3(&defer_thread_futex$link3, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_noasync$4$link3 == 0)
        break;

      signed int *return_value___errno_location$5$link3;
      return_value___errno_location$5$link3=__errno_location();
      switch(*return_value___errno_location$5$link3)
      {
        case 11:
          goto __CPROVER_DUMP_L10;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$6$link3;
            return_value___errno_location$6$link3=__errno_location();
            char *return_value_strerror$7$link3;
            return_value_strerror$7$link3=strerror(*return_value___errno_location$6$link3);
            fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wait_defer", 209, return_value_strerror$7$link3);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);
  }

__CPROVER_DUMP_L10:
  ;
}

// wait_defer$link4
// file urcu-defer-impl.h line 180
static void wait_defer$link4(void)
{
  __uatomic_dec$link4((void *)&defer_thread_futex$link4, (signed int)sizeof(signed int) /*4ul*/ );
  asm("mfence" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link4;
  if(!(defer_thread_stop$link4 == 0))
  {
    signed int _v$link4;
    *((volatile signed int *)&(*(&defer_thread_futex$link4))) = 0;
    tmp_statement_expression$1$link4 = *((volatile signed int *)&(*(&defer_thread_futex$link4)));
    _v$link4 = tmp_statement_expression$1$link4;
    asm("" :  :  : "memory");
    _v$link4 = _v$link4;
    pthread_exit(NULL);
  }

  unsigned long int return_value_rcu_defer_num_callbacks$8$link4;
  return_value_rcu_defer_num_callbacks$8$link4=rcu_defer_num_callbacks$link4();
  volatile signed int tmp_statement_expression$2$link4;
  volatile signed int tmp_statement_expression$3$link4;
  signed int return_value_futex_noasync$4$link4;
  if(!(return_value_rcu_defer_num_callbacks$8$link4 == 0ul))
  {
    asm("mfence" :  :  : "memory");
    signed int wait_defer$$1$$2$$1$$_v$link4;
    *((volatile signed int *)&(*(&defer_thread_futex$link4))) = 0;
    tmp_statement_expression$2$link4 = *((volatile signed int *)&(*(&defer_thread_futex$link4)));
    wait_defer$$1$$2$$1$$_v$link4 = tmp_statement_expression$2$link4;
    asm("" :  :  : "memory");
    wait_defer$$1$$2$$1$$_v$link4 = wait_defer$$1$$2$$1$$_v$link4;
  }

  else
  {
    asm("" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$3$link4 = *((volatile signed int *)&(*(&defer_thread_futex$link4)));
    if(!(tmp_statement_expression$3$link4 == -1))
      goto __CPROVER_DUMP_L10;

    do
    {
      return_value_futex_noasync$4$link4=futex_noasync$link4(&defer_thread_futex$link4, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_noasync$4$link4 == 0)
        break;

      signed int *return_value___errno_location$5$link4;
      return_value___errno_location$5$link4=__errno_location();
      switch(*return_value___errno_location$5$link4)
      {
        case 11:
          goto __CPROVER_DUMP_L10;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$6$link4;
            return_value___errno_location$6$link4=__errno_location();
            char *return_value_strerror$7$link4;
            return_value_strerror$7$link4=strerror(*return_value___errno_location$6$link4);
            fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wait_defer", 209, return_value_strerror$7$link4);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);
  }

__CPROVER_DUMP_L10:
  ;
}

// wait_for_readers
// file urcu.c line 269
static void wait_for_readers(struct cds_list_head *input_readers, struct cds_list_head *cur_snap_readers, struct cds_list_head *qsreaders)
{
  unsigned int wait_loops = (unsigned int)0;
  struct rcu_reader_memb *index;
  struct rcu_reader_memb *tmp;
  volatile signed int tmp_statement_expression$2;
  while((_Bool)1)
  {
    if(!(wait_loops >= 100u))
      wait_loops = wait_loops + 1u;

    if(wait_loops >= 100u)
    {
      __uatomic_dec((void *)&rcu_gp_memb.futex, (signed int)sizeof(signed int) /*4ul*/ );
      smp_mb_master();
    }

    index = (struct rcu_reader_memb *)((char *)input_readers->next - (signed long int)(unsigned long int)&((struct rcu_reader_memb *)0)->node);
    tmp = (struct rcu_reader_memb *)((char *)index->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_memb *)0)->node);
    while(!(&index->node == input_readers))
    {
      enum rcu_state return_value_rcu_reader_state$1;
      return_value_rcu_reader_state$1=rcu_reader_state(&index->ctr);
      switch((signed int)return_value_rcu_reader_state$1)
      {
        case RCU_READER_ACTIVE_CURRENT:
          if(!(cur_snap_readers == ((struct cds_list_head *)NULL)))
          {
            cds_list_move(&index->node, cur_snap_readers);
            goto __CPROVER_DUMP_L7;
          }

        case RCU_READER_INACTIVE:
          cds_list_move(&index->node, qsreaders);
        case RCU_READER_ACTIVE_OLD:

        default:
        {

        __CPROVER_DUMP_L7:
          ;
          index = tmp;
          tmp = (struct rcu_reader_memb *)((char *)index->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_memb *)0)->node);
        }
      }
    }
    signed int return_value_cds_list_empty$3;
    return_value_cds_list_empty$3=cds_list_empty(input_readers);
    if(!(return_value_cds_list_empty$3 == 0))
    {
      if(wait_loops >= 100u)
      {
        smp_mb_master();
        signed int _v;
        *((volatile signed int *)&(*(&rcu_gp_memb.futex))) = 0;
        tmp_statement_expression$2 = *((volatile signed int *)&(*(&rcu_gp_memb.futex)));
        _v = tmp_statement_expression$2;
        asm("" :  :  : "memory");
        _v = _v;
      }

      break;
    }

    else
      if(wait_loops >= 100u)
        wait_gp();

      else
      {
        mutex_unlock(&rcu_registry_lock);
        asm("rep; nop" :  :  : "memory");
        mutex_lock(&rcu_registry_lock);
      }
  }
}

// wait_for_readers$link1
// file urcu.c line 269
static void wait_for_readers$link1(struct cds_list_head *input_readers$link1, struct cds_list_head *cur_snap_readers$link1, struct cds_list_head *qsreaders$link1)
{
  unsigned int wait_loops$link1 = (unsigned int)0;
  struct rcu_reader_mb *index$link1;
  struct rcu_reader_mb *tmp$link1;
  volatile signed int tmp_statement_expression$2$link1;
  while((_Bool)1)
  {
    if(!(wait_loops$link1 >= 100u))
      wait_loops$link1 = wait_loops$link1 + 1u;

    if(wait_loops$link1 >= 100u)
    {
      __uatomic_dec$link1((void *)&rcu_gp_mb.futex, (signed int)sizeof(signed int) /*4ul*/ );
      smp_mb_master$link1();
    }

    index$link1 = (struct rcu_reader_mb *)((char *)input_readers$link1->next - (signed long int)(unsigned long int)&((struct rcu_reader_mb *)0)->node);
    tmp$link1 = (struct rcu_reader_mb *)((char *)index$link1->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_mb *)0)->node);
    while(!(&index$link1->node == input_readers$link1))
    {
      enum rcu_state return_value_rcu_reader_state$1$link1;
      return_value_rcu_reader_state$1$link1=rcu_reader_state$link1(&index$link1->ctr);
      switch((signed int)return_value_rcu_reader_state$1$link1)
      {
        case RCU_READER_ACTIVE_CURRENT:
          if(!(cur_snap_readers$link1 == ((struct cds_list_head *)NULL)))
          {
            cds_list_move$link1(&index$link1->node, cur_snap_readers$link1);
            goto __CPROVER_DUMP_L7;
          }

        case RCU_READER_INACTIVE:
          cds_list_move$link1(&index$link1->node, qsreaders$link1);
        case RCU_READER_ACTIVE_OLD:

        default:
        {

        __CPROVER_DUMP_L7:
          ;
          index$link1 = tmp$link1;
          tmp$link1 = (struct rcu_reader_mb *)((char *)index$link1->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_mb *)0)->node);
        }
      }
    }
    signed int return_value_cds_list_empty$3$link1;
    return_value_cds_list_empty$3$link1=cds_list_empty$link1(input_readers$link1);
    if(!(return_value_cds_list_empty$3$link1 == 0))
    {
      if(wait_loops$link1 >= 100u)
      {
        smp_mb_master$link1();
        signed int _v$link1;
        *((volatile signed int *)&(*(&rcu_gp_mb.futex))) = 0;
        tmp_statement_expression$2$link1 = *((volatile signed int *)&(*(&rcu_gp_mb.futex)));
        _v$link1 = tmp_statement_expression$2$link1;
        asm("" :  :  : "memory");
        _v$link1 = _v$link1;
      }

      break;
    }

    else
      if(wait_loops$link1 >= 100u)
        wait_gp$link1();

      else
      {
        mutex_unlock$link1(&rcu_registry_lock$link1);
        asm("rep; nop" :  :  : "memory");
        mutex_lock$link1(&rcu_registry_lock$link1);
      }
  }
}

// wait_for_readers$link2
// file urcu.c line 269
static void wait_for_readers$link2(struct cds_list_head *input_readers$link2, struct cds_list_head *cur_snap_readers$link2, struct cds_list_head *qsreaders$link2)
{
  unsigned int wait_loops$link2 = (unsigned int)0;
  struct rcu_reader_sig *index$link2;
  struct rcu_reader_sig *tmp$link2;
  volatile signed int tmp_statement_expression$2$link2;
  while((_Bool)1)
  {
    if(!(wait_loops$link2 >= 100u))
      wait_loops$link2 = wait_loops$link2 + 1u;

    if(wait_loops$link2 >= 100u)
    {
      __uatomic_dec$link2((void *)&rcu_gp_sig.futex, (signed int)sizeof(signed int) /*4ul*/ );
      smp_mb_master$link2();
    }

    index$link2 = (struct rcu_reader_sig *)((char *)input_readers$link2->next - (signed long int)(unsigned long int)&((struct rcu_reader_sig *)0)->node);
    tmp$link2 = (struct rcu_reader_sig *)((char *)index$link2->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_sig *)0)->node);
    while(!(&index$link2->node == input_readers$link2))
    {
      enum rcu_state return_value_rcu_reader_state$1$link2;
      return_value_rcu_reader_state$1$link2=rcu_reader_state$link2(&index$link2->ctr);
      switch((signed int)return_value_rcu_reader_state$1$link2)
      {
        case RCU_READER_ACTIVE_CURRENT:
          if(!(cur_snap_readers$link2 == ((struct cds_list_head *)NULL)))
          {
            cds_list_move$link2(&index$link2->node, cur_snap_readers$link2);
            goto __CPROVER_DUMP_L7;
          }

        case RCU_READER_INACTIVE:
          cds_list_move$link2(&index$link2->node, qsreaders$link2);
        case RCU_READER_ACTIVE_OLD:

        default:
        {

        __CPROVER_DUMP_L7:
          ;
          index$link2 = tmp$link2;
          tmp$link2 = (struct rcu_reader_sig *)((char *)index$link2->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_sig *)0)->node);
        }
      }
    }
    signed int return_value_cds_list_empty$3$link2;
    return_value_cds_list_empty$3$link2=cds_list_empty$link2(input_readers$link2);
    if(!(return_value_cds_list_empty$3$link2 == 0))
    {
      if(wait_loops$link2 >= 100u)
      {
        smp_mb_master$link2();
        signed int _v$link2;
        *((volatile signed int *)&(*(&rcu_gp_sig.futex))) = 0;
        tmp_statement_expression$2$link2 = *((volatile signed int *)&(*(&rcu_gp_sig.futex)));
        _v$link2 = tmp_statement_expression$2$link2;
        asm("" :  :  : "memory");
        _v$link2 = _v$link2;
      }

      break;
    }

    else
      if(wait_loops$link2 >= 100u)
        wait_gp$link2();

      else
      {
        mutex_unlock$link2(&rcu_registry_lock$link2);
        asm("rep; nop" :  :  : "memory");
        mutex_lock$link2(&rcu_registry_lock$link2);
      }
  }
}

// wait_for_readers$link3
// file urcu-qsbr.c line 146
static void wait_for_readers$link3(struct cds_list_head *input_readers$link3, struct cds_list_head *cur_snap_readers$link3, struct cds_list_head *qsreaders$link3)
{
  unsigned int wait_loops$link3 = (unsigned int)0;
  struct rcu_reader_qsbr *index$link3;
  struct rcu_reader_qsbr *tmp$link3;
  volatile signed int tmp_statement_expression$1;
  volatile signed int tmp_statement_expression$3;
  while((_Bool)1)
  {
    if(!(wait_loops$link3 >= 100u))
      wait_loops$link3 = wait_loops$link3 + 1u;

    if(wait_loops$link3 >= 100u)
    {
      signed int _v;
      *((volatile signed int *)&(*(&rcu_gp_qsbr.futex))) = -1;
      tmp_statement_expression$1 = *((volatile signed int *)&(*(&rcu_gp_qsbr.futex)));
      _v = tmp_statement_expression$1;
      asm("" :  :  : "memory");
      _v = _v;
      asm("" :  :  : "memory");
      index$link3 = (struct rcu_reader_qsbr *)((char *)input_readers$link3->next - (signed long int)(unsigned long int)&((struct rcu_reader_qsbr *)0)->node);
      for( ; !(&index$link3->node == input_readers$link3); index$link3 = (struct rcu_reader_qsbr *)((char *)index$link3->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_qsbr *)0)->node))
        *((volatile signed int *)&index$link3->waiting) = 1;
      asm("mfence" :  :  : "memory");
    }

    index$link3 = (struct rcu_reader_qsbr *)((char *)input_readers$link3->next - (signed long int)(unsigned long int)&((struct rcu_reader_qsbr *)0)->node);
    tmp$link3 = (struct rcu_reader_qsbr *)((char *)index$link3->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_qsbr *)0)->node);
    while(!(&index$link3->node == input_readers$link3))
    {
      enum rcu_state return_value_rcu_reader_state$2;
      return_value_rcu_reader_state$2=rcu_reader_state$link3(&index$link3->ctr);
      switch((signed int)return_value_rcu_reader_state$2)
      {
        case RCU_READER_ACTIVE_CURRENT:
          if(!(cur_snap_readers$link3 == ((struct cds_list_head *)NULL)))
          {
            cds_list_move$link3(&index$link3->node, cur_snap_readers$link3);
            goto __CPROVER_DUMP_L9;
          }

        case RCU_READER_INACTIVE:
          cds_list_move$link3(&index$link3->node, qsreaders$link3);
        case RCU_READER_ACTIVE_OLD:

        default:
        {

        __CPROVER_DUMP_L9:
          ;
          index$link3 = tmp$link3;
          tmp$link3 = (struct rcu_reader_qsbr *)((char *)index$link3->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_qsbr *)0)->node);
        }
      }
    }
    signed int return_value_cds_list_empty$4;
    return_value_cds_list_empty$4=cds_list_empty$link3(input_readers$link3);
    if(!(return_value_cds_list_empty$4 == 0))
    {
      if(wait_loops$link3 >= 100u)
      {
        asm("mfence" :  :  : "memory");
        signed int _v$link3;
        *((volatile signed int *)&(*(&rcu_gp_qsbr.futex))) = 0;
        tmp_statement_expression$3 = *((volatile signed int *)&(*(&rcu_gp_qsbr.futex)));
        _v$link3 = tmp_statement_expression$3;
        asm("" :  :  : "memory");
        _v$link3 = _v$link3;
      }

      break;
    }

    else
    {
      mutex_unlock$link3(&rcu_registry_lock$link3);
      if(wait_loops$link3 >= 100u)
        wait_gp$link3();

      else
        asm("rep; nop" :  :  : "memory");
      mutex_lock$link3(&rcu_registry_lock$link3);
    }
  }
}

// wait_for_readers$link4
// file urcu-bp.c line 204
static void wait_for_readers$link4(struct cds_list_head *input_readers$link4, struct cds_list_head *cur_snap_readers$link4, struct cds_list_head *qsreaders$link4)
{
  unsigned int wait_loops$link4 = (unsigned int)0;
  struct rcu_reader_bp *index$link4;
  struct rcu_reader_bp *tmp$link4;
  while((_Bool)1)
  {
    if(!(wait_loops$link4 >= 100u))
      wait_loops$link4 = wait_loops$link4 + 1u;

    index$link4 = (struct rcu_reader_bp *)((char *)input_readers$link4->next - (signed long int)(unsigned long int)&((struct rcu_reader_bp *)0)->node);
    tmp$link4 = (struct rcu_reader_bp *)((char *)index$link4->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_bp *)0)->node);
    while(!(&index$link4->node == input_readers$link4))
    {
      enum rcu_state return_value_rcu_reader_state$1$link3;
      return_value_rcu_reader_state$1$link3=rcu_reader_state$link4(&index$link4->ctr);
      switch((signed int)return_value_rcu_reader_state$1$link3)
      {
        case RCU_READER_ACTIVE_CURRENT:
          if(!(cur_snap_readers$link4 == ((struct cds_list_head *)NULL)))
          {
            cds_list_move$link4(&index$link4->node, cur_snap_readers$link4);
            goto __CPROVER_DUMP_L6;
          }

        case RCU_READER_INACTIVE:
          cds_list_move$link4(&index$link4->node, qsreaders$link4);
        case RCU_READER_ACTIVE_OLD:

        default:
        {

        __CPROVER_DUMP_L6:
          ;
          index$link4 = tmp$link4;
          tmp$link4 = (struct rcu_reader_bp *)((char *)index$link4->node.next - (signed long int)(unsigned long int)&((struct rcu_reader_bp *)0)->node);
        }
      }
    }
    signed int return_value_cds_list_empty$2;
    return_value_cds_list_empty$2=cds_list_empty$link4(input_readers$link4);
    if(!(return_value_cds_list_empty$2 == 0))
      break;

    else
    {
      mutex_unlock$link4(&rcu_registry_lock$link4);
      if(wait_loops$link4 >= 100u)
        poll((struct pollfd *)(void *)0, (unsigned long int)0, 10);

      else
        asm("rep; nop" :  :  : "memory");
      mutex_lock$link4(&rcu_registry_lock$link4);
    }
  }
}

// wait_gp
// file urcu.c line 232
static void wait_gp(void)
{
  smp_mb_master();
  mutex_unlock(&rcu_registry_lock);
  volatile signed int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile signed int *)&(*(&rcu_gp_memb.futex)));
  signed int return_value_futex_async$2;
  if(tmp_statement_expression$1 == -1)
    do
    {
      return_value_futex_async$2=futex_async(&rcu_gp_memb.futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2 == 0)
        break;

      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      switch(*return_value___errno_location$3)
      {
        case 11:
          goto end;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            char *return_value_strerror$5;
            return_value_strerror$5=strerror(*return_value___errno_location$4);
            fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"wait_gp", 255, return_value_strerror$5);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


end:
  ;
  mutex_lock(&rcu_registry_lock);
}

// wait_gp$link1
// file urcu.c line 232
static void wait_gp$link1(void)
{
  smp_mb_master$link1();
  mutex_unlock$link1(&rcu_registry_lock$link1);
  volatile signed int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&rcu_gp_mb.futex)));
  signed int return_value_futex_async$2$link1;
  if(tmp_statement_expression$1$link1 == -1)
    do
    {
      return_value_futex_async$2$link1=futex_async$link1(&rcu_gp_mb.futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link1 == 0)
        break;

      signed int *return_value___errno_location$3$link1;
      return_value___errno_location$3$link1=__errno_location();
      switch(*return_value___errno_location$3$link1)
      {
        case 11:
          goto end;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link1;
            return_value___errno_location$4$link1=__errno_location();
            char *return_value_strerror$5$link1;
            return_value_strerror$5$link1=strerror(*return_value___errno_location$4$link1);
            fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"wait_gp", 255, return_value_strerror$5$link1);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


end:
  ;
  mutex_lock$link1(&rcu_registry_lock$link1);
}

// wait_gp$link2
// file urcu.c line 232
static void wait_gp$link2(void)
{
  smp_mb_master$link2();
  mutex_unlock$link2(&rcu_registry_lock$link2);
  volatile signed int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&rcu_gp_sig.futex)));
  signed int return_value_futex_async$2$link2;
  if(tmp_statement_expression$1$link2 == -1)
    do
    {
      return_value_futex_async$2$link2=futex_async$link2(&rcu_gp_sig.futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_async$2$link2 == 0)
        break;

      signed int *return_value___errno_location$3$link2;
      return_value___errno_location$3$link2=__errno_location();
      switch(*return_value___errno_location$3$link2)
      {
        case 11:
          goto end;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link2;
            return_value___errno_location$4$link2=__errno_location();
            char *return_value_strerror$5$link2;
            return_value_strerror$5$link2=strerror(*return_value___errno_location$4$link2);
            fprintf(stderr, "(urcu.c:%s@%u) Unrecoverable error: %s\n", (const void *)"wait_gp", 255, return_value_strerror$5$link2);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


end:
  ;
  mutex_lock$link2(&rcu_registry_lock$link2);
}

// wait_gp$link3
// file urcu-qsbr.c line 120
static void wait_gp$link3(void)
{
  asm("" :  :  : "memory");
  volatile signed int tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&rcu_gp_qsbr.futex)));
  signed int return_value_futex_noasync$2;
  if(tmp_statement_expression$1$link3 == -1)
    do
    {
      return_value_futex_noasync$2=futex_noasync$link3(&rcu_gp_qsbr.futex, 0, -1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_futex_noasync$2 == 0)
        break;

      signed int *return_value___errno_location$3$link3;
      return_value___errno_location$3$link3=__errno_location();
      switch(*return_value___errno_location$3$link3)
      {
        case 11:
          goto __CPROVER_DUMP_L7;
        case 4:
          break;
        default:
          do
          {
            signed int *return_value___errno_location$4$link3;
            return_value___errno_location$4$link3=__errno_location();
            char *return_value_strerror$5$link3;
            return_value_strerror$5$link3=strerror(*return_value___errno_location$4$link3);
            fprintf(stderr, "(urcu-qsbr.c:%s@%u) Unrecoverable error: %s\n", (const void *)"wait_gp", 137, return_value_strerror$5$link3);
            abort();
          }
          while((_Bool)0);
      }
    }
    while((_Bool)1);


__CPROVER_DUMP_L7:
  ;
}

// wake_call_rcu_thread
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread(struct call_rcu_data *crdp)
{
  if((1ul & crdp->flags) == 0ul)
    call_rcu_wake_up(crdp);

}

// wake_call_rcu_thread$link1
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread$link1(struct call_rcu_data *crdp$link1)
{
  if((1ul & crdp$link1->flags) == 0ul)
    call_rcu_wake_up$link1(crdp$link1);

}

// wake_call_rcu_thread$link2
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread$link2(struct call_rcu_data *crdp$link2)
{
  if((1ul & crdp$link2->flags) == 0ul)
    call_rcu_wake_up$link2(crdp$link2);

}

// wake_call_rcu_thread$link3
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread$link3(struct call_rcu_data *crdp$link3)
{
  if((1ul & crdp$link3->flags) == 0ul)
    call_rcu_wake_up$link3(crdp$link3);

}

// wake_call_rcu_thread$link4
// file urcu-call-rcu-impl.h line 674
static void wake_call_rcu_thread$link4(struct call_rcu_data *crdp$link4)
{
  if((1ul & crdp$link4->flags) == 0ul)
    call_rcu_wake_up$link4(crdp$link4);

}

// wake_up_defer
// file urcu-defer-impl.h line 153
static void wake_up_defer(void)
{
  volatile signed int tmp_statement_expression$5;
  asm("" :  :  : "memory");
  tmp_statement_expression$5 = *((volatile signed int *)&(*(&defer_thread_futex)));
  volatile signed int tmp_statement_expression$1;
  if(tmp_statement_expression$5 == -1)
  {
    signed int _v;
    *((volatile signed int *)&(*(&defer_thread_futex))) = 0;
    tmp_statement_expression$1 = *((volatile signed int *)&(*(&defer_thread_futex)));
    _v = tmp_statement_expression$1;
    asm("" :  :  : "memory");
    _v = _v;
    signed int return_value_futex_noasync$4;
    return_value_futex_noasync$4=futex_noasync(&defer_thread_futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_noasync$4 >= 0))
      do
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wake_up_defer", 159, return_value_strerror$3);
        abort();
      }
      while((_Bool)0);

  }

}

// wake_up_defer$link1
// file urcu-defer-impl.h line 153
static void wake_up_defer$link1(void)
{
  volatile signed int tmp_statement_expression$5$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link1 = *((volatile signed int *)&(*(&defer_thread_futex$link1)));
  volatile signed int tmp_statement_expression$1$link1;
  if(tmp_statement_expression$5$link1 == -1)
  {
    signed int _v$link1;
    *((volatile signed int *)&(*(&defer_thread_futex$link1))) = 0;
    tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&defer_thread_futex$link1)));
    _v$link1 = tmp_statement_expression$1$link1;
    asm("" :  :  : "memory");
    _v$link1 = _v$link1;
    signed int return_value_futex_noasync$4$link1;
    return_value_futex_noasync$4$link1=futex_noasync$link1(&defer_thread_futex$link1, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_noasync$4$link1 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link1;
        return_value___errno_location$2$link1=__errno_location();
        char *return_value_strerror$3$link1;
        return_value_strerror$3$link1=strerror(*return_value___errno_location$2$link1);
        fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wake_up_defer", 159, return_value_strerror$3$link1);
        abort();
      }
      while((_Bool)0);

  }

}

// wake_up_defer$link2
// file urcu-defer-impl.h line 153
static void wake_up_defer$link2(void)
{
  volatile signed int tmp_statement_expression$5$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link2 = *((volatile signed int *)&(*(&defer_thread_futex$link2)));
  volatile signed int tmp_statement_expression$1$link2;
  if(tmp_statement_expression$5$link2 == -1)
  {
    signed int _v$link2;
    *((volatile signed int *)&(*(&defer_thread_futex$link2))) = 0;
    tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&defer_thread_futex$link2)));
    _v$link2 = tmp_statement_expression$1$link2;
    asm("" :  :  : "memory");
    _v$link2 = _v$link2;
    signed int return_value_futex_noasync$4$link2;
    return_value_futex_noasync$4$link2=futex_noasync$link2(&defer_thread_futex$link2, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_noasync$4$link2 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link2;
        return_value___errno_location$2$link2=__errno_location();
        char *return_value_strerror$3$link2;
        return_value_strerror$3$link2=strerror(*return_value___errno_location$2$link2);
        fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wake_up_defer", 159, return_value_strerror$3$link2);
        abort();
      }
      while((_Bool)0);

  }

}

// wake_up_defer$link3
// file urcu-defer-impl.h line 153
static void wake_up_defer$link3(void)
{
  volatile signed int tmp_statement_expression$5$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link3 = *((volatile signed int *)&(*(&defer_thread_futex$link3)));
  volatile signed int tmp_statement_expression$1$link3;
  if(tmp_statement_expression$5$link3 == -1)
  {
    signed int _v$link3;
    *((volatile signed int *)&(*(&defer_thread_futex$link3))) = 0;
    tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&defer_thread_futex$link3)));
    _v$link3 = tmp_statement_expression$1$link3;
    asm("" :  :  : "memory");
    _v$link3 = _v$link3;
    signed int return_value_futex_noasync$4$link3;
    return_value_futex_noasync$4$link3=futex_noasync$link3(&defer_thread_futex$link3, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_noasync$4$link3 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link3;
        return_value___errno_location$2$link3=__errno_location();
        char *return_value_strerror$3$link3;
        return_value_strerror$3$link3=strerror(*return_value___errno_location$2$link3);
        fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wake_up_defer", 159, return_value_strerror$3$link3);
        abort();
      }
      while((_Bool)0);

  }

}

// wake_up_defer$link4
// file urcu-defer-impl.h line 153
static void wake_up_defer$link4(void)
{
  volatile signed int tmp_statement_expression$5$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$5$link4 = *((volatile signed int *)&(*(&defer_thread_futex$link4)));
  volatile signed int tmp_statement_expression$1$link4;
  if(tmp_statement_expression$5$link4 == -1)
  {
    signed int _v$link4;
    *((volatile signed int *)&(*(&defer_thread_futex$link4))) = 0;
    tmp_statement_expression$1$link4 = *((volatile signed int *)&(*(&defer_thread_futex$link4)));
    _v$link4 = tmp_statement_expression$1$link4;
    asm("" :  :  : "memory");
    _v$link4 = _v$link4;
    signed int return_value_futex_noasync$4$link4;
    return_value_futex_noasync$4$link4=futex_noasync$link4(&defer_thread_futex$link4, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_futex_noasync$4$link4 >= 0))
      do
      {
        signed int *return_value___errno_location$2$link4;
        return_value___errno_location$2$link4=__errno_location();
        char *return_value_strerror$3$link4;
        return_value_strerror$3$link4=strerror(*return_value___errno_location$2$link4);
        fprintf(stderr, "(urcu-defer-impl.h:%s@%u) Unrecoverable error: %s\n", (const void *)"wake_up_defer", 159, return_value_strerror$3$link4);
        abort();
      }
      while((_Bool)0);

  }

}

// wake_up_gp
// file urcu/static/urcu.h line 158
static inline void wake_up_gp(void)
{
  volatile signed int tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((volatile signed int *)&(*(&rcu_gp_memb.futex)));
  volatile signed int tmp_statement_expression$1;
  if(tmp_statement_expression$2 == -1)
  {
    signed int _v;
    *((volatile signed int *)&(*(&rcu_gp_memb.futex))) = 0;
    tmp_statement_expression$1 = *((volatile signed int *)&(*(&rcu_gp_memb.futex)));
    _v = tmp_statement_expression$1;
    asm("" :  :  : "memory");
    _v = _v;
    futex_async(&rcu_gp_memb.futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
  }

}

// wake_up_gp$link1
// file urcu/static/urcu.h line 158
static inline void wake_up_gp$link1(void)
{
  volatile signed int tmp_statement_expression$2$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link1 = *((volatile signed int *)&(*(&rcu_gp_mb.futex)));
  volatile signed int tmp_statement_expression$1$link1;
  if(tmp_statement_expression$2$link1 == -1)
  {
    signed int _v$link1;
    *((volatile signed int *)&(*(&rcu_gp_mb.futex))) = 0;
    tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&rcu_gp_mb.futex)));
    _v$link1 = tmp_statement_expression$1$link1;
    asm("" :  :  : "memory");
    _v$link1 = _v$link1;
    futex_async$link1(&rcu_gp_mb.futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
  }

}

// wake_up_gp$link2
// file urcu/static/urcu.h line 158
static inline void wake_up_gp$link2(void)
{
  volatile signed int tmp_statement_expression$2$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2$link2 = *((volatile signed int *)&(*(&rcu_gp_sig.futex)));
  volatile signed int tmp_statement_expression$1$link2;
  if(tmp_statement_expression$2$link2 == -1)
  {
    signed int _v$link2;
    *((volatile signed int *)&(*(&rcu_gp_sig.futex))) = 0;
    tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&rcu_gp_sig.futex)));
    _v$link2 = tmp_statement_expression$1$link2;
    asm("" :  :  : "memory");
    _v$link2 = _v$link2;
    futex_async$link2(&rcu_gp_sig.futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
  }

}

// wake_up_gp$link3
// file urcu/static/urcu-qsbr.h line 97
static inline void wake_up_gp$link3(void)
{
  volatile signed int tmp_statement_expression$1$link3;
  volatile signed int tmp_statement_expression$2$link3;
  if(!(rcu_reader_qsbr.waiting == 0))
  {
    *((volatile signed int *)&rcu_reader_qsbr.waiting) = 0;
    asm("mfence" :  :  : "memory");
    asm("" :  :  : "memory");
    tmp_statement_expression$1$link3 = *((volatile signed int *)&(*(&rcu_gp_qsbr.futex)));
    if(tmp_statement_expression$1$link3 == -1)
    {
      signed int _v;
      *((volatile signed int *)&(*(&rcu_gp_qsbr.futex))) = 0;
      tmp_statement_expression$2$link3 = *((volatile signed int *)&(*(&rcu_gp_qsbr.futex)));
      _v = tmp_statement_expression$2$link3;
      asm("" :  :  : "memory");
      _v = _v;
      futex_noasync$link3(&rcu_gp_qsbr.futex, 1, 1, (struct timespec *)(void *)0, (signed int *)(void *)0, 0);
    }

  }

}

