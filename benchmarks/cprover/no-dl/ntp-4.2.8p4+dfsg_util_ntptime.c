// #anon_enum$isc_assertiontype_require=0$isc_assertiontype_ensure=1$isc_assertiontype_insist=2$isc_assertiontype_invariant=3
// file ../lib/isc/include/isc/assertions.h line 33
enum anonymous$46 { isc_assertiontype_require=0, isc_assertiontype_ensure=1, isc_assertiontype_insist=2, isc_assertiontype_invariant=3 };

// #anon_enum$isc_boolean_false=0$isc_boolean_true=1
// file ../lib/isc/include/isc/boolean.h line 25
enum anonymous$11 { isc_boolean_false=0, isc_boolean_true=1 };

// #anon_enum$isc_taskmgrmode_normal=0$isc_taskmgrmode_privileged=1
// file ../lib/isc/include/isc/task.h line 104
enum anonymous$59 { isc_taskmgrmode_normal=0, isc_taskmgrmode_privileged=1 };

// #anon_enum$task_state_idle=0$task_state_ready=1$task_state_running=2$task_state_done=3
// file ./../lib/isc/task.c line 86
enum anonymous$56 { task_state_idle=0, task_state_ready=1, task_state_running=2, task_state_done=3 };

// tag-#anon#ST[*{SYM#tag-isc__task#}$SYM#tag-isc__task#$'head'||*{SYM#tag-isc__task#}$SYM#tag-isc__task#$'tail'|]
// file ./../lib/isc/task.c line 133
struct anonymous$58;

// tag-#anon#ST[*{SYM#tag-isc__task#}$SYM#tag-isc__task#$'prev'||*{SYM#tag-isc__task#}$SYM#tag-isc__task#$'next'|]
// file ./../lib/isc/task.c line 119
struct anonymous$57;

// tag-#anon#ST[*{SYM#tag-isc_buffer#}$SYM#tag-isc_buffer#$'prev'||*{SYM#tag-isc_buffer#}$SYM#tag-isc_buffer#$'next'|]
// file ../lib/isc/include/isc/buffer.h line 179
struct anonymous$16;

// tag-#anon#ST[*{SYM#tag-isc_event#}$SYM#tag-isc_event#$'head'||*{SYM#tag-isc_event#}$SYM#tag-isc_event#$'tail'|]
// file ../lib/isc/include/isc/types.h line 56
struct anonymous$52;

// tag-#anon#ST[*{SYM#tag-isc_event#}$SYM#tag-isc_event#$'prev'||*{SYM#tag-isc_event#}$SYM#tag-isc_event#$'next'|]
// file ../lib/isc/include/isc/event.h line 81
struct anonymous$8;

// tag-#anon#ST[*{SYM#tag-isc_logchannel#}$SYM#tag-isc_logchannel#$'head'||*{SYM#tag-isc_logchannel#}$SYM#tag-isc_logchannel#$'tail'|]
// file ./../lib/isc/log.c line 119
struct anonymous$22;

// tag-#anon#ST[*{SYM#tag-isc_logchannel#}$SYM#tag-isc_logchannel#$'prev'||*{SYM#tag-isc_logchannel#}$SYM#tag-isc_logchannel#$'next'|]
// file ./../lib/isc/log.c line 78
struct anonymous$26;

// tag-#anon#ST[*{SYM#tag-isc_logchannellist#}$SYM#tag-isc_logchannellist#$'head'||*{SYM#tag-isc_logchannellist#}$SYM#tag-isc_logchannellist#$'tail'|]
// file ./../lib/isc/log.c line 120
struct anonymous$23;

// tag-#anon#ST[*{SYM#tag-isc_logchannellist#}$SYM#tag-isc_logchannellist#$'prev'||*{SYM#tag-isc_logchannellist#}$SYM#tag-isc_logchannellist#$'next'|]
// file ./../lib/isc/log.c line 94
struct anonymous$28;

// tag-#anon#ST[*{SYM#tag-isc_logmessage#}$SYM#tag-isc_logmessage#$'head'||*{SYM#tag-isc_logmessage#}$SYM#tag-isc_logmessage#$'tail'|]
// file ./../lib/isc/log.c line 158
struct anonymous$12;

// tag-#anon#ST[*{SYM#tag-isc_logmessage#}$SYM#tag-isc_logmessage#$'prev'||*{SYM#tag-isc_logmessage#}$SYM#tag-isc_logmessage#$'next'|]
// file ./../lib/isc/log.c line 106
struct anonymous$29;

// tag-#anon#ST[*{SYM#tag-isc_sockaddr#}$SYM#tag-isc_sockaddr#$'prev'||*{SYM#tag-isc_sockaddr#}$SYM#tag-isc_sockaddr#$'next'|]
// file ../lib/isc/include/isc/sockaddr.h line 42
struct anonymous$10;

// tag-#anon#ST[*{SYM#tag-recvbuf#}$SYM#tag-recvbuf#$'phead'||*{*{SYM#tag-recvbuf#}$SYM#tag-recvbuf#$}$*{SYM#tag-recvbuf#}$SYM#tag-recvbuf#$$'pptail'|]
// file recvbuff.c line 25
struct anonymous$7;

// tag-#anon#ST[*{SYM#tag-resulttable#}$SYM#tag-resulttable#$'head'||*{SYM#tag-resulttable#}$SYM#tag-resulttable#$'tail'|]
// file ./../lib/isc/result.c line 112
struct anonymous$53;

// tag-#anon#ST[*{SYM#tag-resulttable#}$SYM#tag-resulttable#$'prev'||*{SYM#tag-resulttable#}$SYM#tag-resulttable#$'next'|]
// file ./../lib/isc/result.c line 40
struct anonymous$54;

// tag-#anon#ST[*{SYM#tag-savekey#}$SYM#tag-savekey#$'b'||*{SYM#tag-savekey#}$SYM#tag-savekey#$'f'|]
// file authkeys.c line 26
struct anonymous$55;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$37;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$35;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$25;

// tag-#anon#ST[ARR4{U32}$U32$'buf'||ARR2{U32}$U32$'bytes'||ARR16{U32}$U32$'in'|]
// file ../lib/isc/include/isc/md5.h line 60
struct anonymous$45;

// tag-#anon#ST[ARR5{U32}$U32$'state'||ARR2{U32}$U32$'count'||ARR64{U8}$U8$'buffer'|]
// file ../lib/isc/include/isc/sha1.h line 45
struct anonymous$62;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$3;

// tag-#anon#ST[S32'hi'||S32'lo'|]
// file ../include/ntp_calendar.h line 34
struct anonymous$61;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$31;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$34;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$33;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$27;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$32;

// tag-#anon#ST[S32'tv_sec'||S32'tv_usec'|]
// file /usr/include/x86_64-linux-gnu/bits/utmp.h line 73
struct anonymous$39;

// tag-#anon#ST[S64'quot'||S64'rem'|]
// file /usr/include/inttypes.h line 271
struct anonymous$13;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$36;

// tag-#anon#ST[SYM#tag-#anon#UN[U32'Xl_ui'||S32'Xl_i'|]#'Ul_i'||U32'l_uf'|]
// file ../include/ntp_fp.h line 30
struct anonymous$20;

// tag-#anon#ST[U16'll'||U16'lh'||U16'hl'||S16'hh'|]
// file ../include/ntp_types.h line 190
struct anonymous$40;

// tag-#anon#ST[U16'll'||U16'lh'||U16'hl'||U16'hh'|]
// file ../include/ntp_types.h line 193
struct anonymous$41;

// tag-#anon#ST[U32'lo'||S32'hi'|]
// file ../include/ntp_types.h line 196
struct anonymous$42;

// tag-#anon#ST[U32'lo'||U32'hi'|]
// file ../include/ntp_types.h line 199
struct anonymous$43;

// tag-#anon#ST[U32'magic'|]
// file ../lib/isc/include/isc/magic.h line 25
struct anonymous$21;

// tag-#anon#ST[cU16'more_help'||cU16'save_opts'||cU16'number_option'||cU16'default_opt'|]
// file /usr/include/autoopts/options.h line 551
struct anonymous$0;

// tag-#anon#UN[*{S8}$S8$'ptr'||*{SYM#tag-rsa_st#}$SYM#tag-rsa_st#$'rsa'||*{SYM#tag-dsa_st#}$SYM#tag-dsa_st#$'dsa'||*{SYM#tag-dh_st#}$SYM#tag-dh_st#$'dh'||*{SYM#tag-ec_key_st#}$SYM#tag-ec_key_st#$'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous$6;

// tag-#anon#UN[*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'ifu_broadaddr'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'ifu_dstaddr'|]
// file /usr/include/ifaddrs.h line 38
union anonymous$18;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$24;

// tag-#anon#UN[*{cS8}$cS8$'argString'||U64'argEnum'||U64'argIntptr'||S64'argInt'||U64'argUint'||U32'argBool'||*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$'argFp'||S32'argFd'|]
// file /usr/include/autoopts/options.h line 450
union anonymous;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$49;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$38;

// tag-#anon#UN[ARR32{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous$65;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$60;

// tag-#anon#UN[ARR64{U8}$U8$'c'||ARR16{U32}$U32$'l'|]
// file ./../lib/isc/sha1.c line 125
union anonymous$63;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$1;

// tag-#anon#UN[SYM#tag-#anon#ST[U16'll'||U16'lh'||U16'hl'||S16'hh'|]#'w_s'||SYM#tag-#anon#ST[U16'll'||U16'lh'||U16'hl'||U16'hh'|]#'W_s'||SYM#tag-#anon#ST[U32'lo'||S32'hi'|]#'d_s'||SYM#tag-#anon#ST[U32'lo'||U32'hi'|]#'D_s'||S64'q_s'||U64'Q_s'|]
// file ../include/ntp_types.h line 175
union anonymous$44;

// tag-#anon#UN[SYM#tag-#anon#UN[SYM#tag-sockaddr#'sa'||SYM#tag-sockaddr_in#'sa4'||SYM#tag-sockaddr_in6#'sa6'|]#'X_recv_srcadr'||*{S8}$S8$'X_recv_srcclock'||*{SYM#tag-peer#}$SYM#tag-peer#$'X_recv_peer'||U256'$pad'|]
// file ../include/recvbuff.h line 51
union anonymous$4;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$2;

// tag-#anon#UN[SYM#tag-in_addr#'in'||SYM#tag-in6_addr#'in6'|]
// file ../lib/isc/include/isc/netaddr.h line 38
union anonymous$51;

// tag-#anon#UN[SYM#tag-pkt#'X_recv_pkt'||ARR1000{U8}$U8$'X_recv_buffer'|]
// file ../include/recvbuff.h line 70
union anonymous$5;

// tag-#anon#UN[SYM#tag-sockaddr#'sa'||SYM#tag-sockaddr_in#'sa4'||SYM#tag-sockaddr_in6#'sa6'|]
// file ../include/ntp_net.h line 28
union anonymous$47;

// tag-#anon#UN[SYM#tag-sockaddr#'sa'||SYM#tag-sockaddr_in#'sin'||SYM#tag-sockaddr_in6#'sin6'|]
// file ../lib/isc/include/isc/sockaddr.h line 33
union anonymous$50;

// tag-#anon#UN[U32'Xl_ui'||S32'Xl_i'|]
// file ../include/ntp_fp.h line 31
union anonymous$19;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$48;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$64;

// tag-HistEvent
// file /usr/include/histedit.h line 189
struct HistEvent;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__exit_status
// file /usr/include/x86_64-linux-gnu/bits/utmpx.h line 42
struct __exit_status;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-blocking_child_tag
// file ../include/ntp_worker.h line 70
struct blocking_child_tag;

// tag-blocking_gai_req_tag
// file ntp_intres.c line 122
struct blocking_gai_req_tag;

// tag-blocking_gai_resp_tag
// file ntp_intres.c line 135
struct blocking_gai_resp_tag;

// tag-blocking_gni_req_tag
// file ntp_intres.c line 147
struct blocking_gni_req_tag;

// tag-blocking_gni_resp_tag
// file ntp_intres.c line 161
struct blocking_gni_resp_tag;

// tag-blocking_magic_sig_e
// file ../include/ntp_worker.h line 27
enum blocking_magic_sig_e { BLOCKING_REQ_MAGIC=1359773391, BLOCKING_RESP_MAGIC=1359773268 };

// tag-blocking_pipe_header_tag
// file ../include/ntp_worker.h line 36
struct blocking_pipe_header_tag;

// tag-blocking_work_req_tag
// file ../include/ntp_worker.h line 20
enum blocking_work_req_tag { BLOCKING_GETNAMEINFO=0, BLOCKING_GETADDRINFO=1 };

// tag-calendar
// file ../include/ntp_calendar.h line 12
struct calendar;

// tag-cert_info
// file ../include/ntp_crypto.h line 155
struct cert_info;

// tag-clktype
// file ../include/ntp_refclock.h line 33
struct clktype;

// tag-codestring
// file statestr.c line 23
struct codestring;

// tag-ctl_var
// file ../include/ntp_refclock.h line 87
struct ctl_var;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-dnschild_ctx_tag
// file ntp_intres.c line 175
struct dnschild_ctx_tag;

// tag-dnsworker_ctx_tag
// file ntp_intres.c line 181
struct dnsworker_ctx_tag;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-editline
// file /usr/include/histedit.h line 57
struct editline;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-exit_status
// file /usr/include/x86_64-linux-gnu/bits/utmp.h line 50
struct exit_status;

// tag-exten
// file ../include/ntp_crypto.h line 142
struct exten;

// tag-history
// file /usr/include/histedit.h line 187
struct history;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-ifaddrs
// file /usr/include/ifaddrs.h line 29
struct ifaddrs;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-interface
// file ../include/ntp.h line 174
struct interface;

// tag-isc__task
// file ./../lib/isc/task.c line 100
struct isc__task;

// tag-isc__taskmethods
// file ./../lib/isc/task.c line 250
struct isc__taskmethods;

// tag-isc__taskmgr
// file ./../lib/isc/task.c line 101
struct isc__taskmgr;

// tag-isc_backtrace_symmap
// file ../lib/isc/include/isc/types.h line 47
struct isc_backtrace_symmap;

// tag-isc_buffer
// file ../lib/isc/include/isc/types.h line 49
struct isc_buffer;

// tag-isc_dir
// file ../lib/isc/unix/include/isc/dir.h line 49
struct isc_dir;

// tag-isc_direntry
// file ../lib/isc/unix/include/isc/dir.h line 37
struct isc_direntry;

// tag-isc_event
// file ../lib/isc/include/isc/types.h line 55
struct isc_event;

// tag-isc_interface
// file ../lib/isc/include/isc/types.h line 65
struct isc_interface;

// tag-isc_interfaceiter
// file ../lib/isc/include/isc/types.h line 66
struct isc_interfaceiter;

// tag-isc_interval
// file ../lib/isc/include/isc/types.h line 67
struct isc_interval;

// tag-isc_log
// file ../lib/isc/include/isc/types.h line 69
struct isc_log;

// tag-isc_logcategory
// file ../lib/isc/include/isc/types.h line 70
struct isc_logcategory;

// tag-isc_logchannel
// file ./../lib/isc/log.c line 70
struct isc_logchannel;

// tag-isc_logchannellist
// file ./../lib/isc/log.c line 89
struct isc_logchannellist;

// tag-isc_logconfig
// file ../lib/isc/include/isc/types.h line 71
struct isc_logconfig;

// tag-isc_logdestination
// file ../lib/isc/include/isc/log.h line 138
union isc_logdestination;

// tag-isc_logfile
// file ../lib/isc/include/isc/log.h line 119
struct isc_logfile;

// tag-isc_logmessage
// file ./../lib/isc/log.c line 101
struct isc_logmessage;

// tag-isc_logmodule
// file ../lib/isc/include/isc/types.h line 72
struct isc_logmodule;

// tag-isc_mem
// file ../lib/isc/include/isc/types.h line 73
struct isc_mem;

// tag-isc_msgcat
// file ../lib/isc/include/isc/types.h line 75
struct isc_msgcat;

// tag-isc_netaddr
// file ../lib/isc/include/isc/types.h line 77
struct isc_netaddr;

// tag-isc_ondestroy
// file ../lib/isc/include/isc/types.h line 76
struct isc_ondestroy;

// tag-isc_region
// file ../lib/isc/include/isc/types.h line 82
struct isc_region;

// tag-isc_sockaddr
// file ../lib/isc/include/isc/types.h line 86
struct isc_sockaddr;

// tag-isc_task
// file ../lib/isc/include/isc/types.h line 93
struct isc_task;

// tag-isc_taskmethods
// file ../lib/isc/include/isc/task.h line 120
struct isc_taskmethods;

// tag-isc_taskmgr
// file ../lib/isc/include/isc/types.h line 95
struct isc_taskmgr;

// tag-isc_taskmgrmethods
// file ../lib/isc/include/isc/task.h line 110
struct isc_taskmgrmethods;

// tag-isc_time
// file ../lib/isc/include/isc/types.h line 97
struct isc_time;

// tag-isodate
// file ../include/ntp_calendar.h line 24
struct isodate;

// tag-ntptimeval
// file /usr/include/x86_64-linux-gnu/sys/timex.h line 30
struct ntptimeval;

// tag-opt_desc
// file /usr/include/autoopts/options.h line 405
struct opt_desc;

// tag-options
// file /usr/include/autoopts/options.h line 407
struct options;

// tag-peer
// file ../include/ntp.h line 197
struct peer;

// tag-pkey_info
// file ../include/ntp_crypto.h line 174
struct pkey_info;

// tag-pkt
// file ../include/ntp.h line 533
struct pkt;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-recvbuf
// file ../include/recvbuff.h line 47
struct recvbuf;

// tag-refclock
// file ../include/ntp_refclock.h line 144
struct refclock;

// tag-refclockbug
// file ../include/ntp_refclock.h line 118
struct refclockbug;

// tag-refclockio
// file ../include/ntp_refclock.h line 94
struct refclockio;

// tag-refclockproc
// file ../include/ntp.h line 276
struct refclockproc;

// tag-refclockstat
// file ../include/ntp_refclock.h line 68
struct refclockstat;

// tag-resulttable
// file ./../lib/isc/result.c line 34
struct resulttable;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-savekey
// file ../include/ntp_stdlib.h line 92
struct savekey;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timex
// file /usr/include/x86_64-linux-gnu/bits/timex.h line 25
struct timex;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-utmp
// file /usr/include/x86_64-linux-gnu/bits/utmp.h line 58
struct utmp;

// tag-utmpx
// file /usr/include/x86_64-linux-gnu/bits/utmpx.h line 55
struct utmpx;

// tag-value
// file ../include/ntp_crypto.h line 129
struct value;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_free_strings
// file /usr/include/openssl/err.h line 353
void ERR_free_strings(void);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// ERR_load_crypto_strings
// file /usr/include/openssl/err.h line 352
void ERR_load_crypto_strings(void);
// EVP_DigestFinal
// file /usr/include/openssl/evp.h line 603
signed int EVP_DigestFinal(struct env_md_ctx_st *, unsigned char *, unsigned int *);
// EVP_DigestInit
// file /usr/include/openssl/evp.h line 602
signed int EVP_DigestInit(struct env_md_ctx_st *, const struct env_md_st *);
// EVP_DigestInit_ex
// file /usr/include/openssl/evp.h line 594
signed int EVP_DigestInit_ex(struct env_md_ctx_st *, const struct env_md_st *, struct engine_st *);
// EVP_DigestUpdate
// file /usr/include/openssl/evp.h line 595
signed int EVP_DigestUpdate(struct env_md_ctx_st *, const void *, unsigned long int);
// EVP_MD_CTX_init
// file /usr/include/openssl/evp.h line 586
void EVP_MD_CTX_init(struct env_md_ctx_st *);
// EVP_MD_CTX_set_flags
// file /usr/include/openssl/evp.h line 591
void EVP_MD_CTX_set_flags(struct env_md_ctx_st *, signed int);
// EVP_cleanup
// file /usr/include/openssl/evp.h line 927
void EVP_cleanup(void);
// EVP_get_digestbyname
// file /usr/include/openssl/evp.h line 926
const struct env_md_st * EVP_get_digestbyname(const char *);
// EVP_md5
// file /usr/include/openssl/evp.h line 716
const struct env_md_st * EVP_md5(void);
// FindConfig
// file findconfig.c line 68
extern const char * FindConfig(const char *base);
// MD5auth_setkey
// file authkeys.c line 516
extern void MD5auth_setkey(unsigned int keyno, signed int keytype, const unsigned char *key, unsigned long int len);
// MD5authdecrypt
// file a_md5encrypt.c line 60
extern signed int MD5authdecrypt(signed int type, unsigned char *key, unsigned int *pkt, signed int length, signed int size);
// MD5authencrypt
// file a_md5encrypt.c line 20
extern signed int MD5authencrypt(signed int type, unsigned char *key, unsigned int *pkt, signed int length);
// OBJ_nid2sn
// file /usr/include/openssl/objects.h line 1010
const char * OBJ_nid2sn(signed int);
// OBJ_sn2nid
// file /usr/include/openssl/objects.h line 1016
signed int OBJ_sn2nid(const char *);
// OPENSSL_add_all_algorithms_noconf
// file /usr/include/openssl/evp.h line 905
void OPENSSL_add_all_algorithms_noconf(void);
// RAND_bytes
// file /usr/include/openssl/rand.h line 101
signed int RAND_bytes(unsigned char *, signed int);
// RAND_poll
// file /usr/include/openssl/rand.h line 112
signed int RAND_poll(void);
// _IO_putc
// file /usr/include/libio.h line 435
extern signed int _IO_putc(signed int, struct _IO_FILE *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __res_init
// file /usr/include/resolv.h line 273
signed int __res_init(void);
// __sigsetjmp
// file /usr/include/setjmp.h line 59
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// abs_tval
// file ../include/timevalops.h line 256
static inline struct timeval abs_tval(struct timeval a);
// add_full_recv_buffer
// file recvbuff.c line 175
extern void add_full_recv_buffer(struct recvbuf *rb);
// add_tspec_ns
// file ../include/timespecops.h line 140
static inline struct timespec add_tspec_ns(struct timespec a, signed long int b);
// addr2refid
// file a_md5encrypt.c line 105
extern unsigned int addr2refid(union anonymous$47 *addr);
// addremove_io_fd$object
//
void addremove_io_fd$object(signed int, signed int, signed int);
// addto_syslog
// file msyslog.c line 143
void addto_syslog(signed int level, const char *msg);
// addv64
// file vint64ops.c line 175
extern union anonymous$44 addv64(const union anonymous$44 *lhs, const union anonymous$44 *rhs);
// addv64i32
// file vint64ops.c line 213
extern union anonymous$44 addv64i32(const union anonymous$44 *lhs, signed int rhs);
// addv64u32
// file vint64ops.c line 251
extern union anonymous$44 addv64u32(const union anonymous$44 *lhs, unsigned int rhs);
// adj_systime
// file systime.c line 278
extern signed int adj_systime(double now);
// adjtime
// file /usr/include/x86_64-linux-gnu/sys/time.h line 85
extern signed int adjtime(struct timeval *, struct timeval *);
// adjtimex
// file /usr/include/x86_64-linux-gnu/sys/timex.h line 58
extern signed int adjtimex(struct timex *);
// alloc_dnsworker_context
// file ntp_intres.c line 953
static void alloc_dnsworker_context(unsigned int idx);
// allocsymkey
// file authkeys.c line 263
static void allocsymkey(struct savekey **bucket, unsigned int id, unsigned short int flags, unsigned short int type, unsigned long int lifetime, unsigned short int secretsize, unsigned char *secret);
// assignchannel
// file ./../lib/isc/log.c line 1056
static unsigned int assignchannel(struct isc_logconfig *lcfg, unsigned int category_id, const struct isc_logmodule *module, struct isc_logchannel *channel);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atexit_ssl_cleanup
// file ssl_init.c line 40
void atexit_ssl_cleanup(void);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atoint
// file atoint.c line 12
extern signed int atoint(const char *str, signed long int *ival);
// atolfp
// file atolfp.c line 30
extern signed int atolfp(const char *str, struct anonymous$20 *lfp);
// atouint
// file atouint.c line 17
extern signed int atouint(const char *str, unsigned long int *uval);
// audio_config_read
// file audio.c line 115
static void audio_config_read(signed int unit, const char **c_dev, const char **i_dev);
// audio_gain
// file audio.c line 367
signed int audio_gain(signed int gain, signed int mongain, signed int port);
// audio_init
// file audio.c line 212
signed int audio_init(const char *dname, signed int bufsiz, signed int unit);
// audio_show
// file audio.c line 477
void audio_show(void);
// auth_agekeys
// file authkeys.c line 624
extern void auth_agekeys(void);
// auth_delkeys
// file authkeys.c line 592
extern void auth_delkeys(void);
// auth_findkey
// file authkeys.c line 322
extern struct savekey * auth_findkey(unsigned int id);
// auth_havekey
// file authkeys.c line 342
extern signed int auth_havekey(unsigned int id);
// auth_log2
// file authkeys.c line 214
static inline unsigned short int auth_log2(double x);
// auth_moremem
// file authkeys.c line 159
extern void auth_moremem(signed int keycount);
// auth_prealloc_symkeys
// file authkeys.c line 198
extern void auth_prealloc_symkeys(signed int keycount);
// auth_resize_hashtable
// file authkeys.c line 228
static void auth_resize_hashtable(void);
// authdecrypt
// file authkeys.c line 675
extern signed int authdecrypt(unsigned int keyno, unsigned int *pkt, signed int length, signed int size);
// authencrypt
// file authkeys.c line 645
extern signed int authencrypt(unsigned int keyno, unsigned int *pkt, signed int length);
// authhavekey
// file authkeys.c line 367
extern signed int authhavekey(unsigned int id);
// authistrusted
// file authkeys.c line 491
extern signed int authistrusted(unsigned int keyno);
// authreadkeys
// file authreadkeys.c line 103
extern signed int authreadkeys(const char *file);
// authtrust
// file authkeys.c line 424
extern void authtrust(unsigned int id, unsigned long int trust);
// authusekey
// file authusekey.c line 20
extern signed int authusekey(unsigned int keyno, signed int keytype, const unsigned char *str);
// available_blocking_child_slot
// file ntp_worker.c line 127
extern unsigned int available_blocking_child_slot(void);
// badopt
// file getopt.c line 38
static signed int badopt(const char *mess, signed int ch);
// block_thread_signals
// file work_thread.c line 502
static void block_thread_signals(struct anonymous$25 *pmask);
// blocking_child_common
// file ntp_worker.c line 269
extern signed int blocking_child_common(struct blocking_child_tag *c);
// blocking_getaddrinfo
// file ntp_intres.c line 303
extern signed int blocking_getaddrinfo(struct blocking_child_tag *c, struct blocking_pipe_header_tag *req);
// blocking_getnameinfo
// file ntp_intres.c line 676
extern signed int blocking_getnameinfo(struct blocking_child_tag *c, struct blocking_pipe_header_tag *req);
// blocking_thread
// file work_thread.c line 656
void * blocking_thread(void *ThreadArg);
// bsearch
// file /usr/include/stdlib.h line 754
extern void * bsearch(const void *, const void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// buftvtots
// file buftvtots.c line 16
extern signed int buftvtots(const char *bufp, struct anonymous$20 *ts);
// byteSwap
// file ./../lib/isc/md5.c line 71
static void byteSwap(unsigned int *buf, unsigned int words);
// bzero
// file /usr/include/strings.h line 50
extern void bzero(void *, unsigned long int);
// caldaystart
// file calyearstart.c line 79
extern unsigned int caldaystart(unsigned int ntptime, const signed long int *pivot);
// caljulian
// file caljulian.c line 22
extern void caljulian(unsigned int ntp, struct calendar *jt);
// calmonthstart
// file calyearstart.c line 42
extern unsigned int calmonthstart(unsigned int ntptime, const signed long int *pivot);
// caltontp
// file caltontp.c line 36
extern unsigned int caltontp(struct calendar *jt);
// calweekstart
// file calyearstart.c line 61
extern unsigned int calweekstart(unsigned int ntptime, const signed long int *pivot);
// calyearstart
// file calyearstart.c line 23
extern unsigned int calyearstart(unsigned int ntptime, const signed long int *pivot);
// ceventstr
// file statestr.c line 496
extern const char * ceventstr(signed int num);
// cfsetispeed
// file /usr/include/termios.h line 57
extern signed int cfsetispeed(struct termios *, unsigned int);
// cfsetospeed
// file /usr/include/termios.h line 54
extern signed int cfsetospeed(struct termios *, unsigned int);
// change_logfile
// file msyslog.c line 455
extern signed int change_logfile(const char *fname, signed int leave_crumbs);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// cleanup_after_child
// file work_thread.c line 686
static void cleanup_after_child(struct blocking_child_tag *c);
// clearerr
// file /usr/include/stdio.h line 826
extern void clearerr(struct _IO_FILE *);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// clock_settime
// file /usr/include/time.h line 345
extern signed int clock_settime(signed int, struct timespec *);
// clockname
// file clocktypes.c line 112
extern const char * clockname(signed int num);
// clocktime
// file clocktime.c line 52
extern signed int clocktime(signed int yday, signed int hour, signed int minute, signed int second, signed int tzoff, unsigned int rec_ui, unsigned long int *yearstart, unsigned int *ts_ui);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_all_beyond
// file ntp_worker.c line 100
extern void close_all_beyond(signed int keep_fd);
// close_all_except
// file ntp_worker.c line 80
extern void close_all_except(signed int keep_fd);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// cmp_tspec
// file ../include/timespecops.h line 224
static inline signed int cmp_tspec(struct timespec a, struct timespec b);
// common_prettydate
// file prettydate.c line 155
static char * common_prettydate(struct anonymous$20 *ts, signed int local);
// convertLFPToRefID
// file refidsmear.c line 36
extern unsigned int convertLFPToRefID(struct anonymous$20 num);
// convertRefIDToLFP
// file refidsmear.c line 18
extern struct anonymous$20 convertRefIDToLFP(unsigned int r);
// copy_addrinfo_common
// file ntp_rfc2553.c line 157
struct addrinfo * copy_addrinfo_common(struct addrinfo *src, signed int just_one);
// copy_addrinfo_impl
// file ntp_rfc2553.c line 119
struct addrinfo * copy_addrinfo_impl(struct addrinfo *src);
// copy_addrinfo_list_impl
// file ntp_rfc2553.c line 138
struct addrinfo * copy_addrinfo_list_impl(struct addrinfo *src);
// create_buffers
// file recvbuff.c line 79
static void create_buffers(signed int nbufs);
// ctime
// file /usr/include/time.h line 264
extern char * ctime(const signed long int *);
// ctrl_c_hook$object
//
void ctrl_c_hook$object(void);
// decode_bitflags
// file statestr.c line 335
static const char * decode_bitflags(signed int bits, const char *sep2, struct codestring *tab, unsigned long int tab_ct);
// decodenetnum
// file decodenetnum.c line 24
extern signed int decodenetnum(const char *num, union anonymous$47 *netnum);
// default_callback
// file ./../lib/isc/assertions.c line 105
static void default_callback(const char *file, signed int line, enum anonymous$46 type, const char *cond);
// default_fatal_callback
// file ./../lib/isc/error.c line 97
static void default_fatal_callback(const char *file, signed int line, const char *format, void **args);
// default_unexpected_callback
// file ./../lib/isc/error.c line 87
static void default_unexpected_callback(const char *file, signed int line, const char *format, void **args);
// dequeue_events
// file ./../lib/isc/task.c line 638
static unsigned int dequeue_events(struct isc__task *task, void *sender, unsigned int first, unsigned int last, void *tag, struct anonymous$52 *events, enum anonymous$11 purging);
// destroy
// file ./../lib/isc/event.c line 36
static void destroy(struct isc_event *event);
// dir_current
// file ./../lib/isc/unix/file.c line 429
static unsigned int dir_current(char *dirname, unsigned long int length);
// dispatch
// file ./../lib/isc/task.c line 978
static void dispatch(struct isc__taskmgr *manager);
// dofptoa
// file dofptoa.c line 13
extern char * dofptoa(unsigned int fpv, signed int neg, signed short int ndec, signed int msec);
// dolfptoa
// file dolfptoa.c line 13
extern char * dolfptoa(unsigned int fpi, unsigned int fpv, signed int neg, signed short int ndec, signed int msec);
// doublefreq
// file icom.c line 107
static void doublefreq(double freq, unsigned char *x, signed int len);
// el_end
// file /usr/include/histedit.h line 89
void el_end(struct editline *);
// el_gets
// file /usr/include/histedit.h line 95
const char * el_gets(struct editline *, signed int *);
// el_init
// file /usr/include/histedit.h line 86
struct editline * el_init(const char *, struct _IO_FILE *, struct _IO_FILE *, struct _IO_FILE *);
// el_set
// file /usr/include/histedit.h line 113
signed int el_set(struct editline *, signed int, ...);
// el_source
// file /usr/include/histedit.h line 166
signed int el_source(struct editline *, const char *);
// empty_readyq
// file ./../lib/isc/task.c line 925
static inline enum anonymous$11 empty_readyq(struct isc__taskmgr *manager);
// ensure_workitems_empty_slot
// file work_thread.c line 129
static void ensure_workitems_empty_slot(struct blocking_child_tag *c);
// ensure_workresp_empty_slot
// file work_thread.c line 157
static void ensure_workresp_empty_slot(struct blocking_child_tag *c);
// ereallocz
// file ../include/ntp_stdlib.h line 105
extern void * ereallocz(void *ptr, unsigned long int newsz, unsigned long int priorsz, signed int zero_init);
// errno_to_str
// file msyslog.c line 99
extern void errno_to_str(signed int err, char *buf, unsigned long int bufsiz);
// estrdup_impl
// file emalloc.c line 116
extern char * estrdup_impl(const char *str);
// eventstr
// file statestr.c line 481
extern const char * eventstr(signed int num);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_worker
// file work_thread.c line 72
extern void exit_worker(signed int exitcode);
// fatal_callback$object
//
void fatal_callback$object(const char *, signed int, const char *, void **);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_stats
// file ./../lib/isc/unix/file.c line 89
static unsigned int file_stats(const char *file, struct stat *stats);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fix_tv_usec
// file ./../lib/isc/unix/stdtime.c line 41
static inline void fix_tv_usec(struct timeval *tv);
// fix_tv_usec$link1
// file ./../lib/isc/unix/time.c line 62
static inline void fix_tv_usec$link1(struct timeval *tv$link1);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// format_time_fraction
// file ../include/timetoa.h line 81
extern const char * format_time_fraction(signed long int secs, signed long int frac, signed int prec);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fptoa
// file dofptoa.c line 123
extern char * fptoa(signed int fpv, signed short int ndec);
// fptoms
// file dofptoa.c line 143
extern char * fptoms(signed int fpv, signed short int ndec);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_recvbuffs
// file recvbuff.c line 49
extern unsigned long int free_recvbuffs(void);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freeifaddrs
// file /usr/include/ifaddrs.h line 69
extern void freeifaddrs(struct ifaddrs *);
// freerecvbuf
// file recvbuff.c line 157
extern void freerecvbuf(struct recvbuf *rb);
// freesymkey
// file authkeys.c line 296
static void freesymkey(struct savekey *sk, struct savekey **bucket);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// fsync
// file /usr/include/unistd.h line 956
extern signed int fsync(signed int);
// full_recvbuffs
// file recvbuff.c line 55
extern unsigned long int full_recvbuffs(void);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_addr
// file ./../lib/isc/unix/interfaceiter.c line 70
static void get_addr(unsigned int family, struct isc_netaddr *dst, struct sockaddr *src, char *ifname);
// get_dnschild_ctx
// file ntp_intres.c line 938
static unsigned int get_dnschild_ctx(void);
// get_free_recv_buffer
// file recvbuff.c line 189
extern struct recvbuf * get_free_recv_buffer(void);
// get_full_recv_buffer
// file recvbuff.c line 226
extern struct recvbuf * get_full_recv_buffer(void);
// get_ostime
// file systime.c line 127
static inline void get_ostime(struct timespec *tsp);
// get_struct_tm
// file prettydate.c line 63
static struct tm * get_struct_tm(const union anonymous$44 *stamp, signed int local);
// get_systime
// file systime.c line 162
extern void get_systime(struct anonymous$20 *now);
// get_worker_context
// file ntp_intres.c line 965
static struct dnsworker_ctx_tag * get_worker_context(struct blocking_child_tag *c, unsigned int idx);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getaddrinfo_sometime
// file ntp_intres.c line 235
extern signed int getaddrinfo_sometime(const char *node, const char *service, struct addrinfo *hints, signed int retry, void (*callback)(signed int, signed int, void *, const char *, const char *, struct addrinfo *, struct addrinfo *), void *context);
// getaddrinfo_sometime::callback$object
//
void callback$object(signed int, signed int, void *, const char *, const char *, struct addrinfo *, struct addrinfo *);
// getaddrinfo_sometime_complete
// file ntp_intres.c line 458
static void getaddrinfo_sometime_complete(enum blocking_work_req_tag rtype, void *context, unsigned long int respsize, void *resp);
// getcode
// file statestr.c line 286
static const char * getcode(signed int code, struct codestring *codetab);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getevents
// file statestr.c line 309
static const char * getevents(signed int cnt);
// gethostbyaddr
// file /usr/include/netdb.h line 137
extern struct hostent * gethostbyaddr(const void *, unsigned int, signed int);
// getifaddrs
// file /usr/include/ifaddrs.h line 66
extern signed int getifaddrs(struct ifaddrs **);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getnameinfo_sometime
// file ntp_intres.c line 623
extern signed int getnameinfo_sometime(union anonymous$47 *psau, unsigned long int hostoctets, unsigned long int servoctets, signed int flags, void (*callback)(signed int, signed int, union anonymous$47 *, signed int, const char *, const char *, void *), void *context);
// getnameinfo_sometime::callback$object
//
void callback$object(signed int, signed int, union anonymous$47 *, signed int, const char *, const char *, void *);
// getnameinfo_sometime_complete
// file ntp_intres.c line 789
static void getnameinfo_sometime_complete(enum blocking_work_req_tag rtype, void *context, unsigned long int respsize, void *resp);
// getpass
// file ../include/l_stdlib.h line 53
extern char * getpass(const char *);
// getpass_keytype
// file ssl_init.c line 168
extern char * getpass_keytype(signed int keytype);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, union anonymous$64, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gmprettydate
// file prettydate.c line 214
extern char * gmprettydate(struct anonymous$20 *ts);
// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// good_rand
// file ntp_random.c line 216
static inline signed long int good_rand(signed long int x);
// greatest_version
// file ./../lib/isc/log.c line 1144
static unsigned int greatest_version(struct isc_logchannel *channel, signed int *greatestp);
// has_full_recv_buffer
// file recvbuff.c line 296
extern enum anonymous$11 has_full_recv_buffer(void);
// hextoint
// file hextoint.c line 11
extern signed int hextoint(const char *str, unsigned long int *pu);
// hextolfp
// file hextolfp.c line 13
extern signed int hextolfp(const char *str, struct anonymous$20 *lfp);
// history
// file /usr/include/histedit.h line 200
signed int history(struct history *, struct HistEvent *, signed int, ...);
// history_end
// file /usr/include/histedit.h line 198
void history_end(struct history *);
// history_init
// file /usr/include/histedit.h line 197
struct history * history_init(void);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// humanlogtime
// file humandate.c line 17
extern const char * humanlogtime(void);
// humantime
// file humandate.c line 43
extern const char * humantime(signed long int cursec);
// icmpv64
// file vint64ops.c line 128
extern signed int icmpv64(const union anonymous$44 *lhs, const union anonymous$44 *rhs);
// icom_freq
// file icom.c line 72
signed int icom_freq(signed int fd, signed int ident, double freq);
// icom_init
// file icom.c line 139
signed int icom_init(const char *device, signed int speed, signed int trace);
// if_nametoindex
// file /usr/include/net/if.h line 193
extern unsigned int if_nametoindex(const char *);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_ntop4
// file ./../lib/isc/inet_ntop.c line 89
static const char * inet_ntop4(const unsigned char *src, char *dst, unsigned long int size);
// inet_ntop6
// file ./../lib/isc/inet_ntop.c line 114
static const char * inet_ntop6(const unsigned char *src, char *dst, unsigned long int size);
// inet_pton4
// file ./../lib/isc/inet_pton.c line 83
static signed int inet_pton4(const char *src, unsigned char *dst);
// inet_pton6
// file ./../lib/isc/inet_pton.c line 135
static signed int inet_pton6(const char *src, unsigned char *dst);
// init_auth
// file authkeys.c line 106
extern void init_auth(void);
// init_lib
// file lib_strbuf.c line 31
extern void init_lib(void);
// init_lock
// file ./../lib/isc/unix/strerror.c line 40
static void init_lock(void);
// init_logging
// file msyslog.c line 379
extern void init_logging(const char *name, unsigned int def_syslogmask, signed int is_daemon);
// init_recvbuff
// file recvbuff.c line 109
extern void init_recvbuff(signed int nbufs);
// init_systime
// file systime.c line 116
extern void init_systime(void);
// initialise_buffer
// file recvbuff.c line 73
static inline void initialise_buffer(struct recvbuf *buff);
// initialize
// file ./../lib/isc/unix/net.c line 220
static void initialize(void);
// initialize$link1
// file ./../lib/isc/random.c line 58
static void initialize$link1(void);
// initialize$link2
// file ./../lib/isc/result.c line 166
static void initialize$link2(void);
// initialize_action
// file ./../lib/isc/unix/net.c line 205
static void initialize_action(void);
// initialize_action$link1
// file ./../lib/isc/result.c line 149
static void initialize_action$link1(void);
// initialize_ipv6only
// file ./../lib/isc/unix/net.c line 315
static void initialize_ipv6only(void);
// initialize_ipv6pktinfo
// file ./../lib/isc/unix/net.c line 368
static void initialize_ipv6pktinfo(void);
// initialize_rand
// file ./../lib/isc/random.c line 42
static void initialize_rand(void);
// int32_sflag
// file ntp_calendar.c line 130
static inline unsigned int int32_sflag(const signed int v);
// int32_to_uint32_2cpl
// file ntp_calendar.c line 154
static inline unsigned int int32_to_uint32_2cpl(const signed int v);
// internal_current
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 140
static unsigned int internal_current(struct isc_interfaceiter *iter);
// internal_destroy
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 264
static void internal_destroy(struct isc_interfaceiter *iter);
// internal_first
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 277
static void internal_first(struct isc_interfaceiter *iter);
// internal_next
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 248
static unsigned int internal_next(struct isc_interfaceiter *iter);
// interrupt_worker_sleep
// file work_thread.c line 114
extern void interrupt_worker_sleep(void);
// intres_timeout_req
// file ../include/ntp_intres.h line 43
extern void intres_timeout_req(unsigned int);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// isc___errno2result
// file ./../lib/isc/unix/errno2result.h line 37
unsigned int isc___errno2result(signed int posixerrno, const char *file, unsigned int line);
// isc__buffer_activeregion
// file ./../lib/isc/buffer.c line 180
void isc__buffer_activeregion(struct isc_buffer *b, struct isc_region *r);
// isc__buffer_add
// file ./../lib/isc/buffer.c line 121
void isc__buffer_add(struct isc_buffer *b, unsigned int n);
// isc__buffer_availableregion
// file ./../lib/isc/buffer.c line 109
void isc__buffer_availableregion(struct isc_buffer *b, struct isc_region *r);
// isc__buffer_back
// file ./../lib/isc/buffer.c line 227
void isc__buffer_back(struct isc_buffer *b, unsigned int n);
// isc__buffer_clear
// file ./../lib/isc/buffer.c line 145
void isc__buffer_clear(struct isc_buffer *b);
// isc__buffer_consumedregion
// file ./../lib/isc/buffer.c line 156
void isc__buffer_consumedregion(struct isc_buffer *b, struct isc_region *r);
// isc__buffer_first
// file ./../lib/isc/buffer.c line 204
void isc__buffer_first(struct isc_buffer *b);
// isc__buffer_forward
// file ./../lib/isc/buffer.c line 215
void isc__buffer_forward(struct isc_buffer *b, unsigned int n);
// isc__buffer_init
// file ./../lib/isc/buffer.c line 31
void isc__buffer_init(struct isc_buffer *b, const void *base, unsigned int length);
// isc__buffer_initnull
// file ./../lib/isc/buffer.c line 43
void isc__buffer_initnull(struct isc_buffer *b);
// isc__buffer_invalidate
// file ./../lib/isc/buffer.c line 72
void isc__buffer_invalidate(struct isc_buffer *b);
// isc__buffer_putmem
// file ./../lib/isc/buffer.c line 398
void isc__buffer_putmem(struct isc_buffer *b, const unsigned char *base, unsigned int length);
// isc__buffer_putstr
// file ./../lib/isc/buffer.c line 408
void isc__buffer_putstr(struct isc_buffer *b, const char *source);
// isc__buffer_putuint16
// file ./../lib/isc/buffer.c line 312
void isc__buffer_putuint16(struct isc_buffer *b, unsigned short int val);
// isc__buffer_putuint24
// file ./../lib/isc/buffer.c line 320
void isc__buffer_putuint24(struct isc_buffer *b, unsigned int val);
// isc__buffer_putuint32
// file ./../lib/isc/buffer.c line 351
void isc__buffer_putuint32(struct isc_buffer *b, unsigned int val);
// isc__buffer_putuint48
// file ./../lib/isc/buffer.c line 384
void isc__buffer_putuint48(struct isc_buffer *b, unsigned long long int val);
// isc__buffer_putuint8
// file ./../lib/isc/buffer.c line 283
void isc__buffer_putuint8(struct isc_buffer *b, unsigned char val);
// isc__buffer_region
// file ./../lib/isc/buffer.c line 85
void isc__buffer_region(struct isc_buffer *b, struct isc_region *r);
// isc__buffer_remainingregion
// file ./../lib/isc/buffer.c line 168
void isc__buffer_remainingregion(struct isc_buffer *b, struct isc_region *r);
// isc__buffer_setactive
// file ./../lib/isc/buffer.c line 192
void isc__buffer_setactive(struct isc_buffer *b, unsigned int n);
// isc__buffer_subtract
// file ./../lib/isc/buffer.c line 133
void isc__buffer_subtract(struct isc_buffer *b, unsigned int n);
// isc__buffer_usedregion
// file ./../lib/isc/buffer.c line 97
void isc__buffer_usedregion(struct isc_buffer *b, struct isc_region *r);
// isc__mutex_init
// file ../lib/isc/pthreads/include/isc/mutex.h line 79
unsigned int isc__mutex_init(union anonymous$2 *mp, const char *file, unsigned int line);
// isc__strerror
// file ../lib/isc/unix/include/isc/strerror.h line 41
void isc__strerror(signed int num, char *buf, unsigned long int size);
// isc__task_attach
// file ../lib/isc/include/isc/task.h line 212
void isc__task_attach(struct isc_task *source0, struct isc_task **targetp);
// isc__task_beginexclusive
// file ./../lib/isc/task.c line 1641
unsigned int isc__task_beginexclusive(struct isc_task *task0);
// isc__task_create
// file ./../lib/isc/task.c line 329
unsigned int isc__task_create(struct isc_taskmgr *manager0, unsigned int quantum, struct isc_task **taskp);
// isc__task_destroy
// file ./../lib/isc/task.c line 854
void isc__task_destroy(struct isc_task **taskp);
// isc__task_detach
// file ./../lib/isc/task.c line 505
void isc__task_detach(struct isc_task **taskp);
// isc__task_endexclusive
// file ./../lib/isc/task.c line 1663
void isc__task_endexclusive(struct isc_task *task0);
// isc__task_getcurrenttime
// file ./../lib/isc/task.c line 902
void isc__task_getcurrenttime(struct isc_task *task0, unsigned int *t);
// isc__task_getname
// file ./../lib/isc/task.c line 884
const char * isc__task_getname(struct isc_task *task0);
// isc__task_gettag
// file ./../lib/isc/task.c line 893
void * isc__task_gettag(struct isc_task *task0);
// isc__task_onshutdown
// file ./../lib/isc/task.c line 795
unsigned int isc__task_onshutdown(struct isc_task *task0, void (*action)(struct isc_task *, struct isc_event *), const void *arg);
// isc__task_onshutdown::action$object
//
void action$object(struct isc_task *, struct isc_event *);
// isc__task_privilege
// file ./../lib/isc/task.c line 1707
enum anonymous$11 isc__task_privilege(struct isc_task *task0);
// isc__task_purge
// file ./../lib/isc/task.c line 710
unsigned int isc__task_purge(struct isc_task *task, void *sender, unsigned int type, void *tag);
// isc__task_purgeevent
// file ./../lib/isc/task.c line 723
enum anonymous$11 isc__task_purgeevent(struct isc_task *task0, struct isc_event *event);
// isc__task_purgerange
// file ./../lib/isc/task.c line 678
unsigned int isc__task_purgerange(struct isc_task *task0, void *sender, unsigned int first, unsigned int last, void *tag);
// isc__task_send
// file ./../lib/isc/task.c line 560
void isc__task_send(struct isc_task *task0, struct isc_event **eventp);
// isc__task_sendanddetach
// file ../lib/isc/include/isc/task.h line 265
void isc__task_sendanddetach(struct isc_task **taskp, struct isc_event **eventp);
// isc__task_setname
// file ./../lib/isc/task.c line 867
void isc__task_setname(struct isc_task *task0, const char *name, void *tag);
// isc__task_setprivilege
// file ./../lib/isc/task.c line 1680
void isc__task_setprivilege(struct isc_task *task0, enum anonymous$11 priv);
// isc__task_shutdown
// file ./../lib/isc/task.c line 835
void isc__task_shutdown(struct isc_task *task0);
// isc__task_unsend
// file ./../lib/isc/task.c line 781
unsigned int isc__task_unsend(struct isc_task *task, void *sender, unsigned int type, void *tag, struct anonymous$52 *events);
// isc__task_unsendrange
// file ./../lib/isc/task.c line 766
unsigned int isc__task_unsendrange(struct isc_task *task, void *sender, unsigned int first, unsigned int last, void *tag, struct anonymous$52 *events);
// isc__taskmgr_create
// file ./../lib/isc/task.c line 1321
unsigned int isc__taskmgr_create(struct isc_mem *mctx, unsigned int workers, unsigned int default_quantum, struct isc_taskmgr **managerp);
// isc__taskmgr_destroy
// file ./../lib/isc/task.c line 1456
void isc__taskmgr_destroy(struct isc_taskmgr **managerp);
// isc__taskmgr_mode
// file ./../lib/isc/task.c line 1570
enum anonymous$59 isc__taskmgr_mode(struct isc_taskmgr *manager0);
// isc__taskmgr_pause
// file ./../lib/isc/task.c line 1617
void isc__taskmgr_pause(struct isc_taskmgr *manager0);
// isc__taskmgr_resume
// file ./../lib/isc/task.c line 1628
void isc__taskmgr_resume(struct isc_taskmgr *manager0);
// isc__taskmgr_setmode
// file ./../lib/isc/task.c line 1561
void isc__taskmgr_setmode(struct isc_taskmgr *manager0, enum anonymous$59 mode);
// isc_assertion_failed
// file ../lib/isc/include/isc/assertions.h line 45
void isc_assertion_failed(const char *file, signed int line, enum anonymous$46 type, const char *cond);
// isc_assertion_failed_cb$object
//
void isc_assertion_failed_cb$object(const char *, signed int, enum anonymous$46, const char *);
// isc_assertion_setcallback
// file ./../lib/isc/assertions.c line 64
void isc_assertion_setcallback(void (*cb)(const char *, signed int, enum anonymous$46, const char *));
// isc_assertion_setcallback::cb$object
//
void cb$object(const char *, signed int, enum anonymous$46, const char *);
// isc_assertion_typetotext
// file ./../lib/isc/assertions.c line 73
const char * isc_assertion_typetotext(enum anonymous$46 type);
// isc_backtrace_getsymbol
// file ../lib/isc/include/isc/backtrace.h line 109
unsigned int isc_backtrace_getsymbol(const void *addr, const char **symbolp, unsigned long int *offsetp);
// isc_backtrace_getsymbolfromindex
// file ./../lib/isc/backtrace.c line 214
unsigned int isc_backtrace_getsymbolfromindex(signed int idx, const void **addrp, const char **symbolp);
// isc_backtrace_gettrace
// file ../lib/isc/include/isc/backtrace.h line 66
unsigned int isc_backtrace_gettrace(void **addrs, signed int maxaddrs, signed int *nframes);
// isc_buffer_allocate
// file ./../lib/isc/buffer.c line 449
unsigned int isc_buffer_allocate(struct isc_mem *mctx, struct isc_buffer **dynbuffer, unsigned int length);
// isc_buffer_compact
// file ./../lib/isc/buffer.c line 239
void isc_buffer_compact(struct isc_buffer *b);
// isc_buffer_copyregion
// file ./../lib/isc/buffer.c line 428
unsigned int isc_buffer_copyregion(struct isc_buffer *b, const struct isc_region *r);
// isc_buffer_free
// file ./../lib/isc/buffer.c line 471
void isc_buffer_free(struct isc_buffer **dynbuffer);
// isc_buffer_getuint16
// file ./../lib/isc/buffer.c line 291
unsigned short int isc_buffer_getuint16(struct isc_buffer *b);
// isc_buffer_getuint32
// file ./../lib/isc/buffer.c line 328
unsigned int isc_buffer_getuint32(struct isc_buffer *b);
// isc_buffer_getuint48
// file ./../lib/isc/buffer.c line 359
unsigned long long int isc_buffer_getuint48(struct isc_buffer *b);
// isc_buffer_getuint8
// file ./../lib/isc/buffer.c line 264
unsigned char isc_buffer_getuint8(struct isc_buffer *b);
// isc_buffer_reinit
// file ./../lib/isc/buffer.c line 53
void isc_buffer_reinit(struct isc_buffer *b, void *base, unsigned int length);
// isc_condition_waituntil
// file ./../lib/isc/pthreads/condition.c line 34
unsigned int isc_condition_waituntil(union anonymous$1 *c, union anonymous$2 *m, struct isc_time *t);
// isc_dir_chdir
// file ./../lib/isc/unix/dir.c line 161
unsigned int isc_dir_chdir(const char *dirname);
// isc_dir_chroot
// file ./../lib/isc/unix/dir.c line 175
unsigned int isc_dir_chroot(const char *dirname);
// isc_dir_close
// file ./../lib/isc/unix/dir.c line 141
void isc_dir_close(struct isc_dir *dir);
// isc_dir_createunique
// file ./../lib/isc/unix/dir.c line 190
unsigned int isc_dir_createunique(char *templet);
// isc_dir_init
// file ./../lib/isc/unix/dir.c line 44
void isc_dir_init(struct isc_dir *dir);
// isc_dir_open
// file ./../lib/isc/unix/dir.c line 60
unsigned int isc_dir_open(struct isc_dir *dir, const char *dirname);
// isc_dir_read
// file ./../lib/isc/unix/dir.c line 106
unsigned int isc_dir_read(struct isc_dir *dir);
// isc_dir_reset
// file ./../lib/isc/unix/dir.c line 152
unsigned int isc_dir_reset(struct isc_dir *dir);
// isc_error_fatal
// file ./../lib/isc/error.c line 70
void isc_error_fatal(const char *file, signed int line, const char *format, ...);
// isc_error_runtimecheck
// file ./../lib/isc/error.c line 80
void isc_error_runtimecheck(const char *file, signed int line, const char *expression);
// isc_error_setfatal
// file ./../lib/isc/error.c line 53
void isc_error_setfatal(void (*cb)(const char *, signed int, const char *, void **));
// isc_error_setfatal::cb$object
//
void cb$object(const char *, signed int, const char *, void **);
// isc_error_setunexpected
// file ./../lib/isc/error.c line 45
void isc_error_setunexpected(void (*cb)(const char *, signed int, const char *, void **));
// isc_error_setunexpected::cb$object
//
void cb$object(const char *, signed int, const char *, void **);
// isc_error_unexpected
// file ../lib/isc/include/isc/error.h line 45
void isc_error_unexpected(const char *file, signed int line, const char *format, ...);
// isc_event_allocate
// file ./../lib/isc/event.c line 41
struct isc_event * isc_event_allocate(struct isc_mem *mctx, void *sender, unsigned int type, void (*action)(struct isc_task *, struct isc_event *), const void *arg, unsigned long int size);
// isc_event_allocate::action$object
//
void action$object(struct isc_task *, struct isc_event *);
// isc_event_free
// file ./../lib/isc/event.c line 75
void isc_event_free(struct isc_event **eventp);
// isc_file_absolutepath
// file ./../lib/isc/unix/file.c line 454
unsigned int isc_file_absolutepath(const char *filename, char *path, unsigned long int pathlen);
// isc_file_basename
// file ./../lib/isc/unix/file.c line 392
const char * isc_file_basename(const char *filename);
// isc_file_exists
// file ./../lib/isc/unix/file.c line 344
enum anonymous$11 isc_file_exists(const char *pathname);
// isc_file_getmodtime
// file ./../lib/isc/unix/file.c line 102
unsigned int isc_file_getmodtime(const char *file, struct isc_time *itime);
// isc_file_isabsolute
// file ./../lib/isc/unix/file.c line 370
enum anonymous$11 isc_file_isabsolute(const char *filename);
// isc_file_ischdiridempotent
// file ./../lib/isc/unix/file.c line 382
enum anonymous$11 isc_file_ischdiridempotent(const char *filename);
// isc_file_iscurrentdir
// file ./../lib/isc/unix/file.c line 376
enum anonymous$11 isc_file_iscurrentdir(const char *filename);
// isc_file_isplainfile
// file ./../lib/isc/unix/file.c line 353
unsigned int isc_file_isplainfile(const char *filename);
// isc_file_mktemplate
// file ./../lib/isc/unix/file.c line 165
unsigned int isc_file_mktemplate(const char *path, char *buf, unsigned long int buflen);
// isc_file_openunique
// file ./../lib/isc/unix/file.c line 248
unsigned int isc_file_openunique(char *templet, struct _IO_FILE **fp);
// isc_file_openuniquemode
// file ./../lib/isc/unix/file.c line 260
unsigned int isc_file_openuniquemode(char *templet, signed int mode, struct _IO_FILE **fp);
// isc_file_openuniqueprivate
// file ./../lib/isc/unix/file.c line 254
unsigned int isc_file_openuniqueprivate(char *templet, struct _IO_FILE **fp);
// isc_file_progname
// file ./../lib/isc/unix/file.c line 405
unsigned int isc_file_progname(const char *filename, char *buf, unsigned long int buflen);
// isc_file_remove
// file ./../lib/isc/unix/file.c line 317
unsigned int isc_file_remove(const char *filename);
// isc_file_rename
// file ./../lib/isc/unix/file.c line 330
unsigned int isc_file_rename(const char *oldname, const char *newname);
// isc_file_renameunique
// file ./../lib/isc/unix/file.c line 205
unsigned int isc_file_renameunique(const char *file, char *templet);
// isc_file_safecreate
// file ./../lib/isc/unix/file.c line 475
unsigned int isc_file_safecreate(const char *filename, struct _IO_FILE **fp);
// isc_file_settime
// file ./../lib/isc/unix/file.c line 122
unsigned int isc_file_settime(const char *file, struct isc_time *itime);
// isc_file_splitpath
// file ./../lib/isc/unix/file.c line 511
unsigned int isc_file_splitpath(struct isc_mem *mctx, char *path, char **dirnam, char **basenam);
// isc_file_template
// file ./../lib/isc/unix/file.c line 170
unsigned int isc_file_template(const char *path, const char *templet, char *buf, unsigned long int buflen);
// isc_file_truncate
// file ./../lib/isc/unix/file.c line 466
unsigned int isc_file_truncate(const char *filename, signed long int size);
// isc_hash_calc
// file ../lib/isc/include/isc/hash.h line 161
unsigned int isc_hash_calc(const unsigned char *, unsigned int, enum anonymous$11);
// isc_interfaceiter_create
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 54
unsigned int isc_interfaceiter_create(struct isc_mem *mctx, struct isc_interfaceiter **iterp);
// isc_interfaceiter_current
// file ./../lib/isc/unix/interfaceiter.c line 266
unsigned int isc_interfaceiter_current(struct isc_interfaceiter *iter, struct isc_interface *ifdata);
// isc_interfaceiter_destroy
// file ./../lib/isc/unix/interfaceiter.c line 313
void isc_interfaceiter_destroy(struct isc_interfaceiter **iterp);
// isc_interfaceiter_first
// file ./../lib/isc/unix/interfaceiter.c line 275
unsigned int isc_interfaceiter_first(struct isc_interfaceiter *iter);
// isc_interfaceiter_next
// file ./../lib/isc/unix/interfaceiter.c line 294
unsigned int isc_interfaceiter_next(struct isc_interfaceiter *iter);
// isc_interval_iszero
// file ./../lib/isc/unix/time.c line 98
enum anonymous$11 isc_interval_iszero(const struct isc_interval *i);
// isc_interval_set
// file ../lib/isc/unix/include/isc/time.h line 49
void isc_interval_set(struct isc_interval *i, unsigned int seconds, unsigned int nanoseconds);
// isc_lib_initmsgcat
// file ./../lib/isc/lib.c line 60
void isc_lib_initmsgcat(void);
// isc_log_categorybyname
// file ./../lib/isc/log.c line 613
struct isc_logcategory * isc_log_categorybyname(struct isc_log *lctx, const char *name);
// isc_log_closefilelogs
// file ./../lib/isc/log.c line 1033
void isc_log_closefilelogs(struct isc_log *lctx);
// isc_log_create
// file ./../lib/isc/log.c line 268
unsigned int isc_log_create(struct isc_mem *mctx, struct isc_log **lctxp, struct isc_logconfig **lcfgp);
// isc_log_createchannel
// file ./../lib/isc/log.c line 703
unsigned int isc_log_createchannel(struct isc_logconfig *lcfg, const char *name, unsigned int type, signed int level, const union isc_logdestination *destination, unsigned int flags);
// isc_log_destroy
// file ./../lib/isc/log.c line 462
void isc_log_destroy(struct isc_log **lctxp);
// isc_log_doit
// file ./../lib/isc/log.c line 1405
static void isc_log_doit(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, enum anonymous$11 write_once, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, void **args);
// isc_log_getdebuglevel
// file ./../lib/isc/log.c line 979
unsigned int isc_log_getdebuglevel(struct isc_log *lctx);
// isc_log_getduplicateinterval
// file ./../lib/isc/log.c line 993
unsigned int isc_log_getduplicateinterval(struct isc_logconfig *lcfg);
// isc_log_gettag
// file ./../lib/isc/log.c line 1020
char * isc_log_gettag(struct isc_logconfig *lcfg);
// isc_log_ivwrite
// file ./../lib/isc/log.c line 905
void isc_log_ivwrite(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, void **args);
// isc_log_ivwrite1
// file ./../lib/isc/log.c line 936
void isc_log_ivwrite1(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, void **args);
// isc_log_iwrite
// file ./../lib/isc/log.c line 887
void isc_log_iwrite(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, ...);
// isc_log_iwrite1
// file ./../lib/isc/log.c line 918
void isc_log_iwrite1(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, ...);
// isc_log_modulebyname
// file ./../lib/isc/log.c line 680
struct isc_logmodule * isc_log_modulebyname(struct isc_log *lctx, const char *name);
// isc_log_open
// file ./../lib/isc/log.c line 1319
static unsigned int isc_log_open(struct isc_logchannel *channel);
// isc_log_opensyslog
// file ./../lib/isc/log.c line 1028
void isc_log_opensyslog(const char *tag, signed int options, signed int facility);
// isc_log_registercategories
// file ./../lib/isc/log.c line 569
void isc_log_registercategories(struct isc_log *lctx, struct isc_logcategory *categories);
// isc_log_registermodules
// file ./../lib/isc/log.c line 636
void isc_log_registermodules(struct isc_log *lctx, struct isc_logmodule *modules);
// isc_log_setcontext
// file ./../lib/isc/log.c line 949
void isc_log_setcontext(struct isc_log *lctx);
// isc_log_setdebuglevel
// file ./../lib/isc/log.c line 954
void isc_log_setdebuglevel(struct isc_log *lctx, unsigned int level);
// isc_log_setduplicateinterval
// file ./../lib/isc/log.c line 986
void isc_log_setduplicateinterval(struct isc_logconfig *lcfg, unsigned int interval);
// isc_log_settag
// file ./../lib/isc/log.c line 1000
unsigned int isc_log_settag(struct isc_logconfig *lcfg, const char *tag);
// isc_log_usechannel
// file ./../lib/isc/log.c line 788
unsigned int isc_log_usechannel(struct isc_logconfig *lcfg, const char *name, const struct isc_logcategory *category, const struct isc_logmodule *module);
// isc_log_vwrite
// file ./../lib/isc/log.c line 847
void isc_log_vwrite(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, const char *format, void **args);
// isc_log_vwrite1
// file ./../lib/isc/log.c line 875
void isc_log_vwrite1(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, const char *format, void **args);
// isc_log_wouldlog
// file ./../lib/isc/log.c line 1378
enum anonymous$11 isc_log_wouldlog(struct isc_log *lctx, signed int level);
// isc_log_write
// file ../lib/isc/include/isc/log.h line 568
void isc_log_write(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, const char *format, ...);
// isc_log_write1
// file ./../lib/isc/log.c line 859
void isc_log_write1(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, const char *format, ...);
// isc_logconfig_create
// file ./../lib/isc/log.c line 331
unsigned int isc_logconfig_create(struct isc_log *lctx, struct isc_logconfig **lcfgp);
// isc_logconfig_destroy
// file ./../lib/isc/log.c line 503
void isc_logconfig_destroy(struct isc_logconfig **lcfgp);
// isc_logconfig_get
// file ./../lib/isc/log.c line 423
struct isc_logconfig * isc_logconfig_get(struct isc_log *lctx);
// isc_logconfig_use
// file ./../lib/isc/log.c line 432
unsigned int isc_logconfig_use(struct isc_log *lctx, struct isc_logconfig *lcfg);
// isc_md5_final
// file ./../lib/isc/md5.c line 248
void isc_md5_final(struct anonymous$45 *ctx, unsigned char *digest);
// isc_md5_init
// file ./../lib/isc/md5.c line 87
void isc_md5_init(struct anonymous$45 *ctx);
// isc_md5_invalidate
// file ./../lib/isc/md5.c line 98
void isc_md5_invalidate(struct anonymous$45 *ctx);
// isc_md5_update
// file ./../lib/isc/md5.c line 209
void isc_md5_update(struct anonymous$45 *ctx, const unsigned char *buf, unsigned int len);
// isc_msgcat_close
// file ./../lib/isc/nls/msgcat.c line 87
void isc_msgcat_close(struct isc_msgcat **msgcatp);
// isc_msgcat_get
// file ../lib/isc/include/isc/msgcat.h line 112
const char * isc_msgcat_get(struct isc_msgcat *msgcat, signed int set, signed int message, const char *default_text);
// isc_msgcat_open
// file ../lib/isc/include/isc/msgcat.h line 71
void isc_msgcat_open(const char *name, struct isc_msgcat **msgcatp);
// isc_net_disableipv4
// file ./../lib/isc/unix/net.c line 498
void isc_net_disableipv4(void);
// isc_net_disableipv6
// file ./../lib/isc/unix/net.c line 505
void isc_net_disableipv6(void);
// isc_net_enableipv4
// file ./../lib/isc/unix/net.c line 512
void isc_net_enableipv4(void);
// isc_net_enableipv6
// file ./../lib/isc/unix/net.c line 519
void isc_net_enableipv6(void);
// isc_net_getudpportrange
// file ./../lib/isc/unix/net.c line 478
unsigned int isc_net_getudpportrange(signed int af, unsigned short int *low, unsigned short int *high);
// isc_net_ntop
// file ./../lib/isc/inet_ntop.c line 60
const char * isc_net_ntop(signed int af, const void *src, char *dst, unsigned long int size);
// isc_net_probe_ipv6only
// file ./../lib/isc/unix/net.c line 377
unsigned int isc_net_probe_ipv6only(void);
// isc_net_probe_ipv6pktinfo
// file ./../lib/isc/unix/net.c line 389
unsigned int isc_net_probe_ipv6pktinfo(void);
// isc_net_probeipv4
// file ../lib/isc/unix/include/isc/net.h line 259
unsigned int isc_net_probeipv4(void);
// isc_net_probeipv6
// file ../lib/isc/unix/include/isc/net.h line 272
unsigned int isc_net_probeipv6(void);
// isc_net_probeunix
// file ./../lib/isc/unix/net.c line 237
unsigned int isc_net_probeunix(void);
// isc_net_pton
// file ./../lib/isc/inet_pton.c line 59
signed int isc_net_pton(signed int af, const char *src, void *dst);
// isc_netaddr_any
// file ./../lib/isc/netaddr.c line 364
void isc_netaddr_any(struct isc_netaddr *netaddr);
// isc_netaddr_any6
// file ./../lib/isc/netaddr.c line 371
void isc_netaddr_any6(struct isc_netaddr *netaddr);
// isc_netaddr_eqprefix
// file ./../lib/isc/netaddr.c line 70
enum anonymous$11 isc_netaddr_eqprefix(const struct isc_netaddr *a, const struct isc_netaddr *b, unsigned int prefixlen);
// isc_netaddr_equal
// file ./../lib/isc/netaddr.c line 37
enum anonymous$11 isc_netaddr_equal(const struct isc_netaddr *a, const struct isc_netaddr *b);
// isc_netaddr_format
// file ./../lib/isc/netaddr.c line 183
void isc_netaddr_format(const struct isc_netaddr *na, char *array, unsigned int size);
// isc_netaddr_fromin
// file ./../lib/isc/netaddr.c line 290
void isc_netaddr_fromin(struct isc_netaddr *netaddr, struct in_addr *ina);
// isc_netaddr_fromin6
// file ../lib/isc/include/isc/netaddr.h line 111
void isc_netaddr_fromin6(struct isc_netaddr *netaddr, struct in6_addr *ina6);
// isc_netaddr_frompath
// file ./../lib/isc/netaddr.c line 304
unsigned int isc_netaddr_frompath(struct isc_netaddr *netaddr, const char *path);
// isc_netaddr_fromsockaddr
// file ../lib/isc/include/isc/netaddr.h line 105
void isc_netaddr_fromsockaddr(struct isc_netaddr *t, const struct isc_sockaddr *s);
// isc_netaddr_fromv4mapped
// file ./../lib/isc/netaddr.c line 424
void isc_netaddr_fromv4mapped(struct isc_netaddr *t, const struct isc_netaddr *s);
// isc_netaddr_getzone
// file ./../lib/isc/netaddr.c line 331
unsigned int isc_netaddr_getzone(const struct isc_netaddr *netaddr);
// isc_netaddr_isexperimental
// file ./../lib/isc/netaddr.c line 390
enum anonymous$11 isc_netaddr_isexperimental(struct isc_netaddr *na);
// isc_netaddr_islinklocal
// file ../lib/isc/include/isc/netaddr.h line 147
enum anonymous$11 isc_netaddr_islinklocal(struct isc_netaddr *na);
// isc_netaddr_ismulticast
// file ./../lib/isc/netaddr.c line 378
enum anonymous$11 isc_netaddr_ismulticast(struct isc_netaddr *na);
// isc_netaddr_issitelocal
// file ./../lib/isc/netaddr.c line 412
enum anonymous$11 isc_netaddr_issitelocal(struct isc_netaddr *na);
// isc_netaddr_masktoprefixlen
// file ../lib/isc/include/isc/netaddr.h line 66
unsigned int isc_netaddr_masktoprefixlen(const struct isc_netaddr *s, unsigned int *lenp);
// isc_netaddr_prefixok
// file ./../lib/isc/netaddr.c line 216
unsigned int isc_netaddr_prefixok(const struct isc_netaddr *na, unsigned int prefixlen);
// isc_netaddr_setzone
// file ../lib/isc/include/isc/netaddr.h line 117
void isc_netaddr_setzone(struct isc_netaddr *netaddr, unsigned int zone);
// isc_netaddr_totext
// file ./../lib/isc/netaddr.c line 128
unsigned int isc_netaddr_totext(const struct isc_netaddr *netaddr, struct isc_buffer *target);
// isc_netscope_pton
// file ./../lib/isc/netscope.c line 33
unsigned int isc_netscope_pton(signed int af, char *scopename, void *addr, unsigned int *zoneid);
// isc_ondestroy_init
// file ./../lib/isc/ondestroy.c line 36
void isc_ondestroy_init(struct isc_ondestroy *ondest);
// isc_ondestroy_notify
// file ./../lib/isc/ondestroy.c line 66
void isc_ondestroy_notify(struct isc_ondestroy *ondest, void *sender);
// isc_ondestroy_register
// file ./../lib/isc/ondestroy.c line 42
unsigned int isc_ondestroy_register(struct isc_ondestroy *ondest, struct isc_task *task, struct isc_event **eventp);
// isc_random_get
// file ../lib/isc/include/isc/random.h line 45
void isc_random_get(unsigned int *val);
// isc_random_jitter
// file ./../lib/isc/random.c line 103
unsigned int isc_random_jitter(unsigned int max, unsigned int jitter);
// isc_random_seed
// file ./../lib/isc/random.c line 64
void isc_random_seed(unsigned int seed);
// isc_result_register
// file ./../lib/isc/result.c line 208
unsigned int isc_result_register(unsigned int base, unsigned int nresults, const char **txt, struct isc_msgcat *msgcat, signed int set);
// isc_result_totext
// file ../lib/isc/include/isc/result.h line 98
const char * isc_result_totext(unsigned int result);
// isc_sha1_final
// file ./../lib/isc/sha1.c line 325
void isc_sha1_final(struct anonymous$62 *context, unsigned char *digest);
// isc_sha1_init
// file ./../lib/isc/sha1.c line 268
void isc_sha1_init(struct anonymous$62 *context);
// isc_sha1_invalidate
// file ./../lib/isc/sha1.c line 283
void isc_sha1_invalidate(struct anonymous$62 *context);
// isc_sha1_update
// file ./../lib/isc/sha1.c line 291
void isc_sha1_update(struct anonymous$62 *context, const unsigned char *data, unsigned int len);
// isc_sockaddr_any
// file ./../lib/isc/sockaddr.c line 256
void isc_sockaddr_any(struct isc_sockaddr *sockaddr);
// isc_sockaddr_any6
// file ./../lib/isc/sockaddr.c line 270
void isc_sockaddr_any6(struct isc_sockaddr *sockaddr);
// isc_sockaddr_anyofpf
// file ./../lib/isc/sockaddr.c line 299
void isc_sockaddr_anyofpf(struct isc_sockaddr *sockaddr, signed int pf);
// isc_sockaddr_compare
// file ./../lib/isc/sockaddr.c line 50
enum anonymous$11 isc_sockaddr_compare(const struct isc_sockaddr *a, const struct isc_sockaddr *b, unsigned int flags);
// isc_sockaddr_eqaddr
// file ./../lib/isc/sockaddr.c line 44
enum anonymous$11 isc_sockaddr_eqaddr(const struct isc_sockaddr *a, const struct isc_sockaddr *b);
// isc_sockaddr_eqaddrprefix
// file ./../lib/isc/sockaddr.c line 104
enum anonymous$11 isc_sockaddr_eqaddrprefix(const struct isc_sockaddr *a, const struct isc_sockaddr *b, unsigned int prefixlen);
// isc_sockaddr_equal
// file ./../lib/isc/sockaddr.c line 37
enum anonymous$11 isc_sockaddr_equal(const struct isc_sockaddr *a, const struct isc_sockaddr *b);
// isc_sockaddr_format
// file ./../lib/isc/sockaddr.c line 181
void isc_sockaddr_format(const struct isc_sockaddr *sa, char *array, unsigned int size);
// isc_sockaddr_fromin
// file ./../lib/isc/sockaddr.c line 284
void isc_sockaddr_fromin(struct isc_sockaddr *sockaddr, struct in_addr *ina, unsigned short int port);
// isc_sockaddr_fromin6
// file ./../lib/isc/sockaddr.c line 313
void isc_sockaddr_fromin6(struct isc_sockaddr *sockaddr, struct in6_addr *ina6, unsigned short int port);
// isc_sockaddr_fromnetaddr
// file ./../lib/isc/sockaddr.c line 373
void isc_sockaddr_fromnetaddr(struct isc_sockaddr *sockaddr, const struct isc_netaddr *na, unsigned short int port);
// isc_sockaddr_frompath
// file ./../lib/isc/sockaddr.c line 492
unsigned int isc_sockaddr_frompath(struct isc_sockaddr *sockaddr, const char *path);
// isc_sockaddr_getport
// file ./../lib/isc/sockaddr.c line 424
unsigned short int isc_sockaddr_getport(const struct isc_sockaddr *sockaddr);
// isc_sockaddr_hash
// file ./../lib/isc/sockaddr.c line 205
unsigned int isc_sockaddr_hash(const struct isc_sockaddr *sockaddr, enum anonymous$11 address_only);
// isc_sockaddr_isexperimental
// file ./../lib/isc/sockaddr.c line 459
enum anonymous$11 isc_sockaddr_isexperimental(const struct isc_sockaddr *sockaddr);
// isc_sockaddr_islinklocal
// file ./../lib/isc/sockaddr.c line 481
enum anonymous$11 isc_sockaddr_islinklocal(const struct isc_sockaddr *sockaddr);
// isc_sockaddr_ismulticast
// file ./../lib/isc/sockaddr.c line 447
enum anonymous$11 isc_sockaddr_ismulticast(const struct isc_sockaddr *sockaddr);
// isc_sockaddr_issitelocal
// file ./../lib/isc/sockaddr.c line 470
enum anonymous$11 isc_sockaddr_issitelocal(const struct isc_sockaddr *sockaddr);
// isc_sockaddr_pf
// file ./../lib/isc/sockaddr.c line 345
signed int isc_sockaddr_pf(const struct isc_sockaddr *sockaddr);
// isc_sockaddr_setport
// file ./../lib/isc/sockaddr.c line 405
void isc_sockaddr_setport(struct isc_sockaddr *sockaddr, unsigned short int port);
// isc_sockaddr_totext
// file ./../lib/isc/sockaddr.c line 114
unsigned int isc_sockaddr_totext(const struct isc_sockaddr *sockaddr, struct isc_buffer *target);
// isc_sockaddr_v6fromin
// file ./../lib/isc/sockaddr.c line 328
void isc_sockaddr_v6fromin(struct isc_sockaddr *sockaddr, struct in_addr *ina, unsigned short int port);
// isc_stdio_close
// file ./../lib/isc/unix/stdio.c line 42
unsigned int isc_stdio_close(struct _IO_FILE *f);
// isc_stdio_flush
// file ./../lib/isc/unix/stdio.c line 98
unsigned int isc_stdio_flush(struct _IO_FILE *f);
// isc_stdio_open
// file ../lib/isc/include/isc/stdio.h line 43
unsigned int isc_stdio_open(const char *filename, const char *mode, struct _IO_FILE **fp);
// isc_stdio_read
// file ./../lib/isc/unix/stdio.c line 64
unsigned int isc_stdio_read(void *ptr, unsigned long int size, unsigned long int nmemb, struct _IO_FILE *f, unsigned long int *nret);
// isc_stdio_seek
// file ./../lib/isc/unix/stdio.c line 53
unsigned int isc_stdio_seek(struct _IO_FILE *f, signed long int offset, signed int whence);
// isc_stdio_sync
// file ./../lib/isc/unix/stdio.c line 116
unsigned int isc_stdio_sync(struct _IO_FILE *f);
// isc_stdio_write
// file ./../lib/isc/unix/stdio.c line 82
unsigned int isc_stdio_write(const void *ptr, unsigned long int size, unsigned long int nmemb, struct _IO_FILE *f, unsigned long int *nret);
// isc_stdtime_get
// file ./../lib/isc/unix/stdtime.c line 66
void isc_stdtime_get(unsigned int *t);
// isc_string_touint64
// file ../lib/isc/include/isc/string.h line 42
unsigned long long int isc_string_touint64(char *, char **, signed int);
// isc_task_exiting
// file ./../lib/isc/task.c line 1725
enum anonymous$11 isc_task_exiting(struct isc_task *t);
// isc_thread_create
// file ../lib/isc/pthreads/include/isc/thread.h line 39
unsigned int isc_thread_create(void * (*func)(void *), void *arg, unsigned long int *thread);
// isc_thread_create::func$object
//
void * func$object(void *);
// isc_thread_setconcurrency
// file ../lib/isc/pthreads/include/isc/thread.h line 42
void isc_thread_setconcurrency(unsigned int level);
// isc_time_add
// file ./../lib/isc/unix/time.c line 255
unsigned int isc_time_add(const struct isc_time *t, const struct isc_interval *i, struct isc_time *result);
// isc_time_compare
// file ../lib/isc/unix/include/isc/time.h line 179
signed int isc_time_compare(const struct isc_time *t1, const struct isc_time *t2);
// isc_time_formatISO8601
// file ./../lib/isc/unix/time.c line 411
void isc_time_formatISO8601(const struct isc_time *t, char *buf, unsigned int len);
// isc_time_formathttptimestamp
// file ./../lib/isc/unix/time.c line 399
void isc_time_formathttptimestamp(const struct isc_time *t, char *buf, unsigned int len);
// isc_time_formattimestamp
// file ../lib/isc/unix/include/isc/time.h line 291
void isc_time_formattimestamp(const struct isc_time *t, char *buf, unsigned int len);
// isc_time_isepoch
// file ./../lib/isc/unix/time.c line 134
enum anonymous$11 isc_time_isepoch(const struct isc_time *t);
// isc_time_microdiff
// file ./../lib/isc/unix/time.c line 305
unsigned long long int isc_time_microdiff(const struct isc_time *t1, const struct isc_time *t2);
// isc_time_nanoseconds
// file ../lib/isc/unix/include/isc/time.h line 274
unsigned int isc_time_nanoseconds(const struct isc_time *t);
// isc_time_now
// file ../lib/isc/unix/include/isc/time.h line 133
unsigned int isc_time_now(struct isc_time *t);
// isc_time_nowplusinterval
// file ./../lib/isc/unix/time.c line 188
unsigned int isc_time_nowplusinterval(struct isc_time *t, const struct isc_interval *i);
// isc_time_seconds
// file ../lib/isc/unix/include/isc/time.h line 241
unsigned int isc_time_seconds(const struct isc_time *t);
// isc_time_secondsastimet
// file ../lib/isc/unix/include/isc/time.h line 251
unsigned int isc_time_secondsastimet(const struct isc_time *t, signed long int *secondsp);
// isc_time_set
// file ../lib/isc/unix/include/isc/time.h line 91
void isc_time_set(struct isc_time *t, unsigned int seconds, unsigned int nanoseconds);
// isc_time_settoepoch
// file ./../lib/isc/unix/time.c line 126
void isc_time_settoepoch(struct isc_time *t);
// isc_time_subtract
// file ../lib/isc/unix/include/isc/time.h line 211
unsigned int isc_time_subtract(const struct isc_time *t, const struct isc_interval *i, struct isc_time *result);
// isocal_date_to_ntp
// file ntp_calendar.c line 1791
extern unsigned int isocal_date_to_ntp(struct isodate *id);
// isocal_date_to_ntp64
// file ntp_calendar.c line 1775
extern union anonymous$44 isocal_date_to_ntp64(struct isodate *id);
// isocal_ntp64_to_date
// file ntp_calendar.c line 1713
extern signed int isocal_ntp64_to_date(struct isodate *id, const union anonymous$44 *ntp);
// isocal_ntp_to_date
// file ntp_calendar.c line 1754
extern signed int isocal_ntp_to_date(struct isodate *id, unsigned int ntp, const signed long int *piv);
// isocal_split_eraweeks
// file ntp_calendar.c line 1661
extern struct anonymous$61 isocal_split_eraweeks(signed int weeks);
// isocal_weeks_in_years
// file ntp_calendar.c line 1613
extern signed int isocal_weeks_in_years(signed int years);
// k_st_flags
// file statestr.c line 422
extern const char * k_st_flags(unsigned int st);
// keytype_from_text
// file ../include/ntp_stdlib.h line 228
extern signed int keytype_from_text(const char *text, unsigned long int *pdigest_len);
// keytype_name
// file ssl_init.c line 133
extern const char * keytype_name(signed int nid);
// ldexp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 106
extern double ldexp(double, signed int);
// ldiv
// file /usr/include/stdlib.h line 790
extern struct anonymous$13 ldiv(signed long int, signed long int);
// lfp_stamp_to_tval
// file ../include/timevalops.h line 422
static inline struct timeval lfp_stamp_to_tval(struct anonymous$20 x, const signed long int *p);
// link
// file /usr/include/unistd.h line 790
extern signed int link(const char *, const char *);
// linux_if_inet6_current
// file ./../lib/isc/unix/interfaceiter.c line 189
static unsigned int linux_if_inet6_current(struct isc_interfaceiter *iter);
// linux_if_inet6_first
// file ./../lib/isc/unix/interfaceiter.c line 170
static void linux_if_inet6_first(struct isc_interfaceiter *iter);
// linux_if_inet6_next
// file ./../lib/isc/unix/interfaceiter.c line 179
static unsigned int linux_if_inet6_next(struct isc_interfaceiter *iter);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// log10
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 112
extern double log10(double);
// log_maybe
// file authreadkeys.c line 86
static void log_maybe(unsigned long int *pnerr, const char *fmt, ...);
// lowater_additions
// file recvbuff.c line 67
extern unsigned long int lowater_additions(void);
// make_socket_nonblocking
// file socket.c line 128
extern void make_socket_nonblocking(signed int fd);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// manage_dns_retry_interval
// file ntp_intres.c line 1040
static void manage_dns_retry_interval(signed long int *pscheduled, signed long int *pwhen, signed int *pretry, signed long int *pnext_timeslot);
// manager_free
// file ./../lib/isc/task.c line 1297
static void manager_free(struct isc__taskmgr *manager);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mfprintf
// file msyslog.c line 291
extern signed int mfprintf(struct _IO_FILE *fp, const char *fmt, ...);
// mfptoa
// file dolfptoa.c line 140
extern char * mfptoa(unsigned int fpi, unsigned int fpf, signed short int ndec);
// mfptoms
// file dolfptoa.c line 158
extern char * mfptoms(unsigned int fpi, unsigned int fpf, signed short int ndec);
// mixer_name
// file audio.c line 75
static signed int mixer_name(const char *m_name, signed int m_mask);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// modetoa
// file modetoa.c line 11
extern const char * modetoa(unsigned long int mode);
// move_fd
// file socket.c line 54
extern signed int move_fd(signed int fd);
// mprintf
// file ../include/ntp_stdlib.h line 26
extern signed int mprintf(const char *fmt, ...);
// msnprintf
// file msyslog.c line 326
extern signed int msnprintf(char *buf, unsigned long int bufsiz, const char *fmt, ...);
// mstolfp
// file mstolfp.c line 12
extern signed int mstolfp(const char *str, struct anonymous$20 *lfp);
// msyslog
// file ../include/ntp_stdlib.h line 33
extern void msyslog(signed int level, const char *fmt, ...);
// mvfprintf
// file msyslog.c line 259
extern signed int mvfprintf(struct _IO_FILE *fp, const char *fmt, void **ap);
// mvsnprintf
// file msyslog.c line 226
extern signed int mvsnprintf(char *buf, unsigned long int bufsiz, const char *fmt, void **ap);
// mvsyslog
// file ../include/ntp_stdlib.h line 34
extern void mvsyslog(signed int level, const char *fmt, void **ap);
// netof
// file netof.c line 15
extern union anonymous$47 * netof(union anonymous$47 *hostaddr);
// nexttok
// file authreadkeys.c line 25
static char * nexttok(char **str);
// noconst
// file vint64ops.c line 27
static inline void * noconst(const void *ptr);
// normalize_tspec
// file ../include/timespecops.h line 80
static inline struct timespec normalize_tspec(struct timespec x);
// normalize_tval
// file ../include/timevalops.h line 136
static inline struct timeval normalize_tval(struct timeval x);
// normalize_tval$link1
// file ../include/timevalops.h line 136
static inline struct timeval normalize_tval$link1(struct timeval x$link1);
// now
// file ntp_calendar.c line 118
static inline signed long int now(void);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// ntp2unix_tm
// file prettydate.c line 223
extern struct tm * ntp2unix_tm(unsigned int ntp, signed int local);
// ntpOptionPrintVersion
// file ntp_libopts.c line 47
extern void ntpOptionPrintVersion(struct options *pOpts, struct opt_desc *pOD);
// ntpOptionProcess
// file ntp_libopts.c line 27
extern signed int ntpOptionProcess(struct options *pOpts, signed int argc, char **argv);
// ntp_crypto_random_buf
// file ntp_crypto_rnd.c line 88
signed int ntp_crypto_random_buf(void *buf, unsigned long int nbytes);
// ntp_crypto_srandom
// file ntp_crypto_rnd.c line 67
void ntp_crypto_srandom(void);
// ntp_getopt
// file ../include/ntp_stdlib.h line 89
extern signed int ntp_getopt(signed int argc, char **argv, const char *optstring);
// ntp_gettime
// file /usr/include/x86_64-linux-gnu/sys/timex.h line 61
extern signed int ntp_gettime(struct ntptimeval *);
// ntp_prompt_callback
// file ntp_lineedit.c line 236
char * ntp_prompt_callback(struct editline *el);
// ntp_random
// file ../include/ntp_random.h line 7
signed long int ntp_random(void);
// ntp_readline
// file ntp_lineedit.c line 159
char * ntp_readline(signed int *pcount);
// ntp_readline_init
// file ntp_lineedit.c line 65
signed int ntp_readline_init(const char *prompt);
// ntp_readline_uninit
// file ntp_lineedit.c line 129
void ntp_readline_uninit(void);
// ntp_set_tod
// file ../include/ntp_machine.h line 68
signed int ntp_set_tod(struct timeval *tvp, void *tzp);
// ntp_srandom
// file ntp_random.c line 260
void ntp_srandom(unsigned long int x);
// ntp_to_year
// file clocktime.c line 130
static signed int ntp_to_year(unsigned int ntp);
// ntpcal_date_to_daysec
// file ntp_calendar.c line 1393
extern signed int ntpcal_date_to_daysec(struct calendar *jd);
// ntpcal_date_to_ntp
// file ntp_calendar.c line 1490
extern unsigned int ntpcal_date_to_ntp(struct calendar *jd);
// ntpcal_date_to_ntp64
// file ntp_calendar.c line 1477
extern union anonymous$44 ntpcal_date_to_ntp64(struct calendar *jd);
// ntpcal_date_to_rd
// file ../include/ntp_calendar.h line 220
extern signed int ntpcal_date_to_rd(struct calendar *jd);
// ntpcal_date_to_time
// file ../include/ntp_calendar.h line 334
extern signed long int ntpcal_date_to_time(struct calendar *jd);
// ntpcal_dayjoin
// file ../include/ntp_calendar.h line 158
extern union anonymous$44 ntpcal_dayjoin(signed int days, signed int secs);
// ntpcal_days_in_months
// file ntp_calendar.c line 1192
extern struct anonymous$61 ntpcal_days_in_months(signed int m);
// ntpcal_days_in_years
// file ../include/ntp_calendar.h line 170
extern signed int ntpcal_days_in_years(signed int years);
// ntpcal_daysec_to_date
// file ntp_calendar.c line 952
extern signed int ntpcal_daysec_to_date(struct calendar *jd, signed int sec);
// ntpcal_daysec_to_tm
// file ntp_calendar.c line 975
extern signed int ntpcal_daysec_to_tm(struct tm *utm, signed int sec);
// ntpcal_daysplit
// file ../include/ntp_calendar.h line 151
extern struct anonymous$61 ntpcal_daysplit(const union anonymous$44 *ts);
// ntpcal_daysplit_to_date
// file ../include/ntp_calendar.h line 306
extern signed int ntpcal_daysplit_to_date(struct calendar *jd, const struct anonymous$61 *ds, signed int dof);
// ntpcal_daysplit_to_tm
// file ntp_calendar.c line 1023
extern signed int ntpcal_daysplit_to_tm(struct tm *utm, const struct anonymous$61 *ds, signed int dof);
// ntpcal_edate_to_eradays
// file ntp_calendar.c line 1230
extern signed int ntpcal_edate_to_eradays(signed int years, signed int mons, signed int mdays);
// ntpcal_edate_to_yeardays
// file ntp_calendar.c line 1259
extern signed int ntpcal_edate_to_yeardays(signed int years, signed int mons, signed int mdays);
// ntpcal_etime_to_seconds
// file ../include/ntp_calendar.h line 196
extern signed int ntpcal_etime_to_seconds(signed int hours, signed int minutes, signed int seconds);
// ntpcal_get_build_date
// file ../include/ntp_calendar.h line 127
extern signed int ntpcal_get_build_date(struct calendar *jd);
// ntpcal_leapyears_in_years
// file ntp_calendar.c line 1133
extern signed int ntpcal_leapyears_in_years(signed int years);
// ntpcal_ntp64_to_date
// file ntp_calendar.c line 1444
extern signed int ntpcal_ntp64_to_date(struct calendar *jd, const union anonymous$44 *ntp);
// ntpcal_ntp_to_date
// file ntp_calendar.c line 1458
extern signed int ntpcal_ntp_to_date(struct calendar *jd, unsigned int ntp, const signed long int *piv);
// ntpcal_ntp_to_ntp
// file ../include/ntp_calendar.h line 144
extern union anonymous$44 ntpcal_ntp_to_ntp(unsigned int ntp, const signed long int *pivot);
// ntpcal_ntp_to_time
// file ../include/ntp_calendar.h line 135
extern union anonymous$44 ntpcal_ntp_to_time(unsigned int ntp, const signed long int *pivot);
// ntpcal_periodic_extend
// file ntp_calendar.c line 501
extern signed int ntpcal_periodic_extend(signed int pivot, signed int value, signed int cycle);
// ntpcal_rd_to_date
// file ntp_calendar.c line 873
extern signed int ntpcal_rd_to_date(struct calendar *jd, signed int rd);
// ntpcal_rd_to_mstart
// file ../include/ntp_calendar.h line 302
extern signed int ntpcal_rd_to_mstart(signed int rd);
// ntpcal_rd_to_tm
// file ntp_calendar.c line 919
extern signed int ntpcal_rd_to_tm(struct tm *utm, signed int rd);
// ntpcal_rd_to_ystart
// file ../include/ntp_calendar.h line 296
extern signed int ntpcal_rd_to_ystart(signed int rd);
// ntpcal_set_timefunc
// file ntp_calendar.c line 102
extern signed long int (*ntpcal_set_timefunc(signed long int (*nfunc)(signed long int *)))(signed long int *);
// ntpcal_set_timefunc::1::res$object
//
signed long int res$object(signed long int *);
// ntpcal_set_timefunc::nfunc$object
//
signed long int nfunc$object(signed long int *);
// ntpcal_split_eradays
// file ../include/ntp_calendar.h line 234
extern struct anonymous$61 ntpcal_split_eradays(signed int days, signed int *isleapyear);
// ntpcal_split_yeardays
// file ntp_calendar.c line 844
extern struct anonymous$61 ntpcal_split_yeardays(signed int eyd, signed int isleapyear);
// ntpcal_time_to_date
// file ntp_calendar.c line 1040
extern signed int ntpcal_time_to_date(struct calendar *jd, const union anonymous$44 *ts);
// ntpcal_tm_to_daysec
// file ntp_calendar.c line 1407
extern signed int ntpcal_tm_to_daysec(struct tm *utm);
// ntpcal_tm_to_rd
// file ntp_calendar.c line 1311
extern signed int ntpcal_tm_to_rd(struct tm *utm);
// ntpcal_weekday_close
// file ntp_calendar.c line 1533
extern signed int ntpcal_weekday_close(signed int rdn, signed int dow);
// ntpcal_weekday_ge
// file ntp_calendar.c line 1524
extern signed int ntpcal_weekday_ge(signed int rdn, signed int dow);
// ntpcal_weekday_gt
// file ntp_calendar.c line 1515
extern signed int ntpcal_weekday_gt(signed int rdn, signed int dow);
// ntpcal_weekday_le
// file ../include/ntp_calendar.h line 380
extern signed int ntpcal_weekday_le(signed int rdn, signed int dow);
// ntpcal_weekday_lt
// file ntp_calendar.c line 1551
extern signed int ntpcal_weekday_lt(signed int rdn, signed int dow);
// ntpcal_year_to_ystart
// file ../include/ntp_calendar.h line 289
extern signed int ntpcal_year_to_ystart(signed int year);
// numtoa
// file numtoa.c line 18
extern char * numtoa(unsigned int num);
// numtohost
// file numtohost.c line 20
extern char * numtohost(unsigned int netnum);
// octtoint
// file octtoint.c line 12
extern signed int octtoint(const char *str, unsigned long int *ival);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_msgcat
// file ./../lib/isc/lib.c line 55
static void open_msgcat(void);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// optionProcess
// file /usr/include/autoopts/options.h line 987
extern signed int optionProcess(struct options *, signed int, char **);
// oreallocarray
// file emalloc.c line 86
extern void * oreallocarray(void *optr, unsigned long int nmemb, unsigned long int size);
// peer_st_flags
// file statestr.c line 391
static const char * peer_st_flags(unsigned char pst);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// pipe_socketpair
// file ntp_worker.c line 40
extern signed int pipe_socketpair(signed int *caller_fds, signed int *is_pipe);
// pll_trap
// file ntptime.c line 395
void pll_trap(signed int arg);
// pop_readyq
// file ./../lib/isc/task.c line 945
static inline struct isc__task * pop_readyq(struct isc__taskmgr *manager);
// prepare_child_sems
// file work_thread.c line 554
static void prepare_child_sems(struct blocking_child_tag *c);
// prettydate
// file ../include/ntp_fp.h line 357
extern char * prettydate(struct anonymous$20 *ts);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// priv_timesplit
// file ntp_calendar.c line 746
static signed int priv_timesplit(signed int *split, signed int ts);
// process_blocking_resp
// file ntp_worker.c line 228
extern void process_blocking_resp(struct blocking_child_tag *c);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_getstacksize
// file /usr/include/pthread.h line 370
extern signed int pthread_attr_getstacksize(const union pthread_attr_t *, unsigned long int *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$1 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$1 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$1 *, const union anonymous$60 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$1 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$1 *, union anonymous$2 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$1 *, union anonymous$2 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$2 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$2 *, const union anonymous$60 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$2 *);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$25 *, struct anonymous$25 *);
// purge_recv_buffers_for_fd
// file recvbuff.c line 266
extern void purge_recv_buffers_for_fd(signed int fd);
// push_readyq
// file ./../lib/isc/task.c line 970
static inline void push_readyq(struct isc__taskmgr *manager, struct isc__task *task);
// queue_blocking_request
// file ../include/ntp_worker.h line 111
extern signed int queue_blocking_request(enum blocking_work_req_tag rtype, void *req, unsigned long int reqsize, void (*done_func)(enum blocking_work_req_tag, void *, unsigned long int, void *), void *context);
// queue_blocking_request::done_func$object
//
void done_func$object(enum blocking_work_req_tag, void *, unsigned long int, void *);
// queue_blocking_response
// file ../include/ntp_worker.h line 114
extern signed int queue_blocking_response(struct blocking_child_tag *c, struct blocking_pipe_header_tag *resp, unsigned long int respsize, const struct blocking_pipe_header_tag *req);
// queue_req_pointer
// file work_thread.c line 188
static signed int queue_req_pointer(struct blocking_child_tag *c, struct blocking_pipe_header_tag *hdr);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// receive_blocking_req_internal
// file ../include/ntp_worker.h line 124
extern struct blocking_pipe_header_tag * receive_blocking_req_internal(struct blocking_child_tag *c);
// receive_blocking_resp_internal
// file ../include/ntp_worker.h line 126
extern struct blocking_pipe_header_tag * receive_blocking_resp_internal(struct blocking_child_tag *c);
// refid_str
// file numtoa.c line 38
extern const char * refid_str(unsigned int refid, signed int stratum);
// refnumtoa
// file refnumtoa.c line 12
extern const char * refnumtoa(union anonymous$47 *num);
// register_table
// file ./../lib/isc/result.c line 116
static unsigned int register_table(unsigned int base, unsigned int nresults, const char **txt, struct isc_msgcat *msgcat, signed int set);
// reload_resolv_conf
// file ntp_intres.c line 880
static void reload_resolv_conf(struct dnsworker_ctx_tag *worker_ctx);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// req_child_exit
// file ../include/ntp_worker.h line 133
extern signed int req_child_exit(struct blocking_child_tag *c);
// res_access_flags
// file statestr.c line 411
extern const char * res_access_flags(unsigned short int af);
// res_match_flags
// file statestr.c line 401
extern const char * res_match_flags(unsigned short int mf);
// reserve_dnschild_ctx
// file ntp_intres.c line 909
static unsigned int reserve_dnschild_ctx(void);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rewinddir
// file /usr/include/dirent.h line 208
extern void rewinddir(struct __dirstream *);
// roll_log
// file ./../lib/isc/log.c line 1215
static unsigned int roll_log(struct isc_logchannel *channel);
// run
// file ./../lib/isc/task.c line 1277
static void * run(void *uap);
// scheduled_sleep
// file ntp_intres.c line 997
static void scheduled_sleep(signed long int scheduled, signed long int earliest, struct dnsworker_ctx_tag *worker_ctx);
// sem_destroy
// file /usr/include/semaphore.h line 39
extern signed int sem_destroy(union anonymous$65 *);
// sem_init
// file /usr/include/semaphore.h line 36
extern signed int sem_init(union anonymous$65 *, signed int, unsigned int);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous$65 *);
// sem_timedwait
// file /usr/include/semaphore.h line 61
extern signed int sem_timedwait(union anonymous$65 *, struct timespec *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous$65 *);
// send_blocking_req_internal
// file ../include/ntp_worker.h line 118
extern signed int send_blocking_req_internal(struct blocking_child_tag *c, struct blocking_pipe_header_tag *hdr, void *data);
// send_blocking_resp_internal
// file ../include/ntp_worker.h line 121
extern signed int send_blocking_resp_internal(struct blocking_child_tag *c, struct blocking_pipe_header_tag *resp);
// set_ctrl_c_hook
// file syssignal.c line 133
extern void set_ctrl_c_hook(void (*c_hook)(void));
// set_ctrl_c_hook::1::handler$object
//
void handler$object(signed int);
// set_ctrl_c_hook::c_hook$object
//
void c_hook$object(void);
// set_sys_fuzz
// file systime.c line 104
extern void set_sys_fuzz(double fuzz_val);
// set_tod_using$object
//
void set_tod_using$object(const char *);
// setlogmask
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 184
extern signed int setlogmask(signed int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// settimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 77
extern signed int settimeofday(struct timeval *, struct timezone *);
// setup_logfile
// file msyslog.c line 568
extern void setup_logfile(const char *name);
// should_retry_dns
// file ntp_intres.c line 1068
static signed int should_retry_dns(signed int rescode, signed int res_errno);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$25 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$25 *);
// sigint_handler
// file syssignal.c line 123
void sigint_handler(signed int signum);
// siglongjmp
// file /usr/include/setjmp.h line 102
extern void siglongjmp(struct __jmp_buf_tag *, signed int);
// signal_no_reset
// file syssignal.c line 29
extern void signal_no_reset(signed int sig, void (*func)(signed int));
// signal_no_reset::func$object
//
void func$object(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_hash
// file socktoa.c line 107
extern unsigned short int sock_hash(const union anonymous$47 *addr);
// sockaddr_masktoprefixlen
// file socktoa.c line 150
extern signed int sockaddr_masktoprefixlen(const union anonymous$47 *psa);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sockporttoa
// file socktoa.c line 81
extern const char * sockporttoa(const union anonymous$47 *sock);
// socktoa
// file ../include/ntp_stdlib.h line 158
extern const char * socktoa(const union anonymous$47 *sock);
// socktohost
// file socktohost.c line 25
extern const char * socktohost(const union anonymous$47 *sock);
// sprintb
// file ntptime.c line 408
const char * sprintb(unsigned int v, const char *bits);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// ssl_check_version
// file ssl_init.c line 52
extern void ssl_check_version(void);
// ssl_init
// file ../include/ntp_stdlib.h line 217
extern void ssl_init(void);
// start_blocking_thread
// file work_thread.c line 362
static void start_blocking_thread(struct blocking_child_tag *c);
// start_blocking_thread_internal
// file work_thread.c line 375
static void start_blocking_thread_internal(struct blocking_child_tag *c);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// statustoa
// file statestr.c line 435
extern char * statustoa(signed int type, signed int st);
// step_callback$object
//
void step_callback$object(void);
// step_systime
// file systime.c line 349
extern signed int step_systime(double step);
// stime
// file /usr/include/time.h line 304
extern signed int stime(const signed long int *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 437
extern char * strerror_r(signed int, char *, unsigned long int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlcat
// file strl_obsd.c line 97
extern unsigned long int strlcat(char *dst, const char *src, unsigned long int siz);
// strlcpy
// file ../include/ntp_stdlib.h line 239
extern unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtouv64
// file vint64ops.c line 42
extern union anonymous$44 strtouv64(const char *begp, char **endp, signed int base);
// sub_tspec
// file ../include/timespecops.h line 155
static inline struct timespec sub_tspec(struct timespec a, struct timespec b);
// sub_tval
// file ../include/timevalops.h line 211
static inline struct timeval sub_tval(struct timeval a, struct timeval b);
// subv64
// file vint64ops.c line 194
extern union anonymous$44 subv64(const union anonymous$44 *lhs, const union anonymous$44 *rhs);
// subv64i32
// file vint64ops.c line 232
extern union anonymous$44 subv64i32(const union anonymous$44 *lhs, signed int rhs);
// subv64u32
// file vint64ops.c line 270
extern union anonymous$44 subv64u32(const union anonymous$44 *lhs, unsigned int rhs);
// symtbl_compare
// file ./../lib/isc/backtrace.c line 229
static signed int symtbl_compare(const void *addr, const void *entryarg);
// sync_channellist
// file ./../lib/isc/log.c line 1107
static unsigned int sync_channellist(struct isc_logconfig *lcfg);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// systime_func$object
//
signed long int systime_func$object(signed long int *);
// task_detach
// file ./../lib/isc/task.c line 476
static inline enum anonymous$11 task_detach(struct isc__task *task);
// task_finished
// file ./../lib/isc/task.c line 297
static void task_finished(struct isc__task *task);
// task_ready
// file ./../lib/isc/task.c line 455
static inline void task_ready(struct isc__task *task);
// task_send
// file ./../lib/isc/task.c line 530
static inline enum anonymous$11 task_send(struct isc__task *task, struct isc_event **eventp);
// task_shutdown
// file ./../lib/isc/task.c line 412
static inline enum anonymous$11 task_shutdown(struct isc__task *task);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// time_to_vint64
// file ntp_calendar.c line 240
extern union anonymous$44 time_to_vint64(const signed long int *ptt);
// timex_state
// file ntptime.c line 465
const char * timex_state(signed int s);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// total_recvbuffs
// file recvbuff.c line 61
extern unsigned long int total_recvbuffs(void);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// transform
// file ./../lib/isc/md5.c line 122
static void transform(unsigned int *buf, const unsigned int *in);
// transform$link1
// file ./../lib/isc/sha1.c line 203
static void transform$link1(unsigned int *state, const unsigned char *buffer);
// truncate
// file /usr/include/unistd.h line 993
extern signed int truncate(const char *, signed long int);
// try_ipv6only
// file ./../lib/isc/unix/net.c line 245
static void try_ipv6only(void);
// try_ipv6pktinfo
// file ./../lib/isc/unix/net.c line 322
static void try_ipv6pktinfo(void);
// try_proto
// file ./../lib/isc/unix/net.c line 124
static unsigned int try_proto(signed int domain);
// tspec_intv_to_lfp
// file ../include/timespecops.h line 297
static inline struct anonymous$20 tspec_intv_to_lfp(struct timespec x);
// tspec_stamp_to_lfp
// file ../include/timespecops.h line 313
static inline struct anonymous$20 tspec_stamp_to_lfp(struct timespec x);
// tspectoa
// file ../include/timespecops.h line 284
static inline const char * tspectoa(struct timespec x);
// tval_intv_to_lfp
// file ../include/timevalops.h line 349
static inline struct anonymous$20 tval_intv_to_lfp(struct timeval x);
// tval_stamp_to_lfp
// file ../include/timevalops.h line 365
static inline struct anonymous$20 tval_stamp_to_lfp(struct timeval x);
// ucmpv64
// file vint64ops.c line 152
extern signed int ucmpv64(const union anonymous$44 *lhs, const union anonymous$44 *rhs);
// uglydate
// file uglydate.c line 15
extern char * uglydate(struct anonymous$20 *ts);
// uint32_2cpl_to_int32
// file ntp_calendar.c line 186
static inline signed int uint32_2cpl_to_int32(const unsigned int vu);
// uint32_saturate
// file ntp_calendar.c line 222
static inline unsigned int uint32_saturate(unsigned int vu, unsigned int mu);
// unexpected_callback$object
//
void unexpected_callback$object(const char *, signed int, const char *, void **);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// utimes
// file /usr/include/x86_64-linux-gnu/sys/time.h line 138
extern signed int utimes(const char *, struct timeval *);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vint64_to_time
// file ntp_calendar.c line 286
extern signed long int vint64_to_time(const union anonymous$44 *tv);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait_for_sem
// file work_thread.c line 597
static signed int wait_for_sem(union anonymous$65 *sem, struct timespec *timeout);
// worker_idle_timer_fired
// file ntp_worker.c line 321
extern void worker_idle_timer_fired(void);
// worker_sleep
// file ../include/ntp_worker.h line 130
extern signed int worker_sleep(struct blocking_child_tag *c, signed long int seconds);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// year_to_ntp
// file clocktime.c line 143
static unsigned int year_to_ntp(signed int year);
// ymd2yd
// file ymd2yd.c line 12
extern signed int ymd2yd(signed int y, signed int m, signed int d);

struct anonymous$58
{
  // head
  struct isc__task *head;
  // tail
  struct isc__task *tail;
};

struct anonymous$57
{
  // prev
  struct isc__task *prev;
  // next
  struct isc__task *next;
};

struct anonymous$16
{
  // prev
  struct isc_buffer *prev;
  // next
  struct isc_buffer *next;
};

struct anonymous$52
{
  // head
  struct isc_event *head;
  // tail
  struct isc_event *tail;
};

struct anonymous$8
{
  // prev
  struct isc_event *prev;
  // next
  struct isc_event *next;
};

struct anonymous$22
{
  // head
  struct isc_logchannel *head;
  // tail
  struct isc_logchannel *tail;
};

struct anonymous$26
{
  // prev
  struct isc_logchannel *prev;
  // next
  struct isc_logchannel *next;
};

struct anonymous$23
{
  // head
  struct isc_logchannellist *head;
  // tail
  struct isc_logchannellist *tail;
};

struct anonymous$28
{
  // prev
  struct isc_logchannellist *prev;
  // next
  struct isc_logchannellist *next;
};

struct anonymous$12
{
  // head
  struct isc_logmessage *head;
  // tail
  struct isc_logmessage *tail;
};

struct anonymous$29
{
  // prev
  struct isc_logmessage *prev;
  // next
  struct isc_logmessage *next;
};

struct anonymous$10
{
  // prev
  struct isc_sockaddr *prev;
  // next
  struct isc_sockaddr *next;
};

struct anonymous$7
{
  // phead
  struct recvbuf *phead;
  // pptail
  struct recvbuf **pptail;
};

struct anonymous$53
{
  // head
  struct resulttable *head;
  // tail
  struct resulttable *tail;
};

struct anonymous$54
{
  // prev
  struct resulttable *prev;
  // next
  struct resulttable *next;
};

struct anonymous$55
{
  // b
  struct savekey *b;
  // f
  struct savekey *f;
};

struct anonymous$37
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$35
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$25
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$45
{
  // buf
  unsigned int buf[4l];
  // bytes
  unsigned int bytes[2l];
  // in
  unsigned int in[16l];
};

struct anonymous$62
{
  // state
  unsigned int state[5l];
  // count
  unsigned int count[2l];
  // buffer
  unsigned char buffer[64l];
};

struct anonymous$3
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$61
{
  // hi
  signed int hi;
  // lo
  signed int lo;
};

struct anonymous$31
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$34
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$33
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$32
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$36
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$38
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$31 _kill;
  // _timer
  struct anonymous$32 _timer;
  // _rt
  struct anonymous$33 _rt;
  // _sigchld
  struct anonymous$34 _sigchld;
  // _sigfault
  struct anonymous$35 _sigfault;
  // _sigpoll
  struct anonymous$36 _sigpoll;
  // _sigsys
  struct anonymous$37 _sigsys;
};

struct anonymous$27
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$38 _sifields;
};

struct anonymous$39
{
  // tv_sec
  signed int tv_sec;
  // tv_usec
  signed int tv_usec;
};

struct anonymous$13
{
  // quot
  signed long int quot;
  // rem
  signed long int rem;
};

union anonymous$19
{
  // Xl_ui
  unsigned int Xl_ui;
  // Xl_i
  signed int Xl_i;
};

struct anonymous$20
{
  // Ul_i
  union anonymous$19 Ul_i;
  // l_uf
  unsigned int l_uf;
};

struct anonymous$40
{
  // ll
  unsigned short int ll;
  // lh
  unsigned short int lh;
  // hl
  unsigned short int hl;
  // hh
  signed short int hh;
};

struct anonymous$41
{
  // ll
  unsigned short int ll;
  // lh
  unsigned short int lh;
  // hl
  unsigned short int hl;
  // hh
  unsigned short int hh;
};

struct anonymous$42
{
  // lo
  unsigned int lo;
  // hi
  signed int hi;
};

struct anonymous$43
{
  // lo
  unsigned int lo;
  // hi
  unsigned int hi;
};

struct anonymous$21
{
  // magic
  unsigned int magic;
};

struct anonymous$0
{
  // more_help
  const unsigned short int more_help;
  // save_opts
  const unsigned short int save_opts;
  // number_option
  const unsigned short int number_option;
  // default_opt
  const unsigned short int default_opt;
};

union anonymous$6
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous$18
{
  // ifu_broadaddr
  struct sockaddr *ifu_broadaddr;
  // ifu_dstaddr
  struct sockaddr *ifu_dstaddr;
};

union anonymous$24
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$27 *, void *);
};

union anonymous
{
  // argString
  const char *argString;
  // argEnum
  unsigned long int argEnum;
  // argIntptr
  unsigned long int argIntptr;
  // argInt
  signed long int argInt;
  // argUint
  unsigned long int argUint;
  // argBool
  unsigned int argBool;
  // argFp
  struct _IO_FILE *argFp;
  // argFd
  signed int argFd;
};

union anonymous$49
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$65
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous$60
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$63
{
  // c
  unsigned char c[64l];
  // l
  unsigned int l[16l];
};

union anonymous$1
{
  // __data
  struct anonymous$3 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous$44
{
  // w_s
  struct anonymous$40 w_s;
  // W_s
  struct anonymous$41 W_s;
  // d_s
  struct anonymous$42 d_s;
  // D_s
  struct anonymous$43 D_s;
  // q_s
  signed long int q_s;
  // Q_s
  unsigned long int Q_s;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct in6_addr
{
  // __in6_u
  union anonymous$49 __in6_u;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

union anonymous$47
{
  // sa
  struct sockaddr sa;
  // sa4
  struct sockaddr_in sa4;
  // sa6
  struct sockaddr_in6 sa6;
};

union anonymous$4
{
  // X_recv_srcadr
  union anonymous$47 X_recv_srcadr;
  // X_recv_srcclock
  char *X_recv_srcclock;
  // X_recv_peer
  struct peer *X_recv_peer;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$51
{
  // in
  struct in_addr in;
  // in6
  struct in6_addr in6;
};

struct pkt
{
  // li_vn_mode
  unsigned char li_vn_mode;
  // stratum
  unsigned char stratum;
  // ppoll
  unsigned char ppoll;
  // precision
  signed char precision;
  // rootdelay
  unsigned int rootdelay;
  // rootdisp
  unsigned int rootdisp;
  // refid
  unsigned int refid;
  // reftime
  struct anonymous$20 reftime;
  // org
  struct anonymous$20 org;
  // rec
  struct anonymous$20 rec;
  // xmt
  struct anonymous$20 xmt;
  // exten
  unsigned int exten[518l];
};

union anonymous$5
{
  // X_recv_pkt
  struct pkt X_recv_pkt;
  // X_recv_buffer
  unsigned char X_recv_buffer[1000l];
};

union anonymous$50
{
  // sa
  struct sockaddr sa;
  // sin
  struct sockaddr_in sin;
  // sin6
  struct sockaddr_in6 sin6;
};

union anonymous$48
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$64
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct HistEvent
{
  // num
  signed int num;
  // str
  const char *str;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __exit_status
{
  // e_termination
  signed short int e_termination;
  // e_exit
  signed short int e_exit;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$25 __saved_mask;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct blocking_child_tag
{
  // reusable
  signed int reusable;
  // thread_ref
  unsigned long int *thread_ref;
  // thread_id
  unsigned int thread_id;
  // workitems
  struct blocking_pipe_header_tag * volatile * volatile workitems;
  // workitems_alloc
  volatile unsigned long int workitems_alloc;
  // next_workitem
  unsigned long int next_workitem;
  // next_workeritem
  unsigned long int next_workeritem;
  // responses
  struct blocking_pipe_header_tag * volatile * volatile responses;
  // responses_alloc
  volatile unsigned long int responses_alloc;
  // next_response
  unsigned long int next_response;
  // next_workresp
  unsigned long int next_workresp;
  // blocking_req_ready
  union anonymous$65 *blocking_req_ready;
  // wake_scheduled_sleep
  union anonymous$65 *wake_scheduled_sleep;
  // resp_read_pipe
  signed int resp_read_pipe;
  // resp_write_pipe
  signed int resp_write_pipe;
  // ispipe
  signed int ispipe;
  // resp_read_ctx
  void *resp_read_ctx;
};

struct blocking_gai_req_tag
{
  // octets
  unsigned long int octets;
  // dns_idx
  unsigned int dns_idx;
  // scheduled
  signed long int scheduled;
  // earliest
  signed long int earliest;
  // hints
  struct addrinfo hints;
  // retry
  signed int retry;
  // callback
  void (*callback)(signed int, signed int, void *, const char *, const char *, struct addrinfo *, struct addrinfo *);
  // context
  void *context;
  // nodesize
  unsigned long int nodesize;
  // servsize
  unsigned long int servsize;
};

struct blocking_gai_resp_tag
{
  // octets
  unsigned long int octets;
  // retcode
  signed int retcode;
  // retry
  signed int retry;
  // gai_errno
  signed int gai_errno;
  // ai_count
  signed int ai_count;
};

struct blocking_gni_req_tag
{
  // octets
  unsigned long int octets;
  // dns_idx
  unsigned int dns_idx;
  // scheduled
  signed long int scheduled;
  // earliest
  signed long int earliest;
  // retry
  signed int retry;
  // hostoctets
  unsigned long int hostoctets;
  // servoctets
  unsigned long int servoctets;
  // flags
  signed int flags;
  // callback
  void (*callback)(signed int, signed int, union anonymous$47 *, signed int, const char *, const char *, void *);
  // context
  void *context;
  // socku
  union anonymous$47 socku;
};

struct blocking_gni_resp_tag
{
  // octets
  unsigned long int octets;
  // retcode
  signed int retcode;
  // gni_errno
  signed int gni_errno;
  // retry
  signed int retry;
  // hostoctets
  unsigned long int hostoctets;
  // servoctets
  unsigned long int servoctets;
};

struct blocking_pipe_header_tag
{
  // octets
  unsigned long int octets;
  // magic_sig
  enum blocking_magic_sig_e magic_sig;
  // rtype
  enum blocking_work_req_tag rtype;
  // child_idx
  unsigned int child_idx;
  // done_func
  void (*done_func)(enum blocking_work_req_tag, void *, unsigned long int, void *);
  // context
  void *context;
};

struct calendar
{
  // year
  unsigned short int year;
  // yearday
  unsigned short int yearday;
  // month
  unsigned char month;
  // monthday
  unsigned char monthday;
  // hour
  unsigned char hour;
  // minute
  unsigned char minute;
  // second
  unsigned char second;
  // weekday
  unsigned char weekday;
};

struct value
{
  // tstamp
  unsigned int tstamp;
  // fstamp
  unsigned int fstamp;
  // vallen
  unsigned int vallen;
  // ptr
  void *ptr;
  // siglen
  unsigned int siglen;
  // sig
  unsigned char *sig;
};

struct cert_info
{
  // link
  struct cert_info *link;
  // flags
  unsigned int flags;
  // pkey
  struct evp_pkey_st *pkey;
  // version
  signed long int version;
  // nid
  signed int nid;
  // digest
  const struct env_md_st *digest;
  // serial
  unsigned long int serial;
  // first
  struct calendar first;
  // last
  struct calendar last;
  // subject
  char *subject;
  // issuer
  char *issuer;
  // grpkey
  struct bignum_st *grpkey;
  // cert
  struct value cert;
};

struct clktype
{
  // code
  signed int code;
  // clocktype
  const char *clocktype;
  // abbrev
  const char *abbrev;
};

struct codestring
{
  // code
  signed int code;
  // string
  const char * const string;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct dnschild_ctx_tag
{
  // index
  unsigned int index;
  // next_dns_timeslot
  signed long int next_dns_timeslot;
};

struct dnsworker_ctx_tag
{
  // c
  struct blocking_child_tag *c;
  // ignore_scheduled_before
  signed long int ignore_scheduled_before;
  // next_res_init
  signed long int next_res_init;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous$6 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct exit_status
{
  // e_termination
  signed short int e_termination;
  // e_exit
  signed short int e_exit;
};

struct exten
{
  // opcode
  unsigned int opcode;
  // associd
  unsigned int associd;
  // tstamp
  unsigned int tstamp;
  // fstamp
  unsigned int fstamp;
  // vallen
  unsigned int vallen;
  // pkt
  unsigned int pkt[1l];
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct ifaddrs
{
  // ifa_next
  struct ifaddrs *ifa_next;
  // ifa_name
  char *ifa_name;
  // ifa_flags
  unsigned int ifa_flags;
  // ifa_addr
  struct sockaddr *ifa_addr;
  // ifa_netmask
  struct sockaddr *ifa_netmask;
  // ifa_ifu
  union anonymous$18 ifa_ifu;
  // ifa_data
  void *ifa_data;
};

struct interface
{
  // elink
  struct interface *elink;
  // mclink
  struct interface *mclink;
  // fd
  signed int fd;
  // bfd
  signed int bfd;
  // ifnum
  unsigned int ifnum;
  // sin
  union anonymous$47 sin;
  // mask
  union anonymous$47 mask;
  // bcast
  union anonymous$47 bcast;
  // name
  char name[32l];
  // family
  unsigned short int family;
  // phase
  unsigned short int phase;
  // flags
  unsigned int flags;
  // last_ttl
  signed int last_ttl;
  // addr_refid
  unsigned int addr_refid;
  // num_mcast
  signed int num_mcast;
  // starttime
  unsigned long int starttime;
  // received
  volatile signed long int received;
  // sent
  signed long int sent;
  // notsent
  signed long int notsent;
  // ifindex
  unsigned int ifindex;
  // ignore_packets
  enum anonymous$11 ignore_packets;
  // peers
  struct peer *peers;
  // peercnt
  unsigned int peercnt;
};

struct isc_task
{
  // impmagic
  unsigned int impmagic;
  // magic
  unsigned int magic;
  // methods
  struct isc_taskmethods *methods;
};

struct isc__task
{
  // common
  struct isc_task common;
  // manager
  struct isc__taskmgr *manager;
  // lock
  union anonymous$2 lock;
  // state
  enum anonymous$56 state;
  // references
  unsigned int references;
  // events
  struct anonymous$52 events;
  // on_shutdown
  struct anonymous$52 on_shutdown;
  // quantum
  unsigned int quantum;
  // flags
  unsigned int flags;
  // now
  unsigned int now;
  // name
  char name[16l];
  // tag
  void *tag;
  // link
  struct anonymous$57 link;
  // ready_link
  struct anonymous$57 ready_link;
  // ready_priority_link
  struct anonymous$57 ready_priority_link;
};

struct isc_taskmethods
{
  // attach
  void (*attach)(struct isc_task *, struct isc_task **);
  // detach
  void (*detach)(struct isc_task **);
  // destroy
  void (*destroy)(struct isc_task **);
  // send
  void (*send)(struct isc_task *, struct isc_event **);
  // sendanddetach
  void (*sendanddetach)(struct isc_task **, struct isc_event **);
  // unsend
  unsigned int (*unsend)(struct isc_task *, void *, unsigned int, void *, struct anonymous$52 *);
  // onshutdown
  unsigned int (*onshutdown)(struct isc_task *, void (*)(struct isc_task *, struct isc_event *), const void *);
  // shutdown
  void (*shutdown)(struct isc_task *);
  // setname
  void (*setname)(struct isc_task *, const char *, void *);
  // purgeevents
  unsigned int (*purgeevents)(struct isc_task *, void *, unsigned int, void *);
  // purgerange
  unsigned int (*purgerange)(struct isc_task *, void *, unsigned int, unsigned int, void *);
  // beginexclusive
  unsigned int (*beginexclusive)(struct isc_task *);
  // endexclusive
  void (*endexclusive)(struct isc_task *);
  // setprivilege
  void (*setprivilege)(struct isc_task *, enum anonymous$11);
  // privilege
  enum anonymous$11 (*privilege)(struct isc_task *);
};

struct isc__taskmethods
{
  // methods
  struct isc_taskmethods methods;
};

struct isc_taskmgr
{
  // impmagic
  unsigned int impmagic;
  // magic
  unsigned int magic;
  // methods
  struct isc_taskmgrmethods *methods;
};

struct isc__taskmgr
{
  // common
  struct isc_taskmgr common;
  // mctx
  struct isc_mem *mctx;
  // lock
  union anonymous$2 lock;
  // workers
  unsigned int workers;
  // threads
  unsigned long int *threads;
  // default_quantum
  unsigned int default_quantum;
  // tasks
  struct anonymous$58 tasks;
  // ready_tasks
  struct anonymous$58 ready_tasks;
  // ready_priority_tasks
  struct anonymous$58 ready_priority_tasks;
  // mode
  enum anonymous$59 mode;
  // work_available
  union anonymous$1 work_available;
  // exclusive_granted
  union anonymous$1 exclusive_granted;
  // paused
  union anonymous$1 paused;
  // tasks_running
  unsigned int tasks_running;
  // pause_requested
  enum anonymous$11 pause_requested;
  // exclusive_requested
  enum anonymous$11 exclusive_requested;
  // exiting
  enum anonymous$11 exiting;
};

struct isc_backtrace_symmap
{
  // addr
  void *addr;
  // symbol
  const char *symbol;
};

struct isc_buffer
{
  // magic
  unsigned int magic;
  // base
  void *base;
  // length
  unsigned int length;
  // used
  unsigned int used;
  // current
  unsigned int current;
  // active
  unsigned int active;
  // link
  struct anonymous$16 link;
  // mctx
  struct isc_mem *mctx;
};

struct isc_direntry
{
  // name
  char name[256l];
  // length
  unsigned int length;
};

struct isc_dir
{
  // magic
  unsigned int magic;
  // dirname
  char dirname[1024l];
  // entry
  struct isc_direntry entry;
  // handle
  struct __dirstream *handle;
};

struct isc_event
{
  // ev_size
  unsigned long int ev_size;
  // ev_attributes
  unsigned int ev_attributes;
  // ev_tag
  void *ev_tag;
  // ev_type
  unsigned int ev_type;
  // ev_action
  void (*ev_action)(struct isc_task *, struct isc_event *);
  // ev_arg
  void *ev_arg;
  // ev_sender
  void *ev_sender;
  // ev_destroy
  void (*ev_destroy)(struct isc_event *);
  // ev_destroy_arg
  void *ev_destroy_arg;
  // ev_link
  struct anonymous$8 ev_link;
};

struct isc_netaddr
{
  // family
  unsigned int family;
  // type
  union anonymous$51 type;
  // zone
  unsigned int zone;
};

struct isc_interface
{
  // name
  char name[32l];
  // af
  unsigned int af;
  // address
  struct isc_netaddr address;
  // netmask
  struct isc_netaddr netmask;
  // broadcast
  struct isc_netaddr broadcast;
  // dstaddress
  struct isc_netaddr dstaddress;
  // flags
  unsigned int flags;
  // ifindex
  unsigned int ifindex;
};

struct isc_interfaceiter
{
  // magic
  unsigned int magic;
  // mctx
  struct isc_mem *mctx;
  // buf
  void *buf;
  // bufsize
  unsigned int bufsize;
  // ifaddrs
  struct ifaddrs *ifaddrs;
  // pos
  struct ifaddrs *pos;
  // current
  struct isc_interface current;
  // result
  unsigned int result;
  // proc
  struct _IO_FILE *proc;
  // entry
  char entry[(signed long int)sizeof(char [63l]) /*63l*/ ];
  // valid
  unsigned int valid;
};

struct isc_interval
{
  // seconds
  unsigned int seconds;
  // nanoseconds
  unsigned int nanoseconds;
};

struct isc_log
{
  // magic
  unsigned int magic;
  // mctx
  struct isc_mem *mctx;
  // categories
  struct isc_logcategory *categories;
  // category_count
  unsigned int category_count;
  // modules
  struct isc_logmodule *modules;
  // module_count
  unsigned int module_count;
  // debug_level
  signed int debug_level;
  // lock
  union anonymous$2 lock;
  // logconfig
  struct isc_logconfig *logconfig;
  // buffer
  char buffer[8192l];
  // messages
  struct anonymous$12 messages;
};

struct isc_logcategory
{
  // name
  const char *name;
  // id
  unsigned int id;
};

struct isc_logfile
{
  // stream
  struct _IO_FILE *stream;
  // name
  const char *name;
  // versions
  signed int versions;
  // maximum_size
  signed long int maximum_size;
  // maximum_reached
  enum anonymous$11 maximum_reached;
};

union isc_logdestination
{
  // file
  struct isc_logfile file;
  // facility
  signed int facility;
};

struct isc_logchannel
{
  // name
  char *name;
  // type
  unsigned int type;
  // level
  signed int level;
  // flags
  unsigned int flags;
  // destination
  union isc_logdestination destination;
  // link
  struct anonymous$26 link;
};

struct isc_logchannellist
{
  // module
  const struct isc_logmodule *module;
  // channel
  struct isc_logchannel *channel;
  // link
  struct anonymous$28 link;
};

struct isc_logconfig
{
  // magic
  unsigned int magic;
  // lctx
  struct isc_log *lctx;
  // channels
  struct anonymous$22 channels;
  // channellists
  struct anonymous$23 *channellists;
  // channellist_count
  unsigned int channellist_count;
  // duplicate_interval
  unsigned int duplicate_interval;
  // highest_level
  signed int highest_level;
  // tag
  char *tag;
  // dynamic
  enum anonymous$11 dynamic;
};

struct isc_time
{
  // seconds
  unsigned int seconds;
  // nanoseconds
  unsigned int nanoseconds;
};

struct isc_logmessage
{
  // text
  char *text;
  // time
  struct isc_time time;
  // link
  struct anonymous$29 link;
};

struct isc_logmodule
{
  // name
  const char *name;
  // id
  unsigned int id;
};

struct isc_msgcat
{
  // magic
  unsigned int magic;
};

struct isc_ondestroy
{
  // magic
  unsigned int magic;
  // events
  struct anonymous$52 events;
};

struct isc_region
{
  // base
  unsigned char *base;
  // length
  unsigned int length;
};

struct isc_sockaddr
{
  // type
  union anonymous$50 type;
  // length
  unsigned int length;
  // link
  struct anonymous$10 link;
};

struct isc_taskmgrmethods
{
  // destroy
  void (*destroy)(struct isc_taskmgr **);
  // setmode
  void (*setmode)(struct isc_taskmgr *, enum anonymous$59);
  // mode
  enum anonymous$59 (*mode)(struct isc_taskmgr *);
  // taskcreate
  unsigned int (*taskcreate)(struct isc_taskmgr *, unsigned int, struct isc_task **);
};

struct isodate
{
  // year
  unsigned short int year;
  // week
  unsigned char week;
  // weekday
  unsigned char weekday;
  // hour
  unsigned char hour;
  // minute
  unsigned char minute;
  // second
  unsigned char second;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct ntptimeval
{
  // time
  struct timeval time;
  // maxerror
  signed long int maxerror;
  // esterror
  signed long int esterror;
  // tai
  signed long int tai;
  // __glibc_reserved1
  signed long int __glibc_reserved1;
  // __glibc_reserved2
  signed long int __glibc_reserved2;
  // __glibc_reserved3
  signed long int __glibc_reserved3;
  // __glibc_reserved4
  signed long int __glibc_reserved4;
};

struct opt_desc
{
  // optIndex
  const unsigned short int optIndex;
  // optValue
  const unsigned short int optValue;
  // optActualIndex
  unsigned short int optActualIndex;
  // optActualValue
  unsigned short int optActualValue;
  // optEquivIndex
  const unsigned short int optEquivIndex;
  // optMinCt
  const unsigned short int optMinCt;
  // optMaxCt
  const unsigned short int optMaxCt;
  // optOccCt
  unsigned short int optOccCt;
  // fOptState
  unsigned int fOptState;
  // optUsage
  unsigned int optUsage;
  // optArg
  union anonymous optArg;
  // optCookie
  void *optCookie;
  // pOptMust
  const signed int * const pOptMust;
  // pOptCant
  const signed int * const pOptCant;
  // pOptProc
  void (* const pOptProc)(struct options *, struct opt_desc *);
  // pzText
  const char * const pzText;
  // pz_NAME
  const char * const pz_NAME;
  // pz_Name
  const char * const pz_Name;
  // pz_DisableName
  const char * const pz_DisableName;
  // pz_DisablePfx
  const char * const pz_DisablePfx;
};

struct options
{
  // structVersion
  const signed int structVersion;
  // origArgCt
  unsigned int origArgCt;
  // origArgVect
  char **origArgVect;
  // fOptSet
  unsigned int fOptSet;
  // curOptIdx
  unsigned int curOptIdx;
  // pzCurOpt
  char *pzCurOpt;
  // pzProgPath
  const char * const pzProgPath;
  // pzProgName
  const char * const pzProgName;
  // pzPROGNAME
  const char * const pzPROGNAME;
  // pzRcName
  const char * const pzRcName;
  // pzCopyright
  const char * const pzCopyright;
  // pzCopyNotice
  const char * const pzCopyNotice;
  // pzFullVersion
  const char * const pzFullVersion;
  // papzHomeList
  const char * const * const papzHomeList;
  // pzUsageTitle
  const char * const pzUsageTitle;
  // pzExplain
  const char * const pzExplain;
  // pzDetail
  const char * const pzDetail;
  // pOptDesc
  struct opt_desc * const pOptDesc;
  // pzBugAddr
  const char * const pzBugAddr;
  // pExtensions
  void *pExtensions;
  // pSavedState
  void *pSavedState;
  // pUsageProc
  void (*pUsageProc)(struct options *, signed int);
  // pTransProc
  void (*pTransProc)(void);
  // specOptIdx
  struct anonymous$0 specOptIdx;
  // optCt
  const signed int optCt;
  // presetOptCt
  const signed int presetOptCt;
  // pzFullUsage
  const char *pzFullUsage;
  // pzShortUsage
  const char *pzShortUsage;
  // originalOptArgArray
  const union anonymous * const originalOptArgArray;
  // originalOptArgCookie
  void * const * const originalOptArgCookie;
  // pzPkgDataDir
  const char * const pzPkgDataDir;
  // pzPackager
  const char * const pzPackager;
};

struct peer
{
  // p_link
  struct peer *p_link;
  // adr_link
  struct peer *adr_link;
  // aid_link
  struct peer *aid_link;
  // ilink
  struct peer *ilink;
  // srcadr
  union anonymous$47 srcadr;
  // hostname
  char *hostname;
  // addrs
  struct addrinfo *addrs;
  // ai
  struct addrinfo *ai;
  // dstadr
  struct interface *dstadr;
  // associd
  unsigned short int associd;
  // version
  unsigned char version;
  // hmode
  unsigned char hmode;
  // hpoll
  unsigned char hpoll;
  // minpoll
  unsigned char minpoll;
  // maxpoll
  unsigned char maxpoll;
  // flags
  unsigned int flags;
  // cast_flags
  unsigned char cast_flags;
  // last_event
  unsigned char last_event;
  // num_events
  unsigned char num_events;
  // ttl
  unsigned int ttl;
  // ident
  char *ident;
  // procptr
  struct refclockproc *procptr;
  // refclktype
  unsigned char refclktype;
  // refclkunit
  unsigned char refclkunit;
  // sstclktype
  unsigned char sstclktype;
  // leap
  unsigned char leap;
  // pmode
  unsigned char pmode;
  // stratum
  unsigned char stratum;
  // ppoll
  unsigned char ppoll;
  // precision
  signed char precision;
  // rootdelay
  double rootdelay;
  // rootdisp
  double rootdisp;
  // refid
  unsigned int refid;
  // reftime
  struct anonymous$20 reftime;
  // keyid
  unsigned int keyid;
  // opcode
  unsigned int opcode;
  // assoc
  unsigned short int assoc;
  // crypto
  unsigned int crypto;
  // pkey
  struct evp_pkey_st *pkey;
  // digest
  const struct env_md_st *digest;
  // subject
  char *subject;
  // issuer
  char *issuer;
  // xinfo
  struct cert_info *xinfo;
  // pkeyid
  unsigned int pkeyid;
  // hcookie
  unsigned int hcookie;
  // pcookie
  unsigned int pcookie;
  // ident_pkey
  struct pkey_info *ident_pkey;
  // iffval
  struct bignum_st *iffval;
  // grpkey
  const struct bignum_st *grpkey;
  // cookval
  struct value cookval;
  // recval
  struct value recval;
  // cmmd
  struct exten *cmmd;
  // refresh
  unsigned long int refresh;
  // keylist
  unsigned int *keylist;
  // keynumber
  signed int keynumber;
  // encrypt
  struct value encrypt;
  // sndval
  struct value sndval;
  // status
  unsigned char status;
  // new_status
  unsigned char new_status;
  // reach
  unsigned char reach;
  // flash
  signed int flash;
  // epoch
  unsigned long int epoch;
  // burst
  signed int burst;
  // retry
  signed int retry;
  // flip
  signed int flip;
  // filter_nextpt
  signed int filter_nextpt;
  // filter_delay
  double filter_delay[8l];
  // filter_offset
  double filter_offset[8l];
  // filter_disp
  double filter_disp[8l];
  // filter_epoch
  unsigned long int filter_epoch[8l];
  // filter_order
  unsigned char filter_order[8l];
  // rec
  struct anonymous$20 rec;
  // xmt
  struct anonymous$20 xmt;
  // dst
  struct anonymous$20 dst;
  // aorg
  struct anonymous$20 aorg;
  // borg
  struct anonymous$20 borg;
  // offset
  double offset;
  // delay
  double delay;
  // jitter
  double jitter;
  // disp
  double disp;
  // xleave
  double xleave;
  // bias
  double bias;
  // t21
  double t21;
  // t21_bytes
  signed int t21_bytes;
  // t21_last
  signed int t21_last;
  // r21
  double r21;
  // t34
  double t34;
  // t34_bytes
  signed int t34_bytes;
  // r34
  double r34;
  // update
  unsigned long int update;
  // unreach
  signed int unreach;
  // throttle
  signed int throttle;
  // outdate
  unsigned long int outdate;
  // nextdate
  unsigned long int nextdate;
  // timereset
  unsigned long int timereset;
  // timereceived
  unsigned long int timereceived;
  // timereachable
  unsigned long int timereachable;
  // sent
  unsigned long int sent;
  // received
  unsigned long int received;
  // processed
  unsigned long int processed;
  // badauth
  unsigned long int badauth;
  // bogusorg
  unsigned long int bogusorg;
  // oldpkt
  unsigned long int oldpkt;
  // seldisptoolarge
  unsigned long int seldisptoolarge;
  // selbroken
  unsigned long int selbroken;
};

struct pkey_info
{
  // link
  struct pkey_info *link;
  // pkey
  struct evp_pkey_st *pkey;
  // name
  char *name;
  // fstamp
  unsigned int fstamp;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct recvbuf
{
  // link
  struct recvbuf *link;
  // X_from_where
  union anonymous$4 X_from_where;
  // srcadr
  union anonymous$47 srcadr;
  // dstadr
  struct interface *dstadr;
  // fd
  signed int fd;
  // msg_flags
  signed int msg_flags;
  // recv_time
  struct anonymous$20 recv_time;
  // receiver
  void (*receiver)(struct recvbuf *);
  // recv_length
  signed int recv_length;
  // recv_space
  union anonymous$5 recv_space;
  // used
  signed int used;
};

struct refclock
{
  // clock_start
  signed int (*clock_start)(signed int, struct peer *);
  // clock_shutdown
  void (*clock_shutdown)(signed int, struct peer *);
  // clock_poll
  void (*clock_poll)(signed int, struct peer *);
  // clock_control
  void (*clock_control)(signed int, struct refclockstat *, struct refclockstat *, struct peer *);
  // clock_init
  void (*clock_init)(void);
  // clock_buginfo
  void (*clock_buginfo)(signed int, struct refclockbug *, struct peer *);
  // clock_timer
  void (*clock_timer)(signed int, struct peer *);
};

struct refclockbug
{
  // nvalues
  unsigned char nvalues;
  // ntimes
  unsigned char ntimes;
  // svalues
  unsigned short int svalues;
  // stimes
  unsigned int stimes;
  // values
  unsigned int values[16l];
  // times
  struct anonymous$20 times[32l];
};

struct refclockio
{
  // next
  struct refclockio *next;
  // clock_recv
  void (*clock_recv)(struct recvbuf *);
  // io_input
  signed int (*io_input)(struct recvbuf *);
  // srcclock
  struct peer *srcclock;
  // datalen
  signed int datalen;
  // fd
  signed int fd;
  // recvcount
  unsigned long int recvcount;
  // active
  signed int active;
};

struct refclockproc
{
  // unitptr
  void *unitptr;
  // conf
  struct refclock *conf;
  // io
  struct refclockio io;
  // leap
  unsigned char leap;
  // currentstatus
  unsigned char currentstatus;
  // lastevent
  unsigned char lastevent;
  // type
  unsigned char type;
  // clockdesc
  const char *clockdesc;
  // nextaction
  unsigned long int nextaction;
  // action
  void (*action)(struct peer *);
  // a_lastcode
  char a_lastcode[128l];
  // lencode
  signed int lencode;
  // year
  signed int year;
  // day
  signed int day;
  // hour
  signed int hour;
  // minute
  signed int minute;
  // second
  signed int second;
  // nsec
  signed long int nsec;
  // yearstart
  unsigned long int yearstart;
  // coderecv
  signed int coderecv;
  // codeproc
  signed int codeproc;
  // lastref
  struct anonymous$20 lastref;
  // lastrec
  struct anonymous$20 lastrec;
  // offset
  double offset;
  // disp
  double disp;
  // jitter
  double jitter;
  // filter
  double filter[60l];
  // fudgetime1
  double fudgetime1;
  // fudgetime2
  double fudgetime2;
  // stratum
  unsigned char stratum;
  // refid
  unsigned int refid;
  // sloppyclockflag
  unsigned char sloppyclockflag;
  // timestarted
  unsigned long int timestarted;
  // polls
  unsigned long int polls;
  // noreply
  unsigned long int noreply;
  // badformat
  unsigned long int badformat;
  // baddata
  unsigned long int baddata;
};

struct refclockstat
{
  // type
  unsigned char type;
  // flags
  unsigned char flags;
  // haveflags
  unsigned char haveflags;
  // lencode
  unsigned short int lencode;
  // p_lastcode
  const char *p_lastcode;
  // polls
  unsigned int polls;
  // noresponse
  unsigned int noresponse;
  // badformat
  unsigned int badformat;
  // baddata
  unsigned int baddata;
  // timereset
  unsigned int timereset;
  // clockdesc
  const char *clockdesc;
  // fudgetime1
  double fudgetime1;
  // fudgetime2
  double fudgetime2;
  // fudgeval1
  signed int fudgeval1;
  // fudgeval2
  unsigned int fudgeval2;
  // currentstatus
  unsigned char currentstatus;
  // lastevent
  unsigned char lastevent;
  // leap
  unsigned char leap;
  // kv_list
  struct ctl_var *kv_list;
};

struct resulttable
{
  // base
  unsigned int base;
  // last
  unsigned int last;
  // text
  const char **text;
  // msgcat
  struct isc_msgcat *msgcat;
  // set
  signed int set;
  // link
  struct anonymous$54 link;
};

struct savekey
{
  // hlink
  struct savekey *hlink;
  // llink
  struct anonymous$55 llink;
  // secret
  unsigned char *secret;
  // lifetime
  unsigned long int lifetime;
  // keyid
  unsigned int keyid;
  // type
  unsigned short int type;
  // secretsize
  unsigned short int secretsize;
  // flags
  unsigned short int flags;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$24 __sigaction_handler;
  // sa_mask
  struct anonymous$25 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timex
{
  // modes
  unsigned int modes;
  // offset
  signed long int offset;
  // freq
  signed long int freq;
  // maxerror
  signed long int maxerror;
  // esterror
  signed long int esterror;
  // status
  signed int status;
  // constant
  signed long int constant;
  // precision
  signed long int precision;
  // tolerance
  signed long int tolerance;
  // time
  struct timeval time;
  // tick
  signed long int tick;
  // ppsfreq
  signed long int ppsfreq;
  // jitter
  signed long int jitter;
  // shift
  signed int shift;
  // stabil
  signed long int stabil;
  // jitcnt
  signed long int jitcnt;
  // calcnt
  signed long int calcnt;
  // errcnt
  signed long int errcnt;
  // stbcnt
  signed long int stbcnt;
  // tai
  signed int tai;
  // $anon0
  signed int $anon0 : 32;
  // $anon1
  signed int $anon1 : 32;
  // $anon2
  signed int $anon2 : 32;
  // $anon3
  signed int $anon3 : 32;
  // $anon4
  signed int $anon4 : 32;
  // $anon5
  signed int $anon5 : 32;
  // $anon6
  signed int $anon6 : 32;
  // $anon7
  signed int $anon7 : 32;
  // $anon8
  signed int $anon8 : 32;
  // $anon9
  signed int $anon9 : 32;
  // $anon10
  signed int $anon10 : 32;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct utmp
{
  // ut_type
  signed short int ut_type;
  // ut_pid
  signed int ut_pid;
  // ut_line
  char ut_line[32l];
  // ut_id
  char ut_id[4l];
  // ut_user
  char ut_user[32l];
  // ut_host
  char ut_host[256l];
  // ut_exit
  struct exit_status ut_exit;
  // ut_session
  signed int ut_session;
  // ut_tv
  struct anonymous$39 ut_tv;
  // ut_addr_v6
  signed int ut_addr_v6[4l];
  // __glibc_reserved
  char __glibc_reserved[20l];
};

struct utmpx
{
  // ut_type
  signed short int ut_type;
  // ut_pid
  signed int ut_pid;
  // ut_line
  char ut_line[32l];
  // ut_id
  char ut_id[4l];
  // ut_user
  char ut_user[32l];
  // ut_host
  char ut_host[256l];
  // ut_exit
  struct __exit_status ut_exit;
  // ut_session
  signed int ut_session;
  // ut_tv
  struct anonymous$39 ut_tv;
  // ut_addr_v6
  signed int ut_addr_v6[4l];
  // __glibc_reserved
  char __glibc_reserved[20l];
};


// NotAnEmptyCompilationUnit
// file iosignal.c line 545
signed int NotAnEmptyCompilationUnit;
// Version
// file ../include/ntp_stdlib.h line 275
extern const char *Version;
// addremove_io_fd
// file work_thread.c line 48
void (*addremove_io_fd)(signed int, signed int, signed int);
// agc
// file audio.c line 57
signed int agc = (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(11 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8);
// alphnum
// file ./../lib/isc/unix/file.c line 201
static char alphnum[63l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0 };
// authdecryptions
// file authkeys.c line 81
unsigned long int authdecryptions;
// authencryptions
// file authkeys.c line 80
unsigned long int authencryptions;
// authfreekeys
// file authkeys.c line 87
struct savekey *authfreekeys;
// authhashbuckets
// file authkeys.c line 70
unsigned short int authhashbuckets = (unsigned short int)64;
// authhashdisabled
// file authkeys.c line 69
signed int authhashdisabled;
// authhashmask
// file authkeys.c line 71
unsigned short int authhashmask = (unsigned short int)(64 - 1);
// authkeyexpired
// file authkeys.c line 77
unsigned long int authkeyexpired;
// authkeylookups
// file authkeys.c line 75
unsigned long int authkeylookups;
// authkeynotfound
// file authkeys.c line 74
unsigned long int authkeynotfound;
// authkeyuncached
// file authkeys.c line 78
unsigned long int authkeyuncached;
// authnokey
// file authkeys.c line 79
unsigned long int authnokey;
// authnumfreekeys
// file authkeys.c line 88
signed int authnumfreekeys;
// authnumkeys
// file authkeys.c line 76
unsigned long int authnumkeys;
// blocking_children
// file ntp_worker.c line 26
struct blocking_child_tag **blocking_children;
// blocking_children_alloc
// file ntp_worker.c line 27
unsigned long int blocking_children_alloc;
// buffer_shortfall
// file recvbuff.c line 22
static volatile unsigned long int buffer_shortfall;
// cache_flags
// file authkeys.c line 99
unsigned short int cache_flags;
// cache_keyid
// file authkeys.c line 95
unsigned int cache_keyid;
// cache_secret
// file authkeys.c line 96
unsigned char *cache_secret;
// cache_secretsize
// file authkeys.c line 97
unsigned short int cache_secretsize;
// cache_type
// file authkeys.c line 98
signed int cache_type;
// cf_agc
// file audio.c line 61
char cf_agc[100l];
// cf_c_dev
// file audio.c line 61
char cf_c_dev[100l];
// cf_i_dev
// file audio.c line 61
char cf_i_dev[100l];
// cf_monitor
// file audio.c line 61
char cf_monitor[100l];
// clktypes
// file clocktypes.c line 13
struct clktype clktypes[48l] = { { .code=0, .clocktype="unspecified type (0)", .abbrev="UNKNOWN" },
    { .code=1, .clocktype="Undisciplined local clock (1)", .abbrev="LOCAL" },
    { .code=2, .clocktype="TRAK 8810 GPS Receiver (2)", .abbrev="GPS_TRAK" },
    { .code=3, .clocktype="PSTI/Traconex WWV/WWVH Receiver (3)", .abbrev="WWV_PST" },
    { .code=4, .clocktype="Spectracom (generic) Receivers (4)", .abbrev="SPECTRACOM" },
    { .code=5, .clocktype="TrueTime (generic) Receivers (5)", .abbrev="TRUETIME" },
    { .code=6, .clocktype="IRIG Audio Decoder (6)", .abbrev="IRIG_AUDIO" },
    { .code=7, .clocktype="CHU Audio Demodulator/Decoder (7)", .abbrev="CHU_AUDIO" },
    { .code=8, .clocktype="Generic reference clock driver (8)", .abbrev="GENERIC" },
    { .code=9, .clocktype="Magnavox MX4200 GPS Receiver (9)", .abbrev="GPS_MX4200" },
    { .code=10, .clocktype="Austron 2201A GPS Receiver (10)", .abbrev="GPS_AS2201" },
    { .code=11, .clocktype="Arbiter 1088A/B GPS Receiver (11)", .abbrev="GPS_ARBITER" },
    { .code=12, .clocktype="KSI/Odetics TPRO/S IRIG Interface (12)", .abbrev="IRIG_TPRO" },
    { .code=13, .clocktype="Leitch CSD 5300 Master Clock Controller (13)", .abbrev="ATOM_LEITCH" },
    { .code=14, .clocktype="EES M201 MSF Receiver (14)", .abbrev="MSF_EES" },
    { .code=0, .clocktype="not used (15)", .abbrev="NOT_USED" },
    { .code=16, .clocktype="Bancomm GPS/IRIG Receiver (16)", .abbrev="GPS_BANC" },
    { .code=17, .clocktype="Datum Precision Time System (17)", .abbrev="GPS_DATUM" },
    { .code=18, .clocktype="Automated Computer Time Service (18)", .abbrev="ACTS_MODEM" },
    { .code=19, .clocktype="Heath WWV/WWVH Receiver (19)", .abbrev="WWV_HEATH" },
    { .code=20, .clocktype="Generic NMEA GPS Receiver (20)", .abbrev="GPS_NMEA" },
    { .code=21, .clocktype="TrueTime GPS-VME Interface (21)", .abbrev="GPS_VME" },
    { .code=22, .clocktype="PPS Clock Discipline (22)", .abbrev="PPS" },
    { .code=0, .clocktype="not used (23)", .abbrev="NOT_USED" },
    { .code=0, .clocktype="not used (24)", .abbrev="NOT_USED" },
    { .code=0, .clocktype="not used (25)", .abbrev="NOT_USED" },
    { .code=26, .clocktype="HP 58503A GPS Time & Frequency Receiver (26)", .abbrev="GPS_HP" },
    { .code=27, .clocktype="ARCRON MSF (and DCF77) Receiver (27)", .abbrev="MSF_ARCRON" },
    { .code=28, .clocktype="Clock attached thru shared Memory (28)", .abbrev="SHM" },
    { .code=29, .clocktype="Trimble Navigation Palisade GPS (29)", .abbrev="GPS_PALISADE" },
    { .code=30, .clocktype="Motorola UT Oncore GPS (30)", .abbrev="GPS_ONCORE" },
    { .code=31, .clocktype="Rockwell Jupiter GPS (31)", .abbrev="GPS_JUPITER" },
    { .code=32, .clocktype="Chrono-log K (32)", .abbrev="CHRONOLOG" },
    { .code=33, .clocktype="Dumb generic hh:mm:ss local clock (33)", .abbrev="DUMBCLOCK" },
    { .code=34, .clocktype="Ultralink M320 WWVB receiver (34)", .abbrev="ULINK_M320" },
    { .code=35, .clocktype="Conrad parallel port radio clock (35)", .abbrev="PCF" },
    { .code=36, .clocktype="WWV/H Audio Demodulator/Decoder (36)", .abbrev="WWV_AUDIO" },
    { .code=37, .clocktype="Forum Graphic GPS Dating Station (37)", .abbrev="GPS_FG" },
    { .code=38, .clocktype="hopf Elektronic serial line receiver (38)", .abbrev="HOPF_S" },
    { .code=39, .clocktype="hopf Elektronic PCI receiver (39)", .abbrev="HOPF_P" },
    { .code=40, .clocktype="JJY receiver (40)", .abbrev="JJY" },
    { .code=41, .clocktype="TrueTime 560 IRIG-B decoder (41)", .abbrev="TT_IRIG" },
    { .code=42, .clocktype="Zyfer GPStarplus receiver (42)", .abbrev="GPS_ZYFER" },
    { .code=43, .clocktype="RIPE NCC Trimble driver (43)", .abbrev="GPS_RIPENCC" },
    { .code=44, .clocktype="NeoClock4X DCF77 / TDF receiver (44)", .abbrev="NEOCLK4X" },
    { .code=45, .clocktype="Spectracom TSYNC PCI timing board (45)", .abbrev="PCI_TSYNC" },
    { .code=46, .clocktype="GPSD JSON socket (46)", .abbrev="GPSD_JSON" },
    { .code=-1, .clocktype="", .abbrev="" } };
// clock_codes
// file statestr.c line 74
static struct codestring clock_codes[8l] = { { .code=0, .string="clk_unspec" }, { .code=1, .string="clk_no_reply" }, { .code=2, .string="clk_bad_format" }, { .code=3, .string="clk_fault" }, { .code=4, .string="clk_bad_signal" }, { .code=5, .string="clk_bad_date" }, { .code=6, .string="clk_bad_time" }, { .code=-1, .string="clk" } };
// crypto_codes
// file statestr.c line 199
static struct codestring crypto_codes[17l] = { { .code=(0x100 | 0) & ~0x100, .string="success" },
    { .code=(0x100 | 1) & ~0x100, .string="bad_field_format_or_length" },
    { .code=(0x100 | 2) & ~0x100, .string="bad_timestamp" },
    { .code=(0x100 | 3) & ~0x100, .string="bad_filestamp" },
    { .code=(0x100 | 4) & ~0x100, .string="bad_or_missing_public_key" },
    { .code=(0x100 | 5) & ~0x100, .string="unsupported_digest_type" },
    { .code=(0x100 | 6) & ~0x100, .string="unsupported_identity_type" },
    { .code=(0x100 | 7) & ~0x100, .string="bad_signature_length" },
    { .code=(0x100 | 8) & ~0x100, .string="signature_not_verified" },
    { .code=(0x100 | 9) & ~0x100, .string="certificate_not_verified" },
    { .code=(0x100 | 10) & ~0x100, .string="host_certificate_expired" },
    { .code=(0x100 | 11) & ~0x100, .string="bad_or_missing_cookie" },
    { .code=(0x100 | 12) & ~0x100, .string="bad_or_missing_leapseconds" },
    { .code=(0x100 | 13) & ~0x100, .string="bad_or_missing_certificate" },
    { .code=(0x100 | 14) & ~0x100, .string="bad_or_missing_group key" },
    { .code=(0x100 | 15) & ~0x100, .string="protocol_error" },
    { .code=-1, .string="" } };
// crypto_rand_init
// file ntp_crypto_rnd.c line 24
signed int crypto_rand_init = 0;
// ctl_fd
// file audio.c line 67
static signed int ctl_fd;
// ctrl_c_hook
// file syssignal.c line 12
static void (*ctrl_c_hook)(void);
// current_time
// file ../include/ntpd.h line 534
extern unsigned long int current_time;
// daynames
// file prettydate.c line 25
const char * const daynames[7l] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
// debug
// file lib_strbuf.c line 19
signed int debug;
// default_channel
// file ./../lib/isc/log.c line 217
static struct isc_logchannellist default_channel;
// devmask
// file audio.c line 59
signed int devmask = 0;
// dnschild_contexts
// file ntp_intres.c line 191
struct dnschild_ctx_tag **dnschild_contexts;
// dnschild_contexts_alloc
// file ntp_intres.c line 192
unsigned int dnschild_contexts_alloc;
// dnsworker_contexts
// file ntp_intres.c line 193
struct dnsworker_ctx_tag **dnsworker_contexts;
// dnsworker_contexts_alloc
// file ntp_intres.c line 194
unsigned int dnsworker_contexts_alloc;
// end_ptr
// file ntp_random.c line 211
static unsigned long int *end_ptr;
// randtbl
// file ntp_random.c line 159
static unsigned long int randtbl[32l] = { (unsigned long int)3, (unsigned long int)0x991539b1, (unsigned long int)0x16a5bce3, (unsigned long int)0x6774a4cd, (unsigned long int)0x3e01511e, (unsigned long int)0x4e508aaa, (unsigned long int)0x61048c05, (unsigned long int)0xf5500617, (unsigned long int)0x846b7115, (unsigned long int)0x6a19892c, (unsigned long int)0x896a97af, (unsigned long int)0xdb48f936, (unsigned long int)0x14898454, (unsigned long int)0x37ffd106, (unsigned long int)0xb58bff9c, (unsigned long int)0x59e17104, (unsigned long int)0xcf918a49, (unsigned long int)0x09378c83, (unsigned long int)0x52c7a471, (unsigned long int)0x8d293ea9, (unsigned long int)0x1f4fc301, (unsigned long int)0xc3db71be, (unsigned long int)0x39b44e1c, (unsigned long int)0xf8a44ef9, (unsigned long int)0x4c8b80b1, (unsigned long int)0x19edc328, (unsigned long int)0x87bf4bdd, (unsigned long int)0xc9b240e5, (unsigned long int)0xe9ee4b1b, (unsigned long int)0x4382aee7, (unsigned long int)0x535b6b41, (unsigned long int)0xf3bec5da };
// end_ptr
// file ntp_random.c line 211
static unsigned long int *end_ptr = &randtbl[(signed long int)(31 + 1)];
// env
// file ntptime.c line 70
static struct __jmp_buf_tag env[1l];
// epoch
// file ./../lib/isc/unix/time.c line 113
static struct isc_time epoch = { .seconds=(unsigned int)0, .nanoseconds=(unsigned int)0 };
// fatal_callback
// file ./../lib/isc/error.c line 42
static void (*fatal_callback)(const char *, signed int, const char *, void **);
// fatal_callback
// file ./../lib/isc/error.c line 42
static void (*fatal_callback)(const char *, signed int, const char *, void **) = default_fatal_callback;
// final_0
// file ./../lib/isc/sha1.c line 322
static const unsigned char final_0 = (const unsigned char)0;
// final_200
// file ./../lib/isc/sha1.c line 321
static const unsigned char final_200 = (const unsigned char)128;
// flash
// file ntptime.c line 75
static volatile signed int flash;
// fptr
// file ntp_random.c line 194
static unsigned long int *fptr;
// fptr
// file ntp_random.c line 194
static unsigned long int *fptr = &randtbl[(signed long int)(3 + 1)];
// free_recv_list
// file recvbuff.c line 26
static struct recvbuf *free_recv_list;
// free_recvbufs
// file recvbuff.c line 19
static volatile unsigned long int free_recvbufs;
// full_recv_fifo
// file recvbuff.c line 25
static struct anonymous$7 full_recv_fifo;
// full_recvbufs
// file recvbuff.c line 18
static volatile unsigned long int full_recvbufs;
// hev
// file ntp_lineedit.c line 55
static struct HistEvent hev;
// in6addr_any
// file /usr/include/netinet/in.h line 227
extern struct in6_addr in6addr_any;
// intres_req_pending
// file ntp_worker.c line 29
signed int intres_req_pending;
// ipv4_result
// file ./../lib/isc/unix/net.c line 117
static unsigned int ipv4_result = (unsigned int)23;
// ipv4_works
// file lib_strbuf.c line 22
signed int ipv4_works;
// ipv6_result
// file ./../lib/isc/unix/net.c line 118
static unsigned int ipv6_result = (unsigned int)23;
// ipv6_works
// file lib_strbuf.c line 23
signed int ipv6_works;
// ipv6only_result
// file ./../lib/isc/unix/net.c line 120
static unsigned int ipv6only_result = (unsigned int)23;
// ipv6pktinfo_result
// file ./../lib/isc/unix/net.c line 121
static unsigned int ipv6pktinfo_result = (unsigned int)23;
// isc__backtrace_nsymbols
// file ./../lib/isc/backtrace-emptytbl.c line 33
const signed int isc__backtrace_nsymbols = 0;
// isc__backtrace_symtable
// file ./../lib/isc/backtrace-emptytbl.c line 34
const struct isc_backtrace_symmap isc__backtrace_symtable[1l] = { { .addr=(void *)0, .symbol="" } };
// isc_assertion_failed_cb
// file ./../lib/isc/assertions.c line 45
static void (*isc_assertion_failed_cb)(const char *, signed int, enum anonymous$46, const char *);
// isc_assertion_failed_cb
// file ./../lib/isc/assertions.c line 45
static void (*isc_assertion_failed_cb)(const char *, signed int, enum anonymous$46, const char *) = default_callback;
// isc_categories
// file ./../lib/isc/log.c line 194
struct isc_logcategory isc_categories[3l] = { { .name="default", .id=(unsigned int)0 },
    { .name="general", .id=(unsigned int)0 },
    { .name=(const char *)(void *)0, .id=(unsigned int)0 } };
// isc_interval_zero
// file ./../lib/isc/unix/time.c line 58
struct isc_interval *isc_interval_zero;
// zero_interval
// file ./../lib/isc/unix/time.c line 57
static struct isc_interval zero_interval = { .seconds=(unsigned int)0, .nanoseconds=(unsigned int)0 };
// isc_interval_zero
// file ./../lib/isc/unix/time.c line 58
struct isc_interval *isc_interval_zero = &zero_interval;
// isc_lctx
// file ./../lib/isc/log.c line 222
struct isc_log *isc_lctx = (struct isc_log *)(void *)0;
// isc_modules
// file ./../lib/isc/log.c line 203
struct isc_logmodule isc_modules[6l] = { { .name="socket", .id=(unsigned int)0 },
    { .name="time", .id=(unsigned int)0 }, { .name="interface", .id=(unsigned int)0 },
    { .name="timer", .id=(unsigned int)0 }, { .name="file", .id=(unsigned int)0 }, { .name=(const char *)(void *)0, .id=(unsigned int)0 } };
// isc_msgcat
// file ./../lib/isc/lib.c line 41
struct isc_msgcat *isc_msgcat = (struct isc_msgcat *)(void *)0;
// isc_strerror_lock
// file ./../lib/isc/unix/strerror.c line 39
static union anonymous$2 isc_strerror_lock;
// isc_time_epoch
// file ./../lib/isc/unix/time.c line 114
struct isc_time *isc_time_epoch;
// isc_time_epoch
// file ./../lib/isc/unix/time.c line 114
struct isc_time *isc_time_epoch = &epoch;
// k_st_bits
// file statestr.c line 224
static struct codestring k_st_bits[16l] = { { .code=0x0001, .string="pll" }, { .code=0x0002, .string="ppsfreq" }, { .code=0x0004, .string="ppstime" }, { .code=0x0008, .string="fll" }, { .code=0x0010, .string="ins" }, { .code=0x0020, .string="del" }, { .code=0x0040, .string="unsync" }, { .code=0x0080, .string="freqhold" }, { .code=0x0100, .string="ppssignal" }, { .code=0x0200, .string="ppsjitter" }, { .code=0x0400, .string="ppswander" }, { .code=0x0800, .string="ppserror" }, { .code=0x1000, .string="clockerr" }, { .code=0x2000, .string="nano" }, { .code=0x4000, .string="mode=fll" }, { .code=0x8000, .string="src=B" } };
// key_hash
// file authkeys.c line 72
struct savekey **key_hash;
// key_listhead
// file authkeys.c line 60
struct savekey key_listhead;
// lamport_violated
// file systime.c line 84
static signed int lamport_violated;
// leap_codes
// file statestr.c line 31
static struct codestring leap_codes[5l] = { { .code=0x0, .string="leap_none" }, { .code=0x1, .string="leap_add_sec" }, { .code=0x2, .string="leap_del_sec" }, { .code=0x3, .string="leap_alarm" }, { .code=-1, .string="leap" } };
// lib_inited
// file lib_strbuf.c line 24
signed int lib_inited;
// lib_nextbuf
// file lib_strbuf.c line 21
signed int lib_nextbuf;
// lib_stringbuf
// file lib_strbuf.c line 20
char lib_stringbuf[16l][128l];
// lineedit_prompt
// file ntp_lineedit.c line 46
static char *lineedit_prompt;
// lock
// file ./../lib/isc/result.c line 113
static union anonymous$2 lock;
// log_level_strings
// file ./../lib/isc/log.c line 164
static const char *log_level_strings[6l] = { "debug", "info", "notice", "warning", "error", "critical" };
// lowater_adds
// file recvbuff.c line 21
static volatile unsigned long int lowater_adds;
// m_names
// file audio.c line 63
const char *m_names[25l] = { "vol", "bass", "treble", "synth", "pcm", "speaker", "line", "mic", "cd", "mix", "pcm2", "rec", "igain", "ogain", "line1", "line2", "line3", "dig1", "dig2", "dig3", "phin", "phout", "video", "radio", "monitor" };
// measured_tick
// file systime.c line 73
double measured_tick;
// mktime_bs
// file mktime.c line 262
signed int mktime_bs;
// monitor
// file audio.c line 58
signed int monitor = (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(0 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8);
// months
// file prettydate.c line 20
const char * const months[12l] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
// msgcat_once
// file ./../lib/isc/lib.c line 48
static signed int msgcat_once = 0;
// msyslog_include_timestamp
// file msyslog.c line 32
signed int msyslog_include_timestamp = 1;
// msyslog_term
// file msyslog.c line 30
signed int msyslog_term = 0;
// msyslog_term_pid
// file msyslog.c line 31
signed int msyslog_term_pid = 1;
// nerr_loglimit
// file authreadkeys.c line 80
static const unsigned long int nerr_loglimit = (const unsigned long int)5u;
// nerr_maxlimit
// file authreadkeys.c line 81
static const unsigned long int nerr_maxlimit = (const unsigned long int)15;
// newsigsys
// file ntptime.c line 68
static struct sigaction newsigsys;
// next_res_init
// file ntp_intres.c line 197
static signed long int next_res_init;
// ntp_el
// file ntp_lineedit.c line 53
static struct editline *ntp_el;
// ntp_hist
// file ntp_lineedit.c line 54
static struct history *ntp_hist;
// ntp_optarg
// file getopt.c line 26
char *ntp_optarg;
// ntp_opterr
// file getopt.c line 28
signed int ntp_opterr = 1;
// ntp_optind
// file getopt.c line 27
signed int ntp_optind = 0;
// ntp_optopt
// file getopt.c line 29
signed int ntp_optopt;
// ntp_readline_initted
// file ntp_lineedit.c line 45
static signed int ntp_readline_initted;
// ntp_syslogmask
// file msyslog.c line 39
unsigned int ntp_syslogmask = ~((unsigned int)0);
// once
// file ./../lib/isc/unix/net.c line 115
static signed int once = 0;
// once$link1
// file ./../lib/isc/random.c line 39
static signed int once$link1 = 0;
// once$link2
// file ./../lib/isc/result.c line 111
static signed int once$link2 = 0;
// once_ipv6only
// file ./../lib/isc/unix/net.c line 106
static signed int once_ipv6only = 0;
// once_ipv6pktinfo
// file ./../lib/isc/unix/net.c line 111
static signed int once_ipv6pktinfo = 0;
// optargs
// file ntptime.c line 77
static char optargs[21l] = { 'M', 'N', 'T', ':', 'c', 'd', 'e', ':', 'f', ':', 'h', 'm', ':', 'o', ':', 'r', 's', ':', 't', ':', 0 };
// peer_codes
// file statestr.c line 135
static struct codestring peer_codes[16l] = { { .code=(1 | 0x080) & ~0x080, .string="mobilize" },
    { .code=(2 | 0x080) & ~0x080, .string="demobilize" },
    { .code=(3 | 0x080) & ~0x080, .string="unreachable" },
    { .code=(4 | 0x080) & ~0x080, .string="reachable" },
    { .code=(5 | 0x080) & ~0x080, .string="restart" },
    { .code=(6 | 0x080) & ~0x080, .string="no_reply" },
    { .code=(7 | 0x080) & ~0x080, .string="rate_exceeded" },
    { .code=(8 | 0x080) & ~0x080, .string="access_denied" },
    { .code=(9 | 0x080) & ~0x080, .string="leap_armed" },
    { .code=(10 | 0x080) & ~0x080, .string="sys_peer" },
    { .code=(11 | 0x080) & ~0x080, .string="clock_event" },
    { .code=(12 | 0x080) & ~0x080, .string="bad_auth" },
    { .code=(13 | 0x080) & ~0x080, .string="popcorn" },
    { .code=(14 | 0x080) & ~0x080, .string="interleave_mode" },
    { .code=(15 | 0x080) & ~0x080, .string="interleave_error" },
    { .code=-1, .string="" } };
// peer_st_bits
// file statestr.c line 157
static struct codestring peer_st_bits[5l] = { { .code=0x80, .string="conf" }, { .code=0x40, .string="authenb" }, { .code=0x20, .string="auth" }, { .code=0x10, .string="reach" }, { .code=0x08, .string="bcast" } };
// pll_control
// file ntptime.c line 73
static volatile signed int pll_control;
// prog
// file getopt.c line 32
static const char *prog = "amnesia";
// progname
// file ntptime.c line 76
const char *progname;
// rand_deg
// file ntp_random.c line 209
static signed long int rand_deg = (signed long int)31;
// rand_sep
// file ntp_random.c line 210
static signed long int rand_sep = (signed long int)3;
// rand_type
// file ntp_random.c line 208
static signed long int rand_type = (signed long int)3;
// real_month_table
// file ntp_calendar.c line 407
static const unsigned short int real_month_table[2l][13l] = { { (const unsigned short int)0, (const unsigned short int)31, (const unsigned short int)59, (const unsigned short int)90, (const unsigned short int)120, (const unsigned short int)151, (const unsigned short int)181, (const unsigned short int)212, (const unsigned short int)243, (const unsigned short int)273, (const unsigned short int)304, (const unsigned short int)334, (const unsigned short int)365 },
    { (const unsigned short int)0, (const unsigned short int)31, (const unsigned short int)60, (const unsigned short int)91, (const unsigned short int)121, (const unsigned short int)152, (const unsigned short int)182, (const unsigned short int)213, (const unsigned short int)244, (const unsigned short int)274, (const unsigned short int)305, (const unsigned short int)335, (const unsigned short int)366 } };
// recmask
// file audio.c line 60
signed int recmask = 0;
// res_access_bits
// file statestr.c line 179
static struct codestring res_access_bits[12l] = { { .code=0x0001, .string="ignore" }, { .code=0x0002, .string="noserve" }, { .code=0x0004, .string="notrust" }, { .code=0x0040, .string="noquery" }, { .code=0x0080, .string="nomodify" }, { .code=0x0010, .string="nopeer" }, { .code=0x0100, .string="notrap" }, { .code=0x0200, .string="lptrap" }, { .code=0x0020, .string="limited" }, { .code=0x0008, .string="version" }, { .code=0x0400, .string="kod" }, { .code=0x1000, .string="flake" } };
// res_match_bits
// file statestr.c line 169
static struct codestring res_match_bits[3l] = { { .code=0x2000, .string="ntpport" }, { .code=0x1000, .string="interface" }, { .code=0x4000, .string="source" } };
// rptr
// file ntp_random.c line 195
static unsigned long int *rptr;
// rptr
// file ntp_random.c line 195
static unsigned long int *rptr = &randtbl[(signed long int)1];
// scan
// file getopt.c line 31
static char *scan = (char *)(void *)0;
// seenv6
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 33
static enum anonymous$11 seenv6 = (enum anonymous$11)isc_boolean_false;
// select_codes
// file statestr.c line 59
static struct codestring select_codes[9l] = { { .code=0, .string="sel_reject" }, { .code=1, .string="sel_falsetick" }, { .code=2, .string="sel_excess" }, { .code=3, .string="sel_outlier" }, { .code=4, .string="sel_candidate" }, { .code=5, .string="sel_backup" }, { .code=6, .string="sel_sys.peer" }, { .code=7, .string="sel_pps.peer" }, { .code=-1, .string="sel" } };
// set_tod_used
// file machines.c line 420
const char * const set_tod_used[4l] = { "undetermined", "clock_settime", "settimeofday", "stime" };
// set_tod_using
// file machines.c line 427
void (*set_tod_using)(const char *) = (void (*)(const char *))(void *)0;
// shift_month_table
// file ntp_calendar.c line 402
static const unsigned short int shift_month_table[13l] = { (const unsigned short int)0, (const unsigned short int)31, (const unsigned short int)61, (const unsigned short int)92, (const unsigned short int)122, (const unsigned short int)153, (const unsigned short int)184, (const unsigned short int)214, (const unsigned short int)245, (const unsigned short int)275, (const unsigned short int)306, (const unsigned short int)337, (const unsigned short int)366 };
// sigsys
// file ntptime.c line 69
static struct sigaction sigsys;
// ssl_init_done
// file ssl_init.c line 21
signed int ssl_init_done;
// state
// file ntp_random.c line 207
static unsigned long int *state;
// state
// file ntp_random.c line 207
static unsigned long int *state = &randtbl[(signed long int)1];
// status
// file ntptime.c line 74
static volatile signed int status;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// step_callback
// file systime.c line 76
void (*step_callback)(void);
// strdup_c_nonempty_compilation_unit
// file strdup.c line 28
signed int strdup_c_nonempty_compilation_unit;
// strerror_bs
// file bsd_strerror.c line 48
signed int strerror_bs;
// sync_codes
// file statestr.c line 42
static struct codestring sync_codes[11l] = { { .code=0, .string="sync_unspec" }, { .code=1, .string="sync_pps" }, { .code=2, .string="sync_lf_radio" }, { .code=3, .string="sync_hf_radio" }, { .code=4, .string="sync_uhf_radio" }, { .code=5, .string="sync_local" }, { .code=6, .string="sync_ntp" }, { .code=7, .string="sync_other" }, { .code=8, .string="sync_wristwatch" }, { .code=9, .string="sync_telephone" }, { .code=-1, .string="sync" } };
// sys_codes
// file statestr.c line 112
static struct codestring sys_codes[17l] = { { .code=0, .string="unspecified" }, { .code=1, .string="freq_not_set" }, { .code=2, .string="freq_set" }, { .code=3, .string="spike_detect" }, { .code=4, .string="freq_mode" }, { .code=5, .string="clock_sync" }, { .code=6, .string="restart" }, { .code=7, .string="panic_stop" }, { .code=8, .string="no_sys_peer" }, { .code=9, .string="leap_armed" }, { .code=10, .string="leap_disarmed" }, { .code=11, .string="leap_event" }, { .code=12, .string="clock_step" }, { .code=13, .string="kern" }, { .code=14, .string="TAI" }, { .code=15, .string="stale_leapsecond_values" },
    { .code=-1, .string="" } };
// sys_fuzz
// file systime.c line 71
double sys_fuzz = (double)0;
// sys_fuzz_nsec
// file systime.c line 72
signed long int sys_fuzz_nsec = (signed long int)0;
// sys_residual
// file systime.c line 74
double sys_residual = (double)0;
// sys_tick
// file systime.c line 70
double sys_tick = (double)0;
// syslog_abs_fname
// file msyslog.c line 35
char *syslog_abs_fname;
// syslog_file
// file msyslog.c line 33
struct _IO_FILE *syslog_file;
// syslog_fname
// file msyslog.c line 34
char *syslog_fname;
// syslog_map
// file ./../lib/isc/log.c line 177
static const signed int syslog_map[6l] = { 7, 6, 5, 4, 3, 2 };
// syslogit
// file msyslog.c line 29
signed int syslogit = 1;
// systime_func
// file ntp_calendar.c line 97
static signed long int (*systime_func)(signed long int *);
// systime_func
// file ntp_calendar.c line 97
static signed long int (*systime_func)(signed long int *) = time;
// tables
// file ./../lib/isc/result.c line 112
static struct anonymous$53 tables;
// taskmethods
// file ./../lib/isc/task.c line 259
static struct isc__taskmethods taskmethods;
// taskmethods
// file ./../lib/isc/task.c line 259
static struct isc__taskmethods taskmethods = { .methods={ .attach=isc__task_attach, .detach=isc__task_detach, .destroy=isc__task_destroy,
    .send=isc__task_send, .sendanddetach=isc__task_sendanddetach,
    .unsend=isc__task_unsend,
    .onshutdown=isc__task_onshutdown, .shutdown=isc__task_shutdown,
    .setname=isc__task_setname, .purgeevents=isc__task_purge,
    .purgerange=isc__task_purgerange, .beginexclusive=isc__task_beginexclusive,
    .endexclusive=isc__task_endexclusive,
    .setprivilege=isc__task_setprivilege,
    .privilege=isc__task_privilege } };
// taskmgrmethods
// file ./../lib/isc/task.c line 285
static struct isc_taskmgrmethods taskmgrmethods;
// taskmgrmethods
// file ./../lib/isc/task.c line 285
static struct isc_taskmgrmethods taskmgrmethods = { .destroy=isc__taskmgr_destroy, .setmode=isc__taskmgr_setmode, .mode=isc__taskmgr_mode,
    .taskcreate=isc__task_create };
// ten_to_the_n
// file atolfp.c line 15
static unsigned long int ten_to_the_n[10l] = { (unsigned long int)0, (unsigned long int)10, (unsigned long int)100, (unsigned long int)1000, (unsigned long int)10000, (unsigned long int)100000, (unsigned long int)1000000, (unsigned long int)10000000, (unsigned long int)100000000, (unsigned long int)1000000000 };
// text
// file ./../lib/isc/result.c line 43
static const char *text[62l] = { "success", "out of memory", "timed out", "no available threads", "address not available", "address in use", "permission denied", "no pending connections", "network unreachable", "host unreachable", "network down", "host down", "connection refused", "not enough free resources", "end of file", "socket already bound", "reload", "lock busy", "already exists", "ran out of space", "operation canceled", "socket is not bound", "shutting down", "not found", "unexpected end of input", "failure", "I/O error", "not implemented", "unbalanced parentheses", "no more", "invalid file", "bad base64 encoding", "unexpected token", "quota reached", "unexpected error", "already running", "ignore", "address mask not contiguous", "file not found", "file already exists", "socket is not connected", "out of range", "out of entropy", "invalid use of multicast address", "not a file", "not a directory", "queue is full", "address family mismatch", "address family not supported", "bad hex encoding", "too many open files", "not blocking", "unbalanced quotes", "operation in progress", "connection reset", "soft quota reached", "not a valid number", "disabled", "max size", "invalid address format", "bad base32 encoding", "unset" };
// timex_states
// file ntptime.c line 460
const char * const timex_states[6l] = { "OK", "INS", "DEL", "OOP", "WAIT", "ERROR" };
// total_recvbufs
// file recvbuff.c line 20
static volatile unsigned long int total_recvbufs;
// trunc_os_clock
// file systime.c line 75
signed int trunc_os_clock;
// unexpected_callback
// file ./../lib/isc/error.c line 41
static void (*unexpected_callback)(const char *, signed int, const char *, void **);
// unexpected_callback
// file ./../lib/isc/error.c line 41
static void (*unexpected_callback)(const char *, signed int, const char *, void **) = default_unexpected_callback;
// unix_result
// file ./../lib/isc/unix/net.c line 119
static unsigned int unix_result = (unsigned int)23;
// work_fork_nonempty_compilation_unit
// file work_fork.c line 544
char work_fork_nonempty_compilation_unit;
// worker_per_query
// file ntp_worker.c line 28
signed int worker_per_query;

// FindConfig
// file findconfig.c line 68
extern const char * FindConfig(const char *base)
{
  return base;
}

// MD5auth_setkey
// file authkeys.c line 516
extern void MD5auth_setkey(unsigned int keyno, signed int keytype, const unsigned char *key, unsigned long int len)
{
  struct savekey *sk;
  struct savekey **bucket;
  unsigned char *secret;
  unsigned long int secretsize;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  bucket = &key_hash[(signed long int)(keyno & (unsigned int)authhashmask)];
  sk = *bucket;
  for( ; !(sk == ((struct savekey *)NULL)); sk = sk->hlink)
    if(keyno == sk->keyid)
    {
      if(!(sk->secret == ((unsigned char *)NULL)))
      {
        memset((void *)sk->secret, 0, (unsigned long int)sk->secretsize);
        free((void *)sk->secret);
      }

      void *return_value_ereallocz$1;
      return_value_ereallocz$1=ereallocz((void *)0, len, (unsigned long int)0, 0);
      sk->secret = (unsigned char *)return_value_ereallocz$1;
      sk->type = (unsigned short int)keytype;
      secretsize = len;
      sk->secretsize = (unsigned short int)secretsize;
      memcpy((void *)sk->secret, (const void *)key, secretsize);
      if(cache_keyid == keyno)
      {
        cache_flags = (unsigned short int)0;
        cache_keyid = (unsigned int)0;
      }

      goto __CPROVER_DUMP_L8;
    }

  secretsize = len;
  void *return_value_ereallocz$2;
  return_value_ereallocz$2=ereallocz((void *)0, secretsize, (unsigned long int)0, 0);
  secret = (unsigned char *)return_value_ereallocz$2;
  memcpy((void *)secret, (const void *)key, secretsize);
  allocsymkey(bucket, keyno, (unsigned short int)0, (unsigned short int)keytype, (unsigned long int)0, (unsigned short int)secretsize, secret);

__CPROVER_DUMP_L8:
  ;
}

// MD5authdecrypt
// file a_md5encrypt.c line 60
extern signed int MD5authdecrypt(signed int type, unsigned char *key, unsigned int *pkt, signed int length, signed int size)
{
  unsigned char digest[64l];
  unsigned int len;
  struct env_md_ctx_st ctx;
  do
    if(ssl_init_done == 0)
      ssl_init();

  while((_Bool)0);
  const char *return_value_OBJ_nid2sn$1;
  return_value_OBJ_nid2sn$1=OBJ_nid2sn(type);
  const struct env_md_st *return_value_EVP_get_digestbyname$2;
  return_value_EVP_get_digestbyname$2=EVP_get_digestbyname(return_value_OBJ_nid2sn$1);
  signed int return_value_EVP_DigestInit$3;
  return_value_EVP_DigestInit$3=EVP_DigestInit(&ctx, return_value_EVP_get_digestbyname$2);
  if(return_value_EVP_DigestInit$3 == 0)
  {
    msyslog(3, "MAC decrypt: digest init failed");
    return 0;
  }

  else
  {
    EVP_DigestUpdate(&ctx, (const void *)key, (unsigned long int)cache_secretsize);
    EVP_DigestUpdate(&ctx, (const void *)(unsigned char *)pkt, (unsigned long int)(unsigned int)length);
    EVP_DigestFinal(&ctx, digest, &len);
    if(!((unsigned int)size == 4u + len))
    {
      msyslog(3, "MAC decrypt: MAC length error");
      return 0;
    }

    else
    {
      signed int return_value_memcmp$4;
      return_value_memcmp$4=memcmp((const void *)digest, (const void *)((char *)pkt + (signed long int)length + (signed long int)4), (unsigned long int)len);
      return (signed int)!(return_value_memcmp$4 != 0);
    }
  }
}

// MD5authencrypt
// file a_md5encrypt.c line 20
extern signed int MD5authencrypt(signed int type, unsigned char *key, unsigned int *pkt, signed int length)
{
  unsigned char digest[64l];
  unsigned int len;
  struct env_md_ctx_st ctx;
  do
    if(ssl_init_done == 0)
      ssl_init();

  while((_Bool)0);
  const char *return_value_OBJ_nid2sn$1;
  return_value_OBJ_nid2sn$1=OBJ_nid2sn(type);
  const struct env_md_st *return_value_EVP_get_digestbyname$2;
  return_value_EVP_get_digestbyname$2=EVP_get_digestbyname(return_value_OBJ_nid2sn$1);
  signed int return_value_EVP_DigestInit$3;
  return_value_EVP_DigestInit$3=EVP_DigestInit(&ctx, return_value_EVP_get_digestbyname$2);
  if(return_value_EVP_DigestInit$3 == 0)
  {
    msyslog(3, "MAC encrypt: digest init failed");
    return 0;
  }

  else
  {
    EVP_DigestUpdate(&ctx, (const void *)key, (unsigned long int)cache_secretsize);
    EVP_DigestUpdate(&ctx, (const void *)(unsigned char *)pkt, (unsigned long int)(unsigned int)length);
    EVP_DigestFinal(&ctx, digest, &len);
    memmove((void *)((unsigned char *)pkt + (signed long int)length + (signed long int)4), (const void *)digest, (unsigned long int)len);
    return (signed int)(len + (unsigned int)4);
  }
}

// abs_tval
// file ../include/timevalops.h line 256
static inline struct timeval abs_tval(struct timeval a)
{
  struct timeval c;
  c=normalize_tval(a);
  if(!(c.tv_sec >= 0l))
  {
    if(!(c.tv_usec == 0l))
    {
      c.tv_sec = -c.tv_sec - (signed long int)1;
      c.tv_usec = (signed long int)1000000 - c.tv_usec;
    }

    else
      c.tv_sec = -c.tv_sec;
  }

  return c;
}

// add_full_recv_buffer
// file recvbuff.c line 175
extern void add_full_recv_buffer(struct recvbuf *rb)
{
  if(rb == ((struct recvbuf *)NULL))
    msyslog(3, "add_full_recv_buffer received NULL buffer");

  else
  {

  __CPROVER_DUMP_L1:
    ;

  __CPROVER_DUMP_L2:
    ;
    do
    {
      rb->link = (struct recvbuf *)(void *)0;
      if(!(full_recv_fifo.pptail == ((struct recvbuf **)NULL)))
      {
        (*full_recv_fifo.pptail)->link = rb;
        full_recv_fifo.pptail = &(*full_recv_fifo.pptail)->link;
      }

      else
      {
        full_recv_fifo.phead = rb;
        full_recv_fifo.pptail = &full_recv_fifo.phead;
      }

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    full_recvbufs = full_recvbufs + 1ul;
  }

__CPROVER_DUMP_L5:
  ;
}

// add_tspec_ns
// file ../include/timespecops.h line 140
static inline struct timespec add_tspec_ns(struct timespec a, signed long int b)
{
  struct timespec x = a;
  x.tv_nsec = x.tv_nsec + b;
  struct timespec return_value_normalize_tspec$1;
  return_value_normalize_tspec$1=normalize_tspec(x);
  return return_value_normalize_tspec$1;
}

// addr2refid
// file a_md5encrypt.c line 105
extern unsigned int addr2refid(union anonymous$47 *addr)
{
  unsigned char digest[20l];
  unsigned int addr_refid;
  struct env_md_ctx_st ctx;
  unsigned int len;
  if((signed int)addr->sa.sa_family == 2)
    return addr->sa4.sin_addr.s_addr;

  else
  {
    do
      if(ssl_init_done == 0)
        ssl_init();

    while((_Bool)0);
    EVP_MD_CTX_init(&ctx);
    EVP_MD_CTX_set_flags(&ctx, 0x0008);
    const struct env_md_st *return_value_EVP_md5$1;
    return_value_EVP_md5$1=EVP_md5();
    signed int return_value_EVP_DigestInit_ex$2;
    return_value_EVP_DigestInit_ex$2=EVP_DigestInit_ex(&ctx, return_value_EVP_md5$1, (struct engine_st *)(void *)0);
    if(return_value_EVP_DigestInit_ex$2 == 0)
    {
      msyslog(3, "MD5 init failed");
      exit(1);
    }

    EVP_DigestUpdate(&ctx, (const void *)(unsigned char *)&addr->sa6.sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
    EVP_DigestFinal(&ctx, digest, &len);
    memcpy((void *)&addr_refid, (const void *)digest, sizeof(unsigned int) /*4ul*/ );
    return addr_refid;
  }
}

// addto_syslog
// file msyslog.c line 143
void addto_syslog(signed int level, const char *msg)
{
  const char nl[2l] = { '\n', 0 };
  const char empty[1l] = { 0 };
  struct _IO_FILE *term_file;
  signed int log_to_term;
  signed int log_to_file;
  signed int pid;
  const char *nl_or_empty;
  const char *human_time;
  static const char *addto_syslog$$1$$prog;
  static const char *prevcall_progname;
  if(!(progname == prevcall_progname))
  {
    prevcall_progname = progname;
    addto_syslog$$1$$prog=strrchr(progname, 47);
    if(!(addto_syslog$$1$$prog == ((const char *)NULL)))
      addto_syslog$$1$$prog = addto_syslog$$1$$prog + 1l;

    else
      addto_syslog$$1$$prog = progname;
  }

  log_to_term = msyslog_term;
  log_to_file = 0;
  if(!(syslogit == 0))
    syslog(level, "%s", msg);

  else
    if(!(syslog_file == ((struct _IO_FILE *)NULL)))
      log_to_file = 1;

    else
      log_to_term = 1;
  if(!(log_to_file == 0) || !(log_to_term == 0))
  {
    if(!(msyslog_include_timestamp == 0))
      human_time=humanlogtime();

    else
      human_time = (const char *)(void *)0;
    if(!(log_to_file == 0) || !(msyslog_term_pid == 0))
      pid=getpid();

    else
      pid = -1;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(msg);
    if(!((signed int)msg[-1l + (signed long int)return_value_strlen$1] == 10))
      nl_or_empty = nl;

    else
      nl_or_empty = empty;
    if(!(log_to_term == 0))
    {
      term_file = level <= 3 ? stderr : stdout;
      if(!(msyslog_include_timestamp == 0))
        fprintf(term_file, "%s ", human_time);

      if(!(msyslog_term_pid == 0))
        fprintf(term_file, "%s[%d]: ", addto_syslog$$1$$prog, pid);

      fprintf(term_file, "%s%s", msg, nl_or_empty);
      fflush(term_file);
    }

    if(!(log_to_file == 0))
    {
      if(!(msyslog_include_timestamp == 0))
        fprintf(syslog_file, "%s ", human_time);

      fprintf(syslog_file, "%s[%d]: %s%s", addto_syslog$$1$$prog, pid, msg, nl_or_empty);
      fflush(syslog_file);
    }

  }

}

// addv64
// file vint64ops.c line 175
extern union anonymous$44 addv64(const union anonymous$44 *lhs, const union anonymous$44 *rhs)
{
  union anonymous$44 res;
  res.Q_s = lhs->Q_s + rhs->Q_s;
  return res;
}

// addv64i32
// file vint64ops.c line 213
extern union anonymous$44 addv64i32(const union anonymous$44 *lhs, signed int rhs)
{
  union anonymous$44 res = *lhs;
  res.q_s = res.q_s + (signed long int)rhs;
  return res;
}

// addv64u32
// file vint64ops.c line 251
extern union anonymous$44 addv64u32(const union anonymous$44 *lhs, unsigned int rhs)
{
  union anonymous$44 res = *lhs;
  res.Q_s = res.Q_s + (unsigned long int)rhs;
  return res;
}

// adj_systime
// file systime.c line 278
extern signed int adj_systime(double now)
{
  struct timeval adjtv;
  struct timeval oadjtv;
  double quant;
  double dtemp;
  signed long int ticks;
  signed int isneg = 0;
  if(IEEE_FLOAT_EQUAL(0., now))
    return 1;

  else
  {
    dtemp = now + sys_residual;
    if(dtemp < 0.000000)
    {
      isneg = 1;
      dtemp = -dtemp;
    }

    adjtv.tv_sec = (signed long int)dtemp;
    dtemp = dtemp - (double)adjtv.tv_sec;
    if(sys_tick > sys_fuzz)
      quant = sys_tick;

    else
      quant = 1e-6;
    ticks = (signed long int)(dtemp / quant + .5);
    adjtv.tv_usec = (signed long int)((double)ticks * quant * 1e6);
    dtemp = dtemp - (double)adjtv.tv_usec / 1e6;
    sys_residual = dtemp;
    if(!(isneg == 0))
    {
      adjtv.tv_sec = -adjtv.tv_sec;
      adjtv.tv_usec = -adjtv.tv_usec;
      sys_residual = -sys_residual;
    }

    if(!(adjtv.tv_sec == 0l) || !(adjtv.tv_usec == 0l))
    {
      signed int return_value_adjtime$1;
      return_value_adjtime$1=adjtime(&adjtv, &oadjtv);
      if(!(return_value_adjtime$1 >= 0))
      {
        msyslog(3, "adj_systime: %m");
        return 0;
      }

    }

    return 1;
  }
}

// alloc_dnsworker_context
// file ntp_intres.c line 953
static void alloc_dnsworker_context(unsigned int idx)
{
  const unsigned long int worker_context_sz = sizeof(struct dnsworker_ctx_tag) /*24ul*/ ;
  if(dnsworker_contexts[(signed long int)idx] == ((struct dnsworker_ctx_tag *)NULL))
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_intres.c", 959, (enum anonymous$46)isc_assertiontype_require, "((void *)0) == dnsworker_contexts[idx]");
    (_Bool)0;
  }
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, worker_context_sz, (unsigned long int)0, 1);
  dnsworker_contexts[(signed long int)idx] = (struct dnsworker_ctx_tag *)return_value_ereallocz$1;
}

// allocsymkey
// file authkeys.c line 263
static void allocsymkey(struct savekey **bucket, unsigned int id, unsigned short int flags, unsigned short int type, unsigned long int lifetime, unsigned short int secretsize, unsigned char *secret)
{
  struct savekey *sk;
  if(!(authnumfreekeys >= 1))
    auth_moremem(-1);

  do
  {
    sk = authfreekeys;
    if(!(sk == ((struct savekey *)NULL)))
      authfreekeys = sk->llink.f;


  __CPROVER_DUMP_L2:
    ;
  }
  while((_Bool)0);

__CPROVER_DUMP_L4:
  ;
  sk->keyid = id;
  sk->flags = flags;
  sk->type = type;
  sk->secretsize = secretsize;
  sk->secret = secret;
  sk->lifetime = lifetime;
  do
  {
    sk->hlink = *bucket;
    *bucket = sk;
  }
  while((_Bool)0);
  do
  {
    sk->llink.b = key_listhead.llink.b;
    sk->llink.f = &key_listhead;
    key_listhead.llink.b->llink.f = sk;
    key_listhead.llink.b = sk;
  }
  while((_Bool)0);
  authnumfreekeys = authnumfreekeys - 1;
  authnumkeys = authnumkeys + 1ul;
}

// assignchannel
// file ./../lib/isc/log.c line 1056
static unsigned int assignchannel(struct isc_logconfig *lcfg, unsigned int category_id, const struct isc_logmodule *module, struct isc_logchannel *channel)
{
  struct isc_logchannellist *new_item;
  struct isc_log *lctx;
  unsigned int result;
  _Bool tmp_if_expr$1;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lcfg)->magic == (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1063, (enum anonymous$46)isc_assertiontype_require, "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
    (_Bool)0;
  }
  lctx = lcfg->lctx;
  if(!(category_id >= lctx->category_count))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1067, (enum anonymous$46)isc_assertiontype_require, "category_id < lctx->category_count");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(module == ((const struct isc_logmodule *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = module->id < lctx->module_count ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1068, (enum anonymous$46)isc_assertiontype_require, "module == ((void *)0) || module->id < lctx->module_count");
    (_Bool)0;
  }
  if(!(channel == ((struct isc_logchannel *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1069, (enum anonymous$46)isc_assertiontype_require, "channel != ((void *)0)");
    (_Bool)0;
  }
  result=sync_channellist(lcfg);
  if(!(result == 0u))
    return result;

  else
  {
    (void)lctx->mctx;
    void *return_value_ereallocz$3;
    return_value_ereallocz$3=ereallocz((void *)0, sizeof(struct isc_logchannellist) /*32ul*/ , (unsigned long int)0, 0);
    new_item = (struct isc_logchannellist *)return_value_ereallocz$3;
    if(new_item == ((struct isc_logchannellist *)NULL))
      return (unsigned int)1;

    else
    {
      new_item->channel = channel;
      new_item->module = module;
      do
      {
        if(!((lcfg->channellists + (signed long int)category_id)->head == ((struct isc_logchannellist *)NULL)))
          (lcfg->channellists + (signed long int)category_id)->head->link.prev = new_item;

        else
          (lcfg->channellists + (signed long int)category_id)->tail = new_item;
        new_item->link.prev = (struct isc_logchannellist *)(void *)0;
        new_item->link.next = (lcfg->channellists + (signed long int)category_id)->head;
        (lcfg->channellists + (signed long int)category_id)->head = new_item;
      }
      while((_Bool)0);
      if(!(channel->type == 1u))
      {
        if(!(lcfg->highest_level >= channel->level))
          lcfg->highest_level = channel->level;

        if(channel->level == 0)
          lcfg->dynamic = (enum anonymous$11)isc_boolean_true;

      }

      return (unsigned int)0;
    }
  }
}

// atexit_ssl_cleanup
// file ssl_init.c line 40
void atexit_ssl_cleanup(void)
{
  if(!(ssl_init_done == 0))
  {
    ssl_init_done = 0;
    EVP_cleanup();
    ERR_free_strings();
  }

}

// atoint
// file atoint.c line 12
extern signed int atoint(const char *str, signed long int *ival)
{
  signed long int u;
  const char *cp;
  signed int isneg;
  signed int oflow_digit;
  cp = str;
  if((signed int)*cp == 45)
  {
    cp = cp + 1l;
    isneg = 1;
    oflow_digit = 56;
  }

  else
  {
    isneg = 0;
    oflow_digit = 55;
  }
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  const char *tmp_post$4;
  if((signed int)*cp == 0)
    return 0;

  else
  {
    u = (signed long int)0;
    while(!((signed int)*cp == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$1;
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
        return 0;

      if(u >= 214748365l)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        if(u == 214748364l)
          tmp_if_expr$2 = (signed int)*cp > oflow_digit ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        return 0;

      u = (u << 3) + (u << 1);
      tmp_post$4 = cp;
      cp = cp + 1l;
      u = u + (signed long int)((signed int)*tmp_post$4 - 48);
    }
    if(!(isneg == 0))
      *ival = -u;

    else
      *ival = u;
    return 1;
  }
}

// atolfp
// file atolfp.c line 30
extern signed int atolfp(const char *str, struct anonymous$20 *lfp)
{
  const char *cp;
  unsigned long int dec_i;
  unsigned long int dec_f;
  char *ind;
  signed int ndec;
  signed int isneg;
  if(!(str == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("atolfp.c", 43, (enum anonymous$46)isc_assertiontype_require, "str != ((void *)0)");
    (_Bool)0;
  }
  isneg = 0;
  dec_f = (unsigned long int)0;
  dec_i = dec_f;
  ndec = 0;
  cp = str;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
      break;

    cp = cp + 1l;
  }
  while((_Bool)1);
  if((signed int)*cp == 45)
  {
    cp = cp + 1l;
    isneg = 1;
  }

  if((signed int)*cp == 43)
    cp = cp + 1l;

  const unsigned short int **return_value___ctype_b_loc$2;
  const unsigned short int **return_value___ctype_b_loc$6;
  const char *tmp_post$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  if(!((signed int)*cp == 46))
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)*cp]) == 0))
      goto __CPROVER_DUMP_L8;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    static const char *digits = "0123456789";
    for( ; !((signed int)*cp == 0); cp = cp + 1l)
    {
      ind=strchr(digits, (signed int)*cp);
      if(ind == ((char *)NULL))
        break;

      dec_i = (dec_i << 3) + (dec_i << 1);
      dec_i = dec_i + (unsigned long int)(ind - digits);
    }
    if(!((signed int)*cp == 0))
    {
      return_value___ctype_b_loc$6=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
      {
        tmp_post$3 = cp;
        cp = cp + 1l;
        if(!((signed int)*tmp_post$3 == 46))
          return 0;

        for( ; !(ndec >= 9); cp = cp + 1l)
        {
          if((signed int)*cp == 0)
            break;

          ind=strchr(digits, (signed int)*cp);
          if(ind == ((char *)NULL))
            break;

          ndec = ndec + 1;
          dec_f = (dec_f << 3) + (dec_f << 1);
          dec_f = dec_f + (unsigned long int)(ind - digits);
        }
        do
        {
          return_value___ctype_b_loc$4=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
            break;

          cp = cp + 1l;
        }
        while((_Bool)1);
        if(!((signed int)*cp == 0))
        {
          return_value___ctype_b_loc$5=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
            return 0;

        }

      }

    }

    if(ndec >= 1)
    {
      unsigned long int tmp;
      unsigned long int bit;
      unsigned long int ten_fact = ten_to_the_n[(signed long int)ndec];
      tmp = (unsigned long int)0;
      bit = (unsigned long int)0x80000000;
      for( ; !(bit == 0ul); bit = bit >> 1)
      {
        dec_f = dec_f << 1;
        if(dec_f >= ten_fact)
        {
          tmp = tmp | bit;
          dec_f = dec_f - ten_fact;
        }

      }
      if(!(ten_fact >= dec_f << 1))
        tmp = tmp + 1ul;

      dec_f = tmp;
    }

    if(!(isneg == 0))
      do
      {
        dec_f = ~dec_f + (unsigned long int)1u;
        dec_i = ~dec_i + (unsigned long int)(dec_f == (unsigned long int)0);
      }
      while((_Bool)0);

    lfp->Ul_i.Xl_ui = (unsigned int)dec_i;
    lfp->l_uf = (unsigned int)dec_f;
    return 1;
  }
}

// atouint
// file atouint.c line 17
extern signed int atouint(const char *str, unsigned long int *uval)
{
  unsigned long int u;
  const char *cp = str;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  const char *tmp_post$4;
  if((signed int)*cp == 0)
    return 0;

  else
  {
    u = (unsigned long int)0;
    while(!((signed int)*cp == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$1;
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
        return 0;

      if(u >= 429496730ul)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        if(u == 429496729ul)
          tmp_if_expr$2 = (signed int)*cp >= 54 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        return 0;

      u = (u << 3) + (u << 1);
      tmp_post$4 = cp;
      cp = cp + 1l;
      u = u + (unsigned long int)((signed int)*tmp_post$4 - 48);
    }
    *uval = u;
    return 1;
  }
}

// audio_config_read
// file audio.c line 115
static void audio_config_read(signed int unit, const char **c_dev, const char **i_dev)
{
  struct _IO_FILE *fd;
  char device[20l];
  char line[100l];
  char ab[100l];
  snprintf(device, sizeof(char [20l]) /*20ul*/ , "%s%d", (const void *)"/etc/ntp.audio", unit);
  fd=fopen(device, "r");
  char *return_value_fgets$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  const unsigned short int **return_value___ctype_b_loc$7;
  const unsigned short int **return_value___ctype_b_loc$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$16;
  const unsigned short int **return_value___ctype_b_loc$14;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$28;
  signed int return_value_sscanf$27;
  signed int return_value_strncmp$23;
  _Bool tmp_if_expr$25;
  signed int return_value_sscanf$24;
  signed int return_value_strncmp$20;
  _Bool tmp_if_expr$22;
  signed int return_value_sscanf$21;
  signed int return_value_strncmp$19;
  signed int return_value_sscanf$18;
  if(fd == ((struct _IO_FILE *)NULL))
  {
    printf("audio_config_read: <%s> NO\n", (const void *)device);
    snprintf(device, sizeof(char [20l]) /*20ul*/ , "%s.%d", (const void *)"/etc/ntp.audio", unit);
    fd=fopen(device, "r");
    if(!(fd == ((struct _IO_FILE *)NULL)))
      goto __CPROVER_DUMP_L1;

    printf("audio_config_read: <%s> NO\n", (const void *)device);
    snprintf(device, sizeof(char [20l]) /*20ul*/ , "%s", (const void *)"/etc/ntp.audio");
    fd=fopen(device, "r");
    if(!(fd == ((struct _IO_FILE *)NULL)))
      goto __CPROVER_DUMP_L1;

    printf("audio_config_read: <%s> NO\n", (const void *)device);
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    printf("audio_config_read: reading <%s>\n", (const void *)device);
    do
    {
      return_value_fgets$1=fgets(line, (signed int)sizeof(char [100l]) /*100ul*/ , fd);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      char *cp;
      char *cc;
      char *ca;
      signed int i;
      cp=strchr(line, 35);
      if(!(cp == ((char *)NULL)))
        *cp = (char)0;

      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(line);
      i = (signed int)return_value_strlen$2;
      do
      {
        if(i >= 1)
          tmp_if_expr$3 = ((signed int)(unsigned char)line[(signed long int)(i - 1)] & ~0x7f) == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          return_value___ctype_b_loc$4=__ctype_b_loc();
          tmp_if_expr$5 = ((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned char)line[(signed long int)(i - 1)]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5 = (_Bool)0;
        if(!tmp_if_expr$5)
          break;

        i = i - 1;
        line[(signed long int)i] = (char)0;
      }
      while((_Bool)1);
      cc = line;
      do
      {
        if(!(*cc == 0))
          tmp_if_expr$6 = ((signed int)(unsigned char)*cc & ~0x7f) == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
        {
          return_value___ctype_b_loc$7=__ctype_b_loc();
          tmp_if_expr$8 = ((signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)(unsigned char)*cc] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$8 = (_Bool)0;
        if(!tmp_if_expr$8)
          break;

        cc = cc + 1l;
      }
      while((_Bool)1);
      if(!(*cc == 0))
      {
        ca = cc;
        for( ; !(*ca == 0); ca = ca + 1l)
          if((-128 & (signed int)(unsigned char)*ca) == 0)
          {
            const unsigned short int **return_value___ctype_b_loc$12;
            return_value___ctype_b_loc$12=__ctype_b_loc();
            if(!((512 & (signed int)(*return_value___ctype_b_loc$12)[(signed long int)(signed int)(unsigned char)*ca]) == 0))
            {
              signed int return_value_toupper$9;
              return_value_toupper$9=toupper((signed int)(unsigned char)*ca);
              *ca = (char)return_value_toupper$9;
            }

            else
            {
              return_value___ctype_b_loc$10=__ctype_b_loc();
              if(!((8192 & (signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)(unsigned char)*ca]) == 0))
                tmp_if_expr$11 = (_Bool)1;

              else
                tmp_if_expr$11 = (signed int)*ca == 61 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$11)
                break;

            }
          }

        do
        {
          if(!(*ca == 0))
            tmp_if_expr$13 = ((signed int)(unsigned char)*ca & ~0x7f) == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$13 = (_Bool)0;
          if(tmp_if_expr$13)
          {
            return_value___ctype_b_loc$14=__ctype_b_loc();
            if(!((8192 & (signed int)(*return_value___ctype_b_loc$14)[(signed long int)(signed int)(unsigned char)*ca]) == 0))
              tmp_if_expr$15 = (_Bool)1;

            else
              tmp_if_expr$15 = (signed int)*ca == 61 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$16 = tmp_if_expr$15 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$16 = (_Bool)0;
          if(!tmp_if_expr$16)
            break;

          ca = ca + 1l;
        }
        while((_Bool)1);
        signed int return_value_strncmp$26;
        return_value_strncmp$26=strncmp(cc, "IDEV", (unsigned long int)4);
        if(return_value_strncmp$26 == 0)
        {
          return_value_sscanf$27=sscanf(ca, "%99s", (const void *)ab);
          tmp_if_expr$28 = 1 == return_value_sscanf$27 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$28 = (_Bool)0;
        if(tmp_if_expr$28)
        {
          strlcpy(cf_i_dev, ab, sizeof(char [100l]) /*100ul*/ );
          printf("idev <%s>\n", (const void *)ab);
        }

        else
        {
          return_value_strncmp$23=strncmp(cc, "CDEV", (unsigned long int)4);
          if(return_value_strncmp$23 == 0)
          {
            return_value_sscanf$24=sscanf(ca, "%99s", (const void *)ab);
            tmp_if_expr$25 = 1 == return_value_sscanf$24 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$25 = (_Bool)0;
          if(tmp_if_expr$25)
          {
            strlcpy(cf_c_dev, ab, sizeof(char [100l]) /*100ul*/ );
            printf("cdev <%s>\n", (const void *)ab);
          }

          else
          {
            return_value_strncmp$20=strncmp(cc, "AGC", (unsigned long int)3);
            if(return_value_strncmp$20 == 0)
            {
              return_value_sscanf$21=sscanf(ca, "%99s", (const void *)ab);
              tmp_if_expr$22 = 1 == return_value_sscanf$21 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$22 = (_Bool)0;
            if(tmp_if_expr$22)
            {
              strlcpy(cf_agc, ab, sizeof(char [100l]) /*100ul*/ );
              printf("agc <%s> %d\n", (const void *)ab, i);
            }

            else
            {
              return_value_strncmp$19=strncmp(cc, "MONITOR", (unsigned long int)7);
              if(return_value_strncmp$19 == 0)
              {
                return_value_sscanf$18=sscanf(ca, "%99s", (const void *)ab);
                if(return_value_sscanf$18 == 1)
                {
                  strlcpy(cf_monitor, ab, sizeof(char [100l]) /*100ul*/ );
                  signed int return_value_mixer_name$17;
                  return_value_mixer_name$17=mixer_name(ab, -1);
                  printf("monitor <%s> %d\n", (const void *)ab, return_value_mixer_name$17);
                }

              }

            }
          }
        }
      }

    }
    while((_Bool)1);
    fclose(fd);
    goto __CPROVER_DUMP_L42;
  }

__CPROVER_DUMP_L42:
  ;
}

// audio_gain
// file audio.c line 367
signed int audio_gain(signed int gain, signed int mongain, signed int port)
{
  signed int rval;
  signed int l;
  signed int r;
  l = (100 * gain) / 255;
  r = l;
  l = l | r << 8;
  if(!((signed int)cf_agc[0l] == 0))
    rval=ioctl(ctl_fd, (unsigned long int)agc, &l);

  else
    rval=ioctl(ctl_fd, 2 == port ? (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(6 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8 : (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(7 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &l);
  if(rval == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    printf("audio_gain: agc write: %s\n", return_value_strerror$2);
    return rval;
  }

  static signed int o_mongain = -1;
  if(!(o_mongain == mongain))
  {
    l = (100 * mongain) / 255;
    r = l;
    l = l | r << 8;
    if(!((signed int)cf_monitor[0l] == 0))
      rval=ioctl(ctl_fd, (unsigned long int)monitor, &l);

    else
      rval=ioctl(ctl_fd, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(0 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &l);
    if(rval == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      printf("audio_gain: mongain write: %s\n", return_value_strerror$4);
      return rval;
    }

    o_mongain = mongain;
  }

  static signed int o_port = -1;
  if(!(o_port == port))
  {
    l = 1 << (port == 2 ? 6 : 7);
    rval=ioctl(ctl_fd, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(0xff << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &l);
    if(rval == -1)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      printf("SOUND_MIXER_WRITE_RECSRC: %s\n", return_value_strerror$6);
      return rval;
    }

    o_port = port;
  }

  return rval;
}

// audio_init
// file audio.c line 212
signed int audio_init(const char *dname, signed int bufsiz, signed int unit)
{
  char actl_dev[30l];
  signed int fd;
  signed int rval;
  const char *actl = actl_dev;
  snprintf(actl_dev, sizeof(char [30l]) /*30ul*/ , "/dev/mixer%d", unit);
  audio_config_read(unit, &actl, &dname);
  if(!(cf_c_dev[0l] == 0))
    actl = cf_c_dev;

  if(!(cf_i_dev[0l] == 0))
    dname = cf_i_dev;

  fd=open(dname, 02 | 04000, 0777);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$7;
  char *return_value_strerror$8;
  if(!(fd >= 0))
  {
    msyslog(3, "audio_init: %s %m", dname);
    return fd;
  }

  else
  {
    ctl_fd=open(actl, 02);
    if(!(ctl_fd >= 0))
    {
      msyslog(3, "audio_init: invalid control device <%s>", actl);
      close(fd);
      return ctl_fd;
    }

    else
    {
      printf("audio_init: <%s> bufsiz %d\n", dname, bufsiz);
      rval = fd;
      signed int tmp = (16 << 16) + 6;
      signed int return_value_ioctl$3;
      return_value_ioctl$3=ioctl(fd, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(80 << 0 + 8) | (unsigned int)(10 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &tmp);
      if(return_value_ioctl$3 == -1)
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        printf("audio_init: SNDCTL_DSP_SETFRAGMENT: %s\n", return_value_strerror$2);
      }

      signed int return_value_ioctl$6;
      return_value_ioctl$6=ioctl(ctl_fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(0xfe << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &devmask);
      if(return_value_ioctl$6 == -1)
      {
        return_value___errno_location$4=__errno_location();
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        printf("SOUND_MIXER_READ_DEVMASK: %s\n", return_value_strerror$5);
      }

      signed int return_value_ioctl$9;
      return_value_ioctl$9=ioctl(ctl_fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(0xfd << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &recmask);
      if(return_value_ioctl$9 == -1)
      {
        return_value___errno_location$7=__errno_location();
        return_value_strerror$8=strerror(*return_value___errno_location$7);
        printf("SOUND_MIXER_READ_RECMASK: %s\n", return_value_strerror$8);
      }

      if(!((signed int)cf_agc[0l] == 0))
      {
        signed int i;
        i=mixer_name(cf_agc, recmask);
        if(i >= 0)
          agc = (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(i << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8);

        else
          printf("input %s not in recmask %#x\n", (const void *)cf_agc, recmask);
      }

      if(!((signed int)cf_monitor[0l] == 0))
      {
        signed int audio_init$$1$$5$$i;
        audio_init$$1$$5$$i=mixer_name(cf_monitor, devmask);
        if(audio_init$$1$$5$$i >= 0)
          monitor = (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(audio_init$$1$$5$$i << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8);

        else
          printf("monitor %s not in devmask %#x\n", (const void *)cf_monitor, devmask);
      }

      return rval;
    }
  }
}

// audio_show
// file audio.c line 477
void audio_show(void)
{
  signed int recsrc = 0;
  printf("audio_show: ctl_fd %d\n", ctl_fd);
  signed int return_value_ioctl$3;
  return_value_ioctl$3=ioctl(ctl_fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(77 << 0 + 8) | (unsigned int)(0xff << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &recsrc);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(return_value_ioctl$3 == -1)
  {
    return_value___errno_location$1=__errno_location();
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    printf("SOUND_MIXER_READ_RECSRC: %s\n", return_value_strerror$2);
  }

}

// auth_agekeys
// file authkeys.c line 624
extern void auth_agekeys(void)
{
  struct savekey *sk;
  struct savekey *i_dl_nextiter;
  sk = key_listhead.llink.f;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(sk == &key_listhead))
    {
      i_dl_nextiter = sk->llink.f;
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    if(sk->lifetime >= 1ul)
    {
      if(!(sk->lifetime >= current_time))
      {
        freesymkey(sk, &key_hash[(signed long int)(sk->keyid & (unsigned int)authhashmask)]);
        authkeyexpired = authkeyexpired + 1ul;
      }

    }

    sk = i_dl_nextiter;
  }
  while((_Bool)1);

__CPROVER_DUMP_L6:
  ;
}

// auth_delkeys
// file authkeys.c line 592
extern void auth_delkeys(void)
{
  struct savekey *sk;
  struct savekey *i_dl_nextiter;
  sk = key_listhead.llink.f;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(sk == &key_listhead))
    {
      i_dl_nextiter = sk->llink.f;
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    if(!(sk->keyid >= 65536u))
    {
      if(!((0x001 & (signed int)sk->flags) == 0))
      {
        if(!(sk->secret == ((unsigned char *)NULL)))
        {
          memset((void *)sk->secret, 0, (unsigned long int)sk->secretsize);
          free((void *)sk->secret);
          sk->secret = (unsigned char *)(void *)0;
        }

        sk->secretsize = (unsigned short int)0;
        sk->lifetime = (unsigned long int)0;
      }

      else
        freesymkey(sk, &key_hash[(signed long int)(sk->keyid & (unsigned int)authhashmask)]);
    }

    sk = i_dl_nextiter;
  }
  while((_Bool)1);
}

// auth_findkey
// file authkeys.c line 322
extern struct savekey * auth_findkey(unsigned int id)
{
  struct savekey *sk = key_hash[(signed long int)(id & (unsigned int)authhashmask)];
  for( ; !(sk == ((struct savekey *)NULL)); sk = sk->hlink)
    if(id == sk->keyid)
      return sk;

  return (struct savekey *)(void *)0;
}

// auth_havekey
// file authkeys.c line 342
extern signed int auth_havekey(unsigned int id)
{
  struct savekey *sk;
  if(id == 0u || cache_keyid == id)
    return 1;

  else
  {
    sk = key_hash[(signed long int)(id & (unsigned int)authhashmask)];
    for( ; !(sk == ((struct savekey *)NULL)); sk = sk->hlink)
      if(id == sk->keyid)
        return 1;

    return 0;
  }
}

// auth_log2
// file authkeys.c line 214
static inline unsigned short int auth_log2(double x)
{
  double return_value_log10$1;
  return_value_log10$1=log10(x);
  double return_value_log10$2;
  return_value_log10$2=log10((double)2);
  return (unsigned short int)(return_value_log10$1 / return_value_log10$2);
}

// auth_moremem
// file authkeys.c line 159
extern void auth_moremem(signed int keycount)
{
  struct savekey *sk;
  signed int i = keycount > 0 ? keycount : 16;
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, (unsigned long int)i * sizeof(struct savekey) /*56ul*/  + (unsigned long int)0, (unsigned long int)0, 1);
  sk = (struct savekey *)return_value_ereallocz$1;
  authnumfreekeys = authnumfreekeys + i;
  for( ; i >= 1; sk = sk + 1l)
  {
    do
    {
      sk->llink.f = authfreekeys;
      authfreekeys = sk;
    }
    while((_Bool)0);
    i = i - 1;
  }
}

// auth_prealloc_symkeys
// file authkeys.c line 198
extern void auth_prealloc_symkeys(signed int keycount)
{
  signed int allocated;
  signed int additional;
  allocated = (signed int)(authnumkeys + (unsigned long int)authnumfreekeys);
  additional = keycount - allocated;
  if(additional >= 1)
    auth_moremem(additional);

  auth_resize_hashtable();
}

// auth_resize_hashtable
// file authkeys.c line 228
static void auth_resize_hashtable(void)
{
  unsigned long int totalkeys;
  unsigned short int hashbits;
  unsigned short int hash;
  unsigned long int newalloc;
  struct savekey *sk;
  totalkeys = authnumkeys + (unsigned long int)authnumfreekeys;
  unsigned short int return_value_auth_log2$1;
  return_value_auth_log2$1=auth_log2((double)totalkeys / 4.0);
  hashbits = (unsigned short int)((signed int)return_value_auth_log2$1 + 1);
  hashbits = (unsigned short int)(4 > (signed int)hashbits ? 4 : (signed int)hashbits);
  hashbits = (unsigned short int)(15 < (signed int)hashbits ? 15 : (signed int)hashbits);
  authhashbuckets = (unsigned short int)(1 << (signed int)hashbits);
  authhashmask = (unsigned short int)((signed int)authhashbuckets - 1);
  newalloc = (unsigned long int)authhashbuckets * sizeof(struct savekey *) /*8ul*/ ;
  void *return_value_ereallocz$2;
  return_value_ereallocz$2=ereallocz((void *)key_hash, newalloc, (unsigned long int)0, 0);
  key_hash = (struct savekey **)return_value_ereallocz$2;
  memset((void *)key_hash, 0, newalloc);
  struct savekey *i_dl_nextiter;
  sk = key_listhead.llink.f;
  _Bool tmp_if_expr$3;
  do
  {
    if(!(sk == &key_listhead))
    {
      i_dl_nextiter = sk->llink.f;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    hash = (unsigned short int)(sk->keyid & (unsigned int)authhashmask);
    do
    {
      sk->hlink = key_hash[(signed long int)hash];
      key_hash[(signed long int)hash] = sk;
    }
    while((_Bool)0);
    sk = i_dl_nextiter;
  }
  while((_Bool)1);
}

// authdecrypt
// file authkeys.c line 675
extern signed int authdecrypt(unsigned int keyno, unsigned int *pkt, signed int length, signed int size)
{
  authdecryptions = authdecryptions + 1ul;
  _Bool tmp_if_expr$2;
  signed int return_value_authhavekey$1;
  if(keyno == 0u)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_authhavekey$1=authhavekey(keyno);
    tmp_if_expr$2 = !(return_value_authhavekey$1 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(!(size >= 4) || tmp_if_expr$2)
    return 0;

  else
  {
    signed int return_value_MD5authdecrypt$3;
    return_value_MD5authdecrypt$3=MD5authdecrypt(cache_type, cache_secret, pkt, length, size);
    return return_value_MD5authdecrypt$3;
  }
}

// authencrypt
// file authkeys.c line 645
extern signed int authencrypt(unsigned int keyno, unsigned int *pkt, signed int length)
{
  authencryptions = authencryptions + 1ul;
  pkt[(signed long int)(length / 4)]=htonl(keyno);
  if(keyno == 0u)
    return 4;

  else
  {
    signed int return_value_authhavekey$1;
    return_value_authhavekey$1=authhavekey(keyno);
    if(return_value_authhavekey$1 == 0)
      return 0;

    else
    {
      signed int return_value_MD5authencrypt$2;
      return_value_MD5authencrypt$2=MD5authencrypt(cache_type, cache_secret, pkt, length);
      return return_value_MD5authencrypt$2;
    }
  }
}

// authhavekey
// file authkeys.c line 367
extern signed int authhavekey(unsigned int id)
{
  struct savekey *sk;
  authkeylookups = authkeylookups + 1ul;
  if(id == 0u || cache_keyid == id)
    return 1;

  else
  {
    authkeyuncached = authkeyuncached + 1ul;
    sk = key_hash[(signed long int)(id & (unsigned int)authhashmask)];
    for( ; !(sk == ((struct savekey *)NULL)); sk = sk->hlink)
      if(id == sk->keyid)
      {
        if((signed int)sk->type == 0)
        {
          authkeynotfound = authkeynotfound + 1ul;
          return 0;
        }

        break;
      }

    if(sk == ((struct savekey *)NULL))
    {
      authkeynotfound = authkeynotfound + 1ul;
      return 0;
    }

    else
      if((0x001 & (signed int)sk->flags) == 0)
      {
        authnokey = authnokey + 1ul;
        return 0;
      }

      else
      {
        cache_keyid = sk->keyid;
        cache_type = (signed int)sk->type;
        cache_flags = sk->flags;
        cache_secret = sk->secret;
        cache_secretsize = sk->secretsize;
        return 1;
      }
  }
}

// authistrusted
// file authkeys.c line 491
extern signed int authistrusted(unsigned int keyno)
{
  struct savekey *sk;
  struct savekey **bucket;
  _Bool tmp_if_expr$1;
  if(keyno == cache_keyid)
    return (signed int)!(!((0x001 & (signed int)cache_flags) != 0));

  else
  {
    authkeyuncached = authkeyuncached + 1ul;
    bucket = &key_hash[(signed long int)(keyno & (unsigned int)authhashmask)];
    sk = *bucket;
    for( ; !(sk == ((struct savekey *)NULL)); sk = sk->hlink)
      if(keyno == sk->keyid)
        break;

    if(sk == ((struct savekey *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !((0x001 & (signed int)sk->flags) != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      authkeynotfound = authkeynotfound + 1ul;
      return 0;
    }

    else
      return 1;
  }
}

// authreadkeys
// file authreadkeys.c line 103
extern signed int authreadkeys(const char *file)
{
  struct _IO_FILE *fp;
  char *line;
  char *token;
  unsigned int keyno;
  signed int keytype;
  char buf[512l];
  unsigned char keystr[32l];
  unsigned long int len;
  unsigned long int j;
  unsigned long int nerr;
  fp=fopen(file, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    msyslog(3, "authreadkeys: file %s: %m", file);
    return 0;
  }

  else
  {
    do
      if(ssl_init_done == 0)
        ssl_init();

    while((_Bool)0);
    auth_delkeys();
    nerr = (unsigned long int)0;
    do
    {
      line=fgets(buf, (signed int)sizeof(char [512l]) /*512ul*/ , fp);
      if(line == ((char *)NULL))
        break;

      if(!(nerr_maxlimit >= nerr))
        break;

      token=nexttok(&line);
      if(!(token == ((char *)NULL)))
      {
        signed int return_value_atoi$1;
        return_value_atoi$1=atoi(token);
        keyno = (unsigned int)return_value_atoi$1;
        if(keyno == 0u)
          log_maybe(&nerr, "authreadkeys: cannot change key %s", token);

        else
          if(keyno >= 65536u)
            log_maybe(&nerr, "authreadkeys: key %s > %d reserved for Autokey", token, 65535);

          else
          {
            token=nexttok(&line);
            if(token == ((char *)NULL))
              log_maybe(&nerr, "authreadkeys: no key type for key %d", keyno);

            else
            {
              keytype=keytype_from_text(token, (unsigned long int *)(void *)0);
              if(keytype == 0)
                log_maybe(&nerr, "authreadkeys: invalid type for key %d", keyno);

              else
              {
                const char *return_value_OBJ_nid2sn$2;
                return_value_OBJ_nid2sn$2=OBJ_nid2sn(keytype);
                const struct env_md_st *return_value_EVP_get_digestbyname$3;
                return_value_EVP_get_digestbyname$3=EVP_get_digestbyname(return_value_OBJ_nid2sn$2);
                if(return_value_EVP_get_digestbyname$3 == ((const struct env_md_st *)NULL))
                  log_maybe(&nerr, "authreadkeys: no algorithm for key %d", keyno);

                else
                {
                  token=nexttok(&line);
                  if(token == ((char *)NULL))
                    log_maybe(&nerr, "authreadkeys: no key for key %d", keyno);

                  else
                  {
                    len=strlen(token);
                    if(!(len >= 21ul))
                      MD5auth_setkey(keyno, keytype, (unsigned char *)token, len);

                    else
                    {
                      char hex[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
                      unsigned char temp;
                      char *ptr;
                      unsigned long int jlim = len < (unsigned long int)2 * sizeof(unsigned char [32l]) /*32ul*/  ? len : (unsigned long int)2 * sizeof(unsigned char [32l]) /*32ul*/ ;
                      j = (unsigned long int)0;
                      for( ; !(j >= jlim); j = j + 1ul)
                      {
                        signed int return_value_tolower$4;
                        return_value_tolower$4=tolower((signed int)(unsigned char)token[(signed long int)j]);
                        ptr=strchr(hex, return_value_tolower$4);
                        if(ptr == ((char *)NULL))
                          break;

                        temp = (unsigned char)(ptr - hex);
                        if(!((1ul & j) == 0ul))
                          keystr[(signed long int)(j / (unsigned long int)2)] = keystr[(signed long int)(j / (unsigned long int)2)] | temp;

                        else
                          keystr[(signed long int)(j / (unsigned long int)2)] = (unsigned char)((signed int)temp << 4);
                      }
                      if(!(j >= jlim))
                      {
                        log_maybe(&nerr, "authreadkeys: invalid hex digit for key %d", keyno);
                        continue;
                      }

                      MD5auth_setkey(keyno, keytype, keystr, jlim / (unsigned long int)2);
                    }
                  }
                }
              }
            }
          }
      }

    }
    while((_Bool)1);
    fclose(fp);
    if(!(nerr_maxlimit >= nerr))
    {
      msyslog(3, "authreadkeys: emergency break after %u errors", nerr);
      return 0;
    }

    else
      if(!(nerr_loglimit >= nerr))
        msyslog(3, "authreadkeys: found %u more error(s)", nerr - nerr_loglimit);

    return 1;
  }
}

// authtrust
// file authkeys.c line 424
extern void authtrust(unsigned int id, unsigned long int trust)
{
  struct savekey **bucket;
  struct savekey *sk;
  unsigned long int lifetime;
  bucket = &key_hash[(signed long int)(id & (unsigned int)authhashmask)];
  sk = *bucket;
  for( ; !(sk == ((struct savekey *)NULL)); sk = sk->hlink)
    if(id == sk->keyid)
      break;

  if(!(sk == ((struct savekey *)NULL)) || !(trust == 0ul))
  {
    if(!(sk == ((struct savekey *)NULL)))
    {
      if(cache_keyid == id)
      {
        cache_flags = (unsigned short int)0;
        cache_keyid = (unsigned int)0;
      }

      if(trust >= 1ul)
      {
        sk->flags = sk->flags | (unsigned short int)0x001;
        if(trust >= 2ul)
          sk->lifetime = current_time + trust;

        else
          sk->lifetime = (unsigned long int)0;
        goto __CPROVER_DUMP_L11;
      }

      freesymkey(sk, bucket);
    }

    else
    {
      if(trust >= 2ul)
        lifetime = current_time + trust;

      else
        lifetime = (unsigned long int)0;
      allocsymkey(bucket, id, (unsigned short int)0x001, (unsigned short int)0, lifetime, (unsigned short int)0, (unsigned char *)(void *)0);
    }
  }


__CPROVER_DUMP_L11:
  ;
}

// authusekey
// file authusekey.c line 20
extern signed int authusekey(unsigned int keyno, signed int keytype, const unsigned char *str)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen((const char *)str);
  len = (signed int)return_value_strlen$1;
  if(len == 0)
    return 0;

  else
  {
    MD5auth_setkey(keyno, keytype, str, (unsigned long int)len);
    return 1;
  }
}

// available_blocking_child_slot
// file ntp_worker.c line 127
extern unsigned int available_blocking_child_slot(void)
{
  const unsigned long int each = sizeof(struct blocking_child_tag *) /*8ul*/ ;
  unsigned int slot;
  unsigned long int prev_alloc;
  unsigned long int new_alloc;
  unsigned long int prev_octets;
  unsigned long int octets;
  slot = (unsigned int)0;
  for( ; !((unsigned long int)slot >= blocking_children_alloc); slot = slot + 1u)
  {
    if(blocking_children[(signed long int)slot] == ((struct blocking_child_tag *)NULL))
      return slot;

    if(!(blocking_children[(signed long int)slot]->reusable == 0))
    {
      blocking_children[(signed long int)slot]->reusable = 0;
      return slot;
    }

  }
  prev_alloc = blocking_children_alloc;
  prev_octets = prev_alloc * each;
  new_alloc = blocking_children_alloc + (unsigned long int)4;
  octets = new_alloc * each;
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)blocking_children, octets, prev_octets, 1);
  blocking_children = (struct blocking_child_tag **)return_value_ereallocz$1;
  blocking_children_alloc = new_alloc;
  return (unsigned int)prev_alloc;
}

// badopt
// file getopt.c line 38
static signed int badopt(const char *mess, signed int ch)
{
  if(!(ntp_opterr == 0))
  {
    fputs(prog, stderr);
    fputs(mess, stderr);
    _IO_putc(ch, stderr);
    _IO_putc(10, stderr);
  }

  return 63;
}

// block_thread_signals
// file work_thread.c line 502
static void block_thread_signals(struct anonymous$25 *pmask)
{
  struct anonymous$25 block;
  sigemptyset(&block);
  sigaddset(&block, 14);
  sigaddset(&block, 10);
  sigaddset(&block, 12);
  sigaddset(&block, 1);
  sigaddset(&block, 2);
  sigaddset(&block, 3);
  sigaddset(&block, 15);
  sigaddset(&block, 7);
  sigemptyset(pmask);
  pthread_sigmask(0, &block, pmask);
}

// blocking_child_common
// file ntp_worker.c line 269
extern signed int blocking_child_common(struct blocking_child_tag *c)
{
  signed int say_bye;
  struct blocking_pipe_header_tag *req;
  say_bye = 0;
  signed int return_value_blocking_getaddrinfo$1;
  signed int return_value_blocking_getnameinfo$2;
  while(say_bye == 0)
  {
    req=receive_blocking_req_internal(c);
    if(req == ((struct blocking_pipe_header_tag *)NULL))
      say_bye = 1;

    else
    {

    __CPROVER_DUMP_L2:
      ;
      switch((signed int)req->rtype)
      {
        case BLOCKING_GETADDRINFO:
        {
          return_value_blocking_getaddrinfo$1=blocking_getaddrinfo(c, req);
          if(!(return_value_blocking_getaddrinfo$1 == 0))
            say_bye = 1;

          break;
        }
        case BLOCKING_GETNAMEINFO:
        {
          return_value_blocking_getnameinfo$2=blocking_getnameinfo(c, req);
          if(!(return_value_blocking_getnameinfo$2 == 0))
            say_bye = 1;

          break;
        }
        default:
        {
          msyslog(3, "unknown req %d to blocking worker", req->rtype);
          say_bye = 1;
        }
      }
      free((void *)req);
    }
  }
  return 0;
}

// blocking_getaddrinfo
// file ntp_intres.c line 303
extern signed int blocking_getaddrinfo(struct blocking_child_tag *c, struct blocking_pipe_header_tag *req)
{
  struct blocking_gai_req_tag *gai_req;
  struct dnsworker_ctx_tag *worker_ctx;
  struct blocking_pipe_header_tag *resp;
  struct blocking_gai_resp_tag *gai_resp;
  char *node;
  char *service;
  struct addrinfo *ai_res;
  struct addrinfo *ai;
  struct addrinfo *serialized_ai;
  unsigned long int canons_octets;
  unsigned long int this_octets;
  unsigned long int resp_octets;
  char *cp;
  signed long int time_now;
  gai_req = (struct blocking_gai_req_tag *)(void *)((char *)req + (signed long int)sizeof(struct blocking_pipe_header_tag) /*40ul*/ );
  node = (char *)gai_req + (signed long int)sizeof(struct blocking_gai_req_tag) /*120ul*/ ;
  service = node + (signed long int)gai_req->nodesize;
  worker_ctx=get_worker_context(c, gai_req->dns_idx);
  scheduled_sleep(gai_req->scheduled, gai_req->earliest, worker_ctx);
  reload_resolv_conf(worker_ctx);
  resp_octets = sizeof(struct blocking_pipe_header_tag) /*40ul*/  + sizeof(struct blocking_gai_resp_tag) /*24ul*/  + (unsigned long int)16 * (sizeof(struct addrinfo) /*48ul*/  + sizeof(union anonymous$47) /*28ul*/ ) + (unsigned long int)256;
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, resp_octets, (unsigned long int)0, 1);
  resp = (struct blocking_pipe_header_tag *)return_value_ereallocz$1;
  gai_resp = (struct blocking_gai_resp_tag *)(void *)(resp + (signed long int)1);
  do
    if(debug >= 2)
      mprintf("blocking_getaddrinfo given node %s serv %s fam %d flags %x\n", node, service, gai_req->hints.ai_family, gai_req->hints.ai_flags);

  while((_Bool)0);
  ai_res = (struct addrinfo *)(void *)0;
  gai_resp->retcode=getaddrinfo(node, service, &gai_req->hints, &ai_res);
  gai_resp->retry = gai_req->retry;
  signed int *return_value___errno_location$2;
  if(gai_resp->retcode == -11)
  {
    return_value___errno_location$2=__errno_location();
    gai_resp->gai_errno = *return_value___errno_location$2;
  }

  canons_octets = (unsigned long int)0;
  unsigned long int return_value_strlen$3;
  const char *return_value_humantime$4;
  if(gai_resp->retcode == 0)
  {
    ai = ai_res;
    while(!(ai == ((struct addrinfo *)NULL)))
    {
      gai_resp->ai_count = gai_resp->ai_count + 1;
      if(!(ai->ai_canonname == ((char *)NULL)))
      {
        return_value_strlen$3=strlen(ai->ai_canonname);
        canons_octets = canons_octets + return_value_strlen$3 + (unsigned long int)1;
      }

      ai = ai->ai_next;
    }
    if(gai_resp->retry >= 3)
    {
      time_now=time((signed long int *)(void *)0);
      worker_ctx->ignore_scheduled_before = time_now;
      do
        if(debug >= 1)
        {
          return_value_humantime$4=humantime(time_now);
          mprintf("DNS success after retry, ignoring sleeps scheduled before now (%s)\n", return_value_humantime$4);
        }

      while((_Bool)0);
    }

  }

  gai_resp->octets = sizeof(struct blocking_gai_resp_tag) /*24ul*/  + (unsigned long int)gai_resp->ai_count * (sizeof(struct addrinfo) /*48ul*/  + sizeof(union anonymous$47) /*28ul*/ ) + canons_octets;
  resp_octets = sizeof(struct blocking_pipe_header_tag) /*40ul*/  + gai_resp->octets;
  void *return_value_ereallocz$5;
  return_value_ereallocz$5=ereallocz((void *)resp, resp_octets, (unsigned long int)0, 0);
  resp = (struct blocking_pipe_header_tag *)return_value_ereallocz$5;
  gai_resp = (struct blocking_gai_resp_tag *)(void *)(resp + (signed long int)1);
  cp = (char *)(void *)(gai_resp + (signed long int)1);
  canons_octets = (unsigned long int)0;
  if(gai_resp->retcode == 0)
  {
    ai = ai_res;
    for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
    {
      memcpy((void *)cp, (const void *)ai, sizeof(struct addrinfo) /*48ul*/ );
      serialized_ai = (struct addrinfo *)(void *)cp;
      cp = cp + (signed long int)sizeof(struct addrinfo) /*48ul*/ ;
      if(!(serialized_ai->ai_canonname == ((char *)NULL)))
      {
        serialized_ai->ai_canonname = (char *)canons_octets;
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(ai->ai_canonname);
        canons_octets = canons_octets + return_value_strlen$6 + (unsigned long int)1;
      }

    }
    ai = ai_res;
    for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
    {
      if(!((unsigned long int)ai->ai_addrlen >= 29ul))
        (_Bool)1;

      else
      {
        isc_assertion_failed("ntp_intres.c", 423, (enum anonymous$46)isc_assertiontype_insist, "ai->ai_addrlen <= sizeof(sockaddr_u)");
        (_Bool)0;
      }
      memcpy((void *)cp, (const void *)ai->ai_addr, (unsigned long int)ai->ai_addrlen);
      cp = cp + (signed long int)sizeof(union anonymous$47) /*28ul*/ ;
    }
    ai = ai_res;
    for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
      if(!(ai->ai_canonname == ((char *)NULL)))
      {
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(ai->ai_canonname);
        this_octets = return_value_strlen$7 + (unsigned long int)1;
        memcpy((void *)cp, (const void *)ai->ai_canonname, this_octets);
        cp = cp + (signed long int)this_octets;
      }

    freeaddrinfo(ai_res);
  }


__CPROVER_DUMP_L21:
  ;
  signed int return_value_queue_blocking_response$8;
  return_value_queue_blocking_response$8=queue_blocking_response(c, resp, resp_octets, req);
  if(!(return_value_queue_blocking_response$8 == 0))
  {
    msyslog(3, "blocking_getaddrinfo can not queue response");
    return -1;
  }

  else
    return 0;
}

// blocking_getnameinfo
// file ntp_intres.c line 676
extern signed int blocking_getnameinfo(struct blocking_child_tag *c, struct blocking_pipe_header_tag *req)
{
  struct blocking_gni_req_tag *gni_req;
  struct dnsworker_ctx_tag *worker_ctx;
  struct blocking_pipe_header_tag *resp;
  struct blocking_gni_resp_tag *gni_resp;
  unsigned long int octets;
  unsigned long int resp_octets;
  char *service;
  char *cp;
  signed int rc;
  signed long int time_now;
  char host[1024l];
  gni_req = (struct blocking_gni_req_tag *)(void *)((char *)req + (signed long int)sizeof(struct blocking_pipe_header_tag) /*40ul*/ );
  octets = gni_req->hostoctets + gni_req->servoctets;
  if(!(octets >= sizeof(char [1024l]) /*1024ul*/ ))
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_intres.c", 702, (enum anonymous$46)isc_assertiontype_require, "octets < sizeof(host)");
    (_Bool)0;
  }
  service = host + (signed long int)gni_req->hostoctets;
  worker_ctx=get_worker_context(c, gni_req->dns_idx);
  scheduled_sleep(gni_req->scheduled, gni_req->earliest, worker_ctx);
  reload_resolv_conf(worker_ctx);
  resp_octets = sizeof(struct blocking_pipe_header_tag) /*40ul*/  + sizeof(struct blocking_gni_resp_tag) /*40ul*/  + octets;
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, resp_octets, (unsigned long int)0, 1);
  resp = (struct blocking_pipe_header_tag *)return_value_ereallocz$1;
  gni_resp = (struct blocking_gni_resp_tag *)(void *)((char *)resp + (signed long int)sizeof(struct blocking_pipe_header_tag) /*40ul*/ );
  const char *return_value_socktoa$2;
  do
    if(debug >= 2)
    {
      return_value_socktoa$2=socktoa(&gni_req->socku);
      mprintf("blocking_getnameinfo given addr %s flags 0x%x hostlen %lu servlen %lu\n", return_value_socktoa$2, gni_req->flags, (unsigned long int)gni_req->hostoctets, (unsigned long int)gni_req->servoctets);
    }

  while((_Bool)0);
  gni_resp->retcode=getnameinfo(&gni_req->socku.sa, (unsigned int)(2 == (signed int)(&gni_req->socku)->sa.sa_family ? sizeof(struct sockaddr_in) /*16ul*/  : sizeof(struct sockaddr_in6) /*28ul*/ ), host, (unsigned int)gni_req->hostoctets, service, (unsigned int)gni_req->servoctets, gni_req->flags);
  gni_resp->retry = gni_req->retry;
  signed int *return_value___errno_location$3;
  if(gni_resp->retcode == -11)
  {
    return_value___errno_location$3=__errno_location();
    gni_resp->gni_errno = *return_value___errno_location$3;
  }

  const char *return_value_humantime$6;
  if(!(gni_resp->retcode == 0))
  {
    gni_resp->hostoctets = (unsigned long int)0;
    gni_resp->servoctets = (unsigned long int)0;
  }

  else
  {
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(host);
    gni_resp->hostoctets = return_value_strlen$4 + (unsigned long int)1;
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(service);
    gni_resp->servoctets = return_value_strlen$5 + (unsigned long int)1;
    if(gni_req->retry >= 3)
    {
      time_now=time((signed long int *)(void *)0);
      worker_ctx->ignore_scheduled_before = time_now;
      do
        if(debug >= 1)
        {
          return_value_humantime$6=humantime(time_now);
          mprintf("DNS success after retrying, ignoring sleeps scheduled before now (%s)\n", return_value_humantime$6);
        }

      while((_Bool)0);
    }

  }
  octets = gni_resp->hostoctets + gni_resp->servoctets;
  resp_octets = sizeof(struct blocking_pipe_header_tag) /*40ul*/  + sizeof(struct blocking_gni_resp_tag) /*40ul*/  + octets;
  void *return_value_ereallocz$7;
  return_value_ereallocz$7=ereallocz((void *)resp, resp_octets, (unsigned long int)0, 0);
  resp = (struct blocking_pipe_header_tag *)return_value_ereallocz$7;
  gni_resp = (struct blocking_gni_resp_tag *)(void *)(resp + (signed long int)1);
  gni_resp->octets = sizeof(struct blocking_gni_resp_tag) /*40ul*/  + octets;
  cp = (char *)(void *)(gni_resp + (signed long int)1);
  if(gni_resp->retcode == 0)
  {
    memcpy((void *)cp, (const void *)host, gni_resp->hostoctets);
    cp = cp + (signed long int)gni_resp->hostoctets;
    memcpy((void *)cp, (const void *)service, gni_resp->servoctets);
    cp = cp + (signed long int)gni_resp->servoctets;
  }

  if((unsigned long int)(cp - (char *)resp) == resp_octets)
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_intres.c", 778, (enum anonymous$46)isc_assertiontype_insist, "(size_t)(cp - (char *)resp) == resp_octets");
    (_Bool)0;
  }
  if(resp_octets + 18446744073709551576ul == gni_resp->octets)
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_intres.c", 779, (enum anonymous$46)isc_assertiontype_insist, "resp_octets - sizeof(*resp) == gni_resp->octets");
    (_Bool)0;
  }
  rc=queue_blocking_response(c, resp, resp_octets, req);
  if(!(rc == 0))
    msyslog(3, "blocking_getnameinfo unable to queue response");

  return rc;
}

// blocking_thread
// file work_thread.c line 656
void * blocking_thread(void *ThreadArg)
{
  struct blocking_child_tag *c = (struct blocking_child_tag *)ThreadArg;
  signed int return_value_blocking_child_common$1;
  return_value_blocking_child_common$1=blocking_child_common(c);
  exit_worker(return_value_blocking_child_common$1);
  return NULL;
}

// buftvtots
// file buftvtots.c line 16
extern signed int buftvtots(const char *bufp, struct anonymous$20 *ts)
{
  struct timeval tv;
  memcpy((void *)&tv, (const void *)bufp, sizeof(struct timeval) /*16ul*/ );
  if(tv.tv_usec >= 1000000l)
    return 0;

  else
  {
    *ts=tval_stamp_to_lfp(tv);
    return 1;
  }
}

// byteSwap
// file ./../lib/isc/md5.c line 71
static void byteSwap(unsigned int *buf, unsigned int words)
{
  unsigned char *p = (unsigned char *)buf;
  unsigned int *tmp_post$1;
  do
  {
    tmp_post$1 = buf;
    buf = buf + 1l;
    *tmp_post$1 = (unsigned int)((unsigned int)p[(signed long int)3] << 8 | (unsigned int)p[(signed long int)2]) << 16 | (unsigned int)p[(signed long int)1] << 8 | (unsigned int)p[(signed long int)0];
    p = p + (signed long int)4;
    words = words - 1u;
  }
  while(!(words == 0u));
}

// caldaystart
// file calyearstart.c line 79
extern unsigned int caldaystart(unsigned int ntptime, const signed long int *pivot)
{
  union anonymous$44 vlong;
  struct anonymous$61 split;
  vlong=ntpcal_ntp_to_ntp(ntptime, pivot);
  split=ntpcal_daysplit(&vlong);
  return ntptime - (unsigned int)split.lo;
}

// caljulian
// file caljulian.c line 22
extern void caljulian(unsigned int ntp, struct calendar *jt)
{
  union anonymous$44 vlong;
  struct anonymous$61 split;
  if(!(jt == ((struct calendar *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("caljulian.c", 31, (enum anonymous$46)isc_assertiontype_insist, "((void *)0) != jt");
    (_Bool)0;
  }
  vlong=ntpcal_ntp_to_ntp(ntp, (const signed long int *)(void *)0);
  split=ntpcal_daysplit(&vlong);
  ntpcal_daysplit_to_date(jt, &split, 693596);
}

// calmonthstart
// file calyearstart.c line 42
extern unsigned int calmonthstart(unsigned int ntptime, const signed long int *pivot)
{
  unsigned int ndays;
  union anonymous$44 vlong;
  struct anonymous$61 split;
  vlong=ntpcal_ntp_to_ntp(ntptime, pivot);
  split=ntpcal_daysplit(&vlong);
  signed int return_value_ntpcal_rd_to_mstart$1;
  return_value_ntpcal_rd_to_mstart$1=ntpcal_rd_to_mstart(split.hi + 693596);
  ndays = (unsigned int)(return_value_ntpcal_rd_to_mstart$1 - 693596);
  return (unsigned int)(ndays * (unsigned int)(60 * 60 * 24));
}

// caltontp
// file caltontp.c line 36
extern unsigned int caltontp(struct calendar *jt)
{
  signed int eraday;
  union anonymous$44 ntptime;
  if(!(jt == ((struct calendar *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("caltontp.c", 43, (enum anonymous$46)isc_assertiontype_require, "jt != ((void *)0)");
    (_Bool)0;
  }
  if(!((signed int)jt->month >= 14))
    (_Bool)1;

  else
  {
    isc_assertion_failed("caltontp.c", 45, (enum anonymous$46)isc_assertiontype_require, "jt->month <= 13");
    (_Bool)0;
  }
  if(!((signed int)jt->monthday >= 33))
    (_Bool)1;

  else
  {
    isc_assertion_failed("caltontp.c", 46, (enum anonymous$46)isc_assertiontype_require, "jt->monthday <= 32");
    (_Bool)0;
  }
  if(!((signed int)jt->yearday >= 367))
    (_Bool)1;

  else
  {
    isc_assertion_failed("caltontp.c", 47, (enum anonymous$46)isc_assertiontype_require, "jt->yearday <= 366");
    (_Bool)0;
  }
  if(!((signed int)jt->hour >= 25))
    (_Bool)1;

  else
  {
    isc_assertion_failed("caltontp.c", 48, (enum anonymous$46)isc_assertiontype_require, "jt->hour <= 24");
    (_Bool)0;
  }
  if(!((signed int)jt->minute >= 61))
    (_Bool)1;

  else
  {
    isc_assertion_failed("caltontp.c", 49, (enum anonymous$46)isc_assertiontype_require, "jt->minute <= (60)");
    (_Bool)0;
  }
  if(!((signed int)jt->second >= 61))
    (_Bool)1;

  else
  {
    isc_assertion_failed("caltontp.c", 50, (enum anonymous$46)isc_assertiontype_require, "jt->second <= (60)");
    (_Bool)0;
  }
  signed int return_value_ntpcal_year_to_ystart$1;
  if(!(jt->yearday == 0))
  {
    return_value_ntpcal_year_to_ystart$1=ntpcal_year_to_ystart((signed int)jt->year);
    eraday = (return_value_ntpcal_year_to_ystart$1 + (signed int)jt->yearday) - 1;
  }

  else
    eraday=ntpcal_date_to_rd(jt);
  signed int return_value_ntpcal_etime_to_seconds$2;
  return_value_ntpcal_etime_to_seconds$2=ntpcal_etime_to_seconds((signed int)jt->hour, (signed int)jt->minute, (signed int)jt->second);
  ntptime=ntpcal_dayjoin(eraday - 693596, return_value_ntpcal_etime_to_seconds$2);
  return ntptime.d_s.lo;
}

// calweekstart
// file calyearstart.c line 61
extern unsigned int calweekstart(unsigned int ntptime, const signed long int *pivot)
{
  unsigned int ndays;
  union anonymous$44 vlong;
  struct anonymous$61 split;
  vlong=ntpcal_ntp_to_ntp(ntptime, pivot);
  split=ntpcal_daysplit(&vlong);
  signed int return_value_ntpcal_weekday_le$1;
  return_value_ntpcal_weekday_le$1=ntpcal_weekday_le(split.hi + 693596, 1);
  ndays = (unsigned int)(return_value_ntpcal_weekday_le$1 - 693596);
  return (unsigned int)(ndays * (unsigned int)(60 * 60 * 24));
}

// calyearstart
// file calyearstart.c line 23
extern unsigned int calyearstart(unsigned int ntptime, const signed long int *pivot)
{
  unsigned int ndays;
  union anonymous$44 vlong;
  struct anonymous$61 split;
  vlong=ntpcal_ntp_to_ntp(ntptime, pivot);
  split=ntpcal_daysplit(&vlong);
  signed int return_value_ntpcal_rd_to_ystart$1;
  return_value_ntpcal_rd_to_ystart$1=ntpcal_rd_to_ystart(split.hi + 693596);
  ndays = (unsigned int)(return_value_ntpcal_rd_to_ystart$1 - 693596);
  return (unsigned int)(ndays * (unsigned int)(60 * 60 * 24));
}

// ceventstr
// file statestr.c line 496
extern const char * ceventstr(signed int num)
{
  const char *return_value_getcode$1;
  return_value_getcode$1=getcode(num, clock_codes);
  return return_value_getcode$1;
}

// change_logfile
// file msyslog.c line 455
extern signed int change_logfile(const char *fname, signed int leave_crumbs)
{
  struct _IO_FILE *new_file;
  const char *log_fname;
  char *abs_fname;
  char curdir[512l];
  unsigned long int cd_octets;
  unsigned long int octets;
  if(!(fname == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("msyslog.c", 469, (enum anonymous$46)isc_assertiontype_require, "fname != ((void *)0)");
    (_Bool)0;
  }
  log_fname = fname;
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$2;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  signed int return_value_strcmp$6;
  _Bool tmp_if_expr$9;
  signed int return_value_strcmp$8;
  _Bool tmp_if_expr$11;
  char *return_value_getcwd$10;
  signed int return_value_fileno$14;
  signed int return_value_fileno$15;
  if(!(syslog_fname == ((char *)NULL)) && !(syslog_file == ((struct _IO_FILE *)NULL)))
  {
    return_value_strcmp$1=strcmp(syslog_fname, log_fname);
    if(!(return_value_strcmp$1 == 0))
      goto __CPROVER_DUMP_L4;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    signed int return_value_strcmp$13;
    return_value_strcmp$13=strcmp(log_fname, "stderr");
    if(return_value_strcmp$13 == 0)
    {
      new_file = stderr;
      abs_fname=estrdup_impl(log_fname);
    }

    else
    {
      return_value_strcmp$12=strcmp(log_fname, "stdout");
      if(return_value_strcmp$12 == 0)
      {
        new_file = stdout;
        abs_fname=estrdup_impl(log_fname);
      }

      else
      {
        if(!(syslog_fname == ((char *)NULL)))
        {
          return_value_strcmp$2=strcmp(log_fname, syslog_fname);
          if(return_value_strcmp$2 == 0)
            log_fname = syslog_abs_fname;

        }

        if(!(log_fname == syslog_abs_fname))
          tmp_if_expr$5 = 47 != (signed int)log_fname[(signed long int)0] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          return_value_strcmp$6=strcmp(log_fname, "stderr");
          tmp_if_expr$7 = 0 != return_value_strcmp$6 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$7 = (_Bool)0;
        if(tmp_if_expr$7)
        {
          return_value_strcmp$8=strcmp(log_fname, "stdout");
          tmp_if_expr$9 = 0 != return_value_strcmp$8 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$9 = (_Bool)0;
        if(tmp_if_expr$9)
        {
          return_value_getcwd$10=getcwd(curdir, sizeof(char [512l]) /*512ul*/ );
          tmp_if_expr$11 = (char *)(void *)0 != return_value_getcwd$10 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$11 = (_Bool)0;
        if(tmp_if_expr$11)
        {
          cd_octets=strlen(curdir);
          if(cd_octets >= 2ul)
          {
            if((signed int)curdir[-1l + (signed long int)cd_octets] == 47)
              cd_octets = cd_octets - 1ul;

          }

          octets = cd_octets;
          octets = octets + (unsigned long int)1;
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(log_fname);
          octets = octets + return_value_strlen$3;
          octets = octets + (unsigned long int)1;
          void *return_value_ereallocz$4;
          return_value_ereallocz$4=ereallocz((void *)0, octets, (unsigned long int)0, 0);
          abs_fname = (char *)return_value_ereallocz$4;
          snprintf(abs_fname, octets, "%.*s%c%s", (signed int)cd_octets, (const void *)curdir, 47, log_fname);
        }

        else
          abs_fname=estrdup_impl(log_fname);
        do
          if(debug >= 1)
            mprintf("attempting to open log %s\n", abs_fname);

        while((_Bool)0);
        new_file=fopen(abs_fname, "a");
      }
    }
    if(new_file == ((struct _IO_FILE *)NULL))
    {
      free((void *)abs_fname);
      return -1;
    }

    else
    {
      if(!(leave_crumbs == 0) && (!(log_fname == syslog_abs_fname) || !(syslogit == 0)))
        msyslog(5, "switching logging to file %s", abs_fname);

      if(!(syslog_file == ((struct _IO_FILE *)NULL)) && !(syslog_file == stderr) && !(syslog_file == stdout))
      {
        return_value_fileno$14=fileno(syslog_file);
        return_value_fileno$15=fileno(new_file);
        if(!(return_value_fileno$14 == return_value_fileno$15))
          fclose(syslog_file);

      }

      syslog_file = new_file;
      if(log_fname == syslog_abs_fname)
        free((void *)abs_fname);

      else
      {
        if(!(syslog_abs_fname == ((char *)NULL)) && !(syslog_abs_fname == syslog_fname))
          free((void *)syslog_abs_fname);

        if(!(syslog_fname == ((char *)NULL)))
          free((void *)syslog_fname);

        syslog_fname=estrdup_impl(log_fname);
        syslog_abs_fname = abs_fname;
      }
      syslogit = 0;
      return 0;
    }
  }
}

// cleanup_after_child
// file work_thread.c line 686
static void cleanup_after_child(struct blocking_child_tag *c)
{
  unsigned int idx;

__CPROVER_DUMP_L1:
  ;
  free((void *)c->thread_ref);
  c->thread_ref = (unsigned long int *)(void *)0;
  c->thread_id = (unsigned int)0;

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L3:
  ;
  addremove_io_fd(c->resp_read_pipe, c->ispipe, 1);
  close(c->resp_write_pipe);
  close(c->resp_read_pipe);
  c->resp_write_pipe = -1;
  c->resp_read_pipe = -1;
  idx = (unsigned int)0;
  if(!((unsigned long int)idx >= c->workitems_alloc))
  {
    c->workitems[(signed long int)idx] = (struct blocking_pipe_header_tag *)(void *)0;
    idx = idx + 1u;
  }

  c->next_workitem = (unsigned long int)0;
  c->next_workeritem = (unsigned long int)0;
  idx = (unsigned int)0;
  if(!((unsigned long int)idx >= c->responses_alloc))
  {
    c->responses[(signed long int)idx] = (struct blocking_pipe_header_tag *)(void *)0;
    idx = idx + 1u;
  }

  c->next_response = (unsigned long int)0;
  c->next_workresp = (unsigned long int)0;
  c->reusable = 1;
}

// clockname
// file clocktypes.c line 112
extern const char * clockname(signed int num)
{
  struct clktype *clk = clktypes;
  for( ; !(clk->code == -1); clk = clk + 1l)
    if(num == clk->code)
      return clk->abbrev;

  return (const char *)(void *)0;
}

// clocktime
// file clocktime.c line 52
extern signed int clocktime(signed int yday, signed int hour, signed int minute, signed int second, signed int tzoff, unsigned int rec_ui, unsigned long int *yearstart, unsigned int *ts_ui)
{
  unsigned int ystt[3l];
  unsigned int test[3l];
  unsigned int diff[3l];
  signed int y;
  signed int tmp;
  signed int idx;
  signed int min;
  tmp = (signed int)second + 60 * ((signed int)minute + 60 * ((signed int)hour + (signed int)tzoff + 24 * ((signed int)yday - 1)));
  if(!(*yearstart == 0ul))
  {
    test[(signed long int)0] = (unsigned int)*yearstart + (unsigned int)tmp;
    diff[(signed long int)0] = test[(signed long int)0] - rec_ui;
    if(diff[0l] >= 0x80000000u)
      diff[(signed long int)0] = ~diff[(signed long int)0] + (unsigned int)1;

    if(diff[0l] >= 182u)
      goto __CPROVER_DUMP_L2;

    *ts_ui = test[(signed long int)0];
    return (signed int)(diff[(signed long int)0] < 4u * 60u * 60u);
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    y=ntp_to_year(rec_ui - (unsigned int)tmp);
    idx = 0;
    for( ; !(idx >= 3); idx = idx + 1)
    {
      ystt[(signed long int)idx]=year_to_ntp((y + idx) - 1);
      test[(signed long int)idx] = ystt[(signed long int)idx] + (unsigned int)tmp;
      diff[(signed long int)idx] = test[(signed long int)idx] - rec_ui;
      if(diff[(signed long int)idx] >= 0x80000000u)
        diff[(signed long int)idx] = ~diff[(signed long int)idx] + (unsigned int)1;

    }
    min = 1;
    idx = 0;
    for( ; !(idx >= 3); idx = idx + 1)
      if(!(diff[(signed long int)idx] >= diff[(signed long int)min]))
        min = idx;

    *ts_ui = test[(signed long int)min];
    *yearstart = (unsigned long int)ystt[(signed long int)min];
    return (signed int)(diff[(signed long int)min] < 4u * 60u * 60u);
  }
}

// close_all_beyond
// file ntp_worker.c line 100
extern void close_all_beyond(signed int keep_fd)
{
  signed int fd;
  signed int max_fd;
  signed long int return_value_sysconf$1;
  return_value_sysconf$1=sysconf(4);
  max_fd = (signed int)return_value_sysconf$1;
  fd = keep_fd + 1;
  for( ; !(fd >= max_fd); fd = fd + 1)
    close(fd);
}

// close_all_except
// file ntp_worker.c line 80
extern void close_all_except(signed int keep_fd)
{
  signed int fd = 0;
  for( ; !(fd >= keep_fd); fd = fd + 1)
    close(fd);
  close_all_beyond(keep_fd);
}

// cmp_tspec
// file ../include/timespecops.h line 224
static inline signed int cmp_tspec(struct timespec a, struct timespec b)
{
  signed int r = (signed int)(a.tv_sec > b.tv_sec) - (signed int)(a.tv_sec < b.tv_sec);
  if(r == 0)
    r = (signed int)(a.tv_nsec > b.tv_nsec) - (signed int)(a.tv_nsec < b.tv_nsec);

  return r;
}

// common_prettydate
// file prettydate.c line 155
static char * common_prettydate(struct anonymous$20 *ts, signed int local)
{
  char *bp;
  struct tm *tm;
  unsigned int msec;
  unsigned int ntps;
  union anonymous$44 sec;
  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    bp = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  ntps = ts->Ul_i.Xl_ui;
  msec = ts->l_uf / (unsigned int)4294967;
  if(msec >= 1000u)
  {
    msec = msec - 1000u;
    ntps = ntps + 1u;
  }

  sec=ntpcal_ntp_to_time(ntps, (const signed long int *)(void *)0);
  tm=get_struct_tm(&sec, local);
  const char *tmp_if_expr$2;
  static const char pfmt0[47l] = { '%', '0', '8', 'l', 'x', '.', '%', '0', '8', 'l', 'x', ' ', ' ', '%', 's', ',', ' ', '%', 's', ' ', '%', '2', 'd', ' ', '%', '4', 'd', ' ', '%', '2', 'd', ':', '%', '0', '2', 'd', ':', '%', '0', '2', 'd', '.', '%', '0', '3', 'u', 0 };
  if(tm == ((struct tm *)NULL))
  {
    struct calendar jd;
    ntpcal_time_to_date(&jd, &sec);
    static const char pfmt1[52l] = { '%', '0', '8', 'l', 'x', '.', '%', '0', '8', 'l', 'x', ' ', '[', '%', 's', ',', ' ', '%', 's', ' ', '%', '2', 'd', ' ', '%', '4', 'd', ' ', '%', '2', 'd', ':', '%', '0', '2', 'd', ':', '%', '0', '2', 'd', '.', '%', '0', '3', 'u', ' ', 'U', 'T', 'C', ']', 0 };
    if(!(local == 0))
      tmp_if_expr$2 = pfmt1;

    else
      tmp_if_expr$2 = pfmt0;
    snprintf(bp, (unsigned long int)128, tmp_if_expr$2, (unsigned long int)ts->Ul_i.Xl_ui, (unsigned long int)ts->l_uf, daynames[(signed long int)jd.weekday], months[(signed long int)((signed int)jd.month - 1)], jd.monthday, jd.year, jd.hour, jd.minute, jd.second, msec);
  }

  else
    snprintf(bp, (unsigned long int)128, pfmt0, (unsigned long int)ts->Ul_i.Xl_ui, (unsigned long int)ts->l_uf, daynames[(signed long int)tm->tm_wday], months[(signed long int)tm->tm_mon], tm->tm_mday, 1900 + tm->tm_year, tm->tm_hour, tm->tm_min, tm->tm_sec, msec);
  return bp;
}

// convertLFPToRefID
// file refidsmear.c line 36
extern unsigned int convertLFPToRefID(struct anonymous$20 num)
{
  unsigned int temp;
  do
  {
    unsigned int add_t = (&num)->l_uf;
    (&num)->l_uf = (&num)->l_uf + (unsigned int)0x200;
    (&num)->Ul_i.Xl_ui = (&num)->Ul_i.Xl_ui + (unsigned int)(0 + (signed int)((unsigned int)(&num)->l_uf < add_t));
  }
  while((_Bool)0);
  num.Ul_i.Xl_ui = num.Ul_i.Xl_ui & (unsigned int)3;
  temp = num.Ul_i.Xl_ui << 22 | num.l_uf >> 10;
  temp = temp | 0xFE000000U;
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl(temp);
  return return_value_htonl$1;
}

// convertRefIDToLFP
// file refidsmear.c line 18
extern struct anonymous$20 convertRefIDToLFP(unsigned int r)
{
  struct anonymous$20 temp;
  r=ntohl(r);
  temp.l_uf = r << 10;
  temp.Ul_i.Xl_ui = r >> 22 & (unsigned int)0x3;
  temp.Ul_i.Xl_ui = temp.Ul_i.Xl_ui | ~(temp.Ul_i.Xl_ui & (unsigned int)2) + (unsigned int)1;
  return temp;
}

// copy_addrinfo_common
// file ntp_rfc2553.c line 157
struct addrinfo * copy_addrinfo_common(struct addrinfo *src, signed int just_one)
{
  struct addrinfo *ai_src;
  struct addrinfo *ai_nxt;
  struct addrinfo *ai_cpy;
  struct addrinfo *dst;
  union anonymous$47 *psau;
  char *pcanon;
  unsigned int elements;
  unsigned long int octets;
  unsigned long int canons_octets;
  unsigned long int str_octets;
  elements = (unsigned int)0;
  canons_octets = (unsigned long int)0;
  ai_src = src;
  unsigned long int return_value_strlen$1;
  for( ; !(ai_src == ((struct addrinfo *)NULL)); ai_src = ai_nxt)
  {
    if(!(just_one == 0))
      ai_nxt = (struct addrinfo *)(void *)0;

    else
      ai_nxt = ai_src->ai_next;
    elements = elements + 1u;
    if(!(ai_src->ai_canonname == ((char *)NULL)))
    {
      return_value_strlen$1=strlen(ai_src->ai_canonname);
      canons_octets = canons_octets + (unsigned long int)1 + return_value_strlen$1;
    }

  }
  octets = (unsigned long int)elements * (sizeof(struct addrinfo) /*48ul*/  + sizeof(union anonymous$47) /*28ul*/ );
  octets = octets + canons_octets;
  void *return_value_ereallocz$2;
  return_value_ereallocz$2=ereallocz((void *)0, octets, (unsigned long int)0, 1);
  dst = (struct addrinfo *)return_value_ereallocz$2;
  ai_cpy = dst;
  psau = (union anonymous$47 *)(void *)(ai_cpy + (signed long int)elements);
  pcanon = (char *)(void *)(psau + (signed long int)elements);
  ai_src = src;
  for( ; !(ai_src == ((struct addrinfo *)NULL)); ai_src = ai_nxt)
  {
    if(!(just_one == 0))
      ai_nxt = (struct addrinfo *)(void *)0;

    else
      ai_nxt = ai_src->ai_next;
    *ai_cpy = *ai_src;
    if(!((unsigned long int)ai_src->ai_addrlen >= 29ul))
      (_Bool)1;

    else
    {
      isc_assertion_failed("ntp_rfc2553.c", 206, (enum anonymous$46)isc_assertiontype_require, "ai_src->ai_addrlen <= sizeof(sockaddr_u)");
      (_Bool)0;
    }
    memcpy((void *)psau, (const void *)ai_src->ai_addr, (unsigned long int)ai_src->ai_addrlen);
    ai_cpy->ai_addr = &psau->sa;
    psau = psau + 1l;
    if(!(ai_cpy->ai_canonname == ((char *)NULL)))
    {
      ai_cpy->ai_canonname = pcanon;
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(ai_src->ai_canonname);
      str_octets = (unsigned long int)1 + return_value_strlen$3;
      memcpy((void *)pcanon, (const void *)ai_src->ai_canonname, str_octets);
      pcanon = pcanon + (signed long int)str_octets;
    }

    if(!(ai_cpy->ai_next == ((struct addrinfo *)NULL)))
    {
      if(!(just_one == 0))
        ai_cpy->ai_next = (struct addrinfo *)(void *)0;

      else
        ai_cpy->ai_next = ai_cpy + (signed long int)1;
    }

    ai_cpy = ai_cpy + 1l;
  }
  if(pcanon == (char *)dst + (signed long int)octets)
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_rfc2553.c", 224, (enum anonymous$46)isc_assertiontype_ensure, "pcanon == ((char *)dst + octets)");
    (_Bool)0;
  }
  return dst;
}

// copy_addrinfo_impl
// file ntp_rfc2553.c line 119
struct addrinfo * copy_addrinfo_impl(struct addrinfo *src)
{
  struct addrinfo *return_value_copy_addrinfo_common$1;
  return_value_copy_addrinfo_common$1=copy_addrinfo_common(src, 1);
  return return_value_copy_addrinfo_common$1;
}

// copy_addrinfo_list_impl
// file ntp_rfc2553.c line 138
struct addrinfo * copy_addrinfo_list_impl(struct addrinfo *src)
{
  struct addrinfo *return_value_copy_addrinfo_common$1;
  return_value_copy_addrinfo_common$1=copy_addrinfo_common(src, 0);
  return return_value_copy_addrinfo_common$1;
}

// create_buffers
// file recvbuff.c line 79
static void create_buffers(signed int nbufs)
{
  struct recvbuf *bufp;
  signed int i;
  signed int abuf = (signed int)((unsigned long int)nbufs + buffer_shortfall);
  buffer_shortfall = (volatile unsigned long int)0;
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, (unsigned long int)abuf * sizeof(struct recvbuf) /*2272ul*/ , (unsigned long int)0, 1);
  bufp = (struct recvbuf *)return_value_ereallocz$1;
  i = 0;
  for( ; !(i >= abuf); i = i + 1)
  {
    do
    {
      bufp->link = free_recv_list;
      free_recv_list = bufp;
    }
    while((_Bool)0);
    bufp = bufp + 1l;
    free_recvbufs = free_recvbufs + 1ul;
    total_recvbufs = total_recvbufs + 1ul;
  }
  lowater_adds = lowater_adds + 1ul;
}

// decode_bitflags
// file statestr.c line 335
static const char * decode_bitflags(signed int bits, const char *sep2, struct codestring *tab, unsigned long int tab_ct)
{
  const char *sep;
  char *buf;
  char *pch;
  char *lim;
  unsigned long int b;
  signed int rc;
  signed int saved_errno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  saved_errno = *return_value___errno_location$1;
  signed int tmp_post$2;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$2 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    buf = &lib_stringbuf[(signed long int)tmp_post$2][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  pch = buf;
  lim = buf + (signed long int)128;
  sep = "";
  b = (unsigned long int)0;
  for( ; !(b >= tab_ct); b = b + 1ul)
    if(!(((tab + (signed long int)b)->code & bits) == 0))
    {
      rc=snprintf(pch, (unsigned long int)(lim - pch), "%s%s", sep, (tab + (signed long int)b)->string);
      if(!(rc >= 0))
        goto toosmall;

      pch = pch + (signed long int)(unsigned int)rc;
      if(pch >= lim)
        goto toosmall;

      sep = sep2;
    }

  return buf;

toosmall:
  ;
  char *tmp_if_expr$3;
  if(tab == peer_st_bits)
    tmp_if_expr$3 = "peer_st";

  else
    tmp_if_expr$3 = tab == k_st_bits ? "kern_st" : "";
  snprintf(buf, (unsigned long int)128, "decode_bitflags(%s) can't decode 0x%x in %d bytes", tmp_if_expr$3, bits, (signed int)128);
  signed int *return_value___errno_location$4;
  return_value___errno_location$4=__errno_location();
  *return_value___errno_location$4 = saved_errno;
  return buf;
}

// decodenetnum
// file decodenetnum.c line 24
extern signed int decodenetnum(const char *num, union anonymous$47 *netnum)
{
  struct addrinfo hints;
  struct addrinfo *ai = (struct addrinfo *)(void *)0;
  signed int err;
  unsigned short int port;
  const char *cp;
  const char *port_str;
  char *pp;
  char *np;
  char name[80l];
  if(!(num == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("decodenetnum.c", 38, (enum anonymous$46)isc_assertiontype_require, "num != ((void *)0)");
    (_Bool)0;
  }
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(num);
  char *return_value_strchr$2;
  char *tmp_post$3;
  const char *tmp_post$4;
  _Bool tmp_if_expr$6;
  signed int return_value_sscanf$5;
  if(return_value_strlen$1 >= sizeof(char [80l]) /*80ul*/ )
    return 0;

  else
  {
    port_str = (const char *)(void *)0;
    if(!((signed int)*num == 91))
    {
      pp=strchr(num, 58);
      if(pp == ((char *)NULL))
        cp = num;

      else
      {
        return_value_strchr$2=strchr(pp + (signed long int)1, 58);
        if(!(return_value_strchr$2 == ((char *)NULL)))
          cp = num;

        else
        {
          strlcpy(name, num, sizeof(char [80l]) /*80ul*/ );
          cp = name;
          pp=strchr(cp, 58);
          *pp = (char)0;
          port_str = pp + (signed long int)1;
        }
      }
    }

    else
    {
      cp = num + (signed long int)1;
      np = name;
      for( ; !(*cp == 0); *tmp_post$3 = *tmp_post$4)
      {
        if((signed int)*cp == 93)
          break;

        tmp_post$3 = np;
        np = np + 1l;
        tmp_post$4 = cp;
        cp = cp + 1l;
      }
      *np = (char)0;
      if((signed int)*cp == 93)
      {
        if((signed int)cp[1l] == 58)
        {
          if(!((signed int)cp[2l] == 0))
            port_str = &cp[(signed long int)2];

        }

      }

      cp = name;
    }
    bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_flags = 0x0004;
    err=getaddrinfo(cp, "ntp", &hints, &ai);
    if(!(err == 0))
      return 0;

    else
    {
      if(!((unsigned long int)ai->ai_addrlen >= 29ul))
        (_Bool)1;

      else
      {
        isc_assertion_failed("decodenetnum.c", 78, (enum anonymous$46)isc_assertiontype_insist, "ai->ai_addrlen <= sizeof(*netnum)");
        (_Bool)0;
      }
      bzero((void *)&(*netnum), sizeof(union anonymous$47) /*28ul*/ );
      memcpy((void *)netnum, (const void *)ai->ai_addr, (unsigned long int)ai->ai_addrlen);
      freeaddrinfo(ai);
      if(port_str == ((const char *)NULL))
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_sscanf$5=sscanf(port_str, "%hu", &port);
        tmp_if_expr$6 = 1 != return_value_sscanf$5 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        port = (unsigned short int)123;

      netnum->sa4.sin_port=htons(port);
      return 1;
    }
  }
}

// default_callback
// file ./../lib/isc/assertions.c line 105
static void default_callback(const char *file, signed int line, enum anonymous$46 type, const char *cond)
{
  void *tracebuf[128l];
  signed int i;
  signed int nframes;
  const char *logsuffix = ".";
  const char *fname;
  unsigned int result;
  result=isc_backtrace_gettrace(tracebuf, 128, &nframes);
  if(result == 0u && nframes >= 1)
    logsuffix = ", back trace";

  const char *return_value_isc_assertion_typetotext$1;
  return_value_isc_assertion_typetotext$1=isc_assertion_typetotext(type);
  const char *return_value_isc_msgcat_get$2;
  return_value_isc_msgcat_get$2=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
  fprintf(stderr, "%s:%d: %s(%s) %s%s\n", file, line, return_value_isc_assertion_typetotext$1, cond, return_value_isc_msgcat_get$2, logsuffix);
  if(result == 0u)
  {
    i = 0;
    for( ; !(i >= nframes); i = i + 1)
    {
      unsigned long int offset;
      fname = (const char *)(void *)0;
      result=isc_backtrace_getsymbol(tracebuf[(signed long int)i], &fname, &offset);
      if(result == 0u)
        fprintf(stderr, "#%d %p in %s()+0x%lx\n", i, tracebuf[(signed long int)i], fname, offset);

      else
        fprintf(stderr, "#%d %p in ??\n", i, tracebuf[(signed long int)i]);
    }
  }

  fflush(stderr);
}

// default_fatal_callback
// file ./../lib/isc/error.c line 97
static void default_fatal_callback(const char *file, signed int line, const char *format, void **args)
{
  const char *return_value_isc_msgcat_get$1;
  return_value_isc_msgcat_get$1=isc_msgcat_get(isc_msgcat, 1, 110, "fatal error");
  fprintf(stderr, "%s:%d: %s: ", file, line, return_value_isc_msgcat_get$1);
  vfprintf(stderr, format, args);
  fprintf(stderr, "\n");
  fflush(stderr);
}

// default_unexpected_callback
// file ./../lib/isc/error.c line 87
static void default_unexpected_callback(const char *file, signed int line, const char *format, void **args)
{
  fprintf(stderr, "%s:%d: ", file, line);
  vfprintf(stderr, format, args);
  fprintf(stderr, "\n");
  fflush(stderr);
}

// dequeue_events
// file ./../lib/isc/task.c line 638
static unsigned int dequeue_events(struct isc__task *task, void *sender, unsigned int first, unsigned int last, void *tag, struct anonymous$52 *events, enum anonymous$11 purging)
{
  struct isc_event *event;
  struct isc_event *next_event;
  unsigned int count = (unsigned int)0;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 645, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  if(last >= first)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 646, (enum anonymous$46)isc_assertiontype_require, "last >= first");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 658, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  event = task->events.head;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  for( ; !(event == ((struct isc_event *)NULL)); event = next_event)
  {
    next_event = event->ev_link.next;
    if(event->ev_type >= first)
    {
      if(last >= event->ev_type)
      {
        if(sender == NULL)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = event->ev_sender == sender ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
        {
          if(tag == NULL)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = event->ev_tag == tag ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
          {
            if(purging == /*enum*/isc_boolean_false)
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = (event->ev_attributes & (unsigned int)0x00000001) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
            {

            __CPROVER_DUMP_L19:
              ;
              do
              {
                if(!(event->ev_link.next == ((struct isc_event *)NULL)))
                  event->ev_link.next->ev_link.prev = event->ev_link.prev;

                else
                {
                  if(task->events.tail == event)
                    (_Bool)1;

                  else
                  {
                    isc_assertion_failed("./../lib/isc/task.c", 666, (enum anonymous$46)isc_assertiontype_insist, "(task->events).tail == (event)");
                    (_Bool)0;
                  }
                  task->events.tail = event->ev_link.prev;
                }
                if(!(event->ev_link.prev == ((struct isc_event *)NULL)))
                  event->ev_link.prev->ev_link.next = event->ev_link.next;

                else
                {
                  if(task->events.head == event)
                    (_Bool)1;

                  else
                  {
                    isc_assertion_failed("./../lib/isc/task.c", 666, (enum anonymous$46)isc_assertiontype_insist, "(task->events).head == (event)");
                    (_Bool)0;
                  }
                  task->events.head = event->ev_link.next;
                }
                event->ev_link.prev = (struct isc_event *)(void *)-1;
                event->ev_link.next = (struct isc_event *)(void *)-1;
              }
              while((_Bool)0);

            __CPROVER_DUMP_L30:
              ;
              do
              {
                if(!(events->tail == ((struct isc_event *)NULL)))
                  events->tail->ev_link.next = event;

                else
                  events->head = event;
                event->ev_link.prev = events->tail;
                event->ev_link.next = (struct isc_event *)(void *)0;
                events->tail = event;
              }
              while((_Bool)0);
              count = count + 1u;
            }

          }

        }

      }

    }

  }
  do
  {
    signed int return_value_pthread_mutex_unlock$6;
    return_value_pthread_mutex_unlock$6=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$6 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 672, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  return count;
}

// destroy
// file ./../lib/isc/event.c line 36
static void destroy(struct isc_event *event)
{
  (void)event->ev_size;
  (void)event->ev_destroy_arg;
  free((void *)event);
}

// dir_current
// file ./../lib/isc/unix/file.c line 429
static unsigned int dir_current(char *dirname, unsigned long int length)
{
  char *cwd;
  unsigned int result = (unsigned int)0;
  if(!(dirname == ((char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 433, (enum anonymous$46)isc_assertiontype_require, "dirname != ((void *)0)");
    (_Bool)0;
  }
  if(length >= 1ul)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 434, (enum anonymous$46)isc_assertiontype_require, "length > 0U");
    (_Bool)0;
  }
  cwd=getcwd(dirname, length);
  signed int *return_value___errno_location$1;
  if(cwd == ((char *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 34)
      result = (unsigned int)19;

    else
    {
      return_value___errno_location$1=__errno_location();
      result=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/file.c", (unsigned int)442);
    }
  }

  else
  {
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(dirname);
    if(1ul + return_value_strlen$3 == length)
      result = (unsigned int)19;

    else
      if(!((signed int)dirname[1l] == 0))
        strlcat(dirname, "/", length);

  }
  return result;
}

// dispatch
// file ./../lib/isc/task.c line 978
static void dispatch(struct isc__taskmgr *manager)
{
  struct isc__task *task;
  _Bool tmp_if_expr$1;
  if(!(manager == ((struct isc__taskmgr *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)manager)->magic == (unsigned int)(84 << 24 | 83 << 16 | 75 << 8 | 77) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 986, (enum anonymous$46)isc_assertiontype_require, "(((manager) != ((void *)0)) && (((const isc__magic_t *)(manager))->magic == ((('T') << 24 | ('S') << 16 | ('K') << 8 | ('M')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1042, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  enum anonymous$11 return_value_empty_readyq$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$15;
  enum anonymous$11 return_value_empty_readyq$18;
  while((_Bool)1)
  {
    if(!(manager->exiting == /*enum*/isc_boolean_false))
    {
      if(manager->tasks.head == ((struct isc__task *)NULL))
        goto __CPROVER_DUMP_L93;

    }

    do
    {
      return_value_empty_readyq$3=empty_readyq(manager);
      if(return_value_empty_readyq$3 == /*enum*/isc_boolean_false)
      {
        if(manager->pause_requested == /*enum*/isc_boolean_false)
        {
          if(manager->exclusive_requested == /*enum*/isc_boolean_false)
            break;

        }

      }

      if(!(manager->exiting == /*enum*/isc_boolean_false))
      {
        if(manager->tasks.head == ((struct isc__task *)NULL))
          break;

      }

      do
      {
        signed int return_value_pthread_cond_wait$4;
        return_value_pthread_cond_wait$4=pthread_cond_wait(&manager->work_available, &manager->lock);
        if(return_value_pthread_cond_wait$4 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 1062, "((pthread_cond_wait(((&manager->work_available)), ((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
    }
    while((_Bool)1);
    task=pop_readyq(manager);
    if(!(task == ((struct isc__task *)NULL)))
    {
      unsigned int dispatch_count = (unsigned int)0;
      enum anonymous$11 done = (enum anonymous$11)isc_boolean_false;
      enum anonymous$11 requeue = (enum anonymous$11)isc_boolean_false;
      enum anonymous$11 finished = (enum anonymous$11)isc_boolean_false;
      struct isc_event *event;
      if(!(task == ((struct isc__task *)NULL)))
        tmp_if_expr$5 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        (_Bool)1;

      else
      {
        isc_assertion_failed("./../lib/isc/task.c", 1083, (enum anonymous$46)isc_assertiontype_insist, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
        (_Bool)0;
      }
      manager->tasks_running = manager->tasks_running + 1u;
      do
      {
        signed int return_value_pthread_mutex_unlock$6;
        return_value_pthread_mutex_unlock$6=pthread_mutex_unlock(&manager->lock);
        if(return_value_pthread_mutex_unlock$6 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 1091, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      do
      {
        signed int return_value_pthread_mutex_lock$7;
        return_value_pthread_mutex_lock$7=pthread_mutex_lock(&task->lock);
        if(return_value_pthread_mutex_lock$7 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 1093, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      if((signed int)task->state == task_state_ready)
        (_Bool)1;

      else
      {
        isc_assertion_failed("./../lib/isc/task.c", 1094, (enum anonymous$46)isc_assertiontype_insist, "task->state == task_state_ready");
        (_Bool)0;
      }
      task->state = (enum anonymous$56)task_state_running;
      isc_stdtime_get(&task->now);
      while((_Bool)1)
      {
        if(!(task->events.head == ((struct isc_event *)NULL)))
        {
          event = task->events.head;

        __CPROVER_DUMP_L34:
          ;
          do
          {
            if(!(event->ev_link.next == ((struct isc_event *)NULL)))
              event->ev_link.next->ev_link.prev = event->ev_link.prev;

            else
            {
              if(task->events.tail == event)
                (_Bool)1;

              else
              {
                isc_assertion_failed("./../lib/isc/task.c", 1102, (enum anonymous$46)isc_assertiontype_insist, "(task->events).tail == (event)");
                (_Bool)0;
              }
              task->events.tail = event->ev_link.prev;
            }
            if(!(event->ev_link.prev == ((struct isc_event *)NULL)))
              event->ev_link.prev->ev_link.next = event->ev_link.next;

            else
            {
              if(task->events.head == event)
                (_Bool)1;

              else
              {
                isc_assertion_failed("./../lib/isc/task.c", 1102, (enum anonymous$46)isc_assertiontype_insist, "(task->events).head == (event)");
                (_Bool)0;
              }
              task->events.head = event->ev_link.next;
            }
            event->ev_link.prev = (struct isc_event *)(void *)-1;
            event->ev_link.next = (struct isc_event *)(void *)-1;
          }
          while((_Bool)0);
          if(!(event->ev_action == ((void (*)(struct isc_task *, struct isc_event *))NULL)))
          {
            do
            {
              signed int return_value_pthread_mutex_unlock$8;
              return_value_pthread_mutex_unlock$8=pthread_mutex_unlock(&task->lock);
              if(return_value_pthread_mutex_unlock$8 == 0)
                (_Bool)1;

              else
              {
                isc_error_runtimecheck("./../lib/isc/task.c", 1112, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
                (_Bool)0;
              }
            }
            while((_Bool)0);
            event->ev_action((struct isc_task *)task, event);
            signed int return_value_pthread_mutex_lock$9;
            return_value_pthread_mutex_lock$9=pthread_mutex_lock(&task->lock);
            if(return_value_pthread_mutex_lock$9 == 0)
              (_Bool)1;

            else
            {
              isc_error_runtimecheck("./../lib/isc/task.c", 1116, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
              (_Bool)0;
            }
          }

          dispatch_count = dispatch_count + 1u;
        }

        if(task->references == 0u)
        {
          if(task->events.head == ((struct isc_event *)NULL))
          {
            if((1u & task->flags) == 0u)
            {
              enum anonymous$11 was_idle;
              was_idle=task_shutdown(task);
              if(was_idle == /*enum*/isc_boolean_false)
                (_Bool)1;

              else
              {
                isc_assertion_failed("./../lib/isc/task.c", 1152, (enum anonymous$46)isc_assertiontype_insist, "!was_idle");
                (_Bool)0;
              }
            }

          }

        }

        if(task->events.head == ((struct isc_event *)NULL))
        {
          if(task->references == 0u)
            tmp_if_expr$10 = (task->flags & (unsigned int)0x01) != (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10 = (_Bool)0;
          if(tmp_if_expr$10)
          {
            finished = (enum anonymous$11)isc_boolean_true;
            task->state = (enum anonymous$56)task_state_done;
          }

          else
            task->state = (enum anonymous$56)task_state_idle;
          done = (enum anonymous$11)isc_boolean_true;
        }

        else
          if(dispatch_count >= task->quantum)
          {
            task->state = (enum anonymous$56)task_state_ready;
            requeue = (enum anonymous$11)isc_boolean_true;
            done = (enum anonymous$11)isc_boolean_true;
          }

        if(!(done == /*enum*/isc_boolean_false))
          break;

      }
      do
      {
        signed int return_value_pthread_mutex_unlock$11;
        return_value_pthread_mutex_unlock$11=pthread_mutex_unlock(&task->lock);
        if(return_value_pthread_mutex_unlock$11 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 1199, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      if(!(finished == /*enum*/isc_boolean_false))
        task_finished(task);

      do
      {
        signed int return_value_pthread_mutex_lock$12;
        return_value_pthread_mutex_lock$12=pthread_mutex_lock(&manager->lock);
        if(return_value_pthread_mutex_lock$12 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 1204, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      manager->tasks_running = manager->tasks_running - 1u;
      if(!(manager->exclusive_requested == /*enum*/isc_boolean_false))
        tmp_if_expr$15 = manager->tasks_running == (unsigned int)1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$15 = (_Bool)0;
      if(tmp_if_expr$15)
        do
        {
          signed int return_value_pthread_cond_signal$13;
          return_value_pthread_cond_signal$13=pthread_cond_signal(&manager->exclusive_granted);
          if(return_value_pthread_cond_signal$13 == 0)
            (_Bool)1;

          else
          {
            isc_error_runtimecheck("./../lib/isc/task.c", 1209, "((pthread_cond_signal(((&manager->exclusive_granted))) == 0) ? 0 : 34) == 0");
            (_Bool)0;
          }
        }
        while((_Bool)0);

      else
        if(!(manager->pause_requested == /*enum*/isc_boolean_false))
        {
          if(manager->tasks_running == 0u)
            do
            {
              signed int return_value_pthread_cond_signal$14;
              return_value_pthread_cond_signal$14=pthread_cond_signal(&manager->paused);
              if(return_value_pthread_cond_signal$14 == 0)
                (_Bool)1;

              else
              {
                isc_error_runtimecheck("./../lib/isc/task.c", 1212, "((pthread_cond_signal(((&manager->paused))) == 0) ? 0 : 34) == 0");
                (_Bool)0;
              }
            }
            while((_Bool)0);

        }

      if(!(requeue == /*enum*/isc_boolean_false))
        push_readyq(manager, task);

    }

    if(manager->tasks_running == 0u)
    {
      return_value_empty_readyq$18=empty_readyq(manager);
      if(!(return_value_empty_readyq$18 == /*enum*/isc_boolean_false))
      {
        manager->mode = (enum anonymous$59)isc_taskmgrmode_normal;
        enum anonymous$11 return_value_empty_readyq$17;
        return_value_empty_readyq$17=empty_readyq(manager);
        if(return_value_empty_readyq$17 == /*enum*/isc_boolean_false)
          do
          {
            signed int return_value_pthread_cond_broadcast$16;
            return_value_pthread_cond_broadcast$16=pthread_cond_broadcast(&manager->work_available);
            if(return_value_pthread_cond_broadcast$16 == 0)
              (_Bool)1;

            else
            {
              isc_error_runtimecheck("./../lib/isc/task.c", 1256, "((pthread_cond_broadcast(((&manager->work_available))) == 0) ? 0 : 34) == 0");
              (_Bool)0;
            }
          }
          while((_Bool)0);

      }

    }

  }
  do
  {

  __CPROVER_DUMP_L93:
    ;
    signed int return_value_pthread_mutex_unlock$19;
    return_value_pthread_mutex_unlock$19=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$19 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1269, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// dofptoa
// file dofptoa.c line 13
extern char * dofptoa(unsigned int fpv, signed int neg, signed short int ndec, signed int msec)
{
  unsigned char *cp;
  unsigned char *cpend;
  unsigned long int val;
  signed short int dec;
  unsigned char cbuf[12l];
  unsigned char *cpdec;
  char *buf;
  char *bp;
  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    buf = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  bzero((void *)&cbuf, sizeof(unsigned char [12l]) /*12ul*/ );
  cpend = &cbuf[(signed long int)5];
  cp = cpend;
  val = (unsigned long int)fpv;
  if((4294901760ul & val) == 0ul)
    cp = cp - 1l;

  else
  {
    unsigned short int sv = (unsigned short int)(val >> 16);
    unsigned short int tmp;
    unsigned short int ten = (unsigned short int)10;
    do
    {
      tmp = sv;
      sv = (unsigned short int)((signed int)sv / (signed int)ten);
      cp = cp - 1l;
      *cp = (unsigned char)((signed int)tmp - (((signed int)sv << 3) + ((signed int)sv << 1)));
    }
    while(!((signed int)sv == 0));
  }
  if(!(msec == 0))
  {
    dec = (signed short int)((signed int)ndec + 3);
    if(!((signed int)dec >= 3))
      dec = (signed short int)3;

    cpdec = &cbuf[(signed long int)8];
  }

  else
  {
    dec = ndec;
    cpdec = cpend;
  }
  if((signed int)dec >= 7)
    dec = (signed short int)6;

  unsigned char *tmp_post$2;
  if((signed int)dec >= 1)
    do
    {
      val = val & (unsigned long int)0xffff;
      val = (val << 3) + (val << 1);
      tmp_post$2 = cpend;
      cpend = cpend + 1l;
      *tmp_post$2 = (unsigned char)(val >> 16);
      dec = dec - 1;
    }
    while((signed int)dec >= 1);

  if(!((32768ul & val) == 0ul))
  {
    unsigned char *tp = cpend;
    tp = tp - 1l;
    *tp = *tp + (unsigned char)1;
    for( ; (signed int)*tp >= 10; *tp = *tp + (unsigned char)1)
    {
      *tp = (unsigned char)0;
      tp = tp - 1l;
    }
  }

  for( ; !(cp >= cpdec + -1l); cp = cp + 1l)
    if(!((signed int)*cp == 0))
      break;

  bp = buf;
  char *tmp_post$3;
  if(!(neg == 0))
  {
    tmp_post$3 = bp;
    bp = bp + 1l;
    *tmp_post$3 = (char)45;
  }

  char *tmp_post$4;
  char *tmp_post$5;
  unsigned char *tmp_post$6;
  for( ; !(cp >= cpend); *tmp_post$5 = (char)((signed int)*tmp_post$6 + 48))
  {
    if(cp == cpdec)
    {
      tmp_post$4 = bp;
      bp = bp + 1l;
      *tmp_post$4 = (char)46;
    }

    tmp_post$5 = bp;
    bp = bp + 1l;
    tmp_post$6 = cp;
    cp = cp + 1l;
  }
  *bp = (char)0;
  return buf;
}

// dolfptoa
// file dolfptoa.c line 13
extern char * dolfptoa(unsigned int fpi, unsigned int fpv, signed int neg, signed short int ndec, signed int msec)
{
  unsigned char *cp;
  unsigned char *cpend;
  unsigned char *cpdec;
  signed int dec;
  unsigned char cbuf[24l];
  char *buf;
  char *bp;
  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    buf = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  bzero((void *)&cbuf, sizeof(unsigned char [24l]) /*24ul*/ );
  cpdec = &cbuf[(signed long int)10];
  cpend = cpdec;
  cp = cpend;
  dec = (signed int)(cp - cbuf);
  for( ; dec >= 1 && !(fpi == 0u); dec = dec - 1)
  {
    unsigned int digit = fpi;
    fpi = fpi / 10U;
    digit = digit - ((fpi << 3) + (fpi << 1));
    cp = cp - 1l;
    *cp = (unsigned char)digit;
  }
  dec = (signed int)ndec;
  if(!(dec >= 0))
    dec = 0;

  if(!(msec == 0))
  {
    dec = dec + 3;
    cpdec = cpdec + (signed long int)3;
  }

  if(!(sizeof(unsigned char [24l]) /*24ul*/  + -((unsigned long int)(cpend - cbuf)) >= (unsigned long int)dec))
    dec = (signed int)(sizeof(unsigned char [24l]) /*24ul*/  - (unsigned long int)(cpend - cbuf));

  unsigned char *tmp_post$2;
  for( ; dec >= 1 && !(fpv == 0u); dec = dec - 1)
  {
    unsigned int dolfptoa$$1$$4$$1$$digit;
    unsigned int tmph;
    unsigned int tmpl;
    dolfptoa$$1$$4$$1$$digit = (unsigned int)0;
    do
    {
      dolfptoa$$1$$4$$1$$digit = (unsigned int)dolfptoa$$1$$4$$1$$digit << 1 | (unsigned int)fpv >> 31;
      fpv = (unsigned int)fpv << 1;
    }
    while((_Bool)0);
    tmph = dolfptoa$$1$$4$$1$$digit;
    tmpl = fpv;
    do
    {
      dolfptoa$$1$$4$$1$$digit = (unsigned int)dolfptoa$$1$$4$$1$$digit << 1 | (unsigned int)fpv >> 31;
      fpv = (unsigned int)fpv << 1;
    }
    while((_Bool)0);
    do
    {
      dolfptoa$$1$$4$$1$$digit = (unsigned int)dolfptoa$$1$$4$$1$$digit << 1 | (unsigned int)fpv >> 31;
      fpv = (unsigned int)fpv << 1;
    }
    while((_Bool)0);
    do
    {
      unsigned int add_t = fpv;
      fpv = fpv + tmpl;
      dolfptoa$$1$$4$$1$$digit = dolfptoa$$1$$4$$1$$digit + tmph + (unsigned int)((unsigned int)fpv < add_t);
    }
    while((_Bool)0);
    tmp_post$2 = cpend;
    cpend = cpend + 1l;
    *tmp_post$2 = (unsigned char)dolfptoa$$1$$4$$1$$digit;
  }
  if(dec >= 1)
    cpend = cpend + (signed long int)dec;

  else
  {
    unsigned char *tp = cpend;
    signed int carry = (signed int)((fpv & 0x80000000) != (unsigned int)0);
    dec = (signed int)(tp - cbuf);
    for( ; dec >= 1 && !(carry == 0); dec = dec - 1)
    {
      tp = tp - 1l;
      *tp = *tp + (unsigned char)1;
      if((signed int)*tp == 10)
        *tp = (unsigned char)0;

      else
        carry = 0;
    }
    if(!(tp >= cp))
      cp = tp;

  }
  for( ; !(cp >= cpdec); cp = cp + 1l)
    if(!((signed int)*cp == 0))
      break;

  if(cp >= cpdec)
    cp = cpdec - (signed long int)1;

  bp = buf;
  char *tmp_post$3;
  if(!(neg == 0))
  {
    tmp_post$3 = bp;
    bp = bp + 1l;
    *tmp_post$3 = (char)45;
  }

  char *tmp_post$4;
  char *tmp_post$5;
  unsigned char *tmp_post$6;
  for( ; !(cp >= cpend); *tmp_post$5 = (char)((signed int)(char)*tmp_post$6 + 48))
  {
    if(cp == cpdec)
    {
      tmp_post$4 = bp;
      bp = bp + 1l;
      *tmp_post$4 = (char)46;
    }

    tmp_post$5 = bp;
    bp = bp + 1l;
    tmp_post$6 = cp;
    cp = cp + 1l;
  }
  *bp = (char)0;
  return buf;
}

// doublefreq
// file icom.c line 107
static void doublefreq(double freq, unsigned char *x, signed int len)
{
  signed int i;
  char s1[16l];
  char *y;
  snprintf(s1, sizeof(char [16l]) /*16ul*/ , " %10.0f", freq);
  y = s1 + (signed long int)10;
  i = 0;
  char *tmp_post$1;
  char *tmp_post$2;
  for( ; !((signed int)*y == 32); i = i + 1)
  {
    tmp_post$1 = y;
    y = y - 1l;
    x[(signed long int)i] = (unsigned char)((signed int)*tmp_post$1 & 0x0f);
    tmp_post$2 = y;
    y = y - 1l;
    x[(signed long int)i] = (unsigned char)((signed int)x[(signed long int)i] | ((signed int)*tmp_post$2 & 0x0f) << 4);
  }
  for( ; !(i >= len); i = i + 1)
    x[(signed long int)i] = (unsigned char)0;
  x[(signed long int)i] = (unsigned char)0xfd;
}

// empty_readyq
// file ./../lib/isc/task.c line 925
static inline enum anonymous$11 empty_readyq(struct isc__taskmgr *manager)
{
  struct anonymous$58 queue;
  if((signed int)manager->mode == isc_taskmgrmode_normal)
    queue = manager->ready_tasks;

  else
    queue = manager->ready_priority_tasks;
  return (enum anonymous$11)((queue.head == (struct isc__task *)(void *)0 ? isc_boolean_true : isc_boolean_false) != 0 ? isc_boolean_true : isc_boolean_false);
}

// ensure_workitems_empty_slot
// file work_thread.c line 129
static void ensure_workitems_empty_slot(struct blocking_child_tag *c)
{
  const unsigned long int each = sizeof(struct blocking_pipe_header_tag *) /*8ul*/ ;
  unsigned long int new_alloc;
  unsigned long int old_octets;
  unsigned long int new_octets;
  void *nonvol_workitems;
  if(!(c->workitems == ((struct blocking_pipe_header_tag * volatile * volatile )NULL)))
  {
    if(!(c->workitems[(signed long int)c->next_workitem] == ((struct blocking_pipe_header_tag *)NULL)))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    new_alloc = c->workitems_alloc + (unsigned long int)16;
    old_octets = c->workitems_alloc * each;
    new_octets = new_alloc * each;
    nonvol_workitems = (void *)(unsigned long int)(volatile void *)c->workitems;
    void *return_value_ereallocz$1;
    return_value_ereallocz$1=ereallocz(nonvol_workitems, new_octets, old_octets, 1);
    c->workitems = (struct blocking_pipe_header_tag * volatile * volatile )return_value_ereallocz$1;
    if(c->next_workitem == 0ul)
      c->next_workitem = c->workitems_alloc;

    c->workitems_alloc = new_alloc;
  }
}

// ensure_workresp_empty_slot
// file work_thread.c line 157
static void ensure_workresp_empty_slot(struct blocking_child_tag *c)
{
  const unsigned long int each = sizeof(struct blocking_pipe_header_tag *) /*8ul*/ ;
  unsigned long int new_alloc;
  unsigned long int old_octets;
  unsigned long int new_octets;
  void *nonvol_responses;
  if(!(c->responses == ((struct blocking_pipe_header_tag * volatile * volatile )NULL)))
  {
    if(!(c->responses[(signed long int)c->next_response] == ((struct blocking_pipe_header_tag *)NULL)))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    new_alloc = c->responses_alloc + (unsigned long int)4;
    old_octets = c->responses_alloc * each;
    new_octets = new_alloc * each;
    nonvol_responses = (void *)(unsigned long int)(volatile void *)c->responses;
    void *return_value_ereallocz$1;
    return_value_ereallocz$1=ereallocz(nonvol_responses, new_octets, old_octets, 1);
    c->responses = (struct blocking_pipe_header_tag * volatile * volatile )return_value_ereallocz$1;
    if(c->next_response == 0ul)
      c->next_response = c->responses_alloc;

    c->responses_alloc = new_alloc;
  }
}

// ereallocz
// file ../include/ntp_stdlib.h line 105
extern void * ereallocz(void *ptr, unsigned long int newsz, unsigned long int priorsz, signed int zero_init)
{
  char *mem;
  unsigned long int allocsz;
  if(newsz == 0ul)
    allocsz = (unsigned long int)1;

  else
    allocsz = newsz;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc(ptr, allocsz);
  mem = (char *)return_value_realloc$1;
  if(mem == ((char *)NULL))
  {
    msyslog_term = 1;
    msyslog(3, "fatal out of memory (%lu bytes)", (unsigned long int)newsz);
    exit(1);
  }

  if(!(zero_init == 0) && !(priorsz >= newsz))
    bzero((void *)(mem + (signed long int)priorsz), newsz - priorsz);

  return (void *)mem;
}

// errno_to_str
// file msyslog.c line 99
extern void errno_to_str(signed int err, char *buf, unsigned long int bufsiz)
{
  char *pstatic;
  buf[(signed long int)0] = (char)0;
  pstatic=strerror_r(err, buf, bufsiz);
  _Bool tmp_if_expr$2;
  if(pstatic == ((char *)NULL))
    tmp_if_expr$2 = 0 == (signed int)buf[(signed long int)0] ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  signed int *return_value___errno_location$1;
  if(tmp_if_expr$2)
  {
    return_value___errno_location$1=__errno_location();
    snprintf(buf, bufsiz, "%s(%d): errno %d", (const void *)"strerror_r", err, *return_value___errno_location$1);
  }

  else
    if(!(pstatic == buf) && !((char *)bufsiz >= pstatic))
      strlcpy(buf, pstatic, bufsiz);

}

// estrdup_impl
// file emalloc.c line 116
extern char * estrdup_impl(const char *str)
{
  char *copy;
  unsigned long int bytes;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  bytes = return_value_strlen$1 + (unsigned long int)1;
  void *return_value_ereallocz$2;
  return_value_ereallocz$2=ereallocz((void *)0, bytes, (unsigned long int)0, 0);
  copy = (char *)return_value_ereallocz$2;
  memcpy((void *)copy, (const void *)str, bytes);
  return copy;
}

// eventstr
// file statestr.c line 481
extern const char * eventstr(signed int num)
{
  const char *return_value_getcode$1;
  const char *return_value_getcode$2;
  const char *return_value_getcode$3;
  if(!((0x080 & num) == 0))
  {
    return_value_getcode$1=getcode(num & ~0x080, peer_codes);
    return return_value_getcode$1;
  }

  else
    if(!((0x100 & num) == 0))
    {
      return_value_getcode$2=getcode(num & ~0x100, crypto_codes);
      return return_value_getcode$2;
    }

    else
    {
      return_value_getcode$3=getcode(num, sys_codes);
      return return_value_getcode$3;
    }
}

// exit_worker
// file work_thread.c line 72
extern void exit_worker(signed int exitcode)
{
  pthread_exit((void *)(unsigned long int)exitcode);
}

// file_stats
// file ./../lib/isc/unix/file.c line 89
static unsigned int file_stats(const char *file, struct stat *stats)
{
  unsigned int result = (unsigned int)0;
  if(!(file == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 92, (enum anonymous$46)isc_assertiontype_require, "file != ((void *)0)");
    (_Bool)0;
  }
  if(!(stats == ((struct stat *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 93, (enum anonymous$46)isc_assertiontype_require, "stats != ((void *)0)");
    (_Bool)0;
  }
  signed int return_value_stat$2;
  return_value_stat$2=stat(file, stats);
  signed int *return_value___errno_location$1;
  if(!(return_value_stat$2 == 0))
  {
    return_value___errno_location$1=__errno_location();
    result=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/file.c", (unsigned int)96);
  }

  return result;
}

// fix_tv_usec
// file ./../lib/isc/unix/stdtime.c line 41
static inline void fix_tv_usec(struct timeval *tv)
{
  enum anonymous$11 fixed = (enum anonymous$11)isc_boolean_false;
  if(!(tv->tv_usec >= 0l))
  {
    fixed = (enum anonymous$11)isc_boolean_true;
    do
    {
      tv->tv_sec = tv->tv_sec - (signed long int)1;
      tv->tv_usec = tv->tv_usec + (signed long int)1000000;
    }
    while(!(tv->tv_usec >= 0l));
  }

  else
    if(tv->tv_usec >= 1000000l)
    {
      fixed = (enum anonymous$11)isc_boolean_true;
      do
      {
        tv->tv_sec = tv->tv_sec + (signed long int)1;
        tv->tv_usec = tv->tv_usec - (signed long int)1000000;
      }
      while(tv->tv_usec >= 1000000l);
    }

  if(!(fixed == /*enum*/isc_boolean_false))
    syslog(3, "gettimeofday returned bad tv_usec: corrected");

}

// fix_tv_usec$link1
// file ./../lib/isc/unix/time.c line 62
static inline void fix_tv_usec$link1(struct timeval *tv$link1)
{
  enum anonymous$11 fixed$link1 = (enum anonymous$11)isc_boolean_false;
  if(!(tv$link1->tv_usec >= 0l))
  {
    fixed$link1 = (enum anonymous$11)isc_boolean_true;
    do
    {
      tv$link1->tv_sec = tv$link1->tv_sec - (signed long int)1;
      tv$link1->tv_usec = tv$link1->tv_usec + (signed long int)1000000;
    }
    while(!(tv$link1->tv_usec >= 0l));
  }

  else
    if(tv$link1->tv_usec >= 1000000l)
    {
      fixed$link1 = (enum anonymous$11)isc_boolean_true;
      do
      {
        tv$link1->tv_sec = tv$link1->tv_sec + (signed long int)1;
        tv$link1->tv_usec = tv$link1->tv_usec - (signed long int)1000000;
      }
      while(tv$link1->tv_usec >= 1000000l);
    }

  if(!(fixed$link1 == /*enum*/isc_boolean_false))
    syslog(3, "gettimeofday returned bad tv_usec: corrected");

}

// format_time_fraction
// file ../include/timetoa.h line 81
extern const char * format_time_fraction(signed long int secs, signed long int frac, signed int prec)
{
  char *cp;
  unsigned int prec_u;
  unsigned long int secs_u;
  unsigned int u;
  signed long int fraclimit;
  signed int notneg;
  struct anonymous$13 qr;

__CPROVER_DUMP_L1:
  ;
  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    cp = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  secs_u = (unsigned long int)secs;
  notneg = (signed int)(prec < 0);
  signed int return_value_abs$2;
  return_value_abs$2=abs(prec);
  prec_u = (unsigned int)return_value_abs$2;
  fraclimit = (signed long int)10;
  u = (unsigned int)1;
  for( ; !(u >= prec_u); u = u + 1u)
  {

  __CPROVER_DUMP_L4:
    ;
    fraclimit = fraclimit * (signed long int)10;
  }
  if(frac >= fraclimit || !(frac >= 0l))
  {
    qr=ldiv(frac, fraclimit);
    if(!(qr.rem >= 0l))
    {
      qr.quot = qr.quot - 1l;
      qr.rem = qr.rem + fraclimit;
    }

    secs_u = secs_u + (unsigned long int)(signed long int)qr.quot;
    frac = qr.rem;
  }

  notneg = (signed int)(notneg != 0 || (signed long int)secs_u >= (signed long int)0);
  if(notneg == 0)
  {
    secs_u = ~secs_u;
    if(frac == 0l)
      secs_u = secs_u + 1ul;

    else
      frac = fraclimit - frac;
  }

  snprintf(cp, (unsigned long int)128, "%s%lu.%0*ld", notneg != 0 ? "" : "-", secs_u, prec_u, frac);
  return cp;
}

// fptoa
// file dofptoa.c line 123
extern char * fptoa(signed int fpv, signed short int ndec)
{
  unsigned int plusfp;
  signed int neg = (signed int)(fpv < 0);
  if(!(neg == 0))
    plusfp = (unsigned int)-fpv;

  else
    plusfp = (unsigned int)fpv;
  char *return_value_dofptoa$1;
  return_value_dofptoa$1=dofptoa(plusfp, neg, ndec, 0);
  return return_value_dofptoa$1;
}

// fptoms
// file dofptoa.c line 143
extern char * fptoms(signed int fpv, signed short int ndec)
{
  unsigned int plusfp;
  signed int neg = (signed int)(fpv < 0);
  if(!(neg == 0))
    plusfp = (unsigned int)-fpv;

  else
    plusfp = (unsigned int)fpv;
  char *return_value_dofptoa$1;
  return_value_dofptoa$1=dofptoa(plusfp, neg, ndec, 1);
  return return_value_dofptoa$1;
}

// free_recvbuffs
// file recvbuff.c line 49
extern unsigned long int free_recvbuffs(void)
{
  return free_recvbufs;
}

// freerecvbuf
// file recvbuff.c line 157
extern void freerecvbuf(struct recvbuf *rb)
{
  if(rb == ((struct recvbuf *)NULL))
    msyslog(3, "freerecvbuff received NULL buffer");

  else
  {

  __CPROVER_DUMP_L1:
    ;
    rb->used = rb->used - 1;
    if(!(rb->used == 0))
      msyslog(3, "******** freerecvbuff non-zero usage: %d *******", rb->used);

    do
    {
      rb->link = free_recv_list;
      free_recv_list = rb;
    }
    while((_Bool)0);
    free_recvbufs = free_recvbufs + 1ul;
  }

__CPROVER_DUMP_L3:
  ;
}

// freesymkey
// file authkeys.c line 296
static void freesymkey(struct savekey *sk, struct savekey **bucket)
{
  struct savekey *unlinked;
  if(!(sk->secret == ((unsigned char *)NULL)))
  {
    memset((void *)sk->secret, 0, (unsigned long int)sk->secretsize);
    free((void *)sk->secret);
  }

  _Bool tmp_if_expr$1;
  do
  {
    struct savekey **ppentry = &(*bucket);
    while(!(sk == *ppentry))
    {
      if(!(*ppentry == ((struct savekey *)NULL)))
        tmp_if_expr$1 = (*ppentry)->hlink != (struct savekey *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        ppentry = &(*ppentry)->hlink;

      else
      {
        ppentry = (struct savekey **)(void *)0;
        break;
      }
    }
    if(!(ppentry == ((struct savekey **)NULL)))
    {
      unlinked = *ppentry;
      *ppentry = unlinked->hlink;
    }

    else
      unlinked = (struct savekey *)(void *)0;

  __CPROVER_DUMP_L8:
    ;
  }
  while((_Bool)0);

__CPROVER_DUMP_L11:
  ;
  do
  {
    sk->llink.b->llink.f = sk->llink.f;
    sk->llink.f->llink.b = sk->llink.b;

  __CPROVER_DUMP_L13:
    ;

  __CPROVER_DUMP_L14:
    ;
  }
  while((_Bool)0);
  memset((void *)((char *)sk + (signed long int)24ul), 0, sizeof(struct savekey) /*56ul*/  - 24ul);
  do
  {
    sk->llink.f = authfreekeys;
    authfreekeys = sk;
  }
  while((_Bool)0);
  authnumkeys = authnumkeys - 1ul;
  authnumfreekeys = authnumfreekeys + 1;
}

// full_recvbuffs
// file recvbuff.c line 55
extern unsigned long int full_recvbuffs(void)
{
  return full_recvbufs;
}

// get_addr
// file ./../lib/isc/unix/interfaceiter.c line 70
static void get_addr(unsigned int family, struct isc_netaddr *dst, struct sockaddr *src, char *ifname)
{
  struct sockaddr_in6 *sa6;
  memset((void *)dst, 0, sizeof(struct isc_netaddr) /*24ul*/ );
  dst->family = family;
  _Bool tmp_statement_expression$1;
  switch(family)
  {
    case (unsigned int)2:
    {
      memcpy((void *)&dst->type.in, (const void *)&((struct sockaddr_in *)(void *)src)->sin_addr, sizeof(struct in_addr) /*4ul*/ );
      break;
    }
    case (unsigned int)10:
    {
      sa6 = (struct sockaddr_in6 *)(void *)src;
      memcpy((void *)&dst->type.in6, (const void *)&sa6->sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
      if(!(sa6->sin6_scope_id == 0u))
        isc_netaddr_setzone(dst, sa6->sin6_scope_id);

      else
      {
        struct in6_addr *__a = (struct in6_addr *)&sa6->sin6_addr;
        unsigned int return_value_htonl$2;
        return_value_htonl$2=htonl(0xffc00000);
        unsigned int return_value_htonl$3;
        return_value_htonl$3=htonl(0xfe800000);
        tmp_statement_expression$1 = (__a->__in6_u.__u6_addr32[(signed long int)0] & return_value_htonl$2) == return_value_htonl$3;
        if(tmp_statement_expression$1)
        {
          unsigned short int zone16;
          memcpy((void *)&zone16, (const void *)&sa6->sin6_addr.__in6_u.__u6_addr8[(signed long int)2], sizeof(unsigned short int) /*2ul*/ );
          zone16=ntohs(zone16);
          if(!((signed int)zone16 == 0))
          {
            isc_netaddr_setzone(dst, (unsigned int)zone16);
            dst->type.in6.__in6_u.__u6_addr8[(signed long int)2] = (unsigned char)0;
            dst->type.in6.__in6_u.__u6_addr8[(signed long int)3] = (unsigned char)0;
          }

          else
            if(!(ifname == ((char *)NULL)))
            {
              unsigned int zone;
              zone=if_nametoindex(ifname);
              if(!(zone == 0u))
                isc_netaddr_setzone(dst, (unsigned int)zone);

            }

        }

      }
      break;
    }
    default:
    {
      isc_assertion_failed("./../lib/isc/unix/interfaceiter.c", 143, (enum anonymous$46)isc_assertiontype_insist, "0");
      (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
    }
  }
}

// get_dnschild_ctx
// file ntp_intres.c line 938
static unsigned int get_dnschild_ctx(void)
{
  unsigned int return_value_reserve_dnschild_ctx$1;
  if(!(worker_per_query == 0))
  {
    return_value_reserve_dnschild_ctx$1=reserve_dnschild_ctx();
    return return_value_reserve_dnschild_ctx$1;
  }

  else
  {
    static unsigned int shared_ctx = (unsigned int)0x7fffffff * 2U + 1U;
    if(shared_ctx == 1U)
      shared_ctx=reserve_dnschild_ctx();

    return shared_ctx;
  }
}

// get_free_recv_buffer
// file recvbuff.c line 189
extern struct recvbuf * get_free_recv_buffer(void)
{
  struct recvbuf *buffer;

__CPROVER_DUMP_L1:
  ;
  do
  {
    buffer = free_recv_list;
    if(!(buffer == ((struct recvbuf *)NULL)))
      free_recv_list = buffer->link;


  __CPROVER_DUMP_L3:
    ;
  }
  while((_Bool)0);
  if(!(buffer == ((struct recvbuf *)NULL)))
  {
    free_recvbufs = free_recvbufs - 1ul;
    initialise_buffer(buffer);
    buffer->used = buffer->used + 1;
  }

  else
    buffer_shortfall = buffer_shortfall + 1ul;

__CPROVER_DUMP_L6:
  ;
  return buffer;
}

// get_full_recv_buffer
// file recvbuff.c line 226
extern struct recvbuf * get_full_recv_buffer(void)
{
  struct recvbuf *rbuf;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  do
  {
    rbuf = full_recv_fifo.phead;
    if(!(rbuf == ((struct recvbuf *)NULL)))
    {
      full_recv_fifo.phead = rbuf->link;
      if(full_recv_fifo.phead == ((struct recvbuf *)NULL))
        full_recv_fifo.pptail = (struct recvbuf **)(void *)0;

      else
        if(full_recv_fifo.pptail == &rbuf->link)
          full_recv_fifo.pptail = &full_recv_fifo.phead;

    }


  __CPROVER_DUMP_L4:
    ;

  __CPROVER_DUMP_L5:
    ;
  }
  while((_Bool)0);
  if(!(rbuf == ((struct recvbuf *)NULL)))
    full_recvbufs = full_recvbufs - 1ul;


__CPROVER_DUMP_L7:
  ;
  return rbuf;
}

// get_ostime
// file systime.c line 127
static inline void get_ostime(struct timespec *tsp)
{
  signed int rc;
  signed long int ticks;
  rc=clock_gettime(0, tsp);
  if(!(rc >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    msyslog(3, "read system clock failed: %m (%d)", *return_value___errno_location$1);
    exit(1);
  }

  if(!(trunc_os_clock == 0))
  {
    ticks = (signed long int)(((double)tsp->tv_nsec * 1e-9) / sys_tick);
    tsp->tv_nsec = (signed long int)((double)ticks * 1e9 * sys_tick);
  }

}

// get_struct_tm
// file prettydate.c line 63
static struct tm * get_struct_tm(const union anonymous$44 *stamp, signed int local)
{
  struct tm *tm = (struct tm *)(void *)0;
  signed int folds = 0;
  signed long int ts;
  signed long int tl = stamp->q_s;
  ts = tl;
  for( ; !(ts == tl); ts = tl)
    if(!(tl >= 0l))
    {
      folds = folds - 1;
      if(!(folds >= -3))
        return (struct tm *)(void *)0;

      tl = tl + (signed long int)0x34AADC80UL;
    }

    else
    {
      folds = folds + 1;
      if(folds >= 4)
        return (struct tm *)(void *)0;

      tl = tl - (signed long int)0x34AADC80UL;
    }
  tm=(local != 0 ? localtime : gmtime)(&ts);
  if(tm == ((struct tm *)NULL))
  {
    if(!(ts >= 0l))
    {
      folds = folds - 1;
      if(!(folds >= -3))
        return (struct tm *)(void *)0;

      ts = ts + (signed long int)0x34AADC80UL;
    }

    else
      if(ts >= 883612800l)
      {
        folds = folds + 1;
        if(folds >= 4)
          return (struct tm *)(void *)0;

        ts = ts - (signed long int)0x34AADC80UL;
      }

      else
        return (struct tm *)(void *)0;
  }

  if(!(tm == ((struct tm *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("prettydate.c", 144, (enum anonymous$46)isc_assertiontype_insist, "tm != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(folds == 0))
  {
    tm->tm_year = tm->tm_year + folds * 28;
    if(!(tm->tm_year >= 1))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = tm->tm_year >= 200 ? (_Bool)1 : (_Bool)0;
    return (struct tm *)(void *)0;
  }

  else
    return tm;
}

// get_systime
// file systime.c line 162
extern void get_systime(struct anonymous$20 *now)
{
  struct timespec ts;
  struct timespec ts_min;
  struct timespec ts_lam;
  struct timespec ts_prev_log;
  double dfuzz;
  double ddelta;
  struct anonymous$20 result;
  struct anonymous$20 lfpfuzz;
  struct anonymous$20 lfpdelta;
  get_ostime(&ts);

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  struct timespec return_value_add_tspec_ns$1;
  return_value_add_tspec_ns$1=add_tspec_ns(ts, (signed long int)50000000);
  signed int return_value_cmp_tspec$2;
  static struct timespec ts_last;
  return_value_cmp_tspec$2=cmp_tspec(return_value_add_tspec_ns$1, ts_last);
  if(!(return_value_cmp_tspec$2 >= 0))
    lamport_violated = 1;

  ts_last = ts;
  {
    static struct timespec ts_prev;
    ts_min=add_tspec_ns(ts_prev, sys_fuzz_nsec);
    signed int return_value_cmp_tspec$3;
    return_value_cmp_tspec$3=cmp_tspec(ts, ts_min);
    if(!(return_value_cmp_tspec$3 >= 0))
    {
      ts_lam=sub_tspec(ts_min, ts);
      if(lamport_violated == 0 && ts_lam.tv_sec >= 1l)
      {
        msyslog(3, "get_systime Lamport advance exceeds one second (%.9f)", (double)ts_lam.tv_sec + 1e-9 * (double)ts_lam.tv_nsec);
        exit(1);
      }

      if(lamport_violated == 0)
        ts = ts_min;

    }

    ts_prev_log = ts_prev;
    ts_prev = ts;
  }
  result=tspec_stamp_to_lfp(ts);
  signed long int return_value_ntp_random$4;
  return_value_ntp_random$4=ntp_random();
  dfuzz = (((double)return_value_ntp_random$4 * 2.) / 4294967296.0) * sys_fuzz;
  do
  {
    double d_tmp;
    unsigned long int q_tmp;
    signed int M_isneg;
    d_tmp = dfuzz;
    M_isneg = (signed int)(d_tmp < 0.);
    if(!(M_isneg == 0))
      d_tmp = -d_tmp;

    double return_value_ldexp$5;
    return_value_ldexp$5=ldexp(d_tmp, 32);
    q_tmp = (unsigned long int)return_value_ldexp$5;
    if(!(M_isneg == 0))
      q_tmp = ~q_tmp + (unsigned long int)1;

    (&lfpfuzz)->l_uf = (unsigned int)q_tmp;
    (&lfpfuzz)->Ul_i.Xl_ui = (unsigned int)(q_tmp >> 32);
  }
  while((_Bool)0);
  do
  {
    unsigned int add_t = (&result)->l_uf;
    (&result)->l_uf = (&result)->l_uf + (&lfpfuzz)->l_uf;
    (&result)->Ul_i.Xl_ui = (&result)->Ul_i.Xl_ui + (&lfpfuzz)->Ul_i.Xl_ui + (unsigned int)((unsigned int)(&result)->l_uf < add_t);
  }
  while((_Bool)0);
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  static double dfuzz_prev;
  static struct anonymous$20 lfp_prev;
  if(!((lfp_prev.Ul_i.Xl_ui | lfp_prev.l_uf) == 0u))
  {
    if(lamport_violated == 0)
    {
      if(!(lfp_prev.Ul_i.Xl_ui >= result.Ul_i.Xl_ui))
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        if(result.Ul_i.Xl_ui == lfp_prev.Ul_i.Xl_ui)
          tmp_if_expr$9 = (unsigned int)(&result)->l_uf > (unsigned int)(&lfp_prev)->l_uf ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$10)
      {
        if(sys_fuzz > 0.)
        {
          const char *return_value_tspectoa$6;
          return_value_tspectoa$6=tspectoa(ts_prev_log);
          const char *return_value_tspectoa$7;
          return_value_tspectoa$7=tspectoa(ts_min);
          msyslog(3, "ts_prev %s ts_min %s", return_value_tspectoa$6, return_value_tspectoa$7);
          const char *return_value_tspectoa$8;
          return_value_tspectoa$8=tspectoa(ts);
          msyslog(3, "ts %s", return_value_tspectoa$8);
          msyslog(3, "sys_fuzz %ld nsec, prior fuzz %.9f", sys_fuzz_nsec, dfuzz_prev);
          msyslog(3, "this fuzz %.9f", dfuzz);
          lfpdelta = lfp_prev;
          do
          {
            unsigned int sub_t = (&lfpdelta)->l_uf;
            (&lfpdelta)->l_uf = (&lfpdelta)->l_uf - (&result)->l_uf;
            (&lfpdelta)->Ul_i.Xl_ui = (&lfpdelta)->Ul_i.Xl_ui - ((&result)->Ul_i.Xl_ui + (unsigned int)((unsigned int)(&lfpdelta)->l_uf > sub_t));
          }
          while((_Bool)0);
          do
          {
            double get_systime$$1$$7$$1$$1$$2$$d_tmp;
            unsigned long int get_systime$$1$$7$$1$$1$$2$$q_tmp;
            signed int get_systime$$1$$7$$1$$1$$2$$M_isneg;
            get_systime$$1$$7$$1$$1$$2$$q_tmp = ((unsigned long int)(&lfpdelta)->Ul_i.Xl_ui << 32) + (unsigned long int)(&lfpdelta)->l_uf;
            get_systime$$1$$7$$1$$1$$2$$M_isneg = (signed int)(((&lfpdelta)->Ul_i.Xl_ui & 0x80000000) != (unsigned int)0);
            if(!(get_systime$$1$$7$$1$$1$$2$$M_isneg == 0))
              get_systime$$1$$7$$1$$1$$2$$q_tmp = ~get_systime$$1$$7$$1$$1$$2$$q_tmp + (unsigned long int)1;

            get_systime$$1$$7$$1$$1$$2$$d_tmp=ldexp((double)get_systime$$1$$7$$1$$1$$2$$q_tmp, -32);
            if(!(get_systime$$1$$7$$1$$1$$2$$M_isneg == 0))
              get_systime$$1$$7$$1$$1$$2$$d_tmp = -get_systime$$1$$7$$1$$1$$2$$d_tmp;

            ddelta = get_systime$$1$$7$$1$$1$$2$$d_tmp;
          }
          while((_Bool)0);
          msyslog(3, "prev get_systime 0x%x.%08x is %.9f later than 0x%x.%08x", lfp_prev.Ul_i.Xl_ui, lfp_prev.l_uf, ddelta, result.Ul_i.Xl_ui, result.l_uf);
        }

      }

    }

  }

  lfp_prev = result;
  dfuzz_prev = dfuzz;
  if(!(lamport_violated == 0))
    lamport_violated = 0;


__CPROVER_DUMP_L21:
  ;
  *now = result;
}

// get_worker_context
// file ntp_intres.c line 965
static struct dnsworker_ctx_tag * get_worker_context(struct blocking_child_tag *c, unsigned int idx)
{
  unsigned int min_new_alloc;
  unsigned int new_alloc;
  unsigned long int octets;
  unsigned long int new_octets;
  if(idx >= dnsworker_contexts_alloc)
  {
    min_new_alloc = (unsigned int)1 + idx;
    new_alloc = min_new_alloc + (unsigned int)4 & (unsigned int)~(4 - 1);
    static unsigned long int ps = sizeof(struct dnsworker_ctx_tag *) /*8ul*/ ;
    new_octets = (unsigned long int)new_alloc * ps;
    octets = (unsigned long int)dnsworker_contexts_alloc * ps;
    void *return_value_ereallocz$1;
    return_value_ereallocz$1=ereallocz((void *)dnsworker_contexts, new_octets, octets, 1);
    dnsworker_contexts = (struct dnsworker_ctx_tag **)return_value_ereallocz$1;
    dnsworker_contexts_alloc = new_alloc;
  }

  if(dnsworker_contexts[(signed long int)idx] == ((struct dnsworker_ctx_tag *)NULL))
    alloc_dnsworker_context(idx);

  bzero((void *)&(*dnsworker_contexts[(signed long int)idx]), sizeof(struct dnsworker_ctx_tag) /*24ul*/ );
  dnsworker_contexts[(signed long int)idx]->c = c;
  return dnsworker_contexts[(signed long int)idx];
}

// getaddrinfo_sometime
// file ntp_intres.c line 235
extern signed int getaddrinfo_sometime(const char *node, const char *service, struct addrinfo *hints, signed int retry, void (*callback)(signed int, signed int, void *, const char *, const char *, struct addrinfo *, struct addrinfo *), void *context)
{
  struct blocking_gai_req_tag *gai_req;
  unsigned int idx;
  struct dnschild_ctx_tag *child_ctx;
  unsigned long int req_size;
  unsigned long int nodesize;
  unsigned long int servsize;
  signed long int getaddrinfo_sometime$$1$$now;
  if(!(node == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_intres.c", 252, (enum anonymous$46)isc_assertiontype_require, "((void *)0) != node");
    (_Bool)0;
  }
  if(!(hints == ((struct addrinfo *)NULL)))
  {
    if(hints->ai_addrlen == 0u)
      (_Bool)1;

    else
    {
      isc_assertion_failed("ntp_intres.c", 254, (enum anonymous$46)isc_assertiontype_require, "0 == hints->ai_addrlen");
      (_Bool)0;
    }
    if(hints->ai_addr == ((struct sockaddr *)NULL))
      (_Bool)1;

    else
    {
      isc_assertion_failed("ntp_intres.c", 255, (enum anonymous$46)isc_assertiontype_require, "((void *)0) == hints->ai_addr");
      (_Bool)0;
    }
    if(hints->ai_canonname == ((char *)NULL))
      (_Bool)1;

    else
    {
      isc_assertion_failed("ntp_intres.c", 256, (enum anonymous$46)isc_assertiontype_require, "((void *)0) == hints->ai_canonname");
      (_Bool)0;
    }
    if(hints->ai_next == ((struct addrinfo *)NULL))
      (_Bool)1;

    else
    {
      isc_assertion_failed("ntp_intres.c", 257, (enum anonymous$46)isc_assertiontype_require, "((void *)0) == hints->ai_next");
      (_Bool)0;
    }
  }

  idx=get_dnschild_ctx();
  child_ctx = dnschild_contexts[(signed long int)idx];
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(node);
  nodesize = return_value_strlen$1 + (unsigned long int)1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(service);
  servsize = return_value_strlen$2 + (unsigned long int)1;
  req_size = sizeof(struct blocking_gai_req_tag) /*120ul*/  + nodesize + servsize;
  void *return_value_ereallocz$3;
  return_value_ereallocz$3=ereallocz((void *)0, req_size, (unsigned long int)0, 1);
  gai_req = (struct blocking_gai_req_tag *)return_value_ereallocz$3;
  gai_req->octets = req_size;
  gai_req->dns_idx = idx;
  getaddrinfo_sometime$$1$$now=time((signed long int *)(void *)0);
  gai_req->scheduled = getaddrinfo_sometime$$1$$now;
  signed long int tmp_if_expr$4;
  if(!(child_ctx->next_dns_timeslot >= getaddrinfo_sometime$$1$$now))
    tmp_if_expr$4 = getaddrinfo_sometime$$1$$now;

  else
    tmp_if_expr$4 = child_ctx->next_dns_timeslot;
  gai_req->earliest = tmp_if_expr$4;
  child_ctx->next_dns_timeslot = gai_req->earliest;
  if(!(hints == ((struct addrinfo *)NULL)))
    gai_req->hints = *hints;

  gai_req->retry = retry;
  gai_req->callback = callback;
  gai_req->context = context;
  gai_req->nodesize = nodesize;
  gai_req->servsize = servsize;
  memcpy((void *)((char *)gai_req + (signed long int)sizeof(struct blocking_gai_req_tag) /*120ul*/ ), (const void *)node, nodesize);
  memcpy((void *)((char *)gai_req + (signed long int)sizeof(struct blocking_gai_req_tag) /*120ul*/  + (signed long int)nodesize), (const void *)service, servsize);
  signed int return_value_queue_blocking_request$6;
  return_value_queue_blocking_request$6=queue_blocking_request((enum blocking_work_req_tag)BLOCKING_GETADDRINFO, (void *)gai_req, req_size, getaddrinfo_sometime_complete, (void *)gai_req);
  if(!(return_value_queue_blocking_request$6 == 0))
  {
    msyslog(3, "unable to queue getaddrinfo request");
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    *return_value___errno_location$5 = 14;
    return -1;
  }

  return 0;
}

// getaddrinfo_sometime_complete
// file ntp_intres.c line 458
static void getaddrinfo_sometime_complete(enum blocking_work_req_tag rtype, void *context, unsigned long int respsize, void *resp)
{
  struct blocking_gai_req_tag *gai_req;
  struct blocking_gai_resp_tag *gai_resp;
  struct dnschild_ctx_tag *child_ctx;
  struct addrinfo *ai;
  struct addrinfo *next_ai;
  union anonymous$47 *psau;
  char *node;
  char *service;
  char *canon_start;
  signed long int time_now;
  signed int again;
  signed int af;
  const char *fam_spec;
  signed int i;
  gai_req = (struct blocking_gai_req_tag *)context;
  gai_resp = (struct blocking_gai_resp_tag *)resp;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  node = (char *)gai_req + (signed long int)sizeof(struct blocking_gai_req_tag) /*120ul*/ ;
  service = node + (signed long int)gai_req->nodesize;
  child_ctx = dnschild_contexts[(signed long int)gai_req->dns_idx];
  const char *return_value_humantime$1;
  const char *return_value_gai_strerror$3;
  if(gai_resp->retcode == 0)
  {
    if(gai_resp->retry >= 3)
    {
      time_now=time((signed long int *)(void *)0);
      child_ctx->next_dns_timeslot = time_now;
      do
        if(debug >= 1)
        {
          return_value_humantime$1=humantime(time_now);
          mprintf("DNS success after retry, %u next_dns_timeslot reset (%s)\n", gai_req->dns_idx, return_value_humantime$1);
        }

      while((_Bool)0);
    }

  }

  else
  {
    again=should_retry_dns(gai_resp->retcode, gai_resp->gai_errno);
    if(gai_req->retry >= 1)
    {
      if(!(again == 0))
      {
        if(gai_req->retry == 2)
        {
          if(!((1u & ntp_syslogmask) == 0u))
          {
            af = gai_req->hints.ai_family;
            fam_spec = 10 == af ? " (AAAA)" : (2 == af ? " (A)" : "");
            if(gai_resp->retcode == -11)
            {
              signed int *return_value___errno_location$2;
              return_value___errno_location$2=__errno_location();
              *return_value___errno_location$2 = gai_resp->gai_errno;
              msyslog(6, "retrying DNS %s%s: EAI_SYSTEM %d: %m", node, fam_spec, gai_resp->gai_errno);
            }

            else
            {
              return_value_gai_strerror$3=gai_strerror(gai_resp->retcode);
              msyslog(6, "retrying DNS %s%s: %s (%d)", node, fam_spec, return_value_gai_strerror$3, gai_resp->retcode);
            }
          }

        }

        manage_dns_retry_interval(&gai_req->scheduled, &gai_req->earliest, &gai_req->retry, &child_ctx->next_dns_timeslot);
        signed int return_value_queue_blocking_request$4;
        return_value_queue_blocking_request$4=queue_blocking_request((enum blocking_work_req_tag)BLOCKING_GETADDRINFO, (void *)gai_req, gai_req->octets, getaddrinfo_sometime_complete, (void *)gai_req);
        if(return_value_queue_blocking_request$4 == 0)
          goto __CPROVER_DUMP_L23;

        else
          msyslog(3, "unable to retry hostname %s", node);
      }

    }

  }
  ai = (struct addrinfo *)(void *)((char *)gai_resp + (signed long int)sizeof(struct blocking_gai_resp_tag) /*24ul*/ );
  next_ai = (struct addrinfo *)(void *)0;
  i = gai_resp->ai_count - 1;
  for( ; i >= 0; i = i - 1)
  {
    (ai + (signed long int)i)->ai_next = next_ai;
    next_ai = &ai[(signed long int)i];
  }
  psau = (union anonymous$47 *)(void *)((char *)ai + (signed long int)((unsigned long int)gai_resp->ai_count * sizeof(struct addrinfo) /*48ul*/ ));
  canon_start = (char *)psau + (signed long int)((unsigned long int)gai_resp->ai_count * sizeof(union anonymous$47) /*28ul*/ );
  i = 0;
  for( ; !(i >= gai_resp->ai_count); i = i + 1)
  {
    if(!((ai + (signed long int)i)->ai_addr == ((struct sockaddr *)NULL)))
      (ai + (signed long int)i)->ai_addr = &psau->sa;

    psau = psau + 1l;
    if(!((ai + (signed long int)i)->ai_canonname == ((char *)NULL)))
      (ai + (signed long int)i)->ai_canonname = (ai + (signed long int)i)->ai_canonname + (signed long int)(unsigned long int)canon_start;

  }
  if((char *)psau == canon_start)
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_intres.c", 571, (enum anonymous$46)isc_assertiontype_ensure, "(char *)psau == canon_start");
    (_Bool)0;
  }
  if(gai_resp->ai_count == 0)
    ai = (struct addrinfo *)(void *)0;

  gai_req->callback(gai_resp->retcode, gai_resp->gai_errno, gai_req->context, node, service, &gai_req->hints, ai);
  free((void *)gai_req);

__CPROVER_DUMP_L23:
  ;
}

// getcode
// file statestr.c line 286
static const char * getcode(signed int code, struct codestring *codetab)
{
  char *buf;
  for( ; !(codetab->code == -1); codetab = codetab + 1l)
    if(codetab->code == code)
      return codetab->string;

  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    buf = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  snprintf(buf, (unsigned long int)128, "%s_%d", codetab->string, code);
  return buf;
}

// getevents
// file statestr.c line 309
static const char * getevents(signed int cnt)
{
  char *buf;
  signed int tmp_post$1;
  if(cnt == 0)
    return "no events";

  else
  {
    do
    {
      bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
      tmp_post$1 = lib_nextbuf;
      lib_nextbuf = lib_nextbuf + 1;
      buf = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
      lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
    }
    while((_Bool)0);
    snprintf(buf, (unsigned long int)128, "%d event%s", cnt, 1 == cnt ? "" : "s");
    return buf;
  }
}

// getnameinfo_sometime
// file ntp_intres.c line 623
extern signed int getnameinfo_sometime(union anonymous$47 *psau, unsigned long int hostoctets, unsigned long int servoctets, signed int flags, void (*callback)(signed int, signed int, union anonymous$47 *, signed int, const char *, const char *, void *), void *context)
{
  struct blocking_gni_req_tag *gni_req;
  unsigned int idx;
  struct dnschild_ctx_tag *child_ctx;
  signed long int time_now;
  if(!(hostoctets == 0ul))
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_intres.c", 637, (enum anonymous$46)isc_assertiontype_require, "hostoctets");
    (_Bool)0;
  }
  if(!(hostoctets + servoctets >= 1024ul))
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_intres.c", 638, (enum anonymous$46)isc_assertiontype_require, "hostoctets + servoctets < 1024");
    (_Bool)0;
  }
  idx=get_dnschild_ctx();
  child_ctx = dnschild_contexts[(signed long int)idx];
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, sizeof(struct blocking_gni_req_tag) /*112ul*/ , (unsigned long int)0, 1);
  gni_req = (struct blocking_gni_req_tag *)return_value_ereallocz$1;
  gni_req->octets = sizeof(struct blocking_gni_req_tag) /*112ul*/ ;
  gni_req->dns_idx = idx;
  time_now=time((signed long int *)(void *)0);
  gni_req->scheduled = time_now;
  signed long int tmp_if_expr$2;
  if(!(child_ctx->next_dns_timeslot >= time_now))
    tmp_if_expr$2 = time_now;

  else
    tmp_if_expr$2 = child_ctx->next_dns_timeslot;
  gni_req->earliest = tmp_if_expr$2;
  child_ctx->next_dns_timeslot = gni_req->earliest;
  memcpy((void *)&gni_req->socku, (const void *)psau, 2 == (signed int)psau->sa.sa_family ? sizeof(struct sockaddr_in) /*16ul*/  : sizeof(struct sockaddr_in6) /*28ul*/ );
  gni_req->hostoctets = hostoctets;
  gni_req->servoctets = servoctets;
  gni_req->flags = flags;
  gni_req->retry = 2;
  gni_req->callback = callback;
  gni_req->context = context;
  signed int return_value_queue_blocking_request$4;
  return_value_queue_blocking_request$4=queue_blocking_request((enum blocking_work_req_tag)BLOCKING_GETNAMEINFO, (void *)gni_req, sizeof(struct blocking_gni_req_tag) /*112ul*/ , getnameinfo_sometime_complete, (void *)gni_req);
  if(!(return_value_queue_blocking_request$4 == 0))
  {
    msyslog(3, "unable to queue getnameinfo request");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 14;
    return -1;
  }

  return 0;
}

// getnameinfo_sometime_complete
// file ntp_intres.c line 789
static void getnameinfo_sometime_complete(enum blocking_work_req_tag rtype, void *context, unsigned long int respsize, void *resp)
{
  struct blocking_gni_req_tag *gni_req;
  struct blocking_gni_resp_tag *gni_resp;
  struct dnschild_ctx_tag *child_ctx;
  char *host;
  char *service;
  signed long int time_now;
  signed int again;
  gni_req = (struct blocking_gni_req_tag *)context;
  gni_resp = (struct blocking_gni_resp_tag *)resp;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  child_ctx = dnschild_contexts[(signed long int)gni_req->dns_idx];
  const char *return_value_humantime$1;
  if(gni_resp->retcode == 0)
  {
    if(gni_resp->retry >= 3)
    {
      time_now=time((signed long int *)(void *)0);
      child_ctx->next_dns_timeslot = time_now;
      do
        if(debug >= 1)
        {
          return_value_humantime$1=humantime(time_now);
          mprintf("DNS success after retry, %u next_dns_timeslot reset (%s)\n", gni_req->dns_idx, return_value_humantime$1);
        }

      while((_Bool)0);
    }

  }

  else
  {
    again=should_retry_dns(gni_resp->retcode, gni_resp->gni_errno);
    if(gni_req->retry >= 1)
      manage_dns_retry_interval(&gni_req->scheduled, &gni_req->earliest, &gni_req->retry, &child_ctx->next_dns_timeslot);

    if(gni_req->retry >= 1)
    {
      if(!(again == 0))
      {
        signed int return_value_queue_blocking_request$2;
        return_value_queue_blocking_request$2=queue_blocking_request((enum blocking_work_req_tag)BLOCKING_GETNAMEINFO, (void *)gni_req, gni_req->octets, getnameinfo_sometime_complete, (void *)gni_req);
        if(return_value_queue_blocking_request$2 == 0)
          goto __CPROVER_DUMP_L14;

        const char *return_value_socktoa$3;
        return_value_socktoa$3=socktoa(&gni_req->socku);
        msyslog(3, "unable to retry reverse lookup of %s", return_value_socktoa$3);
      }

    }

  }
  char *tmp_if_expr$4;
  if(gni_resp->hostoctets == 0ul)
  {
    host = (char *)(void *)0;
    service = (char *)(void *)0;
  }

  else
  {
    host = (char *)gni_resp + (signed long int)sizeof(struct blocking_gni_resp_tag) /*40ul*/ ;
    if(!(gni_resp->servoctets == 0ul))
      tmp_if_expr$4 = host + (signed long int)gni_resp->hostoctets;

    else
      tmp_if_expr$4 = (char *)(void *)0;
    service = tmp_if_expr$4;
  }
  gni_req->callback(gni_resp->retcode, gni_resp->gni_errno, &gni_req->socku, gni_req->flags, host, service, gni_req->context);
  free((void *)gni_req);

__CPROVER_DUMP_L14:
  ;
}

// getpass_keytype
// file ssl_init.c line 168
extern char * getpass_keytype(signed int keytype)
{
  char pass_prompt[76l];
  const char *return_value_keytype_name$1;
  return_value_keytype_name$1=keytype_name(keytype);
  snprintf(pass_prompt, sizeof(char [76l]) /*76ul*/ , "%.64s Password: ", return_value_keytype_name$1);
  char *return_value_getpass$2;
  return_value_getpass$2=getpass(pass_prompt);
  return return_value_getpass$2;
}

// gmprettydate
// file prettydate.c line 214
extern char * gmprettydate(struct anonymous$20 *ts)
{
  char *return_value_common_prettydate$1;
  return_value_common_prettydate$1=common_prettydate(ts, 0);
  return return_value_common_prettydate$1;
}

// good_rand
// file ntp_random.c line 216
static inline signed long int good_rand(signed long int x)
{
  signed long int hi;
  signed long int lo;
  hi = x / (signed long int)127773;
  lo = x % (signed long int)127773;
  x = (signed long int)16807 * lo - (signed long int)2836 * hi;
  if(!(x >= 1l))
    x = x + (signed long int)0x7fffffff;

  return x;
}

// greatest_version
// file ./../lib/isc/log.c line 1144
static unsigned int greatest_version(struct isc_logchannel *channel, signed int *greatestp)
{
  char *basenam;
  char *digit_end;
  const char *dirname;
  signed int version;
  signed int greatest = -1;
  unsigned int basenamelen;
  struct isc_dir dir;
  unsigned int result;
  char sep = (char)47;
  if(channel->type == 3u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1157, (enum anonymous$46)isc_assertiontype_require, "channel->type == 3");
    (_Bool)0;
  }
  basenam=strrchr(channel->destination.file.name, (signed int)sep);
  char *tmp_post$1;
  if(!(basenam == ((char *)NULL)))
  {
    tmp_post$1 = basenam;
    basenam = basenam + 1l;
    *tmp_post$1 = (char)0;
    dirname = channel->destination.file.name;
  }

  else
  {
    do
    {
      /* tag-#anon#lUN[l*{clV}$clV$'k'||l*{lV}$lV$'v'|] */
union anonymous$9
{
  // k
  const void *k;
  // v
  void *v;
};

/* */
      ;
      union anonymous$9 _u;
      _u.k = (const void *)channel->destination.file.name;
      basenam = (char *)_u.v;
    }
    while((_Bool)0);
    dirname = ".";
  }
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(basenam);
  basenamelen = (unsigned int)return_value_strlen$2;
  isc_dir_init(&dir);
  result=isc_dir_open(&dir, dirname);
  if(!(basenam == channel->destination.file.name))
    *(basenam - (signed long int)1) = sep;

  unsigned int return_value_isc_dir_read$3;
  signed int return_value_strncmp$5;
  if(!(result == 0u))
    return result;

  else
  {
    do
    {
      return_value_isc_dir_read$3=isc_dir_read(&dir);
      if(!(return_value_isc_dir_read$3 == 0u))
        break;

      if(!(basenamelen >= dir.entry.length))
      {
        return_value_strncmp$5=strncmp(dir.entry.name, basenam, (unsigned long int)basenamelen);
        if(return_value_strncmp$5 == 0)
        {
          if((signed int)dir.entry.name[(signed long int)basenamelen] == 46)
          {
            signed long int return_value_strtol$4;
            return_value_strtol$4=strtol(&dir.entry.name[(signed long int)(basenamelen + (unsigned int)1)], &digit_end, 10);
            version = (signed int)return_value_strtol$4;
            if((signed int)*digit_end == 0)
            {
              if(!(greatest >= version))
                greatest = version;

            }

          }

        }

      }

    }
    while((_Bool)1);
    isc_dir_close(&dir);
    greatest = greatest + 1;
    *greatestp = greatest;
    return (unsigned int)0;
  }
}

// has_full_recv_buffer
// file recvbuff.c line 296
extern enum anonymous$11 has_full_recv_buffer(void)
{
  if(!(full_recv_fifo.phead == ((struct recvbuf *)NULL)))
    return (enum anonymous$11)isc_boolean_true;

  else
    return (enum anonymous$11)isc_boolean_false;
}

// hextoint
// file hextoint.c line 11
extern signed int hextoint(const char *str, unsigned long int *pu)
{
  unsigned long int u;
  const char *cp = str;
  _Bool tmp_if_expr$7;
  const char *tmp_post$2;
  _Bool tmp_if_expr$6;
  const char *tmp_post$3;
  _Bool tmp_if_expr$5;
  const char *tmp_post$4;
  if((signed int)*cp == 0)
    return 0;

  else
  {
    u = (unsigned long int)0;
    while(!((signed int)*cp == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$1;
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((4096 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
        return 0;

      if(!((4026531840ul & u) == 0ul))
        return 0;

      u = u << 4;
      if((signed int)*cp >= 48)
        tmp_if_expr$7 = (signed int)*cp <= 57 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      if(tmp_if_expr$7)
      {
        tmp_post$2 = cp;
        cp = cp + 1l;
        u = u + (unsigned long int)((signed int)*tmp_post$2 - 48);
      }

      else
      {
        if((signed int)*cp >= 97)
          tmp_if_expr$6 = (signed int)*cp <= 102 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
        {
          tmp_post$3 = cp;
          cp = cp + 1l;
          u = u + (unsigned long int)(((signed int)*tmp_post$3 - 97) + 10);
        }

        else
        {
          if((signed int)*cp >= 65)
            tmp_if_expr$5 = (signed int)*cp <= 70 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          if(tmp_if_expr$5)
          {
            tmp_post$4 = cp;
            cp = cp + 1l;
            u = u + (unsigned long int)(((signed int)*tmp_post$4 - 65) + 10);
          }

          else
            return 0;
        }
      }
    }
    *pu = u;
    return 1;
  }
}

// hextolfp
// file hextolfp.c line 13
extern signed int hextolfp(const char *str, struct anonymous$20 *lfp)
{
  const char *cp;
  const char *cpstart;
  unsigned long int dec_i;
  unsigned long int dec_f;
  char *ind = (char *)(void *)0;
  dec_f = (unsigned long int)0;
  dec_i = dec_f;
  cp = str;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
      break;

    cp = cp + 1l;
  }
  while((_Bool)1);
  cpstart = cp;
  static const char *digits = "0123456789abcdefABCDEF";
  for( ; !((signed int)*cp == 0); cp = cp + 1l)
  {
    if(cp - cpstart >= 8l)
      break;

    ind=strchr(digits, (signed int)*cp);
    if(ind == ((char *)NULL))
      break;

    dec_i = dec_i << 4;
    dec_i = dec_i + (unsigned long int)(ind - digits > (signed long int)15 ? (ind - digits) - (signed long int)6 : ind - digits);
  }
  const unsigned short int **return_value___ctype_b_loc$2;
  if(ind == ((char *)NULL) || !(cp - cpstart >= 8l))
    return 0;

  else
  {
    if((signed int)*cp == 46)
      cp = cp + 1l;

    cpstart = cp;
    for( ; !((signed int)*cp == 0); cp = cp + 1l)
    {
      if(cp - cpstart >= 8l)
        break;

      ind=strchr(digits, (signed int)*cp);
      if(ind == ((char *)NULL))
        break;

      dec_f = dec_f << 4;
      dec_f = dec_f + (unsigned long int)(ind - digits > (signed long int)15 ? (ind - digits) - (signed long int)6 : ind - digits);
    }
    if(ind == ((char *)NULL) || !(cp - cpstart >= 8l))
      return 0;

    else
      if(!((signed int)*cp == 0))
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)*cp]) == 0))
          goto __CPROVER_DUMP_L10;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L10:
        ;
        lfp->Ul_i.Xl_ui = (unsigned int)dec_i;
        lfp->l_uf = (unsigned int)dec_f;
        return 1;
      }
  }
}

// humanlogtime
// file humandate.c line 17
extern const char * humanlogtime(void)
{
  char *bp;
  signed long int cursec;
  struct tm *tm;
  cursec=time((signed long int *)(void *)0);
  tm=localtime(&cursec);
  signed int tmp_post$1;
  if(tm == ((struct tm *)NULL))
    return "-- --- --:--:--";

  else
  {
    do
    {
      bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
      tmp_post$1 = lib_nextbuf;
      lib_nextbuf = lib_nextbuf + 1;
      bp = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
      lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
    }
    while((_Bool)0);
    snprintf(bp, (unsigned long int)128, "%2d %s %02d:%02d:%02d", tm->tm_mday, months[(signed long int)tm->tm_mon], tm->tm_hour, tm->tm_min, tm->tm_sec);
    return bp;
  }
}

// humantime
// file humandate.c line 43
extern const char * humantime(signed long int cursec)
{
  char *bp;
  struct tm *tm;
  tm=localtime(&cursec);
  signed int tmp_post$1;
  if(tm == ((struct tm *)NULL))
    return "--:--:--";

  else
  {
    do
    {
      bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
      tmp_post$1 = lib_nextbuf;
      lib_nextbuf = lib_nextbuf + 1;
      bp = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
      lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
    }
    while((_Bool)0);
    snprintf(bp, (unsigned long int)128, "%02d:%02d:%02d", tm->tm_hour, tm->tm_min, tm->tm_sec);
    return bp;
  }
}

// icmpv64
// file vint64ops.c line 128
extern signed int icmpv64(const union anonymous$44 *lhs, const union anonymous$44 *rhs)
{
  signed int res = (signed int)(lhs->q_s > rhs->q_s) - (signed int)(lhs->q_s < rhs->q_s);
  return res;
}

// icom_freq
// file icom.c line 72
signed int icom_freq(signed int fd, signed int ident, double freq)
{
  unsigned char cmd[12l] = { (unsigned char)0xff, (unsigned char)0xfe, (unsigned char)0xfe, (unsigned char)0, (unsigned char)0xe0, (unsigned char)0x05, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0xfd, (unsigned char)0xfd };
  signed int temp;
  signed int rc;
  cmd[(signed long int)3] = (unsigned char)(char)ident;
  if(ident == 0x04)
    temp = 4;

  else
    temp = 5;
  doublefreq(freq * 1e6, &cmd[(signed long int)6], temp);
  signed long int return_value_write$1;
  return_value_write$1=write(fd, (const void *)cmd, (unsigned long int)(temp + 7));
  rc = (signed int)return_value_write$1;
  if(rc == -1)
  {
    msyslog(3, "icom_freq: write() failed: %m");
    return -1;
  }

  else
    if(!(rc == 7 + temp))
    {
      msyslog(3, "icom_freq: only wrote %d of %d bytes.", rc, temp + 7);
      return 1;
    }

  return 0;
}

// icom_init
// file icom.c line 139
signed int icom_init(const char *device, signed int speed, signed int trace)
{
  struct termios ttyb;
  signed int fd;
  signed int rc;
  signed int saved_errno;
  fd=open(device, 02, 0777);
  if(!(fd >= 0))
    return -1;

  else
  {
    rc=tcgetattr(fd, &ttyb);
    if(!(rc >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      saved_errno = *return_value___errno_location$1;
      close(fd);
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = saved_errno;
      return -1;
    }

    ttyb.c_iflag = (unsigned int)0;
    ttyb.c_oflag = (unsigned int)0;
    ttyb.c_cflag = (unsigned int)(0000011 | 0000060 | 0004000);
    ttyb.c_lflag = (unsigned int)0;
    ttyb.c_cc[(signed long int)6] = (unsigned char)0;
    ttyb.c_cc[(signed long int)5] = (unsigned char)5;
    cfsetispeed(&ttyb, (unsigned int)speed);
    cfsetospeed(&ttyb, (unsigned int)speed);
    rc=tcsetattr(fd, 0, &ttyb);
    if(!(rc >= 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      saved_errno = *return_value___errno_location$3;
      close(fd);
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = saved_errno;
      return -1;
    }

    return fd;
  }
}

// inet_ntop4
// file ./../lib/isc/inet_ntop.c line 89
static const char * inet_ntop4(const unsigned char *src, char *dst, unsigned long int size)
{
  char tmp[(signed long int)sizeof(char [16l]) /*16l*/ ];
  signed int len;
  static const char *fmt = "%u.%u.%u.%u";
  len=snprintf(tmp, sizeof(char [16l]) /*16ul*/ , fmt, src[(signed long int)0], src[(signed long int)1], src[(signed long int)2], src[(signed long int)3]);
  if((unsigned long int)len >= size || !(len >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 28;
    return (const char *)(void *)0;
  }

  memcpy((void *)dst, (const void *)tmp, (unsigned long int)(1 + len));
  return dst;
}

// inet_ntop6
// file ./../lib/isc/inet_ntop.c line 114
static const char * inet_ntop6(const unsigned char *src, char *dst, unsigned long int size)
{
  char tmp[(signed long int)sizeof(char [46l]) /*46l*/ ];
  char *tp;
  /* tag-#anon#lST[S32'base'||S32'len'|] */
struct anonymous$15
{
  // base
  signed int base;
  // len
  signed int len;
};

/* */
  ;
  struct anonymous$15 best;
  struct anonymous$15 cur;
  unsigned int words[8l];
  signed int i;
  memset((void *)words, 0, sizeof(unsigned int [8l]) /*32ul*/ );
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    words[(signed long int)(i / 2)] = words[(signed long int)(i / 2)] | (unsigned int)((signed int)src[(signed long int)i] << (1 - i % 2 << 3));
  best.base = -1;
  cur.base = -1;
  cur.len = 0;
  best.len = cur.len;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    if(words[(signed long int)i] == 0u)
    {
      if(cur.base == -1)
      {
        cur.base = i;
        cur.len = 1;
      }

      else
        cur.len = cur.len + 1;
    }

    else
      if(!(cur.base == -1))
      {
        if(best.base == -1 || !(best.len >= cur.len))
          best = cur;

        cur.base = -1;
      }

  if(!(cur.base == -1))
  {
    if(best.base == -1 || !(best.len >= cur.len))
      best = cur;

  }

  if(!(best.base == -1) && !(best.len >= 2))
    best.base = -1;

  tp = tmp;
  i = 0;
  char *tmp_post$1;
  char *tmp_post$2;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  for( ; !(i >= 8); i = i + 1)
    if(i >= best.base && !(best.base == -1) && !(i >= best.base + best.len))
    {
      if(i == best.base)
      {
        tmp_post$1 = tp;
        tp = tp + 1l;
        *tmp_post$1 = (char)58;
      }

    }

    else
    {
      if(!(i == 0))
      {
        tmp_post$2 = tp;
        tp = tp + 1l;
        *tmp_post$2 = (char)58;
      }

      if(best.base == 0 && i == 6)
      {
        if(best.len == 6)
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          if(best.len == 7)
            tmp_if_expr$5 = words[(signed long int)7] != (unsigned int)0x0001 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          if(best.len == 5)
            tmp_if_expr$7 = words[(signed long int)5] == (unsigned int)0xffff ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          const char *return_value_inet_ntop4$3;
          return_value_inet_ntop4$3=inet_ntop4(src + (signed long int)12, tp, sizeof(char [46l]) /*46ul*/  - (unsigned long int)(tp - tmp));
          if(return_value_inet_ntop4$3 == ((const char *)NULL))
            return (const char *)(void *)0;

          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(tp);
          tp = tp + (signed long int)return_value_strlen$4;
          break;
        }

      }

      signed int return_value_snprintf$9;
      return_value_snprintf$9=snprintf(tp, sizeof(char [46l]) /*46ul*/  - (unsigned long int)(tp - tmp), "%x", words[(signed long int)i]);
      tp = tp + (signed long int)return_value_snprintf$9;
    }
  char *tmp_post$10;
  if(best.base + best.len == 8 && !(best.base == -1))
  {
    tmp_post$10 = tp;
    tp = tp + 1l;
    *tmp_post$10 = (char)58;
  }

  char *tmp_post$11 = tp;
  tp = tp + 1l;
  *tmp_post$11 = (char)0;
  if(!(size >= (unsigned long int)(tp - tmp)))
  {
    signed int *return_value___errno_location$12;
    return_value___errno_location$12=__errno_location();
    *return_value___errno_location$12 = 28;
    return (const char *)(void *)0;
  }

  memcpy((void *)dst, (const void *)tmp, (unsigned long int)(tp - tmp));
  return dst;
}

// inet_pton4
// file ./../lib/isc/inet_pton.c line 83
static signed int inet_pton4(const char *src, unsigned char *dst)
{
  signed int saw_digit;
  signed int octets;
  signed int ch;
  unsigned char tmp[4l];
  unsigned char *tp;
  saw_digit = 0;
  octets = 0;
  tp = tmp;
  *tp = (unsigned char)0;
  const char *tmp_post$1;
  do
  {
    tmp_post$1 = src;
    src = src + 1l;
    ch = (signed int)*tmp_post$1;
    if(ch == 0)
      break;

    const char *pch;
    static const char digits[11l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0 };
    pch=strchr(digits, ch);
    if(!(pch == ((const char *)NULL)))
    {
      unsigned int newv = (unsigned int)((signed long int)((signed int)*tp * 10) + (pch - digits));
      if(!(saw_digit == 0))
      {
        if((signed int)*tp == 0)
          return 0;

      }

      if(newv >= 256u)
        return 0;

      *tp = (unsigned char)newv;
      if(saw_digit == 0)
      {
        octets = octets + 1;
        if(octets >= 5)
          return 0;

        saw_digit = 1;
      }

    }

    else
      if(ch == 46 && !(saw_digit == 0))
      {
        if(octets == 4)
          return 0;

        tp = tp + 1l;
        *tp = (unsigned char)0;
        saw_digit = 0;
      }

      else
        return 0;
  }
  while((_Bool)1);
  if(!(octets >= 4))
    return 0;

  else
  {
    memcpy((void *)dst, (const void *)tmp, (unsigned long int)4);
    return 1;
  }
}

// inet_pton6
// file ./../lib/isc/inet_pton.c line 135
static signed int inet_pton6(const char *src, unsigned char *dst)
{
  unsigned char tmp[16l];
  unsigned char *tp;
  unsigned char *endp;
  unsigned char *colonp;
  const char *xdigits;
  const char *curtok;
  signed int ch;
  signed int seen_xdigits;
  unsigned int val;
  tp = tmp;
  memset((void *)tp, 0, (unsigned long int)16);
  endp = tp + (signed long int)16;
  colonp = (unsigned char *)(void *)0;
  const char *tmp_post$1;
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  signed int return_value_inet_pton4$4;
  unsigned char *tmp_post$5;
  unsigned char *tmp_post$6;
  if((signed int)*src == 58)
  {
    src = src + 1l;
    if((signed int)*src == 58)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    curtok = src;
    seen_xdigits = 0;
    val = (unsigned int)0;
    do
    {
      tmp_post$1 = src;
      src = src + 1l;
      ch = (signed int)*tmp_post$1;
      if(ch == 0)
        break;

      const char *pch;
      static const char xdigits_l[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
      xdigits = xdigits_l;
      pch=strchr(xdigits, ch);
      if(pch == ((const char *)NULL))
      {
        static const char xdigits_u[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 0 };
        xdigits = xdigits_u;
        pch=strchr(xdigits, ch);
      }

      if(!(pch == ((const char *)NULL)))
      {
        val = val << 4;
        val = val | (unsigned int)(pch - xdigits);
        seen_xdigits = seen_xdigits + 1;
        if(seen_xdigits >= 5)
          return 0;

      }

      else
        if(ch == 58)
        {
          curtok = src;
          if(seen_xdigits == 0)
          {
            if(!(colonp == ((unsigned char *)NULL)))
              return 0;

            colonp = tp;
            continue;
          }

          if(!(endp >= tp + 2l))
            return 0;

          tmp_post$2 = tp;
          tp = tp + 1l;
          *tmp_post$2 = (unsigned char)((signed int)(unsigned char)(val >> 8) & 0xff);
          tmp_post$3 = tp;
          tp = tp + 1l;
          *tmp_post$3 = (unsigned char)((signed int)(unsigned char)val & 0xff);
          seen_xdigits = 0;
          val = (unsigned int)0;
        }

        else
        {
          if(ch == 46 && endp >= tp + 4l)
          {
            return_value_inet_pton4$4=inet_pton4(curtok, tp);
            if(return_value_inet_pton4$4 >= 1)
            {
              tp = tp + (signed long int)4;
              seen_xdigits = 0;
              break;
            }

          }

          return 0;
        }
    }
    while((_Bool)1);
    if(!(seen_xdigits == 0))
    {
      if(!(endp >= tp + 2l))
        return 0;

      tmp_post$5 = tp;
      tp = tp + 1l;
      *tmp_post$5 = (unsigned char)((signed int)(unsigned char)(val >> 8) & 0xff);
      tmp_post$6 = tp;
      tp = tp + 1l;
      *tmp_post$6 = (unsigned char)((signed int)(unsigned char)val & 0xff);
    }

    if(!(colonp == ((unsigned char *)NULL)))
    {
      const signed int n = (const signed int)(tp - colonp);
      signed int i;
      if(tp == endp)
        return 0;

      i = 1;
      for( ; n >= i; i = i + 1)
      {
        endp[(signed long int)-i] = colonp[(signed long int)(n - i)];
        colonp[(signed long int)(n - i)] = (unsigned char)0;
      }
      tp = endp;
    }

    if(!(tp == endp))
      return 0;

    else
    {
      memcpy((void *)dst, (const void *)tmp, (unsigned long int)16);
      return 1;
    }
  }
}

// init_auth
// file authkeys.c line 106
extern void init_auth(void)
{
  unsigned long int newalloc = (unsigned long int)authhashbuckets * sizeof(struct savekey *) /*8ul*/ ;
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)key_hash, newalloc, (unsigned long int)0, 0);
  key_hash = (struct savekey **)return_value_ereallocz$1;
  memset((void *)key_hash, 0, newalloc);
  do
  {
    key_listhead.llink.f = &key_listhead;
    key_listhead.llink.b = &key_listhead;
  }
  while((_Bool)0);
}

// init_lib
// file lib_strbuf.c line 31
extern void init_lib(void)
{
  if(lib_inited == 0)
  {
    unsigned int return_value_isc_net_probeipv4$1;
    return_value_isc_net_probeipv4$1=isc_net_probeipv4();
    ipv4_works = (signed int)((unsigned int)0 == return_value_isc_net_probeipv4$1);
    unsigned int return_value_isc_net_probeipv6$2;
    return_value_isc_net_probeipv6$2=isc_net_probeipv6();
    ipv6_works = (signed int)((unsigned int)0 == return_value_isc_net_probeipv6$2);
    init_systime();
    lib_inited = 1;
  }

}

// init_lock
// file ./../lib/isc/unix/strerror.c line 40
static void init_lock(void)
{
  unsigned int return_value_isc__mutex_init$1;
  return_value_isc__mutex_init$1=isc__mutex_init(&isc_strerror_lock, "./../lib/isc/unix/strerror.c", (unsigned int)41);
  if(return_value_isc__mutex_init$1 == 0u)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/unix/strerror.c", 41, "isc__mutex_init((&isc_strerror_lock), \"./../lib/isc/unix/strerror.c\", 41) == 0");
    (_Bool)0;
  }
}

// init_logging
// file msyslog.c line 379
extern void init_logging(const char *name, unsigned int def_syslogmask, signed int is_daemon)
{
  char *cp;
  const char *pname;
  if(ntp_syslogmask == 4294967295u && !(def_syslogmask == 0u))
    ntp_syslogmask = def_syslogmask;

  cp=strrchr(name, 47);
  if(cp == ((char *)NULL))
    pname = name;

  else
    pname = (signed long int)1 + cp;
  progname=estrdup_impl(pname);
  static signed int was_daemon;
  if(!(is_daemon == 0))
    was_daemon = 1;

  openlog(progname, 0x01 | 0x08, was_daemon != 0 ? 3 << 3 : 0);
  setlogmask((1 << 7 + 1) - 1);
}

// init_recvbuff
// file recvbuff.c line 109
extern void init_recvbuff(signed int nbufs)
{
  total_recvbufs = (volatile unsigned long int)0;
  free_recvbufs = total_recvbufs;
  lowater_adds = (volatile unsigned long int)0;
  full_recvbufs = lowater_adds;
  create_buffers(nbufs);
}

// init_systime
// file systime.c line 116
extern void init_systime(void)
{

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L3:
  ;
}

// initialise_buffer
// file recvbuff.c line 73
static inline void initialise_buffer(struct recvbuf *buff)
{
  bzero((void *)&(*buff), sizeof(struct recvbuf) /*2272ul*/ );
}

// initialize
// file ./../lib/isc/unix/net.c line 220
static void initialize(void)
{
  signed int return_value_pthread_once$1;
  return_value_pthread_once$1=pthread_once(&once, initialize_action);
  if(return_value_pthread_once$1 == 0)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/unix/net.c", 221, "((pthread_once((&once), (initialize_action)) == 0) ? 0 : 34) == 0");
    (_Bool)0;
  }
}

// initialize$link1
// file ./../lib/isc/random.c line 58
static void initialize$link1(void)
{
  signed int return_value_pthread_once$1$link1;
  return_value_pthread_once$1$link1=pthread_once(&once$link1, initialize_rand);
  if(return_value_pthread_once$1$link1 == 0)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/random.c", 60, "((pthread_once((&once), (initialize_rand)) == 0) ? 0 : 34) == 0");
    (_Bool)0;
  }
}

// initialize$link2
// file ./../lib/isc/result.c line 166
static void initialize$link2(void)
{
  isc_lib_initmsgcat();
  signed int return_value_pthread_once$1$link2;
  return_value_pthread_once$1$link2=pthread_once(&once$link2, initialize_action$link1);
  if(return_value_pthread_once$1$link2 == 0)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/result.c", 168, "((pthread_once((&once), (initialize_action)) == 0) ? 0 : 34) == 0");
    (_Bool)0;
  }
}

// initialize_action
// file ./../lib/isc/unix/net.c line 205
static void initialize_action(void)
{
  ipv4_result=try_proto(2);
  ipv6_result=try_proto(10);
}

// initialize_action$link1
// file ./../lib/isc/result.c line 149
static void initialize_action$link1(void)
{
  unsigned int result;
  unsigned int return_value_isc__mutex_init$1;
  return_value_isc__mutex_init$1=isc__mutex_init(&lock, "./../lib/isc/result.c", (unsigned int)152);
  if(return_value_isc__mutex_init$1 == 0u)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/result.c", 152, "isc__mutex_init((&lock), \"./../lib/isc/result.c\", 152) == 0");
    (_Bool)0;
  }
  do
  {
    tables.head = (struct resulttable *)(void *)0;
    tables.tail = (struct resulttable *)(void *)0;
  }
  while((_Bool)0);
  result=register_table((unsigned int)(0 << 16), (unsigned int)62, text, isc_msgcat, 2);
  const char *return_value_isc_msgcat_get$2;
  if(!(result == 0u))
  {
    return_value_isc_msgcat_get$2=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
    isc_error_unexpected("./../lib/isc/result.c", 158, "register_table() %s: %u", return_value_isc_msgcat_get$2, result);
  }

}

// initialize_ipv6only
// file ./../lib/isc/unix/net.c line 315
static void initialize_ipv6only(void)
{
  signed int return_value_pthread_once$1;
  return_value_pthread_once$1=pthread_once(&once_ipv6only, try_ipv6only);
  if(return_value_pthread_once$1 == 0)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/unix/net.c", 317, "((pthread_once((&once_ipv6only), (try_ipv6only)) == 0) ? 0 : 34) == 0");
    (_Bool)0;
  }
}

// initialize_ipv6pktinfo
// file ./../lib/isc/unix/net.c line 368
static void initialize_ipv6pktinfo(void)
{
  signed int return_value_pthread_once$1;
  return_value_pthread_once$1=pthread_once(&once_ipv6pktinfo, try_ipv6pktinfo);
  if(return_value_pthread_once$1 == 0)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/unix/net.c", 370, "((pthread_once((&once_ipv6pktinfo), (try_ipv6pktinfo)) == 0) ? 0 : 34) == 0");
    (_Bool)0;
  }
}

// initialize_rand
// file ./../lib/isc/random.c line 42
static void initialize_rand(void)
{
  unsigned int pid;
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  pid = (unsigned int)return_value_getpid$1;
  pid = pid << 16 & 0xffff0000 | pid >> 16 & (unsigned int)0xffff;
  signed long int return_value_time$2;
  return_value_time$2=time((signed long int *)(void *)0);
  srand((unsigned int)(return_value_time$2 ^ (signed long int)pid));
}

// int32_sflag
// file ntp_calendar.c line 130
static inline unsigned int int32_sflag(const signed int v)
{
  return 0U - (unsigned int)(v < 0);
}

// int32_to_uint32_2cpl
// file ntp_calendar.c line 154
static inline unsigned int int32_to_uint32_2cpl(const signed int v)
{
  unsigned int vu = (unsigned int)v;
  return vu;
}

// internal_current
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 140
static unsigned int internal_current(struct isc_interfaceiter *iter)
{
  struct ifaddrs *ifa;
  signed int family;
  unsigned int namelen;
  _Bool tmp_if_expr$1;
  if(!(iter == ((struct isc_interfaceiter *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)iter)->magic == (unsigned int)(73 << 24 | 70 << 16 | 73 << 8 | 71) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/ifiter_getifaddrs.c", 145, (enum anonymous$46)isc_assertiontype_require, "(((iter) != ((void *)0)) && (((const isc__magic_t *)(iter))->magic == ((('I') << 24 | ('F') << 16 | ('I') << 8 | ('G')))))");
    (_Bool)0;
  }
  ifa = iter->pos;
  unsigned int return_value_linux_if_inet6_current$2;
  if(iter->pos == ((struct ifaddrs *)NULL))
  {
    return_value_linux_if_inet6_current$2=linux_if_inet6_current(iter);
    return return_value_linux_if_inet6_current$2;
  }

  else
  {
    if(!(ifa == ((struct ifaddrs *)NULL)))
      (_Bool)1;

    else
    {
      isc_assertion_failed("./../lib/isc/unix/ifiter_getifaddrs.c", 162, (enum anonymous$46)isc_assertiontype_insist, "ifa != ((void *)0)");
      (_Bool)0;
    }
    if(!(ifa->ifa_name == ((char *)NULL)))
      (_Bool)1;

    else
    {
      isc_assertion_failed("./../lib/isc/unix/ifiter_getifaddrs.c", 163, (enum anonymous$46)isc_assertiontype_insist, "ifa->ifa_name != ((void *)0)");
      (_Bool)0;
    }
    if((64u & ifa->ifa_flags) == 0u)
      return (unsigned int)36;

    else
      if(ifa->ifa_addr == ((struct sockaddr *)NULL))
        return (unsigned int)36;

      else
      {
        family = (signed int)ifa->ifa_addr->sa_family;
        if(!(family == 2) && !(family == 10))
          return (unsigned int)36;

        else
        {
          if(family == 10)
            seenv6 = (enum anonymous$11)isc_boolean_true;

          memset((void *)&iter->current, 0, sizeof(struct isc_interface) /*140ul*/ );
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(ifa->ifa_name);
          namelen = (unsigned int)return_value_strlen$3;
          if((unsigned long int)namelen >= 32ul)
            namelen = (unsigned int)(sizeof(char [32l]) /*32ul*/  - (unsigned long int)1);

          memset((void *)iter->current.name, 0, sizeof(char [32l]) /*32ul*/ );
          memcpy((void *)iter->current.name, (const void *)ifa->ifa_name, (unsigned long int)namelen);
          iter->current.flags = (unsigned int)0;
          if(!((1u & ifa->ifa_flags) == 0u))
            iter->current.flags = iter->current.flags | 0x00000001U;

          if(!((16u & ifa->ifa_flags) == 0u))
            iter->current.flags = iter->current.flags | 0x00000002U;

          if(!((8u & ifa->ifa_flags) == 0u))
            iter->current.flags = iter->current.flags | 0x00000004U;

          if(!((2u & ifa->ifa_flags) == 0u))
            iter->current.flags = iter->current.flags | 0x00000008U;

          if(!((4096u & ifa->ifa_flags) == 0u))
            iter->current.flags = iter->current.flags | 0x00000010U;

          iter->current.af = (unsigned int)family;
          get_addr((unsigned int)family, &iter->current.address, ifa->ifa_addr, ifa->ifa_name);
          if(!(ifa->ifa_netmask == ((struct sockaddr *)NULL)))
            get_addr((unsigned int)family, &iter->current.netmask, ifa->ifa_netmask, ifa->ifa_name);

          if(!(ifa->ifa_ifu.ifu_dstaddr == ((struct sockaddr *)NULL)))
          {
            if(!((0x00000002U & iter->current.flags) == 0u))
              get_addr((unsigned int)family, &iter->current.dstaddress, ifa->ifa_ifu.ifu_dstaddr, ifa->ifa_name);

          }

          if(!(ifa->ifa_ifu.ifu_broadaddr == ((struct sockaddr *)NULL)))
          {
            if(!((0x00000008U & iter->current.flags) == 0u))
              get_addr((unsigned int)family, &iter->current.broadcast, ifa->ifa_ifu.ifu_broadaddr, ifa->ifa_name);

          }

          iter->current.ifindex=if_nametoindex(iter->current.name);
          return (unsigned int)0;
        }
      }
  }
}

// internal_destroy
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 264
static void internal_destroy(struct isc_interfaceiter *iter)
{
  if(!(iter->proc == ((struct _IO_FILE *)NULL)))
    fclose(iter->proc);

  iter->proc = (struct _IO_FILE *)(void *)0;
  if(!(iter->ifaddrs == ((struct ifaddrs *)NULL)))
    freeifaddrs(iter->ifaddrs);

  iter->ifaddrs = (struct ifaddrs *)(void *)0;
}

// internal_first
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 277
static void internal_first(struct isc_interfaceiter *iter)
{
  linux_if_inet6_first(iter);
  iter->pos = iter->ifaddrs;
}

// internal_next
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 248
static unsigned int internal_next(struct isc_interfaceiter *iter)
{
  if(!(iter->pos == ((struct ifaddrs *)NULL)))
    iter->pos = iter->pos->ifa_next;

  unsigned int return_value_linux_if_inet6_next$1;
  if(iter->pos == ((struct ifaddrs *)NULL))
  {
    if(seenv6 == /*enum*/isc_boolean_false)
    {
      return_value_linux_if_inet6_next$1=linux_if_inet6_next(iter);
      return return_value_linux_if_inet6_next$1;
    }

    return (unsigned int)29;
  }

  return (unsigned int)0;
}

// interrupt_worker_sleep
// file work_thread.c line 114
extern void interrupt_worker_sleep(void)
{
  unsigned int idx;
  struct blocking_child_tag *c;
  idx = (unsigned int)0;
  _Bool tmp_if_expr$1;
  for( ; !((unsigned long int)idx >= blocking_children_alloc); idx = idx + 1u)
  {
    c = blocking_children[(signed long int)idx];
    if(c == ((struct blocking_child_tag *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (union anonymous$65 *)(void *)0 == c->wake_scheduled_sleep ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
      sem_post(c->wake_scheduled_sleep);

  }
}

// isc___errno2result
// file ./../lib/isc/unix/errno2result.h line 37
unsigned int isc___errno2result(signed int posixerrno, const char *file, unsigned int line)
{
  char strbuf[128l];
  switch(posixerrno)
  {
    case 20:

    case 40:

    case 22:

    case 36:

    case 9:
      return (unsigned int)30;
    case 2:
      return (unsigned int)38;
    case 13:

    case 1:
      return (unsigned int)6;
    case 17:
      return (unsigned int)39;
    case 5:
      return (unsigned int)26;
    case 12:
      return (unsigned int)1;
    case 23:

    case 24:
      return (unsigned int)50;
    case 32:

    case 104:

    case 103:
      return (unsigned int)54;
    case 107:
      return (unsigned int)40;
    case 110:
      return (unsigned int)2;
    case 105:
      return (unsigned int)13;
    case 97:
      return (unsigned int)48;
    case 100:
      return (unsigned int)10;
    case 112:
      return (unsigned int)11;
    case 101:
      return (unsigned int)8;
    case 113:
      return (unsigned int)9;
    case 98:
      return (unsigned int)5;
    case 99:
      return (unsigned int)4;
    case 111:
      return (unsigned int)12;
    default:
    {
      isc__strerror(posixerrno, strbuf, sizeof(char [128l]) /*128ul*/ );
      isc_error_unexpected(file, (signed int)line, "unable to convert errno to isc_result: %d: %s", posixerrno, (const void *)strbuf);
      return (unsigned int)34;
    }
  }
}

// isc__buffer_activeregion
// file ./../lib/isc/buffer.c line 180
void isc__buffer_activeregion(struct isc_buffer *b, struct isc_region *r)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 185, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(!(r == ((struct isc_region *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 186, (enum anonymous$46)isc_assertiontype_require, "r != ((void *)0)");
    (_Bool)0;
  }
  do
    if(!(b->current >= b->active))
    {
      r->base = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->current);
      r->length = b->active - b->current;
    }

    else
    {
      r->base = (unsigned char *)(void *)0;
      r->length = (unsigned int)0;
    }
  while((_Bool)0);
}

// isc__buffer_add
// file ./../lib/isc/buffer.c line 121
void isc__buffer_add(struct isc_buffer *b, unsigned int n)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 126, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->length >= b->used + n)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 127, (enum anonymous$46)isc_assertiontype_require, "b->used + n <= b->length");
    (_Bool)0;
  }
  do
    b->used = b->used + n;
  while((_Bool)0);
}

// isc__buffer_availableregion
// file ./../lib/isc/buffer.c line 109
void isc__buffer_availableregion(struct isc_buffer *b, struct isc_region *r)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 114, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(!(r == ((struct isc_region *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 115, (enum anonymous$46)isc_assertiontype_require, "r != ((void *)0)");
    (_Bool)0;
  }
  do
  {
    r->base = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->used);
    r->length = b->length - b->used;
  }
  while((_Bool)0);
}

// isc__buffer_back
// file ./../lib/isc/buffer.c line 227
void isc__buffer_back(struct isc_buffer *b, unsigned int n)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 232, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->current >= n)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 233, (enum anonymous$46)isc_assertiontype_require, "n <= b->current");
    (_Bool)0;
  }
  do
    b->current = b->current - n;
  while((_Bool)0);
}

// isc__buffer_clear
// file ./../lib/isc/buffer.c line 145
void isc__buffer_clear(struct isc_buffer *b)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 150, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  do
  {
    b->used = (unsigned int)0;
    b->current = (unsigned int)0;
    b->active = (unsigned int)0;
  }
  while((_Bool)0);
}

// isc__buffer_consumedregion
// file ./../lib/isc/buffer.c line 156
void isc__buffer_consumedregion(struct isc_buffer *b, struct isc_region *r)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 161, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(!(r == ((struct isc_region *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 162, (enum anonymous$46)isc_assertiontype_require, "r != ((void *)0)");
    (_Bool)0;
  }
  do
  {
    r->base = (unsigned char *)b->base;
    r->length = b->current;
  }
  while((_Bool)0);
}

// isc__buffer_first
// file ./../lib/isc/buffer.c line 204
void isc__buffer_first(struct isc_buffer *b)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 209, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  do
    b->current = (unsigned int)0;
  while((_Bool)0);
}

// isc__buffer_forward
// file ./../lib/isc/buffer.c line 215
void isc__buffer_forward(struct isc_buffer *b, unsigned int n)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 220, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->used >= b->current + n)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 221, (enum anonymous$46)isc_assertiontype_require, "b->current + n <= b->used");
    (_Bool)0;
  }
  do
    b->current = b->current + n;
  while((_Bool)0);
}

// isc__buffer_init
// file ./../lib/isc/buffer.c line 31
void isc__buffer_init(struct isc_buffer *b, const void *base, unsigned int length)
{
  if(!(b == ((struct isc_buffer *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 37, (enum anonymous$46)isc_assertiontype_require, "b != ((void *)0)");
    (_Bool)0;
  }
  do
  {
    /* tag-#anon#lUN[l*{clV}$clV$'konst'||l*{lV}$lV$'var'|] */
union anonymous$17
{
  // konst
  const void *konst;
  // var
  void *var;
};

/* */
    ;
    union anonymous$17 _u;
    _u.konst = base;
    b->base = _u.var;
    b->length = length;
    b->used = (unsigned int)0;
    b->current = (unsigned int)0;
    b->active = (unsigned int)0;
    b->mctx = (struct isc_mem *)(void *)0;
    do
    {
      b->link.prev = (struct isc_buffer *)(void *)-1;
      b->link.next = (struct isc_buffer *)(void *)-1;
    }
    while((_Bool)0);
    b->magic = 0x42756621U;
  }
  while((_Bool)0);
}

// isc__buffer_initnull
// file ./../lib/isc/buffer.c line 43
void isc__buffer_initnull(struct isc_buffer *b)
{
  do
  {
    /* tag-#anon#lUN[l*{clV}$clV$'konst'||l*{lV}$lV$'var'|] */
union anonymous$17
{
  // konst
  const void *konst;
  // var
  void *var;
};

/* */
    ;
    union anonymous$17 _u;
    _u.konst = (void *)0;
    b->base = _u.var;
    b->length = (unsigned int)0;
    b->used = (unsigned int)0;
    b->current = (unsigned int)0;
    b->active = (unsigned int)0;
    b->mctx = (struct isc_mem *)(void *)0;
    do
    {
      b->link.prev = (struct isc_buffer *)(void *)-1;
      b->link.next = (struct isc_buffer *)(void *)-1;
    }
    while((_Bool)0);
    b->magic = 0x42756621U;
  }
  while((_Bool)0);
}

// isc__buffer_invalidate
// file ./../lib/isc/buffer.c line 72
void isc__buffer_invalidate(struct isc_buffer *b)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 77, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if((void *)b->link.prev == (void *)-1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 78, (enum anonymous$46)isc_assertiontype_require, "!((void *)((b)->link.prev) != (void *)(-1))");
    (_Bool)0;
  }
  if(b->mctx == ((struct isc_mem *)NULL))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 79, (enum anonymous$46)isc_assertiontype_require, "b->mctx == ((void *)0)");
    (_Bool)0;
  }
  do
  {
    b->magic = (unsigned int)0;
    b->base = (void *)0;
    b->length = (unsigned int)0;
    b->used = (unsigned int)0;
    b->current = (unsigned int)0;
    b->active = (unsigned int)0;
  }
  while((_Bool)0);
}

// isc__buffer_putmem
// file ./../lib/isc/buffer.c line 398
void isc__buffer_putmem(struct isc_buffer *b, const unsigned char *base, unsigned int length)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 401, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->length >= b->used + length)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 402, (enum anonymous$46)isc_assertiontype_require, "b->used + length <= b->length");
    (_Bool)0;
  }
  do
  {
    memcpy((void *)((unsigned char *)b->base + (signed long int)b->used), (const void *)base, (unsigned long int)length);
    b->used = b->used + length;
  }
  while((_Bool)0);
}

// isc__buffer_putstr
// file ./../lib/isc/buffer.c line 408
void isc__buffer_putstr(struct isc_buffer *b, const char *source)
{
  unsigned int l;
  unsigned char *cp;
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 412, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(!(source == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 413, (enum anonymous$46)isc_assertiontype_require, "source != ((void *)0)");
    (_Bool)0;
  }
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(source);
  l = (unsigned int)return_value_strlen$2;
  if(b->length + -b->used >= l)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 420, (enum anonymous$46)isc_assertiontype_require, "l <= ((b)->length - (b)->used)");
    (_Bool)0;
  }
  cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->used);
  memcpy((void *)cp, (const void *)source, (unsigned long int)l);
  b->used = b->used + l;
}

// isc__buffer_putuint16
// file ./../lib/isc/buffer.c line 312
void isc__buffer_putuint16(struct isc_buffer *b, unsigned short int val)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 313, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->length >= 2u + b->used)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 314, (enum anonymous$46)isc_assertiontype_require, "b->used + 2 <= b->length");
    (_Bool)0;
  }
  do
  {
    unsigned char *_cp;
    unsigned short int _val2 = val;
    _cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->used);
    b->used = b->used + (unsigned int)2;
    _cp[(signed long int)0] = (unsigned char)(((unsigned int)_val2 & 0xff00U) >> 8);
    _cp[(signed long int)1] = (unsigned char)((unsigned int)_val2 & 0x00ffU);
  }
  while((_Bool)0);
}

// isc__buffer_putuint24
// file ./../lib/isc/buffer.c line 320
void isc__buffer_putuint24(struct isc_buffer *b, unsigned int val)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 321, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->length >= 3u + b->used)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 322, (enum anonymous$46)isc_assertiontype_require, "b->used + 3 <= b->length");
    (_Bool)0;
  }
  do
  {
    unsigned char *_cp;
    unsigned int _val2 = val;
    _cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->used);
    b->used = b->used + (unsigned int)3;
    _cp[(signed long int)0] = (unsigned char)((_val2 & 0xff0000U) >> 16);
    _cp[(signed long int)1] = (unsigned char)((_val2 & 0xff00U) >> 8);
    _cp[(signed long int)2] = (unsigned char)(_val2 & 0x00ffU);
  }
  while((_Bool)0);
}

// isc__buffer_putuint32
// file ./../lib/isc/buffer.c line 351
void isc__buffer_putuint32(struct isc_buffer *b, unsigned int val)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 352, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->length >= 4u + b->used)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 353, (enum anonymous$46)isc_assertiontype_require, "b->used + 4 <= b->length");
    (_Bool)0;
  }
  do
  {
    unsigned char *_cp;
    unsigned int _val2 = val;
    _cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->used);
    b->used = b->used + (unsigned int)4;
    _cp[(signed long int)0] = (unsigned char)((_val2 & 0xff000000) >> 24);
    _cp[(signed long int)1] = (unsigned char)((_val2 & (unsigned int)0x00ff0000) >> 16);
    _cp[(signed long int)2] = (unsigned char)((_val2 & (unsigned int)0x0000ff00) >> 8);
    _cp[(signed long int)3] = (unsigned char)(_val2 & (unsigned int)0x000000ff);
  }
  while((_Bool)0);
}

// isc__buffer_putuint48
// file ./../lib/isc/buffer.c line 384
void isc__buffer_putuint48(struct isc_buffer *b, unsigned long long int val)
{
  unsigned short int valhi;
  unsigned int vallo;
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 388, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->length >= 6u + b->used)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 389, (enum anonymous$46)isc_assertiontype_require, "b->used + 6 <= b->length");
    (_Bool)0;
  }
  valhi = (unsigned short int)(val >> 32);
  vallo = (unsigned int)(val & (unsigned long int)0xFFFFFFFF);
  do
  {
    unsigned char *isc__buffer_putuint48$$1$$1$$_cp;
    unsigned short int _val2 = valhi;
    isc__buffer_putuint48$$1$$1$$_cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->used);
    b->used = b->used + (unsigned int)2;
    isc__buffer_putuint48$$1$$1$$_cp[(signed long int)0] = (unsigned char)(((unsigned int)_val2 & 0xff00U) >> 8);
    isc__buffer_putuint48$$1$$1$$_cp[(signed long int)1] = (unsigned char)((unsigned int)_val2 & 0x00ffU);
  }
  while((_Bool)0);
  do
  {
    unsigned char *_cp;
    unsigned int isc__buffer_putuint48$$1$$2$$_val2 = vallo;
    _cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->used);
    b->used = b->used + (unsigned int)4;
    _cp[(signed long int)0] = (unsigned char)((isc__buffer_putuint48$$1$$2$$_val2 & 0xff000000) >> 24);
    _cp[(signed long int)1] = (unsigned char)((isc__buffer_putuint48$$1$$2$$_val2 & (unsigned int)0x00ff0000) >> 16);
    _cp[(signed long int)2] = (unsigned char)((isc__buffer_putuint48$$1$$2$$_val2 & (unsigned int)0x0000ff00) >> 8);
    _cp[(signed long int)3] = (unsigned char)(isc__buffer_putuint48$$1$$2$$_val2 & (unsigned int)0x000000ff);
  }
  while((_Bool)0);
}

// isc__buffer_putuint8
// file ./../lib/isc/buffer.c line 283
void isc__buffer_putuint8(struct isc_buffer *b, unsigned char val)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 284, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->length >= 1u + b->used)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 285, (enum anonymous$46)isc_assertiontype_require, "b->used + 1 <= b->length");
    (_Bool)0;
  }
  do
  {
    unsigned char *_cp;
    unsigned char _val2 = val;
    _cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->used);
    b->used = b->used + 1u;
    _cp[(signed long int)0] = (unsigned char)((signed int)_val2 & 0x00ff);
  }
  while((_Bool)0);
}

// isc__buffer_region
// file ./../lib/isc/buffer.c line 85
void isc__buffer_region(struct isc_buffer *b, struct isc_region *r)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 90, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(!(r == ((struct isc_region *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 91, (enum anonymous$46)isc_assertiontype_require, "r != ((void *)0)");
    (_Bool)0;
  }
  do
  {
    r->base = (unsigned char *)b->base;
    r->length = b->length;
  }
  while((_Bool)0);
}

// isc__buffer_remainingregion
// file ./../lib/isc/buffer.c line 168
void isc__buffer_remainingregion(struct isc_buffer *b, struct isc_region *r)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 173, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(!(r == ((struct isc_region *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 174, (enum anonymous$46)isc_assertiontype_require, "r != ((void *)0)");
    (_Bool)0;
  }
  do
  {
    r->base = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->current);
    r->length = b->used - b->current;
  }
  while((_Bool)0);
}

// isc__buffer_setactive
// file ./../lib/isc/buffer.c line 192
void isc__buffer_setactive(struct isc_buffer *b, unsigned int n)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 197, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->used >= b->current + n)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 198, (enum anonymous$46)isc_assertiontype_require, "b->current + n <= b->used");
    (_Bool)0;
  }
  do
    b->active = b->current + n;
  while((_Bool)0);
}

// isc__buffer_subtract
// file ./../lib/isc/buffer.c line 133
void isc__buffer_subtract(struct isc_buffer *b, unsigned int n)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 138, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->used >= n)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 139, (enum anonymous$46)isc_assertiontype_require, "b->used >= n");
    (_Bool)0;
  }
  do
  {
    b->used = b->used - n;
    if(!(b->used >= b->current))
      b->current = b->used;

    if(!(b->used >= b->active))
      b->active = b->used;

  }
  while((_Bool)0);
}

// isc__buffer_usedregion
// file ./../lib/isc/buffer.c line 97
void isc__buffer_usedregion(struct isc_buffer *b, struct isc_region *r)
{
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 102, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(!(r == ((struct isc_region *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 103, (enum anonymous$46)isc_assertiontype_require, "r != ((void *)0)");
    (_Bool)0;
  }
  do
  {
    r->base = (unsigned char *)b->base;
    r->length = b->used;
  }
  while((_Bool)0);
}

// isc__mutex_init
// file ../lib/isc/pthreads/include/isc/mutex.h line 79
unsigned int isc__mutex_init(union anonymous$2 *mp, const char *file, unsigned int line)
{
  char strbuf[128l];
  unsigned int result = (unsigned int)0;
  signed int err;
  err=pthread_mutex_init(mp, (const union anonymous$60 *)(void *)0);
  if(err == 12)
    return (unsigned int)1;

  else
  {
    if(!(err == 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      isc__strerror(*return_value___errno_location$1, strbuf, sizeof(char [128l]) /*128ul*/ );
      isc_error_unexpected(file, (signed int)line, "isc_mutex_init() failed: %s", (const void *)strbuf);
      result = (unsigned int)34;
    }

    return result;
  }
}

// isc__strerror
// file ../lib/isc/unix/include/isc/strerror.h line 41
void isc__strerror(signed int num, char *buf, unsigned long int size)
{
  char *msg;
  unsigned int unum = (unsigned int)num;
  if(!(buf == ((char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/strerror.c", 55, (enum anonymous$46)isc_assertiontype_require, "buf != ((void *)0)");
    (_Bool)0;
  }
  signed int return_value_pthread_once$1;
  static signed int isc__strerror$$1$$once = 0;
  return_value_pthread_once$1=pthread_once(&isc__strerror$$1$$once, init_lock);
  if(return_value_pthread_once$1 == 0)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/unix/strerror.c", 57, "((pthread_once((&once), (init_lock)) == 0) ? 0 : 34) == 0");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&isc_strerror_lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/unix/strerror.c", 59, "((pthread_mutex_lock(((&isc_strerror_lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  msg=strerror(num);
  if(!(msg == ((char *)NULL)))
    snprintf(buf, size, "%s", msg);

  else
    snprintf(buf, size, "Unknown error: %u", unum);
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&isc_strerror_lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/unix/strerror.c", 65, "((pthread_mutex_unlock(((&isc_strerror_lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// isc__task_attach
// file ../lib/isc/include/isc/task.h line 212
void isc__task_attach(struct isc_task *source0, struct isc_task **targetp)
{
  struct isc__task *source = (struct isc__task *)source0;
  _Bool tmp_if_expr$1;
  if(!(source == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)source)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 399, (enum anonymous$46)isc_assertiontype_require, "(((source) != ((void *)0)) && (((const isc__magic_t *)(source))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(!(targetp == ((struct isc_task **)NULL)))
    tmp_if_expr$2 = *targetp == (struct isc_task *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 400, (enum anonymous$46)isc_assertiontype_require, "targetp != ((void *)0) && *targetp == ((void *)0)");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$3;
    return_value_pthread_mutex_lock$3=pthread_mutex_lock(&source->lock);
    if(return_value_pthread_mutex_lock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 404, "((pthread_mutex_lock(((&source->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  source->references = source->references + 1u;
  do
  {
    signed int return_value_pthread_mutex_unlock$4;
    return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(&source->lock);
    if(return_value_pthread_mutex_unlock$4 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 406, "((pthread_mutex_unlock(((&source->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  *targetp = (struct isc_task *)source;
}

// isc__task_beginexclusive
// file ./../lib/isc/task.c line 1641
unsigned int isc__task_beginexclusive(struct isc_task *task0)
{
  struct isc__task *task = (struct isc__task *)task0;
  struct isc__taskmgr *manager = task->manager;
  if((signed int)task->state == task_state_running)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 1645, (enum anonymous$46)isc_assertiontype_require, "task->state == task_state_running");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1646, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  if(!(manager->exclusive_requested == /*enum*/isc_boolean_false))
  {
    do
    {
      signed int return_value_pthread_mutex_unlock$2;
      return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&manager->lock);
      if(return_value_pthread_mutex_unlock$2 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 1648, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
    return (unsigned int)17;
  }

  else
  {
    manager->exclusive_requested = (enum anonymous$11)isc_boolean_true;
    while(manager->tasks_running >= 2u)
      do
      {
        signed int return_value_pthread_cond_wait$3;
        return_value_pthread_cond_wait$3=pthread_cond_wait(&manager->exclusive_granted, &manager->lock);
        if(return_value_pthread_cond_wait$3 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 1653, "((pthread_cond_wait(((&manager->exclusive_granted)), ((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
    do
    {
      signed int return_value_pthread_mutex_unlock$4;
      return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(&manager->lock);
      if(return_value_pthread_mutex_unlock$4 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 1655, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
    return (unsigned int)0;
  }
}

// isc__task_create
// file ./../lib/isc/task.c line 329
unsigned int isc__task_create(struct isc_taskmgr *manager0, unsigned int quantum, struct isc_task **taskp)
{
  struct isc__taskmgr *manager = (struct isc__taskmgr *)manager0;
  struct isc__task *task;
  enum anonymous$11 exiting;
  unsigned int result;
  _Bool tmp_if_expr$1;
  if(!(manager == ((struct isc__taskmgr *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)manager)->magic == (unsigned int)(84 << 24 | 83 << 16 | 75 << 8 | 77) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 337, (enum anonymous$46)isc_assertiontype_require, "(((manager) != ((void *)0)) && (((const isc__magic_t *)(manager))->magic == ((('T') << 24 | ('S') << 16 | ('K') << 8 | ('M')))))");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(!(taskp == ((struct isc_task **)NULL)))
    tmp_if_expr$2 = *taskp == (struct isc_task *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 338, (enum anonymous$46)isc_assertiontype_require, "taskp != ((void *)0) && *taskp == ((void *)0)");
    (_Bool)0;
  }
  (void)manager->mctx;
  void *return_value_ereallocz$3;
  return_value_ereallocz$3=ereallocz((void *)0, sizeof(struct isc__task) /*192ul*/ , (unsigned long int)0, 0);
  task = (struct isc__task *)return_value_ereallocz$3;
  if(task == ((struct isc__task *)NULL))
    return (unsigned int)1;

  else
  {
    result=isc__mutex_init(&task->lock, "./../lib/isc/task.c", (unsigned int)344);
    if(!(result == 0u))
    {
      (void)manager->mctx;
      free((void *)task);
      return result;
    }

    else
    {
      do
      {
        signed int return_value_pthread_mutex_lock$4;
        return_value_pthread_mutex_lock$4=pthread_mutex_lock(&manager->lock);
        if(return_value_pthread_mutex_lock$4 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 349, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      do
      {
        signed int return_value_pthread_mutex_lock$5;
        return_value_pthread_mutex_lock$5=pthread_mutex_lock(&task->lock);
        if(return_value_pthread_mutex_lock$5 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 350, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      task->manager = manager;
      task->state = (enum anonymous$56)task_state_idle;
      task->references = (unsigned int)1;
      do
      {
        task->events.head = (struct isc_event *)(void *)0;
        task->events.tail = (struct isc_event *)(void *)0;
      }
      while((_Bool)0);
      do
      {
        task->on_shutdown.head = (struct isc_event *)(void *)0;
        task->on_shutdown.tail = (struct isc_event *)(void *)0;
      }
      while((_Bool)0);
      task->quantum = quantum;
      task->flags = (unsigned int)0;
      task->now = (unsigned int)0;
      memset((void *)task->name, 0, sizeof(char [16l]) /*16ul*/ );
      task->tag = (void *)0;
      do
      {
        task->link.prev = (struct isc__task *)(void *)-1;
        task->link.next = (struct isc__task *)(void *)-1;
      }
      while((_Bool)0);
      do
      {
        task->ready_link.prev = (struct isc__task *)(void *)-1;
        task->ready_link.next = (struct isc__task *)(void *)-1;
      }
      while((_Bool)0);
      do
      {
        task->ready_priority_link.prev = (struct isc__task *)(void *)-1;
        task->ready_priority_link.next = (struct isc__task *)(void *)-1;
      }
      while((_Bool)0);
      do
      {
        signed int return_value_pthread_mutex_unlock$6;
        return_value_pthread_mutex_unlock$6=pthread_mutex_unlock(&task->lock);
        if(return_value_pthread_mutex_unlock$6 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 364, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      do
      {
        signed int return_value_pthread_mutex_unlock$7;
        return_value_pthread_mutex_unlock$7=pthread_mutex_unlock(&manager->lock);
        if(return_value_pthread_mutex_unlock$7 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 365, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      exiting = (enum anonymous$11)isc_boolean_false;
      do
      {
        signed int return_value_pthread_mutex_lock$8;
        return_value_pthread_mutex_lock$8=pthread_mutex_lock(&manager->lock);
        if(return_value_pthread_mutex_lock$8 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 368, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      if(manager->exiting == /*enum*/isc_boolean_false)
      {
        if(task->quantum == 0u)
          task->quantum = manager->default_quantum;


      __CPROVER_DUMP_L37:
        ;
        do
        {
          if(!(manager->tasks.tail == ((struct isc__task *)NULL)))
            manager->tasks.tail->link.next = task;

          else
            manager->tasks.head = task;
          task->link.prev = manager->tasks.tail;
          task->link.next = (struct isc__task *)(void *)0;
          manager->tasks.tail = task;
        }
        while((_Bool)0);
      }

      else
        exiting = (enum anonymous$11)isc_boolean_true;
      do
      {
        signed int return_value_pthread_mutex_unlock$9;
        return_value_pthread_mutex_unlock$9=pthread_mutex_unlock(&manager->lock);
        if(return_value_pthread_mutex_unlock$9 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 375, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      if(!(exiting == /*enum*/isc_boolean_false))
      {
        signed int return_value_pthread_mutex_destroy$10;
        return_value_pthread_mutex_destroy$10=pthread_mutex_destroy(&task->lock);
        if(return_value_pthread_mutex_destroy$10 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 378, "((pthread_mutex_destroy(((&task->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
        (void)manager->mctx;
        free((void *)task);
        return (unsigned int)22;
      }

      task->common.methods = (struct isc_taskmethods *)&taskmethods;
      task->common.magic = (unsigned int)(65 << 24 | 116 << 16 | 115 << 8 | 116);
      task->common.impmagic = (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75);
      *taskp = (struct isc_task *)task;
      return (unsigned int)0;
    }
  }
}

// isc__task_destroy
// file ./../lib/isc/task.c line 854
void isc__task_destroy(struct isc_task **taskp)
{
  if(!(taskp == ((struct isc_task **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 860, (enum anonymous$46)isc_assertiontype_require, "taskp != ((void *)0)");
    (_Bool)0;
  }
  isc__task_shutdown(*taskp);
  isc__task_detach(taskp);
}

// isc__task_detach
// file ./../lib/isc/task.c line 505
void isc__task_detach(struct isc_task **taskp)
{
  struct isc__task *task;
  enum anonymous$11 was_idle;
  if(!(taskp == ((struct isc_task **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 513, (enum anonymous$46)isc_assertiontype_require, "taskp != ((void *)0)");
    (_Bool)0;
  }
  task = (struct isc__task *)*taskp;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 515, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 519, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  was_idle=task_detach(task);
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 521, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  if(!(was_idle == /*enum*/isc_boolean_false))
    task_ready(task);

  *taskp = (struct isc_task *)(void *)0;
}

// isc__task_endexclusive
// file ./../lib/isc/task.c line 1663
void isc__task_endexclusive(struct isc_task *task0)
{
  struct isc__task *task = (struct isc__task *)task0;
  struct isc__taskmgr *manager = task->manager;
  if((signed int)task->state == task_state_running)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 1668, (enum anonymous$46)isc_assertiontype_require, "task->state == task_state_running");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1669, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  if(!(manager->exclusive_requested == /*enum*/isc_boolean_false))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 1670, (enum anonymous$46)isc_assertiontype_require, "manager->exclusive_requested");
    (_Bool)0;
  }
  manager->exclusive_requested = (enum anonymous$11)isc_boolean_false;
  do
  {
    signed int return_value_pthread_cond_broadcast$2;
    return_value_pthread_cond_broadcast$2=pthread_cond_broadcast(&manager->work_available);
    if(return_value_pthread_cond_broadcast$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1672, "((pthread_cond_broadcast(((&manager->work_available))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1673, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// isc__task_getcurrenttime
// file ./../lib/isc/task.c line 902
void isc__task_getcurrenttime(struct isc_task *task0, unsigned int *t)
{
  struct isc__task *task = (struct isc__task *)task0;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 905, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  if(!(t == ((unsigned int *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 906, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 908, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  *t = task->now;
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 910, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// isc__task_getname
// file ./../lib/isc/task.c line 884
const char * isc__task_getname(struct isc_task *task0)
{
  struct isc__task *task = (struct isc__task *)task0;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 887, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  return task->name;
}

// isc__task_gettag
// file ./../lib/isc/task.c line 893
void * isc__task_gettag(struct isc_task *task0)
{
  struct isc__task *task = (struct isc__task *)task0;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 896, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  return task->tag;
}

// isc__task_onshutdown
// file ./../lib/isc/task.c line 795
unsigned int isc__task_onshutdown(struct isc_task *task0, void (*action)(struct isc_task *, struct isc_event *), const void *arg)
{
  struct isc__task *task = (struct isc__task *)task0;
  enum anonymous$11 disallowed = (enum anonymous$11)isc_boolean_false;
  unsigned int result = (unsigned int)0;
  struct isc_event *event;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 808, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  if(!(action == ((void (*)(struct isc_task *, struct isc_event *))NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 809, (enum anonymous$46)isc_assertiontype_require, "action != ((void *)0)");
    (_Bool)0;
  }
  event=isc_event_allocate(task->manager->mctx, (void *)0, (unsigned int)((0 << 16) + 1), action, arg, sizeof(struct isc_event) /*88ul*/ );
  if(event == ((struct isc_event *)NULL))
    return (unsigned int)1;

  else
  {
    do
    {
      signed int return_value_pthread_mutex_lock$2;
      return_value_pthread_mutex_lock$2=pthread_mutex_lock(&task->lock);
      if(return_value_pthread_mutex_lock$2 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 820, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
    if(!((1u & task->flags) == 0u))
    {
      disallowed = (enum anonymous$11)isc_boolean_true;
      result = (unsigned int)22;
    }

    else
    {

    __CPROVER_DUMP_L13:
      ;
      do
      {
        if(!(task->on_shutdown.tail == ((struct isc_event *)NULL)))
          task->on_shutdown.tail->ev_link.next = event;

        else
          task->on_shutdown.head = event;
        event->ev_link.prev = task->on_shutdown.tail;
        event->ev_link.next = (struct isc_event *)(void *)0;
        task->on_shutdown.tail = event;
      }
      while((_Bool)0);
    }
    do
    {
      signed int return_value_pthread_mutex_unlock$3;
      return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&task->lock);
      if(return_value_pthread_mutex_unlock$3 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 826, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
    if(!(disallowed == /*enum*/isc_boolean_false))
    {
      (void)task->manager->mctx;
      free((void *)event);
    }

    return result;
  }
}

// isc__task_privilege
// file ./../lib/isc/task.c line 1707
enum anonymous$11 isc__task_privilege(struct isc_task *task0)
{
  struct isc__task *task = (struct isc__task *)task0;
  enum anonymous$11 priv;
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1711, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  priv = (enum anonymous$11)((task->flags & (unsigned int)0x02) != (unsigned int)0 ? isc_boolean_true : isc_boolean_false);
  do
  {
    signed int return_value_pthread_mutex_unlock$2;
    return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1713, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  return priv;
}

// isc__task_purge
// file ./../lib/isc/task.c line 710
unsigned int isc__task_purge(struct isc_task *task, void *sender, unsigned int type, void *tag)
{
  unsigned int return_value_isc__task_purgerange$1;
  return_value_isc__task_purgerange$1=isc__task_purgerange(task, sender, type, type, tag);
  return return_value_isc__task_purgerange$1;
}

// isc__task_purgeevent
// file ./../lib/isc/task.c line 723
enum anonymous$11 isc__task_purgeevent(struct isc_task *task0, struct isc_event *event)
{
  struct isc__task *task = (struct isc__task *)task0;
  struct isc_event *curr_event;
  struct isc_event *next_event;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 733, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 745, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  curr_event = task->events.head;
  for( ; !(curr_event == ((struct isc_event *)NULL)); curr_event = next_event)
  {
    next_event = curr_event->ev_link.next;
    if(curr_event == event)
    {
      if((1u & event->ev_attributes) == 0u)
      {

      __CPROVER_DUMP_L10:
        ;
        do
        {
          if(!(curr_event->ev_link.next == ((struct isc_event *)NULL)))
            curr_event->ev_link.next->ev_link.prev = curr_event->ev_link.prev;

          else
          {
            if(task->events.tail == curr_event)
              (_Bool)1;

            else
            {
              isc_assertion_failed("./../lib/isc/task.c", 751, (enum anonymous$46)isc_assertiontype_insist, "(task->events).tail == (curr_event)");
              (_Bool)0;
            }
            task->events.tail = curr_event->ev_link.prev;
          }
          if(!(curr_event->ev_link.prev == ((struct isc_event *)NULL)))
            curr_event->ev_link.prev->ev_link.next = curr_event->ev_link.next;

          else
          {
            if(task->events.head == curr_event)
              (_Bool)1;

            else
            {
              isc_assertion_failed("./../lib/isc/task.c", 751, (enum anonymous$46)isc_assertiontype_insist, "(task->events).head == (curr_event)");
              (_Bool)0;
            }
            task->events.head = curr_event->ev_link.next;
          }
          curr_event->ev_link.prev = (struct isc_event *)(void *)-1;
          curr_event->ev_link.next = (struct isc_event *)(void *)-1;
        }
        while((_Bool)0);
        break;
      }

    }

  }
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 755, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  if(curr_event == ((struct isc_event *)NULL))
    return (enum anonymous$11)isc_boolean_false;

  else
  {
    isc_event_free(&curr_event);
    return (enum anonymous$11)isc_boolean_true;
  }
}

// isc__task_purgerange
// file ./../lib/isc/task.c line 678
unsigned int isc__task_purgerange(struct isc_task *task0, void *sender, unsigned int first, unsigned int last, void *tag)
{
  struct isc__task *task = (struct isc__task *)task0;
  unsigned int count;
  struct anonymous$52 events;
  struct isc_event *event;
  struct isc_event *next_event;
  do
  {
    events.head = (struct isc_event *)(void *)0;
    events.tail = (struct isc_event *)(void *)0;
  }
  while((_Bool)0);
  count=dequeue_events(task, sender, first, last, tag, &events, (enum anonymous$11)isc_boolean_true);
  event = events.head;
  for( ; !(event == ((struct isc_event *)NULL)); event = next_event)
  {
    next_event = event->ev_link.next;
    isc_event_free(&event);
  }
  return count;
}

// isc__task_send
// file ./../lib/isc/task.c line 560
void isc__task_send(struct isc_task *task0, struct isc_event **eventp)
{
  struct isc__task *task = (struct isc__task *)task0;
  enum anonymous$11 was_idle;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 568, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 577, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  was_idle=task_send(task, eventp);
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 579, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  if(!(was_idle == /*enum*/isc_boolean_false))
    task_ready(task);

}

// isc__task_sendanddetach
// file ../lib/isc/include/isc/task.h line 265
void isc__task_sendanddetach(struct isc_task **taskp, struct isc_event **eventp)
{
  enum anonymous$11 idle1;
  enum anonymous$11 idle2;
  struct isc__task *task;
  if(!(taskp == ((struct isc_task **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 611, (enum anonymous$46)isc_assertiontype_require, "taskp != ((void *)0)");
    (_Bool)0;
  }
  task = (struct isc__task *)*taskp;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 613, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 617, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  idle1=task_send(task, eventp);
  idle2=task_detach(task);
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 620, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  if(idle1 == /*enum*/isc_boolean_false || idle2 == /*enum*/isc_boolean_false)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 627, (enum anonymous$46)isc_assertiontype_insist, "!(idle1 && idle2)");
    (_Bool)0;
  }
  if(!(idle1 == /*enum*/isc_boolean_false) || !(idle2 == /*enum*/isc_boolean_false))
    task_ready(task);

  *taskp = (struct isc_task *)(void *)0;
}

// isc__task_setname
// file ./../lib/isc/task.c line 867
void isc__task_setname(struct isc_task *task0, const char *name, void *tag)
{
  struct isc__task *task = (struct isc__task *)task0;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 874, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 876, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  memset((void *)task->name, 0, sizeof(char [16l]) /*16ul*/ );
  strncpy(task->name, name, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  task->tag = tag;
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 880, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// isc__task_setprivilege
// file ./../lib/isc/task.c line 1680
void isc__task_setprivilege(struct isc_task *task0, enum anonymous$11 priv)
{
  struct isc__task *task = (struct isc__task *)task0;
  struct isc__taskmgr *manager = task->manager;
  enum anonymous$11 oldpriv;
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1685, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  oldpriv = (enum anonymous$11)((task->flags & (unsigned int)0x02) != (unsigned int)0 ? isc_boolean_true : isc_boolean_false);
  if(!(priv == /*enum*/isc_boolean_false))
    task->flags = task->flags | (unsigned int)0x02;

  else
    task->flags = task->flags & (unsigned int)~0x02;
  do
  {
    signed int return_value_pthread_mutex_unlock$2;
    return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1691, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  _Bool tmp_if_expr$4;
  if(!(priv == oldpriv))
  {
    do
    {
      signed int return_value_pthread_mutex_lock$3;
      return_value_pthread_mutex_lock$3=pthread_mutex_lock(&manager->lock);
      if(return_value_pthread_mutex_lock$3 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 1696, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
    if(!(priv == /*enum*/isc_boolean_false))
      tmp_if_expr$4 = (void *)task->ready_link.prev != (void *)-1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {

    __CPROVER_DUMP_L16:
      ;
      do
      {
        if(!(manager->ready_priority_tasks.tail == ((struct isc__task *)NULL)))
          manager->ready_priority_tasks.tail->ready_priority_link.next = task;

        else
          manager->ready_priority_tasks.head = task;
        task->ready_priority_link.prev = manager->ready_priority_tasks.tail;
        task->ready_priority_link.next = (struct isc__task *)(void *)0;
        manager->ready_priority_tasks.tail = task;
      }
      while((_Bool)0);
    }

    else
      if(priv == /*enum*/isc_boolean_false)
      {
        if(!((void *)task->ready_priority_link.prev == (void *)-1))
        {

        __CPROVER_DUMP_L20:
          ;
          do
          {
            if(!(task->ready_priority_link.next == ((struct isc__task *)NULL)))
              task->ready_priority_link.next->ready_priority_link.prev = task->ready_priority_link.prev;

            else
            {
              if(manager->ready_priority_tasks.tail == task)
                (_Bool)1;

              else
              {
                isc_assertion_failed("./../lib/isc/task.c", 1702, (enum anonymous$46)isc_assertiontype_insist, "(manager->ready_priority_tasks).tail == (task)");
                (_Bool)0;
              }
              manager->ready_priority_tasks.tail = task->ready_priority_link.prev;
            }
            if(!(task->ready_priority_link.prev == ((struct isc__task *)NULL)))
              task->ready_priority_link.prev->ready_priority_link.next = task->ready_priority_link.next;

            else
            {
              if(manager->ready_priority_tasks.head == task)
                (_Bool)1;

              else
              {
                isc_assertion_failed("./../lib/isc/task.c", 1702, (enum anonymous$46)isc_assertiontype_insist, "(manager->ready_priority_tasks).head == (task)");
                (_Bool)0;
              }
              manager->ready_priority_tasks.head = task->ready_priority_link.next;
            }
            task->ready_priority_link.prev = (struct isc__task *)(void *)-1;
            task->ready_priority_link.next = (struct isc__task *)(void *)-1;
          }
          while((_Bool)0);
        }

      }

    do
    {
      signed int return_value_pthread_mutex_unlock$5;
      return_value_pthread_mutex_unlock$5=pthread_mutex_unlock(&manager->lock);
      if(return_value_pthread_mutex_unlock$5 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 1703, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
  }

}

// isc__task_shutdown
// file ./../lib/isc/task.c line 835
void isc__task_shutdown(struct isc_task *task0)
{
  struct isc__task *task = (struct isc__task *)task0;
  enum anonymous$11 was_idle;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 843, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&task->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 845, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  was_idle=task_shutdown(task);
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&task->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 847, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  if(!(was_idle == /*enum*/isc_boolean_false))
    task_ready(task);

}

// isc__task_unsend
// file ./../lib/isc/task.c line 781
unsigned int isc__task_unsend(struct isc_task *task, void *sender, unsigned int type, void *tag, struct anonymous$52 *events)
{
  unsigned int return_value_dequeue_events$1;
  return_value_dequeue_events$1=dequeue_events((struct isc__task *)task, sender, type, type, tag, events, (enum anonymous$11)isc_boolean_false);
  return return_value_dequeue_events$1;
}

// isc__task_unsendrange
// file ./../lib/isc/task.c line 766
unsigned int isc__task_unsendrange(struct isc_task *task, void *sender, unsigned int first, unsigned int last, void *tag, struct anonymous$52 *events)
{
  unsigned int return_value_dequeue_events$1;
  return_value_dequeue_events$1=dequeue_events((struct isc__task *)task, sender, first, last, tag, events, (enum anonymous$11)isc_boolean_false);
  return return_value_dequeue_events$1;
}

// isc__taskmgr_create
// file ./../lib/isc/task.c line 1321
unsigned int isc__taskmgr_create(struct isc_mem *mctx, unsigned int workers, unsigned int default_quantum, struct isc_taskmgr **managerp)
{
  unsigned int result;
  unsigned int i;
  unsigned int started = (unsigned int)0;
  struct isc__taskmgr *manager;
  if(workers >= 1u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 1332, (enum anonymous$46)isc_assertiontype_require, "workers > 0");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(managerp == ((struct isc_taskmgr **)NULL)))
    tmp_if_expr$1 = *managerp == (struct isc_taskmgr *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 1333, (enum anonymous$46)isc_assertiontype_require, "managerp != ((void *)0) && *managerp == ((void *)0)");
    (_Bool)0;
  }
  (void)mctx;
  void *return_value_ereallocz$2;
  return_value_ereallocz$2=ereallocz((void *)0, sizeof(struct isc__taskmgr) /*304ul*/ , (unsigned long int)0, 0);
  manager = (struct isc__taskmgr *)return_value_ereallocz$2;
  void *return_value_ereallocz$4;
  signed int return_value_pthread_cond_init$6;
  signed int return_value_pthread_cond_init$8;
  signed int return_value_pthread_cond_init$10;
  signed int return_value_pthread_cond_destroy$13;
  signed int return_value_pthread_cond_destroy$14;
  signed int return_value_pthread_mutex_destroy$16;
  if(manager == ((struct isc__taskmgr *)NULL))
    return (unsigned int)1;

  else
  {
    manager->common.methods = &taskmgrmethods;
    manager->common.impmagic = (unsigned int)(84 << 24 | 83 << 16 | 75 << 8 | 77);
    manager->common.magic = (unsigned int)(65 << 24 | 116 << 16 | 109 << 8 | 103);
    manager->mode = (enum anonymous$59)isc_taskmgrmode_normal;
    manager->mctx = (struct isc_mem *)(void *)0;
    result=isc__mutex_init(&manager->lock, "./../lib/isc/task.c", (unsigned int)1358);
    if(result == 0u)
    {
      do
      {
        signed int return_value_pthread_mutex_lock$3;
        return_value_pthread_mutex_lock$3=pthread_mutex_lock(&manager->lock);
        if(return_value_pthread_mutex_lock$3 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 1361, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      manager->workers = (unsigned int)0;
      (void)mctx;
      return_value_ereallocz$4=ereallocz((void *)0, (unsigned long int)workers * sizeof(unsigned long int) /*8ul*/ , (unsigned long int)0, 0);
      manager->threads = (unsigned long int *)return_value_ereallocz$4;
      if(manager->threads == ((unsigned long int *)NULL))
        result = (unsigned int)1;

      else
      {
        return_value_pthread_cond_init$6=pthread_cond_init(&manager->work_available, (const union anonymous$60 *)(void *)0);
        if(!(return_value_pthread_cond_init$6 == 0))
        {
          const char *return_value_isc_msgcat_get$5;
          return_value_isc_msgcat_get$5=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
          isc_error_unexpected("./../lib/isc/task.c", 1372, "isc_condition_init() %s", return_value_isc_msgcat_get$5);
          result = (unsigned int)34;
          goto cleanup_threads;
        }

        return_value_pthread_cond_init$8=pthread_cond_init(&manager->exclusive_granted, (const union anonymous$60 *)(void *)0);
        if(!(return_value_pthread_cond_init$8 == 0))
        {
          const char *return_value_isc_msgcat_get$7;
          return_value_isc_msgcat_get$7=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
          isc_error_unexpected("./../lib/isc/task.c", 1380, "isc_condition_init() %s", return_value_isc_msgcat_get$7);
          result = (unsigned int)34;
          goto cleanup_workavailable;
        }

        return_value_pthread_cond_init$10=pthread_cond_init(&manager->paused, (const union anonymous$60 *)(void *)0);
        if(!(return_value_pthread_cond_init$10 == 0))
        {
          const char *return_value_isc_msgcat_get$9;
          return_value_isc_msgcat_get$9=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
          isc_error_unexpected("./../lib/isc/task.c", 1388, "isc_condition_init() %s", return_value_isc_msgcat_get$9);
          result = (unsigned int)34;
          goto cleanup_exclusivegranted;
        }

        if(default_quantum == 0u)
          default_quantum = (unsigned int)5;

        manager->default_quantum = default_quantum;
        do
        {
          manager->tasks.head = (struct isc__task *)(void *)0;
          manager->tasks.tail = (struct isc__task *)(void *)0;
        }
        while((_Bool)0);
        do
        {
          manager->ready_tasks.head = (struct isc__task *)(void *)0;
          manager->ready_tasks.tail = (struct isc__task *)(void *)0;
        }
        while((_Bool)0);
        do
        {
          manager->ready_priority_tasks.head = (struct isc__task *)(void *)0;
          manager->ready_priority_tasks.tail = (struct isc__task *)(void *)0;
        }
        while((_Bool)0);
        manager->tasks_running = (unsigned int)0;
        manager->exclusive_requested = (enum anonymous$11)isc_boolean_false;
        manager->pause_requested = (enum anonymous$11)isc_boolean_false;
        manager->exiting = (enum anonymous$11)isc_boolean_false;
        do
          *(&manager->mctx) = mctx;
        while((_Bool)0);
        i = (unsigned int)0;
        for( ; !(i >= workers); i = i + 1u)
        {
          unsigned int return_value_isc_thread_create$11;
          return_value_isc_thread_create$11=isc_thread_create(run, (void *)manager, &manager->threads[(signed long int)manager->workers]);
          if(return_value_isc_thread_create$11 == 0u)
          {
            manager->workers = manager->workers + 1u;
            started = started + 1u;
          }

        }
        do
        {
          signed int return_value_pthread_mutex_unlock$12;
          return_value_pthread_mutex_unlock$12=pthread_mutex_unlock(&manager->lock);
          if(return_value_pthread_mutex_unlock$12 == 0)
            (_Bool)1;

          else
          {
            isc_error_runtimecheck("./../lib/isc/task.c", 1421, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
            (_Bool)0;
          }
        }
        while((_Bool)0);
        if(started == 0u)
        {
          manager_free(manager);
          return (unsigned int)3;
        }

        isc_thread_setconcurrency(workers);
        *managerp = (struct isc_taskmgr *)manager;
        return (unsigned int)0;

      cleanup_exclusivegranted:
        ;
        return_value_pthread_cond_destroy$13=pthread_cond_destroy(&manager->exclusive_granted);
        (void)(return_value_pthread_cond_destroy$13 == 0 ? 0 : 34);

      cleanup_workavailable:
        ;
        return_value_pthread_cond_destroy$14=pthread_cond_destroy(&manager->work_available);
        (void)(return_value_pthread_cond_destroy$14 == 0 ? 0 : 34);

      cleanup_threads:
        ;
        (void)mctx;
        free((void *)manager->threads);
      }
      do
      {

      cleanup_lock:
        ;
        signed int return_value_pthread_mutex_unlock$15;
        return_value_pthread_mutex_unlock$15=pthread_mutex_unlock(&manager->lock);
        if(return_value_pthread_mutex_unlock$15 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 1447, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      return_value_pthread_mutex_destroy$16=pthread_mutex_destroy(&manager->lock);
      if(return_value_pthread_mutex_destroy$16 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 1448, "((pthread_mutex_destroy(((&manager->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }


  cleanup_mgr:
    ;
    (void)sizeof(struct isc__taskmgr) /*304ul*/ ;
    (void)mctx;
    free((void *)manager);
    return result;
  }
}

// isc__taskmgr_destroy
// file ./../lib/isc/task.c line 1456
void isc__taskmgr_destroy(struct isc_taskmgr **managerp)
{
  struct isc__taskmgr *manager;
  struct isc__task *task;
  unsigned int i;
  if(!(managerp == ((struct isc_taskmgr **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 1465, (enum anonymous$46)isc_assertiontype_require, "managerp != ((void *)0)");
    (_Bool)0;
  }
  manager = (struct isc__taskmgr *)*managerp;
  _Bool tmp_if_expr$1;
  if(!(manager == ((struct isc__taskmgr *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)manager)->magic == (unsigned int)(84 << 24 | 83 << 16 | 75 << 8 | 77) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 1467, (enum anonymous$46)isc_assertiontype_require, "(((manager) != ((void *)0)) && (((const isc__magic_t *)(manager))->magic == ((('T') << 24 | ('S') << 16 | ('K') << 8 | ('M')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1499, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  if(manager->exiting == /*enum*/isc_boolean_false)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 1504, (enum anonymous$46)isc_assertiontype_insist, "!manager->exiting");
    (_Bool)0;
  }
  manager->exiting = (enum anonymous$11)isc_boolean_true;
  manager->mode = (enum anonymous$59)isc_taskmgrmode_normal;
  task = manager->tasks.head;
  for( ; !(task == ((struct isc__task *)NULL)); task = task->link.next)
  {
    do
    {
      signed int return_value_pthread_mutex_lock$3;
      return_value_pthread_mutex_lock$3=pthread_mutex_lock(&task->lock);
      if(return_value_pthread_mutex_lock$3 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 1519, "((pthread_mutex_lock(((&task->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
    enum anonymous$11 return_value_task_shutdown$4;
    return_value_task_shutdown$4=task_shutdown(task);
    if(!(return_value_task_shutdown$4 == /*enum*/isc_boolean_false))
      push_readyq(manager, task);

    do
    {
      signed int return_value_pthread_mutex_unlock$5;
      return_value_pthread_mutex_unlock$5=pthread_mutex_unlock(&task->lock);
      if(return_value_pthread_mutex_unlock$5 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 1522, "((pthread_mutex_unlock(((&task->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
  }
  do
  {
    signed int return_value_pthread_cond_broadcast$6;
    return_value_pthread_cond_broadcast$6=pthread_cond_broadcast(&manager->work_available);
    if(return_value_pthread_cond_broadcast$6 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1530, "((pthread_cond_broadcast(((&manager->work_available))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  do
  {
    signed int return_value_pthread_mutex_unlock$7;
    return_value_pthread_mutex_unlock$7=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$7 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1531, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  i = (unsigned int)0;
  signed int return_value_pthread_join$8;
  for( ; !(i >= manager->workers); i = i + 1u)
  {
    return_value_pthread_join$8=pthread_join(manager->threads[(signed long int)i], (void **)(void *)0);
    (void)(return_value_pthread_join$8 == 0 ? 0 : 34);
  }
  manager_free(manager);
  *managerp = (struct isc_taskmgr *)(void *)0;
}

// isc__taskmgr_mode
// file ./../lib/isc/task.c line 1570
enum anonymous$59 isc__taskmgr_mode(struct isc_taskmgr *manager0)
{
  struct isc__taskmgr *manager = (struct isc__taskmgr *)manager0;
  enum anonymous$59 mode;
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1573, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  mode = manager->mode;
  do
  {
    signed int return_value_pthread_mutex_unlock$2;
    return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1575, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  return mode;
}

// isc__taskmgr_pause
// file ./../lib/isc/task.c line 1617
void isc__taskmgr_pause(struct isc_taskmgr *manager0)
{
  struct isc__taskmgr *manager = (struct isc__taskmgr *)manager0;
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1619, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  while(manager->tasks_running >= 1u)
    do
    {
      signed int return_value_pthread_cond_wait$2;
      return_value_pthread_cond_wait$2=pthread_cond_wait(&manager->paused, &manager->lock);
      if(return_value_pthread_cond_wait$2 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 1621, "((pthread_cond_wait(((&manager->paused)), ((&manager->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
  manager->pause_requested = (enum anonymous$11)isc_boolean_true;
  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1624, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// isc__taskmgr_resume
// file ./../lib/isc/task.c line 1628
void isc__taskmgr_resume(struct isc_taskmgr *manager0)
{
  struct isc__taskmgr *manager = (struct isc__taskmgr *)manager0;
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1631, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  if(!(manager->pause_requested == /*enum*/isc_boolean_false))
  {
    manager->pause_requested = (enum anonymous$11)isc_boolean_false;
    do
    {
      signed int return_value_pthread_cond_broadcast$2;
      return_value_pthread_cond_broadcast$2=pthread_cond_broadcast(&manager->work_available);
      if(return_value_pthread_cond_broadcast$2 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 1634, "((pthread_cond_broadcast(((&manager->work_available))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
  }

  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1636, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// isc__taskmgr_setmode
// file ./../lib/isc/task.c line 1561
void isc__taskmgr_setmode(struct isc_taskmgr *manager0, enum anonymous$59 mode)
{
  struct isc__taskmgr *manager = (struct isc__taskmgr *)manager0;
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1564, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  manager->mode = mode;
  do
  {
    signed int return_value_pthread_mutex_unlock$2;
    return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1566, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// isc_assertion_failed
// file ../lib/isc/include/isc/assertions.h line 45
void isc_assertion_failed(const char *file, signed int line, enum anonymous$46 type, const char *cond)
{
  isc_assertion_failed_cb(file, line, type, cond);
  abort();
}

// isc_assertion_setcallback
// file ./../lib/isc/assertions.c line 64
void isc_assertion_setcallback(void (*cb)(const char *, signed int, enum anonymous$46, const char *))
{
  if(cb == ((void (*)(const char *, signed int, enum anonymous$46, const char *))NULL))
    isc_assertion_failed_cb = default_callback;

  else
    isc_assertion_failed_cb = cb;
}

// isc_assertion_typetotext
// file ./../lib/isc/assertions.c line 73
const char * isc_assertion_typetotext(enum anonymous$46 type)
{
  const char *result;
  switch((signed int)type)
  {
    case isc_assertiontype_require:
    {
      result = "REQUIRE";
      break;
    }
    case isc_assertiontype_ensure:
    {
      result = "ENSURE";
      break;
    }
    case isc_assertiontype_insist:
    {
      result = "INSIST";
      break;
    }
    case isc_assertiontype_invariant:
    {
      result = "INVARIANT";
      break;
    }
    default:
      result = (const char *)(void *)0;
  }
  return result;
}

// isc_backtrace_getsymbol
// file ../lib/isc/include/isc/backtrace.h line 109
unsigned int isc_backtrace_getsymbol(const void *addr, const char **symbolp, unsigned long int *offsetp)
{
  unsigned int result = (unsigned int)0;
  struct isc_backtrace_symmap *found;
  _Bool tmp_if_expr$1;
  if(symbolp == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = *symbolp != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(offsetp == ((unsigned long int *)NULL) || tmp_if_expr$1)
    return (unsigned int)25;

  else
    if(!(isc__backtrace_nsymbols >= 1))
      return (unsigned int)23;

    else
    {
      void *return_value_bsearch$2;
      return_value_bsearch$2=bsearch(addr, (const void *)isc__backtrace_symtable, (unsigned long int)isc__backtrace_nsymbols, sizeof(const struct isc_backtrace_symmap) /*16ul*/ , symtbl_compare);
      found = (struct isc_backtrace_symmap *)return_value_bsearch$2;
      if(found == ((struct isc_backtrace_symmap *)NULL))
        result = (unsigned int)23;

      else
      {
        *symbolp = found->symbol;
        *offsetp = (unsigned long int)((const char *)addr - (char *)found->addr);
      }
      return result;
    }
}

// isc_backtrace_getsymbolfromindex
// file ./../lib/isc/backtrace.c line 214
unsigned int isc_backtrace_getsymbolfromindex(signed int idx, const void **addrp, const char **symbolp)
{
  _Bool tmp_if_expr$1;
  if(!(addrp == ((const void **)NULL)))
    tmp_if_expr$1 = *addrp == (void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/backtrace.c", 217, (enum anonymous$46)isc_assertiontype_require, "addrp != ((void *)0) && *addrp == ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(!(symbolp == ((const char **)NULL)))
    tmp_if_expr$2 = *symbolp == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/backtrace.c", 218, (enum anonymous$46)isc_assertiontype_require, "symbolp != ((void *)0) && *symbolp == ((void *)0)");
    (_Bool)0;
  }
  if(idx >= isc__backtrace_nsymbols || !(idx >= 0))
    return (unsigned int)41;

  else
  {
    *addrp = isc__backtrace_symtable[(signed long int)idx].addr;
    *symbolp = isc__backtrace_symtable[(signed long int)idx].symbol;
    return (unsigned int)0;
  }
}

// isc_backtrace_gettrace
// file ../lib/isc/include/isc/backtrace.h line 66
unsigned int isc_backtrace_gettrace(void **addrs, signed int maxaddrs, signed int *nframes)
{
  if(addrs == ((void **)NULL) || nframes == ((signed int *)NULL))
    return (unsigned int)25;

  else
  {
    (void)maxaddrs;
    return (unsigned int)27;
  }
}

// isc_buffer_allocate
// file ./../lib/isc/buffer.c line 449
unsigned int isc_buffer_allocate(struct isc_mem *mctx, struct isc_buffer **dynbuffer, unsigned int length)
{
  struct isc_buffer *dbuf;
  if(!(dynbuffer == ((struct isc_buffer **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 454, (enum anonymous$46)isc_assertiontype_require, "dynbuffer != ((void *)0)");
    (_Bool)0;
  }
  if(*dynbuffer == ((struct isc_buffer *)NULL))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 455, (enum anonymous$46)isc_assertiontype_require, "*dynbuffer == ((void *)0)");
    (_Bool)0;
  }
  (void)mctx;
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, (unsigned long int)length + sizeof(struct isc_buffer) /*56ul*/ , (unsigned long int)0, 0);
  dbuf = (struct isc_buffer *)return_value_ereallocz$1;
  if(dbuf == ((struct isc_buffer *)NULL))
    return (unsigned int)1;

  else
  {
    isc__buffer_init(dbuf, (const void *)((unsigned char *)dbuf + (signed long int)sizeof(struct isc_buffer) /*56ul*/ ), length);
    dbuf->mctx = mctx;
    *dynbuffer = dbuf;
    return (unsigned int)0;
  }
}

// isc_buffer_compact
// file ./../lib/isc/buffer.c line 239
void isc_buffer_compact(struct isc_buffer *b)
{
  unsigned int length;
  void *src;
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 249, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  src = (void *)((unsigned char *)b->base + (signed long int)b->current);
  length = b->used - b->current;
  memmove(b->base, src, (unsigned long int)length);
  if(!(b->current >= b->active))
    b->active = b->active - b->current;

  else
    b->active = (unsigned int)0;
  b->current = (unsigned int)0;
  b->used = length;
}

// isc_buffer_copyregion
// file ./../lib/isc/buffer.c line 428
unsigned int isc_buffer_copyregion(struct isc_buffer *b, const struct isc_region *r)
{
  unsigned char *base;
  unsigned int available;
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 432, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(!(r == ((const struct isc_region *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 433, (enum anonymous$46)isc_assertiontype_require, "r != ((void *)0)");
    (_Bool)0;
  }
  base = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->used);
  available = b->length - b->used;
  if(!(available >= r->length))
    return (unsigned int)19;

  else
  {
    memcpy((void *)base, (const void *)r->base, (unsigned long int)r->length);
    b->used = b->used + r->length;
    return (unsigned int)0;
  }
}

// isc_buffer_free
// file ./../lib/isc/buffer.c line 471
void isc_buffer_free(struct isc_buffer **dynbuffer)
{
  unsigned int real_length;
  struct isc_buffer *dbuf;
  struct isc_mem *mctx;
  if(!(dynbuffer == ((struct isc_buffer **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 476, (enum anonymous$46)isc_assertiontype_require, "dynbuffer != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(*dynbuffer == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)*dynbuffer)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 477, (enum anonymous$46)isc_assertiontype_require, "(((*dynbuffer) != ((void *)0)) && (((const isc__magic_t *)(*dynbuffer))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(!((*dynbuffer)->mctx == ((struct isc_mem *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 478, (enum anonymous$46)isc_assertiontype_require, "(*dynbuffer)->mctx != ((void *)0)");
    (_Bool)0;
  }
  dbuf = *dynbuffer;
  *dynbuffer = (struct isc_buffer *)(void *)0;
  real_length = (unsigned int)((unsigned long int)dbuf->length + sizeof(struct isc_buffer) /*56ul*/ );
  mctx = dbuf->mctx;
  dbuf->mctx = (struct isc_mem *)(void *)0;
  isc__buffer_invalidate(dbuf);
  (void)real_length;
  (void)mctx;
  free((void *)dbuf);
}

// isc_buffer_getuint16
// file ./../lib/isc/buffer.c line 291
unsigned short int isc_buffer_getuint16(struct isc_buffer *b)
{
  unsigned char *cp;
  unsigned short int result;
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 300, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->used + -b->current >= 2u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 301, (enum anonymous$46)isc_assertiontype_require, "b->used - b->current >= 2");
    (_Bool)0;
  }
  cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->current);
  b->current = b->current + (unsigned int)2;
  result = (unsigned short int)((unsigned int)cp[(signed long int)0] << 8);
  result = result | (unsigned short int)(unsigned int)cp[(signed long int)1];
  return result;
}

// isc_buffer_getuint32
// file ./../lib/isc/buffer.c line 328
unsigned int isc_buffer_getuint32(struct isc_buffer *b)
{
  unsigned char *cp;
  unsigned int result;
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 337, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->used + -b->current >= 4u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 338, (enum anonymous$46)isc_assertiontype_require, "b->used - b->current >= 4");
    (_Bool)0;
  }
  cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->current);
  b->current = b->current + (unsigned int)4;
  result = (unsigned int)cp[(signed long int)0] << 24;
  result = result | (unsigned int)cp[(signed long int)1] << 16;
  result = result | (unsigned int)cp[(signed long int)2] << 8;
  result = result | (unsigned int)cp[(signed long int)3];
  return result;
}

// isc_buffer_getuint48
// file ./../lib/isc/buffer.c line 359
unsigned long long int isc_buffer_getuint48(struct isc_buffer *b)
{
  unsigned char *cp;
  unsigned long long int result;
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 368, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->used + -b->current >= 6u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 369, (enum anonymous$46)isc_assertiontype_require, "b->used - b->current >= 6");
    (_Bool)0;
  }
  cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->current);
  b->current = b->current + (unsigned int)6;
  result = (unsigned long long int)((signed long long int)cp[(signed long int)0] << 40);
  result = result | (unsigned long long int)((signed long long int)cp[(signed long int)1] << 32);
  result = result | (unsigned long long int)((signed long long int)cp[(signed long int)2] << 24);
  result = result | (unsigned long long int)((signed long long int)cp[(signed long int)3] << 16);
  result = result | (unsigned long long int)((signed long long int)cp[(signed long int)4] << 8);
  result = result | (unsigned long long int)(signed long long int)cp[(signed long int)5];
  return result;
}

// isc_buffer_getuint8
// file ./../lib/isc/buffer.c line 264
unsigned char isc_buffer_getuint8(struct isc_buffer *b)
{
  unsigned char *cp;
  unsigned char result;
  _Bool tmp_if_expr$1;
  if(!(b == ((struct isc_buffer *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)b)->magic == 0x42756621U ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 272, (enum anonymous$46)isc_assertiontype_require, "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
    (_Bool)0;
  }
  if(b->used + -b->current >= 1u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 273, (enum anonymous$46)isc_assertiontype_require, "b->used - b->current >= 1");
    (_Bool)0;
  }
  cp = (unsigned char *)(void *)((unsigned char *)b->base + (signed long int)b->current);
  b->current = b->current + (unsigned int)1;
  result = (unsigned char)cp[(signed long int)0];
  return result;
}

// isc_buffer_reinit
// file ./../lib/isc/buffer.c line 53
void isc_buffer_reinit(struct isc_buffer *b, void *base, unsigned int length)
{
  if(length >= b->length)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 63, (enum anonymous$46)isc_assertiontype_require, "b->length <= length");
    (_Bool)0;
  }
  if(!(base == NULL))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/buffer.c", 64, (enum anonymous$46)isc_assertiontype_require, "base != ((void *)0)");
    (_Bool)0;
  }
  memmove(base, b->base, (unsigned long int)b->length);
  b->base = base;
  b->length = length;
}

// isc_condition_waituntil
// file ./../lib/isc/pthreads/condition.c line 34
unsigned int isc_condition_waituntil(union anonymous$1 *c, union anonymous$2 *m, struct isc_time *t)
{
  signed int presult;
  unsigned int result;
  struct timespec ts;
  char strbuf[128l];
  if(!(c == ((union anonymous$1 *)NULL)) && !(m == ((union anonymous$2 *)NULL)) && !(t == ((struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/pthreads/condition.c", 40, (enum anonymous$46)isc_assertiontype_require, "c != ((void *)0) && m != ((void *)0) && t != ((void *)0)");
    (_Bool)0;
  }
  result=isc_time_secondsastimet(t, &ts.tv_sec);
  if(!(result == 0u))
    return result;

  else
  {
    unsigned int return_value_isc_time_nanoseconds$1;
    return_value_isc_time_nanoseconds$1=isc_time_nanoseconds(t);
    ts.tv_nsec = (signed long int)return_value_isc_time_nanoseconds$1;
    do
    {
      presult=pthread_cond_timedwait(c, m, &ts);
      if(presult == 0)
        return (unsigned int)0;

      if(presult == 110)
        return (unsigned int)2;

    }
    while(presult == 4);
    isc__strerror(presult, strbuf, sizeof(char [128l]) /*128ul*/ );
    const char *return_value_isc_msgcat_get$2;
    return_value_isc_msgcat_get$2=isc_msgcat_get(isc_msgcat, 1, 109, "returned");
    isc_error_unexpected("./../lib/isc/pthreads/condition.c", 68, "pthread_cond_timedwait() %s %s", return_value_isc_msgcat_get$2, (const void *)strbuf);
    return (unsigned int)34;
  }
}

// isc_dir_chdir
// file ./../lib/isc/unix/dir.c line 161
unsigned int isc_dir_chdir(const char *dirname)
{
  if(!(dirname == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/dir.c", 166, (enum anonymous$46)isc_assertiontype_require, "dirname != ((void *)0)");
    (_Bool)0;
  }
  signed int return_value_chdir$3;
  return_value_chdir$3=chdir(dirname);
  signed int *return_value___errno_location$1;
  unsigned int return_value_isc___errno2result$2;
  if(!(return_value_chdir$3 >= 0))
  {
    return_value___errno_location$1=__errno_location();
    return_value_isc___errno2result$2=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/dir.c", (unsigned int)169);
    return return_value_isc___errno2result$2;
  }

  else
    return (unsigned int)0;
}

// isc_dir_chroot
// file ./../lib/isc/unix/dir.c line 175
unsigned int isc_dir_chroot(const char *dirname)
{
  if(!(dirname == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/dir.c", 177, (enum anonymous$46)isc_assertiontype_require, "dirname != ((void *)0)");
    (_Bool)0;
  }
  return (unsigned int)27;
}

// isc_dir_close
// file ./../lib/isc/unix/dir.c line 141
void isc_dir_close(struct isc_dir *dir)
{
  _Bool tmp_if_expr$1;
  if(!(dir == ((struct isc_dir *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)dir)->magic == (unsigned int)(68 << 24 | 73 << 16 | 82 << 8 | 42) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = dir->handle != (struct __dirstream *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/dir.c", 142, (enum anonymous$46)isc_assertiontype_require, "(((dir) != ((void *)0)) && (((const isc__magic_t *)(dir))->magic == ((('D') << 24 | ('I') << 16 | ('R') << 8 | ('*'))))) && dir->handle != ((void *)0)");
    (_Bool)0;
  }
  closedir(dir->handle);
  dir->handle = (struct __dirstream *)(void *)0;
}

// isc_dir_createunique
// file ./../lib/isc/unix/dir.c line 190
unsigned int isc_dir_createunique(char *templet)
{
  unsigned int result;
  char *x;
  char *p;
  signed int i;
  signed int pid;
  if(!(templet == ((char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/dir.c", 197, (enum anonymous$46)isc_assertiontype_require, "templet != ((void *)0)");
    (_Bool)0;
  }
  pid=getpid();
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(templet);
  x = (templet + (signed long int)return_value_strlen$1) - (signed long int)1;
  for( ; (signed int)*x == 88 && x >= templet; pid = pid / 10)
  {
    *x = (char)(pid % 10 + 48);
    x = x - 1l;
  }
  x = x + 1l;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  char *tmp_post$4;
  do
  {
    i=mkdir(templet, (unsigned int)0700);
    if(i == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 != 17 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      break;

    p = x;
    while(!((signed int)*p == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$5;
      return_value___ctype_b_loc$5=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(0xff & (signed int)*p)]) == 0))
        *p = (char)97;

      else
        if(!((signed int)*p == 122))
          *p = *p + 1;

        else
        {
          tmp_post$4 = p;
          p = p + 1l;
          *tmp_post$4 = (char)97;
          continue;
        }
      break;
    }
    if((signed int)*p == 0)
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      *return_value___errno_location$6 = 17;
      break;
    }

  }
  while((_Bool)1);
  signed int *return_value___errno_location$7;
  if(i == -1)
  {
    return_value___errno_location$7=__errno_location();
    result=isc___errno2result(*return_value___errno_location$7, "./../lib/isc/unix/dir.c", (unsigned int)251);
  }

  else
    result = (unsigned int)0;
  return result;
}

// isc_dir_init
// file ./../lib/isc/unix/dir.c line 44
void isc_dir_init(struct isc_dir *dir)
{
  if(!(dir == ((struct isc_dir *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/dir.c", 45, (enum anonymous$46)isc_assertiontype_require, "dir != ((void *)0)");
    (_Bool)0;
  }
  dir->entry.name[(signed long int)0] = (char)0;
  dir->entry.length = (unsigned int)0;
  dir->handle = (struct __dirstream *)(void *)0;
  dir->magic = (unsigned int)(68 << 24 | 73 << 16 | 82 << 8 | 42);
}

// isc_dir_open
// file ./../lib/isc/unix/dir.c line 60
unsigned int isc_dir_open(struct isc_dir *dir, const char *dirname)
{
  char *p;
  unsigned long int octets;
  unsigned int result = (unsigned int)0;
  _Bool tmp_if_expr$1;
  if(!(dir == ((struct isc_dir *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)dir)->magic == (unsigned int)(68 << 24 | 73 << 16 | 82 << 8 | 42) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/dir.c", 65, (enum anonymous$46)isc_assertiontype_require, "(((dir) != ((void *)0)) && (((const isc__magic_t *)(dir))->magic == ((('D') << 24 | ('I') << 16 | ('R') << 8 | ('*')))))");
    (_Bool)0;
  }
  if(!(dirname == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/dir.c", 66, (enum anonymous$46)isc_assertiontype_require, "dirname != ((void *)0)");
    (_Bool)0;
  }
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(dirname);
  octets = return_value_strlen$2 + (unsigned long int)1;
  char *tmp_post$4;
  char *tmp_post$5;
  signed int *return_value___errno_location$6;
  unsigned int return_value_isc___errno2result$7;
  if(2ul + octets >= 1025ul)
    return (unsigned int)19;

  else
  {
    strlcpy(dir->dirname, dirname, octets);
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(dir->dirname);
    p = dir->dirname + (signed long int)return_value_strlen$3;
    if(!(dir->dirname >= p))
    {
      if(!((signed int)p[-1l] == 47))
      {
        tmp_post$4 = p;
        p = p + 1l;
        *tmp_post$4 = (char)47;
      }

    }

    tmp_post$5 = p;
    p = p + 1l;
    *tmp_post$5 = (char)42;
    *p = (char)0;
    dir->handle=opendir(dirname);
    if(dir->handle == ((struct __dirstream *)NULL))
    {
      return_value___errno_location$6=__errno_location();
      return_value_isc___errno2result$7=isc___errno2result(*return_value___errno_location$6, "./../lib/isc/unix/dir.c", (unsigned int)93);
      return return_value_isc___errno2result$7;
    }

    else
      return result;
  }
}

// isc_dir_read
// file ./../lib/isc/unix/dir.c line 106
unsigned int isc_dir_read(struct isc_dir *dir)
{
  struct dirent *entry;
  unsigned long int octets;
  _Bool tmp_if_expr$1;
  if(!(dir == ((struct isc_dir *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)dir)->magic == (unsigned int)(68 << 24 | 73 << 16 | 82 << 8 | 42) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = dir->handle != (struct __dirstream *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/dir.c", 110, (enum anonymous$46)isc_assertiontype_require, "(((dir) != ((void *)0)) && (((const isc__magic_t *)(dir))->magic == ((('D') << 24 | ('I') << 16 | ('R') << 8 | ('*'))))) && dir->handle != ((void *)0)");
    (_Bool)0;
  }
  entry=readdir(dir->handle);
  if(entry == ((struct dirent *)NULL))
    return (unsigned int)29;

  else
  {
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(entry->d_name);
    octets = return_value_strlen$3 + (unsigned long int)1;
    if(octets >= 257ul)
      return (unsigned int)34;

    else
    {
      strlcpy(dir->entry.name, entry->d_name, octets);
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(entry->d_name);
      dir->entry.length = (unsigned int)return_value_strlen$4;
      return (unsigned int)0;
    }
  }
}

// isc_dir_reset
// file ./../lib/isc/unix/dir.c line 152
unsigned int isc_dir_reset(struct isc_dir *dir)
{
  _Bool tmp_if_expr$1;
  if(!(dir == ((struct isc_dir *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)dir)->magic == (unsigned int)(68 << 24 | 73 << 16 | 82 << 8 | 42) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = dir->handle != (struct __dirstream *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/dir.c", 153, (enum anonymous$46)isc_assertiontype_require, "(((dir) != ((void *)0)) && (((const isc__magic_t *)(dir))->magic == ((('D') << 24 | ('I') << 16 | ('R') << 8 | ('*'))))) && dir->handle != ((void *)0)");
    (_Bool)0;
  }
  rewinddir(dir->handle);
  return (unsigned int)0;
}

// isc_error_fatal
// file ./../lib/isc/error.c line 70
void isc_error_fatal(const char *file, signed int line, const char *format, ...)
{
  void **args = (void **)&format;
  fatal_callback(file, line, format, args);
  args = ((void **)NULL);
  abort();
}

// isc_error_runtimecheck
// file ./../lib/isc/error.c line 80
void isc_error_runtimecheck(const char *file, signed int line, const char *expression)
{
  const char *return_value_isc_msgcat_get$1;
  return_value_isc_msgcat_get$1=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
  isc_error_fatal(file, line, "RUNTIME_CHECK(%s) %s", expression, return_value_isc_msgcat_get$1);
}

// isc_error_setfatal
// file ./../lib/isc/error.c line 53
void isc_error_setfatal(void (*cb)(const char *, signed int, const char *, void **))
{
  if(cb == ((void (*)(const char *, signed int, const char *, void **))NULL))
    fatal_callback = default_fatal_callback;

  else
    fatal_callback = cb;
}

// isc_error_setunexpected
// file ./../lib/isc/error.c line 45
void isc_error_setunexpected(void (*cb)(const char *, signed int, const char *, void **))
{
  if(cb == ((void (*)(const char *, signed int, const char *, void **))NULL))
    unexpected_callback = default_unexpected_callback;

  else
    unexpected_callback = cb;
}

// isc_error_unexpected
// file ../lib/isc/include/isc/error.h line 45
void isc_error_unexpected(const char *file, signed int line, const char *format, ...)
{
  void **args = (void **)&format;
  unexpected_callback(file, line, format, args);
  args = ((void **)NULL);
}

// isc_event_allocate
// file ./../lib/isc/event.c line 41
struct isc_event * isc_event_allocate(struct isc_mem *mctx, void *sender, unsigned int type, void (*action)(struct isc_task *, struct isc_event *), const void *arg, unsigned long int size)
{
  struct isc_event *event;
  void *deconst_arg;
  if(size >= sizeof(struct isc_event) /*88ul*/ )
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/event.c", 47, (enum anonymous$46)isc_assertiontype_require, "size >= sizeof(struct isc_event)");
    (_Bool)0;
  }
  if(!(action == ((void (*)(struct isc_task *, struct isc_event *))NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/event.c", 48, (enum anonymous$46)isc_assertiontype_require, "action != ((void *)0)");
    (_Bool)0;
  }
  (void)mctx;
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, size, (unsigned long int)0, 0);
  event = (struct isc_event *)return_value_ereallocz$1;
  if(event == ((struct isc_event *)NULL))
    return (struct isc_event *)(void *)0;

  else
  {
    do
    {
      /* tag-#anon#lUN[l*{clV}$clV$'k'||l*{lV}$lV$'v'|] */
union anonymous$9
{
  // k
  const void *k;
  // v
  void *v;
};

/* */
      ;
      union anonymous$9 _u;
      _u.k = arg;
      deconst_arg = _u.v;
    }
    while((_Bool)0);
    do
    {
      event->ev_size = size;
      event->ev_attributes = (unsigned int)0;
      event->ev_tag = (void *)0;
      event->ev_type = type;
      event->ev_action = action;
      event->ev_arg = deconst_arg;
      event->ev_sender = sender;
      event->ev_destroy = destroy;
      event->ev_destroy_arg = (void *)mctx;
      do
      {
        event->ev_link.prev = (struct isc_event *)(void *)-1;
        event->ev_link.next = (struct isc_event *)(void *)-1;
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    return event;
  }
}

// isc_event_free
// file ./../lib/isc/event.c line 75
void isc_event_free(struct isc_event **eventp)
{
  struct isc_event *event;
  if(!(eventp == ((struct isc_event **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/event.c", 78, (enum anonymous$46)isc_assertiontype_require, "eventp != ((void *)0)");
    (_Bool)0;
  }
  event = *eventp;
  if(!(event == ((struct isc_event *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/event.c", 80, (enum anonymous$46)isc_assertiontype_require, "event != ((void *)0)");
    (_Bool)0;
  }
  if(!(event->ev_destroy == ((void (*)(struct isc_event *))NULL)))
    event->ev_destroy(event);

  *eventp = (struct isc_event *)(void *)0;
}

// isc_file_absolutepath
// file ./../lib/isc/unix/file.c line 454
unsigned int isc_file_absolutepath(const char *filename, char *path, unsigned long int pathlen)
{
  unsigned int result;
  result=dir_current(path, pathlen);
  if(!(result == 0u))
    return result;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(path);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(filename);
    if(!(pathlen >= 1ul + return_value_strlen$1 + return_value_strlen$2))
      return (unsigned int)19;

    else
    {
      strlcat(path, filename, pathlen);
      return (unsigned int)0;
    }
  }
}

// isc_file_basename
// file ./../lib/isc/unix/file.c line 392
const char * isc_file_basename(const char *filename)
{
  char *s;
  if(!(filename == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 395, (enum anonymous$46)isc_assertiontype_require, "filename != ((void *)0)");
    (_Bool)0;
  }
  s=strrchr(filename, 47);
  if(s == ((char *)NULL))
    return filename;

  else
    return s + (signed long int)1;
}

// isc_file_exists
// file ./../lib/isc/unix/file.c line 344
enum anonymous$11 isc_file_exists(const char *pathname)
{
  struct stat stats;
  if(!(pathname == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 347, (enum anonymous$46)isc_assertiontype_require, "pathname != ((void *)0)");
    (_Bool)0;
  }
  unsigned int return_value_file_stats$1;
  return_value_file_stats$1=file_stats(pathname, &stats);
  return (enum anonymous$11)(return_value_file_stats$1 == (unsigned int)0 ? isc_boolean_true : isc_boolean_false);
}

// isc_file_getmodtime
// file ./../lib/isc/unix/file.c line 102
unsigned int isc_file_getmodtime(const char *file, struct isc_time *itime)
{
  unsigned int result;
  struct stat stats;
  if(!(file == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 106, (enum anonymous$46)isc_assertiontype_require, "file != ((void *)0)");
    (_Bool)0;
  }
  if(!(itime == ((struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 107, (enum anonymous$46)isc_assertiontype_require, "itime != ((void *)0)");
    (_Bool)0;
  }
  result=file_stats(file, &stats);
  if(result == 0u)
    isc_time_set(itime, (unsigned int)stats.st_mtim.tv_sec, (unsigned int)0);

  return result;
}

// isc_file_isabsolute
// file ./../lib/isc/unix/file.c line 370
enum anonymous$11 isc_file_isabsolute(const char *filename)
{
  if(!(filename == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 371, (enum anonymous$46)isc_assertiontype_require, "filename != ((void *)0)");
    (_Bool)0;
  }
  return (enum anonymous$11)((signed int)filename[(signed long int)0] == 47 ? isc_boolean_true : isc_boolean_false);
}

// isc_file_ischdiridempotent
// file ./../lib/isc/unix/file.c line 382
enum anonymous$11 isc_file_ischdiridempotent(const char *filename)
{
  if(!(filename == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 383, (enum anonymous$46)isc_assertiontype_require, "filename != ((void *)0)");
    (_Bool)0;
  }
  enum anonymous$11 return_value_isc_file_isabsolute$1;
  return_value_isc_file_isabsolute$1=isc_file_isabsolute(filename);
  if(!(return_value_isc_file_isabsolute$1 == /*enum*/isc_boolean_false))
    return (enum anonymous$11)isc_boolean_true;

  else
  {
    enum anonymous$11 return_value_isc_file_iscurrentdir$2;
    return_value_isc_file_iscurrentdir$2=isc_file_iscurrentdir(filename);
    if(!(return_value_isc_file_iscurrentdir$2 == /*enum*/isc_boolean_false))
      return (enum anonymous$11)isc_boolean_true;

    else
      return (enum anonymous$11)isc_boolean_false;
  }
}

// isc_file_iscurrentdir
// file ./../lib/isc/unix/file.c line 376
enum anonymous$11 isc_file_iscurrentdir(const char *filename)
{
  if(!(filename == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 377, (enum anonymous$46)isc_assertiontype_require, "filename != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if((signed int)*filename == 46)
    tmp_if_expr$1 = (signed int)filename[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return (enum anonymous$11)(tmp_if_expr$1 ? isc_boolean_true : isc_boolean_false);
}

// isc_file_isplainfile
// file ./../lib/isc/unix/file.c line 353
unsigned int isc_file_isplainfile(const char *filename)
{
  struct stat filestat;
  memset((void *)&filestat, 0, sizeof(struct stat) /*144ul*/ );
  signed int return_value_stat$3;
  return_value_stat$3=stat(filename, &filestat);
  signed int *return_value___errno_location$1;
  unsigned int return_value_isc___errno2result$2;
  if(return_value_stat$3 == -1)
  {
    return_value___errno_location$1=__errno_location();
    return_value_isc___errno2result$2=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/file.c", (unsigned int)361);
    return return_value_isc___errno2result$2;
  }

  else
    if(!((61440u & filestat.st_mode) == 32768u))
      return (unsigned int)30;

    else
      return (unsigned int)0;
}

// isc_file_mktemplate
// file ./../lib/isc/unix/file.c line 165
unsigned int isc_file_mktemplate(const char *path, char *buf, unsigned long int buflen)
{
  unsigned int return_value_isc_file_template$1;
  return_value_isc_file_template$1=isc_file_template(path, "tmp-XXXXXXXXXX", buf, buflen);
  return return_value_isc_file_template$1;
}

// isc_file_openunique
// file ./../lib/isc/unix/file.c line 248
unsigned int isc_file_openunique(char *templet, struct _IO_FILE **fp)
{
  signed int mode = 0200 | 0400 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3;
  unsigned int return_value_isc_file_openuniquemode$1;
  return_value_isc_file_openuniquemode$1=isc_file_openuniquemode(templet, mode, fp);
  return return_value_isc_file_openuniquemode$1;
}

// isc_file_openuniquemode
// file ./../lib/isc/unix/file.c line 260
unsigned int isc_file_openuniquemode(char *templet, signed int mode, struct _IO_FILE **fp)
{
  signed int fd;
  struct _IO_FILE *f;
  unsigned int result = (unsigned int)0;
  char *x;
  char *cp;
  unsigned int which;
  if(!(templet == ((char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 268, (enum anonymous$46)isc_assertiontype_require, "templet != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(fp == ((struct _IO_FILE **)NULL)))
    tmp_if_expr$1 = *fp == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 269, (enum anonymous$46)isc_assertiontype_require, "fp != ((void *)0) && *fp == ((void *)0)");
    (_Bool)0;
  }
  cp = templet;
  for( ; !((signed int)*cp == 0); cp = cp + 1l)
    ;
  char *tmp_post$2;
  char *tmp_post$3;
  signed int *return_value___errno_location$4;
  unsigned int return_value_isc___errno2result$5;
  _Bool tmp_if_expr$8;
  char *tmp_post$7;
  if(cp == templet)
    return (unsigned int)25;

  else
  {
    tmp_post$2 = cp;
    cp = cp - 1l;
    x = tmp_post$2;
    for( ; cp >= templet; x = tmp_post$3)
    {
      if(!((signed int)*cp == 88))
        break;

      isc_random_get(&which);
      *cp = alphnum[(signed long int)((unsigned long int)which % (sizeof(char [63l]) /*63ul*/  - (unsigned long int)1))];
      tmp_post$3 = cp;
      cp = cp - 1l;
    }
    do
    {
      fd=open(templet, 02 | 0100 | 0200, mode);
      if(!(fd == -1))
        break;

      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      if(!(*return_value___errno_location$6 == 17))
      {
        return_value___errno_location$4=__errno_location();
        return_value_isc___errno2result$5=isc___errno2result(*return_value___errno_location$4, "./../lib/isc/unix/file.c", (unsigned int)287);
        return return_value_isc___errno2result$5;
      }

      cp = x;
      do
      {
        char *t;
        if((signed int)*cp == 0)
          return (unsigned int)25;

        t=strchr(alphnum, (signed int)*cp);
        if(t == ((char *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          t = t + 1l;
          tmp_if_expr$8 = (signed int)*t == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          tmp_post$7 = cp;
          cp = cp + 1l;
          *tmp_post$7 = alphnum[(signed long int)0];
        }

        else
        {
          *cp = *t;
          break;
        }
      }
      while((_Bool)1);
    }
    while((_Bool)1);
    f=fdopen(fd, "w+");
    if(f == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      result=isc___errno2result(*return_value___errno_location$9, "./../lib/isc/unix/file.c", (unsigned int)303);
      signed int return_value_remove$10;
      return_value_remove$10=remove(templet);
      if(!(return_value_remove$10 >= 0))
        isc_log_write(isc_lctx, &isc_categories[(signed long int)1], &isc_modules[(signed long int)4], -4, "remove '%s': failed", templet);

      close(fd);
    }

    else
      *fp = f;
    return result;
  }
}

// isc_file_openuniqueprivate
// file ./../lib/isc/unix/file.c line 254
unsigned int isc_file_openuniqueprivate(char *templet, struct _IO_FILE **fp)
{
  signed int mode = 0200 | 0400;
  unsigned int return_value_isc_file_openuniquemode$1;
  return_value_isc_file_openuniquemode$1=isc_file_openuniquemode(templet, mode, fp);
  return return_value_isc_file_openuniquemode$1;
}

// isc_file_progname
// file ./../lib/isc/unix/file.c line 405
unsigned int isc_file_progname(const char *filename, char *buf, unsigned long int buflen)
{
  const char *base;
  unsigned long int len;
  if(!(filename == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 409, (enum anonymous$46)isc_assertiontype_require, "filename != ((void *)0)");
    (_Bool)0;
  }
  if(!(buf == ((char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 410, (enum anonymous$46)isc_assertiontype_require, "buf != ((void *)0)");
    (_Bool)0;
  }
  base=isc_file_basename(filename);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(base);
  len = return_value_strlen$1 + (unsigned long int)1;
  if(!(buflen >= len))
    return (unsigned int)19;

  else
  {
    memcpy((void *)buf, (const void *)base, len);
    return (unsigned int)0;
  }
}

// isc_file_remove
// file ./../lib/isc/unix/file.c line 317
unsigned int isc_file_remove(const char *filename)
{
  signed int r;
  if(!(filename == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 320, (enum anonymous$46)isc_assertiontype_require, "filename != ((void *)0)");
    (_Bool)0;
  }
  r=unlink(filename);
  signed int *return_value___errno_location$1;
  unsigned int return_value_isc___errno2result$2;
  if(r == 0)
    return (unsigned int)0;

  else
  {
    return_value___errno_location$1=__errno_location();
    return_value_isc___errno2result$2=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/file.c", (unsigned int)326);
    return return_value_isc___errno2result$2;
  }
}

// isc_file_rename
// file ./../lib/isc/unix/file.c line 330
unsigned int isc_file_rename(const char *oldname, const char *newname)
{
  signed int r;
  if(!(oldname == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 333, (enum anonymous$46)isc_assertiontype_require, "oldname != ((void *)0)");
    (_Bool)0;
  }
  if(!(newname == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 334, (enum anonymous$46)isc_assertiontype_require, "newname != ((void *)0)");
    (_Bool)0;
  }
  r=rename(oldname, newname);
  signed int *return_value___errno_location$1;
  unsigned int return_value_isc___errno2result$2;
  if(r == 0)
    return (unsigned int)0;

  else
  {
    return_value___errno_location$1=__errno_location();
    return_value_isc___errno2result$2=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/file.c", (unsigned int)340);
    return return_value_isc___errno2result$2;
  }
}

// isc_file_renameunique
// file ./../lib/isc/unix/file.c line 205
unsigned int isc_file_renameunique(const char *file, char *templet)
{
  char *x;
  char *cp;
  unsigned int which;
  if(!(file == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 210, (enum anonymous$46)isc_assertiontype_require, "file != ((void *)0)");
    (_Bool)0;
  }
  if(!(templet == ((char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 211, (enum anonymous$46)isc_assertiontype_require, "templet != ((void *)0)");
    (_Bool)0;
  }
  cp = templet;
  for( ; !((signed int)*cp == 0); cp = cp + 1l)
    ;
  char *tmp_post$1;
  char *tmp_post$2;
  signed int return_value_link$3;
  signed int *return_value___errno_location$4;
  unsigned int return_value_isc___errno2result$5;
  _Bool tmp_if_expr$8;
  char *tmp_post$7;
  signed int *return_value___errno_location$11;
  signed int *return_value___errno_location$9;
  unsigned int return_value_isc___errno2result$10;
  if(cp == templet)
    return (unsigned int)25;

  else
  {
    tmp_post$1 = cp;
    cp = cp - 1l;
    x = tmp_post$1;
    for( ; cp >= templet; x = tmp_post$2)
    {
      if(!((signed int)*cp == 88))
        break;

      isc_random_get(&which);
      *cp = alphnum[(signed long int)((unsigned long int)which % (sizeof(char [63l]) /*63ul*/  - (unsigned long int)1))];
      tmp_post$2 = cp;
      cp = cp - 1l;
    }
    do
    {
      return_value_link$3=link(file, templet);
      if(!(return_value_link$3 == -1))
        break;

      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      if(!(*return_value___errno_location$6 == 17))
      {
        return_value___errno_location$4=__errno_location();
        return_value_isc___errno2result$5=isc___errno2result(*return_value___errno_location$4, "./../lib/isc/unix/file.c", (unsigned int)227);
        return return_value_isc___errno2result$5;
      }

      cp = x;
      do
      {
        char *t;
        if((signed int)*cp == 0)
          return (unsigned int)25;

        t=strchr(alphnum, (signed int)*cp);
        if(t == ((char *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          t = t + 1l;
          tmp_if_expr$8 = (signed int)*t == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          tmp_post$7 = cp;
          cp = cp + 1l;
          *tmp_post$7 = alphnum[(signed long int)0];
        }

        else
        {
          *cp = *t;
          break;
        }
      }
      while((_Bool)1);
    }
    while((_Bool)1);
    signed int return_value_unlink$12;
    return_value_unlink$12=unlink(file);
    if(!(return_value_unlink$12 >= 0))
    {
      return_value___errno_location$11=__errno_location();
      if(*return_value___errno_location$11 == 2)
        goto __CPROVER_DUMP_L21;

      return_value___errno_location$9=__errno_location();
      return_value_isc___errno2result$10=isc___errno2result(*return_value___errno_location$9, "./../lib/isc/unix/file.c", (unsigned int)243);
      return return_value_isc___errno2result$10;
    }

    else
    {

    __CPROVER_DUMP_L21:
      ;
      return (unsigned int)0;
    }
  }
}

// isc_file_safecreate
// file ./../lib/isc/unix/file.c line 475
unsigned int isc_file_safecreate(const char *filename, struct _IO_FILE **fp)
{
  unsigned int result;
  signed int flags;
  struct stat sb;
  struct _IO_FILE *f;
  signed int fd;
  if(!(filename == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 482, (enum anonymous$46)isc_assertiontype_require, "filename != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(fp == ((struct _IO_FILE **)NULL)))
    tmp_if_expr$1 = *fp == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 483, (enum anonymous$46)isc_assertiontype_require, "fp != ((void *)0) && *fp == ((void *)0)");
    (_Bool)0;
  }
  result=file_stats(filename, &sb);
  if(result == 0u)
  {
    if((32768u & sb.st_mode) == 0u)
      return (unsigned int)30;

    flags = 01 | 01000;
  }

  else
    if(result == 38u)
      flags = 01 | 0100 | 0200;

    else
      return result;
  fd=open(filename, flags, 0400 | 0200);
  signed int *return_value___errno_location$2;
  unsigned int return_value_isc___errno2result$3;
  if(fd == -1)
  {
    return_value___errno_location$2=__errno_location();
    return_value_isc___errno2result$3=isc___errno2result(*return_value___errno_location$2, "./../lib/isc/unix/file.c", (unsigned int)497);
    return return_value_isc___errno2result$3;
  }

  else
  {
    f=fdopen(fd, "w");
    if(f == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      result=isc___errno2result(*return_value___errno_location$4, "./../lib/isc/unix/file.c", (unsigned int)501);
      close(fd);
      return result;
    }

    *fp = f;
    return (unsigned int)0;
  }
}

// isc_file_settime
// file ./../lib/isc/unix/file.c line 122
unsigned int isc_file_settime(const char *file, struct isc_time *itime)
{
  struct timeval times[2l];
  if(!(file == ((const char *)NULL)) && !(itime == ((struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 125, (enum anonymous$46)isc_assertiontype_require, "file != ((void *)0) && itime != ((void *)0)");
    (_Bool)0;
  }
  unsigned int return_value_isc_time_seconds$1;
  return_value_isc_time_seconds$1=isc_time_seconds(itime);
  times[(signed long int)1].tv_sec = (signed long int)return_value_isc_time_seconds$1;
  times[(signed long int)0].tv_sec = times[(signed long int)1].tv_sec;
  signed int *return_value___errno_location$3;
  unsigned int return_value_isc___errno2result$4;
  if(!((9223372036854775808ull & (unsigned long int)times[0l].tv_sec) == 0ul))
    return (unsigned int)41;

  else
  {
    unsigned int return_value_isc_time_nanoseconds$2;
    return_value_isc_time_nanoseconds$2=isc_time_nanoseconds(itime);
    times[(signed long int)1].tv_usec = (signed long int)(signed int)(return_value_isc_time_nanoseconds$2 / (unsigned int)1000);
    times[(signed long int)0].tv_usec = times[(signed long int)1].tv_usec;
    signed int return_value_utimes$5;
    return_value_utimes$5=utimes(file, times);
    if(!(return_value_utimes$5 >= 0))
    {
      return_value___errno_location$3=__errno_location();
      return_value_isc___errno2result$4=isc___errno2result(*return_value___errno_location$3, "./../lib/isc/unix/file.c", (unsigned int)156);
      return return_value_isc___errno2result$4;
    }

    else
      return (unsigned int)0;
  }
}

// isc_file_splitpath
// file ./../lib/isc/unix/file.c line 511
unsigned int isc_file_splitpath(struct isc_mem *mctx, char *path, char **dirnam, char **basenam)
{
  char *dir;
  char *file;
  char *slash;
  if(!(path == ((char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 515, (enum anonymous$46)isc_assertiontype_require, "path != ((void *)0)");
    (_Bool)0;
  }
  slash=strrchr(path, 47);
  if(slash == path)
  {
    slash = slash + 1l;
    file = slash;
    (void)mctx;
    char *return_value_estrdup_impl$1;
    return_value_estrdup_impl$1=estrdup_impl("/");
    dir = return_value_estrdup_impl$1;
  }

  else
    if(!(slash == ((char *)NULL)))
    {
      slash = slash + 1l;
      file = slash;
      (void)mctx;
      void *return_value_ereallocz$2;
      return_value_ereallocz$2=ereallocz((void *)0, (unsigned long int)(slash - path), (unsigned long int)0, 0);
      dir = (char *)return_value_ereallocz$2;
      if(!(dir == ((char *)NULL)))
        strlcpy(dir, path, (unsigned long int)(slash - path));

    }

    else
    {
      file = path;
      (void)mctx;
      char *return_value_estrdup_impl$3;
      return_value_estrdup_impl$3=estrdup_impl(".");
      dir = return_value_estrdup_impl$3;
    }
  if(dir == ((char *)NULL))
    return (unsigned int)1;

  else
    if((signed int)*file == 0)
    {
      (void)mctx;
      free((void *)dir);
      return (unsigned int)30;
    }

    else
    {
      *dirnam = dir;
      *basenam = file;
      return (unsigned int)0;
    }
}

// isc_file_template
// file ./../lib/isc/unix/file.c line 170
unsigned int isc_file_template(const char *path, const char *templet, char *buf, unsigned long int buflen)
{
  char *s;
  if(!(path == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 174, (enum anonymous$46)isc_assertiontype_require, "path != ((void *)0)");
    (_Bool)0;
  }
  if(!(templet == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 175, (enum anonymous$46)isc_assertiontype_require, "templet != ((void *)0)");
    (_Bool)0;
  }
  if(!(buf == ((char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/file.c", 176, (enum anonymous$46)isc_assertiontype_require, "buf != ((void *)0)");
    (_Bool)0;
  }
  s=strrchr(templet, 47);
  if(!(s == ((char *)NULL)))
    templet = s + (signed long int)1;

  s=strrchr(path, 47);
  if(!(s == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(templet);
    if(!(buflen >= 2ul + return_value_strlen$1 + (unsigned long int)(s - path)))
      return (unsigned int)19;

    strlcpy(buf, path, buflen);
    buf[(s - path) + (signed long int)1] = (char)0;
    strlcat(buf, templet, buflen);
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(templet);
    if(!(buflen >= 1ul + return_value_strlen$2))
      return (unsigned int)19;

    strlcpy(buf, templet, buflen);
  }
  return (unsigned int)0;
}

// isc_file_truncate
// file ./../lib/isc/unix/file.c line 466
unsigned int isc_file_truncate(const char *filename, signed long int size)
{
  unsigned int result = (unsigned int)0;
  signed int return_value_truncate$2;
  return_value_truncate$2=truncate(filename, size);
  signed int *return_value___errno_location$1;
  if(!(return_value_truncate$2 >= 0))
  {
    return_value___errno_location$1=__errno_location();
    result=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/file.c", (unsigned int)470);
  }

  return result;
}

// isc_interfaceiter_create
// file ./../lib/isc/unix/ifiter_getifaddrs.c line 54
unsigned int isc_interfaceiter_create(struct isc_mem *mctx, struct isc_interfaceiter **iterp)
{
  struct isc_interfaceiter *iter;
  unsigned int result;
  char strbuf[128l];
  signed int trys;
  signed int ret;
  if(!(mctx == ((struct isc_mem *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/ifiter_getifaddrs.c", 60, (enum anonymous$46)isc_assertiontype_require, "mctx != ((void *)0)");
    (_Bool)0;
  }
  if(!(iterp == ((struct isc_interfaceiter **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/ifiter_getifaddrs.c", 61, (enum anonymous$46)isc_assertiontype_require, "iterp != ((void *)0)");
    (_Bool)0;
  }
  if(*iterp == ((struct isc_interfaceiter *)NULL))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/ifiter_getifaddrs.c", 62, (enum anonymous$46)isc_assertiontype_require, "*iterp == ((void *)0)");
    (_Bool)0;
  }
  (void)mctx;
  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, sizeof(struct isc_interfaceiter) /*272ul*/ , (unsigned long int)0, 0);
  iter = (struct isc_interfaceiter *)return_value_ereallocz$1;
  if(iter == ((struct isc_interfaceiter *)NULL))
    return (unsigned int)1;

  else
  {
    iter->mctx = mctx;
    iter->buf = (void *)0;
    iter->bufsize = (unsigned int)0;
    iter->ifaddrs = (struct ifaddrs *)(void *)0;
    if(seenv6 == /*enum*/isc_boolean_false)
    {
      iter->proc=fopen("/proc/net/if_inet6", "r");
      if(iter->proc == ((struct _IO_FILE *)NULL))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        isc__strerror(*return_value___errno_location$2, strbuf, sizeof(char [128l]) /*128ul*/ );
        isc_log_write(isc_lctx, &isc_categories[(signed long int)1], &isc_modules[(signed long int)0], -3, "failed to open /proc/net/if_inet6");
      }

    }

    else
      iter->proc = (struct _IO_FILE *)(void *)0;
    iter->valid = (unsigned int)25;
    trys = 0;
    for( ; !(trys >= 3); trys = trys + 1)
    {
      ret=getifaddrs(&iter->ifaddrs);
      if(ret >= 0)
        break;

      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(!(*return_value___errno_location$3 == 4))
        break;

    }
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      isc__strerror(*return_value___errno_location$4, strbuf, sizeof(char [128l]) /*128ul*/ );
      const char *return_value_isc_msgcat_get$5;
      return_value_isc_msgcat_get$5=isc_msgcat_get(isc_msgcat, 21, 1801, "getifaddrs");
      isc_error_unexpected("./../lib/isc/unix/ifiter_getifaddrs.c", 99, "getting interface addresses: %s: %s", return_value_isc_msgcat_get$5, (const void *)strbuf);
      result = (unsigned int)34;
      goto failure;
    }

    iter->pos = (struct ifaddrs *)(void *)0;
    iter->result = (unsigned int)25;
    iter->magic = (unsigned int)(73 << 24 | 70 << 16 | 73 << 8 | 71);
    *iterp = iter;
    return (unsigned int)0;

  failure:
    ;
    if(!(iter->proc == ((struct _IO_FILE *)NULL)))
      fclose(iter->proc);

    if(!(iter->ifaddrs == ((struct ifaddrs *)NULL)))
      freeifaddrs(iter->ifaddrs);

    (void)mctx;
    free((void *)iter);
    return result;
  }
}

// isc_interfaceiter_current
// file ./../lib/isc/unix/interfaceiter.c line 266
unsigned int isc_interfaceiter_current(struct isc_interfaceiter *iter, struct isc_interface *ifdata)
{
  if(iter->result == 0u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/interfaceiter.c", 269, (enum anonymous$46)isc_assertiontype_require, "iter->result == 0");
    (_Bool)0;
  }
  memcpy((void *)ifdata, (const void *)&iter->current, sizeof(struct isc_interface) /*140ul*/ );
  return (unsigned int)0;
}

// isc_interfaceiter_destroy
// file ./../lib/isc/unix/interfaceiter.c line 313
void isc_interfaceiter_destroy(struct isc_interfaceiter **iterp)
{
  struct isc_interfaceiter *iter;
  if(!(iterp == ((struct isc_interfaceiter **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/interfaceiter.c", 316, (enum anonymous$46)isc_assertiontype_require, "iterp != ((void *)0)");
    (_Bool)0;
  }
  iter = *iterp;
  _Bool tmp_if_expr$1;
  if(!(iter == ((struct isc_interfaceiter *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)iter)->magic == (unsigned int)(73 << 24 | 70 << 16 | 73 << 8 | 71) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/interfaceiter.c", 318, (enum anonymous$46)isc_assertiontype_require, "(((iter) != ((void *)0)) && (((const isc__magic_t *)(iter))->magic == ((('I') << 24 | ('F') << 16 | ('I') << 8 | ('G')))))");
    (_Bool)0;
  }
  internal_destroy(iter);
  if(!(iter->buf == NULL))
  {
    (void)iter->bufsize;
    (void)iter->mctx;
    free(iter->buf);
  }

  iter->magic = (unsigned int)0;
  (void)iter->mctx;
  free((void *)iter);
  *iterp = (struct isc_interfaceiter *)(void *)0;
}

// isc_interfaceiter_first
// file ./../lib/isc/unix/interfaceiter.c line 275
unsigned int isc_interfaceiter_first(struct isc_interfaceiter *iter)
{
  unsigned int result;
  _Bool tmp_if_expr$1;
  if(!(iter == ((struct isc_interfaceiter *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)iter)->magic == (unsigned int)(73 << 24 | 70 << 16 | 73 << 8 | 71) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/interfaceiter.c", 278, (enum anonymous$46)isc_assertiontype_require, "(((iter) != ((void *)0)) && (((const isc__magic_t *)(iter))->magic == ((('I') << 24 | ('F') << 16 | ('I') << 8 | ('G')))))");
    (_Bool)0;
  }
  internal_first(iter);
  do
  {
    result=internal_current(iter);
    if(!(result == 36u))
      break;

    result=internal_next(iter);
    if(!(result == 0u))
      break;

  }
  while((_Bool)1);
  iter->result = result;
  return result;
}

// isc_interfaceiter_next
// file ./../lib/isc/unix/interfaceiter.c line 294
unsigned int isc_interfaceiter_next(struct isc_interfaceiter *iter)
{
  unsigned int result;
  _Bool tmp_if_expr$1;
  if(!(iter == ((struct isc_interfaceiter *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)iter)->magic == (unsigned int)(73 << 24 | 70 << 16 | 73 << 8 | 71) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/interfaceiter.c", 297, (enum anonymous$46)isc_assertiontype_require, "(((iter) != ((void *)0)) && (((const isc__magic_t *)(iter))->magic == ((('I') << 24 | ('F') << 16 | ('I') << 8 | ('G')))))");
    (_Bool)0;
  }
  if(iter->result == 0u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/interfaceiter.c", 298, (enum anonymous$46)isc_assertiontype_require, "iter->result == 0");
    (_Bool)0;
  }
  do
  {
    result=internal_next(iter);
    if(!(result == 0u))
      break;

    result=internal_current(iter);
    if(!(result == 36u))
      break;

  }
  while((_Bool)1);
  iter->result = result;
  return result;
}

// isc_interval_iszero
// file ./../lib/isc/unix/time.c line 98
enum anonymous$11 isc_interval_iszero(const struct isc_interval *i)
{
  if(!(i == ((const struct isc_interval *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 99, (enum anonymous$46)isc_assertiontype_require, "i != ((void *)0)");
    (_Bool)0;
  }
  if(!(i->nanoseconds >= 1000000000u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 100, (enum anonymous$46)isc_assertiontype_insist, "i->nanoseconds < 1000000000");
    (_Bool)0;
  }
  if(i->seconds == 0u)
  {
    if(!(i->nanoseconds == 0u))
      goto __CPROVER_DUMP_L7;

    return (enum anonymous$11)isc_boolean_true;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    return (enum anonymous$11)isc_boolean_false;
  }
}

// isc_interval_set
// file ../lib/isc/unix/include/isc/time.h line 49
void isc_interval_set(struct isc_interval *i, unsigned int seconds, unsigned int nanoseconds)
{
  if(!(i == ((struct isc_interval *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 90, (enum anonymous$46)isc_assertiontype_require, "i != ((void *)0)");
    (_Bool)0;
  }
  if(!(nanoseconds >= 1000000000u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 91, (enum anonymous$46)isc_assertiontype_require, "nanoseconds < 1000000000");
    (_Bool)0;
  }
  i->seconds = seconds;
  i->nanoseconds = nanoseconds;
}

// isc_lib_initmsgcat
// file ./../lib/isc/lib.c line 60
void isc_lib_initmsgcat(void)
{
  unsigned int result;
  signed int return_value_pthread_once$1;
  return_value_pthread_once$1=pthread_once(&msgcat_once, open_msgcat);
  result = (unsigned int)(return_value_pthread_once$1 == 0 ? 0 : 34);
  if(!(result == 0u))
  {
    const char *return_value_isc_msgcat_get$2;
    return_value_isc_msgcat_get$2=isc_msgcat_get(isc_msgcat, 1, 110, "fatal error");
    const char *return_value_isc_msgcat_get$3;
    return_value_isc_msgcat_get$3=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
    fprintf(stderr, "%s:%d: %s: isc_once_do() %s.\n", (const void *)"./../lib/isc/lib.c", 77, return_value_isc_msgcat_get$2, return_value_isc_msgcat_get$3);
    abort();
  }

}

// isc_log_categorybyname
// file ./../lib/isc/log.c line 613
struct isc_logcategory * isc_log_categorybyname(struct isc_log *lctx, const char *name)
{
  struct isc_logcategory *catp;
  _Bool tmp_if_expr$1;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 616, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  if(!(name == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 617, (enum anonymous$46)isc_assertiontype_require, "name != ((void *)0)");
    (_Bool)0;
  }
  catp = lctx->categories;
  while(!(catp->name == ((const char *)NULL)))
    if(catp->id == 1U)
      do
      {
        /* tag-#anon#lUN[l*{clV}$clV$'k'||l*{lV}$lV$'v'|] */
union anonymous$9
{
  // k
  const void *k;
  // v
  void *v;
};

/* */
        ;
        union anonymous$9 _u;
        _u.k = (const void *)catp->name;
        catp = (struct isc_logcategory *)_u.v;
      }
      while((_Bool)0);

    else
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(catp->name, name);
      if(return_value_strcmp$2 == 0)
        return catp;

      catp = catp + 1l;
    }
  return (struct isc_logcategory *)(void *)0;
}

// isc_log_closefilelogs
// file ./../lib/isc/log.c line 1033
void isc_log_closefilelogs(struct isc_log *lctx)
{
  struct isc_logchannel *channel;
  _Bool tmp_if_expr$1;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1036, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&lctx->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/log.c", 1038, "((pthread_mutex_lock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  channel = lctx->logconfig->channels.head;
  for( ; !(channel == ((struct isc_logchannel *)NULL)); channel = channel->link.next)
    if(channel->type == 3u)
    {
      if(!(channel->destination.file.stream == ((struct _IO_FILE *)NULL)))
      {
        fclose(channel->destination.file.stream);
        channel->destination.file.stream = (struct _IO_FILE *)(void *)0;
      }

    }

  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&lctx->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/log.c", 1048, "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// isc_log_create
// file ./../lib/isc/log.c line 268
unsigned int isc_log_create(struct isc_mem *mctx, struct isc_log **lctxp, struct isc_logconfig **lcfgp)
{
  struct isc_log *lctx;
  struct isc_logconfig *lcfg = (struct isc_logconfig *)(void *)0;
  unsigned int result;
  if(!(mctx == ((struct isc_mem *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 273, (enum anonymous$46)isc_assertiontype_require, "mctx != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(lctxp == ((struct isc_log **)NULL)))
    tmp_if_expr$1 = *lctxp == (struct isc_log *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 274, (enum anonymous$46)isc_assertiontype_require, "lctxp != ((void *)0) && *lctxp == ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(lcfgp == ((struct isc_logconfig **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = *lcfgp == (struct isc_logconfig *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 275, (enum anonymous$46)isc_assertiontype_require, "lcfgp == ((void *)0) || *lcfgp == ((void *)0)");
    (_Bool)0;
  }
  (void)mctx;
  void *return_value_ereallocz$3;
  return_value_ereallocz$3=ereallocz((void *)0, sizeof(struct isc_log) /*8304ul*/ , (unsigned long int)0, 0);
  lctx = (struct isc_log *)return_value_ereallocz$3;
  if(!(lctx == ((struct isc_log *)NULL)))
  {
    lctx->mctx = mctx;
    lctx->categories = (struct isc_logcategory *)(void *)0;
    lctx->category_count = (unsigned int)0;
    lctx->modules = (struct isc_logmodule *)(void *)0;
    lctx->module_count = (unsigned int)0;
    lctx->debug_level = 0;
    do
    {
      lctx->messages.head = (struct isc_logmessage *)(void *)0;
      lctx->messages.tail = (struct isc_logmessage *)(void *)0;
    }
    while((_Bool)0);
    result=isc__mutex_init(&lctx->lock, "./../lib/isc/log.c", (unsigned int)288);
    if(!(result == 0u))
    {
      (void)mctx;
      free((void *)lctx);
      return result;
    }

    lctx->magic = (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120);
    isc_log_registercategories(lctx, isc_categories);
    isc_log_registermodules(lctx, isc_modules);
    result=isc_logconfig_create(lctx, &lcfg);
  }

  else
    result = (unsigned int)1;
  if(result == 0u)
    result=sync_channellist(lcfg);

  if(result == 0u)
  {
    lctx->logconfig = lcfg;
    *lctxp = lctx;
    if(!(lcfgp == ((struct isc_logconfig **)NULL)))
      *lcfgp = lcfg;

  }

  else
  {
    if(!(lcfg == ((struct isc_logconfig *)NULL)))
      isc_logconfig_destroy(&lcfg);

    if(!(lctx == ((struct isc_log *)NULL)))
      isc_log_destroy(&lctx);

  }
  return result;
}

// isc_log_createchannel
// file ./../lib/isc/log.c line 703
unsigned int isc_log_createchannel(struct isc_logconfig *lcfg, const char *name, unsigned int type, signed int level, const union isc_logdestination *destination, unsigned int flags)
{
  struct isc_logchannel *channel;
  struct isc_mem *mctx;
  _Bool tmp_if_expr$1;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lcfg)->magic == (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 711, (enum anonymous$46)isc_assertiontype_require, "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
    (_Bool)0;
  }
  if(!(name == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 712, (enum anonymous$46)isc_assertiontype_require, "name != ((void *)0)");
    (_Bool)0;
  }
  if(type == 1u || type == 2u || type == 3u || type == 4u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 714, (enum anonymous$46)isc_assertiontype_require, "type == 2 || type == 3 || type == 4 || type == 1");
    (_Bool)0;
  }
  if(type == 1u || !(destination == ((const union isc_logdestination *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 715, (enum anonymous$46)isc_assertiontype_require, "destination != ((void *)0) || type == 1");
    (_Bool)0;
  }
  if(level >= -5)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 716, (enum anonymous$46)isc_assertiontype_require, "level >= (-5)");
    (_Bool)0;
  }
  if((4294963168u & flags) == 0u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 718, (enum anonymous$46)isc_assertiontype_require, "(flags & (unsigned int)~(0x001F | 0x1000)) == 0");
    (_Bool)0;
  }
  mctx = lcfg->lctx->mctx;
  (void)mctx;
  void *return_value_ereallocz$2;
  return_value_ereallocz$2=ereallocz((void *)0, sizeof(struct isc_logchannel) /*80ul*/ , (unsigned long int)0, 0);
  channel = (struct isc_logchannel *)return_value_ereallocz$2;
  char *return_value_estrdup_impl$4;
  unsigned long int return_value_strlen$5;
  if(channel == ((struct isc_logchannel *)NULL))
    return (unsigned int)1;

  else
  {
    (void)mctx;
    char *return_value_estrdup_impl$3;
    return_value_estrdup_impl$3=estrdup_impl(name);
    channel->name = return_value_estrdup_impl$3;
    if(channel->name == ((char *)NULL))
    {
      (void)mctx;
      free((void *)channel);
      return (unsigned int)1;
    }

    else
    {
      channel->type = type;
      channel->level = level;
      channel->flags = flags;
      do
      {
        channel->link.prev = (struct isc_logchannel *)(void *)-1;
        channel->link.next = (struct isc_logchannel *)(void *)-1;
      }
      while((_Bool)0);
      switch(type)
      {
        case (unsigned int)2:
        {
          channel->destination.facility = destination->facility;
          break;
        }
        case (unsigned int)3:
        {
          (void)mctx;
          return_value_estrdup_impl$4=estrdup_impl(destination->file.name);
          channel->destination.file.name = return_value_estrdup_impl$4;
          channel->destination.file.stream = (struct _IO_FILE *)(void *)0;
          channel->destination.file.versions = destination->file.versions;
          channel->destination.file.maximum_size = destination->file.maximum_size;
          channel->destination.file.maximum_reached = (enum anonymous$11)isc_boolean_false;
          break;
        }
        case (unsigned int)4:
        {
          channel->destination.file.name = (const char *)(void *)0;
          channel->destination.file.stream = destination->file.stream;
          channel->destination.file.maximum_size = (signed long int)0;
          channel->destination.file.versions = -2;
          break;
        }
        case (unsigned int)1:
          break;
        default:
        {
          return_value_strlen$5=strlen(channel->name);
          (void)(return_value_strlen$5 + (unsigned long int)1);
          (void)mctx;
          free((void *)channel->name);
          (void)mctx;
          free((void *)channel);
          return (unsigned int)34;
        }
      }

    __CPROVER_DUMP_L29:
      ;
      do
      {
        if(!(lcfg->channels.head == ((struct isc_logchannel *)NULL)))
          lcfg->channels.head->link.prev = channel;

        else
          lcfg->channels.tail = channel;
        channel->link.prev = (struct isc_logchannel *)(void *)0;
        channel->link.next = lcfg->channels.head;
        lcfg->channels.head = channel;
      }
      while((_Bool)0);
      signed int return_value_strcmp$6;
      return_value_strcmp$6=strcmp(name, "default_stderr");
      if(return_value_strcmp$6 == 0)
        default_channel.channel = channel;

      return (unsigned int)0;
    }
  }
}

// isc_log_destroy
// file ./../lib/isc/log.c line 462
void isc_log_destroy(struct isc_log **lctxp)
{
  struct isc_log *lctx;
  struct isc_logconfig *lcfg;
  struct isc_mem *mctx;
  struct isc_logmessage *message;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(lctxp == ((struct isc_log **)NULL)))
  {
    if(!(*lctxp == ((struct isc_log *)NULL)))
      tmp_if_expr$1 = ((const struct anonymous$21 *)*lctxp)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 468, (enum anonymous$46)isc_assertiontype_require, "lctxp != ((void *)0) && (((*lctxp) != ((void *)0)) && (((const isc__magic_t *)(*lctxp))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  lctx = *lctxp;
  mctx = lctx->mctx;
  if(!(lctx->logconfig == ((struct isc_logconfig *)NULL)))
  {
    lcfg = lctx->logconfig;
    lctx->logconfig = (struct isc_logconfig *)(void *)0;
    isc_logconfig_destroy(&lcfg);
  }

  signed int return_value_pthread_mutex_destroy$3;
  return_value_pthread_mutex_destroy$3=pthread_mutex_destroy(&lctx->lock);
  if(return_value_pthread_mutex_destroy$3 == 0)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/log.c", 479, "((pthread_mutex_destroy(((&lctx->lock))) == 0) ? 0 : 34) == 0");
    (_Bool)0;
  }
  do
  {
    message = lctx->messages.head;
    if(message == ((struct isc_logmessage *)NULL))
      break;


  __CPROVER_DUMP_L12:
    ;
    do
    {
      if(!(message->link.next == ((struct isc_logmessage *)NULL)))
        message->link.next->link.prev = message->link.prev;

      else
      {
        if(lctx->messages.tail == message)
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/log.c", 482, (enum anonymous$46)isc_assertiontype_insist, "(lctx->messages).tail == (message)");
          (_Bool)0;
        }
        lctx->messages.tail = message->link.prev;
      }
      if(!(message->link.prev == ((struct isc_logmessage *)NULL)))
        message->link.prev->link.next = message->link.next;

      else
      {
        if(lctx->messages.head == message)
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/log.c", 482, (enum anonymous$46)isc_assertiontype_insist, "(lctx->messages).head == (message)");
          (_Bool)0;
        }
        lctx->messages.head = message->link.next;
      }
      message->link.prev = (struct isc_logmessage *)(void *)-1;
      message->link.next = (struct isc_logmessage *)(void *)-1;
    }
    while((_Bool)0);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(message->text);
    (void)(sizeof(struct isc_logmessage) /*32ul*/  + return_value_strlen$4 + (unsigned long int)1);
    (void)mctx;
    free((void *)message);
  }
  while((_Bool)1);
  lctx->buffer[(signed long int)0] = (char)0;
  lctx->debug_level = 0;
  lctx->categories = (struct isc_logcategory *)(void *)0;
  lctx->category_count = (unsigned int)0;
  lctx->modules = (struct isc_logmodule *)(void *)0;
  lctx->module_count = (unsigned int)0;
  lctx->mctx = (struct isc_mem *)(void *)0;
  lctx->magic = (unsigned int)0;
  (void)mctx;
  free((void *)lctx);
  *lctxp = (struct isc_log *)(void *)0;
}

// isc_log_doit
// file ./../lib/isc/log.c line 1405
static void isc_log_doit(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, enum anonymous$11 write_once, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, void **args)
{
  signed int syslog_level;
  char time_string[64l];
  char level_string[24l];
  unsigned long int octets;
  const char *iformat;
  struct stat statbuf;
  enum anonymous$11 matched = (enum anonymous$11)isc_boolean_false;
  enum anonymous$11 printtime;
  enum anonymous$11 printtag;
  enum anonymous$11 printcategory;
  enum anonymous$11 printmodule;
  enum anonymous$11 printlevel;
  struct isc_logconfig *lcfg;
  struct isc_logchannel *channel;
  struct isc_logchannellist *category_channels;
  unsigned int result;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(lctx == ((struct isc_log *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(!(lctx == ((struct isc_log *)NULL)))
      tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1424, (enum anonymous$46)isc_assertiontype_require, "lctx == ((void *)0) || (((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  if(!(category == ((struct isc_logcategory *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1425, (enum anonymous$46)isc_assertiontype_require, "category != ((void *)0)");
    (_Bool)0;
  }
  if(!(module == ((struct isc_logmodule *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1426, (enum anonymous$46)isc_assertiontype_require, "module != ((void *)0)");
    (_Bool)0;
  }
  if(!(level == 0))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1427, (enum anonymous$46)isc_assertiontype_require, "level != 0");
    (_Bool)0;
  }
  if(!(format == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1428, (enum anonymous$46)isc_assertiontype_require, "format != ((void *)0)");
    (_Bool)0;
  }
  const char *return_value_isc_msgcat_get$6;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$20;
  signed int return_value_stat$17;
  _Bool tmp_if_expr$19;
  signed int *return_value___errno_location$18;
  _Bool tmp_if_expr$21;
  char *tmp_if_expr$23;
  char *tmp_if_expr$24;
  const char *tmp_if_expr$25;
  const char *tmp_if_expr$27;
  const char *tmp_if_expr$26;
  char *tmp_if_expr$28;
  char *tmp_if_expr$31;
  char *tmp_if_expr$32;
  const char *tmp_if_expr$33;
  const char *tmp_if_expr$35;
  const char *tmp_if_expr$34;
  char *tmp_if_expr$36;
  if(!(lctx == ((struct isc_log *)NULL)))
  {
    if(!(category->id >= lctx->category_count))
      (_Bool)1;

    else
    {
      isc_assertion_failed("./../lib/isc/log.c", 1438, (enum anonymous$46)isc_assertiontype_require, "category->id < lctx->category_count");
      (_Bool)0;
    }
    if(!(module->id >= lctx->module_count))
      (_Bool)1;

    else
    {
      isc_assertion_failed("./../lib/isc/log.c", 1439, (enum anonymous$46)isc_assertiontype_require, "module->id < lctx->module_count");
      (_Bool)0;
    }
    enum anonymous$11 return_value_isc_log_wouldlog$3;
    return_value_isc_log_wouldlog$3=isc_log_wouldlog(lctx, level);
    if(!(return_value_isc_log_wouldlog$3 == /*enum*/isc_boolean_false))
    {
      if(!(msgcat == ((struct isc_msgcat *)NULL)))
        iformat=isc_msgcat_get(msgcat, msgset, msg, format);

      else
        iformat = format;
      time_string[(signed long int)0] = (char)0;
      level_string[(signed long int)0] = (char)0;
      do
      {
        signed int return_value_pthread_mutex_lock$4;
        return_value_pthread_mutex_lock$4=pthread_mutex_lock(&lctx->lock);
        if(return_value_pthread_mutex_lock$4 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/log.c", 1452, "((pthread_mutex_lock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
      lctx->buffer[(signed long int)0] = (char)0;
      lcfg = lctx->logconfig;
      category_channels = (lcfg->channellists + (signed long int)category->id)->head;
      while(!(category_channels == ((struct isc_logchannellist *)NULL)) || matched == /*enum*/isc_boolean_false)
      {
        if(matched == /*enum*/isc_boolean_false && category_channels == ((struct isc_logchannellist *)NULL))
        {
          if(!(category_channels == lcfg->channellists->head))
            category_channels = (lcfg->channellists + (signed long int)0)->head;

        }

        if(matched == /*enum*/isc_boolean_false && category_channels == ((struct isc_logchannellist *)NULL))
          category_channels = &default_channel;

        if(!(category_channels->module == ((const struct isc_logmodule *)NULL)))
        {
          if(category_channels->module == module)
            goto __CPROVER_DUMP_L37;

          category_channels = category_channels->link.next;
        }

        else
        {

        __CPROVER_DUMP_L37:
          ;
          matched = (enum anonymous$11)isc_boolean_true;
          channel = category_channels->channel;
          category_channels = category_channels->link.next;
          if(!((4096u & channel->flags) == 0u))
          {
            if(lctx->debug_level == 0)
              continue;

          }

          if(channel->level == 0)
          {
            if(!(lctx->debug_level >= level))
              continue;

          }

          else
            if(!(channel->level >= level))
              continue;

          if(!((1u & channel->flags) == 0u))
          {
            if((signed int)time_string[0l] == 0)
            {
              struct isc_time isctime;
              unsigned int return_value_isc_time_now$5;
              return_value_isc_time_now$5=isc_time_now(&isctime);
              if(return_value_isc_time_now$5 == 0u)
                (_Bool)1;

              else
              {
                isc_error_runtimecheck("./../lib/isc/log.c", 1515, "isc_time_now((&isctime)) == 0");
                (_Bool)0;
              }
              isc_time_formattimestamp(&isctime, time_string, (unsigned int)sizeof(char [64l]) /*64ul*/ );
            }

          }

          if(!((2u & channel->flags) == 0u))
          {
            if((signed int)level_string[0l] == 0)
            {
              if(!(level >= -5))
              {
                return_value_isc_msgcat_get$6=isc_msgcat_get(isc_msgcat, 10, 802, "level");
                snprintf(level_string, sizeof(char [24l]) /*24ul*/ , "%s %d: ", return_value_isc_msgcat_get$6, level);
              }

              else
                if(level >= 1)
                  snprintf(level_string, sizeof(char [24l]) /*24ul*/ , "%s %d: ", log_level_strings[(signed long int)0], level);

                else
                  snprintf(level_string, sizeof(char [24l]) /*24ul*/ , "%s: ", log_level_strings[(signed long int)-level]);
            }

          }

          if((signed int)lctx->buffer[0l] == 0)
          {
            vsnprintf(lctx->buffer, sizeof(char [8192l]) /*8192ul*/ , iformat, args);
            if(!(write_once == /*enum*/isc_boolean_false))
            {
              struct isc_logmessage *message;
              struct isc_logmessage *new;
              struct isc_time oldest;
              struct isc_interval interval;
              isc_interval_set(&interval, lcfg->duplicate_interval, (unsigned int)0);
              unsigned int return_value_isc_time_now$7;
              return_value_isc_time_now$7=isc_time_now(&oldest);
              if(return_value_isc_time_now$7 == 0u)
                (_Bool)1;

              else
              {
                isc_error_runtimecheck("./../lib/isc/log.c", 1562, "isc_time_now((&oldest)) == 0");
                (_Bool)0;
              }
              unsigned int return_value_isc_time_subtract$8;
              return_value_isc_time_subtract$8=isc_time_subtract(&oldest, &interval, &oldest);
              if(!(return_value_isc_time_subtract$8 == 0u))
                message = (struct isc_logmessage *)(void *)0;

              else
                message = lctx->messages.head;
              while(!(message == ((struct isc_logmessage *)NULL)))
              {
                signed int return_value_isc_time_compare$10;
                return_value_isc_time_compare$10=isc_time_compare(&message->time, &oldest);
                if(!(return_value_isc_time_compare$10 >= 0))
                {
                  new = message->link.next;

                __CPROVER_DUMP_L54:
                  ;
                  do
                  {
                    if(!(message->link.next == ((struct isc_logmessage *)NULL)))
                      message->link.next->link.prev = message->link.prev;

                    else
                    {
                      if(lctx->messages.tail == message)
                        (_Bool)1;

                      else
                      {
                        isc_assertion_failed("./../lib/isc/log.c", 1592, (enum anonymous$46)isc_assertiontype_insist, "(lctx->messages).tail == (message)");
                        (_Bool)0;
                      }
                      lctx->messages.tail = message->link.prev;
                    }
                    if(!(message->link.prev == ((struct isc_logmessage *)NULL)))
                      message->link.prev->link.next = message->link.next;

                    else
                    {
                      if(lctx->messages.head == message)
                        (_Bool)1;

                      else
                      {
                        isc_assertion_failed("./../lib/isc/log.c", 1592, (enum anonymous$46)isc_assertiontype_insist, "(lctx->messages).head == (message)");
                        (_Bool)0;
                      }
                      lctx->messages.head = message->link.next;
                    }
                    message->link.prev = (struct isc_logmessage *)(void *)-1;
                    message->link.next = (struct isc_logmessage *)(void *)-1;
                  }
                  while((_Bool)0);
                  unsigned long int return_value_strlen$9;
                  return_value_strlen$9=strlen(message->text);
                  (void)(sizeof(struct isc_logmessage) /*32ul*/  + (unsigned long int)1 + return_value_strlen$9);
                  (void)lctx->mctx;
                  free((void *)message);
                  message = new;
                  continue;
                }

                signed int return_value_strcmp$12;
                return_value_strcmp$12=strcmp(lctx->buffer, message->text);
                if(return_value_strcmp$12 == 0)
                {
                  do
                  {
                    signed int return_value_pthread_mutex_unlock$11;
                    return_value_pthread_mutex_unlock$11=pthread_mutex_unlock(&lctx->lock);
                    if(return_value_pthread_mutex_unlock$11 == 0)
                      (_Bool)1;

                    else
                    {
                      isc_error_runtimecheck("./../lib/isc/log.c", 1614, "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
                      (_Bool)0;
                    }
                  }
                  while((_Bool)0);
                  goto __CPROVER_DUMP_L132;
                }

                message = message->link.next;
              }
              unsigned long int return_value_strlen$13;
              return_value_strlen$13=strlen(lctx->buffer);
              octets = return_value_strlen$13 + (unsigned long int)1;
              (void)lctx->mctx;
              void *return_value_ereallocz$14;
              return_value_ereallocz$14=ereallocz((void *)0, sizeof(struct isc_logmessage) /*32ul*/  + octets, (unsigned long int)0, 0);
              new = (struct isc_logmessage *)return_value_ereallocz$14;
              if(!(new == ((struct isc_logmessage *)NULL)))
              {
                new->text = (char *)(new + (signed long int)1);
                strlcpy(new->text, lctx->buffer, octets);
                unsigned int return_value_isc_time_now$15;
                return_value_isc_time_now$15=isc_time_now(&new->time);
                if(return_value_isc_time_now$15 == 0u)
                  (_Bool)1;

                else
                {
                  isc_error_runtimecheck("./../lib/isc/log.c", 1637, "isc_time_now((&new->time)) == 0");
                  (_Bool)0;
                }

              __CPROVER_DUMP_L75:
                ;
                do
                {
                  if(!(lctx->messages.tail == ((struct isc_logmessage *)NULL)))
                    lctx->messages.tail->link.next = new;

                  else
                    lctx->messages.head = new;
                  new->link.prev = lctx->messages.tail;
                  new->link.next = (struct isc_logmessage *)(void *)0;
                  lctx->messages.tail = new;
                }
                while((_Bool)0);
              }

            }

          }

          printtime = (enum anonymous$11)((channel->flags & (unsigned int)0x0001) != (unsigned int)0 ? isc_boolean_true : isc_boolean_false);
          if(!((16u & channel->flags) == 0u))
            tmp_if_expr$16 = lcfg->tag != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$16 = (_Bool)0;
          printtag = (enum anonymous$11)(tmp_if_expr$16 ? isc_boolean_true : isc_boolean_false);
          printcategory = (enum anonymous$11)((channel->flags & (unsigned int)0x0004) != (unsigned int)0 ? isc_boolean_true : isc_boolean_false);
          printmodule = (enum anonymous$11)((channel->flags & (unsigned int)0x0008) != (unsigned int)0 ? isc_boolean_true : isc_boolean_false);
          printlevel = (enum anonymous$11)((channel->flags & (unsigned int)0x0002) != (unsigned int)0 ? isc_boolean_true : isc_boolean_false);
          switch(channel->type)
          {
            case (unsigned int)3:
            {
              if(!(channel->destination.file.maximum_reached == /*enum*/isc_boolean_false))
              {
                if(!(channel->destination.file.versions == -2))
                  tmp_if_expr$20 = (_Bool)1;

                else
                {
                  return_value_stat$17=stat(channel->destination.file.name, &statbuf);
                  if(!(return_value_stat$17 == 0))
                  {
                    return_value___errno_location$18=__errno_location();
                    tmp_if_expr$19 = *return_value___errno_location$18 == 2 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr$19 = (_Bool)0;
                  tmp_if_expr$20 = tmp_if_expr$19 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$20)
                  tmp_if_expr$21 = (_Bool)1;

                else
                  tmp_if_expr$21 = statbuf.st_size < channel->destination.file.maximum_size ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$21)
                {
                  fclose(channel->destination.file.stream);
                  channel->destination.file.stream = (struct _IO_FILE *)(void *)0;
                  channel->destination.file.maximum_reached = (enum anonymous$11)isc_boolean_false;
                }

                else
                  break;
              }

              if(channel->destination.file.stream == ((struct _IO_FILE *)NULL))
              {
                result=isc_log_open(channel);
                if(!(result == 0u) && !(result == 58u))
                {
                  if((32768u & channel->flags) == 0u)
                  {
                    const char *return_value_isc_result_totext$22;
                    return_value_isc_result_totext$22=isc_result_totext(result);
                    syslog(3, "isc_log_open '%s' failed: %s", channel->destination.file.name, return_value_isc_result_totext$22);
                    channel->flags = channel->flags | (unsigned int)0x8000;
                  }

                }

                if(!(result == 0u))
                  break;

                channel->flags = channel->flags & (unsigned int)~0x8000;
              }

            }
            case (unsigned int)4:
            {
              if(!(printtime == /*enum*/isc_boolean_false))
                tmp_if_expr$23 = time_string;

              else
                tmp_if_expr$23 = "";
              if(!(printtag == /*enum*/isc_boolean_false))
                tmp_if_expr$24 = lcfg->tag;

              else
                tmp_if_expr$24 = "";
              if(!(printcategory == /*enum*/isc_boolean_false))
                tmp_if_expr$25 = category->name;

              else
                tmp_if_expr$25 = "";
              if(!(printmodule == /*enum*/isc_boolean_false))
              {
                if(!(module == ((struct isc_logmodule *)NULL)))
                  tmp_if_expr$26 = module->name;

                else
                  tmp_if_expr$26 = "no_module";
                tmp_if_expr$27 = tmp_if_expr$26;
              }

              else
                tmp_if_expr$27 = "";
              if(!(printlevel == /*enum*/isc_boolean_false))
                tmp_if_expr$28 = level_string;

              else
                tmp_if_expr$28 = "";
              fprintf(channel->destination.file.stream, "%s%s%s%s%s%s%s%s%s%s\n", tmp_if_expr$23, printtime != (enum anonymous$11)0 ? " " : "", tmp_if_expr$24, printtag != (enum anonymous$11)0 ? ": " : "", tmp_if_expr$25, printcategory != (enum anonymous$11)0 ? ": " : "", tmp_if_expr$27, printmodule != (enum anonymous$11)0 ? ": " : "", tmp_if_expr$28, (const void *)lctx->buffer);
              fflush(channel->destination.file.stream);
              if(channel->destination.file.maximum_size >= 1l)
              {
                if(channel->type == 3u)
                  (_Bool)1;

                else
                {
                  isc_assertion_failed("./../lib/isc/log.c", 1723, (enum anonymous$46)isc_assertiontype_insist, "channel->type == 3");
                  (_Bool)0;
                }
                signed int return_value_fileno$29;
                return_value_fileno$29=fileno(channel->destination.file.stream);
                signed int return_value_fstat$30;
                return_value_fstat$30=fstat(return_value_fileno$29, &statbuf);
                if(return_value_fstat$30 >= 0)
                {
                  if(!(channel->destination.file.maximum_size >= statbuf.st_size))
                    channel->destination.file.maximum_reached = (enum anonymous$11)isc_boolean_true;

                }

              }

              break;
            }
            case (unsigned int)2:
            {
              if(level >= 1)
                syslog_level = 7;

              else
                if(!(level >= -5))
                  syslog_level = 2;

                else
                  syslog_level = syslog_map[(signed long int)-level];
              if(!(printtime == /*enum*/isc_boolean_false))
                tmp_if_expr$31 = time_string;

              else
                tmp_if_expr$31 = "";
              if(!(printtag == /*enum*/isc_boolean_false))
                tmp_if_expr$32 = lcfg->tag;

              else
                tmp_if_expr$32 = "";
              if(!(printcategory == /*enum*/isc_boolean_false))
                tmp_if_expr$33 = category->name;

              else
                tmp_if_expr$33 = "";
              if(!(printmodule == /*enum*/isc_boolean_false))
              {
                if(!(module == ((struct isc_logmodule *)NULL)))
                  tmp_if_expr$34 = module->name;

                else
                  tmp_if_expr$34 = "no_module";
                tmp_if_expr$35 = tmp_if_expr$34;
              }

              else
                tmp_if_expr$35 = "";
              if(!(printlevel == /*enum*/isc_boolean_false))
                tmp_if_expr$36 = level_string;

              else
                tmp_if_expr$36 = "";
              syslog(channel->destination.facility | syslog_level, "%s%s%s%s%s%s%s%s%s%s", tmp_if_expr$31, printtime != (enum anonymous$11)0 ? " " : "", tmp_if_expr$32, printtag != (enum anonymous$11)0 ? ": " : "", tmp_if_expr$33, printcategory != (enum anonymous$11)0 ? ": " : "", tmp_if_expr$35, printmodule != (enum anonymous$11)0 ? ": " : "", tmp_if_expr$36, (const void *)lctx->buffer);
            }
            case (unsigned int)1:

            default:
              ;
          }
        }
      }
      do
      {
        signed int return_value_pthread_mutex_unlock$37;
        return_value_pthread_mutex_unlock$37=pthread_mutex_unlock(&lctx->lock);
        if(return_value_pthread_mutex_unlock$37 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/log.c", 1766, "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);
    }

  }


__CPROVER_DUMP_L132:
  ;
}

// isc_log_getdebuglevel
// file ./../lib/isc/log.c line 979
unsigned int isc_log_getdebuglevel(struct isc_log *lctx)
{
  _Bool tmp_if_expr$1;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 980, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  return (unsigned int)lctx->debug_level;
}

// isc_log_getduplicateinterval
// file ./../lib/isc/log.c line 993
unsigned int isc_log_getduplicateinterval(struct isc_logconfig *lcfg)
{
  _Bool tmp_if_expr$1;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lcfg)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 994, (enum anonymous$46)isc_assertiontype_require, "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  return lcfg->duplicate_interval;
}

// isc_log_gettag
// file ./../lib/isc/log.c line 1020
char * isc_log_gettag(struct isc_logconfig *lcfg)
{
  _Bool tmp_if_expr$1;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lcfg)->magic == (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1021, (enum anonymous$46)isc_assertiontype_require, "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
    (_Bool)0;
  }
  return lcfg->tag;
}

// isc_log_ivwrite
// file ./../lib/isc/log.c line 905
void isc_log_ivwrite(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, void **args)
{
  isc_log_doit(lctx, category, module, level, (enum anonymous$11)isc_boolean_false, msgcat, msgset, msg, format, args);
}

// isc_log_ivwrite1
// file ./../lib/isc/log.c line 936
void isc_log_ivwrite1(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, void **args)
{
  isc_log_doit(lctx, category, module, level, (enum anonymous$11)isc_boolean_true, msgcat, msgset, msg, format, args);
}

// isc_log_iwrite
// file ./../lib/isc/log.c line 887
void isc_log_iwrite(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, ...)
{
  void **args = (void **)&format;
  isc_log_doit(lctx, category, module, level, (enum anonymous$11)isc_boolean_false, msgcat, msgset, msg, format, args);
  args = ((void **)NULL);
}

// isc_log_iwrite1
// file ./../lib/isc/log.c line 918
void isc_log_iwrite1(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, struct isc_msgcat *msgcat, signed int msgset, signed int msg, const char *format, ...)
{
  void **args = (void **)&format;
  isc_log_doit(lctx, category, module, level, (enum anonymous$11)isc_boolean_true, msgcat, msgset, msg, format, args);
  args = ((void **)NULL);
}

// isc_log_modulebyname
// file ./../lib/isc/log.c line 680
struct isc_logmodule * isc_log_modulebyname(struct isc_log *lctx, const char *name)
{
  struct isc_logmodule *modp;
  _Bool tmp_if_expr$1;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 683, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  if(!(name == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 684, (enum anonymous$46)isc_assertiontype_require, "name != ((void *)0)");
    (_Bool)0;
  }
  modp = lctx->modules;
  while(!(modp->name == ((const char *)NULL)))
    if(modp->id == 1U)
      do
      {
        /* tag-#anon#lUN[l*{clV}$clV$'k'||l*{lV}$lV$'v'|] */
union anonymous$9
{
  // k
  const void *k;
  // v
  void *v;
};

/* */
        ;
        union anonymous$9 _u;
        _u.k = (const void *)modp->name;
        modp = (struct isc_logmodule *)_u.v;
      }
      while((_Bool)0);

    else
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(modp->name, name);
      if(return_value_strcmp$2 == 0)
        return modp;

      modp = modp + 1l;
    }
  return (struct isc_logmodule *)(void *)0;
}

// isc_log_open
// file ./../lib/isc/log.c line 1319
static unsigned int isc_log_open(struct isc_logchannel *channel)
{
  struct stat statbuf;
  enum anonymous$11 regular_file;
  enum anonymous$11 roll = (enum anonymous$11)isc_boolean_false;
  unsigned int result = (unsigned int)0;
  const char *path;
  if(channel->type == 3u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1326, (enum anonymous$46)isc_assertiontype_require, "channel->type == 3");
    (_Bool)0;
  }
  if(channel->destination.file.stream == ((struct _IO_FILE *)NULL))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1327, (enum anonymous$46)isc_assertiontype_require, "(channel->destination.file.stream) == ((void *)0)");
    (_Bool)0;
  }
  path = channel->destination.file.name;
  _Bool tmp_if_expr$1;
  if(!(path == ((const char *)NULL)))
    tmp_if_expr$1 = (signed int)*path != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1331, (enum anonymous$46)isc_assertiontype_require, "path != ((void *)0) && *path != '\\0'");
    (_Bool)0;
  }
  signed int return_value_stat$6;
  return_value_stat$6=stat(path, &statbuf);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$5;
  if(return_value_stat$6 == 0)
  {
    regular_file = (enum anonymous$11)((statbuf.st_mode & (unsigned int)0170000) == (unsigned int)0100000 ? isc_boolean_true : isc_boolean_false);
    if(channel->destination.file.maximum_size == 0l)
      tmp_if_expr$2 = channel->destination.file.versions != -2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      if(channel->destination.file.maximum_size >= 1l)
        tmp_if_expr$3 = statbuf.st_size >= channel->destination.file.maximum_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      roll = regular_file;

  }

  else
  {
    return_value___errno_location$5=__errno_location();
    if(*return_value___errno_location$5 == 2)
    {
      regular_file = (enum anonymous$11)isc_boolean_true;
      (void)regular_file;
    }

    else
      result = (unsigned int)30;
  }
  if(result == 0u && !(roll == /*enum*/isc_boolean_false))
  {
    if(channel->destination.file.versions == -2)
      return (unsigned int)58;

    result=roll_log(channel);
    if(result == 0u)
      goto __CPROVER_DUMP_L24;

    if((32768u & channel->flags) == 0u)
    {
      const char *return_value_isc_result_totext$7;
      return_value_isc_result_totext$7=isc_result_totext(result);
      syslog(3, "isc_log_open: roll_log '%s' failed: %s", channel->destination.file.name, return_value_isc_result_totext$7);
      channel->flags = channel->flags | (unsigned int)0x8000;
    }

    return result;
  }

  else
  {

  __CPROVER_DUMP_L24:
    ;
    result=isc_stdio_open(path, "a", &channel->destination.file.stream);
    return result;
  }
}

// isc_log_opensyslog
// file ./../lib/isc/log.c line 1028
void isc_log_opensyslog(const char *tag, signed int options, signed int facility)
{
  openlog(tag, options, facility);
}

// isc_log_registercategories
// file ./../lib/isc/log.c line 569
void isc_log_registercategories(struct isc_log *lctx, struct isc_logcategory *categories)
{
  struct isc_logcategory *catp;
  _Bool tmp_if_expr$1;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 572, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(!(categories == ((struct isc_logcategory *)NULL)))
    tmp_if_expr$2 = (categories + (signed long int)0)->name != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 573, (enum anonymous$46)isc_assertiontype_require, "categories != ((void *)0) && categories[0].name != ((void *)0)");
    (_Bool)0;
  }
  if(lctx->categories == ((struct isc_logcategory *)NULL))
    lctx->categories = categories;

  else
  {
    catp = lctx->categories;
    while(!(catp->name == ((const char *)NULL)))
      if(catp->id == 1U)
        do
        {
          /* tag-#anon#lUN[l*{clV}$clV$'k'||l*{lV}$lV$'v'|] */
union anonymous$9
{
  // k
  const void *k;
  // v
  void *v;
};

/* */
          ;
          union anonymous$9 _u;
          _u.k = (const void *)catp->name;
          catp = (struct isc_logcategory *)_u.v;
        }
        while((_Bool)0);

      else
        catp = catp + 1l;
    catp->name = (const char *)(void *)categories;
    catp->id = (unsigned int)0x7fffffff * 2U + 1U;
  }
  catp = categories;
  unsigned int tmp_post$3;
  for( ; !(catp->name == ((const char *)NULL)); catp = catp + 1l)
  {
    tmp_post$3 = lctx->category_count;
    lctx->category_count = lctx->category_count + 1u;
    catp->id = tmp_post$3;
  }
}

// isc_log_registermodules
// file ./../lib/isc/log.c line 636
void isc_log_registermodules(struct isc_log *lctx, struct isc_logmodule *modules)
{
  struct isc_logmodule *modp;
  _Bool tmp_if_expr$1;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 639, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(!(modules == ((struct isc_logmodule *)NULL)))
    tmp_if_expr$2 = (modules + (signed long int)0)->name != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 640, (enum anonymous$46)isc_assertiontype_require, "modules != ((void *)0) && modules[0].name != ((void *)0)");
    (_Bool)0;
  }
  if(lctx->modules == ((struct isc_logmodule *)NULL))
    lctx->modules = modules;

  else
  {
    modp = lctx->modules;
    while(!(modp->name == ((const char *)NULL)))
      if(modp->id == 1U)
        do
        {
          /* tag-#anon#lUN[l*{clV}$clV$'k'||l*{lV}$lV$'v'|] */
union anonymous$9
{
  // k
  const void *k;
  // v
  void *v;
};

/* */
          ;
          union anonymous$9 _u;
          _u.k = (const void *)modp->name;
          modp = (struct isc_logmodule *)_u.v;
        }
        while((_Bool)0);

      else
        modp = modp + 1l;
    modp->name = (const char *)(void *)modules;
    modp->id = (unsigned int)0x7fffffff * 2U + 1U;
  }
  modp = modules;
  unsigned int tmp_post$3;
  for( ; !(modp->name == ((const char *)NULL)); modp = modp + 1l)
  {
    tmp_post$3 = lctx->module_count;
    lctx->module_count = lctx->module_count + 1u;
    modp->id = tmp_post$3;
  }
}

// isc_log_setcontext
// file ./../lib/isc/log.c line 949
void isc_log_setcontext(struct isc_log *lctx)
{
  isc_lctx = lctx;
}

// isc_log_setdebuglevel
// file ./../lib/isc/log.c line 954
void isc_log_setdebuglevel(struct isc_log *lctx, unsigned int level)
{
  struct isc_logchannel *channel;
  _Bool tmp_if_expr$1;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 957, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&lctx->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/log.c", 959, "((pthread_mutex_lock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  lctx->debug_level = (signed int)level;
  if(lctx->debug_level == 0)
  {
    channel = lctx->logconfig->channels.head;
    for( ; !(channel == ((struct isc_logchannel *)NULL)); channel = channel->link.next)
      if(channel->type == 3u)
      {
        if(!((4096u & channel->flags) == 0u))
        {
          if(!(channel->destination.file.stream == ((struct _IO_FILE *)NULL)))
          {
            fclose(channel->destination.file.stream);
            channel->destination.file.stream = (struct _IO_FILE *)(void *)0;
          }

        }

      }

  }

  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&lctx->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/log.c", 975, "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// isc_log_setduplicateinterval
// file ./../lib/isc/log.c line 986
void isc_log_setduplicateinterval(struct isc_logconfig *lcfg, unsigned int interval)
{
  _Bool tmp_if_expr$1;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lcfg)->magic == (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 987, (enum anonymous$46)isc_assertiontype_require, "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
    (_Bool)0;
  }
  lcfg->duplicate_interval = interval;
}

// isc_log_settag
// file ./../lib/isc/log.c line 1000
unsigned int isc_log_settag(struct isc_logconfig *lcfg, const char *tag)
{
  _Bool tmp_if_expr$1;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lcfg)->magic == (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1001, (enum anonymous$46)isc_assertiontype_require, "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
    (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  if(!(tag == ((const char *)NULL)))
    tmp_if_expr$3 = (signed int)*tag != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
  {
    if(!(lcfg->tag == ((char *)NULL)))
    {
      (void)lcfg->lctx->mctx;
      free((void *)lcfg->tag);
    }

    (void)lcfg->lctx->mctx;
    char *return_value_estrdup_impl$2;
    return_value_estrdup_impl$2=estrdup_impl(tag);
    lcfg->tag = return_value_estrdup_impl$2;
    if(lcfg->tag == ((char *)NULL))
      return (unsigned int)1;

  }

  else
  {
    if(!(lcfg->tag == ((char *)NULL)))
    {
      (void)lcfg->lctx->mctx;
      free((void *)lcfg->tag);
    }

    lcfg->tag = (char *)(void *)0;
  }
  return (unsigned int)0;
}

// isc_log_usechannel
// file ./../lib/isc/log.c line 788
unsigned int isc_log_usechannel(struct isc_logconfig *lcfg, const char *name, const struct isc_logcategory *category, const struct isc_logmodule *module)
{
  struct isc_log *lctx;
  struct isc_logchannel *channel;
  unsigned int result = (unsigned int)0;
  unsigned int i;
  _Bool tmp_if_expr$1;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lcfg)->magic == (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 797, (enum anonymous$46)isc_assertiontype_require, "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
    (_Bool)0;
  }
  if(!(name == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 798, (enum anonymous$46)isc_assertiontype_require, "name != ((void *)0)");
    (_Bool)0;
  }
  lctx = lcfg->lctx;
  _Bool tmp_if_expr$2;
  if(category == ((const struct isc_logcategory *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = category->id < lctx->category_count ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 802, (enum anonymous$46)isc_assertiontype_require, "category == ((void *)0) || category->id < lctx->category_count");
    (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  if(module == ((const struct isc_logmodule *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = module->id < lctx->module_count ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 803, (enum anonymous$46)isc_assertiontype_require, "module == ((void *)0) || module->id < lctx->module_count");
    (_Bool)0;
  }
  channel = lcfg->channels.head;
  signed int return_value_strcmp$4;
  for( ; !(channel == ((struct isc_logchannel *)NULL)); channel = channel->link.next)
  {
    return_value_strcmp$4=strcmp(name, channel->name);
    if(return_value_strcmp$4 == 0)
      break;

  }
  if(channel == ((struct isc_logchannel *)NULL))
    return (unsigned int)23;

  else
  {
    if(!(category == ((const struct isc_logcategory *)NULL)))
      result=assignchannel(lcfg, category->id, module, channel);

    else
    {
      i = (unsigned int)0;
      for( ; !(i >= lctx->category_count); i = i + 1u)
      {
        result=assignchannel(lcfg, i, module, channel);
        if(!(result == 0u))
          break;

      }
    }
    return result;
  }
}

// isc_log_vwrite
// file ./../lib/isc/log.c line 847
void isc_log_vwrite(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, const char *format, void **args)
{
  isc_log_doit(lctx, category, module, level, (enum anonymous$11)isc_boolean_false, (struct isc_msgcat *)(void *)0, 0, 0, format, args);
}

// isc_log_vwrite1
// file ./../lib/isc/log.c line 875
void isc_log_vwrite1(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, const char *format, void **args)
{
  isc_log_doit(lctx, category, module, level, (enum anonymous$11)isc_boolean_true, (struct isc_msgcat *)(void *)0, 0, 0, format, args);
}

// isc_log_wouldlog
// file ./../lib/isc/log.c line 1378
enum anonymous$11 isc_log_wouldlog(struct isc_log *lctx, signed int level)
{
  _Bool tmp_if_expr$1;
  if(lctx == ((struct isc_log *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = lctx->logconfig == (struct isc_logconfig *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    return (enum anonymous$11)isc_boolean_false;

  else
  {
    if(lctx->logconfig->highest_level >= level)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(!(lctx->logconfig->dynamic == /*enum*/isc_boolean_false))
        tmp_if_expr$2 = level <= lctx->debug_level ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    return (enum anonymous$11)(tmp_if_expr$3 ? isc_boolean_true : isc_boolean_false);
  }
}

// isc_log_write
// file ../lib/isc/include/isc/log.h line 568
void isc_log_write(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, const char *format, ...)
{
  void **args = (void **)&format;
  isc_log_doit(lctx, category, module, level, (enum anonymous$11)isc_boolean_false, (struct isc_msgcat *)(void *)0, 0, 0, format, args);
  args = ((void **)NULL);
}

// isc_log_write1
// file ./../lib/isc/log.c line 859
void isc_log_write1(struct isc_log *lctx, struct isc_logcategory *category, struct isc_logmodule *module, signed int level, const char *format, ...)
{
  void **args = (void **)&format;
  isc_log_doit(lctx, category, module, level, (enum anonymous$11)isc_boolean_true, (struct isc_msgcat *)(void *)0, 0, 0, format, args);
  args = ((void **)NULL);
}

// isc_logconfig_create
// file ./../lib/isc/log.c line 331
unsigned int isc_logconfig_create(struct isc_log *lctx, struct isc_logconfig **lcfgp)
{
  struct isc_logconfig *lcfg;
  union isc_logdestination destination;
  unsigned int result = (unsigned int)0;
  signed int level = -1;
  _Bool tmp_if_expr$1;
  if(!(lcfgp == ((struct isc_logconfig **)NULL)))
    tmp_if_expr$1 = *lcfgp == (struct isc_logconfig *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 337, (enum anonymous$46)isc_assertiontype_require, "lcfgp != ((void *)0) && *lcfgp == ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$2 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 338, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  (void)lctx->mctx;
  void *return_value_ereallocz$3;
  return_value_ereallocz$3=ereallocz((void *)0, sizeof(struct isc_logconfig) /*72ul*/ , (unsigned long int)0, 0);
  lcfg = (struct isc_logconfig *)return_value_ereallocz$3;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
  {
    lcfg->lctx = lctx;
    lcfg->channellists = (struct anonymous$23 *)(void *)0;
    lcfg->channellist_count = (unsigned int)0;
    lcfg->duplicate_interval = (unsigned int)0;
    lcfg->highest_level = level;
    lcfg->tag = (char *)(void *)0;
    lcfg->dynamic = (enum anonymous$11)isc_boolean_false;
    do
    {
      lcfg->channels.head = (struct isc_logchannel *)(void *)0;
      lcfg->channels.tail = (struct isc_logchannel *)(void *)0;
    }
    while((_Bool)0);
    lcfg->magic = (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103);
  }

  else
    result = (unsigned int)1;
  if(result == 0u)
  {
    destination.facility = 3 << 3;
    result=isc_log_createchannel(lcfg, "default_syslog", (unsigned int)2, level, &destination, (unsigned int)0);
  }

  if(result == 0u)
  {
    destination.file.stream = stderr;
    destination.file.name = (const char *)(void *)0;
    destination.file.versions = -2;
    destination.file.maximum_size = (signed long int)0;
    result=isc_log_createchannel(lcfg, "default_stderr", (unsigned int)4, level, &destination, (unsigned int)0x0001);
  }

  if(result == 0u)
  {
    default_channel.channel = lcfg->channels.head;
    destination.file.stream = stderr;
    destination.file.name = (const char *)(void *)0;
    destination.file.versions = -2;
    destination.file.maximum_size = (signed long int)0;
    result=isc_log_createchannel(lcfg, "default_debug", (unsigned int)4, 0, &destination, (unsigned int)0x0001);
  }

  if(result == 0u)
    result=isc_log_createchannel(lcfg, "null", (unsigned int)1, 0, (const union isc_logdestination *)(void *)0, (unsigned int)0);

  if(result == 0u)
    *lcfgp = lcfg;

  else
    if(!(lcfg == ((struct isc_logconfig *)NULL)))
      isc_logconfig_destroy(&lcfg);

  return result;
}

// isc_logconfig_destroy
// file ./../lib/isc/log.c line 503
void isc_logconfig_destroy(struct isc_logconfig **lcfgp)
{
  struct isc_logconfig *lcfg;
  struct isc_mem *mctx;
  struct isc_logchannel *channel;
  struct isc_logchannellist *item;
  char *filename;
  unsigned int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(lcfgp == ((struct isc_logconfig **)NULL)))
  {
    if(!(*lcfgp == ((struct isc_logconfig *)NULL)))
      tmp_if_expr$1 = ((const struct anonymous$21 *)*lcfgp)->magic == (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 511, (enum anonymous$46)isc_assertiontype_require, "lcfgp != ((void *)0) && (((*lcfgp) != ((void *)0)) && (((const isc__magic_t *)(*lcfgp))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
    (_Bool)0;
  }
  lcfg = *lcfgp;
  _Bool tmp_if_expr$3;
  if(!(lcfg->lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$3 = lcfg->lctx->logconfig != lcfg ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 519, (enum anonymous$46)isc_assertiontype_require, "lcfg->lctx != ((void *)0) && lcfg->lctx->logconfig != lcfg");
    (_Bool)0;
  }
  mctx = lcfg->lctx->mctx;
  do
  {
    channel = lcfg->channels.head;
    if(channel == ((struct isc_logchannel *)NULL))
      break;


  __CPROVER_DUMP_L14:
    ;
    do
    {
      if(!(channel->link.next == ((struct isc_logchannel *)NULL)))
        channel->link.next->link.prev = channel->link.prev;

      else
      {
        if(lcfg->channels.tail == channel)
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/log.c", 524, (enum anonymous$46)isc_assertiontype_insist, "(lcfg->channels).tail == (channel)");
          (_Bool)0;
        }
        lcfg->channels.tail = channel->link.prev;
      }
      if(!(channel->link.prev == ((struct isc_logchannel *)NULL)))
        channel->link.prev->link.next = channel->link.next;

      else
      {
        if(lcfg->channels.head == channel)
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/log.c", 524, (enum anonymous$46)isc_assertiontype_insist, "(lcfg->channels).head == (channel)");
          (_Bool)0;
        }
        lcfg->channels.head = channel->link.next;
      }
      channel->link.prev = (struct isc_logchannel *)(void *)-1;
      channel->link.next = (struct isc_logchannel *)(void *)-1;
    }
    while((_Bool)0);
    if(channel->type == 3u)
    {
      do
      {
        /* tag-#anon#lUN[l*{clV}$clV$'k'||l*{lV}$lV$'v'|] */
union anonymous$9
{
  // k
  const void *k;
  // v
  void *v;
};

/* */
        ;
        union anonymous$9 _u;
        _u.k = (const void *)channel->destination.file.name;
        filename = (char *)_u.v;
      }
      while((_Bool)0);
      (void)mctx;
      free((void *)filename);
      if(!(channel->destination.file.stream == ((struct _IO_FILE *)NULL)))
        fclose(channel->destination.file.stream);

    }

    (void)mctx;
    free((void *)channel->name);
    (void)mctx;
    free((void *)channel);
  }
  while((_Bool)1);
  i = (unsigned int)0;
  for( ; !(i >= lcfg->channellist_count); i = i + 1u)
    do
    {
      item = (lcfg->channellists + (signed long int)i)->head;
      if(item == ((struct isc_logchannellist *)NULL))
        break;


    __CPROVER_DUMP_L30:
      ;
      do
      {
        if(!(item->link.next == ((struct isc_logchannellist *)NULL)))
          item->link.next->link.prev = item->link.prev;

        else
        {
          if((lcfg->channellists + (signed long int)i)->tail == item)
            (_Bool)1;

          else
          {
            isc_assertion_failed("./../lib/isc/log.c", 546, (enum anonymous$46)isc_assertiontype_insist, "(lcfg->channellists[i]).tail == (item)");
            (_Bool)0;
          }
          (lcfg->channellists + (signed long int)i)->tail = item->link.prev;
        }
        if(!(item->link.prev == ((struct isc_logchannellist *)NULL)))
          item->link.prev->link.next = item->link.next;

        else
        {
          if((lcfg->channellists + (signed long int)i)->head == item)
            (_Bool)1;

          else
          {
            isc_assertion_failed("./../lib/isc/log.c", 546, (enum anonymous$46)isc_assertiontype_insist, "(lcfg->channellists[i]).head == (item)");
            (_Bool)0;
          }
          (lcfg->channellists + (signed long int)i)->head = item->link.next;
        }
        item->link.prev = (struct isc_logchannellist *)(void *)-1;
        item->link.next = (struct isc_logchannellist *)(void *)-1;
      }
      while((_Bool)0);
      (void)mctx;
      free((void *)item);
    }
    while((_Bool)1);
  if(lcfg->channellist_count >= 1u)
  {
    /* tag-#anon#lST[l*{SYM#tag-isc_logchannellist#}$SYM#tag-isc_logchannellist#$'head'||l*{SYM#tag-isc_logchannellist#}$SYM#tag-isc_logchannellist#$'tail'|] */
struct anonymous$30
{
  // head
  struct isc_logchannellist *head;
  // tail
  struct isc_logchannellist *tail;
};

/* */
    ;
    (void)((unsigned long int)lcfg->channellist_count * sizeof(struct anonymous$30) /*16ul*/ );
    (void)mctx;
    free((void *)lcfg->channellists);
  }

  lcfg->dynamic = (enum anonymous$11)isc_boolean_false;
  if(!(lcfg->tag == ((char *)NULL)))
  {
    (void)lcfg->lctx->mctx;
    free((void *)lcfg->tag);
  }

  lcfg->tag = (char *)(void *)0;
  lcfg->highest_level = 0;
  lcfg->duplicate_interval = (unsigned int)0;
  lcfg->magic = (unsigned int)0;
  (void)mctx;
  free((void *)lcfg);
  *lcfgp = (struct isc_logconfig *)(void *)0;
}

// isc_logconfig_get
// file ./../lib/isc/log.c line 423
struct isc_logconfig * isc_logconfig_get(struct isc_log *lctx)
{
  _Bool tmp_if_expr$1;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 424, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  if(!(lctx->logconfig == ((struct isc_logconfig *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 426, (enum anonymous$46)isc_assertiontype_ensure, "lctx->logconfig != ((void *)0)");
    (_Bool)0;
  }
  return lctx->logconfig;
}

// isc_logconfig_use
// file ./../lib/isc/log.c line 432
unsigned int isc_logconfig_use(struct isc_log *lctx, struct isc_logconfig *lcfg)
{
  struct isc_logconfig *old_cfg;
  unsigned int result;
  _Bool tmp_if_expr$1;
  if(!(lctx == ((struct isc_log *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lctx)->magic == (unsigned int)(76 << 24 | 99 << 16 | 116 << 8 | 120) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 436, (enum anonymous$46)isc_assertiontype_require, "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
    tmp_if_expr$2 = ((const struct anonymous$21 *)lcfg)->magic == (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 437, (enum anonymous$46)isc_assertiontype_require, "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
    (_Bool)0;
  }
  if(lcfg->lctx == lctx)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 438, (enum anonymous$46)isc_assertiontype_require, "lcfg->lctx == lctx");
    (_Bool)0;
  }
  result=sync_channellist(lcfg);
  if(!(result == 0u))
    return result;

  else
  {
    do
    {
      signed int return_value_pthread_mutex_lock$3;
      return_value_pthread_mutex_lock$3=pthread_mutex_lock(&lctx->lock);
      if(return_value_pthread_mutex_lock$3 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/log.c", 449, "((pthread_mutex_lock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
    old_cfg = lctx->logconfig;
    lctx->logconfig = lcfg;
    do
    {
      signed int return_value_pthread_mutex_unlock$4;
      return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(&lctx->lock);
      if(return_value_pthread_mutex_unlock$4 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/log.c", 454, "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
    isc_logconfig_destroy(&old_cfg);
    return (unsigned int)0;
  }
}

// isc_md5_final
// file ./../lib/isc/md5.c line 248
void isc_md5_final(struct anonymous$45 *ctx, unsigned char *digest)
{
  signed int count = (signed int)(ctx->bytes[(signed long int)0] & (unsigned int)0x3f);
  unsigned char *p = (unsigned char *)ctx->in + (signed long int)count;
  unsigned char *tmp_post$1 = p;
  p = p + 1l;
  *tmp_post$1 = (unsigned char)0x80;
  count = (56 - 1) - count;
  if(!(count >= 0))
  {
    memset((void *)p, 0, (unsigned long int)(count + 8));
    byteSwap(ctx->in, (unsigned int)16);
    transform(ctx->buf, ctx->in);
    p = (unsigned char *)ctx->in;
    count = 56;
  }

  memset((void *)p, 0, (unsigned long int)count);
  byteSwap(ctx->in, (unsigned int)14);
  ctx->in[(signed long int)14] = ctx->bytes[(signed long int)0] << 3;
  ctx->in[(signed long int)15] = ctx->bytes[(signed long int)1] << 3 | ctx->bytes[(signed long int)0] >> 29;
  transform(ctx->buf, ctx->in);
  byteSwap(ctx->buf, (unsigned int)4);
  memcpy((void *)digest, (const void *)ctx->buf, (unsigned long int)16);
  memset((void *)ctx, 0, sizeof(struct anonymous$45) /*88ul*/ );
}

// isc_md5_init
// file ./../lib/isc/md5.c line 87
void isc_md5_init(struct anonymous$45 *ctx)
{
  ctx->buf[(signed long int)0] = (unsigned int)0x67452301;
  ctx->buf[(signed long int)1] = 0xefcdab89;
  ctx->buf[(signed long int)2] = 0x98badcfe;
  ctx->buf[(signed long int)3] = (unsigned int)0x10325476;
  ctx->bytes[(signed long int)0] = (unsigned int)0;
  ctx->bytes[(signed long int)1] = (unsigned int)0;
}

// isc_md5_invalidate
// file ./../lib/isc/md5.c line 98
void isc_md5_invalidate(struct anonymous$45 *ctx)
{
  memset((void *)ctx, 0, sizeof(struct anonymous$45) /*88ul*/ );
}

// isc_md5_update
// file ./../lib/isc/md5.c line 209
void isc_md5_update(struct anonymous$45 *ctx, const unsigned char *buf, unsigned int len)
{
  unsigned int t = ctx->bytes[(signed long int)0];
  ctx->bytes[(signed long int)0] = t + len;
  if(!(ctx->bytes[0l] >= t))
    ctx->bytes[(signed long int)1] = ctx->bytes[(signed long int)1] + 1u;

  t = (unsigned int)64 - (t & (unsigned int)0x3f);
  if(!(len >= t))
    memcpy((void *)(((unsigned char *)ctx->in + (signed long int)64) - (signed long int)t), (const void *)buf, (unsigned long int)len);

  else
  {
    memcpy((void *)(((unsigned char *)ctx->in + (signed long int)64) - (signed long int)t), (const void *)buf, (unsigned long int)t);
    byteSwap(ctx->in, (unsigned int)16);
    transform(ctx->buf, ctx->in);
    buf = buf + (signed long int)t;
    len = len - t;
    for( ; len >= 64u; len = len - (unsigned int)64)
    {
      memcpy((void *)ctx->in, (const void *)buf, (unsigned long int)64);
      byteSwap(ctx->in, (unsigned int)16);
      transform(ctx->buf, ctx->in);
      buf = buf + (signed long int)64;
    }
    memcpy((void *)ctx->in, (const void *)buf, (unsigned long int)len);
  }
}

// isc_msgcat_close
// file ./../lib/isc/nls/msgcat.c line 87
void isc_msgcat_close(struct isc_msgcat **msgcatp)
{
  struct isc_msgcat *msgcat;
  if(!(msgcatp == ((struct isc_msgcat **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/nls/msgcat.c", 94, (enum anonymous$46)isc_assertiontype_require, "msgcatp != ((void *)0)");
    (_Bool)0;
  }
  msgcat = *msgcatp;
  _Bool tmp_if_expr$1;
  if(!(msgcat == ((struct isc_msgcat *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)msgcat)->magic == (unsigned int)(77 << 24 | 67 << 16 | 97 << 8 | 116) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(msgcat == ((struct isc_msgcat *)NULL) || tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/nls/msgcat.c", 96, (enum anonymous$46)isc_assertiontype_require, "(((msgcat) != ((void *)0)) && (((const isc__magic_t *)(msgcat))->magic == ((('M') << 24 | ('C') << 16 | ('a') << 8 | ('t'))))) || msgcat == ((void *)0)");
    (_Bool)0;
  }
  if(!(msgcat == ((struct isc_msgcat *)NULL)))
  {
    msgcat->magic = (unsigned int)0;
    free((void *)msgcat);
  }

  *msgcatp = (struct isc_msgcat *)(void *)0;
}

// isc_msgcat_get
// file ../lib/isc/include/isc/msgcat.h line 112
const char * isc_msgcat_get(struct isc_msgcat *msgcat, signed int set, signed int message, const char *default_text)
{
  _Bool tmp_if_expr$1;
  if(!(msgcat == ((struct isc_msgcat *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)msgcat)->magic == (unsigned int)(77 << 24 | 67 << 16 | 97 << 8 | 116) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(msgcat == ((struct isc_msgcat *)NULL) || tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/nls/msgcat.c", 119, (enum anonymous$46)isc_assertiontype_require, "(((msgcat) != ((void *)0)) && (((const isc__magic_t *)(msgcat))->magic == ((('M') << 24 | ('C') << 16 | ('a') << 8 | ('t'))))) || msgcat == ((void *)0)");
    (_Bool)0;
  }
  if(set >= 1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/nls/msgcat.c", 120, (enum anonymous$46)isc_assertiontype_require, "set > 0");
    (_Bool)0;
  }
  if(message >= 1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/nls/msgcat.c", 121, (enum anonymous$46)isc_assertiontype_require, "message > 0");
    (_Bool)0;
  }
  if(!(default_text == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/nls/msgcat.c", 122, (enum anonymous$46)isc_assertiontype_require, "default_text != ((void *)0)");
    (_Bool)0;
  }
  return default_text;
}

// isc_msgcat_open
// file ../lib/isc/include/isc/msgcat.h line 71
void isc_msgcat_open(const char *name, struct isc_msgcat **msgcatp)
{
  struct isc_msgcat *msgcat;
  if(!(name == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/nls/msgcat.c", 64, (enum anonymous$46)isc_assertiontype_require, "name != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(msgcatp == ((struct isc_msgcat **)NULL)))
    tmp_if_expr$1 = *msgcatp == (struct isc_msgcat *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/nls/msgcat.c", 65, (enum anonymous$46)isc_assertiontype_require, "msgcatp != ((void *)0) && *msgcatp == ((void *)0)");
    (_Bool)0;
  }
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct isc_msgcat) /*4ul*/ );
  msgcat = (struct isc_msgcat *)return_value_malloc$2;
  if(msgcat == ((struct isc_msgcat *)NULL))
    *msgcatp = (struct isc_msgcat *)(void *)0;

  else
  {
    msgcat->magic = (unsigned int)(77 << 24 | 67 << 16 | 97 << 8 | 116);
    *msgcatp = msgcat;
  }
}

// isc_net_disableipv4
// file ./../lib/isc/unix/net.c line 498
void isc_net_disableipv4(void)
{
  initialize();
  if(ipv4_result == 0u)
    ipv4_result = (unsigned int)57;

}

// isc_net_disableipv6
// file ./../lib/isc/unix/net.c line 505
void isc_net_disableipv6(void)
{
  initialize();
  if(ipv6_result == 0u)
    ipv6_result = (unsigned int)57;

}

// isc_net_enableipv4
// file ./../lib/isc/unix/net.c line 512
void isc_net_enableipv4(void)
{
  initialize();
  if(ipv4_result == 57u)
    ipv4_result = (unsigned int)0;

}

// isc_net_enableipv6
// file ./../lib/isc/unix/net.c line 519
void isc_net_enableipv6(void)
{
  initialize();
  if(ipv6_result == 57u)
    ipv6_result = (unsigned int)0;

}

// isc_net_getudpportrange
// file ./../lib/isc/unix/net.c line 478
unsigned int isc_net_getudpportrange(signed int af, unsigned short int *low, unsigned short int *high)
{
  signed int result = 25;
  if(!(high == ((unsigned short int *)NULL)) && !(low == ((unsigned short int *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/net.c", 481, (enum anonymous$46)isc_assertiontype_require, "low != ((void *)0) && high != ((void *)0)");
    (_Bool)0;
  }
  (void)af;
  if(!(result == 0))
  {
    *low = (unsigned short int)1024;
    *high = (unsigned short int)65535;
  }

  return (unsigned int)0;
}

// isc_net_ntop
// file ./../lib/isc/inet_ntop.c line 60
const char * isc_net_ntop(signed int af, const void *src, char *dst, unsigned long int size)
{
  const char *return_value_inet_ntop4$1;
  const char *return_value_inet_ntop6$2;
  signed int *return_value___errno_location$3;
  switch(af)
  {
    case 2:
    {
      return_value_inet_ntop4$1=inet_ntop4((const unsigned char *)src, dst, size);
      return return_value_inet_ntop4$1;
    }
    case 10:
    {
      return_value_inet_ntop6$2=inet_ntop6((const unsigned char *)src, dst, size);
      return return_value_inet_ntop6$2;
    }
    default:
    {
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 97;
      return (const char *)(void *)0;
    }
  }
}

// isc_net_probe_ipv6only
// file ./../lib/isc/unix/net.c line 377
unsigned int isc_net_probe_ipv6only(void)
{
  initialize_ipv6only();
  return ipv6only_result;
}

// isc_net_probe_ipv6pktinfo
// file ./../lib/isc/unix/net.c line 389
unsigned int isc_net_probe_ipv6pktinfo(void)
{
  initialize_ipv6pktinfo();
  return ipv6pktinfo_result;
}

// isc_net_probeipv4
// file ../lib/isc/unix/include/isc/net.h line 259
unsigned int isc_net_probeipv4(void)
{
  initialize();
  return ipv4_result;
}

// isc_net_probeipv6
// file ../lib/isc/unix/include/isc/net.h line 272
unsigned int isc_net_probeipv6(void)
{
  initialize();
  return ipv6_result;
}

// isc_net_probeunix
// file ./../lib/isc/unix/net.c line 237
unsigned int isc_net_probeunix(void)
{
  initialize();
  return unix_result;
}

// isc_net_pton
// file ./../lib/isc/inet_pton.c line 59
signed int isc_net_pton(signed int af, const char *src, void *dst)
{
  signed int return_value_inet_pton4$1;
  signed int return_value_inet_pton6$2;
  signed int *return_value___errno_location$3;
  switch(af)
  {
    case 2:
    {
      return_value_inet_pton4$1=inet_pton4(src, (unsigned char *)dst);
      return return_value_inet_pton4$1;
    }
    case 10:
    {
      return_value_inet_pton6$2=inet_pton6(src, (unsigned char *)dst);
      return return_value_inet_pton6$2;
    }
    default:
    {
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 97;
      return -1;
    }
  }
}

// isc_netaddr_any
// file ./../lib/isc/netaddr.c line 364
void isc_netaddr_any(struct isc_netaddr *netaddr)
{
  memset((void *)netaddr, 0, sizeof(struct isc_netaddr) /*24ul*/ );
  netaddr->family = (unsigned int)2;
  netaddr->type.in.s_addr = (unsigned int)0x00000000;
}

// isc_netaddr_any6
// file ./../lib/isc/netaddr.c line 371
void isc_netaddr_any6(struct isc_netaddr *netaddr)
{
  memset((void *)netaddr, 0, sizeof(struct isc_netaddr) /*24ul*/ );
  netaddr->family = (unsigned int)10;
  netaddr->type.in6 = in6addr_any;
}

// isc_netaddr_eqprefix
// file ./../lib/isc/netaddr.c line 70
enum anonymous$11 isc_netaddr_eqprefix(const struct isc_netaddr *a, const struct isc_netaddr *b, unsigned int prefixlen)
{
  const unsigned char *pa = (const unsigned char *)(void *)0;
  const unsigned char *pb = (const unsigned char *)(void *)0;
  unsigned int ipabytes = (unsigned int)0;
  unsigned int nbytes;
  unsigned int nbits;
  if(!(a == ((const struct isc_netaddr *)NULL)) && !(b == ((const struct isc_netaddr *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/netaddr.c", 78, (enum anonymous$46)isc_assertiontype_require, "a != ((void *)0) && b != ((void *)0)");
    (_Bool)0;
  }
  if(!(a->family == b->family))
    return (enum anonymous$11)isc_boolean_false;

  else
    if(!(a->zone == b->zone))
    {
      if(b->zone == 0u)
        goto __CPROVER_DUMP_L5;

      return (enum anonymous$11)isc_boolean_false;
    }

    else
    {

    __CPROVER_DUMP_L5:
      ;
      switch(a->family)
      {
        case (unsigned int)2:
        {
          pa = (const unsigned char *)&a->type.in;
          pb = (const unsigned char *)&b->type.in;
          ipabytes = (unsigned int)4;
          break;
        }
        case (unsigned int)10:
        {
          pa = (const unsigned char *)&a->type.in6;
          pb = (const unsigned char *)&b->type.in6;
          ipabytes = (unsigned int)16;
          break;
        }
        default:
          return (enum anonymous$11)isc_boolean_false;
      }
      if(!(8u * ipabytes >= prefixlen))
        prefixlen = ipabytes * (unsigned int)8;

      nbytes = prefixlen / (unsigned int)8;
      nbits = prefixlen % (unsigned int)8;
      if(nbytes >= 1u)
      {
        signed int return_value_memcmp$1;
        return_value_memcmp$1=memcmp((const void *)pa, (const void *)pb, (unsigned long int)nbytes);
        if(!(return_value_memcmp$1 == 0))
          return (enum anonymous$11)isc_boolean_false;

      }

      if(nbits >= 1u)
      {
        unsigned int bytea;
        unsigned int byteb;
        unsigned int mask;
        if(!(nbytes >= ipabytes))
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/netaddr.c", 116, (enum anonymous$46)isc_assertiontype_insist, "nbytes < ipabytes");
          (_Bool)0;
        }
        if(!(nbits >= 8u))
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/netaddr.c", 117, (enum anonymous$46)isc_assertiontype_insist, "nbits < 8");
          (_Bool)0;
        }
        bytea = (unsigned int)pa[(signed long int)nbytes];
        byteb = (unsigned int)pb[(signed long int)nbytes];
        mask = (unsigned int)(0xFF << (unsigned int)8 - nbits & 0xFF);
        if(!((bytea & mask) == (byteb & mask)))
          return (enum anonymous$11)isc_boolean_false;

      }

      return (enum anonymous$11)isc_boolean_true;
    }
}

// isc_netaddr_equal
// file ./../lib/isc/netaddr.c line 37
enum anonymous$11 isc_netaddr_equal(const struct isc_netaddr *a, const struct isc_netaddr *b)
{
  if(!(a == ((const struct isc_netaddr *)NULL)) && !(b == ((const struct isc_netaddr *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/netaddr.c", 38, (enum anonymous$46)isc_assertiontype_require, "a != ((void *)0) && b != ((void *)0)");
    (_Bool)0;
  }
  signed int return_value_memcmp$1;
  _Bool tmp_if_expr$2;
  if(!(a->family == b->family))
    return (enum anonymous$11)isc_boolean_false;

  else
    if(!(a->zone == b->zone))
      return (enum anonymous$11)isc_boolean_false;

    else
    {
      switch(a->family)
      {
        case (unsigned int)2:
        {
          if(!(a->type.in.s_addr == b->type.in.s_addr))
            return (enum anonymous$11)isc_boolean_false;

          break;
        }
        case (unsigned int)10:
        {
          return_value_memcmp$1=memcmp((const void *)&a->type.in6, (const void *)&b->type.in6, sizeof(struct in6_addr) /*16ul*/ );
          if(!(return_value_memcmp$1 == 0))
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = a->zone != b->zone ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
            return (enum anonymous$11)isc_boolean_false;

          break;
        }
        default:
          return (enum anonymous$11)isc_boolean_false;
      }
      return (enum anonymous$11)isc_boolean_true;
    }
}

// isc_netaddr_format
// file ./../lib/isc/netaddr.c line 183
void isc_netaddr_format(const struct isc_netaddr *na, char *array, unsigned int size)
{
  unsigned int result;
  struct isc_buffer buf;
  isc__buffer_init(&buf, (const void *)array, size);
  result=isc_netaddr_totext(na, &buf);
  if(!(size == 0u))
  {
    if(result == 0u)
    {
      if(buf.length + -buf.used >= 1u)
        isc__buffer_putuint8(&buf, (unsigned char)0);

      else
        result = (unsigned int)19;
    }

    if(!(result == 0u))
    {
      const char *return_value_isc_msgcat_get$1;
      return_value_isc_msgcat_get$1=isc_msgcat_get(isc_msgcat, 12, 1001, "unknown address, family");
      snprintf(array, (unsigned long int)size, "<%s %u>", return_value_isc_msgcat_get$1, na->family);
      array[(signed long int)(size - (unsigned int)1)] = (char)0;
    }

  }

}

// isc_netaddr_fromin
// file ./../lib/isc/netaddr.c line 290
void isc_netaddr_fromin(struct isc_netaddr *netaddr, struct in_addr *ina)
{
  memset((void *)netaddr, 0, sizeof(struct isc_netaddr) /*24ul*/ );
  netaddr->family = (unsigned int)2;
  netaddr->type.in = *ina;
}

// isc_netaddr_fromin6
// file ../lib/isc/include/isc/netaddr.h line 111
void isc_netaddr_fromin6(struct isc_netaddr *netaddr, struct in6_addr *ina6)
{
  memset((void *)netaddr, 0, sizeof(struct isc_netaddr) /*24ul*/ );
  netaddr->family = (unsigned int)10;
  netaddr->type.in6 = *ina6;
}

// isc_netaddr_frompath
// file ./../lib/isc/netaddr.c line 304
unsigned int isc_netaddr_frompath(struct isc_netaddr *netaddr, const char *path)
{
  (void)netaddr;
  (void)path;
  return (unsigned int)27;
}

// isc_netaddr_fromsockaddr
// file ../lib/isc/include/isc/netaddr.h line 105
void isc_netaddr_fromsockaddr(struct isc_netaddr *t, const struct isc_sockaddr *s)
{
  signed int family = (signed int)s->type.sa.sa_family;
  t->family = (unsigned int)family;
  switch(family)
  {
    case 2:
    {
      t->type.in = s->type.sin.sin_addr;
      t->zone = (unsigned int)0;
      break;
    }
    case 10:
    {
      memcpy((void *)&t->type.in6, (const void *)&s->type.sin6.sin6_addr, (unsigned long int)16);
      t->zone = s->type.sin6.sin6_scope_id;
      break;
    }
    default:
    {
      isc_assertion_failed("./../lib/isc/netaddr.c", 359, (enum anonymous$46)isc_assertiontype_insist, "0");
      (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
    }
  }
}

// isc_netaddr_fromv4mapped
// file ./../lib/isc/netaddr.c line 424
void isc_netaddr_fromv4mapped(struct isc_netaddr *t, const struct isc_netaddr *s)
{
  struct isc_netaddr *src;
  do
  {
    /* tag-#anon#lUN[l*{clV}$clV$'k'||l*{lV}$lV$'v'|] */
union anonymous$9
{
  // k
  const void *k;
  // v
  void *v;
};

/* */
    ;
    union anonymous$9 _u;
    _u.k = (const void *)s;
    src = (struct isc_netaddr *)_u.v;
  }
  while((_Bool)0);
  if(s->family == 10u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/netaddr.c", 429, (enum anonymous$46)isc_assertiontype_require, "s->family == 10");
    (_Bool)0;
  }
  _Bool tmp_statement_expression$1;
  struct in6_addr *__a = (struct in6_addr *)&src->type.in6;
  _Bool tmp_if_expr$2;
  if(__a->__in6_u.__u6_addr32[0l] == 0u)
    tmp_if_expr$2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$4;
  unsigned int return_value_htonl$3;
  if(tmp_if_expr$2)
  {
    return_value_htonl$3=htonl((unsigned int)0xffff);
    tmp_if_expr$4 = __a->__in6_u.__u6_addr32[(signed long int)2] == return_value_htonl$3 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$4 = (_Bool)0;
  tmp_statement_expression$1 = tmp_if_expr$4;
  if(tmp_statement_expression$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/netaddr.c", 430, (enum anonymous$46)isc_assertiontype_require, "(__extension__ ({ const struct in6_addr *__a = (const struct in6_addr *) (&src->type.in6); __a->__in6_u.__u6_addr32[0] == 0 && __a->__in6_u.__u6_addr32[1] == 0 && __a->__in6_u.__u6_addr32[2] == htonl (0xffff); }))");
    (_Bool)0;
  }
  memset((void *)t, 0, sizeof(struct isc_netaddr) /*24ul*/ );
  t->family = (unsigned int)2;
  memcpy((void *)&t->type.in, (const void *)((char *)&src->type.in6 + (signed long int)12), (unsigned long int)4);
  goto __CPROVER_DUMP_L12;

__CPROVER_DUMP_L12:
  ;
}

// isc_netaddr_getzone
// file ./../lib/isc/netaddr.c line 331
unsigned int isc_netaddr_getzone(const struct isc_netaddr *netaddr)
{
  return netaddr->zone;
}

// isc_netaddr_isexperimental
// file ./../lib/isc/netaddr.c line 390
enum anonymous$11 isc_netaddr_isexperimental(struct isc_netaddr *na)
{
  unsigned int return_value_htonl$1;
  unsigned int return_value_htonl$2;
  if(na->family == 2u)
  {
    return_value_htonl$1=htonl((unsigned int)0xf0000000);
    return_value_htonl$2=htonl((unsigned int)0xf0000000);
    return (enum anonymous$11)(((unsigned int)na->type.in.s_addr & (unsigned int)return_value_htonl$1) == (unsigned int)return_value_htonl$2 ? isc_boolean_true : isc_boolean_false);
  }

  return (enum anonymous$11)isc_boolean_false;
}

// isc_netaddr_islinklocal
// file ../lib/isc/include/isc/netaddr.h line 147
enum anonymous$11 isc_netaddr_islinklocal(struct isc_netaddr *na)
{
  _Bool tmp_statement_expression$1;
  switch(na->family)
  {
    case (unsigned int)2:
      return (enum anonymous$11)isc_boolean_false;
    case (unsigned int)10:
    {
      struct in6_addr *__a = (struct in6_addr *)&na->type.in6;
      unsigned int return_value_htonl$2;
      return_value_htonl$2=htonl(0xffc00000);
      unsigned int return_value_htonl$3;
      return_value_htonl$3=htonl(0xfe800000);
      tmp_statement_expression$1 = (__a->__in6_u.__u6_addr32[(signed long int)0] & return_value_htonl$2) == return_value_htonl$3;
      return (enum anonymous$11)(tmp_statement_expression$1 ? isc_boolean_true : isc_boolean_false);
    }
    default:
      return (enum anonymous$11)isc_boolean_false;
  }
}

// isc_netaddr_ismulticast
// file ./../lib/isc/netaddr.c line 378
enum anonymous$11 isc_netaddr_ismulticast(struct isc_netaddr *na)
{
  unsigned int return_value_htonl$1;
  unsigned int return_value_htonl$2;
  switch(na->family)
  {
    case (unsigned int)2:
    {
      return_value_htonl$1=htonl((unsigned int)0xf0000000);
      return_value_htonl$2=htonl((unsigned int)0xe0000000);
      return (enum anonymous$11)(((unsigned int)na->type.in.s_addr & (unsigned int)return_value_htonl$1) == (unsigned int)return_value_htonl$2 ? isc_boolean_true : isc_boolean_false);
    }
    case (unsigned int)10:
      return (enum anonymous$11)((signed int)((const unsigned char *)&na->type.in6)[(signed long int)0] == 0xff ? isc_boolean_true : isc_boolean_false);
    default:
      return (enum anonymous$11)isc_boolean_false;
  }
}

// isc_netaddr_issitelocal
// file ./../lib/isc/netaddr.c line 412
enum anonymous$11 isc_netaddr_issitelocal(struct isc_netaddr *na)
{
  _Bool tmp_statement_expression$1;
  switch(na->family)
  {
    case (unsigned int)2:
      return (enum anonymous$11)isc_boolean_false;
    case (unsigned int)10:
    {
      struct in6_addr *__a = (struct in6_addr *)&na->type.in6;
      unsigned int return_value_htonl$2;
      return_value_htonl$2=htonl(0xffc00000);
      unsigned int return_value_htonl$3;
      return_value_htonl$3=htonl(0xfec00000);
      tmp_statement_expression$1 = (__a->__in6_u.__u6_addr32[(signed long int)0] & return_value_htonl$2) == return_value_htonl$3;
      return (enum anonymous$11)(tmp_statement_expression$1 ? isc_boolean_true : isc_boolean_false);
    }
    default:
      return (enum anonymous$11)isc_boolean_false;
  }
}

// isc_netaddr_masktoprefixlen
// file ../lib/isc/include/isc/netaddr.h line 66
unsigned int isc_netaddr_masktoprefixlen(const struct isc_netaddr *s, unsigned int *lenp)
{
  unsigned int nbits = (unsigned int)0;
  unsigned int nbytes = (unsigned int)0;
  unsigned int ipbytes = (unsigned int)0;
  unsigned int i;
  const unsigned char *p;
  switch(s->family)
  {
    case (unsigned int)2:
    {
      p = (const unsigned char *)&s->type.in;
      ipbytes = (unsigned int)4;
      break;
    }
    case (unsigned int)10:
    {
      p = (const unsigned char *)&s->type.in6;
      ipbytes = (unsigned int)16;
      break;
    }
    default:
      return (unsigned int)27;
  }
  i = (unsigned int)0;
  for( ; !(i >= ipbytes); i = i + 1u)
    if(!((signed int)p[(signed long int)i] == 0xFF))
      break;

  nbytes = i;
  if(!(i >= ipbytes))
  {
    unsigned int c = (unsigned int)p[(signed long int)nbytes];
    for( ; !((128u & c) == 0u) && !(nbits >= 8u); nbits = nbits + 1u)
      c = c << 1;
    if(!((255u & c) == 0u))
      return (unsigned int)37;

    i = i + 1u;
  }

  for( ; !(i >= ipbytes); i = i + 1u)
  {
    if(!((signed int)p[(signed long int)i] == 0))
      return (unsigned int)37;

    i = i + 1u;
  }
  *lenp = nbytes * (unsigned int)8 + nbits;
  return (unsigned int)0;
}

// isc_netaddr_prefixok
// file ./../lib/isc/netaddr.c line 216
unsigned int isc_netaddr_prefixok(const struct isc_netaddr *na, unsigned int prefixlen)
{
  unsigned int nbits;
  unsigned int nbytes;
  unsigned int ipbytes = (unsigned int)0;
  const unsigned char *p;
  switch(na->family)
  {
    case (unsigned int)2:
    {
      p = (const unsigned char *)&na->type.in;
      ipbytes = (unsigned int)4;
      if(prefixlen >= 33u)
        return (unsigned int)41;

      break;
    }
    case (unsigned int)10:
    {
      p = (const unsigned char *)&na->type.in6;
      ipbytes = (unsigned int)16;
      if(prefixlen >= 129u)
        return (unsigned int)41;

      break;
    }
    default:
      return (unsigned int)27;
  }
  nbytes = prefixlen / (unsigned int)8;
  nbits = prefixlen % (unsigned int)8;
  if(!(nbits == 0u))
  {
    if(!(((unsigned int)(0xff >> nbits) & (unsigned int)(signed int)p[(signed long int)nbytes]) == 0U))
      return (unsigned int)25;

    nbytes = nbytes + 1u;
  }

  signed int return_value_memcmp$1;
  static const unsigned char zeros[16l] = { (const unsigned char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  return_value_memcmp$1=memcmp((const void *)(p + (signed long int)nbytes), (const void *)zeros, (unsigned long int)(ipbytes - nbytes));
  if(!(return_value_memcmp$1 == 0))
    return (unsigned int)25;

  else
    return (unsigned int)0;
}

// isc_netaddr_setzone
// file ../lib/isc/include/isc/netaddr.h line 117
void isc_netaddr_setzone(struct isc_netaddr *netaddr, unsigned int zone)
{
  if(netaddr->family == 10u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/netaddr.c", 325, (enum anonymous$46)isc_assertiontype_require, "netaddr->family == 10");
    (_Bool)0;
  }
  netaddr->zone = zone;
}

// isc_netaddr_totext
// file ./../lib/isc/netaddr.c line 128
unsigned int isc_netaddr_totext(const struct isc_netaddr *netaddr, struct isc_buffer *target)
{
  char abuf[(signed long int)sizeof(char [46l]) /*46l*/ ];
  char zbuf[(signed long int)sizeof(char [12l]) /*12l*/ ];
  unsigned int alen;
  signed int zlen;
  const char *r;
  const void *type;
  if(!(netaddr == ((const struct isc_netaddr *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/netaddr.c", 136, (enum anonymous$46)isc_assertiontype_require, "netaddr != ((void *)0)");
    (_Bool)0;
  }
  switch(netaddr->family)
  {
    case (unsigned int)2:
    {
      type = (const void *)&netaddr->type.in;
      break;
    }
    case (unsigned int)10:
    {
      type = (const void *)&netaddr->type.in6;
      break;
    }
    default:
      return (unsigned int)25;
  }
  r=inet_ntop((signed int)netaddr->family, type, abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
  if(r == ((const char *)NULL))
    return (unsigned int)25;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(abuf);
    alen = (unsigned int)return_value_strlen$1;
    if(!((unsigned long int)alen >= sizeof(char [46l]) /*46ul*/ ))
      (_Bool)1;

    else
    {
      isc_assertion_failed("./../lib/isc/netaddr.c", 163, (enum anonymous$46)isc_assertiontype_insist, "alen < sizeof(abuf)");
      (_Bool)0;
    }
    zlen = 0;
    if(netaddr->family == 10u)
    {
      if(!(netaddr->zone == 0u))
      {
        zlen=snprintf(zbuf, sizeof(char [12l]) /*12ul*/ , "%%%u", netaddr->zone);
        if(!(zlen >= 0))
          return (unsigned int)25;

        if(!((unsigned long int)(unsigned int)zlen >= sizeof(char [12l]) /*12ul*/ ))
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/netaddr.c", 170, (enum anonymous$46)isc_assertiontype_insist, "(unsigned int)zlen < sizeof(zbuf)");
          (_Bool)0;
        }
      }

    }

    if(!(target->length + -target->used >= alen + (unsigned int)zlen))
      return (unsigned int)19;

    else
    {
      isc__buffer_putmem(target, (unsigned char *)abuf, alen);
      isc__buffer_putmem(target, (unsigned char *)zbuf, (unsigned int)zlen);
      return (unsigned int)0;
    }
  }
}

// isc_netscope_pton
// file ./../lib/isc/netscope.c line 33
unsigned int isc_netscope_pton(signed int af, char *scopename, void *addr, unsigned int *zoneid)
{
  char *ep;
  unsigned int ifid;
  struct in6_addr *in6;
  unsigned int zone;
  unsigned long long int llz;
  _Bool tmp_statement_expression$1;
  _Bool tmp_if_expr$4;
  if(!(af == 10))
    return (unsigned int)25;

  else
  {
    in6 = (struct in6_addr *)addr;
    struct in6_addr *__a = (struct in6_addr *)in6;
    unsigned int return_value_htonl$2;
    return_value_htonl$2=htonl(0xffc00000);
    unsigned int return_value_htonl$3;
    return_value_htonl$3=htonl(0xfe800000);
    tmp_statement_expression$1 = (__a->__in6_u.__u6_addr32[(signed long int)0] & return_value_htonl$2) == return_value_htonl$3;
    if(tmp_statement_expression$1)
    {
      ifid=if_nametoindex((const char *)scopename);
      tmp_if_expr$4 = ifid != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      zone = (unsigned int)ifid;

    else
    {
      llz=isc_string_touint64(scopename, &ep, 10);
      if(ep == scopename)
        return (unsigned int)25;

      zone = (unsigned int)(llz & 0xffffffffUL);
      if(!((unsigned long int)zone == llz))
        return (unsigned int)25;

    }
    *zoneid = zone;
    return (unsigned int)0;
  }
}

// isc_ondestroy_init
// file ./../lib/isc/ondestroy.c line 36
void isc_ondestroy_init(struct isc_ondestroy *ondest)
{
  ondest->magic = (unsigned int)(68 << 24 | 101 << 16 | 83 << 8 | 116);
  do
  {
    ondest->events.head = (struct isc_event *)(void *)0;
    ondest->events.tail = (struct isc_event *)(void *)0;
  }
  while((_Bool)0);
}

// isc_ondestroy_notify
// file ./../lib/isc/ondestroy.c line 66
void isc_ondestroy_notify(struct isc_ondestroy *ondest, void *sender)
{
  struct isc_event *eventp;
  struct isc_task *task;
  _Bool tmp_if_expr$1;
  if(!(ondest == ((struct isc_ondestroy *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)ondest)->magic == (unsigned int)(68 << 24 | 101 << 16 | 83 << 8 | 116) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/ondestroy.c", 70, (enum anonymous$46)isc_assertiontype_require, "(((ondest) != ((void *)0)) && (((const isc__magic_t *)(ondest))->magic == ((('D') << 24 | ('e') << 16 | ('S') << 8 | ('t')))))");
    (_Bool)0;
  }
  eventp = ondest->events.head;
  for( ; !(eventp == ((struct isc_event *)NULL)); eventp = ondest->events.head)
  {

  __CPROVER_DUMP_L7:
    ;
    do
    {
      if(!(eventp->ev_link.next == ((struct isc_event *)NULL)))
        eventp->ev_link.next->ev_link.prev = eventp->ev_link.prev;

      else
      {
        if(ondest->events.tail == eventp)
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/ondestroy.c", 74, (enum anonymous$46)isc_assertiontype_insist, "(ondest->events).tail == (eventp)");
          (_Bool)0;
        }
        ondest->events.tail = eventp->ev_link.prev;
      }
      if(!(eventp->ev_link.prev == ((struct isc_event *)NULL)))
        eventp->ev_link.prev->ev_link.next = eventp->ev_link.next;

      else
      {
        if(ondest->events.head == eventp)
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/ondestroy.c", 74, (enum anonymous$46)isc_assertiontype_insist, "(ondest->events).head == (eventp)");
          (_Bool)0;
        }
        ondest->events.head = eventp->ev_link.next;
      }
      eventp->ev_link.prev = (struct isc_event *)(void *)-1;
      eventp->ev_link.next = (struct isc_event *)(void *)-1;
    }
    while((_Bool)0);
    task = (struct isc_task *)eventp->ev_sender;
    eventp->ev_sender = sender;
    isc__task_sendanddetach(&task, &eventp);
  }
}

// isc_ondestroy_register
// file ./../lib/isc/ondestroy.c line 42
unsigned int isc_ondestroy_register(struct isc_ondestroy *ondest, struct isc_task *task, struct isc_event **eventp)
{
  struct isc_event *theevent;
  struct isc_task *thetask = (struct isc_task *)(void *)0;
  _Bool tmp_if_expr$1;
  if(!(ondest == ((struct isc_ondestroy *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)ondest)->magic == (unsigned int)(68 << 24 | 101 << 16 | 83 << 8 | 116) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/ondestroy.c", 48, (enum anonymous$46)isc_assertiontype_require, "(((ondest) != ((void *)0)) && (((const isc__magic_t *)(ondest))->magic == ((('D') << 24 | ('e') << 16 | ('S') << 8 | ('t')))))");
    (_Bool)0;
  }
  if(!(task == ((struct isc_task *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/ondestroy.c", 49, (enum anonymous$46)isc_assertiontype_require, "task != ((void *)0)");
    (_Bool)0;
  }
  if(!(eventp == ((struct isc_event **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/ondestroy.c", 50, (enum anonymous$46)isc_assertiontype_require, "eventp != ((void *)0)");
    (_Bool)0;
  }
  theevent = *eventp;
  if(!(theevent == ((struct isc_event *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/ondestroy.c", 54, (enum anonymous$46)isc_assertiontype_require, "theevent != ((void *)0)");
    (_Bool)0;
  }
  isc__task_attach(task, &thetask);
  theevent->ev_sender = (void *)thetask;

__CPROVER_DUMP_L15:
  ;
  do
  {
    if(!(ondest->events.tail == ((struct isc_event *)NULL)))
      ondest->events.tail->ev_link.next = theevent;

    else
      ondest->events.head = theevent;
    theevent->ev_link.prev = ondest->events.tail;
    theevent->ev_link.next = (struct isc_event *)(void *)0;
    ondest->events.tail = theevent;
  }
  while((_Bool)0);
  return (unsigned int)0;
}

// isc_random_get
// file ../lib/isc/include/isc/random.h line 45
void isc_random_get(unsigned int *val)
{
  if(!(val == ((unsigned int *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/random.c", 78, (enum anonymous$46)isc_assertiontype_require, "val != ((void *)0)");
    (_Bool)0;
  }
  initialize$link1();
  signed int return_value_rand$1;
  return_value_rand$1=rand();
  signed int return_value_rand$2;
  return_value_rand$2=rand();
  *val = (unsigned int)(return_value_rand$1 >> 4 & 0xffff) | (unsigned int)(return_value_rand$2 << 12) & 0xffff0000;
}

// isc_random_jitter
// file ./../lib/isc/random.c line 103
unsigned int isc_random_jitter(unsigned int max, unsigned int jitter)
{
  unsigned int rnd;
  if(jitter == 0u && max == 0u || !(jitter >= max))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/random.c", 106, (enum anonymous$46)isc_assertiontype_require, "jitter < max || (jitter == 0 && max == 0)");
    (_Bool)0;
  }
  if(jitter == 0u)
    return max;

  else
  {
    isc_random_get(&rnd);
    return max - rnd % jitter;
  }
}

// isc_random_seed
// file ./../lib/isc/random.c line 64
void isc_random_seed(unsigned int seed)
{
  initialize$link1();
  srand(seed);
}

// isc_result_register
// file ./../lib/isc/result.c line 208
unsigned int isc_result_register(unsigned int base, unsigned int nresults, const char **txt, struct isc_msgcat *msgcat, signed int set)
{
  initialize$link2();
  unsigned int return_value_register_table$1;
  return_value_register_table$1=register_table(base, nresults, txt, msgcat, set);
  return return_value_register_table$1;
}

// isc_result_totext
// file ../lib/isc/include/isc/result.h line 98
const char * isc_result_totext(unsigned int result)
{
  struct resulttable *table;
  const char *txt;
  const char *default_text;
  signed int idx;
  initialize$link2();
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/result.c", 179, "((pthread_mutex_lock(((&lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  txt = (const char *)(void *)0;
  table = tables.head;
  for( ; !(table == ((struct resulttable *)NULL)); table = table->link.next)
    if(result >= table->base)
    {
      if(table->last >= result)
      {
        idx = (signed int)(result - table->base);
        default_text = table->text[(signed long int)idx];
        txt=isc_msgcat_get(table->msgcat, table->set, idx + 1, default_text);
        break;
      }

    }

  if(txt == ((const char *)NULL))
    txt=isc_msgcat_get(isc_msgcat, 3, 1, "(result code text not available)");

  do
  {
    signed int return_value_pthread_mutex_unlock$2;
    return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&lock);
    if(return_value_pthread_mutex_unlock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/result.c", 202, "((pthread_mutex_unlock(((&lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  return txt;
}

// isc_sha1_final
// file ./../lib/isc/sha1.c line 325
void isc_sha1_final(struct anonymous$62 *context, unsigned char *digest)
{
  unsigned int i;
  unsigned char finalcount[8l];
  if(!(digest == ((unsigned char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sha1.c", 329, (enum anonymous$46)isc_assertiontype_insist, "digest != 0");
    (_Bool)0;
  }
  if(!(context == ((struct anonymous$62 *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sha1.c", 330, (enum anonymous$46)isc_assertiontype_insist, "context != 0");
    (_Bool)0;
  }
  i = (unsigned int)0;
  for( ; !(i >= 8u); i = i + 1u)
    finalcount[(signed long int)i] = (unsigned char)(context->count[(signed long int)(i >= (unsigned int)4 ? 0 : 1)] >> ((unsigned int)3 - (i & (unsigned int)3)) * (unsigned int)8 & (unsigned int)255);
  isc_sha1_update(context, &final_200, (unsigned int)1);
  while(!((504u & context->count[0l]) == 448u))
    isc_sha1_update(context, &final_0, (unsigned int)1);
  isc_sha1_update(context, finalcount, (unsigned int)8);
  if(!(digest == ((unsigned char *)NULL)))
  {
    i = (unsigned int)0;
    for( ; !(i >= 20u); i = i + 1u)
      digest[(signed long int)i] = (unsigned char)(context->state[(signed long int)(i >> 2)] >> ((unsigned int)3 - (i & (unsigned int)3)) * (unsigned int)8 & (unsigned int)255);
  }

  memset((void *)context, 0, sizeof(struct anonymous$62) /*92ul*/ );
}

// isc_sha1_init
// file ./../lib/isc/sha1.c line 268
void isc_sha1_init(struct anonymous$62 *context)
{
  if(!(context == ((struct anonymous$62 *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sha1.c", 270, (enum anonymous$46)isc_assertiontype_insist, "context != ((void *)0)");
    (_Bool)0;
  }
  context->state[(signed long int)0] = (unsigned int)0x67452301;
  context->state[(signed long int)1] = 0xEFCDAB89;
  context->state[(signed long int)2] = 0x98BADCFE;
  context->state[(signed long int)3] = (unsigned int)0x10325476;
  context->state[(signed long int)4] = 0xC3D2E1F0;
  context->count[(signed long int)0] = (unsigned int)0;
  context->count[(signed long int)1] = (unsigned int)0;
}

// isc_sha1_invalidate
// file ./../lib/isc/sha1.c line 283
void isc_sha1_invalidate(struct anonymous$62 *context)
{
  memset((void *)context, 0, sizeof(struct anonymous$62) /*92ul*/ );
}

// isc_sha1_update
// file ./../lib/isc/sha1.c line 291
void isc_sha1_update(struct anonymous$62 *context, const unsigned char *data, unsigned int len)
{
  unsigned int i;
  unsigned int j;
  if(!(context == ((struct anonymous$62 *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sha1.c", 296, (enum anonymous$46)isc_assertiontype_insist, "context != 0");
    (_Bool)0;
  }
  if(!(data == ((const unsigned char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sha1.c", 297, (enum anonymous$46)isc_assertiontype_insist, "data != 0");
    (_Bool)0;
  }
  j = context->count[(signed long int)0];
  context->count[(signed long int)0] = context->count[(signed long int)0] + (len << 3);
  if(!(context->count[0l] >= j))
    context->count[(signed long int)1] = context->count[(signed long int)1] + (len >> 29) + (unsigned int)1;

  j = j >> 3 & (unsigned int)63;
  if(j + len >= 64u)
  {
    i = (unsigned int)64 - j;
    memcpy((void *)&context->buffer[(signed long int)j], (const void *)data, (unsigned long int)i);
    transform$link1(context->state, context->buffer);
    for( ; !(63u + i >= len); i = i + (unsigned int)64)
      transform$link1(context->state, &data[(signed long int)i]);
    j = (unsigned int)0;
  }

  else
    i = (unsigned int)0;
  memcpy((void *)&context->buffer[(signed long int)j], (const void *)&data[(signed long int)i], (unsigned long int)(len - i));
}

// isc_sockaddr_any
// file ./../lib/isc/sockaddr.c line 256
void isc_sockaddr_any(struct isc_sockaddr *sockaddr)
{
  memset((void *)sockaddr, 0, sizeof(struct isc_sockaddr) /*48ul*/ );
  sockaddr->type.sin.sin_family = (unsigned short int)2;
  sockaddr->type.sin.sin_addr.s_addr = (unsigned int)0x00000000;
  sockaddr->type.sin.sin_port = (unsigned short int)0;
  sockaddr->length = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  do
  {
    sockaddr->link.prev = (struct isc_sockaddr *)(void *)-1;
    sockaddr->link.next = (struct isc_sockaddr *)(void *)-1;
  }
  while((_Bool)0);
}

// isc_sockaddr_any6
// file ./../lib/isc/sockaddr.c line 270
void isc_sockaddr_any6(struct isc_sockaddr *sockaddr)
{
  memset((void *)sockaddr, 0, sizeof(struct isc_sockaddr) /*48ul*/ );
  sockaddr->type.sin6.sin6_family = (unsigned short int)10;
  sockaddr->type.sin6.sin6_addr = in6addr_any;
  sockaddr->type.sin6.sin6_port = (unsigned short int)0;
  sockaddr->length = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
  do
  {
    sockaddr->link.prev = (struct isc_sockaddr *)(void *)-1;
    sockaddr->link.next = (struct isc_sockaddr *)(void *)-1;
  }
  while((_Bool)0);
}

// isc_sockaddr_anyofpf
// file ./../lib/isc/sockaddr.c line 299
void isc_sockaddr_anyofpf(struct isc_sockaddr *sockaddr, signed int pf)
{
  switch(pf)
  {
    case 2:
    {
      isc_sockaddr_any(sockaddr);
      break;
    }
    case 10:
    {
      isc_sockaddr_any6(sockaddr);
      break;
    }
    default:
    {
      isc_assertion_failed("./../lib/isc/sockaddr.c", 308, (enum anonymous$46)isc_assertiontype_insist, "0");
      (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
    }
  }
}

// isc_sockaddr_compare
// file ./../lib/isc/sockaddr.c line 50
enum anonymous$11 isc_sockaddr_compare(const struct isc_sockaddr *a, const struct isc_sockaddr *b, unsigned int flags)
{
  if(!(a == ((const struct isc_sockaddr *)NULL)) && !(b == ((const struct isc_sockaddr *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sockaddr.c", 53, (enum anonymous$46)isc_assertiontype_require, "a != ((void *)0) && b != ((void *)0)");
    (_Bool)0;
  }
  signed int return_value_memcmp$1;
  signed int return_value_memcmp$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  if(!(a->length == b->length))
    return (enum anonymous$11)isc_boolean_false;

  else
    if(!(a->type.sa.sa_family == b->type.sa.sa_family))
      return (enum anonymous$11)isc_boolean_false;

    else
    {
      switch((signed int)a->type.sa.sa_family)
      {
        case 2:
        {
          if(!((1u & flags) == 0u))
          {
            return_value_memcmp$1=memcmp((const void *)&a->type.sin.sin_addr, (const void *)&b->type.sin.sin_addr, sizeof(struct in_addr) /*4ul*/ );
            if(!(return_value_memcmp$1 == 0))
              return (enum anonymous$11)isc_boolean_false;

          }

          if(!((2u & flags) == 0u))
          {
            if(!(a->type.sin.sin_port == b->type.sin.sin_port))
              return (enum anonymous$11)isc_boolean_false;

          }

          break;
        }
        case 10:
        {
          if(!((1u & flags) == 0u))
          {
            return_value_memcmp$2=memcmp((const void *)&a->type.sin6.sin6_addr, (const void *)&b->type.sin6.sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
            if(!(return_value_memcmp$2 == 0))
              return (enum anonymous$11)isc_boolean_false;

          }

          if(!((4u & flags) == 0u))
          {
            if(!(a->type.sin6.sin6_scope_id == b->type.sin6.sin6_scope_id))
            {
              if((8u & flags) == 0u)
                tmp_if_expr$4 = (_Bool)1;

              else
              {
                if(!(a->type.sin6.sin6_scope_id == 0u))
                  tmp_if_expr$3 = b->type.sin6.sin6_scope_id != (unsigned int)0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$3 = (_Bool)0;
                tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$4)
                return (enum anonymous$11)isc_boolean_false;

            }

          }

          if(!((2u & flags) == 0u))
          {
            if(!(a->type.sin6.sin6_port == b->type.sin6.sin6_port))
              return (enum anonymous$11)isc_boolean_false;

          }

          break;
        }
        default:
        {
          signed int return_value_memcmp$5;
          return_value_memcmp$5=memcmp((const void *)&a->type, (const void *)&b->type, (unsigned long int)a->length);
          if(!(return_value_memcmp$5 == 0))
            return (enum anonymous$11)isc_boolean_false;

        }
      }
      return (enum anonymous$11)isc_boolean_true;
    }
}

// isc_sockaddr_eqaddr
// file ./../lib/isc/sockaddr.c line 44
enum anonymous$11 isc_sockaddr_eqaddr(const struct isc_sockaddr *a, const struct isc_sockaddr *b)
{
  enum anonymous$11 return_value_isc_sockaddr_compare$1;
  return_value_isc_sockaddr_compare$1=isc_sockaddr_compare(a, b, (unsigned int)(0x0001 | 0x0004));
  return return_value_isc_sockaddr_compare$1;
}

// isc_sockaddr_eqaddrprefix
// file ./../lib/isc/sockaddr.c line 104
enum anonymous$11 isc_sockaddr_eqaddrprefix(const struct isc_sockaddr *a, const struct isc_sockaddr *b, unsigned int prefixlen)
{
  struct isc_netaddr na;
  struct isc_netaddr nb;
  isc_netaddr_fromsockaddr(&na, a);
  isc_netaddr_fromsockaddr(&nb, b);
  enum anonymous$11 return_value_isc_netaddr_eqprefix$1;
  return_value_isc_netaddr_eqprefix$1=isc_netaddr_eqprefix(&na, &nb, prefixlen);
  return return_value_isc_netaddr_eqprefix$1;
}

// isc_sockaddr_equal
// file ./../lib/isc/sockaddr.c line 37
enum anonymous$11 isc_sockaddr_equal(const struct isc_sockaddr *a, const struct isc_sockaddr *b)
{
  enum anonymous$11 return_value_isc_sockaddr_compare$1;
  return_value_isc_sockaddr_compare$1=isc_sockaddr_compare(a, b, (unsigned int)(0x0001 | 0x0002 | 0x0004));
  return return_value_isc_sockaddr_compare$1;
}

// isc_sockaddr_format
// file ./../lib/isc/sockaddr.c line 181
void isc_sockaddr_format(const struct isc_sockaddr *sa, char *array, unsigned int size)
{
  unsigned int result;
  struct isc_buffer buf;
  if(!(size == 0U))
  {
    isc__buffer_init(&buf, (const void *)array, size);
    result=isc_sockaddr_totext(sa, &buf);
    if(!(result == 0u))
    {
      const char *return_value_isc_msgcat_get$1;
      return_value_isc_msgcat_get$1=isc_msgcat_get(isc_msgcat, 12, 1001, "unknown address, family");
      snprintf(array, (unsigned long int)size, "<%s %u>", return_value_isc_msgcat_get$1, sa->type.sa.sa_family);
      array[(signed long int)(size - (unsigned int)1)] = (char)0;
    }

  }

}

// isc_sockaddr_fromin
// file ./../lib/isc/sockaddr.c line 284
void isc_sockaddr_fromin(struct isc_sockaddr *sockaddr, struct in_addr *ina, unsigned short int port)
{
  memset((void *)sockaddr, 0, sizeof(struct isc_sockaddr) /*48ul*/ );
  sockaddr->type.sin.sin_family = (unsigned short int)2;
  sockaddr->type.sin.sin_addr = *ina;
  sockaddr->type.sin.sin_port=htons(port);
  sockaddr->length = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  do
  {
    sockaddr->link.prev = (struct isc_sockaddr *)(void *)-1;
    sockaddr->link.next = (struct isc_sockaddr *)(void *)-1;
  }
  while((_Bool)0);
}

// isc_sockaddr_fromin6
// file ./../lib/isc/sockaddr.c line 313
void isc_sockaddr_fromin6(struct isc_sockaddr *sockaddr, struct in6_addr *ina6, unsigned short int port)
{
  memset((void *)sockaddr, 0, sizeof(struct isc_sockaddr) /*48ul*/ );
  sockaddr->type.sin6.sin6_family = (unsigned short int)10;
  sockaddr->type.sin6.sin6_addr = *ina6;
  sockaddr->type.sin6.sin6_port=htons(port);
  sockaddr->length = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
  do
  {
    sockaddr->link.prev = (struct isc_sockaddr *)(void *)-1;
    sockaddr->link.next = (struct isc_sockaddr *)(void *)-1;
  }
  while((_Bool)0);
}

// isc_sockaddr_fromnetaddr
// file ./../lib/isc/sockaddr.c line 373
void isc_sockaddr_fromnetaddr(struct isc_sockaddr *sockaddr, const struct isc_netaddr *na, unsigned short int port)
{
  memset((void *)sockaddr, 0, sizeof(struct isc_sockaddr) /*48ul*/ );
  sockaddr->type.sin.sin_family = (unsigned short int)(signed short int)na->family;
  switch(na->family)
  {
    case (unsigned int)2:
    {
      sockaddr->length = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      sockaddr->type.sin.sin_addr = na->type.in;
      sockaddr->type.sin.sin_port=htons(port);
      break;
    }
    case (unsigned int)10:
    {
      sockaddr->length = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
      memcpy((void *)&sockaddr->type.sin6.sin6_addr, (const void *)&na->type.in6, (unsigned long int)16);
      sockaddr->type.sin6.sin6_scope_id=isc_netaddr_getzone(na);
      sockaddr->type.sin6.sin6_port=htons(port);
      break;
    }
    default:
    {
      isc_assertion_failed("./../lib/isc/sockaddr.c", 399, (enum anonymous$46)isc_assertiontype_insist, "0");
      (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
    }
  }
  do
  {
    sockaddr->link.prev = (struct isc_sockaddr *)(void *)-1;
    sockaddr->link.next = (struct isc_sockaddr *)(void *)-1;
  }
  while((_Bool)0);
}

// isc_sockaddr_frompath
// file ./../lib/isc/sockaddr.c line 492
unsigned int isc_sockaddr_frompath(struct isc_sockaddr *sockaddr, const char *path)
{
  (void)sockaddr;
  (void)path;
  return (unsigned int)27;
}

// isc_sockaddr_getport
// file ./../lib/isc/sockaddr.c line 424
unsigned short int isc_sockaddr_getport(const struct isc_sockaddr *sockaddr)
{
  unsigned short int port = (unsigned short int)0;
  switch((signed int)sockaddr->type.sa.sa_family)
  {
    case 2:
    {
      port=ntohs(sockaddr->type.sin.sin_port);
      break;
    }
    case 10:
    {
      port=ntohs(sockaddr->type.sin6.sin6_port);
      break;
    }
    default:
    {
      const char *return_value_isc_msgcat_get$1;
      return_value_isc_msgcat_get$1=isc_msgcat_get(isc_msgcat, 16, 1301, "unknown address family");
      isc_error_fatal("./../lib/isc/sockaddr.c", 435, "%s: %d", return_value_isc_msgcat_get$1, (signed int)sockaddr->type.sa.sa_family);
    }
  }
  return port;
}

// isc_sockaddr_hash
// file ./../lib/isc/sockaddr.c line 205
unsigned int isc_sockaddr_hash(const struct isc_sockaddr *sockaddr, enum anonymous$11 address_only)
{
  unsigned int length = (unsigned int)0;
  const unsigned char *s = (const unsigned char *)(void *)0;
  unsigned int h = (unsigned int)0;
  unsigned int g;
  unsigned int p = (unsigned int)0;
  struct in6_addr *in6;
  if(!(sockaddr == ((const struct isc_sockaddr *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sockaddr.c", 213, (enum anonymous$46)isc_assertiontype_require, "sockaddr != ((void *)0)");
    (_Bool)0;
  }
  unsigned short int return_value_ntohs$1;
  _Bool tmp_statement_expression$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_htonl$4;
  unsigned short int return_value_ntohs$6;
  switch((signed int)sockaddr->type.sa.sa_family)
  {
    case 2:
    {
      s = (const unsigned char *)&sockaddr->type.sin.sin_addr;
      return_value_ntohs$1=ntohs(sockaddr->type.sin.sin_port);
      p = (unsigned int)return_value_ntohs$1;
      length = (unsigned int)sizeof(unsigned int) /*4ul*/ ;
      break;
    }
    case 10:
    {
      in6 = &sockaddr->type.sin6.sin6_addr;
      struct in6_addr *__a = (struct in6_addr *)in6;
      if(__a->__in6_u.__u6_addr32[0l] == 0u)
        tmp_if_expr$3 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        return_value_htonl$4=htonl((unsigned int)0xffff);
        tmp_if_expr$5 = __a->__in6_u.__u6_addr32[(signed long int)2] == return_value_htonl$4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      tmp_statement_expression$2 = tmp_if_expr$5;
      if(tmp_statement_expression$2)
      {
        s = (const unsigned char *)&in6 + (signed long int)12;
        length = (unsigned int)sizeof(unsigned int) /*4ul*/ ;
      }

      else
      {
        s = (const unsigned char *)in6;
        length = (unsigned int)sizeof(struct in6_addr) /*16ul*/ ;
      }
      return_value_ntohs$6=ntohs(sockaddr->type.sin6.sin6_port);
      p = (unsigned int)return_value_ntohs$6;
      break;
    }
    default:
    {
      const char *return_value_isc_msgcat_get$7;
      return_value_isc_msgcat_get$7=isc_msgcat_get(isc_msgcat, 16, 1301, "unknown address family");
      isc_error_unexpected("./../lib/isc/sockaddr.c", 233, "%s: %d", return_value_isc_msgcat_get$7, (signed int)sockaddr->type.sa.sa_family);
      s = (const unsigned char *)&sockaddr->type;
      length = sockaddr->length;
      p = (unsigned int)0;
    }
  }
  h=isc_hash_calc(s, length, (enum anonymous$11)isc_boolean_true);
  if(address_only == /*enum*/isc_boolean_false)
  {
    g=isc_hash_calc((const unsigned char *)&p, (unsigned int)sizeof(unsigned int) /*4ul*/ , (enum anonymous$11)isc_boolean_true);
    h = h ^ g;
  }

  return h;
}

// isc_sockaddr_isexperimental
// file ./../lib/isc/sockaddr.c line 459
enum anonymous$11 isc_sockaddr_isexperimental(const struct isc_sockaddr *sockaddr)
{
  struct isc_netaddr netaddr;
  if((signed int)sockaddr->type.sa.sa_family == 2)
  {
    isc_netaddr_fromsockaddr(&netaddr, sockaddr);
    enum anonymous$11 return_value_isc_netaddr_isexperimental$1;
    return_value_isc_netaddr_isexperimental$1=isc_netaddr_isexperimental(&netaddr);
    return return_value_isc_netaddr_isexperimental$1;
  }

  return (enum anonymous$11)isc_boolean_false;
}

// isc_sockaddr_islinklocal
// file ./../lib/isc/sockaddr.c line 481
enum anonymous$11 isc_sockaddr_islinklocal(const struct isc_sockaddr *sockaddr)
{
  struct isc_netaddr netaddr;
  if((signed int)sockaddr->type.sa.sa_family == 10)
  {
    isc_netaddr_fromsockaddr(&netaddr, sockaddr);
    enum anonymous$11 return_value_isc_netaddr_islinklocal$1;
    return_value_isc_netaddr_islinklocal$1=isc_netaddr_islinklocal(&netaddr);
    return return_value_isc_netaddr_islinklocal$1;
  }

  return (enum anonymous$11)isc_boolean_false;
}

// isc_sockaddr_ismulticast
// file ./../lib/isc/sockaddr.c line 447
enum anonymous$11 isc_sockaddr_ismulticast(const struct isc_sockaddr *sockaddr)
{
  struct isc_netaddr netaddr;
  _Bool tmp_if_expr$2;
  if((signed int)sockaddr->type.sa.sa_family == 2)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)sockaddr->type.sa.sa_family == 10 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    isc_netaddr_fromsockaddr(&netaddr, sockaddr);
    enum anonymous$11 return_value_isc_netaddr_ismulticast$1;
    return_value_isc_netaddr_ismulticast$1=isc_netaddr_ismulticast(&netaddr);
    return return_value_isc_netaddr_ismulticast$1;
  }

  return (enum anonymous$11)isc_boolean_false;
}

// isc_sockaddr_issitelocal
// file ./../lib/isc/sockaddr.c line 470
enum anonymous$11 isc_sockaddr_issitelocal(const struct isc_sockaddr *sockaddr)
{
  struct isc_netaddr netaddr;
  if((signed int)sockaddr->type.sa.sa_family == 10)
  {
    isc_netaddr_fromsockaddr(&netaddr, sockaddr);
    enum anonymous$11 return_value_isc_netaddr_issitelocal$1;
    return_value_isc_netaddr_issitelocal$1=isc_netaddr_issitelocal(&netaddr);
    return return_value_isc_netaddr_issitelocal$1;
  }

  return (enum anonymous$11)isc_boolean_false;
}

// isc_sockaddr_pf
// file ./../lib/isc/sockaddr.c line 345
signed int isc_sockaddr_pf(const struct isc_sockaddr *sockaddr)
{
  return (signed int)sockaddr->type.sa.sa_family;
}

// isc_sockaddr_setport
// file ./../lib/isc/sockaddr.c line 405
void isc_sockaddr_setport(struct isc_sockaddr *sockaddr, unsigned short int port)
{
  switch((signed int)sockaddr->type.sa.sa_family)
  {
    case 2:
    {
      sockaddr->type.sin.sin_port=htons(port);
      break;
    }
    case 10:
    {
      sockaddr->type.sin6.sin6_port=htons(port);
      break;
    }
    default:
    {
      const char *return_value_isc_msgcat_get$1;
      return_value_isc_msgcat_get$1=isc_msgcat_get(isc_msgcat, 16, 1301, "unknown address family");
      isc_error_fatal("./../lib/isc/sockaddr.c", 414, "%s: %d", return_value_isc_msgcat_get$1, (signed int)sockaddr->type.sa.sa_family);
    }
  }
}

// isc_sockaddr_totext
// file ./../lib/isc/sockaddr.c line 114
unsigned int isc_sockaddr_totext(const struct isc_sockaddr *sockaddr, struct isc_buffer *target)
{
  unsigned int result;
  struct isc_netaddr netaddr;
  char pbuf[(signed long int)sizeof(char [6l]) /*6l*/ ];
  unsigned int plen;
  struct isc_region avail;
  if(!(sockaddr == ((const struct isc_sockaddr *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sockaddr.c", 121, (enum anonymous$46)isc_assertiontype_require, "sockaddr != ((void *)0)");
    (_Bool)0;
  }
  unsigned short int return_value_ntohs$1;
  unsigned short int return_value_ntohs$2;
  switch((signed int)sockaddr->type.sa.sa_family)
  {
    case 2:
    {
      return_value_ntohs$1=ntohs(sockaddr->type.sin.sin_port);
      snprintf(pbuf, sizeof(char [6l]) /*6ul*/ , "%u", return_value_ntohs$1);
      break;
    }
    case 10:
    {
      return_value_ntohs$2=ntohs(sockaddr->type.sin6.sin6_port);
      snprintf(pbuf, sizeof(char [6l]) /*6ul*/ , "%u", return_value_ntohs$2);
      break;
    }
    default:
      return (unsigned int)25;
  }
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(pbuf);
  plen = (unsigned int)return_value_strlen$3;
  if(!((unsigned long int)plen >= sizeof(char [6l]) /*6ul*/ ))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sockaddr.c", 157, (enum anonymous$46)isc_assertiontype_insist, "plen < sizeof(pbuf)");
    (_Bool)0;
  }
  isc_netaddr_fromsockaddr(&netaddr, sockaddr);
  result=isc_netaddr_totext(&netaddr, target);
  if(!(result == 0u))
    return result;

  else
    if(!(target->length + -target->used >= 2u + plen))
      return (unsigned int)19;

    else
    {
      isc__buffer_putmem(target, (const unsigned char *)"#", (unsigned int)1);
      isc__buffer_putmem(target, (const unsigned char *)pbuf, plen);
      isc__buffer_availableregion(target, &avail);
      if(avail.length >= 1u)
        (_Bool)1;

      else
      {
        isc_assertion_failed("./../lib/isc/sockaddr.c", 174, (enum anonymous$46)isc_assertiontype_insist, "avail.length >= 1");
        (_Bool)0;
      }
      avail.base[(signed long int)0] = (unsigned char)0;
      return (unsigned int)0;
    }
}

// isc_sockaddr_v6fromin
// file ./../lib/isc/sockaddr.c line 328
void isc_sockaddr_v6fromin(struct isc_sockaddr *sockaddr, struct in_addr *ina, unsigned short int port)
{
  memset((void *)sockaddr, 0, sizeof(struct isc_sockaddr) /*48ul*/ );
  sockaddr->type.sin6.sin6_family = (unsigned short int)10;
  sockaddr->type.sin6.sin6_addr.__in6_u.__u6_addr8[(signed long int)10] = (unsigned char)0xff;
  sockaddr->type.sin6.sin6_addr.__in6_u.__u6_addr8[(signed long int)11] = (unsigned char)0xff;
  memcpy((void *)&sockaddr->type.sin6.sin6_addr.__in6_u.__u6_addr8[(signed long int)12], (const void *)ina, (unsigned long int)4);
  sockaddr->type.sin6.sin6_port=htons(port);
  sockaddr->length = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
  do
  {
    sockaddr->link.prev = (struct isc_sockaddr *)(void *)-1;
    sockaddr->link.next = (struct isc_sockaddr *)(void *)-1;
  }
  while((_Bool)0);
}

// isc_stdio_close
// file ./../lib/isc/unix/stdio.c line 42
unsigned int isc_stdio_close(struct _IO_FILE *f)
{
  signed int r;
  r=fclose(f);
  signed int *return_value___errno_location$1;
  unsigned int return_value_isc___errno2result$2;
  if(r == 0)
    return (unsigned int)0;

  else
  {
    return_value___errno_location$1=__errno_location();
    return_value_isc___errno2result$2=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/stdio.c", (unsigned int)49);
    return return_value_isc___errno2result$2;
  }
}

// isc_stdio_flush
// file ./../lib/isc/unix/stdio.c line 98
unsigned int isc_stdio_flush(struct _IO_FILE *f)
{
  signed int r;
  r=fflush(f);
  signed int *return_value___errno_location$1;
  unsigned int return_value_isc___errno2result$2;
  if(r == 0)
    return (unsigned int)0;

  else
  {
    return_value___errno_location$1=__errno_location();
    return_value_isc___errno2result$2=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/stdio.c", (unsigned int)105);
    return return_value_isc___errno2result$2;
  }
}

// isc_stdio_open
// file ../lib/isc/include/isc/stdio.h line 43
unsigned int isc_stdio_open(const char *filename, const char *mode, struct _IO_FILE **fp)
{
  struct _IO_FILE *f;
  f=fopen(filename, mode);
  signed int *return_value___errno_location$1;
  unsigned int return_value_isc___errno2result$2;
  if(f == ((struct _IO_FILE *)NULL))
  {
    return_value___errno_location$1=__errno_location();
    return_value_isc___errno2result$2=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/stdio.c", (unsigned int)36);
    return return_value_isc___errno2result$2;
  }

  else
  {
    *fp = f;
    return (unsigned int)0;
  }
}

// isc_stdio_read
// file ./../lib/isc/unix/stdio.c line 64
unsigned int isc_stdio_read(void *ptr, unsigned long int size, unsigned long int nmemb, struct _IO_FILE *f, unsigned long int *nret)
{
  unsigned int result = (unsigned int)0;
  unsigned long int r;
  clearerr(f);
  r=fread(ptr, size, nmemb, f);
  signed int *return_value___errno_location$1;
  if(!(r == nmemb))
  {
    signed int return_value_feof$2;
    return_value_feof$2=feof(f);
    if(!(return_value_feof$2 == 0))
      result = (unsigned int)14;

    else
    {
      return_value___errno_location$1=__errno_location();
      result=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/stdio.c", (unsigned int)74);
    }
  }

  if(!(nret == ((unsigned long int *)NULL)))
    *nret = r;

  return result;
}

// isc_stdio_seek
// file ./../lib/isc/unix/stdio.c line 53
unsigned int isc_stdio_seek(struct _IO_FILE *f, signed long int offset, signed int whence)
{
  signed int r;
  r=fseek(f, offset, whence);
  signed int *return_value___errno_location$1;
  unsigned int return_value_isc___errno2result$2;
  if(r == 0)
    return (unsigned int)0;

  else
  {
    return_value___errno_location$1=__errno_location();
    return_value_isc___errno2result$2=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/stdio.c", (unsigned int)60);
    return return_value_isc___errno2result$2;
  }
}

// isc_stdio_sync
// file ./../lib/isc/unix/stdio.c line 116
unsigned int isc_stdio_sync(struct _IO_FILE *f)
{
  signed int r;
  signed int return_value_fileno$1;
  return_value_fileno$1=fileno(f);
  r=fsync(return_value_fileno$1);
  _Bool tmp_if_expr$5;
  signed int *return_value___errno_location$4;
  if(r == 0)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value___errno_location$4=__errno_location();
    tmp_if_expr$5 = *return_value___errno_location$4 == 22 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value___errno_location$6=__errno_location();
    tmp_if_expr$7 = *return_value___errno_location$6 == 95 ? (_Bool)1 : (_Bool)0;
  }
  signed int *return_value___errno_location$2;
  unsigned int return_value_isc___errno2result$3;
  if(tmp_if_expr$7)
    return (unsigned int)0;

  else
  {
    return_value___errno_location$2=__errno_location();
    return_value_isc___errno2result$3=isc___errno2result(*return_value___errno_location$2, "./../lib/isc/unix/stdio.c", (unsigned int)127);
    return return_value_isc___errno2result$3;
  }
}

// isc_stdio_write
// file ./../lib/isc/unix/stdio.c line 82
unsigned int isc_stdio_write(const void *ptr, unsigned long int size, unsigned long int nmemb, struct _IO_FILE *f, unsigned long int *nret)
{
  unsigned int result = (unsigned int)0;
  unsigned long int r;
  clearerr(f);
  r=fwrite(ptr, size, nmemb, f);
  signed int *return_value___errno_location$1;
  if(!(r == nmemb))
  {
    return_value___errno_location$1=__errno_location();
    result=isc___errno2result(*return_value___errno_location$1, "./../lib/isc/unix/stdio.c", (unsigned int)91);
  }

  if(!(nret == ((unsigned long int *)NULL)))
    *nret = r;

  return result;
}

// isc_stdtime_get
// file ./../lib/isc/unix/stdtime.c line 66
void isc_stdtime_get(unsigned int *t)
{
  struct timeval tv;
  if(!(t == ((unsigned int *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/stdtime.c", 74, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  signed int return_value_gettimeofday$1;
  return_value_gettimeofday$1=gettimeofday(&tv, (struct timezone *)(void *)0);
  if(!(return_value_gettimeofday$1 == -1))
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/unix/stdtime.c", 76, "gettimeofday(&tv, ((void *)0)) != -1");
    (_Bool)0;
  }
  fix_tv_usec(&tv);
  if(tv.tv_usec >= 0l)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/stdtime.c", 80, (enum anonymous$46)isc_assertiontype_insist, "tv.tv_usec >= 0");
    (_Bool)0;
  }
  *t = (unsigned int)tv.tv_sec;
}

// isc_task_exiting
// file ./../lib/isc/task.c line 1725
enum anonymous$11 isc_task_exiting(struct isc_task *t)
{
  struct isc__task *task = (struct isc__task *)t;
  _Bool tmp_if_expr$1;
  if(!(task == ((struct isc__task *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)task)->magic == (unsigned int)(84 << 24 | 65 << 16 | 83 << 8 | 75) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 1728, (enum anonymous$46)isc_assertiontype_require, "(((task) != ((void *)0)) && (((const isc__magic_t *)(task))->magic == ((('T') << 24 | ('A') << 16 | ('S') << 8 | ('K')))))");
    (_Bool)0;
  }
  return (enum anonymous$11)((task->flags & (unsigned int)0x01) != (unsigned int)0);
}

// isc_thread_create
// file ../lib/isc/pthreads/include/isc/thread.h line 39
unsigned int isc_thread_create(void * (*func)(void *), void *arg, unsigned long int *thread)
{
  union pthread_attr_t attr;
  unsigned long int stacksize;
  signed int ret;
  pthread_attr_init(&attr);
  ret=pthread_attr_getstacksize(&attr, &stacksize);
  if(!(ret == 0))
    return (unsigned int)34;

  else
    if(!(stacksize >= 65536ul))
    {
      ret=pthread_attr_setstacksize(&attr, (unsigned long int)(64U * (unsigned int)1024));
      if(ret == 0)
        goto __CPROVER_DUMP_L2;

      return (unsigned int)34;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      ret=pthread_create(thread, &attr, func, arg);
      if(!(ret == 0))
        return (unsigned int)34;

      else
      {
        pthread_attr_destroy(&attr);
        return (unsigned int)0;
      }
    }
}

// isc_thread_setconcurrency
// file ../lib/isc/pthreads/include/isc/thread.h line 42
void isc_thread_setconcurrency(unsigned int level)
{
  (void)level;
}

// isc_time_add
// file ./../lib/isc/unix/time.c line 255
unsigned int isc_time_add(const struct isc_time *t, const struct isc_interval *i, struct isc_time *result)
{
  if(!(i == ((const struct isc_interval *)NULL)) && !(result == ((struct isc_time *)NULL)) && !(t == ((const struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 257, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0) && i != ((void *)0) && result != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(t->nanoseconds >= 1000000000u))
    tmp_if_expr$1 = i->nanoseconds < (unsigned int)1000000000 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 258, (enum anonymous$46)isc_assertiontype_insist, "t->nanoseconds < 1000000000 && i->nanoseconds < 1000000000");
    (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(t->seconds >= 2147483648u)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = i->seconds > (unsigned int)0x7fffffff ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    if(!((signed long int)i->seconds + (signed long long int)t->seconds >= 4294967296l))
      goto __CPROVER_DUMP_L11;

    return (unsigned int)41;
  }

  else
  {

  __CPROVER_DUMP_L11:
    ;
    result->seconds = t->seconds + i->seconds;
    result->nanoseconds = t->nanoseconds + i->nanoseconds;
    if(result->nanoseconds >= 1000000000u)
    {
      result->seconds = result->seconds + 1u;
      result->nanoseconds = result->nanoseconds - (unsigned int)1000000000;
    }

    return (unsigned int)0;
  }
}

// isc_time_compare
// file ../lib/isc/unix/include/isc/time.h line 179
signed int isc_time_compare(const struct isc_time *t1, const struct isc_time *t2)
{
  if(!(t1 == ((const struct isc_time *)NULL)) && !(t2 == ((const struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 240, (enum anonymous$46)isc_assertiontype_require, "t1 != ((void *)0) && t2 != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(t1->nanoseconds >= 1000000000u))
    tmp_if_expr$1 = t2->nanoseconds < (unsigned int)1000000000 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 241, (enum anonymous$46)isc_assertiontype_insist, "t1->nanoseconds < 1000000000 && t2->nanoseconds < 1000000000");
    (_Bool)0;
  }
  if(!(t1->seconds >= t2->seconds))
    return -1;

  else
    if(!(t2->seconds >= t1->seconds))
      return 1;

    else
      if(!(t1->nanoseconds >= t2->nanoseconds))
        return -1;

      else
        if(!(t2->nanoseconds >= t1->nanoseconds))
          return 1;

        else
          return 0;
}

// isc_time_formatISO8601
// file ./../lib/isc/unix/time.c line 411
void isc_time_formatISO8601(const struct isc_time *t, char *buf, unsigned int len)
{
  signed long int isc_time_formatISO8601$$1$$now;
  unsigned int flen;
  if(len >= 1u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 415, (enum anonymous$46)isc_assertiontype_require, "len > 0");
    (_Bool)0;
  }
  isc_time_formatISO8601$$1$$now = (signed long int)t->seconds;
  struct tm *return_value_gmtime$1;
  return_value_gmtime$1=gmtime(&isc_time_formatISO8601$$1$$now);
  unsigned long int return_value_strftime$2;
  return_value_strftime$2=strftime(buf, (unsigned long int)len, "%Y-%m-%dT%H:%M:%SZ", return_value_gmtime$1);
  flen = (unsigned int)return_value_strftime$2;
  if(!(flen >= len))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 419, (enum anonymous$46)isc_assertiontype_insist, "flen < len");
    (_Bool)0;
  }
}

// isc_time_formathttptimestamp
// file ./../lib/isc/unix/time.c line 399
void isc_time_formathttptimestamp(const struct isc_time *t, char *buf, unsigned int len)
{
  signed long int isc_time_formathttptimestamp$$1$$now;
  unsigned int flen;
  if(len >= 1u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 403, (enum anonymous$46)isc_assertiontype_require, "len > 0");
    (_Bool)0;
  }
  isc_time_formathttptimestamp$$1$$now = (signed long int)t->seconds;
  struct tm *return_value_gmtime$1;
  return_value_gmtime$1=gmtime(&isc_time_formathttptimestamp$$1$$now);
  unsigned long int return_value_strftime$2;
  return_value_strftime$2=strftime(buf, (unsigned long int)len, "%a, %d %b %Y %H:%M:%S GMT", return_value_gmtime$1);
  flen = (unsigned int)return_value_strftime$2;
  if(!(flen >= len))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 407, (enum anonymous$46)isc_assertiontype_insist, "flen < len");
    (_Bool)0;
  }
}

// isc_time_formattimestamp
// file ../lib/isc/unix/include/isc/time.h line 291
void isc_time_formattimestamp(const struct isc_time *t, char *buf, unsigned int len)
{
  signed long int isc_time_formattimestamp$$1$$now;
  unsigned int flen;
  if(len >= 1u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 386, (enum anonymous$46)isc_assertiontype_require, "len > 0");
    (_Bool)0;
  }
  isc_time_formattimestamp$$1$$now = (signed long int)t->seconds;
  struct tm *return_value_localtime$1;
  return_value_localtime$1=localtime(&isc_time_formattimestamp$$1$$now);
  unsigned long int return_value_strftime$2;
  return_value_strftime$2=strftime(buf, (unsigned long int)len, "%d-%b-%Y %X", return_value_localtime$1);
  flen = (unsigned int)return_value_strftime$2;
  if(!(flen >= len))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 390, (enum anonymous$46)isc_assertiontype_insist, "flen < len");
    (_Bool)0;
  }
  if(!(flen == 0u))
    snprintf(buf + (signed long int)flen, (unsigned long int)(len - flen), ".%03u", t->nanoseconds / (unsigned int)1000000);

  else
    snprintf(buf, (unsigned long int)len, "99-Bad-9999 99:99:99.999");
}

// isc_time_isepoch
// file ./../lib/isc/unix/time.c line 134
enum anonymous$11 isc_time_isepoch(const struct isc_time *t)
{
  if(!(t == ((const struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 135, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  if(!(t->nanoseconds >= 1000000000u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 136, (enum anonymous$46)isc_assertiontype_insist, "t->nanoseconds < 1000000000");
    (_Bool)0;
  }
  if(t->seconds == 0u)
  {
    if(!(t->nanoseconds == 0u))
      goto __CPROVER_DUMP_L7;

    return (enum anonymous$11)isc_boolean_true;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    return (enum anonymous$11)isc_boolean_false;
  }
}

// isc_time_microdiff
// file ./../lib/isc/unix/time.c line 305
unsigned long long int isc_time_microdiff(const struct isc_time *t1, const struct isc_time *t2)
{
  unsigned long long int i1;
  unsigned long long int i2;
  unsigned long long int i3;
  if(!(t1 == ((const struct isc_time *)NULL)) && !(t2 == ((const struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 308, (enum anonymous$46)isc_assertiontype_require, "t1 != ((void *)0) && t2 != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(t1->nanoseconds >= 1000000000u))
    tmp_if_expr$1 = t2->nanoseconds < (unsigned int)1000000000 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 309, (enum anonymous$46)isc_assertiontype_insist, "t1->nanoseconds < 1000000000 && t2->nanoseconds < 1000000000");
    (_Bool)0;
  }
  i1 = (unsigned long long int)t1->seconds * (unsigned long int)1000000000 + (unsigned long int)t1->nanoseconds;
  i2 = (unsigned long long int)t2->seconds * (unsigned long int)1000000000 + (unsigned long int)t2->nanoseconds;
  if(i2 >= i1)
    return (unsigned long long int)0;

  else
  {
    i3 = i1 - i2;
    i3 = i3 / (unsigned long long int)1000;
    return i3;
  }
}

// isc_time_nanoseconds
// file ../lib/isc/unix/include/isc/time.h line 274
unsigned int isc_time_nanoseconds(const struct isc_time *t)
{
  if(!(t == ((const struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 374, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  if(!(t->nanoseconds >= 1000000000u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 376, (enum anonymous$46)isc_assertiontype_ensure, "t->nanoseconds < 1000000000");
    (_Bool)0;
  }
  return (unsigned int)t->nanoseconds;
}

// isc_time_now
// file ../lib/isc/unix/include/isc/time.h line 133
unsigned int isc_time_now(struct isc_time *t)
{
  struct timeval tv;
  char strbuf[128l];
  if(!(t == ((struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 150, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  signed int return_value_gettimeofday$2;
  return_value_gettimeofday$2=gettimeofday(&tv, (struct timezone *)(void *)0);
  if(return_value_gettimeofday$2 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    isc__strerror(*return_value___errno_location$1, strbuf, sizeof(char [128l]) /*128ul*/ );
    isc_error_unexpected("./../lib/isc/unix/time.c", 154, "%s", (const void *)strbuf);
    return (unsigned int)34;
  }

  fix_tv_usec$link1(&tv);
  if(!(tv.tv_sec >= 0l))
    return (unsigned int)34;

  else
    if(!(((4294967295l | tv.tv_sec) ^ 4294967295l) == 0l))
      return (unsigned int)41;

    else
    {
      t->seconds = (unsigned int)tv.tv_sec;
      t->nanoseconds = (unsigned int)(tv.tv_usec * (signed long int)1000);
      return (unsigned int)0;
    }
}

// isc_time_nowplusinterval
// file ./../lib/isc/unix/time.c line 188
unsigned int isc_time_nowplusinterval(struct isc_time *t, const struct isc_interval *i)
{
  struct timeval tv;
  char strbuf[128l];
  if(!(t == ((struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 192, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  if(!(i == ((const struct isc_interval *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 193, (enum anonymous$46)isc_assertiontype_require, "i != ((void *)0)");
    (_Bool)0;
  }
  if(!(i->nanoseconds >= 1000000000u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 194, (enum anonymous$46)isc_assertiontype_insist, "i->nanoseconds < 1000000000");
    (_Bool)0;
  }
  signed int return_value_gettimeofday$2;
  return_value_gettimeofday$2=gettimeofday(&tv, (struct timezone *)(void *)0);
  if(return_value_gettimeofday$2 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    isc__strerror(*return_value___errno_location$1, strbuf, sizeof(char [128l]) /*128ul*/ );
    isc_error_unexpected("./../lib/isc/unix/time.c", 198, "%s", (const void *)strbuf);
    return (unsigned int)34;
  }

  fix_tv_usec$link1(&tv);
  _Bool tmp_if_expr$3;
  if(!(tv.tv_sec >= 0l))
    return (unsigned int)34;

  else
  {
    if(tv.tv_sec >= 2147483648l)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = i->seconds > (unsigned int)0x7fffffff ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      if(!(tv.tv_sec + (signed long int)i->seconds >= 4294967296l))
        goto __CPROVER_DUMP_L14;

      return (unsigned int)41;
    }

    else
    {

    __CPROVER_DUMP_L14:
      ;
      t->seconds = (unsigned int)(tv.tv_sec + (signed long int)i->seconds);
      t->nanoseconds = (unsigned int)(tv.tv_usec * (signed long int)1000 + (signed long int)i->nanoseconds);
      if(t->nanoseconds >= 1000000000u)
      {
        t->seconds = t->seconds + 1u;
        t->nanoseconds = t->nanoseconds - (unsigned int)1000000000;
      }

      return (unsigned int)0;
    }
  }
}

// isc_time_seconds
// file ../lib/isc/unix/include/isc/time.h line 241
unsigned int isc_time_seconds(const struct isc_time *t)
{
  if(!(t == ((const struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 329, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  if(!(t->nanoseconds >= 1000000000u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 330, (enum anonymous$46)isc_assertiontype_insist, "t->nanoseconds < 1000000000");
    (_Bool)0;
  }
  return (unsigned int)t->seconds;
}

// isc_time_secondsastimet
// file ../lib/isc/unix/include/isc/time.h line 251
unsigned int isc_time_secondsastimet(const struct isc_time *t, signed long int *secondsp)
{
  signed long int seconds;
  if(!(t == ((const struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 339, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  if(!(t->nanoseconds >= 1000000000u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 340, (enum anonymous$46)isc_assertiontype_insist, "t->nanoseconds < 1000000000");
    (_Bool)0;
  }
  seconds = (signed long int)t->seconds;
  if(t->seconds >= 2147483648u)
  {
    if(seconds >= 2147483648l)
      goto __CPROVER_DUMP_L7;

    return (unsigned int)41;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    *secondsp = seconds;
    return (unsigned int)0;
  }
}

// isc_time_set
// file ../lib/isc/unix/include/isc/time.h line 91
void isc_time_set(struct isc_time *t, unsigned int seconds, unsigned int nanoseconds)
{
  if(!(t == ((struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 118, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  if(!(nanoseconds >= 1000000000u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 119, (enum anonymous$46)isc_assertiontype_require, "nanoseconds < 1000000000");
    (_Bool)0;
  }
  t->seconds = seconds;
  t->nanoseconds = nanoseconds;
}

// isc_time_settoepoch
// file ./../lib/isc/unix/time.c line 126
void isc_time_settoepoch(struct isc_time *t)
{
  if(!(t == ((struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 127, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0)");
    (_Bool)0;
  }
  t->seconds = (unsigned int)0;
  t->nanoseconds = (unsigned int)0;
}

// isc_time_subtract
// file ../lib/isc/unix/include/isc/time.h line 211
unsigned int isc_time_subtract(const struct isc_time *t, const struct isc_interval *i, struct isc_time *result)
{
  if(!(i == ((const struct isc_interval *)NULL)) && !(result == ((struct isc_time *)NULL)) && !(t == ((const struct isc_time *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 284, (enum anonymous$46)isc_assertiontype_require, "t != ((void *)0) && i != ((void *)0) && result != ((void *)0)");
    (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  if(!(t->nanoseconds >= 1000000000u))
    tmp_if_expr$1 = i->nanoseconds < (unsigned int)1000000000 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/unix/time.c", 285, (enum anonymous$46)isc_assertiontype_insist, "t->nanoseconds < 1000000000 && i->nanoseconds < 1000000000");
    (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(!(t->seconds >= i->seconds))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if(t->seconds == i->seconds)
      tmp_if_expr$2 = t->nanoseconds < i->nanoseconds ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    return (unsigned int)41;

  else
  {
    result->seconds = t->seconds - i->seconds;
    if(t->nanoseconds >= i->nanoseconds)
      result->nanoseconds = t->nanoseconds - i->nanoseconds;

    else
    {
      result->nanoseconds = ((unsigned int)1000000000 - i->nanoseconds) + t->nanoseconds;
      result->seconds = result->seconds - 1u;
    }
    return (unsigned int)0;
  }
}

// isocal_date_to_ntp
// file ntp_calendar.c line 1791
extern unsigned int isocal_date_to_ntp(struct isodate *id)
{
  union anonymous$44 return_value_isocal_date_to_ntp64$1;
  return_value_isocal_date_to_ntp64$1=isocal_date_to_ntp64(id);
  return return_value_isocal_date_to_ntp64$1.d_s.lo;
}

// isocal_date_to_ntp64
// file ntp_calendar.c line 1775
extern union anonymous$44 isocal_date_to_ntp64(struct isodate *id)
{
  signed int weeks;
  signed int days;
  signed int secs;
  signed int return_value_isocal_weeks_in_years$1;
  return_value_isocal_weeks_in_years$1=isocal_weeks_in_years((signed int)id->year - 1);
  weeks = (return_value_isocal_weeks_in_years$1 + (signed int)id->week) - 1;
  days = weeks * 7 + (signed int)id->weekday;
  secs=ntpcal_etime_to_seconds((signed int)id->hour, (signed int)id->minute, (signed int)id->second);
  union anonymous$44 return_value_ntpcal_dayjoin$2;
  return_value_ntpcal_dayjoin$2=ntpcal_dayjoin(days - 693596, secs);
  return return_value_ntpcal_dayjoin$2;
}

// isocal_ntp64_to_date
// file ntp_calendar.c line 1713
extern signed int isocal_ntp64_to_date(struct isodate *id, const union anonymous$44 *ntp)
{
  struct anonymous$61 ds;
  signed int ts[3l];
  unsigned int uw;
  unsigned int ud;
  unsigned int sflag;
  ds=ntpcal_daysplit(ntp);
  signed int return_value_priv_timesplit$1;
  return_value_priv_timesplit$1=priv_timesplit(ts, ds.lo);
  ds.hi = ds.hi + return_value_priv_timesplit$1;
  id->hour = (unsigned char)ts[(signed long int)0];
  id->minute = (unsigned char)ts[(signed long int)1];
  id->second = (unsigned char)ts[(signed long int)2];
  ds.hi = ds.hi + (693596 - 1);
  sflag=int32_sflag(ds.hi);
  ud=int32_to_uint32_2cpl(ds.hi);
  uw = sflag ^ (sflag ^ ud) / (unsigned int)7;
  ud = ud - uw * (unsigned int)7;
  ds.hi=uint32_2cpl_to_int32(uw);
  ds.lo = (signed int)ud;
  id->weekday = (unsigned char)((signed int)(unsigned char)ds.lo + 1);
  ds=isocal_split_eraweeks(ds.hi);
  id->year = (unsigned short int)((signed int)(unsigned short int)ds.hi + 1);
  id->week = (unsigned char)((signed int)(unsigned char)ds.lo + 1);
  return (signed int)(ds.hi >= 0 && ds.hi < 0x0000FFFF);
}

// isocal_ntp_to_date
// file ntp_calendar.c line 1754
extern signed int isocal_ntp_to_date(struct isodate *id, unsigned int ntp, const signed long int *piv)
{
  union anonymous$44 ntp64;
  ntp64=ntpcal_ntp_to_ntp(ntp, piv);
  signed int return_value_isocal_ntp64_to_date$1;
  return_value_isocal_ntp64_to_date$1=isocal_ntp64_to_date(id, &ntp64);
  return return_value_isocal_ntp64_to_date$1;
}

// isocal_split_eraweeks
// file ntp_calendar.c line 1661
extern struct anonymous$61 isocal_split_eraweeks(signed int weeks)
{
  struct anonymous$61 res;
  signed int cc;
  signed int ci;
  unsigned int sw;
  unsigned int cy;
  unsigned int Q;
  unsigned int sflag;
  sflag=int32_sflag(weeks);
  unsigned int return_value_int32_to_uint32_2cpl$1;
  return_value_int32_to_uint32_2cpl$1=int32_to_uint32_2cpl(weeks);
  sw=uint32_saturate(return_value_int32_to_uint32_2cpl$1, sflag);
  sw = 4u * sw + (unsigned int)2;
  Q = sflag ^ (sflag ^ sw) / (unsigned int)((4 * (25 * (3 * 365 + 366) - 1) + 1) / 7);
  sw = sw - Q * (unsigned int)((4 * (25 * (3 * 365 + 366) - 1) + 1) / 7);
  ci = (signed int)(Q % 4u);
  cc=uint32_2cpl_to_int32(Q);
  static const unsigned short int bctab[4l] = { (const unsigned short int)85, (const unsigned short int)130, (const unsigned short int)17, (const unsigned short int)62 };
  sw = (sw / 4u) * 157u + (unsigned int)bctab[(signed long int)ci];
  cy = sw / 8192u;
  sw = sw % 8192u;
  res.hi = (signed int)((unsigned int)(100 * cc) + cy);
  res.lo = (signed int)(sw / 157u);
  return res;
}

// isocal_weeks_in_years
// file ntp_calendar.c line 1613
extern signed int isocal_weeks_in_years(signed int years)
{
  signed int cs;
  signed int cw;
  unsigned int cc;
  unsigned int ci;
  unsigned int yu;
  unsigned int sflag;
  sflag=int32_sflag(years);
  yu=int32_to_uint32_2cpl(years);
  cc = sflag ^ (sflag ^ yu) / 100u;
  yu = yu - cc * 100u;
  ci = cc * 3u + (unsigned int)1;
  cs=uint32_2cpl_to_int32(sflag ^ (sflag ^ ci) / 4u);
  ci = ci % 4u;
  static const unsigned short int bctab[4l] = { (const unsigned short int)157, (const unsigned short int)449, (const unsigned short int)597, (const unsigned short int)889 };
  cw = (signed int)((yu * 53431u + (unsigned int)bctab[(signed long int)ci]) / 1024u);
  signed int return_value_uint32_2cpl_to_int32$1;
  return_value_uint32_2cpl_to_int32$1=uint32_2cpl_to_int32(cc);
  return return_value_uint32_2cpl_to_int32$1 * 5217 + cs + cw;
}

// k_st_flags
// file statestr.c line 422
extern const char * k_st_flags(unsigned int st)
{
  const char *return_value_decode_bitflags$1;
  return_value_decode_bitflags$1=decode_bitflags((signed int)st, " ", k_st_bits, sizeof(struct codestring [16l]) /*256ul*/  / sizeof(struct codestring) /*16ul*/ );
  return return_value_decode_bitflags$1;
}

// keytype_from_text
// file ../include/ntp_stdlib.h line 228
extern signed int keytype_from_text(const char *text, unsigned long int *pdigest_len)
{
  signed int key_type;
  unsigned int digest_len;
  const unsigned long int max_digest_len = (unsigned long int)6 * sizeof(unsigned int) /*4ul*/  - sizeof(unsigned int) /*4ul*/ ;
  unsigned char digest[64l];
  char *upcased;
  char *pch;
  struct env_md_ctx_st ctx;
  do
    if(ssl_init_done == 0)
      ssl_init();

  while((_Bool)0);
  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    upcased = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  strlcpy(upcased, text, (unsigned long int)128);
  pch = upcased;
  signed int return_value_toupper$2;
  for( ; !((signed int)*pch == 0); pch = pch + 1l)
  {
    return_value_toupper$2=toupper((signed int)(unsigned char)*pch);
    *pch = (char)return_value_toupper$2;
  }
  key_type=OBJ_sn2nid(upcased);
  signed int return_value_tolower$3;
  if(key_type == 0)
  {
    return_value_tolower$3=tolower((signed int)(unsigned char)text[(signed long int)0]);
    if(return_value_tolower$3 == 109)
      key_type = 4;

  }

  if(key_type == 0)
    return 0;

  else
  {
    if(!(pdigest_len == ((unsigned long int *)NULL)))
    {
      const char *return_value_OBJ_nid2sn$4;
      return_value_OBJ_nid2sn$4=OBJ_nid2sn(key_type);
      const struct env_md_st *return_value_EVP_get_digestbyname$5;
      return_value_EVP_get_digestbyname$5=EVP_get_digestbyname(return_value_OBJ_nid2sn$4);
      EVP_DigestInit(&ctx, return_value_EVP_get_digestbyname$5);
      EVP_DigestFinal(&ctx, digest, &digest_len);
      if(!(max_digest_len >= (unsigned long int)digest_len))
      {
        const char *return_value_keytype_name$6;
        return_value_keytype_name$6=keytype_name(key_type);
        fprintf(stderr, "key type %s %u octet digests are too big, max %lu\n", return_value_keytype_name$6, digest_len, max_digest_len);
        const char *return_value_keytype_name$7;
        return_value_keytype_name$7=keytype_name(key_type);
        msyslog(3, "key type %s %u octet digests are too big, max %lu", return_value_keytype_name$7, digest_len, max_digest_len);
        return 0;
      }

      *pdigest_len = (unsigned long int)digest_len;
    }

    return key_type;
  }
}

// keytype_name
// file ssl_init.c line 133
extern const char * keytype_name(signed int nid)
{
  const char *name;
  do
    if(ssl_init_done == 0)
      ssl_init();

  while((_Bool)0);
  name=OBJ_nid2sn(nid);
  static const char unknown_type[19l] = { '(', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'k', 'e', 'y', ' ', 't', 'y', 'p', 'e', ')', 0 };
  if(name == ((const char *)NULL))
    name = unknown_type;

  return name;
}

// lfp_stamp_to_tval
// file ../include/timevalops.h line 422
static inline struct timeval lfp_stamp_to_tval(struct anonymous$20 x, const signed long int *p)
{
  struct timeval out;
  union anonymous$44 sec;
  sec=ntpcal_ntp_to_time(x.Ul_i.Xl_ui, p);
  out.tv_usec = (signed long int)(signed int)((unsigned long int)x.l_uf * (unsigned long int)1000000 + (unsigned long int)0x80000000 >> 32);
  out.tv_sec = (signed long int)sec.q_s;
  out=normalize_tval(out);
  return out;
}

// linux_if_inet6_current
// file ./../lib/isc/unix/interfaceiter.c line 189
static unsigned int linux_if_inet6_current(struct isc_interfaceiter *iter)
{
  char address[33l];
  char name[17l];
  struct in6_addr addr6;
  unsigned int ifindex;
  signed int prefix;
  signed int scope;
  signed int flags;
  signed int res;
  unsigned int i;
  if(!(iter->valid == 0u))
    return iter->valid;

  else
    if(iter->proc == ((struct _IO_FILE *)NULL))
    {
      isc_log_write(isc_lctx, &isc_categories[(signed long int)1], &isc_modules[(signed long int)2], -4, "/proc/net/if_inet6:iter->proc == NULL");
      return (unsigned int)25;
    }

    else
    {
      res=sscanf(iter->entry, "%32[a-f0-9] %x %x %x %x %16s\n", (const void *)address, &ifindex, &prefix, &scope, &flags, (const void *)name);
      if(!(res == 6))
      {
        isc_log_write(isc_lctx, &isc_categories[(signed long int)1], &isc_modules[(signed long int)2], -4, "/proc/net/if_inet6:sscanf() -> %d (expected 6)", res);
        return (unsigned int)25;
      }

      else
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(address);
        if(!(return_value_strlen$1 == 32ul))
        {
          isc_log_write(isc_lctx, &isc_categories[(signed long int)1], &isc_modules[(signed long int)2], -4, "/proc/net/if_inet6:strlen(%s) != 32", (const void *)address);
          return (unsigned int)25;
        }

        else
          if(!((0x40 & flags) == 0))
            return (unsigned int)36;

          else
          {
            i = (unsigned int)0;
            for( ; !(i >= 16u); i = i + 1u)
            {
              unsigned char byte;
              char *return_value_strchr$2;
              static const char hex[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
              return_value_strchr$2=strchr(hex, (signed int)address[(signed long int)(i * (unsigned int)2)]);
              char *return_value_strchr$3;
              return_value_strchr$3=strchr(hex, (signed int)address[(signed long int)(i * (unsigned int)2 + (unsigned int)1)]);
              byte = (unsigned char)(return_value_strchr$2 - hex << 4 | return_value_strchr$3 - hex);
              addr6.__in6_u.__u6_addr8[(signed long int)i] = byte;
            }
            iter->current.af = (unsigned int)10;
            iter->current.flags = 0x00000001U;
            isc_netaddr_fromin6(&iter->current.address, &addr6);
            iter->current.ifindex = ifindex;
            enum anonymous$11 return_value_isc_netaddr_islinklocal$4;
            return_value_isc_netaddr_islinklocal$4=isc_netaddr_islinklocal(&iter->current.address);
            if(!(return_value_isc_netaddr_islinklocal$4 == /*enum*/isc_boolean_false))
              isc_netaddr_setzone(&iter->current.address, (unsigned int)ifindex);

            i = (unsigned int)0;
            for( ; !(i >= 16u); i = i + 1u)
              if(prefix >= 9)
              {
                addr6.__in6_u.__u6_addr8[(signed long int)i] = (unsigned char)0xff;
                prefix = prefix - 8;
              }

              else
              {
                addr6.__in6_u.__u6_addr8[(signed long int)i] = (unsigned char)(0xff << 8 - prefix & 0xff);
                prefix = 0;
              }
            isc_netaddr_fromin6(&iter->current.netmask, &addr6);
            strncpy(iter->current.name, name, sizeof(char [32l]) /*32ul*/ );
            return (unsigned int)0;
          }
      }
    }
}

// linux_if_inet6_first
// file ./../lib/isc/unix/interfaceiter.c line 170
static void linux_if_inet6_first(struct isc_interfaceiter *iter)
{
  if(!(iter->proc == ((struct _IO_FILE *)NULL)))
  {
    rewind(iter->proc);
    linux_if_inet6_next(iter);
  }

  else
    iter->valid = (unsigned int)29;
}

// linux_if_inet6_next
// file ./../lib/isc/unix/interfaceiter.c line 179
static unsigned int linux_if_inet6_next(struct isc_interfaceiter *iter)
{
  _Bool tmp_if_expr$2;
  char *return_value_fgets$1;
  if(!(iter->proc == ((struct _IO_FILE *)NULL)))
  {
    return_value_fgets$1=fgets(iter->entry, (signed int)sizeof(char [63l]) /*63ul*/ , iter->proc);
    tmp_if_expr$2 = return_value_fgets$1 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    iter->valid = (unsigned int)0;

  else
    iter->valid = (unsigned int)29;
  return iter->valid;
}

// log_maybe
// file authreadkeys.c line 86
static void log_maybe(unsigned long int *pnerr, const char *fmt, ...)
{
  void **ap;
  *pnerr = *pnerr + 1ul;
  if(nerr_loglimit >= *pnerr)
  {
    ap = (void **)&fmt;
    mvsyslog(3, fmt, ap);
    ap = ((void **)NULL);
  }

}

// lowater_additions
// file recvbuff.c line 67
extern unsigned long int lowater_additions(void)
{
  return lowater_adds;
}

// main
// file ntptime.c line 80
signed int main(signed int argc, char **argv)
{
  struct ntptimeval ntv;
  struct timeval tv;
  struct timex ntx;
  struct timex _ntx;
  signed int times[20l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  double ftemp;
  double gtemp;
  double htemp;
  signed long int time_frac;
  struct anonymous$20 ts;
  volatile unsigned int ts_mask = 0xfffff000;
  volatile unsigned int ts_roundbit = (volatile unsigned int)0x00000800;
  volatile signed int fdigits = 6;
  unsigned long int c;
  signed int ch;
  signed int errflg = 0;
  signed int cost = 0;
  volatile signed int rawtime = 0;
  bzero((void *)&ntx, sizeof(struct timex) /*208ul*/ );
  progname = argv[(signed long int)0];
  signed int return_value_atoi$1;
  signed int return_value_atoi$2;
  double return_value_atof$3;
  signed int return_value_atoi$4;
  signed int return_value_atoi$5;
  signed int return_value_atoi$6;
  do
  {
    ch=ntp_getopt(argc, argv, optargs);
    if(ch == -1)
      break;

    switch(ch)
    {
      case 77:
      {
        ntx.modes = ntx.modes | (unsigned int)0x1000;
        break;
      }
      case 78:
      {
        ntx.modes = ntx.modes | (unsigned int)0x2000;
        break;
      }
      case 84:
      {
        ntx.modes = (unsigned int)0x0080;
        return_value_atoi$1=atoi(ntp_optarg);
        ntx.constant = (signed long int)return_value_atoi$1;
        break;
      }
      case 99:
      {
        cost = cost + 1;
        break;
      }
      case 101:
      {
        ntx.modes = ntx.modes | (unsigned int)0x0008;
        return_value_atoi$2=atoi(ntp_optarg);
        ntx.esterror = (signed long int)return_value_atoi$2;
        break;
      }
      case 102:
      {
        ntx.modes = ntx.modes | (unsigned int)0x0002;
        return_value_atof$3=atof(ntp_optarg);
        ntx.freq = (signed long int)(return_value_atof$3 * (double)65536);
        break;
      }
      case 109:
      {
        ntx.modes = ntx.modes | (unsigned int)0x0004;
        return_value_atoi$4=atoi(ntp_optarg);
        ntx.maxerror = (signed long int)return_value_atoi$4;
        break;
      }
      case 111:
      {
        ntx.modes = ntx.modes | (unsigned int)0x0001;
        return_value_atoi$5=atoi(ntp_optarg);
        ntx.offset = (signed long int)return_value_atoi$5;
        break;
      }
      case 114:
      {
        rawtime = rawtime + 1;
        break;
      }
      case 115:
      {
        ntx.modes = ntx.modes | (unsigned int)0x0010;
        ntx.status=atoi(ntp_optarg);
        if(ntx.status >= 0x100 || !(ntx.status >= 0))
          errflg = errflg + 1;

        break;
      }
      case 116:
      {
        ntx.modes = ntx.modes | (unsigned int)0x0020;
        return_value_atoi$6=atoi(ntp_optarg);
        ntx.constant = (signed long int)return_value_atoi$6;
        break;
      }
      default:
        errflg = errflg + 1;
    }
  }
  while((_Bool)1);
  if(!(errflg == 0) || !(ntp_optind == argc))
  {
    fprintf(stderr, "usage: %s [-%s]\n\n%s%s%s-c\t\tdisplay the time taken to call ntp_gettime (us)\n-e esterror\testimate of the error (us)\n-f frequency\tFrequency error (-500 .. 500) (ppm)\n-h\t\tdisplay this help info\n-m maxerror\tmax possible error (us)\n-o offset\tcurrent offset (ms)\n-r\t\tprint the unix and NTP time raw\n-s status\tSet the status bits\n-t timeconstant\tlog2 of PLL time constant (0 .. %d)\n", progname, (const void *)optargs, (const void *)"-M\t\tswitch to microsecond mode\n", (const void *)"-N\t\tswitch to nanosecond mode\n", (const void *)"-T tai_offset\tset TAI offset\n", 6);
    exit(2);
  }

  newsigsys.__sigaction_handler.sa_handler = pll_trap;
  newsigsys.sa_flags = 0;
  signed int return_value_sigaction$7;
  return_value_sigaction$7=sigaction(31, &newsigsys, &sigsys);
  if(!(return_value_sigaction$7 == 0))
  {
    perror("sigaction() fails to save SIGSYS trap");
    exit(1);
  }

  signed int *return_value___errno_location$8;
  if(!(cost == 0))
  {
    signed int return_value___sigsetjmp$9;
    return_value___sigsetjmp$9=__sigsetjmp(env, 1);
    if(return_value___sigsetjmp$9 == 0)
    {
      c = (unsigned long int)0;
      for( ; !(c >= 20ul); c = c + 1ul)
      {
        status=ntp_gettime(&ntv);
        if(!(status >= 0))
        {
          return_value___errno_location$8=__errno_location();
          if(*return_value___errno_location$8 == 38)
            pll_control = pll_control - 1;

        }

        if(!(pll_control >= 0))
          break;

        times[(signed long int)c] = (signed int)ntv.time.tv_usec;
      }
    }

    if(pll_control >= 0)
    {
      printf("[ us %06d:", times[(signed long int)0]);
      c = (unsigned long int)1;
      for( ; !(c >= 20ul); c = c + 1ul)
        printf(" %d", times[(signed long int)c] - times[(signed long int)(c - (unsigned long int)1)]);
      printf(" ]\n");
    }

  }

  signed int return_value___sigsetjmp$11;
  return_value___sigsetjmp$11=__sigsetjmp(env, 1);
  signed int *return_value___errno_location$10;
  if(return_value___sigsetjmp$11 == 0)
  {
    status=ntp_gettime(&ntv);
    if(!(status >= 0))
    {
      return_value___errno_location$10=__errno_location();
      if(*return_value___errno_location$10 == 38)
        pll_control = pll_control - 1;

    }

  }

  _ntx.modes = (unsigned int)0;
  signed int return_value___sigsetjmp$13;
  return_value___sigsetjmp$13=__sigsetjmp(env, 1);
  signed int *return_value___errno_location$12;
  if(return_value___sigsetjmp$13 == 0)
  {
    status=adjtimex(&_ntx);
    if(!(status >= 0))
    {
      return_value___errno_location$12=__errno_location();
      if(*return_value___errno_location$12 == 38)
        pll_control = pll_control - 1;

    }

    flash = _ntx.status;
  }

  char *return_value_ctime$16;
  if(!(pll_control >= 0))
    printf("NTP user interface routines are not configured in this kernel.\n");

  else
  {
    status=ntp_gettime(&ntv);
    if(!(status >= 0))
      perror("ntp_gettime() call fails");

    else
    {
      const char *return_value_timex_state$14;
      return_value_timex_state$14=timex_state(status);
      printf("ntp_gettime() returns code %d (%s)\n", status, return_value_timex_state$14);
      time_frac = ntv.time.tv_usec;
      if(!((0x2000 & flash) == 0))
      {
        ntv.time.tv_usec = ntv.time.tv_usec / (signed long int)1000;
        ts_mask = 0xfffffffc;
        ts_roundbit = (volatile unsigned int)0x00000002;
        fdigits = 9;
      }

      tv.tv_sec = ntv.time.tv_sec;
      tv.tv_usec = ntv.time.tv_usec;
      do
      {
        (&ts)->Ul_i.Xl_ui = (unsigned int)(unsigned long int)(&tv)->tv_sec;
        (&ts)->l_uf = (unsigned int)((((unsigned long int)(&tv)->tv_usec << 32) + (unsigned long int)(1000000 / 2)) / (unsigned long int)1000000);
      }
      while((_Bool)0);
      ts.Ul_i.Xl_ui = ts.Ul_i.Xl_ui + (unsigned int)(719163 - 693596) * (unsigned int)(60 * 60 * 24);
      ts.l_uf = ts.l_uf + ts_roundbit;
      ts.l_uf = ts.l_uf & ts_mask;
      char *return_value_prettydate$15;
      return_value_prettydate$15=prettydate(&ts);
      printf("  time %s, (.%0*d),\n", return_value_prettydate$15, fdigits, (signed int)time_frac);
      printf("  maximum error %lu us, estimated error %lu us", (unsigned long int)ntv.maxerror, (unsigned long int)ntv.esterror);
      if(!(rawtime == 0))
      {
        return_value_ctime$16=ctime((signed long int *)&ntv.time.tv_sec);
        printf("  ntptime=%x.%x unixtime=%x.%0*d %s", (unsigned int)ts.Ul_i.Xl_ui, (unsigned int)ts.l_uf, (signed int)ntv.time.tv_sec, fdigits, (signed int)time_frac, return_value_ctime$16);
      }

      printf(", TAI offset %ld\n", (signed long int)ntv.tai);
    }
    status=adjtimex(&ntx);
    if(!(status >= 0))
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      perror(*return_value___errno_location$17 == 1 ? "Must be root to set kernel values\nntp_adjtime() call fails" : "ntp_adjtime() call fails");
    }

    else
    {
      flash = ntx.status;
      const char *return_value_timex_state$18;
      return_value_timex_state$18=timex_state(status);
      printf("ntp_adjtime() returns code %d (%s)\n", status, return_value_timex_state$18);
      const char *return_value_sprintb$19;
      return_value_sprintb$19=sprintb(ntx.modes, "\020\001OFFSET\002FREQUENCY\003MAXERROR\004ESTERROR\005STATUS\006TIMECONST\vPLL\fFLL\rMICRO\016NANO\017CLKB\020CLKA");
      printf("  modes %s,\n", return_value_sprintb$19);
      ftemp = (double)ntx.offset;
      if(!((0x2000 & flash) == 0))
        ftemp = ftemp / 1000.0;

      printf("  offset %.3f", ftemp);
      ftemp = (double)ntx.freq / (double)65536;
      printf(" us, frequency %.3f ppm, interval %d s,\n", ftemp, 1 << ntx.shift);
      printf("  maximum error %lu us, estimated error %lu us,\n", (unsigned long int)ntx.maxerror, (unsigned long int)ntx.esterror);
      const char *return_value_sprintb$20;
      return_value_sprintb$20=sprintb((unsigned int)ntx.status, "\020\001PLL\002PPSFREQ\003PPSTIME\004FLL\005INS\006DEL\aUNSYNC\bFREQHOLD\tPPSSIGNAL\nPPSJITTER\vPPSWANDER\fPPSERROR\rCLOCKERR\016NANO\017MODE\020CLK");
      printf("  status %s,\n", return_value_sprintb$20);
      ftemp = (double)ntx.tolerance / (double)65536;
      gtemp = (double)ntx.precision;
      if(!((0x2000 & flash) == 0))
        gtemp = gtemp / 1000.0;

      printf("  time constant %lu, precision %.3f us, tolerance %.0f ppm,\n", (unsigned long int)ntx.constant, gtemp, ftemp);
      if(ntx.shift == 0)
        exit(0);

      ftemp = (double)ntx.ppsfreq / (double)65536;
      gtemp = (double)ntx.stabil / (double)65536;
      htemp = (double)ntx.jitter;
      if(!((0x2000 & flash) == 0))
        htemp = htemp / 1000.0;

      printf("  pps frequency %.3f ppm, stability %.3f ppm, jitter %.3f us,\n", ftemp, gtemp, htemp);
      printf("  intervals %lu, jitter exceeded %lu, stability exceeded %lu, errors %lu.\n", (unsigned long int)ntx.calcnt, (unsigned long int)ntx.jitcnt, (unsigned long int)ntx.stbcnt, (unsigned long int)ntx.errcnt);
      return 0;
    }
  }

lexit:
  ;
  signed int return_value_sigaction$21;
  return_value_sigaction$21=sigaction(31, &sigsys, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$21 == 0))
  {
    perror("sigaction() fails to restore SIGSYS trap");
    exit(1);
  }

  exit(0);
}

// make_socket_nonblocking
// file socket.c line 128
extern void make_socket_nonblocking(signed int fd)
{
  signed int return_value_fcntl$1;
  return_value_fcntl$1=fcntl(fd, 4, 04000);
  if(!(return_value_fcntl$1 >= 0))
  {
    msyslog(3, "fcntl(O_NONBLOCK) fails on fd #%d: %m", fd);
    exit(1);
  }

}

// manage_dns_retry_interval
// file ntp_intres.c line 1040
static void manage_dns_retry_interval(signed long int *pscheduled, signed long int *pwhen, signed int *pretry, signed long int *pnext_timeslot)
{
  signed long int manage_dns_retry_interval$$1$$now;
  signed long int when;
  signed int retry;
  manage_dns_retry_interval$$1$$now=time((signed long int *)(void *)0);
  retry = *pretry;
  signed long int tmp_if_expr$1;
  if(!(*pnext_timeslot >= manage_dns_retry_interval$$1$$now + (signed long int)retry))
    tmp_if_expr$1 = manage_dns_retry_interval$$1$$now + (signed long int)retry;

  else
    tmp_if_expr$1 = *pnext_timeslot;
  when = tmp_if_expr$1;
  *pnext_timeslot = when;
  retry = 64 < retry << 1 ? 64 : retry << 1;
  *pscheduled = manage_dns_retry_interval$$1$$now;
  *pwhen = when;
  *pretry = retry;
}

// manager_free
// file ./../lib/isc/task.c line 1297
static void manager_free(struct isc__taskmgr *manager)
{
  struct isc_mem *mctx;
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1300, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  signed int return_value_pthread_cond_destroy$2;
  return_value_pthread_cond_destroy$2=pthread_cond_destroy(&manager->exclusive_granted);
  (void)(return_value_pthread_cond_destroy$2 == 0 ? 0 : 34);
  signed int return_value_pthread_cond_destroy$3;
  return_value_pthread_cond_destroy$3=pthread_cond_destroy(&manager->work_available);
  (void)(return_value_pthread_cond_destroy$3 == 0 ? 0 : 34);
  signed int return_value_pthread_cond_destroy$4;
  return_value_pthread_cond_destroy$4=pthread_cond_destroy(&manager->paused);
  (void)(return_value_pthread_cond_destroy$4 == 0 ? 0 : 34);
  (void)manager->mctx;
  free((void *)manager->threads);
  manager->common.impmagic = (unsigned int)0;
  manager->common.magic = (unsigned int)0;
  mctx = manager->mctx;
  do
  {
    signed int return_value_pthread_mutex_unlock$5;
    return_value_pthread_mutex_unlock$5=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$5 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 1310, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  signed int return_value_pthread_mutex_destroy$6;
  return_value_pthread_mutex_destroy$6=pthread_mutex_destroy(&manager->lock);
  if(return_value_pthread_mutex_destroy$6 == 0)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/task.c", 1311, "((pthread_mutex_destroy(((&manager->lock))) == 0) ? 0 : 34) == 0");
    (_Bool)0;
  }
  (void)mctx;
  free((void *)manager);
  (void)&mctx;
}

// mfprintf
// file msyslog.c line 291
extern signed int mfprintf(struct _IO_FILE *fp, const char *fmt, ...)
{
  void **ap;
  signed int rc;
  ap = (void **)&fmt;
  rc=mvfprintf(fp, fmt, ap);
  ap = ((void **)NULL);
  return rc;
}

// mfptoa
// file dolfptoa.c line 140
extern char * mfptoa(unsigned int fpi, unsigned int fpf, signed short int ndec)
{
  signed int isneg = (signed int)((fpi & 0x80000000) != (unsigned int)0);
  if(!(isneg == 0))
    do
    {
      fpf = ~fpf + 1u;
      fpi = ~fpi + (unsigned int)(fpf == (unsigned int)0);
    }
    while((_Bool)0);

  char *return_value_dolfptoa$1;
  return_value_dolfptoa$1=dolfptoa(fpi, fpf, isneg, ndec, 0);
  return return_value_dolfptoa$1;
}

// mfptoms
// file dolfptoa.c line 158
extern char * mfptoms(unsigned int fpi, unsigned int fpf, signed short int ndec)
{
  signed int isneg = (signed int)((fpi & 0x80000000) != (unsigned int)0);
  if(!(isneg == 0))
    do
    {
      fpf = ~fpf + 1u;
      fpi = ~fpi + (unsigned int)(fpf == (unsigned int)0);
    }
    while((_Bool)0);

  char *return_value_dolfptoa$1;
  return_value_dolfptoa$1=dolfptoa(fpi, fpf, isneg, ndec, 1);
  return return_value_dolfptoa$1;
}

// mixer_name
// file audio.c line 75
static signed int mixer_name(const char *m_name, signed int m_mask)
{
  signed int i = 0;
  signed int return_value_strcmp$1;
  for( ; !(i >= 25); i = i + 1)
    if(!((1 << i & m_mask) == 0))
    {
      return_value_strcmp$1=strcmp(m_names[(signed long int)i], m_name);
      if(return_value_strcmp$1 == 0)
        break;

    }

  return 25 == i ? -1 : i;
}

// modetoa
// file modetoa.c line 11
extern const char * modetoa(unsigned long int mode)
{
  char *bp;
  signed int tmp_post$1;
  static const char * const modestrings[9l] = { "unspec", "sym_active", "sym_passive", "client", "server", "broadcast", "control", "private", "bclient" };
  if(mode >= 9ul)
  {
    do
    {
      bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
      tmp_post$1 = lib_nextbuf;
      lib_nextbuf = lib_nextbuf + 1;
      bp = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
      lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
    }
    while((_Bool)0);
    snprintf(bp, (unsigned long int)128, "mode#%zu", mode);
    return bp;
  }

  else
    return modestrings[(signed long int)mode];
}

// move_fd
// file socket.c line 54
extern signed int move_fd(signed int fd)
{
  signed int newfd;
  if(fd >= 0)
    (_Bool)1;

  else
  {
    isc_assertion_failed("socket.c", 81, (enum anonymous$46)isc_assertiontype_require, "(int)fd >= 0");
    (_Bool)0;
  }
  signed int tmp_if_expr$3;
  signed long int return_value_sysconf$2;
  signed int tmp_if_expr$7;
  signed long int return_value_sysconf$4;
  signed int tmp_if_expr$6;
  signed long int return_value_sysconf$5;
  signed long int return_value_sysconf$8;
  static signed int socket_boundary = -1;
  if(socket_boundary == -1)
  {
    signed long int return_value_sysconf$1;
    return_value_sysconf$1=sysconf(4);
    if(!((signed int)return_value_sysconf$1 + -10 >= 16))
    {
      return_value_sysconf$2=sysconf(4);
      tmp_if_expr$3 = (signed int)return_value_sysconf$2 - 10;
    }

    else
      tmp_if_expr$3 = 16 < 48 ? 16 : 48;
    if(!(tmp_if_expr$3 >= 0))
      tmp_if_expr$7 = 0;

    else
    {
      return_value_sysconf$4=sysconf(4);
      if(!((signed int)return_value_sysconf$4 + -10 >= 16))
      {
        return_value_sysconf$5=sysconf(4);
        tmp_if_expr$6 = (signed int)return_value_sysconf$5 - 10;
      }

      else
        tmp_if_expr$6 = 16 < 48 ? 16 : 48;
      tmp_if_expr$7 = tmp_if_expr$6;
    }
    socket_boundary = tmp_if_expr$7;
    do
      if(debug >= 1)
      {
        return_value_sysconf$8=sysconf(4);
        mprintf("move_fd: estimated max descriptors: %d, initial socket boundary: %d\n", (signed int)return_value_sysconf$8, socket_boundary);
      }

    while((_Bool)0);
  }

  while((_Bool)1)
  {
    if(fd >= 0 && !(fd >= socket_boundary))
    {
      newfd=fcntl(fd, 0, socket_boundary);
      if(!(newfd == -1))
      {
        close(fd);
        return newfd;
      }

    }

    else
      return fd;
    socket_boundary = 0 > socket_boundary - 10 ? 0 : socket_boundary - 10;
    do
      if(debug >= 1)
        mprintf("move_fd: selecting new socket boundary: %d\n", socket_boundary);

    while((_Bool)0);
    if(!(socket_boundary >= 1))
      break;

  }
  return fd;
}

// mprintf
// file ../include/ntp_stdlib.h line 26
extern signed int mprintf(const char *fmt, ...)
{
  void **ap;
  signed int rc;
  ap = (void **)&fmt;
  rc=mvfprintf(stdout, fmt, ap);
  ap = ((void **)NULL);
  return rc;
}

// msnprintf
// file msyslog.c line 326
extern signed int msnprintf(char *buf, unsigned long int bufsiz, const char *fmt, ...)
{
  void **ap;
  unsigned long int rc;
  ap = (void **)&fmt;
  signed int return_value_mvsnprintf$1;
  return_value_mvsnprintf$1=mvsnprintf(buf, bufsiz, fmt, ap);
  rc = (unsigned long int)return_value_mvsnprintf$1;
  ap = ((void **)NULL);
  return (signed int)rc;
}

// mstolfp
// file mstolfp.c line 12
extern signed int mstolfp(const char *str, struct anonymous$20 *lfp)
{
  const char *cp;
  char *bp;
  const char *cpdec;
  char buf[100l];
  bp = buf;
  cp = str;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
      break;

    cp = cp + 1l;
  }
  while((_Bool)1);
  char *tmp_post$2;
  if((signed int)*cp == 45)
  {
    tmp_post$2 = bp;
    bp = bp + 1l;
    *tmp_post$2 = (char)45;
    cp = cp + 1l;
  }

  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  char *tmp_post$5;
  const char *tmp_post$6;
  char *tmp_post$7;
  char *tmp_post$8;
  char *tmp_post$9;
  char *tmp_post$10;
  const char *tmp_post$11;
  const unsigned short int **return_value___ctype_b_loc$12;
  char *tmp_post$13;
  const char *tmp_post$14;
  const unsigned short int **return_value___ctype_b_loc$15;
  if(!((signed int)*cp == 46))
  {
    return_value___ctype_b_loc$3=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)(unsigned char)*cp]) == 0))
      goto __CPROVER_DUMP_L4;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    cpdec = cp;
    do
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(unsigned char)*cpdec]) == 0)
        break;

      cpdec = cpdec + 1l;
    }
    while((_Bool)1);
    if(cpdec - cp >= 4l)
      do
      {
        tmp_post$5 = bp;
        bp = bp + 1l;
        tmp_post$6 = cp;
        cp = cp + 1l;
        *tmp_post$5 = (char)*tmp_post$6;
      }
      while(cpdec - cp >= 4l);

    else
    {
      tmp_post$7 = bp;
      bp = bp + 1l;
      *tmp_post$7 = (char)48;
    }
    tmp_post$8 = bp;
    bp = bp + 1l;
    *tmp_post$8 = (char)46;
    if(!(cpdec - cp >= 3l))
    {
      signed int i = (signed int)((signed long int)3 - (cpdec - cp));
      do
      {
        tmp_post$9 = bp;
        bp = bp + 1l;
        *tmp_post$9 = (char)48;
        i = i - 1;
      }
      while(i >= 1);
    }

    for( ; !(cp >= cpdec); *tmp_post$10 = (char)*tmp_post$11)
    {
      tmp_post$10 = bp;
      bp = bp + 1l;
      tmp_post$11 = cp;
      cp = cp + 1l;
    }
    if((signed int)*cp == 46)
    {
      cp = cp + 1l;
      do
      {
        return_value___ctype_b_loc$12=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$12)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
          break;

        tmp_post$13 = bp;
        bp = bp + 1l;
        tmp_post$14 = cp;
        cp = cp + 1l;
        *tmp_post$13 = (char)*tmp_post$14;
      }
      while((_Bool)1);
    }

    *bp = (char)0;
    if(!((signed int)*cp == 0))
    {
      return_value___ctype_b_loc$15=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$15)[(signed long int)(signed int)(unsigned char)*cp]) == 0))
        goto __CPROVER_DUMP_L16;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L16:
      ;
      signed int return_value_atolfp$16;
      return_value_atolfp$16=atolfp(buf, lfp);
      return return_value_atolfp$16;
    }
  }
}

// msyslog
// file ../include/ntp_stdlib.h line 33
extern void msyslog(signed int level, const char *fmt, ...)
{
  char buf[1024l];
  void **ap = (void **)&fmt;
  mvsnprintf(buf, sizeof(char [1024l]) /*1024ul*/ , fmt, ap);
  ap = ((void **)NULL);
  addto_syslog(level, buf);
}

// mvfprintf
// file msyslog.c line 259
extern signed int mvfprintf(struct _IO_FILE *fp, const char *fmt, void **ap)
{
  const char *nfmt = fmt;
  signed int errval;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  errval = *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = errval;
  signed int return_value_vfprintf$3;
  return_value_vfprintf$3=vfprintf(fp, nfmt, ap);
  return return_value_vfprintf$3;
}

// mvsnprintf
// file msyslog.c line 226
extern signed int mvsnprintf(char *buf, unsigned long int bufsiz, const char *fmt, void **ap)
{
  const char *nfmt = fmt;
  signed int errval;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  errval = *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = errval;
  signed int return_value_vsnprintf$3;
  return_value_vsnprintf$3=vsnprintf(buf, bufsiz, nfmt, ap);
  return return_value_vsnprintf$3;
}

// mvsyslog
// file ../include/ntp_stdlib.h line 34
extern void mvsyslog(signed int level, const char *fmt, void **ap)
{
  char buf[1024l];
  mvsnprintf(buf, sizeof(char [1024l]) /*1024ul*/ , fmt, ap);
  addto_syslog(level, buf);
}

// netof
// file netof.c line 15
extern union anonymous$47 * netof(union anonymous$47 *hostaddr)
{
  unsigned int netnum;
  static signed int next_netofbuf;
  static union anonymous$47 netofbuf[8l];
  union anonymous$47 *netaddr = &netofbuf[(signed long int)next_netofbuf];
  next_netofbuf = (signed int)((unsigned long int)(next_netofbuf + 1) % (sizeof(union anonymous$47 [8l]) /*224ul*/  / sizeof(union anonymous$47) /*28ul*/ ));
  memcpy((void *)netaddr, (const void *)hostaddr, sizeof(union anonymous$47) /*28ul*/ );
  if((signed int)netaddr->sa.sa_family == 2)
  {
    netnum=ntohl(netaddr->sa4.sin_addr.s_addr);
    if((0xe0000000 & netnum) == 0xc0000000)
      netnum = netnum & 0xffffff00;

    else
      if((0xc0000000 & netnum) == 0x80000000)
        netnum = netnum & 0xffff0000;

    netaddr->sa4.sin_addr.s_addr=htonl(netnum);
  }

  else
    if((signed int)netaddr->sa.sa_family == 10)
      bzero((void *)&netaddr->sa6.sin6_addr.__in6_u.__u6_addr8[(signed long int)8], (unsigned long int)8);

  return netaddr;
}

// nexttok
// file authreadkeys.c line 25
static char * nexttok(char **str)
{
  char *cp;
  char *starttok;
  cp = *str;
  for( ; (_Bool)1; cp = cp + 1l)
    if(!((signed int)*cp == 32))
    {
      if(!((signed int)*cp == 9))
        goto __CPROVER_DUMP_L3;

    }


__CPROVER_DUMP_L3:
  ;
  starttok = cp;
  for( ; !((signed int)*cp == 0); cp = cp + 1l)
  {
    if((signed int)*cp == 10)
      break;

    if((signed int)*cp == 32)
      break;

    if((signed int)*cp == 9)
      break;

    if((signed int)*cp == 35)
      break;

  }
  _Bool tmp_if_expr$2;
  char *tmp_post$1;
  if(starttok == cp)
    return (char *)(void *)0;

  else
  {
    if((signed int)*cp == 32)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*cp == 9 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      tmp_post$1 = cp;
      cp = cp + 1l;
      *tmp_post$1 = (char)0;
    }

    else
      *cp = (char)0;
    *str = cp;
    return starttok;
  }
}

// noconst
// file vint64ops.c line 27
static inline void * noconst(const void *ptr)
{
  /* tag-#anon#lUN[l*{clV}$clV$'cp'||l*{lV}$lV$'vp'|] */
union anonymous$14
{
  // cp
  const void *cp;
  // vp
  void *vp;
};

/* */
  ;
  union anonymous$14 tmp;
  tmp.cp = ptr;
  return tmp.vp;
}

// normalize_tspec
// file ../include/timespecops.h line 80
static inline struct timespec normalize_tspec(struct timespec x)
{
  signed long int z;
  if(x.tv_nsec >= 3000000001l || !(x.tv_nsec >= -3000000000l))
  {
    z = x.tv_nsec / (signed long int)1000000000;
    x.tv_nsec = x.tv_nsec - z * (signed long int)1000000000;
    x.tv_sec = x.tv_sec + z;
  }

  if(!(x.tv_nsec >= 0l))
    do
    {
      x.tv_nsec = x.tv_nsec + (signed long int)1000000000;
      x.tv_sec = x.tv_sec - 1l;
    }
    while(!(x.tv_nsec >= 0l));

  else
    if(x.tv_nsec >= 1000000000l)
      do
      {
        x.tv_nsec = x.tv_nsec - (signed long int)1000000000;
        x.tv_sec = x.tv_sec + 1l;
      }
      while(x.tv_nsec >= 1000000000l);

  return x;
}

// normalize_tval
// file ../include/timevalops.h line 136
static inline struct timeval normalize_tval(struct timeval x)
{
  signed long int z;
  if(x.tv_usec >= 3000001l || !(x.tv_usec >= -3000000l))
  {
    z = x.tv_usec / (signed long int)1000000;
    x.tv_usec = x.tv_usec - z * (signed long int)1000000;
    x.tv_sec = x.tv_sec + z;
  }

  if(!(x.tv_usec >= 0l))
    do
    {
      x.tv_usec = x.tv_usec + (signed long int)1000000;
      x.tv_sec = x.tv_sec - 1l;
    }
    while(!(x.tv_usec >= 0l));

  else
    if(x.tv_usec >= 1000000l)
      do
      {
        x.tv_usec = x.tv_usec - (signed long int)1000000;
        x.tv_sec = x.tv_sec + 1l;
      }
      while(x.tv_usec >= 1000000l);

  return x;
}

// normalize_tval$link1
// file ../include/timevalops.h line 136
static inline struct timeval normalize_tval$link1(struct timeval x$link1)
{
  signed long int z$link1;
  if(x$link1.tv_usec >= 3000001l || !(x$link1.tv_usec >= -3000000l))
  {
    z$link1 = x$link1.tv_usec / (signed long int)1000000;
    x$link1.tv_usec = x$link1.tv_usec - z$link1 * (signed long int)1000000;
    x$link1.tv_sec = x$link1.tv_sec + z$link1;
  }

  if(!(x$link1.tv_usec >= 0l))
    do
    {
      x$link1.tv_usec = x$link1.tv_usec + (signed long int)1000000;
      x$link1.tv_sec = x$link1.tv_sec - 1l;
    }
    while(!(x$link1.tv_usec >= 0l));

  else
    if(x$link1.tv_usec >= 1000000l)
      do
      {
        x$link1.tv_usec = x$link1.tv_usec - (signed long int)1000000;
        x$link1.tv_sec = x$link1.tv_sec + 1l;
      }
      while(x$link1.tv_usec >= 1000000l);

  return x$link1;
}

// now
// file ntp_calendar.c line 118
static inline signed long int now(void)
{
  signed long int return_value;
  return_value=systime_func((signed long int *)(void *)0);
  return return_value;
}

// ntp2unix_tm
// file prettydate.c line 223
extern struct tm * ntp2unix_tm(unsigned int ntp, signed int local)
{
  union anonymous$44 vl;
  vl=ntpcal_ntp_to_time(ntp, (const signed long int *)(void *)0);
  struct tm *return_value_get_struct_tm$1;
  return_value_get_struct_tm$1=get_struct_tm(&vl, local);
  return return_value_get_struct_tm$1;
}

// ntpOptionPrintVersion
// file ntp_libopts.c line 47
extern void ntpOptionPrintVersion(struct options *pOpts, struct opt_desc *pOD)
{
  (void)pOpts;
  (void)pOD;
  printf("%s\n", Version);
  fflush(stdout);
  exit(0);
}

// ntpOptionProcess
// file ntp_libopts.c line 27
extern signed int ntpOptionProcess(struct options *pOpts, signed int argc, char **argv)
{
  signed int return_value_optionProcess$1;
  return_value_optionProcess$1=optionProcess(pOpts, argc, argv);
  return return_value_optionProcess$1;
}

// ntp_crypto_random_buf
// file ntp_crypto_rnd.c line 88
signed int ntp_crypto_random_buf(void *buf, unsigned long int nbytes)
{
  signed int rc;
  rc=RAND_bytes((unsigned char *)buf, (signed int)nbytes);
  if(!(rc == 1))
  {
    unsigned long int err;
    char *err_str;
    err=ERR_get_error();
    err_str=ERR_error_string(err, (char *)(void *)0);
    (void)&err_str;
    return -1;
  }

  return 0;
}

// ntp_crypto_srandom
// file ntp_crypto_rnd.c line 67
void ntp_crypto_srandom(void)
{
  if(crypto_rand_init == 0)
  {
    RAND_poll();
    crypto_rand_init = 1;
  }

}

// ntp_getopt
// file ../include/ntp_stdlib.h line 89
extern signed int ntp_getopt(signed int argc, char **argv, const char *optstring)
{
  char c;
  const char *place;
  prog = argv[(signed long int)0];
  ntp_optarg = (char *)(void *)0;
  if(ntp_optind == 0)
  {
    scan = (char *)(void *)0;
    ntp_optind = ntp_optind + 1;
  }

  _Bool tmp_if_expr$4;
  if(scan == ((char *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = (signed int)*scan == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  signed int tmp_post$3;
  if(tmp_if_expr$4)
  {
    if(ntp_optind >= argc)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)argv[(signed long int)ntp_optind][(signed long int)0] != 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)argv[(signed long int)ntp_optind][(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return -1;

    if((signed int)argv[(signed long int)ntp_optind][1l] == 45)
    {
      if((signed int)argv[(signed long int)ntp_optind][2l] == 0)
      {
        ntp_optind = ntp_optind + 1;
        return -1;
      }

    }

    tmp_post$3 = ntp_optind;
    ntp_optind = ntp_optind + 1;
    scan = argv[(signed long int)tmp_post$3] + (signed long int)1;
  }

  char *tmp_post$5 = scan;
  scan = scan + 1l;
  c = *tmp_post$5;
  ntp_optopt = (signed int)c & 0377;
  place = optstring;
  _Bool tmp_if_expr$6;
  do
  {
    if(!(place == ((const char *)NULL)))
      tmp_if_expr$6 = (signed int)*place != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(!tmp_if_expr$6)
      break;

    if(*place == c)
      break;

    place = place + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr$8;
  if(place == ((const char *)NULL))
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = (signed int)*place == 0 ? (_Bool)1 : (_Bool)0;
  if((signed int)c == 58 || (signed int)c == 63 || tmp_if_expr$8)
  {
    signed int return_value_badopt$7;
    return_value_badopt$7=badopt(": unknown option -", (signed int)c);
    return return_value_badopt$7;
  }

  place = place + 1l;
  signed int tmp_post$10;
  if((signed int)*place == 58)
  {
    if(!((signed int)*scan == 0))
    {
      ntp_optarg = scan;
      scan = (char *)(void *)0;
    }

    else
      if(ntp_optind >= argc)
      {
        signed int return_value_badopt$9;
        return_value_badopt$9=badopt(": option requires argument -", (signed int)c);
        return return_value_badopt$9;
      }

      else
      {
        tmp_post$10 = ntp_optind;
        ntp_optind = ntp_optind + 1;
        ntp_optarg = argv[(signed long int)tmp_post$10];
      }
  }

  return (signed int)c & 0377;
}

// ntp_prompt_callback
// file ntp_lineedit.c line 236
char * ntp_prompt_callback(struct editline *el)
{
  (void)el;
  return lineedit_prompt;
}

// ntp_random
// file ../include/ntp_random.h line 7
signed long int ntp_random(void)
{
  signed long int i;
  unsigned long int *f;
  unsigned long int *r;
  if(rand_type == 0l)
  {
    i = (signed long int)state[(signed long int)0];
    signed long int return_value_good_rand$1;
    return_value_good_rand$1=good_rand(i);
    i = return_value_good_rand$1 & (signed long int)0x7fffffff;
    state[(signed long int)0] = (unsigned long int)i;
  }

  else
  {
    f = fptr;
    r = rptr;
    *f = *f + *r;
    i = (signed long int)(*f >> 1 & (unsigned long int)0x7fffffff);
    f = f + 1l;
    if(f >= end_ptr)
    {
      f = state;
      r = r + 1l;
    }

    else
    {
      r = r + 1l;
      if(r >= end_ptr)
        r = state;

    }
    fptr = f;
    rptr = r;
  }
  return i;
}

// ntp_readline
// file ntp_lineedit.c line 159
char * ntp_readline(signed int *pcount)
{
  char *line;
  const char *cline;
  if(ntp_readline_initted == 0)
    return (char *)(void *)0;

  else
  {
    *pcount = 0;
    cline=el_gets(ntp_el, pcount);
    if(!(cline == ((const char *)NULL)))
    {
      history(ntp_hist, &hev, 10, cline);
      line=estrdup_impl(cline);
    }

    else
      if(*pcount == -1)
        line = (char *)(void *)0;

      else
        line=estrdup_impl("");
    if(line == ((char *)NULL))
      fputs("\n", stderr);

    return line;
  }
}

// ntp_readline_init
// file ntp_lineedit.c line 65
signed int ntp_readline_init(const char *prompt)
{
  signed int success = 1;
  if(!(prompt == ((const char *)NULL)))
  {
    if(!(lineedit_prompt == ((char *)NULL)))
      free((void *)lineedit_prompt);

    lineedit_prompt=estrdup_impl(prompt);
  }

  if(ntp_el == ((struct editline *)NULL))
  {
    ntp_el=el_init(progname, stdin, stdout, stderr);
    if(!(ntp_el == ((struct editline *)NULL)))
    {
      el_set(ntp_el, 0, ntp_prompt_callback);
      el_set(ntp_el, 2, (const void *)"emacs");
      ntp_hist=history_init();
      if(ntp_hist == ((struct history *)NULL))
      {
        mfprintf(stderr, "history_init(): %m\n");
        fflush(stderr);
        el_end(ntp_el);
        ntp_el = (struct editline *)(void *)0;
        success = 0;
      }

      else
      {
        bzero((void *)&hev, sizeof(struct HistEvent) /*16ul*/ );
        history(ntp_hist, &hev, 1, 128);
        el_set(ntp_el, 10, history, ntp_hist);
        el_source(ntp_el, (const char *)(void *)0);
      }
    }

    else
      success = 0;
  }

  ntp_readline_initted = success;
  return success;
}

// ntp_readline_uninit
// file ntp_lineedit.c line 129
void ntp_readline_uninit(void)
{
  if(!(ntp_el == ((struct editline *)NULL)))
  {
    el_end(ntp_el);
    ntp_el = (struct editline *)(void *)0;
    history_end(ntp_hist);
    ntp_hist = (struct history *)(void *)0;
  }

  if(!(lineedit_prompt == ((char *)NULL)))
  {
    free((void *)lineedit_prompt);
    lineedit_prompt = (char *)(void *)0;
  }

  ntp_readline_initted = 0;
}

// ntp_set_tod
// file ../include/ntp_machine.h line 68
signed int ntp_set_tod(struct timeval *tvp, void *tzp)
{
  signed int rc;
  signed int saved_errno;
  do
    if(debug >= 1)
      mprintf("In ntp_set_tod\n");

  while((_Bool)0);
  rc = -1;
  saved_errno = 0;
  static signed int tod;
  if(!(rc == 0) && (tod == 0 || tod == 1))
  {
    struct timespec ts;
    ts.tv_sec = tvp->tv_sec;
    ts.tv_nsec = (signed long int)1000 * tvp->tv_usec;
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    rc=clock_settime(0, &ts);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    saved_errno = *return_value___errno_location$2;
    do
      if(debug >= 1)
        mprintf("ntp_set_tod: clock_settime: %d %m\n", rc);

    while((_Bool)0);
    if(rc == 0 && tod == 0)
      tod = 1;

  }

  if(!(rc == 0) && (tod == 0 || tod == 2))
  {
    struct timeval adjtv;
    adjtv.tv_usec = (signed long int)0;
    adjtv.tv_sec = adjtv.tv_usec;
    adjtime(&adjtv, (struct timeval *)(void *)0);
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 0;
    rc=settimeofday(tvp, (struct timezone *)tzp);
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    saved_errno = *return_value___errno_location$4;
    do
      if(debug >= 1)
        mprintf("ntp_set_tod: settimeofday: %d %m\n", rc);

    while((_Bool)0);
    if(rc == 0 && tod == 0)
      tod = 2;

  }

  if(!(rc == 0) && (tod == 0 || tod == 3))
  {
    signed long int tp = tvp->tv_sec;
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    *return_value___errno_location$5 = 0;
    rc=stime(&tp);
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    saved_errno = *return_value___errno_location$6;
    do
      if(debug >= 1)
        mprintf("ntp_set_tod: stime: %d %m\n", rc);

    while((_Bool)0);
    if(rc == 0 && tod == 0)
      tod = 3;

  }

  signed int *return_value___errno_location$7;
  return_value___errno_location$7=__errno_location();
  *return_value___errno_location$7 = saved_errno;
  do
    if(debug >= 1)
      mprintf("ntp_set_tod: Final result: %s: %d %m\n", set_tod_used[(signed long int)tod], rc);

  while((_Bool)0);
  if(rc == 0 && !(set_tod_using == ((void (*)(const char *))NULL)))
  {
    set_tod_using(set_tod_used[(signed long int)tod]);
    set_tod_using = (void (*)(const char *))(void *)0;
  }

  signed int *return_value___errno_location$8;
  if(!(rc == 0))
  {
    return_value___errno_location$8=__errno_location();
    *return_value___errno_location$8 = saved_errno;
  }

  return rc;
}

// ntp_srandom
// file ntp_random.c line 260
void ntp_srandom(unsigned long int x)
{
  signed long int i;
  signed long int return_value_good_rand$1;
  signed long int return_value_ntp_random$2;
  if(rand_type == 0l)
    state[(signed long int)0] = x;

  else
  {
    state[(signed long int)0] = x;
    i = (signed long int)1;
    for( ; !(i >= rand_deg); i = i + 1l)
    {
      return_value_good_rand$1=good_rand((signed long int)state[i - (signed long int)1]);
      state[i] = (unsigned long int)return_value_good_rand$1;
    }
    fptr = &state[rand_sep];
    rptr = &state[(signed long int)0];
    i = (signed long int)0;
    for( ; !(i >= 10l * rand_deg); i = i + 1l)
    {
      return_value_ntp_random$2=ntp_random();
      x = (unsigned long int)return_value_ntp_random$2;
    }
  }
  srand((unsigned int)x);
}

// ntp_to_year
// file clocktime.c line 130
static signed int ntp_to_year(unsigned int ntp)
{
  union anonymous$44 t;
  struct anonymous$61 s;
  t=ntpcal_ntp_to_ntp(ntp, (const signed long int *)(void *)0);
  s=ntpcal_daysplit(&t);
  s=ntpcal_split_eradays((s.hi + 693596) - 1, (signed int *)(void *)0);
  return s.hi + 1;
}

// ntpcal_date_to_daysec
// file ntp_calendar.c line 1393
extern signed int ntpcal_date_to_daysec(struct calendar *jd)
{
  signed int return_value_ntpcal_etime_to_seconds$1;
  return_value_ntpcal_etime_to_seconds$1=ntpcal_etime_to_seconds((signed int)jd->hour, (signed int)jd->minute, (signed int)jd->second);
  return return_value_ntpcal_etime_to_seconds$1;
}

// ntpcal_date_to_ntp
// file ntp_calendar.c line 1490
extern unsigned int ntpcal_date_to_ntp(struct calendar *jd)
{
  union anonymous$44 return_value_ntpcal_date_to_ntp64$1;
  return_value_ntpcal_date_to_ntp64$1=ntpcal_date_to_ntp64(jd);
  return return_value_ntpcal_date_to_ntp64$1.d_s.lo;
}

// ntpcal_date_to_ntp64
// file ntp_calendar.c line 1477
extern union anonymous$44 ntpcal_date_to_ntp64(struct calendar *jd)
{
  signed int return_value_ntpcal_date_to_rd$1;
  return_value_ntpcal_date_to_rd$1=ntpcal_date_to_rd(jd);
  signed int return_value_ntpcal_date_to_daysec$2;
  return_value_ntpcal_date_to_daysec$2=ntpcal_date_to_daysec(jd);
  union anonymous$44 return_value_ntpcal_dayjoin$3;
  return_value_ntpcal_dayjoin$3=ntpcal_dayjoin(return_value_ntpcal_date_to_rd$1 - 693596, return_value_ntpcal_date_to_daysec$2);
  return return_value_ntpcal_dayjoin$3;
}

// ntpcal_date_to_rd
// file ../include/ntp_calendar.h line 220
extern signed int ntpcal_date_to_rd(struct calendar *jd)
{
  signed int return_value_ntpcal_edate_to_eradays$1;
  return_value_ntpcal_edate_to_eradays$1=ntpcal_edate_to_eradays((signed int)jd->year - 1, (signed int)jd->month - 1, (signed int)jd->monthday - 1);
  return return_value_ntpcal_edate_to_eradays$1 + 1;
}

// ntpcal_date_to_time
// file ../include/ntp_calendar.h line 334
extern signed long int ntpcal_date_to_time(struct calendar *jd)
{
  union anonymous$44 join;
  signed int days;
  signed int secs;
  signed int return_value_ntpcal_date_to_rd$1;
  return_value_ntpcal_date_to_rd$1=ntpcal_date_to_rd(jd);
  days = return_value_ntpcal_date_to_rd$1 - 719163;
  secs=ntpcal_date_to_daysec(jd);
  join=ntpcal_dayjoin(days, secs);
  signed long int return_value_vint64_to_time$2;
  return_value_vint64_to_time$2=vint64_to_time(&join);
  return return_value_vint64_to_time$2;
}

// ntpcal_dayjoin
// file ../include/ntp_calendar.h line 158
extern union anonymous$44 ntpcal_dayjoin(signed int days, signed int secs)
{
  union anonymous$44 res;
  res.q_s = (signed long int)days;
  res.q_s = res.q_s * (signed long int)(60 * 60 * 24);
  res.q_s = res.q_s + (signed long int)secs;
  return res;
}

// ntpcal_days_in_months
// file ntp_calendar.c line 1192
extern struct anonymous$61 ntpcal_days_in_months(signed int m)
{
  struct anonymous$61 res;
  res.lo = m + 10;
  res.hi = (signed int)(res.lo >= 12);
  if(!(res.hi == 0))
    res.lo = res.lo - 12;

  if(res.lo >= 12 || !(res.lo >= 0))
  {
    unsigned int mu;
    unsigned int Q;
    unsigned int sflag;
    sflag=int32_sflag(res.lo);
    mu=int32_to_uint32_2cpl(res.lo);
    Q = sflag ^ (sflag ^ mu) / 12u;
    signed int return_value_uint32_2cpl_to_int32$1;
    return_value_uint32_2cpl_to_int32$1=uint32_2cpl_to_int32(Q);
    res.hi = res.hi + return_value_uint32_2cpl_to_int32$1;
    res.lo = (signed int)(mu - Q * 12u);
  }

  res.lo = (signed int)shift_month_table[(signed long int)res.lo] - 306;
  return res;
}

// ntpcal_days_in_years
// file ../include/ntp_calendar.h line 170
extern signed int ntpcal_days_in_years(signed int years)
{
  signed int return_value_ntpcal_leapyears_in_years$1;
  return_value_ntpcal_leapyears_in_years$1=ntpcal_leapyears_in_years(years);
  return years * 365 + return_value_ntpcal_leapyears_in_years$1;
}

// ntpcal_daysec_to_date
// file ntp_calendar.c line 952
extern signed int ntpcal_daysec_to_date(struct calendar *jd, signed int sec)
{
  signed int days;
  signed int ts[3l];
  days=priv_timesplit(ts, sec);
  jd->hour = (unsigned char)ts[(signed long int)0];
  jd->minute = (unsigned char)ts[(signed long int)1];
  jd->second = (unsigned char)ts[(signed long int)2];
  return days;
}

// ntpcal_daysec_to_tm
// file ntp_calendar.c line 975
extern signed int ntpcal_daysec_to_tm(struct tm *utm, signed int sec)
{
  signed int days;
  signed int ts[3l];
  days=priv_timesplit(ts, sec);
  utm->tm_hour = ts[(signed long int)0];
  utm->tm_min = ts[(signed long int)1];
  utm->tm_sec = ts[(signed long int)2];
  return days;
}

// ntpcal_daysplit
// file ../include/ntp_calendar.h line 151
extern struct anonymous$61 ntpcal_daysplit(const union anonymous$44 *ts)
{
  struct anonymous$61 res;
  unsigned int Q;
  if(!(ts->q_s >= 0l))
    Q = ~((unsigned int)(~ts->Q_s / (unsigned long int)(60 * 60 * 24)));

  else
    Q = (unsigned int)(ts->Q_s / (unsigned long int)(60 * 60 * 24));
  res.hi=uint32_2cpl_to_int32(Q);
  res.lo = (signed int)(ts->D_s.lo - Q * (unsigned int)(60 * 60 * 24));
  return res;
}

// ntpcal_daysplit_to_date
// file ../include/ntp_calendar.h line 306
extern signed int ntpcal_daysplit_to_date(struct calendar *jd, const struct anonymous$61 *ds, signed int dof)
{
  signed int return_value_ntpcal_daysec_to_date$1;
  return_value_ntpcal_daysec_to_date$1=ntpcal_daysec_to_date(jd, ds->lo);
  dof = dof + return_value_ntpcal_daysec_to_date$1;
  signed int return_value_ntpcal_rd_to_date$2;
  return_value_ntpcal_rd_to_date$2=ntpcal_rd_to_date(jd, ds->hi + dof);
  return return_value_ntpcal_rd_to_date$2;
}

// ntpcal_daysplit_to_tm
// file ntp_calendar.c line 1023
extern signed int ntpcal_daysplit_to_tm(struct tm *utm, const struct anonymous$61 *ds, signed int dof)
{
  signed int return_value_ntpcal_daysec_to_tm$1;
  return_value_ntpcal_daysec_to_tm$1=ntpcal_daysec_to_tm(utm, ds->lo);
  dof = dof + return_value_ntpcal_daysec_to_tm$1;
  signed int return_value_ntpcal_rd_to_tm$2;
  return_value_ntpcal_rd_to_tm$2=ntpcal_rd_to_tm(utm, ds->hi + dof);
  return return_value_ntpcal_rd_to_tm$2;
}

// ntpcal_edate_to_eradays
// file ntp_calendar.c line 1230
extern signed int ntpcal_edate_to_eradays(signed int years, signed int mons, signed int mdays)
{
  struct anonymous$61 tmp;
  signed int res;
  if(!(mons == 0))
  {
    tmp=ntpcal_days_in_months(mons);
    signed int return_value_ntpcal_days_in_years$1;
    return_value_ntpcal_days_in_years$1=ntpcal_days_in_years(years + tmp.hi);
    res = return_value_ntpcal_days_in_years$1 + tmp.lo;
  }

  else
    res=ntpcal_days_in_years(years);
  res = res + mdays;
  return res;
}

// ntpcal_edate_to_yeardays
// file ntp_calendar.c line 1259
extern signed int ntpcal_edate_to_yeardays(signed int years, signed int mons, signed int mdays)
{
  struct anonymous$61 tmp;
  if(mons >= 0 && !(mons >= 12))
  {
    years = years + 1;
    mdays = mdays + (signed int)real_month_table[(signed long int)(!(years % 4 != 0) && !(!(years % 100 != 0) && years % 400 != 0))][(signed long int)mons];
  }

  else
  {
    tmp=ntpcal_days_in_months(mons);
    signed int return_value_ntpcal_days_in_years$1;
    return_value_ntpcal_days_in_years$1=ntpcal_days_in_years(years + tmp.hi);
    signed int return_value_ntpcal_days_in_years$2;
    return_value_ntpcal_days_in_years$2=ntpcal_days_in_years(years);
    mdays = mdays + ((tmp.lo + return_value_ntpcal_days_in_years$1) - return_value_ntpcal_days_in_years$2);
  }
  return mdays;
}

// ntpcal_etime_to_seconds
// file ../include/ntp_calendar.h line 196
extern signed int ntpcal_etime_to_seconds(signed int hours, signed int minutes, signed int seconds)
{
  signed int res = (hours * 60 + minutes) * 60 + seconds;
  return res;
}

// ntpcal_get_build_date
// file ../include/ntp_calendar.h line 127
extern signed int ntpcal_get_build_date(struct calendar *jd)
{
  char monstr[4l];
  const char *cp;
  unsigned short int hour;
  unsigned short int minute;
  unsigned short int second;
  unsigned short int day;
  unsigned short int year;
  bzero((void *)&(*jd), sizeof(struct calendar) /*10ul*/ );
  jd->year = (unsigned short int)1970;
  jd->month = (unsigned char)1;
  jd->monthday = (unsigned char)1;
  signed int return_value_sscanf$1;
  static const char build[21l] = { '2', '3', ':', '3', '4', ':', '5', '1', '/', 'J', 'a', 'n', ' ', '2', '5', ' ', '2', '0', '1', '6', 0 };
  return_value_sscanf$1=sscanf(build, "%hu:%hu:%hu/%3s %hu %hu", &hour, &minute, &second, (const void *)monstr, &day, &year);
  if(return_value_sscanf$1 == 6)
  {
    static const char mlist[37l] = { 'J', 'a', 'n', 'F', 'e', 'b', 'M', 'a', 'r', 'A', 'p', 'r', 'M', 'a', 'y', 'J', 'u', 'n', 'J', 'u', 'l', 'A', 'u', 'g', 'S', 'e', 'p', 'O', 'c', 't', 'N', 'o', 'v', 'D', 'e', 'c', 0 };
    cp=strstr(mlist, monstr);
    if(cp == ((const char *)NULL))
      goto __CPROVER_DUMP_L1;

    jd->year = year;
    jd->month = (unsigned char)((cp - mlist) / (signed long int)3 + (signed long int)1);
    jd->monthday = (unsigned char)day;
    jd->hour = (unsigned char)hour;
    jd->minute = (unsigned char)minute;
    jd->second = (unsigned char)second;
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// ntpcal_leapyears_in_years
// file ntp_calendar.c line 1133
extern signed int ntpcal_leapyears_in_years(signed int years)
{
  unsigned int sflag;
  unsigned int sum;
  unsigned int uyear;
  sflag=int32_sflag(years);
  uyear=int32_to_uint32_2cpl(years);
  uyear = uyear ^ sflag;
  uyear = uyear / 4u;
  sum = uyear;
  uyear = uyear / 25u;
  sum = sum - uyear;
  uyear = uyear / 4u;
  sum = sum + uyear;
  signed int return_value_uint32_2cpl_to_int32$1;
  return_value_uint32_2cpl_to_int32$1=uint32_2cpl_to_int32(sflag ^ sum);
  return return_value_uint32_2cpl_to_int32$1;
}

// ntpcal_ntp64_to_date
// file ntp_calendar.c line 1444
extern signed int ntpcal_ntp64_to_date(struct calendar *jd, const union anonymous$44 *ntp)
{
  struct anonymous$61 ds;
  ds=ntpcal_daysplit(ntp);
  signed int return_value_ntpcal_daysec_to_date$1;
  return_value_ntpcal_daysec_to_date$1=ntpcal_daysec_to_date(jd, ds.lo);
  ds.hi = ds.hi + return_value_ntpcal_daysec_to_date$1;
  signed int return_value_ntpcal_rd_to_date$2;
  return_value_ntpcal_rd_to_date$2=ntpcal_rd_to_date(jd, ds.hi + 693596);
  return return_value_ntpcal_rd_to_date$2;
}

// ntpcal_ntp_to_date
// file ntp_calendar.c line 1458
extern signed int ntpcal_ntp_to_date(struct calendar *jd, unsigned int ntp, const signed long int *piv)
{
  union anonymous$44 ntp64;
  ntp64=ntpcal_ntp_to_ntp(ntp, piv);
  signed int return_value_ntpcal_ntp64_to_date$1;
  return_value_ntpcal_ntp64_to_date$1=ntpcal_ntp64_to_date(jd, &ntp64);
  return return_value_ntpcal_ntp64_to_date$1;
}

// ntpcal_ntp_to_ntp
// file ../include/ntp_calendar.h line 144
extern union anonymous$44 ntpcal_ntp_to_ntp(unsigned int ntp, const signed long int *pivot)
{
  union anonymous$44 res;
  signed long int tmp_if_expr$2;
  signed long int return_value_now$1;
  if(!(pivot == ((const signed long int *)NULL)))
    tmp_if_expr$2 = *pivot;

  else
  {
    return_value_now$1=now();
    tmp_if_expr$2 = return_value_now$1;
  }
  res.q_s = tmp_if_expr$2;
  res.Q_s = res.Q_s - (unsigned long int)0x80000000;
  res.Q_s = res.Q_s + (unsigned long int)(unsigned int)((unsigned int)(719163 - 693596) * (unsigned int)(60 * 60 * 24));
  ntp = ntp - res.D_s.lo;
  res.Q_s = res.Q_s + (unsigned long int)ntp;
  return res;
}

// ntpcal_ntp_to_time
// file ../include/ntp_calendar.h line 135
extern union anonymous$44 ntpcal_ntp_to_time(unsigned int ntp, const signed long int *pivot)
{
  union anonymous$44 res;
  signed long int tmp_if_expr$2;
  signed long int return_value_now$1;
  if(!(pivot == ((const signed long int *)NULL)))
    tmp_if_expr$2 = *pivot;

  else
  {
    return_value_now$1=now();
    tmp_if_expr$2 = return_value_now$1;
  }
  res.q_s = tmp_if_expr$2;
  res.Q_s = res.Q_s - (unsigned long int)0x80000000;
  ntp = ntp - (unsigned int)((unsigned int)(719163 - 693596) * (unsigned int)(60 * 60 * 24));
  ntp = ntp - res.D_s.lo;
  res.Q_s = res.Q_s + (unsigned long int)ntp;
  return res;
}

// ntpcal_periodic_extend
// file ntp_calendar.c line 501
extern signed int ntpcal_periodic_extend(signed int pivot, signed int value, signed int cycle)
{
  unsigned int diff;
  char cpl = (char)0;
  char neg = (char)0;
  if(!(cycle >= 0))
  {
    cycle = -cycle;
    neg = neg ^ (char)1;
    cpl = cpl ^ (char)1;
  }

  if(cycle >= 2)
  {
    if(value >= pivot)
    {
      unsigned int return_value_int32_to_uint32_2cpl$1;
      return_value_int32_to_uint32_2cpl$1=int32_to_uint32_2cpl(value);
      unsigned int return_value_int32_to_uint32_2cpl$2;
      return_value_int32_to_uint32_2cpl$2=int32_to_uint32_2cpl(pivot);
      diff = return_value_int32_to_uint32_2cpl$1 - return_value_int32_to_uint32_2cpl$2;
    }

    else
    {
      unsigned int return_value_int32_to_uint32_2cpl$3;
      return_value_int32_to_uint32_2cpl$3=int32_to_uint32_2cpl(pivot);
      unsigned int return_value_int32_to_uint32_2cpl$4;
      return_value_int32_to_uint32_2cpl$4=int32_to_uint32_2cpl(value);
      diff = return_value_int32_to_uint32_2cpl$3 - return_value_int32_to_uint32_2cpl$4;
      cpl = cpl ^ (char)1;
    }
    diff = diff % (unsigned int)cycle;
    if(!(diff == 0u))
    {
      if(!(cpl == 0))
        diff = (unsigned int)cycle - diff;

      if(!(neg == 0))
        diff = ~diff + (unsigned int)1;

      signed int return_value_uint32_2cpl_to_int32$5;
      return_value_uint32_2cpl_to_int32$5=uint32_2cpl_to_int32(diff);
      pivot = pivot + return_value_uint32_2cpl_to_int32$5;
    }

  }

  return pivot;
}

// ntpcal_rd_to_date
// file ntp_calendar.c line 873
extern signed int ntpcal_rd_to_date(struct calendar *jd, signed int rd)
{
  struct anonymous$61 split;
  signed int leapy;
  unsigned int ymask;
  jd->weekday = (unsigned char)(rd % 7);
  if((signed int)jd->weekday >= 7)
    jd->weekday = jd->weekday + (unsigned char)7;

  split=ntpcal_split_eradays(rd - 1, &leapy);
  split.hi = split.hi + 1;
  ymask = 0u - (unsigned int)(split.hi >> 16 == 0);
  jd->year = (unsigned short int)((unsigned int)split.hi & ymask);
  jd->yearday = (unsigned short int)((signed int)(unsigned short int)split.lo + 1);
  split=ntpcal_split_yeardays(split.lo, leapy);
  jd->month = (unsigned char)((signed int)(unsigned char)split.hi + 1);
  jd->monthday = (unsigned char)((signed int)(unsigned char)split.lo + 1);
  return ymask != 0u ? leapy : -1;
}

// ntpcal_rd_to_mstart
// file ../include/ntp_calendar.h line 302
extern signed int ntpcal_rd_to_mstart(signed int rd)
{
  struct anonymous$61 split;
  signed int leaps;
  split=ntpcal_split_eradays(rd - 1, &leaps);
  split=ntpcal_split_yeardays(split.lo, leaps);
  return rd - split.lo;
}

// ntpcal_rd_to_tm
// file ntp_calendar.c line 919
extern signed int ntpcal_rd_to_tm(struct tm *utm, signed int rd)
{
  struct anonymous$61 split;
  signed int leapy;
  utm->tm_wday = rd % 7;
  if(!(utm->tm_wday >= 0))
    utm->tm_wday = utm->tm_wday + 7;

  split=ntpcal_split_eradays(rd - 1, &leapy);
  utm->tm_year = split.hi - 1899;
  utm->tm_yday = split.lo;
  split=ntpcal_split_yeardays(split.lo, leapy);
  utm->tm_mon = split.hi;
  utm->tm_mday = split.lo + 1;
  return leapy;
}

// ntpcal_rd_to_ystart
// file ../include/ntp_calendar.h line 296
extern signed int ntpcal_rd_to_ystart(signed int rd)
{
  struct anonymous$61 return_value_ntpcal_split_eradays$1;
  return_value_ntpcal_split_eradays$1=ntpcal_split_eradays(rd - 1, (signed int *)(void *)0);
  return rd - return_value_ntpcal_split_eradays$1.lo;
}

// ntpcal_set_timefunc
// file ntp_calendar.c line 102
extern signed long int (*ntpcal_set_timefunc(signed long int (*nfunc)(signed long int *)))(signed long int *)
{
  signed long int (*res)(signed long int *) = systime_func;
  if(nfunc == ((signed long int (*)(signed long int *))NULL))
    nfunc = time;

  systime_func = nfunc;
  return res;
}

// ntpcal_split_eradays
// file ../include/ntp_calendar.h line 234
extern struct anonymous$61 ntpcal_split_eradays(signed int days, signed int *isleapyear)
{
  struct anonymous$61 res;
  signed int n100;
  signed int n001;
  unsigned int uday;
  unsigned int Q;
  unsigned int sflag;
  sflag=int32_sflag(days);
  unsigned int return_value_int32_to_uint32_2cpl$1;
  return_value_int32_to_uint32_2cpl$1=int32_to_uint32_2cpl(days);
  uday=uint32_saturate(return_value_int32_to_uint32_2cpl$1, sflag);
  uday = 4u * uday | 3u;
  Q = sflag ^ (sflag ^ uday) / (unsigned int)(4 * (25 * (3 * 365 + 366) - 1) + 1);
  uday = uday - Q * (unsigned int)(4 * (25 * (3 * 365 + 366) - 1) + 1);
  n100=uint32_2cpl_to_int32(Q);
  uday = uday | (unsigned int)3;
  n001 = (signed int)(uday / (unsigned int)(3 * 365 + 366));
  uday = uday % (unsigned int)(3 * 365 + 366);
  res.hi = n100 * 100 + n001;
  res.lo = (signed int)(uday / 4u);
  if(!(isleapyear == ((signed int *)NULL)))
    *isleapyear = (signed int)(!((n001 + 1 & 3) != 0) && (n001 != 99 || !((Q + (unsigned int)1 & (unsigned int)3) != 0u)));

  return res;
}

// ntpcal_split_yeardays
// file ntp_calendar.c line 844
extern struct anonymous$61 ntpcal_split_yeardays(signed int eyd, signed int isleapyear)
{
  struct anonymous$61 res;
  const unsigned short int *lt = real_month_table[(signed long int)(isleapyear != 0)];
  _Bool tmp_if_expr$1;
  if(eyd >= 0)
    tmp_if_expr$1 = eyd < (signed int)lt[(signed long int)12] ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    res.hi = eyd >> 5;
    if(eyd >= (signed int)lt[(signed long int)(1 + res.hi)])
      res.hi = res.hi + 1;

    res.lo = eyd - (signed int)lt[(signed long int)res.hi];
  }

  else
  {
    res.hi = -1;
    res.lo = res.hi;
  }
  return res;
}

// ntpcal_time_to_date
// file ntp_calendar.c line 1040
extern signed int ntpcal_time_to_date(struct calendar *jd, const union anonymous$44 *ts)
{
  struct anonymous$61 ds;
  ds=ntpcal_daysplit(ts);
  signed int return_value_ntpcal_daysec_to_date$1;
  return_value_ntpcal_daysec_to_date$1=ntpcal_daysec_to_date(jd, ds.lo);
  ds.hi = ds.hi + return_value_ntpcal_daysec_to_date$1;
  ds.hi = ds.hi + 719163;
  signed int return_value_ntpcal_rd_to_date$2;
  return_value_ntpcal_rd_to_date$2=ntpcal_rd_to_date(jd, ds.hi);
  return return_value_ntpcal_rd_to_date$2;
}

// ntpcal_tm_to_daysec
// file ntp_calendar.c line 1407
extern signed int ntpcal_tm_to_daysec(struct tm *utm)
{
  signed int return_value_ntpcal_etime_to_seconds$1;
  return_value_ntpcal_etime_to_seconds$1=ntpcal_etime_to_seconds(utm->tm_hour, utm->tm_min, utm->tm_sec);
  return return_value_ntpcal_etime_to_seconds$1;
}

// ntpcal_tm_to_rd
// file ntp_calendar.c line 1311
extern signed int ntpcal_tm_to_rd(struct tm *utm)
{
  signed int return_value_ntpcal_edate_to_eradays$1;
  return_value_ntpcal_edate_to_eradays$1=ntpcal_edate_to_eradays(utm->tm_year + 1899, utm->tm_mon, utm->tm_mday - 1);
  return return_value_ntpcal_edate_to_eradays$1 + 1;
}

// ntpcal_weekday_close
// file ntp_calendar.c line 1533
extern signed int ntpcal_weekday_close(signed int rdn, signed int dow)
{
  signed int return_value_ntpcal_periodic_extend$1;
  return_value_ntpcal_periodic_extend$1=ntpcal_periodic_extend(rdn - 3, dow, 7);
  return return_value_ntpcal_periodic_extend$1;
}

// ntpcal_weekday_ge
// file ntp_calendar.c line 1524
extern signed int ntpcal_weekday_ge(signed int rdn, signed int dow)
{
  signed int return_value_ntpcal_periodic_extend$1;
  return_value_ntpcal_periodic_extend$1=ntpcal_periodic_extend(rdn, dow, 7);
  return return_value_ntpcal_periodic_extend$1;
}

// ntpcal_weekday_gt
// file ntp_calendar.c line 1515
extern signed int ntpcal_weekday_gt(signed int rdn, signed int dow)
{
  signed int return_value_ntpcal_periodic_extend$1;
  return_value_ntpcal_periodic_extend$1=ntpcal_periodic_extend(rdn + 1, dow, 7);
  return return_value_ntpcal_periodic_extend$1;
}

// ntpcal_weekday_le
// file ../include/ntp_calendar.h line 380
extern signed int ntpcal_weekday_le(signed int rdn, signed int dow)
{
  signed int return_value_ntpcal_periodic_extend$1;
  return_value_ntpcal_periodic_extend$1=ntpcal_periodic_extend(rdn, dow, -7);
  return return_value_ntpcal_periodic_extend$1;
}

// ntpcal_weekday_lt
// file ntp_calendar.c line 1551
extern signed int ntpcal_weekday_lt(signed int rdn, signed int dow)
{
  signed int return_value_ntpcal_periodic_extend$1;
  return_value_ntpcal_periodic_extend$1=ntpcal_periodic_extend(rdn - 1, dow, -7);
  return return_value_ntpcal_periodic_extend$1;
}

// ntpcal_year_to_ystart
// file ../include/ntp_calendar.h line 289
extern signed int ntpcal_year_to_ystart(signed int year)
{
  signed int return_value_ntpcal_days_in_years$1;
  return_value_ntpcal_days_in_years$1=ntpcal_days_in_years(year - 1);
  return return_value_ntpcal_days_in_years$1 + 1;
}

// numtoa
// file numtoa.c line 18
extern char * numtoa(unsigned int num)
{
  unsigned int netnum;
  char *buf;
  netnum=ntohl(num);
  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    buf = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  snprintf(buf, (unsigned long int)128, "%lu.%lu.%lu.%lu", (unsigned long int)netnum >> 24 & (unsigned long int)0xff, (unsigned long int)netnum >> 16 & (unsigned long int)0xff, (unsigned long int)netnum >> 8 & (unsigned long int)0xff, (unsigned long int)netnum & (unsigned long int)0xff);
  return buf;
}

// numtohost
// file numtohost.c line 20
extern char * numtohost(unsigned int netnum)
{
  char *bp;
  struct hostent *hp;
  unsigned int return_value_ntohl$2;
  return_value_ntohl$2=ntohl(netnum);
  _Bool tmp_if_expr$4;
  unsigned int return_value_ntohl$3;
  if((0xff000000 & return_value_ntohl$2) == 2130706432u)
  {
    return_value_ntohl$3=ntohl(netnum);
    tmp_if_expr$4 = return_value_ntohl$3 != (unsigned int)0x7f000001 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$4 = (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    hp=gethostbyaddr((const void *)(char *)&netnum, (unsigned int)sizeof(unsigned int) /*4ul*/ , 2);
    tmp_if_expr$5 = hp == ((struct hostent *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_numtoa$1;
  signed int tmp_post$6;
  if(tmp_if_expr$5)
  {
    return_value_numtoa$1=numtoa(netnum);
    return return_value_numtoa$1;
  }

  else
  {
    do
    {
      bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
      tmp_post$6 = lib_nextbuf;
      lib_nextbuf = lib_nextbuf + 1;
      bp = &lib_stringbuf[(signed long int)tmp_post$6][(signed long int)0];
      lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
    }
    while((_Bool)0);
    strlcpy(bp, hp->h_name, (unsigned long int)128);
    return bp;
  }
}

// octtoint
// file octtoint.c line 12
extern signed int octtoint(const char *str, unsigned long int *ival)
{
  unsigned long int u;
  const char *cp = str;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  const char *tmp_post$4;
  if((signed int)*cp == 0)
    return 0;

  else
  {
    u = (unsigned long int)0;
    while(!((signed int)*cp == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$1;
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)*cp == 56 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*cp == 57 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        return 0;

      if(u >= 536870912ul)
        return 0;

      u = u << 3;
      tmp_post$4 = cp;
      cp = cp + 1l;
      u = u + (unsigned long int)((signed int)*tmp_post$4 - 48);
    }
    *ival = u;
    return 1;
  }
}

// open_msgcat
// file ./../lib/isc/lib.c line 55
static void open_msgcat(void)
{
  isc_msgcat_open("libisc.cat", &isc_msgcat);
}

// oreallocarray
// file emalloc.c line 86
extern void * oreallocarray(void *optr, unsigned long int nmemb, unsigned long int size)
{
  if(nmemb >= 1ul && !(18446744073709551615UL / nmemb >= size) && (nmemb >= 4294967296ul || size >= 4294967296ul))
  {
    msyslog(3, "fatal allocation size overflow");
    exit(1);
  }

  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz(optr, size * nmemb, (unsigned long int)0, 0);
  return return_value_ereallocz$1;
}

// peer_st_flags
// file statestr.c line 391
static const char * peer_st_flags(unsigned char pst)
{
  const char *return_value_decode_bitflags$1;
  return_value_decode_bitflags$1=decode_bitflags((signed int)pst, ", ", peer_st_bits, sizeof(struct codestring [5l]) /*80ul*/  / sizeof(struct codestring) /*16ul*/ );
  return return_value_decode_bitflags$1;
}

// pipe_socketpair
// file ntp_worker.c line 40
extern signed int pipe_socketpair(signed int *caller_fds, signed int *is_pipe)
{
  signed int rc;
  signed int fds[2l];
  signed int called_pipe;
  rc=socketpair(1, 1, 0, &fds[(signed long int)0]);
  if(rc == -1)
  {
    rc=pipe(&fds[(signed long int)0]);
    called_pipe = 1;
  }

  else
    called_pipe = 0;
  if(rc == -1)
    return rc;

  else
  {
    caller_fds[(signed long int)0] = fds[(signed long int)0];
    caller_fds[(signed long int)1] = fds[(signed long int)1];
    if(!(is_pipe == ((signed int *)NULL)))
      *is_pipe = called_pipe;

    return 0;
  }
}

// pll_trap
// file ntptime.c line 395
void pll_trap(signed int arg)
{
  pll_control = pll_control - 1;
  siglongjmp(env, 1);
}

// pop_readyq
// file ./../lib/isc/task.c line 945
static inline struct isc__task * pop_readyq(struct isc__taskmgr *manager)
{
  struct isc__task *task;
  if((signed int)manager->mode == isc_taskmgrmode_normal)
    task = manager->ready_tasks.head;

  else
    task = manager->ready_priority_tasks.head;
  if(!(task == ((struct isc__task *)NULL)))
  {

  __CPROVER_DUMP_L3:
    ;
    do
    {
      if(!(task->ready_link.next == ((struct isc__task *)NULL)))
        task->ready_link.next->ready_link.prev = task->ready_link.prev;

      else
      {
        if(manager->ready_tasks.tail == task)
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/task.c", 954, (enum anonymous$46)isc_assertiontype_insist, "(manager->ready_tasks).tail == (task)");
          (_Bool)0;
        }
        manager->ready_tasks.tail = task->ready_link.prev;
      }
      if(!(task->ready_link.prev == ((struct isc__task *)NULL)))
        task->ready_link.prev->ready_link.next = task->ready_link.next;

      else
      {
        if(manager->ready_tasks.head == task)
          (_Bool)1;

        else
        {
          isc_assertion_failed("./../lib/isc/task.c", 954, (enum anonymous$46)isc_assertiontype_insist, "(manager->ready_tasks).head == (task)");
          (_Bool)0;
        }
        manager->ready_tasks.head = task->ready_link.next;
      }
      task->ready_link.prev = (struct isc__task *)(void *)-1;
      task->ready_link.next = (struct isc__task *)(void *)-1;
    }
    while((_Bool)0);
    if(!((void *)task->ready_priority_link.prev == (void *)-1))
    {

    __CPROVER_DUMP_L14:
      ;
      do
      {
        if(!(task->ready_priority_link.next == ((struct isc__task *)NULL)))
          task->ready_priority_link.next->ready_priority_link.prev = task->ready_priority_link.prev;

        else
        {
          if(manager->ready_priority_tasks.tail == task)
            (_Bool)1;

          else
          {
            isc_assertion_failed("./../lib/isc/task.c", 957, (enum anonymous$46)isc_assertiontype_insist, "(manager->ready_priority_tasks).tail == (task)");
            (_Bool)0;
          }
          manager->ready_priority_tasks.tail = task->ready_priority_link.prev;
        }
        if(!(task->ready_priority_link.prev == ((struct isc__task *)NULL)))
          task->ready_priority_link.prev->ready_priority_link.next = task->ready_priority_link.next;

        else
        {
          if(manager->ready_priority_tasks.head == task)
            (_Bool)1;

          else
          {
            isc_assertion_failed("./../lib/isc/task.c", 957, (enum anonymous$46)isc_assertiontype_insist, "(manager->ready_priority_tasks).head == (task)");
            (_Bool)0;
          }
          manager->ready_priority_tasks.head = task->ready_priority_link.next;
        }
        task->ready_priority_link.prev = (struct isc__task *)(void *)-1;
        task->ready_priority_link.next = (struct isc__task *)(void *)-1;
      }
      while((_Bool)0);
    }

  }

  return task;
}

// prepare_child_sems
// file work_thread.c line 554
static void prepare_child_sems(struct blocking_child_tag *c)
{
  unsigned long int octets;
  if(c->blocking_req_ready == ((union anonymous$65 *)NULL))
  {
    octets = sizeof(union anonymous$65) /*32ul*/ ;
    octets = octets + sizeof(union anonymous$65) /*32ul*/ ;
    void *return_value_ereallocz$1;
    return_value_ereallocz$1=ereallocz((void *)0, octets, (unsigned long int)0, 1);
    c->blocking_req_ready = (union anonymous$65 *)return_value_ereallocz$1;
    c->wake_scheduled_sleep = (signed long int)1 + c->blocking_req_ready;
  }

  else
  {
    sem_destroy(c->blocking_req_ready);
    sem_destroy(c->wake_scheduled_sleep);
  }
  sem_init(c->blocking_req_ready, 0, (unsigned int)0);
  sem_init(c->wake_scheduled_sleep, 0, (unsigned int)0);
}

// prettydate
// file ../include/ntp_fp.h line 357
extern char * prettydate(struct anonymous$20 *ts)
{
  char *return_value_common_prettydate$1;
  return_value_common_prettydate$1=common_prettydate(ts, 1);
  return return_value_common_prettydate$1;
}

// priv_timesplit
// file ntp_calendar.c line 746
static signed int priv_timesplit(signed int *split, signed int ts)
{
  unsigned int us;
  unsigned int um;
  unsigned int uh;
  unsigned int ud;
  unsigned int sflag;
  sflag=int32_sflag(ts);
  us=int32_to_uint32_2cpl(ts);
  um = (sflag ^ us) / (unsigned int)60;
  uh = um / (unsigned int)60;
  ud = uh / (unsigned int)24;
  um = um ^ sflag;
  uh = uh ^ sflag;
  ud = ud ^ sflag;
  split[(signed long int)0] = (signed int)(uh - ud * (unsigned int)24);
  split[(signed long int)1] = (signed int)(um - uh * (unsigned int)60);
  split[(signed long int)2] = (signed int)(us - um * (unsigned int)60);
  signed int return_value_uint32_2cpl_to_int32$1;
  return_value_uint32_2cpl_to_int32$1=uint32_2cpl_to_int32(ud);
  return return_value_uint32_2cpl_to_int32$1;
}

// process_blocking_resp
// file ntp_worker.c line 228
extern void process_blocking_resp(struct blocking_child_tag *c)
{
  struct blocking_pipe_header_tag *resp;
  void *data;
  do
  {
    resp=receive_blocking_resp_internal(c);
    if(!(resp == ((struct blocking_pipe_header_tag *)NULL)))
    {

    __CPROVER_DUMP_L2:
      ;
      data = (void *)((char *)resp + (signed long int)sizeof(struct blocking_pipe_header_tag) /*40ul*/ );
      intres_req_pending = intres_req_pending - 1;
      resp->done_func(resp->rtype, resp->context, resp->octets - sizeof(struct blocking_pipe_header_tag) /*40ul*/ , data);
      free((void *)resp);
    }

  }
  while(!(resp == ((struct blocking_pipe_header_tag *)NULL)));
  if(intres_req_pending == 0 && worker_per_query == 0)
    intres_timeout_req((unsigned int)(3 * 60));

  else
    if(!(worker_per_query == 0))
      req_child_exit(c);

}

// purge_recv_buffers_for_fd
// file recvbuff.c line 266
extern void purge_recv_buffers_for_fd(signed int fd)
{
  struct recvbuf *rbufp;
  struct recvbuf *next;
  struct recvbuf *punlinked;

__CPROVER_DUMP_L1:
  ;
  rbufp = full_recv_fifo.phead;
  for( ; !(rbufp == ((struct recvbuf *)NULL)); rbufp = next)
  {
    next = rbufp->link;
    if(rbufp->fd == fd)
    {
      do
      {
        struct recvbuf **ppentry;

      __CPROVER_DUMP_L4:
        ;
        ppentry = &full_recv_fifo.phead;
        while(!(rbufp == *ppentry))
          if(!((*ppentry)->link == ((struct recvbuf *)NULL)))
            ppentry = &(*ppentry)->link;

          else
          {
            ppentry = (struct recvbuf **)(void *)0;
            break;
          }
        if(!(ppentry == ((struct recvbuf **)NULL)))
        {
          punlinked = *ppentry;
          *ppentry = punlinked->link;
          if(*ppentry == ((struct recvbuf *)NULL))
            full_recv_fifo.pptail = (struct recvbuf **)(void *)0;

          else
            if(full_recv_fifo.pptail == &punlinked->link)
              full_recv_fifo.pptail = &full_recv_fifo.phead;

        }

        else
          punlinked = (struct recvbuf *)(void *)0;

      __CPROVER_DUMP_L10:
        ;

      __CPROVER_DUMP_L11:
        ;
      }
      while((_Bool)0);
      if(punlinked == rbufp)
        (_Bool)1;

      else
      {
        isc_assertion_failed("recvbuff.c", 283, (enum anonymous$46)isc_assertiontype_insist, "punlinked == rbufp");
        (_Bool)0;
      }
      full_recvbufs = full_recvbufs - 1ul;
      freerecvbuf(rbufp);
    }

  }

__CPROVER_DUMP_L18:
  ;
}

// push_readyq
// file ./../lib/isc/task.c line 970
static inline void push_readyq(struct isc__taskmgr *manager, struct isc__task *task)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(!(manager->ready_tasks.tail == ((struct isc__task *)NULL)))
      manager->ready_tasks.tail->ready_link.next = task;

    else
      manager->ready_tasks.head = task;
    task->ready_link.prev = manager->ready_tasks.tail;
    task->ready_link.next = (struct isc__task *)(void *)0;
    manager->ready_tasks.tail = task;
  }
  while((_Bool)0);
  if(!((2u & task->flags) == 0u))
  {

  __CPROVER_DUMP_L4:
    ;
    do
    {
      if(!(manager->ready_priority_tasks.tail == ((struct isc__task *)NULL)))
        manager->ready_priority_tasks.tail->ready_priority_link.next = task;

      else
        manager->ready_priority_tasks.head = task;
      task->ready_priority_link.prev = manager->ready_priority_tasks.tail;
      task->ready_priority_link.next = (struct isc__task *)(void *)0;
      manager->ready_priority_tasks.tail = task;
    }
    while((_Bool)0);
  }

}

// queue_blocking_request
// file ../include/ntp_worker.h line 111
extern signed int queue_blocking_request(enum blocking_work_req_tag rtype, void *req, unsigned long int reqsize, void (*done_func)(enum blocking_work_req_tag, void *, unsigned long int, void *), void *context)
{
  unsigned int child_slot;
  struct blocking_child_tag *c;
  struct blocking_pipe_header_tag req_hdr;
  req_hdr.octets = sizeof(struct blocking_pipe_header_tag) /*40ul*/  + reqsize;
  req_hdr.magic_sig = (enum blocking_magic_sig_e)BLOCKING_REQ_MAGIC;
  req_hdr.rtype = rtype;
  req_hdr.done_func = done_func;
  req_hdr.context = context;
  child_slot = (unsigned int)0x7fffffff * 2U + 1U;
  _Bool tmp_if_expr$1;
  static unsigned int intres_slot = (unsigned int)0x7fffffff * 2U + 1U;
  if(intres_slot == 1U || !(worker_per_query == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = blocking_children[(signed long int)intres_slot]->reusable != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    child_slot=available_blocking_child_slot();

  if(worker_per_query == 0)
  {
    if(intres_slot == 1U)
      intres_slot = child_slot;

    else
      child_slot = intres_slot;
    if(intres_req_pending == 0)
      intres_timeout_req((unsigned int)0);

  }

  intres_req_pending = intres_req_pending + 1;
  if(!(child_slot == 1U))
    (_Bool)1;

  else
  {
    isc_assertion_failed("ntp_worker.c", 190, (enum anonymous$46)isc_assertiontype_insist, "(0x7fffffff * 2U + 1U) != child_slot");
    (_Bool)0;
  }
  c = blocking_children[(signed long int)child_slot];
  if(c == ((struct blocking_child_tag *)NULL))
  {
    void *return_value_ereallocz$2;
    return_value_ereallocz$2=ereallocz((void *)0, sizeof(struct blocking_child_tag) /*128ul*/ , (unsigned long int)0, 1);
    c = (struct blocking_child_tag *)return_value_ereallocz$2;
    c->resp_read_pipe = -1;
    c->resp_write_pipe = -1;
    blocking_children[(signed long int)child_slot] = c;
  }

  req_hdr.child_idx = child_slot;
  signed int return_value_send_blocking_req_internal$3;
  return_value_send_blocking_req_internal$3=send_blocking_req_internal(c, &req_hdr, req);
  return return_value_send_blocking_req_internal$3;
}

// queue_blocking_response
// file ../include/ntp_worker.h line 114
extern signed int queue_blocking_response(struct blocking_child_tag *c, struct blocking_pipe_header_tag *resp, unsigned long int respsize, const struct blocking_pipe_header_tag *req)
{
  resp->octets = respsize;
  resp->magic_sig = (enum blocking_magic_sig_e)BLOCKING_RESP_MAGIC;
  resp->rtype = req->rtype;
  resp->context = req->context;
  resp->done_func = req->done_func;
  signed int return_value_send_blocking_resp_internal$1;
  return_value_send_blocking_resp_internal$1=send_blocking_resp_internal(c, resp);
  return return_value_send_blocking_resp_internal$1;
}

// queue_req_pointer
// file work_thread.c line 188
static signed int queue_req_pointer(struct blocking_child_tag *c, struct blocking_pipe_header_tag *hdr)
{
  c->workitems[(signed long int)c->next_workitem] = hdr;
  c->next_workitem = ((unsigned long int)1 + c->next_workitem) % c->workitems_alloc;
  sem_post(c->blocking_req_ready);
  return 0;
}

// receive_blocking_req_internal
// file ../include/ntp_worker.h line 124
extern struct blocking_pipe_header_tag * receive_blocking_req_internal(struct blocking_child_tag *c)
{
  struct blocking_pipe_header_tag *req;
  signed int rc;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    rc=wait_for_sem(c->blocking_req_ready, (struct timespec *)(void *)0);
    if(rc == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = 4 == *return_value___errno_location$1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  if(rc == 0)
    (_Bool)1;

  else
  {
    isc_assertion_failed("work_thread.c", 267, (enum anonymous$46)isc_assertiontype_insist, "0 == rc");
    (_Bool)0;
  }
  req = c->workitems[(signed long int)c->next_workeritem];
  if(!(req == ((struct blocking_pipe_header_tag *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("work_thread.c", 271, (enum anonymous$46)isc_assertiontype_insist, "((void *)0) != req");
    (_Bool)0;
  }
  c->workitems[(signed long int)c->next_workeritem] = (struct blocking_pipe_header_tag *)(void *)0;
  c->next_workeritem = ((unsigned long int)1 + c->next_workeritem) % c->workitems_alloc;
  if((struct blocking_pipe_header_tag *)-1l == req)
  {
    send_blocking_resp_internal(c, (struct blocking_pipe_header_tag *)(signed long int)-1);
    req = (struct blocking_pipe_header_tag *)(void *)0;
  }

  return req;
}

// receive_blocking_resp_internal
// file ../include/ntp_worker.h line 126
extern struct blocking_pipe_header_tag * receive_blocking_resp_internal(struct blocking_child_tag *c)
{
  struct blocking_pipe_header_tag *removed;
  signed int rc;
  char scratch[32l];
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    signed long int return_value_read$3;
    return_value_read$3=read(c->resp_read_pipe, (void *)scratch, sizeof(char [32l]) /*32ul*/ );
    rc = (signed int)return_value_read$3;
    if(rc == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = 4 == *return_value___errno_location$1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  removed = c->responses[(signed long int)c->next_workresp];
  if(!(removed == ((struct blocking_pipe_header_tag *)NULL)))
  {
    c->responses[(signed long int)c->next_workresp] = (struct blocking_pipe_header_tag *)(void *)0;
    c->next_workresp = ((unsigned long int)1 + c->next_workresp) % c->responses_alloc;
  }


__CPROVER_DUMP_L4:
  ;
  if((struct blocking_pipe_header_tag *)-1l == removed)
  {
    cleanup_after_child(c);
    removed = (struct blocking_pipe_header_tag *)(void *)0;
  }

  return removed;
}

// refid_str
// file numtoa.c line 38
extern const char * refid_str(unsigned int refid, signed int stratum)
{
  char *refid_str$$1$$text;
  unsigned long int tlen;
  char *return_value_numtoa$1;
  signed int tmp_post$2;
  if(stratum >= 2)
  {
    return_value_numtoa$1=numtoa(refid);
    return return_value_numtoa$1;
  }

  else
  {
    do
    {
      bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
      tmp_post$2 = lib_nextbuf;
      lib_nextbuf = lib_nextbuf + 1;
      refid_str$$1$$text = &lib_stringbuf[(signed long int)tmp_post$2][(signed long int)0];
      lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
    }
    while((_Bool)0);
    refid_str$$1$$text[(signed long int)0] = (char)46;
    memcpy((void *)&refid_str$$1$$text[(signed long int)1], (const void *)&refid, sizeof(unsigned int) /*4ul*/ );
    refid_str$$1$$text[(signed long int)((unsigned long int)1 + sizeof(unsigned int) /*4ul*/ )] = (char)0;
    tlen=strlen(refid_str$$1$$text);
    refid_str$$1$$text[(signed long int)tlen] = (char)46;
    refid_str$$1$$text[(signed long int)(tlen + (unsigned long int)1)] = (char)0;
    return refid_str$$1$$text;
  }
}

// refnumtoa
// file refnumtoa.c line 12
extern const char * refnumtoa(union anonymous$47 *num)
{
  unsigned int netnum;
  char *buf;
  const char *rclock;
  _Bool tmp_if_expr$3;
  unsigned int return_value_ntohl$2;
  if((signed int)num->sa.sa_family == 2)
  {
    return_value_ntohl$2=ntohl(num->sa4.sin_addr.s_addr);
    tmp_if_expr$3 = (return_value_ntohl$2 & 0xffff0000) == (unsigned int)0x7f7f0000 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  const char *return_value_socktoa$1;
  signed int tmp_post$4;
  if(!tmp_if_expr$3)
  {
    return_value_socktoa$1=socktoa(num);
    return return_value_socktoa$1;
  }

  else
  {
    do
    {
      bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
      tmp_post$4 = lib_nextbuf;
      lib_nextbuf = lib_nextbuf + 1;
      buf = &lib_stringbuf[(signed long int)tmp_post$4][(signed long int)0];
      lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
    }
    while((_Bool)0);
    netnum=ntohl(num->sa4.sin_addr.s_addr);
    rclock=clockname((signed int)((unsigned long int)netnum >> 8) & 0xff);
    if(!(rclock == ((const char *)NULL)))
      snprintf(buf, (unsigned long int)128, "%s(%lu)", rclock, (unsigned long int)netnum & (unsigned long int)0xff);

    else
      snprintf(buf, (unsigned long int)128, "REFCLK(%lu,%lu)", (unsigned long int)netnum >> 8 & (unsigned long int)0xff, (unsigned long int)netnum & (unsigned long int)0xff);
    return buf;
  }
}

// register_table
// file ./../lib/isc/result.c line 116
static unsigned int register_table(unsigned int base, unsigned int nresults, const char **txt, struct isc_msgcat *msgcat, signed int set)
{
  struct resulttable *table;
  if(base % 65536u == 0u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/result.c", 121, (enum anonymous$46)isc_assertiontype_require, "base % 65536 == 0");
    (_Bool)0;
  }
  if(!(nresults >= 65537u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/result.c", 122, (enum anonymous$46)isc_assertiontype_require, "nresults <= 65536");
    (_Bool)0;
  }
  if(!(txt == ((const char **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/result.c", 123, (enum anonymous$46)isc_assertiontype_require, "txt != ((void *)0)");
    (_Bool)0;
  }
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct resulttable) /*48ul*/ );
  table = (struct resulttable *)return_value_malloc$1;
  if(table == ((struct resulttable *)NULL))
    return (unsigned int)1;

  else
  {
    table->base = base;
    table->last = (base + nresults) - (unsigned int)1;
    table->text = txt;
    table->msgcat = msgcat;
    table->set = set;
    do
    {
      table->link.prev = (struct resulttable *)(void *)-1;
      table->link.next = (struct resulttable *)(void *)-1;
    }
    while((_Bool)0);
    do
    {
      signed int return_value_pthread_mutex_lock$2;
      return_value_pthread_mutex_lock$2=pthread_mutex_lock(&lock);
      if(return_value_pthread_mutex_lock$2 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/result.c", 139, "((pthread_mutex_lock(((&lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);

  __CPROVER_DUMP_L16:
    ;
    do
    {
      if(!(tables.tail == ((struct resulttable *)NULL)))
        tables.tail->link.next = table;

      else
        tables.head = table;
      table->link.prev = tables.tail;
      table->link.next = (struct resulttable *)(void *)0;
      tables.tail = table;
    }
    while((_Bool)0);
    do
    {
      signed int return_value_pthread_mutex_unlock$3;
      return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&lock);
      if(return_value_pthread_mutex_unlock$3 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/result.c", 143, "((pthread_mutex_unlock(((&lock))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);
    return (unsigned int)0;
  }
}

// reload_resolv_conf
// file ntp_intres.c line 880
static void reload_resolv_conf(struct dnsworker_ctx_tag *worker_ctx)
{
  signed long int time_now;
  time_now=time((signed long int *)(void *)0);
  worker_ctx->next_res_init = next_res_init;
  if(time_now >= worker_ctx->next_res_init)
  {
    if(!(worker_ctx->next_res_init == 0l))
      __res_init();

    worker_ctx->next_res_init = time_now + (signed long int)60;
    next_res_init = worker_ctx->next_res_init;
  }

}

// req_child_exit
// file ../include/ntp_worker.h line 133
extern signed int req_child_exit(struct blocking_child_tag *c)
{
  signed int return_value_queue_req_pointer$1;
  return_value_queue_req_pointer$1=queue_req_pointer(c, (struct blocking_pipe_header_tag *)(signed long int)-1);
  return return_value_queue_req_pointer$1;
}

// res_access_flags
// file statestr.c line 411
extern const char * res_access_flags(unsigned short int af)
{
  const char *return_value_decode_bitflags$1;
  return_value_decode_bitflags$1=decode_bitflags((signed int)af, " ", res_access_bits, sizeof(struct codestring [12l]) /*192ul*/  / sizeof(struct codestring) /*16ul*/ );
  return return_value_decode_bitflags$1;
}

// res_match_flags
// file statestr.c line 401
extern const char * res_match_flags(unsigned short int mf)
{
  const char *return_value_decode_bitflags$1;
  return_value_decode_bitflags$1=decode_bitflags((signed int)mf, " ", res_match_bits, sizeof(struct codestring [3l]) /*48ul*/  / sizeof(struct codestring) /*16ul*/ );
  return return_value_decode_bitflags$1;
}

// reserve_dnschild_ctx
// file ntp_intres.c line 909
static unsigned int reserve_dnschild_ctx(void)
{
  const unsigned long int ps = sizeof(struct dnschild_ctx_tag *) /*8ul*/ ;
  const unsigned long int cs = sizeof(struct dnschild_ctx_tag) /*16ul*/ ;
  unsigned int c;
  unsigned int new_alloc;
  unsigned long int octets;
  unsigned long int new_octets;
  c = (unsigned int)0;
  while((_Bool)1)
  {
    for( ; !(c >= dnschild_contexts_alloc); c = c + 1u)
      if(dnschild_contexts[(signed long int)c] == ((struct dnschild_ctx_tag *)NULL))
      {
        void *return_value_ereallocz$1;
        return_value_ereallocz$1=ereallocz((void *)0, cs, (unsigned long int)0, 1);
        dnschild_contexts[(signed long int)c] = (struct dnschild_ctx_tag *)return_value_ereallocz$1;
        return c;
      }

    new_alloc = dnschild_contexts_alloc + (unsigned int)20;
    new_octets = (unsigned long int)new_alloc * ps;
    octets = (unsigned long int)dnschild_contexts_alloc * ps;
    void *return_value_ereallocz$2;
    return_value_ereallocz$2=ereallocz((void *)dnschild_contexts, new_octets, octets, 1);
    dnschild_contexts = (struct dnschild_ctx_tag **)return_value_ereallocz$2;
    dnschild_contexts_alloc = new_alloc;
  }
}

// roll_log
// file ./../lib/isc/log.c line 1215
static unsigned int roll_log(struct isc_logchannel *channel)
{
  signed int i;
  signed int n;
  signed int greatest;
  char current[4097l];
  char new[4097l];
  const char *path;
  unsigned int result;
  _Bool tmp_if_expr$2;
  const char *return_value_isc_result_totext$1;
  const char *return_value_isc_result_totext$3;
  const char *return_value_isc_result_totext$4;
  const char *return_value_isc_result_totext$5;
  if(channel->destination.file.versions == -2)
    return (unsigned int)0;

  else
  {
    path = channel->destination.file.name;
    result=greatest_version(channel, &greatest);
    if(!(result == 0u))
      return result;

    else
    {
      if(channel->destination.file.versions == -1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = channel->destination.file.versions > greatest ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$2)
        do
        {
          greatest = greatest - 1;
          if(!(greatest >= channel->destination.file.versions))
            break;

          n=snprintf(current, sizeof(char [4097l]) /*4097ul*/ , "%s.%d", path, greatest);
          if(n >= (signed int)sizeof(char [4097l]) /*4097*/  || !(n >= 0))
            result = (unsigned int)19;

          else
            result=isc_file_remove(current);
          if(!(result == 0u) && !(result == 38u))
          {
            return_value_isc_result_totext$1=isc_result_totext(result);
            syslog(3, "unable to remove log file '%s.%d': %s", path, greatest, return_value_isc_result_totext$1);
          }

        }
        while((_Bool)1);

      i = greatest;
      for( ; i >= 1; i = i - 1)
      {
        result = (unsigned int)0;
        n=snprintf(current, sizeof(char [4097l]) /*4097ul*/ , "%s.%d", path, i - 1);
        if(n >= (signed int)sizeof(char [4097l]) /*4097*/  || !(n >= 0))
          result = (unsigned int)19;

        if(result == 0u)
        {
          n=snprintf(new, sizeof(char [4097l]) /*4097ul*/ , "%s.%d", path, i);
          if(n >= (signed int)sizeof(char [4097l]) /*4097*/  || !(n >= 0))
            result = (unsigned int)19;

        }

        if(result == 0u)
          result=isc_file_rename(current, new);

        if(!(result == 0u) && !(result == 38u))
        {
          return_value_isc_result_totext$3=isc_result_totext(result);
          syslog(3, "unable to rename log file '%s.%d' to '%s.%d': %s", path, i - 1, path, i, return_value_isc_result_totext$3);
        }

      }
      if(!(channel->destination.file.versions == 0))
      {
        n=snprintf(new, sizeof(char [4097l]) /*4097ul*/ , "%s.0", path);
        if(n >= (signed int)sizeof(char [4097l]) /*4097*/  || !(n >= 0))
          result = (unsigned int)19;

        else
          result=isc_file_rename(path, new);
        if(!(result == 0u) && !(result == 38u))
        {
          return_value_isc_result_totext$4=isc_result_totext(result);
          syslog(3, "unable to rename log file '%s' to '%s.0': %s", path, path, return_value_isc_result_totext$4);
        }

      }

      else
      {
        result=isc_file_remove(path);
        if(!(result == 0u) && !(result == 38u))
        {
          return_value_isc_result_totext$5=isc_result_totext(result);
          syslog(3, "unable to remove log file '%s': %s", path, return_value_isc_result_totext$5);
        }

      }
      return (unsigned int)0;
    }
  }
}

// run
// file ./../lib/isc/task.c line 1277
static void * run(void *uap)
{
  struct isc__taskmgr *manager = (struct isc__taskmgr *)uap;
  dispatch(manager);
  return (void *)0;
}

// scheduled_sleep
// file ntp_intres.c line 997
static void scheduled_sleep(signed long int scheduled, signed long int earliest, struct dnsworker_ctx_tag *worker_ctx)
{
  signed long int scheduled_sleep$$1$$now;
  const char *return_value_humantime$1;
  const char *return_value_humantime$2;
  const char *return_value_humantime$3;
  const char *return_value_humantime$4;
  const char *return_value_humantime$5;
  const char *return_value_humantime$6;
  const char *return_value_humantime$7;
  if(!(scheduled >= worker_ctx->ignore_scheduled_before))
    do
      if(debug >= 1)
      {
        return_value_humantime$1=humantime(earliest);
        return_value_humantime$2=humantime(scheduled);
        return_value_humantime$3=humantime(worker_ctx->ignore_scheduled_before);
        mprintf("ignoring sleep until %s scheduled at %s (before %s)\n", return_value_humantime$1, return_value_humantime$2, return_value_humantime$3);
      }

    while((_Bool)0);

  else
  {
    scheduled_sleep$$1$$now=time((signed long int *)(void *)0);
    if(!(scheduled_sleep$$1$$now >= earliest))
    {
      do
        if(debug >= 1)
        {
          return_value_humantime$4=humantime(earliest);
          return_value_humantime$5=humantime(scheduled);
          return_value_humantime$6=humantime(worker_ctx->ignore_scheduled_before);
          mprintf("sleep until %s scheduled at %s (>= %s)\n", return_value_humantime$4, return_value_humantime$5, return_value_humantime$6);
        }

      while((_Bool)0);
      signed int return_value_worker_sleep$8;
      return_value_worker_sleep$8=worker_sleep(worker_ctx->c, earliest - scheduled_sleep$$1$$now);
      if(return_value_worker_sleep$8 == -1)
      {
        scheduled_sleep$$1$$now=time((signed long int *)(void *)0);
        worker_ctx->ignore_scheduled_before = scheduled_sleep$$1$$now;
        worker_ctx->next_res_init = scheduled_sleep$$1$$now + (signed long int)60;
        next_res_init = worker_ctx->next_res_init;
        __res_init();
        do
          if(debug >= 1)
          {
            return_value_humantime$7=humantime(worker_ctx->ignore_scheduled_before);
            mprintf("sleep interrupted by daemon, ignoring sleeps scheduled before now (%s)\n", return_value_humantime$7);
          }

        while((_Bool)0);
      }

    }

  }
}

// send_blocking_req_internal
// file ../include/ntp_worker.h line 118
extern signed int send_blocking_req_internal(struct blocking_child_tag *c, struct blocking_pipe_header_tag *hdr, void *data)
{
  struct blocking_pipe_header_tag *threadcopy;
  unsigned long int payload_octets;
  if(!(hdr == ((struct blocking_pipe_header_tag *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("work_thread.c", 218, (enum anonymous$46)isc_assertiontype_require, "hdr != ((void *)0)");
    (_Bool)0;
  }
  if(!(data == NULL))
    (_Bool)1;

  else
  {
    isc_assertion_failed("work_thread.c", 219, (enum anonymous$46)isc_assertiontype_require, "data != ((void *)0)");
    (_Bool)0;
  }

__CPROVER_DUMP_L6:
  ;
  if(!(hdr->octets >= 41ul))
    return 1;

  else
  {
    payload_octets = hdr->octets - sizeof(struct blocking_pipe_header_tag) /*40ul*/ ;
    ensure_workitems_empty_slot(c);
    if(c->thread_ref == ((unsigned long int *)NULL))
    {
      ensure_workresp_empty_slot(c);
      start_blocking_thread(c);
    }

    void *return_value_ereallocz$1;
    return_value_ereallocz$1=ereallocz((void *)0, hdr->octets, (unsigned long int)0, 0);
    threadcopy = (struct blocking_pipe_header_tag *)return_value_ereallocz$1;
    memcpy((void *)threadcopy, (const void *)hdr, sizeof(struct blocking_pipe_header_tag) /*40ul*/ );
    memcpy((void *)((char *)threadcopy + (signed long int)sizeof(struct blocking_pipe_header_tag) /*40ul*/ ), data, payload_octets);
    signed int return_value_queue_req_pointer$2;
    return_value_queue_req_pointer$2=queue_req_pointer(c, threadcopy);
    return return_value_queue_req_pointer$2;
  }
}

// send_blocking_resp_internal
// file ../include/ntp_worker.h line 121
extern signed int send_blocking_resp_internal(struct blocking_child_tag *c, struct blocking_pipe_header_tag *resp)
{
  ensure_workresp_empty_slot(c);
  c->responses[(signed long int)c->next_response] = resp;
  c->next_response = ((unsigned long int)1 + c->next_response) % c->responses_alloc;
  write(c->resp_write_pipe, (const void *)"", (unsigned long int)1);
  return 0;
}

// set_ctrl_c_hook
// file syssignal.c line 133
extern void set_ctrl_c_hook(void (*c_hook)(void))
{
  void (*handler)(signed int);
  if(c_hook == ((void (*)(void))NULL))
  {
    handler = (void (*)(signed int))0;
    ctrl_c_hook = (void (*)(void))(void *)0;
  }

  else
  {
    handler = sigint_handler;
    ctrl_c_hook = c_hook;
  }
  signal_no_reset(2, handler);
}

// set_sys_fuzz
// file systime.c line 104
extern void set_sys_fuzz(double fuzz_val)
{
  sys_fuzz = fuzz_val;
  if(sys_fuzz >= 0.000000)
    (_Bool)1;

  else
  {
    isc_assertion_failed("systime.c", 109, (enum anonymous$46)isc_assertiontype_insist, "sys_fuzz >= 0");
    (_Bool)0;
  }
  if(sys_fuzz <= 1.0)
    (_Bool)1;

  else
  {
    isc_assertion_failed("systime.c", 110, (enum anonymous$46)isc_assertiontype_insist, "sys_fuzz <= 1.0");
    (_Bool)0;
  }
  sys_fuzz_nsec = (signed long int)(sys_fuzz * 1e9 + 0.5);
}

// setup_logfile
// file msyslog.c line 568
extern void setup_logfile(const char *name)
{
  if(syslog_fname == ((char *)NULL) && !(name == ((const char *)NULL)))
  {
    signed int return_value_change_logfile$1;
    return_value_change_logfile$1=change_logfile(name, 1);
    if(return_value_change_logfile$1 == -1)
      msyslog(3, "Cannot open log file %s, %m", name);

    goto __CPROVER_DUMP_L4;
  }

  if(!(syslog_fname == ((char *)NULL)))
  {
    signed int return_value_change_logfile$2;
    return_value_change_logfile$2=change_logfile(syslog_fname, 0);
    if(return_value_change_logfile$2 == -1)
      msyslog(3, "Cannot reopen log file %s, %m", syslog_fname);

  }


__CPROVER_DUMP_L4:
  ;
}

// should_retry_dns
// file ntp_intres.c line 1068
static signed int should_retry_dns(signed int rescode, signed int res_errno)
{
  signed int again = 0;
  if(!(rescode == -4))
  {
    if(rescode == -3)
      goto __CPROVER_DUMP_L2;

    if(rescode == -5 || rescode == -2)
      goto __CPROVER_DUMP_L3;

    if(rescode == -11)
      goto __CPROVER_DUMP_L4;

  }

  else
  {
    again = 1;
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L2:
    ;
    again = 1;
    static signed int eai_again_seen;
    eai_again_seen = 1;
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L3:
    ;
    again = (signed int)!(eai_again_seen != 0);
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L4:
    ;
    again = 1;
  }

__CPROVER_DUMP_L5:
  ;
  const char *return_value_gai_strerror$1;
  do
    if(debug >= 2)
    {
      return_value_gai_strerror$1=gai_strerror(rescode);
      mprintf("intres: resolver returned: %s (%d), %sretrying\n", return_value_gai_strerror$1, rescode, again != 0 ? "" : "not ");
    }

  while((_Bool)0);
  return again;
}

// sigint_handler
// file syssignal.c line 123
void sigint_handler(signed int signum)
{
  (void)signum;
  if(!(ctrl_c_hook == ((void (*)(void))NULL)))
    ctrl_c_hook();

}

// signal_no_reset
// file syssignal.c line 29
extern void signal_no_reset(signed int sig, void (*func)(signed int))
{
  signed int n;
  struct sigaction vec;
  struct sigaction ovec;
  bzero((void *)&vec, sizeof(struct sigaction) /*152ul*/ );
  sigemptyset(&vec.sa_mask);
  vec.__sigaction_handler.sa_handler = func;
  if(sig == 29)
    vec.sa_flags = 0x10000000;

  if(sig == 29)
    vec.sa_flags = 0x10000000;

  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    n=sigaction(sig, &vec, &ovec);
    if(n == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = 4 == *return_value___errno_location$1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  if(n == -1)
  {
    perror("sigaction");
    exit(1);
  }

}

// sock_hash
// file socktoa.c line 107
extern unsigned short int sock_hash(const union anonymous$47 *addr)
{
  unsigned int hashVal;
  unsigned int j;
  unsigned long int len;
  const unsigned char *pch;
  hashVal = (unsigned int)0;
  len = (unsigned long int)0;
  pch = (const unsigned char *)(const void *)&addr->sa.sa_family;
  hashVal = (unsigned int)37 * hashVal + (unsigned int)*pch;
  pch = pch + 1l;
  hashVal = (unsigned int)37 * hashVal + (unsigned int)*pch;
  switch((signed int)addr->sa.sa_family)
  {
    case 2:
    {
      pch = (const unsigned char *)(const void *)&addr->sa4.sin_addr;
      len = sizeof(struct in_addr) /*4ul*/ ;
      break;
    }
    case 10:
    {
      pch = (const unsigned char *)(const void *)&addr->sa6.sin6_addr;
      len = sizeof(struct in6_addr) /*16ul*/ ;
    }
  }
  j = (unsigned int)0;
  for( ; !((unsigned long int)j >= len); j = j + 1u)
    hashVal = (unsigned int)37 * hashVal + (unsigned int)pch[(signed long int)j];
  return (unsigned short int)(hashVal & (unsigned int)(0x7fff * 2 + 1));
}

// sockaddr_masktoprefixlen
// file socktoa.c line 150
extern signed int sockaddr_masktoprefixlen(const union anonymous$47 *psa)
{
  struct isc_netaddr isc_na;
  struct isc_sockaddr isc_sa;
  unsigned int pfxlen;
  unsigned int result;
  signed int rc;
  bzero((void *)&isc_sa, sizeof(struct isc_sockaddr) /*48ul*/ );
  memcpy((void *)&isc_sa.type, (const void *)psa, sizeof(union anonymous$50) /*28ul*/  < sizeof(const union anonymous$47) /*28ul*/  ? sizeof(union anonymous$50) /*28ul*/  : sizeof(const union anonymous$47) /*28ul*/ );
  isc_netaddr_fromsockaddr(&isc_na, &isc_sa);
  result=isc_netaddr_masktoprefixlen(&isc_na, &pfxlen);
  rc = (unsigned int)0 == result ? (signed int)pfxlen : -1;
  return rc;
}

// sockporttoa
// file socktoa.c line 81
extern const char * sockporttoa(const union anonymous$47 *sock)
{
  signed int saved_errno;
  const char *atext;
  char *buf;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  saved_errno = *return_value___errno_location$1;
  atext=socktoa(sock);
  signed int tmp_post$2;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$2 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    buf = &lib_stringbuf[(signed long int)tmp_post$2][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  unsigned short int return_value_ntohs$3;
  return_value_ntohs$3=ntohs(sock->sa4.sin_port);
  snprintf(buf, (unsigned long int)128, 10 == (signed int)sock->sa.sa_family ? "[%s]:%hu" : "%s:%hu", atext, return_value_ntohs$3);
  signed int *return_value___errno_location$4;
  return_value___errno_location$4=__errno_location();
  *return_value___errno_location$4 = saved_errno;
  return buf;
}

// socktoa
// file ../include/ntp_stdlib.h line 158
extern const char * socktoa(const union anonymous$47 *sock)
{
  signed int saved_errno;
  char *res;
  char *addr;
  unsigned long int scope;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  saved_errno = *return_value___errno_location$1;
  signed int tmp_post$2;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$2 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    res = &lib_stringbuf[(signed long int)tmp_post$2][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  char *return_value_strchr$4;
  signed int tmp_post$3;
  if(sock == ((const union anonymous$47 *)NULL))
    strlcpy(res, "(null)", (unsigned long int)128);

  else
    switch((signed int)sock->sa.sa_family)
    {
      case 2:

      case 0:
      {
        inet_ntop(2, (const void *)&sock->sa4.sin_addr, res, (unsigned int)128);
        break;
      }
      case 10:
      {
        inet_ntop(10, (const void *)&sock->sa6.sin6_addr, res, (unsigned int)128);
        scope = (unsigned long int)sock->sa6.sin6_scope_id;
        if(!(scope == 0ul))
        {
          return_value_strchr$4=strchr(res, 37);
          if(return_value_strchr$4 == ((char *)NULL))
          {
            addr = res;
            do
            {
              bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
              tmp_post$3 = lib_nextbuf;
              lib_nextbuf = lib_nextbuf + 1;
              res = &lib_stringbuf[(signed long int)tmp_post$3][(signed long int)0];
              lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
            }
            while((_Bool)0);
            snprintf(res, (unsigned long int)128, "%s%%%lu", addr, scope);
            res[(signed long int)(128 - 1)] = (char)0;
          }

        }

        break;
      }
      default:
        snprintf(res, (unsigned long int)128, "(socktoa unknown family %d)", sock->sa.sa_family);
    }
  signed int *return_value___errno_location$5;
  return_value___errno_location$5=__errno_location();
  *return_value___errno_location$5 = saved_errno;
  return res;
}

// socktohost
// file socktohost.c line 25
extern const char * socktohost(const union anonymous$47 *sock)
{
  const char svc[4l] = { 'n', 't', 'p', 0 };
  char *pbuf;
  char *pliar;
  signed int gni_flags;
  struct addrinfo hints;
  struct addrinfo *alist;
  struct addrinfo *ai;
  union anonymous$47 addr;
  unsigned long int octets;
  signed int a_info;
  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    pbuf = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  gni_flags = 16 | 8;
  signed int return_value_getnameinfo$3;
  return_value_getnameinfo$3=getnameinfo(&sock->sa, (unsigned int)(2 == (signed int)sock->sa.sa_family ? sizeof(struct sockaddr_in) /*16ul*/  : sizeof(struct sockaddr_in6) /*28ul*/ ), pbuf, (unsigned int)128, (char *)(void *)0, (unsigned int)0, gni_flags);
  const char *return_value_socktoa$2;
  const char *return_value_socktoa$4;
  unsigned long int tmp_if_expr$5;
  signed int tmp_if_expr$9;
  signed int tmp_if_expr$8;
  signed int return_value_memcmp$6;
  _Bool tmp_if_expr$7;
  const char *return_value_gai_strerror$10;
  signed int tmp_post$11;
  if(!(return_value_getnameinfo$3 == 0))
  {
    return_value_socktoa$2=socktoa(sock);
    return return_value_socktoa$2;
  }

  else
  {
    do
      if(debug >= 1)
      {
        return_value_socktoa$4=socktoa(sock);
        mprintf("%s reversed to %s\n", return_value_socktoa$4, pbuf);
      }

    while((_Bool)0);
    bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = (signed int)sock->sa.sa_family;
    hints.ai_protocol = 17;
    hints.ai_socktype = 2;
    hints.ai_flags = 0;
    alist = (struct addrinfo *)(void *)0;
    a_info=getaddrinfo(pbuf, svc, &hints, &alist);
    if(a_info == -5 || a_info == -2)
    {
      hints.ai_flags = 0x0002;
      hints.ai_flags = hints.ai_flags | 0x0020;
      a_info=getaddrinfo(pbuf, svc, &hints, &alist);
    }

    if(a_info == -1)
    {
      hints.ai_flags = hints.ai_flags & ~0x0020;
      a_info=getaddrinfo(pbuf, svc, &hints, &alist);
    }

    if(a_info == 0)
    {
      if(!(alist == ((struct addrinfo *)NULL)))
        (_Bool)1;

      else
      {
        isc_assertion_failed("socktohost.c", 82, (enum anonymous$46)isc_assertiontype_insist, "alist != ((void *)0)");
        (_Bool)0;
      }
      ai = alist;
      for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
      {
        bzero((void *)&(*(&addr)), sizeof(union anonymous$47) /*28ul*/ );
        if((unsigned long int)ai->ai_addrlen >= 29ul)
          tmp_if_expr$5 = sizeof(union anonymous$47) /*28ul*/ ;

        else
          tmp_if_expr$5 = (unsigned long int)ai->ai_addrlen;
        octets = tmp_if_expr$5;
        memcpy((void *)&addr, (const void *)ai->ai_addr, octets);
        if(!(sock->sa.sa_family == addr.sa.sa_family))
          tmp_if_expr$9 = 0;

        else
        {
          if((signed int)sock->sa.sa_family == 2)
            tmp_if_expr$8 = (signed int)(sock->sa4.sin_addr.s_addr == (&addr)->sa4.sin_addr.s_addr);

          else
          {
            return_value_memcmp$6=memcmp((const void *)(&sock->sa6.sin6_addr)->__in6_u.__u6_addr8, (const void *)(&(&addr)->sa6.sin6_addr)->__in6_u.__u6_addr8, sizeof(unsigned char [16l]) /*16ul*/ );
            if(return_value_memcmp$6 == 0)
              tmp_if_expr$7 = sock->sa6.sin6_scope_id == (&addr)->sa6.sin6_scope_id ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$7 = (_Bool)0;
            tmp_if_expr$8 = (signed int)tmp_if_expr$7;
          }
          tmp_if_expr$9 = tmp_if_expr$8;
        }
        if(!(tmp_if_expr$9 == 0))
          break;

      }
      freeaddrinfo(alist);
      if(ai == ((struct addrinfo *)NULL))
        goto forward_fail;

      return pbuf;
    }

    else
    {

    forward_fail:
      ;
      do
        if(debug >= 1)
        {
          return_value_gai_strerror$10=gai_strerror(a_info);
          mprintf("%s forward check lookup fail: %s\n", pbuf, return_value_gai_strerror$10);
        }

      while((_Bool)0);
      do
      {
        bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
        tmp_post$11 = lib_nextbuf;
        lib_nextbuf = lib_nextbuf + 1;
        pliar = &lib_stringbuf[(signed long int)tmp_post$11][(signed long int)0];
        lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
      }
      while((_Bool)0);
      const char *return_value_socktoa$12;
      return_value_socktoa$12=socktoa(sock);
      snprintf(pliar, (unsigned long int)128, "%s (%s)", return_value_socktoa$12, pbuf);
      return pliar;
    }
  }
}

// sprintb
// file ntptime.c line 408
const char * sprintb(unsigned int v, const char *bits)
{
  char *cp;
  char *cplim;
  signed int i;
  signed int any;
  char c;
  _Bool tmp_if_expr$1;
  if(!(bits == ((const char *)NULL)))
    tmp_if_expr$1 = (signed int)*bits == 8 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  static char buf[132l];
  if(tmp_if_expr$1)
    snprintf(buf, sizeof(char [132l]) /*132ul*/ , "0%o", v);

  else
    snprintf(buf, sizeof(char [132l]) /*132ul*/ , "0x%x", v);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(buf);
  cp = buf + (signed long int)return_value_strlen$2;
  cplim = buf + (signed long int)sizeof(char [132l]) /*132ul*/ ;
  char *tmp_post$3;
  char *tmp_post$4;
  const char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  char *tmp_post$8;
  if(!(bits == ((const char *)NULL)))
  {
    bits = bits + 1l;
    tmp_post$3 = cp;
    cp = cp + 1l;
    *tmp_post$3 = (char)32;
    tmp_post$4 = cp;
    cp = cp + 1l;
    *tmp_post$4 = (char)40;
    any = 0;
    do
    {
      tmp_post$5 = bits;
      bits = bits + 1l;
      i = (signed int)*tmp_post$5;
      if(i == 0)
        break;

      if(!((v & (unsigned int)(1 << i + -1)) == 0u))
      {
        if(!(any == 0))
        {
          tmp_post$6 = cp;
          cp = cp + 1l;
          *tmp_post$6 = (char)44;
          if(cp >= cplim)
            goto overrun;

        }

        any = 1;
        do
        {
          c = *bits;
          if(!((signed int)c >= 33))
            break;

          tmp_post$7 = cp;
          cp = cp + 1l;
          *tmp_post$7 = c;
          if(cp >= cplim)
            goto overrun;

          bits = bits + 1l;
        }
        while((_Bool)1);
      }

      else
        for( ; (signed int)*bits >= 33; bits = bits + 1l)
          ;
    }
    while((_Bool)1);
    tmp_post$8 = cp;
    cp = cp + 1l;
    *tmp_post$8 = (char)41;
    if(cp >= cplim)
      goto overrun;

  }

  *cp = (char)0;
  return buf;

overrun:
  ;
  return "sprintb buffer too small";
}

// ssl_check_version
// file ssl_init.c line 52
extern void ssl_check_version(void)
{
  do
    if(ssl_init_done == 0)
      ssl_init();

  while((_Bool)0);
}

// ssl_init
// file ../include/ntp_stdlib.h line 217
extern void ssl_init(void)
{
  init_lib();
  if(ssl_init_done == 0)
  {
    ERR_load_crypto_strings();
    OPENSSL_add_all_algorithms_noconf();
    atexit(atexit_ssl_cleanup);
    ssl_init_done = 1;
  }

}

// start_blocking_thread
// file work_thread.c line 362
static void start_blocking_thread(struct blocking_child_tag *c)
{

__CPROVER_DUMP_L1:
  ;
  prepare_child_sems(c);
  start_blocking_thread_internal(c);
}

// start_blocking_thread_internal
// file work_thread.c line 375
static void start_blocking_thread_internal(struct blocking_child_tag *c)
{
  union pthread_attr_t thr_attr;
  signed int rc;
  signed int saved_errno;
  signed int pipe_ends[2l];
  signed int is_pipe;
  signed int flags;
  unsigned long int stacksize;
  struct anonymous$25 saved_sig_mask;
  rc=pipe_socketpair(&pipe_ends[(signed long int)0], &is_pipe);
  if(!(rc == 0))
  {
    msyslog(3, "start_blocking_thread: pipe_socketpair() %m");
    exit(1);
  }

  c->resp_read_pipe=move_fd(pipe_ends[(signed long int)0]);
  c->resp_write_pipe=move_fd(pipe_ends[(signed long int)1]);
  c->ispipe = is_pipe;
  flags=fcntl(c->resp_read_pipe, 3, 0);
  if(flags == -1)
  {
    msyslog(3, "start_blocking_thread: fcntl(F_GETFL) %m");
    exit(1);
  }

  rc=fcntl(c->resp_read_pipe, 4, 04000 | flags);
  if(rc == -1)
  {
    msyslog(3, "start_blocking_thread: fcntl(F_SETFL, O_NONBLOCK) %m");
    exit(1);
  }

  addremove_io_fd(c->resp_read_pipe, c->ispipe, 0);
  pthread_attr_init(&thr_attr);
  pthread_attr_setdetachstate(&thr_attr, 1);
  rc=pthread_attr_getstacksize(&thr_attr, &stacksize);
  if(rc == -1)
    msyslog(3, "start_blocking_thread: pthread_attr_getstacksize %m");

  else
    if(!(stacksize >= 65536ul))
    {
      rc=pthread_attr_setstacksize(&thr_attr, (unsigned long int)(64U * (unsigned int)1024));
      if(rc == -1)
        msyslog(3, "start_blocking_thread: pthread_attr_setstacksize(0x%lx -> 0x%lx) %m", (unsigned long int)stacksize, (unsigned long int)(64U * (unsigned int)1024));

    }

  void *return_value_ereallocz$1;
  return_value_ereallocz$1=ereallocz((void *)0, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)0, 1);
  c->thread_ref = (unsigned long int *)return_value_ereallocz$1;
  block_thread_signals(&saved_sig_mask);
  rc=pthread_create(c->thread_ref, &thr_attr, blocking_thread, (void *)c);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  saved_errno = *return_value___errno_location$2;
  pthread_sigmask(2, &saved_sig_mask, (struct anonymous$25 *)(void *)0);
  pthread_attr_destroy(&thr_attr);
  if(!(rc == 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = saved_errno;
    msyslog(3, "pthread_create() blocking child: %m");
    exit(1);
  }

}

// statustoa
// file statestr.c line 435
extern char * statustoa(signed int type, signed int st)
{
  char *cb;
  char *cc;
  unsigned char pst;
  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    cb = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  const char *return_value_getcode$2;
  const char *return_value_getcode$3;
  const char *return_value_getevents$4;
  const char *return_value_getcode$5;
  const char *return_value_peer_st_flags$6;
  const char *return_value_getcode$7;
  const char *return_value_getevents$8;
  const char *return_value_getevents$11;
  const char *return_value_getcode$12;
  switch(type)
  {
    case 1:
    {
      return_value_getcode$2=getcode(st >> 14 & 0x3, leap_codes);
      return_value_getcode$3=getcode(st >> 8 & 0x3f, sync_codes);
      return_value_getevents$4=getevents(st >> 4 & 0xf);
      return_value_getcode$5=getcode(st & 0xf, sys_codes);
      snprintf(cb, (unsigned long int)128, "%s, %s, %s, %s", return_value_getcode$2, return_value_getcode$3, return_value_getevents$4, return_value_getcode$5);
      break;
    }
    case 2:
    {
      pst = (unsigned char)(st >> 8 & 0xff);
      return_value_peer_st_flags$6=peer_st_flags(pst);
      return_value_getcode$7=getcode((signed int)pst & 0x7, select_codes);
      return_value_getevents$8=getevents(st >> 4 & 0xf);
      snprintf(cb, (unsigned long int)128, "%s, %s, %s", return_value_peer_st_flags$6, return_value_getcode$7, return_value_getevents$8);
      if(!((0xf & st) == 0))
      {
        unsigned long int return_value_strlen$9;
        return_value_strlen$9=strlen(cb);
        cc = cb + (signed long int)return_value_strlen$9;
        const char *return_value_getcode$10;
        return_value_getcode$10=getcode(st & 0xf, peer_codes);
        snprintf(cc, (unsigned long int)((signed long int)128 - (cc - cb)), ", %s", return_value_getcode$10);
      }

      break;
    }
    case 3:
    {
      return_value_getevents$11=getevents(st >> 4 & 0xf);
      return_value_getcode$12=getcode(st & 0xf, clock_codes);
      snprintf(cb, (unsigned long int)128, "%s, %s", return_value_getevents$11, return_value_getcode$12);
    }
  }
  return cb;
}

// step_systime
// file systime.c line 349
extern signed int step_systime(double step)
{
  signed long int pivot;
  struct timeval timetv;
  struct timeval tvlast;
  struct timeval tvdiff;
  struct timespec timets;
  struct calendar jd;
  struct anonymous$20 fp_ofs;
  struct anonymous$20 fp_sys;
  pivot = (signed long int)0x80000000;
  signed int return_value_ntpcal_get_build_date$2;
  return_value_ntpcal_get_build_date$2=ntpcal_get_build_date(&jd);
  if(!(return_value_ntpcal_get_build_date$2 == 0))
  {
    jd.year = jd.year - (unsigned short int)10;
    signed long int return_value_ntpcal_date_to_time$1;
    return_value_ntpcal_date_to_time$1=ntpcal_date_to_time(&jd);
    pivot = pivot + return_value_ntpcal_date_to_time$1;
  }

  else
    msyslog(3, "step-systime: assume 1970-01-01 as build date");
  do
  {
    double d_tmp;
    unsigned long int q_tmp;
    signed int M_isneg;
    d_tmp = sys_residual;
    M_isneg = (signed int)(d_tmp < 0.);
    if(!(M_isneg == 0))
      d_tmp = -d_tmp;

    double return_value_ldexp$3;
    return_value_ldexp$3=ldexp(d_tmp, 32);
    q_tmp = (unsigned long int)return_value_ldexp$3;
    if(!(M_isneg == 0))
      q_tmp = ~q_tmp + (unsigned long int)1;

    (&fp_sys)->l_uf = (unsigned int)q_tmp;
    (&fp_sys)->Ul_i.Xl_ui = (unsigned int)(q_tmp >> 32);
  }
  while((_Bool)0);
  do
  {
    double step_systime$$1$$4$$d_tmp;
    unsigned long int step_systime$$1$$4$$q_tmp;
    signed int step_systime$$1$$4$$M_isneg;
    step_systime$$1$$4$$d_tmp = step;
    step_systime$$1$$4$$M_isneg = (signed int)(step_systime$$1$$4$$d_tmp < 0.);
    if(!(step_systime$$1$$4$$M_isneg == 0))
      step_systime$$1$$4$$d_tmp = -step_systime$$1$$4$$d_tmp;

    double return_value_ldexp$4;
    return_value_ldexp$4=ldexp(step_systime$$1$$4$$d_tmp, 32);
    step_systime$$1$$4$$q_tmp = (unsigned long int)return_value_ldexp$4;
    if(!(step_systime$$1$$4$$M_isneg == 0))
      step_systime$$1$$4$$q_tmp = ~step_systime$$1$$4$$q_tmp + (unsigned long int)1;

    (&fp_ofs)->l_uf = (unsigned int)step_systime$$1$$4$$q_tmp;
    (&fp_ofs)->Ul_i.Xl_ui = (unsigned int)(step_systime$$1$$4$$q_tmp >> 32);
  }
  while((_Bool)0);
  do
  {
    unsigned int add_t = (&fp_ofs)->l_uf;
    (&fp_ofs)->l_uf = (&fp_ofs)->l_uf + (&fp_sys)->l_uf;
    (&fp_ofs)->Ul_i.Xl_ui = (&fp_ofs)->Ul_i.Xl_ui + (&fp_sys)->Ul_i.Xl_ui + (unsigned int)((unsigned int)(&fp_ofs)->l_uf < add_t);
  }
  while((_Bool)0);
  get_ostime(&timets);
  fp_sys=tspec_stamp_to_lfp(timets);
  tvlast.tv_sec = timets.tv_sec;
  tvlast.tv_usec = (timets.tv_nsec + (signed long int)500) / (signed long int)1000;
  do
  {
    unsigned int step_systime$$1$$6$$add_t = (&fp_sys)->l_uf;
    (&fp_sys)->l_uf = (&fp_sys)->l_uf + (&fp_ofs)->l_uf;
    (&fp_sys)->Ul_i.Xl_ui = (&fp_sys)->Ul_i.Xl_ui + (&fp_ofs)->Ul_i.Xl_ui + (unsigned int)((unsigned int)(&fp_sys)->l_uf < step_systime$$1$$6$$add_t);
  }
  while((_Bool)0);
  timetv=lfp_stamp_to_tval(fp_sys, &pivot);
  signed int return_value_ntp_set_tod$5;
  return_value_ntp_set_tod$5=ntp_set_tod(&timetv, (void *)0);
  if(!(return_value_ntp_set_tod$5 == 0))
  {
    msyslog(3, "step-systime: %m");
    return 0;
  }

  else
  {
    sys_residual = (double)0;
    lamport_violated = (signed int)(step < (double)0);
    if(!(step_callback == ((void (*)(void))NULL)))
      step_callback();

    struct timeval return_value_sub_tval$6;
    return_value_sub_tval$6=sub_tval(timetv, tvlast);
    tvdiff=abs_tval(return_value_sub_tval$6);
    if(tvdiff.tv_sec >= 1l)
    {
      struct utmp ut;
      struct utmpx utx;
      bzero((void *)&ut, sizeof(struct utmp) /*384ul*/ );
      bzero((void *)&utx, sizeof(struct utmpx) /*384ul*/ );
    }

    return 1;
  }
}

// strlcat
// file strl_obsd.c line 97
extern unsigned long int strlcat(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  unsigned long int dlen;
  unsigned long int tmp_post$1;
  do
  {
    tmp_post$1 = n;
    n = n - 1ul;
    if(tmp_post$1 == 0ul)
      break;

    if((signed int)*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = siz - dlen;
  unsigned long int return_value_strlen$2;
  char *tmp_post$3;
  if(n == 0ul)
  {
    return_value_strlen$2=strlen(s);
    return dlen + return_value_strlen$2;
  }

  else
  {
    for( ; !((signed int)*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        tmp_post$3 = d;
        d = d + 1l;
        *tmp_post$3 = *s;
        n = n - 1ul;
      }

    *d = (char)0;
    return dlen + (unsigned long int)(s - src);
  }
}

// strlcpy
// file ../include/ntp_stdlib.h line 239
extern unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  char *tmp_post$1;
  const char *tmp_post$2;
  if(!(n == 0ul))
    do
    {
      n = n - 1ul;
      if(n == 0ul)
        break;

      tmp_post$1 = d;
      d = d + 1l;
      tmp_post$2 = s;
      s = s + 1l;
      *tmp_post$1 = *tmp_post$2;
      if((signed int)*tmp_post$1 == 0)
        break;

    }
    while((_Bool)1);

  const char *tmp_post$3;
  if(n == 0ul)
  {
    if(!(siz == 0ul))
      *d = (char)0;

    do
    {
      tmp_post$3 = s;
      s = s + 1l;
      if(*tmp_post$3 == 0)
        break;

    }
    while((_Bool)1);
  }

  return (unsigned long int)((s - src) - (signed long int)1);
}

// strtouv64
// file vint64ops.c line 42
extern union anonymous$44 strtouv64(const char *begp, char **endp, signed int base)
{
  union anonymous$44 res;
  unsigned char digit;
  signed int sig;
  signed int num;
  const unsigned char *src;
  sig = 0;
  num = sig;
  src = (const unsigned char *)begp;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*src]) == 0)
      break;

    src = src + 1l;
  }
  while((_Bool)1);
  if((signed int)*src == 45)
  {
    src = src + 1l;
    sig = 1;
  }

  else
    if((signed int)*src == 43)
      src = src + 1l;

  signed int return_value_toupper$3;
  if(base == 0)
  {
    base = 10;
    if((signed int)*src == 48)
    {
      base = 8;
      src = src + 1l;
      signed int return_value_toupper$2;
      return_value_toupper$2=toupper((signed int)*src);
      if(return_value_toupper$2 == 88)
      {
        src = src + 1l;
        base = 16;
      }

    }

  }

  else
    if(base == 16)
    {
      if((signed int)*src == 48)
      {
        return_value_toupper$3=toupper((signed int)src[(signed long int)1]);
        if(return_value_toupper$3 == 88)
          src = src + (signed long int)2;

      }

    }

    else
      if(base >= 37 || !(base >= 3))
      {
        memset((void *)&res, 0xFF, sizeof(union anonymous$44) /*8ul*/ );
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 34;
        return res;
      }

  memset((void *)&res, 0, sizeof(union anonymous$44) /*8ul*/ );
  const unsigned short int **return_value___ctype_b_loc$6;
  const unsigned short int **return_value___ctype_b_loc$5;
  while(!(*src == 0))
  {
    const unsigned short int **return_value___ctype_b_loc$7;
    return_value___ctype_b_loc$7=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*src]) == 0))
      digit = (unsigned char)((signed int)*src - 48);

    else
    {
      return_value___ctype_b_loc$6=__ctype_b_loc();
      if(!((256 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*src]) == 0))
        digit = (unsigned char)(((signed int)*src - 65) + 10);

      else
      {
        return_value___ctype_b_loc$5=__ctype_b_loc();
        if(!((512 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*src]) == 0))
          digit = (unsigned char)(((signed int)*src - 97) + 10);

        else
          break;
      }
    }
    if((signed int)digit >= base)
      break;

    num = 1;
    res.Q_s = res.Q_s * (unsigned long int)base + (unsigned long int)digit;
    src = src + 1l;
  }
  signed int *return_value___errno_location$8;
  if(num == 0)
  {
    return_value___errno_location$8=__errno_location();
    *return_value___errno_location$8 = 22;
  }

  void *return_value_noconst$9;
  if(!(endp == ((char **)NULL)))
  {
    return_value_noconst$9=noconst((const void *)src);
    *endp = (char *)return_value_noconst$9;
  }

  if(!(sig == 0))
    do
    {
      res.D_s.lo = ~res.D_s.lo + 1u;
      res.D_s.hi = ~res.D_s.hi + (unsigned int)(res.D_s.lo == (unsigned int)0);
    }
    while((_Bool)0);

  return res;
}

// sub_tspec
// file ../include/timespecops.h line 155
static inline struct timespec sub_tspec(struct timespec a, struct timespec b)
{
  struct timespec x = a;
  x.tv_sec = x.tv_sec - b.tv_sec;
  x.tv_nsec = x.tv_nsec - b.tv_nsec;
  struct timespec return_value_normalize_tspec$1;
  return_value_normalize_tspec$1=normalize_tspec(x);
  return return_value_normalize_tspec$1;
}

// sub_tval
// file ../include/timevalops.h line 211
static inline struct timeval sub_tval(struct timeval a, struct timeval b)
{
  struct timeval x = a;
  x.tv_sec = x.tv_sec - b.tv_sec;
  x.tv_usec = x.tv_usec - b.tv_usec;
  struct timeval return_value_normalize_tval$1;
  return_value_normalize_tval$1=normalize_tval(x);
  return return_value_normalize_tval$1;
}

// subv64
// file vint64ops.c line 194
extern union anonymous$44 subv64(const union anonymous$44 *lhs, const union anonymous$44 *rhs)
{
  union anonymous$44 res;
  res.Q_s = lhs->Q_s - rhs->Q_s;
  return res;
}

// subv64i32
// file vint64ops.c line 232
extern union anonymous$44 subv64i32(const union anonymous$44 *lhs, signed int rhs)
{
  union anonymous$44 res = *lhs;
  res.q_s = res.q_s - (signed long int)rhs;
  return res;
}

// subv64u32
// file vint64ops.c line 270
extern union anonymous$44 subv64u32(const union anonymous$44 *lhs, unsigned int rhs)
{
  union anonymous$44 res = *lhs;
  res.Q_s = res.Q_s - (unsigned long int)rhs;
  return res;
}

// symtbl_compare
// file ./../lib/isc/backtrace.c line 229
static signed int symtbl_compare(const void *addr, const void *entryarg)
{
  const struct isc_backtrace_symmap *entry = (const struct isc_backtrace_symmap *)entryarg;
  const struct isc_backtrace_symmap *end = &isc__backtrace_symtable[(signed long int)(isc__backtrace_nsymbols - 1)];
  if(entry == end || isc__backtrace_nsymbols == 1)
  {
    if(addr >= entry->addr)
      return 0;

    return -1;
  }

  else
  {
    if(!(addr >= entry->addr))
      return -1;

    else
      if(addr >= (entry + 1l)->addr)
        return 1;

    return 0;
  }
}

// sync_channellist
// file ./../lib/isc/log.c line 1107
static unsigned int sync_channellist(struct isc_logconfig *lcfg)
{
  unsigned int bytes;
  struct isc_log *lctx;
  void *lists;
  _Bool tmp_if_expr$1;
  if(!(lcfg == ((struct isc_logconfig *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)lcfg)->magic == (unsigned int)(76 << 24 | 99 << 16 | 102 << 8 | 103) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1112, (enum anonymous$46)isc_assertiontype_require, "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
    (_Bool)0;
  }
  lctx = lcfg->lctx;
  if(!(lctx->category_count == 0u))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/log.c", 1116, (enum anonymous$46)isc_assertiontype_require, "lctx->category_count != 0");
    (_Bool)0;
  }
  if(lctx->category_count == lcfg->channellist_count)
    return (unsigned int)0;

  else
  {
    /* tag-#anon#lST[l*{SYM#tag-isc_logchannellist#}$SYM#tag-isc_logchannellist#$'head'||l*{SYM#tag-isc_logchannellist#}$SYM#tag-isc_logchannellist#$'tail'|] */
struct anonymous$30
{
  // head
  struct isc_logchannellist *head;
  // tail
  struct isc_logchannellist *tail;
};

/* */
    ;
    bytes = (unsigned int)((unsigned long int)lctx->category_count * sizeof(struct anonymous$30) /*16ul*/ );
    (void)lctx->mctx;
    void *return_value_ereallocz$2;
    return_value_ereallocz$2=ereallocz((void *)0, (unsigned long int)bytes, (unsigned long int)0, 0);
    lists = return_value_ereallocz$2;
    if(lists == NULL)
      return (unsigned int)1;

    else
    {
      memset(lists, 0, (unsigned long int)bytes);
      if(!(lcfg->channellist_count == 0u))
      {
        bytes = (unsigned int)((unsigned long int)lcfg->channellist_count * sizeof(struct anonymous$30) /*16ul*/ );
        memcpy(lists, (const void *)lcfg->channellists, (unsigned long int)bytes);
        (void)bytes;
        (void)lctx->mctx;
        free((void *)lcfg->channellists);
      }

      lcfg->channellists = (struct anonymous$23 *)lists;
      lcfg->channellist_count = lctx->category_count;
      return (unsigned int)0;
    }
  }
}

// task_detach
// file ./../lib/isc/task.c line 476
static inline enum anonymous$11 task_detach(struct isc__task *task)
{
  if(task->references >= 1u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 482, (enum anonymous$46)isc_assertiontype_require, "task->references > 0");
    (_Bool)0;
  }
  task->references = task->references - 1u;
  if(task->references == 0u)
  {
    if(!((signed int)task->state == task_state_idle))
      goto __CPROVER_DUMP_L7;

    if(task->events.head == ((struct isc_event *)NULL))
      (_Bool)1;

    else
    {
      isc_assertion_failed("./../lib/isc/task.c", 488, (enum anonymous$46)isc_assertiontype_insist, "(((task->events).head == ((void *)0)) ? isc_boolean_true : isc_boolean_false)");
      (_Bool)0;
    }
    task->state = (enum anonymous$56)task_state_ready;
    return (enum anonymous$11)isc_boolean_true;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    return (enum anonymous$11)isc_boolean_false;
  }
}

// task_finished
// file ./../lib/isc/task.c line 297
static void task_finished(struct isc__task *task)
{
  struct isc__taskmgr *manager = task->manager;
  if(task->events.head == ((struct isc_event *)NULL))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 300, (enum anonymous$46)isc_assertiontype_require, "(((task->events).head == ((void *)0)) ? isc_boolean_true : isc_boolean_false)");
    (_Bool)0;
  }
  if(task->on_shutdown.head == ((struct isc_event *)NULL))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 301, (enum anonymous$46)isc_assertiontype_require, "(((task->on_shutdown).head == ((void *)0)) ? isc_boolean_true : isc_boolean_false)");
    (_Bool)0;
  }
  if(task->references == 0u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 302, (enum anonymous$46)isc_assertiontype_require, "task->references == 0");
    (_Bool)0;
  }
  if((signed int)task->state == task_state_done)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 303, (enum anonymous$46)isc_assertiontype_require, "task->state == task_state_done");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$1 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 307, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);

__CPROVER_DUMP_L16:
  ;
  do
  {
    if(!(task->link.next == ((struct isc__task *)NULL)))
      task->link.next->link.prev = task->link.prev;

    else
    {
      if(manager->tasks.tail == task)
        (_Bool)1;

      else
      {
        isc_assertion_failed("./../lib/isc/task.c", 308, (enum anonymous$46)isc_assertiontype_insist, "(manager->tasks).tail == (task)");
        (_Bool)0;
      }
      manager->tasks.tail = task->link.prev;
    }
    if(!(task->link.prev == ((struct isc__task *)NULL)))
      task->link.prev->link.next = task->link.next;

    else
    {
      if(manager->tasks.head == task)
        (_Bool)1;

      else
      {
        isc_assertion_failed("./../lib/isc/task.c", 308, (enum anonymous$46)isc_assertiontype_insist, "(manager->tasks).head == (task)");
        (_Bool)0;
      }
      manager->tasks.head = task->link.next;
    }
    task->link.prev = (struct isc__task *)(void *)-1;
    task->link.next = (struct isc__task *)(void *)-1;
  }
  while((_Bool)0);
  if(!(manager->exiting == /*enum*/isc_boolean_false))
  {
    if(manager->tasks.head == ((struct isc__task *)NULL))
      do
      {
        signed int return_value_pthread_cond_broadcast$2;
        return_value_pthread_cond_broadcast$2=pthread_cond_broadcast(&manager->work_available);
        if(return_value_pthread_cond_broadcast$2 == 0)
          (_Bool)1;

        else
        {
          isc_error_runtimecheck("./../lib/isc/task.c", 317, "((pthread_cond_broadcast(((&manager->work_available))) == 0) ? 0 : 34) == 0");
          (_Bool)0;
        }
      }
      while((_Bool)0);

  }

  do
  {
    signed int return_value_pthread_mutex_unlock$3;
    return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$3 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 320, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  signed int return_value_pthread_mutex_destroy$4;
  return_value_pthread_mutex_destroy$4=pthread_mutex_destroy(&task->lock);
  if(return_value_pthread_mutex_destroy$4 == 0)
    (_Bool)1;

  else
  {
    isc_error_runtimecheck("./../lib/isc/task.c", 322, "((pthread_mutex_destroy(((&task->lock))) == 0) ? 0 : 34) == 0");
    (_Bool)0;
  }
  task->common.impmagic = (unsigned int)0;
  task->common.magic = (unsigned int)0;
  (void)manager->mctx;
  free((void *)task);
}

// task_ready
// file ./../lib/isc/task.c line 455
static inline void task_ready(struct isc__task *task)
{
  struct isc__taskmgr *manager = task->manager;
  enum anonymous$11 has_privilege;
  has_privilege=isc__task_privilege((struct isc_task *)task);
  _Bool tmp_if_expr$1;
  if(!(manager == ((struct isc__taskmgr *)NULL)))
    tmp_if_expr$1 = ((const struct anonymous$21 *)manager)->magic == (unsigned int)(84 << 24 | 83 << 16 | 75 << 8 | 77) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 461, (enum anonymous$46)isc_assertiontype_require, "(((manager) != ((void *)0)) && (((const isc__magic_t *)(manager))->magic == ((('T') << 24 | ('S') << 16 | ('K') << 8 | ('M')))))");
    (_Bool)0;
  }
  if((signed int)task->state == task_state_ready)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 462, (enum anonymous$46)isc_assertiontype_require, "task->state == task_state_ready");
    (_Bool)0;
  }
  do
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&manager->lock);
    if(return_value_pthread_mutex_lock$2 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 466, "((pthread_mutex_lock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
  push_readyq(manager, task);
  if((signed int)manager->mode == isc_taskmgrmode_normal || !(has_privilege == /*enum*/isc_boolean_false))
    do
    {
      signed int return_value_pthread_cond_signal$3;
      return_value_pthread_cond_signal$3=pthread_cond_signal(&manager->work_available);
      if(return_value_pthread_cond_signal$3 == 0)
        (_Bool)1;

      else
      {
        isc_error_runtimecheck("./../lib/isc/task.c", 470, "((pthread_cond_signal(((&manager->work_available))) == 0) ? 0 : 34) == 0");
        (_Bool)0;
      }
    }
    while((_Bool)0);

  do
  {
    signed int return_value_pthread_mutex_unlock$4;
    return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(&manager->lock);
    if(return_value_pthread_mutex_unlock$4 == 0)
      (_Bool)1;

    else
    {
      isc_error_runtimecheck("./../lib/isc/task.c", 472, "((pthread_mutex_unlock(((&manager->lock))) == 0) ? 0 : 34) == 0");
      (_Bool)0;
    }
  }
  while((_Bool)0);
}

// task_send
// file ./../lib/isc/task.c line 530
static inline enum anonymous$11 task_send(struct isc__task *task, struct isc_event **eventp)
{
  enum anonymous$11 was_idle = (enum anonymous$11)isc_boolean_false;
  struct isc_event *event;
  if(!(eventp == ((struct isc_event **)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 538, (enum anonymous$46)isc_assertiontype_require, "eventp != ((void *)0)");
    (_Bool)0;
  }
  event = *eventp;
  if(!(event == ((struct isc_event *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 540, (enum anonymous$46)isc_assertiontype_require, "event != ((void *)0)");
    (_Bool)0;
  }
  if(event->ev_type >= 1u)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 541, (enum anonymous$46)isc_assertiontype_require, "event->ev_type > 0");
    (_Bool)0;
  }
  if(!((signed int)task->state == task_state_done))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 542, (enum anonymous$46)isc_assertiontype_require, "task->state != task_state_done");
    (_Bool)0;
  }
  if((signed int)task->state == task_state_idle)
  {
    was_idle = (enum anonymous$11)isc_boolean_true;
    if(task->events.head == ((struct isc_event *)NULL))
      (_Bool)1;

    else
    {
      isc_assertion_failed("./../lib/isc/task.c", 548, (enum anonymous$46)isc_assertiontype_insist, "(((task->events).head == ((void *)0)) ? isc_boolean_true : isc_boolean_false)");
      (_Bool)0;
    }
    task->state = (enum anonymous$56)task_state_ready;
  }

  _Bool tmp_if_expr$1;
  if((signed int)task->state == task_state_ready)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)task->state == task_state_running ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/task.c", 552, (enum anonymous$46)isc_assertiontype_insist, "task->state == task_state_ready || task->state == task_state_running");
    (_Bool)0;
  }

__CPROVER_DUMP_L21:
  ;
  do
  {
    if(!(task->events.tail == ((struct isc_event *)NULL)))
      task->events.tail->ev_link.next = event;

    else
      task->events.head = event;
    event->ev_link.prev = task->events.tail;
    event->ev_link.next = (struct isc_event *)(void *)0;
    task->events.tail = event;
  }
  while((_Bool)0);
  *eventp = (struct isc_event *)(void *)0;
  return was_idle;
}

// task_shutdown
// file ./../lib/isc/task.c line 412
static inline enum anonymous$11 task_shutdown(struct isc__task *task)
{
  enum anonymous$11 was_idle = (enum anonymous$11)isc_boolean_false;
  struct isc_event *event;
  struct isc_event *prev;
  _Bool tmp_if_expr$1;
  if((1u & task->flags) == 0u)
  {
    task->flags = task->flags | (unsigned int)0x01;
    if((signed int)task->state == task_state_idle)
    {
      if(task->events.head == ((struct isc_event *)NULL))
        (_Bool)1;

      else
      {
        isc_assertion_failed("./../lib/isc/task.c", 427, (enum anonymous$46)isc_assertiontype_insist, "(((task->events).head == ((void *)0)) ? isc_boolean_true : isc_boolean_false)");
        (_Bool)0;
      }
      task->state = (enum anonymous$56)task_state_ready;
      was_idle = (enum anonymous$11)isc_boolean_true;
    }

    if((signed int)task->state == task_state_ready)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)task->state == task_state_running ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      (_Bool)1;

    else
    {
      isc_assertion_failed("./../lib/isc/task.c", 432, (enum anonymous$46)isc_assertiontype_insist, "task->state == task_state_ready || task->state == task_state_running");
      (_Bool)0;
    }
    event = task->on_shutdown.tail;
    for( ; !(event == ((struct isc_event *)NULL)); event = prev)
    {
      prev = event->ev_link.prev;

    __CPROVER_DUMP_L11:
      ;
      do
      {
        if(!(event->ev_link.next == ((struct isc_event *)NULL)))
          event->ev_link.next->ev_link.prev = event->ev_link.prev;

        else
        {
          if(task->on_shutdown.tail == event)
            (_Bool)1;

          else
          {
            isc_assertion_failed("./../lib/isc/task.c", 441, (enum anonymous$46)isc_assertiontype_insist, "(task->on_shutdown).tail == (event)");
            (_Bool)0;
          }
          task->on_shutdown.tail = event->ev_link.prev;
        }
        if(!(event->ev_link.prev == ((struct isc_event *)NULL)))
          event->ev_link.prev->ev_link.next = event->ev_link.next;

        else
        {
          if(task->on_shutdown.head == event)
            (_Bool)1;

          else
          {
            isc_assertion_failed("./../lib/isc/task.c", 441, (enum anonymous$46)isc_assertiontype_insist, "(task->on_shutdown).head == (event)");
            (_Bool)0;
          }
          task->on_shutdown.head = event->ev_link.next;
        }
        event->ev_link.prev = (struct isc_event *)(void *)-1;
        event->ev_link.next = (struct isc_event *)(void *)-1;
      }
      while((_Bool)0);

    __CPROVER_DUMP_L22:
      ;
      do
      {
        if(!(task->events.tail == ((struct isc_event *)NULL)))
          task->events.tail->ev_link.next = event;

        else
          task->events.head = event;
        event->ev_link.prev = task->events.tail;
        event->ev_link.next = (struct isc_event *)(void *)0;
        task->events.tail = event;
      }
      while((_Bool)0);
    }
  }

  return was_idle;
}

// time_to_vint64
// file ntp_calendar.c line 240
extern union anonymous$44 time_to_vint64(const signed long int *ptt)
{
  union anonymous$44 res;
  signed long int tt = *ptt;
  res.q_s = tt;
  return res;
}

// timex_state
// file ntptime.c line 465
const char * timex_state(signed int s)
{
  if(!((unsigned long int)s >= 6ul))
    return timex_states[(signed long int)s];

  else
  {
    static char buf[32l];
    snprintf(buf, sizeof(char [32l]) /*32ul*/ , "TIME-#%d", s);
    return buf;
  }
}

// total_recvbuffs
// file recvbuff.c line 61
extern unsigned long int total_recvbuffs(void)
{
  return total_recvbufs;
}

// transform
// file ./../lib/isc/md5.c line 122
static void transform(unsigned int *buf, const unsigned int *in)
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  a = buf[(signed long int)0];
  b = buf[(signed long int)1];
  c = buf[(signed long int)2];
  d = buf[(signed long int)3];
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)0] + 0xd76aa478;
  a = (a << 7 | a >> 32 - 7) + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)1] + 0xe8c7b756;
  d = (d << 12 | d >> 32 - 12) + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)2] + (unsigned int)0x242070db;
  c = (c << 17 | c >> 32 - 17) + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)3] + 0xc1bdceee;
  b = (b << 22 | b >> 32 - 22) + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)4] + 0xf57c0faf;
  a = (a << 7 | a >> 32 - 7) + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)5] + (unsigned int)0x4787c62a;
  d = (d << 12 | d >> 32 - 12) + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)6] + 0xa8304613;
  c = (c << 17 | c >> 32 - 17) + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)7] + 0xfd469501;
  b = (b << 22 | b >> 32 - 22) + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x698098d8;
  a = (a << 7 | a >> 32 - 7) + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)9] + 0x8b44f7af;
  d = (d << 12 | d >> 32 - 12) + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)10] + 0xffff5bb1;
  c = (c << 17 | c >> 32 - 17) + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)11] + 0x895cd7be;
  b = (b << 22 | b >> 32 - 22) + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)12] + (unsigned int)0x6b901122;
  a = (a << 7 | a >> 32 - 7) + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)13] + 0xfd987193;
  d = (d << 12 | d >> 32 - 12) + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)14] + 0xa679438e;
  c = (c << 17 | c >> 32 - 17) + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)15] + (unsigned int)0x49b40821;
  b = (b << 22 | b >> 32 - 22) + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)1] + 0xf61e2562;
  a = (a << 5 | a >> 32 - 5) + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)6] + 0xc040b340;
  d = (d << 9 | d >> 32 - 9) + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)11] + (unsigned int)0x265e5a51;
  c = (c << 14 | c >> 32 - 14) + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)0] + 0xe9b6c7aa;
  b = (b << 20 | b >> 32 - 20) + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)5] + 0xd62f105d;
  a = (a << 5 | a >> 32 - 5) + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)10] + (unsigned int)0x02441453;
  d = (d << 9 | d >> 32 - 9) + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)15] + 0xd8a1e681;
  c = (c << 14 | c >> 32 - 14) + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)4] + 0xe7d3fbc8;
  b = (b << 20 | b >> 32 - 20) + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = (a << 5 | a >> 32 - 5) + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)14] + 0xc33707d6;
  d = (d << 9 | d >> 32 - 9) + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)3] + 0xf4d50d87;
  c = (c << 14 | c >> 32 - 14) + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x455a14ed;
  b = (b << 20 | b >> 32 - 20) + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)13] + 0xa9e3e905;
  a = (a << 5 | a >> 32 - 5) + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)2] + 0xfcefa3f8;
  d = (d << 9 | d >> 32 - 9) + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)7] + (unsigned int)0x676f02d9;
  c = (c << 14 | c >> 32 - 14) + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)12] + 0x8d2a4c8a;
  b = (b << 20 | b >> 32 - 20) + c;
  a = a + (b ^ c ^ d) + in[(signed long int)5] + 0xfffa3942;
  a = (a << 4 | a >> 32 - 4) + b;
  d = d + (a ^ b ^ c) + in[(signed long int)8] + 0x8771f681;
  d = (d << 11 | d >> 32 - 11) + a;
  c = c + (d ^ a ^ b) + in[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = (c << 16 | c >> 32 - 16) + d;
  b = b + (c ^ d ^ a) + in[(signed long int)14] + 0xfde5380c;
  b = (b << 23 | b >> 32 - 23) + c;
  a = a + (b ^ c ^ d) + in[(signed long int)1] + 0xa4beea44;
  a = (a << 4 | a >> 32 - 4) + b;
  d = d + (a ^ b ^ c) + in[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = (d << 11 | d >> 32 - 11) + a;
  c = c + (d ^ a ^ b) + in[(signed long int)7] + 0xf6bb4b60;
  c = (c << 16 | c >> 32 - 16) + d;
  b = b + (c ^ d ^ a) + in[(signed long int)10] + 0xbebfbc70;
  b = (b << 23 | b >> 32 - 23) + c;
  a = a + (b ^ c ^ d) + in[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = (a << 4 | a >> 32 - 4) + b;
  d = d + (a ^ b ^ c) + in[(signed long int)0] + 0xeaa127fa;
  d = (d << 11 | d >> 32 - 11) + a;
  c = c + (d ^ a ^ b) + in[(signed long int)3] + 0xd4ef3085;
  c = (c << 16 | c >> 32 - 16) + d;
  b = b + (c ^ d ^ a) + in[(signed long int)6] + (unsigned int)0x04881d05;
  b = (b << 23 | b >> 32 - 23) + c;
  a = a + (b ^ c ^ d) + in[(signed long int)9] + 0xd9d4d039;
  a = (a << 4 | a >> 32 - 4) + b;
  d = d + (a ^ b ^ c) + in[(signed long int)12] + 0xe6db99e5;
  d = (d << 11 | d >> 32 - 11) + a;
  c = c + (d ^ a ^ b) + in[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = (c << 16 | c >> 32 - 16) + d;
  b = b + (c ^ d ^ a) + in[(signed long int)2] + 0xc4ac5665;
  b = (b << 23 | b >> 32 - 23) + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)0] + 0xf4292244;
  a = (a << 6 | a >> 32 - 6) + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)7] + (unsigned int)0x432aff97;
  d = (d << 10 | d >> 32 - 10) + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)14] + 0xab9423a7;
  c = (c << 15 | c >> 32 - 15) + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)5] + 0xfc93a039;
  b = (b << 21 | b >> 32 - 21) + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)12] + (unsigned int)0x655b59c3;
  a = (a << 6 | a >> 32 - 6) + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)3] + 0x8f0ccc92;
  d = (d << 10 | d >> 32 - 10) + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)10] + 0xffeff47d;
  c = (c << 15 | c >> 32 - 15) + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)1] + 0x85845dd1;
  b = (b << 21 | b >> 32 - 21) + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = (a << 6 | a >> 32 - 6) + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)15] + 0xfe2ce6e0;
  d = (d << 10 | d >> 32 - 10) + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)6] + 0xa3014314;
  c = (c << 15 | c >> 32 - 15) + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = (b << 21 | b >> 32 - 21) + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)4] + 0xf7537e82;
  a = (a << 6 | a >> 32 - 6) + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)11] + 0xbd3af235;
  d = (d << 10 | d >> 32 - 10) + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = (c << 15 | c >> 32 - 15) + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)9] + 0xeb86d391;
  b = (b << 21 | b >> 32 - 21) + c;
  buf[(signed long int)0] = buf[(signed long int)0] + a;
  buf[(signed long int)1] = buf[(signed long int)1] + b;
  buf[(signed long int)2] = buf[(signed long int)2] + c;
  buf[(signed long int)3] = buf[(signed long int)3] + d;
}

// transform$link1
// file ./../lib/isc/sha1.c line 203
static void transform$link1(unsigned int *state, const unsigned char *buffer)
{
  unsigned int a$link1;
  unsigned int b$link1;
  unsigned int c$link1;
  unsigned int d$link1;
  unsigned int e;
  union anonymous$63 *block;
  union anonymous$63 workspace;
  if(!(buffer == ((const unsigned char *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sha1.c", 208, (enum anonymous$46)isc_assertiontype_insist, "buffer != ((void *)0)");
    (_Bool)0;
  }
  if(!(state == ((unsigned int *)NULL)))
    (_Bool)1;

  else
  {
    isc_assertion_failed("./../lib/isc/sha1.c", 209, (enum anonymous$46)isc_assertiontype_insist, "state != ((void *)0)");
    (_Bool)0;
  }
  block = &workspace;
  memcpy((void *)block, (const void *)buffer, (unsigned long int)64);
  a$link1 = state[(signed long int)0];
  b$link1 = state[(signed long int)1];
  c$link1 = state[(signed long int)2];
  d$link1 = state[(signed long int)3];
  e = state[(signed long int)4];
  block->l[(signed long int)0] = (block->l[(signed long int)0] << 24 | block->l[(signed long int)0] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)0] << 8 | block->l[(signed long int)0] >> 32 - 8) & (unsigned int)0x00FF00FF;
  e = e + (b$link1 & (c$link1 ^ d$link1) ^ d$link1) + block->l[(signed long int)0] + (unsigned int)0x5A827999 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)1] = (block->l[(signed long int)1] << 24 | block->l[(signed long int)1] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)1] << 8 | block->l[(signed long int)1] >> 32 - 8) & (unsigned int)0x00FF00FF;
  d$link1 = d$link1 + (a$link1 & (b$link1 ^ c$link1) ^ c$link1) + block->l[(signed long int)1] + (unsigned int)0x5A827999 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)2] = (block->l[(signed long int)2] << 24 | block->l[(signed long int)2] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)2] << 8 | block->l[(signed long int)2] >> 32 - 8) & (unsigned int)0x00FF00FF;
  c$link1 = c$link1 + (e & (a$link1 ^ b$link1) ^ b$link1) + block->l[(signed long int)2] + (unsigned int)0x5A827999 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)3] = (block->l[(signed long int)3] << 24 | block->l[(signed long int)3] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)3] << 8 | block->l[(signed long int)3] >> 32 - 8) & (unsigned int)0x00FF00FF;
  b$link1 = b$link1 + (d$link1 & (e ^ a$link1) ^ a$link1) + block->l[(signed long int)3] + (unsigned int)0x5A827999 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)4] = (block->l[(signed long int)4] << 24 | block->l[(signed long int)4] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)4] << 8 | block->l[(signed long int)4] >> 32 - 8) & (unsigned int)0x00FF00FF;
  a$link1 = a$link1 + (c$link1 & (d$link1 ^ e) ^ e) + block->l[(signed long int)4] + (unsigned int)0x5A827999 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)5] = (block->l[(signed long int)5] << 24 | block->l[(signed long int)5] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)5] << 8 | block->l[(signed long int)5] >> 32 - 8) & (unsigned int)0x00FF00FF;
  e = e + (b$link1 & (c$link1 ^ d$link1) ^ d$link1) + block->l[(signed long int)5] + (unsigned int)0x5A827999 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)6] = (block->l[(signed long int)6] << 24 | block->l[(signed long int)6] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)6] << 8 | block->l[(signed long int)6] >> 32 - 8) & (unsigned int)0x00FF00FF;
  d$link1 = d$link1 + (a$link1 & (b$link1 ^ c$link1) ^ c$link1) + block->l[(signed long int)6] + (unsigned int)0x5A827999 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)7] = (block->l[(signed long int)7] << 24 | block->l[(signed long int)7] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)7] << 8 | block->l[(signed long int)7] >> 32 - 8) & (unsigned int)0x00FF00FF;
  c$link1 = c$link1 + (e & (a$link1 ^ b$link1) ^ b$link1) + block->l[(signed long int)7] + (unsigned int)0x5A827999 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)8] = (block->l[(signed long int)8] << 24 | block->l[(signed long int)8] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)8] << 8 | block->l[(signed long int)8] >> 32 - 8) & (unsigned int)0x00FF00FF;
  b$link1 = b$link1 + (d$link1 & (e ^ a$link1) ^ a$link1) + block->l[(signed long int)8] + (unsigned int)0x5A827999 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)9] = (block->l[(signed long int)9] << 24 | block->l[(signed long int)9] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)9] << 8 | block->l[(signed long int)9] >> 32 - 8) & (unsigned int)0x00FF00FF;
  a$link1 = a$link1 + (c$link1 & (d$link1 ^ e) ^ e) + block->l[(signed long int)9] + (unsigned int)0x5A827999 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)10] = (block->l[(signed long int)10] << 24 | block->l[(signed long int)10] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)10] << 8 | block->l[(signed long int)10] >> 32 - 8) & (unsigned int)0x00FF00FF;
  e = e + (b$link1 & (c$link1 ^ d$link1) ^ d$link1) + block->l[(signed long int)10] + (unsigned int)0x5A827999 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)11] = (block->l[(signed long int)11] << 24 | block->l[(signed long int)11] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)11] << 8 | block->l[(signed long int)11] >> 32 - 8) & (unsigned int)0x00FF00FF;
  d$link1 = d$link1 + (a$link1 & (b$link1 ^ c$link1) ^ c$link1) + block->l[(signed long int)11] + (unsigned int)0x5A827999 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)12] = (block->l[(signed long int)12] << 24 | block->l[(signed long int)12] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)12] << 8 | block->l[(signed long int)12] >> 32 - 8) & (unsigned int)0x00FF00FF;
  c$link1 = c$link1 + (e & (a$link1 ^ b$link1) ^ b$link1) + block->l[(signed long int)12] + (unsigned int)0x5A827999 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)13] = (block->l[(signed long int)13] << 24 | block->l[(signed long int)13] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)13] << 8 | block->l[(signed long int)13] >> 32 - 8) & (unsigned int)0x00FF00FF;
  b$link1 = b$link1 + (d$link1 & (e ^ a$link1) ^ a$link1) + block->l[(signed long int)13] + (unsigned int)0x5A827999 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)14] = (block->l[(signed long int)14] << 24 | block->l[(signed long int)14] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)14] << 8 | block->l[(signed long int)14] >> 32 - 8) & (unsigned int)0x00FF00FF;
  a$link1 = a$link1 + (c$link1 & (d$link1 ^ e) ^ e) + block->l[(signed long int)14] + (unsigned int)0x5A827999 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)15] = (block->l[(signed long int)15] << 24 | block->l[(signed long int)15] >> 32 - 24) & 0xFF00FF00 | (block->l[(signed long int)15] << 8 | block->l[(signed long int)15] >> 32 - 8) & (unsigned int)0x00FF00FF;
  e = e + (b$link1 & (c$link1 ^ d$link1) ^ d$link1) + block->l[(signed long int)15] + (unsigned int)0x5A827999 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(16 & 15)] = (block->l[(signed long int)(16 + 13 & 15)] ^ block->l[(signed long int)(16 + 8 & 15)] ^ block->l[(signed long int)(16 + 2 & 15)] ^ block->l[(signed long int)(16 & 15)]) << 1 | (block->l[(signed long int)(16 + 13 & 15)] ^ block->l[(signed long int)(16 + 8 & 15)] ^ block->l[(signed long int)(16 + 2 & 15)] ^ block->l[(signed long int)(16 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + (a$link1 & (b$link1 ^ c$link1) ^ c$link1) + block->l[(signed long int)(16 & 15)] + (unsigned int)0x5A827999 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(17 & 15)] = (block->l[(signed long int)(17 + 13 & 15)] ^ block->l[(signed long int)(17 + 8 & 15)] ^ block->l[(signed long int)(17 + 2 & 15)] ^ block->l[(signed long int)(17 & 15)]) << 1 | (block->l[(signed long int)(17 + 13 & 15)] ^ block->l[(signed long int)(17 + 8 & 15)] ^ block->l[(signed long int)(17 + 2 & 15)] ^ block->l[(signed long int)(17 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + (e & (a$link1 ^ b$link1) ^ b$link1) + block->l[(signed long int)(17 & 15)] + (unsigned int)0x5A827999 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(18 & 15)] = (block->l[(signed long int)(18 + 13 & 15)] ^ block->l[(signed long int)(18 + 8 & 15)] ^ block->l[(signed long int)(18 + 2 & 15)] ^ block->l[(signed long int)(18 & 15)]) << 1 | (block->l[(signed long int)(18 + 13 & 15)] ^ block->l[(signed long int)(18 + 8 & 15)] ^ block->l[(signed long int)(18 + 2 & 15)] ^ block->l[(signed long int)(18 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + (d$link1 & (e ^ a$link1) ^ a$link1) + block->l[(signed long int)(18 & 15)] + (unsigned int)0x5A827999 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(19 & 15)] = (block->l[(signed long int)(19 + 13 & 15)] ^ block->l[(signed long int)(19 + 8 & 15)] ^ block->l[(signed long int)(19 + 2 & 15)] ^ block->l[(signed long int)(19 & 15)]) << 1 | (block->l[(signed long int)(19 + 13 & 15)] ^ block->l[(signed long int)(19 + 8 & 15)] ^ block->l[(signed long int)(19 + 2 & 15)] ^ block->l[(signed long int)(19 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + (c$link1 & (d$link1 ^ e) ^ e) + block->l[(signed long int)(19 & 15)] + (unsigned int)0x5A827999 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(20 & 15)] = (block->l[(signed long int)(20 + 13 & 15)] ^ block->l[(signed long int)(20 + 8 & 15)] ^ block->l[(signed long int)(20 + 2 & 15)] ^ block->l[(signed long int)(20 & 15)]) << 1 | (block->l[(signed long int)(20 + 13 & 15)] ^ block->l[(signed long int)(20 + 8 & 15)] ^ block->l[(signed long int)(20 + 2 & 15)] ^ block->l[(signed long int)(20 & 15)]) >> 32 - 1;
  e = e + (b$link1 ^ c$link1 ^ d$link1) + block->l[(signed long int)(20 & 15)] + (unsigned int)0x6ED9EBA1 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(21 & 15)] = (block->l[(signed long int)(21 + 13 & 15)] ^ block->l[(signed long int)(21 + 8 & 15)] ^ block->l[(signed long int)(21 + 2 & 15)] ^ block->l[(signed long int)(21 & 15)]) << 1 | (block->l[(signed long int)(21 + 13 & 15)] ^ block->l[(signed long int)(21 + 8 & 15)] ^ block->l[(signed long int)(21 + 2 & 15)] ^ block->l[(signed long int)(21 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + (a$link1 ^ b$link1 ^ c$link1) + block->l[(signed long int)(21 & 15)] + (unsigned int)0x6ED9EBA1 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(22 & 15)] = (block->l[(signed long int)(22 + 13 & 15)] ^ block->l[(signed long int)(22 + 8 & 15)] ^ block->l[(signed long int)(22 + 2 & 15)] ^ block->l[(signed long int)(22 & 15)]) << 1 | (block->l[(signed long int)(22 + 13 & 15)] ^ block->l[(signed long int)(22 + 8 & 15)] ^ block->l[(signed long int)(22 + 2 & 15)] ^ block->l[(signed long int)(22 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + (e ^ a$link1 ^ b$link1) + block->l[(signed long int)(22 & 15)] + (unsigned int)0x6ED9EBA1 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(23 & 15)] = (block->l[(signed long int)(23 + 13 & 15)] ^ block->l[(signed long int)(23 + 8 & 15)] ^ block->l[(signed long int)(23 + 2 & 15)] ^ block->l[(signed long int)(23 & 15)]) << 1 | (block->l[(signed long int)(23 + 13 & 15)] ^ block->l[(signed long int)(23 + 8 & 15)] ^ block->l[(signed long int)(23 + 2 & 15)] ^ block->l[(signed long int)(23 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + (d$link1 ^ e ^ a$link1) + block->l[(signed long int)(23 & 15)] + (unsigned int)0x6ED9EBA1 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(24 & 15)] = (block->l[(signed long int)(24 + 13 & 15)] ^ block->l[(signed long int)(24 + 8 & 15)] ^ block->l[(signed long int)(24 + 2 & 15)] ^ block->l[(signed long int)(24 & 15)]) << 1 | (block->l[(signed long int)(24 + 13 & 15)] ^ block->l[(signed long int)(24 + 8 & 15)] ^ block->l[(signed long int)(24 + 2 & 15)] ^ block->l[(signed long int)(24 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + (c$link1 ^ d$link1 ^ e) + block->l[(signed long int)(24 & 15)] + (unsigned int)0x6ED9EBA1 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(25 & 15)] = (block->l[(signed long int)(25 + 13 & 15)] ^ block->l[(signed long int)(25 + 8 & 15)] ^ block->l[(signed long int)(25 + 2 & 15)] ^ block->l[(signed long int)(25 & 15)]) << 1 | (block->l[(signed long int)(25 + 13 & 15)] ^ block->l[(signed long int)(25 + 8 & 15)] ^ block->l[(signed long int)(25 + 2 & 15)] ^ block->l[(signed long int)(25 & 15)]) >> 32 - 1;
  e = e + (b$link1 ^ c$link1 ^ d$link1) + block->l[(signed long int)(25 & 15)] + (unsigned int)0x6ED9EBA1 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(26 & 15)] = (block->l[(signed long int)(26 + 13 & 15)] ^ block->l[(signed long int)(26 + 8 & 15)] ^ block->l[(signed long int)(26 + 2 & 15)] ^ block->l[(signed long int)(26 & 15)]) << 1 | (block->l[(signed long int)(26 + 13 & 15)] ^ block->l[(signed long int)(26 + 8 & 15)] ^ block->l[(signed long int)(26 + 2 & 15)] ^ block->l[(signed long int)(26 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + (a$link1 ^ b$link1 ^ c$link1) + block->l[(signed long int)(26 & 15)] + (unsigned int)0x6ED9EBA1 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(27 & 15)] = (block->l[(signed long int)(27 + 13 & 15)] ^ block->l[(signed long int)(27 + 8 & 15)] ^ block->l[(signed long int)(27 + 2 & 15)] ^ block->l[(signed long int)(27 & 15)]) << 1 | (block->l[(signed long int)(27 + 13 & 15)] ^ block->l[(signed long int)(27 + 8 & 15)] ^ block->l[(signed long int)(27 + 2 & 15)] ^ block->l[(signed long int)(27 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + (e ^ a$link1 ^ b$link1) + block->l[(signed long int)(27 & 15)] + (unsigned int)0x6ED9EBA1 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(28 & 15)] = (block->l[(signed long int)(28 + 13 & 15)] ^ block->l[(signed long int)(28 + 8 & 15)] ^ block->l[(signed long int)(28 + 2 & 15)] ^ block->l[(signed long int)(28 & 15)]) << 1 | (block->l[(signed long int)(28 + 13 & 15)] ^ block->l[(signed long int)(28 + 8 & 15)] ^ block->l[(signed long int)(28 + 2 & 15)] ^ block->l[(signed long int)(28 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + (d$link1 ^ e ^ a$link1) + block->l[(signed long int)(28 & 15)] + (unsigned int)0x6ED9EBA1 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(29 & 15)] = (block->l[(signed long int)(29 + 13 & 15)] ^ block->l[(signed long int)(29 + 8 & 15)] ^ block->l[(signed long int)(29 + 2 & 15)] ^ block->l[(signed long int)(29 & 15)]) << 1 | (block->l[(signed long int)(29 + 13 & 15)] ^ block->l[(signed long int)(29 + 8 & 15)] ^ block->l[(signed long int)(29 + 2 & 15)] ^ block->l[(signed long int)(29 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + (c$link1 ^ d$link1 ^ e) + block->l[(signed long int)(29 & 15)] + (unsigned int)0x6ED9EBA1 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(30 & 15)] = (block->l[(signed long int)(30 + 13 & 15)] ^ block->l[(signed long int)(30 + 8 & 15)] ^ block->l[(signed long int)(30 + 2 & 15)] ^ block->l[(signed long int)(30 & 15)]) << 1 | (block->l[(signed long int)(30 + 13 & 15)] ^ block->l[(signed long int)(30 + 8 & 15)] ^ block->l[(signed long int)(30 + 2 & 15)] ^ block->l[(signed long int)(30 & 15)]) >> 32 - 1;
  e = e + (b$link1 ^ c$link1 ^ d$link1) + block->l[(signed long int)(30 & 15)] + (unsigned int)0x6ED9EBA1 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(31 & 15)] = (block->l[(signed long int)(31 + 13 & 15)] ^ block->l[(signed long int)(31 + 8 & 15)] ^ block->l[(signed long int)(31 + 2 & 15)] ^ block->l[(signed long int)(31 & 15)]) << 1 | (block->l[(signed long int)(31 + 13 & 15)] ^ block->l[(signed long int)(31 + 8 & 15)] ^ block->l[(signed long int)(31 + 2 & 15)] ^ block->l[(signed long int)(31 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + (a$link1 ^ b$link1 ^ c$link1) + block->l[(signed long int)(31 & 15)] + (unsigned int)0x6ED9EBA1 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(32 & 15)] = (block->l[(signed long int)(32 + 13 & 15)] ^ block->l[(signed long int)(32 + 8 & 15)] ^ block->l[(signed long int)(32 + 2 & 15)] ^ block->l[(signed long int)(32 & 15)]) << 1 | (block->l[(signed long int)(32 + 13 & 15)] ^ block->l[(signed long int)(32 + 8 & 15)] ^ block->l[(signed long int)(32 + 2 & 15)] ^ block->l[(signed long int)(32 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + (e ^ a$link1 ^ b$link1) + block->l[(signed long int)(32 & 15)] + (unsigned int)0x6ED9EBA1 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(33 & 15)] = (block->l[(signed long int)(33 + 13 & 15)] ^ block->l[(signed long int)(33 + 8 & 15)] ^ block->l[(signed long int)(33 + 2 & 15)] ^ block->l[(signed long int)(33 & 15)]) << 1 | (block->l[(signed long int)(33 + 13 & 15)] ^ block->l[(signed long int)(33 + 8 & 15)] ^ block->l[(signed long int)(33 + 2 & 15)] ^ block->l[(signed long int)(33 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + (d$link1 ^ e ^ a$link1) + block->l[(signed long int)(33 & 15)] + (unsigned int)0x6ED9EBA1 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(34 & 15)] = (block->l[(signed long int)(34 + 13 & 15)] ^ block->l[(signed long int)(34 + 8 & 15)] ^ block->l[(signed long int)(34 + 2 & 15)] ^ block->l[(signed long int)(34 & 15)]) << 1 | (block->l[(signed long int)(34 + 13 & 15)] ^ block->l[(signed long int)(34 + 8 & 15)] ^ block->l[(signed long int)(34 + 2 & 15)] ^ block->l[(signed long int)(34 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + (c$link1 ^ d$link1 ^ e) + block->l[(signed long int)(34 & 15)] + (unsigned int)0x6ED9EBA1 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(35 & 15)] = (block->l[(signed long int)(35 + 13 & 15)] ^ block->l[(signed long int)(35 + 8 & 15)] ^ block->l[(signed long int)(35 + 2 & 15)] ^ block->l[(signed long int)(35 & 15)]) << 1 | (block->l[(signed long int)(35 + 13 & 15)] ^ block->l[(signed long int)(35 + 8 & 15)] ^ block->l[(signed long int)(35 + 2 & 15)] ^ block->l[(signed long int)(35 & 15)]) >> 32 - 1;
  e = e + (b$link1 ^ c$link1 ^ d$link1) + block->l[(signed long int)(35 & 15)] + (unsigned int)0x6ED9EBA1 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(36 & 15)] = (block->l[(signed long int)(36 + 13 & 15)] ^ block->l[(signed long int)(36 + 8 & 15)] ^ block->l[(signed long int)(36 + 2 & 15)] ^ block->l[(signed long int)(36 & 15)]) << 1 | (block->l[(signed long int)(36 + 13 & 15)] ^ block->l[(signed long int)(36 + 8 & 15)] ^ block->l[(signed long int)(36 + 2 & 15)] ^ block->l[(signed long int)(36 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + (a$link1 ^ b$link1 ^ c$link1) + block->l[(signed long int)(36 & 15)] + (unsigned int)0x6ED9EBA1 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(37 & 15)] = (block->l[(signed long int)(37 + 13 & 15)] ^ block->l[(signed long int)(37 + 8 & 15)] ^ block->l[(signed long int)(37 + 2 & 15)] ^ block->l[(signed long int)(37 & 15)]) << 1 | (block->l[(signed long int)(37 + 13 & 15)] ^ block->l[(signed long int)(37 + 8 & 15)] ^ block->l[(signed long int)(37 + 2 & 15)] ^ block->l[(signed long int)(37 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + (e ^ a$link1 ^ b$link1) + block->l[(signed long int)(37 & 15)] + (unsigned int)0x6ED9EBA1 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(38 & 15)] = (block->l[(signed long int)(38 + 13 & 15)] ^ block->l[(signed long int)(38 + 8 & 15)] ^ block->l[(signed long int)(38 + 2 & 15)] ^ block->l[(signed long int)(38 & 15)]) << 1 | (block->l[(signed long int)(38 + 13 & 15)] ^ block->l[(signed long int)(38 + 8 & 15)] ^ block->l[(signed long int)(38 + 2 & 15)] ^ block->l[(signed long int)(38 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + (d$link1 ^ e ^ a$link1) + block->l[(signed long int)(38 & 15)] + (unsigned int)0x6ED9EBA1 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(39 & 15)] = (block->l[(signed long int)(39 + 13 & 15)] ^ block->l[(signed long int)(39 + 8 & 15)] ^ block->l[(signed long int)(39 + 2 & 15)] ^ block->l[(signed long int)(39 & 15)]) << 1 | (block->l[(signed long int)(39 + 13 & 15)] ^ block->l[(signed long int)(39 + 8 & 15)] ^ block->l[(signed long int)(39 + 2 & 15)] ^ block->l[(signed long int)(39 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + (c$link1 ^ d$link1 ^ e) + block->l[(signed long int)(39 & 15)] + (unsigned int)0x6ED9EBA1 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(40 & 15)] = (block->l[(signed long int)(40 + 13 & 15)] ^ block->l[(signed long int)(40 + 8 & 15)] ^ block->l[(signed long int)(40 + 2 & 15)] ^ block->l[(signed long int)(40 & 15)]) << 1 | (block->l[(signed long int)(40 + 13 & 15)] ^ block->l[(signed long int)(40 + 8 & 15)] ^ block->l[(signed long int)(40 + 2 & 15)] ^ block->l[(signed long int)(40 & 15)]) >> 32 - 1;
  e = e + ((b$link1 | c$link1) & d$link1 | b$link1 & c$link1) + block->l[(signed long int)(40 & 15)] + 0x8F1BBCDC + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(41 & 15)] = (block->l[(signed long int)(41 + 13 & 15)] ^ block->l[(signed long int)(41 + 8 & 15)] ^ block->l[(signed long int)(41 + 2 & 15)] ^ block->l[(signed long int)(41 & 15)]) << 1 | (block->l[(signed long int)(41 + 13 & 15)] ^ block->l[(signed long int)(41 + 8 & 15)] ^ block->l[(signed long int)(41 + 2 & 15)] ^ block->l[(signed long int)(41 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + ((a$link1 | b$link1) & c$link1 | a$link1 & b$link1) + block->l[(signed long int)(41 & 15)] + 0x8F1BBCDC + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(42 & 15)] = (block->l[(signed long int)(42 + 13 & 15)] ^ block->l[(signed long int)(42 + 8 & 15)] ^ block->l[(signed long int)(42 + 2 & 15)] ^ block->l[(signed long int)(42 & 15)]) << 1 | (block->l[(signed long int)(42 + 13 & 15)] ^ block->l[(signed long int)(42 + 8 & 15)] ^ block->l[(signed long int)(42 + 2 & 15)] ^ block->l[(signed long int)(42 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + ((e | a$link1) & b$link1 | e & a$link1) + block->l[(signed long int)(42 & 15)] + 0x8F1BBCDC + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(43 & 15)] = (block->l[(signed long int)(43 + 13 & 15)] ^ block->l[(signed long int)(43 + 8 & 15)] ^ block->l[(signed long int)(43 + 2 & 15)] ^ block->l[(signed long int)(43 & 15)]) << 1 | (block->l[(signed long int)(43 + 13 & 15)] ^ block->l[(signed long int)(43 + 8 & 15)] ^ block->l[(signed long int)(43 + 2 & 15)] ^ block->l[(signed long int)(43 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + ((d$link1 | e) & a$link1 | d$link1 & e) + block->l[(signed long int)(43 & 15)] + 0x8F1BBCDC + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(44 & 15)] = (block->l[(signed long int)(44 + 13 & 15)] ^ block->l[(signed long int)(44 + 8 & 15)] ^ block->l[(signed long int)(44 + 2 & 15)] ^ block->l[(signed long int)(44 & 15)]) << 1 | (block->l[(signed long int)(44 + 13 & 15)] ^ block->l[(signed long int)(44 + 8 & 15)] ^ block->l[(signed long int)(44 + 2 & 15)] ^ block->l[(signed long int)(44 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + ((c$link1 | d$link1) & e | c$link1 & d$link1) + block->l[(signed long int)(44 & 15)] + 0x8F1BBCDC + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(45 & 15)] = (block->l[(signed long int)(45 + 13 & 15)] ^ block->l[(signed long int)(45 + 8 & 15)] ^ block->l[(signed long int)(45 + 2 & 15)] ^ block->l[(signed long int)(45 & 15)]) << 1 | (block->l[(signed long int)(45 + 13 & 15)] ^ block->l[(signed long int)(45 + 8 & 15)] ^ block->l[(signed long int)(45 + 2 & 15)] ^ block->l[(signed long int)(45 & 15)]) >> 32 - 1;
  e = e + ((b$link1 | c$link1) & d$link1 | b$link1 & c$link1) + block->l[(signed long int)(45 & 15)] + 0x8F1BBCDC + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(46 & 15)] = (block->l[(signed long int)(46 + 13 & 15)] ^ block->l[(signed long int)(46 + 8 & 15)] ^ block->l[(signed long int)(46 + 2 & 15)] ^ block->l[(signed long int)(46 & 15)]) << 1 | (block->l[(signed long int)(46 + 13 & 15)] ^ block->l[(signed long int)(46 + 8 & 15)] ^ block->l[(signed long int)(46 + 2 & 15)] ^ block->l[(signed long int)(46 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + ((a$link1 | b$link1) & c$link1 | a$link1 & b$link1) + block->l[(signed long int)(46 & 15)] + 0x8F1BBCDC + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(47 & 15)] = (block->l[(signed long int)(47 + 13 & 15)] ^ block->l[(signed long int)(47 + 8 & 15)] ^ block->l[(signed long int)(47 + 2 & 15)] ^ block->l[(signed long int)(47 & 15)]) << 1 | (block->l[(signed long int)(47 + 13 & 15)] ^ block->l[(signed long int)(47 + 8 & 15)] ^ block->l[(signed long int)(47 + 2 & 15)] ^ block->l[(signed long int)(47 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + ((e | a$link1) & b$link1 | e & a$link1) + block->l[(signed long int)(47 & 15)] + 0x8F1BBCDC + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(48 & 15)] = (block->l[(signed long int)(48 + 13 & 15)] ^ block->l[(signed long int)(48 + 8 & 15)] ^ block->l[(signed long int)(48 + 2 & 15)] ^ block->l[(signed long int)(48 & 15)]) << 1 | (block->l[(signed long int)(48 + 13 & 15)] ^ block->l[(signed long int)(48 + 8 & 15)] ^ block->l[(signed long int)(48 + 2 & 15)] ^ block->l[(signed long int)(48 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + ((d$link1 | e) & a$link1 | d$link1 & e) + block->l[(signed long int)(48 & 15)] + 0x8F1BBCDC + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(49 & 15)] = (block->l[(signed long int)(49 + 13 & 15)] ^ block->l[(signed long int)(49 + 8 & 15)] ^ block->l[(signed long int)(49 + 2 & 15)] ^ block->l[(signed long int)(49 & 15)]) << 1 | (block->l[(signed long int)(49 + 13 & 15)] ^ block->l[(signed long int)(49 + 8 & 15)] ^ block->l[(signed long int)(49 + 2 & 15)] ^ block->l[(signed long int)(49 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + ((c$link1 | d$link1) & e | c$link1 & d$link1) + block->l[(signed long int)(49 & 15)] + 0x8F1BBCDC + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(50 & 15)] = (block->l[(signed long int)(50 + 13 & 15)] ^ block->l[(signed long int)(50 + 8 & 15)] ^ block->l[(signed long int)(50 + 2 & 15)] ^ block->l[(signed long int)(50 & 15)]) << 1 | (block->l[(signed long int)(50 + 13 & 15)] ^ block->l[(signed long int)(50 + 8 & 15)] ^ block->l[(signed long int)(50 + 2 & 15)] ^ block->l[(signed long int)(50 & 15)]) >> 32 - 1;
  e = e + ((b$link1 | c$link1) & d$link1 | b$link1 & c$link1) + block->l[(signed long int)(50 & 15)] + 0x8F1BBCDC + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(51 & 15)] = (block->l[(signed long int)(51 + 13 & 15)] ^ block->l[(signed long int)(51 + 8 & 15)] ^ block->l[(signed long int)(51 + 2 & 15)] ^ block->l[(signed long int)(51 & 15)]) << 1 | (block->l[(signed long int)(51 + 13 & 15)] ^ block->l[(signed long int)(51 + 8 & 15)] ^ block->l[(signed long int)(51 + 2 & 15)] ^ block->l[(signed long int)(51 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + ((a$link1 | b$link1) & c$link1 | a$link1 & b$link1) + block->l[(signed long int)(51 & 15)] + 0x8F1BBCDC + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(52 & 15)] = (block->l[(signed long int)(52 + 13 & 15)] ^ block->l[(signed long int)(52 + 8 & 15)] ^ block->l[(signed long int)(52 + 2 & 15)] ^ block->l[(signed long int)(52 & 15)]) << 1 | (block->l[(signed long int)(52 + 13 & 15)] ^ block->l[(signed long int)(52 + 8 & 15)] ^ block->l[(signed long int)(52 + 2 & 15)] ^ block->l[(signed long int)(52 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + ((e | a$link1) & b$link1 | e & a$link1) + block->l[(signed long int)(52 & 15)] + 0x8F1BBCDC + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(53 & 15)] = (block->l[(signed long int)(53 + 13 & 15)] ^ block->l[(signed long int)(53 + 8 & 15)] ^ block->l[(signed long int)(53 + 2 & 15)] ^ block->l[(signed long int)(53 & 15)]) << 1 | (block->l[(signed long int)(53 + 13 & 15)] ^ block->l[(signed long int)(53 + 8 & 15)] ^ block->l[(signed long int)(53 + 2 & 15)] ^ block->l[(signed long int)(53 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + ((d$link1 | e) & a$link1 | d$link1 & e) + block->l[(signed long int)(53 & 15)] + 0x8F1BBCDC + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(54 & 15)] = (block->l[(signed long int)(54 + 13 & 15)] ^ block->l[(signed long int)(54 + 8 & 15)] ^ block->l[(signed long int)(54 + 2 & 15)] ^ block->l[(signed long int)(54 & 15)]) << 1 | (block->l[(signed long int)(54 + 13 & 15)] ^ block->l[(signed long int)(54 + 8 & 15)] ^ block->l[(signed long int)(54 + 2 & 15)] ^ block->l[(signed long int)(54 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + ((c$link1 | d$link1) & e | c$link1 & d$link1) + block->l[(signed long int)(54 & 15)] + 0x8F1BBCDC + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(55 & 15)] = (block->l[(signed long int)(55 + 13 & 15)] ^ block->l[(signed long int)(55 + 8 & 15)] ^ block->l[(signed long int)(55 + 2 & 15)] ^ block->l[(signed long int)(55 & 15)]) << 1 | (block->l[(signed long int)(55 + 13 & 15)] ^ block->l[(signed long int)(55 + 8 & 15)] ^ block->l[(signed long int)(55 + 2 & 15)] ^ block->l[(signed long int)(55 & 15)]) >> 32 - 1;
  e = e + ((b$link1 | c$link1) & d$link1 | b$link1 & c$link1) + block->l[(signed long int)(55 & 15)] + 0x8F1BBCDC + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(56 & 15)] = (block->l[(signed long int)(56 + 13 & 15)] ^ block->l[(signed long int)(56 + 8 & 15)] ^ block->l[(signed long int)(56 + 2 & 15)] ^ block->l[(signed long int)(56 & 15)]) << 1 | (block->l[(signed long int)(56 + 13 & 15)] ^ block->l[(signed long int)(56 + 8 & 15)] ^ block->l[(signed long int)(56 + 2 & 15)] ^ block->l[(signed long int)(56 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + ((a$link1 | b$link1) & c$link1 | a$link1 & b$link1) + block->l[(signed long int)(56 & 15)] + 0x8F1BBCDC + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(57 & 15)] = (block->l[(signed long int)(57 + 13 & 15)] ^ block->l[(signed long int)(57 + 8 & 15)] ^ block->l[(signed long int)(57 + 2 & 15)] ^ block->l[(signed long int)(57 & 15)]) << 1 | (block->l[(signed long int)(57 + 13 & 15)] ^ block->l[(signed long int)(57 + 8 & 15)] ^ block->l[(signed long int)(57 + 2 & 15)] ^ block->l[(signed long int)(57 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + ((e | a$link1) & b$link1 | e & a$link1) + block->l[(signed long int)(57 & 15)] + 0x8F1BBCDC + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(58 & 15)] = (block->l[(signed long int)(58 + 13 & 15)] ^ block->l[(signed long int)(58 + 8 & 15)] ^ block->l[(signed long int)(58 + 2 & 15)] ^ block->l[(signed long int)(58 & 15)]) << 1 | (block->l[(signed long int)(58 + 13 & 15)] ^ block->l[(signed long int)(58 + 8 & 15)] ^ block->l[(signed long int)(58 + 2 & 15)] ^ block->l[(signed long int)(58 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + ((d$link1 | e) & a$link1 | d$link1 & e) + block->l[(signed long int)(58 & 15)] + 0x8F1BBCDC + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(59 & 15)] = (block->l[(signed long int)(59 + 13 & 15)] ^ block->l[(signed long int)(59 + 8 & 15)] ^ block->l[(signed long int)(59 + 2 & 15)] ^ block->l[(signed long int)(59 & 15)]) << 1 | (block->l[(signed long int)(59 + 13 & 15)] ^ block->l[(signed long int)(59 + 8 & 15)] ^ block->l[(signed long int)(59 + 2 & 15)] ^ block->l[(signed long int)(59 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + ((c$link1 | d$link1) & e | c$link1 & d$link1) + block->l[(signed long int)(59 & 15)] + 0x8F1BBCDC + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(60 & 15)] = (block->l[(signed long int)(60 + 13 & 15)] ^ block->l[(signed long int)(60 + 8 & 15)] ^ block->l[(signed long int)(60 + 2 & 15)] ^ block->l[(signed long int)(60 & 15)]) << 1 | (block->l[(signed long int)(60 + 13 & 15)] ^ block->l[(signed long int)(60 + 8 & 15)] ^ block->l[(signed long int)(60 + 2 & 15)] ^ block->l[(signed long int)(60 & 15)]) >> 32 - 1;
  e = e + (b$link1 ^ c$link1 ^ d$link1) + block->l[(signed long int)(60 & 15)] + 0xCA62C1D6 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(61 & 15)] = (block->l[(signed long int)(61 + 13 & 15)] ^ block->l[(signed long int)(61 + 8 & 15)] ^ block->l[(signed long int)(61 + 2 & 15)] ^ block->l[(signed long int)(61 & 15)]) << 1 | (block->l[(signed long int)(61 + 13 & 15)] ^ block->l[(signed long int)(61 + 8 & 15)] ^ block->l[(signed long int)(61 + 2 & 15)] ^ block->l[(signed long int)(61 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + (a$link1 ^ b$link1 ^ c$link1) + block->l[(signed long int)(61 & 15)] + 0xCA62C1D6 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(62 & 15)] = (block->l[(signed long int)(62 + 13 & 15)] ^ block->l[(signed long int)(62 + 8 & 15)] ^ block->l[(signed long int)(62 + 2 & 15)] ^ block->l[(signed long int)(62 & 15)]) << 1 | (block->l[(signed long int)(62 + 13 & 15)] ^ block->l[(signed long int)(62 + 8 & 15)] ^ block->l[(signed long int)(62 + 2 & 15)] ^ block->l[(signed long int)(62 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + (e ^ a$link1 ^ b$link1) + block->l[(signed long int)(62 & 15)] + 0xCA62C1D6 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(63 & 15)] = (block->l[(signed long int)(63 + 13 & 15)] ^ block->l[(signed long int)(63 + 8 & 15)] ^ block->l[(signed long int)(63 + 2 & 15)] ^ block->l[(signed long int)(63 & 15)]) << 1 | (block->l[(signed long int)(63 + 13 & 15)] ^ block->l[(signed long int)(63 + 8 & 15)] ^ block->l[(signed long int)(63 + 2 & 15)] ^ block->l[(signed long int)(63 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + (d$link1 ^ e ^ a$link1) + block->l[(signed long int)(63 & 15)] + 0xCA62C1D6 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(64 & 15)] = (block->l[(signed long int)(64 + 13 & 15)] ^ block->l[(signed long int)(64 + 8 & 15)] ^ block->l[(signed long int)(64 + 2 & 15)] ^ block->l[(signed long int)(64 & 15)]) << 1 | (block->l[(signed long int)(64 + 13 & 15)] ^ block->l[(signed long int)(64 + 8 & 15)] ^ block->l[(signed long int)(64 + 2 & 15)] ^ block->l[(signed long int)(64 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + (c$link1 ^ d$link1 ^ e) + block->l[(signed long int)(64 & 15)] + 0xCA62C1D6 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(65 & 15)] = (block->l[(signed long int)(65 + 13 & 15)] ^ block->l[(signed long int)(65 + 8 & 15)] ^ block->l[(signed long int)(65 + 2 & 15)] ^ block->l[(signed long int)(65 & 15)]) << 1 | (block->l[(signed long int)(65 + 13 & 15)] ^ block->l[(signed long int)(65 + 8 & 15)] ^ block->l[(signed long int)(65 + 2 & 15)] ^ block->l[(signed long int)(65 & 15)]) >> 32 - 1;
  e = e + (b$link1 ^ c$link1 ^ d$link1) + block->l[(signed long int)(65 & 15)] + 0xCA62C1D6 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(66 & 15)] = (block->l[(signed long int)(66 + 13 & 15)] ^ block->l[(signed long int)(66 + 8 & 15)] ^ block->l[(signed long int)(66 + 2 & 15)] ^ block->l[(signed long int)(66 & 15)]) << 1 | (block->l[(signed long int)(66 + 13 & 15)] ^ block->l[(signed long int)(66 + 8 & 15)] ^ block->l[(signed long int)(66 + 2 & 15)] ^ block->l[(signed long int)(66 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + (a$link1 ^ b$link1 ^ c$link1) + block->l[(signed long int)(66 & 15)] + 0xCA62C1D6 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(67 & 15)] = (block->l[(signed long int)(67 + 13 & 15)] ^ block->l[(signed long int)(67 + 8 & 15)] ^ block->l[(signed long int)(67 + 2 & 15)] ^ block->l[(signed long int)(67 & 15)]) << 1 | (block->l[(signed long int)(67 + 13 & 15)] ^ block->l[(signed long int)(67 + 8 & 15)] ^ block->l[(signed long int)(67 + 2 & 15)] ^ block->l[(signed long int)(67 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + (e ^ a$link1 ^ b$link1) + block->l[(signed long int)(67 & 15)] + 0xCA62C1D6 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(68 & 15)] = (block->l[(signed long int)(68 + 13 & 15)] ^ block->l[(signed long int)(68 + 8 & 15)] ^ block->l[(signed long int)(68 + 2 & 15)] ^ block->l[(signed long int)(68 & 15)]) << 1 | (block->l[(signed long int)(68 + 13 & 15)] ^ block->l[(signed long int)(68 + 8 & 15)] ^ block->l[(signed long int)(68 + 2 & 15)] ^ block->l[(signed long int)(68 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + (d$link1 ^ e ^ a$link1) + block->l[(signed long int)(68 & 15)] + 0xCA62C1D6 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(69 & 15)] = (block->l[(signed long int)(69 + 13 & 15)] ^ block->l[(signed long int)(69 + 8 & 15)] ^ block->l[(signed long int)(69 + 2 & 15)] ^ block->l[(signed long int)(69 & 15)]) << 1 | (block->l[(signed long int)(69 + 13 & 15)] ^ block->l[(signed long int)(69 + 8 & 15)] ^ block->l[(signed long int)(69 + 2 & 15)] ^ block->l[(signed long int)(69 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + (c$link1 ^ d$link1 ^ e) + block->l[(signed long int)(69 & 15)] + 0xCA62C1D6 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(70 & 15)] = (block->l[(signed long int)(70 + 13 & 15)] ^ block->l[(signed long int)(70 + 8 & 15)] ^ block->l[(signed long int)(70 + 2 & 15)] ^ block->l[(signed long int)(70 & 15)]) << 1 | (block->l[(signed long int)(70 + 13 & 15)] ^ block->l[(signed long int)(70 + 8 & 15)] ^ block->l[(signed long int)(70 + 2 & 15)] ^ block->l[(signed long int)(70 & 15)]) >> 32 - 1;
  e = e + (b$link1 ^ c$link1 ^ d$link1) + block->l[(signed long int)(70 & 15)] + 0xCA62C1D6 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(71 & 15)] = (block->l[(signed long int)(71 + 13 & 15)] ^ block->l[(signed long int)(71 + 8 & 15)] ^ block->l[(signed long int)(71 + 2 & 15)] ^ block->l[(signed long int)(71 & 15)]) << 1 | (block->l[(signed long int)(71 + 13 & 15)] ^ block->l[(signed long int)(71 + 8 & 15)] ^ block->l[(signed long int)(71 + 2 & 15)] ^ block->l[(signed long int)(71 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + (a$link1 ^ b$link1 ^ c$link1) + block->l[(signed long int)(71 & 15)] + 0xCA62C1D6 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(72 & 15)] = (block->l[(signed long int)(72 + 13 & 15)] ^ block->l[(signed long int)(72 + 8 & 15)] ^ block->l[(signed long int)(72 + 2 & 15)] ^ block->l[(signed long int)(72 & 15)]) << 1 | (block->l[(signed long int)(72 + 13 & 15)] ^ block->l[(signed long int)(72 + 8 & 15)] ^ block->l[(signed long int)(72 + 2 & 15)] ^ block->l[(signed long int)(72 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + (e ^ a$link1 ^ b$link1) + block->l[(signed long int)(72 & 15)] + 0xCA62C1D6 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(73 & 15)] = (block->l[(signed long int)(73 + 13 & 15)] ^ block->l[(signed long int)(73 + 8 & 15)] ^ block->l[(signed long int)(73 + 2 & 15)] ^ block->l[(signed long int)(73 & 15)]) << 1 | (block->l[(signed long int)(73 + 13 & 15)] ^ block->l[(signed long int)(73 + 8 & 15)] ^ block->l[(signed long int)(73 + 2 & 15)] ^ block->l[(signed long int)(73 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + (d$link1 ^ e ^ a$link1) + block->l[(signed long int)(73 & 15)] + 0xCA62C1D6 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(74 & 15)] = (block->l[(signed long int)(74 + 13 & 15)] ^ block->l[(signed long int)(74 + 8 & 15)] ^ block->l[(signed long int)(74 + 2 & 15)] ^ block->l[(signed long int)(74 & 15)]) << 1 | (block->l[(signed long int)(74 + 13 & 15)] ^ block->l[(signed long int)(74 + 8 & 15)] ^ block->l[(signed long int)(74 + 2 & 15)] ^ block->l[(signed long int)(74 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + (c$link1 ^ d$link1 ^ e) + block->l[(signed long int)(74 & 15)] + 0xCA62C1D6 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  block->l[(signed long int)(75 & 15)] = (block->l[(signed long int)(75 + 13 & 15)] ^ block->l[(signed long int)(75 + 8 & 15)] ^ block->l[(signed long int)(75 + 2 & 15)] ^ block->l[(signed long int)(75 & 15)]) << 1 | (block->l[(signed long int)(75 + 13 & 15)] ^ block->l[(signed long int)(75 + 8 & 15)] ^ block->l[(signed long int)(75 + 2 & 15)] ^ block->l[(signed long int)(75 & 15)]) >> 32 - 1;
  e = e + (b$link1 ^ c$link1 ^ d$link1) + block->l[(signed long int)(75 & 15)] + 0xCA62C1D6 + (a$link1 << 5 | a$link1 >> 32 - 5);
  b$link1 = b$link1 << 30 | b$link1 >> 32 - 30;
  block->l[(signed long int)(76 & 15)] = (block->l[(signed long int)(76 + 13 & 15)] ^ block->l[(signed long int)(76 + 8 & 15)] ^ block->l[(signed long int)(76 + 2 & 15)] ^ block->l[(signed long int)(76 & 15)]) << 1 | (block->l[(signed long int)(76 + 13 & 15)] ^ block->l[(signed long int)(76 + 8 & 15)] ^ block->l[(signed long int)(76 + 2 & 15)] ^ block->l[(signed long int)(76 & 15)]) >> 32 - 1;
  d$link1 = d$link1 + (a$link1 ^ b$link1 ^ c$link1) + block->l[(signed long int)(76 & 15)] + 0xCA62C1D6 + (e << 5 | e >> 32 - 5);
  a$link1 = a$link1 << 30 | a$link1 >> 32 - 30;
  block->l[(signed long int)(77 & 15)] = (block->l[(signed long int)(77 + 13 & 15)] ^ block->l[(signed long int)(77 + 8 & 15)] ^ block->l[(signed long int)(77 + 2 & 15)] ^ block->l[(signed long int)(77 & 15)]) << 1 | (block->l[(signed long int)(77 + 13 & 15)] ^ block->l[(signed long int)(77 + 8 & 15)] ^ block->l[(signed long int)(77 + 2 & 15)] ^ block->l[(signed long int)(77 & 15)]) >> 32 - 1;
  c$link1 = c$link1 + (e ^ a$link1 ^ b$link1) + block->l[(signed long int)(77 & 15)] + 0xCA62C1D6 + (d$link1 << 5 | d$link1 >> 32 - 5);
  e = e << 30 | e >> 32 - 30;
  block->l[(signed long int)(78 & 15)] = (block->l[(signed long int)(78 + 13 & 15)] ^ block->l[(signed long int)(78 + 8 & 15)] ^ block->l[(signed long int)(78 + 2 & 15)] ^ block->l[(signed long int)(78 & 15)]) << 1 | (block->l[(signed long int)(78 + 13 & 15)] ^ block->l[(signed long int)(78 + 8 & 15)] ^ block->l[(signed long int)(78 + 2 & 15)] ^ block->l[(signed long int)(78 & 15)]) >> 32 - 1;
  b$link1 = b$link1 + (d$link1 ^ e ^ a$link1) + block->l[(signed long int)(78 & 15)] + 0xCA62C1D6 + (c$link1 << 5 | c$link1 >> 32 - 5);
  d$link1 = d$link1 << 30 | d$link1 >> 32 - 30;
  block->l[(signed long int)(79 & 15)] = (block->l[(signed long int)(79 + 13 & 15)] ^ block->l[(signed long int)(79 + 8 & 15)] ^ block->l[(signed long int)(79 + 2 & 15)] ^ block->l[(signed long int)(79 & 15)]) << 1 | (block->l[(signed long int)(79 + 13 & 15)] ^ block->l[(signed long int)(79 + 8 & 15)] ^ block->l[(signed long int)(79 + 2 & 15)] ^ block->l[(signed long int)(79 & 15)]) >> 32 - 1;
  a$link1 = a$link1 + (c$link1 ^ d$link1 ^ e) + block->l[(signed long int)(79 & 15)] + 0xCA62C1D6 + (b$link1 << 5 | b$link1 >> 32 - 5);
  c$link1 = c$link1 << 30 | c$link1 >> 32 - 30;
  state[(signed long int)0] = state[(signed long int)0] + a$link1;
  state[(signed long int)1] = state[(signed long int)1] + b$link1;
  state[(signed long int)2] = state[(signed long int)2] + c$link1;
  state[(signed long int)3] = state[(signed long int)3] + d$link1;
  state[(signed long int)4] = state[(signed long int)4] + e;
  e = (unsigned int)0;
  d$link1 = e;
  c$link1 = d$link1;
  b$link1 = c$link1;
  a$link1 = b$link1;
  (void)a$link1;
  (void)b$link1;
  (void)c$link1;
  (void)d$link1;
  (void)e;
}

// try_ipv6only
// file ./../lib/isc/unix/net.c line 245
static void try_ipv6only(void)
{
  signed int s;
  signed int on;
  char strbuf[128l];
  unsigned int result;
  result=isc_net_probeipv6();
  signed int return_value_setsockopt$6;
  if(!(result == 0u))
    ipv6only_result = result;

  else
  {
    s=socket(10, 1, 0);
    if(s == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      isc__strerror(*return_value___errno_location$1, strbuf, sizeof(char [128l]) /*128ul*/ );
      const char *return_value_isc_msgcat_get$2;
      return_value_isc_msgcat_get$2=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
      isc_error_unexpected("./../lib/isc/unix/net.c", 266, "socket() %s: %s", return_value_isc_msgcat_get$2, (const void *)strbuf);
      ipv6only_result = (unsigned int)34;
      goto __CPROVER_DUMP_L7;
    }

    on = 1;
    signed int return_value_setsockopt$3;
    return_value_setsockopt$3=setsockopt(s, 41, 26, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt$3 >= 0))
      ipv6only_result = (unsigned int)23;

    else
    {
      close(s);
      s=socket(10, 2, 0);
      if(s == -1)
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        isc__strerror(*return_value___errno_location$4, strbuf, sizeof(char [128l]) /*128ul*/ );
        const char *return_value_isc_msgcat_get$5;
        return_value_isc_msgcat_get$5=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
        isc_error_unexpected("./../lib/isc/unix/net.c", 289, "socket() %s: %s", return_value_isc_msgcat_get$5, (const void *)strbuf);
        ipv6only_result = (unsigned int)34;
        goto __CPROVER_DUMP_L7;
      }

      on = 1;
      return_value_setsockopt$6=setsockopt(s, 41, 26, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt$6 >= 0))
        ipv6only_result = (unsigned int)23;

      else
        ipv6only_result = (unsigned int)0;
    }

  close:
    ;
    close(s);
    goto __CPROVER_DUMP_L7;
  }

__CPROVER_DUMP_L7:
  ;
}

// try_ipv6pktinfo
// file ./../lib/isc/unix/net.c line 322
static void try_ipv6pktinfo(void)
{
  signed int s;
  signed int on;
  char strbuf[128l];
  unsigned int result;
  signed int optname;
  result=isc_net_probeipv6();
  if(!(result == 0u))
    ipv6pktinfo_result = result;

  else
  {
    s=socket(10, 2, 17);
    if(s == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      isc__strerror(*return_value___errno_location$1, strbuf, sizeof(char [128l]) /*128ul*/ );
      const char *return_value_isc_msgcat_get$2;
      return_value_isc_msgcat_get$2=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
      isc_error_unexpected("./../lib/isc/unix/net.c", 338, "socket() %s: %s", return_value_isc_msgcat_get$2, (const void *)strbuf);
      ipv6pktinfo_result = (unsigned int)34;
      goto __CPROVER_DUMP_L5;
    }

    optname = 49;
    on = 1;
    signed int return_value_setsockopt$3;
    return_value_setsockopt$3=setsockopt(s, 41, optname, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt$3 >= 0))
      ipv6pktinfo_result = (unsigned int)23;

    else
      ipv6pktinfo_result = (unsigned int)0;

  close:
    ;
    close(s);
    goto __CPROVER_DUMP_L5;
  }

__CPROVER_DUMP_L5:
  ;
}

// try_proto
// file ./../lib/isc/unix/net.c line 124
static unsigned int try_proto(signed int domain)
{
  signed int s;
  unsigned int result = (unsigned int)0;
  char strbuf[128l];
  s=socket(domain, 1, 0);
  if(s == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 22 || *return_value___errno_location$1 == 93 || *return_value___errno_location$1 == 97)
      return (unsigned int)23;

    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    isc__strerror(*return_value___errno_location$2, strbuf, sizeof(char [128l]) /*128ul*/ );
    const char *return_value_isc_msgcat_get$3;
    return_value_isc_msgcat_get$3=isc_msgcat_get(isc_msgcat, 1, 101, "failed");
    isc_error_unexpected("./../lib/isc/unix/net.c", 144, "socket() %s: %s", return_value_isc_msgcat_get$3, (const void *)strbuf);
    return (unsigned int)34;
  }

  if(domain == 10)
  {
    struct sockaddr_in6 sin6;
    unsigned int len = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
    signed int return_value_getsockname$4;
    return_value_getsockname$4=getsockname(s, (struct sockaddr *)&sin6, &len);
    if(!(return_value_getsockname$4 >= 0))
    {
      isc_log_write(isc_lctx, &isc_categories[(signed long int)1], &isc_modules[(signed long int)0], -4, "retrieving the address of an IPv6 socket from the kernel failed.");
      isc_log_write(isc_lctx, &isc_categories[(signed long int)1], &isc_modules[(signed long int)0], -4, "IPv6 is not supported.");
      result = (unsigned int)23;
    }

    else
      if((unsigned long int)len == sizeof(struct sockaddr_in6) /*28ul*/ )
        result = (unsigned int)0;

      else
      {
        isc_log_write(isc_lctx, &isc_categories[(signed long int)1], &isc_modules[(signed long int)0], -4, "IPv6 structures in kernel and user space do not match.");
        isc_log_write(isc_lctx, &isc_categories[(signed long int)1], &isc_modules[(signed long int)0], -4, "IPv6 is not supported.");
        result = (unsigned int)23;
      }
  }

  close(s);
  return result;
}

// tspec_intv_to_lfp
// file ../include/timespecops.h line 297
static inline struct anonymous$20 tspec_intv_to_lfp(struct timespec x)
{
  struct timespec v;
  struct anonymous$20 y;
  v=normalize_tspec(x);
  y.l_uf = (unsigned int)((((unsigned long int)v.tv_nsec << 32) + (unsigned long int)(1000000000 / 2)) / (unsigned long int)1000000000);
  y.Ul_i.Xl_i = (signed int)v.tv_sec;
  return y;
}

// tspec_stamp_to_lfp
// file ../include/timespecops.h line 313
static inline struct anonymous$20 tspec_stamp_to_lfp(struct timespec x)
{
  struct anonymous$20 y;
  y=tspec_intv_to_lfp(x);
  y.Ul_i.Xl_ui = y.Ul_i.Xl_ui + (unsigned int)(719163 - 693596) * (unsigned int)(60 * 60 * 24);
  return y;
}

// tspectoa
// file ../include/timespecops.h line 284
static inline const char * tspectoa(struct timespec x)
{
  const char *return_value_format_time_fraction$1;
  return_value_format_time_fraction$1=format_time_fraction(x.tv_sec, x.tv_nsec, 9);
  return return_value_format_time_fraction$1;
}

// tval_intv_to_lfp
// file ../include/timevalops.h line 349
static inline struct anonymous$20 tval_intv_to_lfp(struct timeval x)
{
  struct timeval v;
  struct anonymous$20 y;
  v=normalize_tval$link1(x);
  y.l_uf = (unsigned int)((((unsigned long int)v.tv_usec << 32) + (unsigned long int)(1000000 / 2)) / (unsigned long int)1000000);
  y.Ul_i.Xl_i = (signed int)v.tv_sec;
  return y;
}

// tval_stamp_to_lfp
// file ../include/timevalops.h line 365
static inline struct anonymous$20 tval_stamp_to_lfp(struct timeval x)
{
  struct anonymous$20 y;
  y=tval_intv_to_lfp(x);
  y.Ul_i.Xl_ui = y.Ul_i.Xl_ui + (unsigned int)(719163 - 693596) * (unsigned int)(60 * 60 * 24);
  return y;
}

// ucmpv64
// file vint64ops.c line 152
extern signed int ucmpv64(const union anonymous$44 *lhs, const union anonymous$44 *rhs)
{
  signed int res = (signed int)(lhs->Q_s > rhs->Q_s) - (signed int)(lhs->Q_s < rhs->Q_s);
  return res;
}

// uglydate
// file uglydate.c line 15
extern char * uglydate(struct anonymous$20 *ts)
{
  char *bp;
  char *timep;
  struct tm *tm;
  signed long int sec;
  signed long int msec;
  signed int year;
  timep=dolfptoa(ts->Ul_i.Xl_ui, ts->l_uf, 0, (signed short int)6, 0);
  signed int tmp_post$1;
  do
  {
    bzero((void *)&lib_stringbuf[(signed long int)lib_nextbuf], sizeof(char [128l]) /*128ul*/ );
    tmp_post$1 = lib_nextbuf;
    lib_nextbuf = lib_nextbuf + 1;
    bp = &lib_stringbuf[(signed long int)tmp_post$1][(signed long int)0];
    lib_nextbuf = lib_nextbuf % (signed int)(sizeof(char [16l][128l]) /*2048ul*/  / sizeof(char [128l]) /*128ul*/ );
  }
  while((_Bool)0);
  sec = (signed long int)(ts->Ul_i.Xl_ui - (unsigned int)(719163 - 693596) * (unsigned int)(60 * 60 * 24));
  msec = (signed long int)(ts->l_uf / (unsigned int)4294967);
  tm=gmtime(&sec);
  if(ts->Ul_i.Xl_ui == 0u)
  {
    year = 0;
    tm->tm_yday = 0;
    tm->tm_hour = 0;
    tm->tm_min = 0;
    tm->tm_sec = 0;
  }

  else
  {
    year = tm->tm_year;
    for( ; year >= 100; year = year - 100)
      ;
  }
  snprintf(bp, (unsigned long int)128, "%17s %02d:%03d:%02d:%02d:%02d.%03ld", timep, year, tm->tm_yday, tm->tm_hour, tm->tm_min, tm->tm_sec, msec);
  return bp;
}

// uint32_2cpl_to_int32
// file ntp_calendar.c line 186
static inline signed int uint32_2cpl_to_int32(const unsigned int vu)
{
  signed int v = (signed int)vu;
  return v;
}

// uint32_saturate
// file ntp_calendar.c line 222
static inline unsigned int uint32_saturate(unsigned int vu, unsigned int mu)
{
  static const unsigned int limit = 4294967295U / 4u;
  if(!(limit >= (mu ^ vu)))
  {
    vu = mu ^ limit;
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 33;
  }

  return vu;
}

// vint64_to_time
// file ntp_calendar.c line 286
extern signed long int vint64_to_time(const union anonymous$44 *tv)
{
  signed long int res = (signed long int)tv->q_s;
  return res;
}

// wait_for_sem
// file work_thread.c line 597
static signed int wait_for_sem(union anonymous$65 *sem, struct timespec *timeout)
{
  signed int rc;
  if(timeout == ((struct timespec *)NULL))
    rc=sem_wait(sem);

  else
    rc=sem_timedwait(sem, timeout);
  return rc;
}

// worker_idle_timer_fired
// file ntp_worker.c line 321
extern void worker_idle_timer_fired(void)
{
  unsigned int idx;
  struct blocking_child_tag *c;

__CPROVER_DUMP_L1:
  ;
  intres_timeout_req((unsigned int)0);
  idx = (unsigned int)0;
  for( ; !((unsigned long int)idx >= blocking_children_alloc); idx = idx + 1u)
  {
    c = blocking_children[(signed long int)idx];
    if(!(c == ((struct blocking_child_tag *)NULL)))
      req_child_exit(c);

  }
}

// worker_sleep
// file ../include/ntp_worker.h line 130
extern signed int worker_sleep(struct blocking_child_tag *c, signed long int seconds)
{
  struct timespec until;
  signed int rc;
  signed int return_value_clock_gettime$1;
  return_value_clock_gettime$1=clock_gettime(0, &until);
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$4;
  if(!(return_value_clock_gettime$1 == 0))
  {
    msyslog(3, "worker_sleep: clock_gettime() failed: %m");
    return -1;
  }

  else
  {
    until.tv_sec = until.tv_sec + seconds;
    do
    {
      rc=wait_for_sem(c->wake_scheduled_sleep, &until);
      if(rc == -1)
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = 4 == *return_value___errno_location$2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
    }
    while(tmp_if_expr$3);
    if(rc == 0)
      return -1;

    else
      if(rc == -1)
      {
        return_value___errno_location$4=__errno_location();
        if(!(*return_value___errno_location$4 == 110))
          goto __CPROVER_DUMP_L6;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        msyslog(3, "worker_sleep: sem_timedwait: %m");
        return -1;
      }
  }
}

// year_to_ntp
// file clocktime.c line 143
static unsigned int year_to_ntp(signed int year)
{
  unsigned int days;
  signed int return_value_ntpcal_days_in_years$1;
  return_value_ntpcal_days_in_years$1=ntpcal_days_in_years(year - 1);
  days = (unsigned int)((return_value_ntpcal_days_in_years$1 - 693596) + 1);
  return days * (unsigned int)(60 * 60 * 24);
}

// ymd2yd
// file ymd2yd.c line 12
extern signed int ymd2yd(signed int y, signed int m, signed int d)
{
  signed int return_value_ntpcal_edate_to_yeardays$1;
  return_value_ntpcal_edate_to_yeardays$1=ntpcal_edate_to_yeardays(y - 1, m - 1, d - 1);
  return return_value_ntpcal_edate_to_yeardays$1 + 1;
}

