// #anon_enum_BACKEND_PROBE_BLADERF=0_BACKEND_PROBE_FX3_BOOTLOADER=1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.h line 40
enum anonymous_15 { BACKEND_PROBE_BLADERF=0, BACKEND_PROBE_FX3_BOOTLOADER=1 };

// #anon_enum_BLADERF_BACKEND_ANY=0_BLADERF_BACKEND_LINUX=1_BLADERF_BACKEND_LIBUSB=2_BLADERF_BACKEND_CYPRESS=3_BLADERF_BACKEND_DUMMY=100
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 148
enum anonymous_11 { BLADERF_BACKEND_ANY=0, BLADERF_BACKEND_LINUX=1, BLADERF_BACKEND_LIBUSB=2, BLADERF_BACKEND_CYPRESS=3, BLADERF_BACKEND_DUMMY=100 };

// #anon_enum_BLADERF_CORR_LMS_DCOFF_I=0_BLADERF_CORR_LMS_DCOFF_Q=1_BLADERF_CORR_FPGA_PHASE=2_BLADERF_CORR_FPGA_GAIN=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 771
enum anonymous_36 { BLADERF_CORR_LMS_DCOFF_I=0, BLADERF_CORR_LMS_DCOFF_Q=1, BLADERF_CORR_FPGA_PHASE=2, BLADERF_CORR_FPGA_GAIN=3 };

// #anon_enum_BLADERF_DC_CAL_INVALID=-1_BLADERF_DC_CAL_LPF_TUNING=0_BLADERF_DC_CAL_TX_LPF=1_BLADERF_DC_CAL_RX_LPF=2_BLADERF_DC_CAL_RXVGA2=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 754
enum anonymous_0 { BLADERF_DC_CAL_INVALID=-1, BLADERF_DC_CAL_LPF_TUNING=0, BLADERF_DC_CAL_TX_LPF=1, BLADERF_DC_CAL_RX_LPF=2, BLADERF_DC_CAL_RXVGA2=3 };

// #anon_enum_BLADERF_DEVICE_SPEED_UNKNOWN=0_BLADERF_DEVICE_SPEED_HIGH=1_BLADERF_DEVICE_SPEED_SUPER=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 161
enum anonymous_7 { BLADERF_DEVICE_SPEED_UNKNOWN=0, BLADERF_DEVICE_SPEED_HIGH=1, BLADERF_DEVICE_SPEED_SUPER=2 };

// #anon_enum_BLADERF_FORMAT_SC16_Q11=0_BLADERF_FORMAT_SC16_Q11_META=1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1580
enum anonymous_9 { BLADERF_FORMAT_SC16_Q11=0, BLADERF_FORMAT_SC16_Q11_META=1 };

// #anon_enum_BLADERF_FPGA_UNKNOWN=0_BLADERF_FPGA_40KLE=40_BLADERF_FPGA_115KLE=115
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2302
enum anonymous_5 { BLADERF_FPGA_UNKNOWN=0, BLADERF_FPGA_40KLE=40, BLADERF_FPGA_115KLE=115 };

// #anon_enum_BLADERF_IMAGE_TYPE_INVALID=-1_BLADERF_IMAGE_TYPE_RAW=0_BLADERF_IMAGE_TYPE_FIRMWARE=1_BLADERF_IMAGE_TYPE_FPGA_40KLE=2_BLADERF_IMAGE_TYPE_FPGA_115KLE=3_BLADERF_IMAGE_TYPE_CALIBRATION=4_BLADERF_IMAGE_TYPE_RX_DC_CAL=5_BLADERF_IMAGE_TYPE_TX_DC_CAL=6_BLADERF_IMAGE_TYPE_RX_IQ_CAL=7_BLADERF_IMAGE_TYPE_TX_IQ_CAL=8
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2552
enum anonymous_38 { BLADERF_IMAGE_TYPE_INVALID=-1, BLADERF_IMAGE_TYPE_RAW=0, BLADERF_IMAGE_TYPE_FIRMWARE=1, BLADERF_IMAGE_TYPE_FPGA_40KLE=2, BLADERF_IMAGE_TYPE_FPGA_115KLE=3, BLADERF_IMAGE_TYPE_CALIBRATION=4, BLADERF_IMAGE_TYPE_RX_DC_CAL=5, BLADERF_IMAGE_TYPE_TX_DC_CAL=6, BLADERF_IMAGE_TYPE_RX_IQ_CAL=7, BLADERF_IMAGE_TYPE_TX_IQ_CAL=8 };

// #anon_enum_BLADERF_LB_FIRMWARE=1_BLADERF_LB_BB_TXLPF_RXVGA2=2_BLADERF_LB_BB_TXVGA1_RXVGA2=3_BLADERF_LB_BB_TXLPF_RXLPF=4_BLADERF_LB_BB_TXVGA1_RXLPF=5_BLADERF_LB_RF_LNA1=6_BLADERF_LB_RF_LNA2=7_BLADERF_LB_RF_LNA3=8_BLADERF_LB_NONE=9
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 522
enum anonymous_3 { BLADERF_LB_FIRMWARE=1, BLADERF_LB_BB_TXLPF_RXVGA2=2, BLADERF_LB_BB_TXVGA1_RXVGA2=3, BLADERF_LB_BB_TXLPF_RXLPF=4, BLADERF_LB_BB_TXVGA1_RXLPF=5, BLADERF_LB_RF_LNA1=6, BLADERF_LB_RF_LNA2=7, BLADERF_LB_RF_LNA3=8, BLADERF_LB_NONE=9 };

// #anon_enum_BLADERF_LNA_GAIN_UNKNOWN=0_BLADERF_LNA_GAIN_BYPASS=1_BLADERF_LNA_GAIN_MID=2_BLADERF_LNA_GAIN_MAX=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 638
enum anonymous_12 { BLADERF_LNA_GAIN_UNKNOWN=0, BLADERF_LNA_GAIN_BYPASS=1, BLADERF_LNA_GAIN_MID=2, BLADERF_LNA_GAIN_MAX=3 };

// #anon_enum_BLADERF_LOG_LEVEL_VERBOSE=0_BLADERF_LOG_LEVEL_DEBUG=1_BLADERF_LOG_LEVEL_INFO=2_BLADERF_LOG_LEVEL_WARNING=3_BLADERF_LOG_LEVEL_ERROR=4_BLADERF_LOG_LEVEL_CRITICAL=5_BLADERF_LOG_LEVEL_SILENT=6
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2489
enum anonymous_26 { BLADERF_LOG_LEVEL_VERBOSE=0, BLADERF_LOG_LEVEL_DEBUG=1, BLADERF_LOG_LEVEL_INFO=2, BLADERF_LOG_LEVEL_WARNING=3, BLADERF_LOG_LEVEL_ERROR=4, BLADERF_LOG_LEVEL_CRITICAL=5, BLADERF_LOG_LEVEL_SILENT=6 };

// #anon_enum_BLADERF_LPF_NORMAL=0_BLADERF_LPF_BYPASSED=1_BLADERF_LPF_DISABLED=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 651
enum anonymous_14 { BLADERF_LPF_NORMAL=0, BLADERF_LPF_BYPASSED=1, BLADERF_LPF_DISABLED=2 };

// #anon_enum_BLADERF_MODULE_INVALID=-1_BLADERF_MODULE_RX=0_BLADERF_MODULE_TX=1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 660
enum anonymous { BLADERF_MODULE_INVALID=-1, BLADERF_MODULE_RX=0, BLADERF_MODULE_TX=1 };

// #anon_enum_BLADERF_RX_MUX_INVALID=-1_BLADERF_RX_MUX_BASEBAND_LMS=0_BLADERF_RX_MUX_12BIT_COUNTER=1_BLADERF_RX_MUX_32BIT_COUNTER=2_BLADERF_RX_MUX_DIGITAL_LOOPBACK=4
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 581
enum anonymous_33 { BLADERF_RX_MUX_INVALID=-1, BLADERF_RX_MUX_BASEBAND_LMS=0, BLADERF_RX_MUX_12BIT_COUNTER=1, BLADERF_RX_MUX_32BIT_COUNTER=2, BLADERF_RX_MUX_DIGITAL_LOOPBACK=4 };

// #anon_enum_BLADERF_SAMPLING_UNKNOWN=0_BLADERF_SAMPLING_INTERNAL=1_BLADERF_SAMPLING_EXTERNAL=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 629
enum anonymous_34 { BLADERF_SAMPLING_UNKNOWN=0, BLADERF_SAMPLING_INTERNAL=1, BLADERF_SAMPLING_EXTERNAL=2 };

// #anon_enum_BLADERF_TUNING_MODE_INVALID=-1_BLADERF_TUNING_MODE_HOST=0_BLADERF_TUNING_MODE_FPGA=1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 502
enum anonymous_10 { BLADERF_TUNING_MODE_INVALID=-1, BLADERF_TUNING_MODE_HOST=0, BLADERF_TUNING_MODE_FPGA=1 };

// #anon_enum_BLADERF_VCTCXO_TAMER_INVALID=-1_BLADERF_VCTCXO_TAMER_DISABLED=0_BLADERF_VCTCXO_TAMER_1_PPS=1_BLADERF_VCTCXO_TAMER_10_MHZ=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 811
enum anonymous_16 { BLADERF_VCTCXO_TAMER_INVALID=-1, BLADERF_VCTCXO_TAMER_DISABLED=0, BLADERF_VCTCXO_TAMER_1_PPS=1, BLADERF_VCTCXO_TAMER_10_MHZ=2 };

// #anon_enum_BLADERF_XB200_50M=0_BLADERF_XB200_144M=1_BLADERF_XB200_222M=2_BLADERF_XB200_CUSTOM=3_BLADERF_XB200_AUTO_1DB=4_BLADERF_XB200_AUTO_3DB=5
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 682
enum anonymous_8 { BLADERF_XB200_50M=0, BLADERF_XB200_144M=1, BLADERF_XB200_222M=2, BLADERF_XB200_CUSTOM=3, BLADERF_XB200_AUTO_1DB=4, BLADERF_XB200_AUTO_3DB=5 };

// #anon_enum_BLADERF_XB200_BYPASS=0_BLADERF_XB200_MIX=1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 731
enum anonymous_35 { BLADERF_XB200_BYPASS=0, BLADERF_XB200_MIX=1 };

// #anon_enum_BLADERF_XB_NONE=0_BLADERF_XB_100=1_BLADERF_XB_200=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 670
enum anonymous_6 { BLADERF_XB_NONE=0, BLADERF_XB_100=1, BLADERF_XB_200=2 };

// #anon_enum_BW_28MHz=0_BW_20MHz=1_BW_14MHz=2_BW_12MHz=3_BW_10MHz=4_BW_8p75MHz=5_BW_7MHz=6_BW_6MHz=7_BW_5p5MHz=8_BW_5MHz=9_BW_3p84MHz=10_BW_3MHz=11_BW_2p75MHz=12_BW_2p5MHz=13_BW_1p75MHz=14_BW_1p5MHz=15
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 87
enum anonymous_13 { BW_28MHz=0, BW_20MHz=1, BW_14MHz=2, BW_12MHz=3, BW_10MHz=4, BW_8p75MHz=5, BW_7MHz=6, BW_6MHz=7, BW_5p5MHz=8, BW_5MHz=9, BW_3p84MHz=10, BW_3MHz=11, BW_2p75MHz=12, BW_2p5MHz=13, BW_1p75MHz=14, BW_1p5MHz=15 };

// #anon_enum_LNA_NONE=0_LNA_1=1_LNA_2=2_LNA_3=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 110
enum anonymous_2 { LNA_NONE=0, LNA_1=1, LNA_2=2, LNA_3=3 };

// #anon_enum_PA_AUX=0_PA_1=1_PA_2=2_PA_NONE=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 129
enum anonymous_1 { PA_AUX=0, PA_1=1, PA_2=2, PA_NONE=3 };

// #anon_enum_STREAM_IDLE=0_STREAM_RUNNING=1_STREAM_SHUTTING_DOWN=2_STREAM_DONE=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.h line 28
enum anonymous_20 { STREAM_IDLE=0, STREAM_RUNNING=1, STREAM_SHUTTING_DOWN=2, STREAM_DONE=3 };

// #anon_enum_SYNC_BUFFER_EMPTY=0_SYNC_BUFFER_PARTIAL=1_SYNC_BUFFER_FULL=2_SYNC_BUFFER_IN_FLIGHT=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 43
enum anonymous_21 { SYNC_BUFFER_EMPTY=0, SYNC_BUFFER_PARTIAL=1, SYNC_BUFFER_FULL=2, SYNC_BUFFER_IN_FLIGHT=3 };

// #anon_enum_SYNC_META_STATE_HEADER=0_SYNC_META_STATE_SAMPLES=1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 50
enum anonymous_24 { SYNC_META_STATE_HEADER=0, SYNC_META_STATE_SAMPLES=1 };

// #anon_enum_SYNC_STATE_CHECK_WORKER=0_SYNC_STATE_RESET_BUF_MGMT=1_SYNC_STATE_START_WORKER=2_SYNC_STATE_WAIT_FOR_BUFFER=3_SYNC_STATE_BUFFER_READY=4_SYNC_STATE_USING_BUFFER=5_SYNC_STATE_USING_BUFFER_META=6
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 94
enum anonymous_19 { SYNC_STATE_CHECK_WORKER=0, SYNC_STATE_RESET_BUF_MGMT=1, SYNC_STATE_START_WORKER=2, SYNC_STATE_WAIT_FOR_BUFFER=3, SYNC_STATE_BUFFER_READY=4, SYNC_STATE_USING_BUFFER=5, SYNC_STATE_USING_BUFFER_META=6 };

// #anon_enum_SYNC_TX_SUBMITTER_INVALID=-1_SYNC_TX_SUBMITTER_FN=0_SYNC_TX_SUBMITTER_CALLBACK=1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 55
enum anonymous_22 { SYNC_TX_SUBMITTER_INVALID=-1, SYNC_TX_SUBMITTER_FN=0, SYNC_TX_SUBMITTER_CALLBACK=1 };

// #anon_enum_SYNC_WORKER_STATE_STARTUP=0_SYNC_WORKER_STATE_IDLE=1_SYNC_WORKER_STATE_RUNNING=2_SYNC_WORKER_STATE_SHUTTING_DOWN=3_SYNC_WORKER_STATE_STOPPED=4
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 42
enum anonymous_23 { SYNC_WORKER_STATE_STARTUP=0, SYNC_WORKER_STATE_IDLE=1, SYNC_WORKER_STATE_RUNNING=2, SYNC_WORKER_STATE_SHUTTING_DOWN=3, SYNC_WORKER_STATE_STOPPED=4 };

// #anon_enum_TRANSFER_UNINITIALIZED=0_TRANSFER_AVAIL=1_TRANSFER_IN_FLIGHT=2_TRANSFER_CANCEL_PENDING=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 47
enum anonymous_37 { TRANSFER_UNINITIALIZED=0, TRANSFER_AVAIL=1, TRANSFER_IN_FLIGHT=2, TRANSFER_CANCEL_PENDING=3 };

// #anon_enum_USB_DIR_HOST_TO_DEVICE=0_USB_DIR_DEVICE_TO_HOST=128
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 79
enum anonymous_30 { USB_DIR_HOST_TO_DEVICE=0, USB_DIR_DEVICE_TO_HOST=128 };

// #anon_enum_USB_REQUEST_STANDARD=0_USB_REQUEST_CLASS=1_USB_REQUEST_VENDOR=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 73
enum anonymous_29 { USB_REQUEST_STANDARD=0, USB_REQUEST_CLASS=1, USB_REQUEST_VENDOR=2 };

// #anon_enum_USB_TARGET_DEVICE=0_USB_TARGET_INTERFACE=1_USB_TARGET_ENDPOINT=2_USB_TARGET_OTHER=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 66
enum anonymous_28 { USB_TARGET_DEVICE=0, USB_TARGET_INTERFACE=1, USB_TARGET_ENDPOINT=2, USB_TARGET_OTHER=3 };

// tag-#anon#ST[B'in_burst'||B'now'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 124
struct anonymous_32;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_17;

// tag-#anon#ST[U64'msg_timestamp'||U32'msg_flags'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 118
struct anonymous_31;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_27;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_18;

// tag-#anon#UN[SYM#tag-#anon#ST[U64'msg_timestamp'||U32'msg_flags'||U32'_pad0'|]#'_anon0'||SYM#tag-#anon#ST[B'in_burst'||B'now'|]#'_anon1'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 116
union anonymous_25;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_4;

// tag-SHA256Context
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/sha256.h line 42
struct SHA256Context;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-backend_fns
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.h line 54
struct backend_fns;

// tag-bladerf
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 142
struct bladerf;

// tag-bladerf_devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 176
struct bladerf_devinfo;

// tag-bladerf_devinfo_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.h line 38
struct bladerf_devinfo_list;

// tag-bladerf_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2591
struct bladerf_image;

// tag-bladerf_lms_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 3190
struct bladerf_lms_dc_cals;

// tag-bladerf_lusb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 41
struct bladerf_lusb;

// tag-bladerf_metadata
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1746
struct bladerf_metadata;

// tag-bladerf_quick_tune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 743
struct bladerf_quick_tune;

// tag-bladerf_rational_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 619
struct bladerf_rational_rate;

// tag-bladerf_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1829
struct bladerf_stream;

// tag-bladerf_sync
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 127
struct bladerf_sync;

// tag-bladerf_usb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 145
struct bladerf_usb;

// tag-bladerf_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2288
struct bladerf_version;

// tag-buffer_mgmt
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 68
struct buffer_mgmt;

// tag-calibrations
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 82
struct calibrations;

// tag-compat
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 36
struct compat;

// tag-dc_cal_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.h line 28
struct dc_cal_entry;

// tag-dc_cal_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 109
struct dc_cal_state;

// tag-dc_cal_tbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 83
struct dc_cal_tbl;

// tag-freq_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 190
struct freq_range;

// tag-fx3_firmware
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.h line 31
struct fx3_firmware;

// tag-libusb_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 643
struct libusb_config_descriptor;

// tag-libusb_context
// file /usr/include/libusb-1.0/libusb.h line 898
struct libusb_context;

// tag-libusb_device
// file /usr/include/libusb-1.0/libusb.h line 899
struct libusb_device;

// tag-libusb_device_descriptor
// file /usr/include/libusb-1.0/libusb.h line 477
struct libusb_device_descriptor;

// tag-libusb_device_handle
// file /usr/include/libusb-1.0/libusb.h line 900
struct libusb_device_handle;

// tag-libusb_endpoint_descriptor
// file /usr/include/libusb-1.0/libusb.h line 531
struct libusb_endpoint_descriptor;

// tag-libusb_interface
// file /usr/include/libusb-1.0/libusb.h line 629
struct libusb_interface;

// tag-libusb_interface_descriptor
// file /usr/include/libusb-1.0/libusb.h line 581
struct libusb_interface_descriptor;

// tag-libusb_iso_packet_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1177
struct libusb_iso_packet_descriptor;

// tag-libusb_transfer
// file /usr/include/libusb-1.0/libusb.h line 1188
struct libusb_transfer;

// tag-libusb_transfer_status
// file /usr/include/libusb-1.0/libusb.h line 1106
enum libusb_transfer_status { LIBUSB_TRANSFER_COMPLETED=0, LIBUSB_TRANSFER_ERROR=1, LIBUSB_TRANSFER_TIMED_OUT=2, LIBUSB_TRANSFER_CANCELLED=3, LIBUSB_TRANSFER_STALL=4, LIBUSB_TRANSFER_NO_DEVICE=5, LIBUSB_TRANSFER_OVERFLOW=6 };

// tag-libusb_version
// file /usr/include/libusb-1.0/libusb.h line 905
struct libusb_version;

// tag-lms_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 68
struct lms_freq;

// tag-lusb_stream_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 54
struct lusb_stream_data;

// tag-numeric_suffix
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/conversions.h line 44
struct numeric_suffix;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-search_path_entries
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 37
struct search_path_entries;

// tag-si5338_multisynth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 49
struct si5338_multisynth;

// tag-str2args_parse_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 34
enum str2args_parse_state { PARSE_STATE_IN_SPACE=0, PARSE_STATE_START_ARG=1, PARSE_STATE_IN_ARG=2, PARSE_STATE_IN_QUOTE=3, PARSE_STATE_ERROR=4 };

// tag-stream_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 31
struct stream_config;

// tag-sync_meta
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 104
struct sync_meta;

// tag-sync_worker
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 139
struct sync_worker;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tx_options
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 699
struct tx_options;

// tag-uart_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_legacy.h line 226
struct uart_cmd;

// tag-usb_driver
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 140
struct usb_driver;

// tag-usb_fns
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 91
struct usb_fns;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// SHA256_Final
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/sha256.h line 50
void SHA256_Final(unsigned char *digest, struct SHA256Context *ctx);
// SHA256_Init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/sha256.h line 48
void SHA256_Init(struct SHA256Context *ctx);
// SHA256_Pad
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 245
static void SHA256_Pad(struct SHA256Context *ctx);
// SHA256_Transform
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 150
static void SHA256_Transform(unsigned int *state, const unsigned char *block);
// SHA256_Update
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/sha256.h line 49
void SHA256_Update(struct SHA256Context *ctx, const void *in, unsigned long int len);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __bladerf_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/init_fini.c line 93
void __bladerf_fini(void);
// __bladerf_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/init_fini.c line 79
void __bladerf_init(void);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 105
signed int add_field(char *buf, signed int buf_len, const char *field_name, const char *val);
// addr_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 633
static inline _Bool addr_matches(unsigned char addr, struct libusb_device *d);
// advance_rx_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 258
static inline void advance_rx_buffer(struct buffer_mgmt *b);
// advance_tx_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 621
static signed int advance_tx_buffer(struct bladerf_sync *s, struct buffer_mgmt *b);
// append_char
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 306
static signed int append_char(char **arg, signed int *arg_size, signed int *arg_i, char c);
// apply_lms_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 36
static inline signed int apply_lms_dc_cals(struct bladerf *dev);
// async_deinit_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.c line 205
void async_deinit_stream(struct bladerf_stream *stream);
// async_init_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.c line 27
signed int async_init_stream(struct bladerf_stream **stream, struct bladerf *dev, void * (*callback)(struct bladerf *, struct bladerf_stream *, struct bladerf_metadata *, void *, unsigned long int, void *), void ***buffers, unsigned long int num_buffers, enum anonymous_9 format, unsigned long int samples_per_buffer, unsigned long int num_transfers, void *user_data);
// async_init_stream::callback_object
//
void * callback_object(struct bladerf *, struct bladerf_stream *, struct bladerf_metadata *, void *, unsigned long int, void *);
// async_run_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.c line 138
signed int async_run_stream(struct bladerf_stream *stream, enum anonymous module);
// async_stream_buf_bytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.h line 62
static inline unsigned long int async_stream_buf_bytes(struct bladerf_stream *s);
// async_submit_stream_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.c line 155
signed int async_submit_stream_buffer(struct bladerf_stream *stream, void *buffer, unsigned int timeout_ms, _Bool nonblock);
// backend2str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 131
const char * backend2str(enum anonymous_11 backend);
// backend_description
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 594
const char * backend_description(enum anonymous_11 b);
// backend_load_fw_from_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 112
signed int backend_load_fw_from_bootloader(enum anonymous_11 backend, unsigned char bus, unsigned char addr, struct fx3_firmware *fw);
// backend_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 43
signed int backend_open(struct bladerf *device, struct bladerf_devinfo *info);
// backend_probe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 63
signed int backend_probe(enum anonymous_15 probe_target, struct bladerf_devinfo **devinfo_items, unsigned long int *num_items);
// band_select
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/band_select.h line 48
signed int band_select(struct bladerf *dev, enum anonymous module, _Bool low_band);
// be32dec
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 73
static inline unsigned int be32dec(const void *pp);
// be32dec_vect
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 110
static void be32dec_vect(unsigned int *dst, const unsigned char *src, unsigned long int len);
// be32enc
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 81
static inline void be32enc(void *pp, unsigned int u);
// be32enc_vect
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 97
static void be32enc_vect(unsigned char *dst, const unsigned int *src, unsigned long int len);
// begin_fpga_programming
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 390
static signed int begin_fpga_programming(struct bladerf *dev);
// bladerf_alloc_cal_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 486
struct bladerf_image * bladerf_alloc_cal_image(enum anonymous_5 fpga_size, unsigned short int vctcxo_trim);
// bladerf_alloc_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2674
struct bladerf_image * bladerf_alloc_image(enum anonymous_38 type, unsigned int address, unsigned int length);
// bladerf_backend_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1477
const char * bladerf_backend_str(enum anonymous_11 backend);
// bladerf_bus_addr_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.h line 77
_Bool bladerf_bus_addr_matches(struct bladerf_devinfo *a, struct bladerf_devinfo *b);
// bladerf_calibrate_dc
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1919
signed int bladerf_calibrate_dc(struct bladerf *dev, enum anonymous_0 module);
// bladerf_cancel_scheduled_retunes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 912
signed int bladerf_cancel_scheduled_retunes(struct bladerf *dev, enum anonymous m);
// bladerf_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 300
void bladerf_close(struct bladerf *dev);
// bladerf_config_gpio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1562
signed int bladerf_config_gpio_read(struct bladerf *dev, unsigned int *val);
// bladerf_config_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1573
signed int bladerf_config_gpio_write(struct bladerf *dev, unsigned int val);
// bladerf_dac_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1862
signed int bladerf_dac_read(struct bladerf *dev, unsigned short int *val);
// bladerf_dac_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1851
signed int bladerf_dac_write(struct bladerf *dev, unsigned short int val);
// bladerf_deinit_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1110
void bladerf_deinit_stream(struct bladerf_stream *stream);
// bladerf_device_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1225
signed int bladerf_device_reset(struct bladerf *dev);
// bladerf_device_speed
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1176
enum anonymous_7 bladerf_device_speed(struct bladerf *dev);
// bladerf_devinfo_list_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.c line 85
signed int bladerf_devinfo_list_add(struct bladerf_devinfo_list *list, struct bladerf_devinfo *info);
// bladerf_devinfo_list_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.h line 83
signed int bladerf_devinfo_list_init(struct bladerf_devinfo_list *list);
// bladerf_devinfo_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1449
_Bool bladerf_devinfo_matches(struct bladerf_devinfo *a, struct bladerf_devinfo *b);
// bladerf_devstr_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1458
_Bool bladerf_devstr_matches(const char *dev_str, struct bladerf_devinfo *info);
// bladerf_enable_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 335
signed int bladerf_enable_module(struct bladerf *dev, enum anonymous m, _Bool enable);
// bladerf_erase_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1189
signed int bladerf_erase_flash(struct bladerf *dev, unsigned int erase_block, unsigned int count);
// bladerf_erase_stored_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1320
signed int bladerf_erase_stored_fpga(struct bladerf *dev);
// bladerf_expansion_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1588
signed int bladerf_expansion_attach(struct bladerf *dev, enum anonymous_6 xb);
// bladerf_expansion_get_attached
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1599
signed int bladerf_expansion_get_attached(struct bladerf *dev, enum anonymous_6 *xb);
// bladerf_expansion_gpio_dir_masked_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1739
signed int bladerf_expansion_gpio_dir_masked_write(struct bladerf *dev, unsigned int mask, unsigned int val);
// bladerf_expansion_gpio_dir_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1723
signed int bladerf_expansion_gpio_dir_read(struct bladerf *dev, unsigned int *val);
// bladerf_expansion_gpio_dir_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1734
signed int bladerf_expansion_gpio_dir_write(struct bladerf *dev, unsigned int val);
// bladerf_expansion_gpio_masked_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1700
signed int bladerf_expansion_gpio_masked_write(struct bladerf *dev, unsigned int mask, unsigned int val);
// bladerf_expansion_gpio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1678
signed int bladerf_expansion_gpio_read(struct bladerf *dev, unsigned int *val);
// bladerf_expansion_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1689
signed int bladerf_expansion_gpio_write(struct bladerf *dev, unsigned int val);
// bladerf_flash_firmware
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1262
signed int bladerf_flash_firmware(struct bladerf *dev, const char *firmware_file);
// bladerf_flash_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1309
signed int bladerf_flash_fpga(struct bladerf *dev, const char *fpga_file);
// bladerf_fpga_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1168
signed int bladerf_fpga_version(struct bladerf *dev, struct bladerf_version *version);
// bladerf_free_device_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 83
void bladerf_free_device_list(struct bladerf_devinfo *devices);
// bladerf_free_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2699
void bladerf_free_image(struct bladerf_image *image);
// bladerf_fw_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1149
signed int bladerf_fw_version(struct bladerf *dev, struct bladerf_version *version);
// bladerf_get_bandwidth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1281
signed int bladerf_get_bandwidth(struct bladerf *dev, enum anonymous module, unsigned int *bandwidth);
// bladerf_get_bootloader_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1934
signed int bladerf_get_bootloader_list(struct bladerf_devinfo **devices);
// bladerf_get_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1796
signed int bladerf_get_correction(struct bladerf *dev, enum anonymous module, enum anonymous_36 corr, signed short int *value);
// bladerf_get_device_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 78
signed int bladerf_get_device_list(struct bladerf_devinfo **devices);
// bladerf_get_devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1431
signed int bladerf_get_devinfo(struct bladerf *dev, struct bladerf_devinfo *info);
// bladerf_get_devinfo_from_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1443
signed int bladerf_get_devinfo_from_str(const char *devstr, struct bladerf_devinfo *info);
// bladerf_get_fpga_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1141
signed int bladerf_get_fpga_size(struct bladerf *dev, enum anonymous_5 *size);
// bladerf_get_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1422
signed int bladerf_get_frequency(struct bladerf *dev, enum anonymous module, unsigned int *frequency);
// bladerf_get_fw_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1979
signed int bladerf_get_fw_log(struct bladerf *dev, const char *filename);
// bladerf_get_lna_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 696
signed int bladerf_get_lna_gain(struct bladerf *dev, enum anonymous_12 *gain);
// bladerf_get_loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 422
signed int bladerf_get_loopback(struct bladerf *dev, enum anonymous_3 *l);
// bladerf_get_lpf_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 832
signed int bladerf_get_lpf_mode(struct bladerf *dev, enum anonymous module, enum anonymous_14 *mode);
// bladerf_get_quick_tune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 944
signed int bladerf_get_quick_tune(struct bladerf *dev, enum anonymous module, struct bladerf_quick_tune *quick_tune);
// bladerf_get_rational_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1003
signed int bladerf_get_rational_sample_rate(struct bladerf *dev, enum anonymous module, struct bladerf_rational_rate *rate);
// bladerf_get_rational_smb_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 595
signed int bladerf_get_rational_smb_frequency(struct bladerf *dev, struct bladerf_rational_rate *rate);
// bladerf_get_rx_mux
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 484
signed int bladerf_get_rx_mux(struct bladerf *dev, enum anonymous_33 *mux);
// bladerf_get_rxvga1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 718
signed int bladerf_get_rxvga1(struct bladerf *dev, signed int *gain);
// bladerf_get_rxvga2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 740
signed int bladerf_get_rxvga2(struct bladerf *dev, signed int *gain);
// bladerf_get_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 558
signed int bladerf_get_sample_rate(struct bladerf *dev, enum anonymous module, unsigned int *rate);
// bladerf_get_sampling
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 618
signed int bladerf_get_sampling(struct bladerf *dev, enum anonymous_34 *sampling);
// bladerf_get_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1125
signed int bladerf_get_serial(struct bladerf *dev, char *serial);
// bladerf_get_smb_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 607
signed int bladerf_get_smb_frequency(struct bladerf *dev, unsigned int *rate);
// bladerf_get_stream_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 983
signed int bladerf_get_stream_timeout(struct bladerf *dev, enum anonymous module, unsigned int *timeout);
// bladerf_get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1836
signed int bladerf_get_timestamp(struct bladerf *dev, enum anonymous module, unsigned long int *value);
// bladerf_get_txvga1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 673
signed int bladerf_get_txvga1(struct bladerf *dev, signed int *gain);
// bladerf_get_txvga2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 651
signed int bladerf_get_txvga2(struct bladerf *dev, signed int *gain);
// bladerf_get_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1889
signed int bladerf_get_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 *mode);
// bladerf_get_vctcxo_trim
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1133
signed int bladerf_get_vctcxo_trim(struct bladerf *dev, unsigned short int *trim);
// bladerf_image_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2744
signed int bladerf_image_read(struct bladerf_image *img, const char *file);
// bladerf_image_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 276
signed int bladerf_image_write(struct bladerf_image *img, const char *file);
// bladerf_init_devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 338
void bladerf_init_devinfo(struct bladerf_devinfo *info);
// bladerf_init_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1055
signed int bladerf_init_stream(struct bladerf_stream **stream, struct bladerf *dev, void * (*callback)(struct bladerf *, struct bladerf_stream *, struct bladerf_metadata *, void *, unsigned long int, void *), void ***buffers, unsigned long int num_buffers, enum anonymous_9 format, unsigned long int samples_per_buffer, unsigned long int num_transfers, void *data);
// bladerf_init_stream::callback_object
//
void * callback_object(struct bladerf *, struct bladerf_stream *, struct bladerf_metadata *, void *, unsigned long int, void *);
// bladerf_instance_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.h line 53
_Bool bladerf_instance_matches(struct bladerf_devinfo *a, struct bladerf_devinfo *b);
// bladerf_is_fpga_configured
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1157
signed int bladerf_is_fpga_configured(struct bladerf *dev);
// bladerf_jump_to_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1236
signed int bladerf_jump_to_bootloader(struct bladerf *dev);
// bladerf_lms_get_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1546
signed int bladerf_lms_get_dc_cals(struct bladerf *dev, struct bladerf_lms_dc_cals *dc_cals);
// bladerf_lms_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1512
signed int bladerf_lms_read(struct bladerf *dev, unsigned char address, unsigned char *val);
// bladerf_lms_set_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1534
signed int bladerf_lms_set_dc_cals(struct bladerf *dev, struct bladerf_lms_dc_cals *dc_cals);
// bladerf_lms_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1523
signed int bladerf_lms_write(struct bladerf *dev, unsigned char address, unsigned char val);
// bladerf_load_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1297
signed int bladerf_load_fpga(struct bladerf *dev, const char *fpga_file);
// bladerf_load_fw_from_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1939
signed int bladerf_load_fw_from_bootloader(const char *device_identifier, enum anonymous_11 backend, unsigned char bus, unsigned char addr, const char *file);
// bladerf_log_set_verbosity
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1407
void bladerf_log_set_verbosity(enum anonymous_26 level);
// bladerf_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 286
signed int bladerf_open(struct bladerf **device, const char *dev_id);
// bladerf_open_with_devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 225
signed int bladerf_open_with_devinfo(struct bladerf **opened_device, struct bladerf_devinfo *devinfo);
// bladerf_read_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1201
signed int bladerf_read_flash(struct bladerf *dev, unsigned char *buf, unsigned int page, unsigned int count);
// bladerf_schedule_retune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 869
signed int bladerf_schedule_retune(struct bladerf *dev, enum anonymous module, unsigned long int timestamp, unsigned int frequency, struct bladerf_quick_tune *quick_tune);
// bladerf_select_band
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 844
signed int bladerf_select_band(struct bladerf *dev, enum anonymous module, unsigned int frequency);
// bladerf_serial_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.h line 65
_Bool bladerf_serial_matches(struct bladerf_devinfo *a, struct bladerf_devinfo *b);
// bladerf_set_bandwidth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1267
signed int bladerf_set_bandwidth(struct bladerf *dev, enum anonymous module, unsigned int bandwidth, unsigned int *actual);
// bladerf_set_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1761
signed int bladerf_set_correction(struct bladerf *dev, enum anonymous module, enum anonymous_36 corr, signed short int value);
// bladerf_set_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1353
signed int bladerf_set_frequency(struct bladerf *dev, enum anonymous module, unsigned int frequency);
// bladerf_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 752
signed int bladerf_set_gain(struct bladerf *dev, enum anonymous mod, signed int gain);
// bladerf_set_lna_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1169
signed int bladerf_set_lna_gain(struct bladerf *dev, enum anonymous_12 gain);
// bladerf_set_loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 363
signed int bladerf_set_loopback(struct bladerf *dev, enum anonymous_3 l);
// bladerf_set_lpf_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 820
signed int bladerf_set_lpf_mode(struct bladerf *dev, enum anonymous module, enum anonymous_14 mode);
// bladerf_set_rational_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 521
signed int bladerf_set_rational_sample_rate(struct bladerf *dev, enum anonymous module, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual);
// bladerf_set_rational_smb_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 570
signed int bladerf_set_rational_smb_frequency(struct bladerf *dev, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual);
// bladerf_set_rx_mux
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 446
signed int bladerf_set_rx_mux(struct bladerf *dev, enum anonymous_33 mux);
// bladerf_set_rxvga1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1193
signed int bladerf_set_rxvga1(struct bladerf *dev, signed int gain);
// bladerf_set_rxvga2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1217
signed int bladerf_set_rxvga2(struct bladerf *dev, signed int gain);
// bladerf_set_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 920
signed int bladerf_set_sample_rate(struct bladerf *dev, enum anonymous module, unsigned int rate, unsigned int *actual);
// bladerf_set_sampling
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 629
signed int bladerf_set_sampling(struct bladerf *dev, enum anonymous_34 sampling);
// bladerf_set_smb_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 583
signed int bladerf_set_smb_frequency(struct bladerf *dev, unsigned int rate, unsigned int *actual);
// bladerf_set_stream_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 969
signed int bladerf_set_stream_timeout(struct bladerf *dev, enum anonymous module, unsigned int timeout);
// bladerf_set_tuning_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 957
signed int bladerf_set_tuning_mode(struct bladerf *dev, enum anonymous_10 mode);
// bladerf_set_txvga1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1147
signed int bladerf_set_txvga1(struct bladerf *dev, signed int gain);
// bladerf_set_txvga2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1121
signed int bladerf_set_txvga2(struct bladerf *dev, signed int gain);
// bladerf_set_usb_reset_on_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 322
void bladerf_set_usb_reset_on_open(_Bool enabled);
// bladerf_set_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1877
signed int bladerf_set_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 mode);
// bladerf_si5338_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1486
signed int bladerf_si5338_read(struct bladerf *dev, unsigned char address, unsigned char *val);
// bladerf_si5338_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1497
signed int bladerf_si5338_write(struct bladerf *dev, unsigned char address, unsigned char val);
// bladerf_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1075
signed int bladerf_stream(struct bladerf_stream *stream, enum anonymous module);
// bladerf_strerror
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2508
const char * bladerf_strerror(signed int error);
// bladerf_submit_stream_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1098
signed int bladerf_submit_stream_buffer(struct bladerf_stream *stream, void *buffer, unsigned int timeout_ms);
// bladerf_submit_stream_buffer_nb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1105
signed int bladerf_submit_stream_buffer_nb(struct bladerf_stream *stream, void *buffer);
// bladerf_sync_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 995
signed int bladerf_sync_config(struct bladerf *dev, enum anonymous module, enum anonymous_9 format, unsigned int num_buffers, unsigned int buffer_size, unsigned int num_transfers, unsigned int stream_timeout);
// bladerf_sync_rx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1041
signed int bladerf_sync_rx(struct bladerf *dev, void *samples, unsigned int num_samples, struct bladerf_metadata *metadata, unsigned int timeout_ms);
// bladerf_sync_tx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1027
signed int bladerf_sync_tx(struct bladerf *dev, void *samples, unsigned int num_samples, struct bladerf_metadata *metadata, unsigned int timeout_ms);
// bladerf_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1399
void bladerf_version(struct bladerf_version *version);
// bladerf_write_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1213
signed int bladerf_write_flash(struct bladerf *dev, const unsigned char *buf, unsigned int page, unsigned int count);
// bladerf_xb200_get_filterbank
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1634
signed int bladerf_xb200_get_filterbank(struct bladerf *dev, enum anonymous module, enum anonymous_8 *filter);
// bladerf_xb200_get_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1660
signed int bladerf_xb200_get_path(struct bladerf *dev, enum anonymous module, enum anonymous_35 *path);
// bladerf_xb200_set_filterbank
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1621
signed int bladerf_xb200_set_filterbank(struct bladerf *dev, enum anonymous mod, enum anonymous_8 filter);
// bladerf_xb200_set_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1647
signed int bladerf_xb200_set_path(struct bladerf *dev, enum anonymous module, enum anonymous_35 path);
// bladerf_xb_spi_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1905
signed int bladerf_xb_spi_write(struct bladerf *dev, unsigned int val);
// bm_request_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 742
static inline unsigned char bm_request_type(enum anonymous_28 target_type, enum anonymous_29 req_type, enum anonymous_30 direction);
// bus_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 627
static inline _Bool bus_matches(unsigned char bus, struct libusb_device *d);
// bytes_to_sc16q11
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 145
static inline unsigned long int bytes_to_sc16q11(unsigned long int n_bytes);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cancel_all_transfers
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 864
static inline void cancel_all_transfers(struct bladerf_stream *stream);
// capabilities_init_post_fpga_load
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.c line 48
void capabilities_init_post_fpga_load(struct bladerf *dev);
// capabilities_init_pre_fpga_load
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.c line 28
void capabilities_init_pre_fpga_load(struct bladerf *dev);
// change_setting
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 106
static inline signed int change_setting(struct bladerf *dev, unsigned char setting);
// check_eb_access
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 34
static inline signed int check_eb_access(unsigned int erase_block, unsigned int count);
// check_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 417
signed int check_module(enum anonymous m);
// check_page_access
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 51
static inline signed int check_page_access(unsigned int page, unsigned int count);
// check_xb200_filter
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 435
signed int check_xb200_filter(enum anonymous_8 f);
// check_xb200_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 458
signed int check_xb200_path(enum anonymous_35 p);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// config_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 224
signed int config_gpio_write(struct bladerf *dev, unsigned int val);
// config_load_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/config.h line 37
signed int config_load_dc_cals(struct bladerf *dev);
// config_load_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/config.h line 51
signed int config_load_fpga(struct bladerf *dev);
// crc16mp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 32
static unsigned short int crc16mp(unsigned short int crcval, void *data_p, unsigned short int count);
// dc_cal_backup
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2494
static inline signed int dc_cal_backup(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state);
// dc_cal_interp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 238
static inline void dc_cal_interp(struct dc_cal_tbl *tbl, unsigned int idx_low, unsigned int idx_high, unsigned int freq, signed short int *dc_i, signed short int *dc_q);
// dc_cal_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2949
static inline signed int dc_cal_module(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state, _Bool *converged);
// dc_cal_module_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2847
static signed int dc_cal_module_deinit(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state);
// dc_cal_module_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2534
static signed int dc_cal_module_init(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state);
// dc_cal_restore
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2910
static inline signed int dc_cal_restore(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state);
// dc_cal_retry_adjustment
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2792
static signed int dc_cal_retry_adjustment(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state, _Bool *limit_reached);
// dc_cal_submodule
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2663
static signed int dc_cal_submodule(struct bladerf *dev, enum anonymous_0 module, unsigned int submodule, struct dc_cal_state *state, _Bool *converged);
// dc_cal_tbl_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.h line 85
void dc_cal_tbl_free(struct dc_cal_tbl **tbl);
// dc_cal_tbl_load
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.h line 76
struct dc_cal_tbl * dc_cal_tbl_load(unsigned char *buf, unsigned long int buf_len);
// dc_cal_tbl_lookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 122
unsigned int dc_cal_tbl_lookup(struct dc_cal_tbl *tbl, unsigned int freq);
// dc_cal_tbl_vals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 256
void dc_cal_tbl_vals(struct dc_cal_tbl *tbl, unsigned int freq, signed short int *dc_i, signed short int *dc_q);
// device_has_vid_pid
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 171
static _Bool device_has_vid_pid(struct libusb_device *dev, unsigned short int vid, unsigned short int pid);
// device_is_bladerf
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 195
static _Bool device_is_bladerf(struct libusb_device *dev);
// device_is_fx3_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 188
static _Bool device_is_fx3_bootloader(struct libusb_device *dev);
// device_is_probe_target
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 234
static _Bool device_is_probe_target(enum anonymous_15 probe_target, struct libusb_device *dev);
// devspeed2str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 328
const char * devspeed2str(enum anonymous_7 speed);
// enable_lna_power
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1093
static inline signed int enable_lna_power(struct bladerf *dev, _Bool enable);
// enable_lpf_cal_clock
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3013
static inline signed int enable_lpf_cal_clock(struct bladerf *dev, _Bool enable);
// enable_rf_loopback_switch
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1133
static inline signed int enable_rf_loopback_switch(struct bladerf *dev, _Bool enable);
// enable_rxlpf_dccal_clock
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3039
static inline signed int enable_rxlpf_dccal_clock(struct bladerf *dev, _Bool enable);
// enable_rxvga2_dccal_clock
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3026
static inline signed int enable_rxvga2_dccal_clock(struct bladerf *dev, _Bool enable);
// enable_txlpf_dccal_clock
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3052
static inline signed int enable_txlpf_dccal_clock(struct bladerf *dev, _Bool enable);
// encode_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.h line 86
signed int encode_field(char *ptr, signed int len, signed int *idx, const char *field, const char *val);
// entry_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 72
static inline _Bool entry_matches(struct dc_cal_tbl *tbl, unsigned int entry_idx, unsigned int freq);
// error_conv
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 80
static signed int error_conv(signed int error);
// estimate_vcocap
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 342
static inline unsigned char estimate_vcocap(unsigned int f_target, unsigned int f_low, unsigned int f_high);
// example_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/doc/examples/example_common.c line 31
struct bladerf * example_init(const char *devstr);
// exec_idle_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 378
static enum anonymous_23 exec_idle_state(struct bladerf_sync *s);
// exec_running_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 442
static void exec_running_state(struct bladerf_sync *s);
// execute_fw_from_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 961
static signed int execute_fw_from_bootloader(struct bladerf_usb *usb, unsigned int addr);
// extract_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 49
static signed int extract_field(char *ptr, signed int len, char *field, char *val, unsigned long int maxlen);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// file_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.h line 94
char * file_find(const char *filename);
// file_find_and_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 502
signed int file_find_and_read(const char *filename, unsigned char **buf, unsigned long int *size);
// file_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 55
signed int file_read(struct _IO_FILE *f, char *buf, unsigned long int len);
// file_read_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.h line 49
signed int file_read_buffer(const char *filename, unsigned char **buf_ret, unsigned long int *size_ret);
// file_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 72
signed long int file_size(struct _IO_FILE *f);
// file_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 42
signed int file_write(struct _IO_FILE *f, unsigned char *buf, unsigned long int len);
// fill_fpga_metadata_page
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 200
static inline void fill_fpga_metadata_page(unsigned char *metadata, unsigned long int actual_bitstream_len);
// find_and_open_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 395
static signed int find_and_open_device(struct libusb_context *context, struct bladerf_devinfo *info_in, struct bladerf_lusb **dev_out, struct bladerf_devinfo *info_out);
// find_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 83
static unsigned int find_entry(struct dc_cal_tbl *tbl, unsigned int curr_idx, unsigned int min_idx, unsigned int max_idx, unsigned int freq, _Bool *hit_limit);
// find_fpga_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 105
static struct compat * find_fpga_match(struct bladerf *dev);
// find_fw_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 75
static struct compat * find_fw_match(struct bladerf *dev);
// flash_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 98
signed int flash_erase(struct bladerf *dev, unsigned int erase_block, unsigned int count);
// flash_erase_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 165
signed int flash_erase_fpga(struct bladerf *dev);
// flash_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 113
signed int flash_read(struct bladerf *dev, unsigned char *buf, unsigned int page, unsigned int count);
// flash_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 127
signed int flash_write(struct bladerf *dev, const unsigned char *buf, unsigned int page, unsigned int count);
// flash_write_fpga_bitstream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 216
signed int flash_write_fpga_bitstream(struct bladerf *dev, unsigned char **bitstream, unsigned long int len);
// flash_write_fx3_fw
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 142
signed int flash_write_fx3_fw(struct bladerf *dev, unsigned char **image, unsigned long int len);
// float_to_sc16q11
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 627
void float_to_sc16q11(const float *in, signed short int *out, unsigned int n);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fpga_check_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fpga.h line 41
signed int fpga_check_version(struct bladerf *dev);
// fpga_load_from_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fpga.h line 54
signed int fpga_load_from_file(struct bladerf *dev, const char *fpga_file);
// fpga_supports_tuning_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.c line 29
static _Bool fpga_supports_tuning_mode(struct bladerf *dev, enum anonymous_10 mode);
// fpga_write_to_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fpga.h line 66
signed int fpga_write_to_flash(struct bladerf *dev, const char *fpga_file);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 284
void free_args(signed int argc, char **argv);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// fx3_fw_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.h line 52
void fx3_fw_deinit(struct fx3_firmware *fw);
// fx3_fw_entry_point
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 357
unsigned int fx3_fw_entry_point(struct fx3_firmware *fw);
// fx3_fw_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 223
struct fx3_firmware * fx3_fw_init();
// fx3_fw_log_dump
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw_log.h line 37
signed int fx3_fw_log_dump(struct bladerf *dev, const char *filename);
// fx3_fw_next_section
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 309
_Bool fx3_fw_next_section(struct fx3_firmware *fw, unsigned int *section_addr, unsigned char **section_data, unsigned int *section_len);
// fx3_fw_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.h line 44
signed int fx3_fw_read(const char *file, struct fx3_firmware **fw_out);
// gain_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.h line 39
signed int gain_set(struct bladerf *dev, enum anonymous module, signed int gain);
// get_and_cache_fpga_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.h line 72
signed int get_and_cache_fpga_size(struct bladerf *device);
// get_and_cache_vctcxo_trim
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.h line 61
signed int get_and_cache_vctcxo_trim(struct bladerf *dev);
// get_binary_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 227
static inline unsigned long int get_binary_dir(char *buf, unsigned long int max_len);
// get_cal_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 147
signed int get_cal_field(struct bladerf *dev, char *field, char *data, unsigned long int data_size);
// get_dc_cal_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3107
static signed int get_dc_cal_value(struct bladerf *dev, unsigned char base, unsigned char dc_addr, signed short int *value);
// get_dc_offset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3542
signed int get_dc_offset(struct bladerf *dev, enum anonymous module, unsigned char addr, signed short int *value);
// get_devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 130
static signed int get_devinfo(struct libusb_device *dev, struct bladerf_devinfo *info);
// get_home_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 204
static inline unsigned long int get_home_dir(char *buf, unsigned long int max_len);
// get_install_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 221
static inline unsigned long int get_install_dir(char *buf, unsigned long int max_len);
// get_iq_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 410
static signed int get_iq_correction(struct bladerf *dev, unsigned char addr, signed short int *value);
// get_libusb_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 324
static inline void get_libusb_version(char *buf, unsigned long int buf_len);
// get_loglevel
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/init_fini.c line 63
static signed int get_loglevel(void);
// get_next_available_transfer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1015
static inline struct libusb_transfer * get_next_available_transfer(struct lusb_stream_data *stream_data);
// get_otp_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 132
signed int get_otp_field(struct bladerf *dev, char *field, char *data, unsigned long int data_size);
// get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 68
static inline unsigned long int get_timestamp();
// get_vctcxo_tamer_mode_unsupported
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1070
static signed int get_vctcxo_tamer_mode_unsupported(struct bladerf *dev, enum anonymous_16 *mode);
// get_vtune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1771
static inline signed int get_vtune(struct bladerf *dev, unsigned char base, unsigned char delay, unsigned char *vtune);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// handle_backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 42
static signed int handle_backend(char *str, struct bladerf_devinfo *d);
// handle_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 64
static signed int handle_device(struct bladerf_devinfo *d, char *value);
// handle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 91
static signed int handle_instance(struct bladerf_devinfo *d, char *value);
// handle_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 109
static signed int handle_serial(struct bladerf_devinfo *d, char *value);
// handle_tx_parameters
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 704
static inline signed int handle_tx_parameters(struct bladerf_metadata *user_meta, struct bladerf_sync *s, struct tx_options *options);
// have_cap
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap(struct bladerf *dev, unsigned long int capability);
// have_cap_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link1(struct bladerf *dev_link1, unsigned long int capability_link1);
// have_cap_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link2(struct bladerf *dev_link2, unsigned long int capability_link2);
// have_cap_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link3(struct bladerf *dev_link3, unsigned long int capability_link3);
// have_cap_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link4(struct bladerf *dev_link4, unsigned long int capability_link4);
// have_cap_link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link5(struct bladerf *dev_link5, unsigned long int capability_link5);
// have_cap_link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link6(struct bladerf *dev_link6, unsigned long int capability_link6);
// have_cap_link7
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link7(struct bladerf *dev_link7, unsigned long int capability_link7);
// i64_max
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 55
static inline signed long int i64_max(signed long int x, signed long int y);
// i64_min
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 45
static inline signed long int i64_min(signed long int x, signed long int y);
// image_type_is_valid
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 124
static _Bool image_type_is_valid(enum anonymous_38 type);
// init_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 194
signed int init_device(struct bladerf *dev);
// interp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 226
static inline unsigned int interp(unsigned int x0, unsigned int y0, unsigned int x1, unsigned int y1, unsigned int x);
// is_loopback_enabled
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 316
static inline signed int is_loopback_enabled(struct bladerf *dev);
// is_page_aligned
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 381
static inline _Bool is_page_aligned(unsigned int val);
// is_valid_addr_len
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 386
static inline _Bool is_valid_addr_len(unsigned int addr, unsigned int len);
// is_valid_fx3_ram_addr
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 72
static inline _Bool is_valid_fx3_ram_addr(unsigned int addr, unsigned int len);
// left_in_msg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 250
static inline unsigned int left_in_msg(struct bladerf_sync *s);
// libusb_alloc_transfer
// file /usr/include/libusb-1.0/libusb.h line 1477
struct libusb_transfer * libusb_alloc_transfer(signed int);
// libusb_bulk_transfer
// file /usr/include/libusb-1.0/libusb.h line 1744
signed int libusb_bulk_transfer(struct libusb_device_handle *, unsigned char, unsigned char *, signed int, signed int *, unsigned int);
// libusb_cancel_transfer
// file /usr/include/libusb-1.0/libusb.h line 1479
signed int libusb_cancel_transfer(struct libusb_transfer *);
// libusb_claim_interface
// file /usr/include/libusb-1.0/libusb.h line 1376
signed int libusb_claim_interface(struct libusb_device_handle *, signed int);
// libusb_close
// file /usr/include/libusb-1.0/libusb.h line 1371
void libusb_close(struct libusb_device_handle *);
// libusb_control_transfer
// file /usr/include/libusb-1.0/libusb.h line 1740
signed int libusb_control_transfer(struct libusb_device_handle *, unsigned char, unsigned char, unsigned short int, unsigned short int, unsigned char *, unsigned short int, unsigned int);
// libusb_error_name
// file /usr/include/libusb-1.0/libusb.h line 1308
const char * libusb_error_name(signed int);
// libusb_exit
// file /usr/include/libusb-1.0/libusb.h line 1304
void libusb_exit(struct libusb_context *);
// libusb_fill_bulk_transfer
// file /usr/include/libusb-1.0/libusb.h line 1545
static inline void libusb_fill_bulk_transfer(struct libusb_transfer *transfer, struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, signed int length, void (*callback)(struct libusb_transfer *), void *user_data, unsigned int timeout);
// libusb_fill_bulk_transfer::callback_object
//
void callback_object(struct libusb_transfer *);
// libusb_free_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1329
void libusb_free_config_descriptor(struct libusb_config_descriptor *);
// libusb_free_device_list
// file /usr/include/libusb-1.0/libusb.h line 1314
void libusb_free_device_list(struct libusb_device **, signed int);
// libusb_free_transfer
// file /usr/include/libusb-1.0/libusb.h line 1480
void libusb_free_transfer(struct libusb_transfer *);
// libusb_get_bus_number
// file /usr/include/libusb-1.0/libusb.h line 1357
unsigned char libusb_get_bus_number(struct libusb_device *);
// libusb_get_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1325
signed int libusb_get_config_descriptor(struct libusb_device *, unsigned char, struct libusb_config_descriptor **);
// libusb_get_device_address
// file /usr/include/libusb-1.0/libusb.h line 1363
unsigned char libusb_get_device_address(struct libusb_device *);
// libusb_get_device_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1321
signed int libusb_get_device_descriptor(struct libusb_device *, struct libusb_device_descriptor *);
// libusb_get_device_list
// file /usr/include/libusb-1.0/libusb.h line 1312
signed long int libusb_get_device_list(struct libusb_context *, struct libusb_device ***);
// libusb_get_device_speed
// file /usr/include/libusb-1.0/libusb.h line 1364
signed int libusb_get_device_speed(struct libusb_device *);
// libusb_get_string_descriptor_ascii
// file /usr/include/libusb-1.0/libusb.h line 1794
signed int libusb_get_string_descriptor_ascii(struct libusb_device_handle *, unsigned char, unsigned char *, signed int);
// libusb_get_version
// file /usr/include/libusb-1.0/libusb.h line 1306
struct libusb_version * libusb_get_version(void);
// libusb_handle_events_timeout
// file /usr/include/libusb-1.0/libusb.h line 1808
signed int libusb_handle_events_timeout(struct libusb_context *, struct timeval *);
// libusb_init
// file /usr/include/libusb-1.0/libusb.h line 1303
signed int libusb_init(struct libusb_context **);
// libusb_open
// file /usr/include/libusb-1.0/libusb.h line 1370
signed int libusb_open(struct libusb_device *, struct libusb_device_handle **);
// libusb_release_interface
// file /usr/include/libusb-1.0/libusb.h line 1378
signed int libusb_release_interface(struct libusb_device_handle *, signed int);
// libusb_reset_device
// file /usr/include/libusb-1.0/libusb.h line 1388
signed int libusb_reset_device(struct libusb_device_handle *);
// libusb_set_interface_alt_setting
// file /usr/include/libusb-1.0/libusb.h line 1384
signed int libusb_set_interface_alt_setting(struct libusb_device_handle *, signed int, signed int);
// libusb_submit_transfer
// file /usr/include/libusb-1.0/libusb.h line 1478
signed int libusb_submit_transfer(struct libusb_transfer *);
// lms_bw2uint
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 169
unsigned int lms_bw2uint(enum anonymous_13 bw);
// lms_calculate_tuning_params
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 618
signed int lms_calculate_tuning_params(unsigned int freq, struct lms_freq *f);
// lms_calibrate_dc
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 669
signed int lms_calibrate_dc(struct bladerf *dev, enum anonymous_0 module);
// lms_clear
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 204
static inline signed int lms_clear(struct bladerf *dev, unsigned char addr, unsigned char mask);
// lms_config_charge_pumps
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 225
signed int lms_config_charge_pumps(struct bladerf *dev, enum anonymous module);
// lms_dc_cal_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2405
static signed int lms_dc_cal_loop(struct bladerf *dev, unsigned char base, unsigned char cal_address, unsigned char dc_cntval, unsigned char *dc_regval);
// lms_dither_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 654
signed int lms_dither_enable(struct bladerf *dev, enum anonymous mod, unsigned char nbits, _Bool enable);
// lms_dump_registers
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2383
signed int lms_dump_registers(struct bladerf *dev);
// lms_enable_rffe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 503
signed int lms_enable_rffe(struct bladerf *dev, enum anonymous module, _Bool enable);
// lms_frequency_to_hz
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 573
unsigned int lms_frequency_to_hz(struct lms_freq *f);
// lms_get_bandwidth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 281
signed int lms_get_bandwidth(struct bladerf *dev, enum anonymous mod, enum anonymous_13 *bw);
// lms_get_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 687
signed int lms_get_dc_cals(struct bladerf *dev, struct bladerf_lms_dc_cals *dc_cals);
// lms_get_dc_offset_i
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 761
signed int lms_get_dc_offset_i(struct bladerf *dev, enum anonymous module, signed short int *value);
// lms_get_dc_offset_q
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 791
signed int lms_get_dc_offset_q(struct bladerf *dev, enum anonymous module, signed short int *value);
// lms_get_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 594
signed int lms_get_frequency(struct bladerf *dev, enum anonymous mod, struct lms_freq *f);
// lms_get_lna
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 774
signed int lms_get_lna(struct bladerf *dev, enum anonymous_2 *lna);
// lms_get_loopback_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 525
signed int lms_get_loopback_mode(struct bladerf *dev, enum anonymous_3 *loopback);
// lms_get_quick_tune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 606
signed int lms_get_quick_tune(struct bladerf *dev, enum anonymous mod, struct bladerf_quick_tune *quick_tune);
// lms_get_sampling
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 732
signed int lms_get_sampling(struct bladerf *dev, enum anonymous_34 *sampling);
// lms_lna_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 328
signed int lms_lna_get_gain(struct bladerf *dev, enum anonymous_12 *gain);
// lms_lna_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 318
signed int lms_lna_set_gain(struct bladerf *dev, enum anonymous_12 gain);
// lms_lpf_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 235
signed int lms_lpf_enable(struct bladerf *dev, enum anonymous mod, _Bool enable);
// lms_lpf_get_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 258
signed int lms_lpf_get_mode(struct bladerf *dev, enum anonymous mod, enum anonymous_14 *mode);
// lms_lpf_set_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 246
signed int lms_lpf_set_mode(struct bladerf *dev, enum anonymous mod, enum anonymous_14 mode);
// lms_peakdetect_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 950
signed int lms_peakdetect_enable(struct bladerf *dev, _Bool enable);
// lms_pll_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1596
signed int lms_pll_enable(struct bladerf *dev, enum anonymous mod, _Bool enable);
// lms_power_down
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1579
signed int lms_power_down(struct bladerf *dev);
// lms_print_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1675
void lms_print_frequency(struct lms_freq *f);
// lms_rx_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1618
signed int lms_rx_enable(struct bladerf *dev, _Bool enable);
// lms_rxvga1_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 794
signed int lms_rxvga1_enable(struct bladerf *dev, _Bool enable);
// lms_rxvga1_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 382
signed int lms_rxvga1_get_gain(struct bladerf *dev, signed int *gain);
// lms_rxvga1_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 372
signed int lms_rxvga1_set_gain(struct bladerf *dev, signed int gain);
// lms_rxvga2_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 852
signed int lms_rxvga2_enable(struct bladerf *dev, _Bool enable);
// lms_rxvga2_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 415
signed int lms_rxvga2_get_gain(struct bladerf *dev, signed int *gain);
// lms_rxvga2_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 405
signed int lms_rxvga2_set_gain(struct bladerf *dev, signed int gain);
// lms_select_band
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2187
signed int lms_select_band(struct bladerf *dev, enum anonymous module, _Bool low_band);
// lms_select_lna
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 757
signed int lms_select_lna(struct bladerf *dev, enum anonymous_2 lna);
// lms_select_pa
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 907
signed int lms_select_pa(struct bladerf *dev, enum anonymous_1 pa);
// lms_select_sampling
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 722
signed int lms_select_sampling(struct bladerf *dev, enum anonymous_34 sampling);
// lms_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 180
static inline signed int lms_set(struct bladerf *dev, unsigned char addr, unsigned char mask);
// lms_set_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 180
static inline signed int lms_set_link1(struct bladerf *dev_link1, unsigned char addr_link1, unsigned char mask_link1);
// lms_set_bandwidth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 270
signed int lms_set_bandwidth(struct bladerf *dev, enum anonymous mod, enum anonymous_13 bw);
// lms_set_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 678
signed int lms_set_dc_cals(struct bladerf *dev, struct bladerf_lms_dc_cals *dc_cals);
// lms_set_dc_offset_i
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 746
signed int lms_set_dc_offset_i(struct bladerf *dev, enum anonymous module, unsigned short int value);
// lms_set_dc_offset_q
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 776
signed int lms_set_dc_offset_q(struct bladerf *dev, enum anonymous module, signed short int value);
// lms_set_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 641
static inline signed int lms_set_frequency(struct bladerf *dev, enum anonymous mod, unsigned int freq);
// lms_set_frequency_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 641
static inline signed int lms_set_frequency_link1(struct bladerf *dev_link1, enum anonymous mod_link1, unsigned int freq_link1);
// lms_set_loopback_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 514
signed int lms_set_loopback_mode(struct bladerf *dev, enum anonymous_3 mode);
// lms_set_precalculated_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 629
signed int lms_set_precalculated_frequency(struct bladerf *dev, enum anonymous mod, struct lms_freq *f);
// lms_soft_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 697
signed int lms_soft_reset(struct bladerf *dev);
// lms_tx_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1639
signed int lms_tx_enable(struct bladerf *dev, _Bool enable);
// lms_txvga1_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 464
signed int lms_txvga1_get_gain(struct bladerf *dev, signed int *gain);
// lms_txvga1_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 452
signed int lms_txvga1_set_gain(struct bladerf *dev, signed int gain_int);
// lms_txvga2_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 439
signed int lms_txvga2_get_gain(struct bladerf *dev, signed int *gain);
// lms_txvga2_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 429
signed int lms_txvga2_set_gain(struct bladerf *dev, signed int gain_int);
// lms_uint2bw
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 160
enum anonymous_13 lms_uint2bw(unsigned int req);
// load_dc_cal
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/config.c line 29
static inline void load_dc_cal(struct bladerf *dev, const char *file);
// log_set_verbosity
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/log.h line 120
void log_set_verbosity(enum anonymous_26 level);
// log_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/log.h line 105
void log_write(enum anonymous_26 level, const char *format, ...);
// logger_entry_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../firmware_common/logger_entry.h line 66
static inline void logger_entry_unpack(unsigned int e, unsigned char *file, unsigned short int *line, unsigned short int *data);
// logger_id_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../firmware_common/logger_id.h line 36
static inline const char * logger_id_string(unsigned char file_id);
// loopback_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1385
static signed int loopback_path(struct bladerf *dev, enum anonymous_3 mode);
// loopback_rx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1205
static signed int loopback_rx(struct bladerf *dev, enum anonymous_3 mode);
// loopback_tx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1156
static signed int loopback_tx(struct bladerf *dev, enum anonymous_3 mode);
// lusb_backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 68
static inline struct bladerf_lusb * lusb_backend(struct bladerf *dev);
// lusb_bulk_transfer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 820
static signed int lusb_bulk_transfer(void *driver, unsigned char endpoint, void *buffer, unsigned int buffer_len, unsigned int timeout_ms);
// lusb_change_setting
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 577
static signed int lusb_change_setting(void *driver, unsigned char setting);
// lusb_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 587
static void lusb_close(void *driver);
// lusb_close_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 603
static void lusb_close_bootloader(void *driver);
// lusb_control_transfer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 793
static signed int lusb_control_transfer(void *driver, enum anonymous_28 target_type, enum anonymous_29 req_type, enum anonymous_30 dir, unsigned char request, unsigned short int wvalue, unsigned short int windex, void *buffer, unsigned int buffer_len, unsigned int timeout_ms);
// lusb_deinit_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1315
static signed int lusb_deinit_stream(void *driver, struct bladerf_stream *stream);
// lusb_get_speed
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 712
static signed int lusb_get_speed(void *driver, enum anonymous_7 *device_speed);
// lusb_get_string_descriptor
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 840
static signed int lusb_get_string_descriptor(void *driver, unsigned char index, void *buffer, unsigned int buffer_len);
// lusb_init_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1107
static signed int lusb_init_stream(void *driver, struct bladerf_stream *stream, unsigned long int num_transfers);
// lusb_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 519
static signed int lusb_open(void **driver, struct bladerf_devinfo *info_in, struct bladerf_devinfo *info_out);
// lusb_open_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 639
static signed int lusb_open_bootloader(void **driver, unsigned char bus, unsigned char addr);
// lusb_probe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 261
static signed int lusb_probe(enum anonymous_15 probe_target, struct bladerf_devinfo_list *info_list);
// lusb_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1185
static signed int lusb_stream(void *driver, struct bladerf_stream *stream, enum anonymous module);
// lusb_stream_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 899
static void lusb_stream_cb(struct libusb_transfer *transfer);
// lusb_submit_stream_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1259
signed int lusb_submit_stream_buffer(void *driver, struct bladerf_stream *stream, void *buffer, unsigned int timeout_ms, _Bool nonblock);
// make_cal_region
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 449
static signed int make_cal_region(enum anonymous_5 size, unsigned short int vctcxo_trim, unsigned char *buf, unsigned long int len);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// metadata_get_flags
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/metadata.h line 103
static inline unsigned int metadata_get_flags(const unsigned char *header);
// metadata_get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/metadata.h line 92
static inline unsigned long int metadata_get_timestamp(const unsigned char *header);
// metadata_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/metadata.h line 111
static inline void metadata_set(unsigned char *header, unsigned long int timestamp, unsigned int flags);
// min_sz
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 15
static inline unsigned long int min_sz(unsigned long int x, unsigned long int y);
// module2str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/conversions.h line 225
const char * module2str(enum anonymous m);
// msg_per_buf
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 42
static inline unsigned int msg_per_buf(struct bladerf *dev, unsigned long int buf_size, unsigned long int bytes_per_sample);
// next_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 155
static signed int next_arg(char **saveptr, char **arg, char **value);
// nios_32x32_masked_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 241
static signed int nios_32x32_masked_read(struct bladerf *dev, unsigned char id, unsigned int mask, unsigned int *val);
// nios_32x32_masked_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 267
static signed int nios_32x32_masked_write(struct bladerf *dev, unsigned char id, unsigned int mask, unsigned int val);
// nios_8x16_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 141
signed int nios_8x16_read(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned short int *data);
// nios_8x16_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 168
signed int nios_8x16_write(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned short int data);
// nios_8x32_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 192
signed int nios_8x32_read(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned int *data);
// nios_8x32_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 217
signed int nios_8x32_write(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned int data);
// nios_8x8_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 94
signed int nios_8x8_read(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned char *data);
// nios_8x8_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 118
signed int nios_8x8_write(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned char data);
// nios_access
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 61
static signed int nios_access(struct bladerf *dev, unsigned char *buf);
// nios_access_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 70
static signed int nios_access_link1(struct bladerf *dev_link1, unsigned char peripheral, enum anonymous_30 dir, struct uart_cmd *cmd, unsigned long int len);
// nios_config_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 293
signed int nios_config_read(struct bladerf *dev, unsigned int *val);
// nios_config_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 304
signed int nios_config_write(struct bladerf *dev, unsigned int val);
// nios_expansion_gpio_dir_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 685
signed int nios_expansion_gpio_dir_read(struct bladerf *dev, unsigned int *val);
// nios_expansion_gpio_dir_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 697
signed int nios_expansion_gpio_dir_write(struct bladerf *dev, unsigned int mask, unsigned int val);
// nios_expansion_gpio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 660
signed int nios_expansion_gpio_read(struct bladerf *dev, unsigned int *val);
// nios_expansion_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 672
signed int nios_expansion_gpio_write(struct bladerf *dev, unsigned int mask, unsigned int val);
// nios_get_fpga_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 315
signed int nios_get_fpga_version(struct bladerf *dev, struct bladerf_version *ver);
// nios_get_iq_gain_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 526
signed int nios_get_iq_gain_correction(struct bladerf *dev, enum anonymous module, signed short int *value);
// nios_get_iq_phase_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 557
signed int nios_get_iq_phase_correction(struct bladerf *dev, enum anonymous module, signed short int *value);
// nios_get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 337
signed int nios_get_timestamp(struct bladerf *dev, enum anonymous module, unsigned long int *timestamp);
// nios_get_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 491
signed int nios_get_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 *mode);
// nios_legacy_config_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 179
signed int nios_legacy_config_read(struct bladerf *dev, unsigned int *val);
// nios_legacy_config_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 191
signed int nios_legacy_config_write(struct bladerf *dev, unsigned int val);
// nios_legacy_expansion_gpio_dir_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 589
signed int nios_legacy_expansion_gpio_dir_read(struct bladerf *dev, unsigned int *val);
// nios_legacy_expansion_gpio_dir_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 601
signed int nios_legacy_expansion_gpio_dir_write(struct bladerf *dev, unsigned int mask, unsigned int val);
// nios_legacy_expansion_gpio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 557
signed int nios_legacy_expansion_gpio_read(struct bladerf *dev, unsigned int *val);
// nios_legacy_expansion_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 568
signed int nios_legacy_expansion_gpio_write(struct bladerf *dev, unsigned int mask, unsigned int val);
// nios_legacy_get_fpga_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 197
signed int nios_legacy_get_fpga_version(struct bladerf *dev, struct bladerf_version *ver);
// nios_legacy_get_iq_gain_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 447
signed int nios_legacy_get_iq_gain_correction(struct bladerf *dev, enum anonymous module, signed short int *value);
// nios_legacy_get_iq_phase_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 474
signed int nios_legacy_get_iq_phase_correction(struct bladerf *dev, enum anonymous module, signed short int *value);
// nios_legacy_get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 242
signed int nios_legacy_get_timestamp(struct bladerf *dev, enum anonymous mod, unsigned long int *value);
// nios_legacy_get_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 402
signed int nios_legacy_get_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 *mode);
// nios_legacy_lms6_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 326
signed int nios_legacy_lms6_read(struct bladerf *dev, unsigned char addr, unsigned char *data);
// nios_legacy_lms6_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 345
signed int nios_legacy_lms6_write(struct bladerf *dev, unsigned char addr, unsigned char data);
// nios_legacy_pio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 130
signed int nios_legacy_pio_read(struct bladerf *dev, unsigned char addr, unsigned int *data);
// nios_legacy_pio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 157
signed int nios_legacy_pio_write(struct bladerf *dev, unsigned char addr, unsigned int data);
// nios_legacy_set_iq_gain_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 498
signed int nios_legacy_set_iq_gain_correction(struct bladerf *dev, enum anonymous module, signed short int value);
// nios_legacy_set_iq_phase_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 524
signed int nios_legacy_set_iq_phase_correction(struct bladerf *dev, enum anonymous module, signed short int value);
// nios_legacy_set_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 395
signed int nios_legacy_set_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 mode);
// nios_legacy_si5338_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 294
signed int nios_legacy_si5338_read(struct bladerf *dev, unsigned char addr, unsigned char *data);
// nios_legacy_si5338_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 313
signed int nios_legacy_si5338_write(struct bladerf *dev, unsigned char addr, unsigned char data);
// nios_legacy_vctcxo_trim_dac_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 361
signed int nios_legacy_vctcxo_trim_dac_write(struct bladerf *dev, unsigned short int value);
// nios_legacy_xb200_synth_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 550
signed int nios_legacy_xb200_synth_write(struct bladerf *dev, unsigned int value);
// nios_lms6_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 403
signed int nios_lms6_read(struct bladerf *dev, unsigned char addr, unsigned char *data);
// nios_lms6_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 415
signed int nios_lms6_write(struct bladerf *dev, unsigned char addr, unsigned char data);
// nios_pkt_32x32_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_32x32.h line 120
static inline void nios_pkt_32x32_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned int addr, unsigned int data);
// nios_pkt_32x32_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_32x32.h line 192
static inline void nios_pkt_32x32_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned int *addr, unsigned int *data, _Bool *success);
// nios_pkt_32x32_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_32x32.h line 151
static inline void nios_pkt_32x32_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned int *addr, unsigned int *data);
// nios_pkt_8x16_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x16.h line 122
static inline void nios_pkt_8x16_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned char addr, unsigned short int data);
// nios_pkt_8x16_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x16.h line 188
static inline void nios_pkt_8x16_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned short int *data, _Bool *success);
// nios_pkt_8x16_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x16.h line 153
static inline void nios_pkt_8x16_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned short int *data);
// nios_pkt_8x32_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x32.h line 118
static inline void nios_pkt_8x32_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned char addr, unsigned int data);
// nios_pkt_8x32_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x32.h line 186
static inline void nios_pkt_8x32_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned int *data, _Bool *success);
// nios_pkt_8x32_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x32.h line 149
static inline void nios_pkt_8x32_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned int *data);
// nios_pkt_8x64_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x64.h line 120
static inline void nios_pkt_8x64_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned char addr, unsigned long int data);
// nios_pkt_8x64_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x64.h line 192
static inline void nios_pkt_8x64_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned long int *data, _Bool *success);
// nios_pkt_8x64_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x64.h line 151
static inline void nios_pkt_8x64_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned long int *data);
// nios_pkt_8x8_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x8.h line 118
static inline void nios_pkt_8x8_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned char addr, unsigned char data);
// nios_pkt_8x8_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x8.h line 182
static inline void nios_pkt_8x8_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned char *data, _Bool *success);
// nios_pkt_8x8_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x8.h line 148
static inline void nios_pkt_8x8_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned char *data);
// nios_pkt_retune_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_retune.h line 125
static inline void nios_pkt_retune_pack(unsigned char *buf, enum anonymous module, unsigned long int timestamp, unsigned short int nint, unsigned int nfrac, unsigned char freqsel, unsigned char vcocap, _Bool low_band, _Bool quick_tune);
// nios_pkt_retune_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_retune.h line 312
static inline void nios_pkt_retune_resp_unpack(const unsigned char *buf, unsigned long int *duration, unsigned char *vcocap, unsigned char *flags);
// nios_retune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 711
signed int nios_retune(struct bladerf *dev, enum anonymous module, unsigned long int timestamp, unsigned short int nint, unsigned int nfrac, unsigned char freqsel, unsigned char vcocap, _Bool low_band, _Bool quick_tune);
// nios_set_iq_gain_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 588
signed int nios_set_iq_gain_correction(struct bladerf *dev, enum anonymous module, signed short int value);
// nios_set_iq_phase_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 618
signed int nios_set_iq_phase_correction(struct bladerf *dev, enum anonymous module, signed short int value);
// nios_set_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 467
signed int nios_set_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 mode);
// nios_si5338_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 379
signed int nios_si5338_read(struct bladerf *dev, unsigned char addr, unsigned char *data);
// nios_si5338_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 391
signed int nios_si5338_write(struct bladerf *dev, unsigned char addr, unsigned char data);
// nios_vctcxo_trim_dac_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 444
signed int nios_vctcxo_trim_dac_read(struct bladerf *dev, unsigned short int *value);
// nios_vctcxo_trim_dac_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 427
signed int nios_vctcxo_trim_dac_write(struct bladerf *dev, unsigned short int value);
// nios_xb200_synth_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 649
signed int nios_xb200_synth_write(struct bladerf *dev, unsigned int value);
// open_bladerf_from_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/doc/examples/open_via_serial.c line 36
struct bladerf * open_bladerf_from_serial(const char *serial);
// open_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 340
static signed int open_device(struct bladerf_devinfo *info, struct libusb_context *context, struct libusb_device *libusb_dev_in, struct bladerf_lusb **dev_out);
// open_with_any_backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 29
signed int open_with_any_backend(struct bladerf *device, struct bladerf_devinfo *info);
// pack_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 143
static unsigned long int pack_image(struct bladerf_image *img, unsigned char *buf);
// perform_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 468
static inline signed int perform_erase(struct bladerf *dev, unsigned short int block);
// perform_format_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 237
signed int perform_format_config(struct bladerf *dev, enum anonymous module, enum anonymous_9 format);
// perform_format_deconfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 249
signed int perform_format_deconfig(struct bladerf *dev, enum anonymous module);
// populate_abs_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 204
signed int populate_abs_timeout(struct timespec *t, unsigned int timeout_ms);
// populate_fw_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 260
static inline signed int populate_fw_version(struct bladerf_usb *usb, struct bladerf_version *version);
// post_fpga_load_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 156
static signed int post_fpga_load_init(struct bladerf *dev);
// print_device_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/doc/examples/open_via_serial.c line 67
static signed int print_device_state(struct bladerf *dev);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// probe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 53
static signed int probe(enum anonymous_15 target_device, struct bladerf_devinfo **devices);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_18 *, const union anonymous_27 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_18 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_18 *, union anonymous_4 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_18 *, union anonymous_4 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_4 *, const union anonymous_27 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_4 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_4 *);
// read_page
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 518
static inline signed int read_page(struct bladerf *dev, unsigned char read_operation, unsigned short int page, unsigned char *buf);
// read_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 160
signed int read_serial(struct bladerf *dev, char *serial_buf);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// required_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 136
static inline void required_values(struct compat *entry, unsigned int *major, unsigned int *minor, unsigned int *patch);
// requires_timestamps
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 317
static inline signed int requires_timestamps(enum anonymous_9 format, _Bool *required);
// reset_and_reopen
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 476
static signed int reset_and_reopen(struct libusb_context *context, struct bladerf_lusb **dev, struct bladerf_devinfo *info);
// restore_post_flash_setting
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 196
static signed int restore_post_flash_setting(struct bladerf *dev);
// rx_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 41
static void * rx_callback(struct bladerf *dev, struct bladerf_stream *stream, struct bladerf_metadata *meta, void *samples, unsigned long int num_samples, void *user_data);
// samples2bytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 38
static inline unsigned long int samples2bytes(struct bladerf_sync *s, unsigned long int n);
// samples_per_msg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 50
static inline unsigned int samples_per_msg(struct bladerf *dev, unsigned long int bytes_per_sample);
// samples_to_bytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 163
static inline unsigned long int samples_to_bytes(enum anonymous_9 format, unsigned long int n);
// sc16q11_to_bytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 155
static inline unsigned long int sc16q11_to_bytes(unsigned long int n_samples);
// sc16q11_to_bytes_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 155
static inline unsigned long int sc16q11_to_bytes_link1(unsigned long int n_samples_link1);
// sc16q11_to_float
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 617
void sc16q11_to_float(const signed short int *in, float *out, unsigned int n);
// scale_dc_offset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3436
static inline unsigned char scale_dc_offset(enum anonymous module, signed short int value);
// scan_fw_sections
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 115
static signed int scan_fw_sections(struct fx3_firmware *fw);
// set_dc_cal_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3065
static signed int set_dc_cal_value(struct bladerf *dev, unsigned char base, unsigned char dc_addr, signed short int value);
// set_dc_offset_reg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3492
static signed int set_dc_offset_reg(struct bladerf *dev, enum anonymous module, unsigned char addr, signed short int value);
// set_filterbank_mux
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.c line 304
static signed int set_filterbank_mux(struct bladerf *dev, enum anonymous module, enum anonymous_8 filter);
// set_iq_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 429
static signed int set_iq_correction(struct bladerf *dev, unsigned char addr, signed short int value);
// set_rx_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.c line 42
static signed int set_rx_gain(struct bladerf *dev, signed int gain);
// set_rx_gain_combo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.c line 24
static inline signed int set_rx_gain_combo(struct bladerf *dev, enum anonymous_12 lnagain, signed int rxvga1, signed int rxvga2);
// set_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 369
static void set_state(struct sync_worker *w, enum anonymous_23 state);
// set_tx_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.c line 84
static signed int set_tx_gain(struct bladerf *dev, signed int gain);
// set_tx_gain_combo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.c line 72
static inline signed int set_tx_gain_combo(struct bladerf *dev, signed int txvga1, signed int txvga2);
// set_vctcxo_tamer_mode_unsupported
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1063
static signed int set_vctcxo_tamer_mode_unsupported(struct bladerf *dev, enum anonymous_16 mode);
// sha256_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 84
static void sha256_buffer(const char *buf, unsigned long int len, char *digest);
// si5338_calculate_ms_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 326
static void si5338_calculate_ms_freq(struct si5338_multisynth *ms, struct bladerf_rational_rate *rate);
// si5338_calculate_multisynth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 352
static signed int si5338_calculate_multisynth(struct si5338_multisynth *ms, struct bladerf_rational_rate *rate);
// si5338_gcd
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 85
static unsigned long int si5338_gcd(unsigned long int a, unsigned long int b);
// si5338_get_rational_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 41
signed int si5338_get_rational_sample_rate(struct bladerf *dev, enum anonymous module, struct bladerf_rational_rate *rate);
// si5338_get_rational_smb_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 45
signed int si5338_get_rational_smb_freq(struct bladerf *dev, struct bladerf_rational_rate *rate);
// si5338_get_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 39
signed int si5338_get_sample_rate(struct bladerf *dev, enum anonymous module, unsigned int *rate);
// si5338_get_smb_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 43
signed int si5338_get_smb_freq(struct bladerf *dev, unsigned int *rate);
// si5338_pack_regs
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 181
static void si5338_pack_regs(struct si5338_multisynth *ms);
// si5338_rational_double
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 117
static void si5338_rational_double(struct bladerf_rational_rate *r);
// si5338_rational_reduce
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 96
static void si5338_rational_reduce(struct bladerf_rational_rate *r);
// si5338_read_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 73
void si5338_read_error(signed int error, const char *s);
// si5338_read_multisynth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 282
static signed int si5338_read_multisynth(struct bladerf *dev, struct si5338_multisynth *ms);
// si5338_set_rational_multisynth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 477
signed int si5338_set_rational_multisynth(struct bladerf *dev, unsigned char index, unsigned char channel, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual_ret);
// si5338_set_rational_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 40
signed int si5338_set_rational_sample_rate(struct bladerf *dev, enum anonymous module, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual);
// si5338_set_rational_smb_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 44
signed int si5338_set_rational_smb_freq(struct bladerf *dev, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual);
// si5338_set_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 38
signed int si5338_set_sample_rate(struct bladerf *dev, enum anonymous module, unsigned int rate, unsigned int *actual);
// si5338_set_smb_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 42
signed int si5338_set_smb_freq(struct bladerf *dev, unsigned int rate, unsigned int *actual);
// si5338_unpack_regs
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 143
static void si5338_unpack_regs(struct si5338_multisynth *ms);
// si5338_update_base
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 128
static void si5338_update_base(struct si5338_multisynth *ms);
// si5338_write_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 79
void si5338_write_error(signed int error, const char *s);
// si5338_write_multisynth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 228
static signed int si5338_write_multisynth(struct bladerf *dev, struct si5338_multisynth *ms);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// str2args
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 420
signed int str2args(const char *line, char comment_char, char ***argv_ret);
// str2backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 148
signed int str2backend(const char *str, enum anonymous_11 *backend);
// str2dbl_suffix
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 163
double str2dbl_suffix(const char *str, double min, double max, struct numeric_suffix *suffixes, unsigned long int num_suffixes, _Bool *ok);
// str2devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.h line 41
signed int str2devinfo(const char *dev_id_const, struct bladerf_devinfo *d);
// str2double
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 118
double str2double(const char *str, double min, double max, _Bool *ok);
// str2int
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 43
signed int str2int(const char *str, signed int min, signed int max, _Bool *ok);
// str2lnagain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 572
signed int str2lnagain(const char *str, enum anonymous_12 *gain);
// str2loglevel
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/conversions.h line 215
enum anonymous_26 str2loglevel(const char *str, _Bool *ok);
// str2loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 393
signed int str2loopback(const char *str, enum anonymous_3 *loopback);
// str2module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 382
enum anonymous str2module(const char *str);
// str2uint
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/conversions.h line 75
unsigned int str2uint(const char *str, unsigned int min, unsigned int max, _Bool *ok);
// str2uint64
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 93
unsigned long int str2uint64(const char *str, unsigned long int min, unsigned long int max, _Bool *ok);
// str2uint64_suffix
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 231
unsigned long int str2uint64_suffix(const char *str, unsigned long int min, unsigned long int max, struct numeric_suffix *suffixes, unsigned long int num_suffixes, _Bool *ok);
// str2uint_suffix
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 222
unsigned int str2uint_suffix(const char *str, unsigned int min, unsigned int max, struct numeric_suffix *suffixes, unsigned long int num_suffixes, _Bool *ok);
// str2version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 240
signed int str2version(const char *str, struct bladerf_version *version);
// str_to_bladerf_cal_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 637
enum anonymous_0 str_to_bladerf_cal_module(const char *str);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strip_last_path_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 163
static unsigned long int strip_last_path_entry(char *buf, char dir_delim);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// submit_transfer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1042
static signed int submit_transfer(struct bladerf_stream *stream, void *buffer);
// sync_buf2idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 1095
unsigned int sync_buf2idx(struct buffer_mgmt *b, void *addr);
// sync_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 166
void sync_deinit(struct bladerf_sync *sync);
// sync_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 152
signed int sync_init(struct bladerf *dev, enum anonymous module, enum anonymous_9 format, unsigned int num_buffers, unsigned int buffer_size, unsigned int num_transfers, unsigned int stream_timeout);
// sync_rx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 169
signed int sync_rx(struct bladerf *dev, void *samples, unsigned int num_samples, struct bladerf_metadata *user_meta, unsigned int timeout_ms);
// sync_tx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 172
signed int sync_tx(struct bladerf *dev, void *samples, unsigned int num_samples, struct bladerf_metadata *user_meta, unsigned int timeout_ms);
// sync_worker_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 91
void sync_worker_deinit(struct sync_worker *w, union anonymous_4 *lock, union anonymous_18 *cond);
// sync_worker_get_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 119
enum anonymous_23 sync_worker_get_state(struct sync_worker *w, signed int *err_code);
// sync_worker_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 80
signed int sync_worker_init(struct bladerf_sync *s);
// sync_worker_submit_request
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 128
void sync_worker_submit_request(struct sync_worker *w, unsigned int request);
// sync_worker_task
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 466
void * sync_worker_task(void *arg);
// sync_worker_wait_for_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 105
signed int sync_worker_wait_for_state(struct sync_worker *w, enum anonymous_23 state, unsigned int timeout_ms);
// timestamp_in_past
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 686
static inline _Bool timestamp_in_past(struct bladerf_metadata *user_meta, struct bladerf_sync *s);
// timestamp_to_msg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 266
static inline unsigned int timestamp_to_msg(struct bladerf_sync *s, unsigned long int t);
// to_uint32
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 61
static inline unsigned int to_uint32(struct fx3_firmware *fw, unsigned int offset);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// transfer_idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 884
static inline unsigned long int transfer_idx(struct lusb_stream_data *stream_data, struct libusb_transfer *transfer);
// tune_vcocap
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2031
static signed int tune_vcocap(struct bladerf *dev, unsigned char vcocap_est, unsigned char base, unsigned char vcocap_reg_state, unsigned char *vcocap_result);
// tuning_cancel_scheduled
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 87
static inline signed int tuning_cancel_scheduled(struct bladerf *dev, enum anonymous module);
// tuning_get_default_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 115
enum anonymous_10 tuning_get_default_mode(struct bladerf *dev);
// tuning_get_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 104
signed int tuning_get_freq(struct bladerf *dev, enum anonymous module, unsigned int *frequency);
// tuning_schedule
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 70
static inline signed int tuning_schedule(struct bladerf *dev, enum anonymous module, unsigned long int timestamp, struct lms_freq *f);
// tuning_schedule_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 70
static inline signed int tuning_schedule_link1(struct bladerf *dev_link1, enum anonymous module_link1, unsigned long int timestamp_link1, struct lms_freq *f_link1);
// tuning_set_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 54
signed int tuning_set_freq(struct bladerf *dev, enum anonymous module, unsigned int frequency);
// tuning_set_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 126
signed int tuning_set_mode(struct bladerf *dev, enum anonymous_10 mode);
// tx_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 114
static void * tx_callback(struct bladerf *dev, struct bladerf_stream *stream, struct bladerf_metadata *meta, void *samples, unsigned long int num_samples, void *user_data);
// u32_min
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 35
static inline unsigned int u32_min(unsigned int x, unsigned int y);
// uint_min
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 25
static inline unsigned int uint_min(unsigned int x, unsigned int y);
// unpack_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 201
static signed int unpack_image(struct bladerf_image *img, unsigned char *buf, unsigned long int len);
// usb_backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 150
static inline struct bladerf_usb * usb_backend(struct bladerf *dev, void **driver);
// usb_backend_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 150
static inline struct bladerf_usb * usb_backend_link1(struct bladerf *dev_link1, void **driver_link1);
// usb_backend_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 150
static inline struct bladerf_usb * usb_backend_link2(struct bladerf *dev_link2, void **driver_link2);
// usb_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 238
static void usb_close(struct bladerf *dev);
// usb_deinit_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 891
static void usb_deinit_stream(struct bladerf_stream *stream);
// usb_device_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 731
static signed int usb_device_reset(struct bladerf *dev);
// usb_enable_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 831
static signed int usb_enable_module(struct bladerf *dev, enum anonymous m, _Bool enable);
// usb_erase_flash_blocks
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 487
static signed int usb_erase_flash_blocks(struct bladerf *dev, unsigned int eb, unsigned short int count);
// usb_get_cal
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 756
static signed int usb_get_cal(struct bladerf *dev, char *cal);
// usb_get_device_speed
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 790
static signed int usb_get_device_speed(struct bladerf *dev, enum anonymous_7 *speed);
// usb_get_firmware_loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 817
static signed int usb_get_firmware_loopback(struct bladerf *dev, _Bool *is_enabled);
// usb_get_otp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 775
static signed int usb_get_otp(struct bladerf *dev, char *otp);
// usb_init_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 868
static signed int usb_init_stream(struct bladerf_stream *stream, unsigned long int num_transfers);
// usb_is_fpga_configured
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 122
static signed int usb_is_fpga_configured(struct bladerf *dev);
// usb_jump_to_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 744
static signed int usb_jump_to_bootloader(struct bladerf *dev);
// usb_load_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 406
static signed int usb_load_fpga(struct bladerf *dev, unsigned char *image, unsigned long int image_size);
// usb_load_fw_from_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1035
static signed int usb_load_fw_from_bootloader(enum anonymous_11 backend, unsigned char bus, unsigned char addr, struct fx3_firmware *fw);
// usb_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 217
static _Bool usb_matches(enum anonymous_11 backend);
// usb_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 281
static signed int usb_open(struct bladerf *dev, struct bladerf_devinfo *info);
// usb_probe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 225
static signed int usb_probe(enum anonymous_15 probe_target, struct bladerf_devinfo_list *info_list);
// usb_read_flash_pages
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 583
static signed int usb_read_flash_pages(struct bladerf *dev, unsigned char *buf, unsigned int page_u32, unsigned int count_u32);
// usb_read_fw_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1078
static signed int usb_read_fw_log(struct bladerf *dev, unsigned int *e);
// usb_set_firmware_loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 798
static signed int usb_set_firmware_loopback(struct bladerf *dev, _Bool enable);
// usb_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 875
static signed int usb_stream(struct bladerf_stream *stream, enum anonymous module);
// usb_submit_stream_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 882
signed int usb_submit_stream_buffer(struct bladerf_stream *stream, void *buffer, unsigned int timeout_ms, _Bool nonblock);
// usb_write_flash_pages
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 684
static signed int usb_write_flash_pages(struct bladerf *dev, const unsigned char *buf, unsigned int page_u32, unsigned int count_u32);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// valid_fpga_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fpga.c line 73
static inline _Bool valid_fpga_size(unsigned long int len);
// valid_fw_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1250
static inline _Bool valid_fw_size(unsigned long int len);
// vendor_cmd_int
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 92
static inline signed int vendor_cmd_int(struct bladerf *dev, unsigned char cmd, enum anonymous_30 dir, signed int *val);
// vendor_cmd_int_windex
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 59
static inline signed int vendor_cmd_int_windex(struct bladerf *dev, unsigned char cmd, unsigned short int windex, signed int *val);
// vendor_cmd_int_wvalue
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 75
static inline signed int vendor_cmd_int_wvalue(struct bladerf *dev, unsigned char cmd, unsigned short int wvalue, signed int *val);
// verify_checksum
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 94
static signed int verify_checksum(unsigned char *buf, unsigned long int buf_len);
// verify_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 103
static inline signed int verify_flash(struct bladerf *dev, unsigned char *readback_buf, unsigned char *image, unsigned int page, unsigned int count);
// version_check_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 70
signed int version_check_fpga(struct bladerf *dev);
// version_check_fw
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 38
signed int version_check_fw(struct bladerf *dev);
// version_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 226
_Bool version_equal(struct bladerf_version *v1, struct bladerf_version *v2);
// version_greater_or_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 100
_Bool version_greater_or_equal(struct bladerf_version *version, unsigned int major, unsigned int minor, unsigned int patch);
// version_less_than
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 251
_Bool version_less_than(struct bladerf_version *version, unsigned int major, unsigned int minor, unsigned int patch);
// version_required_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 79
void version_required_fpga(struct bladerf *dev, struct bladerf_version *version);
// version_required_fw
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 53
void version_required_fw(struct bladerf *dev, struct bladerf_version *version, _Bool by_fpga);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vtune_high_to_norm
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1829
static signed int vtune_high_to_norm(struct bladerf *dev, unsigned char base, unsigned char vcocap, unsigned char vcocap_reg_state, unsigned char *vtune_high_limit);
// vtune_low_to_norm
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1908
static signed int vtune_low_to_norm(struct bladerf *dev, unsigned char base, unsigned char vcocap, unsigned char vcocap_reg_state, unsigned char *vtune_low_limit);
// vtune_norm_to_high
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1869
static signed int vtune_norm_to_high(struct bladerf *dev, unsigned char base, unsigned char vcocap, unsigned char vcocap_reg_state, unsigned char *vtune_high_limit);
// vtune_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1812
static const char * vtune_str(unsigned char value);
// wait_for_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 219
static signed int wait_for_buffer(struct buffer_mgmt *b, unsigned int timeout_ms, const char *dbg_name, unsigned int dbg_idx);
// wait_for_vtune_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1949
static signed int wait_for_vtune_value(struct bladerf *dev, unsigned char base, unsigned char target_value, unsigned char *vcocap, unsigned char vcocap_reg_state);
// write_and_verify_fw_chunk
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 914
static signed int write_and_verify_fw_chunk(struct bladerf_usb *usb, unsigned int addr, unsigned char *data, unsigned int len, unsigned char *readback_buf);
// write_fw_to_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 992
static signed int write_fw_to_bootloader(void *driver, struct fx3_firmware *fw);
// write_page
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 624
static signed int write_page(struct bladerf *dev, unsigned short int page, const unsigned char *buf);
// write_pll_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 362
static signed int write_pll_config(struct bladerf *dev, enum anonymous module, unsigned char freqsel, _Bool low_band);
// write_vcocap
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1786
static inline signed int write_vcocap(struct bladerf *dev, unsigned char base, unsigned char vcocap, unsigned char vcocap_reg_state);
// xb200_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.c line 65
static signed int xb200_attach(struct bladerf *dev);
// xb200_auto_filter_selection
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 88
signed int xb200_auto_filter_selection(struct bladerf *dev, enum anonymous mod, unsigned int frequency);
// xb200_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.c line 136
signed int xb200_enable(struct bladerf *dev, _Bool enable);
// xb200_get_filterbank
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 101
signed int xb200_get_filterbank(struct bladerf *dev, enum anonymous module, enum anonymous_8 *filter);
// xb200_get_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 126
signed int xb200_get_path(struct bladerf *dev, enum anonymous module, enum anonymous_35 *path);
// xb200_set_filterbank
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 75
signed int xb200_set_filterbank(struct bladerf *dev, enum anonymous module, enum anonymous_8 filter);
// xb200_set_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 113
signed int xb200_set_path(struct bladerf *dev, enum anonymous module, enum anonymous_35 path);
// xb_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 54
signed int xb_attach(struct bladerf *dev, enum anonymous_6 xb);
// xb_get_attached
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 64
signed int xb_get_attached(struct bladerf *dev, enum anonymous_6 *xb);
// zero_argvs
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 297
static void zero_argvs(signed int start, signed int end, char **argv);

struct anonymous_32
{
  // in_burst
  _Bool in_burst;
  // now
  _Bool now;
};

struct anonymous_17
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_31
{
  // msg_timestamp
  unsigned long int msg_timestamp;
  // msg_flags
  unsigned int msg_flags;
};

union anonymous_27
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_18
{
  // __data
  struct anonymous_17 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_25
{
  // _anon0
  struct anonymous_31 _anon0;
  // _anon1
  struct anonymous_32 _anon1;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_4
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct SHA256Context
{
  // state
  unsigned int state[8l];
  // count
  unsigned int count[2l];
  // buf
  unsigned char buf[64l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct backend_fns
{
  // matches
  _Bool (*matches)(enum anonymous_11);
  // probe
  signed int (*probe)(enum anonymous_15, struct bladerf_devinfo_list *);
  // open
  signed int (*open)(struct bladerf *, struct bladerf_devinfo *);
  // close
  void (*close)(struct bladerf *);
  // load_fpga
  signed int (*load_fpga)(struct bladerf *, unsigned char *, unsigned long int);
  // is_fpga_configured
  signed int (*is_fpga_configured)(struct bladerf *);
  // erase_flash_blocks
  signed int (*erase_flash_blocks)(struct bladerf *, unsigned int, unsigned short int);
  // read_flash_pages
  signed int (*read_flash_pages)(struct bladerf *, unsigned char *, unsigned int, unsigned int);
  // write_flash_pages
  signed int (*write_flash_pages)(struct bladerf *, const unsigned char *, unsigned int, unsigned int);
  // device_reset
  signed int (*device_reset)(struct bladerf *);
  // jump_to_bootloader
  signed int (*jump_to_bootloader)(struct bladerf *);
  // get_cal
  signed int (*get_cal)(struct bladerf *, char *);
  // get_otp
  signed int (*get_otp)(struct bladerf *, char *);
  // get_device_speed
  signed int (*get_device_speed)(struct bladerf *, enum anonymous_7 *);
  // config_gpio_write
  signed int (*config_gpio_write)(struct bladerf *, unsigned int);
  // config_gpio_read
  signed int (*config_gpio_read)(struct bladerf *, unsigned int *);
  // expansion_gpio_write
  signed int (*expansion_gpio_write)(struct bladerf *, unsigned int, unsigned int);
  // expansion_gpio_read
  signed int (*expansion_gpio_read)(struct bladerf *, unsigned int *);
  // expansion_gpio_dir_write
  signed int (*expansion_gpio_dir_write)(struct bladerf *, unsigned int, unsigned int);
  // expansion_gpio_dir_read
  signed int (*expansion_gpio_dir_read)(struct bladerf *, unsigned int *);
  // set_iq_gain_correction
  signed int (*set_iq_gain_correction)(struct bladerf *, enum anonymous, signed short int);
  // set_iq_phase_correction
  signed int (*set_iq_phase_correction)(struct bladerf *, enum anonymous, signed short int);
  // get_iq_gain_correction
  signed int (*get_iq_gain_correction)(struct bladerf *, enum anonymous, signed short int *);
  // get_iq_phase_correction
  signed int (*get_iq_phase_correction)(struct bladerf *, enum anonymous, signed short int *);
  // get_timestamp
  signed int (*get_timestamp)(struct bladerf *, enum anonymous, unsigned long int *);
  // si5338_write
  signed int (*si5338_write)(struct bladerf *, unsigned char, unsigned char);
  // si5338_read
  signed int (*si5338_read)(struct bladerf *, unsigned char, unsigned char *);
  // lms_write
  signed int (*lms_write)(struct bladerf *, unsigned char, unsigned char);
  // lms_read
  signed int (*lms_read)(struct bladerf *, unsigned char, unsigned char *);
  // vctcxo_dac_write
  signed int (*vctcxo_dac_write)(struct bladerf *, unsigned short int);
  // vctcxo_dac_read
  signed int (*vctcxo_dac_read)(struct bladerf *, unsigned short int *);
  // set_vctcxo_tamer_mode
  signed int (*set_vctcxo_tamer_mode)(struct bladerf *, enum anonymous_16);
  // get_vctcxo_tamer_mode
  signed int (*get_vctcxo_tamer_mode)(struct bladerf *, enum anonymous_16 *);
  // xb_spi
  signed int (*xb_spi)(struct bladerf *, unsigned int);
  // set_firmware_loopback
  signed int (*set_firmware_loopback)(struct bladerf *, _Bool);
  // get_firmware_loopback
  signed int (*get_firmware_loopback)(struct bladerf *, _Bool *);
  // enable_module
  signed int (*enable_module)(struct bladerf *, enum anonymous, _Bool);
  // init_stream
  signed int (*init_stream)(struct bladerf_stream *, unsigned long int);
  // stream
  signed int (*stream)(struct bladerf_stream *, enum anonymous);
  // submit_stream_buffer
  signed int (*submit_stream_buffer)(struct bladerf_stream *, void *, unsigned int, _Bool);
  // deinit_stream
  void (*deinit_stream)(struct bladerf_stream *);
  // retune
  signed int (*retune)(struct bladerf *, enum anonymous, unsigned long int, unsigned short int, unsigned int, unsigned char, unsigned char, _Bool, _Bool);
  // load_fw_from_bootloader
  signed int (*load_fw_from_bootloader)(enum anonymous_11, unsigned char, unsigned char, struct fx3_firmware *);
  // read_fw_log
  signed int (*read_fw_log)(struct bladerf *, unsigned int *);
};

struct bladerf_devinfo
{
  // backend
  enum anonymous_11 backend;
  // serial
  char serial[33l];
  // usb_bus
  unsigned char usb_bus;
  // usb_addr
  unsigned char usb_addr;
  // instance
  unsigned int instance;
};

struct bladerf_version
{
  // major
  unsigned short int major;
  // minor
  unsigned short int minor;
  // patch
  unsigned short int patch;
  // describe
  const char *describe;
};

struct buffer_mgmt
{
  // status
  enum anonymous_21 *status;
  // buffers
  void **buffers;
  // num_buffers
  unsigned int num_buffers;
  // prod_i
  unsigned int prod_i;
  // cons_i
  unsigned int cons_i;
  // partial_off
  unsigned int partial_off;
  // resubmit_count
  unsigned int resubmit_count;
  // submitter
  enum anonymous_22 submitter;
  // lock
  union anonymous_4 lock;
  // buf_ready
  union anonymous_18 buf_ready;
};

struct stream_config
{
  // format
  enum anonymous_9 format;
  // module
  enum anonymous module;
  // samples_per_buffer
  unsigned int samples_per_buffer;
  // num_xfers
  unsigned int num_xfers;
  // timeout_ms
  unsigned int timeout_ms;
  // bytes_per_sample
  unsigned long int bytes_per_sample;
};

struct sync_meta
{
  // state
  enum anonymous_24 state;
  // curr_msg
  unsigned char *curr_msg;
  // curr_msg_off
  unsigned long int curr_msg_off;
  // msg_per_buf
  unsigned int msg_per_buf;
  // msg_num
  unsigned int msg_num;
  // samples_per_msg
  unsigned int samples_per_msg;
  // _anon0
  union anonymous_25 _anon0;
  // curr_timestamp
  unsigned long int curr_timestamp;
};

struct bladerf_sync
{
  // dev
  struct bladerf *dev;
  // state
  enum anonymous_19 state;
  // buf_mgmt
  struct buffer_mgmt buf_mgmt;
  // stream_config
  struct stream_config stream_config;
  // worker
  struct sync_worker *worker;
  // meta
  struct sync_meta meta;
};

struct calibrations
{
  // dc_rx
  struct dc_cal_tbl *dc_rx;
  // dc_tx
  struct dc_cal_tbl *dc_tx;
};

struct bladerf
{
  // ctrl_lock
  union anonymous_4 ctrl_lock;
  // sync_lock
  union anonymous_4 sync_lock[2l];
  // ident
  struct bladerf_devinfo ident;
  // dac_trim
  unsigned short int dac_trim;
  // fpga_size
  enum anonymous_5 fpga_size;
  // fpga_version
  struct bladerf_version fpga_version;
  // fw_version
  struct bladerf_version fw_version;
  // legacy
  signed int legacy;
  // capabilities
  unsigned long int capabilities;
  // xb
  enum anonymous_6 xb;
  // usb_speed
  enum anonymous_7 usb_speed;
  // msg_size
  unsigned long int msg_size;
  // backend
  void *backend;
  // fn
  struct backend_fns *fn;
  // transfer_timeout
  signed int transfer_timeout[2l];
  // sync
  struct bladerf_sync *sync[2l];
  // cal
  struct calibrations cal;
  // auto_filter
  enum anonymous_8 auto_filter[2l];
  // module_format
  enum anonymous_9 module_format[2l];
  // tuning_mode
  enum anonymous_10 tuning_mode;
};

struct bladerf_devinfo_list
{
  // elt
  struct bladerf_devinfo *elt;
  // num_elt
  unsigned long int num_elt;
  // backing_size
  unsigned long int backing_size;
};

struct bladerf_image
{
  // magic
  char magic[8l];
  // checksum
  unsigned char checksum[32l];
  // version
  struct bladerf_version version;
  // timestamp
  unsigned long int timestamp;
  // serial
  char serial[34l];
  // reserved
  char reserved[128l];
  // type
  enum anonymous_38 type;
  // address
  unsigned int address;
  // length
  unsigned int length;
  // data
  unsigned char *data;
};

struct bladerf_lms_dc_cals
{
  // lpf_tuning
  signed short int lpf_tuning;
  // tx_lpf_i
  signed short int tx_lpf_i;
  // tx_lpf_q
  signed short int tx_lpf_q;
  // rx_lpf_i
  signed short int rx_lpf_i;
  // rx_lpf_q
  signed short int rx_lpf_q;
  // dc_ref
  signed short int dc_ref;
  // rxvga2a_i
  signed short int rxvga2a_i;
  // rxvga2a_q
  signed short int rxvga2a_q;
  // rxvga2b_i
  signed short int rxvga2b_i;
  // rxvga2b_q
  signed short int rxvga2b_q;
};

struct bladerf_lusb
{
  // dev
  struct libusb_device *dev;
  // handle
  struct libusb_device_handle *handle;
  // context
  struct libusb_context *context;
};

struct bladerf_metadata
{
  // timestamp
  unsigned long int timestamp;
  // flags
  unsigned int flags;
  // status
  unsigned int status;
  // actual_count
  unsigned int actual_count;
  // reserved
  unsigned char reserved[32l];
};

struct bladerf_quick_tune
{
  // freqsel
  unsigned char freqsel;
  // vcocap
  unsigned char vcocap;
  // nint
  unsigned short int nint;
  // nfrac
  unsigned int nfrac;
  // flags
  unsigned char flags;
};

struct bladerf_rational_rate
{
  // integer
  unsigned long int integer;
  // num
  unsigned long int num;
  // den
  unsigned long int den;
};

struct bladerf_stream
{
  // dev
  struct bladerf *dev;
  // module
  enum anonymous module;
  // format
  enum anonymous_9 format;
  // cb
  void * (*cb)(struct bladerf *, struct bladerf_stream *, struct bladerf_metadata *, void *, unsigned long int, void *);
  // user_data
  void *user_data;
  // samples_per_buffer
  unsigned long int samples_per_buffer;
  // num_buffers
  unsigned long int num_buffers;
  // buffers
  void **buffers;
  // lock
  union anonymous_4 lock;
  // error_code
  signed int error_code;
  // state
  enum anonymous_20 state;
  // can_submit_buffer
  union anonymous_18 can_submit_buffer;
  // stream_started
  union anonymous_18 stream_started;
  // backend_data
  void *backend_data;
};

struct bladerf_usb
{
  // fn
  struct usb_fns *fn;
  // driver
  void *driver;
};

struct compat
{
  // ver
  struct bladerf_version ver;
  // requires
  struct bladerf_version requires;
};

struct dc_cal_entry
{
  // freq
  unsigned int freq;
  // dc_i
  signed short int dc_i;
  // dc_q
  signed short int dc_q;
};

struct dc_cal_state
{
  // clk_en
  unsigned char clk_en;
  // reg0x72
  unsigned char reg0x72;
  // lna_gain
  enum anonymous_12 lna_gain;
  // rxvga1_gain
  signed int rxvga1_gain;
  // rxvga2_gain
  signed int rxvga2_gain;
  // base_addr
  unsigned char base_addr;
  // num_submodules
  unsigned int num_submodules;
  // rxvga1_curr_gain
  signed int rxvga1_curr_gain;
  // rxvga2_curr_gain
  signed int rxvga2_curr_gain;
};

struct dc_cal_tbl
{
  // version
  unsigned int version;
  // n_entries
  unsigned int n_entries;
  // reg_vals
  struct bladerf_lms_dc_cals reg_vals;
  // curr_idx
  unsigned int curr_idx;
  // entries
  struct dc_cal_entry *entries;
};

struct freq_range
{
  // low
  unsigned int low;
  // high
  unsigned int high;
  // value
  unsigned char value;
};

struct fx3_firmware
{
  // data
  unsigned char *data;
  // data_len
  unsigned int data_len;
  // entry_addr
  unsigned int entry_addr;
  // num_sections
  unsigned int num_sections;
  // curr_section
  unsigned int curr_section;
  // section_offset
  unsigned int section_offset;
};

struct libusb_config_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // wTotalLength
  unsigned short int wTotalLength;
  // bNumInterfaces
  unsigned char bNumInterfaces;
  // bConfigurationValue
  unsigned char bConfigurationValue;
  // iConfiguration
  unsigned char iConfiguration;
  // bmAttributes
  unsigned char bmAttributes;
  // MaxPower
  unsigned char MaxPower;
  // interface
  struct libusb_interface *interface;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_device_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bcdUSB
  unsigned short int bcdUSB;
  // bDeviceClass
  unsigned char bDeviceClass;
  // bDeviceSubClass
  unsigned char bDeviceSubClass;
  // bDeviceProtocol
  unsigned char bDeviceProtocol;
  // bMaxPacketSize0
  unsigned char bMaxPacketSize0;
  // idVendor
  unsigned short int idVendor;
  // idProduct
  unsigned short int idProduct;
  // bcdDevice
  unsigned short int bcdDevice;
  // iManufacturer
  unsigned char iManufacturer;
  // iProduct
  unsigned char iProduct;
  // iSerialNumber
  unsigned char iSerialNumber;
  // bNumConfigurations
  unsigned char bNumConfigurations;
};

struct libusb_endpoint_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bEndpointAddress
  unsigned char bEndpointAddress;
  // bmAttributes
  unsigned char bmAttributes;
  // wMaxPacketSize
  unsigned short int wMaxPacketSize;
  // bInterval
  unsigned char bInterval;
  // bRefresh
  unsigned char bRefresh;
  // bSynchAddress
  unsigned char bSynchAddress;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_interface
{
  // altsetting
  struct libusb_interface_descriptor *altsetting;
  // num_altsetting
  signed int num_altsetting;
};

struct libusb_interface_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bInterfaceNumber
  unsigned char bInterfaceNumber;
  // bAlternateSetting
  unsigned char bAlternateSetting;
  // bNumEndpoints
  unsigned char bNumEndpoints;
  // bInterfaceClass
  unsigned char bInterfaceClass;
  // bInterfaceSubClass
  unsigned char bInterfaceSubClass;
  // bInterfaceProtocol
  unsigned char bInterfaceProtocol;
  // iInterface
  unsigned char iInterface;
  // endpoint
  struct libusb_endpoint_descriptor *endpoint;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_iso_packet_descriptor
{
  // length
  unsigned int length;
  // actual_length
  unsigned int actual_length;
  // status
  enum libusb_transfer_status status;
};

struct libusb_transfer
{
  // dev_handle
  struct libusb_device_handle *dev_handle;
  // flags
  unsigned char flags;
  // endpoint
  unsigned char endpoint;
  // type
  unsigned char type;
  // timeout
  unsigned int timeout;
  // status
  enum libusb_transfer_status status;
  // length
  signed int length;
  // actual_length
  signed int actual_length;
  // callback
  void (*callback)(struct libusb_transfer *);
  // user_data
  void *user_data;
  // buffer
  unsigned char *buffer;
  // num_iso_packets
  signed int num_iso_packets;
  // iso_packet_desc
  struct libusb_iso_packet_descriptor iso_packet_desc[0l];
};

struct libusb_version
{
  // major
  const unsigned short int major;
  // minor
  const unsigned short int minor;
  // micro
  const unsigned short int micro;
  // nano
  const unsigned short int nano;
  // rc
  const char *rc;
  // describe
  const char *describe;
};

struct lms_freq
{
  // freqsel
  unsigned char freqsel;
  // vcocap
  unsigned char vcocap;
  // nint
  unsigned short int nint;
  // nfrac
  unsigned int nfrac;
  // flags
  unsigned char flags;
  // x
  unsigned char x;
  // vcocap_result
  unsigned char vcocap_result;
};

struct lusb_stream_data
{
  // num_transfers
  unsigned long int num_transfers;
  // num_avail
  unsigned long int num_avail;
  // i
  unsigned long int i;
  // transfers
  struct libusb_transfer **transfers;
  // transfer_status
  enum anonymous_37 *transfer_status;
  // out_of_order_event
  _Bool out_of_order_event;
};

struct numeric_suffix
{
  // suffix
  const char *suffix;
  // multiplier
  signed int multiplier;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct search_path_entries
{
  // prepend_home
  _Bool prepend_home;
  // path
  const char *path;
};

struct si5338_multisynth
{
  // index
  unsigned char index;
  // base
  unsigned short int base;
  // requested
  struct bladerf_rational_rate requested;
  // actual
  struct bladerf_rational_rate actual;
  // enable
  unsigned char enable;
  // a
  unsigned int a;
  // b
  unsigned int b;
  // c
  unsigned int c;
  // r
  unsigned int r;
  // p1
  unsigned int p1;
  // p2
  unsigned int p2;
  // p3
  unsigned int p3;
  // regs
  unsigned char regs[10l];
};

struct sync_worker
{
  // thread
  unsigned long int thread;
  // stream
  struct bladerf_stream *stream;
  // cb
  void * (*cb)(struct bladerf *, struct bladerf_stream *, struct bladerf_metadata *, void *, unsigned long int, void *);
  // state
  enum anonymous_23 state;
  // err_code
  signed int err_code;
  // state_lock
  union anonymous_4 state_lock;
  // state_changed
  union anonymous_18 state_changed;
  // requests
  unsigned int requests;
  // requests_pending
  union anonymous_18 requests_pending;
  // request_lock
  union anonymous_4 request_lock;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tx_options
{
  // flush
  _Bool flush;
  // zero_pad
  _Bool zero_pad;
};

struct uart_cmd
{
  // addr
  unsigned char addr;
  // data
  unsigned char data;
};

struct usb_driver
{
  // id
  const enum anonymous_11 id;
  // fn
  struct usb_fns *fn;
};

struct usb_fns
{
  // probe
  signed int (*probe)(enum anonymous_15, struct bladerf_devinfo_list *);
  // open
  signed int (*open)(void **, struct bladerf_devinfo *, struct bladerf_devinfo *);
  // close
  void (*close)(void *);
  // get_speed
  signed int (*get_speed)(void *, enum anonymous_7 *);
  // change_setting
  signed int (*change_setting)(void *, unsigned char);
  // control_transfer
  signed int (*control_transfer)(void *, enum anonymous_28, enum anonymous_29, enum anonymous_30, unsigned char, unsigned short int, unsigned short int, void *, unsigned int, unsigned int);
  // bulk_transfer
  signed int (*bulk_transfer)(void *, unsigned char, void *, unsigned int, unsigned int);
  // get_string_descriptor
  signed int (*get_string_descriptor)(void *, unsigned char, void *, unsigned int);
  // init_stream
  signed int (*init_stream)(void *, struct bladerf_stream *, unsigned long int);
  // stream
  signed int (*stream)(void *, struct bladerf_stream *, enum anonymous);
  // submit_stream_buffer
  signed int (*submit_stream_buffer)(void *, struct bladerf_stream *, void *, unsigned int, _Bool);
  // deinit_stream
  signed int (*deinit_stream)(void *, struct bladerf_stream *);
  // open_bootloader
  signed int (*open_bootloader)(void **, unsigned char, unsigned char);
  // close_bootloader
  void (*close_bootloader)(void *);
};


// PAD
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 236
static unsigned char PAD[64l] = { (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// backend_fns_usb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1166
struct backend_fns backend_fns_usb;
// backend_fns_usb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1166
struct backend_fns backend_fns_usb = { .matches=usb_matches, .probe=usb_probe, .open=usb_open,
    .close=usb_close, .load_fpga=usb_load_fpga, .is_fpga_configured=usb_is_fpga_configured,
    .erase_flash_blocks=usb_erase_flash_blocks,
    .read_flash_pages=usb_read_flash_pages,
    .write_flash_pages=usb_write_flash_pages,
    .device_reset=usb_device_reset,
    .jump_to_bootloader=usb_jump_to_bootloader, .get_cal=usb_get_cal,
    .get_otp=usb_get_otp, .get_device_speed=usb_get_device_speed,
    .config_gpio_write=nios_config_write,
    .config_gpio_read=nios_config_read,
    .expansion_gpio_write=nios_expansion_gpio_write, .expansion_gpio_read=nios_expansion_gpio_read,
    .expansion_gpio_dir_write=nios_expansion_gpio_dir_write,
    .expansion_gpio_dir_read=nios_expansion_gpio_dir_read,
    .set_iq_gain_correction=nios_set_iq_gain_correction,
    .set_iq_phase_correction=nios_set_iq_phase_correction,
    .get_iq_gain_correction=nios_get_iq_gain_correction,
    .get_iq_phase_correction=nios_get_iq_phase_correction,
    .get_timestamp=nios_get_timestamp,
    .si5338_write=nios_si5338_write, .si5338_read=nios_si5338_read,
    .lms_write=nios_lms6_write, .lms_read=nios_lms6_read,
    .vctcxo_dac_write=nios_vctcxo_trim_dac_write, .vctcxo_dac_read=nios_vctcxo_trim_dac_read,
    .set_vctcxo_tamer_mode=nios_set_vctcxo_tamer_mode,
    .get_vctcxo_tamer_mode=nios_get_vctcxo_tamer_mode,
    .xb_spi=nios_xb200_synth_write,
    .set_firmware_loopback=usb_set_firmware_loopback, .get_firmware_loopback=usb_get_firmware_loopback,
    .enable_module=usb_enable_module,
    .init_stream=usb_init_stream, .stream=usb_stream,
    .submit_stream_buffer=usb_submit_stream_buffer, .deinit_stream=usb_deinit_stream,
    .retune=nios_retune, .load_fw_from_bootloader=usb_load_fw_from_bootloader,
    .read_fw_log=usb_read_fw_log };
// backend_fns_usb_legacy
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 56
struct backend_fns backend_fns_usb_legacy;
// backend_fns_usb_legacy
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 56
struct backend_fns backend_fns_usb_legacy = { .matches=usb_matches, .probe=usb_probe, .open=usb_open,
    .close=usb_close, .load_fpga=usb_load_fpga, .is_fpga_configured=usb_is_fpga_configured,
    .erase_flash_blocks=usb_erase_flash_blocks,
    .read_flash_pages=usb_read_flash_pages,
    .write_flash_pages=usb_write_flash_pages,
    .device_reset=usb_device_reset,
    .jump_to_bootloader=usb_jump_to_bootloader, .get_cal=usb_get_cal,
    .get_otp=usb_get_otp, .get_device_speed=usb_get_device_speed,
    .config_gpio_write=nios_legacy_config_write,
    .config_gpio_read=nios_legacy_config_read,
    .expansion_gpio_write=nios_legacy_expansion_gpio_write,
    .expansion_gpio_read=nios_legacy_expansion_gpio_read,
    .expansion_gpio_dir_write=nios_legacy_expansion_gpio_dir_write,
    .expansion_gpio_dir_read=nios_legacy_expansion_gpio_dir_read,
    .set_iq_gain_correction=nios_legacy_set_iq_gain_correction,
    .set_iq_phase_correction=nios_legacy_set_iq_phase_correction,
    .get_iq_gain_correction=nios_legacy_get_iq_gain_correction,
    .get_iq_phase_correction=nios_legacy_get_iq_phase_correction,
    .get_timestamp=nios_legacy_get_timestamp,
    .si5338_write=nios_legacy_si5338_write,
    .si5338_read=nios_legacy_si5338_read,
    .lms_write=nios_legacy_lms6_write,
    .lms_read=nios_legacy_lms6_read, .vctcxo_dac_write=nios_legacy_vctcxo_trim_dac_write,
    .vctcxo_dac_read=nios_vctcxo_trim_dac_read,
    .set_vctcxo_tamer_mode=set_vctcxo_tamer_mode_unsupported,
    .get_vctcxo_tamer_mode=get_vctcxo_tamer_mode_unsupported,
    .xb_spi=nios_legacy_xb200_synth_write,
    .set_firmware_loopback=usb_set_firmware_loopback,
    .get_firmware_loopback=usb_get_firmware_loopback,
    .enable_module=usb_enable_module,
    .init_stream=usb_init_stream, .stream=usb_stream,
    .submit_stream_buffer=usb_submit_stream_buffer, .deinit_stream=usb_deinit_stream,
    .retune=nios_retune, .load_fw_from_bootloader=usb_load_fw_from_bootloader,
    .read_fw_log=usb_read_fw_log };
// backend_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 27
static struct backend_fns *backend_list[1l];
// backend_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 27
static struct backend_fns *backend_list[1l] = { &backend_fns_usb };
// bands
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 194
static struct freq_range bands[16l] = { { .low=237500000u, .high=(unsigned int)(4535000000ull / (unsigned long int)16), .value=(unsigned char)(4 << 3 | 0x7) },
    { .low=(unsigned int)(4535000000ull / (unsigned long int)16), .high=(unsigned int)(5408000000ull / (unsigned long int)16),
    .value=(unsigned char)(5 << 3 | 0x7) },
    { .low=(unsigned int)(5408000000ull / (unsigned long int)16), .high=(unsigned int)(6480000000ull / (unsigned long int)16),
    .value=(unsigned char)(6 << 3 | 0x7) },
    { .low=(unsigned int)(6480000000ull / (unsigned long int)16), .high=(unsigned int)(7600000000ull / (unsigned long int)16),
    .value=(unsigned char)(7 << 3 | 0x7) },
    { .low=(unsigned int)(3800000000ull / (unsigned long int)8), .high=(unsigned int)(4535000000ull / (unsigned long int)8),
    .value=(unsigned char)(4 << 3 | 0x6) },
    { .low=(unsigned int)(4535000000ull / (unsigned long int)8), .high=(unsigned int)(5408000000ull / (unsigned long int)8),
    .value=(unsigned char)(5 << 3 | 0x6) },
    { .low=(unsigned int)(5408000000ull / (unsigned long int)8), .high=(unsigned int)(6480000000ull / (unsigned long int)8),
    .value=(unsigned char)(6 << 3 | 0x6) },
    { .low=(unsigned int)(6480000000ull / (unsigned long int)8), .high=(unsigned int)(7600000000ull / (unsigned long int)8),
    .value=(unsigned char)(7 << 3 | 0x6) },
    { .low=(unsigned int)(3800000000ull / (unsigned long int)4), .high=(unsigned int)(4535000000ull / (unsigned long int)4),
    .value=(unsigned char)(4 << 3 | 0x5) },
    { .low=(unsigned int)(4535000000ull / (unsigned long int)4), .high=(unsigned int)(5408000000ull / (unsigned long int)4),
    .value=(unsigned char)(5 << 3 | 0x5) },
    { .low=(unsigned int)(5408000000ull / (unsigned long int)4), .high=(unsigned int)(6480000000ull / (unsigned long int)4),
    .value=(unsigned char)(6 << 3 | 0x5) },
    { .low=(unsigned int)(6480000000ull / (unsigned long int)4), .high=(unsigned int)(7600000000ull / (unsigned long int)4),
    .value=(unsigned char)(7 << 3 | 0x5) },
    { .low=(unsigned int)(3800000000ull / (unsigned long int)2), .high=(unsigned int)(4535000000ull / (unsigned long int)2),
    .value=(unsigned char)(4 << 3 | 0x4) },
    { .low=(unsigned int)(4535000000ull / (unsigned long int)2), .high=(unsigned int)(5408000000ull / (unsigned long int)2),
    .value=(unsigned char)(5 << 3 | 0x4) },
    { .low=(unsigned int)(5408000000ull / (unsigned long int)2), .high=(unsigned int)(6480000000ull / (unsigned long int)2),
    .value=(unsigned char)(6 << 3 | 0x4) },
    { .low=(unsigned int)(6480000000ull / (unsigned long int)2), .high=3800000000u,
    .value=(unsigned char)(7 << 3 | 0x4) } };
// bladerf_usb_reset_device_on_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 44
_Bool bladerf_usb_reset_device_on_open = (_Bool)1;
// filter_level
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/log.c line 33
static enum anonymous_26 filter_level = (enum anonymous_26)BLADERF_LOG_LEVEL_INFO;
// fpga_compat_tbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 52
static struct compat fpga_compat_tbl[19l] = { { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)5, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)4, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)4, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)3, .patch=(unsigned short int)5,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)3, .patch=(unsigned short int)4,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)3, .patch=(unsigned short int)3,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)3, .patch=(unsigned short int)2,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)3, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)3, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)2, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)1, .patch=(unsigned short int)2,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)1, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)1, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)6,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)5,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)4,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)3,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)2,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 } } };
// fw_compat_tbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 41
static struct compat fw_compat_tbl[7l] = { { .ver={ .major=(unsigned short int)1, .minor=(unsigned short int)9, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)2,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)1, .minor=(unsigned short int)8, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)2,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)1, .minor=(unsigned short int)8, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)2,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)1, .minor=(unsigned short int)7, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)2,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)1, .minor=(unsigned short int)7, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)2,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)2,
    .describe=(const char *)(void *)0 } },
    { .ver={ .major=(unsigned short int)1, .minor=(unsigned short int)6, .patch=(unsigned short int)0,
    .describe=(const char *)(void *)0 }, .requires={ .major=(unsigned short int)0, .minor=(unsigned short int)0, .patch=(unsigned short int)1,
    .describe=(const char *)(void *)0 } } };
// image_magic
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 57
static const char image_magic[8l] = { 'b', 'l', 'a', 'd', 'e', 'R', 'F', 0 };
// libusb_fns
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1334
static struct usb_fns libusb_fns;
// libusb_fns
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1334
static struct usb_fns libusb_fns = { .probe=lusb_probe, .open=lusb_open, .close=lusb_close, .get_speed=lusb_get_speed,
    .change_setting=lusb_change_setting, .control_transfer=lusb_control_transfer,
    .bulk_transfer=lusb_bulk_transfer,
    .get_string_descriptor=lusb_get_string_descriptor, .init_stream=lusb_init_stream,
    .stream=lusb_stream, .submit_stream_buffer=lusb_submit_stream_buffer,
    .deinit_stream=lusb_deinit_stream,
    .open_bootloader=lusb_open_bootloader, .close_bootloader=lusb_close_bootloader };
// lms_reg_dumpset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 239
static const unsigned char lms_reg_dumpset[107l] = { (const unsigned char)0x00, (const unsigned char)0x01, (const unsigned char)0x02, (const unsigned char)0x03, (const unsigned char)0x04, (const unsigned char)0x05, (const unsigned char)0x06, (const unsigned char)0x07, (const unsigned char)0x08, (const unsigned char)0x09, (const unsigned char)0x0A, (const unsigned char)0x0B, (const unsigned char)0x0E, (const unsigned char)0x0F, (const unsigned char)0x10, (const unsigned char)0x11, (const unsigned char)0x12, (const unsigned char)0x13, (const unsigned char)0x14, (const unsigned char)0x15, (const unsigned char)0x16, (const unsigned char)0x17, (const unsigned char)0x18, (const unsigned char)0x19, (const unsigned char)0x1A, (const unsigned char)0x1B, (const unsigned char)0x1C, (const unsigned char)0x1D, (const unsigned char)0x1E, (const unsigned char)0x1F, (const unsigned char)0x20, (const unsigned char)0x21, (const unsigned char)0x22, (const unsigned char)0x23, (const unsigned char)0x24, (const unsigned char)0x25, (const unsigned char)0x26, (const unsigned char)0x27, (const unsigned char)0x28, (const unsigned char)0x29, (const unsigned char)0x2A, (const unsigned char)0x2B, (const unsigned char)0x2C, (const unsigned char)0x2D, (const unsigned char)0x2E, (const unsigned char)0x2F, (const unsigned char)0x30, (const unsigned char)0x31, (const unsigned char)0x32, (const unsigned char)0x33, (const unsigned char)0x34, (const unsigned char)0x35, (const unsigned char)0x36, (const unsigned char)0x40, (const unsigned char)0x41, (const unsigned char)0x42, (const unsigned char)0x43, (const unsigned char)0x44, (const unsigned char)0x45, (const unsigned char)0x46, (const unsigned char)0x47, (const unsigned char)0x48, (const unsigned char)0x49, (const unsigned char)0x4A, (const unsigned char)0x4B, (const unsigned char)0x4C, (const unsigned char)0x4D, (const unsigned char)0x4E, (const unsigned char)0x4F, (const unsigned char)0x50, (const unsigned char)0x51, (const unsigned char)0x52, (const unsigned char)0x53, (const unsigned char)0x54, (const unsigned char)0x55, (const unsigned char)0x56, (const unsigned char)0x57, (const unsigned char)0x58, (const unsigned char)0x59, (const unsigned char)0x5A, (const unsigned char)0x5B, (const unsigned char)0x5C, (const unsigned char)0x5D, (const unsigned char)0x5E, (const unsigned char)0x5F, (const unsigned char)0x60, (const unsigned char)0x61, (const unsigned char)0x62, (const unsigned char)0x63, (const unsigned char)0x64, (const unsigned char)0x65, (const unsigned char)0x66, (const unsigned char)0x67, (const unsigned char)0x68, (const unsigned char)0x70, (const unsigned char)0x71, (const unsigned char)0x72, (const unsigned char)0x73, (const unsigned char)0x74, (const unsigned char)0x75, (const unsigned char)0x76, (const unsigned char)0x77, (const unsigned char)0x78, (const unsigned char)0x79, (const unsigned char)0x7A, (const unsigned char)0x7B, (const unsigned char)0x7C };
// rxvga1_lut_code2val
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 222
static const unsigned char rxvga1_lut_code2val[121l] = { (const unsigned char)5, (const unsigned char)5, (const unsigned char)5, (const unsigned char)5, (const unsigned char)5, (const unsigned char)5, (const unsigned char)5, (const unsigned char)5, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)8, (const unsigned char)8, (const unsigned char)8, (const unsigned char)8, (const unsigned char)8, (const unsigned char)8, (const unsigned char)8, (const unsigned char)8, (const unsigned char)8, (const unsigned char)8, (const unsigned char)8, (const unsigned char)9, (const unsigned char)9, (const unsigned char)9, (const unsigned char)9, (const unsigned char)9, (const unsigned char)9, (const unsigned char)9, (const unsigned char)9, (const unsigned char)9, (const unsigned char)10, (const unsigned char)10, (const unsigned char)10, (const unsigned char)10, (const unsigned char)10, (const unsigned char)10, (const unsigned char)10, (const unsigned char)10, (const unsigned char)11, (const unsigned char)11, (const unsigned char)11, (const unsigned char)11, (const unsigned char)11, (const unsigned char)11, (const unsigned char)11, (const unsigned char)12, (const unsigned char)12, (const unsigned char)12, (const unsigned char)12, (const unsigned char)12, (const unsigned char)12, (const unsigned char)12, (const unsigned char)13, (const unsigned char)13, (const unsigned char)13, (const unsigned char)13, (const unsigned char)13, (const unsigned char)13, (const unsigned char)14, (const unsigned char)14, (const unsigned char)14, (const unsigned char)14, (const unsigned char)14, (const unsigned char)15, (const unsigned char)15, (const unsigned char)15, (const unsigned char)15, (const unsigned char)15, (const unsigned char)16, (const unsigned char)16, (const unsigned char)16, (const unsigned char)16, (const unsigned char)17, (const unsigned char)17, (const unsigned char)17, (const unsigned char)18, (const unsigned char)18, (const unsigned char)18, (const unsigned char)18, (const unsigned char)19, (const unsigned char)19, (const unsigned char)19, (const unsigned char)20, (const unsigned char)20, (const unsigned char)21, (const unsigned char)21, (const unsigned char)22, (const unsigned char)22, (const unsigned char)22, (const unsigned char)23, (const unsigned char)24, (const unsigned char)24, (const unsigned char)25, (const unsigned char)25, (const unsigned char)26, (const unsigned char)27, (const unsigned char)28, (const unsigned char)29, (const unsigned char)30 };
// rxvga1_lut_val2code
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 234
static const unsigned char rxvga1_lut_val2code[31l] = { (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)14, (const unsigned char)26, (const unsigned char)37, (const unsigned char)47, (const unsigned char)56, (const unsigned char)63, (const unsigned char)70, (const unsigned char)76, (const unsigned char)82, (const unsigned char)87, (const unsigned char)91, (const unsigned char)95, (const unsigned char)99, (const unsigned char)102, (const unsigned char)104, (const unsigned char)107, (const unsigned char)109, (const unsigned char)111, (const unsigned char)113, (const unsigned char)114, (const unsigned char)116, (const unsigned char)117, (const unsigned char)118, (const unsigned char)119, (const unsigned char)120 };
// search_paths
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 179
static struct search_path_entries search_paths[7l] = { { .prepend_home=(_Bool)0, .path="" }, { .prepend_home=(_Bool)1, .path="/.config/Nuand/bladeRF/" },
    { .prepend_home=(_Bool)1, .path="/.Nuand/bladeRF/" },
    { .prepend_home=(_Bool)0, .path="/usr/etc/Nuand/bladeRF/" },
    { .prepend_home=(_Bool)0, .path="/usr/share/Nuand/bladeRF/" },
    { .prepend_home=(_Bool)0, .path="/etc/Nuand/bladeRF/" },
    { .prepend_home=(_Bool)0, .path="/usr/share/Nuand/bladeRF/" } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// uint_bandwidths
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 126
static const unsigned int uint_bandwidths[16l] = { (const unsigned int)(28 * 1000000), (const unsigned int)(20 * 1000000), (const unsigned int)(14 * 1000000), (const unsigned int)(12 * 1000000), (const unsigned int)(10 * 1000000), (const unsigned int)(8750 * 1000), (const unsigned int)(7 * 1000000), (const unsigned int)(6 * 1000000), (const unsigned int)(5500 * 1000), (const unsigned int)(5 * 1000000), (const unsigned int)(3840 * 1000), (const unsigned int)(3 * 1000000), (const unsigned int)(2750 * 1000), (const unsigned int)(2500 * 1000), (const unsigned int)(1750 * 1000), (const unsigned int)(1500 * 1000) };
// usb_driver_libusb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1351
struct usb_driver usb_driver_libusb;
// usb_driver_libusb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1351
struct usb_driver usb_driver_libusb = { .id=(const enum anonymous_11)BLADERF_BACKEND_LIBUSB, .fn=&libusb_fns };
// usb_driver_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 53
static struct usb_driver *usb_driver_list[1l];
// usb_driver_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 53
static struct usb_driver *usb_driver_list[1l] = { &usb_driver_libusb };

// SHA256_Final
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/sha256.h line 50
void SHA256_Final(unsigned char *digest, struct SHA256Context *ctx)
{
  SHA256_Pad(ctx);
  be32enc_vect(digest, ctx->state, (unsigned long int)32);
  memset((void *)ctx, 0, sizeof(struct SHA256Context) /*104ul*/ );
}

// SHA256_Init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/sha256.h line 48
void SHA256_Init(struct SHA256Context *ctx)
{
  ctx->count[(signed long int)1] = (unsigned int)0;
  ctx->count[(signed long int)0] = ctx->count[(signed long int)1];
  ctx->state[(signed long int)0] = (unsigned int)0x6A09E667;
  ctx->state[(signed long int)1] = 0xBB67AE85;
  ctx->state[(signed long int)2] = (unsigned int)0x3C6EF372;
  ctx->state[(signed long int)3] = 0xA54FF53A;
  ctx->state[(signed long int)4] = (unsigned int)0x510E527F;
  ctx->state[(signed long int)5] = 0x9B05688C;
  ctx->state[(signed long int)6] = (unsigned int)0x1F83D9AB;
  ctx->state[(signed long int)7] = (unsigned int)0x5BE0CD19;
}

// SHA256_Pad
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 245
static void SHA256_Pad(struct SHA256Context *ctx)
{
  unsigned char len[8l];
  unsigned int r;
  unsigned int plen;
  be32enc_vect(len, ctx->count, (unsigned long int)8);
  r = ctx->count[(signed long int)1] >> 3 & (unsigned int)0x3f;
  plen = r < (unsigned int)56 ? (unsigned int)56 - r : (unsigned int)120 - r;
  SHA256_Update(ctx, (const void *)PAD, (unsigned long int)plen);
  SHA256_Update(ctx, (const void *)len, (unsigned long int)8);
}

// SHA256_Transform
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 150
static void SHA256_Transform(unsigned int *state, const unsigned char *block)
{
  unsigned int W[64l];
  unsigned int S[8l];
  unsigned int t0;
  unsigned int t1;
  signed int i;
  be32dec_vect(W, block, (unsigned long int)64);
  i = 16;
  for( ; !(i >= 64); i = i + 1)
    W[(signed long int)i] = ((W[(signed long int)(i - 2)] >> 17 | W[(signed long int)(i - 2)] << 32 - 17) ^ (W[(signed long int)(i - 2)] >> 19 | W[(signed long int)(i - 2)] << 32 - 19) ^ W[(signed long int)(i - 2)] >> 10) + W[(signed long int)(i - 7)] + ((W[(signed long int)(i - 15)] >> 7 | W[(signed long int)(i - 15)] << 32 - 7) ^ (W[(signed long int)(i - 15)] >> 18 | W[(signed long int)(i - 15)] << 32 - 18) ^ W[(signed long int)(i - 15)] >> 3) + W[(signed long int)(i - 16)];
  memcpy((void *)S, (const void *)state, (unsigned long int)32);
  t0 = S[(signed long int)((71 - 0) % 8)] + ((S[(signed long int)((68 - 0) % 8)] >> 6 | S[(signed long int)((68 - 0) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 0) % 8)] >> 11 | S[(signed long int)((68 - 0) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 0) % 8)] >> 25 | S[(signed long int)((68 - 0) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 0) % 8)] & (S[(signed long int)((69 - 0) % 8)] ^ S[(signed long int)((70 - 0) % 8)]) ^ S[(signed long int)((70 - 0) % 8)]) + W[(signed long int)0] + (unsigned int)0x428a2f98;
  t1 = ((S[(signed long int)((64 - 0) % 8)] >> 2 | S[(signed long int)((64 - 0) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 0) % 8)] >> 13 | S[(signed long int)((64 - 0) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 0) % 8)] >> 22 | S[(signed long int)((64 - 0) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 0) % 8)] & (S[(signed long int)((65 - 0) % 8)] | S[(signed long int)((66 - 0) % 8)]) | S[(signed long int)((65 - 0) % 8)] & S[(signed long int)((66 - 0) % 8)]);
  S[(signed long int)((67 - 0) % 8)] = S[(signed long int)((67 - 0) % 8)] + t0;
  S[(signed long int)((71 - 0) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 1) % 8)] + ((S[(signed long int)((68 - 1) % 8)] >> 6 | S[(signed long int)((68 - 1) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 1) % 8)] >> 11 | S[(signed long int)((68 - 1) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 1) % 8)] >> 25 | S[(signed long int)((68 - 1) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 1) % 8)] & (S[(signed long int)((69 - 1) % 8)] ^ S[(signed long int)((70 - 1) % 8)]) ^ S[(signed long int)((70 - 1) % 8)]) + W[(signed long int)1] + (unsigned int)0x71374491;
  t1 = ((S[(signed long int)((64 - 1) % 8)] >> 2 | S[(signed long int)((64 - 1) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 1) % 8)] >> 13 | S[(signed long int)((64 - 1) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 1) % 8)] >> 22 | S[(signed long int)((64 - 1) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 1) % 8)] & (S[(signed long int)((65 - 1) % 8)] | S[(signed long int)((66 - 1) % 8)]) | S[(signed long int)((65 - 1) % 8)] & S[(signed long int)((66 - 1) % 8)]);
  S[(signed long int)((67 - 1) % 8)] = S[(signed long int)((67 - 1) % 8)] + t0;
  S[(signed long int)((71 - 1) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 2) % 8)] + ((S[(signed long int)((68 - 2) % 8)] >> 6 | S[(signed long int)((68 - 2) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 2) % 8)] >> 11 | S[(signed long int)((68 - 2) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 2) % 8)] >> 25 | S[(signed long int)((68 - 2) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 2) % 8)] & (S[(signed long int)((69 - 2) % 8)] ^ S[(signed long int)((70 - 2) % 8)]) ^ S[(signed long int)((70 - 2) % 8)]) + W[(signed long int)2] + 0xb5c0fbcf;
  t1 = ((S[(signed long int)((64 - 2) % 8)] >> 2 | S[(signed long int)((64 - 2) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 2) % 8)] >> 13 | S[(signed long int)((64 - 2) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 2) % 8)] >> 22 | S[(signed long int)((64 - 2) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 2) % 8)] & (S[(signed long int)((65 - 2) % 8)] | S[(signed long int)((66 - 2) % 8)]) | S[(signed long int)((65 - 2) % 8)] & S[(signed long int)((66 - 2) % 8)]);
  S[(signed long int)((67 - 2) % 8)] = S[(signed long int)((67 - 2) % 8)] + t0;
  S[(signed long int)((71 - 2) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 3) % 8)] + ((S[(signed long int)((68 - 3) % 8)] >> 6 | S[(signed long int)((68 - 3) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 3) % 8)] >> 11 | S[(signed long int)((68 - 3) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 3) % 8)] >> 25 | S[(signed long int)((68 - 3) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 3) % 8)] & (S[(signed long int)((69 - 3) % 8)] ^ S[(signed long int)((70 - 3) % 8)]) ^ S[(signed long int)((70 - 3) % 8)]) + W[(signed long int)3] + 0xe9b5dba5;
  t1 = ((S[(signed long int)((64 - 3) % 8)] >> 2 | S[(signed long int)((64 - 3) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 3) % 8)] >> 13 | S[(signed long int)((64 - 3) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 3) % 8)] >> 22 | S[(signed long int)((64 - 3) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 3) % 8)] & (S[(signed long int)((65 - 3) % 8)] | S[(signed long int)((66 - 3) % 8)]) | S[(signed long int)((65 - 3) % 8)] & S[(signed long int)((66 - 3) % 8)]);
  S[(signed long int)((67 - 3) % 8)] = S[(signed long int)((67 - 3) % 8)] + t0;
  S[(signed long int)((71 - 3) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 4) % 8)] + ((S[(signed long int)((68 - 4) % 8)] >> 6 | S[(signed long int)((68 - 4) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 4) % 8)] >> 11 | S[(signed long int)((68 - 4) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 4) % 8)] >> 25 | S[(signed long int)((68 - 4) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 4) % 8)] & (S[(signed long int)((69 - 4) % 8)] ^ S[(signed long int)((70 - 4) % 8)]) ^ S[(signed long int)((70 - 4) % 8)]) + W[(signed long int)4] + (unsigned int)0x3956c25b;
  t1 = ((S[(signed long int)((64 - 4) % 8)] >> 2 | S[(signed long int)((64 - 4) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 4) % 8)] >> 13 | S[(signed long int)((64 - 4) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 4) % 8)] >> 22 | S[(signed long int)((64 - 4) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 4) % 8)] & (S[(signed long int)((65 - 4) % 8)] | S[(signed long int)((66 - 4) % 8)]) | S[(signed long int)((65 - 4) % 8)] & S[(signed long int)((66 - 4) % 8)]);
  S[(signed long int)((67 - 4) % 8)] = S[(signed long int)((67 - 4) % 8)] + t0;
  S[(signed long int)((71 - 4) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 5) % 8)] + ((S[(signed long int)((68 - 5) % 8)] >> 6 | S[(signed long int)((68 - 5) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 5) % 8)] >> 11 | S[(signed long int)((68 - 5) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 5) % 8)] >> 25 | S[(signed long int)((68 - 5) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 5) % 8)] & (S[(signed long int)((69 - 5) % 8)] ^ S[(signed long int)((70 - 5) % 8)]) ^ S[(signed long int)((70 - 5) % 8)]) + W[(signed long int)5] + (unsigned int)0x59f111f1;
  t1 = ((S[(signed long int)((64 - 5) % 8)] >> 2 | S[(signed long int)((64 - 5) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 5) % 8)] >> 13 | S[(signed long int)((64 - 5) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 5) % 8)] >> 22 | S[(signed long int)((64 - 5) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 5) % 8)] & (S[(signed long int)((65 - 5) % 8)] | S[(signed long int)((66 - 5) % 8)]) | S[(signed long int)((65 - 5) % 8)] & S[(signed long int)((66 - 5) % 8)]);
  S[(signed long int)((67 - 5) % 8)] = S[(signed long int)((67 - 5) % 8)] + t0;
  S[(signed long int)((71 - 5) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 6) % 8)] + ((S[(signed long int)((68 - 6) % 8)] >> 6 | S[(signed long int)((68 - 6) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 6) % 8)] >> 11 | S[(signed long int)((68 - 6) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 6) % 8)] >> 25 | S[(signed long int)((68 - 6) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 6) % 8)] & (S[(signed long int)((69 - 6) % 8)] ^ S[(signed long int)((70 - 6) % 8)]) ^ S[(signed long int)((70 - 6) % 8)]) + W[(signed long int)6] + 0x923f82a4;
  t1 = ((S[(signed long int)((64 - 6) % 8)] >> 2 | S[(signed long int)((64 - 6) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 6) % 8)] >> 13 | S[(signed long int)((64 - 6) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 6) % 8)] >> 22 | S[(signed long int)((64 - 6) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 6) % 8)] & (S[(signed long int)((65 - 6) % 8)] | S[(signed long int)((66 - 6) % 8)]) | S[(signed long int)((65 - 6) % 8)] & S[(signed long int)((66 - 6) % 8)]);
  S[(signed long int)((67 - 6) % 8)] = S[(signed long int)((67 - 6) % 8)] + t0;
  S[(signed long int)((71 - 6) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 7) % 8)] + ((S[(signed long int)((68 - 7) % 8)] >> 6 | S[(signed long int)((68 - 7) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 7) % 8)] >> 11 | S[(signed long int)((68 - 7) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 7) % 8)] >> 25 | S[(signed long int)((68 - 7) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 7) % 8)] & (S[(signed long int)((69 - 7) % 8)] ^ S[(signed long int)((70 - 7) % 8)]) ^ S[(signed long int)((70 - 7) % 8)]) + W[(signed long int)7] + 0xab1c5ed5;
  t1 = ((S[(signed long int)((64 - 7) % 8)] >> 2 | S[(signed long int)((64 - 7) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 7) % 8)] >> 13 | S[(signed long int)((64 - 7) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 7) % 8)] >> 22 | S[(signed long int)((64 - 7) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 7) % 8)] & (S[(signed long int)((65 - 7) % 8)] | S[(signed long int)((66 - 7) % 8)]) | S[(signed long int)((65 - 7) % 8)] & S[(signed long int)((66 - 7) % 8)]);
  S[(signed long int)((67 - 7) % 8)] = S[(signed long int)((67 - 7) % 8)] + t0;
  S[(signed long int)((71 - 7) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 8) % 8)] + ((S[(signed long int)((68 - 8) % 8)] >> 6 | S[(signed long int)((68 - 8) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 8) % 8)] >> 11 | S[(signed long int)((68 - 8) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 8) % 8)] >> 25 | S[(signed long int)((68 - 8) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 8) % 8)] & (S[(signed long int)((69 - 8) % 8)] ^ S[(signed long int)((70 - 8) % 8)]) ^ S[(signed long int)((70 - 8) % 8)]) + W[(signed long int)8] + 0xd807aa98;
  t1 = ((S[(signed long int)((64 - 8) % 8)] >> 2 | S[(signed long int)((64 - 8) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 8) % 8)] >> 13 | S[(signed long int)((64 - 8) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 8) % 8)] >> 22 | S[(signed long int)((64 - 8) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 8) % 8)] & (S[(signed long int)((65 - 8) % 8)] | S[(signed long int)((66 - 8) % 8)]) | S[(signed long int)((65 - 8) % 8)] & S[(signed long int)((66 - 8) % 8)]);
  S[(signed long int)((67 - 8) % 8)] = S[(signed long int)((67 - 8) % 8)] + t0;
  S[(signed long int)((71 - 8) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 9) % 8)] + ((S[(signed long int)((68 - 9) % 8)] >> 6 | S[(signed long int)((68 - 9) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 9) % 8)] >> 11 | S[(signed long int)((68 - 9) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 9) % 8)] >> 25 | S[(signed long int)((68 - 9) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 9) % 8)] & (S[(signed long int)((69 - 9) % 8)] ^ S[(signed long int)((70 - 9) % 8)]) ^ S[(signed long int)((70 - 9) % 8)]) + W[(signed long int)9] + (unsigned int)0x12835b01;
  t1 = ((S[(signed long int)((64 - 9) % 8)] >> 2 | S[(signed long int)((64 - 9) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 9) % 8)] >> 13 | S[(signed long int)((64 - 9) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 9) % 8)] >> 22 | S[(signed long int)((64 - 9) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 9) % 8)] & (S[(signed long int)((65 - 9) % 8)] | S[(signed long int)((66 - 9) % 8)]) | S[(signed long int)((65 - 9) % 8)] & S[(signed long int)((66 - 9) % 8)]);
  S[(signed long int)((67 - 9) % 8)] = S[(signed long int)((67 - 9) % 8)] + t0;
  S[(signed long int)((71 - 9) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 10) % 8)] + ((S[(signed long int)((68 - 10) % 8)] >> 6 | S[(signed long int)((68 - 10) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 10) % 8)] >> 11 | S[(signed long int)((68 - 10) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 10) % 8)] >> 25 | S[(signed long int)((68 - 10) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 10) % 8)] & (S[(signed long int)((69 - 10) % 8)] ^ S[(signed long int)((70 - 10) % 8)]) ^ S[(signed long int)((70 - 10) % 8)]) + W[(signed long int)10] + (unsigned int)0x243185be;
  t1 = ((S[(signed long int)((64 - 10) % 8)] >> 2 | S[(signed long int)((64 - 10) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 10) % 8)] >> 13 | S[(signed long int)((64 - 10) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 10) % 8)] >> 22 | S[(signed long int)((64 - 10) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 10) % 8)] & (S[(signed long int)((65 - 10) % 8)] | S[(signed long int)((66 - 10) % 8)]) | S[(signed long int)((65 - 10) % 8)] & S[(signed long int)((66 - 10) % 8)]);
  S[(signed long int)((67 - 10) % 8)] = S[(signed long int)((67 - 10) % 8)] + t0;
  S[(signed long int)((71 - 10) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 11) % 8)] + ((S[(signed long int)((68 - 11) % 8)] >> 6 | S[(signed long int)((68 - 11) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 11) % 8)] >> 11 | S[(signed long int)((68 - 11) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 11) % 8)] >> 25 | S[(signed long int)((68 - 11) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 11) % 8)] & (S[(signed long int)((69 - 11) % 8)] ^ S[(signed long int)((70 - 11) % 8)]) ^ S[(signed long int)((70 - 11) % 8)]) + W[(signed long int)11] + (unsigned int)0x550c7dc3;
  t1 = ((S[(signed long int)((64 - 11) % 8)] >> 2 | S[(signed long int)((64 - 11) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 11) % 8)] >> 13 | S[(signed long int)((64 - 11) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 11) % 8)] >> 22 | S[(signed long int)((64 - 11) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 11) % 8)] & (S[(signed long int)((65 - 11) % 8)] | S[(signed long int)((66 - 11) % 8)]) | S[(signed long int)((65 - 11) % 8)] & S[(signed long int)((66 - 11) % 8)]);
  S[(signed long int)((67 - 11) % 8)] = S[(signed long int)((67 - 11) % 8)] + t0;
  S[(signed long int)((71 - 11) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 12) % 8)] + ((S[(signed long int)((68 - 12) % 8)] >> 6 | S[(signed long int)((68 - 12) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 12) % 8)] >> 11 | S[(signed long int)((68 - 12) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 12) % 8)] >> 25 | S[(signed long int)((68 - 12) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 12) % 8)] & (S[(signed long int)((69 - 12) % 8)] ^ S[(signed long int)((70 - 12) % 8)]) ^ S[(signed long int)((70 - 12) % 8)]) + W[(signed long int)12] + (unsigned int)0x72be5d74;
  t1 = ((S[(signed long int)((64 - 12) % 8)] >> 2 | S[(signed long int)((64 - 12) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 12) % 8)] >> 13 | S[(signed long int)((64 - 12) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 12) % 8)] >> 22 | S[(signed long int)((64 - 12) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 12) % 8)] & (S[(signed long int)((65 - 12) % 8)] | S[(signed long int)((66 - 12) % 8)]) | S[(signed long int)((65 - 12) % 8)] & S[(signed long int)((66 - 12) % 8)]);
  S[(signed long int)((67 - 12) % 8)] = S[(signed long int)((67 - 12) % 8)] + t0;
  S[(signed long int)((71 - 12) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 13) % 8)] + ((S[(signed long int)((68 - 13) % 8)] >> 6 | S[(signed long int)((68 - 13) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 13) % 8)] >> 11 | S[(signed long int)((68 - 13) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 13) % 8)] >> 25 | S[(signed long int)((68 - 13) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 13) % 8)] & (S[(signed long int)((69 - 13) % 8)] ^ S[(signed long int)((70 - 13) % 8)]) ^ S[(signed long int)((70 - 13) % 8)]) + W[(signed long int)13] + 0x80deb1fe;
  t1 = ((S[(signed long int)((64 - 13) % 8)] >> 2 | S[(signed long int)((64 - 13) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 13) % 8)] >> 13 | S[(signed long int)((64 - 13) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 13) % 8)] >> 22 | S[(signed long int)((64 - 13) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 13) % 8)] & (S[(signed long int)((65 - 13) % 8)] | S[(signed long int)((66 - 13) % 8)]) | S[(signed long int)((65 - 13) % 8)] & S[(signed long int)((66 - 13) % 8)]);
  S[(signed long int)((67 - 13) % 8)] = S[(signed long int)((67 - 13) % 8)] + t0;
  S[(signed long int)((71 - 13) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 14) % 8)] + ((S[(signed long int)((68 - 14) % 8)] >> 6 | S[(signed long int)((68 - 14) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 14) % 8)] >> 11 | S[(signed long int)((68 - 14) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 14) % 8)] >> 25 | S[(signed long int)((68 - 14) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 14) % 8)] & (S[(signed long int)((69 - 14) % 8)] ^ S[(signed long int)((70 - 14) % 8)]) ^ S[(signed long int)((70 - 14) % 8)]) + W[(signed long int)14] + 0x9bdc06a7;
  t1 = ((S[(signed long int)((64 - 14) % 8)] >> 2 | S[(signed long int)((64 - 14) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 14) % 8)] >> 13 | S[(signed long int)((64 - 14) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 14) % 8)] >> 22 | S[(signed long int)((64 - 14) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 14) % 8)] & (S[(signed long int)((65 - 14) % 8)] | S[(signed long int)((66 - 14) % 8)]) | S[(signed long int)((65 - 14) % 8)] & S[(signed long int)((66 - 14) % 8)]);
  S[(signed long int)((67 - 14) % 8)] = S[(signed long int)((67 - 14) % 8)] + t0;
  S[(signed long int)((71 - 14) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 15) % 8)] + ((S[(signed long int)((68 - 15) % 8)] >> 6 | S[(signed long int)((68 - 15) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 15) % 8)] >> 11 | S[(signed long int)((68 - 15) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 15) % 8)] >> 25 | S[(signed long int)((68 - 15) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 15) % 8)] & (S[(signed long int)((69 - 15) % 8)] ^ S[(signed long int)((70 - 15) % 8)]) ^ S[(signed long int)((70 - 15) % 8)]) + W[(signed long int)15] + 0xc19bf174;
  t1 = ((S[(signed long int)((64 - 15) % 8)] >> 2 | S[(signed long int)((64 - 15) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 15) % 8)] >> 13 | S[(signed long int)((64 - 15) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 15) % 8)] >> 22 | S[(signed long int)((64 - 15) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 15) % 8)] & (S[(signed long int)((65 - 15) % 8)] | S[(signed long int)((66 - 15) % 8)]) | S[(signed long int)((65 - 15) % 8)] & S[(signed long int)((66 - 15) % 8)]);
  S[(signed long int)((67 - 15) % 8)] = S[(signed long int)((67 - 15) % 8)] + t0;
  S[(signed long int)((71 - 15) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 16) % 8)] + ((S[(signed long int)((68 - 16) % 8)] >> 6 | S[(signed long int)((68 - 16) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 16) % 8)] >> 11 | S[(signed long int)((68 - 16) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 16) % 8)] >> 25 | S[(signed long int)((68 - 16) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 16) % 8)] & (S[(signed long int)((69 - 16) % 8)] ^ S[(signed long int)((70 - 16) % 8)]) ^ S[(signed long int)((70 - 16) % 8)]) + W[(signed long int)16] + 0xe49b69c1;
  t1 = ((S[(signed long int)((64 - 16) % 8)] >> 2 | S[(signed long int)((64 - 16) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 16) % 8)] >> 13 | S[(signed long int)((64 - 16) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 16) % 8)] >> 22 | S[(signed long int)((64 - 16) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 16) % 8)] & (S[(signed long int)((65 - 16) % 8)] | S[(signed long int)((66 - 16) % 8)]) | S[(signed long int)((65 - 16) % 8)] & S[(signed long int)((66 - 16) % 8)]);
  S[(signed long int)((67 - 16) % 8)] = S[(signed long int)((67 - 16) % 8)] + t0;
  S[(signed long int)((71 - 16) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 17) % 8)] + ((S[(signed long int)((68 - 17) % 8)] >> 6 | S[(signed long int)((68 - 17) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 17) % 8)] >> 11 | S[(signed long int)((68 - 17) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 17) % 8)] >> 25 | S[(signed long int)((68 - 17) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 17) % 8)] & (S[(signed long int)((69 - 17) % 8)] ^ S[(signed long int)((70 - 17) % 8)]) ^ S[(signed long int)((70 - 17) % 8)]) + W[(signed long int)17] + 0xefbe4786;
  t1 = ((S[(signed long int)((64 - 17) % 8)] >> 2 | S[(signed long int)((64 - 17) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 17) % 8)] >> 13 | S[(signed long int)((64 - 17) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 17) % 8)] >> 22 | S[(signed long int)((64 - 17) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 17) % 8)] & (S[(signed long int)((65 - 17) % 8)] | S[(signed long int)((66 - 17) % 8)]) | S[(signed long int)((65 - 17) % 8)] & S[(signed long int)((66 - 17) % 8)]);
  S[(signed long int)((67 - 17) % 8)] = S[(signed long int)((67 - 17) % 8)] + t0;
  S[(signed long int)((71 - 17) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 18) % 8)] + ((S[(signed long int)((68 - 18) % 8)] >> 6 | S[(signed long int)((68 - 18) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 18) % 8)] >> 11 | S[(signed long int)((68 - 18) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 18) % 8)] >> 25 | S[(signed long int)((68 - 18) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 18) % 8)] & (S[(signed long int)((69 - 18) % 8)] ^ S[(signed long int)((70 - 18) % 8)]) ^ S[(signed long int)((70 - 18) % 8)]) + W[(signed long int)18] + (unsigned int)0x0fc19dc6;
  t1 = ((S[(signed long int)((64 - 18) % 8)] >> 2 | S[(signed long int)((64 - 18) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 18) % 8)] >> 13 | S[(signed long int)((64 - 18) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 18) % 8)] >> 22 | S[(signed long int)((64 - 18) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 18) % 8)] & (S[(signed long int)((65 - 18) % 8)] | S[(signed long int)((66 - 18) % 8)]) | S[(signed long int)((65 - 18) % 8)] & S[(signed long int)((66 - 18) % 8)]);
  S[(signed long int)((67 - 18) % 8)] = S[(signed long int)((67 - 18) % 8)] + t0;
  S[(signed long int)((71 - 18) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 19) % 8)] + ((S[(signed long int)((68 - 19) % 8)] >> 6 | S[(signed long int)((68 - 19) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 19) % 8)] >> 11 | S[(signed long int)((68 - 19) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 19) % 8)] >> 25 | S[(signed long int)((68 - 19) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 19) % 8)] & (S[(signed long int)((69 - 19) % 8)] ^ S[(signed long int)((70 - 19) % 8)]) ^ S[(signed long int)((70 - 19) % 8)]) + W[(signed long int)19] + (unsigned int)0x240ca1cc;
  t1 = ((S[(signed long int)((64 - 19) % 8)] >> 2 | S[(signed long int)((64 - 19) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 19) % 8)] >> 13 | S[(signed long int)((64 - 19) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 19) % 8)] >> 22 | S[(signed long int)((64 - 19) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 19) % 8)] & (S[(signed long int)((65 - 19) % 8)] | S[(signed long int)((66 - 19) % 8)]) | S[(signed long int)((65 - 19) % 8)] & S[(signed long int)((66 - 19) % 8)]);
  S[(signed long int)((67 - 19) % 8)] = S[(signed long int)((67 - 19) % 8)] + t0;
  S[(signed long int)((71 - 19) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 20) % 8)] + ((S[(signed long int)((68 - 20) % 8)] >> 6 | S[(signed long int)((68 - 20) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 20) % 8)] >> 11 | S[(signed long int)((68 - 20) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 20) % 8)] >> 25 | S[(signed long int)((68 - 20) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 20) % 8)] & (S[(signed long int)((69 - 20) % 8)] ^ S[(signed long int)((70 - 20) % 8)]) ^ S[(signed long int)((70 - 20) % 8)]) + W[(signed long int)20] + (unsigned int)0x2de92c6f;
  t1 = ((S[(signed long int)((64 - 20) % 8)] >> 2 | S[(signed long int)((64 - 20) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 20) % 8)] >> 13 | S[(signed long int)((64 - 20) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 20) % 8)] >> 22 | S[(signed long int)((64 - 20) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 20) % 8)] & (S[(signed long int)((65 - 20) % 8)] | S[(signed long int)((66 - 20) % 8)]) | S[(signed long int)((65 - 20) % 8)] & S[(signed long int)((66 - 20) % 8)]);
  S[(signed long int)((67 - 20) % 8)] = S[(signed long int)((67 - 20) % 8)] + t0;
  S[(signed long int)((71 - 20) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 21) % 8)] + ((S[(signed long int)((68 - 21) % 8)] >> 6 | S[(signed long int)((68 - 21) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 21) % 8)] >> 11 | S[(signed long int)((68 - 21) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 21) % 8)] >> 25 | S[(signed long int)((68 - 21) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 21) % 8)] & (S[(signed long int)((69 - 21) % 8)] ^ S[(signed long int)((70 - 21) % 8)]) ^ S[(signed long int)((70 - 21) % 8)]) + W[(signed long int)21] + (unsigned int)0x4a7484aa;
  t1 = ((S[(signed long int)((64 - 21) % 8)] >> 2 | S[(signed long int)((64 - 21) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 21) % 8)] >> 13 | S[(signed long int)((64 - 21) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 21) % 8)] >> 22 | S[(signed long int)((64 - 21) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 21) % 8)] & (S[(signed long int)((65 - 21) % 8)] | S[(signed long int)((66 - 21) % 8)]) | S[(signed long int)((65 - 21) % 8)] & S[(signed long int)((66 - 21) % 8)]);
  S[(signed long int)((67 - 21) % 8)] = S[(signed long int)((67 - 21) % 8)] + t0;
  S[(signed long int)((71 - 21) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 22) % 8)] + ((S[(signed long int)((68 - 22) % 8)] >> 6 | S[(signed long int)((68 - 22) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 22) % 8)] >> 11 | S[(signed long int)((68 - 22) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 22) % 8)] >> 25 | S[(signed long int)((68 - 22) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 22) % 8)] & (S[(signed long int)((69 - 22) % 8)] ^ S[(signed long int)((70 - 22) % 8)]) ^ S[(signed long int)((70 - 22) % 8)]) + W[(signed long int)22] + (unsigned int)0x5cb0a9dc;
  t1 = ((S[(signed long int)((64 - 22) % 8)] >> 2 | S[(signed long int)((64 - 22) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 22) % 8)] >> 13 | S[(signed long int)((64 - 22) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 22) % 8)] >> 22 | S[(signed long int)((64 - 22) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 22) % 8)] & (S[(signed long int)((65 - 22) % 8)] | S[(signed long int)((66 - 22) % 8)]) | S[(signed long int)((65 - 22) % 8)] & S[(signed long int)((66 - 22) % 8)]);
  S[(signed long int)((67 - 22) % 8)] = S[(signed long int)((67 - 22) % 8)] + t0;
  S[(signed long int)((71 - 22) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 23) % 8)] + ((S[(signed long int)((68 - 23) % 8)] >> 6 | S[(signed long int)((68 - 23) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 23) % 8)] >> 11 | S[(signed long int)((68 - 23) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 23) % 8)] >> 25 | S[(signed long int)((68 - 23) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 23) % 8)] & (S[(signed long int)((69 - 23) % 8)] ^ S[(signed long int)((70 - 23) % 8)]) ^ S[(signed long int)((70 - 23) % 8)]) + W[(signed long int)23] + (unsigned int)0x76f988da;
  t1 = ((S[(signed long int)((64 - 23) % 8)] >> 2 | S[(signed long int)((64 - 23) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 23) % 8)] >> 13 | S[(signed long int)((64 - 23) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 23) % 8)] >> 22 | S[(signed long int)((64 - 23) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 23) % 8)] & (S[(signed long int)((65 - 23) % 8)] | S[(signed long int)((66 - 23) % 8)]) | S[(signed long int)((65 - 23) % 8)] & S[(signed long int)((66 - 23) % 8)]);
  S[(signed long int)((67 - 23) % 8)] = S[(signed long int)((67 - 23) % 8)] + t0;
  S[(signed long int)((71 - 23) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 24) % 8)] + ((S[(signed long int)((68 - 24) % 8)] >> 6 | S[(signed long int)((68 - 24) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 24) % 8)] >> 11 | S[(signed long int)((68 - 24) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 24) % 8)] >> 25 | S[(signed long int)((68 - 24) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 24) % 8)] & (S[(signed long int)((69 - 24) % 8)] ^ S[(signed long int)((70 - 24) % 8)]) ^ S[(signed long int)((70 - 24) % 8)]) + W[(signed long int)24] + 0x983e5152;
  t1 = ((S[(signed long int)((64 - 24) % 8)] >> 2 | S[(signed long int)((64 - 24) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 24) % 8)] >> 13 | S[(signed long int)((64 - 24) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 24) % 8)] >> 22 | S[(signed long int)((64 - 24) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 24) % 8)] & (S[(signed long int)((65 - 24) % 8)] | S[(signed long int)((66 - 24) % 8)]) | S[(signed long int)((65 - 24) % 8)] & S[(signed long int)((66 - 24) % 8)]);
  S[(signed long int)((67 - 24) % 8)] = S[(signed long int)((67 - 24) % 8)] + t0;
  S[(signed long int)((71 - 24) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 25) % 8)] + ((S[(signed long int)((68 - 25) % 8)] >> 6 | S[(signed long int)((68 - 25) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 25) % 8)] >> 11 | S[(signed long int)((68 - 25) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 25) % 8)] >> 25 | S[(signed long int)((68 - 25) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 25) % 8)] & (S[(signed long int)((69 - 25) % 8)] ^ S[(signed long int)((70 - 25) % 8)]) ^ S[(signed long int)((70 - 25) % 8)]) + W[(signed long int)25] + 0xa831c66d;
  t1 = ((S[(signed long int)((64 - 25) % 8)] >> 2 | S[(signed long int)((64 - 25) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 25) % 8)] >> 13 | S[(signed long int)((64 - 25) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 25) % 8)] >> 22 | S[(signed long int)((64 - 25) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 25) % 8)] & (S[(signed long int)((65 - 25) % 8)] | S[(signed long int)((66 - 25) % 8)]) | S[(signed long int)((65 - 25) % 8)] & S[(signed long int)((66 - 25) % 8)]);
  S[(signed long int)((67 - 25) % 8)] = S[(signed long int)((67 - 25) % 8)] + t0;
  S[(signed long int)((71 - 25) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 26) % 8)] + ((S[(signed long int)((68 - 26) % 8)] >> 6 | S[(signed long int)((68 - 26) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 26) % 8)] >> 11 | S[(signed long int)((68 - 26) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 26) % 8)] >> 25 | S[(signed long int)((68 - 26) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 26) % 8)] & (S[(signed long int)((69 - 26) % 8)] ^ S[(signed long int)((70 - 26) % 8)]) ^ S[(signed long int)((70 - 26) % 8)]) + W[(signed long int)26] + 0xb00327c8;
  t1 = ((S[(signed long int)((64 - 26) % 8)] >> 2 | S[(signed long int)((64 - 26) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 26) % 8)] >> 13 | S[(signed long int)((64 - 26) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 26) % 8)] >> 22 | S[(signed long int)((64 - 26) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 26) % 8)] & (S[(signed long int)((65 - 26) % 8)] | S[(signed long int)((66 - 26) % 8)]) | S[(signed long int)((65 - 26) % 8)] & S[(signed long int)((66 - 26) % 8)]);
  S[(signed long int)((67 - 26) % 8)] = S[(signed long int)((67 - 26) % 8)] + t0;
  S[(signed long int)((71 - 26) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 27) % 8)] + ((S[(signed long int)((68 - 27) % 8)] >> 6 | S[(signed long int)((68 - 27) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 27) % 8)] >> 11 | S[(signed long int)((68 - 27) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 27) % 8)] >> 25 | S[(signed long int)((68 - 27) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 27) % 8)] & (S[(signed long int)((69 - 27) % 8)] ^ S[(signed long int)((70 - 27) % 8)]) ^ S[(signed long int)((70 - 27) % 8)]) + W[(signed long int)27] + 0xbf597fc7;
  t1 = ((S[(signed long int)((64 - 27) % 8)] >> 2 | S[(signed long int)((64 - 27) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 27) % 8)] >> 13 | S[(signed long int)((64 - 27) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 27) % 8)] >> 22 | S[(signed long int)((64 - 27) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 27) % 8)] & (S[(signed long int)((65 - 27) % 8)] | S[(signed long int)((66 - 27) % 8)]) | S[(signed long int)((65 - 27) % 8)] & S[(signed long int)((66 - 27) % 8)]);
  S[(signed long int)((67 - 27) % 8)] = S[(signed long int)((67 - 27) % 8)] + t0;
  S[(signed long int)((71 - 27) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 28) % 8)] + ((S[(signed long int)((68 - 28) % 8)] >> 6 | S[(signed long int)((68 - 28) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 28) % 8)] >> 11 | S[(signed long int)((68 - 28) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 28) % 8)] >> 25 | S[(signed long int)((68 - 28) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 28) % 8)] & (S[(signed long int)((69 - 28) % 8)] ^ S[(signed long int)((70 - 28) % 8)]) ^ S[(signed long int)((70 - 28) % 8)]) + W[(signed long int)28] + 0xc6e00bf3;
  t1 = ((S[(signed long int)((64 - 28) % 8)] >> 2 | S[(signed long int)((64 - 28) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 28) % 8)] >> 13 | S[(signed long int)((64 - 28) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 28) % 8)] >> 22 | S[(signed long int)((64 - 28) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 28) % 8)] & (S[(signed long int)((65 - 28) % 8)] | S[(signed long int)((66 - 28) % 8)]) | S[(signed long int)((65 - 28) % 8)] & S[(signed long int)((66 - 28) % 8)]);
  S[(signed long int)((67 - 28) % 8)] = S[(signed long int)((67 - 28) % 8)] + t0;
  S[(signed long int)((71 - 28) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 29) % 8)] + ((S[(signed long int)((68 - 29) % 8)] >> 6 | S[(signed long int)((68 - 29) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 29) % 8)] >> 11 | S[(signed long int)((68 - 29) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 29) % 8)] >> 25 | S[(signed long int)((68 - 29) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 29) % 8)] & (S[(signed long int)((69 - 29) % 8)] ^ S[(signed long int)((70 - 29) % 8)]) ^ S[(signed long int)((70 - 29) % 8)]) + W[(signed long int)29] + 0xd5a79147;
  t1 = ((S[(signed long int)((64 - 29) % 8)] >> 2 | S[(signed long int)((64 - 29) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 29) % 8)] >> 13 | S[(signed long int)((64 - 29) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 29) % 8)] >> 22 | S[(signed long int)((64 - 29) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 29) % 8)] & (S[(signed long int)((65 - 29) % 8)] | S[(signed long int)((66 - 29) % 8)]) | S[(signed long int)((65 - 29) % 8)] & S[(signed long int)((66 - 29) % 8)]);
  S[(signed long int)((67 - 29) % 8)] = S[(signed long int)((67 - 29) % 8)] + t0;
  S[(signed long int)((71 - 29) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 30) % 8)] + ((S[(signed long int)((68 - 30) % 8)] >> 6 | S[(signed long int)((68 - 30) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 30) % 8)] >> 11 | S[(signed long int)((68 - 30) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 30) % 8)] >> 25 | S[(signed long int)((68 - 30) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 30) % 8)] & (S[(signed long int)((69 - 30) % 8)] ^ S[(signed long int)((70 - 30) % 8)]) ^ S[(signed long int)((70 - 30) % 8)]) + W[(signed long int)30] + (unsigned int)0x06ca6351;
  t1 = ((S[(signed long int)((64 - 30) % 8)] >> 2 | S[(signed long int)((64 - 30) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 30) % 8)] >> 13 | S[(signed long int)((64 - 30) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 30) % 8)] >> 22 | S[(signed long int)((64 - 30) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 30) % 8)] & (S[(signed long int)((65 - 30) % 8)] | S[(signed long int)((66 - 30) % 8)]) | S[(signed long int)((65 - 30) % 8)] & S[(signed long int)((66 - 30) % 8)]);
  S[(signed long int)((67 - 30) % 8)] = S[(signed long int)((67 - 30) % 8)] + t0;
  S[(signed long int)((71 - 30) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 31) % 8)] + ((S[(signed long int)((68 - 31) % 8)] >> 6 | S[(signed long int)((68 - 31) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 31) % 8)] >> 11 | S[(signed long int)((68 - 31) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 31) % 8)] >> 25 | S[(signed long int)((68 - 31) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 31) % 8)] & (S[(signed long int)((69 - 31) % 8)] ^ S[(signed long int)((70 - 31) % 8)]) ^ S[(signed long int)((70 - 31) % 8)]) + W[(signed long int)31] + (unsigned int)0x14292967;
  t1 = ((S[(signed long int)((64 - 31) % 8)] >> 2 | S[(signed long int)((64 - 31) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 31) % 8)] >> 13 | S[(signed long int)((64 - 31) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 31) % 8)] >> 22 | S[(signed long int)((64 - 31) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 31) % 8)] & (S[(signed long int)((65 - 31) % 8)] | S[(signed long int)((66 - 31) % 8)]) | S[(signed long int)((65 - 31) % 8)] & S[(signed long int)((66 - 31) % 8)]);
  S[(signed long int)((67 - 31) % 8)] = S[(signed long int)((67 - 31) % 8)] + t0;
  S[(signed long int)((71 - 31) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 32) % 8)] + ((S[(signed long int)((68 - 32) % 8)] >> 6 | S[(signed long int)((68 - 32) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 32) % 8)] >> 11 | S[(signed long int)((68 - 32) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 32) % 8)] >> 25 | S[(signed long int)((68 - 32) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 32) % 8)] & (S[(signed long int)((69 - 32) % 8)] ^ S[(signed long int)((70 - 32) % 8)]) ^ S[(signed long int)((70 - 32) % 8)]) + W[(signed long int)32] + (unsigned int)0x27b70a85;
  t1 = ((S[(signed long int)((64 - 32) % 8)] >> 2 | S[(signed long int)((64 - 32) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 32) % 8)] >> 13 | S[(signed long int)((64 - 32) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 32) % 8)] >> 22 | S[(signed long int)((64 - 32) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 32) % 8)] & (S[(signed long int)((65 - 32) % 8)] | S[(signed long int)((66 - 32) % 8)]) | S[(signed long int)((65 - 32) % 8)] & S[(signed long int)((66 - 32) % 8)]);
  S[(signed long int)((67 - 32) % 8)] = S[(signed long int)((67 - 32) % 8)] + t0;
  S[(signed long int)((71 - 32) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 33) % 8)] + ((S[(signed long int)((68 - 33) % 8)] >> 6 | S[(signed long int)((68 - 33) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 33) % 8)] >> 11 | S[(signed long int)((68 - 33) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 33) % 8)] >> 25 | S[(signed long int)((68 - 33) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 33) % 8)] & (S[(signed long int)((69 - 33) % 8)] ^ S[(signed long int)((70 - 33) % 8)]) ^ S[(signed long int)((70 - 33) % 8)]) + W[(signed long int)33] + (unsigned int)0x2e1b2138;
  t1 = ((S[(signed long int)((64 - 33) % 8)] >> 2 | S[(signed long int)((64 - 33) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 33) % 8)] >> 13 | S[(signed long int)((64 - 33) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 33) % 8)] >> 22 | S[(signed long int)((64 - 33) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 33) % 8)] & (S[(signed long int)((65 - 33) % 8)] | S[(signed long int)((66 - 33) % 8)]) | S[(signed long int)((65 - 33) % 8)] & S[(signed long int)((66 - 33) % 8)]);
  S[(signed long int)((67 - 33) % 8)] = S[(signed long int)((67 - 33) % 8)] + t0;
  S[(signed long int)((71 - 33) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 34) % 8)] + ((S[(signed long int)((68 - 34) % 8)] >> 6 | S[(signed long int)((68 - 34) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 34) % 8)] >> 11 | S[(signed long int)((68 - 34) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 34) % 8)] >> 25 | S[(signed long int)((68 - 34) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 34) % 8)] & (S[(signed long int)((69 - 34) % 8)] ^ S[(signed long int)((70 - 34) % 8)]) ^ S[(signed long int)((70 - 34) % 8)]) + W[(signed long int)34] + (unsigned int)0x4d2c6dfc;
  t1 = ((S[(signed long int)((64 - 34) % 8)] >> 2 | S[(signed long int)((64 - 34) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 34) % 8)] >> 13 | S[(signed long int)((64 - 34) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 34) % 8)] >> 22 | S[(signed long int)((64 - 34) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 34) % 8)] & (S[(signed long int)((65 - 34) % 8)] | S[(signed long int)((66 - 34) % 8)]) | S[(signed long int)((65 - 34) % 8)] & S[(signed long int)((66 - 34) % 8)]);
  S[(signed long int)((67 - 34) % 8)] = S[(signed long int)((67 - 34) % 8)] + t0;
  S[(signed long int)((71 - 34) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 35) % 8)] + ((S[(signed long int)((68 - 35) % 8)] >> 6 | S[(signed long int)((68 - 35) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 35) % 8)] >> 11 | S[(signed long int)((68 - 35) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 35) % 8)] >> 25 | S[(signed long int)((68 - 35) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 35) % 8)] & (S[(signed long int)((69 - 35) % 8)] ^ S[(signed long int)((70 - 35) % 8)]) ^ S[(signed long int)((70 - 35) % 8)]) + W[(signed long int)35] + (unsigned int)0x53380d13;
  t1 = ((S[(signed long int)((64 - 35) % 8)] >> 2 | S[(signed long int)((64 - 35) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 35) % 8)] >> 13 | S[(signed long int)((64 - 35) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 35) % 8)] >> 22 | S[(signed long int)((64 - 35) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 35) % 8)] & (S[(signed long int)((65 - 35) % 8)] | S[(signed long int)((66 - 35) % 8)]) | S[(signed long int)((65 - 35) % 8)] & S[(signed long int)((66 - 35) % 8)]);
  S[(signed long int)((67 - 35) % 8)] = S[(signed long int)((67 - 35) % 8)] + t0;
  S[(signed long int)((71 - 35) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 36) % 8)] + ((S[(signed long int)((68 - 36) % 8)] >> 6 | S[(signed long int)((68 - 36) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 36) % 8)] >> 11 | S[(signed long int)((68 - 36) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 36) % 8)] >> 25 | S[(signed long int)((68 - 36) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 36) % 8)] & (S[(signed long int)((69 - 36) % 8)] ^ S[(signed long int)((70 - 36) % 8)]) ^ S[(signed long int)((70 - 36) % 8)]) + W[(signed long int)36] + (unsigned int)0x650a7354;
  t1 = ((S[(signed long int)((64 - 36) % 8)] >> 2 | S[(signed long int)((64 - 36) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 36) % 8)] >> 13 | S[(signed long int)((64 - 36) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 36) % 8)] >> 22 | S[(signed long int)((64 - 36) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 36) % 8)] & (S[(signed long int)((65 - 36) % 8)] | S[(signed long int)((66 - 36) % 8)]) | S[(signed long int)((65 - 36) % 8)] & S[(signed long int)((66 - 36) % 8)]);
  S[(signed long int)((67 - 36) % 8)] = S[(signed long int)((67 - 36) % 8)] + t0;
  S[(signed long int)((71 - 36) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 37) % 8)] + ((S[(signed long int)((68 - 37) % 8)] >> 6 | S[(signed long int)((68 - 37) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 37) % 8)] >> 11 | S[(signed long int)((68 - 37) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 37) % 8)] >> 25 | S[(signed long int)((68 - 37) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 37) % 8)] & (S[(signed long int)((69 - 37) % 8)] ^ S[(signed long int)((70 - 37) % 8)]) ^ S[(signed long int)((70 - 37) % 8)]) + W[(signed long int)37] + (unsigned int)0x766a0abb;
  t1 = ((S[(signed long int)((64 - 37) % 8)] >> 2 | S[(signed long int)((64 - 37) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 37) % 8)] >> 13 | S[(signed long int)((64 - 37) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 37) % 8)] >> 22 | S[(signed long int)((64 - 37) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 37) % 8)] & (S[(signed long int)((65 - 37) % 8)] | S[(signed long int)((66 - 37) % 8)]) | S[(signed long int)((65 - 37) % 8)] & S[(signed long int)((66 - 37) % 8)]);
  S[(signed long int)((67 - 37) % 8)] = S[(signed long int)((67 - 37) % 8)] + t0;
  S[(signed long int)((71 - 37) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 38) % 8)] + ((S[(signed long int)((68 - 38) % 8)] >> 6 | S[(signed long int)((68 - 38) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 38) % 8)] >> 11 | S[(signed long int)((68 - 38) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 38) % 8)] >> 25 | S[(signed long int)((68 - 38) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 38) % 8)] & (S[(signed long int)((69 - 38) % 8)] ^ S[(signed long int)((70 - 38) % 8)]) ^ S[(signed long int)((70 - 38) % 8)]) + W[(signed long int)38] + 0x81c2c92e;
  t1 = ((S[(signed long int)((64 - 38) % 8)] >> 2 | S[(signed long int)((64 - 38) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 38) % 8)] >> 13 | S[(signed long int)((64 - 38) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 38) % 8)] >> 22 | S[(signed long int)((64 - 38) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 38) % 8)] & (S[(signed long int)((65 - 38) % 8)] | S[(signed long int)((66 - 38) % 8)]) | S[(signed long int)((65 - 38) % 8)] & S[(signed long int)((66 - 38) % 8)]);
  S[(signed long int)((67 - 38) % 8)] = S[(signed long int)((67 - 38) % 8)] + t0;
  S[(signed long int)((71 - 38) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 39) % 8)] + ((S[(signed long int)((68 - 39) % 8)] >> 6 | S[(signed long int)((68 - 39) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 39) % 8)] >> 11 | S[(signed long int)((68 - 39) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 39) % 8)] >> 25 | S[(signed long int)((68 - 39) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 39) % 8)] & (S[(signed long int)((69 - 39) % 8)] ^ S[(signed long int)((70 - 39) % 8)]) ^ S[(signed long int)((70 - 39) % 8)]) + W[(signed long int)39] + 0x92722c85;
  t1 = ((S[(signed long int)((64 - 39) % 8)] >> 2 | S[(signed long int)((64 - 39) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 39) % 8)] >> 13 | S[(signed long int)((64 - 39) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 39) % 8)] >> 22 | S[(signed long int)((64 - 39) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 39) % 8)] & (S[(signed long int)((65 - 39) % 8)] | S[(signed long int)((66 - 39) % 8)]) | S[(signed long int)((65 - 39) % 8)] & S[(signed long int)((66 - 39) % 8)]);
  S[(signed long int)((67 - 39) % 8)] = S[(signed long int)((67 - 39) % 8)] + t0;
  S[(signed long int)((71 - 39) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 40) % 8)] + ((S[(signed long int)((68 - 40) % 8)] >> 6 | S[(signed long int)((68 - 40) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 40) % 8)] >> 11 | S[(signed long int)((68 - 40) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 40) % 8)] >> 25 | S[(signed long int)((68 - 40) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 40) % 8)] & (S[(signed long int)((69 - 40) % 8)] ^ S[(signed long int)((70 - 40) % 8)]) ^ S[(signed long int)((70 - 40) % 8)]) + W[(signed long int)40] + 0xa2bfe8a1;
  t1 = ((S[(signed long int)((64 - 40) % 8)] >> 2 | S[(signed long int)((64 - 40) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 40) % 8)] >> 13 | S[(signed long int)((64 - 40) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 40) % 8)] >> 22 | S[(signed long int)((64 - 40) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 40) % 8)] & (S[(signed long int)((65 - 40) % 8)] | S[(signed long int)((66 - 40) % 8)]) | S[(signed long int)((65 - 40) % 8)] & S[(signed long int)((66 - 40) % 8)]);
  S[(signed long int)((67 - 40) % 8)] = S[(signed long int)((67 - 40) % 8)] + t0;
  S[(signed long int)((71 - 40) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 41) % 8)] + ((S[(signed long int)((68 - 41) % 8)] >> 6 | S[(signed long int)((68 - 41) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 41) % 8)] >> 11 | S[(signed long int)((68 - 41) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 41) % 8)] >> 25 | S[(signed long int)((68 - 41) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 41) % 8)] & (S[(signed long int)((69 - 41) % 8)] ^ S[(signed long int)((70 - 41) % 8)]) ^ S[(signed long int)((70 - 41) % 8)]) + W[(signed long int)41] + 0xa81a664b;
  t1 = ((S[(signed long int)((64 - 41) % 8)] >> 2 | S[(signed long int)((64 - 41) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 41) % 8)] >> 13 | S[(signed long int)((64 - 41) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 41) % 8)] >> 22 | S[(signed long int)((64 - 41) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 41) % 8)] & (S[(signed long int)((65 - 41) % 8)] | S[(signed long int)((66 - 41) % 8)]) | S[(signed long int)((65 - 41) % 8)] & S[(signed long int)((66 - 41) % 8)]);
  S[(signed long int)((67 - 41) % 8)] = S[(signed long int)((67 - 41) % 8)] + t0;
  S[(signed long int)((71 - 41) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 42) % 8)] + ((S[(signed long int)((68 - 42) % 8)] >> 6 | S[(signed long int)((68 - 42) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 42) % 8)] >> 11 | S[(signed long int)((68 - 42) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 42) % 8)] >> 25 | S[(signed long int)((68 - 42) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 42) % 8)] & (S[(signed long int)((69 - 42) % 8)] ^ S[(signed long int)((70 - 42) % 8)]) ^ S[(signed long int)((70 - 42) % 8)]) + W[(signed long int)42] + 0xc24b8b70;
  t1 = ((S[(signed long int)((64 - 42) % 8)] >> 2 | S[(signed long int)((64 - 42) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 42) % 8)] >> 13 | S[(signed long int)((64 - 42) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 42) % 8)] >> 22 | S[(signed long int)((64 - 42) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 42) % 8)] & (S[(signed long int)((65 - 42) % 8)] | S[(signed long int)((66 - 42) % 8)]) | S[(signed long int)((65 - 42) % 8)] & S[(signed long int)((66 - 42) % 8)]);
  S[(signed long int)((67 - 42) % 8)] = S[(signed long int)((67 - 42) % 8)] + t0;
  S[(signed long int)((71 - 42) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 43) % 8)] + ((S[(signed long int)((68 - 43) % 8)] >> 6 | S[(signed long int)((68 - 43) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 43) % 8)] >> 11 | S[(signed long int)((68 - 43) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 43) % 8)] >> 25 | S[(signed long int)((68 - 43) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 43) % 8)] & (S[(signed long int)((69 - 43) % 8)] ^ S[(signed long int)((70 - 43) % 8)]) ^ S[(signed long int)((70 - 43) % 8)]) + W[(signed long int)43] + 0xc76c51a3;
  t1 = ((S[(signed long int)((64 - 43) % 8)] >> 2 | S[(signed long int)((64 - 43) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 43) % 8)] >> 13 | S[(signed long int)((64 - 43) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 43) % 8)] >> 22 | S[(signed long int)((64 - 43) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 43) % 8)] & (S[(signed long int)((65 - 43) % 8)] | S[(signed long int)((66 - 43) % 8)]) | S[(signed long int)((65 - 43) % 8)] & S[(signed long int)((66 - 43) % 8)]);
  S[(signed long int)((67 - 43) % 8)] = S[(signed long int)((67 - 43) % 8)] + t0;
  S[(signed long int)((71 - 43) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 44) % 8)] + ((S[(signed long int)((68 - 44) % 8)] >> 6 | S[(signed long int)((68 - 44) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 44) % 8)] >> 11 | S[(signed long int)((68 - 44) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 44) % 8)] >> 25 | S[(signed long int)((68 - 44) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 44) % 8)] & (S[(signed long int)((69 - 44) % 8)] ^ S[(signed long int)((70 - 44) % 8)]) ^ S[(signed long int)((70 - 44) % 8)]) + W[(signed long int)44] + 0xd192e819;
  t1 = ((S[(signed long int)((64 - 44) % 8)] >> 2 | S[(signed long int)((64 - 44) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 44) % 8)] >> 13 | S[(signed long int)((64 - 44) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 44) % 8)] >> 22 | S[(signed long int)((64 - 44) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 44) % 8)] & (S[(signed long int)((65 - 44) % 8)] | S[(signed long int)((66 - 44) % 8)]) | S[(signed long int)((65 - 44) % 8)] & S[(signed long int)((66 - 44) % 8)]);
  S[(signed long int)((67 - 44) % 8)] = S[(signed long int)((67 - 44) % 8)] + t0;
  S[(signed long int)((71 - 44) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 45) % 8)] + ((S[(signed long int)((68 - 45) % 8)] >> 6 | S[(signed long int)((68 - 45) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 45) % 8)] >> 11 | S[(signed long int)((68 - 45) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 45) % 8)] >> 25 | S[(signed long int)((68 - 45) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 45) % 8)] & (S[(signed long int)((69 - 45) % 8)] ^ S[(signed long int)((70 - 45) % 8)]) ^ S[(signed long int)((70 - 45) % 8)]) + W[(signed long int)45] + 0xd6990624;
  t1 = ((S[(signed long int)((64 - 45) % 8)] >> 2 | S[(signed long int)((64 - 45) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 45) % 8)] >> 13 | S[(signed long int)((64 - 45) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 45) % 8)] >> 22 | S[(signed long int)((64 - 45) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 45) % 8)] & (S[(signed long int)((65 - 45) % 8)] | S[(signed long int)((66 - 45) % 8)]) | S[(signed long int)((65 - 45) % 8)] & S[(signed long int)((66 - 45) % 8)]);
  S[(signed long int)((67 - 45) % 8)] = S[(signed long int)((67 - 45) % 8)] + t0;
  S[(signed long int)((71 - 45) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 46) % 8)] + ((S[(signed long int)((68 - 46) % 8)] >> 6 | S[(signed long int)((68 - 46) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 46) % 8)] >> 11 | S[(signed long int)((68 - 46) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 46) % 8)] >> 25 | S[(signed long int)((68 - 46) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 46) % 8)] & (S[(signed long int)((69 - 46) % 8)] ^ S[(signed long int)((70 - 46) % 8)]) ^ S[(signed long int)((70 - 46) % 8)]) + W[(signed long int)46] + 0xf40e3585;
  t1 = ((S[(signed long int)((64 - 46) % 8)] >> 2 | S[(signed long int)((64 - 46) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 46) % 8)] >> 13 | S[(signed long int)((64 - 46) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 46) % 8)] >> 22 | S[(signed long int)((64 - 46) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 46) % 8)] & (S[(signed long int)((65 - 46) % 8)] | S[(signed long int)((66 - 46) % 8)]) | S[(signed long int)((65 - 46) % 8)] & S[(signed long int)((66 - 46) % 8)]);
  S[(signed long int)((67 - 46) % 8)] = S[(signed long int)((67 - 46) % 8)] + t0;
  S[(signed long int)((71 - 46) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 47) % 8)] + ((S[(signed long int)((68 - 47) % 8)] >> 6 | S[(signed long int)((68 - 47) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 47) % 8)] >> 11 | S[(signed long int)((68 - 47) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 47) % 8)] >> 25 | S[(signed long int)((68 - 47) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 47) % 8)] & (S[(signed long int)((69 - 47) % 8)] ^ S[(signed long int)((70 - 47) % 8)]) ^ S[(signed long int)((70 - 47) % 8)]) + W[(signed long int)47] + (unsigned int)0x106aa070;
  t1 = ((S[(signed long int)((64 - 47) % 8)] >> 2 | S[(signed long int)((64 - 47) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 47) % 8)] >> 13 | S[(signed long int)((64 - 47) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 47) % 8)] >> 22 | S[(signed long int)((64 - 47) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 47) % 8)] & (S[(signed long int)((65 - 47) % 8)] | S[(signed long int)((66 - 47) % 8)]) | S[(signed long int)((65 - 47) % 8)] & S[(signed long int)((66 - 47) % 8)]);
  S[(signed long int)((67 - 47) % 8)] = S[(signed long int)((67 - 47) % 8)] + t0;
  S[(signed long int)((71 - 47) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 48) % 8)] + ((S[(signed long int)((68 - 48) % 8)] >> 6 | S[(signed long int)((68 - 48) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 48) % 8)] >> 11 | S[(signed long int)((68 - 48) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 48) % 8)] >> 25 | S[(signed long int)((68 - 48) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 48) % 8)] & (S[(signed long int)((69 - 48) % 8)] ^ S[(signed long int)((70 - 48) % 8)]) ^ S[(signed long int)((70 - 48) % 8)]) + W[(signed long int)48] + (unsigned int)0x19a4c116;
  t1 = ((S[(signed long int)((64 - 48) % 8)] >> 2 | S[(signed long int)((64 - 48) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 48) % 8)] >> 13 | S[(signed long int)((64 - 48) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 48) % 8)] >> 22 | S[(signed long int)((64 - 48) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 48) % 8)] & (S[(signed long int)((65 - 48) % 8)] | S[(signed long int)((66 - 48) % 8)]) | S[(signed long int)((65 - 48) % 8)] & S[(signed long int)((66 - 48) % 8)]);
  S[(signed long int)((67 - 48) % 8)] = S[(signed long int)((67 - 48) % 8)] + t0;
  S[(signed long int)((71 - 48) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 49) % 8)] + ((S[(signed long int)((68 - 49) % 8)] >> 6 | S[(signed long int)((68 - 49) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 49) % 8)] >> 11 | S[(signed long int)((68 - 49) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 49) % 8)] >> 25 | S[(signed long int)((68 - 49) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 49) % 8)] & (S[(signed long int)((69 - 49) % 8)] ^ S[(signed long int)((70 - 49) % 8)]) ^ S[(signed long int)((70 - 49) % 8)]) + W[(signed long int)49] + (unsigned int)0x1e376c08;
  t1 = ((S[(signed long int)((64 - 49) % 8)] >> 2 | S[(signed long int)((64 - 49) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 49) % 8)] >> 13 | S[(signed long int)((64 - 49) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 49) % 8)] >> 22 | S[(signed long int)((64 - 49) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 49) % 8)] & (S[(signed long int)((65 - 49) % 8)] | S[(signed long int)((66 - 49) % 8)]) | S[(signed long int)((65 - 49) % 8)] & S[(signed long int)((66 - 49) % 8)]);
  S[(signed long int)((67 - 49) % 8)] = S[(signed long int)((67 - 49) % 8)] + t0;
  S[(signed long int)((71 - 49) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 50) % 8)] + ((S[(signed long int)((68 - 50) % 8)] >> 6 | S[(signed long int)((68 - 50) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 50) % 8)] >> 11 | S[(signed long int)((68 - 50) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 50) % 8)] >> 25 | S[(signed long int)((68 - 50) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 50) % 8)] & (S[(signed long int)((69 - 50) % 8)] ^ S[(signed long int)((70 - 50) % 8)]) ^ S[(signed long int)((70 - 50) % 8)]) + W[(signed long int)50] + (unsigned int)0x2748774c;
  t1 = ((S[(signed long int)((64 - 50) % 8)] >> 2 | S[(signed long int)((64 - 50) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 50) % 8)] >> 13 | S[(signed long int)((64 - 50) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 50) % 8)] >> 22 | S[(signed long int)((64 - 50) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 50) % 8)] & (S[(signed long int)((65 - 50) % 8)] | S[(signed long int)((66 - 50) % 8)]) | S[(signed long int)((65 - 50) % 8)] & S[(signed long int)((66 - 50) % 8)]);
  S[(signed long int)((67 - 50) % 8)] = S[(signed long int)((67 - 50) % 8)] + t0;
  S[(signed long int)((71 - 50) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 51) % 8)] + ((S[(signed long int)((68 - 51) % 8)] >> 6 | S[(signed long int)((68 - 51) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 51) % 8)] >> 11 | S[(signed long int)((68 - 51) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 51) % 8)] >> 25 | S[(signed long int)((68 - 51) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 51) % 8)] & (S[(signed long int)((69 - 51) % 8)] ^ S[(signed long int)((70 - 51) % 8)]) ^ S[(signed long int)((70 - 51) % 8)]) + W[(signed long int)51] + (unsigned int)0x34b0bcb5;
  t1 = ((S[(signed long int)((64 - 51) % 8)] >> 2 | S[(signed long int)((64 - 51) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 51) % 8)] >> 13 | S[(signed long int)((64 - 51) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 51) % 8)] >> 22 | S[(signed long int)((64 - 51) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 51) % 8)] & (S[(signed long int)((65 - 51) % 8)] | S[(signed long int)((66 - 51) % 8)]) | S[(signed long int)((65 - 51) % 8)] & S[(signed long int)((66 - 51) % 8)]);
  S[(signed long int)((67 - 51) % 8)] = S[(signed long int)((67 - 51) % 8)] + t0;
  S[(signed long int)((71 - 51) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 52) % 8)] + ((S[(signed long int)((68 - 52) % 8)] >> 6 | S[(signed long int)((68 - 52) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 52) % 8)] >> 11 | S[(signed long int)((68 - 52) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 52) % 8)] >> 25 | S[(signed long int)((68 - 52) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 52) % 8)] & (S[(signed long int)((69 - 52) % 8)] ^ S[(signed long int)((70 - 52) % 8)]) ^ S[(signed long int)((70 - 52) % 8)]) + W[(signed long int)52] + (unsigned int)0x391c0cb3;
  t1 = ((S[(signed long int)((64 - 52) % 8)] >> 2 | S[(signed long int)((64 - 52) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 52) % 8)] >> 13 | S[(signed long int)((64 - 52) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 52) % 8)] >> 22 | S[(signed long int)((64 - 52) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 52) % 8)] & (S[(signed long int)((65 - 52) % 8)] | S[(signed long int)((66 - 52) % 8)]) | S[(signed long int)((65 - 52) % 8)] & S[(signed long int)((66 - 52) % 8)]);
  S[(signed long int)((67 - 52) % 8)] = S[(signed long int)((67 - 52) % 8)] + t0;
  S[(signed long int)((71 - 52) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 53) % 8)] + ((S[(signed long int)((68 - 53) % 8)] >> 6 | S[(signed long int)((68 - 53) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 53) % 8)] >> 11 | S[(signed long int)((68 - 53) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 53) % 8)] >> 25 | S[(signed long int)((68 - 53) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 53) % 8)] & (S[(signed long int)((69 - 53) % 8)] ^ S[(signed long int)((70 - 53) % 8)]) ^ S[(signed long int)((70 - 53) % 8)]) + W[(signed long int)53] + (unsigned int)0x4ed8aa4a;
  t1 = ((S[(signed long int)((64 - 53) % 8)] >> 2 | S[(signed long int)((64 - 53) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 53) % 8)] >> 13 | S[(signed long int)((64 - 53) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 53) % 8)] >> 22 | S[(signed long int)((64 - 53) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 53) % 8)] & (S[(signed long int)((65 - 53) % 8)] | S[(signed long int)((66 - 53) % 8)]) | S[(signed long int)((65 - 53) % 8)] & S[(signed long int)((66 - 53) % 8)]);
  S[(signed long int)((67 - 53) % 8)] = S[(signed long int)((67 - 53) % 8)] + t0;
  S[(signed long int)((71 - 53) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 54) % 8)] + ((S[(signed long int)((68 - 54) % 8)] >> 6 | S[(signed long int)((68 - 54) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 54) % 8)] >> 11 | S[(signed long int)((68 - 54) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 54) % 8)] >> 25 | S[(signed long int)((68 - 54) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 54) % 8)] & (S[(signed long int)((69 - 54) % 8)] ^ S[(signed long int)((70 - 54) % 8)]) ^ S[(signed long int)((70 - 54) % 8)]) + W[(signed long int)54] + (unsigned int)0x5b9cca4f;
  t1 = ((S[(signed long int)((64 - 54) % 8)] >> 2 | S[(signed long int)((64 - 54) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 54) % 8)] >> 13 | S[(signed long int)((64 - 54) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 54) % 8)] >> 22 | S[(signed long int)((64 - 54) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 54) % 8)] & (S[(signed long int)((65 - 54) % 8)] | S[(signed long int)((66 - 54) % 8)]) | S[(signed long int)((65 - 54) % 8)] & S[(signed long int)((66 - 54) % 8)]);
  S[(signed long int)((67 - 54) % 8)] = S[(signed long int)((67 - 54) % 8)] + t0;
  S[(signed long int)((71 - 54) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 55) % 8)] + ((S[(signed long int)((68 - 55) % 8)] >> 6 | S[(signed long int)((68 - 55) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 55) % 8)] >> 11 | S[(signed long int)((68 - 55) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 55) % 8)] >> 25 | S[(signed long int)((68 - 55) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 55) % 8)] & (S[(signed long int)((69 - 55) % 8)] ^ S[(signed long int)((70 - 55) % 8)]) ^ S[(signed long int)((70 - 55) % 8)]) + W[(signed long int)55] + (unsigned int)0x682e6ff3;
  t1 = ((S[(signed long int)((64 - 55) % 8)] >> 2 | S[(signed long int)((64 - 55) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 55) % 8)] >> 13 | S[(signed long int)((64 - 55) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 55) % 8)] >> 22 | S[(signed long int)((64 - 55) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 55) % 8)] & (S[(signed long int)((65 - 55) % 8)] | S[(signed long int)((66 - 55) % 8)]) | S[(signed long int)((65 - 55) % 8)] & S[(signed long int)((66 - 55) % 8)]);
  S[(signed long int)((67 - 55) % 8)] = S[(signed long int)((67 - 55) % 8)] + t0;
  S[(signed long int)((71 - 55) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 56) % 8)] + ((S[(signed long int)((68 - 56) % 8)] >> 6 | S[(signed long int)((68 - 56) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 56) % 8)] >> 11 | S[(signed long int)((68 - 56) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 56) % 8)] >> 25 | S[(signed long int)((68 - 56) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 56) % 8)] & (S[(signed long int)((69 - 56) % 8)] ^ S[(signed long int)((70 - 56) % 8)]) ^ S[(signed long int)((70 - 56) % 8)]) + W[(signed long int)56] + (unsigned int)0x748f82ee;
  t1 = ((S[(signed long int)((64 - 56) % 8)] >> 2 | S[(signed long int)((64 - 56) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 56) % 8)] >> 13 | S[(signed long int)((64 - 56) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 56) % 8)] >> 22 | S[(signed long int)((64 - 56) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 56) % 8)] & (S[(signed long int)((65 - 56) % 8)] | S[(signed long int)((66 - 56) % 8)]) | S[(signed long int)((65 - 56) % 8)] & S[(signed long int)((66 - 56) % 8)]);
  S[(signed long int)((67 - 56) % 8)] = S[(signed long int)((67 - 56) % 8)] + t0;
  S[(signed long int)((71 - 56) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 57) % 8)] + ((S[(signed long int)((68 - 57) % 8)] >> 6 | S[(signed long int)((68 - 57) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 57) % 8)] >> 11 | S[(signed long int)((68 - 57) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 57) % 8)] >> 25 | S[(signed long int)((68 - 57) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 57) % 8)] & (S[(signed long int)((69 - 57) % 8)] ^ S[(signed long int)((70 - 57) % 8)]) ^ S[(signed long int)((70 - 57) % 8)]) + W[(signed long int)57] + (unsigned int)0x78a5636f;
  t1 = ((S[(signed long int)((64 - 57) % 8)] >> 2 | S[(signed long int)((64 - 57) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 57) % 8)] >> 13 | S[(signed long int)((64 - 57) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 57) % 8)] >> 22 | S[(signed long int)((64 - 57) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 57) % 8)] & (S[(signed long int)((65 - 57) % 8)] | S[(signed long int)((66 - 57) % 8)]) | S[(signed long int)((65 - 57) % 8)] & S[(signed long int)((66 - 57) % 8)]);
  S[(signed long int)((67 - 57) % 8)] = S[(signed long int)((67 - 57) % 8)] + t0;
  S[(signed long int)((71 - 57) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 58) % 8)] + ((S[(signed long int)((68 - 58) % 8)] >> 6 | S[(signed long int)((68 - 58) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 58) % 8)] >> 11 | S[(signed long int)((68 - 58) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 58) % 8)] >> 25 | S[(signed long int)((68 - 58) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 58) % 8)] & (S[(signed long int)((69 - 58) % 8)] ^ S[(signed long int)((70 - 58) % 8)]) ^ S[(signed long int)((70 - 58) % 8)]) + W[(signed long int)58] + 0x84c87814;
  t1 = ((S[(signed long int)((64 - 58) % 8)] >> 2 | S[(signed long int)((64 - 58) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 58) % 8)] >> 13 | S[(signed long int)((64 - 58) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 58) % 8)] >> 22 | S[(signed long int)((64 - 58) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 58) % 8)] & (S[(signed long int)((65 - 58) % 8)] | S[(signed long int)((66 - 58) % 8)]) | S[(signed long int)((65 - 58) % 8)] & S[(signed long int)((66 - 58) % 8)]);
  S[(signed long int)((67 - 58) % 8)] = S[(signed long int)((67 - 58) % 8)] + t0;
  S[(signed long int)((71 - 58) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 59) % 8)] + ((S[(signed long int)((68 - 59) % 8)] >> 6 | S[(signed long int)((68 - 59) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 59) % 8)] >> 11 | S[(signed long int)((68 - 59) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 59) % 8)] >> 25 | S[(signed long int)((68 - 59) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 59) % 8)] & (S[(signed long int)((69 - 59) % 8)] ^ S[(signed long int)((70 - 59) % 8)]) ^ S[(signed long int)((70 - 59) % 8)]) + W[(signed long int)59] + 0x8cc70208;
  t1 = ((S[(signed long int)((64 - 59) % 8)] >> 2 | S[(signed long int)((64 - 59) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 59) % 8)] >> 13 | S[(signed long int)((64 - 59) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 59) % 8)] >> 22 | S[(signed long int)((64 - 59) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 59) % 8)] & (S[(signed long int)((65 - 59) % 8)] | S[(signed long int)((66 - 59) % 8)]) | S[(signed long int)((65 - 59) % 8)] & S[(signed long int)((66 - 59) % 8)]);
  S[(signed long int)((67 - 59) % 8)] = S[(signed long int)((67 - 59) % 8)] + t0;
  S[(signed long int)((71 - 59) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 60) % 8)] + ((S[(signed long int)((68 - 60) % 8)] >> 6 | S[(signed long int)((68 - 60) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 60) % 8)] >> 11 | S[(signed long int)((68 - 60) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 60) % 8)] >> 25 | S[(signed long int)((68 - 60) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 60) % 8)] & (S[(signed long int)((69 - 60) % 8)] ^ S[(signed long int)((70 - 60) % 8)]) ^ S[(signed long int)((70 - 60) % 8)]) + W[(signed long int)60] + 0x90befffa;
  t1 = ((S[(signed long int)((64 - 60) % 8)] >> 2 | S[(signed long int)((64 - 60) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 60) % 8)] >> 13 | S[(signed long int)((64 - 60) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 60) % 8)] >> 22 | S[(signed long int)((64 - 60) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 60) % 8)] & (S[(signed long int)((65 - 60) % 8)] | S[(signed long int)((66 - 60) % 8)]) | S[(signed long int)((65 - 60) % 8)] & S[(signed long int)((66 - 60) % 8)]);
  S[(signed long int)((67 - 60) % 8)] = S[(signed long int)((67 - 60) % 8)] + t0;
  S[(signed long int)((71 - 60) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 61) % 8)] + ((S[(signed long int)((68 - 61) % 8)] >> 6 | S[(signed long int)((68 - 61) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 61) % 8)] >> 11 | S[(signed long int)((68 - 61) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 61) % 8)] >> 25 | S[(signed long int)((68 - 61) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 61) % 8)] & (S[(signed long int)((69 - 61) % 8)] ^ S[(signed long int)((70 - 61) % 8)]) ^ S[(signed long int)((70 - 61) % 8)]) + W[(signed long int)61] + 0xa4506ceb;
  t1 = ((S[(signed long int)((64 - 61) % 8)] >> 2 | S[(signed long int)((64 - 61) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 61) % 8)] >> 13 | S[(signed long int)((64 - 61) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 61) % 8)] >> 22 | S[(signed long int)((64 - 61) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 61) % 8)] & (S[(signed long int)((65 - 61) % 8)] | S[(signed long int)((66 - 61) % 8)]) | S[(signed long int)((65 - 61) % 8)] & S[(signed long int)((66 - 61) % 8)]);
  S[(signed long int)((67 - 61) % 8)] = S[(signed long int)((67 - 61) % 8)] + t0;
  S[(signed long int)((71 - 61) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 62) % 8)] + ((S[(signed long int)((68 - 62) % 8)] >> 6 | S[(signed long int)((68 - 62) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 62) % 8)] >> 11 | S[(signed long int)((68 - 62) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 62) % 8)] >> 25 | S[(signed long int)((68 - 62) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 62) % 8)] & (S[(signed long int)((69 - 62) % 8)] ^ S[(signed long int)((70 - 62) % 8)]) ^ S[(signed long int)((70 - 62) % 8)]) + W[(signed long int)62] + 0xbef9a3f7;
  t1 = ((S[(signed long int)((64 - 62) % 8)] >> 2 | S[(signed long int)((64 - 62) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 62) % 8)] >> 13 | S[(signed long int)((64 - 62) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 62) % 8)] >> 22 | S[(signed long int)((64 - 62) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 62) % 8)] & (S[(signed long int)((65 - 62) % 8)] | S[(signed long int)((66 - 62) % 8)]) | S[(signed long int)((65 - 62) % 8)] & S[(signed long int)((66 - 62) % 8)]);
  S[(signed long int)((67 - 62) % 8)] = S[(signed long int)((67 - 62) % 8)] + t0;
  S[(signed long int)((71 - 62) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 63) % 8)] + ((S[(signed long int)((68 - 63) % 8)] >> 6 | S[(signed long int)((68 - 63) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 63) % 8)] >> 11 | S[(signed long int)((68 - 63) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 63) % 8)] >> 25 | S[(signed long int)((68 - 63) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 63) % 8)] & (S[(signed long int)((69 - 63) % 8)] ^ S[(signed long int)((70 - 63) % 8)]) ^ S[(signed long int)((70 - 63) % 8)]) + W[(signed long int)63] + 0xc67178f2;
  t1 = ((S[(signed long int)((64 - 63) % 8)] >> 2 | S[(signed long int)((64 - 63) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 63) % 8)] >> 13 | S[(signed long int)((64 - 63) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 63) % 8)] >> 22 | S[(signed long int)((64 - 63) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 63) % 8)] & (S[(signed long int)((65 - 63) % 8)] | S[(signed long int)((66 - 63) % 8)]) | S[(signed long int)((65 - 63) % 8)] & S[(signed long int)((66 - 63) % 8)]);
  S[(signed long int)((67 - 63) % 8)] = S[(signed long int)((67 - 63) % 8)] + t0;
  S[(signed long int)((71 - 63) % 8)] = t0 + t1;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    state[(signed long int)i] = state[(signed long int)i] + S[(signed long int)i];
}

// SHA256_Update
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/sha256.h line 49
void SHA256_Update(struct SHA256Context *ctx, const void *in, unsigned long int len)
{
  unsigned int bitlen[2l];
  unsigned int r;
  const unsigned char *src = (const unsigned char *)in;
  r = ctx->count[(signed long int)1] >> 3 & (unsigned int)0x3f;
  bitlen[(signed long int)1] = (unsigned int)len << 3;
  bitlen[(signed long int)0] = (unsigned int)(len >> 29);
  ctx->count[(signed long int)1] = ctx->count[(signed long int)1] + bitlen[(signed long int)1];
  if(!(ctx->count[1l] >= bitlen[1l]))
    ctx->count[(signed long int)0] = ctx->count[(signed long int)0] + 1u;

  ctx->count[(signed long int)0] = ctx->count[(signed long int)0] + bitlen[(signed long int)0];
  if(!(len >= (unsigned long int)(64u + -r)))
    memcpy((void *)&ctx->buf[(signed long int)r], (const void *)src, len);

  else
  {
    memcpy((void *)&ctx->buf[(signed long int)r], (const void *)src, (unsigned long int)((unsigned int)64 - r));
    SHA256_Transform(ctx->state, ctx->buf);
    src = src + (signed long int)((unsigned int)64 - r);
    len = len - (unsigned long int)((unsigned int)64 - r);
    for( ; len >= 64ul; len = len - (unsigned long int)64)
    {
      SHA256_Transform(ctx->state, src);
      src = src + (signed long int)64;
    }
    memcpy((void *)ctx->buf, (const void *)src, len);
  }
}

// __bladerf_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/init_fini.c line 93
void __bladerf_fini(void)
{
  signed int log_level;
  log_level=get_loglevel();
  bladerf_log_set_verbosity((enum anonymous_26)log_level);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ init_fini.c:98] libbladeRF %s: deinitializing\n", (const void *)"1.5.1-0.2016.01~rc1-3");
  while((_Bool)0);
  fflush((struct _IO_FILE *)(void *)0);
}

// __bladerf_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/init_fini.c line 79
void __bladerf_init(void)
{
  signed int log_level;
  log_level=get_loglevel();
  bladerf_log_set_verbosity((enum anonymous_26)log_level);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ init_fini.c:90] libbladeRF %s: initializing\n", (const void *)"1.5.1-0.2016.01~rc1-3");
  while((_Bool)0);
}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx)
{
  signed long long int return_value___builtin_bswap64_1;
  return_value___builtin_bswap64_1=__builtin_bswap64((signed long long int)__bsx);
  return (unsigned long int)return_value___builtin_bswap64_1;
}

// add_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 105
signed int add_field(char *buf, signed int buf_len, const char *field_name, const char *val)
{
  signed int dummy_idx = 0;
  signed int i = 0;
  signed int rv;
  while(!(i >= buf_len))
  {
    unsigned char field_len = (unsigned char)buf[(signed long int)i];
    if((signed int)field_len == 0xff)
      break;

    i = i + (signed int)field_len + 3;
  }
  rv=encode_field(buf + (signed long int)i, buf_len - i, &dummy_idx, field_name, val);
  if(!(rv >= 0))
    return rv;

  else
    return 0;
}

// addr_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 633
static inline _Bool addr_matches(unsigned char addr, struct libusb_device *d)
{
  _Bool tmp_if_expr_2;
  unsigned char return_value_libusb_get_device_address_1;
  if((signed int)addr == 255)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_libusb_get_device_address_1=libusb_get_device_address(d);
    tmp_if_expr_2 = addr == return_value_libusb_get_device_address_1 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr_2;
}

// advance_rx_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 258
static inline void advance_rx_buffer(struct buffer_mgmt *b)
{
  b->status[(signed long int)b->cons_i] = (enum anonymous_21)SYNC_BUFFER_EMPTY;
  b->cons_i = (b->cons_i + (unsigned int)1) % b->num_buffers;
}

// advance_tx_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 621
static signed int advance_tx_buffer(struct bladerf_sync *s, struct buffer_mgmt *b)
{
  signed int status = 0;
  const unsigned int idx = b->prod_i;
  b->status[(signed long int)idx] = (enum anonymous_21)SYNC_BUFFER_FULL;
  if((signed int)b->submitter == SYNC_TX_SUBMITTER_FN)
  {
    pthread_mutex_unlock(&b->lock);
    status=async_submit_stream_buffer(s->worker->stream, b->buffers[(signed long int)idx], s->stream_config.timeout_ms, (_Bool)1);
    pthread_mutex_lock(&b->lock);
    if(status == 0)
    {
      b->status[(signed long int)idx] = (enum anonymous_21)SYNC_BUFFER_IN_FLIGHT;
      goto __CPROVER_DUMP_L3;
    }

    if(status == -18)
    {
      b->submitter = (enum anonymous_22)SYNC_TX_SUBMITTER_CALLBACK;
      b->cons_i = idx;
      status = 0;
      goto __CPROVER_DUMP_L3;
    }

    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:664] %s: Failed to submit buf[%u].\n", (const void *)"advance_tx_buffer", idx);
    while((_Bool)0);
    return status;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    b->prod_i = (idx + (unsigned int)1) % b->num_buffers;
    if((signed int)b->status[(signed long int)b->prod_i] == SYNC_BUFFER_EMPTY)
      s->state = (enum anonymous_19)SYNC_STATE_BUFFER_READY;

    else
      s->state = (enum anonymous_19)SYNC_STATE_CHECK_WORKER;
    return status;
  }
}

// append_char
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 306
static signed int append_char(char **arg, signed int *arg_size, signed int *arg_i, char c)
{
  char *tmp;
  if(*arg_i >= *arg_size)
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)*arg, (unsigned long int)(*arg_size * 2));
    tmp = (char *)return_value_realloc_1;
    if(tmp == ((char *)NULL))
      return -1;

    else
    {
      memset((void *)(tmp + (signed long int)*arg_size), 0, (unsigned long int)*arg_size);
      *arg = tmp;
      *arg_size = *arg_size * 2;
    }
  }

  (*arg)[(signed long int)*arg_i] = c;
  *arg_i = *arg_i + 1;
  return 0;
}

// apply_lms_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 36
static inline signed int apply_lms_dc_cals(struct bladerf *dev)
{
  signed int status = 0;
  struct bladerf_lms_dc_cals cals;
  const _Bool have_rx = dev->cal.dc_rx != (struct dc_cal_tbl *)(void *)0;
  const _Bool have_tx = dev->cal.dc_tx != (struct dc_cal_tbl *)(void *)0;
  cals.lpf_tuning = (signed short int)-1;
  cals.tx_lpf_i = (signed short int)-1;
  cals.tx_lpf_q = (signed short int)-1;
  cals.rx_lpf_i = (signed short int)-1;
  cals.rx_lpf_q = (signed short int)-1;
  cals.dc_ref = (signed short int)-1;
  cals.rxvga2a_i = (signed short int)-1;
  cals.rxvga2a_q = (signed short int)-1;
  cals.rxvga2b_i = (signed short int)-1;
  cals.rxvga2b_q = (signed short int)-1;
  if(!(have_rx == (_Bool)0))
  {
    struct bladerf_lms_dc_cals *reg_vals = &dev->cal.dc_rx->reg_vals;
    cals.lpf_tuning = reg_vals->lpf_tuning;
    cals.rx_lpf_i = reg_vals->rx_lpf_i;
    cals.rx_lpf_q = reg_vals->rx_lpf_q;
    cals.dc_ref = reg_vals->dc_ref;
    cals.rxvga2a_i = reg_vals->rxvga2a_i;
    cals.rxvga2a_q = reg_vals->rxvga2a_q;
    cals.rxvga2b_i = reg_vals->rxvga2b_i;
    cals.rxvga2b_q = reg_vals->rxvga2b_q;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ bladerf_priv.c:66] Fetched register values from RX DC cal table.\n");
    while((_Bool)0);
  }

  if(!(have_tx == (_Bool)0))
  {
    struct bladerf_lms_dc_cals *apply_lms_dc_cals__1__2__reg_vals = &dev->cal.dc_tx->reg_vals;
    cals.tx_lpf_i = apply_lms_dc_cals__1__2__reg_vals->tx_lpf_i;
    cals.tx_lpf_q = apply_lms_dc_cals__1__2__reg_vals->tx_lpf_q;
    if(!(have_rx == (_Bool)0))
    {
      if(!(cals.lpf_tuning == apply_lms_dc_cals__1__2__reg_vals->lpf_tuning))
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ bladerf_priv.c:79] LPF tuning mismatch in tables. RX=0x%04x, TX=0x%04x", cals.lpf_tuning, apply_lms_dc_cals__1__2__reg_vals->lpf_tuning);
        while((_Bool)0);

    }

    else
    {
      cals.rx_lpf_i = apply_lms_dc_cals__1__2__reg_vals->rx_lpf_i;
      cals.rx_lpf_q = apply_lms_dc_cals__1__2__reg_vals->rx_lpf_q;
      cals.dc_ref = apply_lms_dc_cals__1__2__reg_vals->dc_ref;
      cals.rxvga2a_i = apply_lms_dc_cals__1__2__reg_vals->rxvga2a_i;
      cals.rxvga2a_q = apply_lms_dc_cals__1__2__reg_vals->rxvga2a_q;
      cals.rxvga2b_i = apply_lms_dc_cals__1__2__reg_vals->rxvga2b_i;
      cals.rxvga2b_q = apply_lms_dc_cals__1__2__reg_vals->rxvga2b_q;
    }
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ bladerf_priv.c:93] Fetched register values from TX DC cal table.\n");
    while((_Bool)0);
  }

  if(have_tx == (_Bool)0 && !(have_rx == (_Bool)0))
  {
    struct bladerf_lms_dc_cals *apply_lms_dc_cals__1__3__reg_vals = &dev->cal.dc_rx->reg_vals;
    cals.tx_lpf_i = apply_lms_dc_cals__1__3__reg_vals->tx_lpf_i;
    cals.tx_lpf_q = apply_lms_dc_cals__1__3__reg_vals->tx_lpf_q;
  }

  if(!(have_rx == (_Bool)0) || !(have_tx == (_Bool)0))
  {
    status=lms_set_dc_cals(dev, &cals);
    if(status == 0)
    {
      signed int rx_status = 0;
      signed int tx_status = 0;
      if(!(have_rx == (_Bool)0))
      {
        unsigned int rx_f;
        rx_status=tuning_get_freq(dev, (enum anonymous)BLADERF_MODULE_RX, &rx_f);
        if(rx_status == 0)
          rx_status=tuning_set_freq(dev, (enum anonymous)BLADERF_MODULE_RX, rx_f);

      }

      if(!(have_tx == (_Bool)0))
      {
        unsigned int apply_lms_dc_cals__1__4__1__2__rx_f;
        rx_status=tuning_get_freq(dev, (enum anonymous)BLADERF_MODULE_RX, &apply_lms_dc_cals__1__4__1__2__rx_f);
        if(rx_status == 0)
          rx_status=tuning_set_freq(dev, (enum anonymous)BLADERF_MODULE_RX, apply_lms_dc_cals__1__4__1__2__rx_f);

      }

      status = rx_status == 0 ? tx_status : rx_status;
    }

  }

  return status;
}

// async_deinit_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.c line 205
void async_deinit_stream(struct bladerf_stream *stream)
{
  unsigned long int i;
  if(stream == ((struct bladerf_stream *)NULL))
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ async.c:210] %s called with NULL stream\n", (const void *)"async_deinit_stream");
    while((_Bool)0);

  else
  {
    while(!((signed int)stream->state == STREAM_DONE))
    {
      if((signed int)stream->state == STREAM_IDLE)
        break;

      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ async.c:215] Stream not done...\n");
      while((_Bool)0);
      usleep((unsigned int)1000000);
    }
    stream->dev->fn->deinit_stream(stream);
    i = (unsigned long int)0;
    if(!(i >= stream->num_buffers))
    {
      free(stream->buffers[(signed long int)i]);
      i = i + 1ul;
    }

    free((void *)stream->buffers);
    free((void *)stream);
  }
}

// async_init_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.c line 27
signed int async_init_stream(struct bladerf_stream **stream, struct bladerf *dev, void * (*callback)(struct bladerf *, struct bladerf_stream *, struct bladerf_metadata *, void *, unsigned long int, void *), void ***buffers, unsigned long int num_buffers, enum anonymous_9 format, unsigned long int samples_per_buffer, unsigned long int num_transfers, void *user_data)
{
  struct bladerf_stream *lstream;
  unsigned long int buffer_size_bytes;
  unsigned long int i;
  signed int status = 0;
  if(!(num_buffers >= num_transfers))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ async.c:43] num_transfers must be <= num_buffers\n");
    while((_Bool)0);
    return -3;
  }

  else
    if(!(samples_per_buffer % 1024ul == 0ul) || !(samples_per_buffer >= 1024ul))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ async.c:48] samples_per_buffer must be multiples of 1024\n");
      while((_Bool)0);
      return -3;
    }

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct bladerf_stream) /*208ul*/ );
      lstream = (struct bladerf_stream *)return_value_malloc_1;
      if(lstream == ((struct bladerf_stream *)NULL))
        return -4;

      else
      {
        pthread_mutex_init(&lstream->lock, (const union anonymous_27 *)(void *)0);
        signed int return_value_pthread_cond_init_2;
        return_value_pthread_cond_init_2=pthread_cond_init(&lstream->can_submit_buffer, (const union anonymous_27 *)(void *)0);
        if(!(return_value_pthread_cond_init_2 == 0))
        {
          free((void *)lstream);
          return -1;
        }

        else
        {
          signed int return_value_pthread_cond_init_3;
          return_value_pthread_cond_init_3=pthread_cond_init(&lstream->stream_started, (const union anonymous_27 *)(void *)0);
          if(!(return_value_pthread_cond_init_3 == 0))
          {
            free((void *)lstream);
            return -1;
          }

          else
          {
            lstream->dev = dev;
            lstream->error_code = 0;
            lstream->state = (enum anonymous_20)STREAM_IDLE;
            lstream->samples_per_buffer = samples_per_buffer;
            lstream->num_buffers = num_buffers;
            lstream->format = format;
            lstream->cb = callback;
            lstream->user_data = user_data;
            lstream->buffers = (void **)(void *)0;
            if((signed int)format == BLADERF_FORMAT_SC16_Q11 || (signed int)format == BLADERF_FORMAT_SC16_Q11_META)
            {
              buffer_size_bytes=sc16q11_to_bytes(samples_per_buffer);
              goto __CPROVER_DUMP_L10;
            }

            status = -3;

          __CPROVER_DUMP_L10:
            ;
            if(status == 0)
            {
              void *return_value_calloc_4;
              return_value_calloc_4=calloc(num_buffers, sizeof(void *) /*8ul*/ );
              lstream->buffers = (void **)return_value_calloc_4;
              if(!(lstream->buffers == ((void **)NULL)))
              {
                i = (unsigned long int)0;
                for( ; status == 0 && !(i >= num_buffers); i = i + 1ul)
                {
                  lstream->buffers[(signed long int)i]=calloc((unsigned long int)1, buffer_size_bytes);
                  if(lstream->buffers[(signed long int)i] == NULL)
                    status = -4;

                }
              }

              else
                status = -4;
            }

            if(!(status == 0))
            {
              if(!(lstream->buffers == ((void **)NULL)))
              {
                i = (unsigned long int)0;
                for( ; !(i >= num_buffers); i = i + 1ul)
                  free(lstream->buffers[(signed long int)i]);
                free((void *)lstream->buffers);
              }

              free((void *)lstream);
            }

            else
            {
              status=dev->fn->init_stream(lstream, num_transfers);
              if(!(status >= 0))
              {
                async_deinit_stream(lstream);
                *stream = (struct bladerf_stream *)(void *)0;
              }

              else
              {
                *stream = lstream;
                if(!(buffers == ((void ***)NULL)))
                  *buffers = lstream->buffers;

              }
            }
            return status;
          }
        }
      }
    }
}

// async_run_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.c line 138
signed int async_run_stream(struct bladerf_stream *stream, enum anonymous module)
{
  signed int status;
  struct bladerf *dev = stream->dev;
  pthread_mutex_lock(&stream->lock);
  stream->module = module;
  stream->state = (enum anonymous_20)STREAM_RUNNING;
  pthread_cond_signal(&stream->stream_started);
  pthread_mutex_unlock(&stream->lock);
  status=dev->fn->stream(stream, module);
  signed int tmp_if_expr_1;
  if(status == 0)
    tmp_if_expr_1 = stream->error_code;

  else
    tmp_if_expr_1 = status;
  return tmp_if_expr_1;
}

// async_stream_buf_bytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.h line 62
static inline unsigned long int async_stream_buf_bytes(struct bladerf_stream *s)
{
  unsigned long int return_value_samples_to_bytes_1;
  return_value_samples_to_bytes_1=samples_to_bytes(s->format, s->samples_per_buffer);
  return return_value_samples_to_bytes_1;
}

// async_submit_stream_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/async.c line 155
signed int async_submit_stream_buffer(struct bladerf_stream *stream, void *buffer, unsigned int timeout_ms, _Bool nonblock)
{
  signed int status = 0;
  struct timespec timeout_abs;
  pthread_mutex_lock(&stream->lock);
  if(!(buffer == NULL))
  {
    if(!((signed int)stream->state == STREAM_RUNNING))
    {
      if(!(timeout_ms == 0u))
      {
        status=populate_abs_timeout(&timeout_abs, timeout_ms);
        if(!(status == 0))
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ async.c:168] Failed to populate timeout value\n");
          while((_Bool)0);
          goto error;
        }

      }

    }

    while(!((signed int)stream->state == STREAM_RUNNING))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ async.c:175] Buffer submitted while stream's not running. Waiting for stream to start.\n");
      while((_Bool)0);
      if(timeout_ms == 0u)
        status=pthread_cond_wait(&stream->stream_started, &stream->lock);

      else
        status=pthread_cond_timedwait(&stream->stream_started, &stream->lock, &timeout_abs);
      if(status == 110)
      {
        status = -6;
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ async.c:188] %s: %u ms timeout expired", (const void *)"async_submit_stream_buffer", timeout_ms);
        while((_Bool)0);
        goto error;
      }

      else
        if(!(status == 0))
        {
          status = -1;
          goto error;
        }

    }
  }

  status=stream->dev->fn->submit_stream_buffer(stream, buffer, timeout_ms, nonblock);

error:
  ;
  pthread_mutex_unlock(&stream->lock);
  return status;
}

// backend2str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 131
const char * backend2str(enum anonymous_11 backend)
{
  switch((signed int)backend)
  {
    case BLADERF_BACKEND_LIBUSB:
      return "libusb";
    case BLADERF_BACKEND_LINUX:
      return "linux";
    case BLADERF_BACKEND_CYPRESS:
      return "cypress";
    default:
      return "*";
  }
}

// backend_description
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 594
const char * backend_description(enum anonymous_11 b)
{
  switch((signed int)b)
  {
    case BLADERF_BACKEND_ANY:
      return "Any";
    case BLADERF_BACKEND_LINUX:
      return "Linux kernel driver";
    case BLADERF_BACKEND_LIBUSB:
      return "libusb";
    case BLADERF_BACKEND_CYPRESS:
      return "Cypress driver";
    case BLADERF_BACKEND_DUMMY:
      return "Dummy";
    default:
      return "Unknown";
  }
}

// backend_load_fw_from_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 112
signed int backend_load_fw_from_bootloader(enum anonymous_11 backend, unsigned char bus, unsigned char addr, struct fx3_firmware *fw)
{
  signed int status = -7;
  unsigned long int i;
  const unsigned long int n_backends = sizeof(struct backend_fns *[1l]) /*8ul*/  / sizeof(struct backend_fns *) /*8ul*/ ;
  i = (unsigned long int)0;
  if(!(i >= n_backends))
  {
    _Bool return_value;
    return_value=backend_list[(signed long int)i]->matches(backend);
    if(!(return_value == (_Bool)0))
      status=backend_list[(signed long int)i]->load_fw_from_bootloader(backend, bus, addr, fw);

    else
      i = i + 1ul;
  }

  return status;
}

// backend_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 43
signed int backend_open(struct bladerf *device, struct bladerf_devinfo *info)
{
  unsigned long int i;
  signed int status = -7;
  const unsigned long int n_backends = sizeof(struct backend_fns *[1l]) /*8ul*/  / sizeof(struct backend_fns *) /*8ul*/ ;
  if((signed int)info->backend == BLADERF_BACKEND_ANY)
    status=open_with_any_backend(device, info);

  else
  {
    i = (unsigned long int)0;
    if(!(i >= n_backends))
    {
      _Bool return_value;
      return_value=backend_list[(signed long int)i]->matches(info->backend);
      if(!(return_value == (_Bool)0))
        status=backend_list[(signed long int)i]->open(device, info);

      else
        i = i + 1ul;
    }

  }
  return status;
}

// backend_probe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 63
signed int backend_probe(enum anonymous_15 probe_target, struct bladerf_devinfo **devinfo_items, unsigned long int *num_items)
{
  signed int status;
  signed int first_backend_error = 0;
  struct bladerf_devinfo_list list;
  unsigned long int i;
  const unsigned long int n_backends = sizeof(struct backend_fns *[1l]) /*8ul*/  / sizeof(struct backend_fns *) /*8ul*/ ;
  *devinfo_items = (struct bladerf_devinfo *)(void *)0;
  *num_items = (unsigned long int)0;
  status=bladerf_devinfo_list_init(&list);
  if(!(status == 0))
  {
    do
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ backend.c:78] Failed to initialize devinfo list: %s\n", return_value_bladerf_strerror_1);
    }
    while((_Bool)0);
    return status;
  }

  else
  {
    i = (unsigned long int)0;
    if(!(i >= n_backends))
    {
      status=backend_list[(signed long int)i]->probe(probe_target, &list);
      if(!(status == -7) && !(status >= 0))
      {
        const char *return_value_bladerf_strerror_2;
        return_value_bladerf_strerror_2=bladerf_strerror(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ backend.c:87] Probe failed on backend %d: %s\n", i, return_value_bladerf_strerror_2);
        if(first_backend_error == 0)
          first_backend_error = status;

      }

      i = i + 1ul;
    }

    *num_items = list.num_elt;
    if(!(*num_items == 0ul))
      *devinfo_items = list.elt;

    else
    {
      free((void *)list.elt);
      status = first_backend_error == 0 ? -7 : first_backend_error;
    }
    return status;
  }
}

// band_select
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/band_select.h line 48
signed int band_select(struct bladerf *dev, enum anonymous module, _Bool low_band)
{
  signed int status;
  unsigned int gpio;
  const unsigned int band = (const unsigned int)(low_band != (_Bool)0 ? 2 : 1);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ band_select.c:35] Selecting %s band.\n", low_band != (_Bool)0 ? "low" : "high");
  while((_Bool)0);
  status=lms_select_band(dev, module, low_band);
  if(!(status == 0))
    return status;

  else
  {
    status=dev->fn->config_gpio_read(dev, &gpio);
    if(!(status == 0))
      return status;

    else
    {
      gpio = gpio & (unsigned int)~((signed int)module == BLADERF_MODULE_TX ? 3 << 3 : 3 << 5);
      gpio = gpio | ((signed int)module == BLADERF_MODULE_TX ? band << 3 : band << 5);
      signed int return_value_config_gpio_write_1;
      return_value_config_gpio_write_1=config_gpio_write(dev, gpio);
      return return_value_config_gpio_write_1;
    }
  }
}

// be32dec
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 73
static inline unsigned int be32dec(const void *pp)
{
  const unsigned char *p = (const unsigned char *)pp;
  return (unsigned int)p[(signed long int)0] << 24 | (unsigned int)((signed int)p[(signed long int)1] << 16) | (unsigned int)((signed int)p[(signed long int)2] << 8) | (unsigned int)p[(signed long int)3];
}

// be32dec_vect
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 110
static void be32dec_vect(unsigned int *dst, const unsigned char *src, unsigned long int len)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= len / 4ul); i = i + 1ul)
    dst[(signed long int)i]=be32dec((const void *)(src + (signed long int)(i * (unsigned long int)4)));
}

// be32enc
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 81
static inline void be32enc(void *pp, unsigned int u)
{
  unsigned char *p = (unsigned char *)pp;
  p[(signed long int)0] = (unsigned char)(u >> 24 & (unsigned int)0xff);
  p[(signed long int)1] = (unsigned char)(u >> 16 & (unsigned int)0xff);
  p[(signed long int)2] = (unsigned char)(u >> 8 & (unsigned int)0xff);
  p[(signed long int)3] = (unsigned char)(u & (unsigned int)0xff);
}

// be32enc_vect
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/sha256.c line 97
static void be32enc_vect(unsigned char *dst, const unsigned int *src, unsigned long int len)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= len / 4ul); i = i + 1ul)
    be32enc((void *)(dst + (signed long int)(i * (unsigned long int)4)), src[(signed long int)i]);
}

// begin_fpga_programming
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 390
static signed int begin_fpga_programming(struct bladerf *dev)
{
  signed int result;
  signed int status;
  status=vendor_cmd_int(dev, (unsigned char)2, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, &result);
  if(!(status == 0))
    return status;

  else
    if(!(result == 0))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:399] Startg fpga programming, result = %d\n", result);
      while((_Bool)0);
      return -1;
    }

    else
      return 0;
}

// bladerf_alloc_cal_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 486
struct bladerf_image * bladerf_alloc_cal_image(enum anonymous_5 fpga_size, unsigned short int vctcxo_trim)
{
  struct bladerf_image *image;
  signed int status;
  image=bladerf_alloc_image((enum anonymous_38)BLADERF_IMAGE_TYPE_CALIBRATION, (unsigned int)0x00030000, (unsigned int)0x100);
  if(image == ((struct bladerf_image *)NULL))
    return (struct bladerf_image *)(void *)0;

  else
  {
    status=make_cal_region(fpga_size, vctcxo_trim, image->data, (unsigned long int)image->length);
    if(!(status == 0))
    {
      bladerf_free_image(image);
      image = (struct bladerf_image *)(void *)0;
    }

    return image;
  }
}

// bladerf_alloc_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2674
struct bladerf_image * bladerf_alloc_image(enum anonymous_38 type, unsigned int address, unsigned int length)
{
  struct bladerf_image *image;
  /* assertion 7 == (sizeof(image_magic) - 1) */
  assert((unsigned long int)7 == sizeof(const char [8l]) /*8ul*/  - (unsigned long int)1);
  _Bool return_value_is_page_aligned_2;
  _Bool return_value_is_valid_addr_len_1;
  if(!(address == 0xffffffff))
  {
    _Bool return_value_is_page_aligned_3;
    return_value_is_page_aligned_3=is_page_aligned(address);
    if(return_value_is_page_aligned_3 == (_Bool)0)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:411] Address is not page-aligned: 0x%08x\n", address);
      while((_Bool)0);
      return (struct bladerf_image *)(void *)0;
    }

    else
    {
      return_value_is_page_aligned_2=is_page_aligned(length);
      if(return_value_is_page_aligned_2 == (_Bool)0)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:414] Length is not page-aligned: 0x%08x\n", length);
        while((_Bool)0);
        return (struct bladerf_image *)(void *)0;
      }

      else
      {
        return_value_is_valid_addr_len_1=is_valid_addr_len(address, length);
        if(return_value_is_valid_addr_len_1 == (_Bool)0)
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:417] Invalid address=0x%08x or length=0x%08x\n", address, length);
          while((_Bool)0);
          return (struct bladerf_image *)(void *)0;
        }

      }
    }
  }

  void *return_value_calloc_4;
  return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct bladerf_image) /*248ul*/ );
  image = (struct bladerf_image *)return_value_calloc_4;
  if(image == ((struct bladerf_image *)NULL))
    return (struct bladerf_image *)(void *)0;

  else
  {
    if(!(length == 0u))
    {
      void *return_value_calloc_5;
      return_value_calloc_5=calloc((unsigned long int)1, (unsigned long int)length);
      image->data = (unsigned char *)return_value_calloc_5;
      if(image->data == ((unsigned char *)NULL))
      {
        free((void *)image);
        return (struct bladerf_image *)(void *)0;
      }

    }

    memcpy((void *)image->magic, (const void *)&image_magic, (unsigned long int)7);
    image->version.major = (unsigned short int)0;
    image->version.minor = (unsigned short int)1;
    image->version.patch = (unsigned short int)0;
    image->timestamp=get_timestamp();
    image->address = address;
    image->length = length;
    image->type = type;
    return image;
  }
}

// bladerf_backend_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1477
const char * bladerf_backend_str(enum anonymous_11 backend)
{
  const char *return_value_backend2str_1;
  return_value_backend2str_1=backend2str(backend);
  return return_value_backend2str_1;
}

// bladerf_bus_addr_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.h line 77
_Bool bladerf_bus_addr_matches(struct bladerf_devinfo *a, struct bladerf_devinfo *b)
{
  _Bool bus_match;
  _Bool addr_match;
  _Bool tmp_if_expr_1;
  if((signed int)a->usb_bus == 255)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)b->usb_bus == 255 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = a->usb_bus == b->usb_bus ? (_Bool)1 : (_Bool)0;
  bus_match = tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if((signed int)a->usb_addr == 255)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)b->usb_addr == 255 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = a->usb_addr == b->usb_addr ? (_Bool)1 : (_Bool)0;
  addr_match = tmp_if_expr_4;
  return bus_match != (_Bool)0 && addr_match != (_Bool)0;
}

// bladerf_calibrate_dc
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1919
signed int bladerf_calibrate_dc(struct bladerf *dev, enum anonymous_0 module)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_calibrate_dc(dev, module);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_cancel_scheduled_retunes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 912
signed int bladerf_cancel_scheduled_retunes(struct bladerf *dev, enum anonymous m)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap(dev, (unsigned long int)(1 << 3));
  if(!(return_value_have_cap_1 == (_Bool)0))
    status=tuning_cancel_scheduled(dev, m);

  else
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:923] This FPGA version (%u.%u.%u) does not support scheduled retunes.\n", dev->fpga_version.major, dev->fpga_version.minor, dev->fpga_version.patch);
    while((_Bool)0);
    status = -8;
  }
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 300
void bladerf_close(struct bladerf *dev)
{
  signed int status;
  _Bool return_value_have_cap_1;
  if(!(dev == ((struct bladerf *)NULL)))
  {
    pthread_mutex_lock(&dev->ctrl_lock);
    sync_deinit(dev->sync[(signed long int)BLADERF_MODULE_RX]);
    sync_deinit(dev->sync[(signed long int)BLADERF_MODULE_TX]);
    status=dev->fn->is_fpga_configured(dev);
    if(status == 1)
    {
      return_value_have_cap_1=have_cap(dev, (unsigned long int)(1 << 3));
      if(!(return_value_have_cap_1 == (_Bool)0))
      {
        tuning_cancel_scheduled(dev, (enum anonymous)BLADERF_MODULE_RX);
        tuning_cancel_scheduled(dev, (enum anonymous)BLADERF_MODULE_TX);
      }

    }

    dev->fn->close(dev);
    free((void *)dev->fpga_version.describe);
    free((void *)dev->fw_version.describe);
    dc_cal_tbl_free(&dev->cal.dc_rx);
    dc_cal_tbl_free(&dev->cal.dc_tx);
    pthread_mutex_unlock(&dev->ctrl_lock);
    free((void *)dev);
  }

}

// bladerf_config_gpio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1562
signed int bladerf_config_gpio_read(struct bladerf *dev, unsigned int *val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->config_gpio_read(dev, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_config_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1573
signed int bladerf_config_gpio_write(struct bladerf *dev, unsigned int val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=config_gpio_write(dev, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_dac_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1862
signed int bladerf_dac_read(struct bladerf *dev, unsigned short int *val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->vctcxo_dac_read(dev, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_dac_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1851
signed int bladerf_dac_write(struct bladerf *dev, unsigned short int val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->vctcxo_dac_write(dev, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_deinit_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1110
void bladerf_deinit_stream(struct bladerf_stream *stream)
{
  if(!(stream == ((struct bladerf_stream *)NULL)))
  {
    if(!(stream->dev == ((struct bladerf *)NULL)))
    {
      struct bladerf *dev = stream->dev;
      pthread_mutex_lock(&dev->ctrl_lock);
      async_deinit_stream(stream);
      pthread_mutex_unlock(&dev->ctrl_lock);
    }

  }

}

// bladerf_device_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1225
signed int bladerf_device_reset(struct bladerf *dev)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->device_reset(dev);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_device_speed
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1176
enum anonymous_7 bladerf_device_speed(struct bladerf *dev)
{
  enum anonymous_7 speed;
  pthread_mutex_lock(&dev->ctrl_lock);
  speed = dev->usb_speed;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return speed;
}

// bladerf_devinfo_list_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.c line 85
signed int bladerf_devinfo_list_add(struct bladerf_devinfo_list *list, struct bladerf_devinfo *info)
{
  signed int status = 0;
  struct bladerf_devinfo *info_tmp;
  if(list->num_elt >= list->backing_size)
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)list->elt, list->backing_size * (unsigned long int)2 * sizeof(struct bladerf_devinfo) /*44ul*/ );
    info_tmp = (struct bladerf_devinfo *)return_value_realloc_1;
    if(info_tmp == ((struct bladerf_devinfo *)NULL))
      status = -4;

    else
    {
      list->elt = info_tmp;
      list->backing_size = list->backing_size * (unsigned long int)2;
    }
  }

  if(status == 0)
  {
    memcpy((void *)&list->elt[(signed long int)list->num_elt], (const void *)info, sizeof(struct bladerf_devinfo) /*44ul*/ );
    list->num_elt = list->num_elt + 1ul;
  }

  return status;
}

// bladerf_devinfo_list_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.h line 83
signed int bladerf_devinfo_list_init(struct bladerf_devinfo_list *list)
{
  signed int status = 0;
  list->num_elt = (unsigned long int)0;
  list->backing_size = (unsigned long int)5;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(list->backing_size * sizeof(struct bladerf_devinfo) /*44ul*/ );
  list->elt = (struct bladerf_devinfo *)return_value_malloc_1;
  if(list->elt == ((struct bladerf_devinfo *)NULL))
    status = -4;

  return status;
}

// bladerf_devinfo_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1449
_Bool bladerf_devinfo_matches(struct bladerf_devinfo *a, struct bladerf_devinfo *b)
{
  _Bool return_value_bladerf_instance_matches_1;
  return_value_bladerf_instance_matches_1=bladerf_instance_matches(a, b);
  _Bool tmp_if_expr_3;
  _Bool return_value_bladerf_serial_matches_2;
  if(!(return_value_bladerf_instance_matches_1 == (_Bool)0))
  {
    return_value_bladerf_serial_matches_2=bladerf_serial_matches(a, b);
    tmp_if_expr_3 = return_value_bladerf_serial_matches_2 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool return_value_bladerf_bus_addr_matches_4;
  if(tmp_if_expr_3)
  {
    return_value_bladerf_bus_addr_matches_4=bladerf_bus_addr_matches(a, b);
    tmp_if_expr_5 = return_value_bladerf_bus_addr_matches_4 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  return tmp_if_expr_5;
}

// bladerf_devstr_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1458
_Bool bladerf_devstr_matches(const char *dev_str, struct bladerf_devinfo *info)
{
  signed int status;
  _Bool ret;
  struct bladerf_devinfo from_str;
  status=str2devinfo(dev_str, &from_str);
  if(!(status >= 0))
  {
    ret = (_Bool)0;
    do
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:1469] Failed to parse device string: %s\n", return_value_bladerf_strerror_1);
    }
    while((_Bool)0);
  }

  else
    ret=bladerf_devinfo_matches(&from_str, info);
  return ret;
}

// bladerf_enable_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 335
signed int bladerf_enable_module(struct bladerf *dev, enum anonymous m, _Bool enable)
{
  signed int status;
  if(!((signed int)m == BLADERF_MODULE_RX) && !((signed int)m == BLADERF_MODULE_TX))
    return -3;

  else
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:346] Enable Module: %s - %s\n", (signed int)m == BLADERF_MODULE_RX ? "RX" : "TX", enable != (_Bool)0 ? "True" : "False");
    while((_Bool)0);
    pthread_mutex_lock(&dev->ctrl_lock);
    if((signed int)enable == 0)
    {
      sync_deinit(dev->sync[(signed long int)m]);
      dev->sync[(signed long int)m] = (struct bladerf_sync *)(void *)0;
      perform_format_deconfig(dev, m);
    }

    lms_enable_rffe(dev, m, enable);
    status=dev->fn->enable_module(dev, m, enable);
    pthread_mutex_unlock(&dev->ctrl_lock);
    return status;
  }
}

// bladerf_erase_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1189
signed int bladerf_erase_flash(struct bladerf *dev, unsigned int erase_block, unsigned int count)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=flash_erase(dev, erase_block, count);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_erase_stored_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1320
signed int bladerf_erase_stored_fpga(struct bladerf *dev)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=flash_erase_fpga(dev);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_expansion_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1588
signed int bladerf_expansion_attach(struct bladerf *dev, enum anonymous_6 xb)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=xb_attach(dev, xb);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_expansion_get_attached
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1599
signed int bladerf_expansion_get_attached(struct bladerf *dev, enum anonymous_6 *xb)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  if((signed int)dev->xb == BLADERF_XB_NONE || (signed int)dev->xb == BLADERF_XB_100 || (signed int)dev->xb == BLADERF_XB_200)
  {
    status = 0;
    *xb = dev->xb;
    goto __CPROVER_DUMP_L3;
  }

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:1613] Device handle contains invalid XB id: %d\n", dev->xb);
  while((_Bool)0);
  status = -1;

__CPROVER_DUMP_L3:
  ;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_expansion_gpio_dir_masked_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1739
signed int bladerf_expansion_gpio_dir_masked_write(struct bladerf *dev, unsigned int mask, unsigned int val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap(dev, (unsigned long int)(1 << 7));
  if(return_value_have_cap_1 == (_Bool)0 && !(val == 0xffffffff))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:1748] FPGA >= v0.4.1 is required for masked XB GPIO dir writes.\n");
    while((_Bool)0);
    status = -8;
  }

  else
    status=dev->fn->expansion_gpio_dir_write(dev, mask, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_expansion_gpio_dir_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1723
signed int bladerf_expansion_gpio_dir_read(struct bladerf *dev, unsigned int *val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->expansion_gpio_dir_read(dev, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_expansion_gpio_dir_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1734
signed int bladerf_expansion_gpio_dir_write(struct bladerf *dev, unsigned int val)
{
  signed int return_value_bladerf_expansion_gpio_dir_masked_write_1;
  return_value_bladerf_expansion_gpio_dir_masked_write_1=bladerf_expansion_gpio_dir_masked_write(dev, 0xffffffff, val);
  return return_value_bladerf_expansion_gpio_dir_masked_write_1;
}

// bladerf_expansion_gpio_masked_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1700
signed int bladerf_expansion_gpio_masked_write(struct bladerf *dev, unsigned int mask, unsigned int val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap(dev, (unsigned long int)(1 << 7));
  if(return_value_have_cap_1 == (_Bool)0 && !(val == 0xffffffff))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:1709] FPGA >= v0.4.1 is required for masked XB GPIO writes.\n");
    while((_Bool)0);
    status = -8;
  }

  else
    status=dev->fn->expansion_gpio_write(dev, mask, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_expansion_gpio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1678
signed int bladerf_expansion_gpio_read(struct bladerf *dev, unsigned int *val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->expansion_gpio_read(dev, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_expansion_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1689
signed int bladerf_expansion_gpio_write(struct bladerf *dev, unsigned int val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->expansion_gpio_write(dev, 0xffffffff, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_flash_firmware
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1262
signed int bladerf_flash_firmware(struct bladerf *dev, const char *firmware_file)
{
  signed int status;
  unsigned char *buf = (unsigned char *)(void *)0;
  unsigned long int buf_size;
  const char env_override[27l] = { 'B', 'L', 'A', 'D', 'E', 'R', 'F', '_', 'S', 'K', 'I', 'P', '_', 'F', 'W', '_', 'S', 'I', 'Z', 'E', '_', 'C', 'H', 'E', 'C', 'K', 0 };
  pthread_mutex_lock(&dev->ctrl_lock);
  status=file_read_buffer(firmware_file, &buf, &buf_size);
  char *return_value_getenv_1;
  _Bool tmp_if_expr_3;
  _Bool return_value_valid_fw_size_2;
  if(status == 0)
  {
    return_value_getenv_1=getenv(env_override);
    if(return_value_getenv_1 == ((char *)NULL))
    {
      return_value_valid_fw_size_2=valid_fw_size(buf_size);
      tmp_if_expr_3 = !(return_value_valid_fw_size_2 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ bladerf.c:1283] Detected potentially invalid firmware file.\n");
      while((_Bool)0);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ bladerf.c:1285] Define BLADERF_SKIP_FW_SIZE_CHECK in your evironment to skip this check.\n");
      while((_Bool)0);
      status = -3;
    }

    else
      status=flash_write_fx3_fw(dev, &buf, buf_size);
  }


out:
  ;
  pthread_mutex_unlock(&dev->ctrl_lock);
  free((void *)buf);
  return status;
}

// bladerf_flash_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1309
signed int bladerf_flash_fpga(struct bladerf *dev, const char *fpga_file)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=fpga_write_to_flash(dev, fpga_file);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_fpga_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1168
signed int bladerf_fpga_version(struct bladerf *dev, struct bladerf_version *version)
{
  pthread_mutex_lock(&dev->ctrl_lock);
  memcpy((void *)version, (const void *)&dev->fpga_version, sizeof(struct bladerf_version) /*16ul*/ );
  pthread_mutex_unlock(&dev->ctrl_lock);
  return 0;
}

// bladerf_free_device_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 83
void bladerf_free_device_list(struct bladerf_devinfo *devices)
{
  free((void *)devices);
}

// bladerf_free_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2699
void bladerf_free_image(struct bladerf_image *image)
{
  if(!(image == ((struct bladerf_image *)NULL)))
  {
    free((void *)image->data);
    free((void *)image);
  }

}

// bladerf_fw_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1149
signed int bladerf_fw_version(struct bladerf *dev, struct bladerf_version *version)
{
  pthread_mutex_lock(&dev->ctrl_lock);
  memcpy((void *)version, (const void *)&dev->fw_version, sizeof(struct bladerf_version) /*16ul*/ );
  pthread_mutex_unlock(&dev->ctrl_lock);
  return 0;
}

// bladerf_get_bandwidth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1281
signed int bladerf_get_bandwidth(struct bladerf *dev, enum anonymous module, unsigned int *bandwidth)
{
  signed int status;
  enum anonymous_13 bw;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_get_bandwidth(dev, module, &bw);
  if(status == 0)
    *bandwidth=lms_bw2uint(bw);

  else
    *bandwidth = (unsigned int)0;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_bootloader_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1934
signed int bladerf_get_bootloader_list(struct bladerf_devinfo **devices)
{
  signed int return_value_probe_1;
  return_value_probe_1=probe((enum anonymous_15)BACKEND_PROBE_FX3_BOOTLOADER, devices);
  return return_value_probe_1;
}

// bladerf_get_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1796
signed int bladerf_get_correction(struct bladerf *dev, enum anonymous module, enum anonymous_36 corr, signed short int *value)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  switch((signed int)corr)
  {
    case BLADERF_CORR_FPGA_PHASE:
      status=dev->fn->get_iq_phase_correction(dev, module, value);
    case BLADERF_CORR_FPGA_GAIN:
      status=dev->fn->get_iq_gain_correction(dev, module, value);
    case BLADERF_CORR_LMS_DCOFF_I:
    {
      status=lms_get_dc_offset_i(dev, module, value);
      break;
    }
    case BLADERF_CORR_LMS_DCOFF_Q:
    {
      status=lms_get_dc_offset_q(dev, module, value);
      break;
    }
    default:
    {
      status = -3;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:1826] Invalid correction type: %d\n", corr);
      while((_Bool)0);
    }
  }
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_device_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 78
signed int bladerf_get_device_list(struct bladerf_devinfo **devices)
{
  signed int return_value_probe_1;
  return_value_probe_1=probe((enum anonymous_15)BACKEND_PROBE_BLADERF, devices);
  return return_value_probe_1;
}

// bladerf_get_devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1431
signed int bladerf_get_devinfo(struct bladerf *dev, struct bladerf_devinfo *info)
{
  if(!(dev == ((struct bladerf *)NULL)))
  {
    pthread_mutex_lock(&dev->ctrl_lock);
    memcpy((void *)info, (const void *)&dev->ident, sizeof(struct bladerf_devinfo) /*44ul*/ );
    pthread_mutex_unlock(&dev->ctrl_lock);
    return 0;
  }

  else
    return -3;
}

// bladerf_get_devinfo_from_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1443
signed int bladerf_get_devinfo_from_str(const char *devstr, struct bladerf_devinfo *info)
{
  signed int return_value_str2devinfo_1;
  return_value_str2devinfo_1=str2devinfo(devstr, info);
  return return_value_str2devinfo_1;
}

// bladerf_get_fpga_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1141
signed int bladerf_get_fpga_size(struct bladerf *dev, enum anonymous_5 *size)
{
  pthread_mutex_lock(&dev->ctrl_lock);
  *size = dev->fpga_size;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return 0;
}

// bladerf_get_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1422
signed int bladerf_get_frequency(struct bladerf *dev, enum anonymous module, unsigned int *frequency)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=tuning_get_freq(dev, module, frequency);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_fw_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1979
signed int bladerf_get_fw_log(struct bladerf *dev, const char *filename)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=fx3_fw_log_dump(dev, filename);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_lna_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 696
signed int bladerf_get_lna_gain(struct bladerf *dev, enum anonymous_12 *gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_lna_get_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 422
signed int bladerf_get_loopback(struct bladerf *dev, enum anonymous_3 *l)
{
  signed int status = -1;
  *l = (enum anonymous_3)BLADERF_LB_NONE;
  pthread_mutex_lock(&dev->ctrl_lock);
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap(dev, (unsigned long int)1 << 32);
  if(!(return_value_have_cap_1 == (_Bool)0))
  {
    _Bool fw_lb_enabled;
    status=dev->fn->get_firmware_loopback(dev, &fw_lb_enabled);
    if(status == 0 && !(fw_lb_enabled == (_Bool)0))
      *l = (enum anonymous_3)BLADERF_LB_FIRMWARE;

  }

  if((signed int)*l == BLADERF_LB_NONE)
    status=lms_get_loopback_mode(dev, l);

  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_lpf_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 832
signed int bladerf_get_lpf_mode(struct bladerf *dev, enum anonymous module, enum anonymous_14 *mode)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_lpf_get_mode(dev, module, mode);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_quick_tune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 944
signed int bladerf_get_quick_tune(struct bladerf *dev, enum anonymous module, struct bladerf_quick_tune *quick_tune)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_get_quick_tune(dev, module, quick_tune);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_rational_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1003
signed int bladerf_get_rational_sample_rate(struct bladerf *dev, enum anonymous module, struct bladerf_rational_rate *rate)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=si5338_get_rational_sample_rate(dev, module, rate);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_rational_smb_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 595
signed int bladerf_get_rational_smb_frequency(struct bladerf *dev, struct bladerf_rational_rate *rate)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=si5338_get_rational_smb_freq(dev, rate);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_rx_mux
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 484
signed int bladerf_get_rx_mux(struct bladerf *dev, enum anonymous_33 *mux)
{
  enum anonymous_33 val;
  unsigned int config_gpio;
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->config_gpio_read(dev, &config_gpio);
  if(status == 0)
  {
    config_gpio = config_gpio & (unsigned int)(0x7 << 8);
    config_gpio = config_gpio >> 8;
    val = (enum anonymous_33)config_gpio;
    if((signed int)val == BLADERF_RX_MUX_BASEBAND_LMS || (signed int)val == BLADERF_RX_MUX_12BIT_COUNTER || (signed int)val == BLADERF_RX_MUX_32BIT_COUNTER || (signed int)val == BLADERF_RX_MUX_DIGITAL_LOOPBACK)
      *mux = val;

    *mux = (enum anonymous_33)BLADERF_RX_MUX_INVALID;
    status = -1;
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:512] Invalid rx mux mode %d read from config gpio\n", val);
  }


out:
  ;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_rxvga1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 718
signed int bladerf_get_rxvga1(struct bladerf *dev, signed int *gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_rxvga1_get_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_rxvga2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 740
signed int bladerf_get_rxvga2(struct bladerf *dev, signed int *gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_rxvga2_get_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 558
signed int bladerf_get_sample_rate(struct bladerf *dev, enum anonymous module, unsigned int *rate)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=si5338_get_sample_rate(dev, module, rate);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_sampling
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 618
signed int bladerf_get_sampling(struct bladerf *dev, enum anonymous_34 *sampling)
{
  signed int status = 0;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_get_sampling(dev, sampling);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1125
signed int bladerf_get_serial(struct bladerf *dev, char *serial)
{
  pthread_mutex_lock(&dev->ctrl_lock);
  strcpy(serial, dev->ident.serial);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return 0;
}

// bladerf_get_smb_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 607
signed int bladerf_get_smb_frequency(struct bladerf *dev, unsigned int *rate)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=si5338_get_smb_freq(dev, rate);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_stream_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 983
signed int bladerf_get_stream_timeout(struct bladerf *dev, enum anonymous module, unsigned int *timeout)
{
  if(!(dev == ((struct bladerf *)NULL)))
  {
    pthread_mutex_lock(&dev->ctrl_lock);
    *timeout = (unsigned int)dev->transfer_timeout[(signed long int)module];
    pthread_mutex_unlock(&dev->ctrl_lock);
    return 0;
  }

  else
    return -3;
}

// bladerf_get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1836
signed int bladerf_get_timestamp(struct bladerf *dev, enum anonymous module, unsigned long int *value)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->get_timestamp(dev, module, value);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_txvga1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 673
signed int bladerf_get_txvga1(struct bladerf *dev, signed int *gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_txvga1_get_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_txvga2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 651
signed int bladerf_get_txvga2(struct bladerf *dev, signed int *gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_txvga2_get_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1889
signed int bladerf_get_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 *mode)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->get_vctcxo_tamer_mode(dev, mode);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_get_vctcxo_trim
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1133
signed int bladerf_get_vctcxo_trim(struct bladerf *dev, unsigned short int *trim)
{
  pthread_mutex_lock(&dev->ctrl_lock);
  *trim = dev->dac_trim;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return 0;
}

// bladerf_image_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2744
signed int bladerf_image_read(struct bladerf_image *img, const char *file)
{
  signed int rv = -1;
  unsigned char *buf = (unsigned char *)(void *)0;
  unsigned long int buf_len;
  rv=file_read_buffer(file, &buf, &buf_len);
  if(rv >= 0)
  {
    rv=verify_checksum(buf, buf_len);
    if(rv >= 0)
      rv=unpack_image(img, buf, buf_len);

  }


bladerf_image_read_out:
  ;
  if(!(rv == 0))
    free((void *)buf);

  return rv;
}

// bladerf_image_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 276
signed int bladerf_image_write(struct bladerf_image *img, const char *file)
{
  signed int rv;
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  unsigned char *buf = (unsigned char *)(void *)0;
  unsigned long int buf_len;
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)img->magic, (const void *)image_magic, (unsigned long int)7);
  if(!(return_value_memcmp_1 == 0))
  {
    char badmagic[8l];
    memset((void *)badmagic, 0, sizeof(char [8l]) /*8ul*/ );
    memcpy((void *)&badmagic, (const void *)&img->magic, (unsigned long int)7);
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:289] Invalid file format magic value: %s\n", (const void *)badmagic);
    while((_Bool)0);
    return -3;
  }

  _Bool return_value_image_type_is_valid_2;
  return_value_image_type_is_valid_2=image_type_is_valid(img->type);
  if(return_value_image_type_is_valid_2 == (_Bool)0)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:296] Invalid image type: %d\n", img->type);
    while((_Bool)0);
    return -3;
  }

  else
    if(img->data == ((unsigned char *)NULL))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:302] Image data pointer is NULL\n");
      while((_Bool)0);
      return -3;
    }

    else
    {
      buf_len = (unsigned long int)((unsigned long int)(7 + 32) + (unsigned long int)3 * sizeof(unsigned short int) /*2ul*/  + sizeof(unsigned long int) /*8ul*/  + (unsigned long int)33 + (unsigned long int)128 + (unsigned long int)3 * sizeof(unsigned int) /*4ul*/  + (unsigned long int)img->length);
      void *return_value_calloc_3;
      return_value_calloc_3=calloc((unsigned long int)1, buf_len);
      buf = (unsigned char *)return_value_calloc_3;
      if(buf == ((unsigned char *)NULL))
      {
        do
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(*return_value___errno_location_4);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ image.c:309] calloc failed: %s\n", return_value_strerror_5);
        }
        while((_Bool)0);
        return -4;
      }

      else
      {
        if((signed int)img->type == BLADERF_IMAGE_TYPE_RAW)
        {
          if(!(img->address % 65536u == 0u))
          {
            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:317] Image address must be erase block-aligned for RAW.\n");
            while((_Bool)0);
            rv = -3;
            goto error;
          }

          if(img->length % 65536u == 0u)
            goto __CPROVER_DUMP_L12;

          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:321] Image length must be erase block-aligned for RAW.\n");
          while((_Bool)0);
          rv = -3;
        }

        else
        {

        __CPROVER_DUMP_L12:
          ;
          pack_image(img, buf);
          f=fopen(file, "wb");
          if(f == ((struct _IO_FILE *)NULL))
          {
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            if(*return_value___errno_location_6 == 13)
              rv = -17;

            else
              rv = -5;
            do
            {
              signed int *return_value___errno_location_7;
              return_value___errno_location_7=__errno_location();
              char *return_value_strerror_8;
              return_value_strerror_8=strerror(*return_value___errno_location_7);
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:337] Failed to open \"%s\": %s\n", file, return_value_strerror_8);
            }
            while((_Bool)0);
            goto error;
          }

          rv=file_write(f, buf, buf_len);
        }

      error:
        ;
        if(!(f == ((struct _IO_FILE *)NULL)))
          fclose(f);

        free((void *)buf);
        return rv;
      }
    }
}

// bladerf_init_devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 338
void bladerf_init_devinfo(struct bladerf_devinfo *info)
{
  info->backend = (enum anonymous_11)BLADERF_BACKEND_ANY;
  memset((void *)info->serial, 0, (unsigned long int)33);
  strncpy(info->serial, "ANY", (unsigned long int)(33 - 1));
  info->usb_bus = (unsigned char)255;
  info->usb_addr = (unsigned char)255;
  info->instance = (unsigned int)0x7fffffff * 2U + 1U;
}

// bladerf_init_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1055
signed int bladerf_init_stream(struct bladerf_stream **stream, struct bladerf *dev, void * (*callback)(struct bladerf *, struct bladerf_stream *, struct bladerf_metadata *, void *, unsigned long int, void *), void ***buffers, unsigned long int num_buffers, enum anonymous_9 format, unsigned long int samples_per_buffer, unsigned long int num_transfers, void *data)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=async_init_stream(stream, dev, callback, buffers, num_buffers, format, samples_per_buffer, num_transfers, data);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_instance_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.h line 53
_Bool bladerf_instance_matches(struct bladerf_devinfo *a, struct bladerf_devinfo *b)
{
  _Bool tmp_if_expr_1;
  if(a->instance == 1U)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = b->instance == (unsigned int)0x7fffffff * 2U + 1U ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = a->instance == b->instance ? (_Bool)1 : (_Bool)0;
  return tmp_if_expr_2;
}

// bladerf_is_fpga_configured
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1157
signed int bladerf_is_fpga_configured(struct bladerf *dev)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->is_fpga_configured(dev);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_jump_to_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1236
signed int bladerf_jump_to_bootloader(struct bladerf *dev)
{
  signed int status;
  if(dev->fn->jump_to_bootloader == ((signed int (*)(struct bladerf *))NULL))
    return -8;

  else
  {
    pthread_mutex_lock(&dev->ctrl_lock);
    status=dev->fn->jump_to_bootloader(dev);
    pthread_mutex_unlock(&dev->ctrl_lock);
    return status;
  }
}

// bladerf_lms_get_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1546
signed int bladerf_lms_get_dc_cals(struct bladerf *dev, struct bladerf_lms_dc_cals *dc_cals)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_get_dc_cals(dev, dc_cals);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_lms_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1512
signed int bladerf_lms_read(struct bladerf *dev, unsigned char address, unsigned char *val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->lms_read(dev, address, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_lms_set_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1534
signed int bladerf_lms_set_dc_cals(struct bladerf *dev, struct bladerf_lms_dc_cals *dc_cals)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_set_dc_cals(dev, dc_cals);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_lms_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1523
signed int bladerf_lms_write(struct bladerf *dev, unsigned char address, unsigned char val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->lms_write(dev, address, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_load_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1297
signed int bladerf_load_fpga(struct bladerf *dev, const char *fpga_file)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=fpga_load_from_file(dev, fpga_file);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_load_fw_from_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1939
signed int bladerf_load_fw_from_bootloader(const char *device_identifier, enum anonymous_11 backend, unsigned char bus, unsigned char addr, const char *file)
{
  signed int status;
  struct fx3_firmware *fw = (struct fx3_firmware *)(void *)0;
  struct bladerf_devinfo devinfo;
  if(device_identifier == ((const char *)NULL))
  {
    bladerf_init_devinfo(&devinfo);
    devinfo.backend = backend;
    devinfo.usb_bus = bus;
    devinfo.usb_addr = addr;
  }

  else
  {
    status=str2devinfo(device_identifier, &devinfo);
    if(!(status == 0))
      return status;

  }
  status=fx3_fw_read(file, &fw);
  if(!(status == 0))
    return status;

  else
  {
    /* assertion fw != ((void *)0) */
    assert(fw != (struct fx3_firmware *)(void *)0);
    status=backend_load_fw_from_bootloader(devinfo.backend, devinfo.usb_bus, devinfo.usb_addr, fw);
    fx3_fw_deinit(fw);
    return status;
  }
}

// bladerf_log_set_verbosity
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1407
void bladerf_log_set_verbosity(enum anonymous_26 level)
{
  log_set_verbosity(level);
}

// bladerf_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 286
signed int bladerf_open(struct bladerf **device, const char *dev_id)
{
  struct bladerf_devinfo devinfo;
  signed int status;
  *device = (struct bladerf *)(void *)0;
  status=str2devinfo(dev_id, &devinfo);
  if(status == 0)
    status=bladerf_open_with_devinfo(device, &devinfo);

  return status;
}

// bladerf_open_with_devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 225
signed int bladerf_open_with_devinfo(struct bladerf **opened_device, struct bladerf_devinfo *devinfo)
{
  struct bladerf *dev;
  struct bladerf_devinfo any_device;
  signed int status;
  if(devinfo == ((struct bladerf_devinfo *)NULL))
  {
    bladerf_init_devinfo(&any_device);
    devinfo = &any_device;
  }

  *opened_device = (struct bladerf *)(void *)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct bladerf) /*320ul*/ );
  dev = (struct bladerf *)return_value_calloc_1;
  if(dev == ((struct bladerf *)NULL))
    return -4;

  else
  {
    pthread_mutex_init(&dev->ctrl_lock, (const union anonymous_27 *)(void *)0);
    pthread_mutex_init(&dev->sync_lock[(signed long int)BLADERF_MODULE_RX], (const union anonymous_27 *)(void *)0);
    pthread_mutex_init(&dev->sync_lock[(signed long int)BLADERF_MODULE_TX], (const union anonymous_27 *)(void *)0);
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, (unsigned long int)(32 + 1));
    dev->fpga_version.describe = (const char *)return_value_calloc_2;
    if(dev->fpga_version.describe == ((const char *)NULL))
    {
      free((void *)dev);
      return -4;
    }

    else
    {
      void *return_value_calloc_3;
      return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)(32 + 1));
      dev->fw_version.describe = (const char *)return_value_calloc_3;
      if(dev->fw_version.describe == ((const char *)NULL))
      {
        free((void *)dev->fpga_version.describe);
        free((void *)dev);
        return -4;
      }

      else
      {
        dev->capabilities = (unsigned long int)0;
        status=backend_open(dev, devinfo);
        if(!(status == 0))
        {
          free((void *)dev->fw_version.describe);
          free((void *)dev->fpga_version.describe);
          free((void *)dev);
          return status;
        }

        else
        {
          status=dev->fn->get_device_speed(dev, &dev->usb_speed);
          if(!(status >= 0))
          {
            const char *return_value_bladerf_strerror_4;
            return_value_bladerf_strerror_4=bladerf_strerror(status);
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:140] Failed to get device speed: %s\n", return_value_bladerf_strerror_4);
          }

          else
          {
            if((signed int)dev->usb_speed == BLADERF_DEVICE_SPEED_SUPER)
            {
              dev->msg_size = (unsigned long int)2048;
              dev->msg_size = (unsigned long int)1024;
            }

            status = -1;
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ bladerf.c:155] Unsupported device speed: %d\n", dev->usb_speed);
            status=version_check_fw(dev);
            if(!(status == 0))
            {
              if(status == -13)
              {
                struct bladerf_version req;
                const unsigned int dev_maj = (const unsigned int)dev->fw_version.major;
                const unsigned int dev_min = (const unsigned int)dev->fw_version.minor;
                const unsigned int dev_pat = (const unsigned int)dev->fw_version.patch;
                unsigned int req_maj;
                unsigned int req_min;
                unsigned int req_pat;
                version_required_fw(dev, &req, (_Bool)0);
                req_maj = (unsigned int)req.major;
                req_min = (unsigned int)req.minor;
                req_pat = (unsigned int)req.patch;
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ bladerf.c:180] Firmware v%u.%u.%u was detected. libbladeRF v%s requires firmware v%u.%u.%u or later. An upgrade via the bootloader is required.\n\n", dev_maj, dev_min, dev_pat, (const void *)"1.5.1-0.2016.01~rc1-3", req_maj, req_min, req_pat);
              }

            }

            else
            {
              status=get_and_cache_vctcxo_trim(dev);
              if(!(status >= 0))
              {
                const char *return_value_bladerf_strerror_5;
                return_value_bladerf_strerror_5=bladerf_strerror(status);
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ bladerf.c:193] Failed to get VCTCXO trim value: %s\n", return_value_bladerf_strerror_5);
              }

              status=get_and_cache_fpga_size(dev);
              if(!(status >= 0))
              {
                const char *return_value_bladerf_strerror_6;
                return_value_bladerf_strerror_6=bladerf_strerror(status);
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ bladerf.c:199] Failed to get FPGA size %s\n", return_value_bladerf_strerror_6);
              }

              dev->auto_filter[(signed long int)BLADERF_MODULE_RX] = (enum anonymous_8)-1;
              dev->auto_filter[(signed long int)BLADERF_MODULE_TX] = (enum anonymous_8)-1;
              dev->module_format[(signed long int)BLADERF_MODULE_RX] = (enum anonymous_9)-1;
              dev->module_format[(signed long int)BLADERF_MODULE_TX] = (enum anonymous_9)-1;
              dev->tuning_mode = (enum anonymous_10)BLADERF_TUNING_MODE_INVALID;
              status=config_load_dc_cals(dev);
              if(status == 0)
              {
                status=dev->fn->is_fpga_configured(dev);
                if(status >= 1)
                {
                  fpga_check_version(dev);
                  _Bool return_value_have_cap_9;
                  return_value_have_cap_9=have_cap(dev, (unsigned long int)(1 << 3));
                  if(!(return_value_have_cap_9 == (_Bool)0))
                  {
                    status=tuning_cancel_scheduled(dev, (enum anonymous)BLADERF_MODULE_RX);
                    if(!(status == 0))
                    {
                      const char *return_value_bladerf_strerror_7;
                      return_value_bladerf_strerror_7=bladerf_strerror(status);
                      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ bladerf.c:235] Failed to cancel any pending RX retunes: %s\n", return_value_bladerf_strerror_7);
                    }

                    status=tuning_cancel_scheduled(dev, (enum anonymous)BLADERF_MODULE_TX);
                    if(!(status == 0))
                    {
                      const char *return_value_bladerf_strerror_8;
                      return_value_bladerf_strerror_8=bladerf_strerror(status);
                      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ bladerf.c:241] Failed to cancel any pending TX retunes: %s\n", return_value_bladerf_strerror_8);
                    }

                  }

                  status=init_device(dev);
                }

                else
                  status=config_load_fpga(dev);
              }

            }
          }

        error:
          ;
          if(!(status >= 0))
            bladerf_close(dev);

          else
            *opened_device = dev;
          return status;
        }
      }
    }
  }
}

// bladerf_read_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1201
signed int bladerf_read_flash(struct bladerf *dev, unsigned char *buf, unsigned int page, unsigned int count)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=flash_read(dev, buf, page, count);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_schedule_retune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 869
signed int bladerf_schedule_retune(struct bladerf *dev, enum anonymous module, unsigned long int timestamp, unsigned int frequency, struct bladerf_quick_tune *quick_tune)
{
  signed int status;
  struct lms_freq f;
  pthread_mutex_lock(&dev->ctrl_lock);
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap(dev, (unsigned long int)(1 << 3));
  if(return_value_have_cap_1 == (_Bool)0)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:884] This FPGA version (%u.%u.%u) does not support scheduled retunes.\n", dev->fpga_version.major, dev->fpga_version.minor, dev->fpga_version.patch);
    while((_Bool)0);
    status = -8;
  }

  else
    if(quick_tune == ((struct bladerf_quick_tune *)NULL))
    {
      status=lms_calculate_tuning_params(frequency, &f);
      if(status == 0)
        status=tuning_schedule(dev, module, timestamp, &f);

    }

    else
    {
      f.freqsel = quick_tune->freqsel;
      f.vcocap = quick_tune->vcocap;
      f.nint = quick_tune->nint;
      f.nfrac = quick_tune->nfrac;
      f.flags = quick_tune->flags;
      f.x = (unsigned char)0;
      f.vcocap_result = (unsigned char)0;
      status=tuning_schedule(dev, module, timestamp, &f);
    }

out:
  ;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_select_band
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 844
signed int bladerf_select_band(struct bladerf *dev, enum anonymous module, unsigned int frequency)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=band_select(dev, module, frequency < (unsigned int)1500000000);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_serial_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/devinfo.h line 65
_Bool bladerf_serial_matches(struct bladerf_devinfo *a, struct bladerf_devinfo *b)
{
  _Bool wildcard_match;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(a->serial, "ANY");
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(return_value_strcmp_1 == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strcmp_2=strcmp(b->serial, "ANY");
    tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  wildcard_match = tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  char *return_value_strstr_5;
  if(!(wildcard_match == (_Bool)0))
    return (_Bool)1;

  else
  {
    _Bool subset_match;
    char *return_value_strstr_4;
    return_value_strstr_4=strstr(a->serial, b->serial);
    if(return_value_strstr_4 == a->serial)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strstr_5=strstr(b->serial, a->serial);
      tmp_if_expr_6 = return_value_strstr_5 == b->serial ? (_Bool)1 : (_Bool)0;
    }
    subset_match = tmp_if_expr_6;
    return subset_match;
  }
}

// bladerf_set_bandwidth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1267
signed int bladerf_set_bandwidth(struct bladerf *dev, enum anonymous module, unsigned int bandwidth, unsigned int *actual)
{
  signed int status;
  enum anonymous_13 bw;
  pthread_mutex_lock(&dev->ctrl_lock);
  if(!(bandwidth >= 1500000u))
  {
    bandwidth = 1500000u;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ bladerf.c:773] Clamping bandwidth to %dHz\n", bandwidth);
    while((_Bool)0);
  }

  else
    if(bandwidth >= 28000001u)
    {
      bandwidth = 28000000u;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ bladerf.c:776] Clamping bandwidth to %dHz\n", bandwidth);
      while((_Bool)0);
    }

  bw=lms_uint2bw(bandwidth);
  status=lms_lpf_enable(dev, module, (_Bool)1);
  if(status == 0)
  {
    status=lms_set_bandwidth(dev, module, bw);
    if(!(actual == ((unsigned int *)NULL)))
    {
      if(status == 0)
        *actual=lms_bw2uint(bw);

      else
        *actual = (unsigned int)0;
    }

  }


out:
  ;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1761
signed int bladerf_set_correction(struct bladerf *dev, enum anonymous module, enum anonymous_36 corr, signed short int value)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  switch((signed int)corr)
  {
    case BLADERF_CORR_FPGA_PHASE:
      status=dev->fn->set_iq_phase_correction(dev, module, value);
    case BLADERF_CORR_FPGA_GAIN:
    {
      value = value + (signed short int)4096;
      status=dev->fn->set_iq_gain_correction(dev, module, value);
    }
    case BLADERF_CORR_LMS_DCOFF_I:
    {
      status=lms_set_dc_offset_i(dev, module, (unsigned short int)value);
      break;
    }
    case BLADERF_CORR_LMS_DCOFF_Q:
    {
      status=lms_set_dc_offset_q(dev, module, value);
      break;
    }
    default:
    {
      status = -3;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:1788] Invalid correction type: %d\n", corr);
      while((_Bool)0);
    }
  }
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1353
signed int bladerf_set_frequency(struct bladerf *dev, enum anonymous module, unsigned int frequency)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=tuning_set_freq(dev, module, frequency);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 752
signed int bladerf_set_gain(struct bladerf *dev, enum anonymous mod, signed int gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=gain_set(dev, mod, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_lna_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1169
signed int bladerf_set_lna_gain(struct bladerf *dev, enum anonymous_12 gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_lna_set_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 363
signed int bladerf_set_loopback(struct bladerf *dev, enum anonymous_3 l)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  if((signed int)l == BLADERF_LB_FIRMWARE)
  {
    _Bool return_value_have_cap_1;
    return_value_have_cap_1=have_cap(dev, (unsigned long int)1 << 32);
    if(return_value_have_cap_1 == (_Bool)0)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ bladerf.c:374] Firmware v1.7.1 or later is required to use firmware loopback.\n\n");
      while((_Bool)0);
      status = -13;
      goto out;
    }

    else
    {
      status=lms_set_loopback_mode(dev, (enum anonymous_3)BLADERF_LB_RF_LNA3);
      if(!(status == 0))
        goto out;

      status=dev->fn->set_firmware_loopback(dev, (_Bool)1);
    }
  }

  else
  {
    _Bool return_value_have_cap_2;
    return_value_have_cap_2=have_cap(dev, (unsigned long int)1 << 32);
    if(!(return_value_have_cap_2 == (_Bool)0))
    {
      _Bool fw_lb_enabled = (_Bool)0;
      status=dev->fn->get_firmware_loopback(dev, &fw_lb_enabled);
      if(!(fw_lb_enabled == (_Bool)0))
        status=dev->fn->set_firmware_loopback(dev, (_Bool)0);

    }

    status=lms_set_loopback_mode(dev, l);
  }

out:
  ;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_lpf_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 820
signed int bladerf_set_lpf_mode(struct bladerf *dev, enum anonymous module, enum anonymous_14 mode)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_lpf_set_mode(dev, module, mode);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_rational_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 521
signed int bladerf_set_rational_sample_rate(struct bladerf *dev, enum anonymous module, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=si5338_set_rational_sample_rate(dev, module, rate, actual);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_rational_smb_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 570
signed int bladerf_set_rational_smb_frequency(struct bladerf *dev, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=si5338_set_rational_smb_freq(dev, rate, actual);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_rx_mux
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 446
signed int bladerf_set_rx_mux(struct bladerf *dev, enum anonymous_33 mux)
{
  unsigned int rx_mux_val;
  unsigned int config_gpio;
  signed int status;
  if((signed int)mux == BLADERF_RX_MUX_BASEBAND_LMS || (signed int)mux == BLADERF_RX_MUX_12BIT_COUNTER || (signed int)mux == BLADERF_RX_MUX_32BIT_COUNTER || (signed int)mux == BLADERF_RX_MUX_DIGITAL_LOOPBACK)
  {
    rx_mux_val = (unsigned int)mux << 8;
    goto __CPROVER_DUMP_L3;
  }

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf.c:462] Invalid RX mux mode setting passed to %s(): %d\n", mux, (const void *)"bladerf_set_rx_mux");
  while((_Bool)0);
  return -3;

__CPROVER_DUMP_L3:
  ;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->config_gpio_read(dev, &config_gpio);
  if(status == 0)
  {
    config_gpio = config_gpio & (unsigned int)~(0x7 << 8);
    config_gpio = config_gpio | rx_mux_val;
    status=config_gpio_write(dev, config_gpio);
  }


out:
  ;
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_rxvga1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1193
signed int bladerf_set_rxvga1(struct bladerf *dev, signed int gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_rxvga1_set_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_rxvga2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1217
signed int bladerf_set_rxvga2(struct bladerf *dev, signed int gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_rxvga2_set_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 920
signed int bladerf_set_sample_rate(struct bladerf *dev, enum anonymous module, unsigned int rate, unsigned int *actual)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=si5338_set_sample_rate(dev, module, rate, actual);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_sampling
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 629
signed int bladerf_set_sampling(struct bladerf *dev, enum anonymous_34 sampling)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_select_sampling(dev, sampling);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_smb_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 583
signed int bladerf_set_smb_frequency(struct bladerf *dev, unsigned int rate, unsigned int *actual)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=si5338_set_smb_freq(dev, rate, actual);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_stream_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 969
signed int bladerf_set_stream_timeout(struct bladerf *dev, enum anonymous module, unsigned int timeout)
{
  if(!(dev == ((struct bladerf *)NULL)))
  {
    pthread_mutex_lock(&dev->ctrl_lock);
    dev->transfer_timeout[(signed long int)module] = (signed int)timeout;
    pthread_mutex_unlock(&dev->ctrl_lock);
    return 0;
  }

  else
    return -3;
}

// bladerf_set_tuning_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 957
signed int bladerf_set_tuning_mode(struct bladerf *dev, enum anonymous_10 mode)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=tuning_set_mode(dev, mode);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_txvga1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1147
signed int bladerf_set_txvga1(struct bladerf *dev, signed int gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_txvga1_set_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_txvga2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 1121
signed int bladerf_set_txvga2(struct bladerf *dev, signed int gain)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=lms_txvga2_set_gain(dev, gain);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_set_usb_reset_on_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 322
void bladerf_set_usb_reset_on_open(_Bool enabled)
{
  bladerf_usb_reset_device_on_open = enabled;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ bladerf.c:327] USB reset on open %s\n", enabled != (_Bool)0 ? "enabled" : "disabled");
  while((_Bool)0);
}

// bladerf_set_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1877
signed int bladerf_set_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 mode)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->set_vctcxo_tamer_mode(dev, mode);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_si5338_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1486
signed int bladerf_si5338_read(struct bladerf *dev, unsigned char address, unsigned char *val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->si5338_read(dev, address, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_si5338_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1497
signed int bladerf_si5338_write(struct bladerf *dev, unsigned char address, unsigned char val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->si5338_write(dev, address, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1075
signed int bladerf_stream(struct bladerf_stream *stream, enum anonymous module)
{
  signed int stream_status;
  signed int fmt_status;
  pthread_mutex_lock(&stream->dev->ctrl_lock);
  fmt_status=perform_format_config(stream->dev, module, stream->format);
  pthread_mutex_unlock(&stream->dev->ctrl_lock);
  if(!(fmt_status == 0))
    return fmt_status;

  else
  {
    stream_status=async_run_stream(stream, module);
    pthread_mutex_lock(&stream->dev->ctrl_lock);
    fmt_status=perform_format_deconfig(stream->dev, module);
    pthread_mutex_unlock(&stream->dev->ctrl_lock);
    return stream_status == 0 ? fmt_status : stream_status;
  }
}

// bladerf_strerror
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/include/libbladeRF.h line 2508
const char * bladerf_strerror(signed int error)
{
  if(!(error == -1))
  {
    if(error == -2)
      goto __CPROVER_DUMP_L2;

    if(error == -3)
      goto __CPROVER_DUMP_L3;

    if(error == -4)
      goto __CPROVER_DUMP_L4;

    if(error == -5)
      goto __CPROVER_DUMP_L5;

    if(error == -6)
      goto __CPROVER_DUMP_L6;

    if(error == -7)
      goto __CPROVER_DUMP_L7;

    if(error == -8)
      goto __CPROVER_DUMP_L8;

    if(error == -9)
      goto __CPROVER_DUMP_L9;

    if(error == -10)
      goto __CPROVER_DUMP_L10;

    if(error == -11)
      goto __CPROVER_DUMP_L11;

    if(error == -12)
      goto __CPROVER_DUMP_L12;

    if(error == -13)
      goto __CPROVER_DUMP_L13;

    if(error == -14)
      goto __CPROVER_DUMP_L14;

    if(error == -15)
      goto __CPROVER_DUMP_L15;

    if(error == -16)
      goto __CPROVER_DUMP_L16;

    if(error == -17)
      goto __CPROVER_DUMP_L17;

    if(error == -18)
      goto __CPROVER_DUMP_L18;

    if(error == 0)
      goto __CPROVER_DUMP_L19;

  }

  else
  {
    return "An unexpected error occurred";

  __CPROVER_DUMP_L2:
    ;
    return "Provided parameter was out of the allowable range";

  __CPROVER_DUMP_L3:
    ;
    return "Invalid operation or parameter";

  __CPROVER_DUMP_L4:
    ;
    return "A memory allocation error occurred";

  __CPROVER_DUMP_L5:
    ;
    return "File or device I/O failure";

  __CPROVER_DUMP_L6:
    ;
    return "Operation timed out";

  __CPROVER_DUMP_L7:
    ;
    return "No devices available";

  __CPROVER_DUMP_L8:
    ;
    return "Operation not supported";

  __CPROVER_DUMP_L9:
    ;
    return "Misaligned flash access";

  __CPROVER_DUMP_L10:
    ;
    return "Invalid checksum";

  __CPROVER_DUMP_L11:
    ;
    return "File not found";

  __CPROVER_DUMP_L12:
    ;
    return "An FPGA update is required";

  __CPROVER_DUMP_L13:
    ;
    return "A firmware update is required";

  __CPROVER_DUMP_L14:
    ;
    return "Requested timestamp is in the past";

  __CPROVER_DUMP_L15:
    ;
    return "Could not enqueue data into full queue";

  __CPROVER_DUMP_L16:
    ;
    return "An FPGA operation reported a failure";

  __CPROVER_DUMP_L17:
    ;
    return "Insufficient permissions for the requested operation";

  __CPROVER_DUMP_L18:
    ;
    return "The operation would block, but has been requested to be non-blocking";

  __CPROVER_DUMP_L19:
    ;
    return "Success";
  }
  return "Unknown error code";
}

// bladerf_submit_stream_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1098
signed int bladerf_submit_stream_buffer(struct bladerf_stream *stream, void *buffer, unsigned int timeout_ms)
{
  signed int return_value_async_submit_stream_buffer_1;
  return_value_async_submit_stream_buffer_1=async_submit_stream_buffer(stream, buffer, timeout_ms, (_Bool)0);
  return return_value_async_submit_stream_buffer_1;
}

// bladerf_submit_stream_buffer_nb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1105
signed int bladerf_submit_stream_buffer_nb(struct bladerf_stream *stream, void *buffer)
{
  signed int return_value_async_submit_stream_buffer_1;
  return_value_async_submit_stream_buffer_1=async_submit_stream_buffer(stream, buffer, (unsigned int)5000, (_Bool)1);
  return return_value_async_submit_stream_buffer_1;
}

// bladerf_sync_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 995
signed int bladerf_sync_config(struct bladerf *dev, enum anonymous module, enum anonymous_9 format, unsigned int num_buffers, unsigned int buffer_size, unsigned int num_transfers, unsigned int stream_timeout)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=perform_format_config(dev, module, format);
  if(status == 0)
  {
    pthread_mutex_lock(&dev->sync_lock[(signed long int)module]);
    dev->transfer_timeout[(signed long int)module] = (signed int)stream_timeout;
    status=sync_init(dev, module, format, num_buffers, buffer_size, num_transfers, stream_timeout);
    if(!(status == 0))
      perform_format_deconfig(dev, module);

    pthread_mutex_unlock(&dev->sync_lock[(signed long int)module]);
  }

  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_sync_rx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1041
signed int bladerf_sync_rx(struct bladerf *dev, void *samples, unsigned int num_samples, struct bladerf_metadata *metadata, unsigned int timeout_ms)
{
  signed int status;
  pthread_mutex_lock(&dev->sync_lock[(signed long int)BLADERF_MODULE_RX]);
  status=sync_rx(dev, samples, num_samples, metadata, timeout_ms);
  pthread_mutex_unlock(&dev->sync_lock[(signed long int)BLADERF_MODULE_RX]);
  return status;
}

// bladerf_sync_tx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1027
signed int bladerf_sync_tx(struct bladerf *dev, void *samples, unsigned int num_samples, struct bladerf_metadata *metadata, unsigned int timeout_ms)
{
  signed int status;
  pthread_mutex_lock(&dev->sync_lock[(signed long int)BLADERF_MODULE_TX]);
  status=sync_tx(dev, samples, num_samples, metadata, timeout_ms);
  pthread_mutex_unlock(&dev->sync_lock[(signed long int)BLADERF_MODULE_TX]);
  return status;
}

// bladerf_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1399
void bladerf_version(struct bladerf_version *version)
{
  version->major = (unsigned short int)1;
  version->minor = (unsigned short int)5;
  version->patch = (unsigned short int)1;
  version->describe = "1.5.1-0.2016.01~rc1-3";
}

// bladerf_write_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1213
signed int bladerf_write_flash(struct bladerf *dev, const unsigned char *buf, unsigned int page, unsigned int count)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=flash_write(dev, buf, page, count);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_xb200_get_filterbank
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1634
signed int bladerf_xb200_get_filterbank(struct bladerf *dev, enum anonymous module, enum anonymous_8 *filter)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=xb200_get_filterbank(dev, module, filter);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_xb200_get_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1660
signed int bladerf_xb200_get_path(struct bladerf *dev, enum anonymous module, enum anonymous_35 *path)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=xb200_get_path(dev, module, path);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_xb200_set_filterbank
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1621
signed int bladerf_xb200_set_filterbank(struct bladerf *dev, enum anonymous mod, enum anonymous_8 filter)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=xb200_set_filterbank(dev, mod, filter);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_xb200_set_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1647
signed int bladerf_xb200_set_path(struct bladerf *dev, enum anonymous module, enum anonymous_35 path)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=xb200_set_path(dev, module, path);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bladerf_xb_spi_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1905
signed int bladerf_xb_spi_write(struct bladerf *dev, unsigned int val)
{
  signed int status;
  pthread_mutex_lock(&dev->ctrl_lock);
  status=dev->fn->xb_spi(dev, val);
  pthread_mutex_unlock(&dev->ctrl_lock);
  return status;
}

// bm_request_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 742
static inline unsigned char bm_request_type(enum anonymous_28 target_type, enum anonymous_29 req_type, enum anonymous_30 direction)
{
  unsigned char ret = (unsigned char)0;
  switch((signed int)target_type)
  {
    case USB_TARGET_DEVICE:
    {
      ret = ret | (unsigned char)0;
      break;
    }
    case USB_TARGET_INTERFACE:
    {
      ret = ret | (unsigned char)1;
      break;
    }
    case USB_TARGET_ENDPOINT:
    {
      ret = ret | (unsigned char)2;
      break;
    }
    default:
      ret = ret | (unsigned char)3;
  }
  switch((signed int)req_type)
  {
    case USB_REQUEST_STANDARD:
    {
      ret = ret | (unsigned char)0;
      break;
    }
    case USB_REQUEST_CLASS:
    {
      ret = ret | (unsigned char)32;
      break;
    }
    case USB_REQUEST_VENDOR:
      ret = ret | (unsigned char)64;
  }
  switch((signed int)direction)
  {
    case USB_DIR_HOST_TO_DEVICE:
    {
      ret = ret | (unsigned char)0;
      break;
    }
    case USB_DIR_DEVICE_TO_HOST:
      ret = ret | (unsigned char)128;
  }
  return ret;
}

// bus_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 627
static inline _Bool bus_matches(unsigned char bus, struct libusb_device *d)
{
  _Bool tmp_if_expr_2;
  unsigned char return_value_libusb_get_bus_number_1;
  if((signed int)bus == 255)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_libusb_get_bus_number_1=libusb_get_bus_number(d);
    tmp_if_expr_2 = bus == return_value_libusb_get_bus_number_1 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr_2;
}

// bytes_to_sc16q11
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 145
static inline unsigned long int bytes_to_sc16q11(unsigned long int n_bytes)
{
  const unsigned long int sample_size = (unsigned long int)2 * sizeof(signed short int) /*2ul*/ ;
  /* assertion (n_bytes % sample_size) == 0 */
  assert(n_bytes % sample_size == (unsigned long int)0);
  return n_bytes / sample_size;
}

// cancel_all_transfers
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 864
static inline void cancel_all_transfers(struct bladerf_stream *stream)
{
  unsigned long int i;
  signed int status;
  struct lusb_stream_data *stream_data = (struct lusb_stream_data *)stream->backend_data;
  i = (unsigned long int)0;
  for( ; !(i >= stream_data->num_transfers); i = i + 1ul)
    if((signed int)stream_data->transfer_status[(signed long int)i] == TRANSFER_IN_FLIGHT)
    {
      status=libusb_cancel_transfer(stream_data->transfers[(signed long int)i]);
      if(!(status == -5) && !(status >= 0))
        do
        {
          const char *return_value_libusb_error_name_1;
          return_value_libusb_error_name_1=libusb_error_name(status);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:876] Error canceling transfer (%d): %s\r\n", status, return_value_libusb_error_name_1);
        }
        while((_Bool)0);

      else
        stream_data->transfer_status[(signed long int)i] = (enum anonymous_37)TRANSFER_CANCEL_PENDING;
    }

}

// capabilities_init_post_fpga_load
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.c line 48
void capabilities_init_post_fpga_load(struct bladerf *dev)
{
  _Bool return_value_version_greater_or_equal_1;
  return_value_version_greater_or_equal_1=version_greater_or_equal(&dev->fpga_version, (unsigned int)0, (unsigned int)0, (unsigned int)4);
  if(!(return_value_version_greater_or_equal_1 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 0);

  _Bool return_value_version_greater_or_equal_2;
  return_value_version_greater_or_equal_2=version_greater_or_equal(&dev->fpga_version, (unsigned int)0, (unsigned int)0, (unsigned int)5);
  if(!(return_value_version_greater_or_equal_2 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 1);

  _Bool return_value_version_greater_or_equal_3;
  return_value_version_greater_or_equal_3=version_greater_or_equal(&dev->fpga_version, (unsigned int)0, (unsigned int)1, (unsigned int)0);
  if(!(return_value_version_greater_or_equal_3 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 2);

  _Bool return_value_version_greater_or_equal_4;
  return_value_version_greater_or_equal_4=version_greater_or_equal(&dev->fpga_version, (unsigned int)0, (unsigned int)2, (unsigned int)0);
  if(!(return_value_version_greater_or_equal_4 == (_Bool)0))
  {
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 3);
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 3);
  }

  _Bool return_value_version_greater_or_equal_5;
  return_value_version_greater_or_equal_5=version_greater_or_equal(&dev->fpga_version, (unsigned int)0, (unsigned int)3, (unsigned int)0);
  if(!(return_value_version_greater_or_equal_5 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 4);

  _Bool return_value_version_greater_or_equal_6;
  return_value_version_greater_or_equal_6=version_greater_or_equal(&dev->fpga_version, (unsigned int)0, (unsigned int)3, (unsigned int)2);
  if(!(return_value_version_greater_or_equal_6 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 5);

  _Bool return_value_version_greater_or_equal_7;
  return_value_version_greater_or_equal_7=version_greater_or_equal(&dev->fpga_version, (unsigned int)0, (unsigned int)4, (unsigned int)0);
  if(!(return_value_version_greater_or_equal_7 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 6);

  _Bool return_value_version_greater_or_equal_8;
  return_value_version_greater_or_equal_8=version_greater_or_equal(&dev->fpga_version, (unsigned int)0, (unsigned int)4, (unsigned int)1);
  if(!(return_value_version_greater_or_equal_8 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 7);

  _Bool return_value_version_greater_or_equal_9;
  return_value_version_greater_or_equal_9=version_greater_or_equal(&dev->fpga_version, (unsigned int)0, (unsigned int)5, (unsigned int)0);
  if(!(return_value_version_greater_or_equal_9 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)(1 << 8);

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ capabilities.c:88] Capability mask after FPGA load: 0x%016lx\n", dev->capabilities);
  while((_Bool)0);
}

// capabilities_init_pre_fpga_load
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.c line 28
void capabilities_init_pre_fpga_load(struct bladerf *dev)
{
  dev->capabilities = (unsigned long int)0;
  _Bool return_value_version_greater_or_equal_1;
  return_value_version_greater_or_equal_1=version_greater_or_equal(&dev->fw_version, (unsigned int)1, (unsigned int)7, (unsigned int)1);
  if(!(return_value_version_greater_or_equal_1 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)1 << 32;

  _Bool return_value_version_greater_or_equal_2;
  return_value_version_greater_or_equal_2=version_greater_or_equal(&dev->fw_version, (unsigned int)1, (unsigned int)8, (unsigned int)0);
  if(!(return_value_version_greater_or_equal_2 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)1 << 33;

  _Bool return_value_version_greater_or_equal_3;
  return_value_version_greater_or_equal_3=version_greater_or_equal(&dev->fw_version, (unsigned int)1, (unsigned int)9, (unsigned int)0);
  if(!(return_value_version_greater_or_equal_3 == (_Bool)0))
    dev->capabilities = dev->capabilities | (unsigned long int)1 << 34;

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ capabilities.c:45] Capability mask before FPGA load: 0x%016lx\n", dev->capabilities);
  while((_Bool)0);
}

// change_setting
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 106
static inline signed int change_setting(struct bladerf *dev, unsigned char setting)
{
  signed int status;
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ usb.c:112] Changing to USB alt setting %u\n", setting);
  while((_Bool)0);
  status=usb->fn->change_setting(driver, setting);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:116] Failed to change setting: %s\n", return_value_bladerf_strerror_1);
  }

  return status;
}

// check_eb_access
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 34
static inline signed int check_eb_access(unsigned int erase_block, unsigned int count)
{
  if(erase_block >= 64u)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:37] Invalid erase block: %u\n", erase_block);
    while((_Bool)0);
    return -3;
  }

  else
    if(count >= 65u)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:40] Invalid number of erase blocks: %u\n", count);
      while((_Bool)0);
      return -3;
    }

    else
      if(count + erase_block >= 65u)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:44] Requested operation extends past end of flash: eb=%u, count=%u\n", erase_block, count);
        while((_Bool)0);
        return -3;
      }

      else
        return 0;
}

// check_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 417
signed int check_module(enum anonymous m)
{
  signed int status;
  if((signed int)m == BLADERF_MODULE_RX || (signed int)m == BLADERF_MODULE_TX)
  {
    status = 0;
    goto __CPROVER_DUMP_L3;
  }

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf_priv.c:428] Invalid module: %d\n", m);
  while((_Bool)0);
  status = -3;

__CPROVER_DUMP_L3:
  ;
  return status;
}

// check_page_access
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 51
static inline signed int check_page_access(unsigned int page, unsigned int count)
{
  if(page >= 16384u)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:54] Invalid page: %u\n", page);
    while((_Bool)0);
    return -3;
  }

  else
    if(count >= 16385u)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:57] Invalid number of pages: %u\n", count);
      while((_Bool)0);
      return -3;
    }

    else
      if(count + page >= 16385u)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:61] Requested operation extends past end of flash: page=%u, count=%u\n", page, count);
        while((_Bool)0);
        return -3;
      }

      else
        return 0;
}

// check_xb200_filter
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 435
signed int check_xb200_filter(enum anonymous_8 f)
{
  signed int status;
  if((signed int)f == BLADERF_XB200_50M || (signed int)f == BLADERF_XB200_144M || (signed int)f == BLADERF_XB200_222M || (signed int)f == BLADERF_XB200_CUSTOM || (signed int)f == BLADERF_XB200_AUTO_1DB || (signed int)f == BLADERF_XB200_AUTO_3DB)
  {
    status = 0;
    goto __CPROVER_DUMP_L3;
  }

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf_priv.c:450] Invalid XB200 filter: %d\n", f);
  while((_Bool)0);
  status = -3;

__CPROVER_DUMP_L3:
  ;
  return status;
}

// check_xb200_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 458
signed int check_xb200_path(enum anonymous_35 p)
{
  signed int status;
  if((signed int)p == BLADERF_XB200_BYPASS || (signed int)p == BLADERF_XB200_MIX)
  {
    status = 0;
    goto __CPROVER_DUMP_L4;
  }

  status = -3;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf_priv.c:470] Invalid XB200 path: %d\n", p);
  while((_Bool)0);

__CPROVER_DUMP_L4:
  ;
  return status;
}

// config_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 224
signed int config_gpio_write(struct bladerf *dev, unsigned int val)
{
  if((signed int)dev->usb_speed == BLADERF_DEVICE_SPEED_HIGH)
    val = val | (unsigned int)(1 << 7);

  else
    if((signed int)dev->usb_speed == BLADERF_DEVICE_SPEED_SUPER)
      val = val & (unsigned int)~(1 << 7);

    else
    {
      /* assertion !"Encountered unknown USB speed" */
      assert(!((_Bool)"Encountered unknown USB speed"));
      return -1;
    }
  signed int return_value;
  return_value=dev->fn->config_gpio_write(dev, val);
  return return_value;
}

// config_load_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/config.h line 37
signed int config_load_dc_cals(struct bladerf *dev)
{
  char *filename;
  char *full_path;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, (unsigned long int)(4096 + 1));
  filename = (char *)return_value_calloc_1;
  if(filename == ((char *)NULL))
    return -4;

  else
  {
    strncat(filename, dev->ident.serial, (unsigned long int)4096);
    strncat(filename, "_dc_rx.tbl", (unsigned long int)(4096 - 33));
    full_path=file_find(filename);
    if(!(full_path == ((char *)NULL)))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ config.c:102] Loading %s\n", full_path);
      while((_Bool)0);
      load_dc_cal(dev, full_path);
      free((void *)full_path);
    }

    memset((void *)filename, 0, (unsigned long int)(4096 + 1));
    strncat(filename, dev->ident.serial, (unsigned long int)4096);
    strncat(filename, "_dc_tx.tbl", (unsigned long int)(4096 - 33));
    full_path=file_find(filename);
    if(!(full_path == ((char *)NULL)))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ config.c:112] Loading %s\n", full_path);
      while((_Bool)0);
      load_dc_cal(dev, full_path);
      free((void *)full_path);
    }

    free((void *)filename);
    return 0;
  }
}

// config_load_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/config.h line 51
signed int config_load_fpga(struct bladerf *dev)
{
  signed int status = 0;
  char *filename = (char *)(void *)0;
  if((signed int)dev->fpga_size == BLADERF_FPGA_40KLE)
    filename=file_find("hostedx40.rbf");

  else
    if((signed int)dev->fpga_size == BLADERF_FPGA_115KLE)
      filename=file_find("hostedx115.rbf");

    else
      return 0;
  if(!(filename == ((char *)NULL)))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ config.c:80] Loading FPGA from: %s\n", filename);
    while((_Bool)0);
    status=fpga_load_from_file(dev, filename);
  }

  free((void *)filename);
  return status;
}

// crc16mp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 32
static unsigned short int crc16mp(unsigned short int crcval, void *data_p, unsigned short int count)
{
  unsigned short int xx;
  unsigned char *ptr = (unsigned char *)data_p;
  unsigned short int tmp_post_1;
  unsigned char *tmp_post_2;
  do
  {
    tmp_post_1 = count;
    count = count - 1;
    if(!((signed int)tmp_post_1 >= 1))
      break;

    tmp_post_2 = ptr;
    ptr = ptr + 1l;
    crcval = (unsigned short int)((signed int)crcval ^ (signed int)(unsigned short int)((signed int)(unsigned short int)*tmp_post_2 << 8));
    xx = (unsigned short int)0;
    for( ; !((signed int)xx >= 8); xx = xx + 1)
      if(!((0x8000 & (signed int)crcval) == 0))
        crcval = (unsigned short int)((signed int)(unsigned short int)((signed int)crcval << 1) ^ 0x1021);

      else
        crcval = (unsigned short int)((signed int)crcval << 1);
  }
  while((_Bool)1);
  return crcval;
}

// dc_cal_backup
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2494
static inline signed int dc_cal_backup(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state)
{
  signed int status;
  memset((void *)state, 0, sizeof(struct dc_cal_state) /*32ul*/ );
  status=dev->fn->lms_read(dev, (unsigned char)0x09, &state->clk_en);
  if(!(status == 0))
    return status;

  else
    if((signed int)module == BLADERF_DC_CAL_RX_LPF || (signed int)module == BLADERF_DC_CAL_RXVGA2)
    {
      status=dev->fn->lms_read(dev, (unsigned char)0x72, &state->reg0x72);
      if(!(status == 0))
        return status;

      status=lms_lna_get_gain(dev, &state->lna_gain);
      if(!(status == 0))
        return status;

      status=lms_rxvga1_get_gain(dev, &state->rxvga1_gain);
      if(!(status == 0))
        return status;

      status=lms_rxvga2_get_gain(dev, &state->rxvga2_gain);
      return status;
    }

    else
      return 0;
}

// dc_cal_interp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 238
static inline void dc_cal_interp(struct dc_cal_tbl *tbl, unsigned int idx_low, unsigned int idx_high, unsigned int freq, signed short int *dc_i, signed short int *dc_q)
{
  const unsigned int f_low = (tbl->entries + (signed long int)idx_low)->freq;
  const unsigned int f_high = (tbl->entries + (signed long int)idx_high)->freq;
  unsigned int return_value_interp_1;
  return_value_interp_1=interp(f_low, (unsigned int)(tbl->entries + (signed long int)idx_low)->dc_i, f_high, (unsigned int)(tbl->entries + (signed long int)idx_low)->dc_i, freq);
  *dc_i = (signed short int)return_value_interp_1;
  unsigned int return_value_interp_2;
  return_value_interp_2=interp(f_low, (unsigned int)(tbl->entries + (signed long int)idx_low)->dc_q, f_high, (unsigned int)(tbl->entries + (signed long int)idx_low)->dc_q, freq);
  *dc_q = (signed short int)return_value_interp_2;
}

// dc_cal_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2949
static inline signed int dc_cal_module(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state, _Bool *converged)
{
  unsigned int i;
  signed int status = 0;
  *converged = (_Bool)1;
  i = (unsigned int)0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= state->num_submodules))
      tmp_if_expr_1 = *converged != (_Bool)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!(status == 0) || !tmp_if_expr_1)
      break;

    status=dc_cal_submodule(dev, module, i, state, converged);
    i = i + 1u;
  }
  while((_Bool)1);
  return status;
}

// dc_cal_module_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2847
static signed int dc_cal_module_deinit(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state)
{
  signed int status = 0;
  switch((signed int)module)
  {
    case BLADERF_DC_CAL_LPF_TUNING:
      break;
    case BLADERF_DC_CAL_RX_LPF:
    {
      status=lms_set_link1(dev, (unsigned char)0x5f, (unsigned char)(1 << 7));
      if(!(status == 0))
        return status;

      break;
    }
    case BLADERF_DC_CAL_RXVGA2:
      status=dev->fn->lms_write(dev, (unsigned char)0x68, (unsigned char)0x01);
    case BLADERF_DC_CAL_TX_LPF:
    {
      status=lms_set_link1(dev, (unsigned char)0x3f, (unsigned char)(1 << 7));
      if(!(status == 0))
        return status;

      status=lms_clear(dev, (unsigned char)0x36, (unsigned char)(1 << 7));
      if(!(status == 0))
        return status;

      break;
    }
    default:
    {
      /* assertion !"Invalid module" */
      assert(!((_Bool)"Invalid module"));
      status = -3;
    }
  }
  return status;
}

// dc_cal_module_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2534
static signed int dc_cal_module_init(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state)
{
  signed int status;
  unsigned char cal_clock;
  unsigned char val;
  switch((signed int)module)
  {
    case BLADERF_DC_CAL_LPF_TUNING:
    {
      cal_clock = (unsigned char)(1 << 5);
      state->base_addr = (unsigned char)0x00;
      state->num_submodules = (unsigned int)1;
      break;
    }
    case BLADERF_DC_CAL_TX_LPF:
    {
      cal_clock = (unsigned char)(1 << 1);
      state->base_addr = (unsigned char)0x30;
      state->num_submodules = (unsigned int)2;
      break;
    }
    case BLADERF_DC_CAL_RX_LPF:
    {
      cal_clock = (unsigned char)(1 << 3);
      state->base_addr = (unsigned char)0x50;
      state->num_submodules = (unsigned int)2;
      break;
    }
    case BLADERF_DC_CAL_RXVGA2:
    {
      cal_clock = (unsigned char)(1 << 4);
      state->base_addr = (unsigned char)0x60;
      state->num_submodules = (unsigned int)5;
      break;
    }
    default:
      return -3;
  }
  status=dev->fn->lms_write(dev, (unsigned char)0x09, (unsigned char)((signed int)state->clk_en | (signed int)cal_clock));
  if(!(status == 0))
    return status;

  else
  {
    if((signed int)module == BLADERF_DC_CAL_LPF_TUNING)
    {
      if((signed int)module == BLADERF_DC_CAL_RXVGA2)
      {
        status=lms_clear(dev, (unsigned char)0x6e, (unsigned char)(3 << 6));
        if(!(status == 0))
          return status;

      }

      else
      {
        status=lms_clear(dev, (unsigned char)0x5f, (unsigned char)(1 << 7));
        if(!(status == 0))
          return status;

      }
      val = (unsigned char)((signed int)state->reg0x72 & ~(1 << 7));
      status=dev->fn->lms_write(dev, (unsigned char)0x72, val);
      if(!(status == 0))
        return status;

      status=lms_lna_set_gain(dev, (enum anonymous_12)BLADERF_LNA_GAIN_MAX);
      if(!(status == 0))
        return status;

      state->rxvga1_curr_gain = 30;
      status=lms_rxvga1_set_gain(dev, state->rxvga1_curr_gain);
      if(!(status == 0))
        return status;

      state->rxvga2_curr_gain = 30;
      status=lms_rxvga2_set_gain(dev, state->rxvga2_curr_gain);
      if(!(status == 0))
        return status;

      status=lms_set_link1(dev, (unsigned char)0x36, (unsigned char)(1 << 7));
      if(!(status == 0))
        return status;

      status=lms_clear(dev, (unsigned char)0x3f, (unsigned char)(1 << 7));
      if(!(status == 0))
        return status;

    }

    /* assertion !"Invalid module" */
    assert(!((_Bool)"Invalid module"));
    status = -3;
    return status;
  }
}

// dc_cal_restore
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2910
static inline signed int dc_cal_restore(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state)
{
  signed int status;
  signed int ret = 0;
  status=dev->fn->lms_write(dev, (unsigned char)0x09, state->clk_en);
  if(!(status == 0))
    ret = status;

  if((signed int)module == BLADERF_DC_CAL_RX_LPF || (signed int)module == BLADERF_DC_CAL_RXVGA2)
  {
    status=dev->fn->lms_write(dev, (unsigned char)0x72, state->reg0x72);
    if(ret == 0 && !(status == 0))
      ret = status;

    status=lms_lna_set_gain(dev, state->lna_gain);
    if(ret == 0 && !(status == 0))
      ret = status;

    status=lms_rxvga1_set_gain(dev, state->rxvga1_gain);
    if(ret == 0 && !(status == 0))
      ret = status;

    status=lms_rxvga2_set_gain(dev, state->rxvga2_gain);
    if(!(status == 0))
      ret = status;

  }

  return ret;
}

// dc_cal_retry_adjustment
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2792
static signed int dc_cal_retry_adjustment(struct bladerf *dev, enum anonymous_0 module, struct dc_cal_state *state, _Bool *limit_reached)
{
  signed int status = 0;
  switch((signed int)module)
  {
    case BLADERF_DC_CAL_LPF_TUNING:

    case BLADERF_DC_CAL_TX_LPF:
    {
      *limit_reached = (_Bool)1;
      break;
    }
    case BLADERF_DC_CAL_RX_LPF:
    {
      if(state->rxvga1_curr_gain >= 6)
      {
        state->rxvga1_curr_gain = state->rxvga1_curr_gain - 1;
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2810] Retrying DC cal with RXVGA1=%d\n", state->rxvga1_curr_gain);
        while((_Bool)0);
        status=lms_rxvga1_set_gain(dev, state->rxvga1_curr_gain);
      }

      else
        *limit_reached = (_Bool)1;
      break;
    }
    case BLADERF_DC_CAL_RXVGA2:
    {
      if(state->rxvga1_curr_gain >= 6)
      {
        state->rxvga1_curr_gain = state->rxvga1_curr_gain - 1;
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2821] Retrying DC cal with RXVGA1=%d\n", state->rxvga1_curr_gain);
        while((_Bool)0);
        status=lms_rxvga1_set_gain(dev, state->rxvga1_curr_gain);
      }

      else
        if(state->rxvga2_curr_gain >= 1)
        {
          state->rxvga2_curr_gain = state->rxvga2_curr_gain - 3;
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2826] Retrying DC cal with RXVGA2=%d\n", state->rxvga2_curr_gain);
          while((_Bool)0);
          status=lms_rxvga2_set_gain(dev, state->rxvga2_curr_gain);
        }

        else
          *limit_reached = (_Bool)1;
      break;
    }
    default:
    {
      *limit_reached = (_Bool)1;
      /* assertion !"Invalid module" */
      assert(!((_Bool)"Invalid module"));
      status = -1;
    }
  }
  if(!(*limit_reached == (_Bool)0))
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2840] DC Cal retry limit reached\n");
    while((_Bool)0);

  return status;
}

// dc_cal_submodule
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2663
static signed int dc_cal_submodule(struct bladerf *dev, enum anonymous_0 module, unsigned int submodule, struct dc_cal_state *state, _Bool *converged)
{
  signed int status;
  unsigned char val;
  unsigned char dc_regval;
  *converged = (_Bool)0;
  if((signed int)module == BLADERF_DC_CAL_RXVGA2)
    switch(submodule)
    {
      case (unsigned int)0:
      {
        status=lms_clear(dev, (unsigned char)0x64, (unsigned char)(1 << 0));
        if(!(status == 0))
          return status;

        status=dev->fn->lms_write(dev, (unsigned char)0x68, (unsigned char)0x01);
      }
      case (unsigned int)1:
      {
        status=lms_set_link1(dev, (unsigned char)0x64, (unsigned char)(1 << 0));
        if(!(status == 0))
          return status;

        val = (unsigned char)0x06;
        status=dev->fn->lms_write(dev, (unsigned char)0x68, val);
      }
      case (unsigned int)2:
        goto __CPROVER_DUMP_L12;
      case (unsigned int)3:
      {
        val = (unsigned char)0x60;
        status=dev->fn->lms_write(dev, (unsigned char)0x68, val);
      }
      case (unsigned int)4:
        goto __CPROVER_DUMP_L12;
      default:
      {
        /* assertion !"Invalid submodule" */
        assert(!((_Bool)"Invalid submodule"));
        return -1;
      }
    }

  else
  {

  __CPROVER_DUMP_L12:
    ;
    status=lms_dc_cal_loop(dev, state->base_addr, (unsigned char)submodule, (unsigned char)31, &dc_regval);
    if(!(status == 0))
      return status;

    else
      if((signed int)dc_regval == 31)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2746] DC_REGVAL suboptimal value - retrying DC cal loop.\n");
        while((_Bool)0);
        status=lms_dc_cal_loop(dev, state->base_addr, (unsigned char)submodule, (unsigned char)0, &dc_regval);
        if(!(status == 0))
          return status;

        if(!((signed int)dc_regval == 0))
          goto __CPROVER_DUMP_L17;

        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2753] Bad DC_REGVAL detected. DC cal failed.\n");
        while((_Bool)0);
        return 0;
      }

      else
      {

      __CPROVER_DUMP_L17:
        ;
        if((signed int)module == BLADERF_DC_CAL_LPF_TUNING)
        {
          status=dev->fn->lms_read(dev, (unsigned char)0x35, &val);
          if(status == 0)
          {
            val = val & (unsigned char)~0x3f;
            val = val | dc_regval;
            status=dev->fn->lms_write(dev, (unsigned char)0x35, val);
          }

          if(!(status == 0))
            return status;

          status=dev->fn->lms_read(dev, (unsigned char)0x55, &val);
          if(status == 0)
          {
            val = val & (unsigned char)~0x3f;
            val = val | dc_regval;
            status=dev->fn->lms_write(dev, (unsigned char)0x55, val);
          }

          return status;
        }

        else
        {
          *converged = (_Bool)1;
          return 0;
        }
      }
  }
}

// dc_cal_tbl_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.h line 85
void dc_cal_tbl_free(struct dc_cal_tbl **tbl)
{
  if(!(*tbl == ((struct dc_cal_tbl *)NULL)))
  {
    free((void *)(*tbl)->entries);
    free((void *)*tbl);
    *tbl = (struct dc_cal_tbl *)(void *)0;
  }

}

// dc_cal_tbl_load
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.h line 76
struct dc_cal_tbl * dc_cal_tbl_load(unsigned char *buf, unsigned long int buf_len)
{
  struct dc_cal_tbl *ret;
  unsigned int i;
  unsigned short int magic;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  if(!(buf_len >= sizeof(unsigned int) * 8 /*32ul*/ ))
    return (struct dc_cal_tbl *)(void *)0;

  else
  {
    memcpy((void *)&magic, (const void *)buf, sizeof(unsigned short int) /*2ul*/ );
    if(!((signed int)magic == 0x1ab1))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ dc_cal_table.c:157] Invalid magic value in cal table: %d\n", magic);
      while((_Bool)0);
      return (struct dc_cal_tbl *)(void *)0;
    }

    else
    {
      buf = buf + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct dc_cal_tbl) /*40ul*/ );
      ret = (struct dc_cal_tbl *)return_value_malloc_1;
      if(ret == ((struct dc_cal_tbl *)NULL))
        return (struct dc_cal_tbl *)(void *)0;

      else
      {
        buf = buf + (signed long int)sizeof(unsigned int) /*4ul*/ ;
        memcpy((void *)&ret->version, (const void *)buf, sizeof(unsigned int) /*4ul*/ );
        ret->version = ret->version;
        buf = buf + (signed long int)sizeof(unsigned int) /*4ul*/ ;
        memcpy((void *)&ret->n_entries, (const void *)buf, sizeof(unsigned int) /*4ul*/ );
        ret->n_entries = ret->n_entries;
        buf = buf + (signed long int)sizeof(unsigned int) /*4ul*/ ;
        if(!(buf_len >= sizeof(unsigned int) * 2 /*8ul*/  * (unsigned long int)ret->n_entries + 24ul))
        {
          free((void *)ret);
          return (struct dc_cal_tbl *)(void *)0;
        }

        else
        {
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(sizeof(struct dc_cal_entry) /*8ul*/  * (unsigned long int)ret->n_entries);
          ret->entries = (struct dc_cal_entry *)return_value_malloc_2;
          if(ret->entries == ((struct dc_cal_entry *)NULL))
          {
            free((void *)ret);
            return (struct dc_cal_tbl *)(void *)0;
          }

          else
          {
            tmp_post_3 = buf;
            buf = buf + 1l;
            ret->reg_vals.lpf_tuning = (signed short int)*tmp_post_3;
            tmp_post_4 = buf;
            buf = buf + 1l;
            ret->reg_vals.tx_lpf_i = (signed short int)*tmp_post_4;
            tmp_post_5 = buf;
            buf = buf + 1l;
            ret->reg_vals.tx_lpf_q = (signed short int)*tmp_post_5;
            tmp_post_6 = buf;
            buf = buf + 1l;
            ret->reg_vals.rx_lpf_i = (signed short int)*tmp_post_6;
            tmp_post_7 = buf;
            buf = buf + 1l;
            ret->reg_vals.rx_lpf_q = (signed short int)*tmp_post_7;
            tmp_post_8 = buf;
            buf = buf + 1l;
            ret->reg_vals.dc_ref = (signed short int)*tmp_post_8;
            tmp_post_9 = buf;
            buf = buf + 1l;
            ret->reg_vals.rxvga2a_i = (signed short int)*tmp_post_9;
            tmp_post_10 = buf;
            buf = buf + 1l;
            ret->reg_vals.rxvga2a_q = (signed short int)*tmp_post_10;
            tmp_post_11 = buf;
            buf = buf + 1l;
            ret->reg_vals.rxvga2b_i = (signed short int)*tmp_post_11;
            tmp_post_12 = buf;
            buf = buf + 1l;
            ret->reg_vals.rxvga2b_q = (signed short int)*tmp_post_12;
            ret->curr_idx = ret->n_entries / (unsigned int)2;
            i = (unsigned int)0;
            for( ; !(i >= ret->n_entries); i = i + 1u)
            {
              memcpy((void *)&(ret->entries + (signed long int)i)->freq, (const void *)buf, sizeof(unsigned int) /*4ul*/ );
              buf = buf + (signed long int)sizeof(unsigned int) /*4ul*/ ;
              memcpy((void *)&(ret->entries + (signed long int)i)->dc_i, (const void *)buf, sizeof(signed short int) /*2ul*/ );
              buf = buf + (signed long int)sizeof(signed short int) /*2ul*/ ;
              memcpy((void *)&(ret->entries + (signed long int)i)->dc_q, (const void *)buf, sizeof(signed short int) /*2ul*/ );
              buf = buf + (signed long int)sizeof(signed short int) /*2ul*/ ;
              (ret->entries + (signed long int)i)->freq = (ret->entries + (signed long int)i)->freq;
              (ret->entries + (signed long int)i)->dc_i = (ret->entries + (signed long int)i)->dc_i;
              (ret->entries + (signed long int)i)->dc_q = (ret->entries + (signed long int)i)->dc_q;
            }
            return ret;
          }
        }
      }
    }
  }
}

// dc_cal_tbl_lookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 122
unsigned int dc_cal_tbl_lookup(struct dc_cal_tbl *tbl, unsigned int freq)
{
  unsigned int ret = (unsigned int)0;
  _Bool limit = (_Bool)0;
  if(tbl->n_entries >= 11u)
  {
    unsigned int min_idx;
    signed long int return_value_i64_max_1;
    return_value_i64_max_1=i64_max((signed long int)0, (signed long int)tbl->curr_idx - (signed long int)10 / (signed long int)2);
    min_idx = (unsigned int)return_value_i64_max_1;
    unsigned int max_idx;
    signed long int return_value_i64_min_2;
    return_value_i64_min_2=i64_min((signed long int)(tbl->n_entries - (unsigned int)1), (signed long int)(tbl->curr_idx + (unsigned int)(10 / 2)));
    max_idx = (unsigned int)return_value_i64_min_2;
    ret=find_entry(tbl, tbl->curr_idx, min_idx, max_idx, freq, &limit);
    if(limit == (_Bool)0)
      return ret;

  }

  unsigned int return_value_find_entry_3;
  return_value_find_entry_3=find_entry(tbl, tbl->curr_idx, (unsigned int)0, tbl->n_entries - (unsigned int)1, freq, &limit);
  return return_value_find_entry_3;
}

// dc_cal_tbl_vals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 256
void dc_cal_tbl_vals(struct dc_cal_tbl *tbl, unsigned int freq, signed short int *dc_i, signed short int *dc_q)
{
  unsigned int idx;
  idx=dc_cal_tbl_lookup(tbl, freq);
  if((tbl->entries + (signed long int)idx)->freq == freq)
  {
    *dc_i = (tbl->entries + (signed long int)idx)->dc_i;
    *dc_q = (tbl->entries + (signed long int)idx)->dc_q;
    goto __CPROVER_DUMP_L4;
  }

  else
    if(idx == tbl->n_entries + 4294967295u)
      dc_cal_interp(tbl, idx - (unsigned int)1, idx, freq, dc_i, dc_q);

    else
      dc_cal_interp(tbl, idx, idx + (unsigned int)1, freq, dc_i, dc_q);

__CPROVER_DUMP_L4:
  ;
}

// device_has_vid_pid
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 171
static _Bool device_has_vid_pid(struct libusb_device *dev, unsigned short int vid, unsigned short int pid)
{
  signed int status;
  struct libusb_device_descriptor desc;
  _Bool match = (_Bool)0;
  status=libusb_get_device_descriptor(dev, &desc);
  if(!(status == 0))
    do
    {
      const char *return_value_libusb_error_name_1;
      return_value_libusb_error_name_1=libusb_error_name(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:180] Couldn't get device descriptor: %s\n", return_value_libusb_error_name_1);
    }
    while((_Bool)0);

  else
    match = desc.idVendor == vid && desc.idProduct == pid;
  return match;
}

// device_is_bladerf
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 195
static _Bool device_is_bladerf(struct libusb_device *dev)
{
  struct libusb_config_descriptor *cfg;
  signed int status;
  _Bool ret;
  _Bool return_value_device_has_vid_pid_1;
  return_value_device_has_vid_pid_1=device_has_vid_pid(dev, (unsigned short int)0x1d50, (unsigned short int)0x6066);
  if(return_value_device_has_vid_pid_1 == (_Bool)0)
    return (_Bool)0;

  else
  {
    status=libusb_get_config_descriptor(dev, (unsigned char)0, &cfg);
    if(!(status == 0))
    {
      do
      {
        const char *return_value_libusb_error_name_2;
        return_value_libusb_error_name_2=libusb_error_name(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:210] Failed to get configuration descriptor: %s\n", return_value_libusb_error_name_2);
      }
      while((_Bool)0);
      return (_Bool)0;
    }

    else
    {
      if(!(cfg->interface->num_altsetting == 4))
      {
        unsigned char bus;
        bus=libusb_get_bus_number(dev);
        unsigned char addr;
        addr=libusb_get_device_address(dev);
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ libusb.c:223] A bladeRF running incompatible firmware appears to be present on bus=%u, addr=%u. If this is true, a firmware update via the device's bootloader is required.\n\n", bus, addr);
        while((_Bool)0);
        ret = (_Bool)0;
      }

      else
        ret = (_Bool)1;
      libusb_free_config_descriptor(cfg);
      return ret;
    }
  }
}

// device_is_fx3_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 188
static _Bool device_is_fx3_bootloader(struct libusb_device *dev)
{
  _Bool return_value_device_has_vid_pid_1;
  return_value_device_has_vid_pid_1=device_has_vid_pid(dev, (unsigned short int)0x04b4, (unsigned short int)0x00f3);
  _Bool tmp_if_expr_3;
  _Bool return_value_device_has_vid_pid_2;
  if(!(return_value_device_has_vid_pid_1 == (_Bool)0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_device_has_vid_pid_2=device_has_vid_pid(dev, (unsigned short int)0x1d50, (unsigned short int)0x6080);
    tmp_if_expr_3 = return_value_device_has_vid_pid_2 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr_3;
}

// device_is_probe_target
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 234
static _Bool device_is_probe_target(enum anonymous_15 probe_target, struct libusb_device *dev)
{
  _Bool is_probe_target = (_Bool)0;
  switch((signed int)probe_target)
  {
    case BACKEND_PROBE_BLADERF:
    {
      is_probe_target=device_is_bladerf(dev);
      if(!(is_probe_target == (_Bool)0))
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:243] Found a bladeRF\n");
        while((_Bool)0);

      break;
    }
    case BACKEND_PROBE_FX3_BOOTLOADER:
    {
      is_probe_target=device_is_fx3_bootloader(dev);
      if(!(is_probe_target == (_Bool)0))
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:250] Found an FX3 bootloader.\n");
        while((_Bool)0);

      break;
    }
    default:
      /* assertion !"Invalid probe target" */
      assert(!((_Bool)"Invalid probe target"));
  }
  return is_probe_target;
}

// devspeed2str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 328
const char * devspeed2str(enum anonymous_7 speed)
{
  switch((signed int)speed)
  {
    case BLADERF_DEVICE_SPEED_HIGH:
      return "Hi-Speed";
    case BLADERF_DEVICE_SPEED_SUPER:
      return "SuperSpeed";
    default:
      return "Unknown";
  }
}

// enable_lna_power
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1093
static inline signed int enable_lna_power(struct bladerf *dev, _Bool enable)
{
  signed int status;
  unsigned char regval;
  status=dev->fn->lms_read(dev, (unsigned char)0x7d, &regval);
  if(!(status == 0))
    return status;

  else
  {
    if(!(enable == (_Bool)0))
      regval = regval & (unsigned char)~(1 << 0);

    else
      regval = regval | (unsigned char)(1 << 0);
    status=dev->fn->lms_write(dev, (unsigned char)0x7d, regval);
    if(!(status == 0))
      return status;

    else
    {
      status=dev->fn->lms_read(dev, (unsigned char)0x70, &regval);
      if(!(status == 0))
        return status;

      else
      {
        if(!(enable == (_Bool)0))
          regval = regval & (unsigned char)~(1 << 1);

        else
          regval = regval | (unsigned char)(1 << 1);
        signed int return_value;
        return_value=dev->fn->lms_write(dev, (unsigned char)0x70, regval);
        return return_value;
      }
    }
  }
}

// enable_lpf_cal_clock
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3013
static inline signed int enable_lpf_cal_clock(struct bladerf *dev, _Bool enable)
{
  const unsigned char mask = (const unsigned char)(1 << 5);
  if(!(enable == (_Bool)0))
  {
    signed int return_value_lms_set_1;
    return_value_lms_set_1=lms_set_link1(dev, (unsigned char)0x09, mask);
    return return_value_lms_set_1;
  }

  else
  {
    signed int return_value_lms_clear_2;
    return_value_lms_clear_2=lms_clear(dev, (unsigned char)0x09, mask);
    return return_value_lms_clear_2;
  }
}

// enable_rf_loopback_switch
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1133
static inline signed int enable_rf_loopback_switch(struct bladerf *dev, _Bool enable)
{
  signed int status;
  unsigned char regval;
  status=dev->fn->lms_read(dev, (unsigned char)0x0b, &regval);
  if(!(status == 0))
    return status;

  else
  {
    if(!(enable == (_Bool)0))
      regval = regval | (unsigned char)(1 << 0);

    else
      regval = regval & (unsigned char)~(1 << 0);
    signed int return_value;
    return_value=dev->fn->lms_write(dev, (unsigned char)0x0b, regval);
    return return_value;
  }
}

// enable_rxlpf_dccal_clock
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3039
static inline signed int enable_rxlpf_dccal_clock(struct bladerf *dev, _Bool enable)
{
  const unsigned char mask = (const unsigned char)(1 << 3);
  if(!(enable == (_Bool)0))
  {
    signed int return_value_lms_set_1;
    return_value_lms_set_1=lms_set_link1(dev, (unsigned char)0x09, mask);
    return return_value_lms_set_1;
  }

  else
  {
    signed int return_value_lms_clear_2;
    return_value_lms_clear_2=lms_clear(dev, (unsigned char)0x09, mask);
    return return_value_lms_clear_2;
  }
}

// enable_rxvga2_dccal_clock
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3026
static inline signed int enable_rxvga2_dccal_clock(struct bladerf *dev, _Bool enable)
{
  const unsigned char mask = (const unsigned char)(1 << 4);
  if(!(enable == (_Bool)0))
  {
    signed int return_value_lms_set_1;
    return_value_lms_set_1=lms_set_link1(dev, (unsigned char)0x09, mask);
    return return_value_lms_set_1;
  }

  else
  {
    signed int return_value_lms_clear_2;
    return_value_lms_clear_2=lms_clear(dev, (unsigned char)0x09, mask);
    return return_value_lms_clear_2;
  }
}

// enable_txlpf_dccal_clock
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3052
static inline signed int enable_txlpf_dccal_clock(struct bladerf *dev, _Bool enable)
{
  const unsigned char mask = (const unsigned char)(1 << 1);
  if(!(enable == (_Bool)0))
  {
    signed int return_value_lms_set_1;
    return_value_lms_set_1=lms_set_link1(dev, (unsigned char)0x09, mask);
    return return_value_lms_set_1;
  }

  else
  {
    signed int return_value_lms_clear_2;
    return_value_lms_clear_2=lms_clear(dev, (unsigned char)0x09, mask);
    return return_value_lms_clear_2;
  }
}

// encode_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.h line 86
signed int encode_field(char *ptr, signed int len, signed int *idx, const char *field, const char *val)
{
  signed int vlen;
  signed int flen;
  signed int tlen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(field);
  flen = (signed int)return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(val);
  vlen = (signed int)return_value_strlen_2;
  tlen = flen + vlen + 1;
  _Bool tmp_if_expr_3;
  if(tlen >= 256)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = *idx + tlen >= len ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    return -4;

  else
  {
    ptr[(signed long int)*idx] = (char)(flen + vlen);
    strcpy(&ptr[(signed long int)(*idx + 1)], field);
    strcpy(&ptr[(signed long int)(*idx + 1 + flen)], val);
    *((unsigned short int *)&ptr[(signed long int)(*idx + tlen)])=crc16mp((unsigned short int)0, (void *)&ptr[(signed long int)*idx], (unsigned short int)tlen);
    *idx = *idx + tlen + 2;
    return 0;
  }
}

// entry_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 72
static inline _Bool entry_matches(struct dc_cal_tbl *tbl, unsigned int entry_idx, unsigned int freq)
{
  _Bool tmp_if_expr_1;
  if(entry_idx >= tbl->n_entries + 4294967295u)
    return freq >= (tbl->entries + (signed long int)entry_idx)->freq;

  else
  {
    if(freq >= (tbl->entries + (signed long int)entry_idx)->freq)
      tmp_if_expr_1 = freq < (tbl->entries + (signed long int)(entry_idx + (unsigned int)1))->freq ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    return tmp_if_expr_1;
  }
}

// error_conv
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 80
static signed int error_conv(signed int error)
{
  signed int ret;
  switch(error)
  {
    case 0:
    {
      ret = 0;
      break;
    }
    case -1:
    {
      ret = -5;
      break;
    }
    case -2:
    {
      ret = -3;
      break;
    }
    case -6:

    case -4:
    {
      ret = -7;
      break;
    }
    case -7:
    {
      ret = -6;
      break;
    }
    case -11:
    {
      ret = -4;
      break;
    }
    case -12:
    {
      ret = -8;
      break;
    }
    case -3:
    {
      ret = -17;
      break;
    }
    case -8:

    case -9:

    case -10:

    case -5:

    default:
      ret = -1;
  }
  return ret;
}

// estimate_vcocap
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 342
static inline unsigned char estimate_vcocap(unsigned int f_target, unsigned int f_low, unsigned int f_high)
{
  unsigned int vcocap;
  const float denom = (float)(f_high - f_low);
  const float num = (const float)(55 - 15);
  const float f_diff = (float)(f_target - f_low);
  vcocap = (unsigned int)((double)((num / denom) * f_diff) + 0.5 + (double)15);
  if(vcocap >= 64u)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:354] Clamping VCOCAP estimate from %u to %u\n", vcocap, 0x3f);
    while((_Bool)0);
    vcocap = (unsigned int)0x3f;
  }

  else
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:357] VCOCAP estimate: %u\n", vcocap);
    while((_Bool)0);
  return (unsigned char)vcocap;
}

// example_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/doc/examples/example_common.c line 31
struct bladerf * example_init(const char *devstr)
{
  signed int status;
  struct bladerf *dev;
  printf("Opening and initializing device...\n\n");
  status=bladerf_open(&dev, devstr);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    fprintf(stderr, "Failed to open device: %s\n", return_value_bladerf_strerror_1);
    goto out;
  }

  status=bladerf_set_frequency(dev, (enum anonymous)BLADERF_MODULE_RX, (unsigned int)910000000);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_2;
    return_value_bladerf_strerror_2=bladerf_strerror(status);
    fprintf(stderr, "Failed to set RX frequency: %s\n", return_value_bladerf_strerror_2);
    goto out;
  }

  else
    printf("RX frequency: %u Hz\n", 910000000);
  status=bladerf_set_sample_rate(dev, (enum anonymous)BLADERF_MODULE_RX, (unsigned int)2000000, (unsigned int *)(void *)0);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_3;
    return_value_bladerf_strerror_3=bladerf_strerror(status);
    fprintf(stderr, "Failed to set RX sample rate: %s\n", return_value_bladerf_strerror_3);
    goto out;
  }

  else
    printf("RX samplerate: %u sps\n", 2000000);
  status=bladerf_set_bandwidth(dev, (enum anonymous)BLADERF_MODULE_RX, 1500000u, (unsigned int *)(void *)0);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_4;
    return_value_bladerf_strerror_4=bladerf_strerror(status);
    fprintf(stderr, "Failed to set RX bandwidth: %s\n", return_value_bladerf_strerror_4);
    goto out;
  }

  else
    printf("RX bandwidth: %u Hz\n", 1500000u);
  status=bladerf_set_lna_gain(dev, (enum anonymous_12)BLADERF_LNA_GAIN_MAX);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_5;
    return_value_bladerf_strerror_5=bladerf_strerror(status);
    fprintf(stderr, "Failed to set RX LNA gain: %s\n", return_value_bladerf_strerror_5);
    goto out;
  }

  else
    printf("RX LNA Gain: Max\n");
  status=bladerf_set_rxvga1(dev, 20);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_6;
    return_value_bladerf_strerror_6=bladerf_strerror(status);
    fprintf(stderr, "Failed to set RX VGA1 gain: %s\n", return_value_bladerf_strerror_6);
    goto out;
  }

  else
    printf("RX VGA1 gain: %d\n", 20);
  status=bladerf_set_rxvga2(dev, 0);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_7;
    return_value_bladerf_strerror_7=bladerf_strerror(status);
    fprintf(stderr, "Failed to set RX VGA2 gain: %s\n", return_value_bladerf_strerror_7);
    goto out;
  }

  else
    printf("RX VGA2 gain: %d\n\n", 0);
  status=bladerf_set_frequency(dev, (enum anonymous)BLADERF_MODULE_TX, (unsigned int)920000000);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_8;
    return_value_bladerf_strerror_8=bladerf_strerror(status);
    fprintf(stderr, "Faield to set TX frequency: %s\n", return_value_bladerf_strerror_8);
    goto out;
  }

  else
    printf("TX frequency: %u Hz\n", 920000000);
  status=bladerf_set_sample_rate(dev, (enum anonymous)BLADERF_MODULE_TX, (unsigned int)2000000, (unsigned int *)(void *)0);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_9;
    return_value_bladerf_strerror_9=bladerf_strerror(status);
    fprintf(stderr, "Failed to set TX sample rate: %s\n", return_value_bladerf_strerror_9);
    goto out;
  }

  else
    printf("TX samplerate: %u sps\n", 2000000);
  status=bladerf_set_bandwidth(dev, (enum anonymous)BLADERF_MODULE_TX, 1500000u, (unsigned int *)(void *)0);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_10;
    return_value_bladerf_strerror_10=bladerf_strerror(status);
    fprintf(stderr, "Failed to set TX bandwidth: %s\n", return_value_bladerf_strerror_10);
    goto out;
  }

  else
    printf("TX bandwidth: %u\n", 1500000u);
  status=bladerf_set_txvga1(dev, -20);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_11;
    return_value_bladerf_strerror_11=bladerf_strerror(status);
    fprintf(stderr, "Failed to set TX VGA1 gain: %s\n", return_value_bladerf_strerror_11);
    goto out;
  }

  else
    printf("TX VGA1 gain: %d\n", -20);
  status=bladerf_set_txvga2(dev, 0);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_12;
    return_value_bladerf_strerror_12=bladerf_strerror(status);
    fprintf(stderr, "Failed to set TX VGA2 gain: %s\n", return_value_bladerf_strerror_12);
    goto out;
  }

  else
    printf("TX VGA2 gain: %d\n\n", 0);

out:
  ;
  if(!(status == 0))
  {
    bladerf_close(dev);
    return (struct bladerf *)(void *)0;
  }

  else
    return dev;
}

// exec_idle_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 378
static enum anonymous_23 exec_idle_state(struct bladerf_sync *s)
{
  enum anonymous_23 next_state = (enum anonymous_23)SYNC_WORKER_STATE_IDLE;
  unsigned int requests;
  unsigned int i;
  pthread_mutex_lock(&s->worker->request_lock);
  while(s->worker->requests == 0u)
    pthread_cond_wait(&s->worker->requests_pending, &s->worker->request_lock);
  requests = s->worker->requests;
  s->worker->requests = (unsigned int)0;
  pthread_mutex_unlock(&s->worker->request_lock);
  if(!((2u & requests) == 0u))
    next_state = (enum anonymous_23)SYNC_WORKER_STATE_SHUTTING_DOWN;

  else
    if(!((1u & requests) == 0u))
    {
      pthread_mutex_lock(&s->buf_mgmt.lock);
      if((signed int)s->stream_config.module == BLADERF_MODULE_TX)
      {
        i = (unsigned int)0;
        for( ; !(i >= s->buf_mgmt.num_buffers); i = i + 1u)
          if((signed int)s->buf_mgmt.status[(signed long int)i] == SYNC_BUFFER_IN_FLIGHT)
            s->buf_mgmt.status[(signed long int)i] = (enum anonymous_21)SYNC_BUFFER_EMPTY;

        pthread_cond_signal(&s->buf_mgmt.buf_ready);
      }

      else
      {
        /* assertion s->stream_config.module == BLADERF_MODULE_RX */
        assert((signed int)s->stream_config.module == BLADERF_MODULE_RX);
        s->buf_mgmt.prod_i = s->stream_config.num_xfers;
        i = (unsigned int)0;
        for( ; !(i >= s->buf_mgmt.num_buffers); i = i + 1u)
          if(!(i >= s->stream_config.num_xfers))
            s->buf_mgmt.status[(signed long int)i] = (enum anonymous_21)SYNC_BUFFER_IN_FLIGHT;

          else
            if((signed int)s->buf_mgmt.status[(signed long int)i] == SYNC_BUFFER_IN_FLIGHT)
              s->buf_mgmt.status[(signed long int)i] = (enum anonymous_21)SYNC_BUFFER_EMPTY;

      }
      pthread_mutex_unlock(&s->buf_mgmt.lock);
      next_state = (enum anonymous_23)SYNC_WORKER_STATE_RUNNING;
    }

    else
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ sync_worker.c:436] Invalid request value encountered: 0x%08X\n", s->worker->requests);
      while((_Bool)0);
  return next_state;
}

// exec_running_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 442
static void exec_running_state(struct bladerf_sync *s)
{
  signed int status;
  status=async_run_stream(s->worker->stream, s->stream_config.module);
  pthread_mutex_lock(&s->worker->state_lock);
  s->worker->err_code = status;
  pthread_mutex_unlock(&s->worker->state_lock);
  if(!(status == 0))
  {
    pthread_mutex_lock(&s->buf_mgmt.lock);
    pthread_cond_signal(&s->buf_mgmt.buf_ready);
    pthread_mutex_unlock(&s->buf_mgmt.lock);
  }

}

// execute_fw_from_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 961
static signed int execute_fw_from_bootloader(struct bladerf_usb *usb, unsigned int addr)
{
  signed int status;
  status=usb->fn->control_transfer(usb->driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, (unsigned char)0xa0, (unsigned short int)(addr & (unsigned int)0xffff), (unsigned short int)(addr >> 16 & (unsigned int)0xffff), (void *)0, (unsigned int)0, (unsigned int)1000);
  if(!(status == 0) && !(status == -5))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:978] Failed to exec firmware: %s\n:", return_value_bladerf_strerror_1);
  }

  else
    if(status == -5)
    {
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ usb.c:983] Device returned IO error due to FW boot.\n");
      status = 0;
    }

    else
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ usb.c:986] Booting new FW.\n");
  return status;
}

// extract_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 49
static signed int extract_field(char *ptr, signed int len, char *field, char *val, unsigned long int maxlen)
{
  signed int c;
  unsigned char *ub;
  unsigned char *end;
  unsigned short int a1;
  unsigned short int a2;
  unsigned long int flen;
  unsigned long int wlen;
  flen=strlen(field);
  ub = (unsigned char *)ptr;
  end = ub + (signed long int)len;
  for( ; !(ub >= end); ub = ub + (signed long int)(c + 3))
  {
    c = (signed int)*ub;
    if(c == 0xff)
      break;

    a1 = *((unsigned short int *)&ub[(signed long int)(c + 1)]);
    a2=crc16mp((unsigned short int)0, (void *)ub, (unsigned short int)(c + 1));
    if(a1 == a2)
    {
      signed int return_value_strncmp_1;
      return_value_strncmp_1=strncmp((char *)ub + (signed long int)1, field, flen);
      if(return_value_strncmp_1 == 0)
      {
        wlen=min_sz((unsigned long int)c - flen, maxlen);
        strncpy(val, (char *)ub + (signed long int)1 + (signed long int)flen, wlen);
        val[(signed long int)wlen] = (char)0;
        return 0;
      }

    }

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash_fields.c:77] %s: Field checksum mismatch\n", (const void *)"extract_field");
      while((_Bool)0);
      return -3;
    }
  }
  return -3;
}

// file_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.h line 94
char * file_find(const char *filename)
{
  unsigned long int i;
  unsigned long int max_len;
  char *full_path;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(4096 + 1), (unsigned long int)1);
  full_path = (char *)return_value_calloc_1;
  const char *env_var;
  env_var=getenv("BLADERF_SEARCH_DIR");
  if(!(env_var == ((const char *)NULL)))
  {
    strncat(full_path, env_var, (unsigned long int)(4096 - 1));
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(full_path);
    full_path[(signed long int)return_value_strlen_2] = (char)47;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(full_path);
    max_len = (unsigned long int)4096 - return_value_strlen_3;
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(filename);
    if(max_len >= return_value_strlen_5)
    {
      strncat(full_path, filename, max_len);
      signed int return_value_access_4;
      return_value_access_4=access(full_path, 0);
      if(!(return_value_access_4 == -1))
        return full_path;

    }

  }

  memset((void *)full_path, 0, (unsigned long int)4096);
  max_len = (unsigned long int)(4096 - 1);
  unsigned long int return_value_get_binary_dir_9;
  return_value_get_binary_dir_9=get_binary_dir(full_path, max_len);
  if(!(return_value_get_binary_dir_9 == 0ul))
  {
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(full_path);
    max_len = max_len - return_value_strlen_6;
    unsigned long int return_value_strlen_8;
    return_value_strlen_8=strlen(filename);
    if(max_len >= return_value_strlen_8)
    {
      strncat(full_path, filename, max_len);
      signed int return_value_access_7;
      return_value_access_7=access(full_path, 0);
      if(!(return_value_access_7 == -1))
        return full_path;

    }

    else
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ file_ops.c:445] Skipping search for %s in %s. Path would be truncated.\n", filename, full_path);
      while((_Bool)0);
  }

  i = (unsigned long int)0;
  for( ; !(i >= 7ul); i = i + 1ul)
  {
    memset((void *)full_path, 0, (unsigned long int)4096);
    max_len = (unsigned long int)4096;
    if(!(search_paths[(signed long int)i].prepend_home == (_Bool)0))
    {
      unsigned long int len;
      len=get_home_dir(full_path, max_len);
      if(!(len == 0ul))
        max_len = max_len - len;

      else
        goto __CPROVER_DUMP_L15;
    }

    strncat(full_path, search_paths[(signed long int)i].path, max_len);
    unsigned long int return_value_strlen_10;
    return_value_strlen_10=strlen(full_path);
    max_len = (unsigned long int)4096 - return_value_strlen_10;
    unsigned long int return_value_strlen_12;
    return_value_strlen_12=strlen(filename);
    if(max_len >= return_value_strlen_12)
    {
      strncat(full_path, filename, max_len);
      signed int return_value_access_11;
      return_value_access_11=access(full_path, 0);
      if(!(return_value_access_11 == -1))
        return full_path;

    }

    else
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ file_ops.c:478] Skipping search for %s in %s. Path would be truncated.\n", filename, full_path);
      while((_Bool)0);

  __CPROVER_DUMP_L15:
    ;
  }
  unsigned long int return_value_get_install_dir_16;
  return_value_get_install_dir_16=get_install_dir(full_path, (unsigned long int)4096);
  if(!(return_value_get_install_dir_16 == 0ul))
  {
    unsigned long int return_value_strlen_13;
    return_value_strlen_13=strlen(full_path);
    max_len = (unsigned long int)4096 - return_value_strlen_13;
    unsigned long int return_value_strlen_15;
    return_value_strlen_15=strlen(filename);
    if(max_len >= return_value_strlen_15)
    {
      strncat(full_path, filename, max_len);
      signed int return_value_access_14;
      return_value_access_14=access(full_path, 0);
      if(!(return_value_access_14 == -1))
        return full_path;

    }

    else
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ file_ops.c:494] Skipping search for %s in %s. Path would be truncated.\n", filename, full_path);
      while((_Bool)0);
  }

  free((void *)full_path);
  return (char *)(void *)0;
}

// file_find_and_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 502
signed int file_find_and_read(const char *filename, unsigned char **buf, unsigned long int *size)
{
  signed int status;
  char *full_path;
  full_path=file_find(filename);
  *buf = (unsigned char *)(void *)0;
  *size = (unsigned long int)0;
  if(!(full_path == ((char *)NULL)))
  {
    status=file_read_buffer(full_path, buf, size);
    free((void *)full_path);
    return status;
  }

  else
    return -11;
}

// file_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 55
signed int file_read(struct _IO_FILE *f, char *buf, unsigned long int len)
{
  unsigned long int rv;
  rv=fread((void *)buf, (unsigned long int)1, len, f);
  if(!(rv >= len))
  {
    signed int return_value_feof_5;
    return_value_feof_5=feof(f);
    if(!(return_value_feof_5 == 0))
      do
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ file_ops.c:62] Unexpected end of file: %s\n", return_value_strerror_2);
      }
      while((_Bool)0);

    else
      do
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ file_ops.c:64] Error reading file: %s\n", return_value_strerror_4);
      }
      while((_Bool)0);
    return -5;
  }

  return 0;
}

// file_read_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.h line 49
signed int file_read_buffer(const char *filename, unsigned char **buf_ret, unsigned long int *size_ret)
{
  signed int status = -1;
  struct _IO_FILE *f;
  unsigned char *buf = (unsigned char *)(void *)0;
  signed long int len;
  f=fopen(filename, "rb");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    switch(*return_value___errno_location_1)
    {
      case 2:
        return -11;
      case 13:
        return -17;
      default:
        return -5;
    }
  }

  len=file_size(f);
  void *return_value_malloc_2;
  if(!(len >= 0l))
    status = -5;

  else
  {
    return_value_malloc_2=malloc((unsigned long int)len);
    buf = (unsigned char *)return_value_malloc_2;
    if(buf == ((unsigned char *)NULL))
      status = -4;

    else
    {
      status=file_read(f, (char *)buf, (unsigned long int)len);
      if(status >= 0)
      {
        *buf_ret = buf;
        *size_ret = (unsigned long int)len;
        fclose(f);
        return 0;
      }

    }
  }

out:
  ;
  free((void *)buf);
  if(!(f == ((struct _IO_FILE *)NULL)))
    fclose(f);

  return status;
}

// file_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 72
signed long int file_size(struct _IO_FILE *f)
{
  signed long int rv = (signed long int)-5;
  signed long int fpos;
  fpos=ftell(f);
  signed long int len;
  signed int return_value_fseek_5;
  signed int return_value_fseek_10;
  if(!(fpos >= 0l))
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ file_ops.c:79] ftell failed: %s\n", return_value_strerror_2);
    }
    while((_Bool)0);

  else
  {
    return_value_fseek_5=fseek(f, (signed long int)0, 2);
    if(!(return_value_fseek_5 == 0))
      do
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ file_ops.c:84] fseek failed: %s\n", return_value_strerror_4);
      }
      while((_Bool)0);

    else
    {
      len=ftell(f);
      if(!(len >= 0l))
      {
        do
        {
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          char *return_value_strerror_7;
          return_value_strerror_7=strerror(*return_value___errno_location_6);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ file_ops.c:90] ftell failed: %s\n", return_value_strerror_7);
        }
        while((_Bool)0);
        goto out;
      }

      else
        if(len == 0x7fffffffffffffffL)
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ file_ops.c:93] ftell called with a directory?\n");
          while((_Bool)0);
          goto out;
        }

      return_value_fseek_10=fseek(f, fpos, 0);
      if(!(return_value_fseek_10 == 0))
        do
        {
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          char *return_value_strerror_9;
          return_value_strerror_9=strerror(*return_value___errno_location_8);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ file_ops.c:98] fseek failed: %s\n", return_value_strerror_9);
        }
        while((_Bool)0);

      else
      {
        rv = (signed long int)len;
        /* assertion rv == len */
        assert(rv == len);
      }
    }
  }

out:
  ;
  return rv;
}

// file_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 42
signed int file_write(struct _IO_FILE *f, unsigned char *buf, unsigned long int len)
{
  unsigned long int rv;
  rv=fwrite((const void *)buf, (unsigned long int)1, len, f);
  if(!(rv >= len))
  {
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ file_ops.c:48] File write failed: %s\n", return_value_strerror_2);
    }
    while((_Bool)0);
    return -5;
  }

  else
    return 0;
}

// fill_fpga_metadata_page
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 200
static inline void fill_fpga_metadata_page(unsigned char *metadata, unsigned long int actual_bitstream_len)
{
  char len_str[10l];
  signed int idx = 0;
  memset((void *)len_str, 0, sizeof(char [10l]) /*10ul*/ );
  memset((void *)metadata, 0xff, (unsigned long int)256);
  snprintf(len_str, sizeof(char [10l]) /*10ul*/ , "%u", (unsigned int)actual_bitstream_len);
  encode_field((char *)metadata, 256, &idx, "LEN", len_str);
}

// find_and_open_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 395
static signed int find_and_open_device(struct libusb_context *context, struct bladerf_devinfo *info_in, struct bladerf_lusb **dev_out, struct bladerf_devinfo *info_out)
{
  signed int status = -7;
  signed int i;
  signed int n;
  signed long int count;
  struct libusb_device **list;
  struct bladerf_devinfo curr_info;
  _Bool printed_access_warning = (_Bool)0;
  *dev_out = (struct bladerf_lusb *)(void *)0;
  count=libusb_get_device_list(context, &list);
  if(!(count >= 0l))
  {
    if(!(count >= -2147483648l))
      return -1;

    else
    {
      signed int return_value_error_conv_1;
      return_value_error_conv_1=error_conv((signed int)count);
      return return_value_error_conv_1;
    }
  }

  i = 0;
  n = 0;
  _Bool tmp_if_expr_2;
  signed int tmp_post_4;
  do
  {
    if(!((signed long int)i >= count))
      tmp_if_expr_2 = *dev_out == (struct bladerf_lusb *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    _Bool return_value_device_is_bladerf_9;
    return_value_device_is_bladerf_9=device_is_bladerf(list[(signed long int)i]);
    if(!(return_value_device_is_bladerf_9 == (_Bool)0))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:422] Found a bladeRF (idx=%d)\n", i);
      while((_Bool)0);
      status=get_devinfo(list[(signed long int)i], &curr_info);
      if(!(status >= 0))
      {
        if(printed_access_warning == (_Bool)0 && status == -3)
        {
          printed_access_warning = (_Bool)1;
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ libusb.c:433] Found a bladeRF via VID/PID, but could not open it due to insufficient permissions.\n");
          while((_Bool)0);
        }

        else
          do
          {
            const char *return_value_libusb_error_name_3;
            return_value_libusb_error_name_3=libusb_error_name(status);
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:436] Could not open bladeRF device: %s\n", return_value_libusb_error_name_3);
          }
          while((_Bool)0);
        status = -7;
        goto __CPROVER_DUMP_L18;
      }

      else
      {
        tmp_post_4 = n;
        n = n + 1;
        curr_info.instance = (unsigned int)tmp_post_4;
      }
      _Bool return_value_bladerf_devinfo_matches_8;
      return_value_bladerf_devinfo_matches_8=bladerf_devinfo_matches(&curr_info, info_in);
      if(!(return_value_bladerf_devinfo_matches_8 == (_Bool)0))
      {
        status=open_device(&curr_info, context, list[(signed long int)i], dev_out);
        if(!(status >= 0))
        {
          status = -7;
          goto __CPROVER_DUMP_L18;
        }

        else
          memcpy((void *)info_out, (const void *)&curr_info, sizeof(struct bladerf_devinfo) /*44ul*/ );
      }

      else
      {
        status = -7;
        do
        {
          _Bool return_value_bladerf_instance_matches_5;
          return_value_bladerf_instance_matches_5=bladerf_instance_matches(&curr_info, info_in);
          _Bool return_value_bladerf_serial_matches_6;
          return_value_bladerf_serial_matches_6=bladerf_serial_matches(&curr_info, info_in);
          _Bool return_value_bladerf_bus_addr_matches_7;
          return_value_bladerf_bus_addr_matches_7=bladerf_bus_addr_matches(&curr_info, info_in);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:461] Devinfo doesn't match - skipping(instance=%d, serial=%d, bus/addr=%d\n", return_value_bladerf_instance_matches_5, return_value_bladerf_serial_matches_6, return_value_bladerf_bus_addr_matches_7);
        }
        while((_Bool)0);
      }
    }


  __CPROVER_DUMP_L18:
    ;
    i = i + 1;
  }
  while((_Bool)1);
  if(status == 0)
    /* assertion *dev_out != ((void *)0) */
    assert(*dev_out != (struct bladerf_lusb *)(void *)0);

  libusb_free_device_list(list, 1);
  return status;
}

// find_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 83
static unsigned int find_entry(struct dc_cal_tbl *tbl, unsigned int curr_idx, unsigned int min_idx, unsigned int max_idx, unsigned int freq, _Bool *hit_limit)
{
  if(max_idx == curr_idx && max_idx == min_idx || !(max_idx >= min_idx))
  {
    *hit_limit = (_Bool)1;
    return curr_idx;
  }

  else
  {
    _Bool return_value_entry_matches_2;
    return_value_entry_matches_2=entry_matches(tbl, curr_idx, freq);
    if(return_value_entry_matches_2 == (_Bool)0)
    {
      if(!(freq >= (tbl->entries + (signed long int)curr_idx)->freq))
      {
        if(curr_idx >= 1u)
          max_idx = curr_idx - (unsigned int)1;

        else
        {
          *hit_limit = (_Bool)1;
          return (unsigned int)0;
        }
      }

      else
        if(!(curr_idx >= tbl->n_entries + 4294967295u))
          min_idx = curr_idx + (unsigned int)1;

        else
        {
          *hit_limit = (_Bool)1;
          return tbl->n_entries - (unsigned int)1;
        }
      curr_idx = min_idx + (max_idx - min_idx) / (unsigned int)2;
      unsigned int return_value_find_entry_1;
      return_value_find_entry_1=find_entry(tbl, curr_idx, min_idx, max_idx, freq, hit_limit);
      return return_value_find_entry_1;
    }

    else
      return curr_idx;
  }
}

// find_fpga_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 105
static struct compat * find_fpga_match(struct bladerf *dev)
{
  unsigned long int i;
  struct compat *newest_fpga = &fpga_compat_tbl[(signed long int)0];
  _Bool return_value_version_less_than_1;
  return_value_version_less_than_1=version_less_than(&newest_fpga->ver, (unsigned int)dev->fpga_version.major, (unsigned int)dev->fpga_version.minor, (unsigned int)dev->fpga_version.patch);
  if(!(return_value_version_less_than_1 == (_Bool)0))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ version_compat.c:122] FPGA version (v%u.%u.%u) is newer than entries in libbladeRF's compatibility table. Please update libbladeRF if problems arise.\n", dev->fpga_version.major, dev->fpga_version.minor, dev->fpga_version.patch);
    while((_Bool)0);
    return newest_fpga;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= 19ul); i = i + 1ul)
    {
      _Bool return_value_version_equal_2;
      return_value_version_equal_2=version_equal(&dev->fpga_version, &fpga_compat_tbl[(signed long int)i].ver);
      if(!(return_value_version_equal_2 == (_Bool)0))
        return &fpga_compat_tbl[(signed long int)i];

    }
    return (struct compat *)(void *)0;
  }
}

// find_fw_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 75
static struct compat * find_fw_match(struct bladerf *dev)
{
  unsigned long int i;
  struct compat *newest_fw = &fw_compat_tbl[(signed long int)0];
  _Bool return_value_version_less_than_1;
  return_value_version_less_than_1=version_less_than(&newest_fw->ver, (unsigned int)dev->fw_version.major, (unsigned int)dev->fw_version.minor, (unsigned int)dev->fw_version.patch);
  if(!(return_value_version_less_than_1 == (_Bool)0))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ version_compat.c:91] Firmware version (v%u.%u.%u) is newer than entries in libbladeRF's compatibility table. Please update libbladeRF if problems arise.\n", dev->fw_version.major, dev->fw_version.minor, dev->fw_version.patch);
    while((_Bool)0);
    return newest_fw;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= 7ul); i = i + 1ul)
    {
      _Bool return_value_version_equal_2;
      return_value_version_equal_2=version_equal(&dev->fw_version, &fw_compat_tbl[(signed long int)i].ver);
      if(!(return_value_version_equal_2 == (_Bool)0))
        return &fw_compat_tbl[(signed long int)i];

    }
    return (struct compat *)(void *)0;
  }
}

// flash_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 98
signed int flash_erase(struct bladerf *dev, unsigned int erase_block, unsigned int count)
{
  signed int status;
  status=check_eb_access(erase_block, count);
  if(status == 0)
    status=dev->fn->erase_flash_blocks(dev, erase_block, (unsigned short int)count);

  return status;
}

// flash_erase_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 165
signed int flash_erase_fpga(struct bladerf *dev)
{
  signed int return_value_flash_erase_1;
  return_value_flash_erase_1=flash_erase(dev, (unsigned int)(0x00040000 / (64 * 1024)), (unsigned int)(0x00370000 / (64 * 1024)));
  return return_value_flash_erase_1;
}

// flash_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 113
signed int flash_read(struct bladerf *dev, unsigned char *buf, unsigned int page, unsigned int count)
{
  signed int status;
  status=check_page_access(page, count);
  if(status == 0)
    status=dev->fn->read_flash_pages(dev, buf, page, count);

  return status;
}

// flash_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 127
signed int flash_write(struct bladerf *dev, const unsigned char *buf, unsigned int page, unsigned int count)
{
  signed int status;
  status=check_page_access(page, count);
  if(status == 0)
    status=dev->fn->write_flash_pages(dev, buf, page, count);

  return status;
}

// flash_write_fpga_bitstream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 216
signed int flash_write_fpga_bitstream(struct bladerf *dev, unsigned char **bitstream, unsigned long int len)
{
  signed int status;
  unsigned char *readback_buf;
  unsigned char *padded_bitstream;
  unsigned char metadata[256l];
  unsigned int padded_bitstream_len;
  const unsigned int page_size = (const unsigned int)256;
  const unsigned int padding_len = (const unsigned int)(len % (unsigned long int)page_size == (unsigned long int)0 ? (unsigned long int)0 : (unsigned long int)page_size - len % (unsigned long int)page_size);
  if(len >= (unsigned long int)(4294967295U + -padding_len))
    return -3;

  else
  {
    padded_bitstream_len = (unsigned int)len + padding_len;
    fill_fpga_metadata_page(metadata, len);
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)padded_bitstream_len);
    readback_buf = (unsigned char *)return_value_malloc_1;
    if(readback_buf == ((unsigned char *)NULL))
      return -4;

    else
    {
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)*bitstream, (unsigned long int)padded_bitstream_len);
      padded_bitstream = (unsigned char *)return_value_realloc_2;
      if(padded_bitstream == ((unsigned char *)NULL))
        status = -4;

      else
      {
        *bitstream = padded_bitstream;
        memset((void *)(padded_bitstream + (signed long int)len), 0xFF, (unsigned long int)padded_bitstream_len - len);
        status=flash_erase(dev, (unsigned int)(0x00040000 / (64 * 1024)), (unsigned int)(0x00370000 / (64 * 1024)));
        if(!(status == 0))
          do
          {
            const char *return_value_bladerf_strerror_3;
            return_value_bladerf_strerror_3=bladerf_strerror(status);
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:259] Failed to erase FPGA meta & bitstream regions: %s\n", return_value_bladerf_strerror_3);
          }
          while((_Bool)0);

        else
        {
          status=flash_write(dev, metadata, (unsigned int)(0x00040000 / 256), (unsigned int)1);
          if(!(status == 0))
            do
            {
              const char *return_value_bladerf_strerror_4;
              return_value_bladerf_strerror_4=bladerf_strerror(status);
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:267] Failed to write FPGA metadata page: %s\n", return_value_bladerf_strerror_4);
            }
            while((_Bool)0);

          else
          {
            padded_bitstream_len = padded_bitstream_len / (unsigned int)256;
            status=flash_write(dev, padded_bitstream, (unsigned int)(0x00040000 / 256 + 1), padded_bitstream_len);
            if(!(status == 0))
              do
              {
                const char *return_value_bladerf_strerror_5;
                return_value_bladerf_strerror_5=bladerf_strerror(status);
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:279] Failed to write bitstream: %s\n", return_value_bladerf_strerror_5);
              }
              while((_Bool)0);

            else
            {
              status=verify_flash(dev, readback_buf, metadata, (unsigned int)(0x00040000 / 256), (unsigned int)1);
              if(!(status == 0))
                do
                {
                  const char *return_value_bladerf_strerror_6;
                  return_value_bladerf_strerror_6=bladerf_strerror(status);
                  log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:287] Failed to verify metadata: %s\n", return_value_bladerf_strerror_6);
                }
                while((_Bool)0);

              else
              {
                status=verify_flash(dev, readback_buf, padded_bitstream, (unsigned int)(0x00040000 / 256 + 1), padded_bitstream_len);
                if(!(status == 0))
                  do
                  {
                    const char *return_value_bladerf_strerror_7;
                    return_value_bladerf_strerror_7=bladerf_strerror(status);
                    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:297] Failed to verify bitstream data: %s\n", return_value_bladerf_strerror_7);
                  }
                  while((_Bool)0);

              }
            }
          }
        }
      }

    error:
      ;
      free((void *)readback_buf);
      return status;
    }
  }
}

// flash_write_fx3_fw
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.h line 142
signed int flash_write_fx3_fw(struct bladerf *dev, unsigned char **image, unsigned long int len)
{
  signed int status;
  unsigned char *readback_buf;
  unsigned char *padded_image;
  unsigned int padded_image_len;
  const unsigned int page_size = (const unsigned int)256;
  const unsigned int padding_len = (const unsigned int)(len % (unsigned long int)page_size == (unsigned long int)0 ? (unsigned long int)0 : (unsigned long int)page_size - len % (unsigned long int)page_size);
  if(len >= (unsigned long int)(4294967295U + -padding_len))
    return -3;

  else
  {
    padded_image_len = (unsigned int)len + padding_len;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)padded_image_len);
    readback_buf = (unsigned char *)return_value_malloc_1;
    if(readback_buf == ((unsigned char *)NULL))
      return -4;

    else
    {
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)*image, (unsigned long int)padded_image_len);
      padded_image = (unsigned char *)return_value_realloc_2;
      if(padded_image == ((unsigned char *)NULL))
        status = -4;

      else
      {
        *image = padded_image;
        memset((void *)(padded_image + (signed long int)len), 0xFF, (unsigned long int)padded_image_len - len);
        status=flash_erase(dev, (unsigned int)(0x00000000 / (64 * 1024)), (unsigned int)(0x00030000 / (64 * 1024)));
        if(!(status == 0))
          do
          {
            const char *return_value_bladerf_strerror_3;
            return_value_bladerf_strerror_3=bladerf_strerror(status);
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:171] Failed to erase firmware region: %s\n", return_value_bladerf_strerror_3);
          }
          while((_Bool)0);

        else
        {
          padded_image_len = padded_image_len / (unsigned int)256;
          status=flash_write(dev, padded_image, (unsigned int)(0x00000000 / 256), padded_image_len);
          if(!(status >= 0))
            do
            {
              const char *return_value_bladerf_strerror_4;
              return_value_bladerf_strerror_4=bladerf_strerror(status);
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:183] Failed to write firmware: %s\n", return_value_bladerf_strerror_4);
            }
            while((_Bool)0);

          else
          {
            status=verify_flash(dev, readback_buf, padded_image, (unsigned int)(0x00000000 / 256), padded_image_len);
            if(!(status == 0))
              do
              {
                const char *return_value_bladerf_strerror_5;
                return_value_bladerf_strerror_5=bladerf_strerror(status);
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:192] Flash verification failed: %s\n", return_value_bladerf_strerror_5);
              }
              while((_Bool)0);

          }
        }
      }

    error:
      ;
      free((void *)readback_buf);
      return status;
    }
  }
}

// float_to_sc16q11
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 627
void float_to_sc16q11(const float *in, signed short int *out, unsigned int n)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 2u * n); i = i + (unsigned int)2)
  {
    out[(signed long int)i] = (signed short int)(in[(signed long int)i] * 2048.0f);
    out[(signed long int)(i + (unsigned int)1)] = (signed short int)(in[(signed long int)(i + (unsigned int)1)] * 2048.0f);
  }
}

// fpga_check_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fpga.h line 41
signed int fpga_check_version(struct bladerf *dev)
{
  signed int status;
  status=version_check_fpga(dev);
  const unsigned int fw_maj = (const unsigned int)dev->fw_version.major;
  const unsigned int fw_min = (const unsigned int)dev->fw_version.minor;
  const unsigned int fw_pat = (const unsigned int)dev->fw_version.patch;
  const unsigned int fpga_maj = (const unsigned int)dev->fpga_version.major;
  const unsigned int fpga_min = (const unsigned int)dev->fpga_version.minor;
  const unsigned int fpga_pat = (const unsigned int)dev->fpga_version.patch;
  unsigned int req_maj;
  unsigned int req_min;
  unsigned int req_pat;
  struct bladerf_version req;
  if(status == -12)
  {
    version_required_fpga(dev, &req);
    req_maj = (unsigned int)req.major;
    req_min = (unsigned int)req.minor;
    req_pat = (unsigned int)req.patch;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ fpga.c:53] FPGA v%u.%u.%u was detected. Firmware v%u.%u.%u requires FPGA v%u.%u.%u or later. Please load a different FPGA version before continuing.\n\n", fpga_maj, fpga_min, fpga_pat, fw_maj, fw_min, fw_pat, req_maj, req_min, req_pat);
    while((_Bool)0);
  }

  else
    if(status == -13)
    {
      version_required_fw(dev, &req, (_Bool)1);
      req_maj = (unsigned int)req.major;
      req_min = (unsigned int)req.minor;
      req_pat = (unsigned int)req.patch;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ fpga.c:66] FPGA v%u.%u.%u was detected, which requires firmware v%u.%u.%u or later. The device firmware is currently v%u.%u.%u. Please upgrade the device firmware before continuing.\n\n", fpga_maj, fpga_min, fpga_pat, req_maj, req_min, req_pat, fw_maj, fw_min, fw_pat);
      while((_Bool)0);
    }

  return status;
}

// fpga_load_from_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fpga.h line 54
signed int fpga_load_from_file(struct bladerf *dev, const char *fpga_file)
{
  unsigned char *buf = (unsigned char *)(void *)0;
  unsigned long int buf_size;
  signed int status;
  status=file_read_buffer(fpga_file, &buf, &buf_size);
  _Bool return_value_valid_fpga_size_1;
  if(status == 0)
  {
    return_value_valid_fpga_size_1=valid_fpga_size(buf_size);
    if(return_value_valid_fpga_size_1 == (_Bool)0)
      status = -3;

    else
    {
      status=dev->fn->load_fpga(dev, buf, buf_size);
      if(status == 0)
      {
        status=fpga_check_version(dev);
        if(status == 0)
          status=init_device(dev);

      }

    }
  }


error:
  ;
  free((void *)buf);
  return status;
}

// fpga_supports_tuning_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.c line 29
static _Bool fpga_supports_tuning_mode(struct bladerf *dev, enum anonymous_10 mode)
{
  _Bool return_value_have_cap_1;
  switch((signed int)mode)
  {
    case BLADERF_TUNING_MODE_HOST:
      return (_Bool)1;
    case BLADERF_TUNING_MODE_FPGA:
    {
      return_value_have_cap_1=have_cap_link2(dev, (unsigned long int)(1 << 3));
      return return_value_have_cap_1;
    }
    default:
      return (_Bool)0;
  }
}

// fpga_write_to_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fpga.h line 66
signed int fpga_write_to_flash(struct bladerf *dev, const char *fpga_file)
{
  signed int status;
  unsigned long int buf_size;
  unsigned char *buf = (unsigned char *)(void *)0;
  const char env_override[29l] = { 'B', 'L', 'A', 'D', 'E', 'R', 'F', '_', 'S', 'K', 'I', 'P', '_', 'F', 'P', 'G', 'A', '_', 'S', 'I', 'Z', 'E', '_', 'C', 'H', 'E', 'C', 'K', 0 };
  status=file_read_buffer(fpga_file, &buf, &buf_size);
  _Bool tmp_if_expr_3;
  _Bool return_value_valid_fpga_size_2;
  if(status == 0)
  {
    char *return_value_getenv_1;
    return_value_getenv_1=getenv(env_override);
    if(return_value_getenv_1 == ((char *)NULL))
    {
      return_value_valid_fpga_size_2=valid_fpga_size(buf_size);
      tmp_if_expr_3 = !(return_value_valid_fpga_size_2 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ fpga.c:135] Detected potentially invalid firmware file.\n");
      while((_Bool)0);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fpga.c:141] Define BLADERF_SKIP_FPGA_SIZE_CHECK in your evironment to skip this check.\n");
      while((_Bool)0);
      status = -3;
    }

    else
      status=flash_write_fpga_bitstream(dev, &buf, buf_size);
  }

  free((void *)buf);
  return status;
}

// free_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 284
void free_args(signed int argc, char **argv)
{
  signed int i;
  if(argc >= 0 && !(argv == ((char **)NULL)))
  {
    i = 0;
    for( ; !(i >= argc); i = i + 1)
      free((void *)argv[(signed long int)i]);
    free((void *)argv);
  }

}

// fx3_fw_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.h line 52
void fx3_fw_deinit(struct fx3_firmware *fw)
{
  free((void *)fw->data);
  memset((void *)fw, 0, sizeof(struct fx3_firmware) /*32ul*/ );
  free((void *)fw);
}

// fx3_fw_entry_point
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 357
unsigned int fx3_fw_entry_point(struct fx3_firmware *fw)
{
  /* assertion fw != ((void *)0) */
  assert(fw != (struct fx3_firmware *)(void *)0);
  return fw->entry_addr;
}

// fx3_fw_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 223
struct fx3_firmware * fx3_fw_init()
{
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct fx3_firmware) /*32ul*/ );
  return (struct fx3_firmware *)return_value_calloc_1;
}

// fx3_fw_log_dump
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw_log.h line 37
signed int fx3_fw_log_dump(struct bladerf *dev, const char *filename)
{
  signed int status;
  struct _IO_FILE *f;
  unsigned int e;
  if(!(filename == ((const char *)NULL)))
  {
    f=fopen(filename, "w");
    if(f == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      switch(*return_value___errno_location_1)
      {
        case 2:
          return -11;
        case 13:
          return -17;
        default:
          return -5;
      }
    }

  }

  else
    f = stdout;
  status=dev->fn->read_fw_log(dev, &e);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_2;
    return_value_bladerf_strerror_2=bladerf_strerror(status);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw_log.c:60] Failed to read FW log: %s\n", return_value_bladerf_strerror_2);
  }

  else
    if(e == 0xffffffff)
      fprintf(f, "<Unexpected error>,,\n");

    else
      if(!(e == 0u))
      {
        unsigned char file_id;
        unsigned short int line;
        unsigned short int data;
        const char *src_file;
        logger_entry_unpack(e, &file_id, &line, &data);
        src_file=logger_id_string(file_id);
        fprintf(f, "%s, %u, 0x%04x\n", src_file, line, data);
      }


out:
  ;
  if(!(f == ((struct _IO_FILE *)NULL)) && !(f == stdout))
    fclose(f);

  return status;
}

// fx3_fw_next_section
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 309
_Bool fx3_fw_next_section(struct fx3_firmware *fw, unsigned int *section_addr, unsigned char **section_data, unsigned int *section_len)
{
  unsigned int len;
  unsigned int addr;
  unsigned char *data;
  const unsigned int max_offset = (const unsigned int)((unsigned long int)fw->data_len - sizeof(unsigned int) /*4ul*/ );
  /* assertion fw != ((void *)0) */
  assert(fw != (struct fx3_firmware *)(void *)0);
  /* assertion fw->data != ((void *)0) */
  assert(fw->data != (unsigned char *)(void *)0);
  *section_addr = (unsigned int)0;
  *section_data = (unsigned char *)(void *)0;
  *section_len = (unsigned int)0;
  if(fw->curr_section >= fw->num_sections)
    return (_Bool)0;

  else
  {
    unsigned int return_value_to_uint32_1;
    return_value_to_uint32_1=to_uint32(fw, fw->section_offset);
    len = (unsigned int)((unsigned long int)return_value_to_uint32_1 * sizeof(unsigned int) /*4ul*/ );
    if(len == 0u)
      return (_Bool)0;

    else
    {
      fw->section_offset = fw->section_offset + (unsigned int)sizeof(unsigned int) /*4ul*/ ;
      /* assertion fw->section_offset < max_offset */
      assert(fw->section_offset < max_offset);
      addr=to_uint32(fw, fw->section_offset);
      fw->section_offset = fw->section_offset + (unsigned int)sizeof(unsigned int) /*4ul*/ ;
      /* assertion fw->section_offset < max_offset */
      assert(fw->section_offset < max_offset);
      data = &fw->data[(signed long int)fw->section_offset];
      fw->section_offset = fw->section_offset + len;
      /* assertion fw->section_offset < max_offset */
      assert(fw->section_offset < max_offset);
      fw->curr_section = fw->curr_section + 1u;
      *section_addr = addr;
      *section_data = data;
      *section_len = len;
      return (_Bool)1;
    }
  }
}

// fx3_fw_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.h line 44
signed int fx3_fw_read(const char *file, struct fx3_firmware **fw_out)
{
  signed int status;
  unsigned long int buf_len;
  struct fx3_firmware *fw;
  *fw_out = (struct fx3_firmware *)(void *)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct fx3_firmware) /*32ul*/ );
  fw = (struct fx3_firmware *)return_value_calloc_1;
  if(fw == ((struct fx3_firmware *)NULL))
    return -4;

  else
  {
    status=file_read_buffer(file, &fw->data, &buf_len);
    if(!(status == 0))
    {
      free((void *)fw);
      return status;
    }

    else
    {
      if(buf_len >= 4294967296ul)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:251] Size of provided image is too large.\n");
        while((_Bool)0);
        status = -3;
        goto error;
      }

      else
        fw->data_len = (unsigned int)buf_len;
      if(!(fw->data_len >= 12u))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:259] Provided file is too short.");
        while((_Bool)0);
        status = -3;
      }

      else
        if(!(fw->data_len % 4u == 0u))
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:265] Size of provided image is not a multiple of 4 bytes.\n");
          while((_Bool)0);
          status = -3;
        }

        else
          if(!((signed int)*fw->data == 67))
          {
            if((signed int)fw->data[1l] == 89)
              goto __CPROVER_DUMP_L11;

            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:273] FX3 firmware does have 'CY' marker.\n");
            while((_Bool)0);
            status = -3;
          }

          else
          {

          __CPROVER_DUMP_L11:
            ;
            if(!((signed int)fw->data[3l] == 0xb0))
            {
              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:280] FX3 firmware header contained unexpected image type: 0x%02x\n", fw->data[(signed long int)0x03]);
              while((_Bool)0);
              status = -3;
            }

            else
              status=scan_fw_sections(fw);
          }

    error:
      ;
      if(!(status == 0))
      {
        free((void *)fw->data);
        free((void *)fw);
      }

      else
        *fw_out = fw;
      return status;
    }
  }
}

// gain_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.h line 39
signed int gain_set(struct bladerf *dev, enum anonymous module, signed int gain)
{
  signed int status;
  if((signed int)module == BLADERF_MODULE_TX)
    status=set_tx_gain(dev, gain);

  else
    if((signed int)module == BLADERF_MODULE_RX)
      status=set_rx_gain(dev, gain);

    else
      status = -3;
  return status;
}

// get_and_cache_fpga_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.h line 72
signed int get_and_cache_fpga_size(struct bladerf *device)
{
  signed int status;
  char tmp[7l] = { (char)0, 0, 0, 0, 0, 0, 0 };
  status=get_cal_field(device, "B", tmp, sizeof(char [7l]) /*7ul*/  - (unsigned long int)1);
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp("40", tmp);
  signed int return_value_strcmp_1;
  if(return_value_strcmp_2 == 0)
    device->fpga_size = (enum anonymous_5)BLADERF_FPGA_40KLE;

  else
  {
    return_value_strcmp_1=strcmp("115", tmp);
    if(return_value_strcmp_1 == 0)
      device->fpga_size = (enum anonymous_5)BLADERF_FPGA_115KLE;

    else
      device->fpga_size = (enum anonymous_5)BLADERF_FPGA_UNKNOWN;
  }
  return status;
}

// get_and_cache_vctcxo_trim
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.h line 61
signed int get_and_cache_vctcxo_trim(struct bladerf *dev)
{
  signed int status;
  _Bool ok;
  signed short int trim;
  char tmp[7l] = { (char)0, 0, 0, 0, 0, 0, 0 };
  status=get_cal_field(dev, "DAC", tmp, sizeof(char [7l]) /*7ul*/  - (unsigned long int)1);
  if(status == 0)
  {
    unsigned int return_value_str2uint_1;
    return_value_str2uint_1=str2uint(tmp, (unsigned int)0, (unsigned int)0xffff, &ok);
    trim = (signed short int)return_value_str2uint_1;
  }

  if(status == 0 && !(ok == (_Bool)0))
    dev->dac_trim = (unsigned short int)trim;

  else
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash_fields.c:194] Unable to fetch DAC trim. Defaulting to 0x8000\n");
    while((_Bool)0);
    dev->dac_trim = (unsigned short int)0x8000;
  }
  return status;
}

// get_binary_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 227
static inline unsigned long int get_binary_dir(char *buf, unsigned long int max_len)
{
  signed long int result;
  result=readlink("/proc/self/exe", buf, max_len);
  if(result >= 1l)
  {
    unsigned long int return_value_strip_last_path_entry_1;
    return_value_strip_last_path_entry_1=strip_last_path_entry(buf, (char)47);
    return return_value_strip_last_path_entry_1;
  }

  else
    return (unsigned long int)0;
}

// get_cal_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 147
signed int get_cal_field(struct bladerf *dev, char *field, char *data, unsigned long int data_size)
{
  signed int status;
  char cal[256l];
  status=dev->fn->get_cal(dev, cal);
  signed int return_value_extract_field_1;
  if(!(status >= 0))
    return status;

  else
  {
    return_value_extract_field_1=extract_field(cal, 256, field, data, data_size);
    return return_value_extract_field_1;
  }
}

// get_dc_cal_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3107
static signed int get_dc_cal_value(struct bladerf *dev, unsigned char base, unsigned char dc_addr, signed short int *value)
{
  signed int status;
  unsigned char regval;
  status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 3), (unsigned char)(0x08 | (signed int)dc_addr));
  if(!(status == 0))
    return status;

  else
  {
    status=dev->fn->lms_read(dev, base, &regval);
    if(!(status == 0))
    {
      *value = (signed short int)-1;
      return status;
    }

    else
    {
      *value = (signed short int)regval;
      return 0;
    }
  }
}

// get_dc_offset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3542
signed int get_dc_offset(struct bladerf *dev, enum anonymous module, unsigned char addr, signed short int *value)
{
  signed int status;
  unsigned char tmp;
  status=dev->fn->lms_read(dev, addr, &tmp);
  if(!(status == 0))
    return status;

  else
  {
    if((signed int)module == BLADERF_MODULE_RX)
    {
      tmp = (unsigned char)((signed int)tmp & 0x7f);
      if(!((64 & (signed int)tmp) == 0))
        *value = (signed short int)-((signed int)(signed short int)((signed int)tmp & 0x3f));

      else
        *value = (signed short int)((signed int)tmp & 0x3f);
      *value = *value << 5;
      *value = (signed short int)tmp;
      *value = *value << 4;
    }

    return -3;
    return 0;
  }
}

// get_devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 130
static signed int get_devinfo(struct libusb_device *dev, struct bladerf_devinfo *info)
{
  signed int status = 0;
  struct libusb_device_handle *handle;
  struct libusb_device_descriptor desc;
  status=libusb_open(dev, &handle);
  if(status == 0)
  {
    info->backend = (enum anonymous_11)BLADERF_BACKEND_LIBUSB;
    info->usb_bus=libusb_get_bus_number(dev);
    info->usb_addr=libusb_get_device_address(dev);
    status=libusb_get_device_descriptor(dev, &desc);
    if(!(status == 0))
      memset((void *)info->serial, 0, (unsigned long int)33);

    else
    {
      status=libusb_get_string_descriptor_ascii(handle, desc.iSerialNumber, (unsigned char *)&info->serial, 33);
      if(!(status >= 0))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:156] Failed to retrieve serial number\n");
        while((_Bool)0);
        memset((void *)info->serial, 0, (unsigned long int)33);
      }

      else
        status = 0;
    }
    libusb_close(handle);
  }

  return status;
}

// get_home_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 204
static inline unsigned long int get_home_dir(char *buf, unsigned long int max_len)
{
  const char *home;
  home=getenv("HOME");
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(!(home == ((const char *)NULL)))
  {
    return_value_strlen_1=strlen(home);
    tmp_if_expr_2 = return_value_strlen_1 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_4;
  unsigned long int return_value_strlen_3;
  if(tmp_if_expr_2)
  {
    return_value_strlen_3=strlen(home);
    tmp_if_expr_4 = return_value_strlen_3 < max_len ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  if(tmp_if_expr_4)
    strncat(buf, home, max_len);

  else
  {
    struct passwd *passwd;
    unsigned int uid;
    uid=getuid();
    passwd=getpwuid(uid);
    strncat(buf, passwd->pw_dir, max_len);
  }
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(buf);
  return return_value_strlen_5;
}

// get_install_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 221
static inline unsigned long int get_install_dir(char *buf, unsigned long int max_len)
{
  return (unsigned long int)0;
}

// get_iq_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 410
static signed int get_iq_correction(struct bladerf *dev, unsigned char addr, signed short int *value)
{
  signed int i;
  signed int status;
  struct uart_cmd cmd;
  *value = (signed short int)0;
  status = 0;
  i = status;
  for( ; status == 0 && !(i >= 2); i = i + 1)
  {
    cmd.addr = (unsigned char)(i + (signed int)addr);
    cmd.data = (unsigned char)0xff;
    status=nios_access_link1(dev, (unsigned char)(0 << 4), (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, &cmd, (unsigned long int)1);
    *value = *value | (signed short int)((signed int)cmd.data << i * 8);
  }
  return status;
}

// get_libusb_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 324
static inline void get_libusb_version(char *buf, unsigned long int buf_len)
{
  struct libusb_version *version;
  version=libusb_get_version();
  snprintf(buf, buf_len, "%d.%d.%d.%d%s", version->major, version->minor, version->micro, version->nano, version->rc);
}

// get_loglevel
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/init_fini.c line 63
static signed int get_loglevel(void)
{
  signed int log_level = BLADERF_LOG_LEVEL_INFO;
  char *return_value_getenv_5;
  return_value_getenv_5=getenv("BLADERF_LOG_LEVEL");
  char *return_value_getenv_3;
  unsigned long int return_value_strlen_4;
  if(!(return_value_getenv_5 == ((char *)NULL)))
  {
    return_value_getenv_3=getenv("BLADERF_LOG_LEVEL");
    return_value_strlen_4=strlen(return_value_getenv_3);
    if(return_value_strlen_4 >= 1ul)
    {
      _Bool valid_value;
      char *return_value_getenv_1;
      return_value_getenv_1=getenv("BLADERF_LOG_LEVEL");
      enum anonymous_26 return_value_str2loglevel_2;
      return_value_str2loglevel_2=str2loglevel(return_value_getenv_1, &valid_value);
      log_level = (signed int)return_value_str2loglevel_2;
      if(valid_value == (_Bool)0)
        log_level = BLADERF_LOG_LEVEL_INFO;

    }

  }

  return log_level;
}

// get_next_available_transfer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1015
static inline struct libusb_transfer * get_next_available_transfer(struct lusb_stream_data *stream_data)
{
  unsigned int n;
  unsigned long int i = stream_data->i;
  n = (unsigned int)0;
  for( ; !((unsigned long int)n >= stream_data->num_transfers); n = n + 1u)
  {
    if((signed int)stream_data->transfer_status[(signed long int)i] == TRANSFER_AVAIL)
    {
      if(!(stream_data->i == i))
      {
        if((signed int)stream_data->out_of_order_event == 0)
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ libusb.c:1027] Transfer callback occurred out of order. (Warning only this time.)\r\n");
          while((_Bool)0);
          stream_data->out_of_order_event = (_Bool)1;
        }

      }

      stream_data->i = i;
      return stream_data->transfers[(signed long int)i];
    }

    i = (i + (unsigned long int)1) % stream_data->num_transfers;
  }
  return (struct libusb_transfer *)(void *)0;
}

// get_otp_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 132
signed int get_otp_field(struct bladerf *dev, char *field, char *data, unsigned long int data_size)
{
  signed int status;
  char otp[256l];
  memset((void *)otp, 0xff, (unsigned long int)256);
  status=dev->fn->get_otp(dev, otp);
  signed int return_value_extract_field_1;
  if(!(status >= 0))
    return status;

  else
  {
    return_value_extract_field_1=extract_field(otp, 256, field, data, data_size);
    return return_value_extract_field_1;
  }
}

// get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 68
static inline unsigned long int get_timestamp()
{
  unsigned long int ret;
  struct timeval tv;
  signed int return_value_gettimeofday_3;
  return_value_gettimeofday_3=gettimeofday(&tv, (struct timezone *)(void *)0);
  if(return_value_gettimeofday_3 == 0)
    ret = (unsigned long int)tv.tv_sec;

  else
  {
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ image.c:76] gettimeofday failed: %s\n", return_value_strerror_2);
    }
    while((_Bool)0);
    ret = (unsigned long int)0;
  }
  return ret;
}

// get_vctcxo_tamer_mode_unsupported
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1070
static signed int get_vctcxo_tamer_mode_unsupported(struct bladerf *dev, enum anonymous_16 *mode)
{
  *mode = (enum anonymous_16)BLADERF_VCTCXO_TAMER_INVALID;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:1074] Operation not supported with legacy NIOS packet format.\n");
  while((_Bool)0);
  return -8;
}

// get_vtune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1771
static inline signed int get_vtune(struct bladerf *dev, unsigned char base, unsigned char delay, unsigned char *vtune)
{
  signed int status;
  if(!((signed int)delay == 0))
  {

  __CPROVER_DUMP_L1:
    ;
    do
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1777] VTUNE_BUSY_WAIT(%u)\n", delay);
      while((_Bool)0);
    while((_Bool)0);
  }

  status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 10), vtune);
  *vtune = *vtune >> 6;
  return status;
}

// handle_backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 42
static signed int handle_backend(char *str, struct bladerf_devinfo *d)
{
  char *str_end;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(str == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen(str);
    tmp_if_expr_2 = return_value_strlen_1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  const unsigned short int **return_value___ctype_b_loc_3;
  const unsigned short int **return_value___ctype_b_loc_5;
  if(tmp_if_expr_2)
    return -3;

  else
  {
    for( ; !(*str == 0); str = str + 1l)
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(unsigned char)*str]) == 0)
        break;

    }
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(str);
    str_end = (str + (signed long int)return_value_strlen_4) - (signed long int)1;
    for( ; !(str >= str_end); str_end = str_end - 1l)
    {
      return_value___ctype_b_loc_5=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)*str_end]) == 0)
        break;

    }
    str_end[(signed long int)1] = (char)0;
    signed int return_value_str2backend_6;
    return_value_str2backend_6=str2backend(str, &d->backend);
    return return_value_str2backend_6;
  }
}

// handle_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 64
static signed int handle_device(struct bladerf_devinfo *d, char *value)
{
  signed int status = -3;
  _Bool bus_ok;
  _Bool addr_ok;
  char *bus = value;
  char *addr;
  addr=strchr(value, 58);
  if(!(addr == ((char *)NULL)))
  {
    if(!((signed int)addr[1l] == 0))
    {
      *addr = (char)0;
      addr = addr + 1l;
      unsigned int return_value_str2uint_1;
      return_value_str2uint_1=str2uint(bus, (unsigned int)0, (unsigned int)(255 - 1), &bus_ok);
      d->usb_bus = (unsigned char)return_value_str2uint_1;
      unsigned int return_value_str2uint_2;
      return_value_str2uint_2=str2uint(addr, (unsigned int)0, (unsigned int)(255 - 1), &addr_ok);
      d->usb_addr = (unsigned char)return_value_str2uint_2;
      if(!(addr_ok == (_Bool)0) && !(bus_ok == (_Bool)0))
      {
        status = 0;
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ device_identifier.c:82] Device: %d:%d\n", d->usb_bus, d->usb_addr);
        while((_Bool)0);
      }

      else
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ device_identifier.c:84] Bad bus (%s) or address (%s)\n", bus, addr);
        while((_Bool)0);
    }

  }

  return status;
}

// handle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 91
static signed int handle_instance(struct bladerf_devinfo *d, char *value)
{
  _Bool ok;
  if(value == ((char *)NULL))
    return -3;

  else
  {
    d->instance=str2uint(value, (unsigned int)0, ((unsigned int)0x7fffffff * 2U + 1U) - (unsigned int)1, &ok);
    if(ok == (_Bool)0)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ device_identifier.c:101] Bad instance: %s\n", value);
      while((_Bool)0);
      return -3;
    }

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ device_identifier.c:104] Instance: %u\n", d->instance);
      while((_Bool)0);
      return 0;
    }
  }
}

// handle_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 109
static signed int handle_serial(struct bladerf_devinfo *d, char *value)
{
  char c;
  unsigned long int i;
  unsigned long int len;
  if(value == ((char *)NULL))
    return -3;

  else
  {
    len=strlen(value);
    if(len >= 33ul)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ device_identifier.c:122] Provided serial # string too long: %lu\n", (unsigned long int)len);
      while((_Bool)0);
      return -3;
    }

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= len); i = i + 1ul)
      {
        c = value[(signed long int)i];
        if((signed int)c >= 65 && !((signed int)c >= 71))
        {
          signed int return_value_tolower_1;
          return_value_tolower_1=tolower((signed int)(unsigned char)c);
          value[(signed long int)i] = (char)return_value_tolower_1;
        }

        if(((signed int)c >= 58 || !((signed int)c >= 48)) && ((signed int)c >= 103 || !((signed int)c >= 97)))
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ device_identifier.c:134] Bad serial: %s\n", value);
          while((_Bool)0);
          return -3;
        }

      }
      memset((void *)d->serial, 0, sizeof(char [33l]) /*33ul*/ );
      strncpy(d->serial, value, len);
      if(len == 32ul)
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ device_identifier.c:143] Requested serial number: %s\n", (const void *)d->serial);
        while((_Bool)0);

      else
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ device_identifier.c:145] Requested serial number subset: %s\n", (const void *)d->serial);
        while((_Bool)0);
      return 0;
    }
  }
}

// handle_tx_parameters
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 704
static inline signed int handle_tx_parameters(struct bladerf_metadata *user_meta, struct bladerf_sync *s, struct tx_options *options)
{
  _Bool return_value_timestamp_in_past_1;
  if((signed int)s->stream_config.format == BLADERF_FORMAT_SC16_Q11_META)
  {
    if(user_meta == ((struct bladerf_metadata *)NULL))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:710] NULL metadata pointer passed to %s\n", (const void *)"handle_tx_parameters");
      while((_Bool)0);
      return -3;
    }

    if(!((1u & user_meta->flags) == 0u))
    {
      _Bool now = (_Bool)(user_meta->flags & (unsigned int)(1 << 2));
      if(!(s->meta._anon0._anon1.in_burst == (_Bool)0))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:719] %s: BURST_START provided while already in a burst.\n", (const void *)"handle_tx_parameters");
        while((_Bool)0);
        return -3;
      }

      else
        if(now == (_Bool)0)
        {
          return_value_timestamp_in_past_1=timestamp_in_past(user_meta, s);
          if(!(return_value_timestamp_in_past_1 == (_Bool)0))
            return -14;

        }

      s->meta._anon0._anon1.in_burst = (_Bool)1;
      if(!(now == (_Bool)0))
        s->meta._anon0._anon1.now = (_Bool)1;

      else
        s->meta.curr_timestamp = user_meta->timestamp;
      if(!((8u & user_meta->flags) == 0u))
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:736] UPDATE_TIMESTAMP ignored; BURST_START flag was used.\n");
        while((_Bool)0);

    }

    else
      if(!((4u & user_meta->flags) == 0u))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:741] %s: TX_NOW was specified without BURST_START.\n", (const void *)"handle_tx_parameters");
        while((_Bool)0);
        return -3;
      }

      else
        if(!((8u & user_meta->flags) == 0u))
        {
          _Bool return_value_timestamp_in_past_2;
          return_value_timestamp_in_past_2=timestamp_in_past(user_meta, s);
          if(!(return_value_timestamp_in_past_2 == (_Bool)0))
            return -14;

          else
            options->zero_pad = (_Bool)1;
        }

    if(!((2u & user_meta->flags) == 0u))
    {
      if(!(s->meta._anon0._anon1.in_burst == (_Bool)0))
        options->flush = (_Bool)1;

      else
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:756] %s: BURST_END provided while not in a burst.\n", (const void *)"handle_tx_parameters");
        while((_Bool)0);
        return -3;
      }
    }

    user_meta->status = (unsigned int)0;
  }

  return 0;
}

// have_cap
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap(struct bladerf *dev, unsigned long int capability)
{
  return (dev->capabilities & capability) != (unsigned long int)0;
}

// have_cap_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link1(struct bladerf *dev_link1, unsigned long int capability_link1)
{
  return (dev_link1->capabilities & capability_link1) != (unsigned long int)0;
}

// have_cap_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link2(struct bladerf *dev_link2, unsigned long int capability_link2)
{
  return (dev_link2->capabilities & capability_link2) != (unsigned long int)0;
}

// have_cap_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link3(struct bladerf *dev_link3, unsigned long int capability_link3)
{
  return (dev_link3->capabilities & capability_link3) != (unsigned long int)0;
}

// have_cap_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link4(struct bladerf *dev_link4, unsigned long int capability_link4)
{
  return (dev_link4->capabilities & capability_link4) != (unsigned long int)0;
}

// have_cap_link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link5(struct bladerf *dev_link5, unsigned long int capability_link5)
{
  return (dev_link5->capabilities & capability_link5) != (unsigned long int)0;
}

// have_cap_link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link6(struct bladerf *dev_link6, unsigned long int capability_link6)
{
  return (dev_link6->capabilities & capability_link6) != (unsigned long int)0;
}

// have_cap_link7
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/capabilities.h line 120
static inline _Bool have_cap_link7(struct bladerf *dev_link7, unsigned long int capability_link7)
{
  return (dev_link7->capabilities & capability_link7) != (unsigned long int)0;
}

// i64_max
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 55
static inline signed long int i64_max(signed long int x, signed long int y)
{
  return x > y ? x : y;
}

// i64_min
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 45
static inline signed long int i64_min(signed long int x, signed long int y)
{
  return x < y ? x : y;
}

// image_type_is_valid
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 124
static _Bool image_type_is_valid(enum anonymous_38 type)
{
  if((signed int)type == BLADERF_IMAGE_TYPE_RAW || (signed int)type == BLADERF_IMAGE_TYPE_FIRMWARE || (signed int)type == BLADERF_IMAGE_TYPE_FPGA_40KLE || (signed int)type == BLADERF_IMAGE_TYPE_FPGA_115KLE || (signed int)type == BLADERF_IMAGE_TYPE_CALIBRATION || (signed int)type == BLADERF_IMAGE_TYPE_RX_DC_CAL || (signed int)type == BLADERF_IMAGE_TYPE_TX_DC_CAL || (signed int)type == BLADERF_IMAGE_TYPE_RX_IQ_CAL || (signed int)type == BLADERF_IMAGE_TYPE_TX_IQ_CAL)
    return (_Bool)1;

  return (_Bool)0;
}

// init_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 194
signed int init_device(struct bladerf *dev)
{
  signed int status;
  unsigned int val;
  status=dev->fn->config_gpio_read(dev, &val);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf_priv.c:146] Failed to read GPIO config %s\n", return_value_bladerf_strerror_1);
    return status;
  }

  else
  {
    if((127u & val) == 0u)
    {
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ bladerf_priv.c:151] Default GPIO value found - initializing device\n");
      status=config_gpio_write(dev, (unsigned int)0x57);
      if(!(status == 0))
        return status;

      status=lms_enable_rffe(dev, (enum anonymous)BLADERF_MODULE_TX, (_Bool)0);
      if(!(status == 0))
        return status;

      status=lms_enable_rffe(dev, (enum anonymous)BLADERF_MODULE_RX, (_Bool)0);
      if(!(status == 0))
        return status;

      status=dev->fn->lms_write(dev, (unsigned char)0x05, (unsigned char)0x3e);
      if(!(status == 0))
        return status;

      status=dev->fn->lms_write(dev, (unsigned char)0x47, (unsigned char)0x40);
      if(!(status == 0))
        return status;

      status=dev->fn->lms_write(dev, (unsigned char)0x59, (unsigned char)0x29);
      if(!(status == 0))
        return status;

      status=dev->fn->lms_write(dev, (unsigned char)0x64, (unsigned char)0x36);
      if(!(status == 0))
        return status;

      status=dev->fn->lms_write(dev, (unsigned char)0x79, (unsigned char)0x37);
      if(!(status == 0))
        return status;

      status=lms_set(dev, (unsigned char)0x3f, (unsigned char)0x80);
      if(!(status == 0))
        return status;

      status=lms_set(dev, (unsigned char)0x5f, (unsigned char)0x80);
      if(!(status == 0))
        return status;

      status=lms_set(dev, (unsigned char)0x6e, (unsigned char)0xc0);
      if(!(status == 0))
        return status;

      status=lms_config_charge_pumps(dev, (enum anonymous)BLADERF_MODULE_TX);
      if(!(status == 0))
        return status;

      status=lms_config_charge_pumps(dev, (enum anonymous)BLADERF_MODULE_RX);
      if(!(status == 0))
        return status;

      status=si5338_set_sample_rate(dev, (enum anonymous)BLADERF_MODULE_TX, (unsigned int)1000000, (unsigned int *)(void *)0);
      if(!(status == 0))
        return status;

      status=si5338_set_sample_rate(dev, (enum anonymous)BLADERF_MODULE_RX, (unsigned int)1000000, (unsigned int *)(void *)0);
      if(!(status == 0))
        return status;

      dev->tuning_mode=tuning_get_default_mode(dev);
      status=tuning_set_freq(dev, (enum anonymous)BLADERF_MODULE_TX, 2447000000U);
      if(!(status == 0))
        return status;

      status=tuning_set_freq(dev, (enum anonymous)BLADERF_MODULE_RX, 2484000000U);
      if(!(status == 0))
        return status;

      status=dev->fn->vctcxo_dac_write(dev, dev->dac_trim);
      if(!(status == 0))
        return status;

    }

    else
      dev->tuning_mode=tuning_get_default_mode(dev);
    status=xb_get_attached(dev, &dev->xb);
    if(!(status == 0))
      return status;

    else
    {
      status=apply_lms_dc_cals(dev);
      return status;
    }
  }
}

// interp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/dc_cal_table.c line 226
static inline unsigned int interp(unsigned int x0, unsigned int y0, unsigned int x1, unsigned int y1, unsigned int x)
{
  const float num = (float)y1 - (float)y0;
  const float den = (float)x1 - (float)x0;
  const float m = IEEE_FLOAT_EQUAL(den, (float)0) ? 3.40282346638528859812e+38F : num / den;
  const float y = (float)(x - x0) * m + (float)y0;
  return (unsigned int)y;
}

// is_loopback_enabled
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 316
static inline signed int is_loopback_enabled(struct bladerf *dev)
{
  enum anonymous_3 loopback;
  signed int status;
  status=lms_get_loopback_mode(dev, &loopback);
  if(!(status == 0))
    return status;

  else
    return (signed int)((signed int)loopback != BLADERF_LB_NONE);
}

// is_page_aligned
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 381
static inline _Bool is_page_aligned(unsigned int val)
{
  return val % (unsigned int)256 == (unsigned int)0;
}

// is_valid_addr_len
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 386
static inline _Bool is_valid_addr_len(unsigned int addr, unsigned int len)
{
  if(addr >= 4194304u)
    return (_Bool)0;

  else
    if(len >= 4194305u)
      return (_Bool)0;

    else
      if(addr + len >= 4194305u)
        return (_Bool)0;

      else
        return (_Bool)1;
}

// is_valid_fx3_ram_addr
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 72
static inline _Bool is_valid_fx3_ram_addr(unsigned int addr, unsigned int len)
{
  _Bool valid = (_Bool)1;
  const unsigned int itcm_base = (const unsigned int)0x00000000;
  const unsigned int itcm_len = (const unsigned int)0x4000;
  const unsigned int itcm_end = itcm_base + itcm_len;
  const unsigned int sysmem_base = (const unsigned int)0x40000000;
  const unsigned int sysmem_len = (const unsigned int)0x80000;
  const unsigned int sysmem_end = sysmem_base + sysmem_len;
  const _Bool in_itcm = addr < itcm_end && len <= itcm_len && addr + len < itcm_end;
  const _Bool in_sysmem = addr >= sysmem_base && addr < sysmem_end && len <= sysmem_len && addr + len < sysmem_end;
  /* assertion itcm_base == 0 */
  assert(itcm_base == (unsigned int)0);
  valid = in_itcm != (_Bool)0 || in_sysmem != (_Bool)0;
  return valid;
}

// left_in_msg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 250
static inline unsigned int left_in_msg(struct bladerf_sync *s)
{
  unsigned long int ret = (unsigned long int)s->meta.samples_per_msg - s->meta.curr_msg_off;
  /* assertion ret <= (0x7fffffff * 2U + 1U) */
  assert(ret <= (unsigned long int)((unsigned int)0x7fffffff * 2U + 1U));
  return (unsigned int)ret;
}

// libusb_fill_bulk_transfer
// file /usr/include/libusb-1.0/libusb.h line 1545
static inline void libusb_fill_bulk_transfer(struct libusb_transfer *transfer, struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, signed int length, void (*callback)(struct libusb_transfer *), void *user_data, unsigned int timeout)
{
  transfer->dev_handle = dev_handle;
  transfer->endpoint = endpoint;
  transfer->type = (unsigned char)2;
  transfer->timeout = timeout;
  transfer->buffer = buffer;
  transfer->length = length;
  transfer->user_data = user_data;
  transfer->callback = callback;
}

// lms_bw2uint
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 169
unsigned int lms_bw2uint(enum anonymous_13 bw)
{
  unsigned int idx = (unsigned int)((signed int)bw & 0xf);
  /* assertion idx < (sizeof(uint_bandwidths) / sizeof(uint_bandwidths[0])) */
  assert((unsigned long int)idx < sizeof(const unsigned int [16l]) /*64ul*/  / sizeof(const unsigned int) /*4ul*/ );
  return uint_bandwidths[(signed long int)idx];
}

// lms_calculate_tuning_params
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 618
signed int lms_calculate_tuning_params(unsigned int freq, struct lms_freq *f)
{
  unsigned long int vco_x;
  unsigned long int temp;
  unsigned short int nint;
  unsigned int nfrac;
  unsigned char freqsel = bands[(signed long int)0].value;
  unsigned char i = (unsigned char)0;
  const unsigned long int ref_clock = (const unsigned long int)38400000u;
  if(!(freq >= 237500000u))
  {
    freq = 237500000u;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:2225] Clamping frequency to %uHz\n", freq);
    while((_Bool)0);
  }

  else
    if(freq >= 3800000001u)
    {
      freq = 3800000000u;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:2228] Clamping frequency to %uHz\n", freq);
      while((_Bool)0);
    }

  for( ; !((unsigned long int)i >= 16ul); i = i + 1)
    if(freq >= bands[(signed long int)i].low)
    {
      if(bands[(signed long int)i].high >= freq)
      {
        freqsel = bands[(signed long int)i].value;
        break;
      }

    }

  if((unsigned long int)i >= 16ul)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_CRITICAL, "[CRITICAL @ lms.c:2244] BUG: Failed to find frequency band information. Setting frequency to %u Hz.\n", 237500000u);
    while((_Bool)0);
    return -1;
  }

  else
  {
    f->vcocap=estimate_vcocap(freq, bands[(signed long int)i].low, bands[(signed long int)i].high);
    vco_x = (unsigned long int)1 << ((signed int)freqsel & 7) - 3;
    temp = (vco_x * (unsigned long int)freq) / ref_clock;
    /* assertion temp <= (65535) */
    assert(temp <= (unsigned long int)65535);
    nint = (unsigned short int)temp;
    temp = (unsigned long int)(1 << 23) * (vco_x * (unsigned long int)freq - (unsigned long int)nint * ref_clock);
    temp = (temp + ref_clock / (unsigned long int)2) / ref_clock;
    /* assertion temp <= (4294967295U) */
    assert(temp <= (unsigned long int)4294967295U);
    nfrac = (unsigned int)temp;
    /* assertion vco_x <= (255) */
    assert(vco_x <= (unsigned long int)255);
    f->x = (unsigned char)vco_x;
    f->nint = nint;
    f->nfrac = nfrac;
    f->freqsel = freqsel;
    /* assertion ref_clock <= (4294967295U) */
    assert(ref_clock <= (unsigned long int)4294967295U);
    f->flags = (unsigned char)0;
    if(!(freq >= 1500000000u))
      f->flags = f->flags | (unsigned char)(1 << 0);

    lms_print_frequency(f);
    return 0;
  }
}

// lms_calibrate_dc
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 669
signed int lms_calibrate_dc(struct bladerf *dev, enum anonymous_0 module)
{
  signed int status;
  signed int tmp_status;
  struct dc_cal_state state;
  _Bool converged;
  _Bool limit_reached;
  status=dc_cal_backup(dev, module, &state);
  if(!(status == 0))
    return status;

  else
  {
    status=dc_cal_module_init(dev, module, &state);
    if(status == 0)
    {
      converged = (_Bool)0;
      limit_reached = (_Bool)0;
      while(converged == (_Bool)0 && limit_reached == (_Bool)0 && status == 0)
      {
        status=dc_cal_module(dev, module, &state, &converged);
        if(converged == (_Bool)0 && status == 0)
          status=dc_cal_retry_adjustment(dev, module, &state, &limit_reached);

      }
      if(converged == (_Bool)0 && status == 0)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:2997] DC Calibration (module=%d) failed to converge.\n", module);
        while((_Bool)0);
        status = -1;
      }

    }


  error:
    ;
    tmp_status=dc_cal_module_deinit(dev, module, &state);
    status = status != 0 ? status : tmp_status;
    tmp_status=dc_cal_restore(dev, module, &state);
    status = status != 0 ? status : tmp_status;
    return status;
  }
}

// lms_clear
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 204
static inline signed int lms_clear(struct bladerf *dev, unsigned char addr, unsigned char mask)
{
  signed int status;
  unsigned char regval;
  status=dev->fn->lms_read(dev, addr, &regval);
  if(!(status == 0))
    return status;

  else
  {
    regval = regval & (unsigned char)~((signed int)mask);
    signed int return_value;
    return_value=dev->fn->lms_write(dev, addr, regval);
    return return_value;
  }
}

// lms_config_charge_pumps
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 225
signed int lms_config_charge_pumps(struct bladerf *dev, enum anonymous module)
{
  signed int status;
  unsigned char data;
  const unsigned char base = (const unsigned char)((signed int)module == BLADERF_MODULE_RX ? 0x20 : 0x10);
  status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 6), &data);
  if(!(status == 0))
    return status;

  else
  {
    data = data & (unsigned char)~0x1f;
    data = data | (unsigned char)0x0c;
    status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 6), data);
    if(!(status == 0))
      return status;

    else
    {
      status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 7), &data);
      if(!(status == 0))
        return status;

      else
      {
        data = data & (unsigned char)~0x1f;
        data = data | (unsigned char)3;
        status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 7), data);
        if(!(status == 0))
          return status;

        else
        {
          status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 8), &data);
          if(!(status == 0))
            return status;

          else
          {
            data = data & (unsigned char)~0x1f;
            data = data | (unsigned char)3;
            status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 8), data);
            if(!(status == 0))
              return status;

            else
              return 0;
          }
        }
      }
    }
  }
}

// lms_dc_cal_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2405
static signed int lms_dc_cal_loop(struct bladerf *dev, unsigned char base, unsigned char cal_address, unsigned char dc_cntval, unsigned char *dc_regval)
{
  signed int status;
  unsigned char i;
  unsigned char val;
  _Bool done = (_Bool)0;
  const unsigned int max_cal_count = (const unsigned int)25;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2414] Calibrating module %2.2x:%2.2x\n", base, cal_address);
  while((_Bool)0);
  status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 0x03), &val);
  if(!(status == 0))
    return status;

  else
  {
    val = val & (unsigned char)~0x07;
    val = val | (unsigned char)((signed int)cal_address & 0x07);
    status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 0x03), val);
    if(!(status == 0))
      return status;

    else
    {
      status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 0x02), dc_cntval);
      if(!(status == 0))
        return status;

      else
      {
        val = val | (unsigned char)(1 << 4);
        status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 0x03), val);
        if(!(status == 0))
          return status;

        else
        {
          val = val & (unsigned char)~(1 << 4);
          status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 0x03), val);
          if(!(status == 0))
            return status;

          else
          {
            val = val | (unsigned char)(1 << 5);
            status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 0x03), val);
            if(!(status == 0))
              return status;

            else
            {
              val = val & (unsigned char)~(1 << 5);
              status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 0x03), val);
              if(!(status == 0))
                return status;

              else
              {
                i = (unsigned char)0;
                if(done == (_Bool)0 && !((unsigned int)i >= max_cal_count))
                {
                  status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 0x01), &val);
                  if(!(status == 0))
                    return status;

                  if(((signed int)val >> 1 & 1) == 0)
                  {
                    done = (_Bool)1;
                    status=dev->fn->lms_read(dev, base, dc_regval);
                    if(status == 0)
                      *dc_regval = *dc_regval & (unsigned char)0x3f;

                  }

                  i = i + 1;
                }

                if((signed int)done == 0)
                {
                  log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:2483] DC calibration loop did not converge.\n");
                  status = -1;
                }

                else
                  log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2486] DC_REGVAL: %d\n", *dc_regval);
                return status;
              }
            }
          }
        }
      }
    }
  }
}

// lms_dither_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 654
signed int lms_dither_enable(struct bladerf *dev, enum anonymous mod, unsigned char nbits, _Bool enable)
{
  signed int status;
  const unsigned char reg = (const unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 0x24 : 0x14);
  unsigned char data;
  if((signed int)nbits >= 9 || !((signed int)nbits >= 1))
    return -3;

  else
  {
    status=dev->fn->lms_read(dev, reg, &data);
    if(!(status == 0))
      return status;

    else
    {
      if(!(enable == (_Bool)0))
      {
        data = data | (unsigned char)(1 << 7);
        data = data & (unsigned char)~(7 << 4);
        data = data | (unsigned char)(((signed int)nbits - 1 & 7) << 4);
      }

      else
        data = data & (unsigned char)~(1 << 7);
      status=dev->fn->lms_write(dev, reg, data);
      return status;
    }
  }
}

// lms_dump_registers
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2383
signed int lms_dump_registers(struct bladerf *dev)
{
  signed int status = 0;
  unsigned char data;
  unsigned char i;
  const unsigned short int num_reg = (const unsigned short int)sizeof(const unsigned char [107l]) /*107ul*/ ;
  i = (unsigned char)0;
  if(!((signed int)i >= (signed int)num_reg))
  {
    status=dev->fn->lms_read(dev, lms_reg_dumpset[(signed long int)i], &data);
    if(!(status == 0))
    {
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2392] Failed to read LMS @ 0x%02x\n", lms_reg_dumpset[(signed long int)i]);
      return status;
    }

    else
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2395] LMS[0x%02x] = 0x%02x\n", lms_reg_dumpset[(signed long int)i], data);
    i = i + 1;
  }

  return status;
}

// lms_enable_rffe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 503
signed int lms_enable_rffe(struct bladerf *dev, enum anonymous module, _Bool enable)
{
  signed int status;
  unsigned char data;
  unsigned char addr = (unsigned char)((signed int)module == BLADERF_MODULE_TX ? 0x40 : 0x70);
  status=dev->fn->lms_read(dev, addr, &data);
  if(status == 0)
  {
    if((signed int)module == BLADERF_MODULE_TX)
    {
      if(!(enable == (_Bool)0))
        data = data | (unsigned char)(1 << 1);

      else
        data = data & (unsigned char)~(1 << 1);
    }

    else
      if(!(enable == (_Bool)0))
        data = data | (unsigned char)(1 << 0);

      else
        data = data & (unsigned char)~(1 << 0);
    status=dev->fn->lms_write(dev, addr, data);
  }

  return status;
}

// lms_frequency_to_hz
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 573
unsigned int lms_frequency_to_hz(struct lms_freq *f)
{
  unsigned long int pll_coeff;
  unsigned int div;
  pll_coeff = ((unsigned long int)f->nint << 23) + (unsigned long int)f->nfrac;
  div = (unsigned int)((signed int)f->x << 23);
  return (unsigned int)(((unsigned long int)38400000u * pll_coeff + (unsigned long int)(div >> 1)) / (unsigned long int)div);
}

// lms_get_bandwidth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 281
signed int lms_get_bandwidth(struct bladerf *dev, enum anonymous mod, enum anonymous_13 *bw)
{
  signed int status;
  unsigned char data;
  const unsigned char reg = (const unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 0x54 : 0x34);
  status=dev->fn->lms_read(dev, reg, &data);
  if(!(status == 0))
    return status;

  else
  {
    data = data >> 2;
    data = data & (unsigned char)0xf;
    /* assertion data < (sizeof(uint_bandwidths) / sizeof(uint_bandwidths[0])) */
    assert((unsigned long int)data < sizeof(const unsigned int [16l]) /*64ul*/  / sizeof(const unsigned int) /*4ul*/ );
    *bw = (enum anonymous_13)data;
    return 0;
  }
}

// lms_get_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 687
signed int lms_get_dc_cals(struct bladerf *dev, struct bladerf_lms_dc_cals *dc_cals)
{
  signed int status;
  status=get_dc_cal_value(dev, (unsigned char)0x00, (unsigned char)0, &dc_cals->lpf_tuning);
  if(!(status == 0))
    return status;

  else
  {
    status=get_dc_cal_value(dev, (unsigned char)0x30, (unsigned char)0, &dc_cals->tx_lpf_i);
    if(!(status == 0))
      return status;

    else
    {
      status=get_dc_cal_value(dev, (unsigned char)0x30, (unsigned char)1, &dc_cals->tx_lpf_q);
      if(!(status == 0))
        return status;

      else
      {
        status=get_dc_cal_value(dev, (unsigned char)0x50, (unsigned char)0, &dc_cals->rx_lpf_i);
        if(!(status == 0))
          return status;

        else
        {
          status=get_dc_cal_value(dev, (unsigned char)0x50, (unsigned char)1, &dc_cals->rx_lpf_q);
          if(!(status == 0))
            return status;

          else
          {
            status=get_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)0, &dc_cals->dc_ref);
            if(!(status == 0))
              return status;

            else
            {
              status=get_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)1, &dc_cals->rxvga2a_i);
              if(!(status == 0))
                return status;

              else
              {
                status=get_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)2, &dc_cals->rxvga2a_q);
                if(!(status == 0))
                  return status;

                else
                {
                  status=get_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)3, &dc_cals->rxvga2b_i);
                  if(!(status == 0))
                    return status;

                  else
                  {
                    status=get_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)4, &dc_cals->rxvga2b_q);
                    if(!(status == 0))
                      return status;

                    else
                      return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// lms_get_dc_offset_i
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 761
signed int lms_get_dc_offset_i(struct bladerf *dev, enum anonymous module, signed short int *value)
{
  const unsigned char addr = (const unsigned char)((signed int)module == BLADERF_MODULE_TX ? 0x42 : 0x71);
  signed int return_value_get_dc_offset_1;
  return_value_get_dc_offset_1=get_dc_offset(dev, module, addr, value);
  return return_value_get_dc_offset_1;
}

// lms_get_dc_offset_q
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 791
signed int lms_get_dc_offset_q(struct bladerf *dev, enum anonymous module, signed short int *value)
{
  const unsigned char addr = (const unsigned char)((signed int)module == BLADERF_MODULE_TX ? 0x43 : 0x72);
  signed int return_value_get_dc_offset_1;
  return_value_get_dc_offset_1=get_dc_offset(dev, module, addr, value);
  return return_value_get_dc_offset_1;
}

// lms_get_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 594
signed int lms_get_frequency(struct bladerf *dev, enum anonymous mod, struct lms_freq *f)
{
  const unsigned char base = (const unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 0x20 : 0x10);
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 0), &data);
  if(!(status == 0))
    return status;

  else
  {
    f->nint = (unsigned short int)((signed int)(unsigned short int)data << 1);
    status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 1), &data);
    if(!(status == 0))
      return status;

    else
    {
      f->nint = f->nint | (unsigned short int)(((signed int)data & 0x80) >> 7);
      f->nfrac = ((unsigned int)data & (unsigned int)0x7f) << 16;
      status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 2), &data);
      if(!(status == 0))
        return status;

      else
      {
        f->nfrac = f->nfrac | (unsigned int)data << 8;
        status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 3), &data);
        if(!(status == 0))
          return status;

        else
        {
          f->nfrac = f->nfrac | (unsigned int)data;
          status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 5), &data);
          if(!(status == 0))
            return status;

          else
          {
            f->freqsel = (unsigned char)((signed int)data >> 2);
            f->x = (unsigned char)(1 << ((signed int)f->freqsel & 7) - 3);
            status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 9), &data);
            if(!(status == 0))
              return status;

            else
            {
              f->vcocap = (unsigned char)((signed int)data & 0x3f);
              return status;
            }
          }
        }
      }
    }
  }
}

// lms_get_lna
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 774
signed int lms_get_lna(struct bladerf *dev, enum anonymous_2 *lna)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x75, &data);
  if(!(status == 0))
  {
    *lna = (enum anonymous_2)LNA_NONE;
    return status;
  }

  else
  {
    *lna = (enum anonymous_2)((signed int)data >> 4 & 0x3);
    return 0;
  }
}

// lms_get_loopback_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 525
signed int lms_get_loopback_mode(struct bladerf *dev, enum anonymous_3 *loopback)
{
  signed int status;
  unsigned char lben_lbrfen;
  unsigned char loopbben;
  status=dev->fn->lms_read(dev, (unsigned char)0x08, &lben_lbrfen);
  if(!(status == 0))
    return status;

  else
  {
    status=dev->fn->lms_read(dev, (unsigned char)0x46, &loopbben);
    if(!(status == 0))
      return status;

    else
    {
      if((0x7 & (signed int)lben_lbrfen) == 1)
      {
        *loopback = (enum anonymous_3)BLADERF_LB_RF_LNA1;
        return 0;
        *loopback = (enum anonymous_3)BLADERF_LB_RF_LNA2;
        return 0;
        *loopback = (enum anonymous_3)BLADERF_LB_RF_LNA3;
        return 0;
      }

      if((112 & (signed int)lben_lbrfen) == 32)
      {
        if(!((4 & (signed int)loopbben) == 0))
        {
          *loopback = (enum anonymous_3)BLADERF_LB_BB_TXLPF_RXVGA2;
          return 0;
        }

        else
          if(!((8 & (signed int)loopbben) == 0))
          {
            *loopback = (enum anonymous_3)BLADERF_LB_BB_TXVGA1_RXVGA2;
            return 0;
          }

        if(!((4 & (signed int)loopbben) == 0))
        {
          *loopback = (enum anonymous_3)BLADERF_LB_BB_TXLPF_RXLPF;
          return 0;
        }

        else
          if(!((8 & (signed int)loopbben) == 0))
          {
            *loopback = (enum anonymous_3)BLADERF_LB_BB_TXVGA1_RXLPF;
            return 0;
          }

      }

      *loopback = (enum anonymous_3)BLADERF_LB_NONE;
      return 0;
    }
  }
}

// lms_get_quick_tune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 606
signed int lms_get_quick_tune(struct bladerf *dev, enum anonymous mod, struct bladerf_quick_tune *quick_tune)
{
  struct lms_freq f;
  signed int status;
  status=lms_get_frequency(dev, mod, &f);
  if(status == 0)
  {
    quick_tune->freqsel = f.freqsel;
    quick_tune->vcocap = f.vcocap;
    quick_tune->nint = f.nint;
    quick_tune->nfrac = f.nfrac;
    quick_tune->flags = (unsigned char)(1 << 1);
    unsigned int return_value_lms_frequency_to_hz_1;
    return_value_lms_frequency_to_hz_1=lms_frequency_to_hz(&f);
    if(!(return_value_lms_frequency_to_hz_1 >= 1500000000u))
      quick_tune->flags = quick_tune->flags | (unsigned char)(1 << 0);

  }

  return status;
}

// lms_get_sampling
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 732
signed int lms_get_sampling(struct bladerf *dev, enum anonymous_34 *sampling)
{
  signed int status = 0;
  signed int external = 0;
  unsigned char val = (unsigned char)0;
  status=dev->fn->lms_read(dev, (unsigned char)0x09, &val);
  if(!(status == 0))
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3404] Could not read state of ADC pin connectivity\n");

  else
  {
    external = ((signed int)val & 1 << 7) != 0 ? 1 : 0;
    status=dev->fn->lms_read(dev, (unsigned char)0x64, &val);
    if(!(status == 0))
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3411] Could not read RXVGA2 state\n");

    else
    {
      external = external | (((signed int)val & 1 << 1) != 0 ? 0 : 2);
      if(external == 0)
      {
        *sampling = (enum anonymous_34)BLADERF_SAMPLING_INTERNAL;
        *sampling = (enum anonymous_34)BLADERF_SAMPLING_EXTERNAL;
      }

      *sampling = (enum anonymous_34)BLADERF_SAMPLING_UNKNOWN;
    }
  }

out:
  ;
  return status;
}

// lms_lna_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 328
signed int lms_lna_get_gain(struct bladerf *dev, enum anonymous_12 *gain)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x75, &data);
  if(status == 0)
  {
    data = data >> 6;
    data = data & (unsigned char)3;
    *gain = (enum anonymous_12)data;
    if((signed int)*gain == BLADERF_LNA_GAIN_UNKNOWN)
      status = -3;

  }

  return status;
}

// lms_lna_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 318
signed int lms_lna_set_gain(struct bladerf *dev, enum anonymous_12 gain)
{
  signed int status;
  unsigned char data;
  if((signed int)gain == BLADERF_LNA_GAIN_BYPASS || (signed int)gain == BLADERF_LNA_GAIN_MID || (signed int)gain == BLADERF_LNA_GAIN_MAX)
  {
    status=dev->fn->lms_read(dev, (unsigned char)0x75, &data);
    if(status == 0)
    {
      data = data & (unsigned char)~(3 << 6);
      data = data | (unsigned char)(((signed int)gain & 3) << 6);
      status=dev->fn->lms_write(dev, (unsigned char)0x75, data);
    }

  }

  else
    status = -3;
  return status;
}

// lms_lpf_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 235
signed int lms_lpf_enable(struct bladerf *dev, enum anonymous mod, _Bool enable)
{
  signed int status;
  unsigned char data;
  const unsigned char reg = (const unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 0x54 : 0x34);
  status=dev->fn->lms_read(dev, reg, &data);
  if(!(status == 0))
    return status;

  else
  {
    if(!(enable == (_Bool)0))
      data = data | (unsigned char)(1 << 1);

    else
      data = data & (unsigned char)~(1 << 1);
    status=dev->fn->lms_write(dev, reg, data);
    if(!(status == 0))
      return status;

    else
    {
      status=dev->fn->lms_read(dev, (unsigned char)((signed int)reg + 1), &data);
      if(!(status == 0))
        return status;

      else
        if(!((64 & (signed int)data) == 0))
        {
          data = data & (unsigned char)~(1 << 6);
          status=dev->fn->lms_write(dev, (unsigned char)((signed int)reg + 1), data);
        }

      return status;
    }
  }
}

// lms_lpf_get_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 258
signed int lms_lpf_get_mode(struct bladerf *dev, enum anonymous mod, enum anonymous_14 *mode)
{
  signed int status;
  const unsigned char reg = (const unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 0x54 : 0x34);
  unsigned char data_h;
  unsigned char data_l;
  _Bool lpf_enabled;
  _Bool lpf_bypassed;
  status=dev->fn->lms_read(dev, reg, &data_l);
  if(!(status == 0))
    return status;

  else
  {
    status=dev->fn->lms_read(dev, (unsigned char)((signed int)reg + 1), &data_h);
    if(!(status == 0))
      return status;

    else
    {
      lpf_enabled = ((signed int)data_l & 1 << 1) != 0;
      lpf_bypassed = ((signed int)data_h & 1 << 6) != 0;
      if(lpf_bypassed == (_Bool)0 && !(lpf_enabled == (_Bool)0))
        *mode = (enum anonymous_14)BLADERF_LPF_NORMAL;

      else
        if(lpf_enabled == (_Bool)0 && !(lpf_bypassed == (_Bool)0))
          *mode = (enum anonymous_14)BLADERF_LPF_BYPASSED;

        else
          if(lpf_bypassed == (_Bool)0 && lpf_enabled == (_Bool)0)
            *mode = (enum anonymous_14)BLADERF_LPF_DISABLED;

          else
          {
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:516] Invalid LPF configuration: 0x%02x, 0x%02x\n", data_l, data_h);
            status = -3;
          }
      return status;
    }
  }
}

// lms_lpf_set_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 246
signed int lms_lpf_set_mode(struct bladerf *dev, enum anonymous mod, enum anonymous_14 mode)
{
  signed int status;
  const unsigned char reg = (const unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 0x54 : 0x34);
  unsigned char data_l;
  unsigned char data_h;
  status=dev->fn->lms_read(dev, reg, &data_l);
  if(!(status == 0))
    return status;

  else
  {
    status=dev->fn->lms_read(dev, (unsigned char)((signed int)reg + 1), &data_h);
    if(!(status == 0))
      return status;

    else
    {
      if((signed int)mode == BLADERF_LPF_NORMAL)
      {
        data_l = data_l | (unsigned char)(1 << 1);
        data_h = data_h & (unsigned char)~(1 << 6);
        data_l = data_l & (unsigned char)~(1 << 1);
        data_h = data_h | (unsigned char)(1 << 6);
        data_l = data_l & (unsigned char)~(1 << 1);
        data_h = data_h & (unsigned char)~(1 << 6);
      }

      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:559] Invalid LPF mode: %d\n", mode);
      return -3;
      status=dev->fn->lms_write(dev, reg, data_l);
      if(!(status == 0))
        return status;

      else
      {
        status=dev->fn->lms_write(dev, (unsigned char)((signed int)reg + 1), data_h);
        return status;
      }
    }
  }
}

// lms_peakdetect_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 950
signed int lms_peakdetect_enable(struct bladerf *dev, _Bool enable)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x44, &data);
  if(status == 0)
  {
    if(!(enable == (_Bool)0))
      data = data & (unsigned char)~(1 << 0);

    else
      data = data | (unsigned char)(1 << 0);
    status=dev->fn->lms_write(dev, (unsigned char)0x44, data);
  }

  return status;
}

// lms_pll_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1596
signed int lms_pll_enable(struct bladerf *dev, enum anonymous mod, _Bool enable)
{
  signed int status;
  const unsigned char reg = (const unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 0x24 : 0x14);
  unsigned char data;
  status=dev->fn->lms_read(dev, reg, &data);
  if(status == 0)
  {
    if(!(enable == (_Bool)0))
      data = data | (unsigned char)(1 << 3);

    else
      data = data & (unsigned char)~(1 << 3);
    status=dev->fn->lms_write(dev, reg, data);
  }

  return status;
}

// lms_power_down
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1579
signed int lms_power_down(struct bladerf *dev)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x05, &data);
  if(status == 0)
  {
    data = data & (unsigned char)~(1 << 4);
    status=dev->fn->lms_write(dev, (unsigned char)0x05, data);
  }

  return status;
}

// lms_print_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1675
void lms_print_frequency(struct lms_freq *f)
{
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1677] ---- Frequency ----\n");
  while((_Bool)0);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1678]   x        : %d\n", f->x);
  while((_Bool)0);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1679]   nint     : %d\n", f->nint);
  while((_Bool)0);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1680]   nfrac    : %u\n", f->nfrac);
  while((_Bool)0);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1681]   freqsel  : 0x%02x\n", f->freqsel);
  while((_Bool)0);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1682]   reference: %u\n", 38400000u);
  while((_Bool)0);
  do
  {
    unsigned int return_value_lms_frequency_to_hz_1;
    return_value_lms_frequency_to_hz_1=lms_frequency_to_hz(f);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1683]   freq     : %u\n", return_value_lms_frequency_to_hz_1);
  }
  while((_Bool)0);
}

// lms_rx_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1618
signed int lms_rx_enable(struct bladerf *dev, _Bool enable)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x05, &data);
  if(status == 0)
  {
    if(!(enable == (_Bool)0))
      data = data | (unsigned char)(1 << 2);

    else
      data = data & (unsigned char)~(1 << 2);
    status=dev->fn->lms_write(dev, (unsigned char)0x05, data);
  }

  return status;
}

// lms_rxvga1_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 794
signed int lms_rxvga1_enable(struct bladerf *dev, _Bool enable)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x7d, &data);
  if(!(status == 0))
    return status;

  else
  {
    if(!(enable == (_Bool)0))
      data = data & (unsigned char)~(1 << 3);

    else
      data = data | (unsigned char)(1 << 3);
    signed int return_value;
    return_value=dev->fn->lms_write(dev, (unsigned char)0x7d, data);
    return return_value;
  }
}

// lms_rxvga1_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 382
signed int lms_rxvga1_get_gain(struct bladerf *dev, signed int *gain)
{
  unsigned char data;
  signed int status;
  status=dev->fn->lms_read(dev, (unsigned char)0x76, &data);
  if(status == 0)
  {
    data = data & (unsigned char)0x7f;
    if((signed int)data >= 121)
      data = (unsigned char)120;

    *gain = (signed int)rxvga1_lut_code2val[(signed long int)data];
  }

  return status;
}

// lms_rxvga1_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 372
signed int lms_rxvga1_set_gain(struct bladerf *dev, signed int gain)
{
  if(gain >= 31)
  {
    gain = 30;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:820] Clamping RXVGA1 gain to %ddB\n", gain);
    while((_Bool)0);
  }

  else
    if(!(gain >= 5))
    {
      gain = 5;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:823] Clamping RXVGA1 gain to %ddB\n", gain);
      while((_Bool)0);
    }

  signed int return_value;
  return_value=dev->fn->lms_write(dev, (unsigned char)0x76, rxvga1_lut_val2code[(signed long int)gain]);
  return return_value;
}

// lms_rxvga2_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 852
signed int lms_rxvga2_enable(struct bladerf *dev, _Bool enable)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x64, &data);
  if(!(status == 0))
    return status;

  else
  {
    if(!(enable == (_Bool)0))
      data = data | (unsigned char)(1 << 1);

    else
      data = data & (unsigned char)~(1 << 1);
    signed int return_value;
    return_value=dev->fn->lms_write(dev, (unsigned char)0x64, data);
    return return_value;
  }
}

// lms_rxvga2_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 415
signed int lms_rxvga2_get_gain(struct bladerf *dev, signed int *gain)
{
  unsigned char data;
  signed int status;
  status=dev->fn->lms_read(dev, (unsigned char)0x65, &data);
  if(status == 0)
  {
    data = data * (unsigned char)3;
    *gain = (signed int)data;
  }

  return status;
}

// lms_rxvga2_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 405
signed int lms_rxvga2_set_gain(struct bladerf *dev, signed int gain)
{
  if(gain >= 31)
  {
    gain = 30;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:879] Clamping RXVGA2 gain to %ddB\n", gain);
    while((_Bool)0);
  }

  else
    if(!(gain >= 0))
    {
      gain = 0;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:882] Clamping RXVGA2 gain to %ddB\n", gain);
      while((_Bool)0);
    }

  signed int return_value;
  return_value=dev->fn->lms_write(dev, (unsigned char)0x65, (unsigned char)(gain / 3));
  return return_value;
}

// lms_select_band
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2187
signed int lms_select_band(struct bladerf *dev, enum anonymous module, _Bool low_band)
{
  signed int status;
  status=is_loopback_enabled(dev);
  if(!(status >= 0))
    return status;

  else
    if(status >= 1)
      return 0;

  if((signed int)module == BLADERF_MODULE_TX)
  {
    enum anonymous_1 pa = (enum anonymous_1)(low_band != (_Bool)0 ? PA_1 : PA_2);
    status=lms_select_pa(dev, pa);
  }

  else
  {
    enum anonymous_2 lna = (enum anonymous_2)(low_band != (_Bool)0 ? LNA_1 : LNA_2);
    status=lms_select_lna(dev, lna);
  }
  return status;
}

// lms_select_lna
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 757
signed int lms_select_lna(struct bladerf *dev, enum anonymous_2 lna)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x75, &data);
  if(!(status == 0))
    return status;

  else
  {
    data = data & (unsigned char)~(3 << 4);
    data = data | (unsigned char)(((signed int)lna & 3) << 4);
    signed int return_value;
    return_value=dev->fn->lms_write(dev, (unsigned char)0x75, data);
    return return_value;
  }
}

// lms_select_pa
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 907
signed int lms_select_pa(struct bladerf *dev, enum anonymous_1 pa)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x44, &data);
  data = data & (unsigned char)~0x1C;
  data = data | (unsigned char)(1 << 1);
  if((signed int)pa == PA_AUX)
  {
    data = data & (unsigned char)~(1 << 1);
    data = data | (unsigned char)(2 << 2);
    data = data | (unsigned char)(4 << 2);
  }

  /* assertion !"Invalid PA selection" */
  assert(!((_Bool)"Invalid PA selection"));
  status = -3;
  if(status == 0)
    status=dev->fn->lms_write(dev, (unsigned char)0x44, data);

  return status;
}

// lms_select_sampling
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 722
signed int lms_select_sampling(struct bladerf *dev, enum anonymous_34 sampling)
{
  unsigned char val;
  signed int status = 0;
  if((signed int)sampling == BLADERF_SAMPLING_INTERNAL)
  {
    status=dev->fn->lms_read(dev, (unsigned char)0x09, &val);
    if(!(status == 0))
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3336] Could not read LMS to connect ADC to external pins\n");

    val = val & (unsigned char)~(1 << 7);
    status=dev->fn->lms_write(dev, (unsigned char)0x09, val);
    if(!(status == 0))
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3343] Could not write LMS to connect ADC to external pins\n");

    status=dev->fn->lms_read(dev, (unsigned char)0x64, &val);
    if(!(status == 0))
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3350] Could not read LMS to enable RXVGA2\n");

    val = val | (unsigned char)(1 << 1);
    status=dev->fn->lms_write(dev, (unsigned char)0x64, val);
    if(!(status == 0))
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3357] Could not write LMS to enable RXVGA2\n");

  }

  else
    if((signed int)sampling == BLADERF_SAMPLING_EXTERNAL)
    {
      status=dev->fn->lms_read(dev, (unsigned char)0x64, &val);
      if(!(status == 0))
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3364] Could not read the LMS to disable RXVGA2\n");

      val = val & (unsigned char)~(1 << 1);
      status=dev->fn->lms_write(dev, (unsigned char)0x64, val);
      if(!(status == 0))
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3371] Could not write the LMS to disable RXVGA2\n");

      status=dev->fn->lms_read(dev, (unsigned char)0x09, &val);
      if(!(status == 0))
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3378] Could not read the LMS to connect ADC to internal pins\n");

      val = val | (unsigned char)(1 << 7);
      status=dev->fn->lms_write(dev, (unsigned char)0x09, val);
      if(!(status == 0))
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:3385] Could not write the LMS to connect ADC to internal pins\n");

    }

    else
      status = -3;

out:
  ;
  return status;
}

// lms_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 180
static inline signed int lms_set(struct bladerf *dev, unsigned char addr, unsigned char mask)
{
  signed int status;
  unsigned char regval;
  status=dev->fn->lms_read(dev, addr, &regval);
  if(!(status == 0))
    return status;

  else
  {
    regval = regval | mask;
    signed int return_value;
    return_value=dev->fn->lms_write(dev, addr, regval);
    return return_value;
  }
}

// lms_set_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 180
static inline signed int lms_set_link1(struct bladerf *dev_link1, unsigned char addr_link1, unsigned char mask_link1)
{
  signed int status_link1;
  unsigned char regval_link1;
  status_link1=dev_link1->fn->lms_read(dev_link1, addr_link1, &regval_link1);
  if(!(status_link1 == 0))
    return status_link1;

  else
  {
    regval_link1 = regval_link1 | mask_link1;
    signed int return_value_link1;
    return_value_link1=dev_link1->fn->lms_write(dev_link1, addr_link1, regval_link1);
    return return_value_link1;
  }
}

// lms_set_bandwidth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 270
signed int lms_set_bandwidth(struct bladerf *dev, enum anonymous mod, enum anonymous_13 bw)
{
  signed int status;
  unsigned char data;
  const unsigned char reg = (const unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 0x54 : 0x34);
  status=dev->fn->lms_read(dev, reg, &data);
  if(!(status == 0))
    return status;

  else
  {
    data = data & (unsigned char)~0x3c;
    data = data | (unsigned char)((signed int)bw << 2);
    signed int return_value;
    return_value=dev->fn->lms_write(dev, reg, data);
    return return_value;
  }
}

// lms_set_dc_cals
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 678
signed int lms_set_dc_cals(struct bladerf *dev, struct bladerf_lms_dc_cals *dc_cals)
{
  signed int status;
  _Bool cal_tx_lpf;
  _Bool tmp_if_expr_1;
  if((signed int)dc_cals->tx_lpf_i >= 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)dc_cals->tx_lpf_q >= 0 ? (_Bool)1 : (_Bool)0;
  cal_tx_lpf = tmp_if_expr_1;
  _Bool cal_rx_lpf;
  _Bool tmp_if_expr_2;
  if((signed int)dc_cals->rx_lpf_i >= 0)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)dc_cals->rx_lpf_q >= 0 ? (_Bool)1 : (_Bool)0;
  cal_rx_lpf = tmp_if_expr_2;
  _Bool cal_rxvga2;
  _Bool tmp_if_expr_3;
  if((signed int)dc_cals->dc_ref >= 0)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)dc_cals->rxvga2a_i >= 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed int)dc_cals->rxvga2a_q >= 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = (signed int)dc_cals->rxvga2b_i >= 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_5)
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = (signed int)dc_cals->rxvga2b_q >= 0 ? (_Bool)1 : (_Bool)0;
  cal_rxvga2 = tmp_if_expr_6;
  if((signed int)dc_cals->lpf_tuning >= 0)
  {
    status=enable_lpf_cal_clock(dev, (_Bool)1);
    if(!(status == 0))
      return status;

    status=set_dc_cal_value(dev, (unsigned char)0x00, (unsigned char)0, dc_cals->lpf_tuning);
    if(!(status == 0))
      return status;

    status=enable_lpf_cal_clock(dev, (_Bool)0);
    if(status == 0)
      goto __CPROVER_DUMP_L15;

    return status;
  }

  else
  {

  __CPROVER_DUMP_L15:
    ;
    if(!(cal_tx_lpf == (_Bool)0))
    {
      status=enable_txlpf_dccal_clock(dev, (_Bool)1);
      if(!(status == 0))
        return status;

      if((signed int)dc_cals->tx_lpf_i >= 0)
      {
        status=set_dc_cal_value(dev, (unsigned char)0x30, (unsigned char)0, dc_cals->tx_lpf_i);
        if(!(status == 0))
          return status;

      }

      if((signed int)dc_cals->tx_lpf_q >= 0)
      {
        status=set_dc_cal_value(dev, (unsigned char)0x30, (unsigned char)1, dc_cals->tx_lpf_q);
        if(!(status == 0))
          return status;

      }

      status=enable_txlpf_dccal_clock(dev, (_Bool)0);
      if(status == 0)
        goto __CPROVER_DUMP_L19;

      return status;
    }

    else
    {

    __CPROVER_DUMP_L19:
      ;
      if(!(cal_rx_lpf == (_Bool)0))
      {
        status=enable_rxlpf_dccal_clock(dev, (_Bool)1);
        if(!(status == 0))
          return status;

        if((signed int)dc_cals->rx_lpf_i >= 0)
        {
          status=set_dc_cal_value(dev, (unsigned char)0x50, (unsigned char)0, dc_cals->rx_lpf_i);
          if(!(status == 0))
            return status;

        }

        if((signed int)dc_cals->rx_lpf_q >= 0)
        {
          status=set_dc_cal_value(dev, (unsigned char)0x50, (unsigned char)1, dc_cals->rx_lpf_q);
          if(!(status == 0))
            return status;

        }

        status=enable_rxlpf_dccal_clock(dev, (_Bool)0);
        if(status == 0)
          goto __CPROVER_DUMP_L23;

        return status;
      }

      else
      {

      __CPROVER_DUMP_L23:
        ;
        if(!(cal_rxvga2 == (_Bool)0))
        {
          status=enable_rxvga2_dccal_clock(dev, (_Bool)1);
          if(!(status == 0))
            return status;

          if((signed int)dc_cals->dc_ref >= 0)
          {
            status=set_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)0, dc_cals->dc_ref);
            if(!(status == 0))
              return status;

          }

          if((signed int)dc_cals->rxvga2a_i >= 0)
          {
            status=set_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)1, dc_cals->rxvga2a_i);
            if(!(status == 0))
              return status;

          }

          if((signed int)dc_cals->rxvga2a_q >= 0)
          {
            status=set_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)2, dc_cals->rxvga2a_q);
            if(!(status == 0))
              return status;

          }

          if((signed int)dc_cals->rxvga2b_i >= 0)
          {
            status=set_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)3, dc_cals->rxvga2b_i);
            if(!(status == 0))
              return status;

          }

          if((signed int)dc_cals->rxvga2b_q >= 0)
          {
            status=set_dc_cal_value(dev, (unsigned char)0x60, (unsigned char)4, dc_cals->rxvga2b_q);
            if(!(status == 0))
              return status;

          }

          status=enable_rxvga2_dccal_clock(dev, (_Bool)0);
          if(status == 0)
            goto __CPROVER_DUMP_L30;

          return status;
        }

        else
        {

        __CPROVER_DUMP_L30:
          ;
          return 0;
        }
      }
    }
  }
}

// lms_set_dc_offset_i
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 746
signed int lms_set_dc_offset_i(struct bladerf *dev, enum anonymous module, unsigned short int value)
{
  const unsigned char addr = (const unsigned char)((signed int)module == BLADERF_MODULE_TX ? 0x42 : 0x71);
  signed int return_value_set_dc_offset_reg_1;
  return_value_set_dc_offset_reg_1=set_dc_offset_reg(dev, module, addr, (signed short int)value);
  return return_value_set_dc_offset_reg_1;
}

// lms_set_dc_offset_q
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 776
signed int lms_set_dc_offset_q(struct bladerf *dev, enum anonymous module, signed short int value)
{
  const unsigned char addr = (const unsigned char)((signed int)module == BLADERF_MODULE_TX ? 0x43 : 0x72);
  signed int return_value_set_dc_offset_reg_1;
  return_value_set_dc_offset_reg_1=set_dc_offset_reg(dev, module, addr, value);
  return return_value_set_dc_offset_reg_1;
}

// lms_set_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 641
static inline signed int lms_set_frequency(struct bladerf *dev, enum anonymous mod, unsigned int freq)
{
  struct lms_freq f;
  lms_calculate_tuning_params(freq, &f);
  signed int return_value_lms_set_precalculated_frequency_1;
  return_value_lms_set_precalculated_frequency_1=lms_set_precalculated_frequency(dev, mod, &f);
  return return_value_lms_set_precalculated_frequency_1;
}

// lms_set_frequency_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 641
static inline signed int lms_set_frequency_link1(struct bladerf *dev_link1, enum anonymous mod_link1, unsigned int freq_link1)
{
  struct lms_freq f_link1;
  lms_calculate_tuning_params(freq_link1, &f_link1);
  signed int return_value_lms_set_precalculated_frequency_1_link1;
  return_value_lms_set_precalculated_frequency_1_link1=lms_set_precalculated_frequency(dev_link1, mod_link1, &f_link1);
  return return_value_lms_set_precalculated_frequency_1_link1;
}

// lms_set_loopback_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 514
signed int lms_set_loopback_mode(struct bladerf *dev, enum anonymous_3 mode)
{
  signed int status;
  if((signed int)mode == BLADERF_LB_BB_TXLPF_RXVGA2 || (signed int)mode == BLADERF_LB_BB_TXVGA1_RXVGA2 || (signed int)mode == BLADERF_LB_BB_TXLPF_RXLPF || (signed int)mode == BLADERF_LB_BB_TXVGA1_RXLPF || (signed int)mode == BLADERF_LB_RF_LNA1 || (signed int)mode == BLADERF_LB_RF_LNA2 || (signed int)mode == BLADERF_LB_RF_LNA3 || (signed int)mode == BLADERF_LB_NONE)
    goto __CPROVER_DUMP_L3;

  return -3;

__CPROVER_DUMP_L3:
  ;
  status=lms_select_pa(dev, (enum anonymous_1)PA_NONE);
  if(!(status == 0))
    return status;

  else
  {
    status=lms_select_lna(dev, (enum anonymous_2)LNA_NONE);
    if(!(status == 0))
      return status;

    else
    {
      status=loopback_path(dev, (enum anonymous_3)BLADERF_LB_NONE);
      if(!(status == 0))
        return status;

      else
      {
        status=loopback_rx(dev, mode);
        if(!(status == 0))
          return status;

        else
        {
          status=loopback_tx(dev, mode);
          if(!(status == 0))
            return status;

          else
          {
            status=loopback_path(dev, mode);
            if(!(status == 0))
              return status;

            else
              return 0;
          }
        }
      }
    }
  }
}

// lms_set_precalculated_frequency
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 629
signed int lms_set_precalculated_frequency(struct bladerf *dev, enum anonymous mod, struct lms_freq *f)
{
  const unsigned char base = (const unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 0x20 : 0x10);
  unsigned char data;
  unsigned char vcocap_reg_state;
  signed int status;
  signed int dsm_status;
  unsigned char pll_base;
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap_link4(dev, (unsigned long int)(1 << 6));
  pll_base = (const unsigned char)(return_value_have_cap_1 != (_Bool)0 ? (signed int)base | 0x80 : (signed int)base);
  f->vcocap_result = (unsigned char)0xff;
  status=dev->fn->lms_read(dev, (unsigned char)0x09, &data);
  if(status == 0)
  {
    data = data | (unsigned char)0x05;
    status=dev->fn->lms_write(dev, (unsigned char)0x09, data);
  }

  if(!(status == 0))
  {
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:2312] Failed to turn on DSMs\n");
    return status;
  }

  else
  {
    status=dev->fn->lms_read(dev, (unsigned char)((signed int)base + 9), &vcocap_reg_state);
    if(status == 0)
    {
      vcocap_reg_state = vcocap_reg_state & (unsigned char)~0x3f;
      status=write_vcocap(dev, base, f->vcocap, vcocap_reg_state);
      if(status == 0)
      {
        status=write_pll_config(dev, mod, f->freqsel, ((signed int)f->flags & 1 << 0) != 0);
        if(status == 0)
        {
          data = (unsigned char)((signed int)f->nint >> 1);
          status=dev->fn->lms_write(dev, (unsigned char)((signed int)pll_base + 0), data);
          if(status == 0)
          {
            data = (unsigned char)((unsigned int)(((signed int)f->nint & 1) << 7) | f->nfrac >> 16 & (unsigned int)0x7f);
            status=dev->fn->lms_write(dev, (unsigned char)((signed int)pll_base + 1), data);
            if(status == 0)
            {
              data = (unsigned char)(f->nfrac >> 8 & (unsigned int)0xff);
              status=dev->fn->lms_write(dev, (unsigned char)((signed int)pll_base + 2), data);
              if(status == 0)
              {
                data = (unsigned char)(f->nfrac & (unsigned int)0xff);
                status=dev->fn->lms_write(dev, (unsigned char)((signed int)pll_base + 3), data);
                if(status == 0)
                {
                  if(!((2 & (signed int)f->flags) == 0))
                    f->vcocap_result = f->vcocap;

                  else
                    status=tune_vcocap(dev, f->vcocap, base, vcocap_reg_state, &f->vcocap_result);
                }

              }

            }

          }

        }

      }

    }


  error:
    ;
    dsm_status=dev->fn->lms_read(dev, (unsigned char)0x09, &data);
    if(dsm_status == 0)
    {
      data = data & (unsigned char)~0x05;
      dsm_status=dev->fn->lms_write(dev, (unsigned char)0x09, data);
    }

    return status == 0 ? dsm_status : status;
  }
}

// lms_soft_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 697
signed int lms_soft_reset(struct bladerf *dev)
{
  signed int status;
  status=dev->fn->lms_write(dev, (unsigned char)0x05, (unsigned char)0x12);
  if(status == 0)
    status=dev->fn->lms_write(dev, (unsigned char)0x05, (unsigned char)0x32);

  return status;
}

// lms_tx_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1639
signed int lms_tx_enable(struct bladerf *dev, _Bool enable)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x05, &data);
  if(status == 0)
  {
    if(!(enable == (_Bool)0))
      data = data | (unsigned char)(1 << 3);

    else
      data = data & (unsigned char)~(1 << 3);
    status=dev->fn->lms_write(dev, (unsigned char)0x05, data);
  }

  return status;
}

// lms_txvga1_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 464
signed int lms_txvga1_get_gain(struct bladerf *dev, signed int *gain)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x41, &data);
  if(status == 0)
  {
    data = (unsigned char)((signed int)data & 0x1f);
    *gain = (signed int)data - 35;
  }

  return status;
}

// lms_txvga1_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 452
signed int lms_txvga1_set_gain(struct bladerf *dev, signed int gain_int)
{
  signed char gain;
  if(!(gain_int >= -35))
  {
    gain = (signed char)-35;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:1057] Clamping TXVGA1 gain to %ddB\n", gain);
    while((_Bool)0);
  }

  else
    if(gain_int >= -3)
    {
      gain = (signed char)-4;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:1060] Clamping TXVGA1 gain to %ddB\n", gain);
      while((_Bool)0);
    }

    else
      gain = (signed char)gain_int;
  gain = (signed char)((signed int)gain + 35);
  signed int return_value;
  return_value=dev->fn->lms_write(dev, (unsigned char)0x41, (unsigned char)gain);
  return return_value;
}

// lms_txvga2_get_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 439
signed int lms_txvga2_get_gain(struct bladerf *dev, signed int *gain)
{
  signed int status;
  unsigned char data;
  status=dev->fn->lms_read(dev, (unsigned char)0x45, &data);
  if(status == 0)
  {
    *gain = (signed int)data >> 3 & 0x1f;
    if(*gain >= 26)
      *gain = 25;

  }

  return status;
}

// lms_txvga2_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 429
signed int lms_txvga2_set_gain(struct bladerf *dev, signed int gain_int)
{
  signed int status;
  unsigned char data;
  signed char gain;
  if(gain_int >= 26)
  {
    gain = (signed char)25;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:1010] Clamping TXVGA2 gain to %ddB\n", gain);
    while((_Bool)0);
  }

  else
    if(!(gain_int >= 0))
    {
      gain = (signed char)0;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ lms.c:1013] Clamping TXVGA2 gain to %ddB\n", gain);
      while((_Bool)0);
    }

    else
      gain = (signed char)gain_int;
  status=dev->fn->lms_read(dev, (unsigned char)0x45, &data);
  if(status == 0)
  {
    data = data & (unsigned char)~(0x1f << 3);
    data = data | (unsigned char)(((signed int)gain & 0x1f) << 3);
    status=dev->fn->lms_write(dev, (unsigned char)0x45, data);
  }

  return status;
}

// lms_uint2bw
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/lms.h line 160
enum anonymous_13 lms_uint2bw(unsigned int req)
{
  enum anonymous_13 ret;
  if(!(req >= 1500001u))
    ret = (enum anonymous_13)BW_1p5MHz;

  else
    if(!(req >= 1750001u))
      ret = (enum anonymous_13)BW_1p75MHz;

    else
      if(!(req >= 2500001u))
        ret = (enum anonymous_13)BW_2p5MHz;

      else
        if(!(req >= 2750001u))
          ret = (enum anonymous_13)BW_2p75MHz;

        else
          if(!(req >= 3000001u))
            ret = (enum anonymous_13)BW_3MHz;

          else
            if(!(req >= 3840001u))
              ret = (enum anonymous_13)BW_3p84MHz;

            else
              if(!(req >= 5000001u))
                ret = (enum anonymous_13)BW_5MHz;

              else
                if(!(req >= 5500001u))
                  ret = (enum anonymous_13)BW_5p5MHz;

                else
                  if(!(req >= 6000001u))
                    ret = (enum anonymous_13)BW_6MHz;

                  else
                    if(!(req >= 7000001u))
                      ret = (enum anonymous_13)BW_7MHz;

                    else
                      if(!(req >= 8750001u))
                        ret = (enum anonymous_13)BW_8p75MHz;

                      else
                        if(!(req >= 10000001u))
                          ret = (enum anonymous_13)BW_10MHz;

                        else
                          if(!(req >= 12000001u))
                            ret = (enum anonymous_13)BW_12MHz;

                          else
                            if(!(req >= 14000001u))
                              ret = (enum anonymous_13)BW_14MHz;

                            else
                              if(!(req >= 20000001u))
                                ret = (enum anonymous_13)BW_20MHz;

                              else
                                ret = (enum anonymous_13)BW_28MHz;
  return ret;
}

// load_dc_cal
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/config.c line 29
static inline void load_dc_cal(struct bladerf *dev, const char *file)
{
  signed int status;
  struct bladerf_image *img;
  img=bladerf_alloc_image((enum anonymous_38)BLADERF_IMAGE_TYPE_INVALID, (unsigned int)0, (unsigned int)0);
  if(!(img == ((struct bladerf_image *)NULL)))
  {
    status=bladerf_image_read(img, file);
    if(!(status == 0))
      do
      {
        const char *return_value_bladerf_strerror_1;
        return_value_bladerf_strerror_1=bladerf_strerror(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ config.c:42] Failed to open image file (%s): %s\n", file, return_value_bladerf_strerror_1);
      }
      while((_Bool)0);

    else
      switch((signed int)img->type)
      {
        case BLADERF_IMAGE_TYPE_RX_DC_CAL:
        {
          dc_cal_tbl_free(&dev->cal.dc_rx);
          dev->cal.dc_rx=dc_cal_tbl_load(img->data, (unsigned long int)img->length);
          break;
        }
        case BLADERF_IMAGE_TYPE_TX_DC_CAL:
        {
          dc_cal_tbl_free(&dev->cal.dc_tx);
          dev->cal.dc_tx=dc_cal_tbl_load(img->data, (unsigned long int)img->length);
          break;
        }
        default:
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ config.c:58] %s is not an RX DC calibration table.\n", file);
          while((_Bool)0);
      }

  out:
    ;
    bladerf_free_image(img);
  }

}

// log_set_verbosity
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/log.h line 120
void log_set_verbosity(enum anonymous_26 level)
{
  filter_level = level;
}

// log_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/log.h line 105
void log_write(enum anonymous_26 level, const char *format, ...)
{
  if((signed int)level >= (signed int)filter_level)
  {
    void **args = (void **)&format;
    vfprintf(stderr, format, args);
    args = ((void **)NULL);
  }

}

// logger_entry_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../firmware_common/logger_entry.h line 66
static inline void logger_entry_unpack(unsigned int e, unsigned char *file, unsigned short int *line, unsigned short int *data)
{
  *data = (unsigned short int)(e >> 0 & (unsigned int)0xffff);
  *line = (unsigned short int)(e >> 16 & (unsigned int)0x7ff);
  *file = (unsigned char)(e >> 27 & (unsigned int)0x1f);
}

// logger_id_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../firmware_common/logger_id.h line 36
static inline const char * logger_id_string(unsigned char file_id)
{
  switch((signed int)file_id)
  {
    case 0:
      return "<None>";
    case 1:
      return "bladeRF.c";
    case 2:
      return "flash.c";
    case 3:
      return "fpga.c";
    case 4:
      return "gpif.c";
    case 5:
      return "logger.c";
    case 6:
      return "rf.c";
    case 7:
      return "spi_flash_lib.c";
    default:
      return "<Unknown>";
  }
}

// loopback_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1385
static signed int loopback_path(struct bladerf *dev, enum anonymous_3 mode)
{
  signed int status;
  unsigned char loopbben;
  unsigned char lben_lbrf;
  status=dev->fn->lms_read(dev, (unsigned char)0x46, &loopbben);
  if(!(status == 0))
    return status;

  else
  {
    status=dev->fn->lms_read(dev, (unsigned char)0x08, &lben_lbrf);
    if(!(status == 0))
      return status;

    else
    {
      loopbben = loopbben & (unsigned char)~(3 << 2);
      lben_lbrf = lben_lbrf & (unsigned char)~(0xf | 1 << 4 | 1 << 5 | 1 << 6);
      if((signed int)mode == BLADERF_LB_BB_TXLPF_RXVGA2)
      {
        loopbben = loopbben | (unsigned char)(1 << 2);
        lben_lbrf = lben_lbrf | (unsigned char)(1 << 5);
        loopbben = loopbben | (unsigned char)(1 << 2);
        lben_lbrf = lben_lbrf | (unsigned char)(1 << 6);
        loopbben = loopbben | (unsigned char)(2 << 2);
        lben_lbrf = lben_lbrf | (unsigned char)(1 << 5);
        loopbben = loopbben | (unsigned char)(2 << 2);
        lben_lbrf = lben_lbrf | (unsigned char)(1 << 6);
        lben_lbrf = lben_lbrf | (unsigned char)1;
        lben_lbrf = lben_lbrf | (unsigned char)2;
        lben_lbrf = lben_lbrf | (unsigned char)3;
      }

      return -3;
      status=dev->fn->lms_write(dev, (unsigned char)0x46, loopbben);
      if(status == 0)
        status=dev->fn->lms_write(dev, (unsigned char)0x08, lben_lbrf);

      return status;
    }
  }
}

// loopback_rx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1205
static signed int loopback_rx(struct bladerf *dev, enum anonymous_3 mode)
{
  signed int status;
  enum anonymous_14 lpf_mode;
  unsigned char lna;
  unsigned char regval;
  status=lms_lpf_get_mode(dev, (enum anonymous)BLADERF_MODULE_RX, &lpf_mode);
  struct lms_freq f;
  unsigned int return_value_lms_frequency_to_hz_1;
  unsigned int return_value_lms_frequency_to_hz_2;
  if(!(status == 0))
    return status;

  else
  {
    switch((signed int)mode)
    {
      case BLADERF_LB_BB_TXLPF_RXVGA2:

      case BLADERF_LB_BB_TXVGA1_RXVGA2:
      {
        status=lms_rxvga2_enable(dev, (_Bool)1);
        if(!(status == 0))
          return status;

        status=lms_lpf_set_mode(dev, (enum anonymous)BLADERF_MODULE_RX, (enum anonymous_14)BLADERF_LPF_DISABLED);
        if(!(status == 0))
          return status;

        break;
      }
      case BLADERF_LB_BB_TXLPF_RXLPF:

      case BLADERF_LB_BB_TXVGA1_RXLPF:
      {
        status=lms_rxvga1_enable(dev, (_Bool)0);
        if(!(status == 0))
          return status;

        if((signed int)lpf_mode == BLADERF_LPF_DISABLED)
        {
          status=lms_lpf_set_mode(dev, (enum anonymous)BLADERF_MODULE_RX, (enum anonymous_14)BLADERF_LPF_NORMAL);
          if(!(status == 0))
            return status;

        }

        status=lms_rxvga2_enable(dev, (_Bool)1);
        if(!(status == 0))
          return status;

        break;
      }
      case BLADERF_LB_RF_LNA1:

      case BLADERF_LB_RF_LNA2:

      case BLADERF_LB_RF_LNA3:
      {
        lna = (unsigned char)(((signed int)mode - BLADERF_LB_RF_LNA1) + 1);
        /* assertion lna >= 1 && lna <= 3 */
        assert((signed int)lna >= 1 && (signed int)lna <= 3);
        status=enable_lna_power(dev, (_Bool)0);
        if(!(status == 0))
          return status;

        status=lms_rxvga1_enable(dev, (_Bool)1);
        if(!(status == 0))
          return status;

        if((signed int)lpf_mode == BLADERF_LPF_DISABLED)
        {
          status=lms_lpf_set_mode(dev, (enum anonymous)BLADERF_MODULE_RX, (enum anonymous_14)BLADERF_LPF_NORMAL);
          if(!(status == 0))
            return status;

        }

        status=lms_rxvga2_enable(dev, (_Bool)1);
        if(!(status == 0))
          return status;

        status=dev->fn->lms_read(dev, (unsigned char)0x25, &regval);
      }
      case BLADERF_LB_NONE:
      {
        status=lms_rxvga1_enable(dev, (_Bool)1);
        if(!(status == 0))
          return status;

        if((signed int)lpf_mode == BLADERF_LPF_DISABLED)
        {
          status=lms_lpf_set_mode(dev, (enum anonymous)BLADERF_MODULE_RX, (enum anonymous_14)BLADERF_LPF_NORMAL);
          if(!(status == 0))
            return status;

        }

        status=lms_rxvga2_enable(dev, (_Bool)1);
        if(!(status == 0))
          return status;

        status=enable_rf_loopback_switch(dev, (_Bool)0);
        if(!(status == 0))
          return status;

        status=enable_lna_power(dev, (_Bool)1);
        if(!(status == 0))
          return status;

        status=lms_get_frequency(dev, (enum anonymous)BLADERF_MODULE_RX, &f);
        if(!(status == 0))
          return status;

        return_value_lms_frequency_to_hz_1=lms_frequency_to_hz(&f);
        status=lms_set_frequency_link1(dev, (enum anonymous)BLADERF_MODULE_RX, return_value_lms_frequency_to_hz_1);
        if(!(status == 0))
          return status;

        return_value_lms_frequency_to_hz_2=lms_frequency_to_hz(&f);
        status=lms_select_band(dev, (enum anonymous)BLADERF_MODULE_RX, return_value_lms_frequency_to_hz_2 < (unsigned int)1500000000);
        break;
      }
      default:
      {
        /* assertion !"Invalid loopback mode encountered" */
        assert(!((_Bool)"Invalid loopback mode encountered"));
        status = -3;
      }
    }
    return status;
  }
}

// loopback_tx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1156
static signed int loopback_tx(struct bladerf *dev, enum anonymous_3 mode)
{
  signed int status = 0;
  struct lms_freq f;
  unsigned int return_value_lms_frequency_to_hz_1;
  unsigned int return_value_lms_frequency_to_hz_2;
  switch((signed int)mode)
  {
    case BLADERF_LB_BB_TXLPF_RXVGA2:

    case BLADERF_LB_BB_TXLPF_RXLPF:

    case BLADERF_LB_BB_TXVGA1_RXVGA2:

    case BLADERF_LB_BB_TXVGA1_RXLPF:
      break;
    case BLADERF_LB_RF_LNA1:

    case BLADERF_LB_RF_LNA2:

    case BLADERF_LB_RF_LNA3:
    {
      status=lms_select_pa(dev, (enum anonymous_1)PA_AUX);
      break;
    }
    case BLADERF_LB_NONE:
    {
      status=lms_get_frequency(dev, (enum anonymous)BLADERF_MODULE_TX, &f);
      if(!(status == 0))
        return status;

      return_value_lms_frequency_to_hz_1=lms_frequency_to_hz(&f);
      status=lms_set_frequency_link1(dev, (enum anonymous)BLADERF_MODULE_TX, return_value_lms_frequency_to_hz_1);
      if(!(status == 0))
        return status;

      return_value_lms_frequency_to_hz_2=lms_frequency_to_hz(&f);
      status=lms_select_band(dev, (enum anonymous)BLADERF_MODULE_TX, return_value_lms_frequency_to_hz_2 < (unsigned int)1500000000);
      break;
    }
    default:
    {
      /* assertion !"Invalid loopback mode encountered" */
      assert(!((_Bool)"Invalid loopback mode encountered"));
      status = -3;
    }
  }
  return status;
}

// lusb_backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 68
static inline struct bladerf_lusb * lusb_backend(struct bladerf *dev)
{
  struct bladerf_usb *usb;
  _Bool tmp_if_expr_1;
  if(!(dev == ((struct bladerf *)NULL)))
    tmp_if_expr_1 = dev->backend != NULL ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion dev && dev->backend */
  assert(tmp_if_expr_1);
  usb = (struct bladerf_usb *)dev->backend;
  /* assertion usb->driver */
  assert(usb->driver != NULL);
  return (struct bladerf_lusb *)usb->driver;
}

// lusb_bulk_transfer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 820
static signed int lusb_bulk_transfer(void *driver, unsigned char endpoint, void *buffer, unsigned int buffer_len, unsigned int timeout_ms)
{
  signed int status;
  signed int n_transferred;
  struct bladerf_lusb *lusb = (struct bladerf_lusb *)driver;
  status=libusb_bulk_transfer(lusb->handle, endpoint, (unsigned char *)buffer, (signed int)buffer_len, &n_transferred, timeout_ms);
  status=error_conv(status);
  if(status == 0 && !((unsigned int)n_transferred == buffer_len))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:833] Short bulk transfer: requeted=%u, transferred=%u\n", buffer_len, n_transferred);
    while((_Bool)0);
    status = -5;
  }

  return status;
}

// lusb_change_setting
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 577
static signed int lusb_change_setting(void *driver, unsigned char setting)
{
  struct bladerf_lusb *lusb = (struct bladerf_lusb *)driver;
  signed int status;
  status=libusb_set_interface_alt_setting(lusb->handle, 0, (signed int)setting);
  signed int return_value_error_conv_1;
  return_value_error_conv_1=error_conv(status);
  return return_value_error_conv_1;
}

// lusb_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 587
static void lusb_close(void *driver)
{
  signed int status;
  struct bladerf_lusb *lusb = (struct bladerf_lusb *)driver;
  status=libusb_release_interface(lusb->handle, 0);
  if(!(status >= 0))
    do
    {
      const char *return_value_libusb_error_name_1;
      return_value_libusb_error_name_1=libusb_error_name(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:595] Failed to release interface: %s\n", return_value_libusb_error_name_1);
    }
    while((_Bool)0);

  libusb_close(lusb->handle);
  libusb_exit(lusb->context);
  free((void *)lusb);
}

// lusb_close_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 603
static void lusb_close_bootloader(void *driver)
{
  signed int status;
  struct bladerf_lusb *lusb = (struct bladerf_lusb *)driver;
  if(!(lusb == ((struct bladerf_lusb *)NULL)))
  {
    if(!(lusb->handle == ((struct libusb_device_handle *)NULL)))
    {
      status=libusb_release_interface(lusb->handle, 0);
      if(!(status >= 0))
        do
        {
          const char *return_value_libusb_error_name_1;
          return_value_libusb_error_name_1=libusb_error_name(status);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:613] Failed to release interface: %s\n", return_value_libusb_error_name_1);
        }
        while((_Bool)0);

      libusb_close(lusb->handle);
    }

    if(!(lusb->context == ((struct libusb_context *)NULL)))
      libusb_exit(lusb->context);

    free((void *)lusb);
  }

}

// lusb_control_transfer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 793
static signed int lusb_control_transfer(void *driver, enum anonymous_28 target_type, enum anonymous_29 req_type, enum anonymous_30 dir, unsigned char request, unsigned short int wvalue, unsigned short int windex, void *buffer, unsigned int buffer_len, unsigned int timeout_ms)
{
  signed int status;
  struct bladerf_lusb *lusb = (struct bladerf_lusb *)driver;
  unsigned char bm_req_type;
  bm_req_type=bm_request_type(target_type, req_type, dir);
  status=libusb_control_transfer(lusb->handle, bm_req_type, request, wvalue, windex, (unsigned char *)buffer, (unsigned short int)buffer_len, timeout_ms);
  if((unsigned int)status == buffer_len && status >= 0)
    status = 0;

  else
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:814] %s failed: status = %d\n", (const void *)"lusb_control_transfer", status);
    while((_Bool)0);
  signed int return_value_error_conv_1;
  return_value_error_conv_1=error_conv(status);
  return return_value_error_conv_1;
}

// lusb_deinit_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1315
static signed int lusb_deinit_stream(void *driver, struct bladerf_stream *stream)
{
  unsigned long int i;
  struct lusb_stream_data *stream_data = (struct lusb_stream_data *)stream->backend_data;
  i = (unsigned long int)0;
  for( ; !(i >= stream_data->num_transfers); i = i + 1ul)
  {
    libusb_free_transfer(stream_data->transfers[(signed long int)i]);
    stream_data->transfers[(signed long int)i] = (struct libusb_transfer *)(void *)0;
    stream_data->transfer_status[(signed long int)i] = (enum anonymous_37)TRANSFER_UNINITIALIZED;
  }
  free((void *)stream_data->transfers);
  free((void *)stream_data->transfer_status);
  free(stream->backend_data);
  stream->backend_data = (void *)0;
  return 0;
}

// lusb_get_speed
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 712
static signed int lusb_get_speed(void *driver, enum anonymous_7 *device_speed)
{
  signed int speed;
  signed int status = 0;
  struct bladerf_lusb *lusb = (struct bladerf_lusb *)driver;
  speed=libusb_get_device_speed(lusb->dev);
  if(speed == 4)
    *device_speed = (enum anonymous_7)BLADERF_DEVICE_SPEED_SUPER;

  else
    if(speed == 3)
      *device_speed = (enum anonymous_7)BLADERF_DEVICE_SPEED_HIGH;

    else
    {
      *device_speed = (enum anonymous_7)BLADERF_DEVICE_SPEED_UNKNOWN;
      if(speed == 2)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:728] Full speed connection is not supported.\n");
        while((_Bool)0);
        status = -8;
      }

      else
        if(speed == 1)
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:731] Low speed connection is not supported.\n");
          while((_Bool)0);
          status = -8;
        }

        else
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:734] Unknown/unexpected device speed (%d)\n", speed);
          while((_Bool)0);
          status = -1;
        }
    }
  return status;
}

// lusb_get_string_descriptor
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 840
static signed int lusb_get_string_descriptor(void *driver, unsigned char index, void *buffer, unsigned int buffer_len)
{
  signed int status;
  struct bladerf_lusb *lusb = (struct bladerf_lusb *)driver;
  status=libusb_get_string_descriptor_ascii(lusb->handle, index, (unsigned char *)buffer, (signed int)buffer_len);
  if(status >= 1 && !((unsigned int)status >= buffer_len))
    status = 0;

  else
    status = -1;
  return status;
}

// lusb_init_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1107
static signed int lusb_init_stream(void *driver, struct bladerf_stream *stream, unsigned long int num_transfers)
{
  signed int status = 0;
  unsigned long int i;
  struct lusb_stream_data *stream_data;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct lusb_stream_data) /*48ul*/ );
  stream_data = (struct lusb_stream_data *)return_value_malloc_1;
  void *return_value_calloc_3;
  if(stream_data == ((struct lusb_stream_data *)NULL))
    return -4;

  else
  {
    stream->backend_data = (void *)stream_data;
    stream_data->transfers = (struct libusb_transfer **)(void *)0;
    stream_data->transfer_status = (enum anonymous_37 *)(void *)0;
    stream_data->num_transfers = num_transfers;
    stream_data->num_avail = (unsigned long int)0;
    stream_data->i = (unsigned long int)0;
    stream_data->out_of_order_event = (_Bool)0;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(num_transfers * sizeof(struct libusb_transfer *) /*8ul*/ );
    stream_data->transfers = (struct libusb_transfer **)return_value_malloc_2;
    if(stream_data->transfers == ((struct libusb_transfer **)NULL))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:1133] Failed to allocate libusb tranfers\n");
      while((_Bool)0);
      status = -4;
    }

    else
    {
      return_value_calloc_3=calloc(num_transfers, sizeof(enum anonymous_37) /*4ul*/ );
      stream_data->transfer_status = (enum anonymous_37 *)return_value_calloc_3;
      if(stream_data->transfer_status == ((enum anonymous_37 *)NULL))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:1142] Failed to allocated libusb transfer status array\n");
        while((_Bool)0);
        status = -4;
      }

      else
      {
        i = (unsigned long int)0;
        for( ; !(i >= stream_data->num_transfers); i = i + 1ul)
        {
          stream_data->transfers[(signed long int)i]=libusb_alloc_transfer(0);
          if(stream_data->transfers[(signed long int)i] == ((struct libusb_transfer *)NULL))
          {
            while(i >= 1ul)
            {
              i = i - 1ul;
              if(!(i == 0ul))
              {
                libusb_free_transfer(stream_data->transfers[(signed long int)i]);
                stream_data->transfers[(signed long int)i] = (struct libusb_transfer *)(void *)0;
                stream_data->transfer_status[(signed long int)i] = (enum anonymous_37)TRANSFER_UNINITIALIZED;
                stream_data->num_avail = stream_data->num_avail - 1ul;
              }

            }
            status = -4;
            break;
          }

          else
          {
            stream_data->transfer_status[(signed long int)i] = (enum anonymous_37)TRANSFER_AVAIL;
            stream_data->num_avail = stream_data->num_avail + 1ul;
          }
        }
      }
    }

  error:
    ;
    if(!(status == 0))
    {
      free((void *)stream_data->transfer_status);
      free((void *)stream_data->transfers);
      free((void *)stream_data);
      stream->backend_data = (void *)0;
    }

    return status;
  }
}

// lusb_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 519
static signed int lusb_open(void **driver, struct bladerf_devinfo *info_in, struct bladerf_devinfo *info_out)
{
  signed int status;
  struct bladerf_lusb *lusb = (struct bladerf_lusb *)(void *)0;
  struct libusb_context *context;
  status=libusb_init(&context);
  if(!(status == 0))
  {
    do
    {
      const char *return_value_libusb_error_name_1;
      return_value_libusb_error_name_1=libusb_error_name(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:531] Could not initialize libusb: %s\n", return_value_libusb_error_name_1);
    }
    while((_Bool)0);
    signed int return_value_error_conv_2;
    return_value_error_conv_2=error_conv(status);
    return return_value_error_conv_2;
  }

  char buf[64l];
  get_libusb_version(buf, sizeof(char [64l]) /*64ul*/ );
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:541] Using libusb version: %s\n", (const void *)buf);
  while((_Bool)0);
  status=find_and_open_device(context, info_in, &lusb, info_out);
  if(!(status == 0))
  {
    libusb_exit(context);
    if(status == -7)
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:550] No devices available on the libusb backend.\n");
      while((_Bool)0);

    else
      do
      {
        const char *return_value_bladerf_strerror_3;
        return_value_bladerf_strerror_3=bladerf_strerror(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:553] Failed to open bladeRF on libusb backend: %s\n", return_value_bladerf_strerror_3);
      }
      while((_Bool)0);
  }

  else
  {
    /* assertion lusb != ((void *)0) */
    assert(lusb != (struct bladerf_lusb *)(void *)0);
    if(!(bladerf_usb_reset_device_on_open == (_Bool)0))
      status=reset_and_reopen(context, &lusb, info_out);

    if(status == 0)
      *driver = (void *)lusb;

  }
  return status;
}

// lusb_open_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 639
static signed int lusb_open_bootloader(void **driver, unsigned char bus, unsigned char addr)
{
  signed int status;
  struct libusb_device **dev_list = (struct libusb_device **)(void *)0;
  signed long int dev_list_size;
  signed long int i;
  struct bladerf_lusb *lusb;
  *driver = (void *)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct bladerf_lusb) /*24ul*/ );
  lusb = (struct bladerf_lusb *)return_value_calloc_1;
  _Bool return_value_bus_matches_9;
  _Bool return_value_addr_matches_8;
  if(lusb == ((struct bladerf_lusb *)NULL))
    return -4;

  else
  {
    status=libusb_init(&lusb->context);
    if(!(status == 0))
      do
      {
        const char *return_value_libusb_error_name_2;
        return_value_libusb_error_name_2=libusb_error_name(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:656] Failed to initialize libusb context: %s\n", return_value_libusb_error_name_2);
      }
      while((_Bool)0);

    else
    {
      dev_list_size=libusb_get_device_list(lusb->context, &dev_list);
      if(!(dev_list_size >= 0l))
      {
        do
        {
          const char *return_value_libusb_error_name_3;
          return_value_libusb_error_name_3=libusb_error_name(status);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:662] Failed to get device list: %s\n", return_value_libusb_error_name_3);
        }
        while((_Bool)0);
        status = (signed int)dev_list_size;
      }

      else
      {
        i = (signed long int)0;
        for( ; !(i >= dev_list_size); i = i + 1l)
        {
          _Bool return_value_device_is_fx3_bootloader_10;
          return_value_device_is_fx3_bootloader_10=device_is_fx3_bootloader(dev_list[i]);
          if(!(return_value_device_is_fx3_bootloader_10 == (_Bool)0))
          {
            return_value_bus_matches_9=bus_matches(bus, dev_list[i]);
            if(!(return_value_bus_matches_9 == (_Bool)0))
            {
              return_value_addr_matches_8=addr_matches(addr, dev_list[i]);
              if(!(return_value_addr_matches_8 == (_Bool)0))
              {
                status=libusb_open(dev_list[i], &lusb->handle);
                if(!(status == 0))
                {
                  do
                  {
                    const char *return_value_libusb_error_name_4;
                    return_value_libusb_error_name_4=libusb_error_name(status);
                    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:676] Failed to open device: %s\n", return_value_libusb_error_name_4);
                  }
                  while((_Bool)0);
                  break;
                }

                else
                {
                  status=libusb_claim_interface(lusb->handle, 0);
                  if(!(status >= 0))
                  {
                    do
                    {
                      const char *return_value_libusb_error_name_5;
                      return_value_libusb_error_name_5=libusb_error_name(status);
                      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:682] Failed to claim interface: %s\n", return_value_libusb_error_name_5);
                    }
                    while((_Bool)0);
                    break;
                  }

                  else
                  {
                    do
                    {
                      unsigned char return_value_libusb_get_bus_number_6;
                      return_value_libusb_get_bus_number_6=libusb_get_bus_number(dev_list[i]);
                      unsigned char return_value_libusb_get_device_address_7;
                      return_value_libusb_get_device_address_7=libusb_get_device_address(dev_list[i]);
                      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:688] Opened bootloader at %u:%u\n", return_value_libusb_get_bus_number_6, return_value_libusb_get_device_address_7);
                    }
                    while((_Bool)0);
                    *driver = (void *)lusb;
                  }
                  break;
                }
              }

            }

          }

        }
      }
    }

  error:
    ;
    if(!(dev_list == ((struct libusb_device **)NULL)))
      libusb_free_device_list(dev_list, 1);

    if(!(status == 0))
    {
      status=error_conv(status);
      lusb_close_bootloader((void *)lusb);
    }

    else
      if(*driver == NULL)
      {
        status = -7;
        lusb_close_bootloader((void *)lusb);
      }

    return status;
  }
}

// lusb_probe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 261
static signed int lusb_probe(enum anonymous_15 probe_target, struct bladerf_devinfo_list *info_list)
{
  signed int status;
  signed int i;
  signed int n;
  signed long int count;
  struct libusb_device **list;
  struct bladerf_devinfo info;
  _Bool printed_access_warning = (_Bool)0;
  struct libusb_context *context;
  status=libusb_init(&context);
  signed int tmp_post_3;
  if(!(status == 0))
    do
    {
      const char *return_value_libusb_error_name_1;
      return_value_libusb_error_name_1=libusb_error_name(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:276] Could not initialize libusb: %s\n", return_value_libusb_error_name_1);
    }
    while((_Bool)0);

  else
  {
    count=libusb_get_device_list(context, &list);
    i = 0;
    n = 0;
    for( ; status == 0 && !((signed long int)i >= count); i = i + 1)
    {
      _Bool return_value_device_is_probe_target_5;
      return_value_device_is_probe_target_5=device_is_probe_target(probe_target, list[(signed long int)i]);
      if(!(return_value_device_is_probe_target_5 == (_Bool)0))
      {
        status=get_devinfo(list[(signed long int)i], &info);
        if(!(status == 0))
        {
          do
          {
            const char *return_value_libusb_error_name_2;
            return_value_libusb_error_name_2=libusb_error_name(status);
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:292] Could not open device: %s\n", return_value_libusb_error_name_2);
          }
          while((_Bool)0);
          if(printed_access_warning == (_Bool)0 && status == -3)
          {
            printed_access_warning = (_Bool)1;
            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ libusb.c:297] Found a bladeRF via VID/PID, but could not open it due to insufficient permissions.\n");
            while((_Bool)0);
          }

          status = 0;
        }

        else
        {
          tmp_post_3 = n;
          n = n + 1;
          info.instance = (unsigned int)tmp_post_3;
          status=bladerf_devinfo_list_add(info_list, &info);
          if(!(status == 0))
            do
            {
              const char *return_value_bladerf_strerror_4;
              return_value_bladerf_strerror_4=bladerf_strerror(status);
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:307] Could not add device to list: %s\n", return_value_bladerf_strerror_4);
            }
            while((_Bool)0);

          else
            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:310] Added instance %d to device list\n", info.instance);
            while((_Bool)0);
        }
      }

    }
    libusb_free_device_list(list, 1);
    libusb_exit(context);
  }

lusb_probe_done:
  ;
  return status;
}

// lusb_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1185
static signed int lusb_stream(void *driver, struct bladerf_stream *stream, enum anonymous module)
{
  unsigned long int i;
  signed int status = 0;
  void *buffer;
  struct bladerf_metadata metadata;
  struct bladerf *dev = stream->dev;
  struct bladerf_lusb *lusb = (struct bladerf_lusb *)driver;
  struct lusb_stream_data *stream_data = (struct lusb_stream_data *)stream->backend_data;
  struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)(15 * 1000) };
  memset((void *)&metadata, 0, sizeof(struct bladerf_metadata) /*56ul*/ );
  pthread_mutex_lock(&stream->lock);
  i = (unsigned long int)0;
  for( ; !(i >= stream_data->num_transfers); i = i + 1ul)
  {
    if((signed int)module == BLADERF_MODULE_TX)
    {
      buffer=stream->cb(dev, stream, &metadata, (void *)0, stream->samples_per_buffer, stream->user_data);
      if(buffer == NULL)
      {
        if(!(stream_data->num_avail == stream_data->num_transfers))
          stream->state = (enum anonymous_20)STREAM_SHUTTING_DOWN;

        else
          stream->state = (enum anonymous_20)STREAM_DONE;
        break;
      }

    }

    else
      buffer = stream->buffers[(signed long int)i];
    if(!(buffer == (void *)-1))
    {
      status=submit_transfer(stream, buffer);
      if(!(status >= 0))
      {
        stream->error_code = status;
        cancel_all_transfers(stream);
      }

    }

  }
  pthread_mutex_unlock(&stream->lock);
  while(!((signed int)stream->state == STREAM_DONE))
  {
    status=libusb_handle_events_timeout(lusb->context, &tv);
    if(!(status == -10) && !(status >= 0))
    {
      do
      {
        const char *return_value_libusb_error_name_1;
        return_value_libusb_error_name_1=libusb_error_name(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ libusb.c:1251] unexpected value from events processing: %d: %s\n", status, return_value_libusb_error_name_1);
      }
      while((_Bool)0);
      status=error_conv(status);
    }

  }
  return status;
}

// lusb_stream_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 899
static void lusb_stream_cb(struct libusb_transfer *transfer)
{
  struct bladerf_stream *stream = (struct bladerf_stream *)transfer->user_data;
  void *next_buffer = (void *)0;
  struct bladerf_metadata metadata;
  struct lusb_stream_data *stream_data = (struct lusb_stream_data *)stream->backend_data;
  unsigned long int transfer_i;
  memset((void *)&metadata, 0, sizeof(struct bladerf_metadata) /*56ul*/ );
  pthread_mutex_lock(&stream->lock);
  transfer_i=transfer_idx(stream_data, transfer);
  _Bool tmp_if_expr_1;
  if((signed int)stream_data->transfer_status[(signed long int)transfer_i] == TRANSFER_IN_FLIGHT)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)stream_data->transfer_status[(signed long int)transfer_i] == TRANSFER_CANCEL_PENDING ? (_Bool)1 : (_Bool)0;
  /* assertion stream_data->transfer_status[transfer_i] == TRANSFER_IN_FLIGHT || stream_data->transfer_status[transfer_i] == TRANSFER_CANCEL_PENDING */
  assert(tmp_if_expr_1);
  if(transfer_i >= stream_data->num_transfers)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:917] Unable to find transfer");
    while((_Bool)0);
    stream->state = (enum anonymous_20)STREAM_SHUTTING_DOWN;
  }

  else
  {
    stream_data->transfer_status[(signed long int)transfer_i] = (enum anonymous_37)TRANSFER_AVAIL;
    stream_data->num_avail = stream_data->num_avail + 1ul;
    pthread_cond_signal(&stream->can_submit_buffer);
  }
  if(!((signed int)transfer->status == LIBUSB_TRANSFER_COMPLETED))
  {
    stream->state = (enum anonymous_20)STREAM_SHUTTING_DOWN;
    switch((signed int)transfer->status)
    {
      case LIBUSB_TRANSFER_CANCELLED:
        break;
      case LIBUSB_TRANSFER_STALL:
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:937] Hit stall for buffer %p\n", transfer->buffer);
        while((_Bool)0);
        stream->error_code = -5;
        break;
      }
      case LIBUSB_TRANSFER_ERROR:
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:943] Got transfer error for buffer %p\n", transfer->buffer);
        while((_Bool)0);
        stream->error_code = -5;
        break;
      }
      case LIBUSB_TRANSFER_OVERFLOW:
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:950] Got transfer over for buffer %p, transfer \"actual_length\" = %d\n", transfer->buffer, transfer->actual_length);
        while((_Bool)0);
        stream->error_code = -5;
        break;
      }
      case LIBUSB_TRANSFER_TIMED_OUT:
      {
        stream->error_code = -6;
        break;
      }
      case LIBUSB_TRANSFER_NO_DEVICE:
      {
        stream->error_code = -7;
        break;
      }
      default:
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:963] Unexpected transfer status: %d\n", transfer->status);
        while((_Bool)0);
    }
  }

  if((signed int)stream->state == STREAM_RUNNING)
  {
    if(!(transfer->length == transfer->actual_length))
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ libusb.c:973] Received short transfer\n");
      while((_Bool)0);

    unsigned long int return_value_bytes_to_sc16q11_2;
    return_value_bytes_to_sc16q11_2=bytes_to_sc16q11((unsigned long int)transfer->actual_length);
    next_buffer=stream->cb(stream->dev, stream, &metadata, (void *)transfer->buffer, return_value_bytes_to_sc16q11_2, stream->user_data);
    if(next_buffer == NULL)
      stream->state = (enum anonymous_20)STREAM_SHUTTING_DOWN;

    else
      if(!(next_buffer == (void *)-1))
      {
        signed int status;
        status=submit_transfer(stream, next_buffer);
        if(!(status == 0))
          stream->state = (enum anonymous_20)STREAM_SHUTTING_DOWN;

      }

  }

  if((signed int)stream->state == STREAM_SHUTTING_DOWN)
  {
    if(stream_data->num_avail == stream_data->num_transfers)
      stream->state = (enum anonymous_20)STREAM_DONE;

    else
      cancel_all_transfers(stream);
  }

  pthread_mutex_unlock(&stream->lock);
}

// lusb_submit_stream_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1259
signed int lusb_submit_stream_buffer(void *driver, struct bladerf_stream *stream, void *buffer, unsigned int timeout_ms, _Bool nonblock)
{
  signed int status = 0;
  struct lusb_stream_data *stream_data = (struct lusb_stream_data *)stream->backend_data;
  struct timespec timeout_abs;
  if(buffer == NULL)
  {
    if(stream_data->num_avail == stream_data->num_transfers)
      stream->state = (enum anonymous_20)STREAM_DONE;

    else
      stream->state = (enum anonymous_20)STREAM_SHUTTING_DOWN;
    return 0;
  }

  else
  {
    if(stream_data->num_avail == 0ul)
    {
      if(!(nonblock == (_Bool)0))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:1280] Non-blocking buffer submission requested, but no transfers are currently available.");
        while((_Bool)0);
        return -18;
      }

      if(!(timeout_ms == 0u))
      {
        status=populate_abs_timeout(&timeout_abs, timeout_ms);
        if(!(status == 0))
          return -1;

        while(stream_data->num_avail == 0ul)
        {
          if(!(status == 0))
            break;

          status=pthread_cond_timedwait(&stream->can_submit_buffer, &stream->lock, &timeout_abs);
        }
      }

      else
        while(stream_data->num_avail == 0ul)
        {
          if(!(status == 0))
            break;

          status=pthread_cond_wait(&stream->can_submit_buffer, &stream->lock);
        }
    }

    if(status == 110)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:1306] %s: Timed out waiting for a transfer to become available.\n", (const void *)"lusb_submit_stream_buffer");
      while((_Bool)0);
      return -6;
    }

    else
      if(!(status == 0))
        return -1;

      else
      {
        signed int return_value_submit_transfer_1;
        return_value_submit_transfer_1=submit_transfer(stream, buffer);
        return return_value_submit_transfer_1;
      }
  }
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/doc/examples/open_via_serial.c line 120
signed int main(signed int argc, char **argv)
{
  signed int status = 0;
  struct bladerf *dev;
  if(!(argc == 2))
  {
    fprintf(stderr, "Usage: %s <serial #>\n", argv[(signed long int)0]);
    return 1;
  }

  else
  {
    dev=open_bladerf_from_serial(argv[(signed long int)1]);
    if(!(dev == ((struct bladerf *)NULL)))
    {
      printf("Opened device successfully!\n");
      status=print_device_state(dev);
    }

    if(!(status == 0))
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      fprintf(stderr, "Error: %s\n", return_value_bladerf_strerror_1);
    }

    if(!(dev == ((struct bladerf *)NULL)))
      bladerf_close(dev);

    return status;
  }
}

// make_cal_region
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 449
static signed int make_cal_region(enum anonymous_5 size, unsigned short int vctcxo_trim, unsigned char *buf, unsigned long int len)
{
  signed int rv;
  const char *fpga_size;
  char dac[7l] = { (char)0, 0, 0, 0, 0, 0, 0 };
  static const char fpga_size_115[4l] = { '1', '1', '5', 0 };
  static const char fpga_size_40[3l] = { '4', '0', 0 };
  if((signed int)size == BLADERF_FPGA_40KLE)
    fpga_size = fpga_size_40;

  else
    if((signed int)size == BLADERF_FPGA_115KLE)
      fpga_size = fpga_size_115;

    else
    {
      /* assertion 0 */
      assert(0 != 0);
      return -3;
    }
  memset((void *)buf, 0xff, len);
  /* assertion len < 0x7fffffff */
  assert(len < (unsigned long int)0x7fffffff);
  rv=add_field((char *)buf, (signed int)len, "B", fpga_size);
  if(!(rv >= 0))
    return rv;

  else
  {
    sprintf(dac, "%u", vctcxo_trim);
    rv=add_field((char *)buf, (signed int)len, "DAC", dac);
    if(!(rv >= 0))
      return rv;

    else
      return 0;
  }
}

// metadata_get_flags
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/metadata.h line 103
static inline unsigned int metadata_get_flags(const unsigned char *header)
{
  unsigned int ret;
  /* assertion sizeof(ret) == (sizeof(uint32_t)) */
  assert(sizeof(unsigned int) /*4ul*/  == sizeof(unsigned int) /*4ul*/ );
  memcpy((void *)&ret, (const void *)&header[(signed long int)(sizeof(unsigned int) /*4ul*/  + sizeof(unsigned long int) /*8ul*/ )], sizeof(unsigned int) /*4ul*/ );
  return ret;
}

// metadata_get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/metadata.h line 92
static inline unsigned long int metadata_get_timestamp(const unsigned char *header)
{
  unsigned long int ret;
  /* assertion sizeof(ret) == (sizeof(uint64_t)) */
  assert(sizeof(unsigned long int) /*8ul*/  == sizeof(unsigned long int) /*8ul*/ );
  memcpy((void *)&ret, (const void *)&header[(signed long int)sizeof(unsigned int) /*4ul*/ ], sizeof(unsigned long int) /*8ul*/ );
  ret = ret;
  return ret;
}

// metadata_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/metadata.h line 111
static inline void metadata_set(unsigned char *header, unsigned long int timestamp, unsigned int flags)
{
  timestamp = timestamp;
  flags = flags;
  /* assertion sizeof(timestamp) == (sizeof(uint64_t)) */
  assert(sizeof(unsigned long int) /*8ul*/  == sizeof(unsigned long int) /*8ul*/ );
  /* assertion sizeof(flags) == (sizeof(uint32_t)) */
  assert(sizeof(unsigned int) /*4ul*/  == sizeof(unsigned int) /*4ul*/ );
  memset((void *)&header[(signed long int)0], 0, sizeof(unsigned int) /*4ul*/ );
  memcpy((void *)&header[(signed long int)sizeof(unsigned int) /*4ul*/ ], (const void *)&timestamp, sizeof(unsigned long int) /*8ul*/ );
  memcpy((void *)&header[(signed long int)(sizeof(unsigned int) /*4ul*/  + sizeof(unsigned long int) /*8ul*/ )], (const void *)&flags, sizeof(unsigned int) /*4ul*/ );
}

// min_sz
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 15
static inline unsigned long int min_sz(unsigned long int x, unsigned long int y)
{
  return x < y ? x : y;
}

// module2str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/conversions.h line 225
const char * module2str(enum anonymous m)
{
  switch((signed int)m)
  {
    case BLADERF_MODULE_RX:
      return "RX";
    case BLADERF_MODULE_TX:
      return "TX";
    default:
      return "Unknown";
  }
}

// msg_per_buf
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 42
static inline unsigned int msg_per_buf(struct bladerf *dev, unsigned long int buf_size, unsigned long int bytes_per_sample)
{
  unsigned long int n = buf_size / (dev->msg_size / bytes_per_sample);
  /* assertion n <= (0x7fffffff * 2U + 1U) */
  assert(n <= (unsigned long int)((unsigned int)0x7fffffff * 2U + 1U));
  return (unsigned int)n;
}

// next_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.c line 155
static signed int next_arg(char **saveptr, char **arg, char **value)
{
  char *saveptr_local;
  char *token;
  token=strtok_r((char *)(void *)0, " \t\r\n\v\f", saveptr);
  if(token == ((char *)NULL))
    return 0;

  else
  {
    *arg=strtok_r(token, "=", &saveptr_local);
    if(*arg == ((char *)NULL))
    {
      *value = (char *)(void *)0;
      return -3;
    }

    else
    {
      *value=strtok_r((char *)(void *)0, "", &saveptr_local);
      if(*value == ((char *)NULL))
        return -3;

      else
        return 1;
    }
  }
}

// nios_32x32_masked_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 241
static signed int nios_32x32_masked_read(struct bladerf *dev, unsigned char id, unsigned int mask, unsigned int *val)
{
  signed int status;
  _Bool success;
  unsigned char buf[16l];
  nios_pkt_32x32_pack(buf, id, (_Bool)0, mask, (unsigned int)0);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_32x32_resp_unpack(buf, (unsigned char *)(void *)0, (_Bool *)(void *)0, (unsigned int *)(void *)0, val, &success);
    if(!(success == (_Bool)0))
      return 0;

    else
    {
      *val = (unsigned int)0;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:262] %s: response packet reported failure.\n", (const void *)"nios_32x32_masked_read");
      while((_Bool)0);
      return -16;
    }
  }
}

// nios_32x32_masked_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 267
static signed int nios_32x32_masked_write(struct bladerf *dev, unsigned char id, unsigned int mask, unsigned int val)
{
  signed int status;
  _Bool success;
  unsigned char buf[16l];
  nios_pkt_32x32_pack(buf, id, (_Bool)1, mask, val);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_32x32_resp_unpack(buf, (unsigned char *)(void *)0, (_Bool *)(void *)0, (unsigned int *)(void *)0, (unsigned int *)(void *)0, &success);
    if(!(success == (_Bool)0))
      return 0;

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:287] %s: response packet reported failure.\n", (const void *)"nios_32x32_masked_write");
      while((_Bool)0);
      return -16;
    }
  }
}

// nios_8x16_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 141
signed int nios_8x16_read(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned short int *data)
{
  signed int status;
  unsigned char buf[16l];
  _Bool success;
  unsigned short int tmp;
  nios_pkt_8x16_pack(buf, id, (_Bool)0, addr, (unsigned short int)0);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_8x16_resp_unpack(buf, (unsigned char *)(void *)0, (_Bool *)(void *)0, (unsigned char *)(void *)0, &tmp, &success);
    if(!(success == (_Bool)0))
    {
      *data = tmp;
      return 0;
    }

    else
    {
      *data = (unsigned short int)0;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:163] %s: response packet reported failure.\n", (const void *)"nios_8x16_read");
      while((_Bool)0);
      return -16;
    }
  }
}

// nios_8x16_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 168
signed int nios_8x16_write(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned short int data)
{
  signed int status;
  unsigned char buf[16l];
  _Bool success;
  nios_pkt_8x16_pack(buf, id, (_Bool)1, addr, data);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_8x16_resp_unpack(buf, (unsigned char *)(void *)0, (_Bool *)(void *)0, (unsigned char *)(void *)0, (unsigned short int *)(void *)0, &success);
    if(!(success == (_Bool)0))
      return 0;

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:187] %s: response packet reported failure.\n", (const void *)"nios_8x16_write");
      while((_Bool)0);
      return -16;
    }
  }
}

// nios_8x32_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 192
signed int nios_8x32_read(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned int *data)
{
  signed int status;
  unsigned char buf[16l];
  _Bool success;
  nios_pkt_8x32_pack(buf, id, (_Bool)0, (unsigned char)0, (unsigned int)0);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_8x32_resp_unpack(buf, (unsigned char *)(void *)0, (_Bool *)(void *)0, (unsigned char *)(void *)0, data, &success);
    if(!(success == (_Bool)0))
      return 0;

    else
    {
      *data = (unsigned int)0;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:212] %s: response packet reported failure.\n", (const void *)"nios_8x32_read");
      while((_Bool)0);
      return -16;
    }
  }
}

// nios_8x32_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 217
signed int nios_8x32_write(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned int data)
{
  signed int status;
  unsigned char buf[16l];
  _Bool success;
  nios_pkt_8x32_pack(buf, id, (_Bool)1, addr, data);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_8x32_resp_unpack(buf, (unsigned char *)(void *)0, (_Bool *)(void *)0, (unsigned char *)(void *)0, (unsigned int *)(void *)0, &success);
    if(!(success == (_Bool)0))
      return 0;

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:236] %s: response packet reported failure.\n", (const void *)"nios_8x32_write");
      while((_Bool)0);
      return -16;
    }
  }
}

// nios_8x8_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 94
signed int nios_8x8_read(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned char *data)
{
  signed int status;
  unsigned char buf[16l];
  _Bool success;
  nios_pkt_8x8_pack(buf, id, (_Bool)0, addr, (unsigned char)0);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_8x8_resp_unpack(buf, (unsigned char *)(void *)0, (_Bool *)(void *)0, (unsigned char *)(void *)0, data, &success);
    if(!(success == (_Bool)0))
      return 0;

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:112] %s: response packet reported failure.\n", (const void *)"nios_8x8_read");
      while((_Bool)0);
      *data = (unsigned char)0;
      return -16;
    }
  }
}

// nios_8x8_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 118
signed int nios_8x8_write(struct bladerf *dev, unsigned char id, unsigned char addr, unsigned char data)
{
  signed int status;
  unsigned char buf[16l];
  _Bool success;
  nios_pkt_8x8_pack(buf, id, (_Bool)1, addr, data);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_8x8_resp_unpack(buf, (unsigned char *)(void *)0, (_Bool *)(void *)0, (unsigned char *)(void *)0, (unsigned char *)(void *)0, &success);
    if(!(success == (_Bool)0))
      return 0;

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:136] %s: response packet reported failure.\n", (const void *)"nios_8x8_write");
      while((_Bool)0);
      return -16;
    }
  }
}

// nios_access
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 61
static signed int nios_access(struct bladerf *dev, unsigned char *buf)
{
  signed int status;
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend(dev, &driver);

__CPROVER_DUMP_L1:
  ;
  status=usb->fn->bulk_transfer(driver, (unsigned char)0x02, (void *)buf, (unsigned int)16, (unsigned int)250);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:75] Failed to send NIOS II request: %s\n", return_value_bladerf_strerror_1);
    return status;
  }

  else
  {
    status=usb->fn->bulk_transfer(driver, (unsigned char)0x82, (void *)buf, (unsigned int)16, (unsigned int)250);
    if(!(status == 0))
    {
      const char *return_value_bladerf_strerror_2;
      return_value_bladerf_strerror_2=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:86] Failed to receive NIOS II response: %s\n", return_value_bladerf_strerror_2);
    }

    return status;
  }
}

// nios_access_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 70
static signed int nios_access_link1(struct bladerf *dev_link1, unsigned char peripheral, enum anonymous_30 dir, struct uart_cmd *cmd, unsigned long int len)
{
  void *driver_link1;
  struct bladerf_usb *usb_link1;
  usb_link1=usb_backend_link1(dev_link1, &driver_link1);
  signed int status_link1;
  unsigned long int i;
  unsigned char buf[16l] = { (unsigned char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  const unsigned char pkt_mode_dir = (const unsigned char)((signed int)dir == USB_DIR_HOST_TO_DEVICE ? 1 << 6 : 2 << 6);
  /* assertion len <= ((sizeof(buf) - 2) / 2) */
  assert(len <= (sizeof(unsigned char [16l]) /*16ul*/  - (unsigned long int)2) / (unsigned long int)2);
  buf[(signed long int)0] = (unsigned char)78;
  buf[(signed long int)1] = (unsigned char)((signed int)pkt_mode_dir | (signed int)peripheral | (signed int)(unsigned char)len);
  i = (unsigned long int)0;
  for( ; !(i >= len); i = i + 1ul)
  {
    buf[(signed long int)(i * (unsigned long int)2 + (unsigned long int)2)] = (cmd + (signed long int)i)->addr;
    buf[(signed long int)(i * (unsigned long int)2 + (unsigned long int)3)] = (cmd + (signed long int)i)->data;
  }

__CPROVER_DUMP_L2:
  ;
  status_link1=usb_link1->fn->bulk_transfer(driver_link1, (unsigned char)0x02, (void *)buf, (unsigned int)sizeof(unsigned char [16l]) /*16ul*/ , (unsigned int)250);
  if(!(status_link1 == 0))
  {
    const char *return_value_bladerf_strerror_1_link1;
    return_value_bladerf_strerror_1_link1=bladerf_strerror(status_link1);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_legacy_access.c:103] Failed to submit NIOS II request: %s\n", return_value_bladerf_strerror_1_link1);
    return status_link1;
  }

  else
  {
    status_link1=usb_link1->fn->bulk_transfer(driver_link1, (unsigned char)0x82, (void *)buf, (unsigned int)sizeof(unsigned char [16l]) /*16ul*/ , (unsigned int)250);
    if(status_link1 == 0 && (signed int)dir == 128)
    {
      i = (unsigned long int)0;
      if(!(i >= len))
      {
        (cmd + (signed long int)i)->data = buf[(signed long int)(i * (unsigned long int)2 + (unsigned long int)3)];
        i = i + 1ul;
      }

    }

    if(!(status_link1 == 0))
    {
      const char *return_value_bladerf_strerror_2_link1;
      return_value_bladerf_strerror_2_link1=bladerf_strerror(status_link1);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_legacy_access.c:123] Failed to receive NIOS II response: %s\n", return_value_bladerf_strerror_2_link1);
    }

    return status_link1;
  }
}

// nios_config_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 293
signed int nios_config_read(struct bladerf *dev, unsigned int *val)
{
  signed int status;
  status=nios_8x32_read(dev, (unsigned char)0x01, (unsigned char)0, val);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:298] %s: Read 0x%08x\n", (const void *)"nios_config_read", *val);
    while((_Bool)0);

  return status;
}

// nios_config_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 304
signed int nios_config_write(struct bladerf *dev, unsigned int val)
{
  signed int status;
  status=nios_8x32_write(dev, (unsigned char)0x01, (unsigned char)0, val);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:309] %s: Wrote 0x%08x\n", (const void *)"nios_config_write", val);
    while((_Bool)0);

  return status;
}

// nios_expansion_gpio_dir_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 685
signed int nios_expansion_gpio_dir_read(struct bladerf *dev, unsigned int *val)
{
  signed int status;
  status=nios_32x32_masked_read(dev, (unsigned char)0x01, 0xffffffff, val);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:691] %s: Read 0x%08x\n", (const void *)"nios_expansion_gpio_dir_read", *val);
    while((_Bool)0);

  return status;
}

// nios_expansion_gpio_dir_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 697
signed int nios_expansion_gpio_dir_write(struct bladerf *dev, unsigned int mask, unsigned int val)
{
  signed int status;
  status=nios_32x32_masked_write(dev, (unsigned char)0x01, mask, val);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:705] %s: Wrote 0x%08x (with mask 0x%08x)\n", (const void *)"nios_expansion_gpio_dir_write", val, mask);
    while((_Bool)0);

  return status;
}

// nios_expansion_gpio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 660
signed int nios_expansion_gpio_read(struct bladerf *dev, unsigned int *val)
{
  signed int status;
  status=nios_32x32_masked_read(dev, (unsigned char)0x00, 0xffffffff, val);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:666] %s: Read 0x%08x\n", (const void *)"nios_expansion_gpio_read", *val);
    while((_Bool)0);

  return status;
}

// nios_expansion_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 672
signed int nios_expansion_gpio_write(struct bladerf *dev, unsigned int mask, unsigned int val)
{
  signed int status;
  status=nios_32x32_masked_write(dev, (unsigned char)0x00, mask, val);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:679] %s: Wrote 0x%08x (with mask 0x%08x)\n", (const void *)"nios_expansion_gpio_write", val, mask);
    while((_Bool)0);

  return status;
}

// nios_get_fpga_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 315
signed int nios_get_fpga_version(struct bladerf *dev, struct bladerf_version *ver)
{
  unsigned int regval;
  signed int status;
  status=nios_8x32_read(dev, (unsigned char)0x00, (unsigned char)0, &regval);
  if(status == 0)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:322] %s: Read FPGA version word: 0x%08x\n", (const void *)"nios_get_fpga_version", regval);
    while((_Bool)0);
    ver->major = (unsigned short int)(regval >> 24 & (unsigned int)0xff);
    ver->minor = (unsigned short int)(regval >> 16 & (unsigned int)0xff);
    ver->patch = (unsigned short int)(regval & (unsigned int)0xffff);
    snprintf((char *)ver->describe, (unsigned long int)32, "%d.%d.%d", ver->major, ver->minor, ver->patch);
    return 0;
  }

  else
    return status;
}

// nios_get_iq_gain_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 526
signed int nios_get_iq_gain_correction(struct bladerf *dev, enum anonymous module, signed short int *value)
{
  signed int status = -3;
  unsigned short int tmp = (unsigned short int)0;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      status=nios_8x16_read(dev, (unsigned char)0x01, (unsigned char)0x00, &tmp);
      break;
    }
    case BLADERF_MODULE_TX:
    {
      status=nios_8x16_read(dev, (unsigned char)0x01, (unsigned char)0x02, &tmp);
      break;
    }
    default:
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:544] Invalid module: %d\n", module);
      while((_Bool)0);
  }
  *value = (signed short int)tmp;
  if(status == 0)
    do
    {
      const char *return_value_module2str_1;
      return_value_module2str_1=module2str(module);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:551] %s: Read %s %d\n", (const void *)"nios_get_iq_gain_correction", return_value_module2str_1, *value);
    }
    while((_Bool)0);

  return status;
}

// nios_get_iq_phase_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 557
signed int nios_get_iq_phase_correction(struct bladerf *dev, enum anonymous module, signed short int *value)
{
  signed int status = -3;
  unsigned short int tmp = (unsigned short int)0;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      status=nios_8x16_read(dev, (unsigned char)0x01, (unsigned char)0x01, &tmp);
      break;
    }
    case BLADERF_MODULE_TX:
    {
      status=nios_8x16_read(dev, (unsigned char)0x01, (unsigned char)0x03, &tmp);
      break;
    }
    default:
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:575] Invalid module: %d\n", module);
      while((_Bool)0);
  }
  *value = (signed short int)tmp;
  if(status == 0)
    do
    {
      const char *return_value_module2str_1;
      return_value_module2str_1=module2str(module);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:582] %s: Read %s %d\n", (const void *)"nios_get_iq_phase_correction", return_value_module2str_1, *value);
    }
    while((_Bool)0);

  return status;
}

// nios_get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 337
signed int nios_get_timestamp(struct bladerf *dev, enum anonymous module, unsigned long int *timestamp)
{
  signed int status;
  unsigned char buf[16l];
  unsigned char addr;
  _Bool success;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      addr = (unsigned char)0x00;
      break;
    }
    case BLADERF_MODULE_TX:
    {
      addr = (unsigned char)0x01;
      break;
    }
    default:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:355] Invalid module: %d\n", module);
      while((_Bool)0);
      return -3;
    }
  }
  nios_pkt_8x64_pack(buf, (unsigned char)0x00, (_Bool)0, addr, (unsigned long int)0);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_8x64_resp_unpack(buf, (unsigned char *)(void *)0, (_Bool *)(void *)0, (unsigned char *)(void *)0, timestamp, &success);
    if(!(success == (_Bool)0))
    {
      do
      {
        const char *return_value_module2str_1;
        return_value_module2str_1=module2str(module);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:370] %s: Read %s timstamp: 0x%lu\n", (const void *)"nios_get_timestamp", return_value_module2str_1, timestamp);
      }
      while((_Bool)0);
      return 0;
    }

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:373] %s: response packet reported failure.\n", (const void *)"nios_get_timestamp");
      while((_Bool)0);
      *timestamp = (unsigned long int)0;
      return -16;
    }
  }
}

// nios_get_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 491
signed int nios_get_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 *mode)
{
  signed int status;
  unsigned char tmp;
  *mode = (enum anonymous_16)BLADERF_VCTCXO_TAMER_INVALID;
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap_link5(dev, (unsigned long int)(1 << 8));
  if(return_value_have_cap_1 == (_Bool)0)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:501] FPGA %s does not support VCTCXO taming via an input source\n", dev->fpga_version.describe);
    while((_Bool)0);
    return -8;
  }

  else
  {
    status=nios_8x8_read(dev, (unsigned char)0x02, (unsigned char)0xff, &tmp);
    if(status == 0)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:508] %s: Read mode=0x%02x\n", (const void *)"nios_get_vctcxo_tamer_mode", tmp);
      while((_Bool)0);
      if((signed int)(enum anonymous_16)tmp == BLADERF_VCTCXO_TAMER_DISABLED || (signed int)(enum anonymous_16)tmp == BLADERF_VCTCXO_TAMER_1_PPS || (signed int)(enum anonymous_16)tmp == BLADERF_VCTCXO_TAMER_10_MHZ)
      {
        *mode = (enum anonymous_16)tmp;
        goto __CPROVER_DUMP_L6;
      }

      status = -1;
    }


  __CPROVER_DUMP_L6:
    ;
    return status;
  }
}

// nios_legacy_config_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 179
signed int nios_legacy_config_read(struct bladerf *dev, unsigned int *val)
{
  signed int status;
  status=nios_legacy_pio_read(dev, (unsigned char)0, val);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:185] %s: 0x%08x\n", (const void *)"nios_legacy_config_read", val);
    while((_Bool)0);

  return status;
}

// nios_legacy_config_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 191
signed int nios_legacy_config_write(struct bladerf *dev, unsigned int val)
{
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:193] %s: Writing 0x%08x\n", (const void *)"nios_legacy_config_write", val);
  while((_Bool)0);
  signed int return_value_nios_legacy_pio_write_1;
  return_value_nios_legacy_pio_write_1=nios_legacy_pio_write(dev, (unsigned char)0, val);
  return return_value_nios_legacy_pio_write_1;
}

// nios_legacy_expansion_gpio_dir_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 589
signed int nios_legacy_expansion_gpio_dir_read(struct bladerf *dev, unsigned int *val)
{
  signed int status;
  status=nios_legacy_pio_read(dev, (unsigned char)44, val);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:595] %s: 0x%08x\n", (const void *)"nios_legacy_expansion_gpio_dir_read", val);
    while((_Bool)0);

  return status;
}

// nios_legacy_expansion_gpio_dir_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 601
signed int nios_legacy_expansion_gpio_dir_write(struct bladerf *dev, unsigned int mask, unsigned int val)
{
  signed int status;
  unsigned int tmp;
  if(!(mask == 0xffffffff))
  {
    status=nios_legacy_pio_read(dev, (unsigned char)44, &tmp);
    if(!(status == 0))
      return status;

    tmp = tmp & ~mask;
    tmp = tmp | val & mask;
    val = tmp;
  }

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:620] %s: 0x%08\n", (const void *)"nios_legacy_expansion_gpio_dir_write", val);
  while((_Bool)0);
  signed int return_value_nios_legacy_pio_write_1;
  return_value_nios_legacy_pio_write_1=nios_legacy_pio_write(dev, (unsigned char)44, val);
  return return_value_nios_legacy_pio_write_1;
}

// nios_legacy_expansion_gpio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 557
signed int nios_legacy_expansion_gpio_read(struct bladerf *dev, unsigned int *val)
{
  signed int status;
  status=nios_legacy_pio_read(dev, (unsigned char)40, val);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:562] %s: 0x%08x\n", (const void *)"nios_legacy_expansion_gpio_read", val);
    while((_Bool)0);

  return status;
}

// nios_legacy_expansion_gpio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 568
signed int nios_legacy_expansion_gpio_write(struct bladerf *dev, unsigned int mask, unsigned int val)
{
  signed int status;
  unsigned int tmp;
  if(!(mask == 0xffffffff))
  {
    status=nios_legacy_pio_read(dev, (unsigned char)40, &tmp);
    if(!(status == 0))
      return status;

    tmp = tmp & ~mask;
    tmp = tmp | val & mask;
    val = tmp;
  }

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:585] %s: 0x%08x\n", (const void *)"nios_legacy_expansion_gpio_write", val);
  while((_Bool)0);
  signed int return_value_nios_legacy_pio_write_1;
  return_value_nios_legacy_pio_write_1=nios_legacy_pio_write(dev, (unsigned char)40, val);
  return return_value_nios_legacy_pio_write_1;
}

// nios_legacy_get_fpga_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 197
signed int nios_legacy_get_fpga_version(struct bladerf *dev, struct bladerf_version *ver)
{
  signed int i;
  signed int status;
  struct uart_cmd cmd;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    cmd.addr = (unsigned char)(12 + i);
    cmd.data = (unsigned char)0xff;
    status=nios_access_link1(dev, (unsigned char)(0 << 4), (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, &cmd, (unsigned long int)1);
    if(!(status == 0))
    {
      memset((void *)&dev->fpga_version, 0, sizeof(struct bladerf_version) /*16ul*/ );
      do
      {
        const char *return_value_bladerf_strerror_1;
        return_value_bladerf_strerror_1=bladerf_strerror(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_legacy_access.c:213] Failed to read FPGA version[%d]: %s\n", i, return_value_bladerf_strerror_1);
      }
      while((_Bool)0);
      return status;
    }

    switch(i)
    {
      case 0:
      {
        ver->major = (unsigned short int)cmd.data;
        break;
      }
      case 1:
      {
        ver->minor = (unsigned short int)cmd.data;
        break;
      }
      case 2:
      {
        ver->patch = (unsigned short int)cmd.data;
        break;
      }
      case 3:
      {
        ver->patch = ver->patch | (unsigned short int)((signed int)cmd.data << 8);
        break;
      }
      default:
        /* assertion !"Bug" */
        assert(!((_Bool)"Bug"));
    }
  }
  snprintf((char *)ver->describe, (unsigned long int)32, "%d.%d.%d", ver->major, ver->minor, ver->patch);
  return status;
}

// nios_legacy_get_iq_gain_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 447
signed int nios_legacy_get_iq_gain_correction(struct bladerf *dev, enum anonymous module, signed short int *value)
{
  signed int status;
  unsigned char addr;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      addr = (unsigned char)4;
      break;
    }
    case BLADERF_MODULE_TX:
    {
      addr = (unsigned char)8;
      break;
    }
    default:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_legacy_access.c:464] %s: invalid module provided (%d)\n", (const void *)"nios_legacy_get_iq_gain_correction", module);
      while((_Bool)0);
      return -3;
    }
  }
  status=get_iq_correction(dev, addr, value);
  return status;
}

// nios_legacy_get_iq_phase_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 474
signed int nios_legacy_get_iq_phase_correction(struct bladerf *dev, enum anonymous module, signed short int *value)
{
  unsigned char addr;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      addr = (unsigned char)6;
      break;
    }
    case BLADERF_MODULE_TX:
    {
      addr = (unsigned char)10;
      break;
    }
    default:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_legacy_access.c:490] %s: invalid module provided (%d)\n", (const void *)"nios_legacy_get_iq_phase_correction", module);
      while((_Bool)0);
      return -3;
    }
  }
  signed int return_value_get_iq_correction_1;
  return_value_get_iq_correction_1=get_iq_correction(dev, addr, value);
  return return_value_get_iq_correction_1;
}

// nios_legacy_get_timestamp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 242
signed int nios_legacy_get_timestamp(struct bladerf *dev, enum anonymous mod, unsigned long int *value)
{
  signed int status = 0;
  struct uart_cmd cmds[4l];
  unsigned char timestamp_bytes[8l];
  unsigned long int i;
  cmds[(signed long int)0].addr = (unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 16 : 24);
  cmds[(signed long int)1].addr = (unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 17 : 25);
  cmds[(signed long int)2].addr = (unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 18 : 26);
  cmds[(signed long int)3].addr = (unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 19 : 27);
  cmds[(signed long int)3].data = (unsigned char)0xff;
  cmds[(signed long int)2].data = cmds[(signed long int)3].data;
  cmds[(signed long int)1].data = cmds[(signed long int)2].data;
  cmds[(signed long int)0].data = cmds[(signed long int)1].data;
  status=nios_access_link1(dev, (unsigned char)(0 << 4), (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, cmds, sizeof(struct uart_cmd [4l]) /*8ul*/  / sizeof(struct uart_cmd) /*2ul*/ );
  if(!(status == 0))
    return status;

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= 4ul); i = i + 1ul)
      timestamp_bytes[(signed long int)i] = cmds[(signed long int)i].data;
  }
  cmds[(signed long int)0].addr = (unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 20 : 28);
  cmds[(signed long int)1].addr = (unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 21 : 29);
  cmds[(signed long int)2].addr = (unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 22 : 30);
  cmds[(signed long int)3].addr = (unsigned char)((signed int)mod == BLADERF_MODULE_RX ? 23 : 31);
  cmds[(signed long int)3].data = (unsigned char)0xff;
  cmds[(signed long int)2].data = cmds[(signed long int)3].data;
  cmds[(signed long int)1].data = cmds[(signed long int)2].data;
  cmds[(signed long int)0].data = cmds[(signed long int)1].data;
  status=nios_access_link1(dev, (unsigned char)(0 << 4), (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, cmds, sizeof(struct uart_cmd [4l]) /*8ul*/  / sizeof(struct uart_cmd) /*2ul*/ );
  if(!(status == 0))
    return status;

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= 4ul); i = i + 1ul)
      timestamp_bytes[(signed long int)(i + (unsigned long int)4)] = cmds[(signed long int)i].data;
  }
  memcpy((void *)value, (const void *)timestamp_bytes, sizeof(unsigned long int) /*8ul*/ );
  *value = *value;
  return 0;
}

// nios_legacy_get_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 402
signed int nios_legacy_get_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 *mode)
{
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_legacy_access.c:405] This operation is not supported by the legacy NIOS packet format\n");
  while((_Bool)0);
  *mode = (enum anonymous_16)BLADERF_VCTCXO_TAMER_INVALID;
  return -8;
}

// nios_legacy_lms6_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 326
signed int nios_legacy_lms6_read(struct bladerf *dev, unsigned char addr, unsigned char *data)
{
  signed int status;
  struct uart_cmd cmd;
  cmd.addr = addr;
  cmd.data = (unsigned char)0xff;
  status=nios_access_link1(dev, (unsigned char)(1 << 4), (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, &cmd, (unsigned long int)1);
  if(status == 0)
  {
    *data = cmd.data;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:339] %s: 0x%2.2x 0x%2.2x\n", (const void *)"nios_legacy_lms6_read", addr, *data);
    while((_Bool)0);
  }

  return status;
}

// nios_legacy_lms6_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 345
signed int nios_legacy_lms6_write(struct bladerf *dev, unsigned char addr, unsigned char data)
{
  signed int status;
  struct uart_cmd cmd;
  cmd.addr = addr;
  cmd.data = data;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:353] %s: 0x%2.2x 0x%2.2x\n", (const void *)"nios_legacy_lms6_write", addr, data);
  while((_Bool)0);
  status=nios_access_link1(dev, (unsigned char)(1 << 4), (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, &cmd, (unsigned long int)1);
  return status;
}

// nios_legacy_pio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 130
signed int nios_legacy_pio_read(struct bladerf *dev, unsigned char addr, unsigned int *data)
{
  signed int status;
  unsigned long int i;
  struct uart_cmd cmd;
  *data = (unsigned int)0;
  i = (unsigned long int)0;
  for( ; !(i >= sizeof(unsigned int) /*4ul*/ ); i = i + 1ul)
  {
    /* assertion (addr + i) <= (255) */
    assert((unsigned long int)addr + i <= (unsigned long int)255);
    cmd.addr = (unsigned char)((unsigned long int)addr + i);
    cmd.data = (unsigned char)0xff;
    status=nios_access_link1(dev, (unsigned char)(0 << 4), (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, &cmd, (unsigned long int)1);
    if(!(status >= 0))
    {
      *data = (unsigned int)0;
      return status;
    }

    *data = *data | (unsigned int)((signed int)cmd.data << i * (unsigned long int)8);
  }
  return 0;
}

// nios_legacy_pio_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 157
signed int nios_legacy_pio_write(struct bladerf *dev, unsigned char addr, unsigned int data)
{
  signed int status;
  unsigned long int i;
  struct uart_cmd cmd;
  i = (unsigned long int)0;
  for( ; !(i >= sizeof(unsigned int) /*4ul*/ ); i = i + 1ul)
  {
    /* assertion (addr + i) <= (255) */
    assert((unsigned long int)addr + i <= (unsigned long int)255);
    cmd.addr = (unsigned char)((unsigned long int)addr + i);
    cmd.data = (unsigned char)(data >> i * (unsigned long int)8 & (unsigned int)0xff);
    status=nios_access_link1(dev, (unsigned char)(0 << 4), (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, &cmd, (unsigned long int)1);
    if(!(status >= 0))
      return status;

  }
  return 0;
}

// nios_legacy_set_iq_gain_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 498
signed int nios_legacy_set_iq_gain_correction(struct bladerf *dev, enum anonymous module, signed short int value)
{
  unsigned char addr;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      addr = (unsigned char)4;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:506] Setting RX IQ Correction phase: %d\n", value);
      while((_Bool)0);
      break;
    }
    case BLADERF_MODULE_TX:
    {
      addr = (unsigned char)8;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:511] Setting TX IQ Correction phase: %d\n", value);
      while((_Bool)0);
      break;
    }
    default:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_legacy_access.c:516] %s: invalid module provided (%d)\n", (const void *)"nios_legacy_set_iq_gain_correction", module);
      while((_Bool)0);
      return -3;
    }
  }
  signed int return_value_set_iq_correction_1;
  return_value_set_iq_correction_1=set_iq_correction(dev, addr, value);
  return return_value_set_iq_correction_1;
}

// nios_legacy_set_iq_phase_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 524
signed int nios_legacy_set_iq_phase_correction(struct bladerf *dev, enum anonymous module, signed short int value)
{
  unsigned char addr;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:531] Setting RX IQ Correction phase: %d\n", value);
      while((_Bool)0);
      addr = (unsigned char)6;
      break;
    }
    case BLADERF_MODULE_TX:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:536] Setting TX IQ Correction phase: %d\n", value);
      while((_Bool)0);
      addr = (unsigned char)10;
      break;
    }
    default:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_legacy_access.c:542] %s: invalid module provided (%d)\n", (const void *)"nios_legacy_set_iq_phase_correction", module);
      while((_Bool)0);
      return -3;
    }
  }
  signed int return_value_set_iq_correction_1;
  return_value_set_iq_correction_1=set_iq_correction(dev, addr, value);
  return return_value_set_iq_correction_1;
}

// nios_legacy_set_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 395
signed int nios_legacy_set_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 mode)
{
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_legacy_access.c:398] This operation is not supported by the legacy NIOS packet format\n");
  while((_Bool)0);
  return -8;
}

// nios_legacy_si5338_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 294
signed int nios_legacy_si5338_read(struct bladerf *dev, unsigned char addr, unsigned char *data)
{
  signed int status;
  struct uart_cmd cmd;
  cmd.addr = addr;
  cmd.data = (unsigned char)0xff;
  status=nios_access_link1(dev, (unsigned char)(3 << 4), (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, &cmd, (unsigned long int)1);
  if(status == 0)
  {
    *data = cmd.data;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:307] %s: 0x%2.2x 0x%2.2x\n", (const void *)"nios_legacy_si5338_read", addr, *data);
    while((_Bool)0);
  }

  return status;
}

// nios_legacy_si5338_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 313
signed int nios_legacy_si5338_write(struct bladerf *dev, unsigned char addr, unsigned char data)
{
  struct uart_cmd cmd;
  cmd.addr = addr;
  cmd.data = data;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:320] %s: 0x%2.2x 0x%2.2x\n", (const void *)"nios_legacy_si5338_write", addr, data);
  while((_Bool)0);
  signed int return_value_nios_access_1;
  return_value_nios_access_1=nios_access_link1(dev, (unsigned char)(3 << 4), (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, &cmd, (unsigned long int)1);
  return return_value_nios_access_1;
}

// nios_legacy_vctcxo_trim_dac_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 361
signed int nios_legacy_vctcxo_trim_dac_write(struct bladerf *dev, unsigned short int value)
{
  signed int status;
  struct uart_cmd cmd;
  signed int base;
  _Bool legacy_location;
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap_link6(dev, (unsigned long int)(1 << 0));
  legacy_location = !(return_value_have_cap_1 != (_Bool)0);
  base = legacy_location != (_Bool)0 ? 0 : 34;
  cmd.addr = (unsigned char)base;
  cmd.data = (unsigned char)((signed int)value & 0xff);
  status=nios_access_link1(dev, (unsigned char)(legacy_location != (_Bool)0 ? 2 << 4 : 0 << 4), (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, &cmd, (unsigned long int)1);
  if(!(status >= 0))
    return status;

  else
  {
    cmd.addr = (unsigned char)(base + 1);
    cmd.data = (unsigned char)((signed int)value >> 8 & 0xff);
    status=nios_access_link1(dev, (unsigned char)(legacy_location != (_Bool)0 ? 2 << 4 : 0 << 4), (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, &cmd, (unsigned long int)1);
    return status;
  }
}

// nios_legacy_xb200_synth_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 550
signed int nios_legacy_xb200_synth_write(struct bladerf *dev, unsigned int value)
{
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_legacy_access.c:552] %s: 0x%08x\n", (const void *)"nios_legacy_xb200_synth_write", value);
  while((_Bool)0);
  signed int return_value_nios_legacy_pio_write_1;
  return_value_nios_legacy_pio_write_1=nios_legacy_pio_write(dev, (unsigned char)36, value);
  return return_value_nios_legacy_pio_write_1;
}

// nios_lms6_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 403
signed int nios_lms6_read(struct bladerf *dev, unsigned char addr, unsigned char *data)
{
  signed int status;
  status=nios_8x8_read(dev, (unsigned char)0x00, addr, data);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:409] %s: Read 0x%02x from addr 0x%02x\n", (const void *)"nios_lms6_read", *data, addr);
    while((_Bool)0);

  return status;
}

// nios_lms6_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 415
signed int nios_lms6_write(struct bladerf *dev, unsigned char addr, unsigned char data)
{
  signed int status;
  status=nios_8x8_write(dev, (unsigned char)0x00, addr, data);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:421] %s: Wrote 0x%02x to addr 0x%02x\n", (const void *)"nios_lms6_write", data, addr);
    while((_Bool)0);

  return status;
}

// nios_pkt_32x32_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_32x32.h line 120
static inline void nios_pkt_32x32_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned int addr, unsigned int data)
{
  buf[(signed long int)0] = (unsigned char)75;
  buf[(signed long int)1] = target;
  if(!(write == (_Bool)0))
    buf[(signed long int)2] = (unsigned char)(1 << 0);

  else
    buf[(signed long int)2] = (unsigned char)0x00;
  buf[(signed long int)3] = (unsigned char)0x00;
  buf[(signed long int)(4 + 0)] = (unsigned char)(addr >> 0);
  buf[(signed long int)(4 + 1)] = (unsigned char)(addr >> 8);
  buf[(signed long int)(4 + 2)] = (unsigned char)(addr >> 16);
  buf[(signed long int)(4 + 3)] = (unsigned char)(addr >> 24);
  buf[(signed long int)(8 + 0)] = (unsigned char)(data >> 0);
  buf[(signed long int)(8 + 1)] = (unsigned char)(data >> 8);
  buf[(signed long int)(8 + 2)] = (unsigned char)(data >> 16);
  buf[(signed long int)(8 + 3)] = (unsigned char)(data >> 24);
  buf[(signed long int)(12 + 0)] = (unsigned char)0x00;
  buf[(signed long int)(12 + 1)] = (unsigned char)0x00;
  buf[(signed long int)(12 + 2)] = (unsigned char)0x00;
  buf[(signed long int)(12 + 3)] = (unsigned char)0x00;
}

// nios_pkt_32x32_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_32x32.h line 192
static inline void nios_pkt_32x32_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned int *addr, unsigned int *data, _Bool *success)
{
  nios_pkt_32x32_unpack(buf, target, write, addr, data);
  if(!((2 & (signed int)buf[2l]) == 0))
    *success = (_Bool)1;

  else
    *success = (_Bool)0;
}

// nios_pkt_32x32_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_32x32.h line 151
static inline void nios_pkt_32x32_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned int *addr, unsigned int *data)
{
  if(!(target == ((unsigned char *)NULL)))
    *target = buf[(signed long int)1];

  if(!(write == ((_Bool *)NULL)))
    *write = ((signed int)buf[(signed long int)2] & 1 << 0) != 0;

  if(!(addr == ((unsigned int *)NULL)))
    *addr = (unsigned int)((signed int)buf[(signed long int)(4 + 0)] << 0 | (signed int)buf[(signed long int)(4 + 1)] << 8 | (signed int)buf[(signed long int)(4 + 2)] << 16 | (signed int)buf[(signed long int)(4 + 3)] << 24);

  if(!(data == ((unsigned int *)NULL)))
    *data = (unsigned int)((signed int)buf[(signed long int)(8 + 0)] << 0 | (signed int)buf[(signed long int)(8 + 1)] << 8 | (signed int)buf[(signed long int)(8 + 2)] << 16 | (signed int)buf[(signed long int)(8 + 3)] << 24);

}

// nios_pkt_8x16_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x16.h line 122
static inline void nios_pkt_8x16_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned char addr, unsigned short int data)
{
  buf[(signed long int)0] = (unsigned char)66;
  buf[(signed long int)1] = target;
  if(!(write == (_Bool)0))
    buf[(signed long int)2] = (unsigned char)(1 << 0);

  else
    buf[(signed long int)2] = (unsigned char)0x00;
  buf[(signed long int)3] = (unsigned char)0x00;
  buf[(signed long int)4] = addr;
  buf[(signed long int)5] = (unsigned char)((signed int)data & 0xff);
  buf[(signed long int)(5 + 1)] = (unsigned char)((signed int)data >> 8);
  buf[(signed long int)(7 + 0)] = (unsigned char)0x00;
  buf[(signed long int)(7 + 1)] = (unsigned char)0x00;
  buf[(signed long int)(7 + 2)] = (unsigned char)0x00;
  buf[(signed long int)(7 + 3)] = (unsigned char)0x00;
  buf[(signed long int)(7 + 4)] = (unsigned char)0x00;
  buf[(signed long int)(7 + 5)] = (unsigned char)0x00;
  buf[(signed long int)(7 + 6)] = (unsigned char)0x00;
  buf[(signed long int)(7 + 7)] = (unsigned char)0x00;
  buf[(signed long int)(7 + 8)] = (unsigned char)0x00;
}

// nios_pkt_8x16_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x16.h line 188
static inline void nios_pkt_8x16_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned short int *data, _Bool *success)
{
  nios_pkt_8x16_unpack(buf, target, write, addr, data);
  if(!((2 & (signed int)buf[2l]) == 0))
    *success = (_Bool)1;

  else
    *success = (_Bool)0;
}

// nios_pkt_8x16_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x16.h line 153
static inline void nios_pkt_8x16_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned short int *data)
{
  if(!(target == ((unsigned char *)NULL)))
    *target = buf[(signed long int)1];

  if(!(write == ((_Bool *)NULL)))
    *write = ((signed int)buf[(signed long int)2] & 1 << 0) != 0;

  if(!(addr == ((unsigned char *)NULL)))
    *addr = buf[(signed long int)4];

  if(!(data == ((unsigned short int *)NULL)))
    *data = (unsigned short int)((signed int)buf[(signed long int)(5 + 0)] << 0 | (signed int)buf[(signed long int)(5 + 1)] << 8);

}

// nios_pkt_8x32_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x32.h line 118
static inline void nios_pkt_8x32_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned char addr, unsigned int data)
{
  buf[(signed long int)0] = (unsigned char)67;
  buf[(signed long int)1] = target;
  if(!(write == (_Bool)0))
    buf[(signed long int)2] = (unsigned char)(1 << 0);

  else
    buf[(signed long int)2] = (unsigned char)0x00;
  buf[(signed long int)3] = (unsigned char)0x00;
  buf[(signed long int)4] = addr;
  buf[(signed long int)(5 + 0)] = (unsigned char)(data & (unsigned int)0xff);
  buf[(signed long int)(5 + 1)] = (unsigned char)(data >> 8);
  buf[(signed long int)(5 + 2)] = (unsigned char)(data >> 16);
  buf[(signed long int)(5 + 3)] = (unsigned char)(data >> 24);
  buf[(signed long int)(9 + 0)] = (unsigned char)0x00;
  buf[(signed long int)(9 + 1)] = (unsigned char)0x00;
  buf[(signed long int)(9 + 2)] = (unsigned char)0x00;
  buf[(signed long int)(9 + 3)] = (unsigned char)0x00;
  buf[(signed long int)(9 + 4)] = (unsigned char)0x00;
  buf[(signed long int)(9 + 5)] = (unsigned char)0x00;
  buf[(signed long int)(9 + 6)] = (unsigned char)0x00;
}

// nios_pkt_8x32_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x32.h line 186
static inline void nios_pkt_8x32_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned int *data, _Bool *success)
{
  nios_pkt_8x32_unpack(buf, target, write, addr, data);
  if(!((2 & (signed int)buf[2l]) == 0))
    *success = (_Bool)1;

  else
    *success = (_Bool)0;
}

// nios_pkt_8x32_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x32.h line 149
static inline void nios_pkt_8x32_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned int *data)
{
  if(!(target == ((unsigned char *)NULL)))
    *target = buf[(signed long int)1];

  if(!(write == ((_Bool *)NULL)))
    *write = ((signed int)buf[(signed long int)2] & 1 << 0) != 0;

  if(!(addr == ((unsigned char *)NULL)))
    *addr = buf[(signed long int)4];

  if(!(data == ((unsigned int *)NULL)))
    *data = (unsigned int)((signed int)buf[(signed long int)(5 + 0)] << 0 | (signed int)buf[(signed long int)(5 + 1)] << 8 | (signed int)buf[(signed long int)(5 + 2)] << 16 | (signed int)buf[(signed long int)(5 + 3)] << 24);

}

// nios_pkt_8x64_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x64.h line 120
static inline void nios_pkt_8x64_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned char addr, unsigned long int data)
{
  buf[(signed long int)0] = (unsigned char)68;
  buf[(signed long int)1] = target;
  if(!(write == (_Bool)0))
    buf[(signed long int)2] = (unsigned char)(1 << 0);

  else
    buf[(signed long int)2] = (unsigned char)0x00;
  buf[(signed long int)3] = (unsigned char)0x00;
  buf[(signed long int)4] = addr;
  buf[(signed long int)(5 + 0)] = (unsigned char)(data >> 0 & (unsigned long int)0xff);
  buf[(signed long int)(5 + 1)] = (unsigned char)(data >> 8 & (unsigned long int)0xff);
  buf[(signed long int)(5 + 2)] = (unsigned char)(data >> 16 & (unsigned long int)0xff);
  buf[(signed long int)(5 + 3)] = (unsigned char)(data >> 24 & (unsigned long int)0xff);
  buf[(signed long int)(5 + 4)] = (unsigned char)(data >> 32 & (unsigned long int)0xff);
  buf[(signed long int)(5 + 5)] = (unsigned char)(data >> 40 & (unsigned long int)0xff);
  buf[(signed long int)(5 + 6)] = (unsigned char)(data >> 48 & (unsigned long int)0xff);
  buf[(signed long int)(5 + 7)] = (unsigned char)(data >> 56 & (unsigned long int)0xff);
  buf[(signed long int)(13 + 0)] = (unsigned char)0x00;
  buf[(signed long int)(13 + 1)] = (unsigned char)0x00;
  buf[(signed long int)(13 + 2)] = (unsigned char)0x00;
}

// nios_pkt_8x64_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x64.h line 192
static inline void nios_pkt_8x64_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned long int *data, _Bool *success)
{
  nios_pkt_8x64_unpack(buf, target, write, addr, data);
  if(!((2 & (signed int)buf[2l]) == 0))
    *success = (_Bool)1;

  else
    *success = (_Bool)0;
}

// nios_pkt_8x64_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x64.h line 151
static inline void nios_pkt_8x64_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned long int *data)
{
  if(!(target == ((unsigned char *)NULL)))
    *target = buf[(signed long int)1];

  if(!(write == ((_Bool *)NULL)))
    *write = ((signed int)buf[(signed long int)2] & 1 << 0) != 0;

  if(!(addr == ((unsigned char *)NULL)))
    *addr = buf[(signed long int)4];

  if(!(data == ((unsigned long int *)NULL)))
    *data = (unsigned long int)buf[(signed long int)(5 + 0)] << 0 | (unsigned long int)buf[(signed long int)(5 + 1)] << 8 | (unsigned long int)buf[(signed long int)(5 + 2)] << 16 | (unsigned long int)buf[(signed long int)(5 + 3)] << 24 | (unsigned long int)buf[(signed long int)(5 + 4)] << 32 | (unsigned long int)buf[(signed long int)(5 + 5)] << 40 | (unsigned long int)buf[(signed long int)(5 + 6)] << 48 | (unsigned long int)buf[(signed long int)(5 + 7)] << 56;

}

// nios_pkt_8x8_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x8.h line 118
static inline void nios_pkt_8x8_pack(unsigned char *buf, unsigned char target, _Bool write, unsigned char addr, unsigned char data)
{
  buf[(signed long int)0] = (unsigned char)65;
  buf[(signed long int)1] = target;
  if(!(write == (_Bool)0))
    buf[(signed long int)2] = (unsigned char)(1 << 0);

  else
    buf[(signed long int)2] = (unsigned char)0x00;
  buf[(signed long int)3] = (unsigned char)0x00;
  buf[(signed long int)4] = addr;
  buf[(signed long int)5] = data;
  buf[(signed long int)(6 + 0)] = (unsigned char)0x00;
  buf[(signed long int)(6 + 1)] = (unsigned char)0x00;
  buf[(signed long int)(6 + 2)] = (unsigned char)0x00;
  buf[(signed long int)(6 + 3)] = (unsigned char)0x00;
  buf[(signed long int)(6 + 4)] = (unsigned char)0x00;
  buf[(signed long int)(6 + 5)] = (unsigned char)0x00;
  buf[(signed long int)(6 + 6)] = (unsigned char)0x00;
  buf[(signed long int)(6 + 7)] = (unsigned char)0x00;
  buf[(signed long int)(6 + 8)] = (unsigned char)0x00;
  buf[(signed long int)(6 + 9)] = (unsigned char)0x00;
}

// nios_pkt_8x8_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x8.h line 182
static inline void nios_pkt_8x8_resp_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned char *data, _Bool *success)
{
  nios_pkt_8x8_unpack(buf, target, write, addr, data);
  if(!((2 & (signed int)buf[2l]) == 0))
    *success = (_Bool)1;

  else
    *success = (_Bool)0;
}

// nios_pkt_8x8_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_8x8.h line 148
static inline void nios_pkt_8x8_unpack(const unsigned char *buf, unsigned char *target, _Bool *write, unsigned char *addr, unsigned char *data)
{
  if(!(target == ((unsigned char *)NULL)))
    *target = buf[(signed long int)1];

  if(!(write == ((_Bool *)NULL)))
    *write = ((signed int)buf[(signed long int)2] & 1 << 0) != 0;

  if(!(addr == ((unsigned char *)NULL)))
    *addr = buf[(signed long int)4];

  if(!(data == ((unsigned char *)NULL)))
    *data = buf[(signed long int)5];

}

// nios_pkt_retune_pack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_retune.h line 125
static inline void nios_pkt_retune_pack(unsigned char *buf, enum anonymous module, unsigned long int timestamp, unsigned short int nint, unsigned int nfrac, unsigned char freqsel, unsigned char vcocap, _Bool low_band, _Bool quick_tune)
{
  buf[(signed long int)0] = (unsigned char)84;
  buf[(signed long int)(1 + 0)] = (unsigned char)(timestamp & (unsigned long int)0xff);
  buf[(signed long int)(1 + 1)] = (unsigned char)(timestamp >> 8 & (unsigned long int)0xff);
  buf[(signed long int)(1 + 2)] = (unsigned char)(timestamp >> 16 & (unsigned long int)0xff);
  buf[(signed long int)(1 + 3)] = (unsigned char)(timestamp >> 24 & (unsigned long int)0xff);
  buf[(signed long int)(1 + 4)] = (unsigned char)(timestamp >> 32 & (unsigned long int)0xff);
  buf[(signed long int)(1 + 5)] = (unsigned char)(timestamp >> 40 & (unsigned long int)0xff);
  buf[(signed long int)(1 + 6)] = (unsigned char)(timestamp >> 48 & (unsigned long int)0xff);
  buf[(signed long int)(1 + 7)] = (unsigned char)(timestamp >> 56 & (unsigned long int)0xff);
  buf[(signed long int)(9 + 0)] = (unsigned char)((signed int)nint >> 1 & 0xff);
  buf[(signed long int)(9 + 1)] = (unsigned char)(((signed int)nint & 0x1) << 7);
  buf[(signed long int)(9 + 1)] = buf[(signed long int)(9 + 1)] | (unsigned char)(nfrac >> 16 & (unsigned int)0x7f);
  buf[(signed long int)(9 + 2)] = (unsigned char)(nfrac >> 8 & (unsigned int)0xff);
  buf[(signed long int)(9 + 3)] = (unsigned char)(nfrac & (unsigned int)0xff);
  buf[(signed long int)13] = (unsigned char)((signed int)freqsel & 0xff);
  switch((signed int)module)
  {
    case BLADERF_MODULE_TX:
    {
      buf[(signed long int)13] = buf[(signed long int)13] | (unsigned char)(1 << 7);
      break;
    }
    case BLADERF_MODULE_RX:
      buf[(signed long int)13] = buf[(signed long int)13] | (unsigned char)(1 << 6);
  }
  if(!(low_band == (_Bool)0))
    buf[(signed long int)14] = (unsigned char)(1 << 7);

  else
    buf[(signed long int)14] = (unsigned char)0x00;
  if(!(quick_tune == (_Bool)0))
    buf[(signed long int)14] = buf[(signed long int)14] | (unsigned char)(1 << 6);

  buf[(signed long int)14] = buf[(signed long int)14] | vcocap;
  buf[(signed long int)15] = (unsigned char)0x00;
}

// nios_pkt_retune_resp_unpack
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/../fpga_common/include/nios_pkt_retune.h line 312
static inline void nios_pkt_retune_resp_unpack(const unsigned char *buf, unsigned long int *duration, unsigned char *vcocap, unsigned char *flags)
{
  *duration = (unsigned long int)buf[(signed long int)(1 + 0)];
  *duration = *duration | (unsigned long int)buf[(signed long int)(1 + 1)] << 8;
  *duration = *duration | (unsigned long int)buf[(signed long int)(1 + 2)] << 16;
  *duration = *duration | (unsigned long int)buf[(signed long int)(1 + 3)] << 24;
  *duration = *duration | (unsigned long int)buf[(signed long int)(1 + 4)] << 32;
  *duration = *duration | (unsigned long int)buf[(signed long int)(1 + 5)] << 40;
  *duration = *duration | (unsigned long int)buf[(signed long int)(1 + 6)] << 48;
  *duration = *duration | (unsigned long int)buf[(signed long int)(1 + 7)] << 56;
  *vcocap = buf[(signed long int)9];
  *flags = buf[(signed long int)10];
}

// nios_retune
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 711
signed int nios_retune(struct bladerf *dev, enum anonymous module, unsigned long int timestamp, unsigned short int nint, unsigned int nfrac, unsigned char freqsel, unsigned char vcocap, _Bool low_band, _Bool quick_tune)
{
  signed int status;
  unsigned char buf[16l];
  unsigned char resp_flags;
  unsigned long int duration;
  if(timestamp == 18446744073709551615ul)
    do
    {
      const char *return_value_module2str_1;
      return_value_module2str_1=module2str(module);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:723] Clearing %s retune queue.\n", return_value_module2str_1);
    }
    while((_Bool)0);

  else
    do
    {
      const char *return_value_module2str_2;
      return_value_module2str_2=module2str(module);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:728] %s: module=%s timestamp=%lu nint=%u nfrac=%u\n\t\t\t\tfreqsel=0x%02x vcocap=0x%02x low_band=%d quick_tune=%d\n", (const void *)"nios_retune", return_value_module2str_2, timestamp, nint, nfrac, freqsel, vcocap, low_band, quick_tune);
    }
    while((_Bool)0);
  nios_pkt_retune_pack(buf, module, timestamp, nint, nfrac, freqsel, vcocap, low_band, quick_tune);
  status=nios_access(dev, buf);
  if(!(status == 0))
    return status;

  else
  {
    nios_pkt_retune_resp_unpack(buf, &duration, &vcocap, &resp_flags);
    if(!((1 & (signed int)resp_flags) == 0))
      do
      {
        const char *return_value_module2str_3;
        return_value_module2str_3=module2str(module);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:743] %s retune operation: vcocap=%u, duration=%lu\n", return_value_module2str_3, vcocap, duration);
      }
      while((_Bool)0);

    else
      do
      {
        const char *return_value_module2str_4;
        return_value_module2str_4=module2str(module);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:746] %s operation duration: %lu\n", return_value_module2str_4, duration);
      }
      while((_Bool)0);
    if((2 & (signed int)resp_flags) == 0)
    {
      if(timestamp == 0ul)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:751] FPGA tuning reported failure.\n");
        while((_Bool)0);
        status = -1;
      }

      else
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:755] The FPGA's retune queue is full. Try again after a previous request has completed.\n");
        while((_Bool)0);
        status = -15;
      }
    }

    return status;
  }
}

// nios_set_iq_gain_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 588
signed int nios_set_iq_gain_correction(struct bladerf *dev, enum anonymous module, signed short int value)
{
  signed int status = -3;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:595] Setting RX IQ Correction gain: %d\n", value);
      while((_Bool)0);
      status=nios_8x16_write(dev, (unsigned char)0x01, (unsigned char)0x00, (unsigned short int)value);
      break;
    }
    case BLADERF_MODULE_TX:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:601] Setting TX IQ Correction gain: %d\n", value);
      while((_Bool)0);
      status=nios_8x16_write(dev, (unsigned char)0x01, (unsigned char)0x02, (unsigned short int)value);
      break;
    }
    default:
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:607] Invalid module: %d\n", module);
      while((_Bool)0);
  }
  if(status == 0)
    do
    {
      const char *return_value_module2str_1;
      return_value_module2str_1=module2str(module);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:612] %s: Wrote %s %d\n", (const void *)"nios_set_iq_gain_correction", return_value_module2str_1, value);
    }
    while((_Bool)0);

  return status;
}

// nios_set_iq_phase_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 618
signed int nios_set_iq_phase_correction(struct bladerf *dev, enum anonymous module, signed short int value)
{
  signed int status = -3;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:625] Setting RX IQ Correction phase: %d\n", value);
      while((_Bool)0);
      status=nios_8x16_write(dev, (unsigned char)0x01, (unsigned char)0x01, (unsigned short int)value);
      break;
    }
    case BLADERF_MODULE_TX:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:631] Setting TX IQ Correction phase: %d\n", value);
      while((_Bool)0);
      status=nios_8x16_write(dev, (unsigned char)0x01, (unsigned char)0x03, (unsigned short int)value);
      break;
    }
    default:
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:637] Invalid module: %d\n", module);
      while((_Bool)0);
  }
  if(status == 0)
    do
    {
      const char *return_value_module2str_1;
      return_value_module2str_1=module2str(module);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:642] %s: Wrote %s %d\n", (const void *)"nios_set_iq_phase_correction", return_value_module2str_1, value);
    }
    while((_Bool)0);

  return status;
}

// nios_set_vctcxo_tamer_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 467
signed int nios_set_vctcxo_tamer_mode(struct bladerf *dev, enum anonymous_16 mode)
{
  signed int status;
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap_link5(dev, (unsigned long int)(1 << 8));
  if(return_value_have_cap_1 == (_Bool)0)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:474] FPGA %s does not support VCTCXO taming via an input source\n", dev->fpga_version.describe);
    while((_Bool)0);
    return -8;
  }

  else
  {
    status=nios_8x8_write(dev, (unsigned char)0x02, (unsigned char)0xff, (unsigned char)mode);
    if(status == 0)
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:485] %s: Wrote mode=0x%02x\n", (const void *)"nios_set_vctcxo_tamer_mode", mode);
      while((_Bool)0);

    return status;
  }
}

// nios_si5338_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 379
signed int nios_si5338_read(struct bladerf *dev, unsigned char addr, unsigned char *data)
{
  signed int status;
  status=nios_8x8_read(dev, (unsigned char)0x01, addr, data);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:385] %s: Read 0x%02x from addr 0x%02x\n", (const void *)"nios_si5338_read", *data, addr);
    while((_Bool)0);

  return status;
}

// nios_si5338_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 391
signed int nios_si5338_write(struct bladerf *dev, unsigned char addr, unsigned char data)
{
  signed int status;
  status=nios_8x8_write(dev, (unsigned char)0x01, addr, data);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:397] %s: Wrote 0x%02x to addr 0x%02x\n", (const void *)"nios_si5338_write", data, addr);
    while((_Bool)0);

  return status;
}

// nios_vctcxo_trim_dac_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 444
signed int nios_vctcxo_trim_dac_read(struct bladerf *dev, unsigned short int *value)
{
  signed int status;
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap_link5(dev, (unsigned long int)(1 << 5));
  if(return_value_have_cap_1 == (_Bool)0)
  {
    *value = (unsigned short int)0x0000;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ nios_access.c:452] FPGA %s does not support VCTCXO trimdac readback.\n", dev->fpga_version.describe);
    while((_Bool)0);
    return -8;
  }

  else
  {
    status=nios_8x16_read(dev, (unsigned char)0x00, (unsigned char)0x98, value);
    if(!(status == 0))
      *value = (unsigned short int)0;

    else
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:461] %s: Read 0x%04x\n", (const void *)"nios_vctcxo_trim_dac_read", *value);
      while((_Bool)0);
    return status;
  }
}

// nios_vctcxo_trim_dac_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 427
signed int nios_vctcxo_trim_dac_write(struct bladerf *dev, unsigned short int value)
{
  signed int status;
  status=nios_8x16_write(dev, (unsigned char)0x00, (unsigned char)0x28, (unsigned short int)0);
  if(status == 0)
  {
    status=nios_8x16_write(dev, (unsigned char)0x00, (unsigned char)0x08, value);
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:438] %s: Wrote 0x%04x\n", (const void *)"nios_vctcxo_trim_dac_write", value);
    while((_Bool)0);
  }

  return status;
}

// nios_xb200_synth_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_access.c line 649
signed int nios_xb200_synth_write(struct bladerf *dev, unsigned int value)
{
  signed int status;
  status=nios_8x32_write(dev, (unsigned char)0x02, (unsigned char)0, value);
  if(status == 0)
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ nios_access.c:654] %s: Wrote 0x%08x\n", (const void *)"nios_xb200_synth_write", value);
    while((_Bool)0);

  return status;
}

// open_bladerf_from_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/doc/examples/open_via_serial.c line 36
struct bladerf * open_bladerf_from_serial(const char *serial)
{
  signed int status;
  struct bladerf *dev;
  struct bladerf_devinfo info;
  bladerf_init_devinfo(&info);
  strncpy(info.serial, serial, (unsigned long int)(33 - 1));
  info.serial[(signed long int)(33 - 1)] = (char)0;
  status=bladerf_open_with_devinfo(&dev, &info);
  if(status == -7)
  {
    printf("No devices available with serial=%s\n", serial);
    return (struct bladerf *)(void *)0;
  }

  else
    if(!(status == 0))
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      fprintf(stderr, "Failed to open device with serial=%s (%s)\n", serial, return_value_bladerf_strerror_1);
      return (struct bladerf *)(void *)0;
    }

    else
      return dev;
}

// open_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 340
static signed int open_device(struct bladerf_devinfo *info, struct libusb_context *context, struct libusb_device *libusb_dev_in, struct bladerf_lusb **dev_out)
{
  signed int status;
  struct bladerf_lusb *dev;
  *dev_out = (struct bladerf_lusb *)(void *)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct bladerf_lusb) /*24ul*/ );
  dev = (struct bladerf_lusb *)return_value_calloc_1;
  if(dev == ((struct bladerf_lusb *)NULL))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:353] Failed allocate handle for instance %d.\n", info->instance);
    while((_Bool)0);
    return -7;
  }

  else
  {
    dev->context = context;
    dev->dev = libusb_dev_in;
    status=libusb_open(libusb_dev_in, &dev->handle);
    if(!(status >= 0))
    {
      do
      {
        const char *return_value_libusb_error_name_2;
        return_value_libusb_error_name_2=libusb_error_name(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:366] Failed to open device instance %d: %s\n", info->instance, return_value_libusb_error_name_2);
      }
      while((_Bool)0);
      status=error_conv(status);
    }

    else
    {
      status=libusb_claim_interface(dev->handle, 0);
      if(!(status >= 0))
      {
        do
        {
          const char *return_value_libusb_error_name_3;
          return_value_libusb_error_name_3=libusb_error_name(status);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ libusb.c:375] Failed to claim interface 0 for instance %d: %s\n", info->instance, return_value_libusb_error_name_3);
        }
        while((_Bool)0);
        status=error_conv(status);
      }

    }

  error:
    ;
    if(!(status == 0))
    {
      if(!(dev->handle == ((struct libusb_device_handle *)NULL)))
        libusb_close(dev->handle);

      free((void *)dev);
    }

    else
      *dev_out = dev;
    return status;
  }
}

// open_with_any_backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 29
signed int open_with_any_backend(struct bladerf *device, struct bladerf_devinfo *info)
{
  unsigned long int i;
  signed int status = -7;
  const unsigned long int n_backends = sizeof(struct backend_fns *[1l]) /*8ul*/  / sizeof(struct backend_fns *) /*8ul*/ ;
  i = (unsigned long int)0;
  if(!(status == 0) && !(i >= n_backends))
  {
    status=backend_list[(signed long int)i]->open(device, info);
    i = i + 1ul;
  }

  return status;
}

// pack_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 143
static unsigned long int pack_image(struct bladerf_image *img, unsigned char *buf)
{
  unsigned long int i = (unsigned long int)0;
  unsigned short int ver_field;
  unsigned int type;
  unsigned int len;
  unsigned int addr;
  unsigned long int timestamp;
  char checksum[32l];
  memcpy((void *)&buf[(signed long int)i], (const void *)img->magic, (unsigned long int)7);
  i = i + (unsigned long int)7;
  memset((void *)&buf[(signed long int)i], 0, (unsigned long int)32);
  i = i + (unsigned long int)32;
  unsigned short int tmp_statement_expression_1;
  unsigned short int pack_image__1__1____v;
  unsigned short int pack_image__1__1____x = (unsigned short int)img->version.major;
  asm("rorw _8, %w0" : "=r"(pack_image__1__1____v) : "0"(pack_image__1__1____x) : "cc");
  tmp_statement_expression_1 = pack_image__1__1____v;
  ver_field = tmp_statement_expression_1;
  memcpy((void *)&buf[(signed long int)i], (const void *)&ver_field, sizeof(unsigned short int) /*2ul*/ );
  i = i + sizeof(unsigned short int) /*2ul*/ ;
  unsigned short int tmp_statement_expression_2;
  unsigned short int pack_image__1__2____v;
  unsigned short int pack_image__1__2____x = (unsigned short int)img->version.minor;
  asm("rorw _8, %w0" : "=r"(pack_image__1__2____v) : "0"(pack_image__1__2____x) : "cc");
  tmp_statement_expression_2 = pack_image__1__2____v;
  ver_field = tmp_statement_expression_2;
  memcpy((void *)&buf[(signed long int)i], (const void *)&ver_field, sizeof(unsigned short int) /*2ul*/ );
  i = i + sizeof(unsigned short int) /*2ul*/ ;
  unsigned short int tmp_statement_expression_3;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)img->version.patch;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_3 = __v;
  ver_field = tmp_statement_expression_3;
  memcpy((void *)&buf[(signed long int)i], (const void *)&ver_field, sizeof(unsigned short int) /*2ul*/ );
  i = i + sizeof(unsigned short int) /*2ul*/ ;
  timestamp=__bswap_64(img->timestamp);
  memcpy((void *)&buf[(signed long int)i], (const void *)&timestamp, sizeof(unsigned long int) /*8ul*/ );
  i = i + sizeof(unsigned long int) /*8ul*/ ;
  memcpy((void *)&buf[(signed long int)i], (const void *)&img->serial, (unsigned long int)33);
  i = i + (unsigned long int)33;
  memset((void *)&buf[(signed long int)i], 0, (unsigned long int)128);
  i = i + (unsigned long int)128;
  type=__bswap_32((unsigned int)img->type);
  memcpy((void *)&buf[(signed long int)i], (const void *)&type, sizeof(unsigned int) /*4ul*/ );
  i = i + sizeof(unsigned int) /*4ul*/ ;
  addr=__bswap_32(img->address);
  memcpy((void *)&buf[(signed long int)i], (const void *)&addr, sizeof(unsigned int) /*4ul*/ );
  i = i + sizeof(unsigned int) /*4ul*/ ;
  len=__bswap_32(img->length);
  memcpy((void *)&buf[(signed long int)i], (const void *)&len, sizeof(unsigned int) /*4ul*/ );
  i = i + sizeof(unsigned int) /*4ul*/ ;
  memcpy((void *)&buf[(signed long int)i], (const void *)img->data, (unsigned long int)img->length);
  i = i + (unsigned long int)img->length;
  sha256_buffer((const char *)buf, i, checksum);
  memcpy((void *)&buf[(signed long int)7], (const void *)checksum, (unsigned long int)32);
  return i;
}

// perform_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 468
static inline signed int perform_erase(struct bladerf *dev, unsigned short int block)
{
  signed int status;
  signed int erase_ret;
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  status=usb->fn->control_transfer(driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, (unsigned char)102, (unsigned short int)0, block, (void *)&erase_ret, (unsigned int)sizeof(signed int) /*4ul*/ , (unsigned int)1000);
  return status;
}

// perform_format_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 237
signed int perform_format_config(struct bladerf *dev, enum anonymous module, enum anonymous_9 format)
{
  signed int status = 0;
  _Bool use_timestamps;
  enum anonymous other;
  _Bool other_using_timestamps;
  unsigned int gpio_val;
  status=requires_timestamps(format, &use_timestamps);
  _Bool return_value_have_cap_1;
  if(!(status == 0))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf_priv.c:348] %s: Invalid format: %d\n", (const void *)"perform_format_config", format);
    while((_Bool)0);
    return status;
  }

  else
    if(!(use_timestamps == (_Bool)0))
    {
      return_value_have_cap_1=have_cap_link1(dev, (unsigned long int)(1 << 2));
      if(return_value_have_cap_1 != (_Bool)0)
        goto __CPROVER_DUMP_L4;

      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ bladerf_priv.c:353] Timestamp support requires FPGA v0.1.0 or later.\n");
      while((_Bool)0);
      return -12;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      switch((signed int)module)
      {
        case BLADERF_MODULE_RX:
        {
          other = (enum anonymous)BLADERF_MODULE_TX;
          break;
        }
        case BLADERF_MODULE_TX:
        {
          other = (enum anonymous)BLADERF_MODULE_RX;
          break;
        }
        default:
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf_priv.c:367] Invalid module: %d\n", module);
          while((_Bool)0);
          return -3;
        }
      }
      status=requires_timestamps(dev->module_format[(signed long int)other], &other_using_timestamps);
      if(status == 0 && !(other_using_timestamps == use_timestamps))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf_priv.c:375] Format conflict detected: RX=%d, TX=%d\n");
        while((_Bool)0);
        return -3;
      }

      else
      {
        status=dev->fn->config_gpio_read(dev, &gpio_val);
        if(!(status == 0))
          return status;

        else
        {
          if(!(use_timestamps == (_Bool)0))
            gpio_val = gpio_val | (unsigned int)(1 << 16 | 1 << 17);

          else
            gpio_val = gpio_val & (unsigned int)~(1 << 16 | 1 << 17);
          status=config_gpio_write(dev, gpio_val);
          if(status == 0)
            dev->module_format[(signed long int)module] = format;

          return status;
        }
      }
    }
}

// perform_format_deconfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 249
signed int perform_format_deconfig(struct bladerf *dev, enum anonymous module)
{
  if((signed int)module == BLADERF_MODULE_RX || (signed int)module == BLADERF_MODULE_TX)
  {
    dev->module_format[(signed long int)module] = (enum anonymous_9)-1;
    goto __CPROVER_DUMP_L3;
  }

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ bladerf_priv.c:410] %s: Invalid module: %d\n", (const void *)"perform_format_deconfig", module);
  while((_Bool)0);
  return -3;

__CPROVER_DUMP_L3:
  ;
  return 0;
}

// populate_abs_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 204
signed int populate_abs_timeout(struct timespec *t, unsigned int timeout_ms)
{
  const unsigned int timeout_sec = timeout_ms / (unsigned int)1000;
  signed int status;
  status=clock_gettime(0, t);
  if(!(status == 0))
    return -1;

  else
  {
    t->tv_sec = t->tv_sec + (signed long int)timeout_sec;
    t->tv_nsec = t->tv_nsec + (signed long int)((timeout_ms % (unsigned int)1000) * (unsigned int)1000 * (unsigned int)1000);
    static const signed int nsec_per_sec = 1000 * 1000 * 1000;
    if(t->tv_nsec >= (signed long int)nsec_per_sec)
    {
      t->tv_sec = t->tv_sec + t->tv_nsec / (signed long int)nsec_per_sec;
      t->tv_nsec = t->tv_nsec % (signed long int)nsec_per_sec;
    }

    return 0;
  }
}

// populate_fw_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 260
static inline signed int populate_fw_version(struct bladerf_usb *usb, struct bladerf_version *version)
{
  signed int status;
  status=usb->fn->get_string_descriptor(usb->driver, (unsigned char)4, (void *)(unsigned char *)version->describe, (unsigned int)32);
  if(status == 0)
    status=str2version(version->describe, version);

  else
  {
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ usb.c:275] Failed to retrieve firmware version. This may be due to an old firmware version that does not support this request. A firmware update via the bootloader is required.\n\n");
    status = -13;
  }
  return status;
}

// post_fpga_load_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 156
static signed int post_fpga_load_init(struct bladerf *dev)
{
  signed int status;
  status=change_setting(dev, (unsigned char)1);
  if(status == 0)
  {
    status=nios_legacy_get_fpga_version(dev, &dev->fpga_version);
    if(!(status == 0))
      return status;

    else
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ usb.c:169] Read FPGA version: %s\n", dev->fpga_version.describe);
      while((_Bool)0);
  }

  capabilities_init_post_fpga_load(dev);
  char *return_value_getenv_2;
  return_value_getenv_2=getenv("BLADERF_FORCE_LEGACY_NIOS_PKT");
  if(return_value_getenv_2 == ((char *)NULL))
  {
    _Bool return_value_have_cap_1;
    return_value_have_cap_1=have_cap_link7(dev, (unsigned long int)(1 << 4));
    if(!(return_value_have_cap_1 == (_Bool)0))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ usb.c:180] Using current packet handler formats\n");
      while((_Bool)0);
      dev->fn = &backend_fns_usb;
    }

    else
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ usb.c:183] Using legacy packet handler format\n");
      while((_Bool)0);
  }

  else
  {
    dev->capabilities = dev->capabilities & (unsigned long int)~(1 << 4);
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ usb.c:187] Using legacy packet handler format due to env var\n");
    while((_Bool)0);
  }
  return status;
}

// print_device_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/doc/examples/open_via_serial.c line 67
static signed int print_device_state(struct bladerf *dev)
{
  signed int status;
  unsigned int frequency;
  unsigned int bandwidth;
  struct bladerf_rational_rate rate;
  status=bladerf_get_frequency(dev, (enum anonymous)BLADERF_MODULE_RX, &frequency);
  if(!(status == 0))
    return status;

  else
    printf("  RX frequency: %u Hz\n", frequency);
  status=bladerf_get_frequency(dev, (enum anonymous)BLADERF_MODULE_TX, &frequency);
  if(!(status == 0))
    return status;

  else
    printf("  TX frequency: %u Hz\n", frequency);
  status=bladerf_get_bandwidth(dev, (enum anonymous)BLADERF_MODULE_RX, &bandwidth);
  if(!(status == 0))
    return status;

  else
    printf("  RX bandwidth: %u Hz\n", bandwidth);
  status=bladerf_get_bandwidth(dev, (enum anonymous)BLADERF_MODULE_TX, &bandwidth);
  if(!(status == 0))
    return status;

  else
    printf("  TX bandwidth: %u Hz\n", bandwidth);
  status=bladerf_get_rational_sample_rate(dev, (enum anonymous)BLADERF_MODULE_RX, &rate);
  if(!(status == 0))
    return status;

  else
    printf("  RX sample rate: %lu %lu/%lu sps\n", rate.integer, rate.num, rate.den);
  status=bladerf_get_rational_sample_rate(dev, (enum anonymous)BLADERF_MODULE_TX, &rate);
  if(!(status == 0))
    return status;

  else
    printf("  TX sample rate: %lu %lu/%lu sps\n", rate.integer, rate.num, rate.den);
  return 0;
}

// probe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 53
static signed int probe(enum anonymous_15 target_device, struct bladerf_devinfo **devices)
{
  signed int ret;
  unsigned long int num_devices;
  struct bladerf_devinfo *devices_local;
  signed int status;
  status=backend_probe(target_device, &devices_local, &num_devices);
  if(!(status >= 0))
    ret = status;

  else
  {
    /* assertion num_devices <= 0x7fffffff */
    assert(num_devices <= (unsigned long int)0x7fffffff);
    ret = (signed int)num_devices;
    *devices = devices_local;
  }
  return ret;
}

// read_page
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 518
static inline signed int read_page(struct bladerf *dev, unsigned char read_operation, unsigned short int page, unsigned char *buf)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  signed int status;
  signed int op_status;
  unsigned short int read_size;
  unsigned short int offset;
  unsigned char request;
  if((signed int)dev->usb_speed == BLADERF_DEVICE_SPEED_SUPER)
    read_size = (unsigned short int)256;

  else
    if((signed int)dev->usb_speed == BLADERF_DEVICE_SPEED_HIGH)
      read_size = (unsigned short int)64;

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:534] Encountered unknown USB speed in %s\n", (const void *)"read_page");
      while((_Bool)0);
      return -1;
    }
  if((signed int)read_operation == 100 || (signed int)read_operation == 103)
  {
    status=vendor_cmd_int_windex(dev, read_operation, page, &op_status);
    if(!(status == 0))
      return status;

    else
      if(!(op_status == 0))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ usb.c:546] Firmware page read (op=%d) failed at page %u: %d\n", read_operation, page, op_status);
        while((_Bool)0);
        return -1;
      }

    request = (unsigned char)107;
  }

  else
    if((signed int)read_operation == 110)
      request = read_operation;

    else
    {
      /* assertion !"Bug - invalid read_operation value" */
      assert(!((_Bool)"Bug - invalid read_operation value"));
      return -1;
    }
  offset = (unsigned short int)0;
  if(!((signed int)offset >= 256))
  {
    status=usb->fn->control_transfer(driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, request, (unsigned short int)0, offset, (void *)(buf + (signed long int)offset), (unsigned int)read_size, (unsigned int)1000);
    if(!(status >= 0))
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:575] Failed to read page buffer at offset 0x%02x: %s\n", offset, return_value_bladerf_strerror_1);
      return status;
    }

    offset = offset + read_size;
  }

  return 0;
}

// read_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash_fields.c line 160
signed int read_serial(struct bladerf *dev, char *serial_buf)
{
  signed int status;
  status=get_otp_field(dev, "S", serial_buf, (unsigned long int)(33 - 1));
  if(!(status >= 0))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ flash_fields.c:167] Unable to fetch serial number. Defaulting to 0's.\n");
    while((_Bool)0);
    memset((void *)dev->ident.serial, 48, (unsigned long int)(33 - 1));
    status = 0;
  }

  serial_buf[(signed long int)(33 - 1)] = (char)0;
  return status;
}

// required_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 136
static inline void required_values(struct compat *entry, unsigned int *major, unsigned int *minor, unsigned int *patch)
{
  *major = (unsigned int)entry->requires.major;
  *minor = (unsigned int)entry->requires.minor;
  *patch = (unsigned int)entry->requires.patch;
}

// requires_timestamps
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.c line 317
static inline signed int requires_timestamps(enum anonymous_9 format, _Bool *required)
{
  signed int status = 0;
  switch((signed int)format)
  {
    case BLADERF_FORMAT_SC16_Q11_META:
    {
      *required = (_Bool)1;
      break;
    }
    case BLADERF_FORMAT_SC16_Q11:
    {
      *required = (_Bool)0;
      break;
    }
    default:
      return -3;
  }
  return status;
}

// reset_and_reopen
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 476
static signed int reset_and_reopen(struct libusb_context *context, struct bladerf_lusb **dev, struct bladerf_devinfo *info)
{
  signed int status;
  status=libusb_reset_device((*dev)->handle);
  if(status == 0)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:484] USB port reset succeeded for bladeRF %s\n", (const void *)info->serial);
    while((_Bool)0);
    return 0;
  }

  else
    if(status == -4)
    {
      struct bladerf_devinfo new_info;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:495] Re-scan required after port reset for bladeRF %s\n", (const void *)info->serial);
      while((_Bool)0);
      libusb_release_interface((*dev)->handle, 0);
      libusb_close((*dev)->handle);
      *dev = (struct bladerf_lusb *)(void *)0;
      memcpy((void *)&new_info, (const void *)info, sizeof(struct bladerf_devinfo) /*44ul*/ );
      new_info.usb_bus = (unsigned char)255;
      new_info.usb_addr = (unsigned char)255;
      status=find_and_open_device(context, &new_info, dev, info);
    }

    else
    {
      status = -5;
      do
      {
        const char *return_value_libusb_error_name_1;
        return_value_libusb_error_name_1=libusb_error_name(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ libusb.c:511] Port reset failed for bladerf %s: %s\n", (const void *)info->serial, return_value_libusb_error_name_1);
      }
      while((_Bool)0);
    }
  return status;
}

// restore_post_flash_setting
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 196
static signed int restore_post_flash_setting(struct bladerf *dev)
{
  signed int fpga_loaded;
  fpga_loaded=usb_is_fpga_configured(dev);
  signed int status;
  if(!(fpga_loaded >= 0))
  {
    status = fpga_loaded;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:203] Failed to determine if FPGA is loaded (%d)\n", fpga_loaded);
    while((_Bool)0);
  }

  else
    if(!(fpga_loaded == 0))
      status=change_setting(dev, (unsigned char)1);

    else
      status=change_setting(dev, (unsigned char)3);
  if(!(status >= 0))
    do
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:212] Failed to restore alt setting: %s\n", return_value_bladerf_strerror_1);
    }
    while((_Bool)0);

  return status;
}

// rx_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 41
static void * rx_callback(struct bladerf *dev, struct bladerf_stream *stream, struct bladerf_metadata *meta, void *samples, unsigned long int num_samples, void *user_data)
{
  unsigned int requests;
  unsigned int next_idx;
  unsigned int samples_idx;
  void *next_buf = (void *)0;
  struct bladerf_sync *s = (struct bladerf_sync *)user_data;
  struct sync_worker *w = s->worker;
  struct buffer_mgmt *b = &s->buf_mgmt;
  pthread_mutex_lock(&w->request_lock);
  requests = w->requests;
  pthread_mutex_unlock(&w->request_lock);
  if(!((2u & requests) == 0u))
    return (void *)0;

  else
  {
    pthread_mutex_lock(&b->lock);
    samples_idx=sync_buf2idx(b, samples);
    if(b->resubmit_count == 0u)
    {
      if((signed int)b->status[(signed long int)b->prod_i] == SYNC_BUFFER_EMPTY)
      {
        b->status[(signed long int)samples_idx] = (enum anonymous_21)SYNC_BUFFER_FULL;
        pthread_cond_signal(&b->buf_ready);
        next_idx = b->prod_i;
        b->status[(signed long int)next_idx] = (enum anonymous_21)SYNC_BUFFER_IN_FLIGHT;
        next_buf = b->buffers[(signed long int)next_idx];
        b->prod_i = (next_idx + (unsigned int)1) % b->num_buffers;
      }

      else
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync_worker.c:95] RX overrun @ buffer %u\r\n", samples_idx);
        while((_Bool)0);
        next_buf = samples;
        b->resubmit_count = s->stream_config.num_xfers - (unsigned int)1;
      }
    }

    else
    {
      next_buf = samples;
      b->resubmit_count = b->resubmit_count - 1u;
    }
    pthread_mutex_unlock(&b->lock);
    return next_buf;
  }
}

// samples2bytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 38
static inline unsigned long int samples2bytes(struct bladerf_sync *s, unsigned long int n)
{
  return s->stream_config.bytes_per_sample * n;
}

// samples_per_msg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 50
static inline unsigned int samples_per_msg(struct bladerf *dev, unsigned long int bytes_per_sample)
{
  unsigned long int n = (dev->msg_size - (sizeof(unsigned int) /*4ul*/  + sizeof(unsigned long int) /*8ul*/  + sizeof(unsigned int) /*4ul*/ )) / bytes_per_sample;
  /* assertion n <= (0x7fffffff * 2U + 1U) */
  assert(n <= (unsigned long int)((unsigned int)0x7fffffff * 2U + 1U));
  return (unsigned int)n;
}

// samples_to_bytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 163
static inline unsigned long int samples_to_bytes(enum anonymous_9 format, unsigned long int n)
{
  unsigned long int return_value_sc16q11_to_bytes_1;
  if((signed int)format == BLADERF_FORMAT_SC16_Q11 || (signed int)format == BLADERF_FORMAT_SC16_Q11_META)
  {
    return_value_sc16q11_to_bytes_1=sc16q11_to_bytes_link1(n);
    return return_value_sc16q11_to_bytes_1;
  }

  /* assertion !"Invalid format" */
  assert(!((_Bool)"Invalid format"));
  return (unsigned long int)0;
}

// sc16q11_to_bytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 155
static inline unsigned long int sc16q11_to_bytes(unsigned long int n_samples)
{
  const unsigned long int sample_size = (unsigned long int)2 * sizeof(signed short int) /*2ul*/ ;
  /* assertion n_samples <= ((18446744073709551615UL) / sample_size) */
  assert(n_samples <= 18446744073709551615UL / sample_size);
  return n_samples * sample_size;
}

// sc16q11_to_bytes_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf_priv.h line 155
static inline unsigned long int sc16q11_to_bytes_link1(unsigned long int n_samples_link1)
{
  const unsigned long int sample_size_link1 = (unsigned long int)2 * sizeof(signed short int) /*2ul*/ ;
  /* assertion n_samples <= ((18446744073709551615UL) / sample_size) */
  assert(n_samples_link1 <= 18446744073709551615UL / sample_size_link1);
  return n_samples_link1 * sample_size_link1;
}

// sc16q11_to_float
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 617
void sc16q11_to_float(const signed short int *in, float *out, unsigned int n)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 2u * n); i = i + (unsigned int)2)
  {
    out[(signed long int)i] = (float)in[(signed long int)i] * (1.0f / 2048.0f);
    out[(signed long int)(i + (unsigned int)1)] = (float)in[(signed long int)(i + (unsigned int)1)] * (1.0f / 2048.0f);
  }
}

// scale_dc_offset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3436
static inline unsigned char scale_dc_offset(enum anonymous module, signed short int value)
{
  unsigned char ret;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
    {
      value = value >> 5;
      if(!((signed int)value >= 0))
      {
        if(!((signed int)value >= -63))
          value = (signed short int)0x3f;

        else
          value = (signed short int)(-((signed int)value) & 0x3f);
        value = value | (signed short int)(1 << 6);
      }

      else
        if((signed int)value >= 64)
          value = (signed short int)0x3f;

        else
          value = (signed short int)((signed int)value & 0x3f);
      ret = (unsigned char)value;
      break;
    }
    case BLADERF_MODULE_TX:
    {
      value = value >> 4;
      if((signed int)value >= 0)
      {
        ret = (unsigned char)((unsigned char)((signed int)value >= 128) != 0 ? 0x7f : (signed int)value & 0x7f);
        ret = (unsigned char)(1 << 7 | (signed int)ret);
      }

      else
        ret = (unsigned char)((unsigned char)((signed int)value <= -128) != 0 ? 0x00 : (signed int)value & 0x7f);
      break;
    }
    default:
    {
      /* assertion !"Invalid module provided" */
      assert(!((_Bool)"Invalid module provided"));
      ret = (unsigned char)0x00;
    }
  }
  return ret;
}

// scan_fw_sections
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 115
static signed int scan_fw_sections(struct fx3_firmware *fw)
{
  signed int status = 0;
  _Bool done = (_Bool)0;
  unsigned int checksum = (unsigned int)0;
  unsigned int offset;
  unsigned int i;
  unsigned int next_section;
  unsigned int section_len_words;
  unsigned int section_len_bytes;
  const unsigned int checksum_off = (const unsigned int)((unsigned long int)fw->data_len - sizeof(unsigned int) /*4ul*/ );
  /* assertion checksum_off > 0x0c */
  assert(checksum_off > (unsigned int)0x0c);
  /* assertion (checksum_off % 4) == 0 */
  assert(checksum_off % (unsigned int)4 == (unsigned int)0);
  offset = (unsigned int)0x04;
  while(done == (_Bool)0)
  {
    section_len_words=to_uint32(fw, offset);
    if((unsigned long int)section_len_words >= 65537ul)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:142] Firmware section %u is unexpectedly large.\n", fw->num_sections);
      while((_Bool)0);
      status = -3;
      goto error;
    }

    else
    {
      section_len_bytes = (unsigned int)((unsigned long int)section_len_words * sizeof(unsigned int) /*4ul*/ );
      offset = offset + (unsigned int)sizeof(unsigned int) /*4ul*/ ;
    }
    if(section_len_bytes == 0u)
    {
      fw->entry_addr=to_uint32(fw, offset);
      _Bool return_value_is_valid_fx3_ram_addr_1;
      return_value_is_valid_fx3_ram_addr_1=is_valid_fx3_ram_addr(fw->entry_addr, (unsigned int)0);
      if(return_value_is_valid_fx3_ram_addr_1 == (_Bool)0)
      {
        status = -3;
        goto error;
      }

      offset = offset + (unsigned int)sizeof(unsigned int) /*4ul*/ ;
      done = (_Bool)1;
    }

    else
    {
      unsigned int section_start_offset = (unsigned int)((unsigned long int)offset - sizeof(unsigned int) /*4ul*/ );
      unsigned int addr;
      addr=to_uint32(fw, offset);
      _Bool return_value_is_valid_fx3_ram_addr_2;
      return_value_is_valid_fx3_ram_addr_2=is_valid_fx3_ram_addr(addr, section_len_bytes);
      if(return_value_is_valid_fx3_ram_addr_2 == (_Bool)0)
      {
        status = -3;
        goto error;
      }

      offset = offset + (unsigned int)sizeof(unsigned int) /*4ul*/ ;
      if(offset >= checksum_off)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:174] Firmware truncated after section address.\n");
        while((_Bool)0);
        status = -3;
        goto error;
      }

      next_section = offset + section_len_bytes;
      if(next_section >= checksum_off)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:183] Firmware truncated in section %u\n", fw->num_sections);
        while((_Bool)0);
        status = -3;
        goto error;
      }

      i = offset;
      for( ; !(i >= next_section); i = i + (unsigned int)sizeof(unsigned int) /*4ul*/ )
      {
        unsigned int return_value_to_uint32_3;
        return_value_to_uint32_3=to_uint32(fw, i);
        checksum = checksum + return_value_to_uint32_3;
      }
      offset = next_section;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ fx3_fw.c:196] Scanned section %u at offset 0x%08x: addr=0x%08x, len=0x%08x\n", fw->num_sections, section_start_offset, addr, section_len_words);
      while((_Bool)0);
      fw->num_sections = fw->num_sections + 1u;
    }
  }
  if(!(offset == checksum_off))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:203] Invalid offset or junk at the end of the firmware image.\n");
    while((_Bool)0);
    status = -3;
  }

  else
  {
    unsigned int expected_checksum;
    expected_checksum=to_uint32(fw, checksum_off);
    if(!(checksum == expected_checksum))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ fx3_fw.c:210] Bad checksum. Expected 0x%08x, got 0x%08x\n", expected_checksum, checksum);
      while((_Bool)0);
      status = -3;
    }

    else
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ fx3_fw.c:214] Firmware checksum OK.\n");
      while((_Bool)0);
      fw->section_offset = (unsigned int)0x04;
    }
  }

error:
  ;
  return status;
}

// set_dc_cal_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3065
static signed int set_dc_cal_value(struct bladerf *dev, unsigned char base, unsigned char dc_addr, signed short int value)
{
  signed int status;
  const unsigned char new_value = (unsigned char)value;
  unsigned char regval = (unsigned char)(0x08 | (signed int)dc_addr);
  status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 3), regval);
  if(!(status == 0))
    return status;

  else
  {
    status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 2), new_value);
    if(!(status == 0))
      return status;

    else
    {
      regval = regval | (unsigned char)(1 << 4);
      status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 3), regval);
      if(!(status == 0))
        return status;

      else
      {
        regval = regval & (unsigned char)~(1 << 4);
        status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 3), regval);
        if(!(status == 0))
          return status;

        else
        {
          status=dev->fn->lms_read(dev, base, &regval);
          if(!(status == 0))
            return status;

          else
            return 0;
        }
      }
    }
  }
}

// set_dc_offset_reg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 3492
static signed int set_dc_offset_reg(struct bladerf *dev, enum anonymous module, unsigned char addr, signed short int value)
{
  signed int status;
  unsigned char regval;
  unsigned char tmp;
  switch((signed int)module)
  {
    case BLADERF_MODULE_RX:
      status=dev->fn->lms_read(dev, addr, &tmp);
    case BLADERF_MODULE_TX:
    {
      regval=scale_dc_offset(module, value);
      break;
    }
    default:
      return -3;
  }
  status=dev->fn->lms_write(dev, addr, regval);
  return status;
}

// set_filterbank_mux
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.c line 304
static signed int set_filterbank_mux(struct bladerf *dev, enum anonymous module, enum anonymous_8 filter)
{
  signed int status;
  unsigned int orig;
  unsigned int val;
  unsigned int mask;
  unsigned int shift;
  /* assertion filter >= 0 */
  assert((signed int)filter >= 0);
  /* assertion filter < (sizeof(filters) / sizeof(filters[0])) */
  assert((unsigned long int)filter < sizeof(const char *[4l]) /*32ul*/  / sizeof(const char *) /*8ul*/ );
  if((signed int)module == BLADERF_MODULE_RX)
  {
    mask = (unsigned int)0x30000000;
    shift = (unsigned int)28;
  }

  else
  {
    mask = (unsigned int)0x0C000000;
    shift = (unsigned int)26;
  }
  status=dev->fn->expansion_gpio_read(dev, &orig);
  if(!(status == 0))
    return status;

  else
  {
    val = orig & ~mask;
    val = val | (unsigned int)((signed int)filter << shift);
    if(!(orig == val))
    {
      static const char *filters[4l] = { "50M", "144M", "222M", "custom" };
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:332] Engaging %s band XB-200 %s filter\n", filters[(signed long int)filter], mask == (unsigned int)0x0C000000 ? "TX" : "RX");
      status=dev->fn->expansion_gpio_write(dev, 0xffffffff, val);
      return status;
    }

    else
      return 0;
  }
}

// set_iq_correction
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/nios_legacy_access.c line 429
static signed int set_iq_correction(struct bladerf *dev, unsigned char addr, signed short int value)
{
  signed int i;
  signed int status;
  struct uart_cmd cmd;
  status = 0;
  i = status;
  for( ; status == 0 && !(i >= 2); i = i + 1)
  {
    cmd.addr = (unsigned char)(i + (signed int)addr);
    cmd.data = (unsigned char)((signed int)value >> i * 8 & 0xff);
    status=nios_access_link1(dev, (unsigned char)(0 << 4), (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, &cmd, (unsigned long int)1);
  }
  return status;
}

// set_rx_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.c line 42
static signed int set_rx_gain(struct bladerf *dev, signed int gain)
{
  if(!(gain >= 4))
  {
    signed int return_value_set_rx_gain_combo_1;
    return_value_set_rx_gain_combo_1=set_rx_gain_combo(dev, (enum anonymous_12)BLADERF_LNA_GAIN_BYPASS, 5, 0);
    return return_value_set_rx_gain_combo_1;
  }

  else
    if(!(gain >= 9))
    {
      signed int return_value_set_rx_gain_combo_2;
      return_value_set_rx_gain_combo_2=set_rx_gain_combo(dev, (enum anonymous_12)3, 5, 0);
      return return_value_set_rx_gain_combo_2;
    }

    else
      if(!(gain >= 37))
      {
        signed int return_value_set_rx_gain_combo_3;
        return_value_set_rx_gain_combo_3=set_rx_gain_combo(dev, (enum anonymous_12)BLADERF_LNA_GAIN_MID, gain - 3, 0);
        return return_value_set_rx_gain_combo_3;
      }

      else
        if(!(gain >= 30))
        {
          signed int return_value_set_rx_gain_combo_4;
          return_value_set_rx_gain_combo_4=set_rx_gain_combo(dev, (enum anonymous_12)BLADERF_LNA_GAIN_MAX, 30, gain - (6 + 30));
          return return_value_set_rx_gain_combo_4;
        }

        else
        {
          signed int return_value_set_rx_gain_combo_5;
          return_value_set_rx_gain_combo_5=set_rx_gain_combo(dev, (enum anonymous_12)BLADERF_LNA_GAIN_MAX, 30, 30);
          return return_value_set_rx_gain_combo_5;
        }
}

// set_rx_gain_combo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.c line 24
static inline signed int set_rx_gain_combo(struct bladerf *dev, enum anonymous_12 lnagain, signed int rxvga1, signed int rxvga2)
{
  signed int status;
  status=lms_lna_set_gain(dev, lnagain);
  if(!(status >= 0))
    return status;

  else
  {
    status=lms_rxvga1_set_gain(dev, rxvga1);
    if(!(status >= 0))
      return status;

    else
    {
      signed int return_value_lms_rxvga2_set_gain_1;
      return_value_lms_rxvga2_set_gain_1=lms_rxvga2_set_gain(dev, rxvga2);
      return return_value_lms_rxvga2_set_gain_1;
    }
  }
}

// set_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 369
static void set_state(struct sync_worker *w, enum anonymous_23 state)
{
  pthread_mutex_lock(&w->state_lock);
  w->state = state;
  pthread_cond_signal(&w->state_changed);
  pthread_mutex_unlock(&w->state_lock);
}

// set_tx_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.c line 84
static signed int set_tx_gain(struct bladerf *dev, signed int gain)
{
  signed int status;
  const signed int max_gain = (-4 - -35) + 25;
  if(!(gain >= 0))
    gain = 0;

  if(!(gain >= 26))
    status=set_tx_gain_combo(dev, -35, gain);

  else
    if(max_gain >= gain)
      status=set_tx_gain_combo(dev, (-35 + gain) - 25, 25);

    else
      status=set_tx_gain_combo(dev, -4, 25);
  return status;
}

// set_tx_gain_combo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/gain.c line 72
static inline signed int set_tx_gain_combo(struct bladerf *dev, signed int txvga1, signed int txvga2)
{
  signed int status;
  status=lms_txvga1_set_gain(dev, txvga1);
  if(status == 0)
    status=lms_txvga2_set_gain(dev, txvga2);

  return status;
}

// set_vctcxo_tamer_mode_unsupported
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1063
static signed int set_vctcxo_tamer_mode_unsupported(struct bladerf *dev, enum anonymous_16 mode)
{
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:1066] Operation not supported with legacy NIOS packet format.\n");
  while((_Bool)0);
  return -8;
}

// sha256_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 84
static void sha256_buffer(const char *buf, unsigned long int len, char *digest)
{
  struct SHA256Context ctx;
  SHA256_Init(&ctx);
  SHA256_Update(&ctx, (const void *)buf, len);
  SHA256_Final((unsigned char *)digest, &ctx);
}

// si5338_calculate_ms_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 326
static void si5338_calculate_ms_freq(struct si5338_multisynth *ms, struct bladerf_rational_rate *rate)
{
  struct bladerf_rational_rate abc;
  abc.integer = (unsigned long int)ms->a;
  abc.num = (unsigned long int)ms->b;
  abc.den = (unsigned long int)ms->c;
  rate->integer = (unsigned long int)0;
  rate->num = 38400000UL * 66UL * abc.den;
  rate->den = (unsigned long int)ms->r * (abc.integer * abc.den + abc.num);
  _Bool tmp_if_expr_1;
  if((signed int)ms->index == 1)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)ms->index == 2 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    rate->den = rate->den * (unsigned long int)2;

  si5338_rational_reduce(rate);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:347] Calculated multisynth frequency: %lu + %lu/%lu\n", rate->integer, rate->num, rate->den);
  while((_Bool)0);
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// si5338_calculate_multisynth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 352
static signed int si5338_calculate_multisynth(struct si5338_multisynth *ms, struct bladerf_rational_rate *rate)
{
  struct bladerf_rational_rate req;
  struct bladerf_rational_rate abc;
  unsigned char r_value;
  unsigned char r_power;
  req = *rate;
  _Bool tmp_if_expr_1;
  if((signed int)ms->index == 1)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)ms->index == 2 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    si5338_rational_double(&req);

  r_value = (unsigned char)1;
  r_power = (unsigned char)0;
  for( ; !(req.integer >= 5000000ul) && !((signed int)r_value >= 32); r_power = r_power + 1)
  {
    si5338_rational_double(&req);
    r_value = r_value << 1;
  }
  if((signed int)r_value == 32 && !(req.integer >= 5000000ul))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:380] Sample rate requires r > 32\n");
    while((_Bool)0);
    return -3;
  }

  else
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:383] Found r value of: %d\n", r_value);
    while((_Bool)0);
  abc.integer = (unsigned long int)0;
  abc.num = 38400000UL * 66UL * req.den;
  abc.den = req.integer * req.den + req.num;
  si5338_rational_reduce(&abc);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:393] MSx a + b/c: %lu + %lu/%lu\n", abc.integer, abc.num, abc.den);
  while((_Bool)0);
  if(!(abc.integer >= 8ul))
  {
    if(abc.integer == 0ul || abc.integer == 1ul || abc.integer == 2ul || abc.integer == 3ul || abc.integer == 5ul || abc.integer == 7ul)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:404] Integer portion too small: %lu\n", abc.integer);
      while((_Bool)0);
      return -3;
    }

  }

  else
    if(abc.integer >= 568ul)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:408] Integer portion too large: %lu\n", abc.integer);
      while((_Bool)0);
      return -3;
    }

  for( ; abc.den >= 1073741825ul || abc.num >= 1073741825ul; abc.den = abc.den >> 1)
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:416] Loss of precision in reducing fraction from %lu/%lu to %lu/%lu\n", abc.num, abc.den, abc.num >> 1, abc.den >> 1);
    while((_Bool)0);
    abc.num = abc.num >> 1;
  }
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:422] MSx a + b/c: %lu + %lu/%lu\n", abc.integer, abc.num, abc.den);
  while((_Bool)0);
  /* assertion abc.integer <= (4294967295U) */
  assert(abc.integer <= (unsigned long int)4294967295U);
  /* assertion abc.num <= (4294967295U) */
  assert(abc.num <= (unsigned long int)4294967295U);
  /* assertion abc.den <= (4294967295U) */
  assert(abc.den <= (unsigned long int)4294967295U);
  ms->a = (unsigned int)abc.integer;
  ms->b = (unsigned int)abc.num;
  ms->c = (unsigned int)abc.den;
  ms->r = (unsigned int)r_value;
  si5338_pack_regs(ms);
  return 0;
}

// si5338_gcd
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 85
static unsigned long int si5338_gcd(unsigned long int a, unsigned long int b)
{
  unsigned long int t;
  for( ; !(b == 0ul); a = t)
  {
    t = b;
    b = a % t;
  }
  return a;
}

// si5338_get_rational_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 41
signed int si5338_get_rational_sample_rate(struct bladerf *dev, enum anonymous module, struct bladerf_rational_rate *rate)
{
  struct si5338_multisynth ms;
  signed int status;
  ms.index = (unsigned char)((signed int)module == BLADERF_MODULE_RX ? 1 : 2);
  si5338_update_base(&ms);
  status=si5338_read_multisynth(dev, &ms);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    si5338_read_error(status, return_value_bladerf_strerror_1);
    return status;
  }

  si5338_calculate_ms_freq(&ms, rate);
  return 0;
}

// si5338_get_rational_smb_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 45
signed int si5338_get_rational_smb_freq(struct bladerf *dev, struct bladerf_rational_rate *rate)
{
  struct si5338_multisynth ms;
  signed int status;
  ms.index = (unsigned char)3;
  si5338_update_base(&ms);
  status=si5338_read_multisynth(dev, &ms);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    si5338_read_error(status, return_value_bladerf_strerror_1);
    return status;
  }

  si5338_calculate_ms_freq(&ms, rate);
  return 0;
}

// si5338_get_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 39
signed int si5338_get_sample_rate(struct bladerf *dev, enum anonymous module, unsigned int *rate)
{
  struct bladerf_rational_rate actual;
  signed int status;
  status=si5338_get_rational_sample_rate(dev, module, &actual);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    si5338_read_error(status, return_value_bladerf_strerror_1);
    return status;
  }

  if(!(actual.num == 0ul))
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:638] Fractional sample rate truncated during integer sample rateretrieval\n");
    while((_Bool)0);

  /* assertion actual.integer <= (0x7fffffff * 2U + 1U) */
  assert(actual.integer <= (unsigned long int)((unsigned int)0x7fffffff * 2U + 1U));
  *rate = (unsigned int)actual.integer;
  return 0;
}

// si5338_get_smb_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 43
signed int si5338_get_smb_freq(struct bladerf *dev, unsigned int *rate)
{
  struct bladerf_rational_rate actual;
  signed int status;
  status=si5338_get_rational_smb_freq(dev, &actual);
  if(!(status == 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    si5338_read_error(status, return_value_bladerf_strerror_1);
    return status;
  }

  if(!(actual.num == 0ul))
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:661] Fractional SMB frequency truncated during integer SMB frequency retrieval\n");
    while((_Bool)0);

  /* assertion actual.integer <= (0x7fffffff * 2U + 1U) */
  assert(actual.integer <= (unsigned long int)((unsigned int)0x7fffffff * 2U + 1U));
  *rate = (unsigned int)actual.integer;
  return 0;
}

// si5338_pack_regs
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 181
static void si5338_pack_regs(struct si5338_multisynth *ms)
{
  unsigned long int temp = (unsigned long int)ms->a * (unsigned long int)ms->c + (unsigned long int)ms->b;
  temp = temp * (unsigned long int)128;
  temp = temp / (unsigned long int)ms->c - (unsigned long int)512;
  /* assertion temp <= (4294967295U) */
  assert(temp <= (unsigned long int)4294967295U);
  ms->p1 = (unsigned int)temp;
  temp = (unsigned long int)ms->b * (unsigned long int)128;
  temp = temp % (unsigned long int)ms->c;
  /* assertion temp <= (4294967295U) */
  assert(temp <= (unsigned long int)4294967295U);
  ms->p2 = (unsigned int)temp;
  ms->p3 = ms->c;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:211] MSx P1: 0x%8.8x (%u) P2: 0x%8.8x (%u) P3: 0x%8.8x (%u)\n", ms->p1, ms->p1, ms->p2, ms->p2, ms->p3, ms->p3);
  while((_Bool)0);
  ms->regs[(signed long int)0] = (unsigned char)(ms->p1 & (unsigned int)0xff);
  ms->regs[(signed long int)1] = (unsigned char)(ms->p1 >> 8 & (unsigned int)0xff);
  ms->regs[(signed long int)2] = (unsigned char)((ms->p2 & (unsigned int)0x3f) << 2 | ms->p1 >> 16 & (unsigned int)0x3);
  ms->regs[(signed long int)3] = (unsigned char)(ms->p2 >> 6 & (unsigned int)0xff);
  ms->regs[(signed long int)4] = (unsigned char)(ms->p2 >> 14 & (unsigned int)0xff);
  ms->regs[(signed long int)5] = (unsigned char)(ms->p2 >> 22 & (unsigned int)0xff);
  ms->regs[(signed long int)6] = (unsigned char)(ms->p3 & (unsigned int)0xff);
  ms->regs[(signed long int)7] = (unsigned char)(ms->p3 >> 8 & (unsigned int)0xff);
  ms->regs[(signed long int)8] = (unsigned char)(ms->p3 >> 16 & (unsigned int)0xff);
  ms->regs[(signed long int)9] = (unsigned char)(ms->p3 >> 24 & (unsigned int)0xff);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// si5338_rational_double
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 117
static void si5338_rational_double(struct bladerf_rational_rate *r)
{
  r->integer = r->integer * (unsigned long int)2;
  r->num = r->num * (unsigned long int)2;
  si5338_rational_reduce(r);
}

// si5338_rational_reduce
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 96
static void si5338_rational_reduce(struct bladerf_rational_rate *r)
{
  signed long int val;
  if(r->den >= 1ul)
  {
    if(r->num >= r->den)
    {
      unsigned long int whole = r->num / r->den;
      r->integer = r->integer + whole;
      r->num = r->num - whole * r->den;
    }

  }

  unsigned long int return_value_si5338_gcd_1;
  return_value_si5338_gcd_1=si5338_gcd(r->num, r->den);
  val = (signed long int)return_value_si5338_gcd_1;
  if(val >= 1l)
  {
    r->num = r->num / (unsigned long int)val;
    r->den = r->den / (unsigned long int)val;
  }

  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// si5338_read_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 73
void si5338_read_error(signed int error, const char *s)
{
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:75] Could not read from si5338 (%d): %s\n", error, s);
  while((_Bool)0);
}

// si5338_read_multisynth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 282
static signed int si5338_read_multisynth(struct bladerf *dev, struct si5338_multisynth *ms)
{
  signed int i;
  signed int status;
  unsigned char val;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:288] Reading MS%d\n", ms->index);
  while((_Bool)0);
  status=dev->fn->si5338_read(dev, (unsigned char)(36 + (signed int)ms->index), &val);
  if(!(status >= 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    si5338_read_error(status, return_value_bladerf_strerror_1);
    return status;
  }

  ms->enable = (unsigned char)((signed int)val & 7);
  log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:297] Read enable register: 0x%2.2x\n", val);
  i = 0;
  if(!(i >= 10))
  {
    status=dev->fn->si5338_read(dev, (unsigned char)((signed int)ms->base + i), ms->regs + (signed long int)i);
    if(!(status >= 0))
    {
      const char *return_value_bladerf_strerror_2;
      return_value_bladerf_strerror_2=bladerf_strerror(status);
      si5338_read_error(status, return_value_bladerf_strerror_2);
      return status;
    }

    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:306] Read regs[%d]: 0x%2.2x\n", i, ms->regs[(signed long int)i]);
    i = i + 1;
  }

  status=dev->fn->si5338_read(dev, (unsigned char)(31 + (signed int)ms->index), &val);
  if(!(status >= 0))
  {
    const char *return_value_bladerf_strerror_3;
    return_value_bladerf_strerror_3=bladerf_strerror(status);
    si5338_read_error(status, return_value_bladerf_strerror_3);
    return status;
  }

  log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:316] Read r register: 0x%2.2x\n", val);
  val = (unsigned char)((signed int)val >> 2 & 7);
  ms->r = (unsigned int)(1 << (signed int)val);
  si5338_unpack_regs(ms);
  return 0;
}

// si5338_set_rational_multisynth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 477
signed int si5338_set_rational_multisynth(struct bladerf *dev, unsigned char index, unsigned char channel, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual_ret)
{
  struct si5338_multisynth ms;
  struct bladerf_rational_rate req;
  struct bladerf_rational_rate actual;
  signed int status;
  si5338_rational_reduce(rate);
  req = *rate;
  ms.index = index;
  ms.enable = channel;
  si5338_update_base(&ms);
  status=si5338_calculate_multisynth(&ms, &req);
  if(!(status == 0))
    return status;

  else
  {
    si5338_calculate_ms_freq(&ms, &actual);
    if(!(actual_ret == ((struct bladerf_rational_rate *)NULL)))
      memcpy((void *)actual_ret, (const void *)&actual, sizeof(struct bladerf_rational_rate) /*24ul*/ );

    status=si5338_write_multisynth(dev, &ms);
    return status;
  }
}

// si5338_set_rational_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 40
signed int si5338_set_rational_sample_rate(struct bladerf *dev, enum anonymous module, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual)
{
  unsigned char index = (unsigned char)((signed int)module == BLADERF_MODULE_RX ? 1 : 2);
  unsigned char channel = (unsigned char)0x01;
  si5338_rational_reduce(rate);
  if(!(rate->integer >= 80000ul))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:449] %s: provided sample rate violates minimum\n", (const void *)"si5338_set_rational_sample_rate");
    while((_Bool)0);
    return -3;
  }

  else
  {
    if((signed int)module == BLADERF_MODULE_TX)
      channel = channel | (unsigned char)0x02;

    signed int return_value_si5338_set_rational_multisynth_1;
    return_value_si5338_set_rational_multisynth_1=si5338_set_rational_multisynth(dev, index, channel, rate, actual);
    return return_value_si5338_set_rational_multisynth_1;
  }
}

// si5338_set_rational_smb_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 44
signed int si5338_set_rational_smb_freq(struct bladerf *dev, struct bladerf_rational_rate *rate, struct bladerf_rational_rate *actual)
{
  si5338_rational_reduce(rate);
  if(!(rate->integer >= 139682ul))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:467] %s: provided SMB freq violates minimum\n", (const void *)"si5338_set_rational_smb_freq");
    while((_Bool)0);
    return -3;
  }

  else
    if(rate->integer >= 200000001ul)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:470] %s: provided SMB freq violates maximum\n", (const void *)"si5338_set_rational_smb_freq");
      while((_Bool)0);
      return -3;
    }

  signed int return_value_si5338_set_rational_multisynth_1;
  return_value_si5338_set_rational_multisynth_1=si5338_set_rational_multisynth(dev, (unsigned char)3, (unsigned char)0x01, rate, actual);
  return return_value_si5338_set_rational_multisynth_1;
}

// si5338_set_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 38
signed int si5338_set_sample_rate(struct bladerf *dev, enum anonymous module, unsigned int rate, unsigned int *actual)
{
  struct bladerf_rational_rate req;
  struct bladerf_rational_rate act;
  signed int status;
  memset((void *)&act, 0, sizeof(struct bladerf_rational_rate) /*24ul*/ );
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:525] Setting integer sample rate: %d\n", rate);
  while((_Bool)0);
  req.integer = (unsigned long int)rate;
  req.num = (unsigned long int)0;
  req.den = (unsigned long int)1;
  status=si5338_set_rational_sample_rate(dev, module, &req, &act);
  if(status == 0 && !(act.num == 0ul))
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ si5338.c:534] Non-integer sample rate set from integer sample rate, truncating output.\n");
    while((_Bool)0);

  /* assertion act.integer <= (4294967295U) */
  assert(act.integer <= (unsigned long int)4294967295U);
  if(!(actual == ((unsigned int *)NULL)))
    *actual = (unsigned int)act.integer;

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:542] Set actual integer sample rate: %d\n", act.integer);
  while((_Bool)0);
  return status;
}

// si5338_set_smb_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.h line 42
signed int si5338_set_smb_freq(struct bladerf *dev, unsigned int rate, unsigned int *actual)
{
  struct bladerf_rational_rate req;
  struct bladerf_rational_rate act;
  signed int status;
  memset((void *)&act, 0, sizeof(struct bladerf_rational_rate) /*24ul*/ );
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:553] Setting integer SMB frequency: %d\n", rate);
  while((_Bool)0);
  req.integer = (unsigned long int)rate;
  req.num = (unsigned long int)0;
  req.den = (unsigned long int)1;
  status=si5338_set_rational_smb_freq(dev, &req, &act);
  if(status == 0 && !(act.num == 0ul))
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ si5338.c:562] Non-integer SMB frequency set from integer frequency, truncating output.\n");
    while((_Bool)0);

  /* assertion act.integer <= (4294967295U) */
  assert(act.integer <= (unsigned long int)4294967295U);
  if(!(actual == ((unsigned int *)NULL)))
    *actual = (unsigned int)act.integer;

  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:570] Set actual integer SMB frequency: %d\n", act.integer);
  while((_Bool)0);
  return status;
}

// si5338_unpack_regs
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 143
static void si5338_unpack_regs(struct si5338_multisynth *ms)
{
  unsigned long int temp;
  ms->p3 = (unsigned int)0;
  ms->p2 = ms->p3;
  ms->p1 = ms->p2;
  ms->p1 = (unsigned int)(((signed int)ms->regs[(signed long int)2] & 3) << 16 | (signed int)ms->regs[(signed long int)1] << 8 | (signed int)ms->regs[(signed long int)0]);
  ms->p2 = (unsigned int)((signed int)ms->regs[(signed long int)5] << 22 | (signed int)ms->regs[(signed long int)4] << 14 | (signed int)ms->regs[(signed long int)3] << 6 | (signed int)ms->regs[(signed long int)2] >> 2 & 0x3f);
  ms->p3 = (unsigned int)(((signed int)ms->regs[(signed long int)9] & 0x3f) << 24 | (signed int)ms->regs[(signed long int)8] << 16 | (signed int)ms->regs[(signed long int)7] << 8 | (signed int)ms->regs[(signed long int)6]);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:156] Unpacked P1: 0x%8.8x (%u) P2: 0x%8.8x (%u) P3: 0x%8.8x (%u)\n", ms->p1, ms->p1, ms->p2, ms->p2, ms->p3, ms->p3);
  while((_Bool)0);
  ms->c = ms->p3;
  ms->a = (ms->p1 + (unsigned int)512) / (unsigned int)128;
  temp = (unsigned long int)(ms->p1 + (unsigned int)512) - (unsigned long int)128 * (unsigned long int)ms->a;
  temp = temp * (unsigned long int)ms->c + (unsigned long int)ms->p2;
  temp = (temp + (unsigned long int)64) / (unsigned long int)128;
  /* assertion temp <= (4294967295U) */
  assert(temp <= (unsigned long int)4294967295U);
  ms->b = (unsigned int)temp;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:174] Unpacked a + b/c: %d + %d/%d\n", ms->a, ms->b, ms->c);
  while((_Bool)0);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:175] Unpacked r: %d\n", ms->r);
  while((_Bool)0);
}

// si5338_update_base
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 128
static void si5338_update_base(struct si5338_multisynth *ms)
{
  ms->base = (unsigned short int)(53 + (signed int)ms->index * 11);
}

// si5338_write_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 79
void si5338_write_error(signed int error, const char *s)
{
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ si5338.c:81] Could not write to si5338 (%d): %s\n", error, s);
  while((_Bool)0);
}

// si5338_write_multisynth
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/si5338.c line 228
static signed int si5338_write_multisynth(struct bladerf *dev, struct si5338_multisynth *ms)
{
  signed int i;
  signed int status;
  unsigned char r_power;
  unsigned char r_count;
  unsigned char val;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:234] Writing MS%d\n", ms->index);
  while((_Bool)0);
  status=dev->fn->si5338_read(dev, (unsigned char)(36 + (signed int)ms->index), &val);
  if(!(status >= 0))
  {
    const char *return_value_bladerf_strerror_1;
    return_value_bladerf_strerror_1=bladerf_strerror(status);
    si5338_read_error(status, return_value_bladerf_strerror_1);
    return status;
  }

  val = val | ms->enable;
  log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:243] Wrote enable register: 0x%2.2x\n", val);
  status=dev->fn->si5338_write(dev, (unsigned char)(36 + (signed int)ms->index), val);
  if(!(status >= 0))
  {
    const char *return_value_bladerf_strerror_2;
    return_value_bladerf_strerror_2=bladerf_strerror(status);
    si5338_write_error(status, return_value_bladerf_strerror_2);
    return status;
  }

  i = 0;
  if(!(i >= 10))
  {
    status=dev->fn->si5338_write(dev, (unsigned char)((signed int)ms->base + i), ms->regs[(signed long int)i]);
    if(!(status >= 0))
    {
      const char *return_value_bladerf_strerror_3;
      return_value_bladerf_strerror_3=bladerf_strerror(status);
      si5338_write_error(status, return_value_bladerf_strerror_3);
      return status;
    }

    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:257] Wrote regs[%d]: 0x%2.2x\n", i, ms->regs[(signed long int)i]);
    i = i + 1;
  }

  r_power = (unsigned char)0;
  r_count = (unsigned char)(ms->r >> 1);
  if((signed int)r_count >= 1)
  {
    r_count = r_count >> 1;
    r_power = r_power + 1;
  }

  val = (unsigned char)0xc0;
  val = val | (unsigned char)((signed int)r_power << 2);
  log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ si5338.c:272] Wrote r register: 0x%2.2x\n", val);
  status=dev->fn->si5338_write(dev, (unsigned char)(31 + (signed int)ms->index), val);
  if(!(status >= 0))
  {
    const char *return_value_bladerf_strerror_4;
    return_value_bladerf_strerror_4=bladerf_strerror(status);
    si5338_write_error(status, return_value_bladerf_strerror_4);
  }

  return status;
}

// str2args
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 420
signed int str2args(const char *line, char comment_char, char ***argv_ret)
{
  signed int line_i;
  signed int arg_i;
  signed int argv_size = 10;
  signed int arg_size;
  char **argv;
  signed int argc;
  enum str2args_parse_state state = (enum str2args_parse_state)PARSE_STATE_IN_SPACE;
  unsigned long int line_len;
  line_len=strlen(line);
  _Bool got_eol_comment = (_Bool)0;
  arg_i = 0;
  argc = arg_i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)argv_size * sizeof(char *) /*8ul*/ );
  argv = (char **)return_value_malloc_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  const unsigned short int **return_value___ctype_b_loc_6;
  if(argv == ((char **)NULL))
    return -1;

  else
  {
    zero_argvs(0, argv_size - 1, argv);
    arg_size = 0;
    line_i = 0;
    while(got_eol_comment == (_Bool)0 && !((signed int)state == PARSE_STATE_ERROR) && !((unsigned long int)line_i >= line_len))
      switch((signed int)state)
      {
        case PARSE_STATE_IN_SPACE:
        {
          return_value___ctype_b_loc_2=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)line[(signed long int)line_i]]) == 0)
          {
            if(line[(signed long int)line_i] == comment_char)
              got_eol_comment = (_Bool)1;

            else
              state = (enum str2args_parse_state)PARSE_STATE_START_ARG;
          }

          else
            line_i = line_i + 1;
          break;
        }
        case PARSE_STATE_START_ARG:
        {
          if(argc >= argv_size)
          {
            void *tmp;
            argv_size = argv_size + argv_size / 2;
            tmp=realloc((void *)argv, (unsigned long int)argv_size);
            if(!(tmp == NULL))
            {
              argv = (char **)tmp;
              zero_argvs(argc, argv_size - 1, argv);
            }

            else
              state = (enum str2args_parse_state)PARSE_STATE_ERROR;
          }

          if(!((signed int)state == PARSE_STATE_ERROR))
          {
            arg_i = 0;
            arg_size = 32;
            void *return_value_calloc_3;
            return_value_calloc_3=calloc((unsigned long int)arg_size, (unsigned long int)1);
            argv[(signed long int)argc] = (char *)return_value_calloc_3;
            if(argv[(signed long int)argc] == ((char *)NULL))
            {
              state = (enum str2args_parse_state)PARSE_STATE_ERROR;
              break;
            }

            if((signed int)line[(signed long int)line_i] == 34)
              state = (enum str2args_parse_state)PARSE_STATE_IN_QUOTE;

            else
            {
              signed int return_value_append_char_4;
              return_value_append_char_4=append_char(&argv[(signed long int)argc], &arg_size, &arg_i, line[(signed long int)line_i]);
              if(!(return_value_append_char_4 == 0))
                state = (enum str2args_parse_state)PARSE_STATE_ERROR;

              else
                state = (enum str2args_parse_state)PARSE_STATE_IN_ARG;
            }
            argc = argc + 1;
            line_i = line_i + 1;
          }

          break;
        }
        case PARSE_STATE_IN_ARG:
        {
          return_value___ctype_b_loc_6=__ctype_b_loc();
          if(!((8192 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)(unsigned char)line[(signed long int)line_i]]) == 0))
            state = (enum str2args_parse_state)PARSE_STATE_IN_SPACE;

          else
            if((signed int)line[(signed long int)line_i] == 34)
              state = (enum str2args_parse_state)PARSE_STATE_IN_QUOTE;

            else
              if(line[(signed long int)line_i] == comment_char)
                got_eol_comment = (_Bool)1;

              else
              {
                signed int return_value_append_char_5;
                return_value_append_char_5=append_char(&argv[(signed long int)(argc - 1)], &arg_size, &arg_i, line[(signed long int)line_i]);
                if(!(return_value_append_char_5 == 0))
                  state = (enum str2args_parse_state)PARSE_STATE_ERROR;

              }
          line_i = line_i + 1;
          break;
        }
        case PARSE_STATE_IN_QUOTE:
        {
          if((signed int)line[(signed long int)line_i] == 34)
            state = (enum str2args_parse_state)PARSE_STATE_IN_ARG;

          else
          {
            signed int return_value_append_char_7;
            return_value_append_char_7=append_char(&argv[(signed long int)(argc - 1)], &arg_size, &arg_i, line[(signed long int)line_i]);
            if(!(return_value_append_char_7 == 0))
              state = (enum str2args_parse_state)PARSE_STATE_ERROR;

          }
          line_i = line_i + 1;
          break;
        }
        case PARSE_STATE_ERROR:
          ;
      }
    switch((signed int)state)
    {
      case PARSE_STATE_IN_SPACE:

      case PARSE_STATE_IN_ARG:
      {
        *argv_ret = argv;
        break;
      }
      case PARSE_STATE_IN_QUOTE:
      {
        free_args(argc, argv);
        argc = -2;
        break;
      }
      default:
      {
        free_args(argc, argv);
        argc = -1;
      }
    }
    return argc;
  }
}

// str2backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/backend.c line 148
signed int str2backend(const char *str, enum anonymous_11 *backend)
{
  signed int status = 0;
  signed int return_value_strcasecmp_4;
  return_value_strcasecmp_4=strcasecmp("libusb", str);
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if(return_value_strcasecmp_4 == 0)
    *backend = (enum anonymous_11)BLADERF_BACKEND_LIBUSB;

  else
  {
    return_value_strcasecmp_3=strcasecmp("linux", str);
    if(return_value_strcasecmp_3 == 0)
      *backend = (enum anonymous_11)BLADERF_BACKEND_LINUX;

    else
    {
      return_value_strcasecmp_2=strcasecmp("cypress", str);
      if(return_value_strcasecmp_2 == 0)
        *backend = (enum anonymous_11)BLADERF_BACKEND_CYPRESS;

      else
      {
        return_value_strcasecmp_1=strcasecmp("*", str);
        if(return_value_strcasecmp_1 == 0)
          *backend = (enum anonymous_11)BLADERF_BACKEND_ANY;

        else
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ backend.c:161] Invalid backend: %s\n", str);
          while((_Bool)0);
          status = -3;
          *backend = (enum anonymous_11)BLADERF_BACKEND_ANY;
        }
      }
    }
  }
  return status;
}

// str2dbl_suffix
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 163
double str2dbl_suffix(const char *str, double min, double max, struct numeric_suffix *suffixes, unsigned long int num_suffixes, _Bool *ok)
{
  double value;
  char *endptr;
  unsigned long int i;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  value=strtod(str, &endptr);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  _Bool tmp_if_expr_6;
  float return_value___builtin_inff_5;
  if(endptr == str || !(*return_value___errno_location_2 == 0))
  {
    if(!(ok == ((_Bool *)NULL)))
      *ok = (_Bool)0;

    return (double)0;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= num_suffixes); i = i + 1ul)
    {
      signed int return_value_strcasecmp_3;
      return_value_strcasecmp_3=strcasecmp(endptr, (suffixes + (signed long int)i)->suffix);
      if(return_value_strcasecmp_3 == 0)
      {
        value = value * (double)(suffixes + (signed long int)i)->multiplier;
        break;
      }

    }
    float return_value___builtin_inff_4;
    return_value___builtin_inff_4=__builtin_inff();
    if(IEEE_FLOAT_EQUAL(value, (double)return_value___builtin_inff_4))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value___builtin_inff_5=__builtin_inff();
      tmp_if_expr_6 = IEEE_FLOAT_EQUAL(value, (double)-return_value___builtin_inff_5) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      if(!(ok == ((_Bool *)NULL)))
        *ok = (_Bool)0;

      return (double)0;
    }

    else
      if(value < min || value > max)
      {
        if(!(ok == ((_Bool *)NULL)))
          *ok = (_Bool)0;

        return (double)0;
      }

      else
      {
        if(!(ok == ((_Bool *)NULL)))
          *ok = (_Bool)1;

        return value;
      }
  }
}

// str2devinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/device_identifier.h line 41
signed int str2devinfo(const char *dev_id_const, struct bladerf_devinfo *d)
{
  char *dev_id = (char *)(void *)0;
  char *token = (char *)(void *)0;
  char *arg = (char *)(void *)0;
  char *val = (char *)(void *)0;
  char *saveptr = (char *)(void *)0;
  signed int status = -1;
  signed int arg_status = -1;
  /* assertion d */
  assert(d != ((struct bladerf_devinfo *)NULL));
  bladerf_init_devinfo(d);
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(dev_id_const == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen(dev_id_const);
    tmp_if_expr_2 = return_value_strlen_1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    dev_id=strdup(dev_id_const);
    if(dev_id == ((char *)NULL))
      return -4;

    else
    {
      token=strtok_r(dev_id, ":", &saveptr);
      if(!(token == ((char *)NULL)))
      {
        status=handle_backend(token, d);
        arg_status = 1;
        while(arg_status == 1 && status == 0)
        {
          arg_status=next_arg(&saveptr, &arg, &val);
          if(arg_status == 1)
          {
            signed int return_value_strcasecmp_5;
            return_value_strcasecmp_5=strcasecmp("device", arg);
            if(return_value_strcasecmp_5 == 0)
              status=handle_device(d, val);

            else
            {
              return_value_strcasecmp_4=strcasecmp("instance", arg);
              if(return_value_strcasecmp_4 == 0)
                status=handle_instance(d, val);

              else
              {
                return_value_strcasecmp_3=strcasecmp("serial", arg);
                if(return_value_strcasecmp_3 == 0)
                  status=handle_serial(d, val);

                else
                  arg_status = -3;
              }
            }
          }

        }
        if(!(arg_status >= 0))
          status = arg_status;

      }

      else
        status = -3;
      free((void *)dev_id);
      return status;
    }
  }
}

// str2double
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 118
double str2double(const char *str, double min, double max, _Bool *ok)
{
  double value;
  char *endptr;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  value=strtod(str, &endptr);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  _Bool tmp_if_expr_3;
  if(value < min || endptr == str || value > max || !(*return_value___errno_location_2 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    if(!(ok == ((_Bool *)NULL)))
      *ok = (_Bool)0;

    return (double)0;
  }

  else
  {
    if(!(ok == ((_Bool *)NULL)))
      *ok = (_Bool)1;

    return value;
  }
}

// str2int
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 43
signed int str2int(const char *str, signed int min, signed int max, _Bool *ok)
{
  signed long int value;
  char *endptr;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  value=strtol(str, &endptr, 0);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  _Bool tmp_if_expr_3;
  if(endptr == str || !(*return_value___errno_location_2 == 0) || !(value >= (signed long int)min) || !((signed long int)max >= value))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    if(!(ok == ((_Bool *)NULL)))
      *ok = (_Bool)0;

    return 0;
  }

  else
  {
    if(!(ok == ((_Bool *)NULL)))
      *ok = (_Bool)1;

    return (signed int)value;
  }
}

// str2lnagain
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 572
signed int str2lnagain(const char *str, enum anonymous_12 *gain)
{
  *gain = (enum anonymous_12)BLADERF_LNA_GAIN_MAX;
  signed int return_value_strcasecmp_7;
  return_value_strcasecmp_7=strcasecmp("max", str);
  _Bool tmp_if_expr_9;
  signed int return_value_strcasecmp_8;
  if(return_value_strcasecmp_7 == 0)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_strcasecmp_8=strcasecmp("BLADERF_LNA_GAIN_MAX", str);
    tmp_if_expr_9 = !(return_value_strcasecmp_8 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcasecmp_4;
  _Bool tmp_if_expr_6;
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcasecmp_2;
  if(tmp_if_expr_9)
  {
    *gain = (enum anonymous_12)BLADERF_LNA_GAIN_MAX;
    return 0;
  }

  else
  {
    return_value_strcasecmp_4=strcasecmp("mid", str);
    if(return_value_strcasecmp_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strcasecmp_5=strcasecmp("BLADERF_LNA_GAIN_MID", str);
      tmp_if_expr_6 = !(return_value_strcasecmp_5 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      *gain = (enum anonymous_12)BLADERF_LNA_GAIN_MID;
      return 0;
    }

    else
    {
      return_value_strcasecmp_1=strcasecmp("bypass", str);
      if(return_value_strcasecmp_1 == 0)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_strcasecmp_2=strcasecmp("BLADERF_LNA_GAIN_BYPASS", str);
        tmp_if_expr_3 = !(return_value_strcasecmp_2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
      {
        *gain = (enum anonymous_12)BLADERF_LNA_GAIN_BYPASS;
        return 0;
      }

      else
      {
        *gain = (enum anonymous_12)BLADERF_LNA_GAIN_UNKNOWN;
        return -1;
      }
    }
  }
}

// str2loglevel
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/conversions.h line 215
enum anonymous_26 str2loglevel(const char *str, _Bool *ok)
{
  enum anonymous_26 level = (enum anonymous_26)BLADERF_LOG_LEVEL_ERROR;
  _Bool valid = (_Bool)1;
  signed int return_value_strcasecmp_6;
  return_value_strcasecmp_6=strcasecmp(str, "critical");
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if(return_value_strcasecmp_6 == 0)
    level = (enum anonymous_26)BLADERF_LOG_LEVEL_CRITICAL;

  else
  {
    return_value_strcasecmp_5=strcasecmp(str, "error");
    if(return_value_strcasecmp_5 == 0)
      level = (enum anonymous_26)BLADERF_LOG_LEVEL_ERROR;

    else
    {
      return_value_strcasecmp_4=strcasecmp(str, "warning");
      if(return_value_strcasecmp_4 == 0)
        level = (enum anonymous_26)BLADERF_LOG_LEVEL_WARNING;

      else
      {
        return_value_strcasecmp_3=strcasecmp(str, "info");
        if(return_value_strcasecmp_3 == 0)
          level = (enum anonymous_26)BLADERF_LOG_LEVEL_INFO;

        else
        {
          return_value_strcasecmp_2=strcasecmp(str, "debug");
          if(return_value_strcasecmp_2 == 0)
            level = (enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG;

          else
          {
            return_value_strcasecmp_1=strcasecmp(str, "verbose");
            if(return_value_strcasecmp_1 == 0)
              level = (enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE;

            else
              valid = (_Bool)0;
          }
        }
      }
    }
  }
  *ok = valid;
  return level;
}

// str2loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 393
signed int str2loopback(const char *str, enum anonymous_3 *loopback)
{
  signed int status = 0;
  signed int return_value_strcasecmp_8;
  return_value_strcasecmp_8=strcasecmp("bb_txlpf_rxvga2", str);
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if(return_value_strcasecmp_8 == 0)
    *loopback = (enum anonymous_3)BLADERF_LB_BB_TXLPF_RXVGA2;

  else
  {
    return_value_strcasecmp_7=strcasecmp("bb_txlpf_rxlpf", str);
    if(return_value_strcasecmp_7 == 0)
      *loopback = (enum anonymous_3)BLADERF_LB_BB_TXLPF_RXLPF;

    else
    {
      return_value_strcasecmp_6=strcasecmp("bb_txvga1_rxvga2", str);
      if(return_value_strcasecmp_6 == 0)
        *loopback = (enum anonymous_3)BLADERF_LB_BB_TXVGA1_RXVGA2;

      else
      {
        return_value_strcasecmp_5=strcasecmp("bb_txvga1_rxlpf", str);
        if(return_value_strcasecmp_5 == 0)
          *loopback = (enum anonymous_3)BLADERF_LB_BB_TXVGA1_RXLPF;

        else
        {
          return_value_strcasecmp_4=strcasecmp("rf_lna1", str);
          if(return_value_strcasecmp_4 == 0)
            *loopback = (enum anonymous_3)BLADERF_LB_RF_LNA1;

          else
          {
            return_value_strcasecmp_3=strcasecmp("rf_lna2", str);
            if(return_value_strcasecmp_3 == 0)
              *loopback = (enum anonymous_3)BLADERF_LB_RF_LNA2;

            else
            {
              return_value_strcasecmp_2=strcasecmp("rf_lna3", str);
              if(return_value_strcasecmp_2 == 0)
                *loopback = (enum anonymous_3)BLADERF_LB_RF_LNA3;

              else
              {
                return_value_strcasecmp_1=strcasecmp("none", str);
                if(return_value_strcasecmp_1 == 0)
                  *loopback = (enum anonymous_3)BLADERF_LB_NONE;

                else
                  status = -1;
              }
            }
          }
        }
      }
    }
  }
  return status;
}

// str2module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 382
enum anonymous str2module(const char *str)
{
  signed int return_value_strcasecmp_2;
  return_value_strcasecmp_2=strcasecmp(str, "RX");
  signed int return_value_strcasecmp_1;
  if(return_value_strcasecmp_2 == 0)
    return (enum anonymous)BLADERF_MODULE_RX;

  else
  {
    return_value_strcasecmp_1=strcasecmp(str, "TX");
    if(return_value_strcasecmp_1 == 0)
      return (enum anonymous)BLADERF_MODULE_TX;

    else
      return (enum anonymous)BLADERF_MODULE_INVALID;
  }
}

// str2uint
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/conversions.h line 75
unsigned int str2uint(const char *str, unsigned int min, unsigned int max, _Bool *ok)
{
  unsigned long int value;
  char *endptr;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  value=strtoul(str, &endptr, 0);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  _Bool tmp_if_expr_3;
  if(endptr == str || !(*return_value___errno_location_2 == 0) || !(value >= (unsigned long int)min) || !((unsigned long int)max >= value))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    if(!(ok == ((_Bool *)NULL)))
      *ok = (_Bool)0;

    return (unsigned int)0;
  }

  else
  {
    if(!(ok == ((_Bool *)NULL)))
      *ok = (_Bool)1;

    return (unsigned int)value;
  }
}

// str2uint64
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 93
unsigned long int str2uint64(const char *str, unsigned long int min, unsigned long int max, _Bool *ok)
{
  unsigned long long int value;
  char *endptr;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  value=strtoull(str, &endptr, 0);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  _Bool tmp_if_expr_3;
  if(endptr == str || !(*return_value___errno_location_2 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
  if(!(value >= min) || !(max >= value) || tmp_if_expr_3)
  {
    if(!(ok == ((_Bool *)NULL)))
      *ok = (_Bool)0;

    return (unsigned long int)0;
  }

  else
  {
    if(!(ok == ((_Bool *)NULL)))
      *ok = (_Bool)1;

    return (unsigned long int)value;
  }
}

// str2uint64_suffix
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 231
unsigned long int str2uint64_suffix(const char *str, unsigned long int min, unsigned long int max, struct numeric_suffix *suffixes, unsigned long int num_suffixes, _Bool *ok)
{
  double return_value_str2dbl_suffix_1;
  return_value_str2dbl_suffix_1=str2dbl_suffix(str, (double)min, (double)max, suffixes, num_suffixes, ok);
  return (unsigned long int)return_value_str2dbl_suffix_1;
}

// str2uint_suffix
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 222
unsigned int str2uint_suffix(const char *str, unsigned int min, unsigned int max, struct numeric_suffix *suffixes, unsigned long int num_suffixes, _Bool *ok)
{
  double return_value_str2dbl_suffix_1;
  return_value_str2dbl_suffix_1=str2dbl_suffix(str, (double)min, (double)max, suffixes, num_suffixes, ok);
  return (unsigned int)return_value_str2dbl_suffix_1;
}

// str2version
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 240
signed int str2version(const char *str, struct bladerf_version *version)
{
  unsigned long int tmp;
  const char *start = str;
  char *end;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  tmp=strtoul(start, &end, 10);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  _Bool tmp_if_expr_3;
  if(end == start || tmp >= 65536ul || !(*return_value___errno_location_2 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)*end != 46 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  if(tmp_if_expr_3)
    return -1;

  else
  {
    version->major = (unsigned short int)tmp;
    if((signed int)*end == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)end[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      return -1;

    else
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = 0;
      start = &end[(signed long int)1];
      tmp=strtoul(start, &end, 10);
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      if(end == start || tmp >= 65536ul || !(*return_value___errno_location_6 == 0))
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)*end != 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
        return -1;

      else
      {
        version->minor = (unsigned short int)tmp;
        if((signed int)*end == 0)
          tmp_if_expr_8 = (_Bool)1;

        else
          tmp_if_expr_8 = (signed int)end[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_8)
          return -1;

        else
        {
          signed int *return_value___errno_location_9;
          return_value___errno_location_9=__errno_location();
          *return_value___errno_location_9 = 0;
          start = &end[(signed long int)1];
          tmp=strtoul(start, &end, 10);
          signed int *return_value___errno_location_10;
          return_value___errno_location_10=__errno_location();
          if(end == start || tmp >= 65536ul || !(*return_value___errno_location_10 == 0))
            tmp_if_expr_12 = (_Bool)1;

          else
          {
            if(!((signed int)*end == 45))
              tmp_if_expr_11 = (signed int)*end != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_11 = (_Bool)0;
            tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_12)
            return -1;

          else
          {
            version->patch = (unsigned short int)tmp;
            version->describe = str;
            return 0;
          }
        }
      }
    }
  }
}

// str_to_bladerf_cal_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 637
enum anonymous_0 str_to_bladerf_cal_module(const char *str)
{
  enum anonymous_0 module = (enum anonymous_0)BLADERF_DC_CAL_INVALID;
  signed int return_value_strcasecmp_10;
  return_value_strcasecmp_10=strcasecmp(str, "lpf_tuning");
  _Bool tmp_if_expr_12;
  signed int return_value_strcasecmp_11;
  if(return_value_strcasecmp_10 == 0)
    tmp_if_expr_12 = (_Bool)1;

  else
  {
    return_value_strcasecmp_11=strcasecmp(str, "lpftuning");
    tmp_if_expr_12 = !(return_value_strcasecmp_11 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_14;
  signed int return_value_strcasecmp_13;
  if(tmp_if_expr_12)
    tmp_if_expr_14 = (_Bool)1;

  else
  {
    return_value_strcasecmp_13=strcasecmp(str, "tuning");
    tmp_if_expr_14 = !(return_value_strcasecmp_13 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcasecmp_7;
  _Bool tmp_if_expr_9;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_4;
  _Bool tmp_if_expr_6;
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcasecmp_2;
  if(tmp_if_expr_14)
    module = (enum anonymous_0)BLADERF_DC_CAL_LPF_TUNING;

  else
  {
    return_value_strcasecmp_7=strcasecmp(str, "tx_lpf");
    if(return_value_strcasecmp_7 == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strcasecmp_8=strcasecmp(str, "txlpf");
      tmp_if_expr_9 = !(return_value_strcasecmp_8 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      module = (enum anonymous_0)BLADERF_DC_CAL_TX_LPF;

    else
    {
      return_value_strcasecmp_4=strcasecmp(str, "rx_lpf");
      if(return_value_strcasecmp_4 == 0)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_strcasecmp_5=strcasecmp(str, "rxlpf");
        tmp_if_expr_6 = !(return_value_strcasecmp_5 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        module = (enum anonymous_0)BLADERF_DC_CAL_RX_LPF;

      else
      {
        return_value_strcasecmp_1=strcasecmp(str, "rx_vga2");
        if(return_value_strcasecmp_1 == 0)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_strcasecmp_2=strcasecmp(str, "rxvga2");
          tmp_if_expr_3 = !(return_value_strcasecmp_2 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
          module = (enum anonymous_0)BLADERF_DC_CAL_RXVGA2;

      }
    }
  }
  return module;
}

// strip_last_path_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/file_ops.c line 163
static unsigned long int strip_last_path_entry(char *buf, char dir_delim)
{
  unsigned long int len;
  len=strlen(buf);
  for( ; len >= 1ul; len = len - 1ul)
  {
    if(buf[-1l + (signed long int)len] == dir_delim)
      break;

    buf[(signed long int)(len - (unsigned long int)1)] = (char)0;
  }
  return len;
}

// submit_transfer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 1042
static signed int submit_transfer(struct bladerf_stream *stream, void *buffer)
{
  signed int status;
  struct bladerf_lusb *lusb;
  lusb=lusb_backend(stream->dev);
  struct lusb_stream_data *stream_data = (struct lusb_stream_data *)stream->backend_data;
  struct libusb_transfer *transfer;
  unsigned long int bytes_per_buffer;
  bytes_per_buffer=async_stream_buf_bytes(stream);
  unsigned long int prev_idx;
  const unsigned char ep = (const unsigned char)((signed int)stream->module == BLADERF_MODULE_TX ? 0x01 : 0x81);
  transfer=get_next_available_transfer(stream_data);
  /* assertion transfer != ((void *)0) */
  assert(transfer != (struct libusb_transfer *)(void *)0);
  /* assertion bytes_per_buffer <= 0x7fffffff */
  assert(bytes_per_buffer <= (unsigned long int)0x7fffffff);
  libusb_fill_bulk_transfer(transfer, lusb->handle, ep, (unsigned char *)buffer, (signed int)bytes_per_buffer, lusb_stream_cb, (void *)stream, (unsigned int)stream->dev->transfer_timeout[(signed long int)stream->module]);
  prev_idx = stream_data->i;
  stream_data->transfer_status[(signed long int)stream_data->i] = (enum anonymous_37)TRANSFER_IN_FLIGHT;
  stream_data->i = (stream_data->i + (unsigned long int)1) % stream_data->num_transfers;
  /* assertion stream_data->num_avail != 0 */
  assert(stream_data->num_avail != (unsigned long int)0);
  stream_data->num_avail = stream_data->num_avail - 1ul;
  pthread_mutex_unlock(&stream->lock);
  status=libusb_submit_transfer(transfer);
  pthread_mutex_lock(&stream->lock);
  if(!(status == 0))
  {
    do
    {
      const char *return_value_libusb_error_name_1;
      return_value_libusb_error_name_1=libusb_error_name(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ libusb.c:1089] Failed to submit transfer in %s: %s\n", (const void *)"submit_transfer", return_value_libusb_error_name_1);
    }
    while((_Bool)0);
    /* assertion stream_data->transfer_status[prev_idx] == TRANSFER_IN_FLIGHT */
    assert((signed int)stream_data->transfer_status[(signed long int)prev_idx] == TRANSFER_IN_FLIGHT);
    stream_data->transfer_status[(signed long int)prev_idx] = (enum anonymous_37)TRANSFER_AVAIL;
    stream_data->num_avail = stream_data->num_avail + 1ul;
    if(stream_data->i == 0ul)
      stream_data->i = stream_data->num_transfers - (unsigned long int)1;

    else
      stream_data->i = stream_data->i - 1ul;
  }

  signed int return_value_error_conv_2;
  return_value_error_conv_2=error_conv(status);
  return return_value_error_conv_2;
}

// sync_buf2idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 1095
unsigned int sync_buf2idx(struct buffer_mgmt *b, void *addr)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= b->num_buffers); i = i + 1u)
    if(b->buffers[(signed long int)i] == addr)
      return i;

  /* assertion !"Bug: Buffer not found." */
  assert(!((_Bool)"Bug: Buffer not found."));
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_CRITICAL, "[CRITICAL @ sync.c:1109] Bug: Buffer not found.");
  while((_Bool)0);
  return (unsigned int)0;
}

// sync_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 166
void sync_deinit(struct bladerf_sync *sync)
{
  if(!(sync == ((struct bladerf_sync *)NULL)))
  {
    if((signed int)sync->stream_config.module == BLADERF_MODULE_TX)
      async_submit_stream_buffer(sync->worker->stream, (void *)0, (unsigned int)0, (_Bool)0);

    sync_worker_deinit(sync->worker, &sync->buf_mgmt.lock, &sync->buf_mgmt.buf_ready);
    free((void *)sync->buf_mgmt.status);
    free((void *)sync);
  }

}

// sync_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 152
signed int sync_init(struct bladerf *dev, enum anonymous module, enum anonymous_9 format, unsigned int num_buffers, unsigned int buffer_size, unsigned int num_transfers, unsigned int stream_timeout)
{
  struct bladerf_sync *sync;
  signed int status = 0;
  unsigned long int i;
  unsigned long int bytes_per_sample;
  if(num_transfers >= num_buffers)
    return -3;

  else
    if(!((signed int)module == BLADERF_MODULE_RX) && !((signed int)module == BLADERF_MODULE_TX))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:75] Invalid bladerf_module value encountered: %d", module);
      while((_Bool)0);
      return -3;
    }

    else
    {
      if((signed int)format == BLADERF_FORMAT_SC16_Q11 || (signed int)format == BLADERF_FORMAT_SC16_Q11_META)
      {
        bytes_per_sample = (unsigned long int)4;
        goto __CPROVER_DUMP_L6;
      }

      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:86] Invalid format value: %d\n", format);
      while((_Bool)0);
      return -3;

    __CPROVER_DUMP_L6:
      ;
      if(!((bytes_per_sample * (unsigned long int)buffer_size) % 4096ul == 0ul))
        return -3;

      else
      {
        sync_deinit(dev->sync[(signed long int)module]);
        void *return_value_calloc_1;
        return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct bladerf_sync) /*248ul*/ );
        dev->sync[(signed long int)module] = (struct bladerf_sync *)return_value_calloc_1;
        sync = dev->sync[(signed long int)module];
        if(dev->sync[(signed long int)module] == ((struct bladerf_sync *)NULL))
          return -4;

        else
        {
          switch((signed int)module)
          {
            case BLADERF_MODULE_TX:
            {
              sync->buf_mgmt.submitter = (enum anonymous_22)SYNC_TX_SUBMITTER_FN;
              break;
            }
            case BLADERF_MODULE_RX:
            {
              sync->buf_mgmt.submitter = (enum anonymous_22)SYNC_TX_SUBMITTER_INVALID;
              break;
            }
            default:
            {
              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:115] Invalid module provided: %d\n", module);
              while((_Bool)0);
              return -3;
            }
          }
          sync->dev = dev;
          sync->state = (enum anonymous_19)SYNC_STATE_CHECK_WORKER;
          sync->buf_mgmt.num_buffers = num_buffers;
          sync->buf_mgmt.resubmit_count = (unsigned int)0;
          sync->stream_config.module = module;
          sync->stream_config.format = format;
          sync->stream_config.samples_per_buffer = buffer_size;
          sync->stream_config.num_xfers = num_transfers;
          sync->stream_config.timeout_ms = stream_timeout;
          sync->stream_config.bytes_per_sample = bytes_per_sample;
          sync->meta.state = (enum anonymous_24)SYNC_META_STATE_HEADER;
          sync->meta.msg_per_buf=msg_per_buf(dev, (unsigned long int)buffer_size, bytes_per_sample);
          sync->meta.samples_per_msg=samples_per_msg(dev, bytes_per_sample);
          pthread_mutex_init(&sync->buf_mgmt.lock, (const union anonymous_27 *)(void *)0);
          pthread_cond_init(&sync->buf_mgmt.buf_ready, (const union anonymous_27 *)(void *)0);
          void *return_value_malloc_2;
          return_value_malloc_2=malloc((unsigned long int)num_buffers * sizeof(enum anonymous_21) /*4ul*/ );
          sync->buf_mgmt.status = (enum anonymous_21 *)return_value_malloc_2;
          if(sync->buf_mgmt.status == ((enum anonymous_21 *)NULL))
            status = -4;

          else
          {
            switch((signed int)module)
            {
              case BLADERF_MODULE_RX:
              {
                sync->buf_mgmt.prod_i = num_transfers;
                sync->buf_mgmt.cons_i = (unsigned int)0;
                sync->buf_mgmt.partial_off = (unsigned int)0;
                i = (unsigned long int)0;
                for( ; !(i >= (unsigned long int)num_buffers); i = i + 1ul)
                  if(!(i >= (unsigned long int)num_transfers))
                    sync->buf_mgmt.status[(signed long int)i] = (enum anonymous_21)SYNC_BUFFER_IN_FLIGHT;

                  else
                    sync->buf_mgmt.status[(signed long int)i] = (enum anonymous_21)SYNC_BUFFER_EMPTY;
                sync->meta._anon0._anon0.msg_timestamp = (unsigned long int)0;
                sync->meta._anon0._anon0.msg_flags = (unsigned int)0;
                break;
              }
              case BLADERF_MODULE_TX:
              {
                sync->buf_mgmt.prod_i = (unsigned int)0;
                sync->buf_mgmt.cons_i = (unsigned int)0x7fffffff * 2U + 1U;
                sync->buf_mgmt.partial_off = (unsigned int)0;
                i = (unsigned long int)0;
                for( ; !(i >= (unsigned long int)num_buffers); i = i + 1ul)
                  sync->buf_mgmt.status[(signed long int)i] = (enum anonymous_21)SYNC_BUFFER_EMPTY;
                sync->meta._anon0._anon1.in_burst = (_Bool)0;
                sync->meta._anon0._anon1.now = (_Bool)0;
                break;
              }
              default:
                return -3;
            }
            status=sync_worker_init(sync);
          }
          if(!(status == 0))
          {
            sync_deinit(dev->sync[(signed long int)module]);
            dev->sync[(signed long int)module] = (struct bladerf_sync *)(void *)0;
          }

          return status;
        }
      }
    }
}

// sync_rx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 169
signed int sync_rx(struct bladerf *dev, void *samples, unsigned int num_samples, struct bladerf_metadata *user_meta, unsigned int timeout_ms)
{
  struct bladerf_sync *s = dev->sync[(signed long int)BLADERF_MODULE_RX];
  struct buffer_mgmt *b;
  signed int status = 0;
  _Bool exit_early = (_Bool)0;
  _Bool copied_data = (_Bool)0;
  unsigned int samples_returned = (unsigned int)0;
  unsigned char *samples_dest = (unsigned char *)samples;
  unsigned char *buf_src = (unsigned char *)(void *)0;
  unsigned int samples_to_copy = (unsigned int)0;
  unsigned int samples_per_buffer = (unsigned int)0;
  unsigned long int target_timestamp = 18446744073709551615UL;
  if(samples == NULL || s == ((struct bladerf_sync *)NULL))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:290] NULL pointer passed to %s\n", (const void *)"sync_rx");
    while((_Bool)0);
    return -3;
  }

  else
    if((signed int)s->stream_config.format == BLADERF_FORMAT_SC16_Q11_META)
    {
      if(user_meta == ((struct bladerf_metadata *)NULL))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:294] NULL metadata pointer passed to %s\n", (const void *)"sync_rx");
        while((_Bool)0);
        return -3;
      }

      else
      {
        user_meta->status = (unsigned int)0;
        target_timestamp = user_meta->timestamp;
      }
    }

  b = &s->buf_mgmt;
  samples_per_buffer = s->stream_config.samples_per_buffer;
  signed int stream_error;
  enum anonymous_23 worker_state;
  unsigned long int return_value_samples2bytes_1;
  unsigned long int return_value_samples2bytes_2;
  unsigned long int return_value_samples2bytes_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_12;
  unsigned int return_value_left_in_msg_11;
  while(exit_early == (_Bool)0 && status == 0 && !(samples_returned >= num_samples))
    switch((signed int)s->state)
    {
      case SYNC_STATE_CHECK_WORKER:
      {
        worker_state=sync_worker_get_state(s->worker, &stream_error);
        if(!(stream_error == 0))
          status = stream_error;

        else
          if((signed int)worker_state == SYNC_WORKER_STATE_IDLE)
          {
            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:324] %s: Worker is idle. Going to reset buf mgmt.\n", (const void *)"sync_rx");
            while((_Bool)0);
            s->state = (enum anonymous_19)SYNC_STATE_RESET_BUF_MGMT;
          }

          else
            if((signed int)worker_state == SYNC_WORKER_STATE_RUNNING)
              s->state = (enum anonymous_19)SYNC_STATE_WAIT_FOR_BUFFER;

            else
            {
              status = -1;
              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:331] %s: Unexpected worker state=%d\n", (const void *)"sync_rx", worker_state);
              while((_Bool)0);
            }
        break;
      }
      case SYNC_STATE_RESET_BUF_MGMT:
      {
        pthread_mutex_lock(&b->lock);
        b->cons_i = (unsigned int)0;
        pthread_mutex_unlock(&b->lock);
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:344] %s: Reset buf_mgmt consumer index\n", (const void *)"sync_rx");
        while((_Bool)0);
        s->state = (enum anonymous_19)SYNC_STATE_START_WORKER;
        break;
      }
      case SYNC_STATE_START_WORKER:
      {
        sync_worker_submit_request(s->worker, (unsigned int)(1 << 0));
        status=sync_worker_wait_for_state(s->worker, (enum anonymous_23)SYNC_WORKER_STATE_RUNNING, (unsigned int)250);
        if(status == 0)
        {
          s->state = (enum anonymous_19)SYNC_STATE_WAIT_FOR_BUFFER;
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:359] %s: Worker is now running.\n", (const void *)"sync_rx");
          while((_Bool)0);
        }

        else
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:362] %s: Failed to start worker, (%d)\n", (const void *)"sync_rx", status);
          while((_Bool)0);
        break;
      }
      case SYNC_STATE_WAIT_FOR_BUFFER:
      {
        pthread_mutex_lock(&b->lock);
        if((signed int)b->status[(signed long int)b->cons_i] == SYNC_BUFFER_FULL)
          s->state = (enum anonymous_19)SYNC_STATE_BUFFER_READY;

        else
        {
          status=wait_for_buffer(b, timeout_ms, "sync_rx", b->cons_i);
          if(status == 0)
          {
            if(!((signed int)b->status[(signed long int)b->cons_i] == SYNC_BUFFER_FULL))
              s->state = (enum anonymous_19)SYNC_STATE_CHECK_WORKER;

            else
              s->state = (enum anonymous_19)SYNC_STATE_BUFFER_READY;
          }

        }
        pthread_mutex_unlock(&b->lock);
        break;
      }
      case SYNC_STATE_BUFFER_READY:
      {
        pthread_mutex_lock(&b->lock);
        b->status[(signed long int)b->cons_i] = (enum anonymous_21)SYNC_BUFFER_PARTIAL;
        b->partial_off = (unsigned int)0;
        switch((signed int)s->stream_config.format)
        {
          case BLADERF_FORMAT_SC16_Q11:
          {
            s->state = (enum anonymous_19)SYNC_STATE_USING_BUFFER;
            break;
          }
          case BLADERF_FORMAT_SC16_Q11_META:
          {
            s->state = (enum anonymous_19)SYNC_STATE_USING_BUFFER_META;
            s->meta.curr_msg_off = (unsigned long int)0;
            s->meta.msg_num = (unsigned int)0;
            break;
          }
          default:
          {
            /* assertion !"Invalid stream format" */
            assert(!((_Bool)"Invalid stream format"));
            status = -1;
          }
        }
        pthread_mutex_unlock(&b->lock);
        break;
      }
      case SYNC_STATE_USING_BUFFER:
      {
        pthread_mutex_lock(&b->lock);
        buf_src = (unsigned char *)b->buffers[(signed long int)b->cons_i];
        samples_to_copy=uint_min(num_samples - samples_returned, samples_per_buffer - b->partial_off);
        return_value_samples2bytes_1=samples2bytes(s, (unsigned long int)samples_returned);
        return_value_samples2bytes_2=samples2bytes(s, (unsigned long int)b->partial_off);
        return_value_samples2bytes_3=samples2bytes(s, (unsigned long int)samples_to_copy);
        memcpy((void *)(samples_dest + (signed long int)return_value_samples2bytes_1), (const void *)(buf_src + (signed long int)return_value_samples2bytes_2), return_value_samples2bytes_3);
        b->partial_off = b->partial_off + samples_to_copy;
        samples_returned = samples_returned + samples_to_copy;
        if(b->partial_off >= samples_per_buffer)
        {
          /* assertion b->partial_off == samples_per_buffer */
          assert(b->partial_off == samples_per_buffer);
          advance_rx_buffer(b);
          s->state = (enum anonymous_19)SYNC_STATE_WAIT_FOR_BUFFER;
        }

        pthread_mutex_unlock(&b->lock);
        break;
      }
      case SYNC_STATE_USING_BUFFER_META:
      {
        pthread_mutex_lock(&b->lock);
        switch((signed int)s->meta.state)
        {
          case SYNC_META_STATE_HEADER:
          {
            /* assertion s->meta.msg_num < s->meta.msg_per_buf */
            assert(s->meta.msg_num < s->meta.msg_per_buf);
            buf_src = (unsigned char *)b->buffers[(signed long int)b->cons_i];
            s->meta.curr_msg = buf_src + (signed long int)(dev->msg_size * (unsigned long int)s->meta.msg_num);
            s->meta._anon0._anon0.msg_timestamp=metadata_get_timestamp(s->meta.curr_msg);
            s->meta._anon0._anon0.msg_flags=metadata_get_flags(s->meta.curr_msg);
            s->meta.curr_msg_off = (unsigned long int)0;
            if(!(copied_data == (_Bool)0))
              tmp_if_expr_4 = s->meta._anon0._anon0.msg_timestamp != s->meta.curr_timestamp ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            if(tmp_if_expr_4)
            {
              user_meta->status = user_meta->status | (unsigned int)(1 << 0);
              exit_early = (_Bool)1;
              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:483] Sample discontinuity detected @ buffer %u, message %u: Expected t=%llu, got t=%llu\n", b->cons_i, s->meta.msg_num, (unsigned long long int)s->meta.curr_timestamp, (unsigned long long int)s->meta._anon0._anon0.msg_timestamp);
              while((_Bool)0);
            }

            s->meta.curr_timestamp = s->meta._anon0._anon0.msg_timestamp;
            s->meta.state = (enum anonymous_24)SYNC_META_STATE_SAMPLES;
            break;
          }
          case SYNC_META_STATE_SAMPLES:
          {
            if(copied_data == (_Bool)0)
              tmp_if_expr_13 = (user_meta->flags & (unsigned int)(1 << 31)) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_13 = (_Bool)0;
            if(tmp_if_expr_13)
              tmp_if_expr_14 = target_timestamp < s->meta.curr_timestamp ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_14 = (_Bool)0;
            if(tmp_if_expr_14)
            {
              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:506] Current timestamp is %llu, target=%llu (user=%llu)\n", (unsigned long long int)s->meta.curr_timestamp, (unsigned long long int)target_timestamp, (unsigned long long int)user_meta->timestamp);
              while((_Bool)0);
              status = -14;
            }

            else
            {
              if(!((2147483648u & user_meta->flags) == 0u))
                tmp_if_expr_12 = (_Bool)1;

              else
                tmp_if_expr_12 = target_timestamp == s->meta.curr_timestamp ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_12)
              {
                unsigned int return_value_left_in_msg_5;
                return_value_left_in_msg_5=left_in_msg(s);
                samples_to_copy=uint_min(num_samples - samples_returned, return_value_left_in_msg_5);
                unsigned long int return_value_samples2bytes_6;
                return_value_samples2bytes_6=samples2bytes(s, (unsigned long int)samples_returned);
                unsigned long int return_value_samples2bytes_7;
                return_value_samples2bytes_7=samples2bytes(s, s->meta.curr_msg_off);
                unsigned long int return_value_samples2bytes_8;
                return_value_samples2bytes_8=samples2bytes(s, (unsigned long int)samples_to_copy);
                memcpy((void *)(samples_dest + (signed long int)return_value_samples2bytes_6), (const void *)(s->meta.curr_msg + (signed long int)(sizeof(unsigned int) /*4ul*/  + sizeof(unsigned long int) /*8ul*/  + sizeof(unsigned int) /*4ul*/ ) + (signed long int)return_value_samples2bytes_7), return_value_samples2bytes_8);
                samples_returned = samples_returned + samples_to_copy;
                s->meta.curr_msg_off = s->meta.curr_msg_off + (unsigned long int)samples_to_copy;
                if(copied_data == (_Bool)0)
                {
                  if(!((2147483648u & user_meta->flags) == 0u))
                    user_meta->timestamp = s->meta.curr_timestamp;

                }

                copied_data = (_Bool)1;
                s->meta.curr_timestamp = s->meta.curr_timestamp + (unsigned long int)samples_to_copy;
                target_timestamp = s->meta.curr_timestamp;
                unsigned int return_value_left_in_msg_9;
                return_value_left_in_msg_9=left_in_msg(s);
                if(return_value_left_in_msg_9 == 0u)
                {
                  /* assertion s->meta.curr_msg_off == s->meta.samples_per_msg */
                  assert(s->meta.curr_msg_off == (unsigned long int)s->meta.samples_per_msg);
                  s->meta.state = (enum anonymous_24)SYNC_META_STATE_HEADER;
                  s->meta.msg_num = s->meta.msg_num + 1u;
                  if(s->meta.msg_num >= s->meta.msg_per_buf)
                  {
                    /* assertion s->meta.msg_num == s->meta.msg_per_buf */
                    assert(s->meta.msg_num == s->meta.msg_per_buf);
                    advance_rx_buffer(b);
                    s->meta.msg_num = (unsigned int)0;
                    s->state = (enum anonymous_19)SYNC_STATE_WAIT_FOR_BUFFER;
                  }

                }

              }

              else
              {
                const unsigned long int time_delta = target_timestamp - s->meta.curr_timestamp;
                unsigned long int left_in_buffer = (unsigned long int)s->meta.samples_per_msg * (unsigned long int)(s->meta.msg_per_buf - s->meta.msg_num);
                left_in_buffer = left_in_buffer - s->meta.curr_msg_off;
                if(time_delta >= left_in_buffer)
                {
                  advance_rx_buffer(b);
                  s->state = (enum anonymous_19)SYNC_STATE_WAIT_FOR_BUFFER;
                  s->meta.state = (enum anonymous_24)SYNC_META_STATE_HEADER;
                }

                else
                {
                  return_value_left_in_msg_11=left_in_msg(s);
                  if((unsigned long int)return_value_left_in_msg_11 >= time_delta)
                  {
                    /* assertion time_delta <= (18446744073709551615UL) */
                    assert(time_delta <= 18446744073709551615UL);
                    s->meta.curr_msg_off = s->meta.curr_msg_off + (unsigned long int)time_delta;
                    s->meta.curr_timestamp = s->meta.curr_timestamp + time_delta;
                  }

                  else
                  {
                    s->meta.state = (enum anonymous_24)SYNC_META_STATE_HEADER;
                    unsigned int return_value_timestamp_to_msg_10;
                    return_value_timestamp_to_msg_10=timestamp_to_msg(s, time_delta);
                    s->meta.msg_num = s->meta.msg_num + return_value_timestamp_to_msg_10;
                  }
                }
              }
            }
            break;
          }
          default:
          {
            /* assertion !"Invalid state" */
            assert(!((_Bool)"Invalid state"));
            status = -1;
          }
        }
        pthread_mutex_unlock(&b->lock);
      }
    }
  if(!(user_meta == ((struct bladerf_metadata *)NULL)))
    user_meta->actual_count = samples_returned;

  return status;
}

// sync_tx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.h line 172
signed int sync_tx(struct bladerf *dev, void *samples, unsigned int num_samples, struct bladerf_metadata *user_meta, unsigned int timeout_ms)
{
  struct bladerf_sync *s = dev->sync[(signed long int)BLADERF_MODULE_TX];
  struct buffer_mgmt *b = (struct buffer_mgmt *)(void *)0;
  signed int status = 0;
  unsigned int samples_written = (unsigned int)0;
  unsigned int samples_to_copy = (unsigned int)0;
  unsigned int samples_per_buffer = (unsigned int)0;
  unsigned char *samples_src = (unsigned char *)samples;
  unsigned char *buf_dest = (unsigned char *)(void *)0;
  struct tx_options op = { .flush=(_Bool)0, .zero_pad=(_Bool)0 };
  signed int stream_error;
  enum anonymous_23 worker_state;
  unsigned long int return_value_samples2bytes_1;
  unsigned long int return_value_samples2bytes_2;
  unsigned long int return_value_samples2bytes_3;
  _Bool tmp_if_expr_9;
  unsigned int return_value_left_in_msg_8;
  unsigned int return_value_left_in_msg_10;
  unsigned int return_value_left_in_msg_16;
  unsigned int return_value_left_in_msg_17;
  if(samples == NULL || s == ((struct bladerf_sync *)NULL))
    return -3;

  else
  {
    status=handle_tx_parameters(user_meta, s, &op);
    if(!(status == 0))
      return status;

    else
    {
      b = &s->buf_mgmt;
      samples_per_buffer = s->stream_config.samples_per_buffer;
      while(status == 0 && (!(samples_written >= num_samples) || !(op.flush == (_Bool)0)))
        switch((signed int)s->state)
        {
          case SYNC_STATE_CHECK_WORKER:
          {
            worker_state=sync_worker_get_state(s->worker, &stream_error);
            if(!(stream_error == 0))
              status = stream_error;

            else
              if((signed int)worker_state == SYNC_WORKER_STATE_IDLE)
                s->state = (enum anonymous_19)SYNC_STATE_START_WORKER;

              else
                s->state = (enum anonymous_19)SYNC_STATE_WAIT_FOR_BUFFER;
            break;
          }
          case SYNC_STATE_RESET_BUF_MGMT:
          {
            /* assertion !"Bug" */
            assert(!((_Bool)"Bug"));
            break;
          }
          case SYNC_STATE_START_WORKER:
          {
            sync_worker_submit_request(s->worker, (unsigned int)(1 << 0));
            status=sync_worker_wait_for_state(s->worker, (enum anonymous_23)SYNC_WORKER_STATE_RUNNING, (unsigned int)250);
            if(status == 0)
            {
              s->state = (enum anonymous_19)SYNC_STATE_WAIT_FOR_BUFFER;
              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:838] %s: Worker is now running.\n", (const void *)"sync_tx");
              while((_Bool)0);
            }

            break;
          }
          case SYNC_STATE_WAIT_FOR_BUFFER:
          {
            pthread_mutex_lock(&b->lock);
            if((signed int)b->status[(signed long int)b->prod_i] == SYNC_BUFFER_EMPTY)
              s->state = (enum anonymous_19)SYNC_STATE_BUFFER_READY;

            else
              status=wait_for_buffer(b, timeout_ms, "sync_tx", b->prod_i);
            pthread_mutex_unlock(&b->lock);
            break;
          }
          case SYNC_STATE_BUFFER_READY:
          {
            pthread_mutex_lock(&b->lock);
            b->status[(signed long int)b->prod_i] = (enum anonymous_21)SYNC_BUFFER_PARTIAL;
            b->partial_off = (unsigned int)0;
            switch((signed int)s->stream_config.format)
            {
              case BLADERF_FORMAT_SC16_Q11:
              {
                s->state = (enum anonymous_19)SYNC_STATE_USING_BUFFER;
                break;
              }
              case BLADERF_FORMAT_SC16_Q11_META:
              {
                s->state = (enum anonymous_19)SYNC_STATE_USING_BUFFER_META;
                s->meta.curr_msg_off = (unsigned long int)0;
                s->meta.msg_num = (unsigned int)0;
                break;
              }
              default:
              {
                /* assertion !"Invalid stream format" */
                assert(!((_Bool)"Invalid stream format"));
                status = -1;
              }
            }
            pthread_mutex_unlock(&b->lock);
            break;
          }
          case SYNC_STATE_USING_BUFFER:
          {
            pthread_mutex_lock(&b->lock);
            buf_dest = (unsigned char *)b->buffers[(signed long int)b->prod_i];
            samples_to_copy=uint_min(num_samples - samples_written, samples_per_buffer - b->partial_off);
            return_value_samples2bytes_1=samples2bytes(s, (unsigned long int)b->partial_off);
            return_value_samples2bytes_2=samples2bytes(s, (unsigned long int)samples_written);
            return_value_samples2bytes_3=samples2bytes(s, (unsigned long int)samples_to_copy);
            memcpy((void *)(buf_dest + (signed long int)return_value_samples2bytes_1), (const void *)(samples_src + (signed long int)return_value_samples2bytes_2), return_value_samples2bytes_3);
            b->partial_off = b->partial_off + samples_to_copy;
            samples_written = samples_written + samples_to_copy;
            if(b->partial_off >= samples_per_buffer)
            {
              /* assertion b->partial_off == samples_per_buffer */
              assert(b->partial_off == samples_per_buffer);
              status=advance_tx_buffer(s, b);
            }

            pthread_mutex_unlock(&b->lock);
            break;
          }
          case SYNC_STATE_USING_BUFFER_META:
          {
            pthread_mutex_lock(&b->lock);
            switch((signed int)s->meta.state)
            {
              case SYNC_META_STATE_HEADER:
              {
                buf_dest = (unsigned char *)b->buffers[(signed long int)b->prod_i];
                s->meta.curr_msg = buf_dest + (signed long int)(dev->msg_size * (unsigned long int)s->meta.msg_num);
                s->meta.curr_msg_off = (unsigned long int)0;
                if(!(s->meta._anon0._anon1.now == (_Bool)0))
                  metadata_set(s->meta.curr_msg, (unsigned long int)0, (unsigned int)0);

                else
                  metadata_set(s->meta.curr_msg, s->meta.curr_timestamp, (unsigned int)0);
                s->meta.state = (enum anonymous_24)SYNC_META_STATE_SAMPLES;
                break;
              }
              case SYNC_META_STATE_SAMPLES:
              {
                if(!(op.zero_pad == (_Bool)0))
                {
                  const unsigned long int delta = user_meta->timestamp - s->meta.curr_timestamp;
                  unsigned long int to_zero;
                  unsigned int return_value_left_in_msg_5;
                  return_value_left_in_msg_5=left_in_msg(s);
                  if(!(delta >= (unsigned long int)return_value_left_in_msg_5))
                    to_zero = (unsigned long int)delta;

                  else
                  {
                    unsigned int return_value_left_in_msg_4;
                    return_value_left_in_msg_4=left_in_msg(s);
                    to_zero = (unsigned long int)return_value_left_in_msg_4;
                  }
                  unsigned long int return_value_samples2bytes_6;
                  return_value_samples2bytes_6=samples2bytes(s, s->meta.curr_msg_off);
                  unsigned long int return_value_samples2bytes_7;
                  return_value_samples2bytes_7=samples2bytes(s, to_zero);
                  memset((void *)(s->meta.curr_msg + (signed long int)(sizeof(unsigned int) /*4ul*/  + sizeof(unsigned long int) /*8ul*/  + sizeof(unsigned int) /*4ul*/ ) + (signed long int)return_value_samples2bytes_6), 0, return_value_samples2bytes_7);
                  s->meta.curr_msg_off = s->meta.curr_msg_off + to_zero;
                  if(!(to_zero >= 3ul))
                  {
                    return_value_left_in_msg_8=left_in_msg(s);
                    tmp_if_expr_9 = return_value_left_in_msg_8 == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_9 = (_Bool)0;
                  if(tmp_if_expr_9)
                    s->meta.curr_timestamp = s->meta.curr_timestamp + to_zero;

                  else
                  {
                    s->meta.curr_timestamp = user_meta->timestamp;
                    op.zero_pad = (_Bool)0;
                  }
                }

                return_value_left_in_msg_10=left_in_msg(s);
                samples_to_copy=uint_min(num_samples - samples_written, return_value_left_in_msg_10);
                if(!(samples_to_copy == 0u))
                {
                  unsigned long int return_value_samples2bytes_11;
                  return_value_samples2bytes_11=samples2bytes(s, s->meta.curr_msg_off);
                  unsigned long int return_value_samples2bytes_12;
                  return_value_samples2bytes_12=samples2bytes(s, (unsigned long int)samples_written);
                  unsigned long int return_value_samples2bytes_13;
                  return_value_samples2bytes_13=samples2bytes(s, (unsigned long int)samples_to_copy);
                  memcpy((void *)(s->meta.curr_msg + (signed long int)(sizeof(unsigned int) /*4ul*/  + sizeof(unsigned long int) /*8ul*/  + sizeof(unsigned int) /*4ul*/ ) + (signed long int)return_value_samples2bytes_11), (const void *)(samples_src + (signed long int)return_value_samples2bytes_12), return_value_samples2bytes_13);
                  s->meta.curr_msg_off = s->meta.curr_msg_off + (unsigned long int)samples_to_copy;
                  s->meta.curr_timestamp = s->meta.curr_timestamp + (unsigned long int)samples_to_copy;
                  samples_written = samples_written + samples_to_copy;
                }

                return_value_left_in_msg_16=left_in_msg(s);
                if(!(return_value_left_in_msg_16 == 0u))
                {
                  if(!(op.flush == (_Bool)0))
                  {
                    unsigned int sync_tx__1__3__1__7__5__to_zero;
                    sync_tx__1__3__1__7__5__to_zero=left_in_msg(s);
                    unsigned long int off;
                    unsigned long int return_value_samples2bytes_14;
                    return_value_samples2bytes_14=samples2bytes(s, s->meta.curr_msg_off);
                    off = sizeof(unsigned int) /*4ul*/  + sizeof(unsigned long int) /*8ul*/  + sizeof(unsigned int) /*4ul*/  + return_value_samples2bytes_14;
                    /* assertion num_samples == samples_written */
                    assert(num_samples == samples_written);
                    unsigned long int return_value_samples2bytes_15;
                    return_value_samples2bytes_15=samples2bytes(s, (unsigned long int)sync_tx__1__3__1__7__5__to_zero);
                    memset((void *)(s->meta.curr_msg + (signed long int)off), 0, return_value_samples2bytes_15);
                    s->meta.curr_msg_off = s->meta.curr_msg_off + (unsigned long int)sync_tx__1__3__1__7__5__to_zero;
                    s->meta.curr_timestamp = s->meta.curr_timestamp + (unsigned long int)sync_tx__1__3__1__7__5__to_zero;
                  }

                }

                return_value_left_in_msg_17=left_in_msg(s);
                if(return_value_left_in_msg_17 == 0u)
                {
                  s->meta.msg_num = s->meta.msg_num + 1u;
                  s->meta.state = (enum anonymous_24)SYNC_META_STATE_HEADER;
                }

                if(s->meta.msg_num >= s->meta.msg_per_buf)
                {
                  /* assertion s->meta.msg_num == s->meta.msg_per_buf */
                  assert(s->meta.msg_num == s->meta.msg_per_buf);
                  status=advance_tx_buffer(s, b);
                  s->meta.msg_num = (unsigned int)0;
                  s->state = (enum anonymous_19)SYNC_STATE_WAIT_FOR_BUFFER;
                  op.flush = op.flush != (_Bool)0 && samples_written != num_samples;
                }

                break;
              }
              default:
              {
                /* assertion !"Invalid state" */
                assert(!((_Bool)"Invalid state"));
                status = -1;
              }
            }
            pthread_mutex_unlock(&b->lock);
          }
        }
      if((signed int)s->stream_config.format == BLADERF_FORMAT_SC16_Q11_META)
      {
        if(!((2u & user_meta->flags) == 0u))
        {
          s->meta._anon0._anon1.in_burst = (_Bool)0;
          s->meta._anon0._anon1.now = (_Bool)0;
        }

      }

      return status;
    }
  }
}

// sync_worker_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 91
void sync_worker_deinit(struct sync_worker *w, union anonymous_4 *lock, union anonymous_18 *cond)
{
  signed int status;
  if(w == ((struct sync_worker *)NULL))
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync_worker.c:260] %s called with NULL ptr\n", (const void *)"sync_worker_deinit");
    while((_Bool)0);

  else
  {
    sync_worker_submit_request(w, (unsigned int)(1 << 1));
    if(!(cond == ((union anonymous_18 *)NULL)) && !(lock == ((union anonymous_4 *)NULL)))
    {
      pthread_mutex_lock(lock);
      pthread_cond_signal(cond);
      pthread_mutex_unlock(lock);
    }

    status=sync_worker_wait_for_state(w, (enum anonymous_23)SYNC_WORKER_STATE_STOPPED, (unsigned int)3000);
    if(!(status == 0))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ sync_worker.c:277] Timed out while stopping worker. Canceling thread.\n");
      while((_Bool)0);
      pthread_cancel(w->thread);
    }

    pthread_join(w->thread, (void **)(void *)0);
    async_deinit_stream(w->stream);
    free((void *)w);
  }
}

// sync_worker_get_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 119
enum anonymous_23 sync_worker_get_state(struct sync_worker *w, signed int *err_code)
{
  enum anonymous_23 ret;
  pthread_mutex_lock(&w->state_lock);
  ret = w->state;
  if(!(err_code == ((signed int *)NULL)))
  {
    *err_code = w->err_code;
    w->err_code = 0;
  }

  pthread_mutex_unlock(&w->state_lock);
  return ret;
}

// sync_worker_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 80
signed int sync_worker_init(struct bladerf_sync *s)
{
  signed int status = 0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct sync_worker) /*216ul*/ );
  s->worker = (struct sync_worker *)return_value_calloc_1;
  if(s->worker == ((struct sync_worker *)NULL))
    status = -4;

  else
  {
    s->worker->state = (enum anonymous_23)SYNC_WORKER_STATE_STARTUP;
    s->worker->err_code = 0;
    s->worker->cb = (signed int)s->stream_config.module == BLADERF_MODULE_RX ? rx_callback : tx_callback;
    status=async_init_stream(&s->worker->stream, s->dev, s->worker->cb, &s->buf_mgmt.buffers, (unsigned long int)s->buf_mgmt.num_buffers, s->stream_config.format, (unsigned long int)s->stream_config.samples_per_buffer, (unsigned long int)s->stream_config.num_xfers, (void *)s);
    if(!(status == 0))
      do
      {
        const char *return_value_module2str_2;
        return_value_module2str_2=module2str(s->stream_config.module);
        const char *return_value_bladerf_strerror_3;
        return_value_bladerf_strerror_3=bladerf_strerror(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync_worker.c:212] %s worker: Failed to init stream: %s\n", return_value_module2str_2, return_value_bladerf_strerror_3);
      }
      while((_Bool)0);

    else
    {
      pthread_mutex_init(&s->worker->state_lock, (const union anonymous_27 *)(void *)0);
      pthread_mutex_init(&s->worker->request_lock, (const union anonymous_27 *)(void *)0);
      status=pthread_cond_init(&s->worker->state_changed, (const union anonymous_27 *)(void *)0);
      if(!(status == 0))
        status = -1;

      else
      {
        status=pthread_cond_init(&s->worker->requests_pending, (const union anonymous_27 *)(void *)0);
        if(!(status == 0))
          status = -1;

        else
        {
          status=pthread_create(&s->worker->thread, (const union pthread_attr_t *)(void *)0, sync_worker_task, (void *)s);
          if(!(status == 0))
            status = -1;

          else
          {
            status=sync_worker_wait_for_state(s->worker, (enum anonymous_23)SYNC_WORKER_STATE_IDLE, (unsigned int)1000);
            if(!(status == 0))
              status = -6;

          }
        }
      }
    }
  }

worker_init_out:
  ;
  if(!(status == 0))
  {
    free((void *)s->worker);
    s->worker = (struct sync_worker *)(void *)0;
  }

  return status;
}

// sync_worker_submit_request
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 128
void sync_worker_submit_request(struct sync_worker *w, unsigned int request)
{
  pthread_mutex_lock(&w->request_lock);
  w->requests = w->requests | request;
  pthread_cond_signal(&w->requests_pending);
  pthread_mutex_unlock(&w->request_lock);
}

// sync_worker_task
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 466
void * sync_worker_task(void *arg)
{
  enum anonymous_23 state = (enum anonymous_23)SYNC_WORKER_STATE_IDLE;
  struct bladerf_sync *s = (struct bladerf_sync *)arg;
  set_state(s->worker, state);
  while(!((signed int)state == SYNC_WORKER_STATE_STOPPED))
    switch((signed int)state)
    {
      case SYNC_WORKER_STATE_STARTUP:
      {
        /* assertion !"Worker in unexpected state, shutting down. (STARTUP)" */
        assert(!((_Bool)"Worker in unexpected state, shutting down. (STARTUP)"));
        set_state(s->worker, (enum anonymous_23)SYNC_WORKER_STATE_SHUTTING_DOWN);
        break;
      }
      case SYNC_WORKER_STATE_IDLE:
      {
        state=exec_idle_state(s);
        set_state(s->worker, state);
        break;
      }
      case SYNC_WORKER_STATE_RUNNING:
      {
        exec_running_state(s);
        state = (enum anonymous_23)SYNC_WORKER_STATE_IDLE;
        set_state(s->worker, state);
        break;
      }
      case SYNC_WORKER_STATE_SHUTTING_DOWN:
      {
        state = (enum anonymous_23)SYNC_WORKER_STATE_STOPPED;
        set_state(s->worker, state);
        break;
      }
      case SYNC_WORKER_STATE_STOPPED:
      {
        /* assertion !"Worker in unexpected state: STOPPED" */
        assert(!((_Bool)"Worker in unexpected state: STOPPED"));
        break;
      }
      default:
      {
        /* assertion !"Worker in unexpected state, shutting down. (UNKNOWN)" */
        assert(!((_Bool)"Worker in unexpected state, shutting down. (UNKNOWN)"));
        set_state(s->worker, (enum anonymous_23)SYNC_WORKER_STATE_SHUTTING_DOWN);
      }
    }
  return (void *)0;
}

// sync_worker_wait_for_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.h line 105
signed int sync_worker_wait_for_state(struct sync_worker *w, enum anonymous_23 state, unsigned int timeout_ms)
{
  signed int status = 0;
  struct timespec timeout_abs;
  const signed int nsec_per_sec = 1000 * 1000 * 1000;
  if(!(timeout_ms == 0u))
  {
    const unsigned int timeout_sec = timeout_ms / (unsigned int)1000;
    status=clock_gettime(0, &timeout_abs);
    if(!(status == 0))
      return -1;

    timeout_abs.tv_sec = timeout_abs.tv_sec + (signed long int)timeout_sec;
    timeout_abs.tv_nsec = timeout_abs.tv_nsec + (signed long int)((timeout_ms % (unsigned int)1000) * (unsigned int)1000 * (unsigned int)1000);
    if(timeout_abs.tv_nsec >= (signed long int)nsec_per_sec)
    {
      timeout_abs.tv_sec = timeout_abs.tv_sec + timeout_abs.tv_nsec / (signed long int)nsec_per_sec;
      timeout_abs.tv_nsec = timeout_abs.tv_nsec % (signed long int)nsec_per_sec;
    }

    pthread_mutex_lock(&w->state_lock);
    status = 0;
    while(!(w->state == state))
    {
      if(!(status == 0))
        break;

      status=pthread_cond_timedwait(&w->state_changed, &w->state_lock, &timeout_abs);
    }
    pthread_mutex_unlock(&w->state_lock);
  }

  else
  {
    pthread_mutex_lock(&w->state_lock);
    while(!(w->state == state))
      status=pthread_cond_wait(&w->state_changed, &w->state_lock);
    pthread_mutex_unlock(&w->state_lock);
  }
  if(!(status == 0))
  {
    do
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync_worker.c:341] %s: Wait on state change failed: %s\n", (const void *)"sync_worker_wait_for_state", return_value_strerror_1);
    }
    while((_Bool)0);
    if(status == 110)
      status = -6;

    else
      status = -1;
  }

  return status;
}

// timestamp_in_past
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 686
static inline _Bool timestamp_in_past(struct bladerf_metadata *user_meta, struct bladerf_sync *s)
{
  const _Bool in_past = user_meta->timestamp < s->meta.curr_timestamp;
  if(!(in_past == (_Bool)0))
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ sync.c:693] Provided timestamp=%lu is in past: current=%lu\n", user_meta->timestamp, s->meta.curr_timestamp);
    while((_Bool)0);

  return in_past;
}

// timestamp_to_msg
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 266
static inline unsigned int timestamp_to_msg(struct bladerf_sync *s, unsigned long int t)
{
  unsigned long int m = t / (unsigned long int)s->meta.samples_per_msg;
  /* assertion m <= (0x7fffffff * 2U + 1U) */
  assert(m <= (unsigned long int)((unsigned int)0x7fffffff * 2U + 1U));
  return (unsigned int)m;
}

// to_uint32
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fx3_fw.c line 61
static inline unsigned int to_uint32(struct fx3_firmware *fw, unsigned int offset)
{
  unsigned int ret;
  /* assertion (offset + sizeof(uint32_t)) <= fw->data_len */
  assert((unsigned long int)offset + sizeof(unsigned int) /*4ul*/  <= (unsigned long int)fw->data_len);
  memcpy((void *)&ret, (const void *)&fw->data[(signed long int)offset], sizeof(unsigned int) /*4ul*/ );
  return ret;
}

// transfer_idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/libusb.c line 884
static inline unsigned long int transfer_idx(struct lusb_stream_data *stream_data, struct libusb_transfer *transfer)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= stream_data->num_transfers); i = i + 1ul)
    if(stream_data->transfers[(signed long int)i] == transfer)
      return i;

  return (unsigned long int)((unsigned int)0x7fffffff * 2U + 1U);
}

// tune_vcocap
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 2031
static signed int tune_vcocap(struct bladerf *dev, unsigned char vcocap_est, unsigned char base, unsigned char vcocap_reg_state, unsigned char *vcocap_result)
{
  signed int status;
  unsigned char vcocap = vcocap_est;
  unsigned char vtune;
  unsigned char vtune_high_limit;
  unsigned char vtune_low_limit;

__CPROVER_DUMP_L1:
  ;
  vtune_high_limit = (unsigned char)0x3f;
  vtune_low_limit = (unsigned char)0;
  status=get_vtune(dev, base, (unsigned char)50, &vtune);
  if(!(status == 0))
    return status;

  else
  {
    switch((signed int)vtune)
    {
      case 0x02:
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2053] Estimate HIGH: Walking down to NORM.\n");
        while((_Bool)0);
        status=vtune_high_to_norm(dev, base, vcocap, vcocap_reg_state, &vtune_high_limit);
        break;
      }
      case 0x00:
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2059] Estimate NORM: Walking up to HIGH.\n");
        while((_Bool)0);
        status=vtune_norm_to_high(dev, base, vcocap, vcocap_reg_state, &vtune_high_limit);
        break;
      }
      case 0x01:
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2065] Estimate LOW: Walking down to NORM.\n");
        while((_Bool)0);
        status=vtune_low_to_norm(dev, base, vcocap, vcocap_reg_state, &vtune_low_limit);
      }
    }
    if(!(status == 0))
      return status;

    else
      if(!((signed int)vtune_high_limit == 0x3f))
      {
        if((signed int)vtune == 0x00 || (signed int)vtune == 0x02)
        {
          if(!(12 + (signed int)vtune_high_limit >= 0x3f))
            vcocap = (unsigned char)((signed int)vtune_high_limit + 12);

          else
          {
            vcocap = (unsigned char)0x3f;
            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2087] Clamping VCOCAP to %u.\n", vcocap);
            while((_Bool)0);
          }
          goto __CPROVER_DUMP_L13;
        }

        /* assertion !"Invalid state" */
        assert(!((_Bool)"Invalid state"));
        return -1;

      __CPROVER_DUMP_L13:
        ;
        status=write_vcocap(dev, base, vcocap, vcocap_reg_state);
        if(!(status == 0))
          return status;

        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2101] Waiting for VTUNE LOW @ VCOCAP=%u,\n", vcocap);
        while((_Bool)0);
        status=wait_for_vtune_value(dev, base, (unsigned char)0x01, &vcocap, vcocap_reg_state);
        if(status == 0)
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2106] Walking VTUNE LOW to NORM from VCOCAP=%u,\n", vcocap);
          while((_Bool)0);
          status=vtune_low_to_norm(dev, base, vcocap, vcocap_reg_state, &vtune_low_limit);
        }

      }

      else
      {
        if((signed int)vtune == 0x00 || (signed int)vtune == 0x01)
        {
          if((signed int)vtune_low_limit + -12 >= 1)
            vcocap = (unsigned char)((signed int)vtune_low_limit - 12);

          else
          {
            vcocap = (unsigned char)0;
            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2124] Clamping VCOCAP to %u.\n", vcocap);
            while((_Bool)0);
          }
          goto __CPROVER_DUMP_L23;
        }

        /* assertion !"Invalid state" */
        assert(!((_Bool)"Invalid state"));
        return -1;

      __CPROVER_DUMP_L23:
        ;
        status=write_vcocap(dev, base, vcocap, vcocap_reg_state);
        if(!(status == 0))
          return status;

        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2138] Waiting for VTUNE HIGH @ VCOCAP=%u\n", vcocap);
        while((_Bool)0);
        status=wait_for_vtune_value(dev, base, (unsigned char)0x02, &vcocap, vcocap_reg_state);
        if(status == 0)
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2143] Walking VTUNE HIGH to NORM from VCOCAP=%u,\n", vcocap);
          while((_Bool)0);
          status=vtune_high_to_norm(dev, base, vcocap, vcocap_reg_state, &vtune_high_limit);
        }

      }
    if(status == 0)
    {
      vcocap = (unsigned char)((signed int)vtune_high_limit + ((signed int)vtune_low_limit - (signed int)vtune_high_limit) / 2);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2152] VTUNE LOW:   %u\n", vtune_low_limit);
      while((_Bool)0);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2153] VTUNE NORM:  %u\n", vcocap);
      while((_Bool)0);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2155] VTUNE Est:   %u (%d)\n", vcocap_est, (signed int)vcocap_est - (signed int)vcocap);
      while((_Bool)0);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:2156] VTUNE HIGH:  %u\n", vtune_high_limit);
      while((_Bool)0);
      status=write_vcocap(dev, base, vcocap, vcocap_reg_state);
      if(!(status == 0))
        return status;

      *vcocap_result = vcocap;
      status=get_vtune(dev, base, (unsigned char)25, &vtune);
      if(!(status == 0))
        return status;

      if(!((signed int)vtune == 0x00))
      {
        status = -1;
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ lms.c:2180] Final VCOCAP=%u is not in VTUNE NORM region.\n", vcocap);
        while((_Bool)0);
      }

    }

    return status;
  }
}

// tuning_cancel_scheduled
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 87
static inline signed int tuning_cancel_scheduled(struct bladerf *dev, enum anonymous module)
{
  signed int return_value;
  return_value=dev->fn->retune(dev, module, (unsigned long int)-1, (unsigned short int)0, (unsigned int)0, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0);
  return return_value;
}

// tuning_get_default_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 115
enum anonymous_10 tuning_get_default_mode(struct bladerf *dev)
{
  enum anonymous_10 mode = (enum anonymous_10)BLADERF_TUNING_MODE_INVALID;
  const char *str;
  str=getenv("BLADERF_DEFAULT_TUNING_MODE");
  signed int return_value_strcasecmp_2;
  if(!(str == ((const char *)NULL)))
  {
    signed int return_value_strcasecmp_3;
    return_value_strcasecmp_3=strcasecmp("host", str);
    if(return_value_strcasecmp_3 == 0)
      mode = (enum anonymous_10)BLADERF_TUNING_MODE_HOST;

    else
    {
      return_value_strcasecmp_2=strcasecmp("fpga", str);
      if(return_value_strcasecmp_2 == 0)
      {
        mode = (enum anonymous_10)BLADERF_TUNING_MODE_FPGA;
        _Bool return_value_fpga_supports_tuning_mode_1;
        return_value_fpga_supports_tuning_mode_1=fpga_supports_tuning_mode(dev, mode);
        if(return_value_fpga_supports_tuning_mode_1 == (_Bool)0)
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ tuning.c:61] The loaded FPGA version (%u.%u.%u) does not support the tuning mode being used to override the default.\n", dev->fpga_version.major, dev->fpga_version.minor, dev->fpga_version.patch);
          while((_Bool)0);

      }

      else
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ tuning.c:64] Invalid tuning mode override: %s\n", str);
        while((_Bool)0);
    }
  }

  if((signed int)mode == BLADERF_TUNING_MODE_INVALID)
  {
    _Bool return_value_fpga_supports_tuning_mode_4;
    return_value_fpga_supports_tuning_mode_4=fpga_supports_tuning_mode(dev, (enum anonymous_10)BLADERF_TUNING_MODE_FPGA);
    if(!(return_value_fpga_supports_tuning_mode_4 == (_Bool)0))
      mode = (enum anonymous_10)BLADERF_TUNING_MODE_FPGA;

    else
      mode = (enum anonymous_10)BLADERF_TUNING_MODE_HOST;
  }

  switch((signed int)mode)
  {
    case BLADERF_TUNING_MODE_HOST:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ tuning.c:78] Default tuning mode: host\n");
      while((_Bool)0);
      break;
    }
    case BLADERF_TUNING_MODE_FPGA:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ tuning.c:82] Default tuning mode: FPGA\n");
      while((_Bool)0);
      break;
    }
    default:
    {
      /* assertion !"Bug encountered." */
      assert(!((_Bool)"Bug encountered."));
      mode = (enum anonymous_10)BLADERF_TUNING_MODE_HOST;
    }
  }
  return mode;
}

// tuning_get_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 104
signed int tuning_get_freq(struct bladerf *dev, enum anonymous module, unsigned int *frequency)
{
  enum anonymous_6 attached;
  enum anonymous_35 path;
  struct lms_freq f;
  signed int rv = 0;
  rv=lms_get_frequency(dev, module, &f);
  if(!(rv == 0))
    return rv;

  else
  {
    if((signed int)f.x == 0)
    {
      *frequency = (unsigned int)0;
      rv = -5;
    }

    else
      *frequency=lms_frequency_to_hz(&f);
    if(!(rv == 0))
      return rv;

    else
    {
      rv=xb_get_attached(dev, &attached);
      if(!(rv == 0))
        return rv;

      else
      {
        if((signed int)attached == BLADERF_XB_200)
        {
          rv=xb200_get_path(dev, module, &path);
          if(!(rv == 0))
            return rv;

          if((signed int)path == BLADERF_XB200_MIX)
            *frequency = (unsigned int)1248000000 - *frequency;

        }

        return rv;
      }
    }
  }
}

// tuning_schedule
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 70
static inline signed int tuning_schedule(struct bladerf *dev, enum anonymous module, unsigned long int timestamp, struct lms_freq *f)
{
  signed int return_value;
  return_value=dev->fn->retune(dev, module, timestamp, f->nint, f->nfrac, f->freqsel, f->vcocap, ((signed int)f->flags & 1 << 0) != 0, ((signed int)f->flags & 1 << 1) != 0);
  return return_value;
}

// tuning_schedule_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 70
static inline signed int tuning_schedule_link1(struct bladerf *dev_link1, enum anonymous module_link1, unsigned long int timestamp_link1, struct lms_freq *f_link1)
{
  signed int return_value_link1;
  return_value_link1=dev_link1->fn->retune(dev_link1, module_link1, timestamp_link1, f_link1->nint, f_link1->nfrac, f_link1->freqsel, f_link1->vcocap, ((signed int)f_link1->flags & 1 << 0) != 0, ((signed int)f_link1->flags & 1 << 1) != 0);
  return return_value_link1;
}

// tuning_set_freq
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 54
signed int tuning_set_freq(struct bladerf *dev, enum anonymous module, unsigned int frequency)
{
  signed int status;
  const enum anonymous_6 attached = dev->xb;
  signed short int dc_i;
  signed short int dc_q;
  struct dc_cal_tbl *dc_cal;
  struct dc_cal_tbl *tmp_if_expr_1;
  if((signed int)module == BLADERF_MODULE_RX)
    tmp_if_expr_1 = dev->cal.dc_rx;

  else
    tmp_if_expr_1 = dev->cal.dc_tx;
  dc_cal = tmp_if_expr_1;
  do
  {
    const char *return_value_module2str_2;
    return_value_module2str_2=module2str(module);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ tuning.c:134] Setting %s frequency to %u\n", return_value_module2str_2, frequency);
  }
  while((_Bool)0);
  struct lms_freq f;
  if((signed int)attached == BLADERF_XB_200)
  {
    if(!(frequency >= 237500000u))
    {
      status=xb200_set_path(dev, module, (enum anonymous_35)BLADERF_XB200_MIX);
      if(!(status == 0))
        return status;

      status=xb200_auto_filter_selection(dev, module, frequency);
      if(!(status == 0))
        return status;

      frequency = (unsigned int)1248000000 - frequency;
      goto __CPROVER_DUMP_L7;
    }

    status=xb200_set_path(dev, module, (enum anonymous_35)BLADERF_XB200_BYPASS);
    if(status == 0)
      goto __CPROVER_DUMP_L7;

    return status;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    switch((signed int)dev->tuning_mode)
    {
      case BLADERF_TUNING_MODE_HOST:
      {
        status=lms_set_frequency(dev, module, frequency);
        if(!(status == 0))
          return status;

        status=band_select(dev, module, frequency < (unsigned int)1500000000);
        break;
      }
      case BLADERF_TUNING_MODE_FPGA:
      {
        status=lms_calculate_tuning_params(frequency, &f);
        if(status == 0)
          status=tuning_schedule_link1(dev, module, (unsigned long int)0, &f);

        break;
      }
      default:
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ tuning.c:181] Invalid tuning mode: %d\n", dev->tuning_mode);
        while((_Bool)0);
        status = -3;
      }
    }
    if(!(status == 0))
      return status;

    else
    {
      if(!(dc_cal == ((struct dc_cal_tbl *)NULL)))
      {
        dc_cal_tbl_vals(dc_cal, frequency, &dc_i, &dc_q);
        status=lms_set_dc_offset_i(dev, module, (unsigned short int)dc_i);
        if(!(status == 0))
          return status;

        status=lms_set_dc_offset_q(dev, module, dc_q);
        if(!(status == 0))
          return status;

        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ tuning.c:204] Set %s DC offset cal (I, Q) to: (%d, %d)\n", (signed int)module == BLADERF_MODULE_RX ? "RX" : "TX", dc_i, dc_q);
        while((_Bool)0);
      }

      return status;
    }
  }
}

// tuning_set_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/tuning.h line 126
signed int tuning_set_mode(struct bladerf *dev, enum anonymous_10 mode)
{
  signed int status = 0;
  _Bool return_value_fpga_supports_tuning_mode_1;
  return_value_fpga_supports_tuning_mode_1=fpga_supports_tuning_mode(dev, mode);
  if(!(return_value_fpga_supports_tuning_mode_1 == (_Bool)0))
    dev->tuning_mode = mode;

  else
  {
    status = -8;
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ tuning.c:105] The loaded FPGA version (%u.%u.%u) does not support the provided tuning mode (%d)\n", dev->fpga_version.major, dev->fpga_version.minor, dev->fpga_version.patch, mode);
    while((_Bool)0);
  }
  switch((signed int)dev->tuning_mode)
  {
    case BLADERF_TUNING_MODE_HOST:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ tuning.c:110] Tuning mode: host\n");
      while((_Bool)0);
      break;
    }
    case BLADERF_TUNING_MODE_FPGA:
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ tuning.c:114] Tuning mode: FPGA\n");
      while((_Bool)0);
      break;
    }
    default:
    {
      /* assertion !"Bug encountered." */
      assert(!((_Bool)"Bug encountered."));
      status = -3;
    }
  }
  return status;
}

// tx_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync_worker.c line 114
static void * tx_callback(struct bladerf *dev, struct bladerf_stream *stream, struct bladerf_metadata *meta, void *samples, unsigned long int num_samples, void *user_data)
{
  unsigned int requests;
  unsigned int completed_idx;
  struct bladerf_sync *s = (struct bladerf_sync *)user_data;
  struct sync_worker *w = s->worker;
  struct buffer_mgmt *b = &s->buf_mgmt;
  void *ret = (void *)-1;
  pthread_mutex_lock(&w->request_lock);
  requests = w->requests;
  pthread_mutex_unlock(&w->request_lock);
  if(!((2u & requests) == 0u))
    return (void *)0;

  else
  {
    if(!(samples == NULL))
    {
      pthread_mutex_lock(&b->lock);
      completed_idx=sync_buf2idx(b, samples);
      /* assertion b->status[completed_idx] == SYNC_BUFFER_IN_FLIGHT */
      assert((signed int)b->status[(signed long int)completed_idx] == SYNC_BUFFER_IN_FLIGHT);
      b->status[(signed long int)completed_idx] = (enum anonymous_21)SYNC_BUFFER_EMPTY;
      pthread_cond_signal(&b->buf_ready);
      if((signed int)b->submitter == SYNC_TX_SUBMITTER_CALLBACK)
      {
        /* assertion b->cons_i != ((0x7fffffff * 2U + 1U)) */
        assert(b->cons_i != (unsigned int)0x7fffffff * 2U + 1U);
        if((signed int)b->status[(signed long int)b->cons_i] == SYNC_BUFFER_FULL)
        {
          ret = b->buffers[(signed long int)b->cons_i];
          b->status[(signed long int)b->cons_i] = (enum anonymous_21)SYNC_BUFFER_IN_FLIGHT;
          b->cons_i = (b->cons_i + (unsigned int)1) % b->num_buffers;
        }

        else
        {
          b->submitter = (enum anonymous_22)SYNC_TX_SUBMITTER_FN;
          b->cons_i = (unsigned int)0x7fffffff * 2U + 1U;
        }
      }

      pthread_mutex_unlock(&b->lock);
    }

    return ret;
  }
}

// u32_min
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 35
static inline unsigned int u32_min(unsigned int x, unsigned int y)
{
  return x < y ? x : y;
}

// uint_min
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/include/minmax.h line 25
static inline unsigned int uint_min(unsigned int x, unsigned int y)
{
  return x < y ? x : y;
}

// unpack_image
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 201
static signed int unpack_image(struct bladerf_image *img, unsigned char *buf, unsigned long int len)
{
  unsigned long int i = (unsigned long int)0;
  unsigned int type;
  unsigned short int tmp_statement_expression_2;
  unsigned short int tmp_statement_expression_3;
  unsigned short int tmp_statement_expression_4;
  if(!(len >= 226ul))
    return -3;

  else
  {
    memcpy((void *)img->magic, (const void *)&buf[(signed long int)i], (unsigned long int)7);
    img->magic[(signed long int)7] = (char)0;
    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(img->magic, image_magic, (unsigned long int)7);
    if(!(return_value_strncmp_1 == 0))
      return -3;

    else
    {
      i = i + (unsigned long int)7;
      memcpy((void *)img->checksum, (const void *)&buf[(signed long int)i], (unsigned long int)32);
      i = i + (unsigned long int)32;
      memcpy((void *)&img->version.major, (const void *)&buf[(signed long int)i], sizeof(unsigned short int) /*2ul*/ );
      i = i + sizeof(unsigned short int) /*2ul*/ ;
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)img->version.major;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_2 = __v;
      img->version.major = tmp_statement_expression_2;
      memcpy((void *)&img->version.minor, (const void *)&buf[(signed long int)i], sizeof(unsigned short int) /*2ul*/ );
      i = i + sizeof(unsigned short int) /*2ul*/ ;
      unsigned short int unpack_image__1__4____v;
      unsigned short int unpack_image__1__4____x = (unsigned short int)img->version.minor;
      asm("rorw _8, %w0" : "=r"(unpack_image__1__4____v) : "0"(unpack_image__1__4____x) : "cc");
      tmp_statement_expression_3 = unpack_image__1__4____v;
      img->version.minor = tmp_statement_expression_3;
      memcpy((void *)&img->version.patch, (const void *)&buf[(signed long int)i], sizeof(unsigned short int) /*2ul*/ );
      i = i + sizeof(unsigned short int) /*2ul*/ ;
      unsigned short int unpack_image__1__5____v;
      unsigned short int unpack_image__1__5____x = (unsigned short int)img->version.patch;
      asm("rorw _8, %w0" : "=r"(unpack_image__1__5____v) : "0"(unpack_image__1__5____x) : "cc");
      tmp_statement_expression_4 = unpack_image__1__5____v;
      img->version.patch = tmp_statement_expression_4;
      memcpy((void *)&img->timestamp, (const void *)&buf[(signed long int)i], sizeof(unsigned long int) /*8ul*/ );
      i = i + sizeof(unsigned long int) /*8ul*/ ;
      img->timestamp=__bswap_64(img->timestamp);
      memcpy((void *)img->serial, (const void *)&buf[(signed long int)i], (unsigned long int)33);
      img->serial[(signed long int)33] = (char)0;
      i = i + (unsigned long int)33;
      memcpy((void *)img->reserved, (const void *)&buf[(signed long int)i], (unsigned long int)128);
      i = i + (unsigned long int)128;
      memcpy((void *)&type, (const void *)&buf[(signed long int)i], sizeof(unsigned int) /*4ul*/ );
      i = i + sizeof(unsigned int) /*4ul*/ ;
      type=__bswap_32(type);
      _Bool return_value_image_type_is_valid_5;
      return_value_image_type_is_valid_5=image_type_is_valid((enum anonymous_38)type);
      if(return_value_image_type_is_valid_5 == (_Bool)0)
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:249] Invalid type value in image: %d\n", (signed int)type);
        while((_Bool)0);
        return -3;
      }

      else
        img->type = (enum anonymous_38)type;
      memcpy((void *)&img->address, (const void *)&buf[(signed long int)i], sizeof(unsigned int) /*4ul*/ );
      i = i + sizeof(unsigned int) /*4ul*/ ;
      img->address=__bswap_32(img->address);
      memcpy((void *)&img->length, (const void *)&buf[(signed long int)i], sizeof(unsigned int) /*4ul*/ );
      i = i + sizeof(unsigned int) /*4ul*/ ;
      img->length=__bswap_32(img->length);
      if(!(len == sizeof(unsigned int) * 56 + 2 /*226ul*/  + (unsigned long int)img->length))
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:264] Image contains more or less data than expected\n");
        while((_Bool)0);
        return -3;
      }

      else
      {
        memmove((void *)&buf[(signed long int)0], (const void *)&buf[(signed long int)i], (unsigned long int)img->length);
        img->data = buf;
        return 0;
      }
    }
  }
}

// usb_backend
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 150
static inline struct bladerf_usb * usb_backend(struct bladerf *dev, void **driver)
{
  struct bladerf_usb *ret = (struct bladerf_usb *)dev->backend;
  if(!(driver == ((void **)NULL)))
    *driver = ret->driver;

  return ret;
}

// usb_backend_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 150
static inline struct bladerf_usb * usb_backend_link1(struct bladerf *dev_link1, void **driver_link1)
{
  struct bladerf_usb *ret_link1 = (struct bladerf_usb *)dev_link1->backend;
  if(!(driver_link1 == ((void **)NULL)))
    *driver_link1 = ret_link1->driver;

  return ret_link1;
}

// usb_backend_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.h line 150
static inline struct bladerf_usb * usb_backend_link2(struct bladerf *dev_link2, void **driver_link2)
{
  struct bladerf_usb *ret_link2 = (struct bladerf_usb *)dev_link2->backend;
  if(!(driver_link2 == ((void **)NULL)))
    *driver_link2 = ret_link2->driver;

  return ret_link2;
}

// usb_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 238
static void usb_close(struct bladerf *dev)
{
  signed int status;
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  if(!(usb == ((struct bladerf_usb *)NULL)))
  {
    status=usb->fn->change_setting(driver, (unsigned char)0);
    if(!(status == 0))
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ usb.c:251] Failed to switch to NULL interface: %s\n", return_value_bladerf_strerror_1);
    }

    usb->fn->close(driver);
    free((void *)usb);
    dev->backend = (void *)0;
  }

}

// usb_deinit_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 891
static void usb_deinit_stream(struct bladerf_stream *stream)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(stream->dev, &driver);
  usb->fn->deinit_stream(driver, stream);
}

// usb_device_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 731
static signed int usb_device_reset(struct bladerf *dev)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  signed int return_value;
  return_value=usb->fn->control_transfer(driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, (unsigned char)105, (unsigned short int)0, (unsigned short int)0, NULL, (unsigned int)0, (unsigned int)1000);
  return return_value;
}

// usb_enable_module
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 831
static signed int usb_enable_module(struct bladerf *dev, enum anonymous m, _Bool enable)
{
  signed int status;
  signed int fx3_ret = -1;
  const unsigned short int val = (const unsigned short int)(enable != (_Bool)0 ? 1 : 0);
  const unsigned char cmd = (const unsigned char)((signed int)m == BLADERF_MODULE_RX ? 4 : 5);
  status=vendor_cmd_int_wvalue(dev, cmd, val, &fx3_ret);
  if(!(status == 0))
    do
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:843] Could not enable RF %s (%d): %s\n", (signed int)m == BLADERF_MODULE_RX ? "RX" : "TX", status, return_value_bladerf_strerror_1);
    }
    while((_Bool)0);

  else
    if(!(fx3_ret == 0))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ usb.c:849] FX3 reported error=0x%x when %s RF %s\n", fx3_ret, enable != (_Bool)0 ? "enabling" : "disabling", (signed int)m == BLADERF_MODULE_RX ? "RX" : "TX");
      while((_Bool)0);
      if(!(fx3_ret == 0x44))
        status = -1;

    }

  return status;
}

// usb_erase_flash_blocks
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 487
static signed int usb_erase_flash_blocks(struct bladerf *dev, unsigned int eb, unsigned short int count)
{
  signed int status;
  signed int restore_status;
  unsigned short int i;
  status=change_setting(dev, (unsigned char)2);
  if(!(status == 0))
    return status;

  else
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:498] Erasing %u blocks starting at block %u\n", count, eb);
    while((_Bool)0);
    i = (unsigned short int)0;
    for( ; !((signed int)i >= (signed int)count); i = i + 1)
    {
      status=perform_erase(dev, (unsigned short int)(eb + (unsigned int)i));
      if(status == 0)
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:503] Erased block %u%c", eb + (unsigned int)i, (signed int)i + 1 == (signed int)count ? 10 : 13);
        while((_Bool)0);

      else
      {
        do
        {
          const char *return_value_bladerf_strerror_1;
          return_value_bladerf_strerror_1=bladerf_strerror(status);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:506] Failed to erase block %u: %s\n", eb + (unsigned int)i, return_value_bladerf_strerror_1);
        }
        while((_Bool)0);
        goto error;
      }
    }
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:511] Done erasing %u blocks\n", count);
    while((_Bool)0);

  error:
    ;
    restore_status=restore_post_flash_setting(dev);
    return status != 0 ? status : restore_status;
  }
}

// usb_get_cal
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 756
static signed int usb_get_cal(struct bladerf *dev, char *cal)
{
  const unsigned short int dummy_page = (const unsigned short int)0;
  signed int status;
  signed int restore_status;
  /* assertion 256 == 256 */
  assert(256 == 256);
  status=change_setting(dev, (unsigned char)2);
  if(!(status == 0))
    return status;

  else
  {
    status=read_page(dev, (unsigned char)110, dummy_page, (unsigned char *)cal);
    restore_status=restore_post_flash_setting(dev);
    return status == 0 ? restore_status : status;
  }
}

// usb_get_device_speed
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 790
static signed int usb_get_device_speed(struct bladerf *dev, enum anonymous_7 *speed)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  signed int return_value;
  return_value=usb->fn->get_speed(driver, speed);
  return return_value;
}

// usb_get_firmware_loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 817
static signed int usb_get_firmware_loopback(struct bladerf *dev, _Bool *is_enabled)
{
  signed int status;
  signed int result;
  status=vendor_cmd_int(dev, (unsigned char)114, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, &result);
  if(status == 0)
    *is_enabled = result != 0;

  return status;
}

// usb_get_otp
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 775
static signed int usb_get_otp(struct bladerf *dev, char *otp)
{
  signed int status;
  signed int restore_status;
  const unsigned short int dummy_page = (const unsigned short int)0;
  status=change_setting(dev, (unsigned char)2);
  if(!(status == 0))
    return status;

  else
  {
    status=read_page(dev, (unsigned char)103, dummy_page, (unsigned char *)otp);
    restore_status=restore_post_flash_setting(dev);
    return status == 0 ? restore_status : status;
  }
}

// usb_init_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 868
static signed int usb_init_stream(struct bladerf_stream *stream, unsigned long int num_transfers)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(stream->dev, &driver);
  signed int return_value;
  return_value=usb->fn->init_stream(driver, stream, num_transfers);
  return return_value;
}

// usb_is_fpga_configured
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 122
static signed int usb_is_fpga_configured(struct bladerf *dev)
{
  signed int result = -1;
  signed int status;
  char *return_value_getenv_1;
  return_value_getenv_1=getenv("BLADERF_FORCE_NO_FPGA_PRESENT");
  if(!(return_value_getenv_1 == ((char *)NULL)))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:137] Reporting no FPGA present - BLADERF_FORCE_NO_FPGA_PRESENT is set.\n");
    while((_Bool)0);
    return 0;
  }

  else
  {
    status=vendor_cmd_int(dev, (unsigned char)1, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, &result);
    if(!(status >= 0))
      return status;

    else
      if(result == 0 || result == 1)
        return result;

      else
      {
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:149] Unexpected result from FPGA status query: %d\n", result);
        while((_Bool)0);
        return -1;
      }
  }
}

// usb_jump_to_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 744
static signed int usb_jump_to_bootloader(struct bladerf *dev)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  signed int return_value;
  return_value=usb->fn->control_transfer(driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, (unsigned char)106, (unsigned short int)0, (unsigned short int)0, NULL, (unsigned int)0, (unsigned int)1000);
  return return_value;
}

// usb_load_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 406
static signed int usb_load_fpga(struct bladerf *dev, unsigned char *image, unsigned long int image_size)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  unsigned int wait_count;
  const unsigned int timeout_ms = (const unsigned int)(2 * 1000);
  signed int status;
  status=change_setting(dev, (unsigned char)3);
  if(!(status >= 0))
  {
    do
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:419] Failed to switch to FPGA config setting: %s\n", return_value_bladerf_strerror_1);
    }
    while((_Bool)0);
    return status;
  }

  else
  {
    status=begin_fpga_programming(dev);
    if(!(status >= 0))
    {
      do
      {
        const char *return_value_bladerf_strerror_2;
        return_value_bladerf_strerror_2=bladerf_strerror(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:427] Failed to initiate FPGA programming: %s\n", return_value_bladerf_strerror_2);
      }
      while((_Bool)0);
      return status;
    }

    else
    {
      /* assertion image_size <= (4294967295U) */
      assert(image_size <= (unsigned long int)4294967295U);
      status=usb->fn->bulk_transfer(driver, (unsigned char)0x02, (void *)image, (unsigned int)image_size, timeout_ms);
      if(!(status >= 0))
      {
        const char *return_value_bladerf_strerror_3;
        return_value_bladerf_strerror_3=bladerf_strerror(status);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:437] Failed to write FPGA bitstream to FPGA: %s\n", return_value_bladerf_strerror_3);
        return status;
      }

      else
      {
        wait_count = (unsigned int)10;
        status = 0;
        if(status == 0 && wait_count >= 1u)
        {
          status=usb_is_fpga_configured(dev);
          if(!(status == 1))
          {
            usleep((unsigned int)200000);
            wait_count = wait_count - 1u;
          }

        }

        if(!(status >= 0))
        {
          const char *return_value_bladerf_strerror_4;
          return_value_bladerf_strerror_4=bladerf_strerror(status);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:458] Failed to determine if FPGA is loaded: %s\n", return_value_bladerf_strerror_4);
          return status;
        }

        else
          if(wait_count == 0u && !(status == 0))
          {
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:461] Timeout while waiting for FPGA configuration status\n");
            return -6;
          }

        signed int return_value_post_fpga_load_init_5;
        return_value_post_fpga_load_init_5=post_fpga_load_init(dev);
        return return_value_post_fpga_load_init_5;
      }
    }
  }
}

// usb_load_fw_from_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1035
static signed int usb_load_fw_from_bootloader(enum anonymous_11 backend, unsigned char bus, unsigned char addr, struct fx3_firmware *fw)
{
  signed int status = 0;
  unsigned long int i;
  struct bladerf_usb usb;
  i = (unsigned long int)0;
  _Bool tmp_if_expr_1;
  for( ; !(i >= 1ul); i = i + 1ul)
  {
    if((signed int)backend == BLADERF_BACKEND_ANY)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = usb_driver_list[(signed long int)i]->id == backend ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      usb.fn = usb_driver_list[(signed long int)i]->fn;
      status=usb.fn->open_bootloader(&usb.driver, bus, addr);
      if(status == 0)
      {
        status=write_fw_to_bootloader((void *)&usb, fw);
        usb.fn->close_bootloader(usb.driver);
        break;
      }

    }

  }
  return status;
}

// usb_matches
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 217
static _Bool usb_matches(enum anonymous_11 backend)
{
  return (signed int)backend == BLADERF_BACKEND_ANY || (signed int)backend == BLADERF_BACKEND_LINUX || (signed int)backend == BLADERF_BACKEND_LIBUSB || (signed int)backend == BLADERF_BACKEND_CYPRESS;
}

// usb_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 281
static signed int usb_open(struct bladerf *dev, struct bladerf_devinfo *info)
{
  signed int usb_open__1__status;
  unsigned long int usb_open__1__i;
  struct bladerf_usb *usb;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct bladerf_usb) /*16ul*/ );
  usb = (struct bladerf_usb *)return_value_malloc_1;
  _Bool tmp_if_expr_2;
  if(usb == ((struct bladerf_usb *)NULL))
    return -4;

  else
  {
    dev->fn = &backend_fns_usb_legacy;
    dev->backend = (void *)usb;
    usb_open__1__status = -7;
    usb_open__1__i = (unsigned long int)0;
    for( ; usb_open__1__status == -7 && !(usb_open__1__i >= 1ul); usb_open__1__i = usb_open__1__i + 1ul)
    {
      if((signed int)info->backend == BLADERF_BACKEND_ANY)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = usb_driver_list[(signed long int)usb_open__1__i]->id == info->backend ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        usb->fn = usb_driver_list[(signed long int)usb_open__1__i]->fn;
        usb_open__1__status=usb->fn->open(&usb->driver, info, &dev->ident);
      }

    }
    if(!(usb_open__1__status == 0))
    {
      free((void *)usb);
      dev->backend = (void *)0;
      dev->fn = (struct backend_fns *)(void *)0;
      return usb_open__1__status;
    }

    else
    {
      dev->transfer_timeout[(signed long int)BLADERF_MODULE_TX] = 1000;
      dev->transfer_timeout[(signed long int)BLADERF_MODULE_RX] = 1000;
      dev->fpga_version.major = (unsigned short int)0;
      dev->fpga_version.minor = (unsigned short int)0;
      dev->fpga_version.patch = (unsigned short int)0;
      usb_open__1__status=populate_fw_version(usb, &dev->fw_version);
      if(!(usb_open__1__status >= 0))
      {
        do
        {
          const char *return_value_bladerf_strerror_3;
          return_value_bladerf_strerror_3=bladerf_strerror(usb_open__1__status);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:326] Failed to populate FW version: %s\n", return_value_bladerf_strerror_3);
        }
        while((_Bool)0);
        return usb_open__1__status;
      }

      else
      {
        capabilities_init_pre_fpga_load(dev);
        _Bool return_value_have_cap_4;
        return_value_have_cap_4=have_cap_link7(dev, (unsigned long int)1 << 33);
        if(!(return_value_have_cap_4 == (_Bool)0))
        {
          const unsigned int max_retries = (const unsigned int)30;
          unsigned int i;
          signed int status;
          signed int device_ready = 0;
          i = (unsigned int)0;
          for( ; !(device_ready == 1) && !(i >= max_retries); i = i + 1u)
          {
            status=vendor_cmd_int(dev, (unsigned char)6, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, &device_ready);
            if(!(device_ready == 1) || !(status == 0))
            {
              if(i == 0u)
                do
                  log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:346] Waiting for device to become ready...\n");
                while((_Bool)0);

              else
                do
                  log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:348] Retry %02u/%02u.\n", i + (unsigned int)1, max_retries);
                while((_Bool)0);
              usleep((unsigned int)1000000);
            }

          }
          if(i >= max_retries)
          {
            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:356] Timed out while waiting for device.\n");
            while((_Bool)0);
            return -6;
          }

        }

        else
        {
          const unsigned int major = (const unsigned int)dev->fw_version.major;
          const unsigned int minor = (const unsigned int)dev->fw_version.minor;
          const unsigned int patch = (const unsigned int)dev->fw_version.patch;
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:367] FX3 FW v%u.%u.%u does not support the \"device ready\" query.\n\tEnsure flash-autoloading completes before opening a device.\n\tUpgrade the FX3 firmware to avoid this message in the future.\n\n", major, minor, patch);
          while((_Bool)0);
        }
        usb_open__1__status=change_setting(dev, (unsigned char)0);
        if(!(usb_open__1__status >= 0))
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:373] Failed to switch to USB_IF_NULL\n");
          while((_Bool)0);

        else
        {
          usb_open__1__status=usb_is_fpga_configured(dev);
          if(usb_open__1__status >= 1)
            usb_open__1__status=post_fpga_load_init(dev);

        }

      error:
        ;
        if(!(usb_open__1__status == 0))
          usb_close(dev);

        return usb_open__1__status;
      }
    }
  }
}

// usb_probe
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 225
static signed int usb_probe(enum anonymous_15 probe_target, struct bladerf_devinfo_list *info_list)
{
  signed int status;
  unsigned long int i;
  status = 0;
  i = (unsigned long int)status;
  if(!(i >= 1ul))
  {
    status=usb_driver_list[(signed long int)i]->fn->probe(probe_target, info_list);
    i = i + 1ul;
  }

  return status;
}

// usb_read_flash_pages
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 583
static signed int usb_read_flash_pages(struct bladerf *dev, unsigned char *buf, unsigned int page_u32, unsigned int count_u32)
{
  signed int status;
  unsigned long int n_read;
  unsigned short int i;
  const unsigned short int page = (unsigned short int)page_u32;
  const unsigned short int count = (unsigned short int)count_u32;
  /* assertion page == page_u32 */
  assert((unsigned int)page == page_u32);
  /* assertion count == count_u32 */
  assert((unsigned int)count == count_u32);
  status=change_setting(dev, (unsigned char)2);
  if(!(status == 0))
    return status;

  else
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:603] Reading %u pages starting at page %u\n", count, page);
    while((_Bool)0);
    i = (unsigned short int)0;
    n_read = (unsigned long int)i;
    for( ; !((signed int)i >= (signed int)count); i = i + 1)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:606] Reading page %u%c", (signed int)page + (signed int)i, (signed int)i + 1 == (signed int)count ? 10 : 13);
      while((_Bool)0);
      status=read_page(dev, (unsigned char)100, (unsigned short int)((signed int)page + (signed int)i), buf + (signed long int)n_read);
      if(!(status == 0))
        goto error;

      n_read = n_read + (unsigned long int)256;
    }
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:617] Done reading %u pages\n", count);
    while((_Bool)0);

  error:
    ;
    status=restore_post_flash_setting(dev);
    return status;
  }
}

// usb_read_fw_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 1078
static signed int usb_read_fw_log(struct bladerf *dev, unsigned int *e)
{
  signed int status;
  *e = (unsigned int)0x00000000;
  _Bool return_value_have_cap_1;
  return_value_have_cap_1=have_cap_link7(dev, (unsigned long int)1 << 34);
  if(!(return_value_have_cap_1 == (_Bool)0))
    status=vendor_cmd_int(dev, (unsigned char)115, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, (signed int *)e);

  else
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:1088] FX3 FW v%s does not support log retrieval.\n", dev->fw_version.describe);
    while((_Bool)0);
    status = -8;
  }
  return status;
}

// usb_set_firmware_loopback
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 798
static signed int usb_set_firmware_loopback(struct bladerf *dev, _Bool enable)
{
  signed int result;
  signed int status;
  status=vendor_cmd_int_wvalue(dev, (unsigned char)113, (unsigned short int)enable, &result);
  if(!(status == 0))
    return status;

  else
  {
    status=change_setting(dev, (unsigned char)0);
    if(status == 0)
      status=change_setting(dev, (unsigned char)1);

    return status;
  }
}

// usb_stream
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 875
static signed int usb_stream(struct bladerf_stream *stream, enum anonymous module)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(stream->dev, &driver);
  signed int return_value;
  return_value=usb->fn->stream(driver, stream, module);
  return return_value;
}

// usb_submit_stream_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 882
signed int usb_submit_stream_buffer(struct bladerf_stream *stream, void *buffer, unsigned int timeout_ms, _Bool nonblock)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(stream->dev, &driver);
  signed int return_value;
  return_value=usb->fn->submit_stream_buffer(driver, stream, buffer, timeout_ms, nonblock);
  return return_value;
}

// usb_write_flash_pages
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 684
static signed int usb_write_flash_pages(struct bladerf *dev, const unsigned char *buf, unsigned int page_u32, unsigned int count_u32)
{
  signed int status;
  signed int restore_status;
  unsigned short int i;
  unsigned long int n_written;
  const unsigned short int page = (unsigned short int)page_u32;
  const unsigned short int count = (unsigned short int)count_u32;
  /* assertion page == page_u32 */
  assert((unsigned int)page == page_u32);
  /* assertion count == count_u32 */
  assert((unsigned int)count == count_u32);
  status=change_setting(dev, (unsigned char)2);
  if(!(status == 0))
    return status;

  else
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:705] Writing %u pages starting at page %u\n", count, page);
    while((_Bool)0);
    n_written = (unsigned long int)0;
    i = (unsigned short int)0;
    for( ; !((signed int)i >= (signed int)count); i = i + 1)
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:709] Writing page %u%c", (signed int)page + (signed int)i, (signed int)i + 1 == (signed int)count ? 10 : 13);
      while((_Bool)0);
      status=write_page(dev, (unsigned short int)((signed int)page + (signed int)i), buf + (signed long int)n_written);
      if(!(status == 0))
        goto error;

      n_written = n_written + (unsigned long int)256;
    }
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ usb.c:718] Done writing %u pages\n", count);
    while((_Bool)0);

  error:
    ;
    restore_status=restore_post_flash_setting(dev);
    if(!(status == 0))
      return status;

    else
      if(!(restore_status == 0))
        return restore_status;

      else
        return 0;
  }
}

// valid_fpga_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/fpga.c line 73
static inline _Bool valid_fpga_size(unsigned long int len)
{
  if(!(len >= 1048576ul))
    return (_Bool)0;

  else
    if(len >= 3604481ul)
      return (_Bool)0;

    else
      return (_Bool)1;
}

// valid_fw_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/bladerf.c line 1250
static inline _Bool valid_fw_size(unsigned long int len)
{
  if(!(len >= 51200ul))
    return (_Bool)0;

  else
    if(len >= 196609ul)
      return (_Bool)0;

    else
      return (_Bool)1;
}

// vendor_cmd_int
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 92
static inline signed int vendor_cmd_int(struct bladerf *dev, unsigned char cmd, enum anonymous_30 dir, signed int *val)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  signed int return_value;
  return_value=usb->fn->control_transfer(driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, dir, cmd, (unsigned short int)0, (unsigned short int)0, (void *)val, (unsigned int)sizeof(signed int) /*4ul*/ , (unsigned int)1000);
  return return_value;
}

// vendor_cmd_int_windex
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 59
static inline signed int vendor_cmd_int_windex(struct bladerf *dev, unsigned char cmd, unsigned short int windex, signed int *val)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  signed int return_value;
  return_value=usb->fn->control_transfer(driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, cmd, (unsigned short int)0, windex, (void *)val, (unsigned int)sizeof(unsigned int) /*4ul*/ , (unsigned int)1000);
  return return_value;
}

// vendor_cmd_int_wvalue
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 75
static inline signed int vendor_cmd_int_wvalue(struct bladerf *dev, unsigned char cmd, unsigned short int wvalue, signed int *val)
{
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  signed int return_value;
  return_value=usb->fn->control_transfer(driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, cmd, wvalue, (unsigned short int)0, (void *)val, (unsigned int)sizeof(unsigned int) /*4ul*/ , (unsigned int)1000);
  return return_value;
}

// verify_checksum
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/image.c line 94
static signed int verify_checksum(unsigned char *buf, unsigned long int buf_len)
{
  char checksum_expected[32l];
  char checksum_calc[32l];
  if(!(buf_len >= 227ul))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ image.c:100] Provided buffer isn't a full image\n");
    while((_Bool)0);
    return -3;
  }

  else
  {
    memcpy((void *)checksum_expected, (const void *)&buf[(signed long int)7], sizeof(char [32l]) /*32ul*/ );
    memset((void *)&buf[(signed long int)7], 0, (unsigned long int)32);
    sha256_buffer((const char *)buf, buf_len, checksum_calc);
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp((const void *)checksum_expected, (const void *)checksum_calc, (unsigned long int)32);
    if(!(return_value_memcmp_1 == 0))
      return -10;

    else
    {
      memcpy((void *)&buf[(signed long int)7], (const void *)checksum_expected, sizeof(char [32l]) /*32ul*/ );
      return 0;
    }
  }
}

// verify_flash
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/flash.c line 103
static inline signed int verify_flash(struct bladerf *dev, unsigned char *readback_buf, unsigned char *image, unsigned int page, unsigned int count)
{
  signed int status = 0;
  unsigned long int i;
  const unsigned long int len = (const unsigned long int)(count * (unsigned int)256);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ flash.c:110] Verifying %u pages, starting at page %u\n", count, page);
  while((_Bool)0);
  status=flash_read(dev, readback_buf, page, count);
  if(!(status >= 0))
  {
    do
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ flash.c:114] Failed to read from flash: %s\n", return_value_bladerf_strerror_1);
    }
    while((_Bool)0);
    return status;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= len); i = i + 1ul)
      if(!(image[(signed long int)i] == readback_buf[(signed long int)i]))
      {
        status = -1;
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_INFO, "[INFO @ flash.c:123] Flash verification failed at byte %llu. Read %02x, expected %02x\n", i, readback_buf[(signed long int)i], image[(signed long int)i]);
        while((_Bool)0);
        break;
      }

    return status;
  }
}

// version_check_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 70
signed int version_check_fpga(struct bladerf *dev)
{
  struct compat *fw;
  fw=find_fw_match(dev);
  struct compat *fpga;
  fpga=find_fpga_match(dev);
  unsigned int major;
  unsigned int minor;
  unsigned int patch;
  if(fw == ((struct compat *)NULL))
    return -13;

  else
    if(fpga == ((struct compat *)NULL))
      return -12;

  required_values(fw, &major, &minor, &patch);
  _Bool return_value_version_less_than_1;
  return_value_version_less_than_1=version_less_than(&dev->fpga_version, major, minor, patch);
  if(!(return_value_version_less_than_1 == (_Bool)0))
    return -12;

  else
  {
    required_values(fpga, &major, &minor, &patch);
    _Bool return_value_version_less_than_2;
    return_value_version_less_than_2=version_less_than(&dev->fw_version, major, minor, patch);
    if(!(return_value_version_less_than_2 == (_Bool)0))
      return -13;

    else
      return 0;
  }
}

// version_check_fw
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 38
signed int version_check_fw(struct bladerf *dev)
{
  _Bool return_value_version_greater_or_equal_1;
  static struct bladerf_version *ver = &fw_compat_tbl[(signed long int)(sizeof(struct compat [7l]) /*224ul*/  / sizeof(struct compat) /*32ul*/  - (unsigned long int)1)].ver;
  return_value_version_greater_or_equal_1=version_greater_or_equal(&dev->fw_version, (unsigned int)ver->major, (unsigned int)ver->minor, (unsigned int)ver->patch);
  if(!(return_value_version_greater_or_equal_1 == (_Bool)0))
    return 0;

  else
    return -13;
}

// version_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 226
_Bool version_equal(struct bladerf_version *v1, struct bladerf_version *v2)
{
  _Bool tmp_if_expr_1;
  if(v1->major == v2->major)
    tmp_if_expr_1 = v1->minor == v2->minor ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = v1->patch == v2->patch ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  return tmp_if_expr_2;
}

// version_greater_or_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 100
_Bool version_greater_or_equal(struct bladerf_version *version, unsigned int major, unsigned int minor, unsigned int patch)
{
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(major >= (unsigned int)version->major))
    return (_Bool)1;

  else
  {
    if((unsigned int)version->major == major)
      tmp_if_expr_3 = (unsigned int)version->minor > minor ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      return (_Bool)1;

    else
    {
      if((unsigned int)version->major == major)
        tmp_if_expr_1 = (unsigned int)version->minor == minor ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_2 = (unsigned int)version->patch >= patch ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        return (_Bool)1;

      else
        return (_Bool)0;
    }
  }
}

// version_less_than
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.c line 251
_Bool version_less_than(struct bladerf_version *version, unsigned int major, unsigned int minor, unsigned int patch)
{
  _Bool return_value_version_greater_or_equal_1;
  return_value_version_greater_or_equal_1=version_greater_or_equal(version, major, minor, patch);
  return !(return_value_version_greater_or_equal_1 != (_Bool)0);
}

// version_required_fpga
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 79
void version_required_fpga(struct bladerf *dev, struct bladerf_version *version)
{
  struct compat *entry;
  entry=find_fw_match(dev);
  if(entry == ((struct compat *)NULL))
  {
    do
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ version_compat.c:218] %s called before FW version check?", (const void *)"version_required_fpga");
    while((_Bool)0);
    memset((void *)version, 0, sizeof(struct bladerf_version) /*16ul*/ );
    /* assertion !"BUG!" */
    assert(!((_Bool)"BUG!"));
  }

  else
    memcpy((void *)version, (const void *)&entry->requires, sizeof(struct bladerf_version) /*16ul*/ );
}

// version_required_fw
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/version_compat.h line 53
void version_required_fw(struct bladerf *dev, struct bladerf_version *version, _Bool by_fpga)
{
  if(!(by_fpga == (_Bool)0))
  {
    struct compat *fpga;
    fpga=find_fpga_match(dev);
    if(fpga == ((struct compat *)NULL))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ version_compat.c:166] %s is missing FPGA version compat table entry?", (const void *)"version_required_fw");
      while((_Bool)0);
      memset((void *)version, 0, sizeof(struct bladerf_version) /*16ul*/ );
      /* assertion !"BUG!" */
      assert(!((_Bool)"BUG!"));
    }

    else
      memcpy((void *)version, (const void *)&fpga->requires, sizeof(struct bladerf_version) /*16ul*/ );
  }

  else
  {
    struct bladerf_version *required_version = &fw_compat_tbl[(signed long int)(sizeof(struct compat [7l]) /*224ul*/  / sizeof(struct compat) /*32ul*/  - (unsigned long int)1)].ver;
    memcpy((void *)version, (const void *)required_version, sizeof(struct bladerf_version) /*16ul*/ );
  }
}

// vtune_high_to_norm
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1829
static signed int vtune_high_to_norm(struct bladerf *dev, unsigned char base, unsigned char vcocap, unsigned char vcocap_reg_state, unsigned char *vtune_high_limit)
{
  signed int status;
  unsigned int i;
  unsigned char vtune = (unsigned char)0xff;
  i = (unsigned int)0;
  for( ; !(i >= 20u); i = i + 1u)
  {
    if((signed int)vcocap >= 0x3f)
    {
      *vtune_high_limit = (unsigned char)0x3f;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:1841] %s: VCOCAP hit max value.\n", (const void *)"vtune_high_to_norm");
      while((_Bool)0);
      return 0;
    }

    vcocap = vcocap + 1;
    status=write_vcocap(dev, base, vcocap, vcocap_reg_state);
    if(!(status == 0))
      return status;

    status=get_vtune(dev, base, (unsigned char)25, &vtune);
    if(!(status == 0))
      return status;

    if((signed int)vtune == 0x00)
    {
      *vtune_high_limit = (unsigned char)((signed int)vcocap - 1);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1859] VTUNE NORM @ VCOCAP=%u\n", vcocap);
      while((_Bool)0);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1860] VTUNE HIGH @ VCOCAP=%u\n", *vtune_high_limit);
      while((_Bool)0);
      return 0;
    }

  }
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ lms.c:1865] VTUNE High->Norm loop failed to converge.\n");
  while((_Bool)0);
  return -1;
}

// vtune_low_to_norm
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1908
static signed int vtune_low_to_norm(struct bladerf *dev, unsigned char base, unsigned char vcocap, unsigned char vcocap_reg_state, unsigned char *vtune_low_limit)
{
  signed int status;
  unsigned int i;
  unsigned char vtune = (unsigned char)0xff;
  i = (unsigned int)0;
  for( ; !(i >= 20u); i = i + 1u)
  {
    if((signed int)vcocap == 0)
    {
      *vtune_low_limit = (unsigned char)0;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:1920] VCOCAP hit min value.\n");
      while((_Bool)0);
      return 0;
    }

    vcocap = vcocap - 1;
    status=write_vcocap(dev, base, vcocap, vcocap_reg_state);
    if(!(status == 0))
      return status;

    status=get_vtune(dev, base, (unsigned char)25, &vtune);
    if(!(status == 0))
      return status;

    if((signed int)vtune == 0x00)
    {
      *vtune_low_limit = (unsigned char)((signed int)vcocap + 1);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1938] VTUNE NORM @ VCOCAP=%u\n", vcocap);
      while((_Bool)0);
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1939] VTUNE LOW @ VCOCAP=%u\n", *vtune_low_limit);
      while((_Bool)0);
      return 0;
    }

  }
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ lms.c:1944] VTUNE Low->Norm loop failed to converge.\n");
  while((_Bool)0);
  return -1;
}

// vtune_norm_to_high
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1869
static signed int vtune_norm_to_high(struct bladerf *dev, unsigned char base, unsigned char vcocap, unsigned char vcocap_reg_state, unsigned char *vtune_high_limit)
{
  signed int status;
  unsigned int i;
  unsigned char vtune = (unsigned char)0xff;
  i = (unsigned int)0;
  for( ; !(i >= 20u); i = i + 1u)
  {
    if((signed int)vcocap == 0)
    {
      *vtune_high_limit = (unsigned char)0;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:1881] %s: VCOCAP hit min value.\n", (const void *)"vtune_norm_to_high");
      while((_Bool)0);
      return 0;
    }

    vcocap = vcocap - 1;
    status=write_vcocap(dev, base, vcocap, vcocap_reg_state);
    if(!(status == 0))
      return status;

    status=get_vtune(dev, base, (unsigned char)25, &vtune);
    if(!(status == 0))
      return status;

    if((signed int)vtune == 0x02)
    {
      *vtune_high_limit = vcocap;
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1899] VTUNE high @ VCOCAP=%u\n", *vtune_high_limit);
      while((_Bool)0);
      return 0;
    }

  }
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ lms.c:1904] VTUNE High->Norm loop failed to converge.\n");
  while((_Bool)0);
  return -1;
}

// vtune_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1812
static const char * vtune_str(unsigned char value)
{
  switch((signed int)value)
  {
    case 0x02:
      return "HIGH";
    case 0x00:
      return "NORM";
    case 0x01:
      return "LOW";
    default:
      return "INVALID";
  }
}

// wait_for_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/sync.c line 219
static signed int wait_for_buffer(struct buffer_mgmt *b, unsigned int timeout_ms, const char *dbg_name, unsigned int dbg_idx)
{
  signed int status;
  struct timespec timeout;
  if(timeout_ms == 0u)
    status=pthread_cond_wait(&b->buf_ready, &b->lock);

  else
  {
    status=populate_abs_timeout(&timeout, timeout_ms);
    if(status == 0)
      status=pthread_cond_timedwait(&b->buf_ready, &b->lock, &timeout);

  }
  if(status == 110)
    status = -6;

  else
    if(!(status == 0))
      status = -1;

  return status;
}

// wait_for_vtune_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1949
static signed int wait_for_vtune_value(struct bladerf *dev, unsigned char base, unsigned char target_value, unsigned char *vcocap, unsigned char vcocap_reg_state)
{
  unsigned char vtune;
  unsigned int i;
  signed int status = 0;
  const unsigned int max_retries = (const unsigned int)15;
  const unsigned char limit = (const unsigned char)((signed int)target_value == 0x02 ? 0 : 0x3f);
  signed char inc = (signed char)((signed int)target_value == 0x02 ? -1 : 1);
  /* assertion target_value == 0x02 || target_value == 0x01 */
  assert((signed int)target_value == 0x02 || (signed int)target_value == 0x01);
  i = (unsigned int)0;
  for( ; !(i >= max_retries); i = i + 1u)
  {
    status=get_vtune(dev, base, (unsigned char)0, &vtune);
    if(!(status == 0))
      return status;

    if(vtune == target_value)
    {
      do
      {
        const char *return_value_vtune_str_1;
        return_value_vtune_str_1=vtune_str(target_value);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1970] VTUNE reached %s at iteration %u\n", return_value_vtune_str_1, i);
      }
      while((_Bool)0);
      return 0;
    }

    else
    {
      do
      {
        const char *return_value_vtune_str_2;
        return_value_vtune_str_2=vtune_str(vtune);
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1974] VTUNE was %s. Waiting and retrying...\n", return_value_vtune_str_2);
      }
      while((_Bool)0);

    __CPROVER_DUMP_L5:
      ;
      do
        do
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1976] VTUNE_BUSY_WAIT(%u)\n", 10);
        while((_Bool)0);
      while((_Bool)0);
    }
  }
  do
  {
    const char *return_value_vtune_str_3;
    return_value_vtune_str_3=vtune_str(target_value);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:1981] Timed out while waiting for VTUNE=%s. Walking VCOCAP...\n", return_value_vtune_str_3);
  }
  while((_Bool)0);
  while(!(*vcocap == limit))
  {
    *vcocap = *vcocap + (unsigned char)inc;
    status=write_vcocap(dev, base, *vcocap, vcocap_reg_state);
    if(!(status == 0))
      return status;

    status=get_vtune(dev, base, (unsigned char)25, &vtune);
    if(!(status == 0))
      return status;

    else
      if(vtune == target_value)
      {
        do
        {
          const char *return_value_vtune_str_4;
          return_value_vtune_str_4=vtune_str(vtune);
          log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:1996] VTUNE=%s reached with VCOCAP=%u\n", return_value_vtune_str_4, *vcocap);
        }
        while((_Bool)0);
        return 0;
      }

  }
  do
  {
    const char *return_value_vtune_str_5;
    return_value_vtune_str_5=vtune_str(target_value);
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_WARNING, "[WARNING @ lms.c:2002] VTUNE did not reach %s. Tuning may not be nominal.\n", return_value_vtune_str_5);
  }
  while((_Bool)0);
  return 0;
}

// write_and_verify_fw_chunk
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 914
static signed int write_and_verify_fw_chunk(struct bladerf_usb *usb, unsigned int addr, unsigned char *data, unsigned int len, unsigned char *readback_buf)
{
  signed int status;
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ usb.c:919] Writing %u bytes to bootloader @ 0x%08x\n", len, addr);
  while((_Bool)0);
  status=usb->fn->control_transfer(usb->driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, (unsigned char)0xa0, (unsigned short int)(addr & (unsigned int)0xffff), (unsigned short int)(addr >> 16 & (unsigned int)0xffff), (void *)data, len, (unsigned int)1000);
  if(!(status == 0))
  {
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:932] Failed to write FW chunk (%d)\n", status);
    return status;
  }

  else
  {
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ usb.c:936] Reading back %u bytes from bootloader @ 0x%08x\n", len, addr);
    status=usb->fn->control_transfer(usb->driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_DEVICE_TO_HOST, (unsigned char)0xa0, (unsigned short int)(addr & (unsigned int)0xffff), (unsigned short int)(addr >> 16 & (unsigned int)0xffff), (void *)readback_buf, len, (unsigned int)1000);
    if(!(status == 0))
    {
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:949] Failed to read back FW chunk (%d)\n", status);
      return status;
    }

    else
    {
      signed int return_value_memcmp_1;
      return_value_memcmp_1=memcmp((const void *)data, (const void *)readback_buf, (unsigned long int)len);
      if(!(return_value_memcmp_1 == 0))
      {
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ usb.c:954] Readback did match written data.\n");
        status = -1;
      }

      return status;
    }
  }
}

// write_fw_to_bootloader
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 992
static signed int write_fw_to_bootloader(void *driver, struct fx3_firmware *fw)
{
  signed int status = 0;
  unsigned int to_write;
  unsigned int data_len;
  unsigned int addr;
  unsigned char *data;
  _Bool got_section;
  unsigned char *readback;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)4096);
  readback = (unsigned char *)return_value_malloc_1;
  if(readback == ((unsigned char *)NULL))
    return -4;

  else
  {
    do
    {
      got_section=fx3_fw_next_section(fw, &addr, &data, &data_len);
      if(!(got_section == (_Bool)0))
      {
        /* assertion data_len != 0 */
        assert(data_len != (unsigned int)0);
        do
        {
          to_write=u32_min(data_len, (unsigned int)4096);
          status=write_and_verify_fw_chunk((struct bladerf_usb *)driver, addr, data, to_write, readback);
          data_len = data_len - to_write;
          addr = addr + to_write;
          data = data + (signed long int)to_write;
        }
        while(status == 0 && !(data_len == 0u));
      }

    }
    while(status == 0 && got_section != (_Bool)0);
    if(status == 0)
    {
      unsigned int return_value_fx3_fw_entry_point_2;
      return_value_fx3_fw_entry_point_2=fx3_fw_entry_point(fw);
      status=execute_fw_from_bootloader((struct bladerf_usb *)driver, return_value_fx3_fw_entry_point_2);
    }

    free((void *)readback);
    return status;
  }
}

// write_page
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/backend/usb/usb.c line 624
static signed int write_page(struct bladerf *dev, unsigned short int page, const unsigned char *buf)
{
  signed int status;
  signed int commit_status;
  unsigned short int offset;
  unsigned short int write_size;
  void *driver;
  struct bladerf_usb *usb;
  usb=usb_backend_link2(dev, &driver);
  if((signed int)dev->usb_speed == BLADERF_DEVICE_SPEED_SUPER)
    write_size = (unsigned short int)256;

  else
    if((signed int)dev->usb_speed == BLADERF_DEVICE_SPEED_HIGH)
      write_size = (unsigned short int)64;

    else
    {
      /* assertion !"BUG - unexpected device speed" */
      assert(!((_Bool)"BUG - unexpected device speed"));
      return -1;
    }
  offset = (unsigned short int)0;
  if(!((signed int)offset >= 256))
  {
    status=usb->fn->control_transfer(driver, (enum anonymous_28)USB_TARGET_DEVICE, (enum anonymous_29)USB_REQUEST_VENDOR, (enum anonymous_30)USB_DIR_HOST_TO_DEVICE, (unsigned char)108, (unsigned short int)0, offset, (void *)(unsigned char *)&buf[(signed long int)offset], (unsigned int)write_size, (unsigned int)1000);
    if(!(status >= 0))
    {
      const char *return_value_bladerf_strerror_1;
      return_value_bladerf_strerror_1=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ usb.c:660] Failed to write page buffer at offset 0x%02x for page %u: %s\n", offset, page, return_value_bladerf_strerror_1);
      return status;
    }

    offset = offset + write_size;
  }

  status=vendor_cmd_int_windex(dev, (unsigned char)101, page, &commit_status);
  if(!(status == 0))
  {
    do
    {
      const char *return_value_bladerf_strerror_2;
      return_value_bladerf_strerror_2=bladerf_strerror(status);
      log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ usb.c:671] Failed to commit page %u: %s\n", page, return_value_bladerf_strerror_2);
    }
    while((_Bool)0);
    return status;
  }

  else
    if(!(commit_status == 0))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_ERROR, "[ERROR @ usb.c:676] Failed to commit page %u, FW returned %d\n", page, commit_status);
      while((_Bool)0);
      return -1;
    }

  return 0;
}

// write_pll_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 362
static signed int write_pll_config(struct bladerf *dev, enum anonymous module, unsigned char freqsel, _Bool low_band)
{
  signed int status;
  unsigned char regval;
  unsigned char selout;
  unsigned char addr;
  if((signed int)module == BLADERF_MODULE_TX)
    addr = (unsigned char)0x15;

  else
    addr = (unsigned char)0x25;
  status=dev->fn->lms_read(dev, addr, &regval);
  if(!(status == 0))
    return status;

  else
  {
    status=is_loopback_enabled(dev);
    if(!(status >= 0))
      return status;

    else
    {
      if(status == 0)
      {
        selout = (unsigned char)(low_band != (_Bool)0 ? 1 : 2);
        regval = (unsigned char)((signed int)freqsel << 2 | (signed int)selout);
      }

      else
        regval = (unsigned char)((signed int)regval & ~0xfc | (signed int)freqsel << 2);
      signed int return_value;
      return_value=dev->fn->lms_write(dev, addr, regval);
      return return_value;
    }
  }
}

// write_vcocap
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/fpga_common/src/lms.c line 1786
static inline signed int write_vcocap(struct bladerf *dev, unsigned char base, unsigned char vcocap, unsigned char vcocap_reg_state)
{
  signed int status;
  /* assertion vcocap <= 0x3f */
  assert((signed int)vcocap <= 0x3f);
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ lms.c:1792] Writing VCOCAP=%u\n", vcocap);
  while((_Bool)0);
  status=dev->fn->lms_write(dev, (unsigned char)((signed int)base + 9), (unsigned char)((signed int)vcocap | (signed int)vcocap_reg_state));
  if(!(status == 0))
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ lms.c:1797] VCOCAP write failed: %d\n", status);

  return status;
}

// xb200_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.c line 65
static signed int xb200_attach(struct bladerf *dev)
{
  signed int status = 0;
  unsigned int val;
  unsigned char val8;
  unsigned int muxout = (unsigned int)6;
  const char *mux_lut[8l] = { "THREE-STATE OUTPUT", "DVdd", "DGND", "R COUNTER OUTPUT", "N DIVIDER OUTPUT", "ANALOG LOCK DETECT", "DIGITAL LOCK DETECT", "RESERVED" };
  do
    log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:82]   Attaching transverter board\n");
  while((_Bool)0);
  status=dev->fn->si5338_read(dev, (unsigned char)39, &val8);
  if(!(status >= 0))
    return status;

  else
  {
    val8 = val8 | (unsigned char)2;
    status=dev->fn->si5338_write(dev, (unsigned char)39, val8);
    if(!(status == 0))
      return status;

    else
    {
      status=dev->fn->si5338_write(dev, (unsigned char)34, (unsigned char)0x22);
      if(!(status == 0))
        return status;

      else
      {
        status=dev->fn->config_gpio_read(dev, &val);
        if(!(status == 0))
          return status;

        else
        {
          val = val | 0x80000000;
          status=config_gpio_write(dev, val);
          if(!(status == 0))
            return status;

          else
          {
            status=dev->fn->expansion_gpio_read(dev, &val);
            if(!(status == 0))
              return status;

            else
            {
              status=dev->fn->expansion_gpio_dir_write(dev, 0xffffffff, (unsigned int)0x3C00383E);
              if(!(status == 0))
                return status;

              else
              {
                status=dev->fn->expansion_gpio_write(dev, 0xffffffff, (unsigned int)0x800);
                if(!(status == 0))
                  return status;

                else
                {
                  status=dev->fn->xb_spi(dev, (unsigned int)0x580005);
                  if(!(status == 0))
                    return status;

                  else
                  {
                    status=dev->fn->xb_spi(dev, (unsigned int)0x99A16C);
                    if(!(status == 0))
                      return status;

                    else
                    {
                      status=dev->fn->xb_spi(dev, (unsigned int)0xC004B3);
                      if(!(status == 0))
                        return status;

                      else
                      {
                        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:116]   MUXOUT: %s\n", mux_lut[(signed long int)muxout]);
                        status=dev->fn->xb_spi(dev, (unsigned int)(0x60008E42 | 1 << 8) | muxout << 26);
                        if(!(status == 0))
                          return status;

                        else
                        {
                          status=dev->fn->xb_spi(dev, (unsigned int)0x08008011);
                          if(!(status == 0))
                            return status;

                          else
                          {
                            status=dev->fn->xb_spi(dev, (unsigned int)0x00410000);
                            if(!(status == 0))
                              return status;

                            else
                            {
                              status=dev->fn->expansion_gpio_read(dev, &val);
                              if(status == 0 && !((1u & val) == 0u))
                                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:127]   MUXOUT Bit set: OK\n");

                              else
                                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:129]   MUXOUT Bit not set: FAIL\n");
                              status=dev->fn->expansion_gpio_write(dev, 0xffffffff, (unsigned int)0x3C000800);
                              return status;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// xb200_auto_filter_selection
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 88
signed int xb200_auto_filter_selection(struct bladerf *dev, enum anonymous mod, unsigned int frequency)
{
  signed int status;
  enum anonymous_8 filter;
  if(frequency >= 300000000u)
    return 0;

  else
  {
    status=check_module(mod);
    if(!(status == 0))
      return status;

    else
    {
      if((signed int)dev->auto_filter[(signed long int)mod] == BLADERF_XB200_AUTO_1DB)
      {
        if(frequency >= 37774405u && !(frequency >= 59535437u))
          filter = (enum anonymous_8)BLADERF_XB200_50M;

        else
          if(frequency >= 128326173u && !(frequency >= 166711172u))
            filter = (enum anonymous_8)BLADERF_XB200_144M;

          else
            if(frequency >= 187593160u && !(frequency >= 245346404u))
              filter = (enum anonymous_8)BLADERF_XB200_222M;

            else
              filter = (enum anonymous_8)BLADERF_XB200_CUSTOM;
        status=set_filterbank_mux(dev, mod, filter);
      }

      else
        if((signed int)dev->auto_filter[(signed long int)mod] == BLADERF_XB200_AUTO_3DB)
        {
          if(frequency >= 34782924u && !(frequency >= 61899261u))
            filter = (enum anonymous_8)BLADERF_XB200_50M;

          else
            if(frequency >= 121956957u && !(frequency >= 178444100u))
              filter = (enum anonymous_8)BLADERF_XB200_144M;

            else
              if(frequency >= 177522675u && !(frequency >= 260140936u))
                filter = (enum anonymous_8)BLADERF_XB200_222M;

              else
                filter = (enum anonymous_8)BLADERF_XB200_CUSTOM;
          status=set_filterbank_mux(dev, mod, filter);
        }

      return status;
    }
  }
}

// xb200_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.c line 136
signed int xb200_enable(struct bladerf *dev, _Bool enable)
{
  signed int status;
  unsigned int val;
  unsigned int orig;
  status=dev->fn->expansion_gpio_read(dev, &orig);
  if(!(status == 0))
    return status;

  else
  {
    val = orig;
    if(!(enable == (_Bool)0))
      val = val | (unsigned int)0x0800;

    else
      val = val & (unsigned int)~0x0800;
    if(val == orig || !(status == 0))
      return status;

    else
    {
      signed int return_value;
      return_value=dev->fn->expansion_gpio_write(dev, 0xffffffff, val);
      return return_value;
    }
  }
}

// xb200_get_filterbank
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 101
signed int xb200_get_filterbank(struct bladerf *dev, enum anonymous module, enum anonymous_8 *filter)
{
  signed int status;
  unsigned int val;
  unsigned int shift;
  status=check_module(module);
  if(!(status == 0))
    return status;

  else
  {
    status=dev->fn->expansion_gpio_read(dev, &val);
    if(!(status == 0))
      return status;

    else
    {
      if((signed int)module == BLADERF_MODULE_RX)
        shift = (unsigned int)28;

      else
        shift = (unsigned int)26;
      *filter = (enum anonymous_8)(val >> shift & (unsigned int)3);
      status=check_xb200_filter(*filter);
      if(!(status == 0))
      {
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:297] Read back invalid GPIO state: 0x%08x\n", val);
        status = -1;
      }

      return status;
    }
  }
}

// xb200_get_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 126
signed int xb200_get_path(struct bladerf *dev, enum anonymous module, enum anonymous_35 *path)
{
  signed int status;
  unsigned int val;
  status=check_module(module);
  if(!(status == 0))
    return status;

  else
  {
    status=dev->fn->expansion_gpio_read(dev, &val);
    if(!(status == 0))
      return status;

    else
    {
      if((signed int)module == BLADERF_MODULE_RX)
        *path = (enum anonymous_35)((val & (unsigned int)0x10) != 0u ? BLADERF_XB200_MIX : BLADERF_XB200_BYPASS);

      else
        if((signed int)module == BLADERF_MODULE_TX)
          *path = (enum anonymous_35)((val & (unsigned int)0x04) != 0u ? BLADERF_XB200_MIX : BLADERF_XB200_BYPASS);

      return 0;
    }
  }
}

// xb200_set_filterbank
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 75
signed int xb200_set_filterbank(struct bladerf *dev, enum anonymous module, enum anonymous_8 filter)
{
  signed int status = 0;
  unsigned int frequency;
  status=check_module(module);
  if(!(status == 0))
    return status;

  else
  {
    status=check_xb200_filter(filter);
    if(!(status == 0))
      return status;

    else
    {
      if((signed int)filter == BLADERF_XB200_AUTO_1DB || (signed int)filter == BLADERF_XB200_AUTO_3DB)
      {
        dev->auto_filter[(signed long int)module] = filter;
        status=tuning_get_freq(dev, module, &frequency);
        if(status == 0)
          status=xb200_auto_filter_selection(dev, module, frequency);

      }

      else
      {
        dev->auto_filter[(signed long int)module] = (enum anonymous_8)-1;
        status=set_filterbank_mux(dev, module, filter);
      }
      return status;
    }
  }
}

// xb200_set_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 113
signed int xb200_set_path(struct bladerf *dev, enum anonymous module, enum anonymous_35 path)
{
  signed int status;
  unsigned int val;
  unsigned int mask;
  unsigned char lval;
  unsigned char lorig = (unsigned char)0;
  status=check_module(module);
  if(!(status == 0))
    return status;

  else
  {
    status=check_xb200_path(path);
    if(!(status == 0))
      return status;

    else
    {
      status=dev->fn->lms_read(dev, (unsigned char)0x5A, &lorig);
      if(!(status == 0))
        return status;

      else
      {
        lval = lorig;
        if((signed int)path == BLADERF_XB200_MIX)
          lval = lval | (unsigned char)((signed int)module == BLADERF_MODULE_RX ? 0x40 : 0x08);

        else
          lval = lval & (unsigned char)~((signed int)module == BLADERF_MODULE_RX ? 0x40 : 0x08);
        status=dev->fn->lms_write(dev, (unsigned char)0x5A, lval);
        if(!(status == 0))
          return status;

        else
        {
          status=dev->fn->expansion_gpio_read(dev, &val);
          if(!(status == 0))
            return status;

          else
          {
            status=dev->fn->expansion_gpio_read(dev, &val);
            if(!(status == 0))
              return status;

            else
              if((2048u & val) == 0u)
              {
                status=xb200_attach(dev);
                return status;
              }

              else
              {
                if((signed int)module == BLADERF_MODULE_RX)
                  mask = (unsigned int)(0x30 | 0x2000);

                else
                  mask = (unsigned int)(0x0C | 0x1000);
                val = val | (unsigned int)0x0800;
                val = val & ~mask;
                if((signed int)module == BLADERF_MODULE_RX)
                {
                  if((signed int)path == BLADERF_XB200_MIX)
                    val = val | (unsigned int)(0x2000 | 0x10);

                  else
                    val = val | (unsigned int)0x20;
                }

                else
                  if((signed int)path == BLADERF_XB200_MIX)
                    val = val | (unsigned int)(0x1000 | 0x04);

                  else
                    val = val | (unsigned int)0x08;
                signed int return_value;
                return_value=dev->fn->expansion_gpio_write(dev, 0xffffffff, val);
                return return_value;
              }
          }
        }
      }
    }
  }
}

// xb_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 54
signed int xb_attach(struct bladerf *dev, enum anonymous_6 xb)
{
  enum anonymous_6 attached;
  signed int status;
  status=xb_get_attached(dev, &attached);
  _Bool return_value_have_cap_1;
  unsigned int mask;
  unsigned int outputs;
  unsigned int default_values;
  _Bool return_value_have_cap_2;
  if(!(status == 0))
    return status;

  else
    if(!(xb == attached) && !((signed int)attached == BLADERF_XB_NONE))
    {
      do
        log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:166] %s: Switching XB types is not supported.\n", (const void *)"xb_attach");
      while((_Bool)0);
      return -8;
    }

    else
    {
      switch((signed int)xb)
      {
        case BLADERF_XB_100:
        {
          return_value_have_cap_1=have_cap_link3(dev, (unsigned long int)(1 << 7));
          if(return_value_have_cap_1 == (_Bool)0)
          {
            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:175] %s: XB100 support requires FPGA v0.4.1 or later.\n", (const void *)"xb_attach");
            while((_Bool)0);
            return -8;
          }

          mask = (const unsigned int)(1 << 24 - 1 | 1 << 32 - 1 | 1 << 30 - 1 | 1 << 28 - 1 | 1 << 23 - 1 | 1 << 25 - 1 | 1 << 31 - 1 | 1 << 29 - 1 | 1 << 22 - 1 | 1 << 21 - 1 | 1 << 20 - 1);
          outputs = mask;
          default_values = mask;
          status=dev->fn->expansion_gpio_dir_write(dev, mask, outputs);
        }
        case BLADERF_XB_200:
        {
          return_value_have_cap_2=have_cap_link3(dev, (unsigned long int)(1 << 1));
          if(return_value_have_cap_2 == (_Bool)0)
          {
            do
              log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:205] %s: XB200 support requires FPGA v0.0.5 or later\n", (const void *)"xb_attach");
            while((_Bool)0);
            status = -12;
          }

          else
            if(!(attached == xb))
            {
              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ xb.c:208] Attaching XB200\n");
              while((_Bool)0);
              status=xb200_attach(dev);
              if(!(status == 0))
                break;

              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ xb.c:213] Enabling XB200\n");
              while((_Bool)0);
              status=xb200_enable(dev, (_Bool)1);
              if(!(status == 0))
                break;

              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ xb.c:218] Setting RX path\n");
              while((_Bool)0);
              status=xb200_set_path(dev, (enum anonymous)BLADERF_MODULE_RX, (enum anonymous_35)BLADERF_XB200_BYPASS);
              if(!(status == 0))
                break;

              do
                log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ xb.c:223] Setting TX path\n");
              while((_Bool)0);
              status=xb200_set_path(dev, (enum anonymous)BLADERF_MODULE_TX, (enum anonymous_35)BLADERF_XB200_BYPASS);
            }

          if(!(status == 0))
            break;

          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ xb.c:229] Setting RX filter\n");
          while((_Bool)0);
          status=xb200_set_filterbank(dev, (enum anonymous)BLADERF_MODULE_RX, (enum anonymous_8)BLADERF_XB200_AUTO_1DB);
          if(!(status == 0))
            break;

          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_VERBOSE, "[VERBOSE @ xb.c:234] Setting TX filter\n");
          while((_Bool)0);
          status=xb200_set_filterbank(dev, (enum anonymous)BLADERF_MODULE_TX, (enum anonymous_8)BLADERF_XB200_AUTO_1DB);
          break;
        }
        case BLADERF_XB_NONE:
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:240] %s: Disabling an attached XB is not supported.\n", (const void *)"xb_attach");
          while((_Bool)0);
          status = -8;
          break;
        }
        default:
        {
          do
            log_write((enum anonymous_26)BLADERF_LOG_LEVEL_DEBUG, "[DEBUG @ xb.c:245] %s: Unknown xb type: %d\n", (const void *)"xb_attach", xb);
          while((_Bool)0);
          status = -3;
        }
      }
      if(status == 0)
        dev->xb = xb;

      return status;
    }
}

// xb_get_attached
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/libraries/libbladeRF/src/xb.h line 64
signed int xb_get_attached(struct bladerf *dev, enum anonymous_6 *xb)
{
  signed int status;
  unsigned int val;
  status=dev->fn->config_gpio_read(dev, &val);
  if(!(status == 0))
    return status;

  else
  {
    *xb = (enum anonymous_6)(val >> 30 & (unsigned int)0x3);
    return 0;
  }
}

// zero_argvs
// file /srv/jenkins-slave/workspace/sid-goto-cc-bladerf/bladerf-0.2016.01~rc1/host/common/src/conversions.c line 297
static void zero_argvs(signed int start, signed int end, char **argv)
{
  signed int i = start;
  for( ; end >= i; i = i + 1)
    argv[(signed long int)i] = (char *)(void *)0;
}

