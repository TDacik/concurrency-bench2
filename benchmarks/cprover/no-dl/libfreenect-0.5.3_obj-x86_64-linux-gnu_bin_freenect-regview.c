// #anon_enum_FREENECT_AUTO_EXPOSURE=16384_FREENECT_AUTO_WHITE_BALANCE=2_FREENECT_RAW_COLOR=16_FREENECT_MIRROR_DEPTH=65536_FREENECT_MIRROR_VIDEO=131072_FREENECT_NEAR_MODE=262144
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 110
enum anonymous_3 { FREENECT_AUTO_EXPOSURE=16384, FREENECT_AUTO_WHITE_BALANCE=2, FREENECT_RAW_COLOR=16, FREENECT_MIRROR_DEPTH=65536, FREENECT_MIRROR_VIDEO=131072, FREENECT_NEAR_MODE=262144 };

// #anon_enum_FREENECT_DEPTH_11BIT=0_FREENECT_DEPTH_10BIT=1_FREENECT_DEPTH_11BIT_PACKED=2_FREENECT_DEPTH_10BIT_PACKED=3_FREENECT_DEPTH_REGISTERED=4_FREENECT_DEPTH_MM=5_FREENECT_DEPTH_DUMMY=2147483647
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 99
enum anonymous_8 { FREENECT_DEPTH_11BIT=0, FREENECT_DEPTH_10BIT=1, FREENECT_DEPTH_11BIT_PACKED=2, FREENECT_DEPTH_10BIT_PACKED=3, FREENECT_DEPTH_REGISTERED=4, FREENECT_DEPTH_MM=5, FREENECT_DEPTH_DUMMY=2147483647 };

// #anon_enum_FREENECT_DEVICE_MOTOR=1_FREENECT_DEVICE_CAMERA=2_FREENECT_DEVICE_AUDIO=4
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 58
enum anonymous_25 { FREENECT_DEVICE_MOTOR=1, FREENECT_DEVICE_CAMERA=2, FREENECT_DEVICE_AUDIO=4 };

// #anon_enum_FREENECT_LOG_FATAL=0_FREENECT_LOG_ERROR=1_FREENECT_LOG_WARNING=2_FREENECT_LOG_NOTICE=3_FREENECT_LOG_INFO=4_FREENECT_LOG_DEBUG=5_FREENECT_LOG_SPEW=6_FREENECT_LOG_FLOOD=7
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 201
enum anonymous_11 { FREENECT_LOG_FATAL=0, FREENECT_LOG_ERROR=1, FREENECT_LOG_WARNING=2, FREENECT_LOG_NOTICE=3, FREENECT_LOG_INFO=4, FREENECT_LOG_DEBUG=5, FREENECT_LOG_SPEW=6, FREENECT_LOG_FLOOD=7 };

// #anon_enum_FREENECT_OFF=0_FREENECT_ON=1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 122
enum anonymous_4 { FREENECT_OFF=0, FREENECT_ON=1 };

// #anon_enum_FREENECT_RESOLUTION_LOW=0_FREENECT_RESOLUTION_MEDIUM=1_FREENECT_RESOLUTION_HIGH=2_FREENECT_RESOLUTION_DUMMY=2147483647
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 77
enum anonymous_0 { FREENECT_RESOLUTION_LOW=0, FREENECT_RESOLUTION_MEDIUM=1, FREENECT_RESOLUTION_HIGH=2, FREENECT_RESOLUTION_DUMMY=2147483647 };

// #anon_enum_FREENECT_VIDEO_RGB=0_FREENECT_VIDEO_BAYER=1_FREENECT_VIDEO_IR_8BIT=2_FREENECT_VIDEO_IR_10BIT=3_FREENECT_VIDEO_IR_10BIT_PACKED=4_FREENECT_VIDEO_YUV_RGB=5_FREENECT_VIDEO_YUV_RAW=6_FREENECT_VIDEO_DUMMY=2147483647
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 86
enum anonymous_1 { FREENECT_VIDEO_RGB=0, FREENECT_VIDEO_BAYER=1, FREENECT_VIDEO_IR_8BIT=2, FREENECT_VIDEO_IR_10BIT=3, FREENECT_VIDEO_IR_10BIT_PACKED=4, FREENECT_VIDEO_YUV_RGB=5, FREENECT_VIDEO_YUV_RAW=6, FREENECT_VIDEO_DUMMY=2147483647 };

// #anon_enum_LED_OFF=0_LED_GREEN=1_LED_RED=2_LED_YELLOW=3_LED_BLINK_GREEN=4_LED_BLINK_RED_YELLOW=6
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 149
enum anonymous_19 { LED_OFF=0, LED_GREEN=1, LED_RED=2, LED_YELLOW=3, LED_BLINK_GREEN=4, LED_BLINK_RED_YELLOW=6 };

// #anon_enum_TILT_STATUS_STOPPED=0_TILT_STATUS_LIMIT=1_TILT_STATUS_MOVING=4
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 161
enum anonymous_31 { TILT_STATUS_STOPPED=0, TILT_STATUS_LIMIT=1, TILT_STATUS_MOVING=4 };

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_'parent'||*{SYM#tag-libusb_device_handle#}_SYM#tag-libusb_device_handle#_'dev'||S32'device_dead'||S32'VID'||S32'PID'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_'parent'||*{SYM#tag-libusb_device_handle#}_SYM#tag-libusb_device_handle#_'dev'||S32'device_dead'||S32'VID'||S32'PID'||U32'_pad0'|]#_'parent'||*{*{SYM#tag-libusb_transfer#}_SYM#tag-libusb_transfer#_}_*{SYM#tag-libusb_transfer#}_SYM#tag-libusb_transfer#__'xfers'||*{U8}_U8_'buffer'||*{V(*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_|*{U8}_U8_|S32)->V}_V(*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_|*{U8}_U8_|S32)->V_'cb'||S32'num_xfers'||S32'pkts'||S32'len'||S32'dead'||S32'dead_xfers'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 65
struct anonymous_18;

// tag-#anon#ST[*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_'parent'||*{SYM#tag-libusb_device_handle#}_SYM#tag-libusb_device_handle#_'dev'||S32'device_dead'||S32'VID'||S32'PID'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 57
struct anonymous_17;

// tag-#anon#ST[*{SYM#tag-libusb_context#}_SYM#tag-libusb_context#_'ctx'||S32'should_free_ctx'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 52
struct anonymous_16;

// tag-#anon#ST[ARR2{U8}_U8_'magic'||U16'len'||U16'cmd'||U16'tag'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 132
struct anonymous_2;

// tag-#anon#ST[F32'dcmos_emitter_dist'||F32'dcmos_rcmos_dist'||F32'reference_distance'||F32'reference_pixel_size'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 91
struct anonymous;

// tag-#anon#ST[S16'accelerometer_x'||S16'accelerometer_y'||S16'accelerometer_z'||S8'tilt_angle'||U8'_pad0'||EN#anon_enum_TILT_STATUS_STOPPED=0_TILT_STATUS_LIMIT=1_TILT_STATUS_MOVING=4#{U32}_U32_'tilt_status'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 168
struct anonymous_30;

// tag-#anon#ST[S16'left'||S16'right'||S16'center'||S16'lfe'||S16'surround_left'||S16'surround_right'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_audio.h line 36
struct anonymous_14;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_12;

// tag-#anon#ST[S32'dx_center'||S32'ax'||S32'bx'||S32'cx'||S32'dx'||S32'dx_start'||S32'ay'||S32'by'||S32'cy'||S32'dy'||S32'dy_start'||S32'dx_beta_start'||S32'dy_beta_start'||S32'rollout_blank'||S32'rollout_size'||S32'dx_beta_inc'||S32'dy_beta_inc'||S32'dxdx_start'||S32'dxdy_start'||S32'dydx_start'||S32'dydy_start'||S32'dxdxdx_start'||S32'dydxdx_start'||S32'dxdxdy_start'||S32'dydxdy_start'||S32'back_comp1'||S32'dydydx_start'||S32'back_comp2'||S32'dydydy_start'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 38
struct anonymous_5;

// tag-#anon#ST[S32'running'||U32'_pad0'||*{SYM#tag-#anon#ST[S16'left'||S16'right'||S16'center'||S16'lfe'||S16'surround_left'||S16'surround_right'|]#}_SYM#tag-#anon#ST[S16'left'||S16'right'||S16'center'||S16'lfe'||S16'surround_left'||S16'surround_right'|]#_'audio_out_ring'||S32'ring_reader_idx'||S32'ring_writer_idx'||U16'out_window'||U8'out_seq'||U8'out_counter_within_window'||U16'out_weird_timestamp'||U8'out_window_parity'||U8'_pad1'||U16'in_window'||ARR10{U16}_U16_'last_seen_window'||U8'in_counter'||U8'_pad2'||ARR4{*{S32}_S32_}_*{S32}_S32__'mic_buffer'||*{S16}_S16_'cancelled_buffer'||*{V}_V_'in_unknown'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/freenect_internal.h line 174
struct anonymous_15;

// tag-#anon#ST[S32'running'||U8'flag'||U24'_pad0'||S32'synced'||U8'seq'||U24'_pad1'||S32'got_pkts'||S32'pkt_num'||S32'pkts_per_frame'||S32'pkt_size'||S32'frame_size'||S32'last_pkt_size'||S32'valid_pkts'||U32'lost_pkts'||S32'valid_frames'||S32'variable_length'||U32'last_timestamp'||U32'timestamp'||S32'split_bufs'||U32'_pad2'||*{V}_V_'lib_buf'||*{V}_V_'usr_buf'||*{U8}_U8_'raw_buf'||*{V}_V_'proc_buf'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/freenect_internal.h line 150
struct anonymous_28;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'dx_center'||S32'ax'||S32'bx'||S32'cx'||S32'dx'||S32'dx_start'||S32'ay'||S32'by'||S32'cy'||S32'dy'||S32'dy_start'||S32'dx_beta_start'||S32'dy_beta_start'||S32'rollout_blank'||S32'rollout_size'||S32'dx_beta_inc'||S32'dy_beta_inc'||S32'dxdx_start'||S32'dxdy_start'||S32'dydx_start'||S32'dydy_start'||S32'dxdxdx_start'||S32'dydxdx_start'||S32'dxdxdy_start'||S32'dydxdy_start'||S32'back_comp1'||S32'dydydx_start'||S32'back_comp2'||S32'dydydy_start'|]#'reg_info'||SYM#tag-#anon#ST[U16'start_lines'||U16'end_lines'||U16'cropping_lines'|]#'reg_pad_info'||U16'_pad0'||SYM#tag-#anon#ST[F32'dcmos_emitter_dist'||F32'dcmos_rcmos_dist'||F32'reference_distance'||F32'reference_pixel_size'|]#'zero_plane_info'||U32'_pad1'||F64'const_shift'||*{U16}_U16_'raw_to_mm_shift'||*{S32}_S32_'depth_to_rgb_shift'||*{ARR2{S32}_S32_}_ARR2{S32}_S32__'registration_table'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 99
struct anonymous_7;

// tag-#anon#ST[U16'start_lines'||U16'end_lines'||U16'cropping_lines'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 84
struct anonymous_6;

// tag-#anon#ST[U32'magic'||U16'channel'||U16'len'||U16'window'||U16'unknown'||ARR0{S32}_S32_'samples'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/freenect_internal.h line 197
struct anonymous_21;

// tag-#anon#ST[U32'magic'||U16'ver_minor'||U16'ver_major'||U16'ver_release'||U16'ver_patch'||U32'base_addr'||U32'size'||U32'entry_addr'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 42
struct anonymous_27;

// tag-#anon#ST[U32'magic'||U32'tag'||U32'arg1'||U32'cmd'||U32'arg2'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 43
struct anonymous_22;

// tag-#anon#ST[U32'magic'||U32'tag'||U32'arg1'||U32'cmd'||U32'arg2'||ARR8{U32}_U32_'zeros'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 53
struct anonymous_24;

// tag-#anon#ST[U32'magic'||U32'tag'||U32'bytes'||U32'cmd'||U32'addr'||U32'unk'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 33
struct anonymous_26;

// tag-#anon#ST[U32'magic'||U32'tag'||U32'status'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 51
struct anonymous_20;

// tag-#anon#ST[U32'reserved'||EN#anon_enum_FREENECT_RESOLUTION_LOW=0_FREENECT_RESOLUTION_MEDIUM=1_FREENECT_RESOLUTION_HIGH=2_FREENECT_RESOLUTION_DUMMY=2147483647#{U32}_U32_'resolution'||SYM#tag-#anon#UN[S32'dummy'||EN#anon_enum_FREENECT_VIDEO_RGB=0_FREENECT_VIDEO_BAYER=1_FREENECT_VIDEO_IR_8BIT=2_FREENECT_VIDEO_IR_10BIT=3_FREENECT_VIDEO_IR_10BIT_PACKED=4_FREENECT_VIDEO_YUV_RGB=5_FREENECT_VIDEO_YUV_RAW=6_FREENECT_VIDEO_DUMMY=2147483647#{U32}_U32_'video_format'||EN#anon_enum_FREENECT_DEPTH_11BIT=0_FREENECT_DEPTH_10BIT=1_FREENECT_DEPTH_11BIT_PACKED=2_FREENECT_DEPTH_10BIT_PACKED=3_FREENECT_DEPTH_REGISTERED=4_FREENECT_DEPTH_MM=5_FREENECT_DEPTH_DUMMY=2147483647#{U32}_U32_'depth_format'|]#'_anon0'||S32'bytes'||S16'width'||S16'height'||S8'data_bits_per_pixel'||S8'padding_bits_per_pixel'||S8'framerate'||S8'is_valid'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 130
struct anonymous_29;

// tag-#anon#UN[S32'dummy'||EN#anon_enum_FREENECT_VIDEO_RGB=0_FREENECT_VIDEO_BAYER=1_FREENECT_VIDEO_IR_8BIT=2_FREENECT_VIDEO_IR_10BIT=3_FREENECT_VIDEO_IR_10BIT_PACKED=4_FREENECT_VIDEO_YUV_RGB=5_FREENECT_VIDEO_YUV_RAW=6_FREENECT_VIDEO_DUMMY=2147483647#{U32}_U32_'video_format'||EN#anon_enum_FREENECT_DEPTH_11BIT=0_FREENECT_DEPTH_10BIT=1_FREENECT_DEPTH_11BIT_PACKED=2_FREENECT_DEPTH_10BIT_PACKED=3_FREENECT_DEPTH_REGISTERED=4_FREENECT_DEPTH_MM=5_FREENECT_DEPTH_DUMMY=2147483647#{U32}_U32_'depth_format'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 133
union anonymous_9;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_13;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_10;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_freenect_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 176
struct _freenect_context;

// tag-_freenect_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 179
struct _freenect_device;

// tag-freenect_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 67
struct freenect_device_attributes;

// tag-libusb_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 643
struct libusb_config_descriptor;

// tag-libusb_context
// file /usr/include/libusb-1.0/libusb.h line 898
struct libusb_context;

// tag-libusb_device
// file /usr/include/libusb-1.0/libusb.h line 899
struct libusb_device;

// tag-libusb_device_descriptor
// file /usr/include/libusb-1.0/libusb.h line 477
struct libusb_device_descriptor;

// tag-libusb_device_handle
// file /usr/include/libusb-1.0/libusb.h line 900
struct libusb_device_handle;

// tag-libusb_endpoint_descriptor
// file /usr/include/libusb-1.0/libusb.h line 531
struct libusb_endpoint_descriptor;

// tag-libusb_interface
// file /usr/include/libusb-1.0/libusb.h line 629
struct libusb_interface;

// tag-libusb_interface_descriptor
// file /usr/include/libusb-1.0/libusb.h line 581
struct libusb_interface_descriptor;

// tag-libusb_iso_packet_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1177
struct libusb_iso_packet_descriptor;

// tag-libusb_transfer
// file /usr/include/libusb-1.0/libusb.h line 1188
struct libusb_transfer;

// tag-libusb_transfer_status
// file /usr/include/libusb-1.0/libusb.h line 1106
enum libusb_transfer_status { LIBUSB_TRANSFER_COMPLETED=0, LIBUSB_TRANSFER_ERROR=1, LIBUSB_TRANSFER_TIMED_OUT=2, LIBUSB_TRANSFER_CANCELLED=3, LIBUSB_TRANSFER_STALL=4, LIBUSB_TRANSFER_NO_DEVICE=5, LIBUSB_TRANSFER_OVERFLOW=6 };

// tag-pkt_hdr
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 76
struct pkt_hdr;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// DrawGLScene
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 94
void DrawGLScene();
// InitGL
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 171
void InitGL(signed int Width, signed int Height);
// ReSizeGLScene
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 161
void ReSizeGLScene(signed int Width, signed int Height);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// complete_tables
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 306
static void complete_tables(struct anonymous_7 *reg);
// convert_bayer_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 453
static void convert_bayer_to_rgb(unsigned char *raw_buf, unsigned char *proc_buf, struct anonymous_29 frame_mode);
// convert_packed11_to_16bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 345
static void convert_packed11_to_16bit(unsigned char *raw, unsigned short int *frame, signed int n);
// convert_packed_to_16bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 304
static inline void convert_packed_to_16bit(unsigned char *src, unsigned short int *dest, signed int vw, signed int n);
// convert_packed_to_8bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 330
static inline void convert_packed_to_8bit(unsigned char *src, unsigned char *dest, signed int vw, signed int n);
// convert_uyvy_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 420
static void convert_uyvy_to_rgb(unsigned char *raw_buf, unsigned char *proc_buf, struct anonymous_29 frame_mode);
// depth_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 222
void depth_cb(struct _freenect_device *dev, void *v_depth, unsigned int timestamp);
// depth_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 377
static void depth_process(struct _freenect_device *dev, unsigned char *pkt, signed int len);
// dump_bl_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 36
static void dump_bl_cmd(struct _freenect_context *ctx, struct anonymous_26 cmd);
// dump_cemd_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 43
static void dump_cemd_cmd(struct _freenect_context *ctx, struct anonymous_24 cmd);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fn_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 262
void fn_log(struct _freenect_context *ctx, enum anonymous_11 level, const char *fmt, ...);
// fnusb_bulk
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 879
signed int fnusb_bulk(struct anonymous_17 *dev, unsigned char endpoint, unsigned char *data, signed int len, signed int *transferred);
// fnusb_claim_camera
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 255
signed int fnusb_claim_camera(struct _freenect_device *dev);
// fnusb_close_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 86
signed int fnusb_close_subdevices(struct _freenect_device *dev);
// fnusb_control
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 92
signed int fnusb_control(struct anonymous_17 *dev, unsigned char bmRequestType, unsigned char bRequest, unsigned short int wValue, unsigned short int wIndex, unsigned char *data, unsigned short int wLength);
// fnusb_find_connected_audio_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 69
struct libusb_device * fnusb_find_connected_audio_device(struct libusb_device *camera, struct libusb_device **deviceList, signed int cnt);
// fnusb_get_max_iso_packet_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 90
signed int fnusb_get_max_iso_packet_size(struct anonymous_17 *dev, unsigned char endpoint, signed int default_size);
// fnusb_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 80
signed int fnusb_init(struct anonymous_16 *ctx, void *usb_ctx);
// fnusb_is_pid_k4w_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 64
signed int fnusb_is_pid_k4w_audio(signed int pid);
// fnusb_list_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 78
signed int fnusb_list_device_attributes(struct anonymous_16 *ctx, struct freenect_device_attributes **attribute_list);
// fnusb_num_devices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 77
signed int fnusb_num_devices(struct anonymous_16 *ctx);
// fnusb_num_interfaces
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 884
signed int fnusb_num_interfaces(struct anonymous_17 *dev);
// fnusb_open_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 85
signed int fnusb_open_subdevices(struct _freenect_device *dev, signed int index);
// fnusb_process_events
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 245
signed int fnusb_process_events(struct anonymous_16 *ctx);
// fnusb_process_events_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 83
signed int fnusb_process_events_timeout(struct anonymous_16 *ctx, struct timeval *timeout);
// fnusb_set_led_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 246
signed int fnusb_set_led_alt(struct libusb_device_handle *dev, struct _freenect_context *ctx, enum anonymous_19 state);
// fnusb_shutdown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 81
signed int fnusb_shutdown(struct anonymous_16 *ctx);
// fnusb_start_iso
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 88
signed int fnusb_start_iso(struct anonymous_17 *dev, struct anonymous_18 *strm, void (*cb)(struct _freenect_device *, unsigned char *, signed int), unsigned char endpoint, signed int xfers, signed int pkts, signed int len);
// fnusb_start_iso::cb_object
//
void cb_object(struct _freenect_device *, unsigned char *, signed int);
// fnusb_stop_iso
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 89
signed int fnusb_stop_iso(struct anonymous_17 *dev, struct anonymous_18 *strm);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freenect_apply_depth_to_mm
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 34
signed int freenect_apply_depth_to_mm(struct _freenect_device *dev, unsigned char *input_packed, unsigned short int *output_mm);
// freenect_apply_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 33
signed int freenect_apply_registration(struct _freenect_device *dev, unsigned char *input_packed, unsigned short int *output_mm);
// freenect_camera_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.h line 35
signed int freenect_camera_init(struct _freenect_device *dev);
// freenect_camera_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.h line 36
signed int freenect_camera_teardown(struct _freenect_device *dev);
// freenect_camera_to_world
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 318
void freenect_camera_to_world(struct _freenect_device *dev, signed int cx, signed int cy, signed int wz, double *wx, double *wy);
// freenect_close_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 365
signed int freenect_close_device(struct _freenect_device *dev);
// freenect_copy_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 420
struct anonymous_7 freenect_copy_registration(struct _freenect_device *dev);
// freenect_create_dxdy_tables
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 194
static void freenect_create_dxdy_tables(double *reg_x_table, double *reg_y_table, signed int resolution_x, signed int resolution_y, struct anonymous_5 *regdata);
// freenect_destroy_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 116
signed int freenect_destroy_registration(struct anonymous_7 *reg);
// freenect_enabled_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 138
enum anonymous_25 freenect_enabled_subdevices(struct _freenect_context *ctx);
// freenect_fetch_reg_const_shift
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 769
static signed int freenect_fetch_reg_const_shift(struct _freenect_device *dev);
// freenect_fetch_reg_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 664
static signed int freenect_fetch_reg_info(struct _freenect_device *dev);
// freenect_fetch_reg_pad_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 742
static signed int freenect_fetch_reg_pad_info(struct _freenect_device *dev);
// freenect_fetch_zero_plane_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 794
static signed int freenect_fetch_zero_plane_info(struct _freenect_device *dev);
// freenect_find_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 650
struct anonymous_29 freenect_find_depth_mode(enum anonymous_0 res, enum anonymous_8 fmt);
// freenect_find_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 598
struct anonymous_29 freenect_find_video_mode(enum anonymous_0 res, enum anonymous_1 fmt);
// freenect_free_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 112
void freenect_free_device_attributes(struct freenect_device_attributes *attribute_list);
// freenect_get_current_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1197
struct anonymous_29 freenect_get_current_depth_mode(struct _freenect_device *dev);
// freenect_get_current_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1134
struct anonymous_29 freenect_get_current_video_mode(struct _freenect_device *dev);
// freenect_get_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1188
struct anonymous_29 freenect_get_depth_mode(signed int mode_num);
// freenect_get_depth_mode_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1183
signed int freenect_get_depth_mode_count();
// freenect_get_ir_brightness
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 96
signed int freenect_get_ir_brightness(struct _freenect_device *dev);
// freenect_get_mks_accel
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 331
void freenect_get_mks_accel(struct anonymous_30 *state, double *x, double *y, double *z);
// freenect_get_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 321
double freenect_get_tilt_degs(struct anonymous_30 *state);
// freenect_get_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 95
struct anonymous_30 * freenect_get_tilt_state(struct _freenect_device *dev);
// freenect_get_tilt_status
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 326
enum anonymous_31 freenect_get_tilt_status(struct anonymous_30 *state);
// freenect_get_user
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 247
void * freenect_get_user(struct _freenect_device *dev);
// freenect_get_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1125
struct anonymous_29 freenect_get_video_mode(signed int mode_num);
// freenect_get_video_mode_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1120
signed int freenect_get_video_mode_count();
// freenect_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 221
signed int freenect_init(struct _freenect_context **ctx, void *usb_ctx);
// freenect_init_depth_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 60
static void freenect_init_depth_to_rgb(signed int *depth_to_rgb, struct anonymous *zpi);
// freenect_init_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 32
signed int freenect_init_registration(struct _freenect_device *dev);
// freenect_init_registration_table
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 264
static void freenect_init_registration_table(signed int (*registration_table)[2l], struct anonymous_5 *reg_info);
// freenect_list_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 107
signed int freenect_list_device_attributes(struct _freenect_context *ctx, struct freenect_device_attributes **attribute_list);
// freenect_map_rgb_to_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 333
void freenect_map_rgb_to_depth(struct _freenect_device *dev, unsigned short int *depth_mm, unsigned char *rgb_raw, unsigned char *rgb_registered);
// freenect_num_devices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 281
signed int freenect_num_devices(struct _freenect_context *ctx);
// freenect_open_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 343
signed int freenect_open_device(struct _freenect_context *ctx, struct _freenect_device **dev, signed int index);
// freenect_open_device_by_camera_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 181
signed int freenect_open_device_by_camera_serial(struct _freenect_context *ctx, struct _freenect_device **dev, const char *camera_serial);
// freenect_process_events
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 259
signed int freenect_process_events(struct _freenect_context *ctx);
// freenect_process_events_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 80
signed int freenect_process_events_timeout(struct _freenect_context *ctx, struct timeval *timeout);
// freenect_raw_to_mm
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 297
static unsigned short int freenect_raw_to_mm(unsigned short int raw, struct anonymous_7 *reg);
// freenect_select_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 321
void freenect_select_subdevices(struct _freenect_context *ctx, enum anonymous_25 subdevs);
// freenect_set_audio_in_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 142
void freenect_set_audio_in_callback(struct _freenect_device *dev, void (*callback)(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *));
// freenect_set_audio_in_callback::callback_object
//
void callback_object(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *);
// freenect_set_audio_out_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 145
void freenect_set_audio_out_callback(struct _freenect_device *dev, void (*callback)(struct _freenect_device *, struct anonymous_14 *, signed int *));
// freenect_set_audio_out_callback::callback_object
//
void callback_object(struct _freenect_device *, struct anonymous_14 *, signed int *);
// freenect_set_depth_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1241
signed int freenect_set_depth_buffer(struct _freenect_device *dev, void *buf);
// freenect_set_depth_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 399
void freenect_set_depth_callback(struct _freenect_device *dev, void (*cb)(struct _freenect_device *, void *, unsigned int));
// freenect_set_depth_callback::cb_object
//
void cb_object(struct _freenect_device *, void *, unsigned int);
// freenect_set_depth_chunk_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1110
void freenect_set_depth_chunk_callback(struct _freenect_device *dev, void (*cb)(void *, void *, signed int, signed int, void *));
// freenect_set_depth_chunk_callback::cb_object
//
void cb_object(void *, void *, signed int, signed int, void *);
// freenect_set_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 661
signed int freenect_set_depth_mode(struct _freenect_device *dev, const struct anonymous_29 mode);
// freenect_set_flag
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 46
signed int freenect_set_flag(struct _freenect_device *dev, enum anonymous_3 flag, enum anonymous_4 value);
// freenect_set_fw_address_k4w
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 292
void freenect_set_fw_address_k4w(struct _freenect_context *ctx, unsigned char *fw_ptr, unsigned int num_bytes);
// freenect_set_fw_address_nui
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 286
void freenect_set_fw_address_nui(struct _freenect_context *ctx, unsigned char *fw_ptr, unsigned int num_bytes);
// freenect_set_ir_brightness
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 110
signed int freenect_set_ir_brightness(struct _freenect_device *dev, unsigned short int brightness);
// freenect_set_led
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 303
signed int freenect_set_led(struct _freenect_device *dev, enum anonymous_19 option);
// freenect_set_led_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 290
signed int freenect_set_led_alt(struct _freenect_device *dev, enum anonymous_19 state);
// freenect_set_log_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 257
void freenect_set_log_callback(struct _freenect_context *ctx, void (*cb)(struct _freenect_context *, enum anonymous_11, const char *));
// freenect_set_log_callback::cb_object
//
void cb_object(struct _freenect_context *, enum anonymous_11, const char *);
// freenect_set_log_level
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 241
void freenect_set_log_level(struct _freenect_context *ctx, enum anonymous_11 level);
// freenect_set_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 224
signed int freenect_set_tilt_degs(struct _freenect_device *dev, double angle);
// freenect_set_tilt_degs_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 189
signed int freenect_set_tilt_degs_alt(struct _freenect_device *dev, signed int tilt_degrees);
// freenect_set_user
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 242
void freenect_set_user(struct _freenect_device *dev, void *user);
// freenect_set_video_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 447
signed int freenect_set_video_buffer(struct _freenect_device *dev, void *buf);
// freenect_set_video_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 407
void freenect_set_video_callback(struct _freenect_device *dev, void (*cb)(struct _freenect_device *, void *, unsigned int));
// freenect_set_video_callback::cb_object
//
void cb_object(struct _freenect_device *, void *, unsigned int);
// freenect_set_video_chunk_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1115
void freenect_set_video_chunk_callback(struct _freenect_device *dev, void (*cb)(void *, void *, signed int, signed int, void *));
// freenect_set_video_chunk_callback::cb_object
//
void cb_object(void *, void *, signed int, signed int, void *);
// freenect_set_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 612
signed int freenect_set_video_mode(struct _freenect_device *dev, const struct anonymous_29 mode);
// freenect_shutdown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 230
signed int freenect_shutdown(struct _freenect_context *ctx);
// freenect_start_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 149
signed int freenect_start_audio(struct _freenect_device *dev);
// freenect_start_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 456
signed int freenect_start_depth(struct _freenect_device *dev);
// freenect_start_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 465
signed int freenect_start_video(struct _freenect_device *dev);
// freenect_stop_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_audio.h line 110
signed int freenect_stop_audio(struct _freenect_device *dev);
// freenect_stop_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 474
signed int freenect_stop_depth(struct _freenect_device *dev);
// freenect_stop_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 483
signed int freenect_stop_video(struct _freenect_device *dev);
// freenect_supported_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 128
signed int freenect_supported_subdevices(void);
// freenect_threadfunc
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 293
void * freenect_threadfunc(void *arg);
// freenect_update_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 155
signed int freenect_update_tilt_state(struct _freenect_device *dev);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// get_reply
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 60
signed int get_reply(struct libusb_device_handle *dev, struct _freenect_context *ctx);
// get_reply_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 50
static signed int get_reply_link1(struct anonymous_17 *dev_link1);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// glBegin
// file /usr/include/GL/gl.h line 929
void glBegin(unsigned int);
// glBindTexture
// file /usr/include/GL/gl.h line 1311
void glBindTexture(unsigned int, unsigned int);
// glBlendFunc
// file /usr/include/GL/gl.h line 760
void glBlendFunc(unsigned int, unsigned int);
// glClearColor
// file /usr/include/GL/gl.h line 750
void glClearColor(float, float, float, float);
// glClearDepth
// file /usr/include/GL/gl.h line 844
void glClearDepth(double);
// glColor4f
// file /usr/include/GL/gl.h line 1003
void glColor4f(float, float, float, float);
// glDepthFunc
// file /usr/include/GL/gl.h line 846
void glDepthFunc(unsigned int);
// glDepthMask
// file /usr/include/GL/gl.h line 848
void glDepthMask(unsigned char);
// glDisable
// file /usr/include/GL/gl.h line 798
void glDisable(unsigned int);
// glEnable
// file /usr/include/GL/gl.h line 796
void glEnable(unsigned int);
// glEnd
// file /usr/include/GL/gl.h line 931
void glEnd(void);
// glGenTextures
// file /usr/include/GL/gl.h line 1307
void glGenTextures(signed int, unsigned int *);
// glLoadIdentity
// file /usr/include/GL/gl.h line 883
void glLoadIdentity(void);
// glMatrixMode
// file /usr/include/GL/gl.h line 866
void glMatrixMode(unsigned int);
// glOrtho
// file /usr/include/GL/gl.h line 868
void glOrtho(double, double, double, double, double, double);
// glShadeModel
// file /usr/include/GL/gl.h line 1157
void glShadeModel(unsigned int);
// glTexCoord2f
// file /usr/include/GL/gl.h line 1042
void glTexCoord2f(float, float);
// glTexImage2D
// file /usr/include/GL/gl.h line 1294
void glTexImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glTexParameteri
// file /usr/include/GL/gl.h line 1270
void glTexParameteri(unsigned int, unsigned int, signed int);
// glVertex3f
// file /usr/include/GL/gl.h line 940
void glVertex3f(float, float, float);
// glViewport
// file /usr/include/GL/gl.h line 876
void glViewport(signed int, signed int, signed int, signed int);
// gl_threadfunc
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 197
void * gl_threadfunc(void *arg);
// glutCreateWindow
// file /usr/include/GL/freeglut_std.h line 412
signed int glutCreateWindow(const char *);
// glutDestroyWindow
// file /usr/include/GL/freeglut_std.h line 414
void glutDestroyWindow(signed int);
// glutDisplayFunc
// file /usr/include/GL/freeglut_std.h line 480
void glutDisplayFunc(void (*)(void));
// glutGet
// file /usr/include/GL/freeglut_std.h line 505
signed int glutGet(unsigned int);
// glutIdleFunc
// file /usr/include/GL/freeglut_std.h line 471
void glutIdleFunc(void (*)(void));
// glutInit
// file /usr/include/GL/freeglut_std.h line 398
void glutInit(signed int *, char **);
// glutInitDisplayMode
// file /usr/include/GL/freeglut_std.h line 401
void glutInitDisplayMode(unsigned int);
// glutInitWindowPosition
// file /usr/include/GL/freeglut_std.h line 399
void glutInitWindowPosition(signed int, signed int);
// glutInitWindowSize
// file /usr/include/GL/freeglut_std.h line 400
void glutInitWindowSize(signed int, signed int);
// glutKeyboardFunc
// file /usr/include/GL/freeglut_std.h line 476
void glutKeyboardFunc(void (*)(unsigned char, signed int, signed int));
// glutMainLoop
// file /usr/include/GL/freeglut_std.h line 407
void glutMainLoop(void);
// glutPostRedisplay
// file /usr/include/GL/freeglut_std.h line 432
void glutPostRedisplay(void);
// glutReshapeFunc
// file /usr/include/GL/freeglut_std.h line 478
void glutReshapeFunc(void (*)(signed int, signed int));
// glutSwapBuffers
// file /usr/include/GL/freeglut_std.h line 433
void glutSwapBuffers(void);
// idle
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 76
void idle();
// iso_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 703
static void iso_callback(struct libusb_transfer *xfer);
// iso_in_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 85
static void iso_in_callback(struct _freenect_device *dev, unsigned char *pkt, signed int len);
// iso_out_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 81
static void iso_out_callback(struct _freenect_device *dev, unsigned char *pkt, signed int len);
// keyPressed
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 144
void keyPressed(unsigned char key, signed int x, signed int y);
// libusb_alloc_transfer
// file /usr/include/libusb-1.0/libusb.h line 1477
struct libusb_transfer * libusb_alloc_transfer(signed int);
// libusb_attach_kernel_driver
// file /usr/include/libusb-1.0/libusb.h line 1399
signed int libusb_attach_kernel_driver(struct libusb_device_handle *, signed int);
// libusb_bulk_transfer
// file /usr/include/libusb-1.0/libusb.h line 1744
signed int libusb_bulk_transfer(struct libusb_device_handle *, unsigned char, unsigned char *, signed int, signed int *, unsigned int);
// libusb_cancel_transfer
// file /usr/include/libusb-1.0/libusb.h line 1479
signed int libusb_cancel_transfer(struct libusb_transfer *);
// libusb_claim_interface
// file /usr/include/libusb-1.0/libusb.h line 1376
signed int libusb_claim_interface(struct libusb_device_handle *, signed int);
// libusb_close
// file /usr/include/libusb-1.0/libusb.h line 1371
void libusb_close(struct libusb_device_handle *);
// libusb_control_transfer
// file /usr/include/libusb-1.0/libusb.h line 1740
signed int libusb_control_transfer(struct libusb_device_handle *, unsigned char, unsigned char, unsigned short int, unsigned short int, unsigned char *, unsigned short int, unsigned int);
// libusb_detach_kernel_driver
// file /usr/include/libusb-1.0/libusb.h line 1397
signed int libusb_detach_kernel_driver(struct libusb_device_handle *, signed int);
// libusb_error_name
// file /usr/include/libusb-1.0/libusb.h line 1308
const char * libusb_error_name(signed int);
// libusb_exit
// file /usr/include/libusb-1.0/libusb.h line 1304
void libusb_exit(struct libusb_context *);
// libusb_fill_iso_transfer
// file /usr/include/libusb-1.0/libusb.h line 1630
static inline void libusb_fill_iso_transfer(struct libusb_transfer *transfer, struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, signed int length, signed int num_iso_packets, void (*callback)(struct libusb_transfer *), void *user_data, unsigned int timeout);
// libusb_fill_iso_transfer::callback_object
//
void callback_object(struct libusb_transfer *);
// libusb_free_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1329
void libusb_free_config_descriptor(struct libusb_config_descriptor *);
// libusb_free_device_list
// file /usr/include/libusb-1.0/libusb.h line 1314
void libusb_free_device_list(struct libusb_device **, signed int);
// libusb_free_transfer
// file /usr/include/libusb-1.0/libusb.h line 1480
void libusb_free_transfer(struct libusb_transfer *);
// libusb_get_active_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1323
signed int libusb_get_active_config_descriptor(struct libusb_device *, struct libusb_config_descriptor **);
// libusb_get_bus_number
// file /usr/include/libusb-1.0/libusb.h line 1357
unsigned char libusb_get_bus_number(struct libusb_device *);
// libusb_get_device
// file /usr/include/libusb-1.0/libusb.h line 1372
struct libusb_device * libusb_get_device(struct libusb_device_handle *);
// libusb_get_device_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1321
signed int libusb_get_device_descriptor(struct libusb_device *, struct libusb_device_descriptor *);
// libusb_get_device_list
// file /usr/include/libusb-1.0/libusb.h line 1312
signed long int libusb_get_device_list(struct libusb_context *, struct libusb_device ***);
// libusb_get_max_iso_packet_size
// file /usr/include/libusb-1.0/libusb.h line 1367
signed int libusb_get_max_iso_packet_size(struct libusb_device *, unsigned char);
// libusb_get_parent
// file /usr/include/libusb-1.0/libusb.h line 1362
struct libusb_device * libusb_get_parent(struct libusb_device *);
// libusb_get_string_descriptor_ascii
// file /usr/include/libusb-1.0/libusb.h line 1794
signed int libusb_get_string_descriptor_ascii(struct libusb_device_handle *, unsigned char, unsigned char *, signed int);
// libusb_handle_events
// file /usr/include/libusb-1.0/libusb.h line 1812
signed int libusb_handle_events(struct libusb_context *);
// libusb_handle_events_timeout
// file /usr/include/libusb-1.0/libusb.h line 1808
signed int libusb_handle_events_timeout(struct libusb_context *, struct timeval *);
// libusb_init
// file /usr/include/libusb-1.0/libusb.h line 1303
signed int libusb_init(struct libusb_context **);
// libusb_kernel_driver_active
// file /usr/include/libusb-1.0/libusb.h line 1395
signed int libusb_kernel_driver_active(struct libusb_device_handle *, signed int);
// libusb_open
// file /usr/include/libusb-1.0/libusb.h line 1370
signed int libusb_open(struct libusb_device *, struct libusb_device_handle **);
// libusb_release_interface
// file /usr/include/libusb-1.0/libusb.h line 1378
signed int libusb_release_interface(struct libusb_device_handle *, signed int);
// libusb_reset_device
// file /usr/include/libusb-1.0/libusb.h line 1388
signed int libusb_reset_device(struct libusb_device_handle *);
// libusb_set_interface_alt_setting
// file /usr/include/libusb-1.0/libusb.h line 1384
signed int libusb_set_interface_alt_setting(struct libusb_device_handle *, signed int, signed int);
// libusb_set_iso_packet_lengths
// file /usr/include/libusb-1.0/libusb.h line 1654
static inline void libusb_set_iso_packet_lengths(struct libusb_transfer *transfer, unsigned int length);
// libusb_submit_transfer
// file /usr/include/libusb-1.0/libusb.h line 1478
signed int libusb_submit_transfer(struct libusb_transfer *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// powf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern float powf(float, float);
// prepare_iso_out_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 34
static void prepare_iso_out_data(struct _freenect_device *dev, unsigned char *buffer);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_13 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_13 *, union anonymous_10 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_10 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_10 *);
// read_cmos_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 252
unsigned short int read_cmos_register(struct _freenect_device *dev, unsigned short int reg);
// read_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 209
unsigned short int read_register(struct _freenect_device *dev, unsigned short int reg);
// register_for_flag
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 33
signed int register_for_flag(signed int flag);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rgb_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 278
void rgb_cb(struct _freenect_device *dev, void *rgb, unsigned int timestamp);
// send_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.h line 32
signed int send_cmd(struct _freenect_device *dev, unsigned short int cmd, void *cmdbuf, unsigned int cmd_len, void *replybuf, signed int reply_len);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// stream_freebufs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 260
static void stream_freebufs(struct _freenect_context *ctx, struct anonymous_28 *strm);
// stream_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 231
static void stream_init(struct _freenect_context *ctx, struct anonymous_28 *strm, signed int rlen, signed int plen);
// stream_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 87
static signed int stream_process(struct _freenect_context *ctx, struct anonymous_28 *strm, unsigned char *pkt, signed int len, void (*cb)(void *, void *, signed int, signed int, void *), void *user_data);
// stream_process::cb_object
//
void cb_object(void *, void *, signed int, signed int, void *);
// stream_setbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 272
static signed int stream_setbuf(struct _freenect_context *ctx, struct anonymous_28 *strm, void *pbuf);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// unpack_8_pixels
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 77
static inline void unpack_8_pixels(unsigned char *raw, unsigned short int *frame);
// update_tilt_state_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 100
signed int update_tilt_state_alt(struct _freenect_device *dev);
// upload_cemd_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 341
signed int upload_cemd_data(struct anonymous_17 *dev);
// upload_firmware
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 68
signed int upload_firmware(struct anonymous_17 *dev, char *filename);
// upload_firmware_from_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 69
signed int upload_firmware_from_memory(struct anonymous_17 *dev, unsigned char *fw_from_mem, unsigned int fw_size_in_btyes);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// video_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 617
static void video_process(struct _freenect_device *dev, unsigned char *pkt, signed int len);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write_cmos_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 273
signed int write_cmos_register(struct _freenect_device *dev, unsigned short int reg, unsigned short int value);
// write_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.h line 36
signed int write_register(struct _freenect_device *dev, unsigned short int reg, unsigned short int data);

struct anonymous_18
{
  // parent
  struct anonymous_17 *parent;
  // xfers
  struct libusb_transfer **xfers;
  // buffer
  unsigned char *buffer;
  // cb
  void (*cb)(struct _freenect_device *, unsigned char *, signed int);
  // num_xfers
  signed int num_xfers;
  // pkts
  signed int pkts;
  // len
  signed int len;
  // dead
  signed int dead;
  // dead_xfers
  signed int dead_xfers;
};

struct anonymous_17
{
  // parent
  struct _freenect_device *parent;
  // dev
  struct libusb_device_handle *dev;
  // device_dead
  signed int device_dead;
  // VID
  signed int VID;
  // PID
  signed int PID;
};

struct anonymous_16
{
  // ctx
  struct libusb_context *ctx;
  // should_free_ctx
  signed int should_free_ctx;
};

struct anonymous_2
{
  // magic
  unsigned char magic[2l];
  // len
  unsigned short int len;
  // cmd
  unsigned short int cmd;
  // tag
  unsigned short int tag;
};

struct anonymous
{
  // dcmos_emitter_dist
  float dcmos_emitter_dist;
  // dcmos_rcmos_dist
  float dcmos_rcmos_dist;
  // reference_distance
  float reference_distance;
  // reference_pixel_size
  float reference_pixel_size;
};

struct anonymous_30
{
  // accelerometer_x
  signed short int accelerometer_x;
  // accelerometer_y
  signed short int accelerometer_y;
  // accelerometer_z
  signed short int accelerometer_z;
  // tilt_angle
  signed char tilt_angle;
  // tilt_status
  enum anonymous_31 tilt_status;
};

struct anonymous_14
{
  // left
  signed short int left;
  // right
  signed short int right;
  // center
  signed short int center;
  // lfe
  signed short int lfe;
  // surround_left
  signed short int surround_left;
  // surround_right
  signed short int surround_right;
};

struct anonymous_12
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_5
{
  // dx_center
  signed int dx_center;
  // ax
  signed int ax;
  // bx
  signed int bx;
  // cx
  signed int cx;
  // dx
  signed int dx;
  // dx_start
  signed int dx_start;
  // ay
  signed int ay;
  // by
  signed int by;
  // cy
  signed int cy;
  // dy
  signed int dy;
  // dy_start
  signed int dy_start;
  // dx_beta_start
  signed int dx_beta_start;
  // dy_beta_start
  signed int dy_beta_start;
  // rollout_blank
  signed int rollout_blank;
  // rollout_size
  signed int rollout_size;
  // dx_beta_inc
  signed int dx_beta_inc;
  // dy_beta_inc
  signed int dy_beta_inc;
  // dxdx_start
  signed int dxdx_start;
  // dxdy_start
  signed int dxdy_start;
  // dydx_start
  signed int dydx_start;
  // dydy_start
  signed int dydy_start;
  // dxdxdx_start
  signed int dxdxdx_start;
  // dydxdx_start
  signed int dydxdx_start;
  // dxdxdy_start
  signed int dxdxdy_start;
  // dydxdy_start
  signed int dydxdy_start;
  // back_comp1
  signed int back_comp1;
  // dydydx_start
  signed int dydydx_start;
  // back_comp2
  signed int back_comp2;
  // dydydy_start
  signed int dydydy_start;
};

struct anonymous_15
{
  // running
  signed int running;
  // audio_out_ring
  struct anonymous_14 *audio_out_ring;
  // ring_reader_idx
  signed int ring_reader_idx;
  // ring_writer_idx
  signed int ring_writer_idx;
  // out_window
  unsigned short int out_window;
  // out_seq
  unsigned char out_seq;
  // out_counter_within_window
  unsigned char out_counter_within_window;
  // out_weird_timestamp
  unsigned short int out_weird_timestamp;
  // out_window_parity
  unsigned char out_window_parity;
  // in_window
  unsigned short int in_window;
  // last_seen_window
  unsigned short int last_seen_window[10l];
  // in_counter
  unsigned char in_counter;
  // mic_buffer
  signed int *mic_buffer[4l];
  // cancelled_buffer
  signed short int *cancelled_buffer;
  // in_unknown
  void *in_unknown;
};

struct anonymous_28
{
  // running
  signed int running;
  // flag
  unsigned char flag;
  // synced
  signed int synced;
  // seq
  unsigned char seq;
  // got_pkts
  signed int got_pkts;
  // pkt_num
  signed int pkt_num;
  // pkts_per_frame
  signed int pkts_per_frame;
  // pkt_size
  signed int pkt_size;
  // frame_size
  signed int frame_size;
  // last_pkt_size
  signed int last_pkt_size;
  // valid_pkts
  signed int valid_pkts;
  // lost_pkts
  unsigned int lost_pkts;
  // valid_frames
  signed int valid_frames;
  // variable_length
  signed int variable_length;
  // last_timestamp
  unsigned int last_timestamp;
  // timestamp
  unsigned int timestamp;
  // split_bufs
  signed int split_bufs;
  // lib_buf
  void *lib_buf;
  // usr_buf
  void *usr_buf;
  // raw_buf
  unsigned char *raw_buf;
  // proc_buf
  void *proc_buf;
};

struct anonymous_6
{
  // start_lines
  unsigned short int start_lines;
  // end_lines
  unsigned short int end_lines;
  // cropping_lines
  unsigned short int cropping_lines;
};

struct anonymous_7
{
  // reg_info
  struct anonymous_5 reg_info;
  // reg_pad_info
  struct anonymous_6 reg_pad_info;
  // zero_plane_info
  struct anonymous zero_plane_info;
  // const_shift
  double const_shift;
  // raw_to_mm_shift
  unsigned short int *raw_to_mm_shift;
  // depth_to_rgb_shift
  signed int *depth_to_rgb_shift;
  // registration_table
  signed int (*registration_table)[2l];
};

struct anonymous_21
{
  // magic
  unsigned int magic;
  // channel
  unsigned short int channel;
  // len
  unsigned short int len;
  // window
  unsigned short int window;
  // unknown
  unsigned short int unknown;
  // samples
  signed int samples[0l];
};

struct anonymous_27
{
  // magic
  unsigned int magic;
  // ver_minor
  unsigned short int ver_minor;
  // ver_major
  unsigned short int ver_major;
  // ver_release
  unsigned short int ver_release;
  // ver_patch
  unsigned short int ver_patch;
  // base_addr
  unsigned int base_addr;
  // size
  unsigned int size;
  // entry_addr
  unsigned int entry_addr;
};

struct anonymous_22
{
  // magic
  unsigned int magic;
  // tag
  unsigned int tag;
  // arg1
  unsigned int arg1;
  // cmd
  unsigned int cmd;
  // arg2
  unsigned int arg2;
};

struct anonymous_24
{
  // magic
  unsigned int magic;
  // tag
  unsigned int tag;
  // arg1
  unsigned int arg1;
  // cmd
  unsigned int cmd;
  // arg2
  unsigned int arg2;
  // zeros
  unsigned int zeros[8l];
};

struct anonymous_26
{
  // magic
  unsigned int magic;
  // tag
  unsigned int tag;
  // bytes
  unsigned int bytes;
  // cmd
  unsigned int cmd;
  // addr
  unsigned int addr;
  // unk
  unsigned int unk;
};

struct anonymous_20
{
  // magic
  unsigned int magic;
  // tag
  unsigned int tag;
  // status
  unsigned int status;
};

union anonymous_9
{
  // dummy
  signed int dummy;
  // video_format
  enum anonymous_1 video_format;
  // depth_format
  enum anonymous_8 depth_format;
};

struct anonymous_29
{
  // reserved
  unsigned int reserved;
  // resolution
  enum anonymous_0 resolution;
  // _anon0
  union anonymous_9 _anon0;
  // bytes
  signed int bytes;
  // width
  signed short int width;
  // height
  signed short int height;
  // data_bits_per_pixel
  signed char data_bits_per_pixel;
  // padding_bits_per_pixel
  signed char padding_bits_per_pixel;
  // framerate
  signed char framerate;
  // is_valid
  signed char is_valid;
};

union anonymous_13
{
  // __data
  struct anonymous_12 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_10
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _freenect_context
{
  // log_level
  enum anonymous_11 log_level;
  // log_cb
  void (*log_cb)(struct _freenect_context *, enum anonymous_11, const char *);
  // usb
  struct anonymous_16 usb;
  // enabled_subdevices
  enum anonymous_25 enabled_subdevices;
  // first
  struct _freenect_device *first;
  // zero_plane_res
  signed int zero_plane_res;
  // fn_fw_nui_ptr
  unsigned char *fn_fw_nui_ptr;
  // fn_fw_nui_size
  unsigned int fn_fw_nui_size;
  // fn_fw_k4w_ptr
  unsigned char *fn_fw_k4w_ptr;
  // fn_fw_k4w_size
  unsigned int fn_fw_k4w_size;
};

struct _freenect_device
{
  // parent
  struct _freenect_context *parent;
  // next
  struct _freenect_device *next;
  // user_data
  void *user_data;
  // usb_cam
  struct anonymous_17 usb_cam;
  // depth_isoc
  struct anonymous_18 depth_isoc;
  // video_isoc
  struct anonymous_18 video_isoc;
  // depth_cb
  void (*depth_cb)(struct _freenect_device *, void *, unsigned int);
  // video_cb
  void (*video_cb)(struct _freenect_device *, void *, unsigned int);
  // depth_chunk_cb
  void (*depth_chunk_cb)(void *, void *, signed int, signed int, void *);
  // video_chunk_cb
  void (*video_chunk_cb)(void *, void *, signed int, signed int, void *);
  // video_format
  enum anonymous_1 video_format;
  // depth_format
  enum anonymous_8 depth_format;
  // video_resolution
  enum anonymous_0 video_resolution;
  // depth_resolution
  enum anonymous_0 depth_resolution;
  // cam_inited
  signed int cam_inited;
  // cam_tag
  unsigned short int cam_tag;
  // depth
  struct anonymous_28 depth;
  // video
  struct anonymous_28 video;
  // registration
  struct anonymous_7 registration;
  // usb_audio
  struct anonymous_17 usb_audio;
  // audio_out_isoc
  struct anonymous_18 audio_out_isoc;
  // audio_in_isoc
  struct anonymous_18 audio_in_isoc;
  // audio_in_cb
  void (*audio_in_cb)(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *);
  // audio_out_cb
  void (*audio_out_cb)(struct _freenect_device *, struct anonymous_14 *, signed int *);
  // audio
  struct anonymous_15 audio;
  // audio_tag
  unsigned int audio_tag;
  // usb_motor
  struct anonymous_17 usb_motor;
  // raw_state
  struct anonymous_30 raw_state;
  // device_does_motor_control_with_audio
  signed int device_does_motor_control_with_audio;
  // motor_control_with_audio_enabled
  signed int motor_control_with_audio_enabled;
};

struct freenect_device_attributes
{
  // next
  struct freenect_device_attributes *next;
  // camera_serial
  const char *camera_serial;
};

struct libusb_config_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // wTotalLength
  unsigned short int wTotalLength;
  // bNumInterfaces
  unsigned char bNumInterfaces;
  // bConfigurationValue
  unsigned char bConfigurationValue;
  // iConfiguration
  unsigned char iConfiguration;
  // bmAttributes
  unsigned char bmAttributes;
  // MaxPower
  unsigned char MaxPower;
  // interface
  struct libusb_interface *interface;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_device_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bcdUSB
  unsigned short int bcdUSB;
  // bDeviceClass
  unsigned char bDeviceClass;
  // bDeviceSubClass
  unsigned char bDeviceSubClass;
  // bDeviceProtocol
  unsigned char bDeviceProtocol;
  // bMaxPacketSize0
  unsigned char bMaxPacketSize0;
  // idVendor
  unsigned short int idVendor;
  // idProduct
  unsigned short int idProduct;
  // bcdDevice
  unsigned short int bcdDevice;
  // iManufacturer
  unsigned char iManufacturer;
  // iProduct
  unsigned char iProduct;
  // iSerialNumber
  unsigned char iSerialNumber;
  // bNumConfigurations
  unsigned char bNumConfigurations;
};

struct libusb_endpoint_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bEndpointAddress
  unsigned char bEndpointAddress;
  // bmAttributes
  unsigned char bmAttributes;
  // wMaxPacketSize
  unsigned short int wMaxPacketSize;
  // bInterval
  unsigned char bInterval;
  // bRefresh
  unsigned char bRefresh;
  // bSynchAddress
  unsigned char bSynchAddress;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_interface
{
  // altsetting
  struct libusb_interface_descriptor *altsetting;
  // num_altsetting
  signed int num_altsetting;
};

struct libusb_interface_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bInterfaceNumber
  unsigned char bInterfaceNumber;
  // bAlternateSetting
  unsigned char bAlternateSetting;
  // bNumEndpoints
  unsigned char bNumEndpoints;
  // bInterfaceClass
  unsigned char bInterfaceClass;
  // bInterfaceSubClass
  unsigned char bInterfaceSubClass;
  // bInterfaceProtocol
  unsigned char bInterfaceProtocol;
  // iInterface
  unsigned char iInterface;
  // endpoint
  struct libusb_endpoint_descriptor *endpoint;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_iso_packet_descriptor
{
  // length
  unsigned int length;
  // actual_length
  unsigned int actual_length;
  // status
  enum libusb_transfer_status status;
};

struct libusb_transfer
{
  // dev_handle
  struct libusb_device_handle *dev_handle;
  // flags
  unsigned char flags;
  // endpoint
  unsigned char endpoint;
  // type
  unsigned char type;
  // timeout
  unsigned int timeout;
  // status
  enum libusb_transfer_status status;
  // length
  signed int length;
  // actual_length
  signed int actual_length;
  // callback
  void (*callback)(struct libusb_transfer *);
  // user_data
  void *user_data;
  // buffer
  unsigned char *buffer;
  // num_iso_packets
  signed int num_iso_packets;
  // iso_packet_desc
  struct libusb_iso_packet_descriptor iso_packet_desc[0l];
};

struct pkt_hdr
{
  // magic
  unsigned char magic[2l];
  // pad
  unsigned char pad;
  // flag
  unsigned char flag;
  // unk1
  unsigned char unk1;
  // seq
  unsigned char seq;
  // unk2
  unsigned char unk2;
  // unk3
  unsigned char unk3;
  // timestamp
  unsigned int timestamp;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// depth_front
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 57
unsigned char *depth_front;
// depth_mid
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 57
unsigned char *depth_mid;
// die
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 45
volatile signed int die = 0;
// f_ctx
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 63
struct _freenect_context *f_ctx;
// f_dev
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 64
struct _freenect_device *f_dev;
// fps
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 74
double fps = (double)0;
// frame
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 72
signed int frame = 0;
// freenect_angle
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 65
signed int freenect_angle = 0;
// freenect_led
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 66
signed int freenect_led;
// freenect_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 44
unsigned long int freenect_thread;
// g_argc
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 47
signed int g_argc;
// g_argv
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 48
char **g_argv;
// gl_backbuf_mutex
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 52
union anonymous_10 gl_backbuf_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// gl_depth_tex
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 60
unsigned int gl_depth_tex;
// gl_frame_cond
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 68
union anonymous_13 gl_frame_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// gl_rgb_tex
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 61
unsigned int gl_rgb_tex;
// got_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 70
signed int got_depth = 0;
// got_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 69
signed int got_rgb = 0;
// my_ftime
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 73
signed int my_ftime = 0;
// parameter_coefficient
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 292
static double parameter_coefficient = (double)4;
// pixel_size_factor
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 294
static double pixel_size_factor = (double)1;
// rgb_back
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 58
unsigned char *rgb_back;
// rgb_front
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 58
unsigned char *rgb_front;
// rgb_mid
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 58
unsigned char *rgb_mid;
// shift_scale
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 293
static double shift_scale = (double)10;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// supported_depth_modes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 65
static struct anonymous_29 supported_depth_modes[6l] = { { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_11BIT & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_11BIT },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)11, .padding_bits_per_pixel=(signed char)5,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_10BIT & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_10BIT },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)6,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_11BIT_PACKED & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_11BIT_PACKED },
    .bytes=(640 * 480 * 11) / 8,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)11, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_10BIT_PACKED & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_10BIT_PACKED },
    .bytes=(640 * 480 * 10) / 8,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_REGISTERED & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_REGISTERED },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)16, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_MM & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_MM },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)16, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 } };
// supported_video_modes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 42
static struct anonymous_29 supported_video_modes[12l] = { { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_RGB & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_RGB },
    .bytes=1280 * 1024 * 3,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)24, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_RGB & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_RGB },
    .bytes=640 * 480 * 3,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)24, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_BAYER & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_BAYER },
    .bytes=1280 * 1024,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_BAYER & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_BAYER },
    .bytes=640 * 480,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_IR_8BIT & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_8BIT },
    .bytes=1280 * 1024,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_IR_8BIT & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_8BIT },
    .bytes=640 * 488,
    .width=(signed short int)640, .height=(signed short int)488,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT },
    .bytes=1280 * 1024 * 2,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)6,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT },
    .bytes=640 * 488 * 2,
    .width=(signed short int)640, .height=(signed short int)488,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)6,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT_PACKED & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT_PACKED },
    .bytes=(1280 * 1024 * 10) / 8,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT_PACKED & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT_PACKED },
    .bytes=(640 * 488 * 10) / 8,
    .width=(signed short int)640, .height=(signed short int)488,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_YUV_RGB & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_YUV_RGB },
    .bytes=640 * 480 * 3,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)24, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)15,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_YUV_RAW & 0xff), .resolution=(enum anonymous_0)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_YUV_RAW },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)16, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)15,
    .is_valid=(signed char)1 } };
// t_gamma
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 220
unsigned short int t_gamma[10000l];
// tag_next_ack
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 58
static signed int tag_next_ack = 0;
// tag_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 57
static signed int tag_seq = 0;
// window
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 50
signed int window;

// DrawGLScene
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 94
void DrawGLScene()
{
  unsigned char *tmp;
  pthread_mutex_lock(&gl_backbuf_mutex);
  if(!(got_depth == 0))
  {
    tmp = depth_front;
    depth_front = depth_mid;
    depth_mid = tmp;
    got_depth = 0;
  }

  if(!(got_rgb == 0))
  {
    tmp = rgb_front;
    rgb_front = rgb_mid;
    rgb_mid = tmp;
    got_rgb = 0;
  }

  pthread_mutex_unlock(&gl_backbuf_mutex);
  glBindTexture((unsigned int)0x0DE1, gl_rgb_tex);
  glTexImage2D((unsigned int)0x0DE1, 0, 3, 640, 480, 0, (unsigned int)0x1907, (unsigned int)0x1401, (const void *)rgb_front);
  glBegin((unsigned int)0x0006);
  glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
  glTexCoord2f((float)0, (float)0);
  glVertex3f((float)0, (float)0, (float)0);
  glTexCoord2f((float)1, (float)0);
  glVertex3f((float)640, (float)0, (float)0);
  glTexCoord2f((float)1, (float)1);
  glVertex3f((float)640, (float)480, (float)0);
  glTexCoord2f((float)0, (float)1);
  glVertex3f((float)0, (float)480, (float)0);
  glEnd();
  glBindTexture((unsigned int)0x0DE1, gl_depth_tex);
  glTexImage2D((unsigned int)0x0DE1, 0, 4, 640, 480, 0, (unsigned int)0x1908, (unsigned int)0x1401, (const void *)depth_front);
  glBegin((unsigned int)0x0006);
  glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
  glTexCoord2f((float)0, (float)0);
  glVertex3f((float)0, (float)0, (float)0);
  glTexCoord2f((float)1, (float)0);
  glVertex3f((float)640, (float)0, (float)0);
  glTexCoord2f((float)1, (float)1);
  glVertex3f((float)640, (float)480, (float)0);
  glTexCoord2f((float)0, (float)1);
  glVertex3f((float)0, (float)480, (float)0);
  glEnd();
  glutSwapBuffers();
  frame = frame + 1;
  if(frame % 30 == 0)
  {
    signed int ms;
    ms=glutGet((unsigned int)0x02BC);
    fps = 30.0 / ((double)(ms - my_ftime) / 1000.0);
    my_ftime = ms;
  }

}

// InitGL
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 171
void InitGL(signed int Width, signed int Height)
{
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
  glClearDepth(1.0);
  glDepthFunc((unsigned int)0x0201);
  glDepthMask((unsigned char)0);
  glDisable((unsigned int)0x0B71);
  glEnable((unsigned int)0x0BE2);
  glDisable((unsigned int)0x0BC0);
  glEnable((unsigned int)0x0DE1);
  glBlendFunc((unsigned int)0x0302, (unsigned int)0x0303);
  glShadeModel((unsigned int)0x1D00);
  glGenTextures(1, &gl_depth_tex);
  glBindTexture((unsigned int)0x0DE1, gl_depth_tex);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
  glGenTextures(1, &gl_rgb_tex);
  glBindTexture((unsigned int)0x0DE1, gl_rgb_tex);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
  ReSizeGLScene(Width, Height);
}

// ReSizeGLScene
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 161
void ReSizeGLScene(signed int Width, signed int Height)
{
  glViewport(0, 0, Width, Height);
  glMatrixMode((unsigned int)0x1701);
  glLoadIdentity();
  glOrtho((double)0, (double)640, (double)480, (double)0, (double)-1.0f, (double)1.0f);
  glMatrixMode((unsigned int)0x1700);
  glLoadIdentity();
}

// complete_tables
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 306
static void complete_tables(struct anonymous_7 *reg)
{
  unsigned short int i = (unsigned short int)0;
  for( ; !((signed int)i >= 2048); i = i + 1)
    reg->raw_to_mm_shift[(signed long int)i]=freenect_raw_to_mm(i, reg);
  reg->raw_to_mm_shift[(signed long int)2047] = (unsigned short int)0;
  freenect_init_depth_to_rgb(reg->depth_to_rgb_shift, &reg->zero_plane_info);
  freenect_init_registration_table(reg->registration_table, &reg->reg_info);
}

// convert_bayer_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 453
static void convert_bayer_to_rgb(unsigned char *raw_buf, unsigned char *proc_buf, struct anonymous_29 frame_mode)
{
  signed int x;
  signed int y;
  unsigned char *dst = proc_buf;
  unsigned char *prevLine;
  unsigned char *curLine;
  unsigned char *nextLine;
  unsigned int hVals;
  unsigned int vSums;
  curLine = raw_buf;
  nextLine = curLine + (signed long int)frame_mode.width;
  y = 0;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  unsigned char *tmp_post_14;
  unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  unsigned char *tmp_post_17;
  unsigned char *tmp_post_18;
  unsigned char *tmp_post_19;
  unsigned char *tmp_post_20;
  unsigned char *tmp_post_21;
  unsigned char *tmp_post_22;
  unsigned char *tmp_post_23;
  unsigned char *tmp_post_24;
  unsigned char *tmp_post_25;
  unsigned char *tmp_post_26;
  unsigned char *tmp_post_27;
  unsigned char *tmp_post_28;
  unsigned char *tmp_post_29;
  unsigned char *tmp_post_30;
  for( ; !(y >= (signed int)frame_mode.height); y = y + 1)
  {
    if(y >= 1 && !(y >= (signed int)frame_mode.height + -1))
      prevLine = curLine - (signed long int)frame_mode.width;

    else
      if(y == 0)
        prevLine = nextLine;

      else
        nextLine = prevLine;
    tmp_post_1 = curLine;
    curLine = curLine + 1l;
    hVals = (unsigned int)((signed int)*tmp_post_1 << 8);
    hVals = hVals | (unsigned int)((signed int)*curLine << 16);
    tmp_post_2 = prevLine;
    prevLine = prevLine + 1l;
    tmp_post_3 = nextLine;
    nextLine = nextLine + 1l;
    vSums = (unsigned int)((signed int)*tmp_post_2 + (signed int)*tmp_post_3 << 7 & 0xFF00);
    vSums = vSums | (unsigned int)((signed int)*prevLine + (signed int)*nextLine << 15 & 0xFF0000);
    unsigned char yOdd = (unsigned char)(y & 1);
    x = 0;
    for( ; !(x >= (signed int)frame_mode.width + -1); x = x + 1)
    {
      tmp_post_4 = curLine;
      curLine = curLine + 1l;
      hVals = hVals | (unsigned int)*tmp_post_4;
      tmp_post_5 = prevLine;
      prevLine = prevLine + 1l;
      tmp_post_6 = nextLine;
      nextLine = nextLine + 1l;
      vSums = vSums | (unsigned int)((signed int)*tmp_post_5 + (signed int)*tmp_post_6 >> 1);
      unsigned char hSum = (unsigned char)((signed int)(unsigned char)(hVals >> 16) + (signed int)(unsigned char)hVals >> 1);
      if((signed int)yOdd == 0)
      {
        if((1 & x) == 0)
        {
          tmp_post_7 = dst;
          dst = dst + 1l;
          *tmp_post_7 = hSum;
          tmp_post_8 = dst;
          dst = dst + 1l;
          *tmp_post_8 = (unsigned char)(hVals >> 8);
          tmp_post_9 = dst;
          dst = dst + 1l;
          *tmp_post_9 = (unsigned char)(vSums >> 8);
        }

        else
        {
          tmp_post_10 = dst;
          dst = dst + 1l;
          *tmp_post_10 = (unsigned char)(hVals >> 8);
          tmp_post_11 = dst;
          dst = dst + 1l;
          *tmp_post_11 = (unsigned char)((signed int)hSum + (signed int)(unsigned char)(vSums >> 8) >> 1);
          tmp_post_12 = dst;
          dst = dst + 1l;
          *tmp_post_12 = (unsigned char)((signed int)(unsigned char)(vSums >> 16) + (signed int)(unsigned char)vSums >> 1);
        }
      }

      else
        if((1 & x) == 0)
        {
          tmp_post_13 = dst;
          dst = dst + 1l;
          *tmp_post_13 = (unsigned char)((signed int)(unsigned char)(vSums >> 16) + (signed int)(unsigned char)vSums >> 1);
          tmp_post_14 = dst;
          dst = dst + 1l;
          *tmp_post_14 = (unsigned char)((signed int)hSum + (signed int)(unsigned char)(vSums >> 8) >> 1);
          tmp_post_15 = dst;
          dst = dst + 1l;
          *tmp_post_15 = (unsigned char)(hVals >> 8);
        }

        else
        {
          tmp_post_16 = dst;
          dst = dst + 1l;
          *tmp_post_16 = (unsigned char)(vSums >> 8);
          tmp_post_17 = dst;
          dst = dst + 1l;
          *tmp_post_17 = (unsigned char)(hVals >> 8);
          tmp_post_18 = dst;
          dst = dst + 1l;
          *tmp_post_18 = hSum;
        }
      hVals = hVals << 8;
      vSums = vSums << 8;
    }
    hVals = hVals | (unsigned int)(unsigned char)(hVals >> 16);
    vSums = vSums | (unsigned int)(unsigned char)(vSums >> 16);
    unsigned char convert_bayer_to_rgb__1__1__1__hSum = (unsigned char)hVals;
    if((signed int)yOdd == 0)
    {
      if((1 & x) == 0)
      {
        tmp_post_19 = dst;
        dst = dst + 1l;
        *tmp_post_19 = convert_bayer_to_rgb__1__1__1__hSum;
        tmp_post_20 = dst;
        dst = dst + 1l;
        *tmp_post_20 = (unsigned char)(hVals >> 8);
        tmp_post_21 = dst;
        dst = dst + 1l;
        *tmp_post_21 = (unsigned char)(vSums >> 8);
      }

      else
      {
        tmp_post_22 = dst;
        dst = dst + 1l;
        *tmp_post_22 = (unsigned char)(hVals >> 8);
        tmp_post_23 = dst;
        dst = dst + 1l;
        *tmp_post_23 = (unsigned char)((signed int)convert_bayer_to_rgb__1__1__1__hSum + (signed int)(unsigned char)(vSums >> 8) >> 1);
        tmp_post_24 = dst;
        dst = dst + 1l;
        *tmp_post_24 = (unsigned char)vSums;
      }
    }

    else
      if((1 & x) == 0)
      {
        tmp_post_25 = dst;
        dst = dst + 1l;
        *tmp_post_25 = (unsigned char)vSums;
        tmp_post_26 = dst;
        dst = dst + 1l;
        *tmp_post_26 = (unsigned char)((signed int)convert_bayer_to_rgb__1__1__1__hSum + (signed int)(unsigned char)(vSums >> 8) >> 1);
        tmp_post_27 = dst;
        dst = dst + 1l;
        *tmp_post_27 = (unsigned char)(hVals >> 8);
      }

      else
      {
        tmp_post_28 = dst;
        dst = dst + 1l;
        *tmp_post_28 = (unsigned char)(vSums >> 8);
        tmp_post_29 = dst;
        dst = dst + 1l;
        *tmp_post_29 = (unsigned char)(hVals >> 8);
        tmp_post_30 = dst;
        dst = dst + 1l;
        *tmp_post_30 = convert_bayer_to_rgb__1__1__1__hSum;
      }
  }
}

// convert_packed11_to_16bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 345
static void convert_packed11_to_16bit(unsigned char *raw, unsigned short int *frame, signed int n)
{
  unsigned short int baseMask = (unsigned short int)((1 << 11) - 1);
  while(n >= 8)
  {
    unsigned char r0 = raw[(signed long int)0];
    unsigned char r1 = raw[(signed long int)1];
    unsigned char r2 = raw[(signed long int)2];
    unsigned char r3 = raw[(signed long int)3];
    unsigned char r4 = raw[(signed long int)4];
    unsigned char r5 = raw[(signed long int)5];
    unsigned char r6 = raw[(signed long int)6];
    unsigned char r7 = raw[(signed long int)7];
    unsigned char r8 = raw[(signed long int)8];
    unsigned char r9 = raw[(signed long int)9];
    unsigned char r10 = raw[(signed long int)10];
    frame[(signed long int)0] = (unsigned short int)((signed int)r0 << 3 | (signed int)r1 >> 5);
    frame[(signed long int)1] = (unsigned short int)(((signed int)r1 << 6 | (signed int)r2 >> 2) & (signed int)baseMask);
    frame[(signed long int)2] = (unsigned short int)(((signed int)r2 << 9 | (signed int)r3 << 1 | (signed int)r4 >> 7) & (signed int)baseMask);
    frame[(signed long int)3] = (unsigned short int)(((signed int)r4 << 4 | (signed int)r5 >> 4) & (signed int)baseMask);
    frame[(signed long int)4] = (unsigned short int)(((signed int)r5 << 7 | (signed int)r6 >> 1) & (signed int)baseMask);
    frame[(signed long int)5] = (unsigned short int)(((signed int)r6 << 10 | (signed int)r7 << 2 | (signed int)r8 >> 6) & (signed int)baseMask);
    frame[(signed long int)6] = (unsigned short int)(((signed int)r8 << 5 | (signed int)r9 >> 3) & (signed int)baseMask);
    frame[(signed long int)7] = (unsigned short int)(((signed int)r9 << 8 | (signed int)r10) & (signed int)baseMask);
    n = n - 8;
    raw = raw + (signed long int)11;
    frame = frame + (signed long int)8;
  }
}

// convert_packed_to_16bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 304
static inline void convert_packed_to_16bit(unsigned char *src, unsigned short int *dest, signed int vw, signed int n)
{
  unsigned int mask = (unsigned int)((1 << vw) - 1);
  unsigned int buffer = (unsigned int)0;
  signed int bitsIn = 0;
  signed int tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned short int *tmp_post_3;
  do
  {
    tmp_post_1 = n;
    n = n - 1;
    if(tmp_post_1 == 0)
      break;

    for( ; !(bitsIn >= vw); bitsIn = bitsIn + 8)
    {
      tmp_post_2 = src;
      src = src + 1l;
      buffer = buffer << 8 | (unsigned int)*tmp_post_2;
    }
    bitsIn = bitsIn - vw;
    tmp_post_3 = dest;
    dest = dest + 1l;
    *tmp_post_3 = (unsigned short int)(buffer >> bitsIn & mask);
  }
  while((_Bool)1);
}

// convert_packed_to_8bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 330
static inline void convert_packed_to_8bit(unsigned char *src, unsigned char *dest, signed int vw, signed int n)
{
  unsigned int buffer = (unsigned int)0;
  signed int bitsIn = 0;
  signed int tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  do
  {
    tmp_post_1 = n;
    n = n - 1;
    if(tmp_post_1 == 0)
      break;

    for( ; !(bitsIn >= vw); bitsIn = bitsIn + 8)
    {
      tmp_post_2 = src;
      src = src + 1l;
      buffer = buffer << 8 | (unsigned int)*tmp_post_2;
    }
    bitsIn = bitsIn - vw;
    tmp_post_3 = dest;
    dest = dest + 1l;
    *tmp_post_3 = (unsigned char)(buffer >> (bitsIn + vw) - 8);
  }
  while((_Bool)1);
}

// convert_uyvy_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 420
static void convert_uyvy_to_rgb(unsigned char *raw_buf, unsigned char *proc_buf, struct anonymous_29 frame_mode)
{
  signed int x;
  signed int y = 0;
  for( ; !(y >= (signed int)frame_mode.height); y = y + 1)
  {
    x = 0;
    for( ; !(x >= (signed int)frame_mode.width); x = x + 2)
    {
      signed int i = (signed int)frame_mode.width * y + x;
      signed int u = (signed int)raw_buf[(signed long int)(2 * i)];
      signed int y1 = (signed int)raw_buf[(signed long int)(2 * i + 1)];
      signed int v = (signed int)raw_buf[(signed long int)(2 * i + 2)];
      signed int y2 = (signed int)raw_buf[(signed long int)(2 * i + 3)];
      signed int r1 = ((y1 - 16) * 1164) / 1000 + ((v - 128) * 1596) / 1000;
      signed int g1 = (((y1 - 16) * 1164) / 1000 - ((v - 128) * 813) / 1000) - ((u - 128) * 391) / 1000;
      signed int b1 = ((y1 - 16) * 1164) / 1000 + ((u - 128) * 2018) / 1000;
      signed int r2 = ((y2 - 16) * 1164) / 1000 + ((v - 128) * 1596) / 1000;
      signed int g2 = (((y2 - 16) * 1164) / 1000 - ((v - 128) * 813) / 1000) - ((u - 128) * 391) / 1000;
      signed int b2 = ((y2 - 16) * 1164) / 1000 + ((u - 128) * 2018) / 1000;
      if(!(r1 >= 0))
        r1 = 0;

      if(r1 >= 256)
        r1 = 255;

      if(!(g1 >= 0))
        g1 = 0;

      if(g1 >= 256)
        g1 = 255;

      if(!(b1 >= 0))
        b1 = 0;

      if(b1 >= 256)
        b1 = 255;

      if(!(r2 >= 0))
        r2 = 0;

      if(r2 >= 256)
        r2 = 255;

      if(!(g2 >= 0))
        g2 = 0;

      if(g2 >= 256)
        g2 = 255;

      if(!(b2 >= 0))
        b2 = 0;

      if(b2 >= 256)
        b2 = 255;

      proc_buf[(signed long int)(3 * i)] = (unsigned char)r1;
      proc_buf[(signed long int)(3 * i + 1)] = (unsigned char)g1;
      proc_buf[(signed long int)(3 * i + 2)] = (unsigned char)b1;
      proc_buf[(signed long int)(3 * i + 3)] = (unsigned char)r2;
      proc_buf[(signed long int)(3 * i + 4)] = (unsigned char)g2;
      proc_buf[(signed long int)(3 * i + 5)] = (unsigned char)b2;
    }
  }
}

// depth_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 222
void depth_cb(struct _freenect_device *dev, void *v_depth, unsigned int timestamp)
{
  signed int i;
  unsigned short int *depth = (unsigned short int *)v_depth;
  pthread_mutex_lock(&gl_backbuf_mutex);
  i = 0;
  for( ; !(i >= 480); i = i + 1)
  {
    signed int pval = (signed int)t_gamma[(signed long int)depth[(signed long int)i]] / 4;
    signed int lb = pval & 0xff;
    depth_mid[(signed long int)(4 * i + 3)] = (unsigned char)128;
    if((signed int)depth[(signed long int)i] == 0)
      depth_mid[(signed long int)(4 * i + 3)] = (unsigned char)0;

    switch(pval >> 8)
    {
      case 0:
      {
        depth_mid[(signed long int)(4 * i + 0)] = (unsigned char)255;
        depth_mid[(signed long int)(4 * i + 1)] = (unsigned char)(255 - lb);
        depth_mid[(signed long int)(4 * i + 2)] = (unsigned char)(255 - lb);
        break;
      }
      case 1:
      {
        depth_mid[(signed long int)(4 * i + 0)] = (unsigned char)255;
        depth_mid[(signed long int)(4 * i + 1)] = (unsigned char)lb;
        depth_mid[(signed long int)(4 * i + 2)] = (unsigned char)0;
        break;
      }
      case 2:
      {
        depth_mid[(signed long int)(4 * i + 0)] = (unsigned char)(255 - lb);
        depth_mid[(signed long int)(4 * i + 1)] = (unsigned char)255;
        depth_mid[(signed long int)(4 * i + 2)] = (unsigned char)0;
        break;
      }
      case 3:
      {
        depth_mid[(signed long int)(4 * i + 0)] = (unsigned char)0;
        depth_mid[(signed long int)(4 * i + 1)] = (unsigned char)255;
        depth_mid[(signed long int)(4 * i + 2)] = (unsigned char)lb;
        break;
      }
      case 4:
      {
        depth_mid[(signed long int)(4 * i + 0)] = (unsigned char)0;
        depth_mid[(signed long int)(4 * i + 1)] = (unsigned char)(255 - lb);
        depth_mid[(signed long int)(4 * i + 2)] = (unsigned char)255;
        break;
      }
      case 5:
      {
        depth_mid[(signed long int)(4 * i + 0)] = (unsigned char)0;
        depth_mid[(signed long int)(4 * i + 1)] = (unsigned char)0;
        depth_mid[(signed long int)(4 * i + 2)] = (unsigned char)(255 - lb);
        break;
      }
      default:
      {
        depth_mid[(signed long int)(4 * i + 0)] = (unsigned char)0;
        depth_mid[(signed long int)(4 * i + 1)] = (unsigned char)0;
        depth_mid[(signed long int)(4 * i + 2)] = (unsigned char)0;
        depth_mid[(signed long int)(4 * i + 3)] = (unsigned char)0;
      }
    }
  }
  got_depth = got_depth + 1;
  pthread_cond_signal(&gl_frame_cond);
  pthread_mutex_unlock(&gl_backbuf_mutex);
}

// depth_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 377
static void depth_process(struct _freenect_device *dev, unsigned char *pkt, signed int len)
{
  struct _freenect_context *ctx = dev->parent;
  if(!(len == 0))
  {
    if(!(dev->depth.running == 0))
    {
      signed int got_frame_size;
      got_frame_size=stream_process(ctx, &dev->depth, pkt, len, dev->depth_chunk_cb, dev->user_data);
      if(!(got_frame_size == 0))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Got depth frame of size %d/%d, %d/%d packets arrived, TS %08x\n", got_frame_size, dev->depth.frame_size, dev->depth.valid_pkts, dev->depth.pkts_per_frame, dev->depth.timestamp);
        switch((signed int)dev->depth_format)
        {
          case FREENECT_DEPTH_11BIT:
          {
            convert_packed11_to_16bit(dev->depth.raw_buf, (unsigned short int *)dev->depth.proc_buf, 640 * 480);
            break;
          }
          case FREENECT_DEPTH_REGISTERED:
          {
            freenect_apply_registration(dev, dev->depth.raw_buf, (unsigned short int *)dev->depth.proc_buf);
            break;
          }
          case FREENECT_DEPTH_MM:
          {
            freenect_apply_depth_to_mm(dev, dev->depth.raw_buf, (unsigned short int *)dev->depth.proc_buf);
            break;
          }
          case FREENECT_DEPTH_10BIT:
          {
            convert_packed_to_16bit(dev->depth.raw_buf, (unsigned short int *)dev->depth.proc_buf, 10, 640 * 480);
            break;
          }
          case FREENECT_DEPTH_10BIT_PACKED:

          case FREENECT_DEPTH_11BIT_PACKED:
            break;
          default:
            fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "depth_process() was called, but an invalid depth_format is set\n");
        }
        if(!(dev->depth_cb == ((void (*)(struct _freenect_device *, void *, unsigned int))NULL)))
          dev->depth_cb(dev, dev->depth.proc_buf, dev->depth.timestamp);

      }

    }

  }

}

// dump_bl_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 36
static void dump_bl_cmd(struct _freenect_context *ctx, struct anonymous_26 cmd)
{
  signed int i = 0;
  for( ; !(i >= 24); i = i + 1)
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "%02X ", ((unsigned char *)&cmd)[(signed long int)i]);
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "\n");
}

// dump_cemd_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 43
static void dump_cemd_cmd(struct _freenect_context *ctx, struct anonymous_24 cmd)
{
  signed int i = 0;
  for( ; !(i >= 24); i = i + 1)
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "%02X ", ((unsigned char *)&cmd)[(signed long int)i]);
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "(%d more zeros)\n", (signed int)(sizeof(struct anonymous_24) /*52ul*/  - (unsigned long int)24));
}

// fn_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 262
void fn_log(struct _freenect_context *ctx, enum anonymous_11 level, const char *fmt, ...)
{
  void **ap;
  if((signed int)ctx->log_level >= (signed int)level)
  {
    if(!(ctx->log_cb == ((void (*)(struct _freenect_context *, enum anonymous_11, const char *))NULL)))
    {
      char msgbuf[1024l];
      ap = (void **)&fmt;
      vsnprintf(msgbuf, (unsigned long int)1024, fmt, ap);
      msgbuf[(signed long int)1023] = (char)0;
      ap = ((void **)NULL);
      ctx->log_cb(ctx, level, msgbuf);
    }

    else
    {
      ap = (void **)&fmt;
      vfprintf(stderr, fmt, ap);
      ap = ((void **)NULL);
    }
  }

}

// fnusb_bulk
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 879
signed int fnusb_bulk(struct anonymous_17 *dev, unsigned char endpoint, unsigned char *data, signed int len, signed int *transferred)
{
  *transferred = 0;
  signed int return_value_libusb_bulk_transfer_1;
  return_value_libusb_bulk_transfer_1=libusb_bulk_transfer(dev->dev, endpoint, data, len, transferred, (unsigned int)0);
  return return_value_libusb_bulk_transfer_1;
}

// fnusb_claim_camera
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 255
signed int fnusb_claim_camera(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  signed int ret = 0;
  ret=libusb_kernel_driver_active(dev->usb_cam.dev, 0);
  if(ret == 1)
  {
    ret=libusb_detach_kernel_driver(dev->usb_cam.dev, 0);
    if(!(ret >= 0))
    {
      const char *return_value_libusb_error_name_1;
      return_value_libusb_error_name_1=libusb_error_name(ret);
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to detach camera kernel driver: %s\n", return_value_libusb_error_name_1);
      libusb_close(dev->usb_cam.dev);
      dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
      return ret;
    }

  }

  ret=libusb_claim_interface(dev->usb_cam.dev, 0);
  if(!(ret >= 0))
  {
    const char *return_value_libusb_error_name_2;
    return_value_libusb_error_name_2=libusb_error_name(ret);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to claim camera interface: %s\n", return_value_libusb_error_name_2);
    libusb_close(dev->usb_cam.dev);
    dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
    return ret;
  }

  if(dev->usb_cam.PID == 0x02bf)
  {
    ret=libusb_set_interface_alt_setting(dev->usb_cam.dev, 0, 1);
    if(!(ret == 0))
    {
      const char *return_value_libusb_error_name_3;
      return_value_libusb_error_name_3=libusb_error_name(ret);
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to set alternate interface #1 for K4W: %s\n", return_value_libusb_error_name_3);
      libusb_close(dev->usb_cam.dev);
      dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
      return ret;
    }

  }

  return ret;
}

// fnusb_close_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 86
signed int fnusb_close_subdevices(struct _freenect_device *dev)
{
  if(!(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
  {
    libusb_release_interface(dev->usb_cam.dev, 0);
    libusb_attach_kernel_driver(dev->usb_cam.dev, 0);
    libusb_close(dev->usb_cam.dev);
    dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
  }

  if(!(dev->usb_motor.dev == ((struct libusb_device_handle *)NULL)))
  {
    libusb_release_interface(dev->usb_motor.dev, 0);
    libusb_close(dev->usb_motor.dev);
    dev->usb_motor.dev = (struct libusb_device_handle *)(void *)0;
  }

  if(!(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL)))
  {
    libusb_release_interface(dev->usb_audio.dev, 0);
    libusb_close(dev->usb_audio.dev);
    dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
  }

  return 0;
}

// fnusb_control
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 92
signed int fnusb_control(struct anonymous_17 *dev, unsigned char bmRequestType, unsigned char bRequest, unsigned short int wValue, unsigned short int wIndex, unsigned char *data, unsigned short int wLength)
{
  signed int return_value_libusb_control_transfer_1;
  return_value_libusb_control_transfer_1=libusb_control_transfer(dev->dev, bmRequestType, bRequest, wValue, wIndex, data, wLength, (unsigned int)0);
  return return_value_libusb_control_transfer_1;
}

// fnusb_find_connected_audio_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 69
struct libusb_device * fnusb_find_connected_audio_device(struct libusb_device *camera, struct libusb_device **deviceList, signed int cnt)
{
  _Bool tmp_if_expr_4;
  signed int return_value_fnusb_is_pid_k4w_audio_3;
  if(!(cnt >= 1))
    return (struct libusb_device *)(void *)0;

  else
  {
    signed int cameraBusNo;
    unsigned char return_value_libusb_get_bus_number_1;
    return_value_libusb_get_bus_number_1=libusb_get_bus_number(camera);
    cameraBusNo = (signed int)return_value_libusb_get_bus_number_1;
    if(!(cameraBusNo >= 0))
      return (struct libusb_device *)(void *)0;

    else
    {
      struct libusb_device *cameraParent;
      cameraParent=libusb_get_parent(camera);
      signed int i = 0;
      i = 0;
      for( ; !(i >= cnt); i = i + 1)
      {
        struct libusb_device_descriptor desc;
        signed int res;
        res=libusb_get_device_descriptor(deviceList[(signed long int)i], &desc);
        if(res >= 0)
        {
          if((signed int)desc.idVendor == 0x45e)
          {
            if((signed int)desc.idProduct == 0x02ad)
              tmp_if_expr_4 = (_Bool)1;

            else
            {
              return_value_fnusb_is_pid_k4w_audio_3=fnusb_is_pid_k4w_audio((signed int)desc.idProduct);
              tmp_if_expr_4 = return_value_fnusb_is_pid_k4w_audio_3 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_4)
            {
              signed int audioBusNo;
              unsigned char return_value_libusb_get_bus_number_2;
              return_value_libusb_get_bus_number_2=libusb_get_bus_number(deviceList[(signed long int)i]);
              audioBusNo = (signed int)return_value_libusb_get_bus_number_2;
              if(audioBusNo == cameraBusNo)
              {
                struct libusb_device *audioParent;
                audioParent=libusb_get_parent(deviceList[(signed long int)i]);
                if(cameraParent == audioParent)
                  return deviceList[(signed long int)i];

              }

            }

          }

        }

      }
      return (struct libusb_device *)(void *)0;
    }
  }
}

// fnusb_get_max_iso_packet_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 90
signed int fnusb_get_max_iso_packet_size(struct anonymous_17 *dev, unsigned char endpoint, signed int default_size)
{
  struct _freenect_context *ctx = dev->parent->parent;
  signed int size;
  struct libusb_device *return_value_libusb_get_device_1;
  return_value_libusb_get_device_1=libusb_get_device(dev->dev);
  size=libusb_get_max_iso_packet_size(return_value_libusb_get_device_1, endpoint);
  if(!(size >= 1))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "libusb_get_max_iso_packet_size() returned %d; using default %d\n", size, default_size);
    size = default_size;
  }

  return size;
}

// fnusb_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 80
signed int fnusb_init(struct anonymous_16 *ctx, void *usb_ctx)
{
  signed int res;
  if(usb_ctx == NULL)
  {
    res=libusb_init(&ctx->ctx);
    if(res >= 0)
    {
      ctx->should_free_ctx = 1;
      return 0;
    }

    else
    {
      ctx->should_free_ctx = 0;
      ctx->ctx = (struct libusb_context *)(void *)0;
      return res;
    }
  }

  else
  {
    ctx->ctx = (struct libusb_context *)usb_ctx;
    ctx->should_free_ctx = 0;
    return 0;
  }
}

// fnusb_is_pid_k4w_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 64
signed int fnusb_is_pid_k4w_audio(signed int pid)
{
  return (signed int)(pid == 0x02be || pid == 0x02c3 || pid == 0x02bb);
}

// fnusb_list_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 78
signed int fnusb_list_device_attributes(struct anonymous_16 *ctx, struct freenect_device_attributes **attribute_list)
{
  *attribute_list = (struct freenect_device_attributes *)(void *)0;
  struct libusb_device **devs;
  signed long int count;
  count=libusb_get_device_list(ctx->ctx, &devs);
  if(!(count >= 0l))
    return -1;

  else
  {
    struct freenect_device_attributes **next_attr = attribute_list;
    signed int num_cams = 0;
    signed int i = 0;
    for( ; !((signed long int)i >= count); i = i + 1)
    {
      struct libusb_device *camera_device = devs[(signed long int)i];
      struct libusb_device_descriptor desc;
      signed int res;
      res=libusb_get_device_descriptor(camera_device, &desc);
      if(res >= 0)
      {
        if((signed int)desc.idVendor == 0x45e && ((signed int)desc.idProduct == 0x02ae || (signed int)desc.idProduct == 0x02bf))
        {
          if((signed int)desc.iSerialNumber == 0)
            goto __CPROVER_DUMP_L12;

          struct libusb_device_handle *camera_handle;
          res=libusb_open(camera_device, &camera_handle);
          if(!(res == 0))
            goto __CPROVER_DUMP_L12;

          unsigned char serial[256l];
          res=libusb_get_string_descriptor_ascii(camera_handle, desc.iSerialNumber, serial, 256);
          libusb_close(camera_handle);
          if(!(res >= 0))
            goto __CPROVER_DUMP_L12;

          const char * const K4W_1473_SERIAL = "0000000000000000";
          signed int return_value_strncmp_1;
          return_value_strncmp_1=strncmp((const char *)serial, K4W_1473_SERIAL, (unsigned long int)16);
          if(return_value_strncmp_1 == 0)
          {
            struct libusb_device *audio_device;
            audio_device=fnusb_find_connected_audio_device(camera_device, devs, (signed int)count);
            if(!(audio_device == ((struct libusb_device *)NULL)))
            {
              struct libusb_device_descriptor audio_desc;
              res=libusb_get_device_descriptor(audio_device, &audio_desc);
              if(res == 0)
              {
                struct libusb_device_handle *audio_handle = (struct libusb_device_handle *)(void *)0;
                res=libusb_open(audio_device, &audio_handle);
                if(res == 0)
                {
                  res=libusb_get_string_descriptor_ascii(audio_handle, audio_desc.iSerialNumber, serial, 256);
                  libusb_close(audio_handle);
                }

              }

            }

          }

          struct freenect_device_attributes *current_attr;
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(sizeof(struct freenect_device_attributes) /*16ul*/ );
          current_attr = (struct freenect_device_attributes *)return_value_malloc_2;
          memset((void *)current_attr, 0, sizeof(struct freenect_device_attributes) /*16ul*/ );
          current_attr->camera_serial=strdup((char *)serial);
          *next_attr = current_attr;
          next_attr = &current_attr->next;
          num_cams = num_cams + 1;
        }

      }


    __CPROVER_DUMP_L12:
      ;
    }
    libusb_free_device_list(devs, 1);
    return num_cams;
  }
}

// fnusb_num_devices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 77
signed int fnusb_num_devices(struct anonymous_16 *ctx)
{
  struct libusb_device **devs;
  signed long int cnt;
  cnt=libusb_get_device_list(ctx->ctx, &devs);
  if(!(cnt >= 0l))
    return -1;

  else
  {
    signed int nr = 0;
    signed int i = 0;
    struct libusb_device_descriptor desc;
    i = 0;
    for( ; !((signed long int)i >= cnt); i = i + 1)
    {
      signed int r;
      r=libusb_get_device_descriptor(devs[(signed long int)i], &desc);
      if(r >= 0)
      {
        if((signed int)desc.idVendor == 0x45e && ((signed int)desc.idProduct == 0x02ae || (signed int)desc.idProduct == 0x02bf))
          nr = nr + 1;

      }

    }
    libusb_free_device_list(devs, 1);
    return nr;
  }
}

// fnusb_num_interfaces
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 884
signed int fnusb_num_interfaces(struct anonymous_17 *dev)
{
  signed int retval = 0;
  signed int res;
  struct libusb_device *d;
  d=libusb_get_device(dev->dev);
  struct libusb_config_descriptor *config;
  res=libusb_get_active_config_descriptor(d, &config);
  if(!(res >= 0))
    return res;

  else
  {
    retval = (signed int)config->bNumInterfaces;
    libusb_free_config_descriptor(config);
    return retval;
  }
}

// fnusb_open_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 85
signed int fnusb_open_subdevices(struct _freenect_device *dev, signed int index)
{
  struct _freenect_context *ctx = dev->parent;
  dev->device_does_motor_control_with_audio = 0;
  dev->motor_control_with_audio_enabled = 0;
  dev->usb_cam.parent = dev;
  dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
  dev->usb_motor.parent = dev;
  dev->usb_motor.dev = (struct libusb_device_handle *)(void *)0;
  dev->usb_audio.parent = dev;
  dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
  struct libusb_device **devs;
  signed long int cnt;
  cnt=libusb_get_device_list(dev->parent->usb.ctx, &devs);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_14;
  signed int return_value_fnusb_is_pid_k4w_audio_13;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_12;
  signed int return_value_fnusb_is_pid_k4w_audio_11;
  _Bool tmp_if_expr_10;
  signed int return_value_strcmp_9;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_15;
  if(!(cnt >= 0l))
    return -1;

  else
  {
    signed int i = 0;
    signed int nr_cam = 0;
    signed int nr_mot = 0;
    signed int nr_audio = 0;
    signed int res;
    struct libusb_device_descriptor desc;
    i = 0;
    for( ; !((signed long int)i >= cnt); i = i + 1)
    {
      signed int r;
      r=libusb_get_device_descriptor(devs[(signed long int)i], &desc);
      if(r >= 0)
      {
        if((signed int)desc.idVendor == 0x45e)
        {
          res = 0;
          if(!((FREENECT_DEVICE_CAMERA & (signed int)ctx->enabled_subdevices) == 0))
          {
            if(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL))
            {
              if((signed int)desc.idProduct == 0x02ae || (signed int)desc.idProduct == 0x02bf)
              {
                if(nr_cam == index)
                {
                  dev->usb_cam.VID = (signed int)desc.idVendor;
                  dev->usb_cam.PID = (signed int)desc.idProduct;
                  res=libusb_open(devs[(signed long int)i], &dev->usb_cam.dev);
                  if(!(res >= 0))
                    tmp_if_expr_1 = (_Bool)1;

                  else
                    tmp_if_expr_1 = !(dev->usb_cam.dev != ((struct libusb_device_handle *)NULL)) ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_1)
                  {
                    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Could not open camera: %d\n", res);
                    dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                  if((signed int)desc.idProduct == 0x02bf || !((signed int)desc.bcdDevice == 267))
                  {
                    enum anonymous_25 requested_devices = ctx->enabled_subdevices;
                    ctx->enabled_subdevices = (enum anonymous_25)((signed int)ctx->enabled_subdevices & ~FREENECT_DEVICE_MOTOR);
                    ctx->zero_plane_res = 334;
                    dev->device_does_motor_control_with_audio = 1;
                    struct libusb_device *audioDevice;
                    audioDevice=fnusb_find_connected_audio_device(devs[(signed long int)i], devs, (signed int)cnt);
                    if(!(audioDevice == ((struct libusb_device *)NULL)))
                    {
                      struct libusb_device_handle *audioHandle = (struct libusb_device_handle *)(void *)0;
                      res=libusb_open(audioDevice, &audioHandle);
                      if(!(res == 0))
                        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to set the LED of K4W or 1473 device: %d\n", res);

                      else
                      {
                        libusb_reset_device(audioHandle);
                        libusb_close(audioHandle);
                        res=libusb_open(audioDevice, &audioHandle);
                        if(res == 0)
                        {
                          res=libusb_claim_interface(audioHandle, 0);
                          if(!(res == 0))
                            fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Unable to claim interface %d\n", res);

                          else
                          {
                            fnusb_set_led_alt(audioHandle, ctx, (enum anonymous_19)LED_GREEN);
                            libusb_release_interface(audioHandle, 0);
                          }
                          libusb_close(audioHandle);
                        }

                      }
                    }

                    if((FREENECT_DEVICE_AUDIO & (signed int)requested_devices) == 0 && !((FREENECT_DEVICE_MOTOR & (signed int)requested_devices) == 0))
                      ctx->enabled_subdevices = (enum anonymous_25)((signed int)ctx->enabled_subdevices | FREENECT_DEVICE_AUDIO);

                  }

                  else
                    ctx->zero_plane_res = 322;
                  res=fnusb_claim_camera(dev);
                  if(!(res >= 0))
                    break;

                }

                else
                  nr_cam = nr_cam + 1;
              }

            }

          }

        }

      }

    }
    if((signed int)ctx->enabled_subdevices == FREENECT_DEVICE_CAMERA || !(res >= 0))
      cnt = (signed long int)0;

    i = 0;
    for( ; !((signed long int)i >= cnt); i = i + 1)
    {
      signed int fnusb_open_subdevices__1__2__1__r;
      fnusb_open_subdevices__1__2__1__r=libusb_get_device_descriptor(devs[(signed long int)i], &desc);
      if(fnusb_open_subdevices__1__2__1__r >= 0)
      {
        if((signed int)desc.idVendor == 0x45e)
        {
          if(!((FREENECT_DEVICE_MOTOR & (signed int)ctx->enabled_subdevices) == 0))
          {
            if(dev->usb_motor.dev == ((struct libusb_device_handle *)NULL))
            {
              if((signed int)desc.idProduct == 0x02b0)
              {
                if(nr_mot == index)
                {
                  dev->usb_motor.VID = (signed int)desc.idVendor;
                  dev->usb_motor.PID = (signed int)desc.idProduct;
                  res=libusb_open(devs[(signed long int)i], &dev->usb_motor.dev);
                  if(!(res >= 0))
                    tmp_if_expr_2 = (_Bool)1;

                  else
                    tmp_if_expr_2 = !(dev->usb_motor.dev != ((struct libusb_device_handle *)NULL)) ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_2)
                  {
                    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Could not open motor: %d\n", res);
                    dev->usb_motor.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                  res=libusb_claim_interface(dev->usb_motor.dev, 0);
                  if(!(res >= 0))
                  {
                    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Could not claim interface on motor: %d\n", res);
                    libusb_close(dev->usb_motor.dev);
                    dev->usb_motor.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                }

                else
                  nr_mot = nr_mot + 1;
              }

            }

          }

          if(!((FREENECT_DEVICE_AUDIO & (signed int)ctx->enabled_subdevices) == 0))
          {
            if(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL))
            {
              if((signed int)desc.idProduct == 0x02ad)
                tmp_if_expr_14 = (_Bool)1;

              else
              {
                return_value_fnusb_is_pid_k4w_audio_13=fnusb_is_pid_k4w_audio((signed int)desc.idProduct);
                tmp_if_expr_14 = return_value_fnusb_is_pid_k4w_audio_13 != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_14)
              {
                if(nr_audio == index)
                {
                  dev->usb_audio.VID = (signed int)desc.idVendor;
                  dev->usb_audio.PID = (signed int)desc.idProduct;
                  res=libusb_open(devs[(signed long int)i], &dev->usb_audio.dev);
                  if(!(res >= 0))
                    tmp_if_expr_3 = (_Bool)1;

                  else
                    tmp_if_expr_3 = !(dev->usb_audio.dev != ((struct libusb_device_handle *)NULL)) ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_3)
                  {
                    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Could not open audio: %d\n", res);
                    dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                  res=libusb_claim_interface(dev->usb_audio.dev, 0);
                  if(!(res >= 0))
                  {
                    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Could not claim interface on audio: %d\n", res);
                    libusb_close(dev->usb_audio.dev);
                    dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                  signed int num_interfaces;
                  num_interfaces=fnusb_num_interfaces(&dev->usb_audio);
                  if(num_interfaces >= 2)
                  {
                    if(!(dev->device_does_motor_control_with_audio == 0))
                      dev->motor_control_with_audio_enabled = 1;

                  }

                  else
                  {
                    unsigned char string_desc[256l];
                    res=libusb_get_string_descriptor_ascii(dev->usb_audio.dev, desc.iSerialNumber, string_desc, 256);
                    if(!(res >= 0))
                    {
                      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to retrieve serial number for audio device in bootloader state\n");
                      break;
                    }

                    char *audio_serial;
                    audio_serial=strdup((char *)string_desc);
                    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Uploading firmware to audio device in bootloader state.\n");
                    if((signed int)desc.idProduct == 0x02ad)
                      tmp_if_expr_6 = ctx->fn_fw_nui_ptr != ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_6 = (_Bool)0;
                    if(tmp_if_expr_6)
                      tmp_if_expr_7 = ctx->fn_fw_nui_size > (unsigned int)0 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_7 = (_Bool)0;
                    if(tmp_if_expr_7)
                    {
                      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "loading firmware from memory\n");
                      res=upload_firmware_from_memory(&dev->usb_audio, ctx->fn_fw_nui_ptr, ctx->fn_fw_nui_size);
                    }

                    else
                    {
                      if((signed int)desc.idProduct == 0x02be)
                        tmp_if_expr_4 = ctx->fn_fw_k4w_ptr != ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_4 = (_Bool)0;
                      if(tmp_if_expr_4)
                        tmp_if_expr_5 = ctx->fn_fw_k4w_size > (unsigned int)0 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_5 = (_Bool)0;
                      if(tmp_if_expr_5)
                      {
                        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "loading firmware from memory\n");
                        res=upload_firmware_from_memory(&dev->usb_audio, ctx->fn_fw_k4w_ptr, ctx->fn_fw_k4w_size);
                      }

                      else
                        res=upload_firmware(&dev->usb_audio, "audios.bin");
                    }
                    if(!(res >= 0))
                    {
                      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_firmware failed: %d\n", res);
                      break;
                    }

                    libusb_close(dev->usb_audio.dev);
                    dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
                    signed int loops = 0;
                    loops = 0;
                    for( ; !(loops >= 10); loops = loops + 1)
                    {
                      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Try %d: Looking for new audio device matching serial %s\n", loops, audio_serial);
                      struct libusb_device **new_dev_list;
                      signed int dev_index;
                      signed long int num_new_devs;
                      num_new_devs=libusb_get_device_list(ctx->usb.ctx, &new_dev_list);
                      dev_index = 0;
                      for( ; !((signed long int)dev_index >= num_new_devs); dev_index = dev_index + 1)
                      {
                        struct libusb_device_descriptor new_dev_desc;
                        signed int fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r;
                        fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r=libusb_get_device_descriptor(new_dev_list[(signed long int)dev_index], &new_dev_desc);
                        if(fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r >= 0)
                        {
                          if((signed int)new_dev_desc.idVendor == 0x45e)
                          {
                            if((signed int)new_dev_desc.idProduct == 0x02ad)
                              tmp_if_expr_12 = (_Bool)1;

                            else
                            {
                              return_value_fnusb_is_pid_k4w_audio_11=fnusb_is_pid_k4w_audio((signed int)desc.idProduct);
                              tmp_if_expr_12 = return_value_fnusb_is_pid_k4w_audio_11 != 0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_12)
                            {
                              fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Matched VID/PID!\n");
                              struct libusb_device_handle *new_dev_handle;
                              fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r=libusb_open(new_dev_list[(signed long int)dev_index], &new_dev_handle);
                              if(!(fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r >= 0))
                                goto __CPROVER_DUMP_L68;

                              fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r=libusb_get_string_descriptor_ascii(new_dev_handle, new_dev_desc.iSerialNumber, string_desc, 256);
                              if(!(fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r >= 0))
                              {
                                fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Lost new audio device while fetching serial number.\n");
                                libusb_close(new_dev_handle);
                                goto __CPROVER_DUMP_L68;
                              }

                              unsigned long int return_value_strlen_8;
                              return_value_strlen_8=strlen(audio_serial);
                              if((unsigned long int)fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r == return_value_strlen_8)
                              {
                                return_value_strcmp_9=strcmp((char *)string_desc, audio_serial);
                                tmp_if_expr_10 = return_value_strcmp_9 == 0 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr_10 = (_Bool)0;
                              if(tmp_if_expr_10)
                              {
                                fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r=libusb_claim_interface(new_dev_handle, 0);
                                if(!(fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r == 0))
                                {
                                  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Device with serial %s reappeared but couldn't claim interface 0\n", audio_serial);
                                  libusb_close(new_dev_handle);
                                  goto __CPROVER_DUMP_L68;
                                }

                                dev->usb_audio.dev = new_dev_handle;
                                num_interfaces=fnusb_num_interfaces(&dev->usb_audio);
                                if(num_interfaces >= 2)
                                {
                                  if(!(dev->device_does_motor_control_with_audio == 0))
                                    dev->motor_control_with_audio_enabled = 1;

                                }

                                else
                                {
                                  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Opened audio with matching serial but too few interfaces.\n");
                                  dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
                                  libusb_close(new_dev_handle);
                                  goto __CPROVER_DUMP_L68;
                                }
                                break;
                              }

                              else
                                fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Got serial %s, expected serial %s\n", (char *)string_desc, audio_serial);
                            }

                          }

                        }


                      __CPROVER_DUMP_L68:
                        ;
                      }
                      libusb_free_device_list(new_dev_list, 1);
                      if(!(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL)))
                        break;

                      sleep((unsigned int)1);
                    }
                    free((void *)audio_serial);
                  }
                }

                else
                  nr_audio = nr_audio + 1;
              }

            }

          }

        }

      }

    }
    libusb_free_device_list(devs, 1);
    if(!(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
      tmp_if_expr_16 = (_Bool)1;

    else
      tmp_if_expr_16 = !(((signed int)ctx->enabled_subdevices & FREENECT_DEVICE_CAMERA) != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_16)
    {
      if(!(dev->usb_motor.dev == ((struct libusb_device_handle *)NULL)))
        tmp_if_expr_15 = (_Bool)1;

      else
        tmp_if_expr_15 = !(((signed int)ctx->enabled_subdevices & FREENECT_DEVICE_MOTOR) != 0) ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_15)
        goto __CPROVER_DUMP_L80;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L80:
      ;
      if(!(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
      {
        libusb_release_interface(dev->usb_cam.dev, 0);
        libusb_close(dev->usb_cam.dev);
      }

      else
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to open camera subdevice or it is not disabled.");
      if(!(dev->usb_motor.dev == ((struct libusb_device_handle *)NULL)))
      {
        libusb_release_interface(dev->usb_motor.dev, 0);
        libusb_close(dev->usb_motor.dev);
      }

      else
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to open motor subddevice or it is not disabled.");
      if(!(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL)))
      {
        libusb_release_interface(dev->usb_audio.dev, 0);
        libusb_close(dev->usb_audio.dev);
      }

      else
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to open audio subdevice or it is not disabled.");
      return -1;
    }
  }
}

// fnusb_process_events
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 245
signed int fnusb_process_events(struct anonymous_16 *ctx)
{
  signed int return_value_libusb_handle_events_1;
  return_value_libusb_handle_events_1=libusb_handle_events(ctx->ctx);
  return return_value_libusb_handle_events_1;
}

// fnusb_process_events_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 83
signed int fnusb_process_events_timeout(struct anonymous_16 *ctx, struct timeval *timeout)
{
  signed int return_value_libusb_handle_events_timeout_1;
  return_value_libusb_handle_events_timeout_1=libusb_handle_events_timeout(ctx->ctx, timeout);
  return return_value_libusb_handle_events_timeout_1;
}

// fnusb_set_led_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 246
signed int fnusb_set_led_alt(struct libusb_device_handle *dev, struct _freenect_context *ctx, enum anonymous_19 state)
{
  if((signed int)state == LED_GREEN)
    state = (enum anonymous_19)3;

  else
    if((signed int)state == LED_RED)
      state = (enum anonymous_19)4;

    else
      if((signed int)state == LED_YELLOW)
        state = (enum anonymous_19)3;

      else
        if((signed int)state == LED_OFF)
          state = (enum anonymous_19)1;

        else
          if((signed int)state == LED_BLINK_GREEN)
            state = (enum anonymous_19)2;

          else
            state = (enum anonymous_19)LED_GREEN;
  struct anonymous_22 cmd;
  cmd.magic = (unsigned int)0x06022009;
  signed int tmp_post_1 = tag_seq;
  tag_seq = tag_seq + 1;
  cmd.tag = (unsigned int)tmp_post_1;
  cmd.arg1 = (unsigned int)0;
  cmd.cmd = (unsigned int)0x10;
  cmd.arg2 = (unsigned int)(signed int)state;
  unsigned char buffer[20l];
  memcpy((void *)buffer, (const void *)&cmd, (unsigned long int)20);
  signed int transferred = 0;
  signed int res;
  res=libusb_bulk_transfer(dev, (unsigned char)0x01, buffer, 20, &transferred, (unsigned int)100);
  if(!(res == 0))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "fnusb_set_led_alt(): libusb_bulk_transfer failed: %d (transferred = %d)\n", res, transferred);
    return res;
  }

  else
  {
    signed int return_value_get_reply_2;
    return_value_get_reply_2=get_reply(dev, ctx);
    return return_value_get_reply_2;
  }
}

// fnusb_shutdown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 81
signed int fnusb_shutdown(struct anonymous_16 *ctx)
{
  if(!(ctx->should_free_ctx == 0))
  {
    libusb_exit(ctx->ctx);
    ctx->ctx = (struct libusb_context *)(void *)0;
  }

  return 0;
}

// fnusb_start_iso
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 88
signed int fnusb_start_iso(struct anonymous_17 *dev, struct anonymous_18 *strm, void (*cb)(struct _freenect_device *, unsigned char *, signed int), unsigned char endpoint, signed int xfers, signed int pkts, signed int len)
{
  struct _freenect_context *ctx = dev->parent->parent;
  strm->parent = dev;
  strm->cb = cb;
  strm->num_xfers = xfers;
  strm->pkts = pkts;
  strm->len = len;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(xfers * pkts * len));
  strm->buffer = (unsigned char *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct libusb_transfer *) /*8ul*/  * (unsigned long int)xfers);
  strm->xfers = (struct libusb_transfer **)return_value_malloc_2;
  strm->dead = 0;
  strm->dead_xfers = 0;
  signed int i;
  unsigned char *bufp = strm->buffer;
  i = 0;
  for( ; !(i >= xfers); i = i + 1)
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Creating endpoint %02x transfer #%d\n", endpoint, i);
    strm->xfers[(signed long int)i]=libusb_alloc_transfer(pkts);
    if(strm->xfers[(signed long int)i] == ((struct libusb_transfer *)NULL))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "Failed to allocate transfer\n");
      strm->dead_xfers = strm->dead_xfers + 1;
    }

    else
    {
      libusb_fill_iso_transfer(strm->xfers[(signed long int)i], dev->dev, endpoint, bufp, pkts * len, pkts, iso_callback, (void *)strm, (unsigned int)0);
      libusb_set_iso_packet_lengths(strm->xfers[(signed long int)i], (unsigned int)len);
      signed int ret;
      ret=libusb_submit_transfer(strm->xfers[(signed long int)i]);
      if(!(ret >= 0))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "Failed to submit isochronous transfer %d: %d\n", i, ret);
        strm->dead_xfers = strm->dead_xfers + 1;
      }

    }
    bufp = bufp + (signed long int)(pkts * len);
  }
  return 0;
}

// fnusb_stop_iso
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 89
signed int fnusb_stop_iso(struct anonymous_17 *dev, struct anonymous_18 *strm)
{
  struct _freenect_context *ctx = dev->parent->parent;
  signed int i;
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_FLOOD, "fnusb_stop_iso() called\n");
  strm->dead = 1;
  i = 0;
  for( ; !(i >= strm->num_xfers); i = i + 1)
    libusb_cancel_transfer(strm->xfers[(signed long int)i]);
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_FLOOD, "fnusb_stop_iso() cancelled all transfers\n");
  while(!(strm->dead_xfers >= strm->num_xfers))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_FLOOD, "fnusb_stop_iso() dead = %d\tnum = %d\n", strm->dead_xfers, strm->num_xfers);
    libusb_handle_events(ctx->usb.ctx);
  }
  i = 0;
  for( ; !(i >= strm->num_xfers); i = i + 1)
    libusb_free_transfer(strm->xfers[(signed long int)i]);
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_FLOOD, "fnusb_stop_iso() freed all transfers\n");
  free((void *)strm->buffer);
  free((void *)strm->xfers);
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_FLOOD, "fnusb_stop_iso() freed buffers and stream\n");
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_FLOOD, "fnusb_stop_iso() done\n");
  return 0;
}

// freenect_apply_depth_to_mm
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 34
signed int freenect_apply_depth_to_mm(struct _freenect_device *dev, unsigned char *input_packed, unsigned short int *output_mm)
{
  struct anonymous_7 *reg = &dev->registration;
  unsigned short int unpack[8l];
  unsigned int x;
  unsigned int y;
  unsigned int source_index = (unsigned int)8;
  y = (unsigned int)0;
  unsigned int tmp_post_1;
  for( ; !(y >= 480u); y = y + 1u)
  {
    x = (unsigned int)0;
    for( ; !(x >= 640u); x = x + 1u)
    {
      if(source_index == 8u)
      {
        unpack_8_pixels(input_packed, unpack);
        source_index = (unsigned int)0;
        input_packed = input_packed + (signed long int)11;
      }

      unsigned short int metric_depth;
      tmp_post_1 = source_index;
      source_index = source_index + 1u;
      metric_depth = reg->raw_to_mm_shift[(signed long int)unpack[(signed long int)tmp_post_1]];
      output_mm[(signed long int)(y * (unsigned int)640 + x)] = (unsigned short int)((signed int)metric_depth < 10000 ? (signed int)metric_depth : 10000);
    }
  }
  return 0;
}

// freenect_apply_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 33
signed int freenect_apply_registration(struct _freenect_device *dev, unsigned char *input_packed, unsigned short int *output_mm)
{
  struct anonymous_7 *reg = &dev->registration;
  unsigned long int i;
  unsigned long int *wipe = (unsigned long int *)output_mm;
  i = (unsigned long int)0;
  for( ; !(i >= 76800ul); i = i + 1ul)
    wipe[(signed long int)i] = (unsigned long int)0;
  unsigned short int unpack[8l];
  unsigned int target_offset = (unsigned int)(480 * (signed int)reg->reg_pad_info.start_lines);
  unsigned int x;
  unsigned int y;
  unsigned int source_index = (unsigned int)8;
  y = (unsigned int)0;
  unsigned int tmp_post_1;
  for( ; !(y >= 480u); y = y + 1u)
  {
    x = (unsigned int)0;
    for( ; !(x >= 640u); x = x + 1u)
    {
      if(source_index == 8u)
      {
        unpack_8_pixels(input_packed, unpack);
        source_index = (unsigned int)0;
        input_packed = input_packed + (signed long int)11;
      }

      unsigned short int metric_depth;
      tmp_post_1 = source_index;
      source_index = source_index + 1u;
      metric_depth = reg->raw_to_mm_shift[(signed long int)unpack[(signed long int)tmp_post_1]];
      if(!((signed int)metric_depth == 0))
      {
        if(!((signed int)metric_depth >= 10000))
        {
          unsigned int reg_index = 0 != 0 ? ((y + (unsigned int)1) * (unsigned int)640 - x) - (unsigned int)1 : y * (unsigned int)640 + x;
          unsigned int nx = (unsigned int)((reg->registration_table[(signed long int)reg_index][(signed long int)0] + reg->depth_to_rgb_shift[(signed long int)metric_depth]) / 256);
          unsigned int ny = (unsigned int)reg->registration_table[(signed long int)reg_index][(signed long int)1];
          if(!(nx >= 640u))
          {
            unsigned int target_index = (0 != 0 ? ((ny + (unsigned int)1) * (unsigned int)640 - nx) - (unsigned int)1 : ny * (unsigned int)640 + nx) - target_offset;
            unsigned short int current_depth = output_mm[(signed long int)target_index];
            if((signed int)current_depth == 0 || !((signed int)metric_depth >= (signed int)current_depth))
              output_mm[(signed long int)target_index] = metric_depth;

          }

        }

      }

    }
  }
  return 0;
}

// freenect_camera_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.h line 35
signed int freenect_camera_init(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  signed int res;
  res=freenect_fetch_reg_pad_info(dev);
  if(!(res >= 0))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_camera_init(): Failed to fetch registration pad info for device\n");
    return res;
  }

  else
  {
    res=freenect_fetch_zero_plane_info(dev);
    if(!(res >= 0))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_camera_init(): Failed to fetch zero plane info for device\n");
      return res;
    }

    else
    {
      struct anonymous_29 return_value_freenect_find_video_mode_1;
      return_value_freenect_find_video_mode_1=freenect_find_video_mode((enum anonymous_0)FREENECT_RESOLUTION_MEDIUM, (enum anonymous_1)FREENECT_VIDEO_RGB);
      res=freenect_set_video_mode(dev, return_value_freenect_find_video_mode_1);
      struct anonymous_29 return_value_freenect_find_depth_mode_2;
      return_value_freenect_find_depth_mode_2=freenect_find_depth_mode((enum anonymous_0)FREENECT_RESOLUTION_MEDIUM, (enum anonymous_8)FREENECT_DEPTH_11BIT);
      res=freenect_set_depth_mode(dev, return_value_freenect_find_depth_mode_2);
      res=freenect_fetch_reg_const_shift(dev);
      if(!(res >= 0))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_camera_init(): Failed to fetch const shift for device\n");
        return res;
      }

      else
        return 0;
    }
  }
}

// freenect_camera_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.h line 36
signed int freenect_camera_teardown(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  signed int res = 0;
  if(!(dev->depth.running == 0))
  {
    res=freenect_stop_depth(dev);
    if(!(res >= 0))
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_camera_teardown(): Failed to stop depth camera\n");

    return res;
  }

  else
    if(!(dev->video.running == 0))
    {
      res=freenect_stop_video(dev);
      if(!(res >= 0))
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_camera_teardown(): Failed to stop video camera\n");

      return res;
    }

    else
    {
      freenect_destroy_registration(&dev->registration);
      return 0;
    }
}

// freenect_camera_to_world
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 318
void freenect_camera_to_world(struct _freenect_device *dev, signed int cx, signed int cy, signed int wz, double *wx, double *wy)
{
  double ref_pix_size = (double)dev->registration.zero_plane_info.reference_pixel_size;
  double ref_distance = (double)dev->registration.zero_plane_info.reference_distance;
  double factor = ((double)2 * ref_pix_size * (double)wz) / ref_distance;
  *wx = (double)(cx - 640 / 2) * factor;
  *wy = (double)(cy - 480 / 2) * factor;
}

// freenect_close_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 365
signed int freenect_close_device(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  signed int res;
  if(!(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
    freenect_camera_teardown(dev);

  res=fnusb_close_subdevices(dev);
  if(!(res >= 0))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "fnusb_close_subdevices failed: %d\n", res);
    return res;
  }

  else
  {
    struct _freenect_device *last = (struct _freenect_device *)(void *)0;
    struct _freenect_device *cur = ctx->first;
    for( ; !(cur == ((struct _freenect_device *)NULL)) && !(cur == dev); cur = cur->next)
      last = cur;
    if(cur == ((struct _freenect_device *)NULL))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "device %p not found in linked list for this context!\n", dev);
      return -1;
    }

    else
    {
      if(!(last == ((struct _freenect_device *)NULL)))
        last->next = cur->next;

      else
        ctx->first = cur->next;
      free((void *)dev);
      return 0;
    }
  }
}

// freenect_copy_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 420
struct anonymous_7 freenect_copy_registration(struct _freenect_device *dev)
{
  struct anonymous_7 retval;
  retval.reg_info = dev->registration.reg_info;
  retval.reg_pad_info = dev->registration.reg_pad_info;
  retval.zero_plane_info = dev->registration.zero_plane_info;
  retval.const_shift = dev->registration.const_shift;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/  * (unsigned long int)2048);
  retval.raw_to_mm_shift = (unsigned short int *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)10000);
  retval.depth_to_rgb_shift = (signed int *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)640 * (unsigned long int)480 * (unsigned long int)2);
  retval.registration_table = (signed int (*)[2l])return_value_malloc_3;
  complete_tables(&retval);
  return retval;
}

// freenect_create_dxdy_tables
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 194
static void freenect_create_dxdy_tables(double *reg_x_table, double *reg_y_table, signed int resolution_x, signed int resolution_y, struct anonymous_5 *regdata)
{
  signed long int AX6 = (signed long int)regdata->ax;
  signed long int BX6 = (signed long int)regdata->bx;
  signed long int CX2 = (signed long int)regdata->cx;
  signed long int DX2 = (signed long int)regdata->dx;
  signed long int AY6 = (signed long int)regdata->ay;
  signed long int BY6 = (signed long int)regdata->by;
  signed long int CY2 = (signed long int)regdata->cy;
  signed long int DY2 = (signed long int)regdata->dy;
  signed long int dX0 = (signed long int)((regdata->dx_start << 13) >> 4);
  signed long int dY0 = (signed long int)((regdata->dy_start << 13) >> 4);
  signed long int dXdX0 = (signed long int)((regdata->dxdx_start << 11) >> 3);
  signed long int dXdY0 = (signed long int)((regdata->dxdy_start << 11) >> 3);
  signed long int dYdX0 = (signed long int)((regdata->dydx_start << 11) >> 3);
  signed long int dYdY0 = (signed long int)((regdata->dydy_start << 11) >> 3);
  signed long int dXdXdX0 = (signed long int)((regdata->dxdxdx_start << 5) << 3);
  signed long int dYdXdX0 = (signed long int)((regdata->dydxdx_start << 5) << 3);
  signed long int dYdXdY0 = (signed long int)((regdata->dydxdy_start << 5) << 3);
  signed long int dXdXdY0 = (signed long int)((regdata->dxdxdy_start << 5) << 3);
  signed long int dYdYdX0 = (signed long int)((regdata->dydydx_start << 5) << 3);
  signed long int dYdYdY0 = (signed long int)((regdata->dydydy_start << 5) << 3);
  signed int row;
  signed int col;
  signed int tOffs = 0;
  row = 0;
  for( ; !(row >= resolution_y); row = row + 1)
  {
    dXdXdX0 = dXdXdX0 + CX2;
    dXdX0 = dXdX0 + (dYdXdX0 >> 8);
    dYdXdX0 = dYdXdX0 + DX2;
    dX0 = dX0 + (dYdX0 >> 6);
    dYdX0 = dYdX0 + (dYdYdX0 >> 8);
    dYdYdX0 = dYdYdX0 + BX6;
    dXdXdY0 = dXdXdY0 + CY2;
    dXdY0 = dXdY0 + (dYdXdY0 >> 8);
    dYdXdY0 = dYdXdY0 + DY2;
    dY0 = dY0 + (dYdY0 >> 6);
    dYdY0 = dYdY0 + (dYdYdY0 >> 8);
    dYdYdY0 = dYdYdY0 + BY6;
    signed long int coldXdXdY0 = dXdXdY0;
    signed long int coldXdY0 = dXdY0;
    signed long int coldY0 = dY0;
    signed long int coldXdXdX0 = dXdXdX0;
    signed long int coldXdX0 = dXdX0;
    signed long int coldX0 = dX0;
    col = 0;
    for( ; !(col >= resolution_x); tOffs = tOffs + 1)
    {
      reg_x_table[(signed long int)tOffs] = (double)coldX0 * (1.0 / (double)(1 << 17));
      reg_y_table[(signed long int)tOffs] = (double)coldY0 * (1.0 / (double)(1 << 17));
      coldX0 = coldX0 + (coldXdX0 >> 6);
      coldXdX0 = coldXdX0 + (coldXdXdX0 >> 8);
      coldXdXdX0 = coldXdXdX0 + AX6;
      coldY0 = coldY0 + (coldXdY0 >> 6);
      coldXdY0 = coldXdY0 + (coldXdXdY0 >> 8);
      coldXdXdY0 = coldXdXdY0 + AY6;
      col = col + 1;
    }
  }
}

// freenect_destroy_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 116
signed int freenect_destroy_registration(struct anonymous_7 *reg)
{
  if(!(reg->raw_to_mm_shift == ((unsigned short int *)NULL)))
  {
    free((void *)reg->raw_to_mm_shift);
    reg->raw_to_mm_shift = (unsigned short int *)(void *)0;
  }

  if(!(reg->depth_to_rgb_shift == ((signed int *)NULL)))
  {
    free((void *)reg->depth_to_rgb_shift);
    reg->depth_to_rgb_shift = (signed int *)(void *)0;
  }

  if(!(reg->registration_table == ((signed int (*)[2l])NULL)))
  {
    free((void *)reg->registration_table);
    reg->registration_table = (signed int (*)[2l])(void *)0;
  }

  return 0;
}

// freenect_enabled_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 138
enum anonymous_25 freenect_enabled_subdevices(struct _freenect_context *ctx)
{
  return ctx->enabled_subdevices;
}

// freenect_fetch_reg_const_shift
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 769
static signed int freenect_fetch_reg_const_shift(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  char reply[512l];
  unsigned short int cmd[5l];
  struct anonymous_29 mode;
  mode=freenect_get_current_video_mode(dev);
  cmd[(signed long int)0] = (unsigned short int)0x00;
  cmd[(signed long int)1] = (unsigned short int)0;
  cmd[(signed long int)2] = (unsigned short int)mode.resolution;
  cmd[(signed long int)3] = (unsigned short int)mode.framerate;
  cmd[(signed long int)4] = (unsigned short int)0;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x16, (void *)cmd, (unsigned int)10, (void *)reply, 4);
  if(!(res == 4))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_fetch_reg_const_shift: send_cmd read %d bytes (expected 8)\n", res);
    return -1;
  }

  else
  {
    unsigned short int shift;
    memcpy((void *)&shift, (const void *)(reply + (signed long int)2), sizeof(unsigned short int) /*2ul*/ );
    shift = shift;
    dev->registration.const_shift = (double)shift;
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "const_shift: %f\n", dev->registration.const_shift);
    return 0;
  }
}

// freenect_fetch_reg_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 664
static signed int freenect_fetch_reg_info(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  char reply[512l];
  unsigned short int cmd[5l];
  struct anonymous_29 mode;
  mode=freenect_get_current_video_mode(dev);
  cmd[(signed long int)0] = (unsigned short int)0x40;
  cmd[(signed long int)1] = (unsigned short int)0;
  cmd[(signed long int)2] = (unsigned short int)mode.resolution;
  cmd[(signed long int)3] = (unsigned short int)mode.framerate;
  cmd[(signed long int)4] = (unsigned short int)0;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x16, (void *)cmd, (unsigned int)10, (void *)reply, 118);
  if(!(res == 118))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_fetch_reg_info: send_cmd read %d bytes (expected 118)\n", res);
    return -1;
  }

  else
  {
    memcpy((void *)&dev->registration.reg_info, (const void *)(reply + (signed long int)2), sizeof(struct anonymous_5) /*116ul*/ );
    dev->registration.reg_info.ax = dev->registration.reg_info.ax;
    dev->registration.reg_info.bx = dev->registration.reg_info.bx;
    dev->registration.reg_info.cx = dev->registration.reg_info.cx;
    dev->registration.reg_info.dx = dev->registration.reg_info.dx;
    dev->registration.reg_info.ay = dev->registration.reg_info.ay;
    dev->registration.reg_info.by = dev->registration.reg_info.by;
    dev->registration.reg_info.cy = dev->registration.reg_info.cy;
    dev->registration.reg_info.dy = dev->registration.reg_info.dy;
    dev->registration.reg_info.dx_start = dev->registration.reg_info.dx_start;
    dev->registration.reg_info.dy_start = dev->registration.reg_info.dy_start;
    dev->registration.reg_info.dx_beta_start = dev->registration.reg_info.dx_beta_start;
    dev->registration.reg_info.dy_beta_start = dev->registration.reg_info.dy_beta_start;
    dev->registration.reg_info.dx_beta_inc = dev->registration.reg_info.dx_beta_inc;
    dev->registration.reg_info.dy_beta_inc = dev->registration.reg_info.dy_beta_inc;
    dev->registration.reg_info.dxdx_start = dev->registration.reg_info.dxdx_start;
    dev->registration.reg_info.dxdy_start = dev->registration.reg_info.dxdy_start;
    dev->registration.reg_info.dydx_start = dev->registration.reg_info.dydx_start;
    dev->registration.reg_info.dydy_start = dev->registration.reg_info.dydy_start;
    dev->registration.reg_info.dxdxdx_start = dev->registration.reg_info.dxdxdx_start;
    dev->registration.reg_info.dydxdx_start = dev->registration.reg_info.dydxdx_start;
    dev->registration.reg_info.dxdxdy_start = dev->registration.reg_info.dxdxdy_start;
    dev->registration.reg_info.dydxdy_start = dev->registration.reg_info.dydxdy_start;
    dev->registration.reg_info.dydydx_start = dev->registration.reg_info.dydydx_start;
    dev->registration.reg_info.dydydy_start = dev->registration.reg_info.dydydy_start;
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "ax:                %d\n", dev->registration.reg_info.ax);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "bx:                %d\n", dev->registration.reg_info.bx);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "cx:                %d\n", dev->registration.reg_info.cx);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dx:                %d\n", dev->registration.reg_info.dx);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "ay:                %d\n", dev->registration.reg_info.ay);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "by:                %d\n", dev->registration.reg_info.by);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "cy:                %d\n", dev->registration.reg_info.cy);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dy:                %d\n", dev->registration.reg_info.dy);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dx_start:          %d\n", dev->registration.reg_info.dx_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dy_start:          %d\n", dev->registration.reg_info.dy_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dx_beta_start:     %d\n", dev->registration.reg_info.dx_beta_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dy_beta_start:     %d\n", dev->registration.reg_info.dy_beta_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dx_beta_inc:       %d\n", dev->registration.reg_info.dx_beta_inc);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dy_beta_inc:       %d\n", dev->registration.reg_info.dy_beta_inc);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dxdx_start:        %d\n", dev->registration.reg_info.dxdx_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dxdy_start:        %d\n", dev->registration.reg_info.dxdy_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dydx_start:        %d\n", dev->registration.reg_info.dydx_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dydy_start:        %d\n", dev->registration.reg_info.dydy_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dxdxdx_start:      %d\n", dev->registration.reg_info.dxdxdx_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dydxdx_start:      %d\n", dev->registration.reg_info.dydxdx_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dxdxdy_start:      %d\n", dev->registration.reg_info.dxdxdy_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dydxdy_start:      %d\n", dev->registration.reg_info.dydxdy_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dydydx_start:      %d\n", dev->registration.reg_info.dydydx_start);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dydydy_start:      %d\n", dev->registration.reg_info.dydydy_start);
    return 0;
  }
}

// freenect_fetch_reg_pad_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 742
static signed int freenect_fetch_reg_pad_info(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  char reply[512l];
  unsigned short int cmd[5l];
  struct anonymous_29 mode;
  mode=freenect_get_current_video_mode(dev);
  cmd[(signed long int)0] = (unsigned short int)0x41;
  cmd[(signed long int)1] = (unsigned short int)0;
  cmd[(signed long int)2] = (unsigned short int)mode.resolution;
  cmd[(signed long int)3] = (unsigned short int)mode.framerate;
  cmd[(signed long int)4] = (unsigned short int)0;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x16, (void *)cmd, (unsigned int)10, (void *)reply, 8);
  if(!(res == 8))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_fetch_reg_pad_info: send_cmd read %d bytes (expected 8)\n", res);
    return -1;
  }

  else
  {
    memcpy((void *)&dev->registration.reg_pad_info, (const void *)(reply + (signed long int)2), sizeof(struct anonymous_6) /*6ul*/ );
    dev->registration.reg_pad_info.start_lines = dev->registration.reg_pad_info.start_lines;
    dev->registration.reg_pad_info.end_lines = dev->registration.reg_pad_info.end_lines;
    dev->registration.reg_pad_info.cropping_lines = dev->registration.reg_pad_info.cropping_lines;
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "start_lines:    %u\n", dev->registration.reg_pad_info.start_lines);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "end_lines:      %u\n", dev->registration.reg_pad_info.end_lines);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "cropping_lines: %u\n", dev->registration.reg_pad_info.cropping_lines);
    return 0;
  }
}

// freenect_fetch_zero_plane_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 794
static signed int freenect_fetch_zero_plane_info(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  char reply[512l];
  unsigned short int cmd[5l] = { (unsigned short int)0, 0, 0, 0, 0 };
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x04, (void *)cmd, (unsigned int)10, (void *)reply, ctx->zero_plane_res);
  if(!(res == ctx->zero_plane_res))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_fetch_zero_plane_info: send_cmd read %d bytes (expected %d)\n", res, ctx->zero_plane_res);
    return -1;
  }

  else
  {
    memcpy((void *)&dev->registration.zero_plane_info, (const void *)(reply + (signed long int)94), sizeof(struct anonymous) /*16ul*/ );
    /* tag-#anon#lUN[U32'ui'||F32'f'|] */
union anonymous_32
{
  // ui
  unsigned int ui;
  // f
  float f;
};

/* */
    ;
    union anonymous_32 conversion_union;
    conversion_union.f = dev->registration.zero_plane_info.dcmos_emitter_dist;
    conversion_union.ui = conversion_union.ui;
    dev->registration.zero_plane_info.dcmos_emitter_dist = conversion_union.f;
    conversion_union.f = dev->registration.zero_plane_info.dcmos_rcmos_dist;
    conversion_union.ui = conversion_union.ui;
    dev->registration.zero_plane_info.dcmos_rcmos_dist = conversion_union.f;
    conversion_union.f = dev->registration.zero_plane_info.reference_distance;
    conversion_union.ui = conversion_union.ui;
    dev->registration.zero_plane_info.reference_distance = conversion_union.f;
    conversion_union.f = dev->registration.zero_plane_info.reference_pixel_size;
    conversion_union.ui = conversion_union.ui;
    dev->registration.zero_plane_info.reference_pixel_size = conversion_union.f;
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dcmos_emitter_distance: %f\n", dev->registration.zero_plane_info.dcmos_emitter_dist);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "dcmos_rcmos_distance:   %f\n", dev->registration.zero_plane_info.dcmos_rcmos_dist);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "reference_distance:     %f\n", dev->registration.zero_plane_info.reference_distance);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "reference_pixel_size:   %f\n", dev->registration.zero_plane_info.reference_pixel_size);
    dev->registration.zero_plane_info.dcmos_rcmos_dist = 2.4f;
    return 0;
  }
}

// freenect_find_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 650
struct anonymous_29 freenect_find_depth_mode(enum anonymous_0 res, enum anonymous_8 fmt)
{
  unsigned int unique_id = (unsigned int)(((signed int)res & 0xff) << 8 | (signed int)fmt & 0xff);
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(supported_depth_modes[(signed long int)i].reserved == unique_id)
      return supported_depth_modes[(signed long int)i];

  struct anonymous_29 retval;
  retval.is_valid = (signed char)0;
  return retval;
}

// freenect_find_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 598
struct anonymous_29 freenect_find_video_mode(enum anonymous_0 res, enum anonymous_1 fmt)
{
  unsigned int unique_id = (unsigned int)(((signed int)res & 0xff) << 8 | (signed int)fmt & 0xff);
  signed int i = 0;
  for( ; !(i >= 12); i = i + 1)
    if(supported_video_modes[(signed long int)i].reserved == unique_id)
      return supported_video_modes[(signed long int)i];

  struct anonymous_29 retval;
  retval.is_valid = (signed char)0;
  return retval;
}

// freenect_free_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 112
void freenect_free_device_attributes(struct freenect_device_attributes *attribute_list)
{
  struct freenect_device_attributes *to_free;
  while(!(attribute_list == ((struct freenect_device_attributes *)NULL)))
  {
    to_free = attribute_list;
    if(!(attribute_list->camera_serial == ((const char *)NULL)))
    {
      free((void *)(char *)attribute_list->camera_serial);
      attribute_list->camera_serial = (const char *)(void *)0;
    }

    attribute_list = attribute_list->next;
    free((void *)to_free);
  }
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// freenect_get_current_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1197
struct anonymous_29 freenect_get_current_depth_mode(struct _freenect_device *dev)
{
  struct anonymous_29 return_value_freenect_find_depth_mode_1;
  return_value_freenect_find_depth_mode_1=freenect_find_depth_mode(dev->depth_resolution, dev->depth_format);
  return return_value_freenect_find_depth_mode_1;
}

// freenect_get_current_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1134
struct anonymous_29 freenect_get_current_video_mode(struct _freenect_device *dev)
{
  struct anonymous_29 return_value_freenect_find_video_mode_1;
  return_value_freenect_find_video_mode_1=freenect_find_video_mode(dev->video_resolution, dev->video_format);
  return return_value_freenect_find_video_mode_1;
}

// freenect_get_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1188
struct anonymous_29 freenect_get_depth_mode(signed int mode_num)
{
  if(mode_num >= 0 && !(mode_num >= 6))
    return supported_depth_modes[(signed long int)mode_num];

  else
  {
    struct anonymous_29 retval;
    retval.is_valid = (signed char)0;
    return retval;
  }
}

// freenect_get_depth_mode_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1183
signed int freenect_get_depth_mode_count()
{
  return 6;
}

// freenect_get_ir_brightness
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 96
signed int freenect_get_ir_brightness(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  unsigned short int brightness;
  brightness=read_register(dev, (unsigned short int)0x15);
  if((signed int)brightness == 65535)
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "Failed to get IR brightness!");
    return -1;
  }

  else
    return (signed int)brightness;
}

// freenect_get_mks_accel
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 331
void freenect_get_mks_accel(struct anonymous_30 *state, double *x, double *y, double *z)
{
  *x = ((double)state->accelerometer_x / (double)819) * 9.80665;
  *y = ((double)state->accelerometer_y / (double)819) * 9.80665;
  *z = ((double)state->accelerometer_z / (double)819) * 9.80665;
}

// freenect_get_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 321
double freenect_get_tilt_degs(struct anonymous_30 *state)
{
  return (double)state->tilt_angle / 2.;
}

// freenect_get_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 95
struct anonymous_30 * freenect_get_tilt_state(struct _freenect_device *dev)
{
  return &dev->raw_state;
}

// freenect_get_tilt_status
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 326
enum anonymous_31 freenect_get_tilt_status(struct anonymous_30 *state)
{
  return state->tilt_status;
}

// freenect_get_user
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 247
void * freenect_get_user(struct _freenect_device *dev)
{
  return dev->user_data;
}

// freenect_get_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1125
struct anonymous_29 freenect_get_video_mode(signed int mode_num)
{
  if(mode_num >= 0 && !(mode_num >= 12))
    return supported_video_modes[(signed long int)mode_num];

  else
  {
    struct anonymous_29 retval;
    retval.is_valid = (signed char)0;
    return retval;
  }
}

// freenect_get_video_mode_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1120
signed int freenect_get_video_mode_count()
{
  return 12;
}

// freenect_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 221
signed int freenect_init(struct _freenect_context **ctx, void *usb_ctx)
{
  signed int res;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _freenect_context) /*88ul*/ );
  *ctx = (struct _freenect_context *)return_value_malloc_1;
  if(*ctx == ((struct _freenect_context *)NULL))
    return -1;

  else
  {
    memset((void *)*ctx, 0, sizeof(struct _freenect_context) /*88ul*/ );
    (*ctx)->log_level = (enum anonymous_11)FREENECT_LOG_WARNING;
    (*ctx)->enabled_subdevices = (enum anonymous_25)(FREENECT_DEVICE_MOTOR | FREENECT_DEVICE_CAMERA);
    res=fnusb_init(&(*ctx)->usb, usb_ctx);
    if(!(res >= 0))
    {
      free((void *)*ctx);
      *ctx = (struct _freenect_context *)(void *)0;
    }

    return res;
  }
}

// freenect_init_depth_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 60
static void freenect_init_depth_to_rgb(signed int *depth_to_rgb, struct anonymous *zpi)
{
  unsigned int i;
  unsigned int x_scale = (unsigned int)(1280 / 640);
  double pixel_size = 1.0 / (double)(zpi->reference_pixel_size * (float)x_scale * (float)10);
  double pixels_between_rgb_and_ir_cmos = (double)zpi->dcmos_rcmos_dist * pixel_size * (double)10;
  double reference_distance_in_pixels = (double)zpi->reference_distance * pixel_size * (double)10;
  memset((void *)depth_to_rgb, 0, (unsigned long int)10000 * sizeof(signed int) /*4ul*/ );
  i = (unsigned int)0;
  for( ; !(i >= 10000u); i = i + 1u)
  {
    double current_depth_in_pixels = (double)i * pixel_size;
    depth_to_rgb[(signed long int)i] = (signed int)(((pixels_between_rgb_and_ir_cmos * (current_depth_in_pixels - reference_distance_in_pixels)) / current_depth_in_pixels + 0.375) * (double)256);
  }
}

// freenect_init_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 32
signed int freenect_init_registration(struct _freenect_device *dev)
{
  struct anonymous_7 *reg = &dev->registration;
  freenect_destroy_registration(&dev->registration);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/  * (unsigned long int)2048);
  reg->raw_to_mm_shift = (unsigned short int *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)10000);
  reg->depth_to_rgb_shift = (signed int *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)640 * (unsigned long int)480 * (unsigned long int)2);
  reg->registration_table = (signed int (*)[2l])return_value_malloc_3;
  complete_tables(reg);
  return 0;
}

// freenect_init_registration_table
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 264
static void freenect_init_registration_table(signed int (*registration_table)[2l], struct anonymous_5 *reg_info)
{
  double *regtable_dx;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  regtable_dx = (double *)return_value_malloc_1;
  double *regtable_dy;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  regtable_dy = (double *)return_value_malloc_2;
  memset((void *)regtable_dx, 0, (unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  memset((void *)regtable_dy, 0, (unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  signed int x;
  signed int y;
  signed int index = 0;
  freenect_create_dxdy_tables(regtable_dx, regtable_dy, 640, 480, reg_info);
  y = 0;
  for( ; !(y >= 480); y = y + 1)
  {
    x = 0;
    for( ; !(x >= 640); index = index + 1)
    {
      double new_x = (double)x + regtable_dx[(signed long int)index] + (double)1;
      double new_y = (double)y + regtable_dy[(signed long int)index] + (double)1;
      if(new_x < 0.000000 || new_y < 0.000000 || new_x >= 640.000000 || new_y >= 480.000000)
        new_x = (double)(2 * 640);

      registration_table[(signed long int)index][(signed long int)0] = (signed int)(new_x * (double)256);
      registration_table[(signed long int)index][(signed long int)1] = (signed int)new_y;
      x = x + 1;
    }
  }
  free((void *)regtable_dx);
  free((void *)regtable_dy);
}

// freenect_list_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 107
signed int freenect_list_device_attributes(struct _freenect_context *ctx, struct freenect_device_attributes **attribute_list)
{
  signed int return_value_fnusb_list_device_attributes_1;
  return_value_fnusb_list_device_attributes_1=fnusb_list_device_attributes(&ctx->usb, attribute_list);
  return return_value_fnusb_list_device_attributes_1;
}

// freenect_map_rgb_to_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 333
void freenect_map_rgb_to_depth(struct _freenect_device *dev, unsigned short int *depth_mm, unsigned char *rgb_raw, unsigned char *rgb_registered)
{
  unsigned int target_offset = (unsigned int)((signed int)dev->registration.reg_pad_info.start_lines * 480);
  signed int x;
  signed int y;
  signed int *map;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(480 * 640) * sizeof(signed int) /*4ul*/ );
  map = (signed int *)return_value_malloc_1;
  unsigned short int *zBuffer;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(480 * 640) * sizeof(unsigned short int) /*2ul*/ );
  zBuffer = (unsigned short int *)return_value_malloc_2;
  memset((void *)zBuffer, 0, (unsigned long int)(640 * 480) * sizeof(unsigned short int) /*2ul*/ );
  y = 0;
  _Bool tmp_if_expr_3;
  for( ; !(y >= 480); y = y + 1)
  {
    x = 0;
    for( ; !(x >= 640); x = x + 1)
    {
      unsigned int index = (unsigned int)(y * 640 + x);
      unsigned int cx;
      unsigned int cy;
      unsigned int cindex;
      map[(signed long int)index] = -1;
      signed int wz = (signed int)depth_mm[(signed long int)index];
      if(!(wz == 0))
      {
        cx = (unsigned int)((dev->registration.registration_table[(signed long int)index][(signed long int)0] + dev->registration.depth_to_rgb_shift[(signed long int)wz]) / 256);
        cy = (unsigned int)dev->registration.registration_table[(signed long int)index][(signed long int)1] - target_offset;
        if(!(cx >= 640u))
        {
          cindex = cy * (unsigned int)640 + cx;
          map[(signed long int)index] = (signed int)cindex;
          if((signed int)zBuffer[(signed long int)cindex] == 0)
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = (signed int)zBuffer[(signed long int)cindex] > wz ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            zBuffer[(signed long int)cindex] = (unsigned short int)wz;

        }

      }

    }
  }
  y = 0;
  for( ; !(y >= 480); y = y + 1)
  {
    x = 0;
    for( ; !(x >= 640); x = x + 1)
    {
      unsigned int freenect_map_rgb_to_depth__1__2__1__1__index = (unsigned int)(y * 640 + x);
      unsigned int freenect_map_rgb_to_depth__1__2__1__1__cindex = (unsigned int)map[(signed long int)freenect_map_rgb_to_depth__1__2__1__1__index];
      if(freenect_map_rgb_to_depth__1__2__1__1__cindex == 4294967295u)
      {
        freenect_map_rgb_to_depth__1__2__1__1__index = freenect_map_rgb_to_depth__1__2__1__1__index * (unsigned int)3;
        rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)0)] = (unsigned char)0;
        rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)1)] = (unsigned char)0;
        rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)2)] = (unsigned char)0;
      }

      else
      {
        unsigned short int currentDepth = depth_mm[(signed long int)freenect_map_rgb_to_depth__1__2__1__1__index];
        unsigned short int minDepth = zBuffer[(signed long int)freenect_map_rgb_to_depth__1__2__1__1__cindex];
        if((signed int)minDepth >= (signed int)currentDepth)
        {
          freenect_map_rgb_to_depth__1__2__1__1__index = freenect_map_rgb_to_depth__1__2__1__1__index * (unsigned int)3;
          freenect_map_rgb_to_depth__1__2__1__1__cindex = freenect_map_rgb_to_depth__1__2__1__1__cindex * (unsigned int)3;
          rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)0)] = rgb_raw[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__cindex + (unsigned int)0)];
          rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)1)] = rgb_raw[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__cindex + (unsigned int)1)];
          rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)2)] = rgb_raw[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__cindex + (unsigned int)2)];
        }

      }
    }
  }
  free((void *)zBuffer);
  free((void *)map);
}

// freenect_num_devices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 281
signed int freenect_num_devices(struct _freenect_context *ctx)
{
  signed int return_value_fnusb_num_devices_1;
  return_value_fnusb_num_devices_1=fnusb_num_devices(&ctx->usb);
  return return_value_fnusb_num_devices_1;
}

// freenect_open_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 343
signed int freenect_open_device(struct _freenect_context *ctx, struct _freenect_device **dev, signed int index)
{
  signed int res;
  struct _freenect_device *pdev;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _freenect_device) /*936ul*/ );
  pdev = (struct _freenect_device *)return_value_malloc_1;
  if(pdev == ((struct _freenect_device *)NULL))
    return -1;

  else
  {
    memset((void *)pdev, 0, sizeof(struct _freenect_device) /*936ul*/ );
    pdev->parent = ctx;
    res=fnusb_open_subdevices(pdev, index);
    if(!(res >= 0))
    {
      free((void *)pdev);
      return res;
    }

    else
    {
      if(ctx->first == ((struct _freenect_device *)NULL))
        ctx->first = pdev;

      else
      {
        struct _freenect_device *prev = ctx->first;
        for( ; !(prev->next == ((struct _freenect_device *)NULL)); prev = prev->next)
          ;
        prev->next = pdev;
      }
      *dev = pdev;
      if(!(pdev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
      {
        signed int return_value_freenect_camera_init_2;
        return_value_freenect_camera_init_2=freenect_camera_init(pdev);
        if(!(return_value_freenect_camera_init_2 >= 0))
          return -1;

      }

      return 0;
    }
  }
}

// freenect_open_device_by_camera_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 181
signed int freenect_open_device_by_camera_serial(struct _freenect_context *ctx, struct _freenect_device **dev, const char *camera_serial)
{
  struct freenect_device_attributes *attrlist;
  struct freenect_device_attributes *item;
  signed int count;
  count=fnusb_list_device_attributes(&ctx->usb, &attrlist);
  signed int return_value_strcmp_2;
  if(!(count >= 0))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_open_device_by_camera_serial: Couldn't enumerate serial numbers\n");
    return count;
  }

  else
  {
    signed int index = 0;
    item = attrlist;
    for( ; !(item == ((struct freenect_device_attributes *)NULL)); index = index + 1)
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(item->camera_serial);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(camera_serial);
      if(return_value_strlen_3 == return_value_strlen_4)
      {
        return_value_strcmp_2=strcmp(item->camera_serial, camera_serial);
        if(return_value_strcmp_2 == 0)
        {
          freenect_free_device_attributes(attrlist);
          signed int return_value_freenect_open_device_1;
          return_value_freenect_open_device_1=freenect_open_device(ctx, dev, index);
          return return_value_freenect_open_device_1;
        }

      }

      item = item->next;
    }
    freenect_free_device_attributes(attrlist);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_open_device_by_camera_serial: Couldn't find a device with serial %s\n", camera_serial);
    return -1;
  }
}

// freenect_process_events
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 259
signed int freenect_process_events(struct _freenect_context *ctx)
{
  struct timeval timeout;
  timeout.tv_sec = (signed long int)60;
  timeout.tv_usec = (signed long int)0;
  signed int return_value_freenect_process_events_timeout_1;
  return_value_freenect_process_events_timeout_1=freenect_process_events_timeout(ctx, &timeout);
  return return_value_freenect_process_events_timeout_1;
}

// freenect_process_events_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 80
signed int freenect_process_events_timeout(struct _freenect_context *ctx, struct timeval *timeout)
{
  signed int res;
  res=fnusb_process_events_timeout(&ctx->usb, timeout);
  struct _freenect_device *dev = ctx->first;
  for( ; !(dev == ((struct _freenect_device *)NULL)); dev = dev->next)
  {
    if(!(dev->usb_cam.device_dead == 0))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "USB camera marked dead, stopping streams\n");
      res = -1;
      freenect_stop_video(dev);
      freenect_stop_depth(dev);
    }

    if(!(dev->usb_audio.device_dead == 0))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "USB audio marked dead, stopping streams\n");
      res = -1;
      freenect_stop_audio(dev);
    }

  }
  return res;
}

// freenect_raw_to_mm
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 297
static unsigned short int freenect_raw_to_mm(unsigned short int raw, struct anonymous_7 *reg)
{
  struct anonymous *zpi = &reg->zero_plane_info;
  double fixed_ref_x = ((double)raw - (parameter_coefficient * reg->const_shift) / pixel_size_factor) / parameter_coefficient - 0.375;
  double metric = fixed_ref_x * (double)zpi->reference_pixel_size * pixel_size_factor;
  return (unsigned short int)(shift_scale * ((metric * (double)zpi->reference_distance) / ((double)zpi->dcmos_emitter_dist - metric) + (double)zpi->reference_distance));
}

// freenect_select_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 321
void freenect_select_subdevices(struct _freenect_context *ctx, enum anonymous_25 subdevs)
{
  ctx->enabled_subdevices = (enum anonymous_25)((signed int)subdevs & (FREENECT_DEVICE_MOTOR | FREENECT_DEVICE_CAMERA | FREENECT_DEVICE_AUDIO));
}

// freenect_set_audio_in_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 142
void freenect_set_audio_in_callback(struct _freenect_device *dev, void (*callback)(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *))
{
  dev->audio_in_cb = callback;
}

// freenect_set_audio_out_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 145
void freenect_set_audio_out_callback(struct _freenect_device *dev, void (*callback)(struct _freenect_device *, struct anonymous_14 *, signed int *))
{
  dev->audio_out_cb = callback;
}

// freenect_set_depth_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1241
signed int freenect_set_depth_buffer(struct _freenect_device *dev, void *buf)
{
  signed int return_value_stream_setbuf_1;
  return_value_stream_setbuf_1=stream_setbuf(dev->parent, &dev->depth, buf);
  return return_value_stream_setbuf_1;
}

// freenect_set_depth_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 399
void freenect_set_depth_callback(struct _freenect_device *dev, void (*cb)(struct _freenect_device *, void *, unsigned int))
{
  dev->depth_cb = cb;
}

// freenect_set_depth_chunk_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1110
void freenect_set_depth_chunk_callback(struct _freenect_device *dev, void (*cb)(void *, void *, signed int, signed int, void *))
{
  dev->depth_chunk_cb = cb;
}

// freenect_set_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 661
signed int freenect_set_depth_mode(struct _freenect_device *dev, const struct anonymous_29 mode)
{
  struct _freenect_context *ctx = dev->parent;
  if(!(dev->depth.running == 0))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Tried to set depth mode while stream is active\n");
    return -1;
  }

  else
  {
    signed int found = 0;
    signed int i = 0;
    for( ; !(i >= 6); i = i + 1)
      if(supported_depth_modes[(signed long int)i].reserved == mode.reserved)
      {
        found = 1;
        break;
      }

    if(found == 0)
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_set_depth_mode: freenect_frame_mode provided is invalid\n");
      return -1;
    }

    else
    {
      enum anonymous_0 res = (enum anonymous_0)(mode.reserved >> 8 & (unsigned int)0xff);
      enum anonymous_8 fmt = (enum anonymous_8)(mode.reserved & (unsigned int)0xff);
      dev->depth_format = fmt;
      dev->depth_resolution = res;
      return 0;
    }
  }
}

// freenect_set_flag
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 46
signed int freenect_set_flag(struct _freenect_device *dev, enum anonymous_3 flag, enum anonymous_4 value)
{
  struct _freenect_context *ctx = dev->parent;
  if((signed int)flag == FREENECT_NEAR_MODE)
  {
    if(!(dev->usb_cam.PID == 0x02bf))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "Near mode is only supported by K4W");
      return -1;
    }

    if((signed int)value == FREENECT_ON)
    {
      signed int ret;
      ret=write_register(dev, (unsigned short int)0x0015, (unsigned short int)0x0007);
      if(!(ret >= 0))
        return ret;

      usleep((unsigned int)100000);
      signed int return_value_write_register_1;
      return_value_write_register_1=write_register(dev, (unsigned short int)0x02EF, (unsigned short int)0x0000);
      return return_value_write_register_1;
    }

    else
    {
      signed int freenect_set_flag__1__1__3__ret;
      freenect_set_flag__1__1__3__ret=write_register(dev, (unsigned short int)0x0015, (unsigned short int)0x001E);
      if(!(freenect_set_flag__1__1__3__ret >= 0))
        return freenect_set_flag__1__1__3__ret;

      usleep((unsigned int)100000);
      signed int return_value_write_register_2;
      return_value_write_register_2=write_register(dev, (unsigned short int)0x02EF, (unsigned short int)0x0190);
      return return_value_write_register_2;
    }
  }

  if((signed int)flag >= 65536)
  {
    signed int reg;
    reg=register_for_flag((signed int)flag);
    if(!(reg >= 0))
      return reg;

    signed int return_value_write_register_3;
    return_value_write_register_3=write_register(dev, (unsigned short int)reg, (unsigned short int)value);
    return return_value_write_register_3;
  }

  unsigned short int cmos_value;
  cmos_value=read_cmos_register(dev, (unsigned short int)0x0106);
  if((signed int)cmos_value == 65535)
    return -1;

  else
  {
    if((signed int)value == FREENECT_ON)
      cmos_value = cmos_value | (unsigned short int)flag;

    else
      cmos_value = cmos_value & (unsigned short int)~((signed int)flag);
    signed int return_value_write_cmos_register_4;
    return_value_write_cmos_register_4=write_cmos_register(dev, (unsigned short int)0x0106, cmos_value);
    return return_value_write_cmos_register_4;
  }
}

// freenect_set_fw_address_k4w
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 292
void freenect_set_fw_address_k4w(struct _freenect_context *ctx, unsigned char *fw_ptr, unsigned int num_bytes)
{
  ctx->fn_fw_k4w_ptr = fw_ptr;
  ctx->fn_fw_k4w_size = num_bytes;
}

// freenect_set_fw_address_nui
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 286
void freenect_set_fw_address_nui(struct _freenect_context *ctx, unsigned char *fw_ptr, unsigned int num_bytes)
{
  ctx->fn_fw_nui_ptr = fw_ptr;
  ctx->fn_fw_nui_size = num_bytes;
}

// freenect_set_ir_brightness
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 110
signed int freenect_set_ir_brightness(struct _freenect_device *dev, unsigned short int brightness)
{
  struct _freenect_context *ctx = dev->parent;
  if(!((signed int)brightness >= 1))
    brightness = (unsigned short int)1;

  if((signed int)brightness >= 51)
    brightness = (unsigned short int)50;

  signed int ret;
  ret=write_register(dev, (unsigned short int)0x15, brightness);
  if(!(ret >= 0))
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "Failed to set IR brightness");

  return ret;
}

// freenect_set_led
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 303
signed int freenect_set_led(struct _freenect_device *dev, enum anonymous_19 option)
{
  struct _freenect_context *ctx = dev->parent;
  if(!(dev->motor_control_with_audio_enabled == 0))
  {
    signed int return_value_freenect_set_led_alt_1;
    return_value_freenect_set_led_alt_1=freenect_set_led_alt(dev, option);
    return return_value_freenect_set_led_alt_1;
  }

  if((FREENECT_DEVICE_MOTOR & (signed int)ctx->enabled_subdevices) == 0)
    return 0;

  else
  {
    signed int ret;
    unsigned char empty[1l];
    ret=fnusb_control(&dev->usb_motor, (unsigned char)0x40, (unsigned char)0x06, (unsigned short int)option, (unsigned short int)0x0, empty, (unsigned short int)0x0);
    return ret;
  }
}

// freenect_set_led_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 290
signed int freenect_set_led_alt(struct _freenect_device *dev, enum anonymous_19 state)
{
  struct _freenect_context *ctx = dev->parent;
  if(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "Motor control failed: audio device missing");
    return -1;
  }

  else
  {
    signed int return_value_fnusb_set_led_alt_1;
    return_value_fnusb_set_led_alt_1=fnusb_set_led_alt(dev->usb_audio.dev, ctx, state);
    return return_value_fnusb_set_led_alt_1;
  }
}

// freenect_set_log_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 257
void freenect_set_log_callback(struct _freenect_context *ctx, void (*cb)(struct _freenect_context *, enum anonymous_11, const char *))
{
  ctx->log_cb = cb;
}

// freenect_set_log_level
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 241
void freenect_set_log_level(struct _freenect_context *ctx, enum anonymous_11 level)
{
  ctx->log_level = level;
}

// freenect_set_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 224
signed int freenect_set_tilt_degs(struct _freenect_device *dev, double angle)
{
  struct _freenect_context *ctx = dev->parent;
  if(!(dev->motor_control_with_audio_enabled == 0))
  {
    signed int return_value_freenect_set_tilt_degs_alt_1;
    return_value_freenect_set_tilt_degs_alt_1=freenect_set_tilt_degs_alt(dev, (signed int)angle);
    return return_value_freenect_set_tilt_degs_alt_1;
  }

  if((FREENECT_DEVICE_MOTOR & (signed int)ctx->enabled_subdevices) == 0)
    return 0;

  else
  {
    signed int ret;
    unsigned char empty[1l];
    angle = angle < (double)-31 ? (double)-31 : (angle > (double)31 ? (double)31 : angle);
    angle = angle * (double)2;
    ret=fnusb_control(&dev->usb_motor, (unsigned char)0x40, (unsigned char)0x31, (unsigned short int)(signed short int)angle, (unsigned short int)0x0, empty, (unsigned short int)0x0);
    return ret;
  }
}

// freenect_set_tilt_degs_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 189
signed int freenect_set_tilt_degs_alt(struct _freenect_device *dev, signed int tilt_degrees)
{
  struct _freenect_context *ctx = dev->parent;
  signed int tmp_post_1;
  if(tilt_degrees >= 32 || !(tilt_degrees >= -31))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "set_tilt(): degrees %d out of safe range [-31, 31]\n", tilt_degrees);
    return -1;
  }

  else
    if(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "Motor control failed: audio device missing");
      return -1;
    }

    else
    {
      struct anonymous_22 cmd;
      cmd.magic = (unsigned int)0x06022009;
      tmp_post_1 = tag_seq;
      tag_seq = tag_seq + 1;
      cmd.tag = (unsigned int)tmp_post_1;
      cmd.arg1 = (unsigned int)0;
      cmd.cmd = (unsigned int)0x803b;
      cmd.arg2 = (unsigned int)(signed int)tilt_degrees;
      signed int transferred = 0;
      signed int res = 0;
      unsigned char buffer[20l];
      memcpy((void *)buffer, (const void *)&cmd, (unsigned long int)20);
      res=libusb_bulk_transfer(dev->usb_audio.dev, (unsigned char)0x01, buffer, 20, &transferred, (unsigned int)250);
      if(!(res == 0))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_set_tilt_alt(): libusb_bulk_transfer failed: %d (transferred = %d)\n", res, transferred);
        return res;
      }

      else
      {
        signed int return_value_get_reply_2;
        return_value_get_reply_2=get_reply(dev->usb_audio.dev, ctx);
        return return_value_get_reply_2;
      }
    }
}

// freenect_set_user
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 242
void freenect_set_user(struct _freenect_device *dev, void *user)
{
  dev->user_data = user;
}

// freenect_set_video_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 447
signed int freenect_set_video_buffer(struct _freenect_device *dev, void *buf)
{
  signed int return_value_stream_setbuf_1;
  return_value_stream_setbuf_1=stream_setbuf(dev->parent, &dev->video, buf);
  return return_value_stream_setbuf_1;
}

// freenect_set_video_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 407
void freenect_set_video_callback(struct _freenect_device *dev, void (*cb)(struct _freenect_device *, void *, unsigned int))
{
  dev->video_cb = cb;
}

// freenect_set_video_chunk_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1115
void freenect_set_video_chunk_callback(struct _freenect_device *dev, void (*cb)(void *, void *, signed int, signed int, void *))
{
  dev->video_chunk_cb = cb;
}

// freenect_set_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 612
signed int freenect_set_video_mode(struct _freenect_device *dev, const struct anonymous_29 mode)
{
  struct _freenect_context *ctx = dev->parent;
  if(!(dev->video.running == 0))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Tried to set video mode while stream is active\n");
    return -1;
  }

  else
  {
    signed int found = 0;
    signed int i = 0;
    for( ; !(i >= 12); i = i + 1)
      if(supported_video_modes[(signed long int)i].reserved == mode.reserved)
      {
        found = 1;
        break;
      }

    if(found == 0)
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_set_video_mode: freenect_frame_mode provided is invalid\n");
      return -1;
    }

    else
    {
      enum anonymous_0 res = (enum anonymous_0)(mode.reserved >> 8 & (unsigned int)0xff);
      enum anonymous_1 fmt = (enum anonymous_1)(mode.reserved & (unsigned int)0xff);
      dev->video_format = fmt;
      dev->video_resolution = res;
      freenect_fetch_reg_info(dev);
      return 0;
    }
  }
}

// freenect_shutdown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 230
signed int freenect_shutdown(struct _freenect_context *ctx)
{
  while(!(ctx->first == ((struct _freenect_device *)NULL)))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_NOTICE, "Device %p open during shutdown, closing...\n", ctx->first);
    freenect_close_device(ctx->first);
  }
  fnusb_shutdown(&ctx->usb);
  free((void *)ctx);
  return 0;
}

// freenect_start_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 149
signed int freenect_start_audio(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  signed int res;
  if(!(dev->audio.running == 0))
    return -1;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)256 * sizeof(struct anonymous_14) /*12ul*/ );
    dev->audio.audio_out_ring = (struct anonymous_14 *)return_value_malloc_1;
    memset((void *)dev->audio.audio_out_ring, 0, (unsigned long int)256 * sizeof(struct anonymous_14) /*12ul*/ );
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)256 * sizeof(signed short int) /*2ul*/ );
    dev->audio.cancelled_buffer = (signed short int *)return_value_malloc_2;
    memset((void *)dev->audio.cancelled_buffer, 0, (unsigned long int)256 * sizeof(signed short int) /*2ul*/ );
    signed int i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)256 * sizeof(signed int) /*4ul*/ );
      dev->audio.mic_buffer[(signed long int)i] = (signed int *)return_value_malloc_3;
      memset((void *)dev->audio.mic_buffer[(signed long int)i], 0, (unsigned long int)256 * sizeof(signed int) /*4ul*/ );
    }
    dev->audio.in_unknown=malloc((unsigned long int)48);
    dev->audio.ring_reader_idx = 0;
    dev->audio.ring_writer_idx = 0;
    dev->audio.out_window = (unsigned short int)0;
    dev->audio.out_seq = (unsigned char)0;
    dev->audio.out_counter_within_window = (unsigned char)0;
    dev->audio.out_weird_timestamp = (unsigned short int)0;
    dev->audio.out_window_parity = (unsigned char)0;
    dev->audio.in_window = (unsigned short int)0;
    dev->audio.in_counter = (unsigned char)0;
    i = 0;
    for( ; !(i >= 10); i = i + 1)
      dev->audio.last_seen_window[(signed long int)i] = (unsigned short int)0;
    res=fnusb_start_iso(&dev->usb_audio, &dev->audio_in_isoc, iso_in_callback, (unsigned char)0x82, 16, 16, 524);
    if(!(res >= 0))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "audio: failed to start isochronous IN stream: %d\n", res);
      return res;
    }

    else
    {
      res=fnusb_start_iso(&dev->usb_audio, &dev->audio_out_isoc, iso_out_callback, (unsigned char)0x02, 16, 16, 76);
      if(!(res >= 0))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "audio: failed to start isochronous OUT stream: %d\n", res);
        return res;
      }

      else
      {
        dev->audio.running = 1;
        return 0;
      }
    }
  }
}

// freenect_start_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 456
signed int freenect_start_depth(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  struct anonymous_29 return_value_freenect_find_depth_mode_1;
  struct anonymous_29 return_value_freenect_find_depth_mode_2;
  struct anonymous_29 return_value_freenect_find_depth_mode_3;
  struct anonymous_29 return_value_freenect_find_depth_mode_4;
  struct anonymous_29 return_value_freenect_find_depth_mode_5;
  if(!(dev->depth.running == 0))
    return -1;

  else
  {
    dev->depth.pkt_size = 1760 - 12;
    dev->depth.flag = (unsigned char)0x70;
    dev->depth.variable_length = 0;
    switch((signed int)dev->depth_format)
    {
      case FREENECT_DEPTH_REGISTERED:

      case FREENECT_DEPTH_MM:
        freenect_init_registration(dev);
      case FREENECT_DEPTH_11BIT:
      {
        return_value_freenect_find_depth_mode_1=freenect_find_depth_mode(dev->depth_resolution, (enum anonymous_8)FREENECT_DEPTH_11BIT_PACKED);
        return_value_freenect_find_depth_mode_2=freenect_find_depth_mode(dev->depth_resolution, (enum anonymous_8)FREENECT_DEPTH_11BIT);
        stream_init(ctx, &dev->depth, return_value_freenect_find_depth_mode_1.bytes, return_value_freenect_find_depth_mode_2.bytes);
        break;
      }
      case FREENECT_DEPTH_10BIT:
      {
        return_value_freenect_find_depth_mode_3=freenect_find_depth_mode(dev->depth_resolution, (enum anonymous_8)FREENECT_DEPTH_10BIT_PACKED);
        return_value_freenect_find_depth_mode_4=freenect_find_depth_mode(dev->depth_resolution, (enum anonymous_8)FREENECT_DEPTH_10BIT);
        stream_init(ctx, &dev->depth, return_value_freenect_find_depth_mode_3.bytes, return_value_freenect_find_depth_mode_4.bytes);
        break;
      }
      case FREENECT_DEPTH_11BIT_PACKED:

      case FREENECT_DEPTH_10BIT_PACKED:
      {
        return_value_freenect_find_depth_mode_5=freenect_find_depth_mode(dev->depth_resolution, dev->depth_format);
        stream_init(ctx, &dev->depth, 0, return_value_freenect_find_depth_mode_5.bytes);
        break;
      }
      default:
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_start_depth() called with invalid depth format %d\n", dev->depth_format);
        return -1;
      }
    }
    const unsigned char depth_endpoint = (const unsigned char)0x82;
    signed int packet_size;
    packet_size=fnusb_get_max_iso_packet_size(&dev->usb_cam, depth_endpoint, 1920);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "[Stream 70] Negotiated packet size %d\n", packet_size);
    signed int res;
    res=fnusb_start_iso(&dev->usb_cam, &dev->depth_isoc, depth_process, depth_endpoint, 16, 16, packet_size);
    if(!(res >= 0))
      return res;

    else
    {
      write_register(dev, (unsigned short int)0x105, (unsigned short int)0x00);
      write_register(dev, (unsigned short int)0x06, (unsigned short int)0x00);
      switch((signed int)dev->depth_format)
      {
        case FREENECT_DEPTH_11BIT:

        case FREENECT_DEPTH_11BIT_PACKED:

        case FREENECT_DEPTH_REGISTERED:

        case FREENECT_DEPTH_MM:
        {
          write_register(dev, (unsigned short int)0x12, (unsigned short int)0x03);
          goto __CPROVER_DUMP_L11;
        }
        case FREENECT_DEPTH_10BIT:

        case FREENECT_DEPTH_10BIT_PACKED:
          write_register(dev, (unsigned short int)0x12, (unsigned short int)0x02);
        case FREENECT_DEPTH_DUMMY:

        default:
        {

        __CPROVER_DUMP_L11:
          ;
          write_register(dev, (unsigned short int)0x13, (unsigned short int)0x01);
          write_register(dev, (unsigned short int)0x14, (unsigned short int)0x1e);
          write_register(dev, (unsigned short int)0x06, (unsigned short int)0x02);
          write_register(dev, (unsigned short int)0x17, (unsigned short int)0x00);
          dev->depth.running = 1;
          return 0;
        }
      }
    }
  }
}

// freenect_start_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 465
signed int freenect_start_video(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  struct anonymous_29 return_value_freenect_find_video_mode_1;
  struct anonymous_29 return_value_freenect_find_video_mode_2;
  struct anonymous_29 return_value_freenect_find_video_mode_3;
  struct anonymous_29 return_value_freenect_find_video_mode_4;
  if(!(dev->video.running == 0))
    return -1;

  else
  {
    dev->video.pkt_size = 1920 - 12;
    dev->video.flag = (unsigned char)0x80;
    dev->video.variable_length = 0;
    unsigned short int mode_reg;
    unsigned short int mode_value;
    unsigned short int res_reg;
    unsigned short int res_value;
    unsigned short int fps_reg;
    unsigned short int fps_value;
    unsigned short int hflip_reg;
    switch((signed int)dev->video_format)
    {
      case FREENECT_VIDEO_RGB:

      case FREENECT_VIDEO_BAYER:
      {
        if((signed int)dev->video_resolution == FREENECT_RESOLUTION_HIGH)
        {
          mode_value = (unsigned short int)0x00;
          res_value = (unsigned short int)0x02;
          fps_value = (unsigned short int)0x0f;
        }

        else
          if((signed int)dev->video_resolution == FREENECT_RESOLUTION_MEDIUM)
          {
            mode_value = (unsigned short int)0x00;
            res_value = (unsigned short int)0x01;
            fps_value = (unsigned short int)0x1e;
          }

          else
          {
            fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_start_video(): called with invalid format/resolution combination\n");
            return -1;
          }
        mode_reg = (unsigned short int)0x0c;
        res_reg = (unsigned short int)0x0d;
        fps_reg = (unsigned short int)0x0e;
        hflip_reg = (unsigned short int)0x47;
        break;
      }
      case FREENECT_VIDEO_IR_8BIT:

      case FREENECT_VIDEO_IR_10BIT:

      case FREENECT_VIDEO_IR_10BIT_PACKED:
      {
        if((signed int)dev->video_resolution == FREENECT_RESOLUTION_HIGH)
        {
          if(!(dev->depth.running == 0))
          {
            fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_start_video(): cannot stream high-resolution IR at same time as depth stream\n");
            return -1;
          }

          write_register(dev, (unsigned short int)0x13, (unsigned short int)0x01);
          write_register(dev, (unsigned short int)0x14, (unsigned short int)0x1e);
          write_register(dev, (unsigned short int)0x06, (unsigned short int)0x02);
          write_register(dev, (unsigned short int)0x06, (unsigned short int)0x00);
          mode_value = (unsigned short int)0x00;
          res_value = (unsigned short int)0x02;
          fps_value = (unsigned short int)0x0f;
        }

        else
          if((signed int)dev->video_resolution == FREENECT_RESOLUTION_MEDIUM)
          {
            mode_value = (unsigned short int)0x00;
            res_value = (unsigned short int)0x01;
            fps_value = (unsigned short int)0x1e;
          }

          else
          {
            fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_start_video(): called with invalid format/resolution combination\n");
            return -1;
          }
        mode_reg = (unsigned short int)0x19;
        res_reg = (unsigned short int)0x1a;
        fps_reg = (unsigned short int)0x1b;
        hflip_reg = (unsigned short int)0x48;
        break;
      }
      case FREENECT_VIDEO_YUV_RGB:

      case FREENECT_VIDEO_YUV_RAW:
      {
        if((signed int)dev->video_resolution == FREENECT_RESOLUTION_MEDIUM)
        {
          mode_value = (unsigned short int)0x05;
          res_value = (unsigned short int)0x01;
          fps_value = (unsigned short int)0x0f;
        }

        else
        {
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_start_video(): called with invalid format/resolution combination\n");
          return -1;
        }
        mode_reg = (unsigned short int)0x0c;
        res_reg = (unsigned short int)0x0d;
        fps_reg = (unsigned short int)0x0e;
        hflip_reg = (unsigned short int)0x47;
        break;
      }
      default:
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "freenect_start_video(): called with invalid video format %d\n", dev->video_format);
        return -1;
      }
    }
    struct anonymous_29 frame_mode;
    frame_mode=freenect_get_current_video_mode(dev);
    switch((signed int)dev->video_format)
    {
      case FREENECT_VIDEO_RGB:
      {
        return_value_freenect_find_video_mode_1=freenect_find_video_mode(dev->video_resolution, (enum anonymous_1)FREENECT_VIDEO_BAYER);
        stream_init(ctx, &dev->video, return_value_freenect_find_video_mode_1.bytes, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_BAYER:
      {
        stream_init(ctx, &dev->video, 0, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_IR_8BIT:
      {
        return_value_freenect_find_video_mode_2=freenect_find_video_mode(dev->video_resolution, (enum anonymous_1)FREENECT_VIDEO_IR_10BIT_PACKED);
        stream_init(ctx, &dev->video, return_value_freenect_find_video_mode_2.bytes, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_IR_10BIT:
      {
        return_value_freenect_find_video_mode_3=freenect_find_video_mode(dev->video_resolution, (enum anonymous_1)FREENECT_VIDEO_IR_10BIT_PACKED);
        stream_init(ctx, &dev->video, return_value_freenect_find_video_mode_3.bytes, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_IR_10BIT_PACKED:
      {
        stream_init(ctx, &dev->video, 0, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_YUV_RGB:
      {
        return_value_freenect_find_video_mode_4=freenect_find_video_mode(dev->video_resolution, (enum anonymous_1)FREENECT_VIDEO_YUV_RAW);
        stream_init(ctx, &dev->video, return_value_freenect_find_video_mode_4.bytes, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_YUV_RAW:
      {
        stream_init(ctx, &dev->video, 0, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_DUMMY:
        ;
    }
    const unsigned char video_endpoint = (const unsigned char)0x81;
    signed int packet_size;
    packet_size=fnusb_get_max_iso_packet_size(&dev->usb_cam, video_endpoint, 1920);
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "[Stream 80] Negotiated packet size %d\n", packet_size);
    signed int res;
    res=fnusb_start_iso(&dev->usb_cam, &dev->video_isoc, video_process, video_endpoint, 16, 16, packet_size);
    if(!(res >= 0))
      return res;

    else
    {
      write_register(dev, mode_reg, mode_value);
      write_register(dev, res_reg, res_value);
      write_register(dev, fps_reg, fps_value);
      switch((signed int)dev->video_format)
      {
        case FREENECT_VIDEO_RGB:

        case FREENECT_VIDEO_BAYER:

        case FREENECT_VIDEO_YUV_RGB:

        case FREENECT_VIDEO_YUV_RAW:
        {
          write_register(dev, (unsigned short int)0x05, (unsigned short int)0x01);
          goto __CPROVER_DUMP_L28;
        }
        case FREENECT_VIDEO_IR_8BIT:

        case FREENECT_VIDEO_IR_10BIT:

        case FREENECT_VIDEO_IR_10BIT_PACKED:
        {
          write_register(dev, (unsigned short int)0x105, (unsigned short int)0x00);
          write_register(dev, (unsigned short int)0x05, (unsigned short int)0x03);
        }
        case FREENECT_VIDEO_DUMMY:

        default:
        {

        __CPROVER_DUMP_L28:
          ;
          write_register(dev, hflip_reg, (unsigned short int)0x00);
          dev->video.running = 1;
          return 0;
        }
      }
    }
  }
}

// freenect_stop_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_audio.h line 110
signed int freenect_stop_audio(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  signed int res;
  signed int ret = 0;
  if(dev->audio.running == 0)
    return -1;

  else
  {
    dev->audio.running = 0;
    res=fnusb_stop_iso(&dev->usb_audio, &dev->audio_in_isoc);
    if(!(res >= 0))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "audio: failed to stop isochronous IN stream: %d\n", res);
      return res;
    }

    else
    {
      res=fnusb_stop_iso(&dev->usb_audio, &dev->audio_out_isoc);
      if(!(res >= 0))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "audio: failed to stop isochronous OUT stream: %d\n", res);
        return res;
      }

      else
      {
        if(!(dev->audio.audio_out_ring == ((struct anonymous_14 *)NULL)))
          free((void *)dev->audio.audio_out_ring);

        if(!(dev->audio.cancelled_buffer == ((signed short int *)NULL)))
          free((void *)dev->audio.cancelled_buffer);

        if(!(dev->audio.in_unknown == NULL))
          free(dev->audio.in_unknown);

        signed int i = 0;
        for( ; !(i >= 4); i = i + 1)
        {
          if(!(dev->audio.mic_buffer[(signed long int)i] == ((signed int *)NULL)))
            free((void *)dev->audio.mic_buffer[(signed long int)i]);

          dev->audio.mic_buffer[(signed long int)i] = (signed int *)(void *)0;
        }
        dev->audio.audio_out_ring = (struct anonymous_14 *)(void *)0;
        dev->audio.cancelled_buffer = (signed short int *)(void *)0;
        dev->audio.in_unknown = (void *)0;
        return ret;
      }
    }
  }
}

// freenect_stop_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 474
signed int freenect_stop_depth(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  signed int res;
  if(dev->depth.running == 0)
    return -1;

  else
  {
    dev->depth.running = 0;
    write_register(dev, (unsigned short int)0x06, (unsigned short int)0x00);
    res=fnusb_stop_iso(&dev->usb_cam, &dev->depth_isoc);
    if(!(res >= 0))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to stop depth isochronous stream: %d\n", res);
      return res;
    }

    else
    {
      freenect_destroy_registration(&dev->registration);
      stream_freebufs(ctx, &dev->depth);
      return 0;
    }
  }
}

// freenect_stop_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 483
signed int freenect_stop_video(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  signed int res;
  if(dev->video.running == 0)
    return -1;

  else
  {
    dev->video.running = 0;
    write_register(dev, (unsigned short int)0x05, (unsigned short int)0x00);
    res=fnusb_stop_iso(&dev->usb_cam, &dev->video_isoc);
    if(!(res >= 0))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Failed to stop RGB isochronous stream: %d\n", res);
      return res;
    }

    else
    {
      stream_freebufs(ctx, &dev->video);
      return 0;
    }
  }
}

// freenect_supported_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 128
signed int freenect_supported_subdevices(void)
{
  return FREENECT_DEVICE_MOTOR | FREENECT_DEVICE_CAMERA | FREENECT_DEVICE_AUDIO;
}

// freenect_threadfunc
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 293
void * freenect_threadfunc(void *arg)
{
  freenect_set_depth_callback(f_dev, depth_cb);
  freenect_set_video_callback(f_dev, rgb_cb);
  struct anonymous_29 return_value_freenect_find_video_mode_1;
  return_value_freenect_find_video_mode_1=freenect_find_video_mode((enum anonymous_0)FREENECT_RESOLUTION_MEDIUM, (enum anonymous_1)FREENECT_VIDEO_RGB);
  freenect_set_video_mode(f_dev, return_value_freenect_find_video_mode_1);
  struct anonymous_29 return_value_freenect_find_depth_mode_2;
  return_value_freenect_find_depth_mode_2=freenect_find_depth_mode((enum anonymous_0)FREENECT_RESOLUTION_MEDIUM, (enum anonymous_8)FREENECT_DEPTH_REGISTERED);
  freenect_set_depth_mode(f_dev, return_value_freenect_find_depth_mode_2);
  freenect_set_video_buffer(f_dev, (void *)rgb_back);
  freenect_start_depth(f_dev);
  freenect_start_video(f_dev);
  printf("'w'-tilt up, 's'-level, 'x'-tilt down, '0'-'6'-select LED mode, 'f'-video format\n");
  while(die == 0)
  {
    signed int res;
    res=freenect_process_events(f_ctx);
    if(!(res == -10) && !(res >= 0))
    {
      printf("\nError %d received from libusb - aborting.\n", res);
      break;
    }

  }
  printf("\nshutting down streams...\n");
  freenect_stop_depth(f_dev);
  freenect_stop_video(f_dev);
  freenect_close_device(f_dev);
  freenect_shutdown(f_ctx);
  printf("-- done!\n");
  return (void *)0;
}

// freenect_update_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 155
signed int freenect_update_tilt_state(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  if(!(dev->motor_control_with_audio_enabled == 0))
  {
    signed int return_value_update_tilt_state_alt_1;
    return_value_update_tilt_state_alt_1=update_tilt_state_alt(dev);
    return return_value_update_tilt_state_alt_1;
  }

  if((FREENECT_DEVICE_MOTOR & (signed int)ctx->enabled_subdevices) == 0)
    return 0;

  else
  {
    unsigned char buf[10l];
    unsigned short int ux;
    unsigned short int uy;
    unsigned short int uz;
    signed int ret;
    ret=fnusb_control(&dev->usb_motor, (unsigned char)0xC0, (unsigned char)0x32, (unsigned short int)0x0, (unsigned short int)0x0, buf, (unsigned short int)10);
    if(!(ret == 10))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Error in accelerometer reading, libusb_control_transfer returned %d\n", ret);
      return ret < 0 ? ret : -1;
    }

    else
    {
      ux = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)2] << 8 | (signed int)buf[(signed long int)3]);
      uy = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)4] << 8 | (signed int)buf[(signed long int)5]);
      uz = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)6] << 8 | (signed int)buf[(signed long int)7]);
      dev->raw_state.accelerometer_x = (signed short int)ux;
      dev->raw_state.accelerometer_y = (signed short int)uy;
      dev->raw_state.accelerometer_z = (signed short int)uz;
      dev->raw_state.tilt_angle = (signed char)buf[(signed long int)8];
      dev->raw_state.tilt_status = (enum anonymous_31)buf[(signed long int)9];
      return ret;
    }
  }
}

// get_reply
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 60
signed int get_reply(struct libusb_device_handle *dev, struct _freenect_context *ctx)
{
  unsigned char buffer[512l];
  memset((void *)buffer, 0, (unsigned long int)512);
  signed int transferred = 0;
  signed int res = 0;
  res=libusb_bulk_transfer(dev, (unsigned char)0x81, buffer, 512, &transferred, (unsigned int)100);
  if(!(res == 0))
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "get_reply(): libusb_bulk_transfer failed: %d (transferred = %d)\n", res, transferred);

  else
    if(!(transferred == 12))
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "get_reply(): weird - got %d bytes (expected 12)\n", transferred);

    else
    {
      struct anonymous_20 reply;
      memcpy((void *)&reply, (const void *)buffer, sizeof(struct anonymous_20) /*12ul*/ );
      if(!(reply.magic == 175104000u))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Bad magic: %08X (expected 0A6FE000\n", reply.magic);
        res = -1;
      }

      if(!(reply.status == 0u))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "reply status != 0: failure?\n");
        res = -1;
      }

      tag_next_ack = tag_next_ack + 1;
    }
  return res;
}

// get_reply_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 50
static signed int get_reply_link1(struct anonymous_17 *dev_link1)
{
  struct _freenect_context *ctx = dev_link1->parent->parent;
  unsigned char dump[512l];
  struct anonymous_20 buffer_link1;
  signed int res_link1;
  signed int transferred_link1;
  res_link1=fnusb_bulk(dev_link1, (unsigned char)0x81, dump, 512, &transferred_link1);
  if(!(res_link1 == 0) || !((unsigned long int)transferred_link1 == sizeof(struct anonymous_20) /*12ul*/ ))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Error reading reply: %d\ttransferred: %d (expected %d)\n", res_link1, transferred_link1, (signed int)sizeof(struct anonymous_20) /*12ul*/ );
    return res_link1;
  }

  else
  {
    memcpy((void *)&buffer_link1, (const void *)dump, sizeof(struct anonymous_20) /*12ul*/ );
    if(!(buffer_link1.magic == 175104000u))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Error reading reply: invalid magic %08X\n", buffer_link1.magic);
      return -1;
    }

    else
      if(!(buffer_link1.tag == dev_link1->parent->audio_tag))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Error reading reply: non-matching tag number %08X (expected %08X)\n", buffer_link1.tag, dev_link1->parent->audio_tag);
        return -1;
      }

      else
      {
        if(!(buffer_link1.status == 0u))
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Notice reading reply: last uint32_t was nonzero: %d\n", buffer_link1.status);

        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "Reading reply: ");
        signed int i = 0;
        for( ; !(i >= transferred_link1); i = i + 1)
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "%02X ", ((unsigned char *)&buffer_link1)[(signed long int)i]);
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "\n");
        return res_link1;
      }
  }
}

// gl_threadfunc
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 197
void * gl_threadfunc(void *arg)
{
  printf("GL thread\n");
  glutInit(&g_argc, g_argv);
  glutInitDisplayMode((unsigned int)(0x0000 | 0x0002 | 0x0008 | 0x0010));
  glutInitWindowSize(640, 480);
  glutInitWindowPosition(0, 0);
  window=glutCreateWindow("libfreenect Registration viewer");
  glutDisplayFunc((void (*)(void))DrawGLScene);
  glutIdleFunc((void (*)(void))idle);
  glutReshapeFunc(ReSizeGLScene);
  glutKeyboardFunc(keyPressed);
  InitGL(640, 480);
  glutMainLoop();
  return (void *)0;
}

// idle
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 76
void idle()
{
  pthread_mutex_lock(&gl_backbuf_mutex);
  while(got_depth == 0 && got_rgb == 0)
    pthread_cond_wait(&gl_frame_cond, &gl_backbuf_mutex);
  if(got_depth == 0 || got_rgb == 0)
    pthread_mutex_unlock(&gl_backbuf_mutex);

  else
  {
    pthread_mutex_unlock(&gl_backbuf_mutex);
    glutPostRedisplay();
  }
}

// iso_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 703
static void iso_callback(struct libusb_transfer *xfer)
{
  signed int i;
  struct anonymous_18 *strm = (struct anonymous_18 *)xfer->user_data;
  struct _freenect_context *ctx = strm->parent->parent->parent;
  unsigned char *buf;
  signed int res;
  signed int iso_callback__1__2__4__res;
  if(!(strm->dead == 0))
  {
    strm->dead_xfers = strm->dead_xfers + 1;
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "EP %02x transfer complete, %d left\n", xfer->endpoint, strm->num_xfers - strm->dead_xfers);
  }

  else
    switch((signed int)xfer->status)
    {
      case LIBUSB_TRANSFER_COMPLETED:
      {
        buf = (unsigned char *)xfer->buffer;
        i = 0;
        if(!(i >= strm->pkts))
        {
          strm->cb(strm->parent->parent, buf, (signed int)xfer->iso_packet_desc[(signed long int)i].actual_length);
          buf = buf + (signed long int)strm->len;
          i = i + 1;
        }

        res=libusb_submit_transfer(xfer);
        if(!(res == 0))
        {
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "iso_callback(): failed to resubmit transfer after successful completion: %d\n", res);
          strm->dead_xfers = strm->dead_xfers + 1;
          if(res == -4)
            strm->parent->device_dead = 1;

        }

        break;
      }
      case LIBUSB_TRANSFER_NO_DEVICE:
      {
        if(strm->parent->device_dead == 0)
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "USB device disappeared, cancelling stream %02x :(\n", xfer->endpoint);

        strm->dead_xfers = strm->dead_xfers + 1;
        strm->parent->device_dead = 1;
        break;
      }
      case LIBUSB_TRANSFER_CANCELLED:
      {
        if(!(strm->dead == 0))
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "EP %02x transfer cancelled\n", xfer->endpoint);

        else
        {
          if(strm->parent->device_dead == 0)
            fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Got cancelled transfer, but we didn't request it - device disconnected?\n");

          strm->parent->device_dead = 1;
        }
        strm->dead_xfers = strm->dead_xfers + 1;
        break;
      }
      default:
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "Isochronous transfer error: %d\n", xfer->status);
        iso_callback__1__2__4__res=libusb_submit_transfer(xfer);
        if(!(iso_callback__1__2__4__res == 0))
        {
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Isochronous transfer resubmission failed after unknown error: %d\n", iso_callback__1__2__4__res);
          strm->dead_xfers = strm->dead_xfers + 1;
          if(iso_callback__1__2__4__res == -4)
            strm->parent->device_dead = 1;

        }

      }
    }
}

// iso_in_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 85
static void iso_in_callback(struct _freenect_device *dev, unsigned char *pkt, signed int len)
{
  struct _freenect_context *ctx = dev->parent;
  if(len == 524)
  {
    struct anonymous_21 *block = (struct anonymous_21 *)pkt;
    if(!(block->magic == 0x80000080))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "audio: invalid magic in iso IN packet: %08X\n", block->magic);
      goto __CPROVER_DUMP_L16;
    }

    if(!(block->window == dev->audio.in_window))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "audio: IN window changed: was %04X now %04X\n", dev->audio.in_window, block->window);
      if(!(dev->audio_in_cb == ((void (*)(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *))NULL)))
        dev->audio_in_cb(dev, 256, dev->audio.mic_buffer[(signed long int)0], dev->audio.mic_buffer[(signed long int)1], dev->audio.mic_buffer[(signed long int)2], dev->audio.mic_buffer[(signed long int)3], dev->audio.cancelled_buffer, dev->audio.in_unknown);

      signed int t = 0;
      for( ; !(t >= 10); t = t + 1)
        if(!(dev->audio.last_seen_window[(signed long int)t] == dev->audio.in_window))
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "audio: did not receive data for channel 0x%02x\n", t + 1);

      if((signed int)block->window + -((signed int)dev->audio.in_window) >= 4)
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "audio: packet loss, dropped %d windows\n", (((signed int)block->window - (signed int)dev->audio.in_window) - 3) / 3);

      dev->audio.in_window = block->window;
    }

    switch((signed int)block->channel)
    {
      case 1:
      {
        memcpy((void *)dev->audio.cancelled_buffer, (const void *)&block->samples, (unsigned long int)512);
        break;
      }
      case 2:

      case 3:

      case 4:

      case 5:

      case 6:

      case 7:

      case 8:

      case 9:
      {
        if(!((1 & (signed int)block->channel) == 0))
          memcpy((void *)&dev->audio.mic_buffer[(signed long int)(((signed int)block->channel - 2) / 2)][(signed long int)128], (const void *)&block->samples, (unsigned long int)512);

        else
          memcpy((void *)dev->audio.mic_buffer[(signed long int)(((signed int)block->channel - 2) / 2)], (const void *)&block->samples, (unsigned long int)512);
        break;
      }
      default:
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "audio: invalid channel in iso IN packet: %d\n", block->channel);
    }
    dev->audio.last_seen_window[(signed long int)((signed int)block->channel - 1)] = block->window;
  }

  else
    if(!(len == 60))
    {
      if(!(len == 0))
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "audio: received an iso IN packet of strange length: %d\n", len);

    }


__CPROVER_DUMP_L16:
  ;
}

// iso_out_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 81
static void iso_out_callback(struct _freenect_device *dev, unsigned char *pkt, signed int len)
{
  prepare_iso_out_data(dev, pkt);
}

// keyPressed
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 144
void keyPressed(unsigned char key, signed int x, signed int y)
{
  if((signed int)key == 27 || (signed int)key == 113)
  {
    die = 1;
    pthread_join(freenect_thread, (void **)(void *)0);
    pthread_cond_signal(&gl_frame_cond);
    glutDestroyWindow(window);
    free((void *)depth_mid);
    free((void *)depth_front);
    free((void *)rgb_back);
    free((void *)rgb_mid);
    free((void *)rgb_front);
    exit(0);
  }

}

// libusb_fill_iso_transfer
// file /usr/include/libusb-1.0/libusb.h line 1630
static inline void libusb_fill_iso_transfer(struct libusb_transfer *transfer, struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, signed int length, signed int num_iso_packets, void (*callback)(struct libusb_transfer *), void *user_data, unsigned int timeout)
{
  transfer->dev_handle = dev_handle;
  transfer->endpoint = endpoint;
  transfer->type = (unsigned char)1;
  transfer->timeout = timeout;
  transfer->buffer = buffer;
  transfer->length = length;
  transfer->num_iso_packets = num_iso_packets;
  transfer->user_data = user_data;
  transfer->callback = callback;
}

// libusb_set_iso_packet_lengths
// file /usr/include/libusb-1.0/libusb.h line 1654
static inline void libusb_set_iso_packet_lengths(struct libusb_transfer *transfer, unsigned int length)
{
  signed int i = 0;
  for( ; !(i >= transfer->num_iso_packets); i = i + 1)
    transfer->iso_packet_desc[(signed long int)i].length = length;
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 325
signed int main(signed int argc, char **argv)
{
  signed int res;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(640 * 480 * 4));
  depth_mid = (unsigned char *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(640 * 480 * 4));
  depth_front = (unsigned char *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)(640 * 480 * 3));
  rgb_back = (unsigned char *)return_value_malloc_3;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)(640 * 480 * 3));
  rgb_mid = (unsigned char *)return_value_malloc_4;
  void *return_value_malloc_5;
  return_value_malloc_5=malloc((unsigned long int)(640 * 480 * 3));
  rgb_front = (unsigned char *)return_value_malloc_5;
  printf("Kinect camera test\n");
  signed int i = 0;
  for( ; !(i >= 10000); i = i + 1)
  {
    float v = (float)((double)i / 2048.0);
    float return_value_powf_6;
    return_value_powf_6=powf(v, (float)3);
    v = return_value_powf_6 * (float)6;
    t_gamma[(signed long int)i] = (unsigned short int)(v * (float)6 * (float)256);
  }
  g_argc = argc;
  g_argv = argv;
  signed int return_value_freenect_init_7;
  return_value_freenect_init_7=freenect_init(&f_ctx, (void *)0);
  if(!(return_value_freenect_init_7 >= 0))
  {
    printf("freenect_init() failed\n");
    return 1;
  }

  else
  {
    freenect_set_log_level(f_ctx, (enum anonymous_11)FREENECT_LOG_DEBUG);
    freenect_select_subdevices(f_ctx, (enum anonymous_25)FREENECT_DEVICE_CAMERA);
    signed int nr_devices;
    nr_devices=freenect_num_devices(f_ctx);
    printf("Number of devices found: %d\n", nr_devices);
    signed int user_device_number = 0;
    if(argc >= 2)
      user_device_number=atoi(argv[(signed long int)1]);

    if(!(nr_devices >= 1))
    {
      freenect_shutdown(f_ctx);
      return 1;
    }

    else
    {
      signed int return_value_freenect_open_device_8;
      return_value_freenect_open_device_8=freenect_open_device(f_ctx, &f_dev, user_device_number);
      if(!(return_value_freenect_open_device_8 >= 0))
      {
        printf("Could not open device\n");
        freenect_shutdown(f_ctx);
        return 1;
      }

      else
      {
        res=pthread_create(&freenect_thread, (const union pthread_attr_t *)(void *)0, freenect_threadfunc, (void *)0);
        if(!(res == 0))
        {
          printf("pthread_create failed\n");
          freenect_shutdown(f_ctx);
          return 1;
        }

        else
        {
          gl_threadfunc((void *)0);
          return 0;
        }
      }
    }
  }
}

// prepare_iso_out_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 34
static void prepare_iso_out_data(struct _freenect_device *dev, unsigned char *buffer)
{
  struct anonymous_15 *stream = &dev->audio;
  if(dev->audio_out_cb == ((void (*)(struct _freenect_device *, struct anonymous_14 *, signed int *))NULL))
    memset((void *)buffer, 0, (unsigned long int)76);

  ((unsigned short int *)buffer)[(signed long int)0] = stream->out_window;
  buffer[(signed long int)2] = stream->out_seq;
  if((signed int)stream->out_window_parity == 0)
  {
    if(!((signed int)stream->out_counter_within_window >= 4))
      buffer[(signed long int)3] = (unsigned char)(((signed int)stream->out_weird_timestamp >> (signed int)stream->out_counter_within_window * 4 & 0x000f) << 4 | 0x05);

    else
      if(!((signed int)stream->out_counter_within_window >= 8))
        buffer[(signed long int)3] = (unsigned char)(((signed int)stream->out_weird_timestamp + 23 >> ((signed int)stream->out_counter_within_window - 4) * 4 & 0x000f) << 4 | 0x05);

      else
        buffer[(signed long int)3] = (unsigned char)0x01;
  }

  else
    if(!((signed int)stream->out_counter_within_window >= 4))
      buffer[(signed long int)3] = (unsigned char)(((signed int)stream->out_weird_timestamp >> (signed int)stream->out_counter_within_window * 4 & 0x000f) << 4 | 0x05);

    else
      buffer[(signed long int)3] = (unsigned char)0x01;
  stream->out_seq = stream->out_seq + 1;
  stream->out_counter_within_window = stream->out_counter_within_window + 1;
  stream->out_weird_timestamp = stream->out_weird_timestamp + (unsigned short int)((signed int)stream->out_window_parity == 1 ? 6 : 5);
  switch((signed int)stream->out_seq)
  {
    case 0x80:
      stream->out_seq = (unsigned char)0;
    case 0x2b:

    case 0x56:
    {
      stream->out_counter_within_window = (unsigned char)0;
      stream->out_window = stream->out_window + 1;
      stream->out_window_parity = stream->out_window_parity + 1;
    }
    default:
      if((signed int)stream->out_window_parity == 3)
        stream->out_window_parity = (unsigned char)0;

  }
}

// read_cmos_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 252
unsigned short int read_cmos_register(struct _freenect_device *dev, unsigned short int reg)
{
  struct _freenect_context *ctx = dev->parent;
  unsigned short int replybuf[512l];
  unsigned short int cmdbuf[3l];
  cmdbuf[(signed long int)0] = (unsigned short int)1;
  cmdbuf[(signed long int)1] = (unsigned short int)((signed int)reg & 0x7fff);
  cmdbuf[(signed long int)2] = (unsigned short int)0;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x95, (void *)cmdbuf, (unsigned int)6, (void *)replybuf, 6);
  if(!(res >= 0))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "read_cmos_register: send_cmd() returned %d\n", res);
    return (unsigned short int)65535;
  }

  else
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_DEBUG, "read_cmos_register: 0x%04x => 0x%04x\n", reg, replybuf[(signed long int)2]);
    return replybuf[(signed long int)2];
  }
}

// read_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 209
unsigned short int read_register(struct _freenect_device *dev, unsigned short int reg)
{
  struct _freenect_context *ctx = dev->parent;
  unsigned short int reply[2l];
  unsigned short int cmd = reg;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x02, (void *)&cmd, (unsigned int)2, (void *)reply, 4);
  if(!(res >= 0))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "read_register: send_cmd() failed: %d\n", res);
    return (unsigned short int)65535;
  }

  else
  {
    if(!(res == 4))
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "read_register: send_cmd() returned %d [%04x %04x], 0000 expected\n", res, reply[(signed long int)0], reply[(signed long int)1]);

    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_DEBUG, "read_register: 0x%04x => 0x%04x\n", reg, reply[(signed long int)1]);
    return reply[(signed long int)1];
  }
}

// register_for_flag
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 33
signed int register_for_flag(signed int flag)
{
  switch(flag)
  {
    case FREENECT_MIRROR_DEPTH:
      return 0x17;
    case FREENECT_MIRROR_VIDEO:
      return 0x47;
    default:
      return -1;
  }
}

// rgb_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regview.c line 278
void rgb_cb(struct _freenect_device *dev, void *rgb, unsigned int timestamp)
{
  pthread_mutex_lock(&gl_backbuf_mutex);
  /* assertion rgb_back == rgb */
  assert(rgb_back == (unsigned char *)rgb);
  rgb_back = rgb_mid;
  freenect_set_video_buffer(dev, (void *)rgb_back);
  rgb_mid = (unsigned char *)rgb;
  got_rgb = got_rgb + 1;
  pthread_cond_signal(&gl_frame_cond);
  pthread_mutex_unlock(&gl_backbuf_mutex);
}

// send_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.h line 32
signed int send_cmd(struct _freenect_device *dev, unsigned short int cmd, void *cmdbuf, unsigned int cmd_len, void *replybuf, signed int reply_len)
{
  struct _freenect_context *ctx = dev->parent;
  signed int res;
  signed int actual_len;
  unsigned char obuf[1024l];
  unsigned char ibuf[512l];
  struct anonymous_2 *chdr = (struct anonymous_2 *)obuf;
  struct anonymous_2 *rhdr = (struct anonymous_2 *)ibuf;
  _Bool tmp_if_expr_1;
  if((unsigned long int)cmd_len >= 1017ul || !((1u & cmd_len) == 0u))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "send_cmd: Invalid command length (0x%x)\n", cmd_len);
    return -1;
  }

  else
  {
    chdr->magic[(signed long int)0] = (unsigned char)0x47;
    chdr->magic[(signed long int)1] = (unsigned char)0x4d;
    chdr->cmd = cmd;
    chdr->tag = dev->cam_tag;
    chdr->len = (unsigned short int)(cmd_len / (unsigned int)2);
    memcpy((void *)(obuf + (signed long int)sizeof(struct anonymous_2) /*8ul*/ ), cmdbuf, (unsigned long int)cmd_len);
    res=fnusb_control(&dev->usb_cam, (unsigned char)0x40, (unsigned char)0, (unsigned short int)0, (unsigned short int)0, obuf, (unsigned short int)((unsigned long int)cmd_len + sizeof(struct anonymous_2) /*8ul*/ ));
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "send_cmd: cmd=%04x tag=%04x len=%04x: %d\n", cmd, dev->cam_tag, cmd_len, res);
    if(!(res >= 0))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "send_cmd: Output control transfer failed (%d)\n", res);
      return res;
    }

    else
    {
      do
      {
        actual_len=fnusb_control(&dev->usb_cam, (unsigned char)0xc0, (unsigned char)0, (unsigned short int)0, (unsigned short int)0, ibuf, (unsigned short int)0x200);
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_FLOOD, "send_cmd: actual length = %d\n", actual_len);
      }
      while(actual_len == 0 || actual_len == 0x200);
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Control reply: %d\n", res);
      if(!(actual_len >= (signed int)sizeof(struct anonymous_2) /*8*/ ))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "send_cmd: Input control transfer failed (%d)\n", res);
        return res;
      }

      else
      {
        actual_len = actual_len - (signed int)sizeof(struct anonymous_2) /*8ul*/ ;
        if(!((signed int)rhdr->magic[0l] == 0x52))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (signed int)rhdr->magic[(signed long int)1] != 0x42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "send_cmd: Bad magic %02x %02x\n", rhdr->magic[(signed long int)0], rhdr->magic[(signed long int)1]);
          return -1;
        }

        else
          if(!(rhdr->cmd == chdr->cmd))
          {
            fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "send_cmd: Bad cmd %02x != %02x\n", rhdr->cmd, chdr->cmd);
            return -1;
          }

          else
            if(!(rhdr->tag == chdr->tag))
            {
              fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "send_cmd: Bad tag %04x != %04x\n", rhdr->tag, chdr->tag);
              return -1;
            }

            else
              if(!((signed int)rhdr->len == actual_len / 2))
              {
                fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "send_cmd: Bad len %04x != %04x\n", rhdr->len, (signed int)(actual_len / 2));
                return -1;
              }

              else
              {
                if(!(reply_len >= actual_len))
                {
                  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "send_cmd: Data buffer is %d bytes long, but got %d bytes\n", reply_len, actual_len);
                  memcpy(replybuf, (const void *)(ibuf + (signed long int)sizeof(struct anonymous_2) /*8ul*/ ), (unsigned long int)reply_len);
                }

                else
                  memcpy(replybuf, (const void *)(ibuf + (signed long int)sizeof(struct anonymous_2) /*8ul*/ ), (unsigned long int)actual_len);
                dev->cam_tag = dev->cam_tag + 1;
                return actual_len;
              }
      }
    }
  }
}

// stream_freebufs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 260
static void stream_freebufs(struct _freenect_context *ctx, struct anonymous_28 *strm)
{
  if(!(strm->split_bufs == 0))
    free((void *)strm->raw_buf);

  if(!(strm->lib_buf == NULL))
    free(strm->lib_buf);

  strm->raw_buf = (unsigned char *)(void *)0;
  strm->proc_buf = (void *)0;
  strm->lib_buf = (void *)0;
}

// stream_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 231
static void stream_init(struct _freenect_context *ctx, struct anonymous_28 *strm, signed int rlen, signed int plen)
{
  strm->valid_frames = 0;
  strm->synced = 0;
  if(!(strm->usr_buf == NULL))
  {
    strm->lib_buf = (void *)0;
    strm->proc_buf = strm->usr_buf;
  }

  else
  {
    strm->lib_buf=malloc((unsigned long int)plen);
    strm->proc_buf = strm->lib_buf;
  }
  if(rlen == 0)
  {
    strm->split_bufs = 0;
    strm->raw_buf = (unsigned char *)strm->proc_buf;
    strm->frame_size = plen;
  }

  else
  {
    strm->split_bufs = 1;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)rlen);
    strm->raw_buf = (unsigned char *)return_value_malloc_1;
    strm->frame_size = rlen;
  }
  strm->last_pkt_size = strm->frame_size % strm->pkt_size;
  if(strm->last_pkt_size == 0)
    strm->last_pkt_size = strm->pkt_size;

  strm->pkts_per_frame = ((strm->frame_size + strm->pkt_size) - 1) / strm->pkt_size;
}

// stream_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 87
static signed int stream_process(struct _freenect_context *ctx, struct anonymous_28 *strm, unsigned char *pkt, signed int len, void (*cb)(void *, void *, signed int, signed int, void *), void *user_data)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_3;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  if(!(len >= 12))
    return 0;

  else
  {
    struct pkt_hdr *hdr = (struct pkt_hdr *)pkt;
    unsigned char *data = pkt + (signed long int)sizeof(struct pkt_hdr) /*12ul*/ ;
    signed int datalen = (signed int)((unsigned long int)len - sizeof(struct pkt_hdr) /*12ul*/ );
    enum anonymous_11 l_info = (enum anonymous_11)FREENECT_LOG_INFO;
    enum anonymous_11 l_notice = (enum anonymous_11)FREENECT_LOG_NOTICE;
    enum anonymous_11 l_warning = (enum anonymous_11)FREENECT_LOG_WARNING;
    if(!(strm->valid_frames >= 2))
    {
      l_warning = (enum anonymous_11)FREENECT_LOG_SPEW;
      l_notice = l_warning;
      l_info = l_notice;
    }

    if(!((signed int)hdr->magic[0l] == 82))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)hdr->magic[(signed long int)1] != 66 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      fn_log(ctx, l_notice, "[Stream %02x] Invalid magic %02x%02x\n", strm->flag, hdr->magic[(signed long int)0], hdr->magic[(signed long int)1]);
      return 0;
    }

    else
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_FLOOD, "[Stream %02x] Packet with flag: %02x\n", strm->flag, hdr->flag);
      unsigned char sof = (unsigned char)((signed int)strm->flag | 1);
      unsigned char mof = (unsigned char)((signed int)strm->flag | 2);
      unsigned char eof = (unsigned char)((signed int)strm->flag | 5);
      if(strm->synced == 0)
      {
        if(!(hdr->flag == sof))
        {
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "[Stream %02x] Not synced yet...\n", strm->flag);
          return 0;
        }

        strm->synced = 1;
        strm->seq = hdr->seq;
        strm->pkt_num = 0;
        strm->valid_pkts = 0;
        strm->got_pkts = 0;
      }

      signed int got_frame_size = 0;
      if(!(strm->seq == hdr->seq))
      {
        unsigned char lost = (unsigned char)((signed int)hdr->seq - (signed int)strm->seq);
        strm->lost_pkts = strm->lost_pkts + (unsigned int)lost;
        fn_log(ctx, l_info, "[Stream %02x] Lost %d packets\n", strm->flag, lost);
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_DEBUG, "[Stream %02x] Lost %d total packets in %d frames (%f lppf)\n", strm->flag, strm->lost_pkts, strm->valid_frames, (float)strm->lost_pkts / (float)strm->valid_frames);
        if((signed int)lost >= 6)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = strm->variable_length != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          fn_log(ctx, l_notice, "[Stream %02x] Lost too many packets, resyncing...\n", strm->flag);
          strm->synced = 0;
          return 0;
        }

        strm->seq = hdr->seq;
        signed int left = strm->pkts_per_frame - strm->pkt_num;
        if((signed int)lost >= left)
        {
          strm->pkt_num = (signed int)lost - left;
          strm->valid_pkts = strm->got_pkts;
          strm->got_pkts = 0;
          got_frame_size = strm->frame_size;
          strm->timestamp = strm->last_timestamp;
          strm->valid_frames = strm->valid_frames + 1;
        }

        else
          strm->pkt_num = strm->pkt_num + (signed int)lost;
      }

      signed int expected_pkt_size;
      if(strm->pkt_num == strm->pkts_per_frame + -1)
        tmp_if_expr_3 = strm->last_pkt_size;

      else
        tmp_if_expr_3 = strm->pkt_size;
      expected_pkt_size = tmp_if_expr_3;
      if(strm->variable_length == 0)
      {
        if(strm->pkt_num == 0)
          tmp_if_expr_7 = hdr->flag == sof ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(!tmp_if_expr_7)
        {
          if(strm->pkt_num == strm->pkts_per_frame + -1)
            tmp_if_expr_6 = hdr->flag == eof ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          if(!tmp_if_expr_6)
          {
            if(strm->pkt_num >= 1)
              tmp_if_expr_4 = strm->pkt_num < strm->pkts_per_frame - 1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            if(tmp_if_expr_4)
              tmp_if_expr_5 = hdr->flag == mof ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_5 = (_Bool)0;
            if(!tmp_if_expr_5)
            {
              fn_log(ctx, l_notice, "[Stream %02x] Inconsistent flag %02x with %d packets in buf (%d total), resyncing...\n", strm->flag, hdr->flag, strm->pkt_num, strm->pkts_per_frame);
              strm->synced = 0;
              return got_frame_size;
            }

          }

        }

        if(!(expected_pkt_size >= datalen))
        {
          fn_log(ctx, l_warning, "[Stream %02x] Expected max %d data bytes, but got %d. Dropping...\n", strm->flag, expected_pkt_size, datalen);
          return got_frame_size;
        }

        if(!(datalen >= expected_pkt_size))
          fn_log(ctx, l_warning, "[Stream %02x] Expected %d data bytes, but got %d\n", strm->flag, expected_pkt_size, datalen);

      }

      else
      {
        if(strm->pkt_num == 0)
          tmp_if_expr_10 = hdr->flag == sof ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_10 = (_Bool)0;
        if(!tmp_if_expr_10)
        {
          if(!(strm->pkt_num >= strm->pkts_per_frame))
          {
            if(hdr->flag == eof)
              tmp_if_expr_8 = (_Bool)1;

            else
              tmp_if_expr_8 = hdr->flag == mof ? (_Bool)1 : (_Bool)0;
            tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_9 = (_Bool)0;
          if(!tmp_if_expr_9)
          {
            fn_log(ctx, l_notice, "[Stream %02x] Inconsistent flag %02x with %d packets in buf (%d total), resyncing...\n", strm->flag, hdr->flag, strm->pkt_num, strm->pkts_per_frame);
            strm->synced = 0;
            return got_frame_size;
          }

        }

        if(!(expected_pkt_size >= datalen))
        {
          fn_log(ctx, l_warning, "[Stream %02x] Expected max %d data bytes, but got %d. Resyncng...\n", strm->flag, expected_pkt_size, datalen);
          strm->synced = 0;
          return got_frame_size;
        }

        if(!(datalen >= expected_pkt_size))
        {
          if(!(hdr->flag == eof))
          {
            fn_log(ctx, l_warning, "[Stream %02x] Expected %d data bytes, but got %d. Resyncing...\n", strm->flag, expected_pkt_size, datalen);
            strm->synced = 0;
            return got_frame_size;
          }

        }

      }
      unsigned char *dbuf = strm->raw_buf + (signed long int)(strm->pkt_num * strm->pkt_size);
      if(!(cb == ((void (*)(void *, void *, signed int, signed int, void *))NULL)))
        cb((void *)strm->raw_buf, (void *)data, strm->pkt_num, datalen, user_data);

      else
        memcpy((void *)dbuf, (const void *)data, (unsigned long int)datalen);
      strm->pkt_num = strm->pkt_num + 1;
      strm->seq = strm->seq + 1;
      strm->got_pkts = strm->got_pkts + 1;
      strm->last_timestamp = hdr->timestamp;
      if(hdr->flag == eof)
      {
        if(!(strm->variable_length == 0))
          got_frame_size = (signed int)((dbuf - strm->raw_buf) + (signed long int)datalen);

        else
          got_frame_size = (signed int)((dbuf - strm->raw_buf) + (signed long int)strm->last_pkt_size);
        strm->pkt_num = 0;
        strm->valid_pkts = strm->got_pkts;
        strm->got_pkts = 0;
        strm->timestamp = strm->last_timestamp;
        strm->valid_frames = strm->valid_frames + 1;
      }

      return got_frame_size;
    }
  }
}

// stream_setbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 272
static signed int stream_setbuf(struct _freenect_context *ctx, struct anonymous_28 *strm, void *pbuf)
{
  if(strm->running == 0)
  {
    strm->usr_buf = pbuf;
    return 0;
  }

  else
  {
    if(pbuf == NULL)
    {
      if(strm->lib_buf == NULL)
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Attempted to set buffer to NULL but stream was started with no internal buffer\n");
        return -1;
      }

    }

    strm->usr_buf = pbuf;
    if(pbuf == NULL)
      strm->proc_buf = strm->lib_buf;

    else
      strm->proc_buf = pbuf;
    if(strm->split_bufs == 0)
      strm->raw_buf = (unsigned char *)strm->proc_buf;

    return 0;
  }
}

// unpack_8_pixels
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 77
static inline void unpack_8_pixels(unsigned char *raw, unsigned short int *frame)
{
  unsigned short int baseMask = (unsigned short int)0x7FF;
  unsigned char r0 = raw[(signed long int)0];
  unsigned char r1 = raw[(signed long int)1];
  unsigned char r2 = raw[(signed long int)2];
  unsigned char r3 = raw[(signed long int)3];
  unsigned char r4 = raw[(signed long int)4];
  unsigned char r5 = raw[(signed long int)5];
  unsigned char r6 = raw[(signed long int)6];
  unsigned char r7 = raw[(signed long int)7];
  unsigned char r8 = raw[(signed long int)8];
  unsigned char r9 = raw[(signed long int)9];
  unsigned char r10 = raw[(signed long int)10];
  frame[(signed long int)0] = (unsigned short int)((signed int)r0 << 3 | (signed int)r1 >> 5);
  frame[(signed long int)1] = (unsigned short int)(((signed int)r1 << 6 | (signed int)r2 >> 2) & (signed int)baseMask);
  frame[(signed long int)2] = (unsigned short int)(((signed int)r2 << 9 | (signed int)r3 << 1 | (signed int)r4 >> 7) & (signed int)baseMask);
  frame[(signed long int)3] = (unsigned short int)(((signed int)r4 << 4 | (signed int)r5 >> 4) & (signed int)baseMask);
  frame[(signed long int)4] = (unsigned short int)(((signed int)r5 << 7 | (signed int)r6 >> 1) & (signed int)baseMask);
  frame[(signed long int)5] = (unsigned short int)(((signed int)r6 << 10 | (signed int)r7 << 2 | (signed int)r8 >> 6) & (signed int)baseMask);
  frame[(signed long int)6] = (unsigned short int)(((signed int)r8 << 5 | (signed int)r9 >> 3) & (signed int)baseMask);
  frame[(signed long int)7] = (unsigned short int)(((signed int)r9 << 8 | (signed int)r10) & (signed int)baseMask);
}

// update_tilt_state_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 100
signed int update_tilt_state_alt(struct _freenect_device *dev)
{
  struct _freenect_context *ctx = dev->parent;
  signed int tmp_post_1;
  if(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "Motor control failed: audio device missing");
    return -1;
  }

  else
  {
    signed int transferred = 0;
    signed int res = 0;
    struct anonymous_22 cmd;
    cmd.magic = (unsigned int)0x06022009;
    tmp_post_1 = tag_seq;
    tag_seq = tag_seq + 1;
    cmd.tag = (unsigned int)tmp_post_1;
    cmd.arg1 = (unsigned int)0x68;
    cmd.cmd = (unsigned int)0x8032;
    unsigned char buffer[256l];
    memcpy((void *)buffer, (const void *)&cmd, (unsigned long int)16);
    res=libusb_bulk_transfer(dev->usb_audio.dev, (unsigned char)0x01, buffer, 16, &transferred, (unsigned int)250);
    if(!(res == 0))
      return res;

    else
    {
      res=libusb_bulk_transfer(dev->usb_audio.dev, (unsigned char)0x81, buffer, 256, &transferred, (unsigned int)250);
      if(!(res == 0))
        return res;

      else
      {
        /* tag-#anon#lST[S32'x'||S32'y'||S32'z'||S32'tilt'|] */
struct anonymous_23
{
  // x
  signed int x;
  // y
  signed int y;
  // z
  signed int z;
  // tilt
  signed int tilt;
};

/* */
        ;
        struct anonymous_23 accel_and_tilt;
        memcpy((void *)&accel_and_tilt, (const void *)(buffer + (signed long int)16), sizeof(struct anonymous_23) /*16ul*/ );
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Accelerometer state: X == %d \t Y == %d \t Z == %d \t Tilt == %d\n", accel_and_tilt.x, accel_and_tilt.y, accel_and_tilt.z, accel_and_tilt.tilt);
        dev->raw_state.accelerometer_x = (signed short int)accel_and_tilt.x;
        dev->raw_state.accelerometer_y = (signed short int)accel_and_tilt.y;
        dev->raw_state.accelerometer_z = (signed short int)accel_and_tilt.z;
        dev->raw_state.tilt_angle = (signed char)((signed int)(signed char)accel_and_tilt.tilt * 2);
        signed int return_value_get_reply_2;
        return_value_get_reply_2=get_reply(dev->usb_audio.dev, ctx);
        return return_value_get_reply_2;
      }
    }
  }
}

// upload_cemd_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 341
signed int upload_cemd_data(struct anonymous_17 *dev)
{
  struct _freenect_context *ctx = dev->parent->parent;
  struct anonymous_24 cemdcmd;
  memset((void *)&cemdcmd, 0, sizeof(struct anonymous_24) /*52ul*/ );
  cemdcmd.magic = (unsigned int)0x06022009;
  cemdcmd.tag = dev->parent->audio_tag;
  cemdcmd.arg1 = (unsigned int)0;
  cemdcmd.cmd = (unsigned int)0x00000133;
  cemdcmd.arg2 = (unsigned int)0x00064014;
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "Starting CEMD data upload:\n");
  signed int res;
  signed int transferred;
  res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&cemdcmd, (signed int)sizeof(struct anonymous_24) /*52ul*/ , &transferred);
  if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_24) /*52ul*/ ))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_24) /*52ul*/ );
    return -1;
  }

  else
  {
    res=get_reply_link1(dev);
    dev->parent->audio_tag = dev->parent->audio_tag + 1u;
    const char *cemd_filename = "cemd_data.bin";
    struct _IO_FILE *cf;
    cf=fopen(cemd_filename, "r");
    if(cf == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_cemd_data: Failed to open %s: error %d", cemd_filename, *return_value___errno_location_1);
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      return *return_value___errno_location_2;
    }

    unsigned int addr = (unsigned int)0x00000000;
    signed int read = 0;
    unsigned char page[16384l];
    do
    {
      unsigned long int return_value_fread_3;
      return_value_fread_3=fread((void *)page, (unsigned long int)1, (unsigned long int)0x4000, cf);
      read = (signed int)return_value_fread_3;
      if(!(read >= 1))
        break;

      cemdcmd.tag = dev->parent->audio_tag;
      cemdcmd.arg1 = (unsigned int)read;
      cemdcmd.cmd = (unsigned int)0x134;
      cemdcmd.arg2 = addr;
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "About to send: ");
      dump_cemd_cmd(ctx, cemdcmd);
      res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&cemdcmd, (signed int)sizeof(struct anonymous_24) /*52ul*/ , &transferred);
      if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_24) /*52ul*/ ))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_24) /*52ul*/ );
        return -1;
      }

      signed int bytes_sent = 0;
      while(!(bytes_sent >= read))
      {
        signed int to_send = read - bytes_sent > 512 ? 512 : read - bytes_sent;
        res=fnusb_bulk(dev, (unsigned char)1, &page[(signed long int)bytes_sent], to_send, &transferred);
        if(!(res == 0) || !(transferred == to_send))
        {
          fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, to_send);
          return -1;
        }

        bytes_sent = bytes_sent + to_send;
      }
      res=get_reply_link1(dev);
      addr = addr + (unsigned int)read;
      dev->parent->audio_tag = dev->parent->audio_tag + 1u;
    }
    while(read >= 1);
    fclose(cf);
    cf = (struct _IO_FILE *)(void *)0;
    cemdcmd.tag = dev->parent->audio_tag;
    cemdcmd.arg1 = (unsigned int)0;
    cemdcmd.cmd = (unsigned int)0x135;
    cemdcmd.arg2 = (unsigned int)0x00064000;
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "Finishing CEMD data upload...\n");
    res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&cemdcmd, (signed int)sizeof(struct anonymous_24) /*52ul*/ , &transferred);
    if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_24) /*52ul*/ ))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_cemd_data(): Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_24) /*52ul*/ );
      return -1;
    }

    else
    {
      res=get_reply_link1(dev);
      dev->parent->audio_tag = dev->parent->audio_tag + 1u;
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "CEMD data uploaded successfully.\n");
      return 0;
    }
  }
}

// upload_firmware
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 68
signed int upload_firmware(struct anonymous_17 *dev, char *filename)
{
  struct _freenect_context *ctx = dev->parent->parent;
  char fw_filename[1024l];
  sprintf(fw_filename, "/%s", filename);
  signed int filenamelen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(fw_filename);
  filenamelen = (signed int)return_value_strlen_1;
  signed int i;
  signed int searchpathcount;
  struct _IO_FILE *fw = (struct _IO_FILE *)(void *)0;
  i = 0;
  searchpathcount = 6;
  void *return_value_malloc_4;
  void *return_value_malloc_8;
  void *return_value_malloc_9;
  void *return_value_malloc_10;
  for( ; fw == ((struct _IO_FILE *)NULL) && !(i >= searchpathcount); i = i + 1)
  {
    char *fwfile;
    signed int needs_free = 0;
    switch(i)
    {
      case 0:
      {
        char *envpath;
        envpath=getenv("LIBFREENECT_FIRMWARE_PATH");
        if(envpath == ((char *)NULL))
          goto __CPROVER_DUMP_L13;

        signed int pathlen;
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(envpath);
        pathlen = (signed int)return_value_strlen_2;
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)(pathlen + filenamelen + 1));
        fwfile = (char *)return_value_malloc_3;
        strcpy(fwfile, envpath);
        strcat(fwfile, fw_filename);
        needs_free = 1;
        break;
      }
      case 1:
      {
        return_value_malloc_4=malloc((unsigned long int)2048);
        fwfile = (char *)return_value_malloc_4;
        needs_free = 1;
        sprintf(fwfile, ".%s", (const void *)fw_filename);
        break;
      }
      case 2:
      {
        char *home;
        home=getenv("HOME");
        if(home == ((char *)NULL))
          goto __CPROVER_DUMP_L13;

        signed int homelen;
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(home);
        homelen = (signed int)return_value_strlen_5;
        char *dotfolder = "/.libfreenect";
        signed int locallen;
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(dotfolder);
        locallen = (signed int)return_value_strlen_6;
        void *return_value_malloc_7;
        return_value_malloc_7=malloc((unsigned long int)(homelen + locallen + filenamelen + 1));
        fwfile = (char *)return_value_malloc_7;
        strcpy(fwfile, home);
        strcat(fwfile, dotfolder);
        strcat(fwfile, fw_filename);
        needs_free = 1;
        break;
      }
      case 3:
      {
        return_value_malloc_8=malloc((unsigned long int)2048);
        fwfile = (char *)return_value_malloc_8;
        needs_free = 1;
        sprintf(fwfile, "/usr/local/share/libfreenect%s", (const void *)fw_filename);
        break;
      }
      case 4:
      {
        return_value_malloc_9=malloc((unsigned long int)2048);
        fwfile = (char *)return_value_malloc_9;
        needs_free = 1;
        sprintf(fwfile, "/usr/share/libfreenect%s", (const void *)fw_filename);
        break;
      }
      case 5:
      {
        return_value_malloc_10=malloc((unsigned long int)2048);
        fwfile = (char *)return_value_malloc_10;
        needs_free = 1;
        sprintf(fwfile, "./../Resources%s", (const void *)fw_filename);
        break;
      }
      default:
        ;
    }
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "Trying to open %s as firmware...\n", fwfile);
    fw=fopen(fwfile, "rb");
    if(!(needs_free == 0))
      free((void *)fwfile);


  __CPROVER_DUMP_L13:
    ;
  }
  if(fw == ((struct _IO_FILE *)NULL))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_firmware: failed to find firmware file.\n");
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    return -(*return_value___errno_location_11);
  }

  fseek(fw, (signed long int)0, 2);
  signed int fw_num_bytes;
  signed long int return_value_ftell_12;
  return_value_ftell_12=ftell(fw);
  fw_num_bytes = (signed int)return_value_ftell_12;
  rewind(fw);
  if(!(fw_num_bytes >= 1))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_firmware: failed to find file with any data.\n");
    signed int *return_value___errno_location_13;
    return_value___errno_location_13=__errno_location();
    return -(*return_value___errno_location_13);
  }

  unsigned char *fw_bytes;
  void *return_value_malloc_14;
  return_value_malloc_14=malloc((unsigned long int)fw_num_bytes);
  fw_bytes = (unsigned char *)return_value_malloc_14;
  signed int numRead;
  unsigned long int return_value_fread_15;
  return_value_fread_15=fread((void *)fw_bytes, (unsigned long int)1, (unsigned long int)fw_num_bytes, fw);
  numRead = (signed int)return_value_fread_15;
  fw_num_bytes = numRead;
  signed int retVal;
  retVal=upload_firmware_from_memory(dev, fw_bytes, (unsigned int)fw_num_bytes);
  fclose(fw);
  fw = (struct _IO_FILE *)(void *)0;
  return retVal;
}

// upload_firmware_from_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 69
signed int upload_firmware_from_memory(struct anonymous_17 *dev, unsigned char *fw_from_mem, unsigned int fw_size_in_btyes)
{
  struct _freenect_context *ctx = dev->parent->parent;
  struct anonymous_26 bootcmd;
  memset((void *)&bootcmd, 0, sizeof(struct anonymous_26) /*24ul*/ );
  bootcmd.magic = (unsigned int)0x06022009;
  signed int res;
  signed int transferred;
  struct anonymous_27 fwheader;
  signed int read = 0;
  signed int bytesLeft = (signed int)fw_size_in_btyes;
  unsigned char *readPtr = &fw_from_mem[(signed long int)0];
  if(!((unsigned long int)fw_size_in_btyes >= sizeof(struct anonymous_27) /*24ul*/ ))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_firmware: firmware image too small, has no header?\n");
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    return -(*return_value___errno_location_1);
  }

  memcpy((void *)&fwheader, (const void *)readPtr, sizeof(struct anonymous_27) /*24ul*/ );
  fwheader.magic = fwheader.magic;
  fwheader.ver_major = fwheader.ver_major;
  fwheader.ver_minor = fwheader.ver_minor;
  fwheader.ver_release = fwheader.ver_release;
  fwheader.ver_patch = fwheader.ver_patch;
  fwheader.base_addr = fwheader.base_addr;
  fwheader.size = fwheader.size;
  fwheader.entry_addr = fwheader.entry_addr;
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "Found firmware image:\n");
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "\tmagic        %08X\n", fwheader.magic);
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "\tversion      %02d.%02d.%02d.%02d\n", fwheader.ver_major, fwheader.ver_minor, fwheader.ver_release, fwheader.ver_patch);
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "\tbase address 0x%08x\n", fwheader.base_addr);
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "\tsize         0x%08x\n", fwheader.size);
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "\tentry point  0x%08x\n", fwheader.entry_addr);
  unsigned int addr = fwheader.base_addr;
  unsigned char page[16384l];
  signed int readIndex = 0;
  signed int total_bytes_sent = 0;
  do
  {
    read = (signed int)((unsigned int)0x4000 > fwheader.size - (unsigned int)total_bytes_sent ? fwheader.size - (unsigned int)total_bytes_sent : (unsigned int)0x4000);
    if(!(bytesLeft >= read))
      read = bytesLeft;

    if(!(read >= 1))
      break;

    memcpy((void *)page, (const void *)&readPtr[(signed long int)readIndex], (unsigned long int)read);
    readIndex = readIndex + read;
    bytesLeft = bytesLeft - read;
    bootcmd.tag = dev->parent->audio_tag;
    bootcmd.bytes = (unsigned int)read;
    bootcmd.cmd = (unsigned int)0x03;
    bootcmd.addr = addr;
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "About to send: ");
    dump_bl_cmd(ctx, bootcmd);
    res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&bootcmd, (signed int)sizeof(struct anonymous_26) /*24ul*/ , &transferred);
    if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_26) /*24ul*/ ))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_firmware(): Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_26) /*24ul*/ );
      return -1;
    }

    signed int bytes_sent = 0;
    while(!(bytes_sent >= read))
    {
      signed int to_send = read - bytes_sent > 512 ? 512 : read - bytes_sent;
      res=fnusb_bulk(dev, (unsigned char)1, &page[(signed long int)bytes_sent], to_send, &transferred);
      if(!(res == 0) || !(transferred == to_send))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_firmware(): Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, to_send);
        return -1;
      }

      bytes_sent = bytes_sent + to_send;
      total_bytes_sent = total_bytes_sent + to_send;
    }
    res=get_reply_link1(dev);
    addr = addr + (unsigned int)read;
    dev->parent->audio_tag = dev->parent->audio_tag + 1u;
  }
  while(read >= 1);
  if(!((unsigned int)total_bytes_sent == fwheader.size))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_firmware: firmware image declared %d bytes, but file only contained %d bytes\n", fwheader.size, total_bytes_sent);
    return -1;
  }

  else
  {
    bootcmd.tag = dev->parent->audio_tag;
    bootcmd.bytes = (unsigned int)0;
    bootcmd.cmd = (unsigned int)0x04;
    bootcmd.addr = fwheader.entry_addr;
    dump_bl_cmd(ctx, bootcmd);
    res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&bootcmd, (signed int)sizeof(struct anonymous_26) /*24ul*/ , &transferred);
    if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_26) /*24ul*/ ))
    {
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "upload_firmware(): Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_26) /*24ul*/ );
      return -1;
    }

    else
    {
      res=get_reply_link1(dev);
      dev->parent->audio_tag = dev->parent->audio_tag + 1u;
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_INFO, "Firmware successfully uploaded and launched.  Device will disconnect and reenumerate.\n");
      return 0;
    }
  }
}

// video_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 617
static void video_process(struct _freenect_device *dev, unsigned char *pkt, signed int len)
{
  struct _freenect_context *ctx = dev->parent;
  if(!(len == 0))
  {
    if(!(dev->video.running == 0))
    {
      signed int got_frame_size;
      got_frame_size=stream_process(ctx, &dev->video, pkt, len, dev->video_chunk_cb, dev->user_data);
      if(!(got_frame_size == 0))
      {
        fn_log(ctx, (enum anonymous_11)FREENECT_LOG_SPEW, "Got video frame of size %d/%d, %d/%d packets arrived, TS %08x\n", got_frame_size, dev->video.frame_size, dev->video.valid_pkts, dev->video.pkts_per_frame, dev->video.timestamp);
        struct anonymous_29 frame_mode;
        frame_mode=freenect_get_current_video_mode(dev);
        switch((signed int)dev->video_format)
        {
          case FREENECT_VIDEO_RGB:
          {
            convert_bayer_to_rgb(dev->video.raw_buf, (unsigned char *)dev->video.proc_buf, frame_mode);
            break;
          }
          case FREENECT_VIDEO_BAYER:
            break;
          case FREENECT_VIDEO_IR_10BIT:
          {
            convert_packed_to_16bit(dev->video.raw_buf, (unsigned short int *)dev->video.proc_buf, 10, (signed int)frame_mode.width * (signed int)frame_mode.height);
            break;
          }
          case FREENECT_VIDEO_IR_10BIT_PACKED:
            break;
          case FREENECT_VIDEO_IR_8BIT:
          {
            convert_packed_to_8bit(dev->video.raw_buf, (unsigned char *)dev->video.proc_buf, 10, (signed int)frame_mode.width * (signed int)frame_mode.height);
            break;
          }
          case FREENECT_VIDEO_YUV_RGB:
          {
            convert_uyvy_to_rgb(dev->video.raw_buf, (unsigned char *)dev->video.proc_buf, frame_mode);
            break;
          }
          case FREENECT_VIDEO_YUV_RAW:
            break;
          default:
            fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "video_process() was called, but an invalid video_format is set\n");
        }
        if(!(dev->video_cb == ((void (*)(struct _freenect_device *, void *, unsigned int))NULL)))
          dev->video_cb(dev, dev->video.proc_buf, dev->video.timestamp);

      }

    }

  }

}

// write_cmos_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 273
signed int write_cmos_register(struct _freenect_device *dev, unsigned short int reg, unsigned short int value)
{
  struct _freenect_context *ctx = dev->parent;
  unsigned short int replybuf[512l];
  unsigned short int cmdbuf[3l];
  cmdbuf[(signed long int)0] = (unsigned short int)1;
  cmdbuf[(signed long int)1] = (unsigned short int)((signed int)reg | 0x8000);
  cmdbuf[(signed long int)2] = value;
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_DEBUG, "write_cmos_register: 0x%04x <= 0x%04x\n", reg, value);
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x95, (void *)cmdbuf, (unsigned int)6, (void *)replybuf, 6);
  if(!(res >= 0))
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "write_cmos_register: send_cmd() returned %d\n", res);

  return res;
}

// write_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.h line 36
signed int write_register(struct _freenect_device *dev, unsigned short int reg, unsigned short int data)
{
  struct _freenect_context *ctx = dev->parent;
  unsigned short int reply[2l];
  unsigned short int cmd[2l];
  cmd[(signed long int)0] = reg;
  cmd[(signed long int)1] = data;
  fn_log(ctx, (enum anonymous_11)FREENECT_LOG_DEBUG, "write_register: 0x%04x <= 0x%02x\n", reg, data);
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x03, (void *)cmd, (unsigned int)4, (void *)reply, 4);
  if(!(res >= 0))
  {
    fn_log(ctx, (enum anonymous_11)FREENECT_LOG_ERROR, "write_register: send_cmd() returned %d\n", res);
    return res;
  }

  else
  {
    if(!(res == 2))
      fn_log(ctx, (enum anonymous_11)FREENECT_LOG_WARNING, "write_register: send_cmd() returned %d [%04x %04x], 0000 expected\n", res, reply[(signed long int)0], reply[(signed long int)1]);

    return 0;
  }
}

